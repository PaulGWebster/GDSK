, tmp)^(x+(((-1258213460.041857)<<(tmp = 302017800.72064054, tmp))|((((tmp = -624254210, tmp)^((-338165065.97507)|((623392964)-x)))>>>x)%(tmp = 2767629843.0643625, tmp)))))))));
  assertEquals(0, x >>>= x);
  assertEquals(0, x >>>= x);
  assertEquals(0, x |= ((-2001549164.1988192)*x));
  assertEquals(0, x -= x);
  assertEquals(0, x *= (((((165836842.14390492)*(tmp = -3220002961, tmp))|(-2840620221.747431))%((x/(tmp = 3153915610, tmp))>>>(tmp = 2018941558, tmp)))>>>x));
  assertEquals(-0, x *= (-231994402.93764925));
  assertEquals(0, x <<= x);
  assertEquals(0, x %= (tmp = 2702385056.1149964, tmp));
  assertEquals(0, x <<= (tmp = 378459323, tmp));
  assertEquals(0, x >>>= ((x&(x&(((-1014963013)<<(x&((tmp = -3110294840, tmp)|(x+(x<<(1129643420))))))+(1093795819.1853619))))+((((tmp = -2295103369.697398, tmp)&(((370501313.43019223)>>>(2465439579))/x))-x)>>x)));
  assertEquals(0, x /= ((tmp = 1779625847, tmp)+(tmp = -662459654.6908865, tmp)));
  assertEquals(0, x -= x);
  assertEquals(0, x %= ((tmp = 2723291421, tmp)|(277246502.4027958)));
  assertEquals(0, x ^= (((-2936270162)>>>((((tmp = -2019015609.1648235, tmp)|(47218153))*(-823685284))+x))&(x<<(x*(x|(((tmp = -941955398, tmp)^(tmp = -2365238993.5300865, tmp))-(778674685)))))));
  assertEquals(0, x >>>= x);
  assertEquals(NaN, x %= x);
  assertEquals(0, x &= (-175235975.8858137));
  assertEquals(-2684493800.1062117, x += (tmp = -2684493800.1062117, tmp));
  assertEquals(-1290806265.6063132, x -= (-1393687534.4998984));
  assertEquals(-1290806265, x >>= (((x>>(tmp = -1710112056.4935386, tmp))*(586227650.2860553))<<(tmp = -2918251533.6052856, tmp)));
  assertEquals(23470008, x >>>= x);
  assertEquals(1668734969, x |= ((-295560682.9663689)^(x|((((tmp = -1183847364, tmp)&(3135327694))+(1679127747.1406744))-((-1895825528)%((tmp = -3180115006, tmp)+((tmp = 2373812187, tmp)|x)))))));
  assertEquals(1744306169, x |= (1188503928.5009093));
  assertEquals(1744306169, x %= (tmp = -2723982401.4997177, tmp));
  assertEquals(3488612338, x += x);
  assertEquals(3488612337, x += (((x/(-325849204))>>x)|(-1820624550.9149108)));
  assertEquals(-1511119305, x ^= (tmp = 1778506182.2952862, tmp));
  assertEquals(-12211415, x %= (x^(tmp = -54943035, tmp)));
  assertEquals(-12211415, x %= ((-1267051884)%(-643566443.0122576)));
  assertEquals(-30.84976063258681, x /= (((1052047194)>>>x)&(1495698235.5117269)));
  assertEquals(-61.69952126517362, x += x);
  assertEquals(-244, x <<= (x^(x+(tmp = -2822258210.076373, tmp))));
  assertEquals(-6652, x &= ((tmp = 2593685093, tmp)>>((((2047688852.4609032)<<((x*(-611076291))*x))^(-2665364024.817528))>>>(165267874))));
  assertEquals(0, x -= x);
  assertEquals(0, x /= (2454186758));
  assertEquals(0, x &= (tmp = -2226895206, tmp));
  assertEquals(0, x += x);
  assertEquals(-21390701, x += ((-1369004846.0816503)>>(tmp = -2661552634.039692, tmp)));
  assertEquals(-0.012568536912921919, x /= (1701924507.856429));
  assertEquals(7.09517966608176e-11, x /= (tmp = -177141911.8955555, tmp));
  assertEquals(0, x >>= (tmp = 231535697, tmp));
  assertEquals(1383687797, x ^= (tmp = -2911279499.568808, tmp));
  assertEquals(1383687797, x %= (tmp = -2258636646.5294995, tmp));
  assertEquals(1319, x >>= ((tmp = -2549411892.8426056, tmp)/(((((1532476676)^(153720871.82640445))+x)/(((2988190456.3206205)&(tmp = -2920873674, tmp))-(((((tmp = -1044518167.0581458, tmp)>>x)-((((tmp = -194701879.13505793, tmp)&(498352051))&((tmp = -2167339635.6529818, tmp)^(((x>>(tmp = 700159851, tmp))*(tmp = 2874921158, tmp))/x)))-((2856128689)|((-1876321441)>>>(2110732915)))))^((((tmp = -193379494.18825436, tmp)/(-3055182489.533142))<<x)+((tmp = -2286109605, tmp)>>(tmp = 698475484.3987849, tmp))))^(3182231653.500364))))|(((tmp = -194670835, tmp)>>>((786780139)%(((2114171416.2305853)^(1703145352.8143656))/x)))>>>((tmp = -3029462067, tmp)>>((67647572.02624655)&(x*(-2394283060))))))));
  assertEquals(13903855, x |= ((tmp = -2515306586, tmp)>>>x));
  assertEquals(54311, x >>>= ((-2413722658)-((tmp = -2159787584, tmp)^(tmp = 949937622.9744623, tmp))));
  assertEquals(108622, x += x);
  assertEquals(1250717187, x ^= ((tmp = 842692148, tmp)+(((2649331689.694273)<<x)-(tmp = -2992181273, tmp))));
  assertEquals(4536777, x %= (tmp = 73304730, tmp));
  assertEquals(0, x -= x);
  assertEquals(-580081499, x ^= ((tmp = -580081499.0170684, tmp)^(x%(tmp = -1542730817.88261, tmp))));
  assertEquals(-1382738784, x <<= x);
  assertEquals(-1382738784, x <<= x);
  assertEquals(2912228512, x >>>= (x*(x>>>x)));
  assertEquals(-1076374105, x |= (2589443367));
  assertEquals(-0.2818750938197037, x /= (((tmp = -1559525732.9603848, tmp)|(-477068917.5483327))>>>((-688616257)*((((tmp = -1192490153.1226473, tmp)*(-502280624.0265591))<<(-442688727.4881985))%(x+(((((tmp = -2948836853.831935, tmp)-(tmp = -2850398330.910424, tmp))>>>(x>>>(-1947835558)))^x)+(x*x)))))));
  assertEquals(2032826546, x |= (tmp = 2032826546.819327, tmp));
  assertEquals(3408404827.14316, x += (tmp = 1375578281.1431599, tmp));
  assertEquals(258183922.14315987, x %= (tmp = 350024545, tmp));
  assertEquals(479694848, x <<= (tmp = -481187157, tmp));
  assertEquals(-2147483648, x <<= (((tmp = -2956588045.472398, tmp)>>>(((tmp = -1838455399.1775856, tmp)&(((((tmp = -637547, tmp)/x)&(x^((-44876328.1767962)+(((-2059598286)-(1071496688))%(tmp = -1492254402, tmp)))))-(x%x))*(x|x)))>>(1226250760)))<<x));
  assertEquals(-2288163338.9020815, x -= (140679690.9020816));
  assertEquals(4954833118513997000, x *= (-2165419327.4906025));
  assertEquals(1578331238, x ^= (-2410854298.2270393));
  assertEquals(-810627292, x += (-2388958530));
  assertEquals(-810627292, x ^= ((1495296640.4087524)/(tmp = 1561790291, tmp)));
  assertEquals(657116606535253200, x *= x);
  assertEquals(0.675840332689047, x %= (((-1816548473)^(((tmp = -151918689.19451094, tmp)|(1819911186.535233))/((((((1514297447)+(tmp = 856485190.9684253, tmp))&(((1809369464.4363992)<<(493538496))*x))+((x*(x>>(x&(tmp = 222293461, tmp))))>>>(((784519621)|x)^((-580766922)>>(tmp = -947264116, tmp)))))>>>((((2794210354.22964)>>>(((2896952532.0183973)*((x+(tmp = -1813175940, tmp))<<(tmp = -1302618293, tmp)))&x))>>(x-(((x|((1456466890.1952953)*x))^(-169979758.19158387))-(x-x))))>>x))&(tmp = 2671604078.3026733, tmp))))/(-1701675745)));
  assertEquals(0.675840332689047, x %= ((tmp = 2421871143, tmp)^x));
  assertEquals(NaN, x %= ((((tmp = 1175526323.433271, tmp)+(tmp = 2813009575.952405, tmp))%((tmp = -3112133516.3303423, tmp)&x))&((((((-424329392)^(tmp = 1430146361, tmp))+x)-(1533557337.268306))%((tmp = -3117619446, tmp)-(-3127129232)))>>>x)));
  assertEquals(NaN, x += x);
  assertEquals(0, x >>>= ((1710641057.7325037)%(104961723.56541145)));
  assertEquals(0, x <<= (tmp = -970072906, tmp));
  assertEquals(0, x *= (87768668));
  assertEquals(-1464968122, x ^= (tmp = -1464968122, tmp));
  assertEquals(-1467983895, x ^= ((tmp = -1204896021, tmp)>>>(((91792661)&(x>>>(((-2364345606)>>>x)*x)))+x)));
  assertEquals(2.991581508270506, x /= (-490704963.5591147));
  assertEquals(0, x >>>= x);
  assertEquals(0, x >>= ((tmp = 639854873, tmp)%(tmp = 743486160.3597239, tmp)));
  assertEquals(0, x <<= (tmp = 1045577245.3403939, tmp));
  assertEquals(0, x >>= ((tmp = -1932462290, tmp)|(tmp = 1629217987, tmp)));
  assertEquals(517617438, x ^= ((tmp = 2737789043, tmp)%(tmp = -2220171604.135681, tmp)));
  assertEquals(126371, x >>>= ((tmp = 205210223.69909227, tmp)-(tmp = 598118404, tmp)));
  assertEquals(918548455, x |= ((918228734.8363427)+(x+x)));
  assertEquals(918548455, x |= ((tmp = 599828198, tmp)>>((tmp = -851081330, tmp)|(tmp = -1152596996.8443217, tmp))));
  assertEquals(918548443.7739062, x -= ((tmp = 1497642976.2260938, tmp)%(x>>(tmp = -548469702.5849569, tmp))));
  assertEquals(0.7739062309265137, x %= (x&x));
  assertEquals(2317939163.8239403, x *= (tmp = 2995116296, tmp));
  assertEquals(1014415360, x <<= (-279972114));
  assertEquals(0, x &= ((296810932)/(x*(tmp = -2750499950, tmp))));
  assertEquals(0, x *= (x%((126285451.05086231)>>>(x*(tmp = -2789790532, tmp)))));
  assertEquals(0, x >>>= ((975695102.5771483)%(x-((-1011726540)-((tmp = 2223194882, tmp)/x)))));
  assertEquals(-1747794584, x |= (-1747794584.3839395));
  assertEquals(-543544679, x %= (tmp = -1204249905, tmp));
  assertEquals(-543544679, x %= (-881024001));
  assertEquals(1, x /= x);
  assertEquals(-1879376393, x |= ((tmp = 161643764, tmp)|(tmp = 2281346499.9084272, tmp)));
  assertEquals(1.321124264431369, x /= (-1422558379.7061746));
  assertEquals(1, x >>>= (x&(tmp = -963118950.4710281, tmp)));
  assertEquals(3, x ^= ((x+x)/x));
  assertEquals(1, x /= x);
  assertEquals(1, x &= (2090796073));
  assertEquals(-1284301873, x ^= (((-11041168.146357536)+(tmp = -1273260707.8134556, tmp))+x));
  assertEquals(292559045, x &= (x&((-2401110739)^((tmp = 630802904, tmp)^(((1012634447.0346229)+x)%((tmp = -1240091095, tmp)%(x/(-1483936527))))))));
  assertEquals(0, x %= x);
  assertEquals(0, x /= (tmp = 613145428.3653506, tmp));
  assertEquals(0, x /= ((x-(tmp = 3116638456, tmp))*(-973300716)));
  assertEquals(0, x %= (tmp = -1794741286.0464535, tmp));
  assertEquals(0, x &= x);
  assertEquals(0, x >>= (-551370105.0746605));
  assertEquals(-1471996874, x ^= ((2822970422.2331414)-x));
  assertEquals(-277914313, x |= (tmp = -818980601.2544096, tmp));
  assertEquals(-34, x >>= x);
  assertEquals(305422768, x -= (-305422802));
  assertEquals(-2406146240, x += (tmp = -2711569008, tmp));
  assertEquals(1073745408, x &= (tmp = -3046625618, tmp));
  assertEquals(1073745408, x <<= ((-1234108306.7646303)<<((-233519302)|x)));
  assertEquals(1073745408, x %= (tmp = 1898831268, tmp));
  assertEquals(1073745408, x <<= (((tmp = 3089406038, tmp)/x)&(-2960027680)));
  assertEquals(65536, x >>>= (2858188366));
  assertEquals(128, x >>>= ((-2640257239.857275)%((tmp = -3185405235.3177376, tmp)*x)));
  assertEquals(128, x >>>= x);
  assertEquals(128, x -= (x&(x-(tmp = -247588018, tmp))));
  assertEquals(81616906825.07776, x *= (tmp = 637632084.57092, tmp));
  assertEquals(78860097686.07776, x -= (((1507215684)^((709254783)+(((x<<x)*((-2890828152.667641)%(2537817529.2041526)))^x)))+(3114024487)));
  assertEquals(-2920545695.721283, x += (((tmp = -2555437435, tmp)>>>x)-((2920546109.72129)+x)));
  assertEquals(-2879412281.721283, x += ((-1662428756)>>>(tmp = -1928491386.6926208, tmp)));
  assertEquals(67403845, x &= (tmp = 2921644117, tmp));
  assertEquals(16850961, x >>>= (((-1039328365)>>>(tmp = -768615112, tmp))<<((1037261855)*(tmp = -2906902831.4797926, tmp))));
  assertEquals(0, x ^= x);
  assertEquals(0, x *= ((-2729056530)/((-1776175111)%(1493002300.4604707))));
  assertEquals(0, x *= (tmp = 370696035.22912216, tmp));
  assertEquals(0, x ^= x);
  assertEquals(0, x |= ((((((tmp = -1541196993, tmp)^x)/(854730380.1799632))/(2879117705.492209))+((((-2892068577)^(-2460614446.1044483))>>>((743413943)<<(-1285280084.4220598)))/(tmp = -1719994579.5141463, tmp)))%(((((tmp = 2522797851.088227, tmp)<<(tmp = 2257160597.1538725, tmp))/(-680406007))&((x>>>(tmp = -260350730, tmp))^(tmp = 1920522110.852598, tmp)))>>(-697620442))));
  assertEquals(0, x &= x);
  assertEquals(-591399642.958673, x += (x-(tmp = 591399642.958673, tmp)));
  assertEquals(27, x >>>= (tmp = -726721317.2109983, tmp));
  assertEquals(-2043736843, x -= (2043736870));
  assertEquals(-3991674, x >>= (tmp = 1098126089, tmp));
  assertEquals(-997919, x >>= ((x%(((x*(((-1497329257.1781685)%(2334511329.2690516))/(-3072526140.6635056)))+(-1843998852))-(tmp = 240300314.34070587, tmp)))+(714080860.6032693)));
  assertEquals(-0, x %= x);
  assertEquals(NaN, x /= x);
  assertEquals(0, x >>= (tmp = 538348328.5363884, tmp));
  assertEquals(0, x *= (800317515));
  assertEquals(0, x -= x);
  assertEquals(0, x >>= (984205514));
  assertEquals(857282491, x += (tmp = 857282491, tmp));
  assertEquals(587792897, x &= (tmp = 2951307845.164059, tmp));
  assertEquals(595301269, x |= (tmp = 24285588.90314555, tmp));
  assertEquals(1190602538, x += x);
  assertEquals(0, x -= x);
  assertEquals(-442423060, x |= ((x^((x-(tmp = 2342497475.637024, tmp))%(-1900074414.7678084)))|((tmp = 1932380130, tmp)%(x%(2291727569.817062)))));
  assertEquals(-442423060, x %= (((tmp = 703479475.545413, tmp)>>(x-x))<<(2435723056.753845)));
  assertEquals(1, x /= x);
  assertEquals(0, x >>= x);
  assertEquals(-1265317851, x |= (tmp = -1265317851, tmp));
  assertEquals(-2, x >>= (-2015895906.8256726));
  assertEquals(-0, x %= x);
  assertEquals(-0, x %= (((1219237746)+(284683029))*(((tmp = 2288119628, tmp)|(-404658161.2563329))*(-265228691.74142504))));
  assertEquals(1039509109, x -= (-1039509109));
  assertEquals(2079018218, x += x);
  assertEquals(-1979.9362673719077, x /= ((3219723500)>>x));
  assertEquals(-62, x >>= ((x/(326466691))*(tmp = -607654070, tmp)));
  assertEquals(-45, x |= (tmp = -2954888429.549882, tmp));
  assertEquals(-1180929712, x &= (3114037588.570232));
  assertEquals(815550480, x &= (-2302684143.3378315));
  assertEquals(815550480, x %= (-2177479570));
  assertEquals(815550480, x %= (tmp = 2895822167, tmp));
  assertEquals(815550480, x %= (-1247621230.5438688));
  assertEquals(283929811, x -= ((tmp = 251831053.17096448, tmp)|((tmp = 1140463506.004994, tmp)+(tmp = -743224673.546309, tmp))));
  assertEquals(1825767424, x <<= (((tmp = 1732353599, tmp)^(tmp = 658726044, tmp))>>>((-2827889370.932477)%(tmp = 1950139204.3291233, tmp))));
  assertEquals(1828450414, x |= (tmp = 1618538606, tmp));
  assertEquals(0, x <<= (-2411670689.045702));
  assertEquals(0, x <<= (-27744888.428537607));
  assertEquals(-0, x /= (tmp = -1597552450, tmp));
  assertEquals(0, x >>>= (((2165722776.7220936)>>>(tmp = 1233069931, tmp))>>>(-1120420811)));
  assertEquals(-0, x *= ((tmp = -1505252656, tmp)>>((((3035637099.6156535)&((467761577.7669761)>>(-361034537)))^(tmp = -2347994840.6541123, tmp))*(tmp = -2191739821, tmp))));
  assertEquals(0, x &= (795727404.0738752));
  assertEquals(-0, x *= (tmp = -3125944685.3991394, tmp));
  assertEquals(-0, x *= (x&x));
  assertEquals(0, x >>= ((tmp = -2045709233, tmp)^x));
  assertEquals(NaN, x /= (x>>(x/(3102894071))));
  assertEquals(NaN, x += ((tmp = 2149079756.8941655, tmp)-(tmp = 810121645.305179, tmp)));
  assertEquals(0, x >>>= (-859842989));
  assertEquals(0, x >>>= (tmp = 2530531143.9369526, tmp));
  assertEquals(0, x >>= (((-932981419.6254237)|(tmp = 1591591715, tmp))>>>(x+((3149795006)>>>(tmp = 613352154, tmp)))));
  assertEquals(-4294967295, x -= ((((-2289331668)%(-282648480.0078714))>>(-1373720705.5142756))>>>((tmp = 15511563.517014384, tmp)/(360279080))));
  assertEquals(1, x &= x);
  assertEquals(0, x >>= (x^(-2791872557.5190563)));
  assertEquals(0, x &= ((tmp = 336466956.7847167, tmp)>>((1235728252.053619)|(x<<((1828176636.13488)%x)))));
  assertEquals(-0, x *= (-364042830.8894656));
  assertEquals(0, x >>>= x);
  assertEquals(-1675298680, x |= ((2323049541.321387)+(296619075)));
  assertEquals(-0, x %= x);
  assertEquals(-1583048579.4420977, x += (-1583048579.4420977));
  assertEquals(0, x -= x);
  assertEquals(-2, x ^= ((603171992.0545617)/(((-271888695.718297)%(tmp = -400159585, tmp))^((((tmp = 1536123971, tmp)-(tmp = -2310418666.6243773, tmp))|((tmp = 2242779597.1219435, tmp)<<(tmp = 1758127684.4745512, tmp)))/x))));
  assertEquals(-2, x &= (x&x));
  assertEquals(0, x &= ((tmp = -1098806007.4049063, tmp)/(((2862384059.3229523)/((((tmp = -92960842, tmp)-(x>>(tmp = 1244068344.2269042, tmp)))&x)*(tmp = -1919148313, tmp)))<<(-2486665929))));
  assertEquals(0, x &= x);
  assertEquals(-1441272634.582818, x -= (1441272634.582818));
  assertEquals(-3, x >>= (tmp = 3186393693.7727594, tmp));
  assertEquals(-1206855850, x ^= (((tmp = 607979495.303539, tmp)-(tmp = -2480131951, tmp))^(x*((tmp = 1324153477, tmp)/((1248126288)+(x|(1917331780.0741704)))))));
  assertEquals(-1206855853, x ^= (x>>>(653288765.1749961)));
  assertEquals(-1206857725, x &= (3149461539.6019173));
  assertEquals(3088109571, x >>>= (x*(x<<(tmp = 1543540084, tmp))));
  assertEquals(536903680, x &= (tmp = 644851760, tmp));
  assertEquals(536903674.312194, x += (((-3183290076)-((tmp = 40738191.12097299, tmp)-x))/((x>>>(3151371851.9408646))^(tmp = 472698205.22445416, tmp))));
  assertEquals(2127424750.0506563, x -= (tmp = -1590521075.7384624, tmp));
  assertEquals(2127424750.0506563, x %= (tmp = 3027273433.361373, tmp));
  assertEquals(0, x >>= (x>>(1445204441.702043)));
  assertEquals(NaN, x %= (x<<x));
  assertEquals(0, x ^= ((tmp = -2903841152.136344, tmp)-(x%(2938662860))));
  assertEquals(0, x <<= (x<<x));
  assertEquals(0, x >>>= (tmp = -979481631.33442, tmp));
  assertEquals(0, x >>= x);
  assertEquals(0, x &= (((x%((((((tmp = 1657446354.6820035, tmp)>>(-1916527001.2992697))/x)>>(tmp = 1450467955, tmp))&(277676820))+(x/(-945587805))))/((tmp = -690095354, tmp)^x))+(tmp = -2651195021, tmp)));
  assertEquals(0, x <<= (752343428.2934296));
  assertEquals(0, x /= (tmp = 3022310299, tmp));
  assertEquals(0, x >>= (x%((388245402)>>>x)));
  assertEquals(NaN, x %= x);
  assertEquals(NaN, x %= ((tmp = 1205123529.8649468, tmp)>>>(-2848300932)));
  assertEquals(0, x >>= ((x>>>x)<<(tmp = 487841938, tmp)));
  assertEquals(0, x *= (((273436000.9463471)|(tmp = 141134074.27978027, tmp))^(tmp = 1220326800.7885802, tmp)));
  assertEquals(1525600768, x |= (((x^(-2674777396))-(tmp = 1966360716.3434916, tmp))<<(794782595.9340223)));
  assertEquals(761927595, x %= (tmp = -763673173, tmp));
  assertEquals(1.1353588586934338, x /= ((x&((-1897159300.4789193)*(-348338328.0939896)))&(978680905.6470605)));
  assertEquals(8.631173314966319e-10, x /= (1315416592));
  assertEquals(0, x >>= ((tmp = -2581239435, tmp)-((-628818404.1122074)<<x)));
  assertEquals(0, x -= x);
  assertEquals(0, x *= (2925158236));
  assertEquals(0, x /= (x+(tmp = 1405531594.0181243, tmp)));
  assertEquals(0, x *= (2712022631.230831));
  assertEquals(0, x >>= (tmp = 80518779.81608999, tmp));
  assertEquals(1953477932.8046472, x += (tmp = 1953477932.8046472, tmp));
  assertEquals(1953477932, x >>= (tmp = 3025539936, tmp));
  assertEquals(1953477932, x -= ((-2675119685.8812313)>>(x/(-1808264410.9754841))));
  assertEquals(1292620430, x += ((-660857502)%((((tmp = -698782819, tmp)%(tmp = 2847304199, tmp))<<(-2423443217.1315413))+x)));
  assertEquals(78895, x >>>= x);
  assertEquals(2, x >>= x);
  assertEquals(2, x <<= (tmp = 1313641888.8301702, tmp));
  assertEquals(1857416935.2532766, x += (tmp = 1857416933.2532766, tmp));
  assertEquals(-1677721600, x <<= (tmp = -2482476902, tmp));
  assertEquals(309226853.62854385, x -= (tmp = -1986948453.6285439, tmp));
  assertEquals(33965156, x &= (2409088742));
  assertEquals(Infinity, x /= (x-(x<<((x/(tmp = -3106546671.536726, tmp))/((tmp = 2695710176, tmp)-((((-2102442864)&(857636911.7079853))/x)%(-65640292)))))));
  assertEquals(1270005091, x |= (tmp = 1270005091.0081215, tmp));
  assertEquals(1270005091, x %= (tmp = -1833876598.2761571, tmp));
  assertEquals(158750636, x >>>= x);
  assertEquals(-1000809106.0879555, x -= (tmp = 1159559742.0879555, tmp));
  assertEquals(72400936, x &= ((2448271389.3097963)%(tmp = 1517733861, tmp)));
  assertEquals(282816, x >>= x);
  assertEquals(282816, x %= (tmp = 3192677386, tmp));
  assertEquals(0.00021521351827207216, x /= (1314118194.2040696));
  assertEquals(Infinity, x /= (((tmp = 2822091386.1977024, tmp)&x)%(tmp = -3155658210, tmp)));
  assertEquals(NaN, x %= (-359319199));
  assertEquals(0, x >>>= (((tmp = -2651558483, tmp)-(x<<(tmp = 2537675226.941645, tmp)))<<(tmp = 667468049.0240343, tmp)));
  assertEquals(-0, x *= (tmp = -2827980482.12998, tmp));
  assertEquals(-0, x %= (((tmp = -689972329.3533998, tmp)>>>x)|(tmp = -7488144, tmp)));
  assertEquals(0, x >>>= x);
  assertEquals(0, x |= x);
  assertEquals(-2410373675.2262926, x -= (2410373675.2262926));
  assertEquals(1840423, x >>= ((-1081642113)^x));
  assertEquals(-4829451429403412, x *= (-2624098606.35485));
  assertEquals(-94552231, x %= (tmp = -97015883, tmp));
  assertEquals(-94433287, x ^= (((tmp = -2297735280, tmp)&(((tmp = 2261074987.7072973, tmp)%((((2565078998)^(-2573247878))|x)|(((tmp = -2120919004.7239416, tmp)>>(tmp = -579224101, tmp))>>>(1905808441))))*(x|(3149383322))))>>(542664972)));
  assertEquals(0, x ^= (x<<(tmp = -3112569312, tmp)));
  assertEquals(0, x <<= (-2141934818.7052917));
  assertEquals(0, x >>= (tmp = -2539525922, tmp));
  assertEquals(-434467613, x ^= (tmp = -434467613, tmp));
  assertEquals(-274792709, x |= (1233452601.462551));
  assertEquals(-274726917, x |= (-2130333750));
  assertEquals(-272629761, x |= (-1516071602.5622227));
  assertEquals(-272629761, x |= ((tmp = 3012131694, tmp)&((tmp = -2595342375.8674774, tmp)-((tmp = -2710765792, tmp)>>>((x-(tmp = 2397845540, tmp))+(2496667307))))));
  assertEquals(-4194305, x |= (1343705633.165825));
  assertEquals(4190207, x >>>= ((tmp = 276587830, tmp)*((tmp = -1517753936, tmp)>>x)));
  assertEquals(0, x >>= (x|((2247486919)-((-1664642412.4710495)*((((tmp = -358185292.17083216, tmp)-(tmp = -1472193444, tmp))*(tmp = 2699733752, tmp))&((x|(x<<(1137610148.1318119)))>>(((375089690.8764564)*x)&(tmp = 859788933.9560187, tmp))))))));
  assertEquals(0, x %= (3080673960));
  assertEquals(0, x >>>= (1328846190.1963305));
  assertEquals(1249447579, x |= (-3045519717.580775));
  assertEquals(-0.8743931060971377, x /= (-1428931187));
  assertEquals(1, x |= ((tmp = -1756877535.7557893, tmp)/((-142900015.93200803)<<(1414557031.347334))));
  assertEquals(759627265, x ^= (759627264.0514802));
  assertEquals(741823, x >>= (1106391210));
  assertEquals(610451, x &= ((x>>>((919849416)+((tmp = -427708986, tmp)^((x%x)|(tmp = -2853100288.932063, tmp)))))*x));
  assertEquals(372650423401, x *= x);
  assertEquals(410404493, x >>>= ((((-1425086765)>>>x)>>((2813118707.914771)>>(-424850240)))^x));
  assertEquals(120511585729013, x *= ((tmp = -1889454669, tmp)>>>x));
  assertEquals(120513295294304.22, x -= (tmp = -1709565291.2115698, tmp));
  assertEquals(6164, x >>>= ((2244715719.397763)^(tmp = -741235818.6903033, tmp)));
  assertEquals(937572790.468221, x -= (tmp = -937566626.468221, tmp));
  assertEquals(937572790, x |= ((2129102867.156146)*(x%x)));
  assertEquals(32, x &= ((2700124055.3712993)>>>((1977241506)>>>(-2915605511))));
  assertEquals(32, x %= (tmp = -2513825862, tmp));
  assertEquals(0, x <<= (-1379604802));
  assertEquals(0, x >>>= (tmp = -1033248759, tmp));
  assertEquals(-1151517050, x ^= (3143450246));
  assertEquals(-180577, x |= ((738373819.4081701)^(-357134176)));
  assertEquals(-0, x %= x);
  assertEquals(-2086887759, x |= (tmp = 2208079537, tmp));
  assertEquals(-2, x >>= (1460216478.7305799));
  assertEquals(-2, x %= ((-1979700249.0593133)^(-3156454032.4790583)));
  assertEquals(-256, x <<= ((1810316926)>>>(tmp = 414362256, tmp)));
  assertEquals(-1, x >>= (((((((-1616428585.595561)*((tmp = 2574896242.9045777, tmp)|(86659152.37838173)))>>(((tmp = 2476869361, tmp)&((x+((tmp = -2445847462.1974697, tmp)>>(tmp = -1960643509.5255682, tmp)))+(x|(((((2231574372.778028)|(tmp = 1824767560, tmp))>>>((1108035230.2692142)|(tmp = 2354035815, tmp)))/((tmp = -2602922032, tmp)>>(-925080304.7681987)))-x))))-(x>>x)))>>>((tmp = 751425805.8402164, tmp)|(tmp = 1165240270.3437088, tmp)))-x)*(2870745939))-(x>>>((tmp = 2986532631.405425, tmp)>>>(((tmp = 2547448699, tmp)+(((((x<<(((((-2756908638.4197435)>>>(3134770084))-(-1147872642.3756688))%(x*(tmp = -282198341.6600039, tmp)))+(-770969864.2055655)))+((-2725270341)^x))/(-3093925722))>>(x&x))>>((tmp = -2705768192, tmp)>>>(((tmp = 577253091.6042917, tmp)/(((x&(((((x+x)>>>(-1000588972))/(x&(717414336)))^(tmp = 428782104.21504414, tmp))>>>(1084724288.953223)))%(tmp = -2130932217.4562194, tmp))&x))-(-286367389)))))+((x>>(tmp = 2001277117, tmp))>>((tmp = 1028512592, tmp)^((tmp = 2055148650, tmp)+((tmp = 1490798399, tmp)/(tmp = -2077566434.2678986, tmp))))))))));
  assertEquals(-1, x |= (tmp = 1542129482, tmp));
  assertEquals(-671816743, x &= (tmp = -671816743.9111726, tmp));
  assertEquals(-1840333080, x -= (1168516337));
  assertEquals(-1755382023, x |= ((((tmp = 2625163636.0142937, tmp)>>>((tmp = 1534304735, tmp)^x))-(tmp = -1959666777.9995313, tmp))%x));
  assertEquals(-1750421896, x += (x>>>(tmp = -1364828055.1003118, tmp)));
  assertEquals(-72864007, x %= (tmp = 239651127, tmp));
  assertEquals(-72863956, x -= (((tmp = -1103261657.626319, tmp)*((tmp = 2789506613, tmp)+((tmp = 2294239314, tmp)>>>(2588428607.5454817))))>>x));
  assertEquals(-170337477, x -= (tmp = 97473521, tmp));
  assertEquals(-170337477, x |= (((tmp = 246292300.58998203, tmp)/(((tmp = -2664407492, tmp)|((-2416228818)^(tmp = 909802077, tmp)))%(tmp = 532643021.68109465, tmp)))/(tmp = 1015597843.8295637, tmp)));
  assertEquals(1, x >>>= (((tmp = -2247554641.7422867, tmp)/(1186555294))%(tmp = -785511772.3124621, tmp)));
  assertEquals(1188939891.668705, x -= (tmp = -1188939890.668705, tmp));
  assertEquals(1188939891, x &= x);
  assertEquals(1188413555, x &= (((tmp = -372965330.5709038, tmp)%(((tmp = 3108909487, tmp)|(x^(-1056955571.9951684)))^(-1549217484.009048)))/(x>>>(1403428437.9368362))));
  assertEquals(-0.7343692094664643, x /= (-1618278026.4758227));
  assertEquals(0, x -= x);
  assertEquals(0, x &= (-2701762139.7500515));
  assertEquals(0, x >>>= (((-1692761485.2299166)^x)+(tmp = -1221349575.938864, tmp)));
  assertEquals(0, x <<= ((2148160230)<<x));
  assertEquals(0, x <<= (((x<<(-740907931.38363))&(tmp = -930960051.6095045, tmp))>>(x/((tmp = -1921545150.1239789, tmp)/(-3015379806)))));
  assertEquals(0, x <<= x);
  assertEquals(NaN, x /= (x|x));
  assertEquals(0, x >>= (tmp = -2265988773, tmp));
  assertEquals(-0, x *= (((x<<(-928153614))<<(-989694208))^(2544757713.481016)));
  assertEquals(0, x >>= ((tmp = 578009959.5299993, tmp)>>x));
  assertEquals(0, x /= ((((tmp = 412689800.0431709, tmp)&(1630886276))*(tmp = 2028783080.7296097, tmp))/x));
  assertEquals(0, x |= ((((x*(-2197198786))>>((2719887264.761987)<<(tmp = 2253246512, tmp)))-(tmp = -150703768.07045603, tmp))/(((-3160098146)%(((((1486098047.843547)>>(((tmp = -593773744.1144242, tmp)&(x<<(2651087978)))|((-680492758.930413)>>(tmp = 88363052.13662052, tmp))))<<x)<<(tmp = 2232672341, tmp))/((x<<x)&(((((348589117.64135563)<<(-1010050456.3097556))^(x/(tmp = -2282328795, tmp)))-(tmp = 1653716293, tmp))-((3157124731)/((tmp = 3007369535.341745, tmp)%(tmp = -2246556917, tmp)))))))+x)));
  assertEquals(0, x >>= ((1935211663.5568764)>>(x-(tmp = 2116580032, tmp))));
  assertEquals(-1725272693, x ^= (tmp = -1725272693, tmp));
  assertEquals(313683, x >>>= (-1782632531.2877684));
  assertEquals(0.009772287443565642, x /= (tmp = 32099240, tmp));
  assertEquals(-647945916.9902277, x += (-647945917));
  assertEquals(3647021380, x >>>= ((((((((2470411371.688199)<<x)>>x)-(x>>>((tmp = 1750747780, tmp)/x)))-x)<<(tmp = -2666186351.695101, tmp))^(((tmp = 2749205312.6666174, tmp)%x)&(2069802830.360536)))<<(tmp = 6051917.9244532585, tmp)));
  assertEquals(-647939220, x |= ((x>>>((tmp = -2980404582.794245, tmp)>>>(-996846982)))^x));
  assertEquals(-572178450, x |= ((-800571300.3277931)+(tmp = 2084365671, tmp)));
  assertEquals(1172311208, x &= (x&((tmp = -1207487657.8953774, tmp)^x)));
  assertEquals(12176516458994, x += ((((tmp = -1534997221, tmp)%(412142731))*((tmp = 2958726303, tmp)>>(1489169839)))+(((-574726407.2051775)>>>(((1772885017)<<(947804536.9958035))>>(-2406844737)))>>x)));
  assertEquals(-1480065024, x <<= x);
  assertEquals(-1736999042.227129, x += (tmp = -256934018.22712898, tmp));
  assertEquals(-1338699394, x ^= ((((((x%(((tmp = -2551168455.222048, tmp)|(3213507293.930222))/((-1559278033)>>((tmp = 3107774495.3698573, tmp)-(2456375180.8660913)))))*((x*(tmp = 1088820004.8562922, tmp))+((tmp = 1850986704.9836102, tmp)%(tmp = -1226590364, tmp))))*(1786192008))&(((2193303940.310299)%(tmp = 1041726867.0602217, tmp))|((2210722848)/((-1293401295.6714435)&((tmp = 3052430315, tmp)|x)))))>>>(tmp = -2028014470.1524236, tmp))+(((1695818039.0383925)<<((1669068145)*(-2746592133.899276)))<<(tmp = 519092169, tmp))));
  assertEquals(-334674849, x >>= (1170377794));
  assertEquals(-10214, x >>= ((tmp = 1074704264.3712895, tmp)>>>((tmp = -1200860192, tmp)^((tmp = 539325023.4101218, tmp)*((tmp = -588989295, tmp)|x)))));
  assertEquals(1384169472, x &= (1384171140));
  assertEquals(1384169472, x >>>= ((tmp = -2161405973.830981, tmp)*(tmp = 2054628644, tmp)));
  assertEquals(1610140972, x |= (527961388));
  assertEquals(1073273198, x += ((tmp = -259650225.71344328, tmp)&(tmp = -344359694, tmp)));
  assertEquals(65507, x >>= ((x<<((tmp = 2925070713.5245204, tmp)%(x+((tmp = -1229447799, tmp)/(((x/(x|(((-2337139694)|((((((2996268529.7965417)&x)%(((tmp = -1088587413, tmp)>>(-1384104418.90339))>>((tmp = -1643984822.3946526, tmp)+x)))%(((1118125268.4540217)-((((-1975051668.6652594)-(-704573232))+((tmp = 1674952373, tmp)/(tmp = 1321895696.0062659, tmp)))*(tmp = 1820002533.2021284, tmp)))>>>(tmp = -583960746.9993203, tmp)))|((tmp = -2577675508.550925, tmp)&x))/(tmp = 1459790066, tmp)))/(((((1051712301.7804044)&(tmp = -2726396354, tmp))^(tmp = 263937254.18934345, tmp))+(((x^x)*(((tmp = -2289491571, tmp)+x)%(-2239181148)))&x))>>(tmp = -1743418186.3030887, tmp)))))/(tmp = 1475718622, tmp))<<x)))))|(x&((((tmp = -2934707420, tmp)<<x)/x)^(1022527598.7386684)))));
  assertEquals(2047, x >>= (x-(tmp = 2300626270, tmp)));
  assertEquals(8384512, x <<= (tmp = -1917680820, tmp));
  assertEquals(0, x <<= (2393691134));
  assertEquals(0, x >>= x);
  assertEquals(649995936.5853252, x -= (tmp = -649995936.5853252, tmp));
  assertEquals(649995936, x &= x);
  assertEquals(-0.33672017582945424, x /= (tmp = -1930374188, tmp));
  assertEquals(-0.33672017582945424, x += (x&((1208055031)^(-2761287670.968586))));
  assertEquals(0, x |= x);
  assertEquals(0, x <<= ((-2038368978)/x));
  assertEquals(0, x >>= (x&((tmp = 2481378057.738218, tmp)&(x+(1172701643)))));
  assertEquals(0, x <<= ((x*(((((((tmp = 70690601.3046323, tmp)&(((((((((((x+(x+(x^(3118107461))))<<(264682213.41888392))&(tmp = -709415381.8623683, tmp))%(((((-1840054964)>>>(tmp = -405893120.89603686, tmp))|((-625507229)^(3128979265)))>>(x>>((tmp = -2480442390, tmp)*((x>>(tmp = -421414980.88330936, tmp))>>>((tmp = 1850868592, tmp)&(-2948543832.879225))))))|((2986545185)&((tmp = -1947550706, tmp)%(((tmp = 2590238422.1414256, tmp)/(((tmp = -361038812, tmp)>>x)|(((tmp = 1798444068, tmp)|((x&((tmp = -3104542069, tmp)-x))*((tmp = -1158658918, tmp)+((tmp = 2777031040.5552707, tmp)<<(-2816019335.9008327)))))<<x)))/(((2287795988.231702)/x)/(((-2588712925)>>>(2521189250))*((tmp = -2533527920, tmp)+(tmp = 1762281307.2162101, tmp)))))))))/x)/(tmp = 1047121955.5357032, tmp))|(((-121292251)<<(x^(x-(tmp = 1420006180, tmp))))%((-2278606219)>>>(((tmp = -1412487726, tmp)&(((((tmp = 253596554.16016424, tmp)/(tmp = 2083376247.0079951, tmp))^(x^((1549116789.8449988)>>>((((-1844170084)^(tmp = 1886066422, tmp))&x)<<(34918329)))))^(tmp = -440805555.3369155, tmp))-x))%(-1936512969)))))+(2911511178.4035435))|(1012059391))|(x>>>(tmp = -2551794626.158037, tmp)))+((2926596072.210515)/(tmp = -280299595.0450909, tmp))))&((tmp = 1501086971, tmp)^(tmp = 2114076983, tmp)))-((-1679390574.1466925)-(941349044)))-((x>>x)>>((-2600539474.2033434)+(tmp = 2567056503.9079475, tmp))))*(tmp = 1285896052, tmp))%(((tmp = 1191465410.7595167, tmp)>>((tmp = -2857472754, tmp)%x))>>>(((tmp = 1960819627.6552541, tmp)&(-2651207221.127376))*((((-687312743)+((x>>x)<<x))|((((((1549588195)*((tmp = 2733091019, tmp)^((527322540)<<(x>>x))))%(tmp = -2063962943, tmp))*x)*(734060600))&(-3049417708)))+(((((1084267726)+((x|x)^((tmp = -1917070472.4858549, tmp)%((690016078.9375831)*x))))%((((((tmp = -2091172769, tmp)%(2532365378))>>>(-871354260))/(tmp = 254167019.07825458, tmp))&(1330216175.9871218))>>(tmp = 1931099207, tmp)))^(-1116448185.2618852))>>((961660080.8135855)/x)))))))>>>(-1486048007.7053368)));
  assertEquals(0, x >>= x);
  assertEquals(0, x %= (tmp = -1202200444.6506357, tmp));
  assertEquals(-0, x *= (-527500796.4145117));
  assertEquals(0, x >>= (tmp = -2082822707, tmp));
  assertEquals(0, x *= ((-1882398459.290778)>>>x));
  assertEquals(0, x &= (x/(tmp = -1569332286.392817, tmp)));
  assertEquals(-390169607, x |= (-390169607.11600184));
  assertEquals(-780339214, x += x);
  assertEquals(-780339214, x %= (2765959073));
  assertEquals(-5954, x >>= (tmp = -1900007055, tmp));
  assertEquals(743563420, x &= ((((-1520146483.5367205)|(-2075330284.3762321))-(tmp = -2263151872, tmp))%(-1264641939.957402)));
  assertEquals(1487126840, x += (x>>>(((x+((tmp = -1263274491, tmp)>>>x))&(470419048.0490037))%(tmp = -2642587112, tmp))));
  assertEquals(Infinity, x /= (x^x));
  assertEquals(0, x ^= ((tmp = -1436368543, tmp)+(x/(tmp = -1125415374.3297129, tmp))));
  assertEquals(0, x += x);
  assertEquals(0, x <<= x);
  assertEquals(0, x &= (tmp = 3101147204.2905564, tmp));
  assertEquals(0, x &= (tmp = 2914487586.606511, tmp));
  assertEquals(0, x += x);
  assertEquals(0, x -= (((-1738542908.6138556)&(((x+x)-(tmp = -2801153969, tmp))%(tmp = -1206684064.1477358, tmp)))>>((-2575546469.271897)|(tmp = -2573119106, tmp))));
  assertEquals(-1468808707, x ^= (tmp = -1468808707, tmp));
  assertEquals(1357349882, x <<= (tmp = -2808501087.7003627, tmp));
  assertEquals(-572025862, x |= ((((tmp = -2415486246.573399, tmp)/((tmp = -707895732.4593301, tmp)&x))%((-1960091005.0425267)*(972618070.9166157)))-(1649962343)));
  assertEquals(327213586796843100, x *= (x%(1337884626)));
  assertEquals(42991616, x &= (-2905576654.1280055));
  assertEquals(-26049289585042860, x *= (-605915571.6557121));
  assertEquals(597809748, x >>= ((362850791.077795)/(tmp = 1222777657.4401796, tmp)));
  assertEquals(597809748, x |= x);
  assertEquals(770065246, x -= ((-711227660)|(tmp = -508554506, tmp)));
  assertEquals(593000483097040500, x *= x);
  assertEquals(0, x %= x);
  assertEquals(0, x <<= (317862995.456813));
  assertEquals(0, x >>= ((tmp = 2518385735, tmp)+((-2973864605.267604)/(-930953312.718833))));
  assertEquals(1227822411, x ^= (x^(1227822411.8553264)));
  assertEquals(1090520320, x &= (x+((((-2100097959)>>(x/(tmp = -2002285068, tmp)))/(-364207954.9242482))-((tmp = 2771293106.7927113, tmp)-(tmp = -847237774, tmp)))));
  assertEquals(1090520320, x >>= (((((2439492849)<<((-2932672756.2578926)*((743648426.7224461)+((2942284935)<<((x/(((tmp = 886289462.6565771, tmp)+(-459458622.7475352))>>(tmp = -785521448.4979162, tmp)))|(tmp = -11630282.877367258, tmp))))))-(tmp = -647511106.9602091, tmp))^x)&x));
  assertEquals(115944291.48829031, x %= (243644007.12792742));
  assertEquals(1, x /= x);
  assertEquals(0, x >>>= ((tmp = -819782567, tmp)%(tmp = 2774793208.1994505, tmp)));
  assertEquals(0, x >>= (tmp = 721096000.2409859, tmp));
  assertEquals(0, x &= ((x%x)%x));
  assertEquals(-0, x *= ((-1670466344)<<x));
  assertEquals(0, x >>= (-677240844.904707));
  assertEquals(NaN, x %= (((((-1575993236.6126876)/(-2846264078.9581823))^((((-2220459664)-(((-1809496020)>>>(tmp = -3015964803.4566207, tmp))&x))/(tmp = -3081895596.0486784, tmp))>>>(x&x)))%(x^(-1338943139)))^(x-((((2074140963.2841332)^(tmp = 1878485274, tmp))%(((x/(-2568856967.6491556))^x)<<((x+x)^((((2139002721)|(x<<(-1356174045.840464)))>>x)-(tmp = 2305062176, tmp)))))>>>(((((x<<(tmp = -1663280319.078543, tmp))-((1498355849.4158854)-((-1321681257)>>>(tmp = -1321415088.6152222, tmp))))^(-2266278142.1584673))+(858538943))&((((x-((x|(((tmp = -1576599651, tmp)+((tmp = 1595319586, tmp)&(-2736785205.9203863)))>>((x+((-1856237826)+x))<<(tmp = -1590561854.3540869, tmp))))^(((-41283672.55606127)&(tmp = 2971132248, tmp))+x)))/(-849371349.1667476))%(x*((-1705070934.6892798)>>>x)))<<((2418200640)*x)))))));
  assertEquals(0, x >>>= (tmp = 664214199.5283061, tmp));
  assertEquals(0, x <<= ((-2827299151)<<(1815817649)));
  assertEquals(1405772596, x |= (tmp = 1405772596, tmp));
  assertEquals(-1483422104, x <<= (-2791499935.6822596));
  assertEquals(-45271, x >>= (1740128943.4254808));
  assertEquals(-45271, x <<= ((2072269957)-((tmp = -2553664811.4472017, tmp)*(tmp = -2502730352, tmp))));
  assertEquals(1192951471.6745887, x -= (-1192996742.6745887));
  assertEquals(-353370112, x <<= (tmp = -1410280844, tmp));
  assertEquals(0, x ^= (x%((2754092728)*(-1017564599.1094015))));
  assertEquals(-2662096003.2397957, x -= (tmp = 2662096003.2397957, tmp));
  assertEquals(-2587094028.50764, x -= (tmp = -75001974.7321558, tmp));
  assertEquals(6693055512339889000, x *= x);
  assertEquals(897526784, x %= (x-((tmp = 897526813, tmp)%(-1525574090))));
  assertEquals(7011928, x >>= ((-440899641.344357)%x));
  assertEquals(8382047686388683, x += (x*(1195398423.8538609)));
  assertEquals(16764095372777366, x += x);
  assertEquals(16764096859576696, x -= (tmp = -1486799329.7207344, tmp));
  assertEquals(16764099774187724, x += (2914611029));
  assertEquals(16764102926624664, x -= (-3152436939.724612));
  assertEquals(-538220648, x |= x);
  assertEquals(269110324, x /= (((-2114698894.6014318)/(tmp = 767687453, tmp))>>(623601568.1558858)));
  assertEquals(256, x >>= x);
  assertEquals(-293446891, x += (x+(-293447403)));
  assertEquals(119, x >>>= ((1759400753)>>(2481263470.4489403)));
  assertEquals(14, x >>= (762849027.89693));
  assertEquals(16, x += (x&(x>>(1104537666.1510491))));
  assertEquals(-12499808227.980995, x *= (tmp = -781238014.2488122, tmp));
  assertEquals(1, x /= x);
  assertEquals(1, x &= x);
  assertEquals(0, x >>>= ((tmp = 1513381008, tmp)|(tmp = 1593208075.7259543, tmp)));
  assertEquals(0, x &= (-788154636.2843091));
  assertEquals(-0, x /= (tmp = -2124830879, tmp));
  assertEquals(0, x &= (934237436));
  assertEquals(0, x |= x);
  assertEquals(-79370942.97651315, x += (-79370942.97651315));
  assertEquals(-79370942.97651315, x %= ((tmp = -2683255523, tmp)<<(tmp = 2323123280.287587, tmp)));
  assertEquals(-79370942, x |= x);
  assertEquals(0.05861647801688159, x /= (-1354072177.061561));
  assertEquals(0, x <<= (((((((tmp = 1989257036, tmp)&(tmp = 1565496213.6578887, tmp))&x)&(tmp = -2798643735.905287, tmp))&(2354854813.43784))%(tmp = 1118124748, tmp))<<((tmp = 2453617740, tmp)*(((tmp = 1762604500.492329, tmp)<<(-2865619363))%(((2474193854.640994)|((tmp = 1425847419.6256948, tmp)|(((-1271669386)%((x|((tmp = -2059795445.3607287, tmp)+x))*(x*x)))>>>(tmp = -2997360849.0750895, tmp))))/(tmp = 2326894252, tmp))))));
  assertEquals(0, x >>>= ((-671325215)/((-727408755.8793397)>>(tmp = 315457854, tmp))));
  assertEquals(0, x >>= (x&x));
  assertEquals(0, x <<= ((x/x)>>>(((((x&x)-((x*(((tmp = -2689062497.0087833, tmp)^x)/((-1465906334.9701924)<<(tmp = -349000262, tmp))))*x))%(1630399442.5429945))*x)+((tmp = 605234630, tmp)%(tmp = 2325750892.5065155, tmp)))));
  assertEquals(0, x |= (x%((x>>(((((tmp = 1622100459, tmp)<<x)&((((((tmp = 2411490075, tmp)<<x)|x)>>((x<<x)-(-2133780459)))/x)&(x+x)))%(x/((((tmp = 580125125.5035453, tmp)>>>(-470336002.1246581))|((tmp = 871348531, tmp)*x))>>(2866448831.23781))))-((2352334552)-(-562797641.6467373))))-(x^(tmp = -681731388, tmp)))));
  assertEquals(0, x <<= (tmp = -1358347010.3729038, tmp));
  assertEquals(-260967814, x |= ((tmp = -260967814.45976686, tmp)%(tmp = 1126020255.1772437, tmp)));
  assertEquals(NaN, x %= ((((tmp = 3176388281, tmp)<<(tmp = 611228283.2600244, tmp))>>>((tmp = 3068009824, tmp)+(tmp = 2482705111, tmp)))>>>((tmp = -750778285.2580311, tmp)>>>x)));
  assertEquals(0, x <<= (x>>>x));
  assertEquals(0, x /= (1238919162));
  assertEquals(0, x >>= (x^x));
  assertEquals(0, x &= (-2137844801));
  assertEquals(0, x >>>= (x^(x*(-1774217252))));
  assertEquals(0, x >>= x);
  assertEquals(0, x |= x);
  assertEquals(0, x &= (x<<(tmp = 2791377560, tmp)));
  assertEquals(-1330674638.8117397, x += (tmp = -1330674638.8117397, tmp));
  assertEquals(353, x >>>= (-212202857.4320326));
  assertEquals(353, x ^= ((((x+(tmp = 1448262278, tmp))-(-3141272537))>>(tmp = 1116596587.7832575, tmp))>>>((x-(((tmp = 303953098, tmp)>>>((tmp = 691514425, tmp)/((176223098)*(((2876180016)%(-1805235275.892374))|x))))<<(((tmp = 528736141.838547, tmp)^(2556817082))*(2898381286.2846575))))|((-1445518239)&(tmp = 389789481.9604758, tmp)))));
  assertEquals(0, x >>>= (-227376461.14343977));
  assertEquals(0, x <<= (tmp = -2575967504, tmp));
  assertEquals(0, x <<= (x^((-2668391896)>>((x+(tmp = 598697235.9205595, tmp))+((((-2105306785)|((-1174912319.794015)>>>(x-((148979923)%((((tmp = -2459140558.4436393, tmp)|(1265905916.494016))^(tmp = 1213922357.2230597, tmp))|(1028030636))))))%x)+(((tmp = 1393280827.0135512, tmp)^((tmp = 1210906638, tmp)+(-1572777641.1396031)))<<x))))));
  assertEquals(0, x *= (tmp = 2134187165, tmp));
  assertEquals(-1084549964, x -= (tmp = 1084549964, tmp));
  assertEquals(-2045706240, x &= ((tmp = -1250758905.7889671, tmp)*(x+(((x<<(x/(tmp = -738983664.845448, tmp)))>>>x)&(tmp = 2197525295, tmp)))));
  assertEquals(-2045706240, x ^= (((522049712.14743733)>>(tmp = -2695628092, tmp))>>>(tmp = -2603972068, tmp)));
  assertEquals(2249261056, x >>>= x);
  assertEquals(-33291, x |= ((((1891467762)<<(184547486.213719))-((458875403.50689447)^(((x&(x*x))|x)%(-3127945140))))|(-100765232)));
  assertEquals(-33291, x %= (1460486884.1367688));
  assertEquals(-1, x >>= (tmp = -2667341441, tmp));
  assertEquals(-3.6289151568259606e-10, x /= (tmp = 2755644474.4072013, tmp));
  assertEquals(-3.6289151568259606e-10, x %= (tmp = 1186700893.0751028, tmp));
  assertEquals(0, x <<= (tmp = -1199872107.9612694, tmp));
  assertEquals(371216449, x ^= ((tmp = 371324611.1357789, tmp)&(x-(x|((tmp = -518410357, tmp)>>((tmp = 687379733, tmp)/x))))));
  assertEquals(0.3561383159088311, x /= (((((x%(((((-2293101242)%((((495316779)/x)-((-3198854939.8857965)>>>((tmp = -288916023, tmp)-(x^(tmp = -2504080119.431858, tmp)))))^(-1201674989)))-((2965433901)*(405932927)))/((1974547923)|(tmp = 534069372, tmp)))-(x-((x+(-1258297330))%x))))<<(((-2648166176.4947824)^(-3043930615))&(1550481610)))<<(tmp = -3118264986.743822, tmp))<<x)|x));
  assertEquals(-46272499.15029934, x -= (tmp = 46272499.50643766, tmp));
  assertEquals(-6, x >>= ((tmp = -731454087.0621192, tmp)>>>x));
  assertEquals(-2.7207928474520667e-9, x /= (((x<<(x|((tmp = -1650731700.9540024, tmp)/(tmp = -677823292, tmp))))^((((((1972576122.928667)>>x)%(2952412902.115453))<<((-2888879343)+(tmp = -425663504, tmp)))>>>(((((tmp = 1089969932, tmp)>>>(x|((-2088509661)/(1131470551))))>>>x)+x)|(tmp = 955695979.7982506, tmp)))|(((((tmp = 826954002.6188571, tmp)^(2016485728))|((x/(((x<<(tmp = 2493217141, tmp))/(-2259979800.997408))-(tmp = -427592173.41389966, tmp)))%(((-471172918)/x)>>>((383234436.16425097)&(tmp = 1664411146.5308032, tmp)))))*(tmp = 1863669754.7545495, tmp))*(x>>(2062197604)))))>>>((x-(2624545856))*(tmp = 1025803102, tmp))));
  assertEquals(0, x >>= ((tmp = 1068702028, tmp)*(296106770)));
  assertEquals(0, x ^= (x/x));
  assertEquals(85359536, x ^= (((x|(((tmp = 740629227, tmp)<<(-1107397366))%((tmp = 2315368172, tmp)>>(((-2269513683)|(-2698795048))+(-396757976)))))*(929482738.803125))^(((-1415213955.4198723)-(tmp = -2885808324, tmp))>>>((tmp = -472842353.85736656, tmp)&(tmp = 1684231312.4497018, tmp)))));
  assertEquals(2075131904, x <<= x);
  assertEquals(123, x >>>= (x>>>(tmp = 754093009, tmp)));
  assertEquals(0, x >>= ((-2690948145)/((1988638799)+x)));
  assertEquals(0, x >>>= (tmp = -798849903.2467625, tmp));
  assertEquals(NaN, x %= x);
  assertEquals(NaN, x *= (2431863540.4609756));
  assertEquals(484934656, x |= ((-2322193663)*(tmp = -2754666771, tmp)));
  assertEquals(-82505091404694530, x *= (tmp = -170136513, tmp));
  assertEquals(-82505090515370620, x += ((-148762237)&(tmp = 889417717, tmp)));
  assertEquals(-908221124, x %= (tmp = -2346393300, tmp));
  assertEquals(-1242515799, x ^= (2083328917));
  assertEquals(-1126056310271520600, x *= ((((tmp = -3065605442, tmp)<<(-3012703413))|x)^(-2081329316.4781387)));
  assertEquals(-1126056309941068000, x += ((((tmp = 1886925157, tmp)&((tmp = -163003119.31722307, tmp)/((tmp = 2094816076, tmp)>>((tmp = -706947027, tmp)^x))))^((1819889650.5261197)<<(-1641091933)))>>x));
  assertEquals(-1864360191, x |= (((x/x)|x)|x));
  assertEquals(-1864360191, x &= x);
  assertEquals(-3728720382, x += x);
  assertEquals(1042663165, x ^= (535165183.4230335));
  assertEquals(2644530017.8833704, x += (1601866852.8833704));
  assertEquals(-574949401, x |= ((tmp = 943193254.5210983, tmp)^((x%(tmp = -2645213497, tmp))*(-1904818769))));
  assertEquals(1763223578, x ^= ((x^(tmp = -2244359016, tmp))^(tmp = 320955522, tmp)));
  assertEquals(-1.9640961474334235, x /= (tmp = -897727731.0502782, tmp));
  assertEquals(1, x >>>= (x-(-3183031393.8967886)));
  assertEquals(1, x &= (tmp = 1732572051.4196641, tmp));
  assertEquals(1, x >>= (-1642797568));
  assertEquals(-2339115203.3140306, x += (-2339115204.3140306));
  assertEquals(1955852093, x ^= (((((-1469402389)/(-2648643333.1454573))>>>x)<<(x/x))>>x));
  assertEquals(-965322519, x ^= (3001399252));
  assertEquals(-2139727840, x &= (tmp = 2298411812.964484, tmp));
  assertEquals(2103328, x &= (tmp = -2488723009, tmp));
  assertEquals(1799011007, x |= (tmp = -2498057537.226923, tmp));
  assertEquals(1799011007, x |= ((-308193085)>>>x));
  assertEquals(1799011007, x |= x);
  assertEquals(818879107, x ^= (1542823996.423564));
  assertEquals(-2601416919234843600, x *= ((-2357923057.076759)-x));
  assertEquals(-2601416920481796600, x -= (x|(tmp = -3048039765, tmp)));
  assertEquals(-33690112, x <<= x);
  assertEquals(1039491072, x &= (tmp = 1039491474.3389125, tmp));
  assertEquals(126891, x >>= (-3079837011.6151257));
  assertEquals(-163191923097543, x *= (((tmp = -2847221258.4048786, tmp)*(x-(tmp = 1527622853.5925639, tmp)))^x));
  assertEquals(753616551, x ^= (-946895202));
  assertEquals(-347691264, x <<= (tmp = -433184408.33790135, tmp));
  assertEquals(0, x <<= (x|(tmp = -1911731462.6835637, tmp)));
  assertEquals(-0, x *= (tmp = -2616154415.1662617, tmp));
  assertEquals(0, x >>= x);
  assertEquals(0, x -= x);
  assertEquals(0, x *= (2272504250.501526));
  assertEquals(0, x ^= x);
  assertEquals(NaN, x %= x);
  assertEquals(0, x >>>= (2475346113));
  assertEquals(NaN, x /= (((x+(-2646140897))&(((tmp = 1039073714.142481, tmp)-x)*x))|(x*(((-1277822905.773948)>>(tmp = 2035512354.2400663, tmp))*(77938193.80013895)))));
  assertEquals(0, x ^= (x<<(tmp = 2491934268, tmp)));
  assertEquals(0, x &= (tmp = 569878335.4607931, tmp));
  assertEquals(-88575883, x ^= ((453890820.8012209)-((1569189876)%((-1280613677.7083852)^(-1902514249.29567)))));
  assertEquals(-88575883, x %= (tmp = 257947563.19206762, tmp));
  assertEquals(-88575881.7863678, x -= ((tmp = 1257547359.029678, tmp)/(x^(tmp = 948265672.821815, tmp))));
  assertEquals(-169, x >>= (tmp = -2530523309.6703596, tmp));
  assertEquals(-1, x >>= x);
  assertEquals(-1, x |= x);
  assertEquals(131071, x >>>= (-673590289));
}
f();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/numops-fuzz-part3.js                                               0000664 0000000 0000000 00000274575 14746647661 0022443 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2011 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function f() {
  var x = 131071;
  var tmp = 0;
  assertEquals(1117196836, x -= (-1117065765));
  assertEquals(3092236000.7125187, x -= (-1975039164.7125185));
  assertEquals(1, x /= x);
  assertEquals(-1599945863, x ^= (tmp = 2695021432.453696, tmp));
  assertEquals(940543782, x ^= (tmp = 2561494111, tmp));
  assertEquals(891400321673221800, x *= (tmp = 947749949.2662871, tmp));
  assertEquals(-1509927296, x >>= ((tmp = 1113290009, tmp)-x));
  assertEquals(-23, x >>= (tmp = 3216989626.7370152, tmp));
  assertEquals(-0, x %= x);
  assertEquals(0, x <<= (431687857.15246475));
  assertEquals(-0, x /= (tmp = -1924652745.081665, tmp));
  assertEquals(0, x <<= (1312950547.2179976));
  assertEquals(0, x %= ((tmp = 2110842937.8580878, tmp)|(x<<x)));
  assertEquals(0, x >>>= ((((-386879000)-((tmp = -2334036143.9396124, tmp)/((tmp = 965101904.2841234, tmp)<<(((3029227182.8426695)<<((tmp = -464466927, tmp)>>((((((tmp = 849594477.4111787, tmp)^(x&((513950657.6663146)%(x>>>x))))-((2898589263)|x))+(tmp = 2842171258.621288, tmp))>>>(tmp = -3158746843, tmp))<<(tmp = -2891369879, tmp))))-(x-(x&(tmp = -1707413686.2706504, tmp)))))))-(-2860419051))*(-1708418923)));
  assertEquals(-328055783, x += ((((2857010474.8010874)|((tmp = -1415997622.320347, tmp)-(-1706423374)))%(tmp = 824357977.1339042, tmp))^(x>>(x|x))));
  assertEquals(-168539902503779140, x *= ((tmp = -1057687018, tmp)<<((1408752963)-(2030056734))));
  assertEquals(-Infinity, x /= ((x-(2232683614.320658))*(((tmp = 195551174, tmp)*((((739595970)>>>(tmp = -2218890946.8788786, tmp))>>>(((tmp = -240716255.22407627, tmp)&(((((1598029916.3478878)|((tmp = -881749732, tmp)+(x>>x)))^(4443059))<<(((tmp = 2453020763, tmp)+((x>>>(tmp = -1904203813, tmp))&(-355424604.49235344)))<<(tmp = 2814696070, tmp)))%((tmp = -250266444, tmp)>>>(((((2710614972)&(((tmp = 910572052.6994087, tmp)^(tmp = -1028443184.3220406, tmp))/((-2718010521)^(tmp = 676361106, tmp))))|x)^(-1326539884))>>(-1573782639.7129154)))))/(tmp = 1923172768, tmp)))>>>(tmp = -2858780232.4886074, tmp)))/((((((-2060319376.353397)%x)>>(tmp = -3122570085.9065285, tmp))/(tmp = -1499018723.8064275, tmp))*((-655257391)<<x))>>x))));
  assertEquals(NaN, x += ((3059633304)%((((tmp = 2538190083, tmp)*((tmp = -2386800763.356364, tmp)/x))&(1341370996))%(-2929765076.078223))));
  assertEquals(NaN, x %= ((x&(347774821))>>>(462318570.2578629)));
  assertEquals(NaN, x *= ((2829810152.071517)*(tmp = 768565684.6892327, tmp)));
  assertEquals(NaN, x -= x);
  assertEquals(0, x >>>= (x&(tmp = 1786182552, tmp)));
  assertEquals(973967377, x ^= ((tmp = 2115869489.836838, tmp)&(994956497)));
  assertEquals(985246427.4230617, x += (11279050.423061728));
  assertEquals(985246427, x &= x);
  assertEquals(0, x >>= ((tmp = 1090502660.1867907, tmp)>>((-1599370623.5747645)-(tmp = -1321550958, tmp))));
  assertEquals(0, x %= (tmp = -2386531950.018572, tmp));
  assertEquals(0, x >>>= x);
  assertEquals(NaN, x /= x);
  assertEquals(0, x >>>= (tmp = -1535987507.682257, tmp));
  assertEquals(-0, x /= (-2570639987));
  assertEquals(-542895632, x |= (tmp = -542895632, tmp));
  assertEquals(-33930977, x >>= (tmp = -861198108.1147206, tmp));
  assertEquals(-0, x %= x);
  assertEquals(0, x ^= (x*(-608154714.1872904)));
  assertEquals(-140011520, x |= ((tmp = 377418995, tmp)<<((1989575902)>>(tmp = -2558458031.066773, tmp))));
  assertEquals(-140026048, x -= ((((tmp = 1465272774.7540011, tmp)<<((2164701398)<<(tmp = -818119264, tmp)))>>((tmp = -1490486001, tmp)>>(664410099.6412607)))>>(x>>>(((tmp = -2438272073.2205153, tmp)%(tmp = 2142162105.4572072, tmp))-(tmp = 2259040711.6543813, tmp)))));
  assertEquals(39214588236996610, x *= (x<<(-401696127.06632423)));
  assertEquals(1, x /= x);
  assertEquals(0, x %= x);
  assertEquals(0, x *= ((tmp = -1709874807.176726, tmp)&(-2786424611)));
  assertEquals(-1320474063.3408537, x += (tmp = -1320474063.3408537, tmp));
  assertEquals(88, x >>>= (tmp = -3179247911.7094674, tmp));
  assertEquals(1606348131, x += ((tmp = 1555621121.5726175, tmp)|(-3026277110.9493155)));
  assertEquals(200793516, x >>>= x);
  assertEquals(-2952688672.1074514, x -= (tmp = 3153482188.1074514, tmp));
  assertEquals(1342278624, x >>>= ((x>>>((tmp = 1264475713, tmp)-(-913041544)))>>>((tmp = 2008379930, tmp)%(tmp = 3105129336, tmp))));
  assertEquals(0, x ^= x);
  assertEquals(0, x /= (tmp = 788363717, tmp));
  assertEquals(430466213, x -= (tmp = -430466213, tmp));
  assertEquals(164757385222499550, x *= (tmp = 382741735, tmp));
  assertEquals(164757385222499550, x %= (((tmp = 1974063648, tmp)%((806015603)>>>x))*((tmp = 2836795324, tmp)<<(tmp = -1785878767, tmp))));
  assertEquals(-190957725.86956096, x /= (x^((-2939333300.066044)-(x|(-2085991826)))));
  assertEquals(-190957725.86956096, x %= (tmp = -948386352, tmp));
  assertEquals(0.6457336106922105, x /= (-295722141));
  assertEquals(0, x |= ((415991250)&((x>>(tmp = -3188277823, tmp))<<(511898664.1008285))));
  assertEquals(0, x &= ((793238922)|x));
  assertEquals(-1576701979, x ^= (2718265317));
  assertEquals(-49271937, x >>= x);
  assertEquals(-49271937, x |= x);
  assertEquals(-49271937, x &= x);
  assertEquals(775316382, x -= (-824588319));
  assertEquals(912498176, x <<= (tmp = -2223542776.836312, tmp));
  assertEquals(0, x -= (x&((tmp = 1999412385.1074471, tmp)/(-1628205254))));
  assertEquals(0, x -= x);
  assertEquals(0, x >>= (-768730139.7749677));
  assertEquals(-1861304245, x |= (((5128483)^(((tmp = -1768372004, tmp)/(x^(tmp = 1310002444.757094, tmp)))*((tmp = 188242683.09898067, tmp)^(tmp = -2263757432, tmp))))^((tmp = 2223246327, tmp)*((tmp = -2360528979, tmp)-((tmp = 2442334308, tmp)>>(458302081))))));
  assertEquals(1, x /= x);
  assertEquals(2, x += x);
  assertEquals(1, x /= x);
  assertEquals(0, x ^= x);
  assertEquals(-0, x *= (-1852374359.3930533));
  assertEquals(0, x <<= (tmp = 1223645195.148961, tmp));
  assertEquals(1789655087, x |= ((-2505312209.770559)>>x));
  assertEquals(-65568768, x <<= x);
  assertEquals(4229398528, x >>>= x);
  assertEquals(-8408187, x |= (-3029781627));
  assertEquals(-8408187, x |= (((2322165037)-((tmp = -1424506897.362995, tmp)%x))&x));
  assertEquals(-7884926, x += (x>>>(x|(2738095820))));
  assertEquals(-7884926, x %= (576507013));
  assertEquals(751801768, x ^= (tmp = -750241238, tmp));
  assertEquals(-1986010067668600800, x *= (tmp = -2641667195, tmp));
  assertEquals(1921196240, x ^= (x%(-1954178308)));
  assertEquals(847388880, x ^= ((tmp = 1632856124, tmp)&((tmp = -1536309755, tmp)<<(tmp = -3158362800, tmp))));
  assertEquals(-469662000.6651099, x += (tmp = -1317050880.6651099, tmp));
  assertEquals(-812358332, x ^= ((-2832480471)>>>(2016495937)));
  assertEquals(21, x ^= (((tmp = 1815603134.2513008, tmp)/((tmp = 147415927, tmp)%(-1059701742)))+x));
  assertEquals(-2844409139.792712, x += (tmp = -2844409160.792712, tmp));
  assertEquals(177070, x >>>= x);
  assertEquals(0, x %= x);
  assertEquals(0, x >>= x);
  assertEquals(1459126376, x ^= (tmp = -2835840920, tmp));
  assertEquals(1459126376, x %= (-1462864282));
  assertEquals(0, x >>>= (tmp = 2922724319, tmp));
  assertEquals(338995506, x ^= (338995506.6411549));
  assertEquals(336896258, x &= (2635904967));
  assertEquals(336634112, x -= (x&(tmp = 1659656287, tmp)));
  assertEquals(NaN, x %= (x-x));
  assertEquals(NaN, x /= (tmp = -674606200, tmp));
  assertEquals(NaN, x %= ((x|(2788108542))/(x+(tmp = 600941473, tmp))));
  assertEquals(0, x >>>= ((-1858251597.3970242)>>>x));
  assertEquals(1951294747, x |= (tmp = 1951294747, tmp));
  assertEquals(1951294747, x &= x);
  assertEquals(-153190625, x |= (-1500095737));
  assertEquals(23467367587890624, x *= x);
  assertEquals(346531290.1813514, x /= (((((-513617734.11148167)|x)/((tmp = -2042982150.1170752, tmp)%((x%((x%x)>>>(((-1369980151)&(((922678983)%(x&(tmp = -855337708, tmp)))-((tmp = -2717183760, tmp)>>>((1939904985.4701347)%(((tmp = -2473316858, tmp)&((tmp = -599556221.9046664, tmp)>>((tmp = -6352213, tmp)/x)))&x)))))%x)))/((tmp = -1842773812.8648412, tmp)>>>(((x>>>(tmp = 499774063, tmp))<<(((tmp = -1353532660.5755146, tmp)*(-3070956509))>>(((-905883994.0188017)>>(tmp = -16637173, tmp))<<((tmp = 471668537, tmp)*((tmp = -232036004.26637793, tmp)/x)))))&(tmp = 85227224, tmp))))))>>>(x|(-2528471983)))-((tmp = 1531574803, tmp)+((x>>>x)-(2889291290.158888)))));
  assertEquals(-94.42225749399837, x /= (((tmp = 2381634642.1432824, tmp)>>(tmp = -2637618935, tmp))|(2307200473)));
  assertEquals(-47, x >>= (1524333345.141235));
  assertEquals(-2.8699253616435082e-8, x /= (1637673252));
  assertEquals(0, x |= x);
  assertEquals(1083427040, x += ((-2012055268)<<(tmp = -2192382589.6911573, tmp)));
  assertEquals(1083427040, x %= (x*x));
  assertEquals(2694039776, x += ((((-1740065704.9004602)<<(-736392934))%(2781638048.424092))>>>(x&x)));
  assertEquals(-1600927520, x |= ((tmp = 2904430054.869525, tmp)*(((1054051883.4751332)*x)*((-939020743)-(tmp = 1636935481.1834455, tmp)))));
  assertEquals(-1600927520, x -= (x%x));
  assertEquals(3037584978216498700, x *= (tmp = -1897390694, tmp));
  assertEquals(372598954.1823988, x %= (tmp = 1553763703.5082102, tmp));
  assertEquals(-1476395008, x <<= ((x>>((tmp = 282496335.49494267, tmp)^((-1948623419.6947453)|((((((tmp = -1203306995, tmp)-(-5554612.355098486))>>>(1867254951.4836824))>>x)|(-695777865))/((-59122652.19377303)<<(-609999229.7448442))))))>>(x/(tmp = -1207010654.9993455, tmp))));
  assertEquals(-2.2540185787941605, x /= (((tmp = 1364159859.9199843, tmp)*x)>>x));
  assertEquals(-2, x |= x);
  assertEquals(2241824008, x *= ((3174055292.962967)>>(((-2379151623.602476)>>(tmp = -1423760236, tmp))>>(tmp = -522536019.2225733, tmp))));
  assertEquals(-2138158385, x ^= ((x>>((((1316131966.9180691)-((x*x)>>x))>>>x)>>((-2712430284)|(((((x<<(-616185937.6090865))-(((x-(tmp = 2957048661, tmp))<<(tmp = 617564839.888214, tmp))/(x%((tmp = -447175647.9393475, tmp)<<(2203298493.460617)))))-((x&((x<<(914944265))^(((-1294901094)*((tmp = 2512344795, tmp)+((((tmp = -1227572518, tmp)%(1831277766.4920158))*((x|x)^(tmp = 2515415182.6718826, tmp)))*x)))-(961485129))))>>>(tmp = 2079018304, tmp)))>>(tmp = 734028202, tmp))^(554858721.6149715)))))-((tmp = 1312985279.5114603, tmp)^(tmp = 2450817476.179955, tmp))));
  assertEquals(2.759030298237921, x /= (x|(tmp = -775901745.3688724, tmp)));
  assertEquals(8, x <<= x);
  assertEquals(NaN, x %= (((x&((1792031228.831834)>>(-1174912501)))%(((-2351757750)+(tmp = -2610099430, tmp))*(-2811655968)))*(x&(tmp = -1881632878, tmp))));
  assertEquals(0, x &= ((x*(616116645.7508612))^(2789436828.536846)));
  assertEquals(0, x *= x);
  assertEquals(35097452, x ^= ((tmp = 1023684579, tmp)%(((x|((tmp = -757953041, tmp)+(772988909)))+(tmp = -2934577578, tmp))>>>((tmp = -1973224283, tmp)>>>((x*(2244818063.270375))|(x-(-716709285)))))));
  assertEquals(0.015207441433418992, x /= (2307913014.4056892));
  assertEquals(-5865042.942076175, x -= (5865042.957283616));
  assertEquals(-67719.94207617454, x %= (((1464126615.2493973)+(398302030.0108756))>>>x));
  assertEquals(4294899577, x >>>= (x<<x));
  assertEquals(-1, x >>= (tmp = 607447902, tmp));
  assertEquals(-1, x >>= (3081219749.9119744));
  assertEquals(6.53694303504065e-10, x /= (tmp = -1529767040.4034374, tmp));
  assertEquals(6.53694303504065e-10, x %= ((tmp = 899070650.7190754, tmp)&(tmp = -1101166301, tmp)));
  assertEquals(6.53694303504065e-10, x %= (tmp = -2207346460, tmp));
  assertEquals(NaN, x %= (((x&x)>>x)%(((-10980184)+x)&(tmp = -1473044870.4729445, tmp))));
  assertEquals(NaN, x -= x);
  assertEquals(-1755985426, x ^= (tmp = 2538981870, tmp));
  assertEquals(-13842, x %= ((((-2258237411.3816605)+(-1325704332.0531585))<<((tmp = -877665450.1877053, tmp)>>(((((2420989037)+(2084279990.6278818))*(-327869571.9348242))+x)^x)))>>>x));
  assertEquals(1, x /= x);
  assertEquals(1, x >>= ((2241312290)^(2859250114)));
  assertEquals(0, x >>= x);
  assertEquals(-1615631756, x |= (-1615631756.1469975));
  assertEquals(-1615631756, x |= x);
  assertEquals(-627245056, x <<= ((x*(tmp = -1308330685.5971081, tmp))|(tmp = 1479586158, tmp)));
  assertEquals(-627245056, x |= x);
  assertEquals(1786953888, x ^= (-1340096352.1839824));
  assertEquals(1668014353, x -= (tmp = 118939535, tmp));
  assertEquals(1, x /= x);
  assertEquals(-645681, x ^= ((-1322356629)>>(tmp = 1829870283, tmp)));
  assertEquals(-1322354688, x <<= (-794779253));
  assertEquals(-4310084378.672725, x += (-2987729690.6727247));
  assertEquals(-8620168757.34545, x += x);
  assertEquals(-8720421, x |= (tmp = -748107877.6417065, tmp));
  assertEquals(-1508858270, x ^= (1500137913));
  assertEquals(-0.825735756765112, x /= (1827289490.1767085));
  assertEquals(1253449509.1742642, x += (((tmp = 1253449509.9576545, tmp)-(((tmp = 2860243975, tmp)+(367947569.85976696))>>(((((530960315)>>>((((x%(tmp = -2203199228, tmp))<<(x*(((tmp = -117302283, tmp)/(x-((2579576936)%(-1225024012))))&(tmp = -2857767500.1967726, tmp))))/((x/((tmp = -166066119, tmp)<<x))|x))>>>x))|(((2771852372)>>(((tmp = -3103692094.1463976, tmp)-(tmp = 2867208546.069278, tmp))>>>(702718610.1963737)))|(tmp = 2680447361, tmp)))>>x)>>(-2006613979.051014))))^((-1665626277.9339101)/(x<<(tmp = 342268763, tmp)))));
  assertEquals(1693336701.1742642, x += (tmp = 439887192, tmp));
  assertEquals(0.8479581831275719, x /= ((1171383583)+(((x&x)>>>(51482548.618915915))-(tmp = -825572595.1031849, tmp))));
  assertEquals(28, x |= ((tmp = -2355932919.6737213, tmp)>>(tmp = -2395605638, tmp)));
  assertEquals(0, x %= x);
  assertEquals(0, x -= x);
  assertEquals(0, x <<= (x^((tmp = 2793423893.484949, tmp)*(1585074754.3250475))));
  assertEquals(0, x >>= (x/(x-((957719861.9175875)&(1288527195)))));
  assertEquals(0, x >>>= ((-1429196921.4432657)/x));
  assertEquals(-852424225.734199, x -= (tmp = 852424225.734199, tmp));
  assertEquals(-46674433, x |= ((tmp = -2335242963, tmp)*((2135206646.2614377)>>(tmp = 505649511.8292929, tmp))));
  assertEquals(2944662357, x += (tmp = 2991336790, tmp));
  assertEquals(1404, x >>>= (849155189.1503456));
  assertEquals(-846755170, x ^= (tmp = -846753822.4471285, tmp));
  assertEquals(52615, x >>>= ((-517068110)+x));
  assertEquals(1475021859.9916897, x += (tmp = 1474969244.9916897, tmp));
  assertEquals(0, x %= x);
  assertEquals(0, x %= ((539583595.8244679)*(tmp = 1469751690.9193692, tmp)));
  assertEquals(0, x &= (807524227.2057163));
  assertEquals(NaN, x %= x);
  assertEquals(NaN, x -= (x^((tmp = -362481588, tmp)%(2611296227))));
  assertEquals(NaN, x *= x);
  assertEquals(0, x >>= ((-2519875630.999908)<<x));
  assertEquals(NaN, x %= x);
  assertEquals(NaN, x += (((tmp = 2485209575, tmp)>>(tmp = 2326979823, tmp))%(x-(((-1296334640.7476478)&x)<<x))));
  assertEquals(0, x >>= (((tmp = 1370704131, tmp)^((((tmp = 793217372.7587746, tmp)>>(((-1455696484.109328)|(((((-2186284424.5379324)<<(tmp = 3052914152.254852, tmp))-(x>>(tmp = 3121403408, tmp)))+((778194280)-(((((tmp = 2398957652, tmp)-(x+(((-2592019996.937958)>>((tmp = 1648537981, tmp)>>x))<<(-677436594))))<<(39366669.09012544))|((tmp = 3133808408.9582872, tmp)-(-2987527245.010673)))*x)))|((tmp = -2178662629, tmp)<<x)))^(((tmp = 909652440.3570575, tmp)%(-2572839902.6852217))%(-1879408081))))*(tmp = -2910988598, tmp))&(((x^x)>>(2822040993))|((x*x)^(((1072489842.6785052)|(x-(((464054192.7390214)^x)<<(tmp = -2754448095, tmp))))*((tmp = -1544182396, tmp)/(tmp = -3198554481, tmp)))))))^(tmp = 1946162396.9841106, tmp)));
  assertEquals(371272192, x |= (((x^((x-(x/x))&(tmp = 2370429394, tmp)))-(tmp = -403692829, tmp))*(tmp = 2808636109, tmp)));
  assertEquals(929786482, x |= ((729966239.8987448)^(x-((tmp = 120127779, tmp)^((tmp = -3088531385, tmp)>>>((x+((tmp = 2364833601, tmp)>>>(((599149090.6666714)>>(tmp = 2838821032, tmp))%(tmp = -662846011, tmp))))-(tmp = 1168491221.1813436, tmp)))))));
  assertEquals(-681121542, x += ((-1610909505.998718)^((tmp = -957338882, tmp)>>>(tmp = 1935594133.6531684, tmp))));
  assertEquals(-2147483648, x <<= ((tmp = 15161708, tmp)|(2453975670)));
  assertEquals(-2147483648, x >>= x);
  assertEquals(0, x <<= (2080486058));
  assertEquals(0, x &= (((x&(tmp = -767821326, tmp))/((tmp = 1877040536, tmp)>>>(tmp = 2378603217.75597, tmp)))*(-1601799835)));
  assertEquals(0, x %= (-1820240383));
  assertEquals(1621233920, x ^= ((tmp = 820230232, tmp)*(1727283900)));
  assertEquals(1621233920, x |= (x>>>x));
  assertEquals(1621233931, x += ((tmp = 794966194.9011587, tmp)>>(tmp = -597737830.5450518, tmp)));
  assertEquals(1621276543, x |= (((x^((2354444886)+(tmp = 685142845.4708651, tmp)))-(tmp = 790204976.9120214, tmp))>>>((((tmp = -2792921939, tmp)/(((((tmp = -80705524, tmp)<<x)-(((((((tmp = 1951577216.379527, tmp)>>>x)%((-529882150)>>>(tmp = -1682409624, tmp)))<<((-42043756.29025769)-(-1803729173.6855814)))/(2937202170.118023))*(tmp = -1998098798.5722106, tmp))*(tmp = -2996229463.904228, tmp)))&x)>>>(-301330643)))/(-2858859382.0050273))-(tmp = 1571854256.0740635, tmp))));
  assertEquals(810638271, x >>>= (x/(1553632833)));
  assertEquals(810638271, x <<= (tmp = -1467397440, tmp));
  assertEquals(-2147483648, x <<= x);
  assertEquals(871068871, x ^= (tmp = 3018552519, tmp));
  assertEquals(-1073743881, x |= ((tmp = 2294122324.020989, tmp)|(tmp = -1799706842.4493146, tmp)));
  assertEquals(-77816868, x += (((-2225296403)&x)>>(tmp = -2667103424.445239, tmp)));
  assertEquals(-1215889, x >>= (tmp = 1876107590.8391647, tmp));
  assertEquals(-2431778, x += x);
  assertEquals(4292535518, x >>>= (((x>>(-1825580683))/x)%x));
  assertEquals(4292802560, x -= (x|(1492864090)));
  assertEquals(0, x -= x);
  assertEquals(0, x >>= x);
  assertEquals(0, x %= (tmp = 2173121205, tmp));
  assertEquals(0, x *= (x>>x));
  assertEquals(1565261471, x |= ((1565261471.323931)>>>x));
  assertEquals(0, x -= x);
  assertEquals(-86980804, x |= (-86980804));
  assertEquals(-698956484, x -= (((((2754713793.1746016)*(((((-1514587465.0698888)>>(tmp = -1307050817, tmp))/(tmp = 2368054667.438519, tmp))*(-1908125943.5714772))<<(x>>>(-357164827.4932244))))+(1257487617))<<(2954979945))&(612330472)));
  assertEquals(-1073741824, x <<= x);
  assertEquals(54497747, x ^= (-1019244077.098908));
  assertEquals(54501375, x |= (((tmp = 1944912427, tmp)>>>x)%x));
  assertEquals(0, x -= x);
  assertEquals(0, x -= x);
  assertEquals(-0, x *= (-1748215388));
  assertEquals(0, x >>= x);
  assertEquals(0, x >>>= (((tmp = 988769112, tmp)%(tmp = -3133658477, tmp))<<x));
  assertEquals(0, x %= (1685221089.2950323));
  assertEquals(0, x >>>= (x+((793467168)-(tmp = 135877882, tmp))));
  assertEquals(0, x %= ((tmp = -2406801984, tmp)%(tmp = -987618172, tmp)));
  assertEquals(0, x *= ((-2943444887.953456)|(tmp = -2327469738.4544783, tmp)));
  assertEquals(0, x >>= x);
  assertEquals(-145484729.70167828, x += (tmp = -145484729.70167828, tmp));
  assertEquals(1140855872, x &= (x^(tmp = 3151437967.965556, tmp)));
  assertEquals(1486808408, x += (tmp = 345952536, tmp));
  assertEquals(107846582.36594129, x %= (-1378961825.6340587));
  assertEquals(-642031616, x <<= (x+x));
  assertEquals(151747770.95108718, x *= (x/(tmp = 2716379907, tmp)));
  assertEquals(192723456, x <<= (tmp = -1731167384, tmp));
  assertEquals(2151208003, x -= ((-2151208003)+x));
  assertEquals(1, x /= x);
  assertEquals(1, x |= x);
  assertEquals(1996766603, x |= (1996766602));
  assertEquals(895606123, x ^= (tmp = 1113972960.966081, tmp));
  assertEquals(-1500036886, x ^= (tmp = 2482412929, tmp));
  assertEquals(-1542644247, x ^= (x>>>((tmp = 51449105, tmp)>>>(((-2057313176)*x)/(-1768119916)))));
  assertEquals(-1496074063273093600, x *= ((tmp = 786152274, tmp)^(387292498)));
  assertEquals(-794329073, x %= (((tmp = -2314637675.617696, tmp)*((((x*(411053423.29070306))-(2889448433.4240828))/((-970630131)/(tmp = -2886607600.7423067, tmp)))<<(tmp = 1263617112.9362245, tmp)))|(2816980223.8209996)));
  assertEquals(2468008436047106600, x *= (tmp = -3107035257.725115, tmp));
  assertEquals(3040956928, x >>>= ((tmp = 1514372119.1787262, tmp)*(3169809008)));
  assertEquals(-19, x >>= (tmp = -266966022.10604453, tmp));
  assertEquals(-1.6505580654964654e-8, x /= ((-3143841480)>>(x-x)));
  assertEquals(-2.2420284729165577e-7, x *= (x*((((703414102.2523813)%(tmp = 2989948152, tmp))-((-1583401827.2949386)^((tmp = -1916731338, tmp)%((331500653.3566053)|(((tmp = 29865940, tmp)+((tmp = -2294889418.6764183, tmp)<<(tmp = -1558629267.255229, tmp)))>>>(x*(x+x)))))))|((988977957)&(-2986790281)))));
  assertEquals(0, x ^= (x/(tmp = 781117823.345541, tmp)));
  assertEquals(NaN, x *= (((x^((((tmp = -2969290335, tmp)+(((((tmp = -175387021, tmp)&(tmp = -1080807973, tmp))<<(tmp = -2395571076.6876855, tmp))|((tmp = -1775289899.4106793, tmp)^x))|(-2963463918)))*(tmp = -1761443911, tmp))^(tmp = 847135725, tmp)))<<((146689636)<<x))%x));
  assertEquals(0, x ^= x);
  assertEquals(1720182184, x -= (((tmp = 3184020508, tmp)|((-489485703)+(tmp = -2644503573, tmp)))&(tmp = 2575055579.6375213, tmp)));
  assertEquals(1720182184, x >>= (x<<(-45408034)));
  assertEquals(5.759243187540471e+27, x *= (((x&(1456298805))+(x<<(106573181)))*((566861317.2877743)+(2262937360.3733215))));
  assertEquals(5.759243187540471e+27, x -= (tmp = -1365873935, tmp));
  assertEquals(0, x <<= x);
  assertEquals(0, x >>= (1960073319.3465362));
  assertEquals(0, x <<= x);
  assertEquals(560463904, x += ((tmp = 1844076589.9286406, tmp)&((((((-691675777.5800121)|(-745631201))|x)+(tmp = 1504458593.2843904, tmp))-x)<<x)));
  assertEquals(-513210271, x -= (x|(1052702623.7761713)));
  assertEquals(3781757025, x >>>= ((-1346666404.362477)*(tmp = 2798191459, tmp)));
  assertEquals(1080100929, x &= (1122097879.882534));
  assertEquals(1276833905.8093092, x *= ((1276833905.8093092)/x));
  assertEquals(1276833905.8093092, x %= (1796226525.7152414));
  assertEquals(1276833905, x <<= (((tmp = -491205007.83412814, tmp)*(tmp = 1496201476.496839, tmp))>>(x+((tmp = -854043282.114594, tmp)-((x|(tmp = -807842056, tmp))*x)))));
  assertEquals(1276833905, x %= (((-1870099318)>>>(((tmp = -2689717222, tmp)/(248095232))/(tmp = 1036728800.5566598, tmp)))&(((((857866837)>>(tmp = 3034825801.740485, tmp))|(-1676371984))>>>(x<<x))%((-3035366571.0221004)*(1578324367.8819473)))));
  assertEquals(1, x /= x);
  assertEquals(2819223656.189109, x += (2819223655.189109));
  assertEquals(-1475743640, x >>= (((tmp = 2586723314.38089, tmp)/(x&(tmp = -697978283.9961061, tmp)))<<(x%((-1167534676)>>(x^((tmp = -284763535, tmp)*((x%x)&((((tmp = 2916973220.726839, tmp)%x)/(tmp = -1338421209.0621986, tmp))|((tmp = -834710536.803335, tmp)%x)))))))));
  assertEquals(-3267683406, x -= (tmp = 1791939766, tmp));
  assertEquals(-2090420900700614100, x *= (639725653));
  assertEquals(-1540353536, x %= ((-1800269105)<<((((x&(((tmp = 1135087416.3945065, tmp)^(613708290))>>x))>>(tmp = -1234604858.7683473, tmp))^(2404822882.7666225))>>>((tmp = -287205516, tmp)-((1648853730.1462333)^((x+(x%((tmp = 359176339, tmp)%((2856479172)<<(tmp = -1995209313, tmp)))))^(((tmp = 2857919171.839304, tmp)>>>(tmp = 2779498870, tmp))>>x)))))));
  assertEquals(-2093767030, x ^= (654554250.498078));
  assertEquals(1, x >>>= ((tmp = -166296226.12181997, tmp)^(x/x)));
  assertEquals(-1487427474, x -= ((x<<x)|(1487427475.4063978)));
  assertEquals(-1487427470.562726, x += ((-1226399959.8267038)/((tmp = 2172365551, tmp)<<x)));
  assertEquals(-3457859227618939400, x *= (tmp = 2324724597.3686075, tmp));
  assertEquals(396221312, x >>= (-1354035390));
  assertEquals(0, x %= x);
  assertEquals(0, x &= (tmp = 2733387603, tmp));
  assertEquals(1485905453, x |= ((((tmp = -1321532329.304437, tmp)&((((tmp = 1817382709.4180388, tmp)%(((tmp = 2089156555.7749293, tmp)-(-1555460267))|(tmp = 717392475.9986715, tmp)))%(tmp = 1976713214, tmp))^x))>>>x)+(tmp = -2812404197.002721, tmp)));
  assertEquals(1485905453, x |= x);
  assertEquals(-997658264, x <<= (-1409757949.6038744));
  assertEquals(-997657290, x -= ((-2041106361)>>(tmp = -2014750507, tmp)));
  assertEquals(-2138512124, x &= (tmp = 2565597060, tmp));
  assertEquals(8422400, x &= ((-2819342693.5172367)*(tmp = 1441722560, tmp)));
  assertEquals(111816531.81703067, x -= (-103394131.81703067));
  assertEquals(59606682.673836395, x *= ((tmp = -1451690098, tmp)/(x-(2835050651.717734))));
  assertEquals(-119213365.34767279, x *= (x|((-2656365050)/((-66180492)+(tmp = 284225706.32323086, tmp)))));
  assertEquals(-232839, x >>= (1694344809.435083));
  assertEquals(-1, x >>= x);
  assertEquals(1, x *= x);
  assertEquals(1, x |= x);
  assertEquals(0, x >>= (tmp = 397239268, tmp));
  assertEquals(-1525784563, x -= (tmp = 1525784563, tmp));
  assertEquals(-153.62740888512675, x /= (((tmp = -2040622579.5354173, tmp)*(tmp = -1149025861.549324, tmp))%(((tmp = 2981701364.0073133, tmp)*(tmp = 2993366361, tmp))|(x|(tmp = 1800299979, tmp)))));
  assertEquals(-1671795135, x &= (-1671795135.6173766));
  assertEquals(-4253, x |= ((((x*((1533721762.8796673)<<((tmp = 1026164775.0081646, tmp)<<x)))<<(((x-((((x>>((((((tmp = -481536070.7067797, tmp)&(tmp = 1663121016, tmp))>>>(-2974733313.5449667))+(tmp = -493019653, tmp))>>x)&(tmp = 879307404.8600142, tmp)))>>>x)%(x-(tmp = -1806412445.788453, tmp)))%x))<<(x<<(x+x)))+x))>>((tmp = -332473688.28477216, tmp)<<((tmp = 1701065928, tmp)+(((((tmp = -2407330783, tmp)+x)-((tmp = 584100783, tmp)%(tmp = -3077106506, tmp)))^x)>>x))))<<x));
  assertEquals(-0, x %= x);
  assertEquals(0, x >>>= x);
  assertEquals(0, x >>>= (1578470476.6074834));
  assertEquals(0, x >>>= (974609751));
  assertEquals(-120, x += (x-((tmp = -245718438.0842378, tmp)>>>(tmp = -1870354951, tmp))));
  assertEquals(-6.134465505515781e-8, x /= (1956160645));
  assertEquals(-0, x %= x);
  assertEquals(0, x *= (tmp = -399718472.70049024, tmp));
  assertEquals(-1803198769.8413258, x += (-1803198769.8413258));
  assertEquals(988624943, x ^= ((((tmp = 320776739.5608537, tmp)*(((tmp = -983452570.3150327, tmp)^x)&(tmp = -3181597938, tmp)))-(tmp = -1367913740.9036021, tmp))/(((tmp = -535854933.2943456, tmp)-(717666905.8122432))>>>(((((x^(tmp = 380453258.60062766, tmp))^(tmp = -1242333929, tmp))/((tmp = 1072416261, tmp)+(((2090466933)*(x*(tmp = -386283072, tmp)))|((tmp = 789259942, tmp)<<(tmp = -1475723636.1901488, tmp)))))>>>x)%((x>>(tmp = -1243048658.3818703, tmp))|((((((tmp = -619553509, tmp)|x)/(878117279.285609))|((x<<(x>>>(tmp = -749568437.7390883, tmp)))*x))/(tmp = 1674804407, tmp))-(x*(tmp = 1528620873, tmp))))))));
  assertEquals(988625135, x |= (x>>>(tmp = 2402222006, tmp)));
  assertEquals(988625135, x %= (-2691094165.990094));
  assertEquals(0, x %= x);
  assertEquals(-0, x *= (tmp = -1409904262, tmp));
  assertEquals(-0, x /= ((1176483512.8626208)<<x));
  assertEquals(0, x &= ((((1677892713.6240005)^(tmp = 2575724881, tmp))^(tmp = -2935655281.208194, tmp))*(216675668)));
  assertEquals(0, x >>= (tmp = -1296960457, tmp));
  assertEquals(0, x |= x);
  assertEquals(NaN, x /= x);
  assertEquals(0, x <<= (x>>(-3127984289.9112387)));
  assertEquals(0, x %= ((tmp = 190018725.45957255, tmp)<<((x>>>x)/x)));
  assertEquals(0, x /= (1185681972));
  assertEquals(0, x &= ((tmp = -1285574617, tmp)>>x));
  assertEquals(0, x >>>= ((tmp = 2498246277.2054763, tmp)+(((tmp = 924534435, tmp)&x)>>(tmp = 1379755429, tmp))));
  assertEquals(0, x -= x);
  assertEquals(0, x /= (3093439341));
  assertEquals(0, x *= (x>>>x));
  assertEquals(0, x &= (tmp = 551328367, tmp));
  assertEquals(-0, x /= (-3153411714.834353));
  assertEquals(1217585288, x ^= (tmp = -3077382008.637764, tmp));
  assertEquals(-639702017, x |= ((tmp = -640922633, tmp)%(tmp = -879654762, tmp)));
  assertEquals(-1645297680, x <<= (tmp = 1418982820.8182912, tmp));
  assertEquals(-1.4059558868398736, x /= (1170234212.4674253));
  assertEquals(-2650856935.66554, x *= (1885448157));
  assertEquals(1326259953.26931, x *= (((x>>(x|(-496195134.78045774)))+((2029515886)%(tmp = 1148955580, tmp)))/(tmp = -1760016519, tmp)));
  assertEquals(0, x &= (((((-273334205)+(tmp = 797224093.682485, tmp))/x)>>>((((tmp = -887577414, tmp)/x)+x)%(tmp = 720417467, tmp)))^(((x-(tmp = -309071035, tmp))>>(-3123114729.33889))/x)));
  assertEquals(0, x ^= x);
  assertEquals(0, x %= ((tmp = -2243857462, tmp)/((((((2642220700.6673346)&x)*(tmp = 1454878837, tmp))|((-25825087.30002737)%(851535616.3479034)))<<(tmp = -697581582, tmp))%(tmp = 2248990486, tmp))));
  assertEquals(0, x >>= (((x|(((tmp = -220437911, tmp)&((((255690498)*(((2993252642)>>>(tmp = 300426048.0338713, tmp))>>x))&((-364232989)+(x<<(-1824069275))))%(x+(tmp = 2696406059.026349, tmp))))+((tmp = 2911683270, tmp)/(tmp = 2718991915, tmp))))*(x/(((tmp = -982851060.0744538, tmp)^((-2903383954)<<((-85365803.80553412)^x)))%(1489258330.5730634))))>>>x));
  assertEquals(0.7805921633088815, x += (((-1886920875)/(-2417294156.5304217))%(tmp = -1176793645.8923106, tmp)));
  assertEquals(0, x <<= x);
  assertEquals(-2215008905, x -= (2215008905));
  assertEquals(1931542900, x &= (-215923724.72133207));
  assertEquals(907191462, x ^= (-3133954606.357727));
  assertEquals(453595731, x >>>= (((tmp = 2726241550, tmp)/(tmp = -332682163, tmp))*((((tmp = 2500467531, tmp)>>>(((x<<(tmp = -1847200310.4863105, tmp))/x)^x))+x)<<(191688342.22953415))));
  assertEquals(-0.21671182880645923, x /= ((((-1169180683.1316955)%x)>>>(1650525418))^((2198033206.797462)&((-6913973.910871983)%(1758398541.8440342)))));
  assertEquals(-375102237.1603561, x += (tmp = -375102236.9436443, tmp));
  assertEquals(1, x &= (((84374105.89811504)|((tmp = -2480295008.926951, tmp)>>((605043461)>>(tmp = -2495122811, tmp))))>>(-2129266088)));
  assertEquals(1, x |= x);
  assertEquals(0.0000024171579540208214, x /= (((-2600416098)>>(-2076954196))^x));
  assertEquals(0.0000024171579540208214, x %= (tmp = -2632420148.815531, tmp));
  assertEquals(1809220936.0126908, x -= (-1809220936.0126884));
  assertEquals(1682452118.2686126, x += (((2358977542)<<(x/(tmp = -2862107929, tmp)))+(x+(x%((-3101674407)/(((x*((x>>(tmp = 630458691.3736696, tmp))>>>(tmp = -852137742, tmp)))/x)-((-1875892391.1022017)&(tmp = -1027359748.9533749, tmp))))))));
  assertEquals(1682452118, x <<= (((tmp = -80832958.07816291, tmp)>>x)%(x-((x^(x<<(tmp = -156565345, tmp)))|((tmp = -1208807363.727137, tmp)/(tmp = 2614737513.304538, tmp))))));
  assertEquals(6572078, x >>= (-1573364824));
  assertEquals(13144156, x += x);
  assertEquals(1731678184, x ^= ((tmp = 593370804.9985657, tmp)|(-3124896848.53273)));
  assertEquals(845545, x >>>= (tmp = -605637621.2299933, tmp));
  assertEquals(-1383361088, x ^= (tmp = -1383632087, tmp));
  assertEquals(-82545896480031520, x += ((x+(1023183845.7316296))*((((tmp = 576673669, tmp)>>(((-584800080.1625061)/(2388147521.9174623))+((((x>>>(-905032341.5830328))^(tmp = -2170356357, tmp))-x)+((136459319)+(-1799824119.689473)))))|x)&(tmp = -2688743506.0257063, tmp))));
  assertEquals(-895206176, x |= x);
  assertEquals(-0, x %= x);
  assertEquals(1791306023, x ^= ((tmp = -3219480856, tmp)+(tmp = 715819582.0181161, tmp)));
  assertEquals(1791306023, x &= x);
  assertEquals(2725167636753240600, x *= (1521330025));
  assertEquals(-281190679, x |= (tmp = -1422045975.798171, tmp));
  assertEquals(-281190679, x += (x%x));
  assertEquals(-2342097426.906673, x -= (tmp = 2060906747.906673, tmp));
  assertEquals(-4651462701.906673, x -= (2309365275));
  assertEquals(1878, x >>>= (2544974549.345834));
  assertEquals(1964, x += (x&((1067649861)>>(182139255.7513579))));
  assertEquals(2209, x += (x>>(tmp = -1775039165, tmp)));
  assertEquals(0, x -= x);
  assertEquals(-0, x /= (tmp = -1634697185, tmp));
  assertEquals(NaN, x /= x);
  assertEquals(0, x >>>= ((tmp = 3075747652, tmp)&(tmp = 819236484, tmp)));
  assertEquals(0, x /= ((1276203810.476657)%(-2434960500.784484)));
  assertEquals(0, x >>>= (tmp = -503633649, tmp));
  assertEquals(-982731931, x |= (-982731931));
  assertEquals(-1965463862, x += x);
  assertEquals(-0.221469672913716, x %= ((tmp = -1742292120, tmp)/x));
  assertEquals(-0.221469672913716, x %= (-2021391941.1839576));
  assertEquals(0, x <<= (((((tmp = -2802447851, tmp)>>((2534456072.6518855)&x))%(tmp = 2841162496.610816, tmp))<<((89341820)/(2565367990.0552235)))>>(tmp = 2700250984.4830647, tmp)));
  assertEquals(0, x >>= x);
  assertEquals(0, x >>= ((tmp = -636189745, tmp)>>>(x/(((tmp = 2634252476, tmp)%(2026595795))>>(tmp = -2048078394.743723, tmp)))));
  assertEquals(NaN, x %= ((x%((((x%((tmp = -2583207106, tmp)&x))|(190357769))<<(tmp = 595856931.2599536, tmp))%x))*((-2433186614.6715775)<<((2856869562.1088696)^(tmp = 1112328003, tmp)))));
  assertEquals(1621713910, x |= (tmp = 1621713910.0282416, tmp));
  assertEquals(3243427820, x += x);
  assertEquals(0, x *= (x&(x-x)));
  assertEquals(0, x >>>= (((2871235439)<<((x+((tmp = -1319445828.9659343, tmp)+(tmp = 1595655077.959171, tmp)))>>(tmp = -86333903, tmp)))-(x/(2907174373.268768))));
  assertEquals(0, x >>= (-1091774077.2173789));
  assertEquals(NaN, x /= x);
  assertEquals(NaN, x *= (tmp = 1976023677.7015994, tmp));
  assertEquals(NaN, x -= (-3013707698));
  assertEquals(NaN, x += ((x+(((tmp = -3119865782.9691515, tmp)<<(1327383504.0158405))^(((-143382411.7239611)>>>((-2157016781)+(((-335815848)/x)<<(tmp = 1953515427, tmp))))&(-2715729178))))/(413738158.2334299)));
  assertEquals(NaN, x %= x);
  assertEquals(NaN, x += (-845480493));
  assertEquals(-789816013, x |= (tmp = -789816013.129916, tmp));
  assertEquals(0, x ^= x);
  assertEquals(0, x <<= (3032573320));
  assertEquals(47630, x ^= ((1086705488)%((x^(tmp = -1610832418, tmp))>>>(tmp = 1136352558, tmp))));
  assertEquals(47630, x >>= (tmp = 1035320352.4269229, tmp));
  assertEquals(47630, x >>= ((((x^x)<<(x*((((x&((-1657468419)*((tmp = -674435523, tmp)&((tmp = 2992300334, tmp)|x))))*((tmp = -489509378.31950426, tmp)*(tmp = 2276316053, tmp)))>>>x)<<x)))%(tmp = -1209988989, tmp))/(tmp = -2080515253.3541622, tmp)));
  assertEquals(3192518951.8129544, x += (3192471321.8129544));
  assertEquals(648116457.8129544, x %= (-2544402494));
  assertEquals(0, x -= x);
  assertEquals(NaN, x /= x);
  assertEquals(NaN, x /= x);
  assertEquals(0, x <<= x);
  assertEquals(0, x >>= x);
  assertEquals(0, x *= (tmp = 30051865, tmp));
  assertEquals(0, x ^= ((x&(((x&x)>>>(((((((x+(2319551861.0414495))>>>(tmp = -3099624461, tmp))^((((tmp = 1574312763, tmp)|x)>>>((-2723797246)&(tmp = -1993956152, tmp)))|(-1830179045)))|(((((((-2545698704.3662167)>>>x)-(((-79478653)|x)%(x+(x>>((tmp = 2386405508.2180576, tmp)/x)))))>>((((-1947911815.2808042)*((x+(368522081.2884482))-(tmp = 2452991210, tmp)))>>(343556643.1123545))>>((((tmp = 1869261547.537739, tmp)>>(3193214755))|x)&(x*(2027025120)))))<<((-1149196187)>>>(814378291.8374172)))+((((((((-160721403)/(2079201480.2186408))+((x|((((tmp = -299595483.16805863, tmp)>>>((x|((x+x)/(-2359032023.9366207)))<<(tmp = -3095108545, tmp)))>>((tmp = -1547963617.9087071, tmp)*(x>>x)))&((tmp = -1568186648.7499216, tmp)+(((2646528453)^(-2004832723.0506048))>>>(tmp = -3188715603.921877, tmp)))))+(tmp = 1578824724, tmp)))^x)^x)/(tmp = -985331362, tmp))|(tmp = 445135036, tmp))<<(tmp = -73386074.43413758, tmp)))+(((-1674995105.9837937)-(tmp = 1392915573, tmp))>>x)))%(tmp = 1215953864, tmp))&((tmp = -439264643.5238693, tmp)>>>x))+(((tmp = 2311895902, tmp)|(1604405793.6399229))&(tmp = -565192829, tmp))))-x))>>(-2455985321)));
  assertEquals(0, x %= ((1177798817)>>(tmp = 2081394163.5420477, tmp)));
  assertEquals(0, x >>>= ((x^(tmp = -41947528.33954811, tmp))>>(x>>>((tmp = 1367644771, tmp)+x))));
  assertEquals(0, x %= ((x+((tmp = 163275724, tmp)<<((tmp = -514460883.3040788, tmp)+x)))|(tmp = -287112073.2482593, tmp)));
  assertEquals(0, x &= (3067975906));
  assertEquals(201342051, x |= (tmp = 201342051, tmp));
  assertEquals(0, x %= (((((-2580351108.8990865)<<(tmp = 2675329316, tmp))&((1338398946)%((-1548041558)+((x>>(-1568233868.7366815))|((x>>((tmp = -1064582207, tmp)/(-1062237014)))>>(tmp = 854123209, tmp))))))<<(((989032887)*(1842748656))%(tmp = -1566983130, tmp)))-x));
  assertEquals(-0, x /= (tmp = -828519512.617768, tmp));
  assertEquals(0, x &= ((((1449608518)+(-1829731972))*(1828894311))*(((tmp = -1121326205.614264, tmp)^(-2057547855))<<(tmp = -2758835896, tmp))));
  assertEquals(NaN, x %= ((tmp = -2138671333, tmp)%x));
  assertEquals(0, x &= x);
  assertEquals(665568613.0328879, x += (665568613.0328879));
  assertEquals(317, x >>= (2627267349.735873));
  assertEquals(0, x -= x);
  assertEquals(0, x &= (((tmp = 3030611035, tmp)*(((tmp = 476143340.933007, tmp)>>(x-(2238302130.2331467)))|(x|x)))%(tmp = 320526262, tmp)));
  assertEquals(0, x <<= (tmp = 729401206, tmp));
  assertEquals(0, x >>>= (1721412276));
  assertEquals(217629949.3530736, x += ((tmp = 217629949.3530736, tmp)%((-931931100.601475)%(x^(tmp = -2149340123.548764, tmp)))));
  assertEquals(217629949.3530736, x %= (tmp = 2275384959.4243402, tmp));
  assertEquals(0, x >>>= (1112677437.5524077));
  assertEquals(0, x *= (500256656.7476063));
  assertEquals(0, x >>>= x);
  assertEquals(0, x -= x);
  assertEquals(0, x -= x);
  assertEquals(0, x &= (-1076968794));
  assertEquals(0, x /= (tmp = 1774420931.0082943, tmp));
  assertEquals(0, x |= x);
  assertEquals(0, x >>= x);
  assertEquals(0, x %= (-2978890122.943079));
  assertEquals(-0, x /= (tmp = -2954608787, tmp));
  assertEquals(-800048201, x ^= ((tmp = -800048201.7227018, tmp)>>>((-2016227566.1480863)/(tmp = -2263395521, tmp))));
  assertEquals(3333, x >>>= (-2038839052));
  assertEquals(487957736.625432, x += (487954403.625432));
  assertEquals(-1650983426, x |= (2643918270));
  assertEquals(-1861867448, x &= (tmp = -251254199.12813115, tmp));
  assertEquals(-7.934314690172143e-18, x %= ((((x^(-703896560.6519544))>>(tmp = -1853262409, tmp))/(tmp = -1168012152.177894, tmp))/(tmp = 837616075.1097361, tmp)));
  assertEquals(0, x ^= x);
  assertEquals(0, x &= (tmp = -2328150260.5399947, tmp));
  assertEquals(-1954860020, x |= (tmp = 2340107276, tmp));
  assertEquals(-1954860020, x >>= ((tmp = 159177341, tmp)*(x&(-705832619))));
  assertEquals(-1954895727, x -= (x>>>((-1443742544.7183702)^((((tmp = 869581714.0137681, tmp)+x)^((x%(tmp = -1036566362.5189383, tmp))^(x%x)))>>x))));
  assertEquals(1.0241361338078498, x /= (tmp = -1908824093.2692068, tmp));
  assertEquals(16777216, x <<= (x*(((-1925197281)^(tmp = -1392300089.4750946, tmp))|x)));
  assertEquals(-225882765524992, x *= (tmp = -13463662, tmp));
  assertEquals(-1845493760, x |= x);
  assertEquals(-1845493760, x %= (tmp = 3181618519.786825, tmp));
  assertEquals(0, x ^= x);
  assertEquals(0, x <<= x);
  assertEquals(0, x >>>= x);
  assertEquals(NaN, x /= (x>>>x));
  assertEquals(NaN, x %= (((((tmp = -521176477, tmp)>>(((tmp = 370693623, tmp)/(((tmp = -1181033022.4136918, tmp)>>(x|(x*(2601660441))))+(tmp = -1696992780, tmp)))|(x|(-1197454193.198036))))>>>(((2512453418.3855605)+((((((tmp = 799501914, tmp)&(((1788580469.7069902)*(((((1476778529.5109258)<<(tmp = -1873387738.3541565, tmp))-((tmp = -521988584.7945764, tmp)*(-1598785351.3914914)))&(-1899161721.8061454))&((x/x)*(690506460))))>>>((tmp = 2255896398.840741, tmp)>>((tmp = -1331486014.6180065, tmp)+(-1159698058.534132)))))*((1112115365.2633948)&((x>>((x>>(-784426389.4693215))&(-492064338.97227573)))>>x)))^((x-((tmp = 2986028023, tmp)>>(tmp = 2347380320.00517, tmp)))*(tmp = -1463851121, tmp)))*(tmp = -1059437133, tmp))%(x-(tmp = 1238739493.7636225, tmp))))^(2029235174)))*(-1923899530))>>>x));
  assertEquals(0, x >>>= (2848792983.510682));
  assertEquals(0, x >>= (((tmp = 3042817032.705198, tmp)>>>x)&((((tmp = -829389221, tmp)-((2669682285.8576303)+(tmp = 1812236814.3082042, tmp)))^x)%((tmp = -2401726554, tmp)^((tmp = 2464685683, tmp)|(-2685039620.224061))))));
  assertEquals(2069649722, x |= (2069649722.311271));
  assertEquals(NaN, x %= (((((-68757739.39282179)&(-1382816369))/(3122326124))<<(x-(-507995800.3369653)))<<(((-1962768567.343907)+((tmp = 1357057125, tmp)/x))^(tmp = 1997617124, tmp))));
  assertEquals(NaN, x += x);
  assertEquals(0, x >>= (26895919));
  assertEquals(0, x >>>= x);
  assertEquals(0, x %= (tmp = 1092448030, tmp));
  assertEquals(0, x <<= (tmp = -477672441.46258235, tmp));
  assertEquals(0, x /= (2113701907));
  assertEquals(0, x >>>= x);
  assertEquals(NaN, x /= x);
  assertEquals(1341078673, x |= (-2953888623));
  assertEquals(1341078673, x &= x);
  assertEquals(0, x %= x);
  assertEquals(414817852.151006, x -= (-414817852.151006));
  assertEquals(1006632960, x <<= ((((((126465614.8316778)+(x-(2511803375)))+(tmp = 1620717148.352402, tmp))*x)/(tmp = -3013745105.5275207, tmp))-((tmp = -418034061.6865432, tmp)/(-300492911))));
  assertEquals(1055624813, x |= (tmp = 921407085, tmp));
  assertEquals(-3, x |= ((((tmp = 1382397819.7507677, tmp)+(tmp = -111851147.7289567, tmp))+x)/((tmp = 247980405.7238742, tmp)^(tmp = -592156399.8577058, tmp))));
  assertEquals(35161, x &= (((((((-2973570544.725141)*(tmp = -1244715638, tmp))+x)<<(x/((x>>>(-2143371615.073137))/(226072236))))%((x-(tmp = 1971392936, tmp))^(tmp = 2653103658, tmp)))%((tmp = 2828319571.7066674, tmp)>>((1528970502)^((tmp = -55869558, tmp)%x))))>>(889380585.6738582)));
  assertEquals(0, x ^= x);
  assertEquals(0, x *= (2749718750));
  assertEquals(0, x >>>= ((((-1633495402.6252813)*(tmp = 2943656739.1108646, tmp))+(tmp = 977432165, tmp))&((tmp = -2338132019, tmp)*(408176349.8061733))));
  assertEquals(-1778794752, x -= (((tmp = -1391412154.5199084, tmp)-((-3172342474)|x))&(1854366052)));
  assertEquals(-1778794752, x %= (tmp = 2024807296.6901965, tmp));
  assertEquals(-1114410.466337204, x %= ((tmp = -240344444.24487805, tmp)%(-47661164)));
  assertEquals(-0, x %= x);
  assertEquals(0, x >>= (x>>x));
  assertEquals(0, x *= x);
  assertEquals(0, x /= ((-3134902611)|(tmp = -3131158951, tmp)));
  assertEquals(-0, x /= (((tmp = 1430247610.634234, tmp)&x)+((tmp = -2047191110.8623483, tmp)-((((x%((((x/(tmp = -2599234213, tmp))|(tmp = 2650380060, tmp))|x)+x))>>>x)&(-1961373866))<<x))));
  assertEquals(-718394682, x -= ((x|(tmp = 1764417670.8577194, tmp))%(1046022988)));
  assertEquals(3576572614, x >>>= (((tmp = 2480472883.078992, tmp)<<x)>>((2035208402.8039393)&(tmp = 492980449, tmp))));
  assertEquals(434034142, x %= (x&((x>>>(311110449.48751545))|(-243530647))));
  assertEquals(524703439.3065736, x += (((tmp = 1392771723.3065736, tmp)%(x&x))%(tmp = -2199704930, tmp)));
  assertEquals(373686272, x &= (x<<((tmp = 2103372351.9456532, tmp)%(tmp = -1367109519, tmp))));
  assertEquals(373686272, x >>= x);
  assertEquals(-0.12245430020241108, x /= (tmp = -3051638622.5907507, tmp));
  assertEquals(1, x /= x);
  assertEquals(1, x %= (3095983855));
  assertEquals(-1454736871, x ^= (x*(tmp = -1454736872, tmp)));
  assertEquals(-1454736866, x ^= (((724989405.7338341)|(tmp = -2834298786.384371, tmp))>>>(tmp = -2029602148.1758833, tmp)));
  assertEquals(-1454736866, x &= x);
  assertEquals(-197394432, x <<= (tmp = -1562128975, tmp));
  assertEquals(251658240, x <<= (tmp = 2126510950, tmp));
  assertEquals(3295700610.703306, x -= (tmp = -3044042370.703306, tmp));
  assertEquals(-51152917, x |= ((949179883.1784958)|(((tmp = -2046168220, tmp)>>(x/x))/(((835064313)*(tmp = 2197600689, tmp))^(((tmp = 2717104216, tmp)&x)<<(-1402661995.3845913))))));
  assertEquals(-1549204421, x ^= ((((tmp = -481013711, tmp)>>>((tmp = 119589341.80209589, tmp)%(-995489985.2905662)))-(635717011))^(x+(x*x))));
  assertEquals(-1078356672.3999934, x += (470847748.6000067));
  assertEquals(1484987268.4638166, x += (tmp = 2563343940.86381, tmp));
  assertEquals(277020804, x &= (tmp = 2532819117, tmp));
  assertEquals(-2097118208, x <<= (x>>>x));
  assertEquals(-2147483648, x <<= (tmp = 761285045, tmp));
  assertEquals(2147483648, x >>>= x);
  assertEquals(-935909870282997800, x *= ((-2583300643)|x));
  assertEquals(-370753566.54721737, x %= (-1084543510.4524941));
  assertEquals(-177, x >>= (-946264747.6588805));
  assertEquals(-416077682, x ^= (tmp = 416077761, tmp));
  assertEquals(NaN, x %= ((((tmp = 779607408, tmp)*(((tmp = -3007128117, tmp)*(851442866.6153773))+x))&(1283388806))/(-876363553)));
  assertEquals(NaN, x %= (x/(tmp = -1668413939.652408, tmp)));
  assertEquals(-1726405921, x ^= (tmp = -1726405921, tmp));
  assertEquals(-1, x >>= ((3031008213.807012)>>x));
  assertEquals(4294967295, x >>>= ((x>>>x)&(tmp = 2788082290, tmp)));
  assertEquals(8544111670008449000, x *= (tmp = 1989331020.0417833, tmp));
  assertEquals(268435456, x <<= (tmp = 3121736017.2098465, tmp));
  assertEquals(-2.1011176170964474e+26, x -= (((tmp = 1392503299, tmp)*(tmp = 1446108825.1572113, tmp))*(x^(tmp = 372776014.213725, tmp))));
  assertEquals(0, x |= x);
  assertEquals(0, x >>= ((-112413907.70074797)*(-702798603)));
  assertEquals(1829518838, x |= (tmp = -2465448458, tmp));
  assertEquals(57172463, x >>= ((tmp = 2979642955.241792, tmp)%(tmp = -2464398693.291434, tmp)));
  assertEquals(114344926, x += x);
  assertEquals(113279134, x &= (2397742238.6877637));
  assertEquals(54, x >>= (1908522709.6377516));
  assertEquals(-2.966982919573829e-7, x /= (tmp = -182003070, tmp));
  assertEquals(0, x <<= (-1078417156));
  assertEquals(-147831390, x ^= (((-147831390)>>>x)+x));
  assertEquals(0, x -= x);
  assertEquals(-242221450.44696307, x -= (tmp = 242221450.44696307, tmp));
  assertEquals(-484442900, x <<= (((tmp = -2033947265.088614, tmp)&x)/(x^(tmp = -2893953848, tmp))));
  assertEquals(-3227648, x <<= (x<<((tmp = -193993010, tmp)*((983187830)|(3146465242.2783365)))));
  assertEquals(-6455296, x += x);
  assertEquals(-1771542585, x -= (x^(tmp = -1767335879, tmp)));
  assertEquals(-0, x %= x);
  assertEquals(0, x >>>= ((((tmp = -1612864670.4532743, tmp)*(tmp = 786265765.210487, tmp))*((((tmp = -893735877.3250401, tmp)*((x^(tmp = -2804782464.233885, tmp))<<x))&(x-x))^x))<<x));
  assertEquals(0, x -= (x>>>(-1648118674.380736)));
  assertEquals(0, x >>= ((tmp = -2706058813.0028524, tmp)>>(2745047169)));
  assertEquals(0, x += x);
  assertEquals(0, x %= (-898267735.137356));
  assertEquals(0, x >>>= x);
  assertEquals(0, x >>= ((265527509)/((tmp = 2190845136.7048635, tmp)+((x>>x)>>>((x%(x-x))&((((-2080184609.8989801)&((-327231633)>>>((tmp = 864849136, tmp)%(((-524363239)*(((((tmp = 2245852565.3713694, tmp)&(1918365.8978698254))>>>(tmp = -2463081769, tmp))-(((2438244059.471446)|((((-135303645.38470244)*(-861663832.2253196))%(tmp = 1273185196.0261836, tmp))|((2261539338.832875)%((320267076.2363237)+x))))>>(tmp = -2731398821, tmp)))/(tmp = -1947938611, tmp)))^x))))>>(tmp = 833666235, tmp))|x))))));
  assertEquals(-1116704570, x ^= (-1116704570));
  assertEquals(1379561710, x ^= (tmp = -280362968.19654894, tmp));
  assertEquals(-1673822208, x <<= x);
  assertEquals(-1673822208, x |= (x<<(tmp = 1389479193.9038138, tmp)));
  assertEquals(2559712, x >>>= (-2703763734.0354066));
  assertEquals(2593499, x ^= (x>>>((tmp = 148668150.03291285, tmp)^(tmp = -1580360304, tmp))));
  assertEquals(2070393855, x |= (tmp = -2227002907, tmp));
  assertEquals(304197770, x &= (tmp = 2453257354, tmp));
  assertEquals(304197770, x <<= ((-669331453.8814087)-(x^(x^(tmp = 33804899.98928583, tmp)))));
  assertEquals(297068, x >>= x);
  assertEquals(Infinity, x /= (x-x));
  assertEquals(NaN, x %= x);
  assertEquals(0, x ^= x);
  assertEquals(0, x %= ((tmp = 1723087085, tmp)%(2859382131.304421)));
  assertEquals(0, x %= (((tmp = 2935439763, tmp)<<(-3163992768.637094))%(tmp = 67176733, tmp)));
  assertEquals(0, x &= (tmp = 2480771277, tmp));
  assertEquals(0, x >>>= (x+(tmp = -3168690063, tmp)));
  assertEquals(0, x *= ((tmp = -1915275449.1806245, tmp)>>>((tmp = -1644482094.1822858, tmp)/(tmp = -432927173, tmp))));
  assertEquals(0, x += (((2766509428.071809)/(x/((942453848.5423365)/(((tmp = -1284574492, tmp)&((tmp = 760186450.7301528, tmp)-(2464974117.358138)))/((x/(x|(672536969)))*(x>>(-1272232579)))))))>>(x*(-3175565978))));
  assertEquals(-1277710521, x -= (1277710521));
  assertEquals(-1277710521, x >>= (((tmp = -2349135858, tmp)-x)-x));
  assertEquals(-1277710521, x >>= ((tmp = 2135645051, tmp)*(tmp = -2468555366, tmp)));
  assertEquals(-155971, x >>= (-1294859507));
  assertEquals(-0, x %= x);
  assertEquals(0, x >>>= (((861078292.6597499)|(-268063679))-(((((-221864206.9494424)-(-3186868203.2201176))&(tmp = 1287132927, tmp))<<(((tmp = 1964887915, tmp)<<((25908382)^(tmp = -688293519.875164, tmp)))*(2075946055)))&(x-((x>>x)&(1395338223.7954774))))));
  assertEquals(788002218, x -= (-788002218));
  assertEquals(716399906, x &= (-1145868506));
  assertEquals(145776674, x &= (-1661931477.360386));
  assertEquals(145776674, x |= x);
  assertEquals(-0.05255700469257692, x /= (tmp = -2773686873, tmp));
  assertEquals(-660918434, x |= (-660918434.2915542));
  assertEquals(1223537346, x ^= (tmp = -1871274596, tmp));
  assertEquals(305884336, x >>= (x&x));
  assertEquals(-1.1123775647978218e-8, x *= ((tmp = -793393031.4229445, tmp)/((tmp = -503919284, tmp)*(((((tmp = 429810625, tmp)>>>x)-((2091544148.870375)<<(((((x^x)%x)|x)/(-260773261))<<((tmp = -1323834653, tmp)&x))))*((-1231800099.3724015)+x))*((x+((-559726167)^x))>>>((-549148877)<<((((tmp = 1196115201, tmp)/((tmp = -2654658968.390111, tmp)%(tmp = -1044419580, tmp)))*(((((x>>>(733571228))+(2919762692.511447))/(-2718451983.570547))^x)+((2891533060.1804514)^((tmp = -2514488663, tmp)&x))))<<(tmp = -2526139641.6733007, tmp))))))));
  assertEquals(0, x >>>= x);
  assertEquals(0, x *= x);
  assertEquals(0, x |= x);
  assertEquals(3076984066.336236, x -= ((tmp = -3076984066.336236, tmp)+((tmp = -446575828.5155368, tmp)&x)));
  assertEquals(1, x /= x);
  assertEquals(1513281647.839972, x *= (1513281647.839972));
  assertEquals(1251138155, x ^= ((tmp = 2124481052, tmp)&(2431937351.4392214)));
  assertEquals(1, x /= x);
  assertEquals(0, x &= (tmp = 627050040, tmp));
  assertEquals(497153016, x ^= (497153016));
  assertEquals(-1112801283, x |= (tmp = 2752196557, tmp));
  assertEquals(0.5735447276296568, x /= ((((tmp = -500878794, tmp)%(tmp = -2559962372.2930336, tmp))%(2661010102))+(tmp = -1439338297, tmp)));
  assertEquals(1.0244795995097235e-9, x /= (559840067));
  assertEquals(0.43468811912309857, x *= (424301391));
  assertEquals(-1972757928, x ^= (tmp = -1972757928.9227014, tmp));
  assertEquals(-606757265, x ^= (tmp = -2923461577.264596, tmp));
  assertEquals(-37, x >>= (((-2736561559.7474318)%(tmp = -27668972.662741184, tmp))*(2774711606)));
  assertEquals(-1923785671, x += ((-1923785597)+x));
  assertEquals(-3877639176, x += (tmp = -1953853505, tmp));
  assertEquals(-4688259242, x -= ((810620066.4394455)>>(((-1474285107.459875)>>x)/(((((-570672326.4007359)>>(tmp = -3086802075, tmp))%x)>>>(((tmp = 286938819.28193486, tmp)>>>((1712478502)>>(tmp = 3045149117.796816, tmp)))<<(tmp = 750463263.292952, tmp)))&(tmp = 2055350255.5669963, tmp)))));
  assertEquals(-0, x %= x);
  assertEquals(0, x <<= (1037856162.5105649));
  assertEquals(0, x *= x);
  assertEquals(0, x &= (997845077.4917375));
  assertEquals(0, x *= x);
  assertEquals(0, x *= x);
  assertEquals(0, x <<= (((x<<x)&(57691805))>>(786927663)));
  assertEquals(0, x ^= x);
  assertEquals(0, x += x);
  assertEquals(0, x &= (-2131910624.1429484));
  assertEquals(0, x >>>= (-43787814));
  assertEquals(-2415062021, x += (tmp = -2415062021, tmp));
  assertEquals(-4830124042, x += x);
  assertEquals(-186683401, x |= (tmp = 1960135383, tmp));
  assertEquals(NaN, x *= ((tmp = -1674740173.9864025, tmp)%(((((((-432895485.7261934)-x)^x)>>>(((-1627743078.3383338)>>(179992151))<<((tmp = 911484278.0555259, tmp)|(((tmp = -3042492703, tmp)>>(((-663866035.302746)>>(((x-((440661929.50030375)>>>(tmp = 263692082, tmp)))*x)+x))/((1546004407)^(((tmp = 2023662889.1594632, tmp)*(tmp = -2456602312, tmp))+(tmp = 755602286.1810379, tmp)))))%((tmp = -336449961, tmp)|(tmp = 206780145, tmp))))))/(1068005219.1508512))<<(tmp = -474008862.6864624, tmp))/(((((((1518711056.5437899)>>>(tmp = 287418286.63085747, tmp))<<(tmp = 2823048707, tmp))^(((x<<(x^(-1600970311)))&(x>>(((tmp = 157300110.7636031, tmp)*(tmp = -3047000529, tmp))&(1743024951.3535223))))>>x))-(tmp = -2895435807, tmp))*((tmp = -314120704, tmp)&(tmp = 1759205369, tmp)))>>(tmp = 1833555960.046526, tmp)))));
  assertEquals(NaN, x -= (tmp = 694955369, tmp));
  assertEquals(NaN, x *= (x%x));
  assertEquals(0, x |= x);
  assertEquals(0, x ^= x);
  assertEquals(0, x &= x);
  assertEquals(NaN, x /= (x+x));
  assertEquals(NaN, x %= ((tmp = -1595988845, tmp)*((1754043345)>>>(-601631332))));
  assertEquals(0, x >>>= (tmp = 862768754.5445609, tmp));
  assertEquals(NaN, x /= x);
  assertEquals(NaN, x %= x);
  assertEquals(NaN, x *= (tmp = -1774545519, tmp));
  assertEquals(0, x >>>= (tmp = -2492937784, tmp));
  assertEquals(0, x %= ((((x<<(-1657262788.2028513))&((x^(tmp = -671811451, tmp))<<(-2984124996)))^(1455422699.7504625))-((-340550620)>>x)));
  assertEquals(918278025, x ^= ((tmp = -918278027, tmp)^((tmp = 2889422870, tmp)/(tmp = -657306935.7725658, tmp))));
  assertEquals(918278025, x %= (2603186571.0582614));
  assertEquals(107034679.32509923, x %= (tmp = -811243345.6749008, tmp));
  assertEquals(53517339, x >>= (x%((((x*((tmp = -983766424, tmp)^(-1881545357.8686862)))|(tmp = -1429937087, tmp))>>((x<<x)>>((((tmp = -2347470476, tmp)&x)+((x&x)<<(396061331.6476157)))*(tmp = -3136296453.209073, tmp))))>>>(((tmp = 908427836, tmp)|(tmp = 207737064, tmp))|(((1253036041)-(tmp = 2705074182, tmp))+(-431215157.82083917))))));
  assertEquals(53477378, x &= ((((-1128036654.165636)*x)+x)>>(x>>(3080099059))));
  assertEquals(0, x >>= (-590692293));
  assertEquals(0, x %= (-2395850570.9700127));
  assertEquals(0, x *= ((tmp = 1377485272, tmp)&(1129370608)));
  assertEquals(0, x += (x>>>(x%(((((tmp = -1746827236, tmp)+((tmp = -326913490, tmp)&((-58256967)&x)))*(tmp = -1176487022.001651, tmp))>>>(-2089147643))-x))));
  assertEquals(0, x <<= (tmp = 1073298160.2914447, tmp));
  assertEquals(-837811832, x ^= (-837811832));
  assertEquals(102760448, x <<= (tmp = 2833582450.4544373, tmp));
  assertEquals(0, x &= (((((((tmp = 2595641175, tmp)*x)+(tmp = -2049260172.1025927, tmp))%((2986747823)>>(tmp = -2120598518, tmp)))&((tmp = -2742408622, tmp)&x))>>x)*((1043474247.9601482)&(tmp = 1686365779.9885998, tmp))));
  assertEquals(0, x >>= ((tmp = 1717862848, tmp)-(tmp = 1077024446.4160957, tmp)));
  assertEquals(NaN, x /= x);
  assertEquals(NaN, x /= (-1669429787.975099));
  assertEquals(NaN, x -= (-2299895633.4807186));
  assertEquals(138173970, x ^= (138173970.56627905));
  assertEquals(-2084183776, x <<= (3073345316));
  assertEquals(-0, x %= x);
  assertEquals(0, x >>= (-3080556066.068573));
  assertEquals(0, x &= ((tmp = -2587514820, tmp)*(x-((x^(1995672257))*(1125326747.2339358)))));
  assertEquals(NaN, x %= x);
  assertEquals(0, x >>= (tmp = 2139186585, tmp));
  assertEquals(-1904096640, x |= ((-602301360.1919911)*(-1270444810)));
  assertEquals(1073741824, x <<= (tmp = -1069467849, tmp));
  assertEquals(1073741824, x ^= (x-x));
  assertEquals(536870912, x >>>= (-1579466367.160293));
  assertEquals(512, x >>= (972402804.3890183));
  assertEquals(512, x &= (tmp = 2664796831, tmp));
  assertEquals(16777216, x <<= (-2738292561));
  assertEquals(0, x >>>= ((((1397663615.3889246)|(1117420260.6730964))-(-1173734560))<<((tmp = 1007006104.0172879, tmp)<<((tmp = -623002097, tmp)%(tmp = -35829654.379403114, tmp)))));
  assertEquals(1200191544, x ^= (tmp = -3094775752, tmp));
  assertEquals(71, x >>>= x);
  assertEquals(71, x |= x);
  assertEquals(1394763772, x += (1394763701));
  assertEquals(-1.492717171027427, x /= ((x&(tmp = 1243787435, tmp))-(2043911970.26752)));
  assertEquals(-1.1002448961224718e-8, x /= ((((835185744)*(((tmp = 2165818437, tmp)^(tmp = 2567417009.1166553, tmp))/x))/x)/(((63485842.39971793)^(2668248282.597389))/x)));
  assertEquals(0, x <<= (tmp = 1598238578.637568, tmp));
  assertEquals(0, x |= (x&((tmp = -1812945547.5373957, tmp)>>>x)));
  assertEquals(0, x >>>= (x+(-1969679729.7299538)));
  assertEquals(1582033662, x += (tmp = 1582033662, tmp));
  assertEquals(1, x >>>= x);
  assertEquals(-550748739, x += ((tmp = -550748740, tmp)/(x&((2537822642.235506)^((-2167656297)%(tmp = 1161201210, tmp))))));
  assertEquals(-268921, x >>= (tmp = 1916069547.7381654, tmp));
  assertEquals(-0.00021776939364231114, x /= (tmp = 1234888868, tmp));
  assertEquals(0, x <<= (-1036375023));
  assertEquals(0, x &= ((((x/(2398886792.27443))&(x|((-1813057854.1797302)-x)))&(x/(((tmp = 3091133731.4967556, tmp)|(3013139691.823039))<<x)))>>>(2542784636.963599)));
  assertEquals(0, x += ((x*x)/(tmp = 347079383, tmp)));
  assertEquals(788347904, x |= ((1462257124.6374629)*((3180592147.4065146)-(x&(1922244678)))));
  assertEquals(2130672735, x |= (tmp = -2846986145, tmp));
  assertEquals(-1331327970, x ^= ((656251304)-(tmp = 1489152359, tmp)));
  assertEquals(-0.14377179742889856, x %= (((2889747597.813753)-(1730428996))/(((tmp = -1378710998, tmp)&x)|x)));
  assertEquals(-1754612583.143772, x += ((-1754725729)^((-2285838408)>>>(1434074349))));
  assertEquals(-0, x %= x);
  assertEquals(0, x &= (tmp = -1031961332, tmp));
  assertEquals(NaN, x /= x);
  assertEquals(NaN, x /= (3059476325));
  assertEquals(NaN, x *= ((x*((((tmp = 13529540.462185979, tmp)&x)^((x<<(-1312696238.1628869))&(-2029766712.3852897)))>>x))/x));
  assertEquals(1657339940, x ^= ((tmp = -488956817.1491232, tmp)&(tmp = -2352413900.1983714, tmp)));
  assertEquals(-530683621952432200, x *= (tmp = -320202035.2882054, tmp));
  assertEquals(229226258, x ^= ((tmp = -1263410990.026416, tmp)+(((-808046349)&(tmp = -1294442506, tmp))&((tmp = 1147437219, tmp)<<((tmp = -820299900, tmp)-(tmp = -1947748943.3443851, tmp))))));
  assertEquals(7163320, x >>= (-2631307131));
  assertEquals(-68, x |= (((-1271721343)>>x)%x));
  assertEquals(-39956523818.38862, x *= (587595938.505715));
  assertEquals(0, x -= x);
  assertEquals(0, x >>>= ((x^(x+x))<<(tmp = 265212367, tmp)));
  assertEquals(0, x |= (((x>>((tmp = 2294761023, tmp)/(x>>(2125624288))))&((-2125650113)|(tmp = 1014409884, tmp)))%(tmp = -527324757, tmp)));
  assertEquals(0, x >>= ((tmp = 2267075595, tmp)*(-1681569641.8304193)));
  assertEquals(0, x >>>= x);
  assertEquals(0.5738410949707031, x -= ((tmp = -1846572645.573841, tmp)%((((((x^(((-156613905.64173532)/x)<<x))+((x|((2405109060)>>>x))^x))/(570585894.8542807))+(x&(-2544708558)))^((((tmp = -2539082152.490635, tmp)+((((-657138283)/(2204743293))-((tmp = -1422552246.565012, tmp)+x))<<(x-x)))>>(x/(x>>>(tmp = -3027022305.484394, tmp))))<<x))&((-2066650303.3258202)/(tmp = -1666842593.0050385, tmp)))));
  assertEquals(0, x >>>= ((((tmp = 2473451837.613817, tmp)>>((2526373359.1434193)>>(x<<x)))+((tmp = -579162065, tmp)+((tmp = -3115798169.551487, tmp)-(tmp = 933004398.9618305, tmp))))&(tmp = 131167062, tmp)));
  assertEquals(-2067675316, x ^= (-2067675316.6300585));
  assertEquals(543772, x >>>= x);
  assertEquals(-1073741824, x <<= x);
  assertEquals(3221225472, x >>>= ((x*(1478586441.081221))&(tmp = -3050416829.2279186, tmp)));
  assertEquals(0, x ^= x);
  assertEquals(0, x *= x);
  assertEquals(-1017771903.0298333, x -= (1017771903.0298333));
  assertEquals(0.6404112721149928, x /= ((tmp = -144667370, tmp)^(-2849599562)));
  assertEquals(-2410517638773644000, x -= (((tmp = 1759631550, tmp)*x)*((((tmp = -2949481475, tmp)>>>x)*x)|(tmp = -2977983804, tmp))));
  assertEquals(-0, x %= (x+((((tmp = -1307866327.7569134, tmp)<<((x&((tmp = -2380043169.8405933, tmp)|x))>>(472992789.7639668)))|(((((x<<(tmp = -1416427232.7298179, tmp))%(-1404989679.409946))*((x/(tmp = -992416608, tmp))/(tmp = 524646495, tmp)))-(tmp = 734405570, tmp))>>x))/(1079256317.7325506))));
  assertEquals(0, x <<= (tmp = 2459834668, tmp));
  assertEquals(-0, x /= (tmp = -1892164840.5719755, tmp));
  assertEquals(0, x >>= (x|(((1299844244)>>>(((tmp = -2422924469.9824634, tmp)|x)-((((1914590293.2194016)+(-3033885853.8243046))-((tmp = -1720088308, tmp)%x))<<(tmp = 2210817619, tmp))))<<x)));
  assertEquals(0, x <<= (((tmp = 3192483902.841396, tmp)>>>(((x^(2944537154))|(tmp = -1334426566, tmp))*(((((((-2705218389)&x)+(1987320749))+(tmp = -111851605, tmp))|(2894234323))-(265580345))&x)))%(((tmp = 1431928204.6987057, tmp)&(tmp = 914901046, tmp))&(x>>>x))));
  assertEquals(0, x >>>= (tmp = 1941940941, tmp));
  assertEquals(0, x %= (3089014384));
  assertEquals(0, x += ((tmp = 2948646615, tmp)*x));
  assertEquals(-0, x /= (tmp = -1480146895, tmp));
  assertEquals(NaN, x /= x);
  assertEquals(NaN, x %= (-2995257724.158043));
  assertEquals(NaN, x %= (tmp = 2714835455, tmp));
  assertEquals(NaN, x /= (tmp = -311440765.98078775, tmp));
  assertEquals(NaN, x -= (-1600234513.697098));
  assertEquals(0, x <<= x);
  assertEquals(0, x <<= (-1499045929));
  assertEquals(-0, x *= (-2491783113));
  assertEquals(0, x ^= (x%((x>>(((1234398704.3681123)>>>x)%(x+x)))>>(402257223.4673699))));
  assertEquals(-643225204, x ^= (((-55960194.698637486)+((((721411198)-(((tmp = 1308676208.7953796, tmp)%(2242904895))-x))>>((((tmp = 332791012, tmp)&((tmp = -2094787948, tmp)/((x/(2427791092))^(2444944499.6414557))))%(((x+(1253986263.5049214))+(((((3135584075.248715)+((tmp = -2569819028.5414333, tmp)%(440908176.1619092)))>>>(x<<((3061615025)-x)))%x)%(x+((2369612016)*((((tmp = 1173615806, tmp)*(-1910894327))&(2428053015.077821))*(-55668334.70082307))))))<<(tmp = -2129259989.0307562, tmp)))+(1579400360)))%((-3053590451.8996153)>>x)))+(x>>(x%(x^((-1772493876)^x))))));
  assertEquals(413738663060841600, x *= x);
  assertEquals(1581062538.4501781, x %= ((tmp = -1298397672.0300272, tmp)-((2237197923)+(tmp = -1385478459, tmp))));
  assertEquals(755644566.8709538, x %= (tmp = -825417971.5792243, tmp));
  assertEquals(1, x /= x);
  assertEquals(0, x >>>= ((89330582)%(-1012731642.4855506)));
  assertEquals(0, x >>>= x);
  assertEquals(NaN, x %= ((x>>>((x/(tmp = -1848848941.2352903, tmp))>>>(tmp = -71862893, tmp)))&(-2385996598.2015553)));
  assertEquals(NaN, x += (-2292484503.318904));
  assertEquals(NaN, x *= (2961064461));
  assertEquals(NaN, x += (x<<((2076798243.6442)/((tmp = -81541044.75366282, tmp)^((3041366498.551101)+((2126874365)/(tmp = -177610359, tmp)))))));
  assertEquals(NaN, x %= ((x/((x/x)+x))>>>x));
  assertEquals(NaN, x /= x);
  assertEquals(NaN, x += (1171761980.678));
  assertEquals(NaN, x += ((2355675823)<<(-390497521)));
  assertEquals(NaN, x %= x);
  assertEquals(0, x &= (tmp = -658428225.56619, tmp));
  assertEquals(0, x ^= x);
  assertEquals(0, x <<= (1643310725.5713737));
  assertEquals(0, x <<= x);
  assertEquals(0, x <<= (-397005335.3712895));
  assertEquals(0, x >>>= (tmp = -2804713458.166788, tmp));
  assertEquals(0, x <<= (((((((tmp = 1879988501, tmp)%(1528081313.9360204))+(1376936736))*((((x>>>((1736268617.339198)>>>(-2598735297.4277673)))<<((((((((-2742982036)/(231867353.4549594))-(875335564))<<x)|((2241386341.742653)<<((-22024910.828409433)&(x<<x))))*(-756987803.5693252))+x)^(tmp = 1084498737, tmp)))<<(1920373881.8464394))&(2370827451.82652)))&(x^(tmp = -891503574, tmp)))<<x)>>>((-1519588625.2332087)^(483024636.2600144))));
  assertEquals(52193878.40997505, x -= ((tmp = -341753803.40997505, tmp)%(tmp = -96519975, tmp)));
  assertEquals(-1665844168.938803, x -= (1718038047.348778));
  assertEquals(3.6962232549405003e-19, x /= (((((-809583468.5507183)>>>((tmp = 286797763, tmp)%((1579183142.7321532)/(1853824036.001172))))<<x)>>(((x|x)^((tmp = -2641304815, tmp)<<(x<<x)))>>(((((268338128.8300134)&(-1778318362.8509881))*(751081373.346478))<<(((525066612)>>(-1139761212))*(2949167563.299916)))<<x)))+((tmp = 664905121, tmp)*((-2208280205)*(3069462420)))));
  assertEquals(4710721795.110161, x += (((217604832)+((1307891481.781326)-x))+(tmp = 3185225481.328835, tmp)));
  assertEquals(0, x %= x);
  assertEquals(0, x -= (((x>>>(x/(tmp = 46977522.46204984, tmp)))>>(-2466993199.615269))&(tmp = 14524430.287991166, tmp)));
  assertEquals(0, x >>= x);
  assertEquals(0, x /= (tmp = 578120637, tmp));
  assertEquals(-17267104, x -= (((tmp = 1515285919.495792, tmp)+(((tmp = -1364790286.7057304, tmp)+((954599071)>>((897770243.1509961)*x)))^x))>>>(566027942.1732262)));
  assertEquals(-17267104, x &= x);
  assertEquals(189138241, x ^= ((tmp = 1565742675.9503145, tmp)-((tmp = 1737806643, tmp)|((x*(tmp = -1382435297.5955122, tmp))*(-2820516692.153056)))));
  assertEquals(189138241, x %= (x*(tmp = -1670678493, tmp)));
  assertEquals(1693, x %= ((-2328713314)>>>(1623637325)));
  assertEquals(1693, x %= ((-1019394014)*(x|x)));
  assertEquals(3386, x += x);
  assertEquals(9268970871604, x *= (2737439714));
  assertEquals(-4720.120483643183, x /= (tmp = -1963714889, tmp));
  assertEquals(-1, x >>= ((x^(((-2404688047.455056)|((1439590234.6203847)<<(tmp = -2496557617, tmp)))/((x<<((tmp = 1865549512.282249, tmp)/(((360384191.55661833)>>(tmp = -1225297117.344188, tmp))>>>(2703264010.4122753))))*(1521960888.0071676))))%(tmp = 2834001448.0508294, tmp)));
  assertEquals(63, x >>>= (x&(-3079339174.6490154)));
  assertEquals(0, x >>>= (1039770956.6196513));
  assertEquals(0, x >>>= (-1074820214));
  assertEquals(0, x >>>= (x/x));
  assertEquals(0, x >>= ((tmp = -449117604.2811785, tmp)&x));
  assertEquals(-0, x /= (tmp = -118266935.1241343, tmp));
  assertEquals(2226140134, x += (tmp = 2226140134, tmp));
  assertEquals(2068827161, x ^= ((tmp = -1950744808.846384, tmp)>>((2258661151)^((tmp = -1118176421.8650177, tmp)<<(2828634014)))));
  assertEquals(123, x >>>= (-1779624840.0515127));
  assertEquals(0, x >>>= (x|((tmp = -239082904, tmp)<<(tmp = 1404827607, tmp))));
  assertEquals(0, x >>>= x);
  assertEquals(1793109749, x ^= (tmp = -2501857547.710491, tmp));
  assertEquals(855, x >>>= x);
  assertEquals(0, x >>>= (-847289833));
  assertEquals(0, x %= (-2271241045));
  assertEquals(169648072, x ^= (((tmp = 169648072.66759944, tmp)^x)|x));
  assertEquals(176025927479164930, x *= ((tmp = 1111997198.8803885, tmp)<<(tmp = 2913623691, tmp)));
  assertEquals(176025926613281700, x += ((tmp = -865883245, tmp)<<(x+(-2624661650))));
  assertEquals(3406506912, x >>>= ((x|(tmp = 2436016535, tmp))*(((tmp = -1222337225, tmp)<<((1765930268)&x))*(tmp = 1600702938, tmp))));
  assertEquals(1.694694170868292, x %= (x/(-1597121830.794548)));
  assertEquals(0, x >>= (tmp = -2443203089, tmp));
  assertEquals(0, x >>>= (1323174858.2229874));
  assertEquals(0, x &= ((tmp = 846556929.2764134, tmp)|(((1483000635.0020065)|(-3151225553))|(tmp = -229028309, tmp))));
  assertEquals(0, x >>= x);
  assertEquals(0, x >>= ((((((-2677334787)>>>x)>>((tmp = 496077992, tmp)&((((x<<(x*(tmp = 1095163344.2352686, tmp)))+(-952017952))%((x<<((x*x)/(tmp = 2983152477, tmp)))^((tmp = -939521852.1514642, tmp)^(tmp = 143967625.83755958, tmp))))*((tmp = 551827709.8366535, tmp)>>>x))))^((-1552681253.69869)-(-1874069995)))>>>(x>>(x%(tmp = -2554673215, tmp))))|(tmp = -190693051.77664518, tmp)));
  assertEquals(0, x /= (tmp = 427402761.37668264, tmp));
  assertEquals(0, x <<= x);
  assertEquals(0, x |= (x>>>(((((-543326164.0673618)>>>(-2344090136.707964))>>>((((-563350246.6026886)/x)/(1525481037.3332934))&(tmp = -2917983401.88958, tmp)))^(-1094667845.1208413))^x)));
  assertEquals(0, x &= (1080322749.897747));
  assertEquals(0, x %= (tmp = -1572157280, tmp));
  assertEquals(0, x >>>= x);
  assertEquals(0, x %= ((377280936)|x));
  assertEquals(708335912, x -= (tmp = -708335912, tmp));
  assertEquals(2766937, x >>>= x);
  assertEquals(547342779, x += (tmp = 544575842, tmp));
  assertEquals(546273751, x -= ((x>>>(472833385.9560914))|((tmp = -1164832103.9970903, tmp)/(3147856452.1699758))));
  assertEquals(546273751, x &= x);
  assertEquals(0, x ^= x);
  assertEquals(0, x >>>= (tmp = -3181805175, tmp));
  assertEquals(-375546685, x |= (-375546685.08261824));
  assertEquals(1089992785780217200, x *= (tmp = -2902416209, tmp));
  assertEquals(0, x %= x);
  assertEquals(-1854981526, x -= ((x-x)-(-1854981526)));
  assertEquals(-3709963052, x += x);
  assertEquals(-316772482, x %= (tmp = -1696595285, tmp));
  assertEquals(-316772482, x |= x);
  assertEquals(1, x /= x);
  assertEquals(0, x -= x);
  assertEquals(-1418375842, x ^= (-1418375842));
  assertEquals(-2, x >>= x);
  assertEquals(-4, x += x);
  assertEquals(-8388608, x &= (x<<(-350555339.30086184)));
  assertEquals(-16777216, x += x);
  assertEquals(-0, x %= x);
  assertEquals(1083355129, x += (tmp = 1083355129, tmp));
  assertEquals(0, x &= (((tmp = 389729053, tmp)-(tmp = 2944192190.0939536, tmp))/(x-(2081712461.2657034))));
  assertEquals(0, x += x);
  assertEquals(-3, x += ((3147270119.5831738)>>((2455837253.1801558)%((-2100649096)>>(((290236808.01408327)|(x&((2661741230.3235292)|((tmp = 1686874589.4690177, tmp)<<x))))*(x+(tmp = 2327674670, tmp)))))));
  assertEquals(-3, x %= ((x>>(((-2962686431)%x)>>((((2438370783)-(tmp = 2667305770.4839745, tmp))>>>x)>>>x)))<<((x&(tmp = 1428498616, tmp))|((tmp = 2621728539.102742, tmp)/(-204559901)))));
  assertEquals(2, x ^= (x|((((tmp = 1751230118.6865973, tmp)/(-867465831.207304))>>((-808143600.0912395)+(-2882191493.0506454)))^x)));
  assertEquals(2, x %= (-2015954220.2250996));
  assertEquals(0, x >>>= (tmp = 401373999, tmp));
  assertEquals(0, x >>= (2371830723));
  assertEquals(0, x >>>= ((((tmp = 2765919396, tmp)-x)-(530310269.7131671))|(tmp = -615761207.9006102, tmp)));
  assertEquals(-145389011, x ^= (tmp = -145389011, tmp));
  assertEquals(-145389011, x |= x);
  assertEquals(1632929832, x &= (-2518898392));
  assertEquals(4190540017.751949, x += (tmp = 2557610185.751949, tmp));
  assertEquals(4980024282.153588, x += ((1841304364.1177452)%(tmp = 1051820099.7161053, tmp)));
  assertEquals(0, x >>>= (((((1379314342.4233718)>>((-2782805860)^((x%(tmp = 1328845288, tmp))>>>(tmp = 901403219.858733, tmp))))+(x/((tmp = -3078904299, tmp)/x)))/x)|(x|(1399702815))));
  assertEquals(-1820494882, x ^= (tmp = -1820494882.407127, tmp));
  assertEquals(-305870376, x %= (tmp = -757312253, tmp));
  assertEquals(-577530443, x += (x|(tmp = -1958083619.6653333, tmp)));
  assertEquals(333541412591776260, x *= x);
  assertEquals(-949341696, x >>= ((((1550069663)<<((x>>>(tmp = 2406565178.902887, tmp))>>>((1844746612.632984)/((tmp = 2233757197, tmp)*((-1524891464.1028347)>>(tmp = 2498623474.5616803, tmp))))))&x)<<(x&(tmp = -370379833.3884752, tmp))));
  assertEquals(-277202090, x |= ((-762200848.8405354)-(tmp = 1749136282, tmp)));
  assertEquals(0.13704539927239265, x /= (tmp = -2022702633.373563, tmp));
  assertEquals(0, x -= x);
  assertEquals(0, x %= ((132951580.19304836)-((427623236.27544415)-(1212242858))));
  assertEquals(0, x &= ((449148576)&(-1609588210.249217)));
  assertEquals(0, x >>= x);
  assertEquals(0, x -= x);
  assertEquals(-0, x /= (tmp = -1640777090.9694843, tmp));
  assertEquals(0, x &= (((tmp = -1923412153, tmp)>>>((x>>(tmp = 3027958119.0651507, tmp))+(60243350)))>>(tmp = -2610106062, tmp)));
  assertEquals(0, x ^= (((-186998676)/(tmp = 2697937056, tmp))-x));
  assertEquals(-1147950080, x |= ((2425449461)*(tmp = -2525854833, tmp)));
  assertEquals(457688198, x ^= (2698274950.660941));
  assertEquals(8724, x %= ((1174351031)>>>((371599047.36048746)+(3025292010))));
  assertEquals(0, x <<= (tmp = -710011617, tmp));
  assertEquals(0, x >>>= (1693410026));
  assertEquals(1443005362, x ^= ((tmp = -2851961934, tmp)+((((x%x)-(tmp = 547622400, tmp))<<(((tmp = 722396486.5553623, tmp)|x)>>>((((tmp = -542268973.5080287, tmp)<<(tmp = 1347854903.771954, tmp))>>>(tmp = -889664427.7115686, tmp))&((tmp = 1549560114, tmp)*(tmp = 964918035, tmp)))))&(-2422502602.920377))));
  assertEquals(3986573462, x -= (-2543568100));
  assertEquals(7973146924, x += x);
  assertEquals(-1, x >>= (-75987297));
  assertEquals(-12, x += ((2940824338.64834)>>(tmp = 3061467355, tmp)));
  assertEquals(-3.8229398525977614e-8, x /= (313894554));
  assertEquals(-2.890709270374084e-17, x /= (tmp = 1322491989, tmp));
  assertEquals(0, x |= (x-x));
  assertEquals(0, x >>>= (tmp = -1205300664, tmp));
  assertEquals(-0, x /= (((2869505187.6914144)>>(tmp = 1541407065, tmp))/(((-571132581)>>>(x>>x))/((x^(170373762.8793683))>>>((((tmp = -363073421.05897164, tmp)|(((tmp = -1591421637, tmp)>>(1095719702.8838692))&(636687681.9145031)))^x)^(x|x))))));
  assertEquals(-1487828433, x ^= (-1487828433.3462324));
  assertEquals(-0, x %= x);
  assertEquals(1716342498, x -= ((tmp = 2578624798, tmp)^x));
  assertEquals(1636, x >>= ((264194540)>>>(-801900756)));
  assertEquals(0, x >>>= ((tmp = 2502688876, tmp)+((x<<(x|((-628272226.0338528)|((x<<(-2083074091))>>>(tmp = 1692123246.8418589, tmp)))))>>(1594759826.990993))));
  assertEquals(0, x <<= (tmp = -904399643, tmp));
  assertEquals(NaN, x /= ((x^(x-x))%((tmp = 1744962024.4882128, tmp)%x)));
  assertEquals(NaN, x /= (-1013142883.1845908));
  assertEquals(NaN, x /= ((tmp = 793633198, tmp)^(-2993598490.8659954)));
  assertEquals(0, x &= (x>>((tmp = 1200937851, tmp)<<(((tmp = -2807378465, tmp)&(tmp = -143778237, tmp))|(tmp = -1200772223, tmp)))));
  assertEquals(0, x <<= x);
  assertEquals(88144, x |= (((((tmp = 3002723937.8560686, tmp)*(tmp = -3171720774.2612267, tmp))%(((tmp = -2586705978.7271833, tmp)%((x+(-1553704278))&(2405085526.501994)))>>((-240842053)>>>(((((tmp = -1886367228.4794896, tmp)>>>x)^(tmp = 2604098316, tmp))^(tmp = 1362808529, tmp))<<((tmp = -1062263918, tmp)|((-172718753)%(tmp = -1910172365.4882073, tmp)))))))^((1444153362)>>((x&((-1205465523.2604182)^(tmp = -2062463383, tmp)))>>(tmp = 956712476, tmp))))>>((((-1004215312)^((((-1707378612.5424936)^(tmp = 2372161553, tmp))/((tmp = 1802586581, tmp)*((2082257.1896460056)&((tmp = -1270773477, tmp)^(tmp = 942517360.3447798, tmp)))))+x))%((((666494127)^(x^x))>>>(tmp = -2592829775, tmp))+((-1601528223)+((x+(tmp = -2417034771.7409983, tmp))>>>((tmp = -730673817, tmp)*x)))))>>x)));
  assertEquals(-2603179111.7557006, x -= ((2603267255.755627)+(x/(1200979191.2823262))));
  assertEquals(1691788185, x >>= (tmp = 3088840032, tmp));
  assertEquals(-168382533, x |= (tmp = -780750941.4590135, tmp));
  assertEquals(-168382533, x >>= (60741120.48285198));
  assertEquals(-134287365, x |= (x*(tmp = 834637940.7151251, tmp)));
  assertEquals(-1481917089, x -= (tmp = 1347629724, tmp));
  assertEquals(1, x >>>= x);
  assertEquals(262144, x <<= (2680216914));
  assertEquals(1075132032, x ^= (x-((tmp = 3220359552.3398685, tmp)^(((-434474746.6039338)|((((((((tmp = 1945689314.9683735, tmp)>>(1300022273))>>>(333705550))&x)%(588357521))-(x+(x^(((tmp = -134560382, tmp)+x)-((((994246147.7195556)-(-1506599689.7383268))%(x<<x))>>((1256426985.5269494)+(tmp = 1860295952.8232574, tmp)))))))^(((tmp = 917333220.2226384, tmp)>>x)>>>(tmp = 865898066, tmp)))%((x|(x%((tmp = -2660580370, tmp)&(tmp = 2966426022, tmp))))*x)))/(((tmp = 682585452, tmp)&(-3219368609))+((tmp = -1330253964, tmp)+((x&(2857161427))/x)))))));
  assertEquals(274944, x &= ((2606953028.1319966)-(-1707165702)));
  assertEquals(266752, x &= ((x<<((x+(x+(x^(-1570175484))))^x))^(x+(x<<(tmp = 90330700.84649956, tmp)))));
  assertEquals(266752, x &= ((((x*(tmp = 2033225408, tmp))-(x-((tmp = 1507658653, tmp)/(-3016036094))))>>>((1497480588)>>(2784070758)))|(tmp = -3025904401.93921, tmp)));
  assertEquals(-1680442631, x |= ((x/(445284843))|((tmp = 2614520057.2723284, tmp)<<x)));
  assertEquals(40851947, x >>>= (tmp = -1577031386.938616, tmp));
  assertEquals(2493, x >>= ((3044630989.3662357)-(-2670572992.8580284)));
  assertEquals(-0.0000017317105653562252, x /= (-1439617017.9207587));
  assertEquals(0, x &= (2359806567));
  assertEquals(623768541, x ^= (623768541));
  assertEquals(1028567149.0716183, x += (((tmp = 1307794561, tmp)%(x>>x))-(-404798608.0716183)));
  assertEquals(-1.2971762489811298, x /= (tmp = -792927830.6471529, tmp));
  assertEquals(-1.2971762489811298, x %= ((-2426421701.2490773)/(-689566815.3393874)));
  assertEquals(-2147483648, x <<= x);
  assertEquals(-2147483648, x &= (tmp = -869991477, tmp));
  assertEquals(-268435456, x >>= (1383186659));
  assertEquals(0, x -= x);
  assertEquals(-2009742037, x |= (-2009742037.5389993));
  assertEquals(-1386630820, x ^= (627864695));
  assertEquals(-1033479103975173600, x *= (tmp = 745316697.9046186, tmp));
  assertEquals(-1628048487, x |= (2662654361));
  assertEquals(325551, x >>>= (340874477));
  assertEquals(-1235730537, x ^= (tmp = 3059533880.0725217, tmp));
  assertEquals(-1235730537, x %= (2247137328));
  assertEquals(-220200960, x <<= ((x>>x)-x));
  assertEquals(0, x <<= ((tmp = 337220439.90653336, tmp)|(tmp = 2901619168.375105, tmp)));
  assertEquals(0, x >>>= ((-2114406183)/x));
  assertEquals(0, x %= ((1425828626.3896675)/x));
  assertEquals(0, x >>>= ((3213757494)>>>(2595550834.3436537)));
  assertEquals(0, x <<= x);
  assertEquals(-0, x /= ((1544519069.5634403)/((tmp = -1332146306, tmp)&(-762835430.0022461))));
  assertEquals(0, x ^= x);
  assertEquals(0, x >>= (x|((((x*((-786272700)+x))<<x)+((tmp = -1868484904, tmp)-(tmp = -1692200376, tmp)))+(-1010450257.6674457))));
  assertEquals(0, x -= x);
  assertEquals(0, x ^= (x>>>(706010741)));
  assertEquals(-964928697, x |= (-964928697));
  assertEquals(1, x /= x);
  assertEquals(0, x >>= ((((tmp = 1778003555.3780043, tmp)>>(x%((tmp = -766158535, tmp)^((-2681449292.8257303)%((x-(x|(tmp = 1966478387.2443752, tmp)))^(((tmp = -1848398085, tmp)&x)>>>(tmp = -2860470842, tmp)))))))%(tmp = 2315077030, tmp))^x));
  assertEquals(0, x ^= x);
  assertEquals(-288007757, x ^= ((tmp = 183607156.1803962, tmp)-(tmp = 471614914, tmp)));
  assertEquals(-270573581, x |= (tmp = -849475741.9424644, tmp));
  assertEquals(-2129929, x |= (((((1942852445)&(tmp = 1280372312, tmp))*(x*(tmp = -1601900291, tmp)))^((509080002.81080174)-(tmp = 2699498226.9164257, tmp)))>>(((-335361221)>>(tmp = 843134832, tmp))%(-35532542))));
  assertEquals(-232622355, x ^= ((-3060885134.5375547)-(((tmp = 1965966723, tmp)-((tmp = 1248630129.6970558, tmp)<<(tmp = 1859637857.5027392, tmp)))*x)));
  assertEquals(-52149658093200070, x *= (224181627.31264615));
  assertEquals(-697122968, x ^= (x-(x+(tmp = 2747211186.407712, tmp))));
  assertEquals(-2146269688, x &= ((tmp = -1466710519, tmp)^(x/(1419998975))));
  assertEquals(-536567422, x >>= (((((tmp = -1760701688.999274, tmp)>>(-1821976334))/(((tmp = -1660849531, tmp)>>>x)-((x+((tmp = -2489545009.4327965, tmp)>>>((tmp = -267360771.39148235, tmp)^x)))*(((-1453528661)%x)>>>(((243967010.3118453)/((((((2977476024)>>>((-1630798246)<<x))&(591563895.2506002))*(((2668543723.9720144)>>>x)|(1600638279)))^x)>>(x<<(tmp = -152589389, tmp))))>>>(x|(2821305924.9225664)))))))+(618968002.8307843))%(tmp = -1005408074.368274, tmp)));
  assertEquals(40962, x &= (114403906));
  assertEquals(19741977727890, x *= ((-2367133915.963945)>>>(-3119344126)));
  assertEquals(1313341440, x <<= x);
  assertEquals(626, x >>>= ((((-333992843)%(tmp = -2742280618.6046286, tmp))>>>x)|x));
  assertEquals(0, x <<= (2598188575));
  assertEquals(NaN, x %= x);
  assertEquals(NaN, x %= x);
  assertEquals(0, x ^= (x%((2507288229.3233204)&(tmp = -1714553169.9276752, tmp))));
  assertEquals(0, x /= ((633436914.3859445)>>>(tmp = 1579804050.6442273, tmp)));
  assertEquals(0, x *= ((tmp = 1172218326, tmp)<<((tmp = -2491306095.8456626, tmp)*(((tmp = 1305371897.9753594, tmp)>>((x^(((3077992060)*x)<<(492815553.904796)))>>((652151523)|x)))%x))));
  assertEquals(0, x <<= x);
  assertEquals(0, x %= (1118131711));
  assertEquals(0, x &= ((tmp = 2734673884, tmp)|(x-((tmp = 2694578672.8975897, tmp)*(((x>>(2350811280.974167))*(1052548515))&(x^(x*(tmp = -1336287059.0982835, tmp))))))));
  assertEquals(-2632782867.1256156, x += ((tmp = -2743992725.1256156, tmp)+(tmp = 111209858, tmp)));
  assertEquals(-0, x %= x);
  assertEquals(0, x >>>= (((tmp = -2050519887, tmp)^(106865302.74529803))>>(1642851915.2909596)));
  assertEquals(-171964826, x |= (tmp = -171964826.6087358, tmp));
  assertEquals(-2.113405951193522, x /= (tmp = 81368572.80206144, tmp));
  assertEquals(3, x >>>= x);
  assertEquals(0, x %= x);
  assertEquals(-1717345907.837667, x += (-1717345907.837667));
  assertEquals(-100964883, x |= (tmp = -109574931.80629134, tmp));
  assertEquals(-33849857, x |= (-974111718.2433801));
  assertEquals(1, x >>>= (tmp = -2556222849.005595, tmp));
  assertEquals(1, x /= x);
  assertEquals(0, x >>>= (-1796630999.4739401));
  assertEquals(0, x >>>= x);
  assertEquals(2031695758, x += (((x/(((tmp = -2364918403, tmp)%(x^((tmp = 277767803.6375599, tmp)>>((((tmp = 540036080, tmp)/(x|(2665298931)))/(x|((x>>(-2035456216.6165116))<<(2143184420.5651584))))^x))))&(tmp = 927798419.8784283, tmp)))-(-2031695758))>>>x));
  assertEquals(2031695758, x |= x);
  assertEquals(2031695758, x <<= (((x>>(x%x))|(tmp = -1164531232.7384055, tmp))*x));
  assertEquals(124004, x >>>= x);
  assertEquals(529846352, x += ((529722348)%((2417645298.865121)|(x>>(x>>>(x+x))))));
  assertEquals(60067920, x &= (((tmp = -3166008541.8486233, tmp)-x)|(x%x)));
  assertEquals(1415594240755200, x *= ((-2786707452.873729)>>(((tmp = -2369315809, tmp)*((1559868465)|(1011218835.1735028)))>>>x)));
  assertEquals(1415595182259140, x += (941503939.9023957));
  assertEquals(0, x <<= ((tmp = 2887184784.265529, tmp)/(-2575891671.0881453)));
  assertEquals(0, x &= ((tmp = -1546339583, tmp)>>>(tmp = -587433830, tmp)));
  assertEquals(0, x *= (((tmp = 1356991166.5990682, tmp)%(tmp = -284401292, tmp))*(1869973719.9757812)));
  assertEquals(NaN, x %= x);
  assertEquals(0, x ^= (((tmp = 92575404.43720293, tmp)>>>(263475358.17717505))%x));
  assertEquals(0, x <<= (((561514358)*(tmp = -439584969, tmp))%((((-3005411368.7172136)+x)|(-2230472917))&x)));
  assertEquals(0, x >>= ((x>>>x)-((x-(1630649280.510933))+x)));
  assertEquals(0, x >>= (tmp = -1772403084.7012017, tmp));
  assertEquals(0, x *= x);
  assertEquals(0, x += x);
  assertEquals(0, x &= x);
  assertEquals(0, x >>= (tmp = 1622680387, tmp));
  assertEquals(1033887633558225200, x -= ((-510616337)*(tmp = 2024783695, tmp)));
  assertEquals(-2.8073538539158063e+27, x *= (tmp = -2715337492, tmp));
  assertEquals(-2.8073538539158063e+27, x -= ((tmp = -1664804757, tmp)&((tmp = -226616419, tmp)>>>(1006711498))));
  assertEquals(1894539615, x |= (tmp = -2400427681.1831083, tmp));
  assertEquals(7400545, x >>= (774629608.4463601));
  assertEquals(456756268, x += (449355723));
  assertEquals(285771784, x &= (-1316427366));
  assertEquals(17, x >>= ((tmp = -220509931.20787525, tmp)*(((tmp = 2518859292, tmp)+(-1477543005.1586645))>>(tmp = 3172820250.687789, tmp))));
  assertEquals(85924262443, x *= (x*((tmp = -2856669745.965829, tmp)&(((tmp = 401420695, tmp)^(tmp = 2355371132, tmp))|(tmp = 590645330.021911, tmp)))));
  assertEquals(1703875715, x ^= ((-2576394029.7843904)-x));
  assertEquals(1703875715, x %= (tmp = 2234144310, tmp));
  assertEquals(271405807, x ^= (1973569132));
  assertEquals(1060178, x >>>= (tmp = -84823096, tmp));
  assertEquals(8, x >>>= (tmp = 2246120561.905554, tmp));
  assertEquals(-2846791089, x += (-2846791097));
  assertEquals(104933962, x &= (x-(-2969030955.99584)));
  assertEquals(489215611.96215343, x -= (-384281649.96215343));
  assertEquals(489215611, x |= x);
  assertEquals(1186191360, x <<= ((tmp = 774407142.993727, tmp)%x));
  assertEquals(1186191360, x %= (1555004022));
  assertEquals(-1697134080, x ^= (tmp = -597421568, tmp));
  assertEquals(-1102053376, x <<= ((-927370769.4059179)^((tmp = 1093490918, tmp)>>(((-2522227493.3821955)%x)+(-2657319903)))));
  assertEquals(1086450058, x ^= (-23991926.187098265));
  assertEquals(1086450058, x |= x);
  assertEquals(-1.6554590588410778, x /= (x|(x<<(x+x))));
  assertEquals(67108863, x >>>= ((-926530233)+x));
  assertEquals(494553310, x ^= (tmp = 512079649, tmp));
  assertEquals(207751168, x &= (2892146720.6261826));
  assertEquals(207751168, x &= x);
  assertEquals(207751168, x |= x);
  assertEquals(6340, x >>>= (((((x<<(x-((-2819638321)*((x<<x)+x))))>>x)+(tmp = 2016170261, tmp))+(tmp = 2755496043.772017, tmp))+(-841368625.1402085)));
  assertEquals(6340, x ^= ((x/(tmp = -192734784, tmp))>>>(((-140306239)&x)-x)));
  assertEquals(1, x /= x);
  assertEquals(0, x >>= x);
  assertEquals(26786600, x ^= (tmp = 26786600, tmp));
  assertEquals(-0.014657576899542954, x /= ((-1454855938.0338)+(-372635753.3681567)));
  assertEquals(0, x &= ((tmp = 2480635933, tmp)&(-2986584704.9165974)));
  assertEquals(-2108639122, x += ((tmp = 2108639123.8683565, tmp)^((-881296055)/(((x<<(2026200582))|(tmp = -862495245.138771, tmp))-(-1111596494.892467)))));
  assertEquals(1893466112, x <<= (tmp = 607974481, tmp));
  assertEquals(1893466112, x |= x);
  assertEquals(1133122783.997418, x += ((tmp = -760343332, tmp)-((x-(tmp = -878561823.4218843, tmp))/(tmp = -693454632.596637, tmp))));
  assertEquals(8, x >>>= (tmp = 700339003.3919828, tmp));
  assertEquals(4.605305035175536e-9, x /= (1737127060.8343256));
  assertEquals(4.605305035175536e-9, x -= ((x%(897221779))>>>x));
  assertEquals(-1864423625.5704088, x += (tmp = -1864423625.5704088, tmp));
  assertEquals(1132240092, x <<= (1304417186.1193643));
  assertEquals(-2088985380, x ^= (x<<x));
  assertEquals(-4, x >>= ((tmp = 1959823884.0935726, tmp)%(-1679792398.569136)));
  assertEquals(-268435456, x <<= ((tmp = 2586838136, tmp)|((tmp = -481716750.718518, tmp)>>>((1485826674.882607)/(tmp = -2826294011, tmp)))));
  assertEquals(-32768, x >>= (2060648973));
  assertEquals(1, x /= x);
  assertEquals(-2838976297, x -= (tmp = 2838976298, tmp));
  assertEquals(-1382985298, x <<= ((tmp = -2104305023, tmp)&x));
  assertEquals(10, x >>>= (x+x));
  assertEquals(10, x -= (x>>>(361588901.70779836)));
  assertEquals(854603510, x -= (-854603500));
  assertEquals(-557842432, x <<= (tmp = 1212985813.6094751, tmp));
  assertEquals(-459390188241943040, x *= (tmp = 823512450.6304014, tmp));
  assertEquals(-232800033621957060, x /= ((((((686635689)/(tmp = 2013252543, tmp))*(tmp = -1591617746.8678951, tmp))|(((tmp = -1777454093.5611362, tmp)>>>((tmp = 2680809394, tmp)^(((x>>((((((tmp = -265022244, tmp)%((tmp = -3075004537, tmp)>>(((((1427784269.5686688)^((tmp = -1095171528.911587, tmp)^(-942424985.7979553)))>>(-1279441481.1987405))*((2493620394)>>(-2769016043)))/(x&((tmp = 2059033657, tmp)%(((tmp = 1948606940.1488457, tmp)-(tmp = -2645984114.13219, tmp))^x))))))^x)^x)%(x%((((tmp = 3209433446.4551353, tmp)%(tmp = 1364430104.0424738, tmp))/(tmp = -2103044578.349498, tmp))+(tmp = -2613222750, tmp))))*(2099218034)))&(((tmp = -378500985.49700975, tmp)>>(((x+x)|(x%(((-1841907486)<<(-1220613546.194021))<<(tmp = -1260884176, tmp))))^(tmp = 1858784116, tmp)))>>>((x%x)%((x>>>(tmp = -2540799113.7667685, tmp))|x))))/((((tmp = 642072894.6455215, tmp)-(-324951103.6679399))*(tmp = 1424524615, tmp))+((x<<(tmp = -904578863.5945344, tmp))*(tmp = 49233475.435349464, tmp))))))<<(tmp = 1680210257, tmp)))+((tmp = -1516431503, tmp)>>>(-1105406695.3068116)))/(-275019361.6764543)));
  assertEquals(192359387.42913792, x /= (-1210234846));
  assertEquals(192359387.42913792, x %= (-2920206625.0154076));
  assertEquals(192359387.42913803, x -= (((((((tmp = -1263203016.3258834, tmp)-(2432034005.6011124))&x)<<(1479434294))>>((tmp = -1695856315.523002, tmp)>>>(tmp = 557391345, tmp)))/(tmp = -1280240246.2501266, tmp))%((tmp = -2196489823.034029, tmp)>>(((x&((912221637.1101809)+((tmp = -3003677979.652423, tmp)>>(tmp = -716129460.1668484, tmp))))-((x+(x-(-2780610859)))>>>(-2445608016)))<<((x*(x+(x+(((-2124412727.9007604)%(tmp = -593539041.5539455, tmp))&(tmp = 2404054468.768749, tmp)))))%(x>>(tmp = -2913066344.404591, tmp)))))));
  assertEquals(11740, x >>= (688848398.7228824));
  assertEquals(11740, x >>= ((1545765912)*(307650529.9764147)));
  assertEquals(23480, x += x);
  assertEquals(0, x >>>= ((tmp = 1313078391, tmp)|x));
  assertEquals(1726251264, x -= ((1939413887)<<(1004888744.2840619)));
  assertEquals(765324793.5278986, x %= (960926470.4721014));
  assertEquals(747387, x >>= ((2483010044)-(tmp = -413698190, tmp)));
  assertEquals(1, x /= x);
  assertEquals(3016811624, x *= (3016811624));
  assertEquals(17408, x &= (((tmp = -991624868, tmp)<<(((63107932)/(tmp = 2659939199, tmp))|(tmp = -1968768911.3575773, tmp)))>>(((-2876822038.9910746)|(tmp = 2550230179.243425, tmp))<<((x*(x<<((x<<((tmp = -1627718523.616604, tmp)|((2154120561.254636)-(x%(x<<(1484563622.1791654))))))<<((((x^(tmp = 3016524169, tmp))<<(((x+(tmp = 1887816698.2455955, tmp))+x)-x))-(-3023329069))-x))))+x))));
  assertEquals(0, x <<= (((1247441062.177967)/(-1717276234))+x));
  assertEquals(0, x |= ((x%((-1648299429.4520087)>>(-137511052)))>>(tmp = 221301016.4926411, tmp)));
  assertEquals(0, x /= ((-2598501544.913707)>>>(-2177037696)));
  assertEquals(NaN, x %= (x>>x));
  assertEquals(0, x &= (tmp = 1852419158, tmp));
  assertEquals(-829029120, x |= (((2122339180)*((((((tmp = 768748914, tmp)<<((1008490427)&((1937367899.957056)-(((635094486)>>(((tmp = -795046025, tmp)*(2665104134.4455256))^(tmp = 706594584.2462804, tmp)))/(504397522)))))/(-556057788))>>((x/(tmp = -2732280594, tmp))-x))+(-1989667473))+(tmp = 2766802447.789895, tmp)))<<(((tmp = -2969169096, tmp)-x)+(tmp = 2093593159.0942125, tmp))));
  assertEquals(0.6451933462602606, x /= ((-1284931292)<<(x<<(tmp = 1294716764, tmp))));
  assertEquals(1515416866.520901, x *= (2348779440));
  assertEquals(-1620606242886682600, x *= ((-993898625.5357854)&(((tmp = -571100481, tmp)/x)*((2428590177.311031)%(tmp = -2671379453, tmp)))));
  assertEquals(-1137472828, x %= (tmp = -1195183004, tmp));
  assertEquals(-3096634005473250000, x *= (tmp = 2722380640, tmp));
  assertEquals(-3096634003996758500, x -= (-1476491033.833419));
  assertEquals(-3096634000805538000, x += (3191220521.978341));
  assertEquals(-3096634000805468000, x += ((((tmp = -3024976741, tmp)&(952616360))|((x*(-1547952311))+(x*x)))>>>(tmp = 981373323, tmp)));
  assertEquals(-3096633998655594000, x += (2149873927));
  assertEquals(-118812224101.54297, x %= (((2641881276.9898443)*(((502159480)^x)<<x))%((tmp = -2840045365.547772, tmp)*(((((-2297661528)>>>(x>>(-229103883.94961858)))&(((-1285047374.6746495)<<((-360045084)>>>((x-(tmp = -956123411.1260898, tmp))%x)))>>((tmp = -2375660287.5213504, tmp)+((((tmp = -2753478891, tmp)>>>(((tmp = 101438098, tmp)>>(((tmp = -2736502951, tmp)<<((tmp = -3084561882.368902, tmp)&(tmp = 1491700884, tmp)))|x))&(tmp = 1627412882.6404104, tmp)))>>>(tmp = 1039002116.6784904, tmp))<<((tmp = -2840130800, tmp)-(tmp = -740035567, tmp))))))&(tmp = -416316142, tmp))>>x))));
  assertEquals(86, x >>>= (tmp = -293489896.5572462, tmp));
  assertEquals(172, x += (x%((((-2635082487.364155)|((-2361650420.634912)&(-2147095650.7451198)))<<((tmp = 2258905145.9231243, tmp)%((((tmp = -1365987098.5130103, tmp)*(((((((932437391)/x)/(289270413.0780891))%(x-x))+((((2194986374.917528)>>(((((tmp = -1553805025, tmp)|x)^(((x>>(-564400586.0780811))^(tmp = 1738428582.0238137, tmp))>>(tmp = 1717774140, tmp)))&(tmp = -2789427438, tmp))%(((tmp = -1386118057, tmp)*(-2333221237.7915535))*(x>>>(((((41346648.46438944)&x)%(-478973697.6792319))|(tmp = 2108106738, tmp))/x)))))-(tmp = -133437701.64136505, tmp))>>>x))+(tmp = -1567210003, tmp))*(x+((x&x)-(2942851671)))))>>>(tmp = -446377136, tmp))*((((((tmp = 1597203255, tmp)>>>(619157171))|(-2766246629.005985))>>((tmp = 3130227370, tmp)%x))*(tmp = 2072227901.6101904, tmp))|((tmp = 1369019520, tmp)^(759659487))))))>>>x)));
  assertEquals(1996475731, x ^= ((1456327892.2281098)|(1728022827)));
  assertEquals(0, x %= x);
  assertEquals(0, x &= (1323847974));
  assertEquals(3076829073.8848357, x += (3076829073.8848357));
  assertEquals(9569842648396755000, x *= (3110293883.2782717));
  assertEquals(9569842646260304000, x -= (2136450372.9038036));
  assertEquals(9.158188827418242e+37, x *= x);
  assertEquals(0, x <<= ((x&(tmp = -2241179286, tmp))+((tmp = 2553144081, tmp)&((tmp = -1914709694, tmp)^(tmp = -1469651409.0651562, tmp)))));
  assertEquals(0, x <<= x);
  assertEquals(0, x /= (2177840666.276347));
  assertEquals(0, x %= (-690827104));
  assertEquals(0, x >>>= x);
  assertEquals(0, x ^= x);
  assertEquals(-0, x /= (tmp = -803415280, tmp));
  assertEquals(-2355576914.316743, x += (-2355576914.316743));
  assertEquals(-833671722514674000, x *= ((3053388806.692315)-(tmp = 2699474775.081724, tmp)));
  assertEquals(1, x /= x);
  assertEquals(1898147684, x += ((tmp = 1898147683, tmp)|(x<<x)));
  assertEquals(2.192324660388075, x %= ((tmp = 2630187518, tmp)/((2868794982.790862)|(490860748))));
  assertEquals(0, x >>>= ((2751021779)/(-952522559)));
  assertEquals(321040461, x ^= ((321040461.153594)-x));
  assertEquals(-2.3814602031636922, x /= ((tmp = -170472190, tmp)|x));
  assertEquals(-1, x >>= (2200125174.177402));
  assertEquals(-2964432647.9379396, x += (-2964432646.9379396));
  assertEquals(-370116502.93793964, x %= (tmp = -518863229, tmp));
  assertEquals(777927355.2283959, x -= (-1148043858.1663356));
  assertEquals(0, x *= ((tmp = 1134913539, tmp)&(((x>>>((tmp = -989822787, tmp)>>>x))%x)&(tmp = 1078636160.7313156, tmp))));
  assertEquals(-1089245637, x ^= (3205721659.3548856));
  assertEquals(-1192493056, x <<= (-1173291054));
  assertEquals(78013832, x += ((tmp = 2462999944, tmp)+x));
  assertEquals(0, x %= x);
  assertEquals(0, x >>>= (1794908927.7409873));
  assertEquals(1708338504, x += ((-2586628792.3484306)<<x));
  assertEquals(12, x >>= (-545794789.3827574));
  assertEquals(0, x &= ((2753207225)<<(((-1776581207.557251)+((tmp = -2414140402, tmp)*x))+(x<<(x|(tmp = 772358560.3022032, tmp))))));
  assertEquals(0, x <<= ((tmp = -2755724712.152605, tmp)/((x>>(-732875466))&x)));
  assertEquals(NaN, x *= (((tmp = 2617815318.1134562, tmp)/x)%(x|((((((-851659337.194871)<<(tmp = 2072294700, tmp))%((x+(2193880878.5566335))^((tmp = 3005338026, tmp)-(2947963290))))/x)/(x+(2091745239.4210382)))-(x>>x)))));
  assertEquals(NaN, x /= (tmp = -427684595.0278094, tmp));
  assertEquals(NaN, x /= (tmp = -263945678, tmp));
  assertEquals(0, x <<= x);
  assertEquals(0, x <<= x);
  assertEquals(0, x -= (((x>>((x&x)-(tmp = -673697315, tmp)))>>(((1575095242.2330558)/(x-(-1816886266)))%(-1580195729)))>>>x));
  assertEquals(0, x >>>= x);
  assertEquals(0, x >>= (-2815518206));
  assertEquals(0, x -= (x/(1795634670.692437)));
  assertEquals(-2753579891, x += (tmp = -2753579891, tmp));
  assertEquals(2.7773776150171776, x /= (tmp = -991431585, tmp));
  assertEquals(5.554755230034355, x += x);
  assertEquals(3.362161997528237e-9, x /= (1652137890.4758453));
  assertEquals(3.362161997528237e-9, x %= (tmp = -10848734.527020693, tmp));
  assertEquals(1, x /= x);
  assertEquals(-2978012493, x -= (x+(2978012493)));
  assertEquals(-5.158905851797543, x /= (((x+((tmp = -2548840164, tmp)>>x))<<(x^((tmp = -533281232.7294345, tmp)&x)))&(tmp = -1502692171, tmp)));
  assertEquals(-5.158905851797543, x %= (-3009435255.5612025));
  assertEquals(-20971520, x <<= ((tmp = -2728812464, tmp)%(2619809573.672677)));
  assertEquals(-1900019712, x &= (2398099552));
  assertEquals(-1991377, x %= ((tmp = 1562364373.7334614, tmp)>>>(((x-(-946283217))<<(-2044590694))^(((tmp = 1681238509, tmp)>>(-2801649769))-x))));
  assertEquals(1, x /= x);
  assertEquals(1, x %= (x/(x-x)));
  assertEquals(1.3525631913093335e-9, x /= (739336991));
  assertEquals(0, x &= ((x&(x|(-1530424204)))<<((((tmp = -295143065.9115021, tmp)>>x)+x)<<x)));
  assertEquals(0, x <<= (-1311017801));
  assertEquals(-0, x /= (-667133339.1918633));
  assertEquals(1038307283, x += (1038307283));
  assertEquals(506985, x >>>= ((tmp = 1550624472.9157984, tmp)^x));
  assertEquals(506985, x >>>= ((254646626)<<(tmp = 1572845412.744642, tmp)));
  assertEquals(32447040, x <<= (tmp = -2427326042, tmp));
  assertEquals(0, x -= (x<<((x|x)>>>x)));
  assertEquals(0, x &= x);
  assertEquals(0, x &= ((-484420357)|((tmp = 807540590.6132902, tmp)/(x/x))));
}
f();
                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/numops-fuzz-part4.js                                               0000664 0000000 0000000 00000321175 14746647661 0022431 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2011 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function f() {
  var x = 0;
  var tmp = 0;
  assertEquals(-890607324, x ^= ((tmp = -890607324, tmp)>>((((-2876826295)>>x)<<((tmp = 2351495148.117994, tmp)>>(tmp = 1368611893.274765, tmp)))*(tmp = 1531795251, tmp))));
  assertEquals(-729075363, x += (x+(tmp = 1052139285, tmp)));
  assertEquals(531550884933581760, x *= x);
  assertEquals(1980836332, x ^= ((-746269795.2320724)-((2400458512)>>((1290672548)>>>((((1536843439.5629003)&(3185059975.158061))*(tmp = -1339249276.2667086, tmp))&x)))));
  assertEquals(941373096, x %= ((x+(-451098412))^(tmp = 1725497732, tmp)));
  assertEquals(-1766019323, x += (tmp = -2707392419, tmp));
  assertEquals(2528947973, x >>>= (x^(-896237435.3809054)));
  assertEquals(-263192576, x <<= (-866361580));
  assertEquals(-2008, x >>= (-2608071791));
  assertEquals(-88, x %= (((-1076807218.4792447)&((tmp = 601044863, tmp)>>((tmp = 1228976729, tmp)+((((-2711426325)*x)|x)|(x%(-2700007330.3266068))))))&(tmp = 3147972836.778858, tmp)));
  assertEquals(1762886843, x ^= (tmp = 2532080403, tmp));
  assertEquals(1762886843, x %= ((((((tmp = -2059247788, tmp)>>x)/x)+(x<<x))^x)>>>(-1969283040.3683646)));
  assertEquals(4812334726.587896, x += (tmp = 3049447883.587897, tmp));
  assertEquals(1, x /= x);
  assertEquals(1, x *= x);
  assertEquals(-2150507334, x -= ((tmp = 1578221999, tmp)+(tmp = 572285336, tmp)));
  assertEquals(-4546475858941548500, x *= ((tmp = -931533139.5546813, tmp)^(tmp = 3061503275, tmp)));
  assertEquals(-269064192, x |= ((207217276.91936445)<<(tmp = -957353678.4997551, tmp)));
  assertEquals(1, x /= x);
  assertEquals(1, x <<= (((1463856021.8616743)%(x*(tmp = -2286419102, tmp)))/(-2852887593)));
  assertEquals(2223868564.8383617, x *= (tmp = 2223868564.8383617, tmp));
  assertEquals(918797189.9033995, x -= ((1305071374.9349623)%(x+(2211992629))));
  assertEquals(-2212004787.4668465, x -= (tmp = 3130801977.370246, tmp));
  assertEquals(31783, x >>= (2951958960));
  assertEquals(31783, x ^= ((((tmp = -2441511566, tmp)&((tmp = 91427553.90168321, tmp)+((tmp = 3001737720.327718, tmp)%x)))>>>(-2263859841))>>>((2109161329)>>(tmp = -2816295136.7443414, tmp))));
  assertEquals(4068224, x <<= (x%((tmp = -682576250.4464607, tmp)*(x/(((x-x)>>>(x&((((x<<(x<<x))>>>((((2243036981.528562)/(((-1839328916.9411087)>>(-1907748022.162144))<<(x+x)))+((tmp = 2362574171, tmp)<<(tmp = 1987834539, tmp)))|(-444329240)))|(399451601.1717081))>>x)))&(968363335.6089249))))));
  assertEquals(0.0030991932898194294, x /= ((tmp = 1067316540.5529796, tmp)^(-2388640366)));
  assertEquals(0, x >>= x);
  assertEquals(0, x >>>= (tmp = -393433349.1636851, tmp));
  assertEquals(0, x *= (((x^(((1806955787.471396)<<x)^((517668047.55566347)>>>(x%(x<<(tmp = -276586733.4844558, tmp))))))%(1661242196.1472542))|x));
  assertEquals(0, x |= (x>>x));
  assertEquals(-155236210, x |= (tmp = -155236210.19366312, tmp));
  assertEquals(-606392, x >>= ((tmp = -1533446042.97781, tmp)^x));
  assertEquals(-1, x >>= (936126810));
  assertEquals(2325115611, x -= (-2325115612));
  assertEquals(0, x -= x);
  assertEquals(0, x >>= (tmp = -354826623, tmp));
  assertEquals(-0, x *= (-1232528947.7321298));
  assertEquals(0, x |= x);
  assertEquals(0, x <<= (((tmp = 187758893.4254812, tmp)&(x-(tmp = 648201576, tmp)))&(385106597)));
  assertEquals(0, x >>= (tmp = 2554891961, tmp));
  assertEquals(-1311492611.2970417, x += (-1311492611.2970417));
  assertEquals(-688179220.3221785, x += (623313390.9748632));
  assertEquals(1416835528, x &= (tmp = 1953739224, tmp));
  assertEquals(-11.04719252755072, x /= (-128252995));
  assertEquals(-6.287413042114223e-9, x /= (tmp = 1757033052.1558928, tmp));
  assertEquals(-4231171, x |= (((((2022730885.7773404)*((-2495777565.221855)|(tmp = 274627292, tmp)))<<(-3072596920.4902725))>>>((-2215057529)+(-1134713759.4247034)))^((tmp = -1888181788, tmp)/(572025985.2748461))));
  assertEquals(-4194305, x |= ((tmp = 167328318.038759, tmp)>>>(153800904.34551537)));
  assertEquals(-1316525687, x -= (1312331382));
  assertEquals(1448723245.7863903, x += (2765248932.7863903));
  assertEquals(1.7219707102205526, x /= (tmp = 841317008, tmp));
  assertEquals(1872027792.5217001, x *= (x|(tmp = 1087142645.6665378, tmp)));
  assertEquals(3504488055973669400, x *= x);
  assertEquals(-1075254784, x |= x);
  assertEquals(-5, x >>= (((844461331.8957539)-((x&x)<<((tmp = 1443904777, tmp)+(tmp = 736164505.3670597, tmp))))-(((tmp = 1348422110, tmp)>>((tmp = -2878252514, tmp)/(-1175443113)))|((-2138724317)%(2057081133)))));
  assertEquals(-3.038875804165675e-9, x /= (1645345292.8698258));
  assertEquals(1.25204541454491e-18, x /= (-2427129055.274914));
  assertEquals(-1.7151576137235622e-9, x *= (-1369884505.6247284));
  assertEquals(1590804618, x ^= (1590804618.4910607));
  assertEquals(5061318665300252000, x *= (x+x));
  assertEquals(5061318665300252000, x %= ((tmp = 1102144242, tmp)*x));
  assertEquals(-7, x >>= (2772167516.624264));
  assertEquals(16383, x >>>= (-2979259214.5855684));
  assertEquals(47108415435, x *= ((2944456517.839616)>>>(1041288554.5330646)));
  assertEquals(61, x >>>= (x^(((-1305163705)<<((948566605)-x))-x)));
  assertEquals(0, x %= x);
  assertEquals(0, x ^= (((tmp = 1918861879.3521824, tmp)/((x%(tmp = 945292773.7188392, tmp))%(x|x)))>>x));
  assertEquals(-0, x *= ((((x|((2810775287)|(tmp = 1265530406, tmp)))^((tmp = 3198912504.175658, tmp)-(((tmp = 1422607729.281712, tmp)<<(tmp = 2969836271.8682737, tmp))&x)))<<((tmp = 844656612, tmp)*(((((tmp = -828311659, tmp)%(((-2083870654)>>>(x^(((((933133782)-(tmp = 1033670745, tmp))-(629026895.4391923))%((-605095673.8097742)*((((-227510375.38460112)*x)+x)&(((((tmp = 472873752.68609154, tmp)^(tmp = 2815407038.712165, tmp))+((x>>>((tmp = -1331030665.3510115, tmp)>>>(2281234581)))-(x>>>x)))&(tmp = -2160840573.325921, tmp))&x))))<<(tmp = 1411888595, tmp))))|(((tmp = -915703839.0444739, tmp)/((x+(418836101.8158506))%(-1112605325.4404268)))&((-3098311830.6721926)-x))))-((49446671.477988124)*(-2522433127)))+((tmp = 443068797, tmp)>>(tmp = 418030554.97275746, tmp)))*((tmp = 38931296.738208175, tmp)+(1842742215.3282685)))))-((tmp = 1325672181.205841, tmp)^(tmp = 669284428, tmp))));
  assertEquals(-0, x *= (tmp = 93843030, tmp));
  assertEquals(0, x ^= x);
  assertEquals(0, x ^= x);
  assertEquals(0, x <<= x);
  assertEquals(0, x >>>= (x%((((((tmp = -107458601, tmp)>>(x*((x|((tmp = 2117286494, tmp)>>((x^(tmp = 114214295.42048478, tmp))>>>(tmp = 1032826615, tmp))))&((x*x)&(-225386977.67686415)))))^((-780566702.5911419)+(-1113319771)))|(((x^x)<<(1288064444))>>(-2292704291.619477)))>>(365125945))-((tmp = -1986270727.235776, tmp)/x))));
  assertEquals(-0, x *= (((-18925517.67125845)|((((-1975220517)+(tmp = -1250070128.296064, tmp))+(1085931410.5895243))<<(((x|(((x*(tmp = 160207581.50536323, tmp))|(tmp = 1798744469.7958293, tmp))-x))>>>(((x+((x%x)&((((x^x)<<((tmp = 2538012074.623554, tmp)^x))*x)&x)))/(x+(tmp = -2563837407, tmp)))/(tmp = 2189564730, tmp)))/(((-1703793330.5770798)<<((176432492)|x))<<(1347017755.345185)))))<<(((tmp = -577100582.7258489, tmp)&x)/(-31246973))));
  assertEquals(0, x >>>= x);
  assertEquals(NaN, x %= ((x*(tmp = 1167625971, tmp))&(((tmp = -770445060, tmp)>>((339248786)^((2058689781.2387645)-((-2381162024)*(660448066)))))&x)));
  assertEquals(NaN, x += ((3088519732.515986)-(-267270786.06493092)));
  assertEquals(0, x &= (tmp = 2748768426.3393354, tmp));
  assertEquals(-1109969306, x ^= ((-1109969306)>>>x));
  assertEquals(-1109969306, x %= (tmp = 1150376563.581773, tmp));
  assertEquals(-2058145178, x &= (-2057586057));
  assertEquals(-850185626, x |= ((x^(tmp = 1223093422, tmp))&((-589909669)<<(2299786170))));
  assertEquals(1489215443, x += (2339401069));
  assertEquals(-23592960, x <<= x);
  assertEquals(2063937322, x ^= (-2053296342.2317986));
  assertEquals(12922122, x %= (x^((-2259987830)>>(x*(((tmp = -799867804.7716949, tmp)&(tmp = -1068744142, tmp))*(((((1091932754.8596292)-((tmp = -1778727010, tmp)>>(((tmp = 1207737073.2689717, tmp)-(x-(tmp = -1191958946, tmp)))+(-631801383.7488799))))-(-618332177))>>>(-156558558))>>>(3032101547.6262517)))))));
  assertEquals(12922122, x &= x);
  assertEquals(Infinity, x /= (x%x));
  assertEquals(0, x &= (x*(-227800722.62070823)));
  assertEquals(-865648691, x ^= (-865648691));
  assertEquals(1, x /= (x%(tmp = 1524739353.8907173, tmp)));
  assertEquals(16, x <<= (x<<(2335214658.789205)));
  assertEquals(0, x &= ((tmp = 570332368.1239192, tmp)^(-2278439501)));
  assertEquals(1881145344, x -= (((-569715735.8853142)+(2093355159))<<(tmp = 2788920949, tmp)));
  assertEquals(0, x ^= x);
  assertEquals(NaN, x -= ((tmp = -1427789954, tmp)%((((((411038329.49866784)-x)-(x<<((-1330832247)+x)))/x)^((x*(845763550.2134092))>>(tmp = 1427987604.5938706, tmp)))>>>(1857667535))));
  assertEquals(NaN, x /= (-313793473));
  assertEquals(0, x >>>= (x/x));
  assertEquals(1869358566, x -= (-1869358566));
  assertEquals(-1901664519209545200, x += ((tmp = 944729941.3936644, tmp)*(-2012918653)));
  assertEquals(-1901664519209545200, x += ((tmp = 1348246793, tmp)/(x&x)));
  assertEquals(-1576791552, x &= (tmp = 2719250966.739456, tmp));
  assertEquals(-305087899, x ^= (-2955630491.030272));
  assertEquals(0, x ^= (x%(1575252839.559443)));
  assertEquals(4184604407, x += ((((tmp = -244720076.17657042, tmp)|(2819320515))^((((tmp = 1222623743.9184055, tmp)*(-95662379.577173))/(x/(x+(((x-(tmp = -3024718107.6310973, tmp))^(-1494390781))&(tmp = 2284054218.8323536, tmp)))))>>>(tmp = 2090069761, tmp)))>>>(x%x)));
  assertEquals(3148907440, x -= (((tmp = -332379100.7695112, tmp)-(-1145399547))^(((((((tmp = 3133792677.785844, tmp)+x)<<(2306999139.5799255))>>((tmp = -2051266106, tmp)*(((((x+(((-728654312.8954825)>>(x>>>(((x%x)&(-1587152364))|(((((-2114138294)&x)&(1547554688))^x)-(-1856094268)))))*(((-1135018784)&((x+(tmp = -1444020289, tmp))|x))+x)))>>x)&x)/(2449005489))<<((131073798.64314616)%(x>>>((-2592101383.2205048)^(tmp = -757096673.0381112, tmp)))))))^(2766467316.8307915))-(-2465892914.515834))-((((tmp = 234064056, tmp)^((x>>>(1622627548.7944543))+(-1750474146)))|(-1959662039.4687617))^((-1222880974)&(-2794536175.906498))))));
  assertEquals(-1157627488, x &= (-1156639323));
  assertEquals(-1342170624, x <<= ((x/((((1829945345.0613894)/(x*((tmp = 1278865203.0854595, tmp)/(((tmp = -2298274086.519347, tmp)+(tmp = -545203761, tmp))-(tmp = 2712195820, tmp)))))>>>((tmp = 240870798.9384452, tmp)-(tmp = -3188865300.4768195, tmp)))>>>(x%((648799266)>>>(tmp = 24460403.864815235, tmp)))))|((tmp = 232533924, tmp)|x)));
  assertEquals(-2684341248, x += x);
  assertEquals(1073755136, x &= (((-662718514.9245079)>>(tmp = -1915462105, tmp))+(tmp = 1478850441.8689613, tmp)));
  assertEquals(-1073755136, x /= (x|((tmp = -1767915185, tmp)|((325827419.1430224)|(((-1343423676)|(tmp = -1929549501, tmp))|(-866933068.9585254))))));
  assertEquals(-1073755136, x %= ((tmp = 547342356, tmp)-((tmp = 2213249646.7047653, tmp)-((((((-2463314705)^(tmp = -993331620, tmp))^(((x%x)>>(tmp = 1798026491.3658786, tmp))-(((1024072781)/(tmp = -2407354455, tmp))%(1973295010))))<<(-1966787233))^x)|(-1787730004)))));
  assertEquals(-1073754452, x |= (tmp = 3099823788.077907, tmp));
  assertEquals(-1540683096, x &= (-1540674632.7013893));
  assertEquals(-1540683052, x ^= ((tmp = -126183090, tmp)>>>((-622437575.5788481)|((((tmp = -2947914022, tmp)%(((tmp = 2512586745, tmp)>>x)>>>((27238232.23677671)/(tmp = 3203958551, tmp))))/(tmp = 2906005721.402535, tmp))^((((tmp = 1763897860.737334, tmp)^(1445562340.2485332))/x)+(-2393501217.716533))))));
  assertEquals(-1258599433, x |= (tmp = 351291767.59661686, tmp));
  assertEquals(-1241560065, x |= (626346046.5083935));
  assertEquals(-1241560065, x ^= ((2263372092)/((tmp = -2868907862, tmp)>>>x)));
  assertEquals(-893685228, x -= (tmp = -347874837, tmp));
  assertEquals(3401282068, x >>>= (x*x));
  assertEquals(0, x %= x);
  assertEquals(0, x >>>= x);
  assertEquals(-2079237393, x ^= (tmp = 2215729903, tmp));
  assertEquals(NaN, x %= ((((tmp = 3203450436, tmp)/(2867575150.6528325))&(1864945829))&((x&((((tmp = -1927086741.3438427, tmp)|x)|(-1783290909.3240588))*((-1074778499.0697656)*(x-((tmp = -848983542.8456669, tmp)^(tmp = -1324673961, tmp))))))>>(tmp = -2144580304.245896, tmp))));
  assertEquals(-43334009, x |= (x^(-43334009.72683525)));
  assertEquals(-43334009, x &= x);
  assertEquals(-43334009, x %= (tmp = 1252450645.060542, tmp));
  assertEquals(-43334009, x |= (((((((tmp = 968062202, tmp)/(x|(tmp = 2766801984, tmp)))*((2173353793.938968)>>(((tmp = -2459317247, tmp)<<(tmp = -2333601397, tmp))>>>((tmp = -578254251.8969193, tmp)*(tmp = 839964110.7893236, tmp)))))&(((1675305119)&(tmp = -929153707, tmp))*((x*x)*x)))/x)|(x/(tmp = 384740559.43867135, tmp)))%(1657362591)));
  assertEquals(0, x -= x);
  assertEquals(0, x %= (-1334758781.1087842));
  assertEquals(0, x -= x);
  assertEquals(-54, x += ((tmp = -1787151355.470972, tmp)>>((tmp = 237028977, tmp)>>(((2829473542)<<(x>>>(((((((x-(-1950724753))*(((x>>>(2807353513.6283565))<<((-583810779.1155353)>>(x*x)))>>(-1068513265)))^(x^(-696263908.5131407)))%(((tmp = -1325619399, tmp)<<((tmp = -1030194450, tmp)-x))^x))+((-2852768585.3718724)>>(tmp = -3160022361, tmp)))%(x&x))>>(tmp = 2667222702.5454206, tmp))))+((804998368.8915854)<<x)))));
  assertEquals(-54, x %= (-1601267268.4306633));
  assertEquals(1, x >>>= (tmp = -543199585.579128, tmp));
  assertEquals(4.732914708226396e-10, x /= (tmp = 2112862922, tmp));
  assertEquals(-4266932650, x -= ((((x^((((tmp = 2784618443, tmp)^(tmp = -2271260297.9010153, tmp))|((((tmp = -599752639.7516592, tmp)*(2751967680.3680997))^(tmp = -1478450055.578217, tmp))*x))-x))&((tmp = -520061982, tmp)-((tmp = 1400176711.9637299, tmp)^(((2100417541)|(x+(tmp = -674592897.0420957, tmp)))>>x))))^(tmp = -365650686.7947228, tmp))>>>((-2943521813)&(((tmp = -1888789582, tmp)>>(tmp = 700459655.488978, tmp))+(tmp = -1725725703.655931, tmp)))));
  assertEquals(224277168, x <<= (tmp = 2885115011.8229475, tmp));
  assertEquals(224277168, x %= (tmp = -2655345206.442777, tmp));
  assertEquals(850395136, x <<= (x-(((((-769868538.1729524)/((tmp = -298603579, tmp)%(x^x)))+((2691475692)|(((x>>>(628995710.4745524))^(x<<(((tmp = -1046054749, tmp)|(919868171))-x)))^((-1377678789.8170452)&((3065147797)%(tmp = 2638804433, tmp))))))^(tmp = -2036295169, tmp))&(((tmp = -157844758.08476114, tmp)*(tmp = -2819601496, tmp))&((((tmp = 78921441, tmp)<<(653551762.5197772))/(1801316098))*(-1479268961.8276927))))));
  assertEquals(1645565728, x ^= (tmp = 1353013024, tmp));
  assertEquals(1645565728, x >>>= x);
  assertEquals(3020513544, x += (1374947816));
  assertEquals(0, x %= x);
  assertEquals(0, x %= ((((((tmp = -304228072.4115715, tmp)>>>((-90523260.45975709)-(tmp = -3013349171.084838, tmp)))%((-1640997281)*((tmp = -1600634553, tmp)%((tmp = 557387864, tmp)<<((888796080.766409)|(x^((((x%(((((tmp = 1164377954.1041703, tmp)*x)|(2742407432.192806))&((tmp = 1707928950, tmp)<<(1279554132.4481683)))+(tmp = -2108725405.7752397, tmp)))%(tmp = -465060827, tmp))^((tmp = 2422773793, tmp)+x))^((((((((tmp = -1755376249, tmp)^((-267446806)^x))/(((tmp = -1808578662.4939392, tmp)+((tmp = -1997100217, tmp)+x))+(((tmp = -2469853122.411479, tmp)/x)>>(tmp = 660624616.7956645, tmp))))%((x<<((((((tmp = -1701946558, tmp)-(tmp = 133302235, tmp))>>>x)/(738231394))<<(-1060468151.4959564))&(((((-1877380837.4678264)|(tmp = 2366186363, tmp))%x)>>>(-2382914822.1745577))>>((-1874291848.9775913)<<(tmp = 2522973186, tmp)))))<<(-2672141993)))|(tmp = 732379966, tmp))%x)^x)^x))))))))%(tmp = 2385998902.7287374, tmp))*x)+(tmp = -2195749866.017106, tmp)));
  assertEquals(401488, x ^= (((-320896627)>>>(tmp = 2812780333.9572906, tmp))&(tmp = -2088849328, tmp)));
  assertEquals(-1661116571.0046256, x += (tmp = -1661518059.0046256, tmp));
  assertEquals(-1616122720, x <<= x);
  assertEquals(-1616122720, x >>= x);
  assertEquals(-390439413, x %= (tmp = -1225683307, tmp));
  assertEquals(-84189205, x |= ((x|(2054757858))^(((x<<(((x|x)|(((x>>>((-2938303938.1397676)<<((2993545056)^((tmp = -643895708.5427527, tmp)/((1371449825.5345795)-(1896270238.695752))))))-(tmp = 1061837650, tmp))+(x+(tmp = 3072396681, tmp))))>>(x-((((tmp = -1877865355.1550744, tmp)&x)%(-2766344937))>>>(2055121782)))))-((x<<x)|(tmp = -2742351880.1974454, tmp)))<<((-2600270279.219802)>>(-1625612979)))));
  assertEquals(-168378410, x += x);
  assertEquals(-168378410, x &= x);
  assertEquals(-1534983792, x &= (-1501412943));
  assertEquals(-1821543761, x ^= (938439487));
  assertEquals(-1821543761, x &= (x^(((tmp = -4237854, tmp)>>x)/x)));
  assertEquals(2358, x >>>= (2954252724.620632));
  assertEquals(4716, x <<= ((-75522382.8757689)/((tmp = 1074334479, tmp)|((tmp = -720387522, tmp)>>(x>>>(-3085295162.6877327))))));
  assertEquals(-1313079316, x |= (2981887904.020387));
  assertEquals(-1957790646, x -= (644711330));
  assertEquals(17831, x >>>= ((tmp = -2550108342, tmp)-(((tmp = 454671414.0146706, tmp)+(-661129693.9333956))>>(x>>>(((tmp = 1752959432.3473055, tmp)*(-2619510342.1812334))%(tmp = -456773274.2411971, tmp))))));
  assertEquals(689287937.6879716, x -= ((tmp = -397126863.6879716, tmp)-(((x>>x)^(x/(-1387467129.6278908)))|((x>>((tmp = -2361114214.8413954, tmp)<<(tmp = -805670024.4717407, tmp)))<<(-2724018098)))));
  assertEquals(1378575875.3759432, x += x);
  assertEquals(84112428460187.8, x *= (((((2681425112.3513584)%(tmp = -1757945333, tmp))|x)>>(-1793353713.0003397))%x));
  assertEquals(-3221, x >>= (-1976874128));
  assertEquals(-3221, x %= (((tmp = 2318583056.834932, tmp)|((tmp = -1016115125, tmp)+((-472566636.32567954)+x)))|(tmp = 3135899138.065598, tmp)));
  assertEquals(-6596608, x <<= x);
  assertEquals(-1249902592, x <<= (((tmp = -2025951709.5051148, tmp)/((-465639441)<<(-2273423897.9682302)))*((tmp = -2408892408.0294642, tmp)-(tmp = 1017739741, tmp))));
  assertEquals(73802092170444800, x *= (tmp = -59046275, tmp));
  assertEquals(-1619001344, x <<= x);
  assertEquals(0, x <<= (tmp = 1610670303, tmp));
  assertEquals(-0, x *= ((((x+(tmp = 2039867675, tmp))|(tmp = 399355061, tmp))<<(1552355369.313559))^x));
  assertEquals(0, x *= x);
  assertEquals(0, x >>>= (((2875576018.0610805)>>x)%(tmp = -2600467554, tmp)));
  assertEquals(2290405226.139538, x -= (-2290405226.139538));
  assertEquals(0, x %= x);
  assertEquals(0, x ^= (((tmp = 2542309844.485515, tmp)-x)%((-2950029429.0027323)/(tmp = 2943628481, tmp))));
  assertEquals(0, x += x);
  assertEquals(0, x -= x);
  assertEquals(0, x >>>= (tmp = 2337330038, tmp));
  assertEquals(0, x += (x/(((292272669.0808271)&(tmp = 2923699026.224247, tmp))^(tmp = 367745855, tmp))));
  assertEquals(0, x &= x);
  assertEquals(0, x %= ((tmp = 1565155613.3644123, tmp)<<(-308403859.5844681)));
  assertEquals(-1845345399.3731332, x += (tmp = -1845345399.3731332, tmp));
  assertEquals(5158590659731951000, x *= (-2795460763.8680177));
  assertEquals(-364664, x >>= (1837745292.5701954));
  assertEquals(1, x /= x);
  assertEquals(-860616114.8182092, x += ((tmp = 2076961323.1817908, tmp)+(-2937577439)));
  assertEquals(-860616115, x ^= ((x*(tmp = 2841422442.583121, tmp))>>>((tmp = 1929082917.9039137, tmp)>>(-2602087246.7521305))));
  assertEquals(-38387843, x |= (3114677624));
  assertEquals(2927507837, x += (tmp = 2965895680, tmp));
  assertEquals(1, x /= x);
  assertEquals(-1792887531, x *= (-1792887531));
  assertEquals(-0, x %= ((x^x)+x));
  assertEquals(-0, x %= (tmp = 2800752702.562547, tmp));
  assertEquals(1384510548, x ^= (tmp = 1384510548, tmp));
  assertEquals(42251, x >>= (1645421551.363844));
  assertEquals(0, x >>>= (17537561));
  assertEquals(-2076742862, x ^= (tmp = 2218224434, tmp));
  assertEquals(-2.790313825067623, x /= (744268563.3934636));
  assertEquals(5313538, x &= (((((tmp = -2406579239.0691676, tmp)+((-1470174628)+(((tmp = -783981599, tmp)<<(tmp = -1789801141.272646, tmp))^(((((((tmp = -844643189.5616491, tmp)&(tmp = -252337862, tmp))&(x|x))%((-3159642145.7728815)+(tmp = 2149920003.9525595, tmp)))&(x>>(1737589807.9431858)))-((((((((1610161800)<<(497024994))>>x)<<x)/x)>>>x)&x)-(757420763.2141517)))-(tmp = -3061016994.9596977, tmp)))))/(tmp = 1810041920.4089384, tmp))&(tmp = 5887654.786785364, tmp))&((tmp = 1626414403.2432103, tmp)+(x%x))));
  assertEquals(-2147483648, x <<= (tmp = 1304102366.8011155, tmp));
  assertEquals(-208418816, x %= (((((-2850404799)*(x+(3158771063.226051)))*(-2017465205))/(x>>x))>>(x%(tmp = 2760203322, tmp))));
  assertEquals(-2189223477, x -= (1980804661));
  assertEquals(-859239912, x ^= (tmp = 2974421971.3544703, tmp));
  assertEquals(-1599850415, x ^= (tmp = -2475871671.140151, tmp));
  assertEquals(-1600636847, x += ((((tmp = -1311002944, tmp)<<((tmp = -1137871342, tmp)<<(tmp = 115719116, tmp)))/(413107255.6242596))<<(x>>((((-1908022173)&(((-1519897333)^((x>>(x*(tmp = -2886087774.426503, tmp)))*(tmp = 530910975, tmp)))+(-2579617265.889692)))+((2518127437.127563)>>>((tmp = 481642471.56441486, tmp)>>>(792447239))))^(x<<(248857393.6819017))))));
  assertEquals(-191, x >>= (-1591265193));
  assertEquals(-192.27421813247196, x += ((tmp = 2627329028.207775, tmp)/(tmp = -2061914644.9523563, tmp)));
  assertEquals(1230613220, x ^= (tmp = 3064354212.307105, tmp));
  assertEquals(1230613220, x &= x);
  assertEquals(1230613220, x %= (1833479205.1064768));
  assertEquals(1230613220, x >>>= ((((1559450742.1425748)|((2151905260.956583)*(1213275165)))%(514723483.12764716))>>>x));
  assertEquals(1230613493, x |= ((((3004939197.578903)*(tmp = -576274956, tmp))+((tmp = 1037832416.2243971, tmp)^x))>>>(tmp = 2273969109.7735467, tmp)));
  assertEquals(2461226986, x += x);
  assertEquals(-27981, x >>= ((692831755.8048055)^((tmp = -1593598757, tmp)%(x-((((-1470536513.882593)|((tmp = -2716394020.466401, tmp)|(tmp = 2399097686, tmp)))&x)%x)))));
  assertEquals(-1.4660454948034359e+23, x *= (((x>>>((((((tmp = -3056016696, tmp)<<(-2882888332))*(2041143608.321916))&(((tmp = -634710040, tmp)|(tmp = -2559412457, tmp))>>(1916553549.7552106)))%((-2150969350.3643866)*x))<<((x*(tmp = 2657960438.247278, tmp))|x)))%((tmp = 526041379, tmp)*(tmp = 2514771352.4509397, tmp)))*(1219908294.8107886)));
  assertEquals(-1.4660454948034359e+23, x -= ((1709004428)>>(((x|(-422745730.626189))%x)>>x)));
  assertEquals(-2247766068, x %= (-3105435508));
  assertEquals(-386845856.0649812, x -= (-1860920211.9350188));
  assertEquals(-386846803.0649812, x -= ((((-3214465921)|((tmp = -1326329034, tmp)+(((tmp = -1203188938.9833462, tmp)%((((((-1318276502)+(x+x))^((x<<x)%(x>>>x)))+(tmp = -439689881, tmp))+((-1455448168.695214)^(x-((-388589993)>>((((940252202)^(-2218777278))|x)/(tmp = -1007511556, tmp))))))&(-140407706.28176737)))-(x/((888903270.7746506)-((tmp = -2885938478.632409, tmp)<<(((((tmp = -1750518830.270917, tmp)>>(((((((tmp = 868557365.7908674, tmp)/(tmp = -2805687195.5172157, tmp))*x)|((((((-1342484550)-((tmp = 1089284576, tmp)^(tmp = 120651272, tmp)))<<(tmp = 2230578669.4642825, tmp))-(x*x))%(x^(((tmp = -3177941534, tmp)+(x>>(-1595660968)))/(-1738933247))))>>>(tmp = 2860175623, tmp)))-(((2392690115.8475947)>>>(tmp = -1754609670.2068992, tmp))>>>(tmp = 2615573062, tmp)))-(tmp = 2590387730, tmp))^((x+((((x-(tmp = -2823664112.4548965, tmp))*(200070977))>>>(((x|((((tmp = 1361398, tmp)>>((tmp = 1649209268, tmp)%x))+x)+(x>>>(tmp = -2379989262.1245675, tmp))))|(x^((tmp = -647953298.7526417, tmp)-x)))&(tmp = -1881232501.1945808, tmp)))>>>x))%(x^(tmp = -1737853471.005935, tmp)))))>>>(427363558))>>>((tmp = -3076726422.0846386, tmp)^(-1518782569.1853383)))/x)))))))|x)>>>(1854299126)));
  assertEquals(-386846803.0649812, x -= (x%x));
  assertEquals(238532, x >>>= (-448890706.10774803));
  assertEquals(232, x >>>= (-791593878));
  assertEquals(232, x <<= (((x^((x-x)&(tmp = 1219114201, tmp)))/(tmp = -427332955, tmp))%(tmp = 1076283154, tmp)));
  assertEquals(210, x ^= (x>>>((2975097430)>>>x)));
  assertEquals(1, x /= x);
  assertEquals(2317899531, x *= (2317899531));
  assertEquals(1131786, x >>>= x);
  assertEquals(2301667519.6379366, x += ((tmp = 193109669.63793683, tmp)+(tmp = 2107426064, tmp)));
  assertEquals(3842614963.6379366, x += (((-1676516834)>>>(tmp = -1817478916.5658965, tmp))^(((tmp = 1122659711, tmp)>>>(tmp = -2190796437, tmp))|(tmp = -2754023244, tmp))));
  assertEquals(-452352333, x &= x);
  assertEquals(-863, x >>= x);
  assertEquals(-3.777863669459606e-7, x /= (2284359827.424491));
  assertEquals(-3.777863669459606e-7, x %= ((tmp = -2509759238, tmp)>>>x));
  assertEquals(0, x <<= (-814314066.6614306));
  assertEquals(0, x %= (tmp = 190720260, tmp));
  assertEquals(2301702913, x += (2301702913));
  assertEquals(-249158048, x >>= (tmp = -2392013853.302008, tmp));
  assertEquals(-249158048, x >>= x);
  assertEquals(-498316096, x += x);
  assertEquals(-498316096, x %= (tmp = 2981330372.914731, tmp));
  assertEquals(106616.2199211318, x *= (((((tmp = 1020104482.2766557, tmp)^((tmp = -416114189.96786, tmp)>>>(1844055704)))|(tmp = 1665418123, tmp))>>(1826111980.6564898))/(-2446724367)));
  assertEquals(106616, x |= x);
  assertEquals(1094927345, x -= (((-1229759420)|(741260479.7854375))-x));
  assertEquals(8353, x >>= x);
  assertEquals(0, x >>>= (tmp = -327942828, tmp));
  assertEquals(-953397616.8888416, x += (tmp = -953397616.8888416, tmp));
  assertEquals(-1906641240.7776833, x += (x+((-3033450184.9106326)>>>(tmp = 2090901325.5617187, tmp))));
  assertEquals(-1906641240.7776833, x %= (tmp = 2584965124.3953505, tmp));
  assertEquals(-1098907671, x |= (tmp = -1272590495, tmp));
  assertEquals(-1.8305258600334393, x /= (600323489));
  assertEquals(-1, x &= x);
  assertEquals(-1, x |= ((x+x)-x));
  assertEquals(1, x *= x);
  assertEquals(867473898, x ^= (tmp = 867473899.0274491, tmp));
  assertEquals(6, x >>>= (tmp = 1174763611.341228, tmp));
  assertEquals(0, x >>= ((689882795)^(2250084531)));
  assertEquals(0, x /= (tmp = 2545625607, tmp));
  assertEquals(0, x >>= x);
  assertEquals(0, x += x);
  assertEquals(0, x -= (x*(-1098372339.5157008)));
  assertEquals(NaN, x %= x);
  assertEquals(NaN, x -= (tmp = -1797344676.375759, tmp));
  assertEquals(1121476698, x |= (tmp = 1121476698, tmp));
  assertEquals(1, x /= x);
  assertEquals(1, x &= (-191233693));
  assertEquals(330137888.92595553, x += (330137887.92595553));
  assertEquals(-1792236714, x ^= (tmp = 2256609910, tmp));
  assertEquals(269000724, x &= (316405813.62093115));
  assertEquals(256, x >>= x);
  assertEquals(256, x %= ((2556320341.54669)|(1066176021.2344948)));
  assertEquals(256, x |= x);
  assertEquals(131072, x <<= ((-1650561175.8467631)|x));
  assertEquals(-286761951, x -= ((tmp = 287024095, tmp)-((-2293511421)&(x|x))));
  assertEquals(-1561852927, x &= (3002663949.0989227));
  assertEquals(-460778761, x %= (tmp = -550537083, tmp));
  assertEquals(-3023749308.0492287, x += (tmp = -2562970547.0492287, tmp));
  assertEquals(-481313332.04922867, x %= ((x|((tmp = -855929299, tmp)%((2181641323)%(x|(220607471.33018696)))))&x));
  assertEquals(17510668, x &= (tmp = 363557663, tmp));
  assertEquals(12552, x &= (3020225307));
  assertEquals(1814655896, x |= ((x<<(((-1475967464)*(-3122830185))*x))+(x^(-2480340864.2661023))));
  assertEquals(-3209124403525266400, x -= ((1146847590)*(tmp = 2798213497, tmp)));
  assertEquals(-6418248807050533000, x += x);
  assertEquals(1.1856589432073933e+28, x *= (-1847324681.313275));
  assertEquals(-1238853292, x ^= (-1238853292));
  assertEquals(-77428331, x >>= (x&((((2043976651.8514216)>>>x)^(x>>>(((tmp = -1785122464.9720652, tmp)%x)<<(1570073474.271266))))*x)));
  assertEquals(2011, x >>>= x);
  assertEquals(2011, x &= x);
  assertEquals(0, x >>= (-2682377538));
  assertEquals(-1.1367252770299785, x -= (((tmp = 2704334195.566802, tmp)/(2379056972))%((((-1764065164)*((((468315142.8822602)>>((x%(((tmp = 2537190513.506641, tmp)+((x&(x|((tmp = -947458639, tmp)^(2653736677.417406))))*((x<<((1243371170.1759553)>>>(((tmp = 1572208816, tmp)<<((tmp = 963855806.1090456, tmp)>>>x))%((-3078281718.7743487)*x))))^(-1154518374))))^(-2839738226.6314087)))^((-2865141241.190915)*(-2400659423.8207664))))>>((tmp = 32940590, tmp)/(tmp = 2917024064.570817, tmp)))+(((27601850)/(tmp = 3168834986, tmp))>>x)))+(tmp = 2528181032.600125, tmp))/(3162473952))));
  assertEquals(-1697395408.7948515, x -= (1697395407.6581264));
  assertEquals(1536992607912062500, x *= (tmp = -905500627.5781817, tmp));
  assertEquals(102759872, x >>= (tmp = -707887133.4484048, tmp));
  assertEquals(102759872, x %= (tmp = -1764067619.7913327, tmp));
  assertEquals(12543, x >>>= (-144142995.1469829));
  assertEquals(-2059555229.2592103, x += ((-2059555229.2592103)-x));
  assertEquals(-537022593, x |= (tmp = -2770761410.407701, tmp));
  assertEquals(23777505, x ^= (-560496738.6854918));
  assertEquals(-64329014115772310, x *= ((tmp = -2729234369.198843, tmp)+x));
  assertEquals(189083830, x ^= (tmp = 933619934, tmp));
  assertEquals(189083830, x %= ((tmp = -2918083254, tmp)-(x|(x^(-2481479224.0329475)))));
  assertEquals(378167660, x += x);
  assertEquals(-0.45833387791900504, x /= ((tmp = 2727991875.241294, tmp)<<(tmp = 2570034571.9084663, tmp)));
  assertEquals(0, x <<= x);
  assertEquals(-0, x /= (tmp = -67528553.30662966, tmp));
  assertEquals(0, x <<= (938440044.3983492));
  assertEquals(-945479171, x ^= (tmp = -945479171, tmp));
  assertEquals(-225632619284361200, x *= (238643670.00884593));
  assertEquals(-0, x %= x);
  assertEquals(-585826304, x ^= ((-1256265560)<<(tmp = 1144713549, tmp)));
  assertEquals(-671583855, x ^= (183333265.1468178));
  assertEquals(-484311040, x <<= x);
  assertEquals(-3969762.62295082, x /= ((((tmp = -1164308668.931008, tmp)-x)%x)>>>(((397816647)>>(-1605343671.4070785))<<x)));
  assertEquals(758097879, x ^= ((tmp = -2871307491, tmp)^(-2043176492.646442)));
  assertEquals(0, x *= ((x>>(tmp = 1983292927, tmp))&(tmp = -860505131.4484091, tmp)));
  assertEquals(0, x <<= x);
  assertEquals(0, x &= x);
  assertEquals(0, x %= ((3132981707)-(-2832016477)));
  assertEquals(0, x >>= (x<<((1830195133.0342631)>>>(tmp = -1003969250, tmp))));
  assertEquals(NaN, x %= x);
  assertEquals(NaN, x += (tmp = 273271019.87603223, tmp));
  assertEquals(NaN, x += (625749326.1155348));
  assertEquals(0, x >>= (tmp = -531039433.3702333, tmp));
  assertEquals(0, x -= (((tmp = 2029464099, tmp)-(x-(tmp = -329058111.411458, tmp)))*(x<<x)));
  assertEquals(-0, x *= ((-1112957170.5613296)|((tmp = 847344494, tmp)>>>(tmp = 2735119927, tmp))));
  assertEquals(-0, x /= (tmp = 544636506, tmp));
  assertEquals(0, x >>>= (x^(545093699)));
  assertEquals(0, x %= (((tmp = -2208409647.5052004, tmp)+(3083455385.374988))+(((-482178732.7077277)*x)>>>((2661060565)*(-2125201239)))));
  assertEquals(0, x >>>= (-212334007.34016395));
  assertEquals(0.7004300865203454, x -= ((2032883941)/(-2902336693.0154715)));
  assertEquals(0, x <<= (x<<((265868133.50175047)>>>(1162631094))));
  assertEquals(604920272.4394834, x -= (-604920272.4394834));
  assertEquals(604920272, x &= x);
  assertEquals(0, x <<= (((-1961880051.1127694)%(tmp = 1715021796, tmp))|((tmp = 2474759639.4587016, tmp)|(243416152.55635))));
  assertEquals(-46419074, x |= (((tmp = -518945938.5238774, tmp)%((x+(tmp = 242636408, tmp))+(-1974062910)))|(1546269242.0259726)));
  assertEquals(-46419074, x += ((-629802130)*((tmp = -658144149, tmp)%((-905005358.5370393)>>>x))));
  assertEquals(-46419074, x |= (x%(-1103652494)));
  assertEquals(7892881050983985, x *= (-170035297.36469936));
  assertEquals(1105701997.4273424, x %= ((((-490612260.0023911)>>>(tmp = 1803426906, tmp))^(x%(2725270344.2568116)))-(1010563167.8934317)));
  assertEquals(1088619532, x &= (-2232199650));
  assertEquals(1073807364, x &= (-888024506.5008001));
  assertEquals(1153062254980628500, x *= x);
  assertEquals(1153062255703627000, x -= (tmp = -722998613.897227, tmp));
  assertEquals(-1141418584, x |= (3017232552.4814596));
  assertEquals(-373464140, x ^= (-2914372068));
  assertEquals(994050048, x <<= x);
  assertEquals(0, x ^= x);
  assertEquals(0, x &= (tmp = -3166402389, tmp));
  assertEquals(0, x &= ((-1760842506.337213)|(tmp = 2538748127.795164, tmp)));
  assertEquals(-0, x /= (-2635127769.808626));
  assertEquals(0, x &= ((((tmp = 1414701581, tmp)^(((2425608769)/((x<<x)^(x-x)))^((tmp = -2641946468.737288, tmp)|(tmp = -313564549.1754241, tmp))))*(tmp = -2126027460, tmp))|(-2255015479)));
  assertEquals(225482894, x ^= (225482894.8767246));
  assertEquals(0, x ^= x);
  assertEquals(306216231, x += (tmp = 306216231, tmp));
  assertEquals(306216231, x -= ((-465875275.19848967)&((-806775661.4260025)/((((-184966089.49763203)>>>((x>>x)+((tmp = -1951107532, tmp)|x)))%x)*((2704859526.4047284)%((x*x)>>x))))));
  assertEquals(30754, x &= (1706162402.033193));
  assertEquals(30454.010307602264, x -= (((590456519)>>>(tmp = 2713582726.8181214, tmp))/x));
  assertEquals(8419062, x |= ((2848886788)<<(tmp = 2993383029.402275, tmp)));
  assertEquals(16, x >>= (tmp = -1651287021, tmp));
  assertEquals(1, x /= x);
  assertEquals(-1407643485, x ^= (-1407643486));
  assertEquals(2, x >>>= (-1126004674));
  assertEquals(470812081, x ^= ((-2411718964)>>>x));
  assertEquals(550443688.6407901, x += (tmp = 79631607.6407901, tmp));
  assertEquals(3669092443.64079, x -= (-3118648755));
  assertEquals(-625874853, x <<= (((tmp = -1640437346, tmp)/(((x*x)>>>x)<<x))/x));
  assertEquals(-1431439050363516700, x *= (2287101077));
  assertEquals(-1921660672, x |= ((((((((-1912249689.9978154)&(-1676922742.5343294))*(2625527768))<<((820676465)^(((x+(tmp = -852743692, tmp))&((x-((((1361714551)/(311531668))>>>(tmp = -1330495518.8175917, tmp))<<(((tmp = 1369938417.8760853, tmp)*(-1217947853.8942266))<<(-2048029668))))-(-513455284)))>>>(tmp = 1980267333.6201067, tmp))))<<(((1503464217.2901971)>>(tmp = 2258265389, tmp))>>>(1868451148)))&(x-(x^(tmp = -1565209787, tmp))))*x)<<(tmp = -2426550685, tmp)));
  assertEquals(-1921660672, x %= (((tmp = 523950472.3315773, tmp)+(((2971865706)^x)-x))&(-1773969177)));
  assertEquals(420176973.1169958, x += (2341837645.116996));
  assertEquals(420176973, x >>>= (((tmp = -2485489141, tmp)<<((tmp = -2520928568.360244, tmp)+x))&(543950045.0932506)));
  assertEquals(50, x ^= (x|((tmp = 2001660699.5898843, tmp)>>>(tmp = 1209151128, tmp))));
  assertEquals(138212770720.96973, x *= (2764255414.4193945));
  assertEquals(-28683, x |= (((-535647551)|x)>>((((2065261509)>>(-354214733))*x)+(-3218217378.2592907))));
  assertEquals(1627048838, x ^= (tmp = -1627044749, tmp));
  assertEquals(-839408795, x ^= (2903337187.480303));
  assertEquals(-1000652427, x += (tmp = -161243632, tmp));
  assertEquals(740237908.4196916, x += ((tmp = 1587000348, tmp)+(tmp = 153889987.41969144, tmp)));
  assertEquals(Infinity, x /= (((((-615607376.1012697)&(57343184.023578644))+((-1967741575)|(-3082318496)))<<(((tmp = -958212971.99792, tmp)>>(tmp = 2962656321.3519197, tmp))-(x|(x*(969365195)))))<<(tmp = -1739470562.344624, tmp)));
  assertEquals(-Infinity, x /= ((tmp = -1736849852, tmp)%x));
  assertEquals(0, x <<= x);
  assertEquals(0, x %= (tmp = -226505646, tmp));
  assertEquals(1982856549, x -= (((x+(-1982856549))%(-2274946222))>>(x%(((tmp = -1289577208.9097936, tmp)>>x)^(778147661)))));
  assertEquals(1648018703, x ^= ((3085618856)+((tmp = 1546283467, tmp)&(((x|((-2376306530)*(((((((tmp = -2807616416, tmp)%(((((tmp = 347097983.1491085, tmp)<<x)|(((((1135380667)/(x>>>(tmp = 1679395106, tmp)))^((1277761947)<<((tmp = -1614841203.5244312, tmp)>>x)))%((tmp = 1552249234.2065845, tmp)>>>x))>>>(tmp = -1677859287, tmp)))>>>(2605907565))/(tmp = 2291657422.221277, tmp)))%(((tmp = 425501732.6666014, tmp)>>>(1327403879.455553))+x))>>((tmp = -3075752653.2474413, tmp)&(x-(tmp = -71834630, tmp))))|((((2532199449.6500597)*(-842197612.4577162))%x)>>x))*(((1220047194.5100307)<<((tmp = 1642962251, tmp)<<((-662340)>>>((tmp = -1672316631.3251066, tmp)<<((tmp = 1762690952.542441, tmp)-(x/(1904755683.3277364)))))))>>x))|(((((tmp = 1625817700.7052522, tmp)%(tmp = -2990984460, tmp))|(2395645662))-((2619930607.550086)>>x))^(tmp = 130618712, tmp)))))&((-3142462204.4628367)/(1078126534.8819227)))%(((tmp = -256343715.2267704, tmp)+x)^(tmp = 2009243755, tmp))))));
  assertEquals(1937698223, x |= (((tmp = 866354374.7435778, tmp)+(tmp = 2751925259.3264275, tmp))%(-2252220455)));
  assertEquals(0, x -= x);
  assertEquals(-823946290.6515498, x -= (tmp = 823946290.6515498, tmp));
  assertEquals(706970324, x ^= (-457174758));
  assertEquals(32916, x &= (25740724));
  assertEquals(0, x >>>= ((-1658933418.6445677)|(tmp = -846929510.4794133, tmp)));
  assertEquals(0, x ^= ((-834208600)/((-1256752740)&(tmp = 1973248337.8973258, tmp))));
  assertEquals(-1639195806, x += (-1639195806));
  assertEquals(-1559416478, x ^= ((tmp = 1349893449.0193534, tmp)*(tmp = 2044785568.1713037, tmp)));
  assertEquals(0, x &= ((x>>(tmp = 1720833612, tmp))/((x+(-1305879952.5854573))^x)));
  assertEquals(-0, x *= (tmp = -1713182743, tmp));
  assertEquals(0, x >>= x);
  assertEquals(NaN, x /= (((x%((x>>>(((-1515761763.5499895)^(-3076528507.626539))<<(tmp = 1293944457.8983147, tmp)))<<(tmp = 276867491.8483894, tmp)))>>(tmp = -2831726496.6887417, tmp))%((((tmp = 1780632637.3666987, tmp)^x)%((208921173.18897665)>>(tmp = 633138136, tmp)))+x)));
  assertEquals(0, x >>= (tmp = -2755513767.0561147, tmp));
  assertEquals(0, x |= x);
  assertEquals(840992300.0324914, x -= ((-840992300.0324914)+x));
  assertEquals(840992300, x &= x);
  assertEquals(-1094140277, x ^= (2364029095));
  assertEquals(-Infinity, x /= ((((((1257084956)<<(2009241695))>>(x+x))*x)>>>x)>>>(205318919.85870552)));
  assertEquals(-Infinity, x -= (((x>>>(tmp = 3037168809.20163, tmp))&x)*(x&(((806151109)*x)-(tmp = -1741679480.58333, tmp)))));
  assertEquals(400659949, x ^= (tmp = 400659949, tmp));
  assertEquals(5, x >>= (tmp = 1175519290, tmp));
  assertEquals(5, x |= x);
  assertEquals(0, x >>= x);
  assertEquals(0, x >>= ((1317772443)&(x<<x)));
  assertEquals(-1123981819, x ^= (tmp = 3170985477, tmp));
  assertEquals(1123864651, x ^= ((x%(((x&x)&(-2606227299.7590737))<<((tmp = -2018123078.1859496, tmp)*x)))|(x+(((((1935939774.8139446)/((-1303958190)/(2802816697.32639)))<<((2880056582)*x))+x)+x))));
  assertEquals(1543368927, x |= (-2795691884));
  assertEquals(NaN, x /= (x%((tmp = -1129915114, tmp)<<x)));
  assertEquals(NaN, x += (tmp = -3045743135, tmp));
  assertEquals(NaN, x -= (tmp = -2849555731.8207827, tmp));
  assertEquals(NaN, x /= (((((2127485827)>>>((((tmp = 363239924, tmp)>>x)|((((tmp = -1419142286.0523334, tmp)-(x<<x))^(tmp = -1990365089.8283136, tmp))*((tmp = 2780242444.0739098, tmp)>>>(((-2336511023.342298)&x)/(tmp = 2296926221.402897, tmp)))))>>((tmp = 1378982475.6839466, tmp)>>(tmp = -816522530, tmp))))&(x^(tmp = -1668642255.0586753, tmp)))%(((tmp = 921249300.1500335, tmp)^x)*(tmp = -2228816905, tmp)))>>x));
  assertEquals(-1460685191, x |= (tmp = 2834282105, tmp));
  assertEquals(-1463439264, x &= (tmp = 2881860064.146755, tmp));
  assertEquals(20.98100714963762, x /= (((3017150580.7875347)^((250499372.5339837)<<(tmp = -42767556.30788112, tmp)))|(x%(-2829281526))));
  assertEquals(1, x /= x);
  assertEquals(2, x += x);
  assertEquals(8, x <<= x);
  assertEquals(0, x >>>= ((730174750)>>>x));
  assertEquals(0, x ^= x);
  assertEquals(-1459637373, x ^= (2835329923.456409));
  assertEquals(-1233115861, x ^= (511678120));
  assertEquals(95682857, x >>>= ((tmp = 1534570885, tmp)|(tmp = -414425499.3786578, tmp)));
  assertEquals(70254633, x &= (-1502067585));
  assertEquals(51384749748909710, x *= (tmp = 731407276, tmp));
  assertEquals(9390482.873469353, x %= (tmp = -592576964.7982686, tmp));
  assertEquals(4695241, x >>>= (tmp = -1879898431.5395758, tmp));
  assertEquals(-3129811912538149000, x += (((-727481809)^((3106908604)%x))*((((tmp = -1218123690, tmp)^(x>>((-942923806)^x)))/(x+x))>>>(-1508881888.969373))));
  assertEquals(1596870236, x ^= (-1135673764.9721224));
  assertEquals(0, x ^= x);
  assertEquals(2133782410, x |= (((-2202469371)>>((tmp = 1327588406.183342, tmp)/(tmp = 253581265.7246865, tmp)))-((tmp = 2226575446.838795, tmp)^x)));
  assertEquals(-81895217.83608055, x -= (tmp = 2215677627.8360806, tmp));
  assertEquals(812089344, x <<= ((tmp = 882824005, tmp)/(((x>>((((((((tmp = 1211145185, tmp)/((-137817273)-(((tmp = 2165480503.1144185, tmp)-(-1840859887.1288517))*((155886014.8393339)>>((-1984526598)<<(tmp = 1331249058.3246582, tmp))))))>>(x*x))%(2830324652))%(933701061))|(1346496215))^(tmp = -988800810, tmp))+x))>>>x)<<(-2372088384))));
  assertEquals(812089344, x <<= x);
  assertEquals(8472, x %= ((((x|(((x%(tmp = 2772099481.664402, tmp))+(2894690616))-x))&(x&(((-715790638.6454093)>>(tmp = -1447931029, tmp))-(tmp = 1761027889, tmp))))^x)%(((tmp = 830969811, tmp)|x)|((-1102267929)-(3193018687)))));
  assertEquals(-0.0000028559857417864914, x /= (-2966401364));
  assertEquals(0, x >>= x);
  assertEquals(-701800392, x += (tmp = -701800392, tmp));
  assertEquals(2034756873, x -= (tmp = -2736557265, tmp));
  assertEquals(-0.9475075048394501, x /= (((((82879340.27231383)+((tmp = -2876678920.653639, tmp)*(-2801097850)))<<x)>>>((x<<(((((x|x)&(tmp = -1572694766, tmp))>>(x+(x/((x-(((tmp = 1435301275, tmp)|(tmp = 983577854.212041, tmp))>>(tmp = 632633852.1644179, tmp)))+x))))>>>x)|(-850932021)))>>x))<<(-821983991)));
  assertEquals(0, x >>= (x>>(2424003553.0883207)));
  assertEquals(2599386349, x -= (-2599386349));
  assertEquals(-68157441, x |= (((tmp = -1170343454.9327996, tmp)+((((tmp = 448468098, tmp)|(x>>(x>>(((x>>(((x/(x&(x<<x)))<<(2436876051.2588806))^(3010167261)))%((tmp = 2577616315.7538686, tmp)>>>(-2953152591.015912)))%((tmp = -1304628613, tmp)/(x&((x|((-2000952119)%((691146914)/((tmp = 1480966978.7766845, tmp)<<((tmp = 2644449477.392441, tmp)|(-2143869305.871568))))))+(tmp = -315254308, tmp))))))))&(-2060205555))|((-604140518.8186448)^(x*x))))%(x*((tmp = 1383244000.2807684, tmp)/(3195793656)))));
  assertEquals(-68157441, x |= x);
  assertEquals(-1, x >>= x);
  assertEquals(-2147483648, x <<= x);
  assertEquals(-1.5257198286933313, x /= (tmp = 1407521622, tmp));
  assertEquals(1149084989.47428, x += (((tmp = 1149084991.9004865, tmp)&x)^((((((2797053000)/(x^x))*(-2829253694))>>>((tmp = -610924351, tmp)>>x))>>>(tmp = -675681012, tmp))<<(2812852729))));
  assertEquals(0, x %= x);
  assertEquals(0, x <<= ((tmp = -584069073, tmp)*(-2953140326)));
  assertEquals(0, x <<= (tmp = -481515023.6404002, tmp));
  assertEquals(-1441535370, x ^= (2853431926));
  assertEquals(2853431926, x >>>= (((((((tmp = 2215663525.9620194, tmp)%((-1102832735.9274108)/x))>>x)&(3220898702.76322))&(((2077584946)*((x>>x)<<((tmp = 1845701049, tmp)-x)))/(tmp = 1947184202.5737212, tmp)))|(((tmp = 2976351488, tmp)^(-42517339))%((2648230244.410125)^(1520051731.31089))))/(1761635964)));
  assertEquals(43539, x >>>= (tmp = 1361671184.7432632, tmp));
  assertEquals(21769, x >>= ((tmp = -804932298.9572575, tmp)>>((((tmp = 1749006993.253409, tmp)+(276536978))^x)|(2698166994))));
  assertEquals(1103025563, x |= (tmp = 1103007891, tmp));
  assertEquals(1327594607, x += (tmp = 224569044, tmp));
  assertEquals(1327594607, x |= x);
  assertEquals(-478674944, x <<= (((672378508)&x)^(((-2070209708.6470091)|x)|(x>>>x))));
  assertEquals(-478674943, x ^= ((-1832457698.6345716)>>>((tmp = -3077714019, tmp)/(1809383028))));
  assertEquals(229129701056053250, x *= x);
  assertEquals(1, x /= x);
  assertEquals(2, x <<= (-1522529727));
  assertEquals(2, x &= x);
  assertEquals(-2016989182, x |= ((((tmp = -1267845511, tmp)*(1225350332))+((tmp = -1397690831.5717893, tmp)>>>(tmp = -2575382994, tmp)))+x));
  assertEquals(-241, x >>= (tmp = 931869591, tmp));
  assertEquals(-1048087547, x &= (tmp = -1048087403.1163051, tmp));
  assertEquals(-4004486369.844599, x += (tmp = -2956398822.844599, tmp));
  assertEquals(-4004486368.844599, x -= (((2701878498)>>x)|(x|(-1079354967))));
  assertEquals(1, x >>= (tmp = -1583689092, tmp));
  assertEquals(1, x *= (x>>(x%x)));
  assertEquals(0, x %= x);
  assertEquals(-0, x *= (-120818969));
  assertEquals(0, x >>= ((tmp = 1794099660, tmp)/(((x&(((-321906091)^(tmp = -3009885933.8449526, tmp))&((tmp = -140917780, tmp)|(2037803173.4075825))))&x)&(tmp = -745357154, tmp))));
  assertEquals(0, x <<= (563984257.3493614));
  assertEquals(NaN, x %= ((((x>>(tmp = -2190891392.320677, tmp))-x)<<(462714956))<<((tmp = -84413570, tmp)|((x|(-2787022855))-((tmp = 2028532622, tmp)|(tmp = 1103757073.9178817, tmp))))));
  assertEquals(NaN, x *= ((2137674085.3142445)|((tmp = -1054749859.2353804, tmp)%x)));
  assertEquals(NaN, x /= (x>>>(((((tmp = 597103360.9069608, tmp)>>>(-2850217714.1866236))-((tmp = 1125150527, tmp)*x))%(tmp = -982662312, tmp))|((x/(((968656808.6069037)*(((128484784.15362918)>>x)^x))&((((x/((((tmp = 748775979, tmp)*((x-(((tmp = 709571811.9883962, tmp)%(-2083567026))%(x/(tmp = -680467505, tmp))))/((tmp = -167543858, tmp)/(tmp = -3113588783, tmp))))/x)<<(-2605415230)))>>>(tmp = 3133054172, tmp))%(tmp = -1904650393, tmp))*((x|(-1193709562))*(tmp = -1731312795.718104, tmp)))))/((tmp = -672386301, tmp)/(tmp = 808898833.4163612, tmp))))));
  assertEquals(-9, x |= (((((tmp = 150377964.57195818, tmp)/(tmp = 2161910879.0514045, tmp))-(-2381625849))>>(-2715928517))/(((452113643)^(-2502232011))/((-3076471740)^(((tmp = 1664851172, tmp)*(((-1460011714)>>>x)<<((-2870606437)%x)))*((tmp = -2836565755.609597, tmp)-((x/(tmp = -871461415, tmp))-(2278867564))))))));
  assertEquals(-1, x >>= x);
  assertEquals(-1, x |= ((-1319927272)>>>(-2866709980)));
  assertEquals(-1, x >>= ((2345179803.155703)&(-978025218.2243443)));
  assertEquals(1, x /= x);
  assertEquals(-260730973, x |= (tmp = -260730973, tmp));
  assertEquals(1174405120, x <<= (2681054073));
  assertEquals(1174405120, x &= x);
  assertEquals(1073741824, x &= (tmp = 2017166572.7622075, tmp));
  assertEquals(1073741824, x |= x);
  assertEquals(168806102, x %= ((((tmp = -2939969193.950067, tmp)|((-2325174027.614815)/(-2329212715)))*(x/(((((-2927776738)/(x|x))+(x%(tmp = -3007347037.698492, tmp)))<<(-1898633380))>>(tmp = 204338085.45241892, tmp))))^x));
  assertEquals(168806102, x %= ((-832849739.5197744)&(tmp = -141908598, tmp)));
  assertEquals(-401033205.05225074, x -= (tmp = 569839307.0522507, tmp));
  assertEquals(-401033205, x &= x);
  assertEquals(-401130402, x ^= ((x*(tmp = 311418759.22436893, tmp))>>x));
  assertEquals(793533469, x ^= (-950312893.5201888));
  assertEquals(756, x >>>= (-1096189516));
  assertEquals(711, x += ((tmp = -753105189, tmp)>>(599823192.5381484)));
  assertEquals(0, x >>>= ((tmp = -2859668634.4641137, tmp)+(-1160392986.1521513)));
  assertEquals(2427599726.176195, x -= (-2427599726.176195));
  assertEquals(1942312465.2523103, x -= (485287260.92388475));
  assertEquals(0, x >>>= ((tmp = -1740656456, tmp)/(tmp = 1339746799.9335847, tmp)));
  assertEquals(0, x <<= ((-7017077.38786912)*((-699490904.4551768)^x)));
  assertEquals(0, x <<= (tmp = 715662384, tmp));
  assertEquals(0, x *= (x>>>(2149735450.0758677)));
  assertEquals(NaN, x /= x);
  assertEquals(0, x >>= ((397078885)*((851639692.8982519)-x)));
  assertEquals(0, x &= (-2526654445));
  assertEquals(0, x %= (-1204924598));
  assertEquals(251639720, x ^= (x|(tmp = 251639720, tmp)));
  assertEquals(695433573, x ^= (663539405));
  assertEquals(-1038050104, x -= (1733483677));
  assertEquals(0, x ^= x);
  assertEquals(NaN, x %= x);
  assertEquals(0, x &= (392107269));
  assertEquals(0, x %= (-3084908458.241551));
  assertEquals(0, x ^= x);
  assertEquals(-2121660509, x ^= (tmp = -2121660509.7861986, tmp));
  assertEquals(2285041855588855800, x *= (x|(3209046634)));
  assertEquals(54915072, x >>>= (x%(((((x%((((tmp = -1429433339.5078833, tmp)|(tmp = 2906845137, tmp))^(3207260333))&(-848438650)))-(-2721099735))&(141851917.19978714))+x)/x)));
  assertEquals(54915072, x &= x);
  assertEquals(54915072, x %= (x+(1855489160)));
  assertEquals(70078753, x ^= ((((((-1648661736)+(x%((-1421237596)+(tmp = 2053180992.3857927, tmp))))+(tmp = 38606889, tmp))<<((-241334284)%((x>>(215316122))*(tmp = 396488307, tmp))))+((tmp = -2900704565, tmp)^x))^(((1103481003.1111188)^x)-(tmp = 1304113534, tmp))));
  assertEquals(1149501440, x <<= ((x>>(tmp = 3203172843, tmp))*(tmp = -192535531, tmp)));
  assertEquals(0, x ^= x);
  assertEquals(0, x >>= ((tmp = 2751499787, tmp)&((tmp = 2217654798, tmp)*(tmp = -2798728014, tmp))));
  assertEquals(NaN, x /= ((((-2019592425)>>>((((-1571930240.741224)>>>((-183952981)/((((1990518443.672842)>>(((((2051371284)%(685322833.6793983))>>>(2662885938))<<(-1212029669.6675105))|((-2790877875)<<(1546643473))))<<x)-(tmp = 804296674.4579233, tmp))))-(tmp = -417759051.68770766, tmp))/((-621859758)>>>x)))&x)<<(tmp = -48558935.55320549, tmp)));
  assertEquals(0, x <<= (x&x));
  assertEquals(0, x *= (x%(tmp = 301196068, tmp)));
  assertEquals(398290944, x |= (((tmp = 1904146839, tmp)+(1521017178))*(-3174245888.562067)));
  assertEquals(1256401076, x ^= (1566464180));
  assertEquals(149620758, x %= ((tmp = 532626355, tmp)^(tmp = -382971203, tmp)));
  assertEquals(149620791, x |= (x>>x));
  assertEquals(-0.07034576194938641, x /= ((tmp = -1977313182.7573922, tmp)-x));
  assertEquals(0, x <<= x);
  assertEquals(0, x &= x);
  assertEquals(0, x /= ((2182424851.139966)%(((-2768516150)+x)>>>x)));
  assertEquals(0, x %= (-504299638.53962016));
  assertEquals(-0, x *= (-2915134629.6909094));
  assertEquals(0, x <<= ((tmp = 952692723.402582, tmp)%(2146335996.785011)));
  assertEquals(230457472, x |= ((tmp = -574776101.8681948, tmp)*(683185125)));
  assertEquals(933795934, x ^= (tmp = 974395614, tmp));
  assertEquals(933801974, x ^= (x>>>((-148683729)*(((tmp = 2912596991.415531, tmp)^(-2883672328))/x))));
  assertEquals(222, x >>= (-3060224682));
  assertEquals(27, x >>>= (1429156099.1338701));
  assertEquals(754519106, x ^= (tmp = 754519129.7281355, tmp));
  assertEquals(188629776, x >>>= ((x>>>((1247267193)<<(tmp = -936228622, tmp)))%((tmp = 978604324.8236886, tmp)*((tmp = -3018953108, tmp)^(((tmp = 259650195, tmp)>>>(tmp = 2762928902.7901163, tmp))*(x>>((tmp = 787444263.5542864, tmp)/(x>>>(((-2039193776)<<(tmp = -1408159169, tmp))-(1238893783))))))))));
  assertEquals(188629775.33987066, x += ((tmp = 1040520414, tmp)/((-1576237184)|((tmp = -970083705, tmp)&(((tmp = -312062761.12228274, tmp)|(1171754278.2968853))<<(-2069846597.7723892))))));
  assertEquals(1473670, x >>>= ((tmp = 202409672, tmp)^x));
  assertEquals(2171703268900, x *= (x>>(((tmp = 840468550, tmp)&(-3208057101.2136793))/x)));
  assertEquals(0, x ^= x);
  assertEquals(0, x ^= (x&((tmp = 2569871408.2405066, tmp)|((tmp = -3149374622, tmp)<<(x-(x|((tmp = -821239139.1626894, tmp)>>>x)))))));
  assertEquals(NaN, x /= x);
  assertEquals(NaN, x %= (tmp = 1926106354, tmp));
  assertEquals(0, x >>= ((x/(-2848416))/(tmp = 2484293767, tmp)));
  assertEquals(0, x <<= ((tmp = -2484137114, tmp)>>>(tmp = -887083772.8318355, tmp)));
  assertEquals(0, x >>= (tmp = -2651389432, tmp));
  assertEquals(0, x ^= x);
  assertEquals(1041871201, x += ((tmp = 1041871201.9272791, tmp)|(x<<(-1136959830))));
  assertEquals(651390879501530900, x *= ((tmp = 1250424964.0346212, tmp)>>x));
  assertEquals(1965815296.245636, x %= ((2650603245.655831)+((-1610821947.8640454)>>>(((878987151.6917406)*((((784630543)%(((1448720244)>>(((tmp = 3036767847, tmp)+((tmp = 1012548422, tmp)<<(1957000200)))-x))/(x>>x)))<<((tmp = 914710268, tmp)*(((x^(1559603121))<<(tmp = 3181816736, tmp))|((-1964115655)+x))))-(-1055603890)))&(946797797.0616649)))));
  assertEquals(1965815296.245636, x %= (tmp = -2601038357.593118, tmp));
  assertEquals(-769384440.872302, x += (-2735199737.117938));
  assertEquals(-769384440.872302, x %= (2193123162));
  assertEquals(1, x /= x);
  assertEquals(1, x -= (((x>>>(-1968465925))*((tmp = 563037904, tmp)>>((tmp = 3009534415.769578, tmp)>>((-2567240601.7038674)<<(tmp = -1258402723.4150183, tmp)))))%(3112239470.276867)));
  assertEquals(1, x |= x);
  assertEquals(1505461527, x ^= (tmp = 1505461526.5858076, tmp));
  assertEquals(406553877, x &= (tmp = 2558242293, tmp));
  assertEquals(406553877, x |= x);
  assertEquals(-574902339, x |= ((-709809495)%(tmp = -2880884811.410611, tmp)));
  assertEquals(-20281777.349363208, x %= (22184822.46602547));
  assertEquals(1, x /= x);
  assertEquals(-4360732, x ^= ((x|(tmp = 3178620274, tmp))>>(((2686286888)&(((-1107223053.8716578)/(((-2955575332.3675404)+(-2770518721))|(-2705016953.640522)))-x))^((1473641110.4633303)*((((-1466496401)<<x)+x)%(1805868749.082736))))));
  assertEquals(-1158545408, x <<= ((((x/((-2710098221.691819)-(-2421462965.788145)))/(((((x>>>(tmp = 1994541591.1032422, tmp))+(tmp = -1276676679.9747126, tmp))&((tmp = 1764029634.2493339, tmp)+((x|(tmp = -3050446156, tmp))-((tmp = -9441859, tmp)/(((-2072420232)&x)*(-1003199889))))))+(tmp = -2443230628, tmp))*x))*((x&((((x|(747566933))*(((2039741506)>>>((tmp = -2456000554, tmp)>>>(-1566360933.7788877)))^((tmp = 960600745, tmp)/x)))&(x^(((-2649310348.777452)^((2224282875)-(tmp = -2129141087.3182096, tmp)))<<((x<<x)+((-1307892509.3874407)-(x|(tmp = -2831643528.9720087, tmp)))))))/(((tmp = -35502946, tmp)<<((tmp = 1091279222, tmp)>>(((-2686069468.8930416)-x)+(tmp = 367442353.2904701, tmp))))%(1218262628))))/x))^(-919079153.7857773)));
  assertEquals(747, x >>>= (1229157974));
  assertEquals(747, x |= x);
  assertEquals(NaN, x %= (((3086718766.4715977)*((7912648.497568846)*((-2713828337.1659327)*(-176492425.4011252))))<<(tmp = -1074475173, tmp)));
  assertEquals(0, x >>>= ((((444923201)<<x)>>>(-883391420.2142565))*((((617245412)<<x)>>>x)*(-913086143.2793813))));
  assertEquals(1941802406, x ^= (tmp = -2353164890, tmp));
  assertEquals(14, x >>>= (-1600311077.4571416));
  assertEquals(-18229482703.7246, x += (((x+(-993157139.7880647))%x)*(1862419512.1781366)));
  assertEquals(-14.531388114858734, x /= ((tmp = -1649072797.951641, tmp)<<x));
  assertEquals(0, x ^= x);
  assertEquals(0, x >>= ((x/x)^x));
  assertEquals(2, x ^= ((-1597416259)/(-738770020)));
  assertEquals(0, x >>= (tmp = -387850072.74833393, tmp));
  assertEquals(0, x >>>= ((2491085477.186817)>>(x*(((tmp = -1592498533, tmp)+(tmp = 2086841852, tmp))&(-3174019330.8288536)))));
  assertEquals(0, x >>= x);
  assertEquals(0, x >>>= (tmp = -3045348659.45243, tmp));
  assertEquals(-1208573479, x |= ((3086393817)-x));
  assertEquals(1460649854142163500, x *= x);
  assertEquals(1588199424, x <<= (-1902076952));
  assertEquals(1586102272, x &= (tmp = 2139876091.9142454, tmp));
  assertEquals(-460908552.5528109, x -= (tmp = 2047010824.552811, tmp));
  assertEquals(-460908552.5528109, x %= (tmp = 507904117.09368753, tmp));
  assertEquals(-460908552.5528109, x %= (2749577642.527038));
  assertEquals(234012, x >>>= (-340465746.91275));
  assertEquals(0, x >>>= x);
  assertEquals(0, x %= (tmp = -2601875531, tmp));
  assertEquals(0, x %= (x|(tmp = 650979981.1158671, tmp)));
  assertEquals(0, x %= (tmp = -2286020987, tmp));
  assertEquals(0, x |= x);
  assertEquals(0, x &= (x|((tmp = 2568101411, tmp)-(-1438002403))));
  assertEquals(0, x >>>= (1399248574));
  assertEquals(0, x %= (-1906670287.2043698));
  assertEquals(0, x >>= (1019286379.6962404));
  assertEquals(0, x |= (x/(tmp = -82583591.62643051, tmp)));
  assertEquals(NaN, x %= x);
  assertEquals(NaN, x *= (x^(1874776436)));
  assertEquals(NaN, x -= ((-1238826797)-(-2971588236.7228813)));
  assertEquals(0, x <<= (2064632559));
  assertEquals(-0.5967273958864694, x += (((tmp = 1502995019, tmp)>>x)/(-2518729707)));
  assertEquals(0, x >>>= x);
  assertEquals(-0, x /= (-1923030890));
  assertEquals(NaN, x %= x);
  assertEquals(0, x >>= (tmp = 1081732779.9449487, tmp));
  assertEquals(-820183066, x |= ((tmp = -3169007292.4721155, tmp)|(-1912588318)));
  assertEquals(0, x -= x);
  assertEquals(NaN, x %= x);
  assertEquals(NaN, x /= (tmp = 287181840, tmp));
  assertEquals(0, x &= (x/((tmp = -1139766051, tmp)<<(x&(tmp = 2779004578, tmp)))));
  assertEquals(0, x >>= (((tmp = -1816938028, tmp)+(-224851993.3139863))*(-2933829524)));
  assertEquals(0, x |= ((((tmp = 305077929.1808746, tmp)&((x-(((((tmp = 2122810346.7475111, tmp)<<(717271979))*(tmp = 256854043.72633624, tmp))%((x+(tmp = -318657223.9992106, tmp))*((1993144830)<<(2594890698.603228))))^((((tmp = 257370667, tmp)>>>((((x^(3160746820))>>>(2049640466.8116226))>>>(2543930504.7117066))^(x-x)))^(x%(964838975)))^x)))%(x*x)))>>>x)*(tmp = -46861540, tmp)));
  assertEquals(747575633, x ^= ((-2406502427)-(-3154078060.3794584)));
  assertEquals(0, x *= (x%x));
  assertEquals(0, x <<= (1313773705.3087234));
  assertEquals(0, x >>>= ((x+x)>>>(3068164056)));
  assertEquals(-0, x *= (tmp = -1771797797, tmp));
  assertEquals(1784146970, x ^= (tmp = 1784146970, tmp));
  assertEquals(1784146970, x >>>= (tmp = -2219972320.7195597, tmp));
  assertEquals(1744830464, x <<= ((((-2769476584)-(((1798431604)>>(tmp = 1337687914.799577, tmp))>>>((-2802941943.15014)>>x)))>>>(tmp = 646033678, tmp))-x));
  assertEquals(3044433348102455300, x *= x);
  assertEquals(0, x >>= ((tmp = 1592076570.1900845, tmp)-((645774223.6317859)>>x)));
  assertEquals(0, x >>= (x>>>(-3045822290.1536255)));
  assertEquals(-0, x *= (tmp = -2450298800.986624, tmp));
  assertEquals(0, x >>= (tmp = 1379605393, tmp));
  assertEquals(0, x &= (((x-((((tmp = 837939461.6683749, tmp)+((((-813261853.3247359)|(x&(((-2565113940)*(tmp = -2725085381.240134, tmp))|x)))%(-1457259320))-(x+((tmp = -273947066, tmp)%((1164825698.879649)>>(1653138880.3434052))))))>>>(2823967606.411492))>>>((((((((1189235604.9646997)/(tmp = -2875620103.4002438, tmp))-(tmp = -801261493, tmp))<<(((1832556579.5095325)<<x)|((tmp = -2740330665, tmp)>>(tmp = -2352814025, tmp))))-(tmp = -1445043552.99499, tmp))&(x<<(((((445325471)*(1293047043.1808558))>>>(((1901837408.5910044)-(tmp = -2349093446.5313253, tmp))>>>(tmp = 1000847053.1861948, tmp)))*(x>>>(1771853406.6567078)))>>x)))>>>x)>>>(x^((tmp = 2813422715, tmp)-(x+(-342599947)))))))&(x>>>x))*x));
  assertEquals(NaN, x %= ((tmp = -3027713526, tmp)-((((x%(((((x/((2711155710)^(((((x>>>x)%((1098599291.155015)^(((((tmp = 1855724377.8987885, tmp)/(x|x))*((-1963179786)*((x-((-1634717702)%x))<<x)))>>(2008859507))>>((tmp = 2635024299.7983694, tmp)^(tmp = -602049246, tmp)))))*(x>>x))&(tmp = -1925103609, tmp))*((tmp = 2106913531.2828505, tmp)%((tmp = -200970069, tmp)*(-2809001910.951446))))))%x)*((1990098169)>>((x<<(2303347904.2601404))%x)))|(2767962065.9846206))+(201589933.301661)))>>(((tmp = 1921071149.5140274, tmp)>>(1054558799.1731887))|x))*(x/((((-2833879637.345674)>>>(tmp = 2849099601, tmp))%x)+(x%(x%(((tmp = 1983018049, tmp)^(tmp = -2659637454, tmp))>>((-1335497229.6945198)-(x+(((((tmp = 1136612609.848967, tmp)%(2471741030.01762))<<(x|(((tmp = 1644081190.1972675, tmp)&(-1422527338))^(2379264356.265957))))/(tmp = 2979299484.1884174, tmp))/x)))))))))*((tmp = 1858298882, tmp)^((tmp = -547417134.9651439, tmp)*x)))));
  assertEquals(-7664, x |= ((2286000258.825538)>>(1716389170)));
  assertEquals(-1, x >>= x);
  assertEquals(-1231640486.3023372, x += ((tmp = 1231640485.3023372, tmp)*x));
  assertEquals(-2463280972.6046743, x += x);
  assertEquals(1746, x >>>= x);
  assertEquals(1746, x >>>= (((tmp = -562546488.0669937, tmp)*((-2475357745.8508205)&((x%(821425388.8633704))%((((-2315481592.687686)&(((tmp = 3130530521.7453523, tmp)+x)-x))^(-973033390.1773088))/x))))<<x));
  assertEquals(1746, x %= (-1544973951.076033));
  assertEquals(27936, x <<= (-525441532.33816123));
  assertEquals(27936, x %= (x*((tmp = 344991423.5336287, tmp)+(-2267207281))));
  assertEquals(27, x >>>= (tmp = 1249792906, tmp));
  assertEquals(0, x >>>= (tmp = -1068989615, tmp));
  assertEquals(0, x >>>= (tmp = 347969658.92579734, tmp));
  assertEquals(-2656611892, x -= (2656611892));
  assertEquals(1944539596, x |= (((tmp = 3000889963, tmp)-x)<<((tmp = 2917390580.5323124, tmp)^(-996041439))));
  assertEquals(1944539596, x |= x);
  assertEquals(-739740167.0752468, x -= ((1712009965.0752468)+(x>>((tmp = -740611560.99014, tmp)>>>((tmp = -1033267419.6253037, tmp)&(862184116.3583733))))));
  assertEquals(-1479480334.1504936, x += x);
  assertEquals(-4294967296.150494, x -= (x>>>((1219235492.3661718)&(3138970355.0665245))));
  assertEquals(0, x >>= (x*x));
  assertEquals(-0, x *= ((-2202530054.6558375)-(-676578695)));
  assertEquals(-0, x %= (1336025846));
  assertEquals(0, x &= x);
  assertEquals(0, x /= (1759366510));
  assertEquals(630007622, x |= (630007622));
  assertEquals(-0.22460286863455903, x /= (tmp = -2804984753, tmp));
  assertEquals(1102410276.775397, x -= (-1102410277));
  assertEquals(1102410276.775397, x %= ((((-2569525203)&x)*(x|(-1932675298)))/((-2376634450)>>>(x>>>(tmp = 936937604.9491489, tmp)))));
  assertEquals(33642, x >>= (3028252527));
  assertEquals(2181106522.688034, x -= (-2181072880.688034));
  assertEquals(-2113861630, x &= (2523921542));
  assertEquals(-2147483646, x &= (-1996601566.9370148));
  assertEquals(-2147483648, x &= (tmp = -665669175.1968856, tmp));
  assertEquals(-2858673260.1367273, x -= (tmp = 711189612.1367272, tmp));
  assertEquals(350657, x >>= (tmp = -170243892.25474262, tmp));
  assertEquals(-0.0001405571562140975, x /= (-2494764474.7868776));
  assertEquals(0, x ^= x);
  assertEquals(NaN, x /= ((x&(-2041236879))*((tmp = -2182530229, tmp)^((1274197078)*x))));
  assertEquals(0, x |= (x&(x-(1794950303))));
  assertEquals(1222105379, x |= (tmp = 1222105379, tmp));
  assertEquals(729884484, x ^= (tmp = 1666645607.6907792, tmp));
  assertEquals(729884484, x %= (tmp = -2896922082, tmp));
  assertEquals(8768, x &= ((tmp = 358940932, tmp)>>>(3159687631.3308897)));
  assertEquals(1892384495, x |= (-2402591569));
  assertEquals(1892470533, x += ((((x^(-2266612043))>>>(tmp = -531009952, tmp))<<(x>>>((-1365315963.5698428)>>>((x+((-3168207800.184341)-(tmp = 1776222157.609917, tmp)))+(-1588857469.3596382)))))>>>x));
  assertEquals(143587205, x += (tmp = -1748883328, tmp));
  assertEquals(0, x ^= x);
  assertEquals(0, x >>= (tmp = 2334880462.3195543, tmp));
  assertEquals(0, x &= ((tmp = 1819359625.4396145, tmp)|(tmp = -1323513565, tmp)));
  assertEquals(-1102259874, x ^= (3192707422));
  assertEquals(2567457772588852700, x *= (-2329267202));
  assertEquals(-16783687, x |= ((-2212476227.060922)^(378973700.78452563)));
  assertEquals(4278183609, x >>>= ((((((((tmp = 1766363150.197206, tmp)*(-2774552871))%x)>>>((3071429820)&((((((tmp = 351068445.27642524, tmp)<<(tmp = 2646575765, tmp))^(806452682))<<((x>>>(-2217968415.505327))<<(1564726716)))|x)-(tmp = -3110814468.9023848, tmp))))+x)^x)>>>(tmp = -617705282.0788529, tmp))>>>x));
  assertEquals(4314933530, x -= ((1032195469.789219)|(tmp = -448053861.9531791, tmp)));
  assertEquals(9709850, x %= (((tmp = -3056286252.5853324, tmp)*x)&x));
  assertEquals(9709850, x %= (tmp = -2596800940, tmp));
  assertEquals(2655489828.9461126, x -= (tmp = -2645779978.9461126, tmp));
  assertEquals(369266212, x &= (((335712316.24874604)|(tmp = 33648215, tmp))-((x/(2639848695))<<((-499681175)<<(-2490554556)))));
  assertEquals(-2147483648, x <<= (-834465507));
  assertEquals(1073741824, x >>>= (((tmp = 3018385473.1824775, tmp)>>(x*(-2574502558.216812)))|(((tmp = -1742844828, tmp)*(1698724455))&x)));
  assertEquals(-270818218, x += (-1344560042));
  assertEquals(360710144, x <<= x);
  assertEquals(0, x <<= (tmp = 612718075, tmp));
  assertEquals(0, x <<= x);
  assertEquals(-0, x /= (tmp = -1922423684, tmp));
  assertEquals(-0, x *= ((((tmp = 741806213.3264687, tmp)%(-711184803.2022421))+((tmp = -3209040938, tmp)&(525355849.044886)))&(x<<(tmp = -698610297, tmp))));
  assertEquals(0, x <<= (-482471790));
  assertEquals(0, x &= ((-921538707)/(tmp = -482498765.988616, tmp)));
  assertEquals(0, x ^= (x^x));
  assertEquals(-351721702, x ^= (-351721702.8850286));
  assertEquals(726242219625599900, x -= ((2064820612)*x));
  assertEquals(1452484439251199700, x += x);
  assertEquals(2.52318299412847e-15, x %= ((((x<<((2508143285)+x))>>(-2493225905.011774))%(1867009511.0792103))/((((x<<(2542171236))>>((x|x)&(tmp = -384528563, tmp)))+((-1168755343)*(1731980691.6745195)))+(tmp = -1608066022.71164, tmp))));
  assertEquals(79905008, x += ((((-2702081714.590131)&(x+(tmp = -1254725471.2121565, tmp)))*(3088309981))%(((tmp = 1476844981.1453142, tmp)|((((tmp = -1243556934.7291331, tmp)%x)^(-1302096154))+((660489180)/(tmp = -681535480.8642154, tmp))))^(tmp = -8410710, tmp))));
  assertEquals(1215822204, x ^= ((-3008054900)>>>(tmp = -1990206464.460693, tmp)));
  assertEquals(-394790532, x |= ((((-1334779133.2038574)+(tmp = -1407958866.832946, tmp))<<(1699208315))-(((x^(x%x))<<(3216443))>>(x+((((2576716374.3081336)|((tmp = 2316167191.348064, tmp)&((51086351.20208645)&((x|(tmp = -357261999, tmp))^(x/x)))))*(-45901631.10155654))*(((-439588079)>>>((-2358959768.7634916)|(1613636894.9373643)))+(((-908627176)<<x)%(x%((-1669567978)>>>((x>>(1289400876))+(tmp = 2726174270, tmp)))))))))));
  assertEquals(-0.17717467607696327, x /= (2228255982.974148));
  assertEquals(-1905616474, x ^= (tmp = 2389350822.851587, tmp));
  assertEquals(-0, x %= x);
  assertEquals(2818124981.508915, x -= (-2818124981.508915));
  assertEquals(-1476842315, x |= x);
  assertEquals(73408564, x &= (-3147390604.3453345));
  assertEquals(70, x >>>= x);
  assertEquals(1, x >>= x);
  assertEquals(3086527319.899181, x *= (3086527319.899181));
  assertEquals(-145, x >>= x);
  assertEquals(-145, x %= (tmp = -2500421077.3982406, tmp));
  assertEquals(-1, x >>= (tmp = -2970678326.712191, tmp));
  assertEquals(-1, x %= ((tmp = -535932632.4668834, tmp)+(((-1226598339.347982)<<((tmp = 616949449, tmp)/(tmp = 2779464046, tmp)))/(214578501.67984307))));
  assertEquals(1, x *= x);
  assertEquals(1, x >>= ((tmp = 11080208, tmp)<<(460763913)));
  assertEquals(-1.8406600706723492e-19, x /= ((tmp = -2334126306.1720915, tmp)*(tmp = 2327566272.5901165, tmp)));
  assertEquals(856681434186007200, x -= ((tmp = -2286974992.8133907, tmp)*(374591518)));
  assertEquals(3126084224, x >>>= x);
  assertEquals(-1160460669, x |= (tmp = 181716099, tmp));
  assertEquals(873988096, x <<= (tmp = 406702419, tmp));
  assertEquals(0, x <<= ((tmp = 802107965.4672925, tmp)-((tmp = 1644174603, tmp)>>((tmp = 604679952, tmp)+(tmp = -515450096.51425123, tmp)))));
  assertEquals(NaN, x %= ((x>>(tmp = 2245570378, tmp))*(tmp = 1547616585, tmp)));
  assertEquals(NaN, x /= ((tmp = -776657947.0382309, tmp)&(tmp = 163929332.28270507, tmp)));
  assertEquals(NaN, x *= (tmp = 243725679.78916526, tmp));
  assertEquals(NaN, x /= (x>>x));
  assertEquals(0, x <<= ((tmp = -1293291295.5735884, tmp)%(((((63309078)>>>x)&(x&(-2835108260.025297)))+x)>>>(-1317213424))));
  assertEquals(0, x *= ((((tmp = -1140319441.0068483, tmp)*(tmp = 2102496185, tmp))&(-2326380427))<<(tmp = -2765904696, tmp)));
  assertEquals(0, x /= (tmp = 2709618593, tmp));
  assertEquals(0, x >>= (-1753085095.7670164));
  assertEquals(1766381484, x |= (-2528585812));
  assertEquals(1766381484, x %= (2735943476.6363373));
  assertEquals(1766381484, x %= (x*(tmp = 2701354268, tmp)));
  assertEquals(-2147483648, x <<= (-323840707.4949653));
  assertEquals(4611686018427388000, x *= (x<<x));
  assertEquals(0, x <<= (3066735113));
  assertEquals(0, x ^= ((((x*x)^(tmp = -2182795086.39927, tmp))<<(x^(tmp = 1661144992.4371827, tmp)))<<((((-2885512572.176741)*(tmp = 609919485, tmp))|(tmp = 929399391.0790694, tmp))>>>((((((((((399048996)>>((-107976581.61751771)>>>x))|(((-1502100015)<<(tmp = -1108852531.9494338, tmp))&(x/(tmp = -3198795871.7239237, tmp))))+((-2627653357)>>x))>>>x)*(1066736757.2718519))%(tmp = 1326732482.201604, tmp))/(tmp = 2513496019.814191, tmp))>>>((1694891519)>>>(-2860217254.378931)))<<(tmp = 31345503, tmp)))));
  assertEquals(0, x ^= (x/((-2556481161)>>>(x/(x%(x&(1302923615.7148068)))))));
  assertEquals(NaN, x /= x);
  assertEquals(NaN, x += (tmp = 846522031, tmp));
  assertEquals(0, x >>= (x+(-1420249556.419045)));
  assertEquals(0, x ^= (((x%(-1807673170))&x)-x));
  assertEquals(-3484.311990686845, x -= ((((((-510347602.0068991)>>>x)<<((tmp = 1647999950, tmp)&(((305407727)>>((1781066601.791009)&x))<<((tmp = -998795238, tmp)%(((x/x)+x)<<(((2586995491.434947)<<x)-((((tmp = 545715607.9395425, tmp)*x)>>>x)>>>(((((2332534960.4595165)^(-3159493972.3695474))<<(tmp = 867030294, tmp))|(2950723135.753855))^(((3150916666)<<x)>>((tmp = 414988690, tmp)|((tmp = -1879594606, tmp)/(tmp = 1485647336.933429, tmp))))))))))))>>(tmp = -2676293177, tmp))%(617312699.1995015))/((((tmp = -1742121185, tmp)^((((x&x)<<(tmp = 698266916, tmp))/(-1860886248))+((-213304430)%((((((-2508973021.1333447)+(tmp = 2678876318.4903, tmp))&(tmp = -43584540, tmp))-x)^(-2251323850.4611115))-x))))>>>(tmp = 2555971284, tmp))%((((tmp = 16925106, tmp)^x)&x)|((x/((x|(tmp = -2787677257.125139, tmp))<<(-853699567)))+(tmp = -1721553520, tmp))))));
  assertEquals(-447873933.26863855, x += (-447870448.9566479));
  assertEquals(200591060101520900, x *= x);
  assertEquals(200591062202483420, x -= (-2100962536));
  assertEquals(-5.261023346568228e+24, x *= ((tmp = -419641692.6377077, tmp)>>(tmp = -224703100, tmp)));
  assertEquals(1269498660, x |= (195756836));
  assertEquals(1269498660, x |= x);
  assertEquals(1269498660, x |= x);
  assertEquals(-37.75978948486164, x /= (((tmp = -595793780, tmp)+((tmp = 2384365752, tmp)>>>(1597707155)))|((968887032)^(tmp = 2417905313.4337964, tmp))));
  assertEquals(-37.75978948486164, x %= (tmp = -1846958365.291661, tmp));
  assertEquals(1102319266.6421175, x += (1102319304.401907));
  assertEquals(-1664202255175155200, x -= ((x^(tmp = 407408729, tmp))*x));
  assertEquals(-752874653, x ^= (tmp = 314673507, tmp));
  assertEquals(-72474761, x |= (tmp = -2538726025.8884344, tmp));
  assertEquals(-72474761, x |= x);
  assertEquals(-122849418, x += ((tmp = -2332080457, tmp)|(((((30496388.145492196)*(((-1654329438.451212)|(-2205923896))&(x>>(tmp = -1179784444.957002, tmp))))&(tmp = 319312118, tmp))*(651650825))|(((-2305190283)|x)>>>(-428229803)))));
  assertEquals(994, x >>>= x);
  assertEquals(614292, x *= (((((2565736877)/((tmp = 649009094, tmp)>>>(((x>>>(2208471260))>>(x>>>x))%x)))&(tmp = 357846438, tmp))<<(tmp = -2175355851, tmp))%x));
  assertEquals(1792008118, x |= (tmp = 1791924774.5121183, tmp));
  assertEquals(1246238208, x &= (tmp = 1264064009.9569638, tmp));
  assertEquals(-88877082, x ^= (2969289190.285704));
  assertEquals(0.044923746573582474, x /= ((tmp = -3057438043, tmp)^(-1009304907)));
  assertEquals(0, x <<= ((-828383918)-((((x>>(734512101))*(tmp = -3108890379, tmp))-(x|((tmp = 3081370585.3127823, tmp)^((-271087194)-(x/(tmp = -2777995324.4073873, tmp))))))%x)));
  assertEquals(1604111507.3365753, x -= (-1604111507.3365753));
  assertEquals(-1721314970, x ^= (tmp = -956686859, tmp));
  assertEquals(-102247425, x |= (tmp = -2535095555, tmp));
  assertEquals(-102247425, x %= (-955423877));
  assertEquals(1053144489850425, x *= (((tmp = 1583243590.9550207, tmp)&(1356978114.8592746))|(tmp = -10299961.622774363, tmp)));
  assertEquals(-0.0043728190668037336, x /= ((-1196259252.435701)*(((-689529982)|(tmp = -1698518652.4373918, tmp))<<x)));
  assertEquals(-2, x ^= (((x+(tmp = 2961627388, tmp))>>(tmp = 231666110.84104693, tmp))|x));
  assertEquals(-1, x >>= (tmp = -83214419.92958307, tmp));
  assertEquals(-1, x %= (-1303878209.6288595));
  assertEquals(2944850457.5213213, x -= (tmp = -2944850458.5213213, tmp));
  assertEquals(-1.6607884436053055, x /= (-1773164107));
  assertEquals(-0.6607884436053055, x %= ((x>>(1240245489.8629928))%(tmp = -3044136221, tmp)));
  assertEquals(-0, x *= ((x*x)>>>((1069542313.7656753)+x)));
  assertEquals(0, x >>>= (tmp = -202931587.00212693, tmp));
  assertEquals(-0, x *= (-375274420));
  assertEquals(0, x |= ((x/(((tmp = -876417141, tmp)*(x>>>x))&(-2406962078)))<<x));
  assertEquals(0, x &= ((tmp = -650283599.0780096, tmp)*(tmp = 513255913.34108484, tmp)));
  assertEquals(3027255453.458466, x += (3027255453.458466));
  assertEquals(-12568623413253943000, x *= (((x-(198689694.92141533))|x)-x));
  assertEquals(-12568623410285185000, x -= (tmp = -2968758030.3694654, tmp));
  assertEquals(-2008903680, x &= (3111621747.7679076));
  assertEquals(-110045263.26583672, x += (tmp = 1898858416.7341633, tmp));
  assertEquals(15964, x >>>= (1141042034));
  assertEquals(31928, x += x);
  assertEquals(0, x ^= x);
  assertEquals(-1159866377, x |= (-1159866377));
  assertEquals(0, x ^= x);
  assertEquals(3072699529.4306993, x -= (tmp = -3072699529.4306993, tmp));
  assertEquals(1, x /= x);
  assertEquals(-1471195029, x |= (2823772267.429641));
  assertEquals(-4152937108, x += (-2681742079));
  assertEquals(142030188, x |= x);
  assertEquals(270, x >>= (tmp = 1013826483, tmp));
  assertEquals(0, x >>>= (529670686));
  assertEquals(-2912300367, x -= (2912300367));
  assertEquals(2213791134963007500, x *= (x<<((((-3214746140)>>(tmp = -588929463, tmp))+((tmp = -3084290306, tmp)>>x))>>x)));
  assertEquals(2213791133466809900, x -= (tmp = 1496197641, tmp));
  assertEquals(69834416, x >>>= (x|(((2755815509.6323137)^(x%(((x*((((tmp = 375453453, tmp)<<(x*x))>>(tmp = -973199642, tmp))*x))>>((tmp = -356288629, tmp)>>(tmp = 2879464644, tmp)))<<((((1353647167.9291127)>>>(x/x))<<((2919449101)/(2954998123.5529594)))^x))))&((-2317273650)>>>(tmp = 34560010.71060455, tmp)))));
  assertEquals(69834416, x >>>= (x^(-2117657680.8646245)));
  assertEquals(2217318064, x -= ((tmp = 2035883891, tmp)<<(tmp = -1884739265, tmp)));
  assertEquals(-1272875686, x ^= (tmp = 805889002.7165648, tmp));
  assertEquals(-1272875686, x >>= (x&(((1750455903)*x)>>((722098015)%((tmp = 1605335626, tmp)>>(tmp = -565369634, tmp))))));
  assertEquals(-1274351316, x -= (x>>>((tmp = 2382002632, tmp)-((tmp = -2355012843, tmp)+(1465018311.6735773)))));
  assertEquals(-2982908522.4418216, x -= ((tmp = 1635549038.4418216, tmp)+(((1952167017.720186)&((tmp = -2284822073.1002254, tmp)>>(-1403893917)))%(tmp = 655347757, tmp))));
  assertEquals(312, x >>>= x);
  assertEquals(1248, x <<= (2376583906));
  assertEquals(0, x ^= x);
  assertEquals(0, x *= ((((tmp = 1914053541.881434, tmp)>>>(tmp = 1583032186, tmp))>>>(-2511688231))%(tmp = -2647173031, tmp)));
  assertEquals(0, x >>>= (tmp = -2320612994.2421227, tmp));
  assertEquals(0, x %= (((x+(tmp = -720216298.5403998, tmp))<<(414712685))>>(tmp = 480416588, tmp)));
  assertEquals(0, x >>= ((((3039442014.271272)<<x)%(-2402430612.9724464))&((-2141451461.3664773)%((x>>(1361764256))/((tmp = -1723952801.9320493, tmp)%(477351810.2485285))))));
  assertEquals(-0, x /= (tmp = -1627035877, tmp));
  assertEquals(0, x >>>= (tmp = 1745193212, tmp));
  assertEquals(0, x >>>= (2309131575));
  assertEquals(NaN, x %= (((x*(tmp = -1730907131.6124666, tmp))%((((1481750041)|(x>>((((x>>>(tmp = 3128156522.5936565, tmp))/(tmp = -1277222645.9880452, tmp))^(tmp = -2327254789, tmp))+x)))>>>(-1161176960))>>>(tmp = 3135906272.5466847, tmp)))*(((((-2230902834.464362)^(1822893689.8183987))+(((tmp = 1597326356, tmp)/(x&((tmp = -3044163063.587389, tmp)>>(tmp = 2844997555, tmp))))%(x^x)))>>((x|x)/x))^(2634614167.2529745))));
  assertEquals(0, x &= (3081901595));
  assertEquals(0, x &= (-2453019214.8914948));
  assertEquals(0, x &= x);
  assertEquals(0, x >>>= (-596810618.3666217));
  assertEquals(0, x >>= (((908276623)|x)/x));
  assertEquals(0, x ^= x);
  assertEquals(958890056, x |= (tmp = 958890056.474458, tmp));
  assertEquals(1325436928, x <<= (tmp = -2474326583, tmp));
  assertEquals(711588532333838300, x *= ((-148161646.68183947)<<(tmp = -1149179108.8049204, tmp)));
  assertEquals(0, x ^= (((2862565506)%x)/(tmp = -2865813112, tmp)));
  assertEquals(-2064806628, x += (((tmp = -2677361175.7317276, tmp)/((817159440)>>>(tmp = 1895467706, tmp)))^(x|(tmp = -2309094859, tmp))));
  assertEquals(-69806982479424, x *= ((x&(tmp = 2857559765.1909904, tmp))&(-3166908966.754988)));
  assertEquals(-430255744, x %= ((((((-2968574724.119535)<<x)<<((tmp = 1603913671, tmp)%((-1495838556.661653)^(tmp = 1778219751, tmp))))*(-400364265))<<((((1607866371.235576)-(1961740136))|(1259754297))&(tmp = -1018024797.1352971, tmp)))^x));
  assertEquals(6.828637393208647e-7, x /= (x*(tmp = 1464421, tmp)));
  assertEquals(0, x &= x);
  assertEquals(-0, x *= (((tmp = -2510016276, tmp)-(2088209546))<<((tmp = -1609442851.3789036, tmp)+(tmp = 1919930212, tmp))));
  assertEquals(-0, x %= (tmp = 1965117998, tmp));
  assertEquals(-290294792.53186846, x += ((tmp = -2361555894.5318685, tmp)%(2071261102)));
  assertEquals(-70873, x >>= (tmp = 2206814124, tmp));
  assertEquals(-141746, x += x);
  assertEquals(-141733.9831459089, x -= (((tmp = -806523527, tmp)>>>(tmp = 1897214891, tmp))/x));
  assertEquals(-141733.9831459089, x %= ((tmp = 1996295696, tmp)<<(tmp = 3124244672, tmp)));
  assertEquals(141733.9831459089, x /= (x>>(2688555704.561076)));
  assertEquals(3196954517.3075542, x -= (tmp = -3196812783.3244085, tmp));
  assertEquals(-19929155, x |= (((x|x)+x)^((tmp = 391754876, tmp)-(((((((tmp = -3051902902.5100636, tmp)*(x/(1546924993)))|(tmp = 1494375949, tmp))/((((-795378522)/(tmp = 509984856, tmp))>>>(tmp = -106173186, tmp))+x))|x)|(1916921307))>>>x))));
  assertEquals(1279271449, x &= ((tmp = 1289446971, tmp)&(tmp = 1836102619, tmp)));
  assertEquals(17876992, x <<= (-207633461));
  assertEquals(0, x >>= (tmp = -903885218.9406946, tmp));
  assertEquals(0, x >>>= x);
  assertEquals(-2999, x -= (((754533336.2183633)%(tmp = 557970276.0537136, tmp))>>(tmp = -1171045520, tmp)));
  assertEquals(-0.000003020470363504361, x /= (tmp = 992891715.2229724, tmp));
  assertEquals(1, x /= x);
  assertEquals(0.45768595820301217, x %= ((tmp = 673779031, tmp)/(tmp = -1242414872.3263657, tmp)));
  assertEquals(-980843052.1872087, x += (tmp = -980843052.6448946, tmp));
  assertEquals(-Infinity, x /= ((((tmp = 317747175.8024508, tmp)&(x&(((tmp = 1632953053, tmp)>>x)/x)))%x)/(3145184986)));
  assertEquals(0, x &= (x<<x));
  assertEquals(0, x ^= (x-((2969023660.5619783)/x)));
  assertEquals(0, x *= x);
  assertEquals(NaN, x %= (x/(((x-x)/((tmp = -1622970458.3812745, tmp)-(1626134522)))&((((((tmp = 1384729039.4149384, tmp)^(x%(tmp = -2736365959, tmp)))+((-1465172172)%x))>>(tmp = -1839184810.2603343, tmp))^(((tmp = 1756918419, tmp)>>>(x+(x%(tmp = -2011122996.9794662, tmp))))<<(-3026600748.902623)))*((tmp = -2040286580, tmp)>>(-2899217430.655154))))));
  assertEquals(0, x >>>= (tmp = 2100066003.3046467, tmp));
  assertEquals(1362012169, x ^= (tmp = 1362012169, tmp));
  assertEquals(1476312683, x |= ((457898409)>>>(-3079768830.723079)));
  assertEquals(1441711, x >>>= (905040778.7770994));
  assertEquals(2078530607521, x *= x);
  assertEquals(-208193103, x |= ((tmp = -241750000, tmp)^x));
  assertEquals(745036378, x ^= (((tmp = -1737151062.4726632, tmp)<<x)|(tmp = -1900321813, tmp)));
  assertEquals(1744830464, x <<= x);
  assertEquals(212992, x >>>= ((1210741037)-(x-(x>>>((x^(-1273817997.0036907))+((2401915056.5471)%(x<<(tmp = 1696738364.277438, tmp))))))));
  assertEquals(0.0001604311565639742, x /= (1327622418));
  assertEquals(0, x <<= (tmp = 166631979.34529006, tmp));
  assertEquals(0, x *= ((((tmp = 657814984, tmp)/(((-831055031)>>>(1531978379.1768064))|((tmp = 2470027754.302619, tmp)^(-223467597))))/(tmp = 1678697269.468965, tmp))&(tmp = -1756260071.4360774, tmp)));
  assertEquals(-2049375053, x ^= (tmp = -2049375053, tmp));
  assertEquals(-1879109889, x |= (tmp = -1963586818.0436726, tmp));
  assertEquals(718239919, x ^= (tmp = -1523550640.1925273, tmp));
  assertEquals(-1361085185, x |= (-1939964707));
  assertEquals(2, x >>>= (1864136030.7395325));
  assertEquals(0.794648722849246, x %= ((-668830999)*(((-2227700170.7193384)%(x^(x>>>x)))/(tmp = 399149892, tmp))));
  assertEquals(0, x >>= x);
  assertEquals(0, x *= x);
  assertEquals(0, x &= ((tmp = -2389008496.5948563, tmp)|((((tmp = -2635919193.905919, tmp)*((-64464127)<<(2136112830.1317358)))>>((184057979)*(-1204959085.8362718)))>>>(-442946870.3341484))));
  assertEquals(-243793920, x -= ((tmp = 3002998032, tmp)<<((537875759)<<x)));
  assertEquals(0, x -= x);
  assertEquals(0, x *= ((((66852616.82442963)/((((x^x)&(2975318321.223734))+(((tmp = -1388210811.1249495, tmp)^((((-680567297.7620237)%(x-(tmp = -672906716.4672911, tmp)))-x)*(tmp = -1452125821.0132627, tmp)))*(((2770387154.5427895)%x)%x)))-x))<<((-1481832432.924325)>>(tmp = 3109693867, tmp)))>>>(x/(((((((tmp = 928294418, tmp)^(((-1018314535)/(tmp = -3167523001, tmp))%((((((tmp = -1639338126, tmp)-(tmp = -2613558829, tmp))&x)/x)%(tmp = 513624872, tmp))/((-520660667)&x))))*(2620452414))^((tmp = 2337189239.5949326, tmp)*(3200887846.7954993)))>>>((tmp = 1173330667, tmp)^x))<<x)>>(((tmp = -2475534594.982338, tmp)*x)|x)))));
  assertEquals(0, x /= (2520915286));
  assertEquals(0, x &= x);
  assertEquals(0, x >>= (-1908119327));
  assertEquals(0, x >>>= (tmp = 549007635, tmp));
  assertEquals(0, x >>= (-994747873.8117285));
  assertEquals(0, x <<= ((((x>>>((-3084793026.846681)%((1107295502)&(tmp = -296613957.8133817, tmp))))&((19637717.166736007)/(x+x)))+x)/(-2479724242)));
  assertEquals(-695401420, x += (-695401420));
  assertEquals(-695401394, x += (x>>>(tmp = 2340097307.6556053, tmp)));
  assertEquals(-555745552, x -= (x|(-483851950.68644)));
  assertEquals(-17825792, x <<= x);
  assertEquals(-17825792, x >>= x);
  assertEquals(-17, x %= ((tmp = 1799361095, tmp)|((x>>(((-1201252592)<<((((543273288)+(-2859945716.606924))*x)<<((-3030193601)<<(3081129914.9217644))))|((1471431587.981769)>>(-246180750))))|(((tmp = -2689251055.1605787, tmp)>>x)&(((2131333169)^x)-((tmp = -951555489, tmp)/x))))));
  assertEquals(-8912896, x <<= (1146444211));
  assertEquals(2854567584, x += (tmp = 2863480480, tmp));
  assertEquals(426232502.24151134, x %= (1214167540.8792443));
  assertEquals(1806802048, x ^= (-2368317898));
  assertEquals(432537600, x <<= (tmp = 2831272652.589364, tmp));
  assertEquals(432537600, x %= (((1713810619.3880467)-x)&((-2853023009.553296)&(tmp = -3158798098.3355417, tmp))));
  assertEquals(-509804066, x += (tmp = -942341666, tmp));
  assertEquals(-509804066, x %= (-732349220));
  assertEquals(259900185710132350, x *= x);
  assertEquals(711598501.7021885, x %= ((tmp = 2020395586.2280731, tmp)-(tmp = 3031459563.1386633, tmp)));
  assertEquals(711598503.0618857, x += ((tmp = 967558548.4141241, tmp)/x));
  assertEquals(711598503, x &= x);
  assertEquals(711598503, x ^= (((((1609355669.1963444)+((((tmp = -2660082403.258437, tmp)+(tmp = -235367868, tmp))&(x/x))*((-2595932186.69466)|((tmp = -3039202860, tmp)<<x))))>>>(-951354869))-((tmp = -691482949.6335375, tmp)/(tmp = -1735502400, tmp)))/(tmp = 798440377, tmp)));
  assertEquals(558262613882868500, x *= (784519095.4299527));
  assertEquals(558262611968479000, x -= ((((tmp = 1039039153.4026555, tmp)/(-3138845051.6240187))*(tmp = 633557994, tmp))&(1981507217)));
  assertEquals(1170427648, x |= ((x>>((((-1086327124)%((tmp = -1818798806.368613, tmp)^(tmp = 2183576654.9959817, tmp)))>>x)&((((((tmp = 1315985464.0330539, tmp)&(2774283689.333836))%x)*((2722693772.8994813)&(tmp = -2720671984.945404, tmp)))^(tmp = -76808019, tmp))<<((tmp = 685037799.2336662, tmp)^((tmp = 1057250849, tmp)&(tmp = 1469205111.2989025, tmp))))))+(x*(((tmp = 448288818.47173154, tmp)-(-2527606231))-((8387088.402292728)>>x)))));
  assertEquals(558, x >>>= (tmp = 2732701109, tmp));
  assertEquals(558, x &= x);
  assertEquals(-0.00015855057024653912, x /= ((x+(((tmp = -1963815633, tmp)-(x>>x))-((x|x)>>x)))/x));
  assertEquals(1.3458861596445712e-13, x /= (-1178038492.4116466));
  assertEquals(0, x <<= (-104550232));
  assertEquals(0, x >>>= (x>>(tmp = -255275244.12613606, tmp)));
  assertEquals(0, x >>= x);
  assertEquals(375, x |= ((1576819294.6991196)>>>(-2570246122)));
  assertEquals(96000, x <<= ((2252913843.0150948)>>>(-49239716)));
  assertEquals(6144000, x <<= ((((tmp = -2478967279, tmp)&((x%((tmp = -1705332610.8018858, tmp)+(x+(tmp = 590766349, tmp))))<<(tmp = 1759375933, tmp)))+(-2024465658.849834))&(1564539207.3650014)));
  assertEquals(-1149239296, x <<= (1862803657.7241006));
  assertEquals(-9, x >>= (((tmp = 463306384.05696774, tmp)^x)|((x>>((((-2098070856.799663)<<((-2054870274.9012866)<<(((-2582579691)/(829257170.0266814))<<(((((tmp = -1753535573.7074275, tmp)<<((x>>(-197886116))%((2487188445)%(tmp = 2465391564.873364, tmp))))&(((tmp = -500069832, tmp)&(tmp = 3016637032, tmp))&((tmp = 2525942628, tmp)|((((-920996215)|x)^((((tmp = -687548533.419106, tmp)&(1423222636.058937))<<((tmp = -1096532228, tmp)>>((((tmp = -3124481449.2740726, tmp)^(tmp = 2724328271.808975, tmp))>>x)*x)))+(-1661789589.5808442)))+(((x*(tmp = -1224371664.9549093, tmp))^((tmp = 3202970043, tmp)^x))/(tmp = 131494054.58501709, tmp))))))|(((tmp = -1654136720, tmp)<<x)>>((1652979932.362416)-(tmp = -863732721, tmp))))^(-113307998)))))^(-90820449.91417909))*((tmp = 641519890, tmp)-((((x<<(tmp = 2349936514.071881, tmp))*(2324420443.587892))^x)%(x<<((tmp = -1838473742, tmp)/(((-3154172718.4274178)-x)+x)))))))|(x>>>((tmp = 2096024376.4308293, tmp)<<x)))));
  assertEquals(81, x *= x);
  assertEquals(81, x &= x);
  assertEquals(81, x %= (tmp = 2223962994, tmp));
  assertEquals(81, x ^= ((x/(((-1606183420.099584)|(-1242175583))&(((x|((tmp = 828718431.3311573, tmp)/(x>>x)))+(((-2207542725.4531174)^(x*x))*(tmp = 551575809.955105, tmp)))/x)))&((x>>x)&x)));
  assertEquals(81, x %= (tmp = 279598358.6976975, tmp));
  assertEquals(101.72338484518858, x -= (((tmp = 2452584495.44003, tmp)%((-1181192721)+(((x>>(((x&x)^x)+((x>>>((x+(-2472793823.57181))/(((2854104951)>>(-1208718359.6554642))>>>(1089411895.694705))))/(x|(-2821482890.1780205)))))^(-1786654551))/(-29404242.70557475))))/(((-4352531)<<((-1227287545)<<x))%(-2558589438))));
  assertEquals(101.72338484518858, x %= (-943645643));
  assertEquals(0, x -= x);
  assertEquals(0, x >>>= (-2440404084));
  assertEquals(0, x >>= (tmp = 1029680958.405923, tmp));
  assertEquals(0, x >>>= (1213820208.7204895));
  assertEquals(-0, x /= (tmp = -103093683, tmp));
  assertEquals(0, x >>>= (-2098144813));
  assertEquals(-0, x /= (((-3087283334)+(((tmp = -3129028112.6859293, tmp)%(tmp = 2413829931.1605015, tmp))-(2578195237.8071446)))|x));
  assertEquals(-15, x |= ((((-178926550.92823577)>>>(-965071271))^((tmp = -484633724.7237625, tmp)-(tmp = 473098919.1486404, tmp)))>>((-2264998310.203265)%(tmp = -499034672, tmp))));
  assertEquals(0, x ^= x);
  assertEquals(0, x >>= (((-3207915976.698118)<<(tmp = 2347058630, tmp))|(tmp = -2396250098.559627, tmp)));
  assertEquals(NaN, x %= x);
  assertEquals(NaN, x *= (621843222));
  assertEquals(0, x >>= (((-2409032228.7238913)*x)-(tmp = -887793239, tmp)));
  assertEquals(NaN, x /= x);
  assertEquals(1193017666, x ^= (tmp = 1193017666, tmp));
  assertEquals(3.5844761899682753, x /= (tmp = 332829011.206393, tmp));
  assertEquals(-888572929, x |= (((tmp = 1032409228, tmp)+(tmp = -1920982163.7853453, tmp))+x));
  assertEquals(-1817051951333455600, x *= (((-1506265102)^(tmp = -775881816, tmp))-(tmp = -32116372.59181881, tmp)));
  assertEquals(-1638479616, x |= x);
  assertEquals(-114489, x %= (((tmp = -247137297.37866855, tmp)>>>((((((-322805409)-x)^x)>>((((((((x>>>(tmp = -900610424.7148039, tmp))/(-1155208489.6240904))|((-2874045803)|(tmp = 3050499811, tmp)))+(x/((tmp = -613902712, tmp)^((-982142626.2892077)*((((tmp = -3201753245.6026397, tmp)|((1739238762.0423079)^x))/(243217629.47237313))^((tmp = -11944405.987132788, tmp)/(tmp = 2054031985.633406, tmp)))))))*(tmp = 2696108952.450961, tmp))*x)>>>(tmp = 3058430643.0660386, tmp))>>(x<<x)))>>(-984468302.7450335))%((tmp = 1302320585.246251, tmp)>>>x)))%(tmp = -2436842285.8208156, tmp)));
  assertEquals(2047, x >>>= (2380161237));
  assertEquals(0, x >>= x);
  assertEquals(0, x &= (tmp = 980821012.975836, tmp));
  assertEquals(-1090535537, x -= ((-3064511503.1214876)&((tmp = -2598316939.163751, tmp)<<((tmp = -969452391.8925576, tmp)*x))));
  assertEquals(-2181071074, x += x);
  assertEquals(1, x >>>= ((2902525386.449062)>>x));
  assertEquals(1, x += (x&(tmp = -2643758684.6636515, tmp)));
  assertEquals(1, x %= ((tmp = -2646526891.7004848, tmp)/x));
  assertEquals(448735695.7888887, x -= (tmp = -448735694.7888887, tmp));
  assertEquals(1, x /= x);
  assertEquals(1, x >>= ((-480385726)<<(2641021142)));
  assertEquals(1, x %= (375099107.9200462));
  assertEquals(1, x >>= (((x&((tmp = -2402469116.9903326, tmp)%(tmp = -2862459555.860298, tmp)))*(tmp = -2834162871.0586414, tmp))%(((x>>>(tmp = 721589907.5073895, tmp))*(x^x))%(((tmp = 2844611489.231776, tmp)^((983556913)&(906035409.6693488)))^(x>>>(1239322375))))));
  assertEquals(268435456, x <<= (tmp = 178807644.80966163, tmp));
  assertEquals(44, x %= ((tmp = 2527026779.081539, tmp)>>>(2736129559)));
  assertEquals(88, x += x);
  assertEquals(0, x >>>= x);
  assertEquals(0, x -= x);
  assertEquals(-1523121602, x |= (2771845694));
  assertEquals(-2, x >>= x);
  assertEquals(-4, x += x);
  assertEquals(-256, x <<= (((2522793132.8616533)>>(tmp = 77232772.94058788, tmp))+(3118669244.49152)));
  assertEquals(4294967040, x >>>= x);
  assertEquals(-256, x &= x);
  assertEquals(1278370155.835435, x -= (-1278370411.835435));
  assertEquals(-3.488228054921667, x /= (tmp = -366481243.6881058, tmp));
  assertEquals(1.162742684973889, x /= ((x|(((((2404819175.562809)*(tmp = -2524589506, tmp))&(tmp = -675727145, tmp))>>>(x*x))&((-413250006)<<(tmp = 2408322715, tmp))))|((2940367603)>>>x)));
  assertEquals(0, x >>>= ((2513665793)-(tmp = 1249857454.3367786, tmp)));
  assertEquals(0, x ^= x);
  assertEquals(0, x ^= x);
  assertEquals(1989998348.6336238, x -= (-1989998348.6336238));
  assertEquals(903237918.986834, x %= (1086760429.6467898));
  assertEquals(-4.4185765232981975, x /= (-204418304));
  assertEquals(1471621914, x ^= (tmp = -1471621914.1771696, tmp));
  assertEquals(1471621914, x |= ((((((x<<(tmp = -2676407394.536844, tmp))%(((343324258)+(x/(x>>(((-221193011)>>>x)|x))))>>(((-2737713893)^((tmp = -49214797.00735545, tmp)+((-2818106123.172874)/(tmp = -2361786565.3028684, tmp))))<<(1859353297.6355076))))*(tmp = -751970685, tmp))|((tmp = 2502717391.425871, tmp)/(tmp = -2647169430, tmp)))*((tmp = -1647567294, tmp)&(((tmp = 1819557651, tmp)/x)>>((((-3073469753)/x)-(((tmp = -1973810496.6407511, tmp)&((x-(x+(tmp = -2986851659, tmp)))>>>(tmp = -2226975699, tmp)))|(418770782.142766)))<<x))))*(((((tmp = 125466732, tmp)/((((1453655756.398259)|(((874792086.7064595)-(194880772.91499102))>>>x))%(x<<(tmp = -1445557137, tmp)))<<x))>>>(tmp = -1953751906, tmp))/((tmp = -2140573172.2979035, tmp)*((-108581964)^x)))|(-481484013.0393069))));
  assertEquals(1454179065, x += ((tmp = 947147038.2829313, tmp)|(tmp = -154822975.3629098, tmp)));
  assertEquals(1, x /= x);
  assertEquals(1, x %= ((((((tmp = -2262250297.991866, tmp)-(tmp = 481953960, tmp))/(1629215187.6020458))|(2515244216))>>>((tmp = -3040594752.2184515, tmp)-(tmp = -1116041279, tmp)))^(((-182133502)-(1065160192.6609197))+(((((-1850040207)^(tmp = -1570328610, tmp))^(tmp = 20542725.09256518, tmp))*x)|(2386866629)))));
  assertEquals(1, x &= (2889186303));
  assertEquals(0, x >>= (((-1323093107.050538)>>(x%x))-(((((((-1736522840)+(tmp = -2623890690.8318863, tmp))*(959395040.5565329))*(233734920))<<((x+(x%((tmp = -2370717284.4370327, tmp)%(tmp = 2109311949, tmp))))-(tmp = -1005532894, tmp)))|(861703605))>>>((2399820772)/x))));
  assertEquals(0, x >>= x);
  assertEquals(57233408, x |= ((tmp = 2655923764.4179816, tmp)*(-1353634624.3025436)));
  assertEquals(997939728, x |= (980552208.9005274));
  assertEquals(1859642592476610800, x *= (1863481872));
  assertEquals(-977190656, x <<= x);
  assertEquals(4.378357529141239e+26, x *= ((((x/(((tmp = 2429520991, tmp)/(x/(tmp = 784592802, tmp)))-(tmp = -2704781982, tmp)))*(tmp = -2161015768.2322354, tmp))&((((-3164868762)>>(tmp = 2390893153.32907, tmp))^x)>>(-2422626718.322538)))*(tmp = 278291869, tmp)));
  assertEquals(4.378357529141239e+26, x -= (1710777896.992369));
  assertEquals(0, x &= (((((tmp = -2532956158.400033, tmp)|((2195255831.279001)|(1051047432)))|(-1628591858))|(tmp = -2042607521.947963, tmp))>>((-1471225208)/(((-133621318)>>(1980416325.7358408))*((1741069593.1036062)-(x|(2133911581.991011)))))));
  assertEquals(-0, x /= (-656083507));
  assertEquals(NaN, x += ((tmp = -1071410982.2789869, tmp)%x));
  assertEquals(NaN, x *= (tmp = -1513535145.3146675, tmp));
  assertEquals(0, x >>= ((2831245247.5267224)>>(x<<((x+(((3068824580.7922907)|(1708295544.275714))*((tmp = -1662930228.1170444, tmp)-(((tmp = 1979994889, tmp)<<(tmp = -1826911988, tmp))&((x/(x<<(1909384611.043981)))+(1958052414.7139997))))))<<(tmp = 2481909816.56558, tmp)))));
  assertEquals(0, x *= (((tmp = -2979739958.1614842, tmp)&x)+x));
  assertEquals(-0, x *= ((-332769864.50313234)^x));
  assertEquals(0, x >>= ((((689018886.1436445)+(tmp = -2819546038.620694, tmp))|(((tmp = -1459669934.9066005, tmp)|x)/x))<<(((tmp = 2640360389, tmp)/((x%((-1947492547.9056122)%((1487212416.2083092)-(-1751984129))))^x))%(tmp = 2666842881, tmp))));
  assertEquals(-1801321460, x |= (tmp = 2493645836, tmp));
  assertEquals(-1801321460, x %= (2400405136));
  assertEquals(-2905399858195810300, x *= (tmp = 1612926911, tmp));
  assertEquals(-2905399858195810300, x -= (x>>(tmp = 1603910263.9593458, tmp)));
  assertEquals(-238798848, x &= ((tmp = -2638646212.767516, tmp)/(((tmp = 1755616291.436998, tmp)>>>(tmp = 1083349775, tmp))-(x%(((tmp = 1728859105.53634, tmp)^(1931522619.0403612))/(tmp = 712460587.0025489, tmp))))));
  assertEquals(-2363873607.2302856, x += (-2125074759.230286));
  assertEquals(1712665, x &= (((117229515)>>>(((1707090894.1915488)>>>((-1696008695)>>(((-1045367326.7522249)<<(tmp = -209334716, tmp))-x)))|(-1707909786.080653)))%(1260761349.172689)));
  assertEquals(1073741824, x <<= (tmp = -289437762.34742975, tmp));
  assertEquals(1073741824, x &= (tmp = 2079141140, tmp));
  assertEquals(0, x <<= ((x^(-3139646716.1615124))-(((-362323071.74237394)|(tmp = 2989896849, tmp))*(tmp = -218217991, tmp))));
  assertEquals(0, x &= (tmp = -1476835288.425903, tmp));
  assertEquals(0, x >>>= (tmp = 61945262.70868635, tmp));
  assertEquals(0, x ^= x);
  assertEquals(-2735263498.7189775, x -= (2735263498.7189775));
  assertEquals(-1182289920, x <<= (x+x));
  assertEquals(-1182289580, x ^= ((2858446263.2258)>>>(2387398039.6273785)));
  assertEquals(696693056, x &= ((2178665823)*(-51848583)));
  assertEquals(1652555776, x <<= (((tmp = 2943916975, tmp)-((-1544273901)>>(-1671503106.2896929)))|x));
  assertEquals(6455296, x >>>= (tmp = 1492638248.675439, tmp));
  assertEquals(2097152, x &= (((x|x)*(2873891571.7000637))^((2165264807)+(tmp = 451721563, tmp))));
  assertEquals(2097152, x %= (tmp = 1089484582.1455994, tmp));
  assertEquals(2097152, x <<= x);
  assertEquals(2097152, x &= ((tmp = 119096343.4032247, tmp)^((-1947874541)*x)));
  assertEquals(0, x &= (tmp = 2363070677, tmp));
  assertEquals(0, x &= ((tmp = -1897325383, tmp)>>>((2368480527)>>>((tmp = 1837528979, tmp)*(-1838904077)))));
  assertEquals(-1898659416, x ^= (-1898659416.1125412));
  assertEquals(-725506048, x <<= x);
  assertEquals(1392943104, x <<= (295287938.9104482));
  assertEquals(-63620329, x ^= ((tmp = -3175925826.5573816, tmp)-(tmp = 2474613927, tmp)));
  assertEquals(-1135111726, x -= ((tmp = -1133259081, tmp)^(((tmp = -742228219, tmp)>>((-7801909.587711811)%((tmp = -642758873, tmp)+(tmp = 2893927824.6036444, tmp))))^((tmp = -2145465178.9142997, tmp)+x))));
  assertEquals(0, x ^= x);
  assertEquals(660714589, x |= (660714589));
  assertEquals(660714676, x ^= ((-376720042.8047826)>>>(2196220344)));
  assertEquals(660714676, x |= ((((((((x<<(-1140465568))-(tmp = -1648489774.1573918, tmp))%(((tmp = -2955505390.573639, tmp)*x)<<((((tmp = -1769375963, tmp)*(tmp = -440619797, tmp))&((tmp = 1904284066, tmp)%(-2420852665.0629807)))+(-324601009.2063596))))>>(tmp = 2317210783.9757776, tmp))^((tmp = 750057067.4541628, tmp)^(tmp = -1391814244.7286487, tmp)))>>((344544658.6054913)%((tmp = -1508630423.218488, tmp)&(tmp = 1918909238.2974637, tmp))))>>((-647746783.685822)&(tmp = 2444858958.3595476, tmp)))&x));
  assertEquals(-962337195, x ^= (tmp = -507358495.30825853, tmp));
  assertEquals(-182008925.58535767, x %= (tmp = -195082067.35366058, tmp));
  assertEquals(502070, x >>>= (tmp = 1459732237.1447744, tmp));
  assertEquals(-2391009930.7235765, x -= (tmp = 2391512000.7235765, tmp));
  assertEquals(1568669696, x <<= x);
  assertEquals(0, x <<= (tmp = -571056688.2717848, tmp));
  assertEquals(1770376226, x ^= (tmp = 1770376226.0584736, tmp));
  assertEquals(0, x ^= x);
  assertEquals(0, x &= ((((x<<x)>>>x)|x)|(((tmp = -2141573723, tmp)^x)|(64299956))));
  assertEquals(0, x ^= x);
  assertEquals(0, x &= x);
  assertEquals(0, x <<= (1106060336.7362857));
  assertEquals(-0, x /= (x|(tmp = 2760823963, tmp)));
  assertEquals(0, x <<= ((-2436225757)|(-1800598694.4062433)));
  assertEquals(0, x >>>= ((-728332508.9870625)<<x));
  assertEquals(-173377680, x ^= ((tmp = -173377680, tmp)%(tmp = -2843994892, tmp)));
  assertEquals(-173377680, x |= ((((-819217898)&(tmp = -1321650255, tmp))&(x+((x^x)<<((1700753064)>>((((((-1038799327)>>((782275464)^x))-(tmp = -2113814317.8539028, tmp))>>(2143804838))&x)-((2970418921)/(-3073015285.6587048)))))))&((-1759593079.4077306)%((1699128805)-((tmp = -467193967, tmp)&(((2225788267.3466334)*(((2687946762.5504274)+x)>>>x))<<(-1853556066.880512)))))));
  assertEquals(-0.5520657226957338, x /= ((tmp = -755493878, tmp)&(tmp = 918108389, tmp)));
  assertEquals(0.30477656217556287, x *= x);
  assertEquals(0, x &= ((tmp = -2746007517, tmp)<<(2749629340)));
  assertEquals(0, x ^= ((x%(tmp = 1683077876, tmp))%(-162706778)));
  assertEquals(0, x *= (tmp = 10203423, tmp));
  assertEquals(119043212.1461842, x += (tmp = 119043212.1461842, tmp));
  assertEquals(587202560, x <<= (tmp = 658697910.7051642, tmp));
  assertEquals(-138689730, x |= (x-(tmp = 1296317634.5661907, tmp)));
  assertEquals(-138663011, x -= ((-1751010109.5506423)>>(152829872)));
  assertEquals(-138663011, x %= (-1266200468));
  assertEquals(-138663011, x &= (x|((tmp = -571277275.622529, tmp)<<x)));
  assertEquals(-138663011, x >>= ((971259905.1265712)*(tmp = 2203764981, tmp)));
  assertEquals(-138663011, x %= (-904715829));
  assertEquals(-138663011, x |= ((tmp = -2823047885.283391, tmp)>>>(((tmp = 533217000, tmp)|(650754598.7836078))|(-1475565890))));
  assertEquals(-1610612736, x <<= x);
  assertEquals(-1610612736, x &= x);
  assertEquals(163840, x >>>= (-188885010));
  assertEquals(-1224224814, x |= (tmp = 3070742482, tmp));
  assertEquals(1498726395213334500, x *= x);
  assertEquals(1723591210, x |= ((tmp = 615164458, tmp)|x));
  assertEquals(1721910480, x ^= (x>>>x));
  assertEquals(4505284605.764313, x -= (tmp = -2783374125.7643127, tmp));
  assertEquals(-9504912393868483000, x *= (((tmp = 2896651872, tmp)<<(-2896385692.9017262))&(((((tmp = -2081179810.20238, tmp)|(tmp = -2484863999, tmp))>>((tmp = 1560885110.2665749, tmp)/(((tmp = 934324123.4289343, tmp)<<((tmp = -1591614157.0496385, tmp)+x))/(((x%(((tmp = 1672629986.8055913, tmp)%x)>>(tmp = 2116315086.2559657, tmp)))/(((-2687682697.5806303)>>x)/(-2034391222.5029132)))%(x-((((((tmp = 2598594967, tmp)/(((((((2950032233)%x)/x)^(tmp = -2126753451.3732262, tmp))<<(tmp = -3019113473, tmp))+(tmp = -2021220129.2320697, tmp))%((((-587645875.4666483)>>(((((x+x)+x)&(tmp = 533801785, tmp))|x)-((tmp = -2224808495.678903, tmp)/(1501942300))))>>>(-2558947646))>>((2798508249.020792)>>>x))))>>>((1060584557)/((((((((x&x)|(1426725365))>>>(tmp = 1500508838, tmp))>>(-1328705938))*((tmp = -2288009425.598777, tmp)>>>(((2586897285.9759064)%((-1605651559.2122297)>>>(tmp = 1936736684.4887302, tmp)))+((tmp = 2316261040, tmp)^(570340750.353874)))))&(x^((tmp = -2266524143, tmp)-(tmp = 2358520476, tmp))))+(tmp = 1449254900.9222453, tmp))%((-100598196)%((tmp = -2985318242.153491, tmp)>>((620722274.4565848)>>(871118975)))))))<<x)*(tmp = -1287065606.4143271, tmp))>>>(1038059916.2438471)))))))+((x/(-276990308.1264961))&(tmp = 2471016351.2195315, tmp)))|(((((tmp = -1288792769.3210807, tmp)+((tmp = -641817194, tmp)*(x<<(((-1933817364)>>(((tmp = 2084673536, tmp)|x)&x))&(tmp = -2752464480, tmp)))))%((796026752)*x))+(((tmp = -3083359669, tmp)|x)-((715303522)|(tmp = 181297266, tmp))))*(-1691520182.3207517)))));
  assertEquals(0, x <<= (-2322389800));
  assertEquals(0, x *= (tmp = 3188682235, tmp));
  assertEquals(0, x |= (x>>>((tmp = -2729325231.8288336, tmp)^((-393497076.96012783)*(x/(tmp = -2198942459.9466457, tmp))))));
  assertEquals(0, x ^= x);
  assertEquals(0, x %= (2835024997.4447937));
  assertEquals(0, x <<= x);
  assertEquals(0, x >>= (tmp = 1109824126, tmp));
  assertEquals(0, x <<= (3013043386));
  assertEquals(206825782.74659085, x -= (-206825782.74659085));
  assertEquals(-645346761227699500, x *= (-3120243292));
  assertEquals(6825462, x >>= ((tmp = 1457908135, tmp)<<x));
  assertEquals(-612366097.9189918, x -= (619191559.9189918));
  assertEquals(-612306090.9189918, x -= ((2328676543.893506)>>x));
  assertEquals(0, x ^= (x>>(((x>>>(1856200611.2269292))&(tmp = 2003217473, tmp))%((((((-107135673)+(((3062079356.170611)<<(tmp = -676928983, tmp))>>((tmp = -1487074941.2638814, tmp)|((-1601614031)/(1317006144.5025365)))))+x)*(((1163301641)>>>(448796567))/((x%((tmp = 72293197.34410787, tmp)+(-2304112723)))/((455610361)%(-2799431520)))))>>>(-217305041.09432888))<<(x-(tmp = -2168353649, tmp))))));
  assertEquals(0, x >>= x);
  assertEquals(-Infinity, x -= (((-1651597599.8950624)+(1780404320))/x));
  assertEquals(0, x <<= (tmp = 2246420272.4321294, tmp));
  assertEquals(0, x *= ((2793605382)-(tmp = -272299011, tmp)));
  assertEquals(0, x *= x);
  assertEquals(0, x <<= x);
  assertEquals(0, x >>= (tmp = 2556413090, tmp));
  assertEquals(0, x >>= ((tmp = -1784710085, tmp)%x));
  assertEquals(0, x %= (tmp = -1929880813, tmp));
  assertEquals(0, x *= (2586983368));
  assertEquals(0, x &= x);
  assertEquals(0, x <<= (-2144588807));
  assertEquals(0, x ^= ((x<<(((((((-596537598)+((x-(((((((tmp = -3179604796, tmp)/((tmp = 1156725365.3543215, tmp)>>>(tmp = -2762144319, tmp)))%(x<<x))&((tmp = 1750241928.1271567, tmp)&(x/((tmp = 1781306819, tmp)|x))))+((((2893068644)/((tmp = -576164593.9720252, tmp)<<((2724671.48995471)&(tmp = -573132475, tmp))))%(tmp = -1355625108, tmp))&(tmp = -302869512.5880568, tmp)))+x)<<x))>>((tmp = -2569172808, tmp)/x)))^x)-(tmp = -1174006275.2213159, tmp))&x)&(((((((-2303274799)>>(tmp = -814839320, tmp))/(tmp = 183887306.09810615, tmp))>>(((tmp = 1054106394.3704875, tmp)|x)>>>x))-(x-(tmp = 1313696830, tmp)))-((tmp = 2373274399.0742035, tmp)|((((tmp = -3163779539.4902935, tmp)*(tmp = -3056125181.726942, tmp))&(((x^(x^(x/((tmp = -576441696.6015451, tmp)<<(tmp = -26223719.920306206, tmp)))))>>(tmp = -2332835940, tmp))|((-146303509.41093707)&(tmp = -2676964025, tmp))))/((((x*(tmp = 1059918020, tmp))|((((2341797349)|(tmp = -744763805.1381104, tmp))<<x)+((2991320875.552578)^(2920702604.701831))))^(-1721756138))^(((tmp = -2794367554, tmp)>>((-2671235923.2097874)<<(x&((((tmp = -621472314.0859051, tmp)-(((x*x)+x)>>>((tmp = 1834038956, tmp)+x)))*x)^(tmp = -2090567586.321468, tmp)))))<<(321395210))))))>>>(tmp = -1207661719, tmp)))+(-2877264053.3805156)))/(x%(tmp = -2226991657.709366, tmp))));
  assertEquals(0, x *= (tmp = 986904991.061398, tmp));
  assertEquals(0, x -= (x%(650819306.6671969)));
  assertEquals(0, x >>>= (905893666.2871252));
  assertEquals(0, x += (((tmp = 2501942710.4804144, tmp)&x)/((tmp = -851080399.1751502, tmp)-(-1168623992))));
  assertEquals(-0, x *= (tmp = -2014577821.4554045, tmp));
  assertEquals(0, x &= (tmp = 1995246018, tmp));
  assertEquals(0, x %= (1724355237.7031958));
  assertEquals(-954696411, x += (((-2825222201)+(((1662353496.1795506)>>>(x-x))|(tmp = 225015046, tmp)))^(x&x)));
  assertEquals(-2158427339993389800, x *= (2260852052.1539803));
  assertEquals(19559, x >>>= (-862409169.4978967));
  assertEquals(-0.000012241163878671237, x /= (x^(tmp = 2697144215.160239, tmp)));
  assertEquals(0, x -= x);
  assertEquals(1448177644, x |= (tmp = 1448177644.624848, tmp));
  assertEquals(1448177644, x %= (((-1497553637.4976408)+(402228446))<<x));
  assertEquals(2304640553, x -= (-856462909));
  assertEquals(152436736, x &= ((766686903)*(((tmp = 660964683.1744609, tmp)|((((tmp = 297369746, tmp)-(x+((tmp = -2677127146, tmp)/x)))>>(((((((x%(x<<x))-(((((529254728)|((x|(-1407086127.6088922))&(tmp = -1968465008.5000398, tmp)))/(x%x))&((((-2761805265.92574)-x)*(x^(tmp = 110730179, tmp)))%((177220657.06030762)*(((2532585190.671373)/x)+(-1465143151)))))<<((tmp = -3008848338, tmp)<<(-2475597073))))|((-192996756.38619018)|((((1445996780)|(x>>>((((tmp = -2482370545.791443, tmp)*(tmp = -270543594, tmp))^x)*((1346780586)/(tmp = -625613363.885356, tmp)))))-(x<<(x/(-562307527))))&(-125701272))))*((x&x)%(tmp = 752963070, tmp)))>>>(tmp = 17419750.79086232, tmp))*x)^(x^((-157821212.04674292)-(tmp = 503849221.598824, tmp)))))-(tmp = 1479418449, tmp)))>>>((((((-78138548.2193842)<<(((2319032860.806689)-(tmp = -1564963892.5137577, tmp))>>>(-73673322.28957987)))<<((1797573493.3467085)*x))>>(tmp = 759994997, tmp))>>>(-1066441220))&(((((((tmp = 1972048857, tmp)*(((x&((-1347017320.0747669)>>>x))*(-2332716925.705054))%(-376976019.24362826)))>>>((tmp = -466479974, tmp)+x))&(-2282789473.3675604))|(((((((((269205423.7510414)-(tmp = 21919626.105656862, tmp))*((x-(tmp = -378670528, tmp))>>(tmp = -1045706598, tmp)))>>(tmp = -3062647341.234485, tmp))>>>x)|(tmp = -285399599.9386575, tmp))%(tmp = 2731214562, tmp))|((((tmp = 837093165.3438574, tmp)|(tmp = -2956931321, tmp))+((1871874558.3292787)<<((x|((tmp = -3169147427, tmp)%(((x^x)%(1479885041))%((1769991217)%(tmp = -1899472458, tmp)))))*(tmp = -837098563.71806, tmp))))>>(tmp = -1866722748, tmp)))-(2037734340.8345597)))>>((tmp = -1262019180.5332131, tmp)+(x*(1274173993.9800131))))*(tmp = 2336989321.855402, tmp))))));
  assertEquals(4, x >>= (tmp = -2577728327, tmp));
  assertEquals(16, x *= (x<<((2622323372.580596)*(tmp = -1947643367, tmp))));
  assertEquals(33554432, x <<= (tmp = -2938370507, tmp));
  assertEquals(-2399497018.987414, x -= (tmp = 2433051450.987414, tmp));
  assertEquals(1, x /= x);
  assertEquals(2, x <<= x);
  assertEquals(0, x >>= (x&x));
  assertEquals(0, x <<= x);
}
f();
                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/obj-construct.js                                                   0000664 0000000 0000000 00000003566 14746647661 0021661 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

var consCalled = false;

function Object() {
  consCalled = true;
}

function Array() {
  consCalled = true;
}

assertFalse(consCalled);
var x1 = { };
assertFalse(consCalled);
var x2 = { a: 3, b: 4 };
assertFalse(consCalled);
var x3 = [ ];
assertFalse(consCalled);
var x4 = [ 1, 2, 3 ];
assertFalse(consCalled);
                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/object-assign-regressions.js                                       0000664 0000000 0000000 00000003747 14746647661 0024157 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Flags: --allow-natives-syntax

(function() {
  let obj = {};
  // Add a property
  Object.defineProperty(obj, "__proto__", { enumerable: true, writable: true });
  // Adds side-step from {__proto__} -> {}
  Object.assign({}, obj);
  // Generalizes {__proto__}
  Object.defineProperty(obj, "__proto__", { value: 0 });
})();

(function() {
  var a = {};
  a.asdf = 42;
  Object.defineProperty(Object.prototype, "asdf", {get(){assertTrue(false);},
                                                   set(v){Object.defineProperty(this, "asdf", {value:100})}});
  assertTrue(Object.assign({}, a).asdf === 100);
  assertTrue(Object.assign({}, a).asdf === 100);
  assertTrue(Object.assign({}, a).asdf === 100);
})();

(function() {
  var a = {};
  a.x = 42;
  var b = {};
  b.y = 42;
  Object.assign({}, a);
  Object.defineProperty(Object.prototype, "x", {set(v) {}, configurable: true});
  assertTrue(Object.assign({}, a).x === undefined);
  assertTrue(Object.assign({}, b).y === 42);
  assertTrue(Object.assign({}, a).x === undefined);
  assertTrue(Object.assign({}, b).y === 42);
  Object.defineProperty(Object.prototype, "y", {set(v) {}, configurable: true});
  assertTrue(Object.assign({}, a).x === undefined);
  assertTrue(Object.assign({}, b).y === undefined);
  assertTrue(Object.assign({}, a).x === undefined);
  assertTrue(Object.assign({}, b).y === undefined);
})();

(function() {
  let a = {};
  a.qwer1 = 42;
  Object.defineProperty(Object.prototype, "qwer1", { writable: false });
  assertThrows(function(){ Object.assign({}, a) });
  assertThrows(function(){ Object.assign({}, a) });
  a = {};
  a.qwer2 = 42;
  Object.assign({}, a);
  Object.assign({}, a);
  Object.defineProperty(Object.prototype, "qwer2", { configurable: false });
  assertThrows(function(){ Object.assign({}, a) });
  assertThrows(function(){ Object.assign({}, a) });
})();
                         node-23.7.0/deps/v8/test/mjsunit/object-create.js                                                   0000664 0000000 0000000 00000020721 14746647661 0021564 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Test ES5 sections 15.2.3.5 Object.create.
// We do not support nonconfigurable properties on objects so that is not
// tested.  We do test getters, setters, writable, enumerable and value.

// Check that no exceptions are thrown.
Object.create(null);
Object.create(null, undefined);

// Check that the right exception is thrown.
try {
  Object.create(4);
  assertTrue(false);
} catch (e) {
  assertTrue(/Object or null/.test(e));
}

try {
  Object.create("foo");
  print(2);
  assertTrue(false);
} catch (e) {
  assertTrue(/Object or null/.test(e));
}

try {
  Object.create(null, this);
  assertTrue(false);
} catch(e) {
  assertTrue(/Property description/.test(e))
}

try {
  Object.create(null, [1, 2, 3]);
  assertTrue(false);
} catch(e) {
  assertTrue(/Property description/.test(e))
}

try {
  Object.create(null, new Proxy([1, 2, 3], {}));
  assertTrue(false);
} catch(e) {
  assertTrue(/Property description/.test(e))
}

var ctr = 0;
var ctr2 = 0;
var ctr3 = 0;
var ctr4 = 0;
var ctr5 = 0;
var ctr6 = 1000;

var protoFoo = { foo: function() { ctr++; }};
var fooValue = { foo: { writable: true, value: function() { ctr2++; }}};
var fooGetter = { foo: { get: function() { return ctr3++; }}};
var fooSetter = { foo: { set: function() { return ctr4++; }}};
var fooAmbiguous = { foo: { get: function() { return ctr3++; },
                            value: 3 }};

function valueGet() { ctr5++; return 3 };
function getterGet() { ctr5++; return function() { return ctr6++; }; };

// Simple object with prototype, no properties added.
Object.create(protoFoo).foo();
assertEquals(1, ctr);

// Simple object with object with prototype, no properties added.
Object.create(Object.create(protoFoo)).foo();
assertEquals(2, ctr);

// Add a property foo that returns a function.
var v = Object.create(protoFoo, fooValue);
v.foo();
assertEquals(2, ctr);
assertEquals(1, ctr2);

// Ensure the property is writable.
v.foo = 42;
assertEquals(42, v.foo);
assertEquals(2, ctr);
assertEquals(1, ctr2);

// Ensure by default properties are not writable.
v = Object.create(null, { foo: {value: 103}});
assertEquals(103, v.foo);
v.foo = 42;
assertEquals(103, v.foo);

// Add a getter foo that returns a counter value.
assertEquals(0, Object.create(protoFoo, fooGetter).foo);
assertEquals(2, ctr);
assertEquals(1, ctr2);
assertEquals(1, ctr3);

// Add a setter foo that runs a function.
assertEquals(1, Object.create(protoFoo, fooSetter).foo = 1);
assertEquals(2, ctr);
assertEquals(1, ctr2);
assertEquals(1, ctr3);
assertEquals(1, ctr4);

// Make sure that trying to add both a value and a getter
// will result in an exception.
try {
  Object.create(protoFoo, fooAmbiguous);
  assertTrue(false);
} catch (e) {
  assertTrue(/Invalid property/.test(e));
}
assertEquals(2, ctr);
assertEquals(1, ctr2);
assertEquals(1, ctr3);
assertEquals(1, ctr4);

var ctr7 = 0;

var metaProps = {
  enumerable: { get: function() {
                       assertEquals(0, ctr7++);
                       return true;
                     }},
  configurable: { get: function() {
                         assertEquals(1, ctr7++);
                         return true;
                       }},
  value: { get: function() {
                  assertEquals(2, ctr7++);
                  return 4;
                }},
  writable: { get: function() {
                     assertEquals(3, ctr7++);
                     return true;
                   }},
  get: { get: function() {
                assertEquals(4, ctr7++);
                return function() { };
              }},
  set: { get: function() {
                assertEquals(5, ctr7++);
                return function() { };
              }}
};


// Instead of a plain props object, let's use getters to return its properties.
var magicValueProps = { foo: Object.create(null, { value: { get: valueGet }})};
var magicGetterProps = { foo: Object.create(null, { get: { get: getterGet }})};
var magicAmbiguousProps = { foo: Object.create(null, metaProps) };

assertEquals(3, Object.create(null, magicValueProps).foo);
assertEquals(1, ctr5);

assertEquals(1000, Object.create(null, magicGetterProps).foo);
assertEquals(2, ctr5);

// See if we do the steps in ToPropertyDescriptor in the right order.
// We shouldn't throw the exception for an ambiguous properties object
// before we got all the values out.
try {
  Object.create(null, magicAmbiguousProps);
  assertTrue(false);
} catch (e) {
  assertTrue(/Invalid property/.test(e));
  assertEquals(6, ctr7);
}

var magicWritableProps = {
  foo: Object.create(null, { value: { value: 4 },
                             writable: { get: function() {
                                                ctr6++;
                                                return false;
                                              }}})};

var fooNotWritable = Object.create(null, magicWritableProps)
assertEquals(1002, ctr6);
assertEquals(4, fooNotWritable.foo);
fooNotWritable.foo = 5;
assertEquals(4, fooNotWritable.foo);


// Test enumerable flag.

var fooNotEnumerable =
    Object.create({fizz: 14}, {foo: {value: 3, enumerable: false},
                               bar: {value: 4, enumerable: true},
                               baz: {value: 5}});
var sum = 0;
for (x in fooNotEnumerable) {
  assertTrue(x === 'bar' || x === 'fizz');
  sum += fooNotEnumerable[x];
}
assertEquals(18, sum);


try {
  Object.create(null, {foo: { get: 0 }});
  assertTrue(false);
} catch (e) {
  assertTrue(/Getter must be a function/.test(e));
}

try {
  Object.create(null, {foo: { set: 0 }});
  assertTrue(false);
} catch (e) {
  assertTrue(/Setter must be a function/.test(e));
}

try {
  Object.create(null, {foo: { set: 0, get: 0 }});
  assertTrue(false);
} catch (e) {
  assertTrue(/Getter must be a function/.test(e));
}


// Ensure that only enumerable own properties on the descriptor are used.
var tricky = Object.create(
  { foo: { value: 1, enumerable: true }},
  { bar: { value: { value: 2, enumerable: true }, enumerable: false },
    baz: { value: { value: 4, enumerable: false }, enumerable: true },
    fizz: { value: { value: 8, enumerable: false }, enumerable: false },
    buzz: { value: { value: 16, enumerable: true }, enumerable: true }});

assertEquals(1, tricky.foo.value);
assertEquals(2, tricky.bar.value);
assertEquals(4, tricky.baz.value);
assertEquals(8, tricky.fizz.value);
assertEquals(16, tricky.buzz.value);

var sonOfTricky = Object.create(null, tricky);

assertFalse("foo" in sonOfTricky);
assertFalse("bar" in sonOfTricky);
assertTrue("baz" in sonOfTricky);
assertFalse("fizz" in sonOfTricky);
assertTrue("buzz" in sonOfTricky);

var sum = 0;
for (x in sonOfTricky) {
  assertTrue(x === 'buzz');
  sum += sonOfTricky[x];
}
assertEquals(16, sum);


(function createWithEmptyProtoInfoCreateMap() {
  var proto = {a:1};
  var instance = {__proto__: proto };
  // Try force creation of prototype info on proto by loading a proto property.
  assertEquals(instance.a, 1);
  var result = Object.create(proto, {});
  assertEquals(result.a, 1);
  assertEquals(result.__proto__, proto);
})()
                                               node-23.7.0/deps/v8/test/mjsunit/object-define-properties.js                                        0000664 0000000 0000000 00000005502 14746647661 0023745 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Tests the Object.defineProperties method - ES 15.2.3.7
// Note that the internal DefineOwnProperty method is tested through
// object-define-property.js, this file only contains tests specific for
// Object.defineProperties. Also note that object-create.js contains
// a range of indirect tests on this method since Object.create uses
// Object.defineProperties as a step in setting up the object.

// Try defining with null as descriptor:
try {
  Object.defineProperties({}, null);
} catch(e) {
  assertTrue(/null to object/.test(e));
}

// Try defining with null as object
try {
  Object.defineProperties(null, {});
} catch(e) {
  assertTrue(/called on non-object/.test(e));
}


var desc = {foo: {value: 10}, bar: {get: function() {return 42; }}};
var obj = {};
// Check that we actually get the object back as returnvalue
var x = Object.defineProperties(obj, desc);

assertEquals(x.foo, 10);
assertEquals(x.bar, 42);


// Make sure that all property descriptors are calculated before any
// modifications are done.

var object = {};

assertThrows(function() {
    Object.defineProperties(object, {
      foo: { value: 1 },
      bar: { value: 2, get: function() { return 3; } }
    });
  }, TypeError);

assertEquals(undefined, object.foo);
assertEquals(undefined, object.bar);
                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/object-define-property-length.js                                   0000664 0000000 0000000 00000002035 14746647661 0024712 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Tests the object.defineProperty method - ES 15.2.3.6

var arr = new Array()
arr[1] = 'foo'
arr[2] = 'bar'
arr[3] = '42'
arr[4] = '43'
arr[5] = '44'

// ES6 9.4.2.1
// If P is 'length', than ArraySetLength(A, Desc).

assertThrows(
  () => Object.defineProperty(arr, 'length', { value: -1, configurable: true }),
  RangeError,
  'Invalid array length'
)
assertThrows(
  () =>
    Object.defineProperty(arr, 'len' + 'gth', {
      value: -1,
      configurable: true
    }),
  RangeError,
  'Invalid array length'
)

assertThrows(
  () => Object.defineProperty(arr, 'length', { value: 1, configurable: true }),
  TypeError,
  'Cannot redefine property: length'
)

Object.defineProperty(arr, 'length', { value: 10 })
desc = Object.getOwnPropertyDescriptor(arr, 'length')
assertEquals(desc.value, 10)
assertTrue(desc.writable)
assertFalse(desc.enumerable)
assertFalse(desc.configurable)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/object-define-property.js                                          0000664 0000000 0000000 00000104040 14746647661 0023432 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2012 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Tests the object.defineProperty method - ES 15.2.3.6

// Flags: --allow-natives-syntax

// Check that an exception is thrown when null is passed as object.
var exception = false;
try {
  Object.defineProperty(null, null, null);
} catch (e) {
  exception = true;
  assertTrue(/called on non-object/.test(e));
}
assertTrue(exception);

// Check that an exception is thrown when undefined is passed as object.
exception = false;
try {
  Object.defineProperty(undefined, undefined, undefined);
} catch (e) {
  exception = true;
  assertTrue(/called on non-object/.test(e));
}
assertTrue(exception);

// Check that an exception is thrown when non-object is passed as object.
exception = false;
try {
  Object.defineProperty(0, "foo", undefined);
} catch (e) {
  exception = true;
  assertTrue(/called on non-object/.test(e));
}
assertTrue(exception);

// Object.
var obj1 = {};

// Values.
var val1 = 0;
var val2 = 0;
var val3 = 0;

function setter1() {val1++; }
function getter1() {return val1; }

function setter2() {val2++; }
function getter2() {return val2; }

function setter3() {val3++; }
function getter3() {return val3; }


// Descriptors.
var emptyDesc = {};

var accessorConfigurable = {
    set: setter1,
    get: getter1,
    configurable: true
};

var accessorNoConfigurable = {
    set: setter2,
    get: getter2,
    configurable: false
};

var accessorOnlySet = {
  set: setter3,
  configurable: true
};

var accessorOnlyGet = {
  get: getter3,
  configurable: true
};

var accessorDefault = {set: function(){} };

var dataConfigurable = { value: 1000, configurable: true };

var dataNoConfigurable = { value: 2000, configurable: false };

var dataWritable = { value: 3000, writable: true};


// Check that we can't add property with undefined attributes.
try {
  Object.defineProperty(obj1, "foo", undefined);
  assertTrue(false);
} catch (e) {
  assertTrue(/must be an object/.test(e));
}

// Make sure that we can add a property with an empty descriptor and
// that it has the default descriptor values.
Object.defineProperty(obj1, "foo", emptyDesc);

// foo should be undefined as it has no get, set or value
assertEquals(undefined, obj1.foo);

// We should, however, be able to retrieve the propertydescriptor which should
// have all default values (according to 8.6.1).
var desc = Object.getOwnPropertyDescriptor(obj1, "foo");
assertFalse(desc.configurable);
assertFalse(desc.enumerable);
assertFalse(desc.writable);
assertEquals(desc.get, undefined);
assertEquals(desc.set, undefined);
assertEquals(desc.value, undefined);

// Make sure that getOwnPropertyDescriptor does not return a descriptor
// with default values if called with non existing property (otherwise
// the test above is invalid).
desc = Object.getOwnPropertyDescriptor(obj1, "bar");
assertEquals(desc, undefined);

// Make sure that foo can't be reset (as configurable is false).
try {
  Object.defineProperty(obj1, "foo", accessorConfigurable);
} catch (e) {
  assertTrue(/Cannot redefine property/.test(e));
}


// Accessor properties

Object.defineProperty(obj1, "bar", accessorConfigurable);
desc = Object.getOwnPropertyDescriptor(obj1, "bar");
assertTrue(desc.configurable);
assertFalse(desc.enumerable);
assertEquals(desc.writable, undefined);
assertEquals(desc.get, accessorConfigurable.get);
assertEquals(desc.set, accessorConfigurable.set);
assertEquals(desc.value, undefined);
assertEquals(1, obj1.bar = 1);
assertEquals(1, val1);
assertEquals(1, obj1.bar = 1);
assertEquals(2, val1);
assertEquals(2, obj1.bar);

// Redefine bar with non configurable test
Object.defineProperty(obj1, "bar", accessorNoConfigurable);
desc = Object.getOwnPropertyDescriptor(obj1, "bar");
assertFalse(desc.configurable);
assertFalse(desc.enumerable);
assertEquals(desc.writable, undefined);
assertEquals(desc.get, accessorNoConfigurable.get);
assertEquals(desc.set, accessorNoConfigurable.set);
assertEquals(desc.value, undefined);
assertEquals(1, obj1.bar = 1);
assertEquals(2, val1);
assertEquals(1, val2);
assertEquals(1, obj1.bar = 1)
assertEquals(2, val1);
assertEquals(2, val2);
assertEquals(2, obj1.bar);

// Try to redefine bar again - should fail as configurable is false.
try {
  Object.defineProperty(obj1, "bar", accessorConfigurable);
  assertTrue(false);
} catch(e) {
  assertTrue(/Cannot redefine property/.test(e));
}

// Try to redefine bar again using the data descriptor - should fail.
try {
  Object.defineProperty(obj1, "bar", dataConfigurable);
  assertTrue(false);
} catch(e) {
  assertTrue(/Cannot redefine property/.test(e));
}

// Redefine using same descriptor - should succeed.
Object.defineProperty(obj1, "bar", accessorNoConfigurable);
desc = Object.getOwnPropertyDescriptor(obj1, "bar");
assertFalse(desc.configurable);
assertFalse(desc.enumerable);
assertEquals(desc.writable, undefined);
assertEquals(desc.get, accessorNoConfigurable.get);
assertEquals(desc.set, accessorNoConfigurable.set);
assertEquals(desc.value, undefined);
assertEquals(1, obj1.bar = 1);
assertEquals(2, val1);
assertEquals(3, val2);
assertEquals(1, obj1.bar = 1)
assertEquals(2, val1);
assertEquals(4, val2);
assertEquals(4, obj1.bar);

// Define an accessor that has only a setter.
Object.defineProperty(obj1, "setOnly", accessorOnlySet);
desc = Object.getOwnPropertyDescriptor(obj1, "setOnly");
assertTrue(desc.configurable);
assertFalse(desc.enumerable);
assertEquals(desc.set, accessorOnlySet.set);
assertEquals(desc.writable, undefined);
assertEquals(desc.value, undefined);
assertEquals(desc.get, undefined);
assertEquals(1, obj1.setOnly = 1);
assertEquals(1, val3);

// Add a getter - should not touch the setter.
Object.defineProperty(obj1, "setOnly", accessorOnlyGet);
desc = Object.getOwnPropertyDescriptor(obj1, "setOnly");
assertTrue(desc.configurable);
assertFalse(desc.enumerable);
assertEquals(desc.get, accessorOnlyGet.get);
assertEquals(desc.set, accessorOnlySet.set);
assertEquals(desc.writable, undefined);
assertEquals(desc.value, undefined);
assertEquals(1, obj1.setOnly = 1);
assertEquals(2, val3);

// The above should also work if redefining just a getter or setter on
// an existing property with both a getter and a setter.
Object.defineProperty(obj1, "both", accessorConfigurable);

Object.defineProperty(obj1, "both", accessorOnlySet);
desc = Object.getOwnPropertyDescriptor(obj1, "both");
assertTrue(desc.configurable);
assertFalse(desc.enumerable);
assertEquals(desc.set, accessorOnlySet.set);
assertEquals(desc.get, accessorConfigurable.get);
assertEquals(desc.writable, undefined);
assertEquals(desc.value, undefined);
assertEquals(1, obj1.both = 1);
assertEquals(3, val3);


// Data properties

Object.defineProperty(obj1, "foobar", dataConfigurable);
desc = Object.getOwnPropertyDescriptor(obj1, "foobar");
assertEquals(obj1.foobar, 1000);
assertEquals(desc.value, 1000);
assertTrue(desc.configurable);
assertFalse(desc.writable);
assertFalse(desc.enumerable);
assertEquals(desc.get, undefined);
assertEquals(desc.set, undefined);
//Try writing to non writable attribute - should remain 1000
obj1.foobar = 1001;
assertEquals(obj1.foobar, 1000);


// Redefine to writable descriptor - now writing to foobar should be allowed.
Object.defineProperty(obj1, "foobar", dataWritable);
desc = Object.getOwnPropertyDescriptor(obj1, "foobar");
assertEquals(obj1.foobar, 3000);
assertEquals(desc.value, 3000);
// Note that since dataWritable does not define configurable the configurable
// setting from the redefined property (in this case true) is used.
assertTrue(desc.configurable);
assertTrue(desc.writable);
assertFalse(desc.enumerable);
assertEquals(desc.get, undefined);
assertEquals(desc.set, undefined);
// Writing to the property should now be allowed
obj1.foobar = 1001;
assertEquals(obj1.foobar, 1001);


// Redefine with non configurable data property.
Object.defineProperty(obj1, "foobar", dataNoConfigurable);
desc = Object.getOwnPropertyDescriptor(obj1, "foobar");
assertEquals(obj1.foobar, 2000);
assertEquals(desc.value, 2000);
assertFalse(desc.configurable);
assertTrue(desc.writable);
assertFalse(desc.enumerable);
assertEquals(desc.get, undefined);
assertEquals(desc.set, undefined);

// Try redefine again - shold fail because configurable is now false.
try {
  Object.defineProperty(obj1, "foobar", dataConfigurable);
  assertTrue(false);
} catch (e) {
  assertTrue(/Cannot redefine property/.test(e));
}

// Try redefine again with accessor property - shold also fail.
try {
  Object.defineProperty(obj1, "foobar", dataConfigurable);
  assertTrue(false);
} catch (e) {
  assertTrue(/Cannot redefine property/.test(e));
}


// Redifine with the same descriptor - should succeed (step 6).
Object.defineProperty(obj1, "foobar", dataNoConfigurable);
desc = Object.getOwnPropertyDescriptor(obj1, "foobar");
assertEquals(obj1.foobar, 2000);
assertEquals(desc.value, 2000);
assertFalse(desc.configurable);
assertTrue(desc.writable);
assertFalse(desc.enumerable);
assertEquals(desc.get, undefined);
assertEquals(desc.set, undefined);


// New object
var obj2 = {};

// Make accessor - redefine to data
Object.defineProperty(obj2, "foo", accessorConfigurable);

// Redefine to data property
Object.defineProperty(obj2, "foo", dataConfigurable);
desc = Object.getOwnPropertyDescriptor(obj2, "foo");
assertEquals(obj2.foo, 1000);
assertEquals(desc.value, 1000);
assertTrue(desc.configurable);
assertFalse(desc.writable);
assertFalse(desc.enumerable);
assertEquals(desc.get, undefined);
assertEquals(desc.set, undefined);


// Redefine back to accessor
Object.defineProperty(obj2, "foo", accessorConfigurable);
desc = Object.getOwnPropertyDescriptor(obj2, "foo");
assertTrue(desc.configurable);
assertFalse(desc.enumerable);
assertEquals(desc.writable, undefined);
assertEquals(desc.get, accessorConfigurable.get);
assertEquals(desc.set, accessorConfigurable.set);
assertEquals(desc.value, undefined);
assertEquals(1, obj2.foo = 1);
assertEquals(3, val1);
assertEquals(4, val2);
assertEquals(3, obj2.foo);

// Make data - redefine to accessor
Object.defineProperty(obj2, "bar", dataConfigurable)

// Redefine to accessor property
Object.defineProperty(obj2, "bar", accessorConfigurable);
desc = Object.getOwnPropertyDescriptor(obj2, "bar");
assertTrue(desc.configurable);
assertFalse(desc.enumerable);
assertEquals(desc.writable, undefined);
assertEquals(desc.get, accessorConfigurable.get);
assertEquals(desc.set, accessorConfigurable.set);
assertEquals(desc.value, undefined);
assertEquals(1, obj2.bar = 1);
assertEquals(4, val1);
assertEquals(4, val2);
assertEquals(4, obj2.foo);

// Redefine back to data property
Object.defineProperty(obj2, "bar", dataConfigurable);
desc = Object.getOwnPropertyDescriptor(obj2, "bar");
assertEquals(obj2.bar, 1000);
assertEquals(desc.value, 1000);
assertTrue(desc.configurable);
assertFalse(desc.writable);
assertFalse(desc.enumerable);
assertEquals(desc.get, undefined);
assertEquals(desc.set, undefined);


// Redefinition of an accessor defined using __defineGetter__ and
// __defineSetter__.
function get(){return this.x}
function set(x){this.x=x};

var obj3 = {x:1000};
obj3.__defineGetter__("foo", get);
obj3.__defineSetter__("foo", set);

desc = Object.getOwnPropertyDescriptor(obj3, "foo");
assertTrue(desc.configurable);
assertTrue(desc.enumerable);
assertEquals(desc.writable, undefined);
assertEquals(desc.get, get);
assertEquals(desc.set, set);
assertEquals(desc.value, undefined);
assertEquals(1, obj3.foo = 1);
assertEquals(1, obj3.x);
assertEquals(1, obj3.foo);

// Redefine to accessor property (non configurable) - note that enumerable
// which we do not redefine should remain the same (true).
Object.defineProperty(obj3, "foo", accessorNoConfigurable);
desc = Object.getOwnPropertyDescriptor(obj3, "foo");
assertFalse(desc.configurable);
assertTrue(desc.enumerable);
assertEquals(desc.writable, undefined);
assertEquals(desc.get, accessorNoConfigurable.get);
assertEquals(desc.set, accessorNoConfigurable.set);
assertEquals(desc.value, undefined);
assertEquals(1, obj3.foo = 1);
assertEquals(5, val2);
assertEquals(5, obj3.foo);


obj3.__defineGetter__("bar", get);
obj3.__defineSetter__("bar", set);


// Redefine back to data property
Object.defineProperty(obj3, "bar", dataConfigurable);
desc = Object.getOwnPropertyDescriptor(obj3, "bar");
assertEquals(obj3.bar, 1000);
assertEquals(desc.value, 1000);
assertTrue(desc.configurable);
assertFalse(desc.writable);
assertTrue(desc.enumerable);
assertEquals(desc.get, undefined);
assertEquals(desc.set, undefined);


var obj4 = {};
var func = function (){return 42;};
obj4.bar = func;
assertEquals(42, obj4.bar());

Object.defineProperty(obj4, "bar", accessorConfigurable);
desc = Object.getOwnPropertyDescriptor(obj4, "bar");
assertTrue(desc.configurable);
assertTrue(desc.enumerable);
assertEquals(desc.writable, undefined);
assertEquals(desc.get, accessorConfigurable.get);
assertEquals(desc.set, accessorConfigurable.set);
assertEquals(desc.value, undefined);
assertEquals(1, obj4.bar = 1);
assertEquals(5, val1);
assertEquals(5, obj4.bar);

// Make sure an error is thrown when trying to access to redefined function.
try {
  obj4.bar();
  assertTrue(false);
} catch (e) {
  assertTrue(/is not a function/.test(e));
}


// Test that all possible differences in step 6 in DefineOwnProperty are
// exercised, i.e., any difference in the given property descriptor and the
// existing properties should not return true, but throw an error if the
// existing configurable property is false.

var obj5 = {};
// Enumerable will default to false.
Object.defineProperty(obj5, 'foo', accessorNoConfigurable);
desc = Object.getOwnPropertyDescriptor(obj5, 'foo');
// First, test that we are actually allowed to set the accessor if all
// values are of the descriptor are the same as the existing one.
Object.defineProperty(obj5, 'foo', accessorNoConfigurable);

// Different setter.
var descDifferent = {
  configurable:false,
  enumerable:false,
  set: setter1,
  get: getter2
};

try {
  Object.defineProperty(obj5, 'foo', descDifferent);
  assertTrue(false);
} catch (e) {
  assertTrue(/Cannot redefine property/.test(e));
}

// Different getter.
descDifferent = {
  configurable:false,
  enumerable:false,
  set: setter2,
  get: getter1
};

try {
  Object.defineProperty(obj5, 'foo', descDifferent);
  assertTrue(false);
} catch (e) {
  assertTrue(/Cannot redefine property/.test(e));
}

// Different enumerable.
descDifferent = {
  configurable:false,
  enumerable:true,
  set: setter2,
  get: getter2
};

try {
  Object.defineProperty(obj5, 'foo', descDifferent);
  assertTrue(false);
} catch (e) {
  assertTrue(/Cannot redefine property/.test(e));
}

// Different configurable.
descDifferent = {
  configurable:false,
  enumerable:true,
  set: setter2,
  get: getter2
};

try {
  Object.defineProperty(obj5, 'foo', descDifferent);
  assertTrue(false);
} catch (e) {
  assertTrue(/Cannot redefine property/.test(e));
}

// No difference.
descDifferent = {
  configurable:false,
  enumerable:false,
  set: setter2,
  get: getter2
};
// Make sure we can still redefine if all properties are the same.
Object.defineProperty(obj5, 'foo', descDifferent);

// Make sure that obj5 still holds the original values.
desc = Object.getOwnPropertyDescriptor(obj5, 'foo');
assertEquals(desc.get, getter2);
assertEquals(desc.set, setter2);
assertFalse(desc.enumerable);
assertFalse(desc.configurable);


// Also exercise step 6 on data property, writable and enumerable
// defaults to false.
Object.defineProperty(obj5, 'bar', dataNoConfigurable);

// Test that redefinition with the same property descriptor is possible
Object.defineProperty(obj5, 'bar', dataNoConfigurable);

// Different value.
descDifferent = {
  configurable:false,
  enumerable:false,
  writable: false,
  value: 1999
};

try {
  Object.defineProperty(obj5, 'bar', descDifferent);
  assertTrue(false);
} catch (e) {
  assertTrue(/Cannot redefine property/.test(e));
}

// Different writable.
descDifferent = {
  configurable:false,
  enumerable:false,
  writable: true,
  value: 2000
};

try {
  Object.defineProperty(obj5, 'bar', descDifferent);
  assertTrue(false);
} catch (e) {
  assertTrue(/Cannot redefine property/.test(e));
}


// Different enumerable.
descDifferent = {
  configurable:false,
  enumerable:true ,
  writable:false,
  value: 2000
};

try {
  Object.defineProperty(obj5, 'bar', descDifferent);
  assertTrue(false);
} catch (e) {
  assertTrue(/Cannot redefine property/.test(e));
}


// Different configurable.
descDifferent = {
  configurable:true,
  enumerable:false,
  writable:false,
  value: 2000
};

try {
  Object.defineProperty(obj5, 'bar', descDifferent);
  assertTrue(false);
} catch (e) {
  assertTrue(/Cannot redefine property/.test(e));
}

// No difference.
descDifferent = {
  configurable:false,
  enumerable:false,
  writable:false,
  value:2000
};
// Make sure we can still redefine if all properties are the same.
Object.defineProperty(obj5, 'bar', descDifferent);

// Make sure that obj5 still holds the original values.
desc = Object.getOwnPropertyDescriptor(obj5, 'bar');
assertEquals(desc.value, 2000);
assertFalse(desc.writable);
assertFalse(desc.enumerable);
assertFalse(desc.configurable);


// Make sure that we can't overwrite +0 with -0 and vice versa.
var descMinusZero = {value: -0, configurable: false};
var descPlusZero = {value: +0, configurable: false};

Object.defineProperty(obj5, 'minuszero', descMinusZero);

// Make sure we can redefine with -0.
Object.defineProperty(obj5, 'minuszero', descMinusZero);

exception = false;
try {
  Object.defineProperty(obj5, 'minuszero', descPlusZero);
} catch (e) {
  exception = true;
  assertTrue(/Cannot redefine property/.test(e));
}
assertTrue(exception);


Object.defineProperty(obj5, 'pluszero', descPlusZero);

// Make sure we can redefine with +0.
Object.defineProperty(obj5, 'pluszero', descPlusZero);

exception = false;
try {
  Object.defineProperty(obj5, 'pluszero', descMinusZero);
} catch (e) {
  exception = true;
  assertTrue(/Cannot redefine property/.test(e));
}
assertTrue(exception);


var obj6 = {};
obj6[1] = 'foo';
obj6[2] = 'bar';
obj6[3] = '42';
obj6[4] = '43';
obj6[5] = '44';

var descElement = { value: 'foobar' };
var descElementNonConfigurable = { value: 'barfoo', configurable: false };
var descElementNonWritable = { value: 'foofoo', writable: false };
var descElementNonEnumerable = { value: 'barbar', enumerable: false };
var descElementAllFalse = { value: 'foofalse',
                            configurable: false,
                            writable: false,
                            enumerable: false };


// Redefine existing property.
Object.defineProperty(obj6, '1', descElement);
desc = Object.getOwnPropertyDescriptor(obj6, '1');
assertEquals(desc.value, 'foobar');
assertTrue(desc.writable);
assertTrue(desc.enumerable);
assertTrue(desc.configurable);

// Redefine existing property with configurable: false.
Object.defineProperty(obj6, '2', descElementNonConfigurable);
desc = Object.getOwnPropertyDescriptor(obj6, '2');
assertEquals(desc.value, 'barfoo');
assertTrue(desc.writable);
assertTrue(desc.enumerable);
assertFalse(desc.configurable);

// Can use defineProperty to change the value of a non
// configurable property.
try {
  Object.defineProperty(obj6, '2', descElement);
  desc = Object.getOwnPropertyDescriptor(obj6, '2');
  assertEquals(desc.value, 'foobar');
} catch (e) {
  assertUnreachable();
}

// Ensure that we can't change the descriptor of a
// non configurable property.
exception = false;
try {
  var descAccessor = { get: function() { return 0; } };
  Object.defineProperty(obj6, '2', descAccessor);
} catch (e) {
  exception = true;
  assertTrue(/Cannot redefine property/.test(e));
}
assertTrue(exception);

Object.defineProperty(obj6, '2', descElementNonWritable);
desc = Object.getOwnPropertyDescriptor(obj6, '2');
assertEquals(desc.value, 'foofoo');
assertFalse(desc.writable);
assertTrue(desc.enumerable);
assertFalse(desc.configurable);

Object.defineProperty(obj6, '3', descElementNonWritable);
desc = Object.getOwnPropertyDescriptor(obj6, '3');
assertEquals(desc.value, 'foofoo');
assertFalse(desc.writable);
assertTrue(desc.enumerable);
assertTrue(desc.configurable);

// Redefine existing property with configurable: false.
Object.defineProperty(obj6, '4', descElementNonEnumerable);
desc = Object.getOwnPropertyDescriptor(obj6, '4');
assertEquals(desc.value, 'barbar');
assertTrue(desc.writable);
assertFalse(desc.enumerable);
assertTrue(desc.configurable);

// Redefine existing property with configurable: false.
Object.defineProperty(obj6, '5', descElementAllFalse);
desc = Object.getOwnPropertyDescriptor(obj6, '5');
assertEquals(desc.value, 'foofalse');
assertFalse(desc.writable);
assertFalse(desc.enumerable);
assertFalse(desc.configurable);

// Define non existing property - all attributes should default to false.
Object.defineProperty(obj6, '15', descElement);
desc = Object.getOwnPropertyDescriptor(obj6, '15');
assertEquals(desc.value, 'foobar');
assertFalse(desc.writable);
assertFalse(desc.enumerable);
assertFalse(desc.configurable);

// Make sure that we can't redefine using direct access.
obj6[15] ='overwrite';
assertEquals(obj6[15],'foobar');


// Repeat the above tests on an array.
var arr = new Array();
arr[1] = 'foo';
arr[2] = 'bar';
arr[3] = '42';
arr[4] = '43';
arr[5] = '44';

var descElement = { value: 'foobar' };
var descElementNonConfigurable = { value: 'barfoo', configurable: false };
var descElementNonWritable = { value: 'foofoo', writable: false };
var descElementNonEnumerable = { value: 'barbar', enumerable: false };
var descElementAllFalse = { value: 'foofalse',
                            configurable: false,
                            writable: false,
                            enumerable: false };


// Redefine existing property.
Object.defineProperty(arr, '1', descElement);
desc = Object.getOwnPropertyDescriptor(arr, '1');
assertEquals(desc.value, 'foobar');
assertTrue(desc.writable);
assertTrue(desc.enumerable);
assertTrue(desc.configurable);

// Redefine existing property with configurable: false.
Object.defineProperty(arr, '2', descElementNonConfigurable);
desc = Object.getOwnPropertyDescriptor(arr, '2');
assertEquals(desc.value, 'barfoo');
assertTrue(desc.writable);
assertTrue(desc.enumerable);
assertFalse(desc.configurable);

// Can use defineProperty to change the value of a non
// configurable property of an array.
try {
  Object.defineProperty(arr, '2', descElement);
  desc = Object.getOwnPropertyDescriptor(arr, '2');
  assertEquals(desc.value, 'foobar');
} catch (e) {
  assertUnreachable();
}

// Ensure that we can't change the descriptor of a
// non configurable property.
exception = false;
try {
  var descAccessor = { get: function() { return 0; } };
  Object.defineProperty(arr, '2', descAccessor);
} catch (e) {
  exception = true;
  assertTrue(/Cannot redefine property/.test(e));
}
assertTrue(exception);

Object.defineProperty(arr, '2', descElementNonWritable);
desc = Object.getOwnPropertyDescriptor(arr, '2');
assertEquals(desc.value, 'foofoo');
assertFalse(desc.writable);
assertTrue(desc.enumerable);
assertFalse(desc.configurable);

Object.defineProperty(arr, '3', descElementNonWritable);
desc = Object.getOwnPropertyDescriptor(arr, '3');
assertEquals(desc.value, 'foofoo');
assertFalse(desc.writable);
assertTrue(desc.enumerable);
assertTrue(desc.configurable);

// Redefine existing property with configurable: false.
Object.defineProperty(arr, '4', descElementNonEnumerable);
desc = Object.getOwnPropertyDescriptor(arr, '4');
assertEquals(desc.value, 'barbar');
assertTrue(desc.writable);
assertFalse(desc.enumerable);
assertTrue(desc.configurable);

// Redefine existing property with configurable: false.
Object.defineProperty(arr, '5', descElementAllFalse);
desc = Object.getOwnPropertyDescriptor(arr, '5');
assertEquals(desc.value, 'foofalse');
assertFalse(desc.writable);
assertFalse(desc.enumerable);
assertFalse(desc.configurable);

// Define non existing property - all attributes should default to false.
Object.defineProperty(arr, '15', descElement);
desc = Object.getOwnPropertyDescriptor(arr, '15');
assertEquals(desc.value, 'foobar');
assertFalse(desc.writable);
assertFalse(desc.enumerable);
assertFalse(desc.configurable);

// Define non-array property, check that .length is unaffected.
assertEquals(16, arr.length);
Object.defineProperty(arr, '0x20', descElement);
assertEquals(16, arr.length);

// See issue 968: http://code.google.com/p/v8/issues/detail?id=968
var o = { x : 42 };
Object.defineProperty(o, "x", { writable: false });
assertEquals(42, o.x);
o.x = 37;
assertEquals(42, o.x);

o = { x : 42 };
Object.defineProperty(o, "x", {});
assertEquals(42, o.x);
o.x = 37;
// Writability is preserved.
assertEquals(37, o.x);

var o = { };
Object.defineProperty(o, "x", { writable: false });
assertEquals(undefined, o.x);
o.x = 37;
assertEquals(undefined, o.x);

o = { get x() { return 87; } };
Object.defineProperty(o, "x", { writable: false });
assertEquals(undefined, o.x);
o.x = 37;
assertEquals(undefined, o.x);

// Ignore inherited properties.
o = { __proto__ : { x : 87 } };
Object.defineProperty(o, "x", { writable: false });
assertEquals(undefined, o.x);
o.x = 37;
assertEquals(undefined, o.x);

function testDefineProperty(obj, propertyName, desc, resultDesc) {
  Object.defineProperty(obj, propertyName, desc);
  var actualDesc = Object.getOwnPropertyDescriptor(obj, propertyName);
  assertEquals(resultDesc.enumerable, actualDesc.enumerable);
  assertEquals(resultDesc.configurable, actualDesc.configurable);
  if (resultDesc.hasOwnProperty('value')) {
    assertEquals(resultDesc.value, actualDesc.value);
    assertEquals(resultDesc.writable, actualDesc.writable);
    assertFalse(resultDesc.hasOwnProperty('get'));
    assertFalse(resultDesc.hasOwnProperty('set'));
  } else {
    assertEquals(resultDesc.get, actualDesc.get);
    assertEquals(resultDesc.set, actualDesc.set);
    assertFalse(resultDesc.hasOwnProperty('value'));
    assertFalse(resultDesc.hasOwnProperty('writable'));
  }
}

// tests redefining existing property with a generic descriptor
o = { p : 42 };
testDefineProperty(o, 'p',
  { },
  { value : 42, writable : true, enumerable : true, configurable : true });

o = { p : 42 };
testDefineProperty(o, 'p',
  { enumerable : true },
  { value : 42, writable : true, enumerable : true, configurable : true });

o = { p : 42 };
testDefineProperty(o, 'p',
  { configurable : true },
  { value : 42, writable : true, enumerable : true, configurable : true });

o = { p : 42 };
testDefineProperty(o, 'p',
  { enumerable : false },
  { value : 42, writable : true, enumerable : false, configurable : true });

o = { p : 42 };
testDefineProperty(o, 'p',
  { configurable : false },
  { value : 42, writable : true, enumerable : true, configurable : false });

o = { p : 42 };
testDefineProperty(o, 'p',
  { enumerable : true, configurable : true },
  { value : 42, writable : true, enumerable : true, configurable : true });

o = { p : 42 };
testDefineProperty(o, 'p',
  { enumerable : false, configurable : true },
  { value : 42, writable : true, enumerable : false, configurable : true });

o = { p : 42 };
testDefineProperty(o, 'p',
  { enumerable : true, configurable : false },
  { value : 42, writable : true, enumerable : true, configurable : false });

o = { p : 42 };
testDefineProperty(o, 'p',
  { enumerable : false, configurable : false },
  { value : 42, writable : true, enumerable : false, configurable : false });

// can make a writable, non-configurable field non-writable
o = { p : 42 };
Object.defineProperty(o, 'p', { configurable: false });
testDefineProperty(o, 'p',
  { writable: false },
  { value : 42, writable : false, enumerable : true, configurable : false });

// redefine of get only property with generic descriptor
o = {};
Object.defineProperty(o, 'p',
  { get : getter1, enumerable: true, configurable: true });
testDefineProperty(o, 'p',
  { enumerable : false, configurable : false },
  { get: getter1, set: undefined, enumerable : false, configurable : false });

// redefine of get/set only property with generic descriptor
o = {};
Object.defineProperty(o, 'p',
  { get: getter1, set: setter1, enumerable: true, configurable: true });
testDefineProperty(o, 'p',
  { enumerable : false, configurable : false },
  { get: getter1, set: setter1, enumerable : false, configurable : false });

// redefine of set only property with generic descriptor
o = {};
Object.defineProperty(o, 'p',
  { set : setter1, enumerable: true, configurable: true });
testDefineProperty(o, 'p',
  { enumerable : false, configurable : false },
  { get: undefined, set: setter1, enumerable : false, configurable : false });


// Regression test: Ensure that growing dictionaries are not ignored.
o = {};
for (var i = 0; i < 1000; i++) {
  // Non-enumerable property forces dictionary mode.
  Object.defineProperty(o, i, {value: i, enumerable: false});
}
assertEquals(999, o[999]);


// Regression test: Bizarre behavior on non-strict arguments object.
// TODO(yangguo): Tests disabled, needs investigation!
/*
(function test(arg0) {
  // Here arguments[0] is a fast alias on arg0.
  Object.defineProperty(arguments, "0", {
    value:1,
    enumerable:false
  });
  // Here arguments[0] is a slow alias on arg0.
  Object.defineProperty(arguments, "0", {
    value:2,
    writable:false
  });
  // Here arguments[0] is no alias at all.
  Object.defineProperty(arguments, "0", {
    value:3
  });
  assertEquals(2, arg0);
  assertEquals(3, arguments[0]);
})(0);
*/

// Regression test: We should never observe the hole value.
var objectWithGetter = {};
objectWithGetter.__defineGetter__('foo', function() {});
assertEquals(undefined, objectWithGetter.__lookupSetter__('foo'));

var objectWithSetter = {};
objectWithSetter.__defineSetter__('foo', function(x) {});
assertEquals(undefined, objectWithSetter.__lookupGetter__('foo'));

// An object with a getter on the prototype chain.
function getter() { return 111; }
function anotherGetter() { return 222; }

function testGetterOnProto(expected, o) {
  assertEquals(expected, o.quebec);
}
%PrepareFunctionForOptimization(testGetterOnProto);

obj1 = {};
Object.defineProperty(obj1, "quebec", { get: getter, configurable: true });
obj2 = Object.create(obj1);
obj3 = Object.create(obj2);

%PrepareFunctionForOptimization(testGetterOnProto);
testGetterOnProto(111, obj3);
testGetterOnProto(111, obj3);
%OptimizeFunctionOnNextCall(testGetterOnProto);
testGetterOnProto(111, obj3);
testGetterOnProto(111, obj3);

Object.defineProperty(obj1, "quebec", { get: anotherGetter });

testGetterOnProto(222, obj3);
testGetterOnProto(222, obj3);
%PrepareFunctionForOptimization(testGetterOnProto);
%OptimizeFunctionOnNextCall(testGetterOnProto);
testGetterOnProto(222, obj3);
testGetterOnProto(222, obj3);

// An object with a setter on the prototype chain.
var modifyMe;
function setter(x) { modifyMe = x+1; }
function anotherSetter(x) { modifyMe = x+2; }

function testSetterOnProto(expected, o) {
  modifyMe = 333;
  o.romeo = 444;
  assertEquals(expected, modifyMe);
}
%PrepareFunctionForOptimization(testSetterOnProto);

obj1 = {};
Object.defineProperty(obj1, "romeo", { set: setter, configurable: true });
obj2 = Object.create(obj1);
obj3 = Object.create(obj2);

testSetterOnProto(445, obj3);
testSetterOnProto(445, obj3);
%OptimizeFunctionOnNextCall(testSetterOnProto);
testSetterOnProto(445, obj3);
testSetterOnProto(445, obj3);

Object.defineProperty(obj1, "romeo", { set: anotherSetter });

testSetterOnProto(446, obj3);
testSetterOnProto(446, obj3);
%PrepareFunctionForOptimization(testSetterOnProto);
%OptimizeFunctionOnNextCall(testSetterOnProto);
testSetterOnProto(446, obj3);
testSetterOnProto(446, obj3);

// Removing a setter on the prototype chain.
function testSetterOnProtoStrict(o) {
  "use strict";
  o.sierra = 12345;
}
%PrepareFunctionForOptimization(testSetterOnProtoStrict);

obj1 = {};
Object.defineProperty(obj1, "sierra",
                      { get: getter, set: setter, configurable: true });
obj2 = Object.create(obj1);
obj3 = Object.create(obj2);

testSetterOnProtoStrict(obj3);
testSetterOnProtoStrict(obj3);
%OptimizeFunctionOnNextCall(testSetterOnProtoStrict);
testSetterOnProtoStrict(obj3);
testSetterOnProtoStrict(obj3);

Object.defineProperty(obj1, "sierra",
                      { get: getter, set: undefined, configurable: true });

exception = false;
try {
  testSetterOnProtoStrict(obj3);
} catch (e) {
  exception = true;
  assertTrue(/which has only a getter/.test(e));
}
assertTrue(exception);

// Test assignment to a getter-only property on the prototype chain. This makes
// sure that crankshaft re-checks its assumptions and doesn't rely only on type
// feedback (which would be monomorphic here).

function Assign(o) {
  o.blubb = 123;
}
%PrepareFunctionForOptimization(Assign);

function C() {}

Assign(new C);
Assign(new C);
%OptimizeFunctionOnNextCall(Assign);
Object.defineProperty(C.prototype, "blubb", {get: function() { return -42; }});
Assign(new C);

// Test that changes to the prototype of a simple constructor are not ignored,
// even after creating initial instances.
function C() {
  this.x = 23;
}
assertEquals(23, new C().x);
C.prototype.__defineSetter__('x', function(value) { this.y = 23; });
assertEquals(void 0, new C().x);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/object-freeze-global.js                                            0000664 0000000 0000000 00000000340 14746647661 0023032 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

Object.freeze(this);
assertTrue(Object.isFrozen(this));
                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/object-freeze.js                                                   0000664 0000000 0000000 00000121172 14746647661 0021603 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Tests the Object.freeze and Object.isFrozen methods - ES 19.1.2.5 and
// ES 19.1.2.12

// Flags: --allow-natives-syntax

// Test that we return obj if non-object is passed as argument
var non_objects = new Array(undefined, null, 1, -1, 0, 42.43, Symbol("test"));
for (var key in non_objects) {
  assertSame(non_objects[key], Object.freeze(non_objects[key]));
}

// Test that isFrozen always returns true for non-objects
for (var key in non_objects) {
  assertTrue(Object.isFrozen(non_objects[key]));
}

// Test normal data properties.
var obj = { x: 42, z: 'foobar' };
var desc = Object.getOwnPropertyDescriptor(obj, 'x');
assertTrue(desc.writable);
assertTrue(desc.configurable);
assertEquals(42, desc.value);

desc = Object.getOwnPropertyDescriptor(obj, 'z');
assertTrue(desc.writable);
assertTrue(desc.configurable);
assertEquals('foobar', desc.value);

assertTrue(Object.isExtensible(obj));
assertFalse(Object.isFrozen(obj));

Object.freeze(obj);

// Make sure we are no longer extensible.
assertFalse(Object.isExtensible(obj));
assertTrue(Object.isFrozen(obj));

obj.foo = 42;
assertEquals(obj.foo, undefined);

desc = Object.getOwnPropertyDescriptor(obj, 'x');
assertFalse(desc.writable);
assertFalse(desc.configurable);
assertEquals(42, desc.value);

desc = Object.getOwnPropertyDescriptor(obj, 'z');
assertFalse(desc.writable);
assertFalse(desc.configurable);
assertEquals("foobar", desc.value);

// Make sure that even if we try overwrite a value that is not writable, it is
// not changed.
obj.x = "tete";
assertEquals(42, obj.x);
obj.x = { get: function() {return 43}, set: function() {} };
assertEquals(42, obj.x);

// Test on accessors.
var obj2 = {};
function get() { return 43; };
function set() {};
Object.defineProperty(obj2, 'x', { get: get, set: set, configurable: true });

desc = Object.getOwnPropertyDescriptor(obj2, 'x');
assertTrue(desc.configurable);
assertEquals(undefined, desc.value);
assertEquals(set, desc.set);
assertEquals(get, desc.get);

assertTrue(Object.isExtensible(obj2));
assertFalse(Object.isFrozen(obj2));
Object.freeze(obj2);
assertTrue(Object.isFrozen(obj2));
assertFalse(Object.isExtensible(obj2));

desc = Object.getOwnPropertyDescriptor(obj2, 'x');
assertFalse(desc.configurable);
assertEquals(undefined, desc.value);
assertEquals(set, desc.set);
assertEquals(get, desc.get);

obj2.foo = 42;
assertEquals(obj2.foo, undefined);


// Test freeze on arrays.
var arr = new Array(42,43);

desc = Object.getOwnPropertyDescriptor(arr, '0');
assertTrue(desc.configurable);
assertTrue(desc.writable);
assertEquals(42, desc.value);

desc = Object.getOwnPropertyDescriptor(arr, '1');
assertTrue(desc.configurable);
assertTrue(desc.writable);
assertEquals(43, desc.value);

assertTrue(Object.isExtensible(arr));
assertFalse(Object.isFrozen(arr));
Object.freeze(arr);
assertTrue(Object.isFrozen(arr));
assertFalse(Object.isExtensible(arr));

desc = Object.getOwnPropertyDescriptor(arr, '0');
assertFalse(desc.configurable);
assertFalse(desc.writable);
assertEquals(42, desc.value);

desc = Object.getOwnPropertyDescriptor(arr, '1');
assertFalse(desc.configurable);
assertFalse(desc.writable);
assertEquals(43, desc.value);

arr[0] = 'foo';

assertEquals(arr[0], 42);


// Test that isFrozen return the correct value even if configurable has been set
// to false on all properties manually and the extensible flag has also been set
// to false manually.
var obj3 = { x: 42, y: 'foo' };

assertFalse(Object.isFrozen(obj3));

Object.defineProperty(obj3, 'x', {configurable: false, writable: false});
Object.defineProperty(obj3, 'y', {configurable: false, writable: false});
Object.preventExtensions(obj3);

assertTrue(Object.isFrozen(obj3));


// Make sure that an object that has only non-configurable, but one
// writable property, is not classified as frozen.
var obj4 = {};
Object.defineProperty(obj4, 'x', {configurable: false, writable: true});
Object.defineProperty(obj4, 'y', {configurable: false, writable: false});
Object.preventExtensions(obj4);

assertFalse(Object.isFrozen(obj4));

// Make sure that an object that has only non-writable, but one
// configurable property, is not classified as frozen.
var obj5 = {};
Object.defineProperty(obj5, 'x', {configurable: true, writable: false});
Object.defineProperty(obj5, 'y', {configurable: false, writable: false});
Object.preventExtensions(obj5);

assertFalse(Object.isFrozen(obj5));

// Make sure that Object.freeze returns the frozen object.
var obj6 = {}
assertTrue(obj6 === Object.freeze(obj6))

// Test that the enumerable attribute is unperturbed by freezing.
obj = { x: 42, y: 'foo' };
Object.defineProperty(obj, 'y', {enumerable: false});
Object.freeze(obj);
assertTrue(Object.isFrozen(obj));
desc = Object.getOwnPropertyDescriptor(obj, 'x');
assertTrue(desc.enumerable);
desc = Object.getOwnPropertyDescriptor(obj, 'y');
assertFalse(desc.enumerable);

// Fast properties should remain fast
obj = { x: 42, y: 'foo' };
assertTrue(%HasFastProperties(obj));
Object.freeze(obj);
assertTrue(Object.isFrozen(obj));
assertTrue(%HasFastProperties(obj));

// Frozen objects should share maps where possible
obj = { prop1: 1, prop2: 2 };
obj2 = { prop1: 3, prop2: 4 };
assertTrue(%HaveSameMap(obj, obj2));
Object.freeze(obj);
Object.freeze(obj2);
assertTrue(Object.isFrozen(obj));
assertTrue(Object.isFrozen(obj2));
assertTrue(%HaveSameMap(obj, obj2));

// Frozen objects should share maps even when they have elements
obj = { prop1: 1, prop2: 2, 75: 'foo' };
obj2 = { prop1: 3, prop2: 4, 150: 'bar' };
assertTrue(%HaveSameMap(obj, obj2));
Object.freeze(obj);
Object.freeze(obj2);
assertTrue(Object.isFrozen(obj));
assertTrue(Object.isFrozen(obj2));
assertTrue(%HaveSameMap(obj, obj2));

// Setting elements after freezing should not be allowed
obj = { prop: 'thing' };
Object.freeze(obj);
assertTrue(Object.isFrozen(obj));
obj[0] = 'hello';
assertFalse(obj.hasOwnProperty(0));

// Freezing an object in dictionary mode should work
// Also testing that getter/setter properties work after freezing
obj = { };
for (var i = 0; i < 100; ++i) {
  obj['x' + i] = i;
}
var accessorDidRun = false;
Object.defineProperty(obj, 'accessor', {
  get: function() { return 42 },
  set: function() { accessorDidRun = true },
  configurable: true,
  enumerable: true
});

assertFalse(%HasFastProperties(obj));
Object.freeze(obj);
assertFalse(%HasFastProperties(obj));
assertTrue(Object.isFrozen(obj));
assertFalse(Object.isExtensible(obj));
for (var i = 0; i < 100; ++i) {
  desc = Object.getOwnPropertyDescriptor(obj, 'x' + i);
  assertFalse(desc.writable);
  assertFalse(desc.configurable);
}
assertEquals(42, obj.accessor);
assertFalse(accessorDidRun);
obj.accessor = 'ignored value';
assertTrue(accessorDidRun);

// Freezing arguments should work
var func = function(arg) {
  Object.freeze(arguments);
  assertTrue(Object.isFrozen(arguments));
};
func('hello', 'world');
func('goodbye', 'world');

// Freezing sparse arrays
var sparseArr = [0, 1];
sparseArr[10000] = 10000;
Object.freeze(sparseArr);
assertTrue(Object.isFrozen(sparseArr));

// Accessors on fast object should behavior properly after freezing
obj = {};
Object.defineProperty(obj, 'accessor', {
  get: function() { return 42 },
  set: function() { accessorDidRun = true },
  configurable: true,
  enumerable: true
});
assertTrue(%HasFastProperties(obj));
Object.freeze(obj);
assertTrue(Object.isFrozen(obj));
assertTrue(%HasFastProperties(obj));
assertEquals(42, obj.accessor);
accessorDidRun = false;
obj.accessor = 'ignored value';
assertTrue(accessorDidRun);

// Test for regression in mixed accessor/data property objects.
// The strict function is one such object.
assertTrue(Object.isFrozen(Object.freeze(function(){"use strict";})));

// Also test a simpler case
obj = {};
Object.defineProperty(obj, 'accessor2', {
  get: function() { return 42 },
  set: function() { accessorDidRun = true },
  configurable: true,
  enumerable: true
});
obj.data = 'foo';
assertTrue(%HasFastProperties(obj));
Object.freeze(obj);
assertTrue(%HasFastProperties(obj));
assertTrue(Object.isFrozen(obj));

// Test array built-in functions with freeze.
obj = [1,2,3];
Object.freeze(obj);
// if frozen implies sealed, then the tests in object-seal.js are mostly
// sufficient.
assertTrue(Object.isSealed(obj));

// Verify that the length can't be written by builtins.
assertThrows(function() { obj.push(); }, TypeError);
assertThrows(function() { obj.unshift(); }, TypeError);
assertThrows(function() { obj.splice(0,0); }, TypeError);
assertTrue(Object.isFrozen(obj));

// Verify that an item can't be changed with splice.
assertThrows(function() { obj.splice(0,1,1); }, TypeError);
assertTrue(Object.isFrozen(obj));

// Verify that unshift() with no arguments will fail if it reifies from
// the prototype into the object.
obj = [1,,3];
obj.__proto__[1] = 1;
assertEquals(1, obj[1]);
Object.freeze(obj);
assertThrows(function() { obj.unshift(); }, TypeError);

// Sealing and then Freezing should do the right thing.
var obj = { foo: 'bar', 0: 'element' };
Object.seal(obj);
assertTrue(Object.isSealed(obj));
assertFalse(Object.isFrozen(obj));
Object.freeze(obj);
assertTrue(Object.isSealed(obj));
assertTrue(Object.isFrozen(obj));


(function propertiesOfFrozenObjectNotFrozen() {
  function Frozen() {}
  Object.freeze(Frozen);
  assertDoesNotThrow(function() { return new Frozen(); });
  Frozen.prototype.prototypeExists = true;
  assertTrue((new Frozen()).prototypeExists);
})();


(function frozenPrototypePreventsPUT() {
  // A read-only property on the prototype should prevent a [[Put]] .
  function Constructor() {}
  Constructor.prototype.foo = 1;
  Object.freeze(Constructor.prototype);
  var obj = new Constructor();
  obj.foo = 2;
  assertSame(1, obj.foo);
})();


(function frozenFunctionSloppy() {
  // Check that freezing a function works correctly.
  var func = Object.freeze(function foo(){});
  assertTrue(Object.isFrozen(func));
  func.prototype = 42;
  assertFalse(func.prototype === 42);
  assertFalse(Object.getOwnPropertyDescriptor(func, "prototype").writable);
})();


(function frozenFunctionStrict() {
  // Check that freezing a strict function works correctly.
  var func = Object.freeze(function foo(){ "use strict"; });
  assertTrue(Object.isFrozen(func));
  func.prototype = 42;
  assertFalse(func.prototype === 42);
  assertFalse(Object.getOwnPropertyDescriptor(func, "prototype").writable);
})();


(function frozenArrayObject() {
  // Check that freezing array objects works correctly.
  var array = Object.freeze([0,1,2]);
  assertTrue(Object.isFrozen(array));
  array[0] = 3;
  assertEquals(0, array[0]);
  assertFalse(Object.getOwnPropertyDescriptor(array, "length").writable);
})();


(function frozenArgumentsObject() {
  // Check that freezing arguments objects works correctly.
  var args = Object.freeze((function(){ return arguments; })(0,1,2));
  assertTrue(Object.isFrozen(args));
  args[0] = 3;
  assertEquals(0, args[0]);
  assertFalse(Object.getOwnPropertyDescriptor(args, "length").writable);
  assertFalse(Object.getOwnPropertyDescriptor(args, "callee").writable);
})();

// Test packed element array built-in functions with freeze.
function testPackedFrozenArray1(obj) {
  assertTrue(Object.isSealed(obj));
  // Verify that the value can't be written
  obj1 = new Array(...obj);
  var length = obj.length;
  for (var i = 0; i < length-1; i++) {
    obj[i] = 'new';
    assertEquals(obj1[i], obj[i]);
  }
  // for symbol we cannot compare directly
  assertTrue(typeof obj[length-1] == 'symbol');

  // Verify that the length can't be written by builtins.
  assertTrue(Array.isArray(obj));
  assertThrows(function() { obj.pop(); }, TypeError);
  assertThrows(function() { obj.push(); }, TypeError);
  assertThrows(function() { obj.shift(); }, TypeError);
  assertThrows(function() { obj.unshift(); }, TypeError);
  assertThrows(function() { obj.copyWithin(0,0); }, TypeError);
  assertThrows(function() { obj.fill(0); }, TypeError);
  assertThrows(function() { obj.reverse(); }, TypeError);
  assertThrows(function() { obj.sort(); }, TypeError);
  assertThrows(function() { obj.splice(0); }, TypeError);
  assertThrows(function() { obj.splice(0, 0); }, TypeError);
  assertTrue(Object.isFrozen(obj));

  // Verify search, filter, iterator
  assertEquals(obj.lastIndexOf(1), 2);
  assertEquals(obj.indexOf('a'), 4);
  assertEquals(obj.indexOf(undefined), 0);
  assertFalse(obj.includes(Symbol("test")));
  assertTrue(obj.includes(undefined));
  assertFalse(obj.includes(NaN));
  assertTrue(obj.includes());
  assertEquals(obj.find(x => x==0), undefined);
  assertEquals(obj.findIndex(x => x=='a'), 4);
  assertTrue(obj.some(x => typeof x == 'symbol'));
  assertFalse(obj.every(x => x == -1));
  var filteredArray = obj.filter(e => typeof e == "symbol");
  assertEquals(filteredArray.length, 1);
  assertEquals(obj.map(x => x), obj);
  var countPositiveNumber = 0;
  obj.forEach(function(item, index) {
    if (item === 1) {
      countPositiveNumber++;
      assertEquals(index, 2);
    }
  });
  assertEquals(countPositiveNumber, 1);
  assertEquals(obj.length, obj.concat([]).length);
  var iterator = obj.values();
  assertEquals(iterator.next().value, undefined);
  assertEquals(iterator.next().value, null);
  var iterator = obj.keys();
  assertEquals(iterator.next().value, 0);
  assertEquals(iterator.next().value, 1);
  var iterator = obj.entries();
  assertEquals(iterator.next().value, [0, undefined]);
  assertEquals(iterator.next().value, [1, null]);
}

obj = new Array(undefined, null, 1, -1, 'a', Symbol("test"));
assertTrue(%HasPackedElements(obj));
Object.freeze(obj);
testPackedFrozenArray1(obj);

// Verify change from sealed to frozen
obj = new Array(undefined, null, 1, -1, 'a', Symbol("test"));
assertTrue(%HasPackedElements(obj));
Object.seal(obj);
Object.freeze(obj);
assertTrue(Object.isSealed(obj));
testPackedFrozenArray1(obj);

// Verify change from non-extensible to frozen
obj = new Array(undefined, null, 1, -1, 'a', Symbol("test"));
assertTrue(%HasPackedElements(obj));
Object.preventExtensions(obj);
Object.freeze(obj);
assertTrue(Object.isSealed(obj));
testPackedFrozenArray1(obj);

// Verify flat, map, slice, flatMap, join, reduce, reduceRight for frozen packed array
function testPackedFrozenArray2(arr) {
  assertTrue(Object.isFrozen(arr));
  assertTrue(Array.isArray(arr));
  assertEquals(arr.map(x => [x]), [['a'], ['b'], ['c']]);
  assertEquals(arr.flatMap(x => [x]), arr);
  assertEquals(arr.flat(), arr);
  assertEquals(arr.join('-'), "a-b-c");
  const reducer = (accumulator, currentValue) => accumulator + currentValue;
  assertEquals(arr.reduce(reducer), "abc");
  assertEquals(arr.reduceRight(reducer), "cba");
  assertEquals(arr.slice(0, 1), ['a']);
}
var arr1 = new Array('a', 'b', 'c');
assertTrue(%HasPackedElements(arr1));
Object.freeze(arr1);
testPackedFrozenArray2(arr1);

// Verify change from sealed to frozen
var arr2 = new Array('a', 'b', 'c');
assertTrue(%HasPackedElements(arr2));
Object.seal(arr2);
Object.freeze(arr2);
testPackedFrozenArray2(arr2);

// Verify change from non-extensible to frozen
var arr2 = new Array('a', 'b', 'c');
assertTrue(%HasPackedElements(arr2));
Object.preventExtensions(arr2);
Object.freeze(arr2);
testPackedFrozenArray2(arr2);

// Verify that repeatedly attemping to freeze a typed array fails
var typedArray = new Uint8Array(10);
assertThrows(() => { Object.freeze(typedArray); }, TypeError);
assertFalse(Object.isFrozen(typedArray));
assertThrows(() => { Object.freeze(typedArray); }, TypeError);
assertFalse(Object.isFrozen(typedArray));

// Verify that freezing an empty typed array works
var typedArray = new Uint8Array(0);
Object.freeze(typedArray);
assertTrue(Object.isFrozen(typedArray));

// Test regression with Object.defineProperty
var obj = [];
obj.propertyA = 42;
obj[0] = true;
Object.freeze(obj);
assertThrows(function() {
  Object.defineProperty(obj, 'propertyA', {
    value: obj,
  });
}, TypeError);
assertEquals(42, obj.propertyA);
assertThrows(function() {
  Object.defineProperty(obj, 'propertyA', {
    value: obj,
    writable: false,
  });
}, TypeError);
assertDoesNotThrow(function() {obj.propertyA = 2;});
assertEquals(obj.propertyA, 42);
assertThrows(function() {
  Object.defineProperty(obj, 'abc', {
    value: obj,
  });
}, TypeError);

// Regression test with simple array
var arr = ['a'];
Object.freeze(arr);
arr[0] = 'b';
assertEquals(arr[0], 'a');

// Test regression Array.concat with double
var arr = ['a'];
Object.freeze(arr);
arr = arr.concat(0.5);
assertEquals(arr, ['a', 0.5]);
Object.freeze(arr);
arr = arr.concat([1.5, 'b']);
assertEquals(arr, ['a', 0.5, 1.5, 'b']);

// Regression test with change length
var arr = ['a', 'b'];
Object.freeze(arr);
assertEquals(arr.length, 2);
arr.length = 3;
assertEquals(arr.length, 2);
arr[2] = 'c';
assertEquals(arr[2], undefined);
arr.length = 1;
assertEquals(arr.length, 2);

// Start testing with holey array
// Test holey element array built-in functions with freeze.
function testHoleyFrozenArray1(obj) {
  assertTrue(Object.isSealed(obj));
  // Verify that the value can't be written
  obj1 = new Array(...obj);
  var length = obj.length;
  for (var i = 0; i < length-1; i++) {
    obj[i] = 'new';
    assertEquals(obj1[i], obj[i]);
  }
  // for symbol we cannot compare directly
  assertTrue(typeof obj[length-1] == 'symbol');

  // Verify that the length can't be written by builtins.
  assertTrue(Array.isArray(obj));
  assertThrows(function() { obj.pop(); }, TypeError);
  assertThrows(function() { obj.push(); }, TypeError);
  assertThrows(function() { obj.shift(); }, TypeError);
  assertThrows(function() { obj.unshift(); }, TypeError);
  assertThrows(function() { obj.copyWithin(0,0); }, TypeError);
  assertThrows(function() { obj.fill(0); }, TypeError);
  assertThrows(function() { obj.reverse(); }, TypeError);
  assertThrows(function() { obj.sort(); }, TypeError);
  assertThrows(function() { obj.splice(0); }, TypeError);
  assertThrows(function() { obj.splice(0, 0); }, TypeError);
  assertTrue(Object.isFrozen(obj));

  // Verify search, filter, iterator
  assertEquals(obj.lastIndexOf(1), 2);
  assertEquals(obj.indexOf('a'), 5);
  assertEquals(obj.indexOf(undefined), 0);
  assertFalse(obj.includes(Symbol("test")));
  assertTrue(obj.includes(undefined));
  assertFalse(obj.includes(NaN));
  assertTrue(obj.includes());
  assertEquals(obj.find(x => x==0), undefined);
  assertEquals(obj.findIndex(x => x=='a'), 5);
  assertTrue(obj.some(x => typeof x == 'symbol'));
  assertFalse(obj.every(x => x == -1));
  var filteredArray = obj.filter(e => typeof e == "symbol");
  assertEquals(filteredArray.length, 1);
  assertEquals(obj.map(x => x), obj);
  var countPositiveNumber = 0;
  obj.forEach(function(item, index) {
    if (item === 1) {
      countPositiveNumber++;
      assertEquals(index, 2);
    }
  });
  assertEquals(countPositiveNumber, 1);
  assertEquals(obj.length, obj.concat([]).length);
  var iterator = obj.values();
  assertEquals(iterator.next().value, undefined);
  assertEquals(iterator.next().value, null);
  var iterator = obj.keys();
  assertEquals(iterator.next().value, 0);
  assertEquals(iterator.next().value, 1);
  var iterator = obj.entries();
  assertEquals(iterator.next().value, [0, undefined]);
  assertEquals(iterator.next().value, [1, null]);
}

obj = [undefined, null, 1, , -1, 'a', Symbol("test")];
assertTrue(%HasHoleyElements(obj));
Object.freeze(obj);
testHoleyFrozenArray1(obj);

// Verify change from sealed to frozen
obj = [undefined, null, 1, , -1, 'a', Symbol("test")];
assertTrue(%HasHoleyElements(obj));
Object.seal(obj);
Object.freeze(obj);
assertTrue(Object.isSealed(obj));
testHoleyFrozenArray1(obj);

// Verify change from non-extensible to frozen
obj = [undefined, null, 1, ,-1, 'a', Symbol("test")];
assertTrue(%HasHoleyElements(obj));
Object.preventExtensions(obj);
Object.freeze(obj);
assertTrue(Object.isSealed(obj));
testHoleyFrozenArray1(obj);

// Verify flat, map, slice, flatMap, join, reduce, reduceRight for frozen packed array
function testHoleyFrozenArray2(arr) {
  assertTrue(Object.isFrozen(arr));
  assertTrue(Array.isArray(arr));
  assertEquals(arr.map(x => [x]), [, ['a'], ['b'], ['c']]);
  assertEquals(arr.flatMap(x => [x]), ["a", "b", "c"]);
  assertEquals(arr.flat(), ["a", "b", "c"]);
  assertEquals(arr.join('-'), "-a-b-c");
  const reducer = (accumulator, currentValue) => accumulator + currentValue;
  assertEquals(arr.reduce(reducer), "abc");
  assertEquals(arr.reduceRight(reducer), "cba");
  assertEquals(arr.slice(0, 1), [,]);
  assertEquals(arr.slice(1, 2), ["a"]);
}
var arr1 = [, 'a', 'b', 'c'];
assertTrue(%HasHoleyElements(arr1));
Object.freeze(arr1);
testHoleyFrozenArray2(arr1);

// Verify change from sealed to frozen
var arr2 = [, 'a', 'b', 'c'];
assertTrue(%HasHoleyElements(arr2));
Object.seal(arr2);
Object.freeze(arr2);
testHoleyFrozenArray2(arr2);

// Verify change from non-extensible to frozen
var arr2 = [, 'a', 'b', 'c'];
assertTrue(%HasHoleyElements(arr2));
Object.preventExtensions(arr2);
Object.freeze(arr2);
testHoleyFrozenArray2(arr2);

// Test regression with Object.defineProperty
var obj = ['a', , 'b'];
obj.propertyA = 42;
obj[0] = true;
Object.freeze(obj);
assertThrows(function() {
  Object.defineProperty(obj, 'propertyA', {
    value: obj,
  });
}, TypeError);
assertEquals(42, obj.propertyA);
assertThrows(function() {
  Object.defineProperty(obj, 'propertyA', {
    value: obj,
    writable: false,
  });
}, TypeError);
assertDoesNotThrow(function() {obj.propertyA = 2;});
assertEquals(obj.propertyA, 42);
assertThrows(function() {
  Object.defineProperty(obj, 'abc', {
    value: obj,
  });
}, TypeError);

// Regression test with simple holey array
var arr = [, 'a'];
Object.freeze(arr);
arr[1] = 'b';
assertEquals(arr[1], 'a');
arr[0] = 1;
assertEquals(arr[0], undefined);

// Test regression Array.concat with double
var arr = ['a', , 'b'];
Object.freeze(arr);
arr = arr.concat(0.5);
assertEquals(arr, ['a', ,'b', 0.5]);
Object.freeze(arr);
arr = arr.concat([1.5, 'c']);
assertEquals(arr, ['a', ,'b', 0.5, 1.5, 'c']);

// Regression test with change length
var arr = ['a', ,'b'];
Object.freeze(arr);
assertEquals(arr.length, 3);
arr.length = 4;
assertEquals(arr.length, 3);
arr[3] = 'c';
assertEquals(arr[2], 'b');
assertEquals(arr[3], undefined);
arr.length = 2;
assertEquals(arr.length, 3);

// Change length with holey entries at the end
var arr = ['a', ,];
Object.freeze(arr);
assertEquals(arr.length, 2);
arr.length = 0;
assertEquals(arr.length, 2);
arr.length = 3;
assertEquals(arr.length, 2);
arr.length = 0;
assertEquals(arr.length, 2);

// Spread with array
var arr = ['a', 'b', 'c'];
Object.freeze(arr);
var arrSpread = [...arr];
assertEquals(arrSpread.length, arr.length);
assertEquals(arrSpread[0], 'a');
assertEquals(arrSpread[1], 'b');
assertEquals(arrSpread[2], 'c');

// Spread with array-like
function returnArgs() {
  return Object.freeze(arguments);
}
var arrLike = returnArgs('a', 'b', 'c');
assertTrue(Object.isFrozen(arrLike));
var arrSpread = [...arrLike];
assertEquals(arrSpread.length, arrLike.length);
assertEquals(arrSpread[0], 'a');
assertEquals(arrSpread[1], 'b');
assertEquals(arrSpread[2], 'c');

// Spread with holey
function countArgs() {
  return arguments.length;
}
var arr = [, 'b','c'];
Object.freeze(arr);
assertEquals(countArgs(...arr), 3);
assertEquals(countArgs(...[...arr]), 3);
assertEquals(countArgs.apply(this, [...arr]), 3);
function checkUndefined() {
  return arguments[0] === undefined;
}
assertTrue(checkUndefined(...arr));
assertTrue(checkUndefined(...[...arr]));
assertTrue(checkUndefined.apply(this, [...arr]));

//
// Array.prototype.map
//
(function() {
  var a = Object.freeze(['0','1','2','3','4']);

  // Simple use.
  var result = [1,2,3,4,5];
  assertArrayEquals(result, a.map(function(n) { return Number(n) + 1; }));

  // Use specified object as this object when calling the function.
  var o = { delta: 42 }
  result = [42,43,44,45,46];
  assertArrayEquals(result, a.map(function(n) { return this.delta + Number(n); }, o));

  // Modify original array.
  b = Object.freeze(['0','1','2','3','4']);
  result = [1,2,3,4,5];
  assertArrayEquals(result,
      b.map(function(n, index, array) {
        array[index] = Number(n) + 1; return Number(n) + 1;
      }));
  assertArrayEquals(b, a);

  // Only loop through initial part of array and elements are not
  // added.
  a = Object.freeze(['0','1','2','3','4']);
  result = [1,2,3,4,5];
  assertArrayEquals(result,
      a.map(function(n, index, array) { assertThrows(() => { array.push(n) }); return Number(n) + 1; }));
  assertArrayEquals(['0','1','2','3','4'], a);

  // Respect holes.
  a = new Array(20);
  a[1] = '2';
  Object.freeze(a);
  a = Object.freeze(a).map(function(n) { return 2*Number(n); });

  for (var i in a) {
    assertEquals(4, a[i]);
    assertEquals('1', i);
  }

  // Skip over missing properties.
  a = {
    "0": 1,
    "2": 2,
    length: 3
  };
  var received = [];
  assertArrayEquals([2, , 4],
      Array.prototype.map.call(Object.freeze(a), function(n) {
        received.push(n);
        return n * 2;
      }));
  assertArrayEquals([1, 2], received);

  // Modify array prototype
  a = ['1', , 2];
  received = [];
  assertThrows(() => {
    Array.prototype.map.call(Object.freeze(a), function(n) {
      a.__proto__ = null;
      received.push(n);
      return n * 2;
    });
  }, TypeError);
  assertArrayEquals([], received);

  // Create a new object in each function call when receiver is a
  // primitive value. See ECMA-262, Annex C.
  a = [];
  Object.freeze(['1', '2']).map(function() { a.push(this) }, "");
  assertTrue(a[0] !== a[1]);

  // Do not create a new object otherwise.
  a = [];
  Object.freeze(['1', '2']).map(function() { a.push(this) }, {});
  assertSame(a[0], a[1]);

  // In strict mode primitive values should not be coerced to an object.
  a = [];
  Object.freeze(['1', '2']).map(function() { 'use strict'; a.push(this); }, "");
  assertEquals("", a[0]);
  assertEquals(a[0], a[1]);

})();

// Test with double elements
// Test packed element array built-in functions with freeze.
function testDoubleFrozenArray1(obj) {
  assertTrue(Object.isSealed(obj));
  // Verify that the value can't be written
  obj1 = new Array(...obj);
  var length = obj.length;
  for (var i = 0; i < length-1; i++) {
    obj[i] = 'new';
    assertEquals(obj1[i], obj[i]);
  }
  // Verify that the length can't be written by builtins.
  assertTrue(Array.isArray(obj));
  assertThrows(function() { obj.pop(); }, TypeError);
  assertThrows(function() { obj.push(); }, TypeError);
  assertThrows(function() { obj.shift(); }, TypeError);
  assertThrows(function() { obj.unshift(); }, TypeError);
  assertThrows(function() { obj.copyWithin(0,0); }, TypeError);
  assertThrows(function() { obj.fill(0); }, TypeError);
  assertThrows(function() { obj.reverse(); }, TypeError);
  assertThrows(function() { obj.sort(); }, TypeError);
  assertThrows(function() { obj.splice(0); }, TypeError);
  assertThrows(function() { obj.splice(0, 0); }, TypeError);
  assertTrue(Object.isFrozen(obj));

  // Verify search, filter, iterator
  assertEquals(obj.lastIndexOf(1), 2);
  assertEquals(obj.indexOf(undefined), -1);
  assertFalse(obj.includes(Symbol("test")));
  assertTrue(obj.includes(1));
  assertTrue(obj.includes(-1.1));
  assertFalse(obj.includes());
  assertEquals(obj.find(x => x==0), undefined);
  assertEquals(obj.findIndex(x => x==2), 4);
  assertFalse(obj.some(x => typeof x == 'symbol'));
  assertFalse(obj.every(x => x == -1));
  var filteredArray = obj.filter(e => typeof e == "symbol");
  assertEquals(filteredArray.length, 0);
  assertEquals(obj.map(x => x), obj);
  var countPositiveNumber = 0;
  obj.forEach(function(item, index) {
    if (item === 1) {
      countPositiveNumber++;
      assertEquals(index, 2);
    }
  });
  assertEquals(countPositiveNumber, 1);
  assertEquals(obj.length, obj.concat([]).length);
  var iterator = obj.values();
  assertEquals(iterator.next().value, 1.1);
  assertEquals(iterator.next().value, -1.1);
  var iterator = obj.keys();
  assertEquals(iterator.next().value, 0);
  assertEquals(iterator.next().value, 1);
  var iterator = obj.entries();
  assertEquals(iterator.next().value, [0, 1.1]);
  assertEquals(iterator.next().value, [1, -1.1]);
}

obj = new Array(1.1, -1.1, 1, -1, 2);
assertTrue(%HasDoubleElements(obj));
Object.freeze(obj);
testDoubleFrozenArray1(obj);

// Verify change from sealed to frozen
obj = new Array(1.1, -1.1, 1, -1, 2);
assertTrue(%HasDoubleElements(obj));
Object.seal(obj);
Object.freeze(obj);
assertTrue(Object.isSealed(obj));
testDoubleFrozenArray1(obj);

// Verify change from non-extensible to frozen
obj = new Array(1.1, -1.1, 1, -1, 2);
assertTrue(%HasDoubleElements(obj));
Object.preventExtensions(obj);
Object.freeze(obj);
assertTrue(Object.isSealed(obj));
testDoubleFrozenArray1(obj);

// Verify flat, map, slice, flatMap, join, reduce, reduceRight for frozen packed array
function testDoubleFrozenArray2(arr) {
  assertTrue(Object.isFrozen(arr));
  assertTrue(Array.isArray(arr));
  assertEquals(arr.map(x => [x]), [[1], [1.1], [0]]);
  assertEquals(arr.flatMap(x => [x]), arr);
  assertEquals(arr.flat(), arr);
  assertEquals(arr.join('-'), "1-1.1-0");
  const reducer = (accumulator, currentValue) => accumulator + currentValue;
  assertEquals(arr.reduce(reducer), 2.1);
  assertEquals(arr.reduceRight(reducer), 2.1);
  assertEquals(arr.slice(0, 1), [1]);
}
var arr1 = new Array(1, 1.1, 0);
assertTrue(%HasDoubleElements(arr1));
Object.freeze(arr1);
testDoubleFrozenArray2(arr1);

// Verify change from sealed to frozen
var arr1 = new Array(1, 1.1, 0);
assertTrue(%HasDoubleElements(arr1));
Object.seal(arr1);
Object.freeze(arr1);
testDoubleFrozenArray2(arr1);


// Verify change from non-extensible to frozen
var arr1 = new Array(1, 1.1, 0);
assertTrue(%HasDoubleElements(arr1));
Object.preventExtensions(arr1);
Object.freeze(arr1);
testDoubleFrozenArray2(arr1);

// Test regression with Object.defineProperty
var obj = [];
obj.propertyA = 42;
obj[0] = 1.1;
Object.freeze(obj);
assertThrows(function() {
  Object.defineProperty(obj, 'propertyA', {
    value: obj,
  });
}, TypeError);
assertEquals(42, obj.propertyA);
assertThrows(function() {
  Object.defineProperty(obj, 'propertyA', {
    value: obj,
    writable: false,
  });
}, TypeError);
assertDoesNotThrow(function() {obj.propertyA = 2;});
assertEquals(obj.propertyA, 42);
assertThrows(function() {
  Object.defineProperty(obj, 'abc', {
    value: obj,
  });
}, TypeError);

// Regression test with simple array
var arr = [1.1];
Object.freeze(arr);
arr[0] = 1;
assertEquals(arr[0], 1.1);

// Test regression Array.concat with double
var arr = [1.1];
Object.freeze(arr);
arr = arr.concat(0.5);
assertEquals(arr, [1.1, 0.5]);
Object.freeze(arr);
arr = arr.concat([1.5, 'b']);
assertEquals(arr, [1.1, 0.5, 1.5, 'b']);

// Regression test with change length
var arr = [1.1, 0];
Object.freeze(arr);
assertEquals(arr.length, 2);
arr.length = 3;
assertEquals(arr.length, 2);
arr[2] = 'c';
assertEquals(arr[2], undefined);
arr.length = 1;
assertEquals(arr.length, 2);

// Start testing with holey array
// Test holey element array built-in functions with freeze.
function testHoleyDoubleFrozenArray1(obj) {
  assertTrue(Object.isSealed(obj));
  // Verify that the value can't be written
  obj1 = new Array(...obj);
  var length = obj.length;
  for (var i = 0; i < length-1; i++) {
    obj[i] = 'new';
    assertEquals(obj1[i], obj[i]);
  }

  // Verify that the length can't be written by builtins.
  assertTrue(Array.isArray(obj));
  assertThrows(function() { obj.pop(); }, TypeError);
  assertThrows(function() { obj.push(); }, TypeError);
  assertThrows(function() { obj.shift(); }, TypeError);
  assertThrows(function() { obj.unshift(); }, TypeError);
  assertThrows(function() { obj.copyWithin(0,0); }, TypeError);
  assertThrows(function() { obj.fill(0); }, TypeError);
  assertThrows(function() { obj.reverse(); }, TypeError);
  assertThrows(function() { obj.sort(); }, TypeError);
  assertThrows(function() { obj.splice(0); }, TypeError);
  assertThrows(function() { obj.splice(0, 0); }, TypeError);
  assertTrue(Object.isFrozen(obj));

  // Verify search, filter, iterator
  assertEquals(obj.lastIndexOf(1), 2);
  assertEquals(obj.indexOf(1.1), 5);
  assertEquals(obj.indexOf(undefined), -1);
  assertFalse(obj.includes(Symbol("test")));
  assertTrue(obj.includes(undefined));
  assertFalse(obj.includes(NaN));
  assertTrue(obj.includes());
  assertEquals(obj.find(x => x==2), undefined);
  assertEquals(obj.findIndex(x => x==1.1), 5);
  assertFalse(obj.some(x => typeof x == 'symbol'));
  assertFalse(obj.every(x => x == -1));
  var filteredArray = obj.filter(e => typeof e == "symbol");
  assertEquals(filteredArray.length, 0);
  assertEquals(obj.map(x => x), obj);
  var countPositiveNumber = 0;
  obj.forEach(function(item, index) {
    if (item === 1) {
      countPositiveNumber++;
      assertEquals(index, 2);
    }
  });
  assertEquals(countPositiveNumber, 1);
  assertEquals(obj.length, obj.concat([]).length);
  var iterator = obj.values();
  assertEquals(iterator.next().value, -1.1);
  assertEquals(iterator.next().value, 0);
  var iterator = obj.keys();
  assertEquals(iterator.next().value, 0);
  assertEquals(iterator.next().value, 1);
  var iterator = obj.entries();
  assertEquals(iterator.next().value, [0, -1.1]);
  assertEquals(iterator.next().value, [1, 0]);
}

obj = [-1.1, 0, 1, , -1, 1.1];
assertTrue(%HasHoleyElements(obj));
Object.freeze(obj);
testHoleyDoubleFrozenArray1(obj);

// Verify change from sealed to frozen
obj = [-1.1, 0, 1, , -1, 1.1];
assertTrue(%HasHoleyElements(obj));
Object.seal(obj);
Object.freeze(obj);
assertTrue(Object.isSealed(obj));
testHoleyDoubleFrozenArray1(obj);

// Verify change from non-extensible to frozen
obj = [-1.1, 0, 1, , -1, 1.1];
assertTrue(%HasHoleyElements(obj));
Object.preventExtensions(obj);
Object.freeze(obj);
assertTrue(Object.isSealed(obj));
testHoleyDoubleFrozenArray1(obj);

// Verify flat, map, slice, flatMap, join, reduce, reduceRight for frozen packed array
function testHoleyDoubleFrozenArray2(arr) {
  assertTrue(Object.isFrozen(arr));
  assertTrue(Array.isArray(arr));
  assertEquals(arr.map(x => [x]), [, [1.1], [1], [0]]);
  assertEquals(arr.flatMap(x => [x]), [1.1, 1, 0]);
  assertEquals(arr.flat(), [1.1, 1, 0]);
  assertEquals(arr.join('-'), "-1.1-1-0");
  const reducer = (accumulator, currentValue) => accumulator + currentValue;
  assertEquals(arr.reduce(reducer), 2.1);
  assertEquals(arr.reduceRight(reducer), 2.1);
  assertEquals(arr.slice(0, 1), [,]);
  assertEquals(arr.slice(1, 2), [1.1]);
}
var arr1 = [, 1.1, 1, 0];
assertTrue(%HasHoleyElements(arr1));
Object.preventExtensions(arr1);
Object.freeze(arr1);
testHoleyDoubleFrozenArray2(arr1);

// Verify change from sealed to frozen
var arr1 = [, 1.1, 1, 0];
assertTrue(%HasHoleyElements(arr1));
Object.seal(arr1);
Object.freeze(arr1);
testHoleyDoubleFrozenArray2(arr1);

// Verify change from non-extensible to frozen
var arr1 = [, 1.1, 1, 0];
assertTrue(%HasHoleyElements(arr1));
Object.preventExtensions(arr1);
Object.freeze(arr1);
testHoleyDoubleFrozenArray2(arr1);

// Test regression with Object.defineProperty
var obj = [1.1, , 0];
obj.propertyA = 42;
obj[0] = true;
Object.freeze(obj);
assertThrows(function() {
  Object.defineProperty(obj, 'propertyA', {
    value: obj,
  });
}, TypeError);
assertEquals(42, obj.propertyA);
assertThrows(function() {
  Object.defineProperty(obj, 'propertyA', {
    value: obj,
    writable: false,
  });
}, TypeError);
assertDoesNotThrow(function() {obj.propertyA = 2;});
assertEquals(obj.propertyA, 42);
assertThrows(function() {
  Object.defineProperty(obj, 'abc', {
    value: obj,
  });
}, TypeError);

// Regression test with simple holey array
var arr = [, 1.1];
Object.freeze(arr);
arr[1] = 'b';
assertEquals(arr[1], 1.1);
arr[0] = 1;
assertEquals(arr[0], undefined);

// Test regression Array.concat with double
var arr = [1.1, , 0];
Object.freeze(arr);
arr = arr.concat(0.5);
assertEquals(arr, [1.1, , 0, 0.5]);
Object.freeze(arr);
arr = arr.concat([1.5, 'c']);
assertEquals(arr, [1.1, ,0, 0.5, 1.5, 'c']);

// Regression test with change length
var arr = [1.1, ,0];
Object.freeze(arr);
assertEquals(arr.length, 3);
arr.length = 4;
assertEquals(arr.length, 3);
arr[3] = 'c';
assertEquals(arr[2], 0);
assertEquals(arr[3], undefined);
arr.length = 2;
assertEquals(arr.length, 3);

// Change length with holey entries at the end
var arr = [1.1, ,];
Object.freeze(arr);
assertEquals(arr.length, 2);
arr.length = 0;
assertEquals(arr.length, 2);
arr.length = 3;
assertEquals(arr.length, 2);
arr.length = 0;
assertEquals(arr.length, 2);

// Spread with array
var arr = [1.1, 0, -1];
Object.freeze(arr);
var arrSpread = [...arr];
assertEquals(arrSpread.length, arr.length);
assertEquals(arrSpread[0], 1.1);
assertEquals(arrSpread[1], 0);
assertEquals(arrSpread[2], -1);

// Spread with array-like
function returnArgs() {
  return Object.freeze(arguments);
}
var arrLike = returnArgs(1.1, 0, -1);
assertTrue(Object.isFrozen(arrLike));
var arrSpread = [...arrLike];
assertEquals(arrSpread.length, arrLike.length);
assertEquals(arrSpread[0], 1.1);
assertEquals(arrSpread[1], 0);
assertEquals(arrSpread[2], -1);

// Spread with holey
function countArgs() {
  return arguments.length;
}
var arr = [, 1.1, 0];
Object.freeze(arr);
assertEquals(countArgs(...arr), 3);
assertEquals(countArgs(...[...arr]), 3);
assertEquals(countArgs.apply(this, [...arr]), 3);
function checkUndefined() {
  return arguments[0] === undefined;
}
assertTrue(checkUndefined(...arr));
assertTrue(checkUndefined(...[...arr]));
assertTrue(checkUndefined.apply(this, [...arr]));

//
// Array.prototype.map
//
(function() {
  var a = Object.freeze([0.1,1,2,3,4]);

  // Simple use.
  var result = [1.1,2,3,4,5];
  assertArrayEquals(result, a.map(function(n) { return Number(n) + 1; }));

  // Use specified object as this object when calling the function.
  var o = { delta: 42 }
  result = [42.1,43,44,45,46];
  assertArrayEquals(result, a.map(function(n) { return this.delta + Number(n); }, o));

  // Modify original array.
  b = Object.freeze([0.1,1,2,3,4]);
  result = [1.1,2,3,4,5];
  assertArrayEquals(result,
      b.map(function(n, index, array) {
        array[index] = Number(n) + 1; return Number(n) + 1;
      }));
  assertArrayEquals(b, a);

  // Only loop through initial part of array and elements are not
  // added.
  a = Object.freeze([0.1,1,2,3,4]);
  result = [1.1,2,3,4,5];
  assertArrayEquals(result,
      a.map(function(n, index, array) { assertThrows(() => { array.push(n) }); return Number(n) + 1; }));
  assertArrayEquals([0.1,1,2,3,4], a);

  // Respect holes.
  a = new Array(20);
  a[1] = 1.1;
  Object.freeze(a);
  a = Object.freeze(a).map(function(n) { return 2*Number(n); });

  for (var i in a) {
    assertEquals(2.2, a[i]);
    assertEquals('1', i);
  }

  // Skip over missing properties.
  a = {
    "0": 1.1,
    "2": 2,
    length: 3
  };
  var received = [];
  assertArrayEquals([2.2, , 4],
      Array.prototype.map.call(Object.freeze(a), function(n) {
        received.push(n);
        return n * 2;
      }));
  assertArrayEquals([1.1, 2], received);

  // Modify array prototype
  a = [1.1, , 2];
  received = [];
  assertThrows(() => {
    Array.prototype.map.call(Object.freeze(a), function(n) {
      a.__proto__ = null;
      received.push(n);
      return n * 2;
    });
  }, TypeError);
  assertArrayEquals([], received);

  // Create a new object in each function call when receiver is a
  // primitive value. See ECMA-262, Annex C.
  a = [];
  Object.freeze([1.1, 2]).map(function() { a.push(this) }, "");
  assertTrue(a[0] !== a[1]);

  // Do not create a new object otherwise.
  a = [];
  Object.freeze([1.1, 2]).map(function() { a.push(this) }, {});
  assertSame(a[0], a[1]);

  // In strict mode primitive values should not be coerced to an object.
  a = [];
  Object.freeze([1.1, 1.2]).map(function() { 'use strict'; a.push(this); }, "");
  assertEquals("", a[0]);
  assertEquals(a[0], a[1]);

})();
                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/object-get-own-property-names.js                                   0000664 0000000 0000000 00000010476 14746647661 0024672 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Test ES5 section 15.2.3.4 Object.getOwnPropertyNames.

// Check simple cases.
var obj = {};
assertEquals(0, Object.getOwnPropertyNames(obj).length);

var obj = { a: 1, b: 2};
var propertyNames = Object.getOwnPropertyNames(obj);
propertyNames.sort();
assertEquals(2, propertyNames.length);
assertEquals("a", propertyNames[0]);
assertEquals("b", propertyNames[1]);

var obj = { a: function(){}, b: function(){} };
var propertyNames = Object.getOwnPropertyNames(obj);
propertyNames.sort();
assertEquals(2, propertyNames.length);
assertEquals("a", propertyNames[0]);
assertEquals("b", propertyNames[1]);

// Check slow case
var obj = { a: 1, b: 2, c: 3 };
delete obj.b;
var propertyNames = Object.getOwnPropertyNames(obj)
propertyNames.sort();
assertEquals(2, propertyNames.length);
assertEquals("a", propertyNames[0]);
assertEquals("c", propertyNames[1]);

// Check that non-enumerable properties are being returned.
var obj = {};
Object.defineProperty(obj, 'x', {
  value: 1,
  enumerable: false
});
assertEquals(1, Object.getOwnPropertyNames(obj).length);

var propertyNames = Object.getOwnPropertyNames([1, 2]);
propertyNames.sort();
assertEquals(3, propertyNames.length);
assertEquals("0", propertyNames[0]);
assertEquals("1", propertyNames[1]);
assertEquals("string", typeof propertyNames[0]);
assertEquals("string", typeof propertyNames[1]);
assertEquals("length", propertyNames[2]);

// Check that no proto properties are returned.
var obj = { foo: "foo" };
obj.__proto__ = { bar: "bar" };
propertyNames = Object.getOwnPropertyNames(obj);
propertyNames.sort();
assertEquals(1, propertyNames.length);
assertEquals("foo", propertyNames[0]);

// Check that getter properties are returned.
var obj = {};
obj.__defineGetter__("getter", function() {});
propertyNames = Object.getOwnPropertyNames(obj);
propertyNames.sort();
assertEquals(1, propertyNames.length);
assertEquals("getter", propertyNames[0]);

// Check that implementation does not access Array.prototype.
var savedConcat = Array.prototype.concat;
Array.prototype.concat = function() { return []; }
propertyNames = Object.getOwnPropertyNames({0: 'foo', bar: 'baz'});
assertEquals(2, propertyNames.length);
assertEquals('0', propertyNames[0]);
assertEquals('bar', propertyNames[1]);
assertSame(Array.prototype, propertyNames.__proto__);
Array.prototype.concat = savedConcat;

assertEquals(Object.getOwnPropertyNames(4), []);
assertEquals(Object.getOwnPropertyNames("foo"), ["0", "1", "2", "length"]);
assertEquals(Object.getOwnPropertyNames(true), []);

try {
  Object.getOwnPropertyNames(undefined);
  assertTrue(false);
} catch (e) {
  assertTrue(/Cannot convert undefined or null to object/.test(e));
}

try {
  Object.getOwnPropertyNames(null);
  assertTrue(false);
} catch (e) {
  assertTrue(/Cannot convert undefined or null to object/.test(e));
}
                                                                                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/object-in-array.js                                                 0000664 0000000 0000000 00000020450 14746647661 0022042 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --no-lazy-feedback-allocation --allow-natives-syntax

// The expected token (has to be a SMI so that we get SMI_ELEMENTS when
// it's in an array):
const T = 1234;

// The unexpected token:
const T2 = 'unexpected';

function warmup(f) {
  %PrepareFunctionForOptimization(f);
  for (let i = 0; i < 10; i++) {
    f();
  }
}

function test(creator, getter, setter, expectedToken = T) {
  // Warm up the creator function so there's feedback and the boilerplate
  // gets created.
  warmup(creator);

  const o1 = creator();
  assertEquals(expectedToken, getter(o1));

  if (setter == undefined) {
     return;
  }

  // Test that we did a deep copy by setting a field in o1, creating another
  // object, and asserting that it got a fresh copy of the data.
  setter(o1);
  assertNotEquals(expectedToken, getter(o1));

  const o2 = creator();
  assertEquals(expectedToken, getter(o2));
}

// Shallow array:
test(() => { return [T, 2, 3]; }, (o) => o[0], (o) => o[0] = T2);

// Shallow object:
test(() => { return {a: 1, b: T}; }, (o) => o.b, (o) => o.b = T2);

// Shallow object in array:
test(() => { return [0, {a: 10, b: T, c: 20 }, 1]; },
     (o) => o[1].b, (o) => o[1].b = T2);

// Nested array:
test(() => { return [0, 0, [1, 2, 3, T]]; },
     (o) => o[2][3], (o) => o[2][3] = T2);

// Nested object
test(() => { return {a: 0, b: 0, c: {d: 1, e: 2, f: 3, g: T}}; },
     (o) => o.c.g, (o) => o.c.g = T2);

// Array containing an object containing an array:
test(() => { return [{a: [1, 2, T]}]; },
     (o) => o[0].a[2], (o) => o[0].a[2] = T2);

// Object containing an object containing an array:
test(() => { return {a: {b: [1, 2, T]}}; },
(o) => o.a.b[2], (o) => o.a.b[2] = T2);

// Object with both properties and elements in array:
test(() => { return [{a: [1, 2, T], 0: 3}]; },
     (o) => o[0].a[2], (o) => o[0].a[2] = T2);

test(() => { return [{0: 3, a: [1, 2, T]}]; },
     (o) => o[0].a[2], (o) => o[0].a[2] = T2);

test(() => { return [{0: [1, 2, T], a: 3}]; },
     (o) => o[0][0][2], (o) => o[0][0][2] = T2);

test(() => { return [{a: 3, 0: [1, 2, T]}]; },
     (o) => o[0][0][2], (o) => o[0][0][2] = T2);

// Deep object in array:
test(() => { return [{a: {b: {c: T}}}]; },
     (o) => o[0].a.b.c, (o) => o[0].a.b.c = T2);

// Deep array in object:
test(() => { return {a: [[[T]]]}; },
     (o) => o.a[0][0][0], (o) => o.a[0][0][0] = T2);

// Object and arrays in array. Interestingly, {a: T} uses the AllocationSite
// of the main array, but {b: 2} uses the AllocationSite of [3, 4].
test(() => { return [1, 2, {a: T}, [3, 4], {b: 2}]; },
     (o) => o[2].a, (o) => o[2].a = T2);

test(() => { return [1, 2, {a: 1}, [3, 4], {b: T}]; },
     (o) => o[4].b, (o) => o[4].b = T2);

// Object with HeapNumbers in array:
test(() => { return [{a: 3.14159}] },
     (o) => o[0].a, (o) => o[0].a = T2, 3.14159);

// Empty array in array:
test(() => { return [[]]; }, (o) => o[0], (o) => o[0] = T2, []);

// Empty array in object:
test(() => { return {a: []}; }, (o) => o.a, (o) => o.a = T2, []);

// Empty array in object in array:
test(() => { return [{a: []}]; }, (o) => o[0].a, (o) => o[0].a = T2, []);

// Empty object in array:
test(() => { return [{}]; }, (o) => o[0], (o) => o[0] = T2, {});

// Different elements kinds in nested arrays:

// PACKED_SMI_ELEMENTS:
test(() => { return [[1, 2]];}, (o) => o[0][0], (o) => o[0][0] = 2, 1);

// HOLEY_SMI_ELEMENTS:
{
  function createHoleySmiArrayInArray() {
     return [[1, , 2]];
  }
  test(createHoleySmiArrayInArray, (o) => o[0][0], (o) => o[0][0] = 2, 1);
  const o1 = createHoleySmiArrayInArray();
  assertTrue(0 in o1[0]);
  assertFalse(1 in o1[0]);
  assertTrue(2 in o1[0]);
}

// PACKED_DOUBLE_ELEMENTS:
test(() => { return [[1, 2.3]];}, (o) => o[0][0], (o) => o[0][0] = 2, 1);

// HOLEY_DOUBLE_ELEMENTS:
{
  function createHoleyDoubleArrayInArray() {
     return [[1, , 2.3]];
  }
  test(createHoleyDoubleArrayInArray, (o) => o[0][0], (o) => o[0][0] = 2, 1);
  const o1 = createHoleyDoubleArrayInArray();
  assertTrue(0 in o1[0]);
  assertFalse(1 in o1[0]);
  assertTrue(2 in o1[0]);
}

// PACKED_ELEMENTS:
test(() => { return [['a', 'b']];}, (o) => o[0][0], (o) => o[0][0] = 'c', 'a');

// HOLEY_ELEMENTS:
{
  function createHoleyArrayInArray() {
     return [['a', , 'b']];
  }
  test(createHoleyArrayInArray, (o) => o[0][0], (o) => o[0][0] = 'c', 'a');
  const o1 = createHoleyArrayInArray();
  assertTrue(0 in o1[0]);
  assertFalse(1 in o1[0]);
  assertTrue(2 in o1[0]);
}

// Object literal with a custom __proto__. These are handled outside of the
// boilerplate cloning code; this test is here to make sure we don't break
// this case.
{
  function createObjectWithCustomProtoInArray() {
    return [{__proto__: {a: T}, b: 'b'}];
  }
  test(createObjectWithCustomProtoInArray,
       (o) => o[0].__proto__.a, (o) => o[0].__proto__.a = T2);
  const o1 = createObjectWithCustomProtoInArray();
  const o2 = createObjectWithCustomProtoInArray();
  assertNotSame(o1[0].__proto__, o2[0].__proto__);
  assertEquals(T, o1[0].a);
  assertEquals(T, o2[0].a);
}

// Similarly, objects with accessors are handled outside.
test(
    () => { return [
        {get a() { return this.a; }, set a(v) { this.a = v;}, a: T }
        ]; },
    (o) => o[0].a, (o) => o[0].a = T2);

// Similarly, function-valued properties are handled outside.
{
  function createObjectWithFunctionInArray() {
     return [{a: function() { return 0; }}];
  }
  const o1 = createObjectWithFunctionInArray();
  const o2 = createObjectWithFunctionInArray();
  assertNotSame(o1[0].a, o2[0].a);
  assertEquals(0, o1[0].a());
  assertEquals(0, o2[0].a());
}

// Dictionary mode object in array:
{
  function createObjectWithNullProtoInArray() {
    return [{__proto__: null, b: T}];
  }
  test(createObjectWithNullProtoInArray,
       (o) => o[0].b, (o) => o[0].b = T2);
  const o1 = createObjectWithNullProtoInArray();
  assertFalse(%HasFastProperties(o1[0]));
  assertEquals(null, Object.getPrototypeOf(o1[0]));
}

// Object with out-of-object properties in array:
function createLargeObjectInArrayCreator(size) {
  let code = "() => { return [{ ";
  for (let i = 0; i < size; i++) {
    if (i > 0) code += ",";
    code += 'a' + i + ':' + i;
  }
  code += "}];}";
  return eval(code);
}

test(createLargeObjectInArrayCreator(500),
     (o) => o[0].a140, (o) => o[0].a140 = T2, 140);

// Array with an object refrence (not object literal; should not be cloned).
// Likewise, the array boilerplate won't contain the object, but it's
// added outside.
{
   const outsideObject = {a: T, b: 2};
   function createObjectInNestedArray() {
     return [[outsideObject]];
   }
   test(createObjectInNestedArray, (o) => o[0][0].a);

   const o1 = createObjectInNestedArray();
   assertEquals(2, o1[0][0].b);
   outsideObject.b = 'new';
   assertEquals('new', o1[0][0].b);
}

// Object with a deprecated map in an array:
{
  const outside = {prop1: 123};
  function createObjectWithDeprecatedMapInArray() {
     return [{prop1: 123}];
  }
  test(createObjectWithDeprecatedMapInArray, o => o[0].prop1, undefined, 123);
  outside.prop1 = 3.4;
  test(createObjectWithDeprecatedMapInArray, o => o[0].prop1, undefined, 123);
}

// Assert we keep elements COW.
{
  function createNestedArray() {
     return [[1, 2, 3]];
  }
  warmup(createNestedArray);
  const o1 = createNestedArray();
  assertTrue(%HasCowElements(o1[0]));
}

{
  function createNestedArray() {
     return [[1, 2, , 3]];
  }
  warmup(createNestedArray);
  const o1 = createNestedArray();
  assertTrue(%HasCowElements(o1[0]));
  assertFalse(2 in o1);
}

{
  function createNestedArray() {
     return [[1, 2, 3, 'force PACKED_ELEMENTS']];
  }
  warmup(createNestedArray);
  const o1 = createNestedArray();
  assertTrue(%HasCowElements(o1[0]));
}

{
  function createNestedArray() {
     return [[1, 2,  , 3, 'force HOLEY_PACKED_ELEMENTS']];
  }
  warmup(createNestedArray);
  const o1 = createNestedArray();
  assertTrue(%HasCowElements(o1[0]));
  assertFalse(2 in o1);
}

{
  function createArrayInObjectInArray() {
     return [{a: [1, 2, 3] }];
  }
  warmup(createArrayInObjectInArray);
  const o1 = createArrayInObjectInArray();
  assertTrue(%HasCowElements(o1[0].a));
}

// Object with dictionary elements in array:
test(() => { return [{0: T, 10: 5, 1000000000: 5}]; },
     (o) => o[0][0], (o) => o[0][0] = T2);
                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/object-is.js                                                       0000664 0000000 0000000 00000003731 14746647661 0020736 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2012 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

var test_set = [ {}, [], Infinity, -Infinity, "s", "ア", 0, 0/-1, null,
    undefined, true, false, Symbol("foo"), NaN ];
for (var i = 0; i < test_set.length; i++) {
  for (var j = 0; j < test_set.length; j++) {
    if (i == j) {
      assertSame(test_set[i], test_set[j]);
      assertTrue(Object.is(test_set[i], test_set[j]));
    } else {
      assertFalse(Object.is(test_set[i], test_set[j]));
    }
  }
}
                                       node-23.7.0/deps/v8/test/mjsunit/object-keys-typedarray.js                                          0000664 0000000 0000000 00000001213 14746647661 0023451 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

[Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array,
 Uint32Array, Float32Array, Float64Array]
    .forEach(constructor => {
      const huge = new constructor(128);
      assertEquals(Array.from({length: 128}).map((_, i) => String(i)),
                   Object.keys(huge));

      const tiny = new constructor(2);
      assertEquals(["0", "1"], Object.keys(tiny));

      const empty = new constructor(0);
      assertEquals([], Object.keys(empty));
});
                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/object-keys.js                                                     0000664 0000000 0000000 00000006053 14746647661 0021276 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

// Ensure empty keys are handled properly
(function() {
  const a = {};
  let k = Object.keys(a);
  %HeapObjectVerify(k);
  assertEquals(0, k.length);
})();

// Ensure non-enumerable keys are handled properly
(function() {
  const a = {};
  Object.defineProperty(a, 'x', {
    value: 1,
    enumerable: false
  });
  let k = Object.keys(a);
  %HeapObjectVerify(k);
  assertEquals(0, k.length);

  a.y = 2;
  k = Object.keys(a);
  %HeapObjectVerify(k);
  assertEquals(1, k.length);
})();

// Ensure that mutation of the Object.keys result doesn't affect the
// enumeration cache for fast-mode objects.
(function() {
  const a = {x:1, y:2};
  let k = Object.keys(a);
  %HeapObjectVerify(k);
  assertEquals(2, k.length);
  assertEquals("x", k[0]);
  assertEquals("y", k[1]);
  k[0] = "y";
  k[1] = "x";
  k = Object.keys(a);
  assertEquals(2, k.length);
  assertEquals("x", k[0]);
  assertEquals("y", k[1]);
})();

// Ensure that the copy-on-write keys are handled properly, even in
// the presence of Symbols.
(function() {
  const s = Symbol();
  const a = {[s]: 1};
  let k = Object.keys(a);
  %HeapObjectVerify(k);
  assertEquals(0, k.length);
  k.shift();
  assertEquals(0, k.length);
})();

// Ensure we invoke all steps on proxies.
(function ObjectKeysProxy() {
  let log = [];
  let result = Object.keys(new Proxy({}, {
    ownKeys(target) {
      log.push('ownKeys');
      return ['a', 'b', 'c'];
    },
    getOwnPropertyDescriptor(target, key) {
      log.push('getOwnPropertyDescriptor-' + key);
      if (key === 'b') return {enumerable: false, configurable: true};
      return {enumerable: true, configurable: true};
    }
  }));
  assertEquals(['a', 'c'], result);
  assertEquals(
      [
        'ownKeys', 'getOwnPropertyDescriptor-a', 'getOwnPropertyDescriptor-b',
        'getOwnPropertyDescriptor-c'
      ],
      log);

  // Test normal target.
  log = [];
  let target = {a: 1, b: 1, c: 1};
  let handler = {
    getOwnPropertyDescriptor(target, key) {
      log.push('getOwnPropertyDescriptor-' + key);
      if (key === 'b') return {enumerable: false, configurable: true};
      return {enumerable: true, configurable: true};
    }
  };
  result = Object.keys(new Proxy(target, handler));
  assertEquals(['a', 'c'], result);
  assertEquals(
      [
        'getOwnPropertyDescriptor-a', 'getOwnPropertyDescriptor-b',
        'getOwnPropertyDescriptor-c'
      ],
      log);

  // Test trap invocation with non-enumerable target properties.
  log = [];
  target = Object.create(Object.prototype, {
    a: {enumerable: true, configurable: true},
    b: {enumerable: false, configurable: true},
    c: {enumerable: true, configurable: true}
  });
  result = Object.keys(new Proxy(target, handler));
  assertEquals(['a', 'c'], result);
  assertEquals(
      [
        'getOwnPropertyDescriptor-a', 'getOwnPropertyDescriptor-b',
        'getOwnPropertyDescriptor-c'
      ],
      log);
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/object-literal-conversions.js                                      0000664 0000000 0000000 00000004136 14746647661 0024325 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Test that the various conversions between property names are correctly
// used when overwriting initializers.

var test1 = { 13: 6, "13": 7 };
var test2 = { 13: 7, "13.0": 6 };
var test3 = { "13": 6, 13.0000000000000000: 7 };
var test4 = { 13.213000: 6, "13.213": 7 };

assertEquals(7, test1[13]);
assertEquals(7, test2[13]);
assertEquals(7, test3[13]);
assertEquals(7, test4[13.213]);

var test5 = { 13: function() {}, "13": 7 };
var test6 = { 17.31: function() {}, "17.31": 7 };

assertEquals(7, test5[13]);
assertEquals(7, test6[17.31]);
                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/object-literal-gc.js                                               0000664 0000000 0000000 00000004632 14746647661 0022347 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --expose-gc

// Test that the clearing of object literal when normalizing objects
// works.  In particular, test that the garbage collector handles the
// normalized object literals correctly.
function testLiteral(size) {

  // Build object-literal string.
  var literal = "var o = { ";

  for (var i = 0; i < size; i++) {
    if (i > 0) literal += ",";
    literal += ("a" + i + ":" + i);
  }
  literal += "}";

  // Create the object literal.
  eval(literal);

  // Force normalization of the properties.
  delete o["a" + (size - 1)];

  // Perform GC.
  gc();

  // Check that the properties have the expected values.
  for (var i = 0; i < size - 1; i++) {
    assertEquals(i, o["a"+i]);
  }
}

// The sizes to test.
var sizes = [0, 1, 2, 100, 200, 400, 1000];

// Run the test.
for (var i = 0; i < sizes.length; i++) {
  testLiteral(sizes[i]);
}
                                                                                                      node-23.7.0/deps/v8/test/mjsunit/object-literal-modified-object-prototype.js                        0000664 0000000 0000000 00000001102 14746647661 0027032 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

(function TestModifedPrototypeInObjectLiteral() {
  // The prototype chain should not be used if the definition
  // happens in the object literal.

  Object.defineProperty(Object.prototype, 'c', {
    get: function () {
      return 21;
    },
    set: function () {
    }
  });

  var o = {};
  o.c = 7;
  assertEquals(21, o.c);

  var l = {c: 7};
  assertEquals(7, l.c);

  delete Object.prototype.c;
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/object-literal-multiple-fields.js                                  0000664 0000000 0000000 00000002577 14746647661 0025063 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

(function TestConstants() {
  var o = {
    p: 1,
    p: 2,
  };
  assertEquals(2, o.p);
})();


(function TestMaterialized() {
  var o = {
    p: [1],
    p: [2],
  };
  assertEquals(2, o.p[0]);
})();


(function TestMaterialize2() {
  var o = {
    p: function() {},
    p: 2,
  };
  assertEquals(2, o.p);
})();



(function TestComputed() {
  var o = {
    p: (function() { return 1; })(),
    p: (function() { return 2; })(),
  };
  assertEquals(2, o.p);
})();


(function TestComputed2() {
  var o = {
    p: (function() { return 1; })(),
    p: 2,
  };
  assertEquals(2, o.p);
})();



(function TestGetter() {
  var o = {
    get p() { return 1; },
    get p() { return 2; },
  };
  assertEquals(2, o.p);
})();


(function TestGetterSetter() {
  var o = {
    get p() { return 1; },
    set p(_) {},
  };
  assertEquals(1, o.p);

  o = {
    set p(_) {},
    get p() { return 2; },
  };
  assertEquals(2, o.p);
})();


(function TestCombined() {
  var o = {
    get p() { return 1; },
    p: 2,
  };
  assertEquals(2, o.p);

  o = {
    get p() { return 1; },
    p: 2,
    get p() { return 3; },
  };
  assertEquals(3, o.p);

  o = {
    get p() { return 1; },
    p: 2,
    set p(_) {},
  };
  assertEquals(undefined, o.p);
})();
                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/object-literal-multiple-proto-fields.js                            0000664 0000000 0000000 00000000736 14746647661 0026217 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var p1 = {};
var p2 = {};
var p3 = {};
var x = 0;
var y = 1;
var z = 2;
var o = 3;
assertThrows(
    'o = {' +
    '  __proto__: (x++, p1),' +
    '  __proto__: (y++, p2),' +
    '  __proto__: (z++, p3)' +
    '};', SyntaxError);
assertEquals(0, x);
assertEquals(1, y);
assertEquals(2, z);
assertEquals(3, o);
                                  node-23.7.0/deps/v8/test/mjsunit/object-literal-overwrite.js                                        0000664 0000000 0000000 00000006433 14746647661 0024005 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax

// Check that constants and computed properties are overwriting each other
// correctly, i.e., the last initializer for any name is stored in the object.


// Tests for the full code generator (if active).

var foo1 = {bar: 6, bar: 7};

var foo2 = {bar: function(a) {}, bar: 7};

var foo3 = {bar: function(a) {}, bar: function(b) {}, bar: 7};

var foo4 = {
  bar: function(b) {},
  bar: 4,
  bar: function() {
    return 7;
  }
};

var foo5 = {13: function(a) {}, 13: 7};

var foo6 = {14.31: function(a) {}, 14.31: 7};

var foo7 = {15: 6, 15: 7};

function foo8(i) {
  var obj = {x: {a: i}, x: 7};

  return obj.x;
};
%PrepareFunctionForOptimization(foo8);
;
assertEquals(7, foo1.bar);
assertEquals(7, foo2.bar);
assertEquals(7, foo3.bar);
assertEquals(7, foo4.bar());
assertEquals(7, foo5[13]);
assertEquals(7, foo6[14.31]);
assertEquals(7, foo7[15]);

assertEquals(7, foo8(1));
assertEquals(7, foo8(1));
%OptimizeFunctionOnNextCall(foo8);
assertEquals(7, foo8(1));


// Test for the classic code generator.

function fun(x) {
  var inner = {
    j: function(x) {
      return x;
    },
    j: 7
  };
  return inner.j;
}

assertEquals(7, fun(7));

// Check that the initializers of computed properties are executed, even if
// no store instructions are generated for the literals.

var glob1 = 0;

var bar1 = {x: glob1++, x: glob1++, x: glob1++, x: 7};

assertEquals(3, glob1);


var glob2 = 0;

function fun2() {
  var r = {y: glob2++, y: glob2++, y: glob2++, y: 7};
  return r.y;
}

var y = fun2();
assertEquals(7, y);
assertEquals(3, glob2);

var glob3 = 0;

function fun3() {
  var r = {113: glob3++, 113: glob3++, 113: glob3++, 113: 7};
  return r[113];
}

var y = fun3();
assertEquals(7, y);
assertEquals(3, glob3);
                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/object-literal.js                                                  0000664 0000000 0000000 00000262004 14746647661 0021757 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax

function runLiteralsTest(fn) {
  %PrepareFunctionForOptimization(fn);
  // The first run creates an copy directly from the boilerplate decsription.
  fn();
  // The second run will create the boilerplate.
  fn();
  // The third run might copy literals directly in the stub.
  fn();
  // Several invocations more to trigger potential map deprecations.
  fn();
  fn();
  fn();
  // Make sure literals keep on workin in optimized code.
  %OptimizeFunctionOnNextCall(fn);
  fn();
}


runLiteralsTest(function testEmptyObjectLiteral() {
  let object = {};
  assertTrue(%HasFastProperties(object));
  assertTrue(%HasObjectElements(object ));
  assertTrue(%HasHoleyElements(object));
  assertEquals([], Object.keys(object));
});

runLiteralsTest(function testSingleGetter() {
  let object = { get foo() { return 1 } };
  // For now getters create dict mode objects.
  assertFalse(%HasFastProperties(object));
  assertTrue(%HasObjectElements(object ));
  assertTrue(%HasHoleyElements(object));
  assertEquals(['foo'], Object.keys(object));
});

runLiteralsTest(function testBasicPrototype() {
  var obj = {
      a: 7,
      b: { x: 12, y: 24 },
      c: 'Zebra'
  }

  assertEquals(7, obj.a);
  assertEquals(12, obj.b.x);
  assertEquals(24, obj.b.y);
  assertEquals('Zebra', obj.c);
  assertEquals(Object.getPrototypeOf(obj), Object.prototype);
  assertEquals(Object.getPrototypeOf(obj.b), Object.prototype);
});

runLiteralsTest(function testDynamicValue() {
  var z = 24;

  var obj2 = {
      a: 7,
      b: { x: 12, y: z },
      c: 'Zebra'
  }

  assertEquals(7, obj2.a);
  assertEquals(12, obj2.b.x);
  assertEquals(24, obj2.b.y);
  assertEquals('Zebra', obj2.c);
});

runLiteralsTest(function testMultipleInstatiations() {
  var arr = [];
  for (var i = 0; i < 2; i++) {
    arr[i] = {
        a: 7,
        b: { x: 12, y: 24 },
        c: 'Zebra'
    }
  }

  arr[0].b.x = 2;
  assertEquals(2, arr[0].b.x);
  assertEquals(12, arr[1].b.x);
});


runLiteralsTest(function TestSparseElements() {
  function createSparseElements() {
    let sa1 = {
        '0': { x: 12, y: 24 },
        '1000000': { x: 1, y: 2 }
      };
    %HeapObjectVerify(sa1);
    assertEquals(['0', '1000000'], Object.keys(sa1));
    assertEquals(12, sa1[0].x);
    assertEquals(24, sa1[0].y);
    assertEquals(['x', 'y'], Object.keys(sa1[0]));
    assertEquals(1, sa1[1000000].x);
    assertEquals(2, sa1[1000000].y);
    assertEquals(['x', 'y'], Object.keys(sa1[1000000]));
    assertEquals(Object.prototype, Object.getPrototypeOf(sa1));
    assertEquals(Object.prototype, Object.getPrototypeOf(sa1[0]));
    assertEquals(Object.prototype, Object.getPrototypeOf(sa1[1000000]));
    return sa1;
  }

  let object = createSparseElements();
  // modify the object and rerun the test, ensuring the literal didn't change.
  object[1] = "a";
  object[0].x = -12;
  createSparseElements();
});

runLiteralsTest(function TestNonConstLiterals() {
  // Test that non-constant literals work.
  var n = new Object();

  function makeNonConstantArray() { return [ [ n ] ]; }

  var a = makeNonConstantArray();
  var b = makeNonConstantArray();
  assertTrue(a[0][0] === n);
  assertTrue(b[0][0] === n);
  assertFalse(a[0] === b[0]);
  a[0][0].foo = "bar";
  assertEquals("bar", n.foo);

  function makeNonConstantObject() { return { a: { b: n } }; }

  a = makeNonConstantObject();
  b = makeNonConstantObject();
  assertFalse(a.a === b.a);
  assertTrue(a.a.b === b.a.b);
  a.a.b.bar = "foo";
  assertEquals("foo", n.bar);
});

runLiteralsTest(function TestRegexpInArray() {
  // Test that exceptions for regexps still hold.
  function makeRegexpInArray() { return [ [ /a*/, {} ] ]; }

  let a = makeRegexpInArray();
  let b = makeRegexpInArray();
  assertFalse(a[0][0] === b[0][0]);
  assertFalse(a[0][1] === b[0][1]);
  assertEquals(Array.prototype, Object.getPrototypeOf(a));
  assertEquals(Array.prototype, Object.getPrototypeOf(b));
  assertEquals(Array.prototype, Object.getPrototypeOf(a[0]));
  assertEquals(Array.prototype, Object.getPrototypeOf(b[0]));
  assertEquals(RegExp.prototype, Object.getPrototypeOf(a[0][0]));
  assertEquals(RegExp.prototype, Object.getPrototypeOf(b[0][0]));
});

runLiteralsTest(function TestRegexpInObject() {
  function makeRegexpInObject() { return { a: { b: /b*/, c: {} } }; }
  let a = makeRegexpInObject();
  let b = makeRegexpInObject();
  assertFalse(a.a.b === b.a.b);
  assertFalse(a.a.c === b.a.c);
  assertEquals(RegExp.prototype, Object.getPrototypeOf(a.a.b));
  assertEquals(RegExp.prototype, Object.getPrototypeOf(b.a.b));
});

runLiteralsTest(function TestKeywordProperties() {
  // Test keywords are valid as property names in initializers and dot-access.
  var keywords = [
    "break",
    "case",
    "catch",
    "const",
    "continue",
    "debugger",
    "default",
    "delete",
    "do",
    "else",
    "false",
    "finally",
    "for",
    "function",
    "if",
    "in",
    "instanceof",
    "new",
    "null",
    "return",
    "switch",
    "this",
    "throw",
    "true",
    "try",
    "typeof",
    "var",
    "void",
    "while",
    "with"
  ];

  function testKeywordProperty(keyword) {
    var exception = false;
    try {
      // Sanity check that what we get is a keyword.
      eval("var " + keyword + " = 42;");
    } catch (e) {
      exception = true;
    }
    assertTrue(exception);

    // Simple property, read and write.
    var x = eval("({" + keyword + ": 42})");
    assertEquals(42, x[keyword]);
    assertEquals(42, eval("x." + keyword));
    eval("x." + keyword + " = 37");
    assertEquals(37, x[keyword]);
    assertEquals(37, eval("x." + keyword));

    // Getter/setter property, read and write.
    var y = eval("({value : 42, get " + keyword + "(){return this.value}," +
                 " set " + keyword + "(v) { this.value = v; }})");
    assertEquals(42, y[keyword]);
    assertEquals(42, eval("y." + keyword));
    eval("y." + keyword + " = 37");
    assertEquals(37, y[keyword]);
    assertEquals(37, eval("y." + keyword));

    // Quoted keyword works is read back by unquoted as well.
    var z = eval("({\"" + keyword + "\": 42})");
    assertEquals(42, z[keyword]);
    assertEquals(42, eval("z." + keyword));

    // Function property, called.
    var was_called;
    function test_call() { this.was_called = true; was_called = true; }
    var w = eval("({" + keyword + ": test_call, was_called: false})");
    eval("w." + keyword + "();");
    assertTrue(was_called);
    assertTrue(w.was_called);

    // Function property, constructed.
    function construct() { this.constructed = true; }
    var v = eval("({" + keyword + ": construct})");
    var vo = eval("new v." + keyword + "()");
    assertTrue(vo instanceof construct);
    assertTrue(vo.constructed);
  }

  for (var i = 0; i < keywords.length; i++) {
    testKeywordProperty(keywords[i]);
  }
});

runLiteralsTest(function TestSimpleElements() {
  var o = { 0:"zero", 1:"one", 2:"two" };
  assertEquals({0:"zero", 1:"one", 2:"two"}, o);
  o[0] = 0;
  assertEquals({0:0, 1:"one", 2:"two"}, o);
});

runLiteralsTest(function TestNumericNames() {
  var o = {
    1: 1,
    2.: 2,
    3.0: 3,
    4e0: 4,
    5E0: 5,
    6e-0: 6,
    7E-0: 7,
    0x8: 8,
    0X9: 9,
  };
  %HeapObjectVerify(o);
  assertEquals(['1', '2', '3', '4', '5', '6', '7', '8', '9'], Object.keys(o));

  o = {
    1.2: 1.2,
    1.30: 1.3
  };
  %HeapObjectVerify(o);
  assertEquals(['1.2', '1.3'], Object.keys(o));
});

runLiteralsTest(function TestDictionaryElements() {
  let o = {1024: true};
  assertTrue(%HasDictionaryElements(o));
  assertEquals(true, o[1024]);
  assertEquals(["1024"], Object.keys(o));
  assertEquals([true], Object.values(o));
  %HeapObjectVerify(o);
  o[1024] = "test";
  assertEquals(["test"], Object.values(o));

  let o2 = {1024: 1024};
  assertTrue(%HasDictionaryElements(o2));
  assertEquals(1024, o2[1024]);
  assertEquals(["1024"], Object.keys(o2));
  assertEquals([1024], Object.values(o2));
  %HeapObjectVerify(o2);
  o2[1024] = "test";
  assertEquals(["test"], Object.values(o2));
});

runLiteralsTest(function TestLiteralElementsKind() {
  let o = {0:0, 1:1, 2:2};
  assertTrue(%HasObjectElements(o));
  assertTrue(%HasHoleyElements(o));
  o = {0:0, 2:2};
  assertTrue(%HasObjectElements(o));
  assertTrue(%HasHoleyElements(o));

  o = {0:0.1, 1:1, 2:2};
  assertTrue(%HasObjectElements(o));
  assertTrue(%HasHoleyElements(o));
  o = {0:0.1, 2:2};
  assertTrue(%HasObjectElements(o));
  assertTrue(%HasHoleyElements(o));

  o = {0:0.1, 1:1, 2:true};
  assertTrue(%HasObjectElements(o));
  assertTrue(%HasHoleyElements(o));
  o = {0:0.1, 2:true};
  assertTrue(%HasObjectElements(o));
  assertTrue(%HasHoleyElements(o));

  assertTrue(%HasDictionaryElements({0xFFFFFF:true}));
});

runLiteralsTest(function TestNonNumberElementValues() {
  var o = {
    1: true,
    2: false,
    3: undefined,
    4: ""
  };
  %HeapObjectVerify(o);
  assertEquals(['1', '2', '3', '4'], Object.keys(o));
  assertEquals([true, false, undefined, ""], Object.values(o));
  o[1] = 'a';
  o[2] = 'b';
  assertEquals(['1', '2', '3', '4'], Object.keys(o));
  assertEquals(['a', 'b', undefined, ""], Object.values(o));

  var o2 = {
    1: true,
    2: false,
    3: undefined,
    4: "",
    a: 'a',
    b: 'b'
  };
  %HeapObjectVerify(o2);
  assertEquals(['1', '2', '3', '4', 'a', 'b'], Object.keys(o2));
  assertEquals([true, false, undefined, "", 'a', 'b'], Object.values(o2));
  o2[1] = 'a';
  o2[2] = 'b';
  assertEquals(['1', '2', '3', '4', 'a', 'b'], Object.keys(o2));
  assertEquals(['a', 'b', undefined, "", 'a', 'b'], Object.values(o2));

  var o3 = {
    __proto__:null,
    1: true,
    2: false,
    3: undefined,
    4: ""
  };
  %HeapObjectVerify(o3);
  assertEquals(['1', '2', '3', '4'], Object.keys(o3));

  var o4 = {
    __proto__:null,
    1: true,
    2: false,
    3: undefined,
    4: "",
    a: 'a',
    b: 'b'
  };
  %HeapObjectVerify(o4);
  assertEquals(['1', '2', '3', '4', 'a', 'b'], Object.keys(o4));
})


runLiteralsTest(function numericGetters() {
  function TestNumericNamesGetter(expectedKeys, object) {
    assertEquals(expectedKeys, Object.keys(object));
    expectedKeys.forEach(function(key) {
      var descr = Object.getOwnPropertyDescriptor(object, key);
      assertEquals('get ' + key, descr.get.name);
    });
  }
  TestNumericNamesGetter(['1', '2', '3', '4', '5', '6', '7', '8', '9'], {
    get 1() {},
    get 2.() {},
    get 3.0() {},
    get 4e0() {},
    get 5E0() {},
    get 6e-0() {},
    get 7E-0() {},
    get 0x8() {},
    get 0X9() {},
  });
  TestNumericNamesGetter(['1.2', '1.3'], {
    get 1.2() {},
    get 1.30() {}
  });
});

runLiteralsTest(function numericSetters() {
  function TestNumericNamesSetter(expectedKeys, object) {
    assertEquals(expectedKeys, Object.keys(object));
    expectedKeys.forEach(function(key) {
      var descr = Object.getOwnPropertyDescriptor(object, key);
      assertEquals('set ' + key, descr.set.name);
    });
  }
  TestNumericNamesSetter(['1', '2', '3', '4', '5', '6', '7', '8', '9'], {
    set 1(_) {},
    set 2.(_) {},
    set 3.0(_) {},
    set 4e0(_) {},
    set 5E0(_) {},
    set 6e-0(_) {},
    set 7E-0(_) {},
    set 0x8(_) {},
    set 0X9(_) {},
  });
  TestNumericNamesSetter(['1.2', '1.3'], {
    set 1.2(_) {; },
    set 1.30(_) {; }
  });
});


runLiteralsTest(function TestProxyWithDefinitionInObjectLiteral() {
  // Trap for set should not be used if the definition
  // happens in the object literal.
  var handler = {
    set: function(target, name, value) {
    }
  };

  const prop = 'a';

  var p = new Proxy({}, handler);
  p[prop] = 'my value';
  assertEquals(undefined, p[prop]);


  var l = new Proxy({[prop]: 'my value'}, handler);
  assertEquals('my value', l[prop]);
});

runLiteralsTest(function TestLiteralWithNullProto() {
  // Assume dictionary usage for simple null prototype literal objects,
  // this is equivalent to Object.create(null). Note that on the first call
  // the literal boilerplate is initialized, and from then on we use a the
  // fast clone stub.
  function testDictModeNullProtoLiteral(fn) {
    let obj = fn();
    assertFalse(%HasFastProperties(obj));
    assertEquals(Object.getPrototypeOf(obj), null);
    let next = fn();
    assertFalse(obj === next);
    obj = next;
    assertFalse(%HasFastProperties(obj));
    assertEquals(Object.getPrototypeOf(obj), null);
    next = fn();
    assertFalse(obj === next);
    obj = next;
    assertFalse(%HasFastProperties(obj));
    assertEquals(Object.getPrototypeOf(obj), null);
  }
  testDictModeNullProtoLiteral(() => ({__proto__:null}));
  testDictModeNullProtoLiteral(() => ({__proto__:null, a:1, b:2}));
  testDictModeNullProtoLiteral(() => ({__proto__: null, ["a"]: 1}));
  testDictModeNullProtoLiteral(() => ({__proto__: null, a: Object}));
  testDictModeNullProtoLiteral(() => ({a:1, b:2, __proto__:null}));
  testDictModeNullProtoLiteral(() => ({["a"]: 1, __proto__: null}));
  testDictModeNullProtoLiteral(() => ({a: Object, __proto__: null}));
});

runLiteralsTest(function testNestedNullProtoLiteral() {
  let obj;
  obj = { foo: { __proto__:Math, bar:"barValue"}};
  assertTrue(%HasFastProperties(obj));
  assertTrue(%HasFastProperties(obj.foo));
  assertEquals(Object.prototype, Object.getPrototypeOf(obj));
  assertEquals(Math, Object.getPrototypeOf(obj.foo));
  assertEquals(["foo"], Object.keys(obj));
  assertEquals(["bar"], Object.keys(obj.foo));
  assertEquals("barValue", obj.foo.bar);
  obj.foo.bar = "barValue2";
  assertEquals("barValue2", obj.foo.bar);

  obj = { foo: { __proto__:null, bar:"barValue"}};
  assertTrue(%HasFastProperties(obj));
  assertFalse(%HasFastProperties(obj.foo));
  assertEquals(Object.prototype, Object.getPrototypeOf(obj));
  assertEquals(null, Object.getPrototypeOf(obj.foo));
  assertEquals(["foo"], Object.keys(obj));
  assertEquals(["bar"], Object.keys(obj.foo));
  assertEquals("barValue", obj.foo.bar);
  obj.foo.bar = "barValue2";
  assertEquals("barValue2", obj.foo.bar);
});


runLiteralsTest(function TestSlowLiteralOptimized() {
  function f() {
    return {__proto__:null, bar:"barValue"};
  }
  %PrepareFunctionForOptimization(f);
  let obj = f();
  assertFalse(%HasFastProperties(obj));
  assertEquals(Object.getPrototypeOf(obj), null);
  assertEquals(["bar"], Object.keys(obj));
  assertEquals("barValue", obj.bar);
  obj.bar = "barValue2";
  assertEquals("barValue2", obj.bar);

  %OptimizeFunctionOnNextCall(f);
  obj = f();
  assertFalse(%HasFastProperties(obj));
  assertEquals(Object.getPrototypeOf(obj), null);
  assertEquals(["bar"], Object.keys(obj));
  assertEquals("barValue", obj.bar);
  obj.bar = "barValue2";
  assertEquals("barValue2", obj.bar);
});

runLiteralsTest(function TestLargeDictionaryLiteral() {
  // Create potential large-space object literal.
  function createObject() {
    // This literal has least kMaxRegularHeapObjectSize / 64 number of
    // properties, forcing the backing store to be in large object space.
    return { __proto__:null,
      p1:'',p2:'',p3:'',p4:'',p5:'',p6:'',p7:'',p8:'',
      p9:'',pa:'',pb:'',pc:'',pd:'',pe:'',pf:'',p10:'',
      p11:'',p12:'',p13:'',p14:'',p15:'',p16:'',p17:'',p18:'',
      p19:'',p1a:'',p1b:'',p1c:'',p1d:'',p1e:'',p1f:'',p20:'',
      p21:'',p22:'',p23:'',p24:'',p25:'',p26:'',p27:'',p28:'',
      p29:'',p2a:'',p2b:'',p2c:'',p2d:'',p2e:'',p2f:'',p30:'',
      p31:'',p32:'',p33:'',p34:'',p35:'',p36:'',p37:'',p38:'',
      p39:'',p3a:'',p3b:'',p3c:'',p3d:'',p3e:'',p3f:'',p40:'',
      p41:'',p42:'',p43:'',p44:'',p45:'',p46:'',p47:'',p48:'',
      p49:'',p4a:'',p4b:'',p4c:'',p4d:'',p4e:'',p4f:'',p50:'',
      p51:'',p52:'',p53:'',p54:'',p55:'',p56:'',p57:'',p58:'',
      p59:'',p5a:'',p5b:'',p5c:'',p5d:'',p5e:'',p5f:'',p60:'',
      p61:'',p62:'',p63:'',p64:'',p65:'',p66:'',p67:'',p68:'',
      p69:'',p6a:'',p6b:'',p6c:'',p6d:'',p6e:'',p6f:'',p70:'',
      p71:'',p72:'',p73:'',p74:'',p75:'',p76:'',p77:'',p78:'',
      p79:'',p7a:'',p7b:'',p7c:'',p7d:'',p7e:'',p7f:'',p80:'',
      p81:'',p82:'',p83:'',p84:'',p85:'',p86:'',p87:'',p88:'',
      p89:'',p8a:'',p8b:'',p8c:'',p8d:'',p8e:'',p8f:'',p90:'',
      p91:'',p92:'',p93:'',p94:'',p95:'',p96:'',p97:'',p98:'',
      p99:'',p9a:'',p9b:'',p9c:'',p9d:'',p9e:'',p9f:'',pa0:'',
      pa1:'',pa2:'',pa3:'',pa4:'',pa5:'',pa6:'',pa7:'',pa8:'',
      pa9:'',paa:'',pab:'',pac:'',pad:'',pae:'',paf:'',pb0:'',
      pb1:'',pb2:'',pb3:'',pb4:'',pb5:'',pb6:'',pb7:'',pb8:'',
      pb9:'',pba:'',pbb:'',pbc:'',pbd:'',pbe:'',pbf:'',pc0:'',
      pc1:'',pc2:'',pc3:'',pc4:'',pc5:'',pc6:'',pc7:'',pc8:'',
      pc9:'',pca:'',pcb:'',pcc:'',pcd:'',pce:'',pcf:'',pd0:'',
      pd1:'',pd2:'',pd3:'',pd4:'',pd5:'',pd6:'',pd7:'',pd8:'',
      pd9:'',pda:'',pdb:'',pdc:'',pdd:'',pde:'',pdf:'',pe0:'',
      pe1:'',pe2:'',pe3:'',pe4:'',pe5:'',pe6:'',pe7:'',pe8:'',
      pe9:'',pea:'',peb:'',pec:'',ped:'',pee:'',pef:'',pf0:'',
      pf1:'',pf2:'',pf3:'',pf4:'',pf5:'',pf6:'',pf7:'',pf8:'',
      pf9:'',pfa:'',pfb:'',pfc:'',pfd:'',pfe:'',pff:'',p100:'',
      p101:'',p102:'',p103:'',p104:'',p105:'',p106:'',p107:'',p108:'',
      p109:'',p10a:'',p10b:'',p10c:'',p10d:'',p10e:'',p10f:'',p110:'',
      p111:'',p112:'',p113:'',p114:'',p115:'',p116:'',p117:'',p118:'',
      p119:'',p11a:'',p11b:'',p11c:'',p11d:'',p11e:'',p11f:'',p120:'',
      p121:'',p122:'',p123:'',p124:'',p125:'',p126:'',p127:'',p128:'',
      p129:'',p12a:'',p12b:'',p12c:'',p12d:'',p12e:'',p12f:'',p130:'',
      p131:'',p132:'',p133:'',p134:'',p135:'',p136:'',p137:'',p138:'',
      p139:'',p13a:'',p13b:'',p13c:'',p13d:'',p13e:'',p13f:'',p140:'',
      p141:'',p142:'',p143:'',p144:'',p145:'',p146:'',p147:'',p148:'',
      p149:'',p14a:'',p14b:'',p14c:'',p14d:'',p14e:'',p14f:'',p150:'',
      p151:'',p152:'',p153:'',p154:'',p155:'',p156:'',p157:'',p158:'',
      p159:'',p15a:'',p15b:'',p15c:'',p15d:'',p15e:'',p15f:'',p160:'',
      p161:'',p162:'',p163:'',p164:'',p165:'',p166:'',p167:'',p168:'',
      p169:'',p16a:'',p16b:'',p16c:'',p16d:'',p16e:'',p16f:'',p170:'',
      p171:'',p172:'',p173:'',p174:'',p175:'',p176:'',p177:'',p178:'',
      p179:'',p17a:'',p17b:'',p17c:'',p17d:'',p17e:'',p17f:'',p180:'',
      p181:'',p182:'',p183:'',p184:'',p185:'',p186:'',p187:'',p188:'',
      p189:'',p18a:'',p18b:'',p18c:'',p18d:'',p18e:'',p18f:'',p190:'',
      p191:'',p192:'',p193:'',p194:'',p195:'',p196:'',p197:'',p198:'',
      p199:'',p19a:'',p19b:'',p19c:'',p19d:'',p19e:'',p19f:'',p1a0:'',
      p1a1:'',p1a2:'',p1a3:'',p1a4:'',p1a5:'',p1a6:'',p1a7:'',p1a8:'',
      p1a9:'',p1aa:'',p1ab:'',p1ac:'',p1ad:'',p1ae:'',p1af:'',p1b0:'',
      p1b1:'',p1b2:'',p1b3:'',p1b4:'',p1b5:'',p1b6:'',p1b7:'',p1b8:'',
      p1b9:'',p1ba:'',p1bb:'',p1bc:'',p1bd:'',p1be:'',p1bf:'',p1c0:'',
      p1c1:'',p1c2:'',p1c3:'',p1c4:'',p1c5:'',p1c6:'',p1c7:'',p1c8:'',
      p1c9:'',p1ca:'',p1cb:'',p1cc:'',p1cd:'',p1ce:'',p1cf:'',p1d0:'',
      p1d1:'',p1d2:'',p1d3:'',p1d4:'',p1d5:'',p1d6:'',p1d7:'',p1d8:'',
      p1d9:'',p1da:'',p1db:'',p1dc:'',p1dd:'',p1de:'',p1df:'',p1e0:'',
      p1e1:'',p1e2:'',p1e3:'',p1e4:'',p1e5:'',p1e6:'',p1e7:'',p1e8:'',
      p1e9:'',p1ea:'',p1eb:'',p1ec:'',p1ed:'',p1ee:'',p1ef:'',p1f0:'',
      p1f1:'',p1f2:'',p1f3:'',p1f4:'',p1f5:'',p1f6:'',p1f7:'',p1f8:'',
      p1f9:'',p1fa:'',p1fb:'',p1fc:'',p1fd:'',p1fe:'',p1ff:'',p200:'',
      p201:'',p202:'',p203:'',p204:'',p205:'',p206:'',p207:'',p208:'',
      p209:'',p20a:'',p20b:'',p20c:'',p20d:'',p20e:'',p20f:'',p210:'',
      p211:'',p212:'',p213:'',p214:'',p215:'',p216:'',p217:'',p218:'',
      p219:'',p21a:'',p21b:'',p21c:'',p21d:'',p21e:'',p21f:'',p220:'',
      p221:'',p222:'',p223:'',p224:'',p225:'',p226:'',p227:'',p228:'',
      p229:'',p22a:'',p22b:'',p22c:'',p22d:'',p22e:'',p22f:'',p230:'',
      p231:'',p232:'',p233:'',p234:'',p235:'',p236:'',p237:'',p238:'',
      p239:'',p23a:'',p23b:'',p23c:'',p23d:'',p23e:'',p23f:'',p240:'',
      p241:'',p242:'',p243:'',p244:'',p245:'',p246:'',p247:'',p248:'',
      p249:'',p24a:'',p24b:'',p24c:'',p24d:'',p24e:'',p24f:'',p250:'',
      p251:'',p252:'',p253:'',p254:'',p255:'',p256:'',p257:'',p258:'',
      p259:'',p25a:'',p25b:'',p25c:'',p25d:'',p25e:'',p25f:'',p260:'',
      p261:'',p262:'',p263:'',p264:'',p265:'',p266:'',p267:'',p268:'',
      p269:'',p26a:'',p26b:'',p26c:'',p26d:'',p26e:'',p26f:'',p270:'',
      p271:'',p272:'',p273:'',p274:'',p275:'',p276:'',p277:'',p278:'',
      p279:'',p27a:'',p27b:'',p27c:'',p27d:'',p27e:'',p27f:'',p280:'',
      p281:'',p282:'',p283:'',p284:'',p285:'',p286:'',p287:'',p288:'',
      p289:'',p28a:'',p28b:'',p28c:'',p28d:'',p28e:'',p28f:'',p290:'',
      p291:'',p292:'',p293:'',p294:'',p295:'',p296:'',p297:'',p298:'',
      p299:'',p29a:'',p29b:'',p29c:'',p29d:'',p29e:'',p29f:'',p2a0:'',
      p2a1:'',p2a2:'',p2a3:'',p2a4:'',p2a5:'',p2a6:'',p2a7:'',p2a8:'',
      p2a9:'',p2aa:'',p2ab:'',p2ac:'',p2ad:'',p2ae:'',p2af:'',p2b0:'',
      p2b1:'',p2b2:'',p2b3:'',p2b4:'',p2b5:'',p2b6:'',p2b7:'',p2b8:'',
      p2b9:'',p2ba:'',p2bb:'',p2bc:'',p2bd:'',p2be:'',p2bf:'',p2c0:'',
      p2c1:'',p2c2:'',p2c3:'',p2c4:'',p2c5:'',p2c6:'',p2c7:'',p2c8:'',
      p2c9:'',p2ca:'',p2cb:'',p2cc:'',p2cd:'',p2ce:'',p2cf:'',p2d0:'',
      p2d1:'',p2d2:'',p2d3:'',p2d4:'',p2d5:'',p2d6:'',p2d7:'',p2d8:'',
      p2d9:'',p2da:'',p2db:'',p2dc:'',p2dd:'',p2de:'',p2df:'',p2e0:'',
      p2e1:'',p2e2:'',p2e3:'',p2e4:'',p2e5:'',p2e6:'',p2e7:'',p2e8:'',
      p2e9:'',p2ea:'',p2eb:'',p2ec:'',p2ed:'',p2ee:'',p2ef:'',p2f0:'',
      p2f1:'',p2f2:'',p2f3:'',p2f4:'',p2f5:'',p2f6:'',p2f7:'',p2f8:'',
      p2f9:'',p2fa:'',p2fb:'',p2fc:'',p2fd:'',p2fe:'',p2ff:'',p300:'',
      p301:'',p302:'',p303:'',p304:'',p305:'',p306:'',p307:'',p308:'',
      p309:'',p30a:'',p30b:'',p30c:'',p30d:'',p30e:'',p30f:'',p310:'',
      p311:'',p312:'',p313:'',p314:'',p315:'',p316:'',p317:'',p318:'',
      p319:'',p31a:'',p31b:'',p31c:'',p31d:'',p31e:'',p31f:'',p320:'',
      p321:'',p322:'',p323:'',p324:'',p325:'',p326:'',p327:'',p328:'',
      p329:'',p32a:'',p32b:'',p32c:'',p32d:'',p32e:'',p32f:'',p330:'',
      p331:'',p332:'',p333:'',p334:'',p335:'',p336:'',p337:'',p338:'',
      p339:'',p33a:'',p33b:'',p33c:'',p33d:'',p33e:'',p33f:'',p340:'',
      p341:'',p342:'',p343:'',p344:'',p345:'',p346:'',p347:'',p348:'',
      p349:'',p34a:'',p34b:'',p34c:'',p34d:'',p34e:'',p34f:'',p350:'',
      p351:'',p352:'',p353:'',p354:'',p355:'',p356:'',p357:'',p358:'',
      p359:'',p35a:'',p35b:'',p35c:'',p35d:'',p35e:'',p35f:'',p360:'',
      p361:'',p362:'',p363:'',p364:'',p365:'',p366:'',p367:'',p368:'',
      p369:'',p36a:'',p36b:'',p36c:'',p36d:'',p36e:'',p36f:'',p370:'',
      p371:'',p372:'',p373:'',p374:'',p375:'',p376:'',p377:'',p378:'',
      p379:'',p37a:'',p37b:'',p37c:'',p37d:'',p37e:'',p37f:'',p380:'',
      p381:'',p382:'',p383:'',p384:'',p385:'',p386:'',p387:'',p388:'',
      p389:'',p38a:'',p38b:'',p38c:'',p38d:'',p38e:'',p38f:'',p390:'',
      p391:'',p392:'',p393:'',p394:'',p395:'',p396:'',p397:'',p398:'',
      p399:'',p39a:'',p39b:'',p39c:'',p39d:'',p39e:'',p39f:'',p3a0:'',
      p3a1:'',p3a2:'',p3a3:'',p3a4:'',p3a5:'',p3a6:'',p3a7:'',p3a8:'',
      p3a9:'',p3aa:'',p3ab:'',p3ac:'',p3ad:'',p3ae:'',p3af:'',p3b0:'',
      p3b1:'',p3b2:'',p3b3:'',p3b4:'',p3b5:'',p3b6:'',p3b7:'',p3b8:'',
      p3b9:'',p3ba:'',p3bb:'',p3bc:'',p3bd:'',p3be:'',p3bf:'',p3c0:'',
      p3c1:'',p3c2:'',p3c3:'',p3c4:'',p3c5:'',p3c6:'',p3c7:'',p3c8:'',
      p3c9:'',p3ca:'',p3cb:'',p3cc:'',p3cd:'',p3ce:'',p3cf:'',p3d0:'',
      p3d1:'',p3d2:'',p3d3:'',p3d4:'',p3d5:'',p3d6:'',p3d7:'',p3d8:'',
      p3d9:'',p3da:'',p3db:'',p3dc:'',p3dd:'',p3de:'',p3df:'',p3e0:'',
      p3e1:'',p3e2:'',p3e3:'',p3e4:'',p3e5:'',p3e6:'',p3e7:'',p3e8:'',
      p3e9:'',p3ea:'',p3eb:'',p3ec:'',p3ed:'',p3ee:'',p3ef:'',p3f0:'',
      p3f1:'',p3f2:'',p3f3:'',p3f4:'',p3f5:'',p3f6:'',p3f7:'',p3f8:'',
      p3f9:'',p3fa:'',p3fb:'',p3fc:'',p3fd:'',p3fe:'',p3ff:'',p400:'',
      p401:'',p402:'',p403:'',p404:'',p405:'',p406:'',p407:'',p408:'',
      p409:'',p40a:'',p40b:'',p40c:'',p40d:'',p40e:'',p40f:'',p410:'',
      p411:'',p412:'',p413:'',p414:'',p415:'',p416:'',p417:'',p418:'',
      p419:'',p41a:'',p41b:'',p41c:'',p41d:'',p41e:'',p41f:'',p420:'',
      p421:'',p422:'',p423:'',p424:'',p425:'',p426:'',p427:'',p428:'',
      p429:'',p42a:'',p42b:'',p42c:'',p42d:'',p42e:'',p42f:'',p430:'',
      p431:'',p432:'',p433:'',p434:'',p435:'',p436:'',p437:'',p438:'',
      p439:'',p43a:'',p43b:'',p43c:'',p43d:'',p43e:'',p43f:'',p440:'',
      p441:'',p442:'',p443:'',p444:'',p445:'',p446:'',p447:'',p448:'',
      p449:'',p44a:'',p44b:'',p44c:'',p44d:'',p44e:'',p44f:'',p450:'',
      p451:'',p452:'',p453:'',p454:'',p455:'',p456:'',p457:'',p458:'',
      p459:'',p45a:'',p45b:'',p45c:'',p45d:'',p45e:'',p45f:'',p460:'',
      p461:'',p462:'',p463:'',p464:'',p465:'',p466:'',p467:'',p468:'',
      p469:'',p46a:'',p46b:'',p46c:'',p46d:'',p46e:'',p46f:'',p470:'',
      p471:'',p472:'',p473:'',p474:'',p475:'',p476:'',p477:'',p478:'',
      p479:'',p47a:'',p47b:'',p47c:'',p47d:'',p47e:'',p47f:'',p480:'',
      p481:'',p482:'',p483:'',p484:'',p485:'',p486:'',p487:'',p488:'',
      p489:'',p48a:'',p48b:'',p48c:'',p48d:'',p48e:'',p48f:'',p490:'',
      p491:'',p492:'',p493:'',p494:'',p495:'',p496:'',p497:'',p498:'',
      p499:'',p49a:'',p49b:'',p49c:'',p49d:'',p49e:'',p49f:'',p4a0:'',
      p4a1:'',p4a2:'',p4a3:'',p4a4:'',p4a5:'',p4a6:'',p4a7:'',p4a8:'',
      p4a9:'',p4aa:'',p4ab:'',p4ac:'',p4ad:'',p4ae:'',p4af:'',p4b0:'',
      p4b1:'',p4b2:'',p4b3:'',p4b4:'',p4b5:'',p4b6:'',p4b7:'',p4b8:'',
      p4b9:'',p4ba:'',p4bb:'',p4bc:'',p4bd:'',p4be:'',p4bf:'',p4c0:'',
      p4c1:'',p4c2:'',p4c3:'',p4c4:'',p4c5:'',p4c6:'',p4c7:'',p4c8:'',
      p4c9:'',p4ca:'',p4cb:'',p4cc:'',p4cd:'',p4ce:'',p4cf:'',p4d0:'',
      p4d1:'',p4d2:'',p4d3:'',p4d4:'',p4d5:'',p4d6:'',p4d7:'',p4d8:'',
      p4d9:'',p4da:'',p4db:'',p4dc:'',p4dd:'',p4de:'',p4df:'',p4e0:'',
      p4e1:'',p4e2:'',p4e3:'',p4e4:'',p4e5:'',p4e6:'',p4e7:'',p4e8:'',
      p4e9:'',p4ea:'',p4eb:'',p4ec:'',p4ed:'',p4ee:'',p4ef:'',p4f0:'',
      p4f1:'',p4f2:'',p4f3:'',p4f4:'',p4f5:'',p4f6:'',p4f7:'',p4f8:'',
      p4f9:'',p4fa:'',p4fb:'',p4fc:'',p4fd:'',p4fe:'',p4ff:'',p500:'',
      p501:'',p502:'',p503:'',p504:'',p505:'',p506:'',p507:'',p508:'',
      p509:'',p50a:'',p50b:'',p50c:'',p50d:'',p50e:'',p50f:'',p510:'',
      p511:'',p512:'',p513:'',p514:'',p515:'',p516:'',p517:'',p518:'',
      p519:'',p51a:'',p51b:'',p51c:'',p51d:'',p51e:'',p51f:'',p520:'',
      p521:'',p522:'',p523:'',p524:'',p525:'',p526:'',p527:'',p528:'',
      p529:'',p52a:'',p52b:'',p52c:'',p52d:'',p52e:'',p52f:'',p530:'',
      p531:'',p532:'',p533:'',p534:'',p535:'',p536:'',p537:'',p538:'',
      p539:'',p53a:'',p53b:'',p53c:'',p53d:'',p53e:'',p53f:'',p540:'',
      p541:'',p542:'',p543:'',p544:'',p545:'',p546:'',p547:'',p548:'',
      p549:'',p54a:'',p54b:'',p54c:'',p54d:'',p54e:'',p54f:'',p550:'',
      p551:'',p552:'',p553:'',p554:'',p555:'',p556:'',p557:'',p558:'',
      p559:'',p55a:'',p55b:'',p55c:'',p55d:'',p55e:'',p55f:'',p560:'',
      p561:'',p562:'',p563:'',p564:'',p565:'',p566:'',p567:'',p568:'',
      p569:'',p56a:'',p56b:'',p56c:'',p56d:'',p56e:'',p56f:'',p570:'',
      p571:'',p572:'',p573:'',p574:'',p575:'',p576:'',p577:'',p578:'',
      p579:'',p57a:'',p57b:'',p57c:'',p57d:'',p57e:'',p57f:'',p580:'',
      p581:'',p582:'',p583:'',p584:'',p585:'',p586:'',p587:'',p588:'',
      p589:'',p58a:'',p58b:'',p58c:'',p58d:'',p58e:'',p58f:'',p590:'',
      p591:'',p592:'',p593:'',p594:'',p595:'',p596:'',p597:'',p598:'',
      p599:'',p59a:'',p59b:'',p59c:'',p59d:'',p59e:'',p59f:'',p5a0:'',
      p5a1:'',p5a2:'',p5a3:'',p5a4:'',p5a5:'',p5a6:'',p5a7:'',p5a8:'',
      p5a9:'',p5aa:'',p5ab:'',p5ac:'',p5ad:'',p5ae:'',p5af:'',p5b0:'',
      p5b1:'',p5b2:'',p5b3:'',p5b4:'',p5b5:'',p5b6:'',p5b7:'',p5b8:'',
      p5b9:'',p5ba:'',p5bb:'',p5bc:'',p5bd:'',p5be:'',p5bf:'',p5c0:'',
      p5c1:'',p5c2:'',p5c3:'',p5c4:'',p5c5:'',p5c6:'',p5c7:'',p5c8:'',
      p5c9:'',p5ca:'',p5cb:'',p5cc:'',p5cd:'',p5ce:'',p5cf:'',p5d0:'',
      p5d1:'',p5d2:'',p5d3:'',p5d4:'',p5d5:'',p5d6:'',p5d7:'',p5d8:'',
      p5d9:'',p5da:'',p5db:'',p5dc:'',p5dd:'',p5de:'',p5df:'',p5e0:'',
      p5e1:'',p5e2:'',p5e3:'',p5e4:'',p5e5:'',p5e6:'',p5e7:'',p5e8:'',
      p5e9:'',p5ea:'',p5eb:'',p5ec:'',p5ed:'',p5ee:'',p5ef:'',p5f0:'',
      p5f1:'',p5f2:'',p5f3:'',p5f4:'',p5f5:'',p5f6:'',p5f7:'',p5f8:'',
      p5f9:'',p5fa:'',p5fb:'',p5fc:'',p5fd:'',p5fe:'',p5ff:'',p600:'',
      p601:'',p602:'',p603:'',p604:'',p605:'',p606:'',p607:'',p608:'',
      p609:'',p60a:'',p60b:'',p60c:'',p60d:'',p60e:'',p60f:'',p610:'',
      p611:'',p612:'',p613:'',p614:'',p615:'',p616:'',p617:'',p618:'',
      p619:'',p61a:'',p61b:'',p61c:'',p61d:'',p61e:'',p61f:'',p620:'',
      p621:'',p622:'',p623:'',p624:'',p625:'',p626:'',p627:'',p628:'',
      p629:'',p62a:'',p62b:'',p62c:'',p62d:'',p62e:'',p62f:'',p630:'',
      p631:'',p632:'',p633:'',p634:'',p635:'',p636:'',p637:'',p638:'',
      p639:'',p63a:'',p63b:'',p63c:'',p63d:'',p63e:'',p63f:'',p640:'',
      p641:'',p642:'',p643:'',p644:'',p645:'',p646:'',p647:'',p648:'',
      p649:'',p64a:'',p64b:'',p64c:'',p64d:'',p64e:'',p64f:'',p650:'',
      p651:'',p652:'',p653:'',p654:'',p655:'',p656:'',p657:'',p658:'',
      p659:'',p65a:'',p65b:'',p65c:'',p65d:'',p65e:'',p65f:'',p660:'',
      p661:'',p662:'',p663:'',p664:'',p665:'',p666:'',p667:'',p668:'',
      p669:'',p66a:'',p66b:'',p66c:'',p66d:'',p66e:'',p66f:'',p670:'',
      p671:'',p672:'',p673:'',p674:'',p675:'',p676:'',p677:'',p678:'',
      p679:'',p67a:'',p67b:'',p67c:'',p67d:'',p67e:'',p67f:'',p680:'',
      p681:'',p682:'',p683:'',p684:'',p685:'',p686:'',p687:'',p688:'',
      p689:'',p68a:'',p68b:'',p68c:'',p68d:'',p68e:'',p68f:'',p690:'',
      p691:'',p692:'',p693:'',p694:'',p695:'',p696:'',p697:'',p698:'',
      p699:'',p69a:'',p69b:'',p69c:'',p69d:'',p69e:'',p69f:'',p6a0:'',
      p6a1:'',p6a2:'',p6a3:'',p6a4:'',p6a5:'',p6a6:'',p6a7:'',p6a8:'',
      p6a9:'',p6aa:'',p6ab:'',p6ac:'',p6ad:'',p6ae:'',p6af:'',p6b0:'',
      p6b1:'',p6b2:'',p6b3:'',p6b4:'',p6b5:'',p6b6:'',p6b7:'',p6b8:'',
      p6b9:'',p6ba:'',p6bb:'',p6bc:'',p6bd:'',p6be:'',p6bf:'',p6c0:'',
      p6c1:'',p6c2:'',p6c3:'',p6c4:'',p6c5:'',p6c6:'',p6c7:'',p6c8:'',
      p6c9:'',p6ca:'',p6cb:'',p6cc:'',p6cd:'',p6ce:'',p6cf:'',p6d0:'',
      p6d1:'',p6d2:'',p6d3:'',p6d4:'',p6d5:'',p6d6:'',p6d7:'',p6d8:'',
      p6d9:'',p6da:'',p6db:'',p6dc:'',p6dd:'',p6de:'',p6df:'',p6e0:'',
      p6e1:'',p6e2:'',p6e3:'',p6e4:'',p6e5:'',p6e6:'',p6e7:'',p6e8:'',
      p6e9:'',p6ea:'',p6eb:'',p6ec:'',p6ed:'',p6ee:'',p6ef:'',p6f0:'',
      p6f1:'',p6f2:'',p6f3:'',p6f4:'',p6f5:'',p6f6:'',p6f7:'',p6f8:'',
      p6f9:'',p6fa:'',p6fb:'',p6fc:'',p6fd:'',p6fe:'',p6ff:'',p700:'',
      p701:'',p702:'',p703:'',p704:'',p705:'',p706:'',p707:'',p708:'',
      p709:'',p70a:'',p70b:'',p70c:'',p70d:'',p70e:'',p70f:'',p710:'',
      p711:'',p712:'',p713:'',p714:'',p715:'',p716:'',p717:'',p718:'',
      p719:'',p71a:'',p71b:'',p71c:'',p71d:'',p71e:'',p71f:'',p720:'',
      p721:'',p722:'',p723:'',p724:'',p725:'',p726:'',p727:'',p728:'',
      p729:'',p72a:'',p72b:'',p72c:'',p72d:'',p72e:'',p72f:'',p730:'',
      p731:'',p732:'',p733:'',p734:'',p735:'',p736:'',p737:'',p738:'',
      p739:'',p73a:'',p73b:'',p73c:'',p73d:'',p73e:'',p73f:'',p740:'',
      p741:'',p742:'',p743:'',p744:'',p745:'',p746:'',p747:'',p748:'',
      p749:'',p74a:'',p74b:'',p74c:'',p74d:'',p74e:'',p74f:'',p750:'',
      p751:'',p752:'',p753:'',p754:'',p755:'',p756:'',p757:'',p758:'',
      p759:'',p75a:'',p75b:'',p75c:'',p75d:'',p75e:'',p75f:'',p760:'',
      p761:'',p762:'',p763:'',p764:'',p765:'',p766:'',p767:'',p768:'',
      p769:'',p76a:'',p76b:'',p76c:'',p76d:'',p76e:'',p76f:'',p770:'',
      p771:'',p772:'',p773:'',p774:'',p775:'',p776:'',p777:'',p778:'',
      p779:'',p77a:'',p77b:'',p77c:'',p77d:'',p77e:'',p77f:'',p780:'',
      p781:'',p782:'',p783:'',p784:'',p785:'',p786:'',p787:'',p788:'',
      p789:'',p78a:'',p78b:'',p78c:'',p78d:'',p78e:'',p78f:'',p790:'',
      p791:'',p792:'',p793:'',p794:'',p795:'',p796:'',p797:'',p798:'',
      p799:'',p79a:'',p79b:'',p79c:'',p79d:'',p79e:'',p79f:'',p7a0:'',
      p7a1:'',p7a2:'',p7a3:'',p7a4:'',p7a5:'',p7a6:'',p7a7:'',p7a8:'',
      p7a9:'',p7aa:'',p7ab:'',p7ac:'',p7ad:'',p7ae:'',p7af:'',p7b0:'',
      p7b1:'',p7b2:'',p7b3:'',p7b4:'',p7b5:'',p7b6:'',p7b7:'',p7b8:'',
      p7b9:'',p7ba:'',p7bb:'',p7bc:'',p7bd:'',p7be:'',p7bf:'',p7c0:'',
      p7c1:'',p7c2:'',p7c3:'',p7c4:'',p7c5:'',p7c6:'',p7c7:'',p7c8:'',
      p7c9:'',p7ca:'',p7cb:'',p7cc:'',p7cd:'',p7ce:'',p7cf:'',p7d0:'',
      p7d1:'',p7d2:'',p7d3:'',p7d4:'',p7d5:'',p7d6:'',p7d7:'',p7d8:'',
      p7d9:'',p7da:'',p7db:'',p7dc:'',p7dd:'',p7de:'',p7df:'',p7e0:'',
      p7e1:'',p7e2:'',p7e3:'',p7e4:'',p7e5:'',p7e6:'',p7e7:'',p7e8:'',
      p7e9:'',p7ea:'',p7eb:'',p7ec:'',p7ed:'',p7ee:'',p7ef:'',p7f0:'',
      p7f1:'',p7f2:'',p7f3:'',p7f4:'',p7f5:'',p7f6:'',p7f7:'',p7f8:'',
      p7f9:'',p7fa:'',p7fb:'',p7fc:'',p7fd:'',p7fe:'',p7ff:'',p800:'',
      p801:'',p802:'',p803:'',p804:'',p805:'',p806:'',p807:'',p808:'',
      p809:'',p80a:'',p80b:'',p80c:'',p80d:'',p80e:'',p80f:'',p810:'',
      p811:'',p812:'',p813:'',p814:'',p815:'',p816:'',p817:'',p818:'',
      p819:'',p81a:'',p81b:'',p81c:'',p81d:'',p81e:'',p81f:'',p820:'',
      p821:'',p822:'',p823:'',p824:'',p825:'',p826:'',p827:'',p828:'',
      p829:'',p82a:'',p82b:'',p82c:'',p82d:'',p82e:'',p82f:'',p830:'',
      p831:'',p832:'',p833:'',p834:'',p835:'',p836:'',p837:'',p838:'',
      p839:'',p83a:'',p83b:'',p83c:'',p83d:'',p83e:'',p83f:'',p840:'',
      p841:'',p842:'',p843:'',p844:'',p845:'',p846:'',p847:'',p848:'',
      p849:'',p84a:'',p84b:'',p84c:'',p84d:'',p84e:'',p84f:'',p850:'',
      p851:'',p852:'',p853:'',p854:'',p855:'',p856:'',p857:'',p858:'',
      p859:'',p85a:'',p85b:'',p85c:'',p85d:'',p85e:'',p85f:'',p860:'',
      p861:'',p862:'',p863:'',p864:'',p865:'',p866:'',p867:'',p868:'',
      p869:'',p86a:'',p86b:'',p86c:'',p86d:'',p86e:'',p86f:'',p870:'',
      p871:'',p872:'',p873:'',p874:'',p875:'',p876:'',p877:'',p878:'',
      p879:'',p87a:'',p87b:'',p87c:'',p87d:'',p87e:'',p87f:'',p880:'',
      p881:'',p882:'',p883:'',p884:'',p885:'',p886:'',p887:'',p888:'',
      p889:'',p88a:'',p88b:'',p88c:'',p88d:'',p88e:'',p88f:'',p890:'',
      p891:'',p892:'',p893:'',p894:'',p895:'',p896:'',p897:'',p898:'',
      p899:'',p89a:'',p89b:'',p89c:'',p89d:'',p89e:'',p89f:'',p8a0:'',
      p8a1:'',p8a2:'',p8a3:'',p8a4:'',p8a5:'',p8a6:'',p8a7:'',p8a8:'',
      p8a9:'',p8aa:'',p8ab:'',p8ac:'',p8ad:'',p8ae:'',p8af:'',p8b0:'',
      p8b1:'',p8b2:'',p8b3:'',p8b4:'',p8b5:'',p8b6:'',p8b7:'',p8b8:'',
      p8b9:'',p8ba:'',p8bb:'',p8bc:'',p8bd:'',p8be:'',p8bf:'',p8c0:'',
      p8c1:'',p8c2:'',p8c3:'',p8c4:'',p8c5:'',p8c6:'',p8c7:'',p8c8:'',
      p8c9:'',p8ca:'',p8cb:'',p8cc:'',p8cd:'',p8ce:'',p8cf:'',p8d0:'',
      p8d1:'',p8d2:'',p8d3:'',p8d4:'',p8d5:'',p8d6:'',p8d7:'',p8d8:'',
      p8d9:'',p8da:'',p8db:'',p8dc:'',p8dd:'',p8de:'',p8df:'',p8e0:'',
      p8e1:'',p8e2:'',p8e3:'',p8e4:'',p8e5:'',p8e6:'',p8e7:'',p8e8:'',
      p8e9:'',p8ea:'',p8eb:'',p8ec:'',p8ed:'',p8ee:'',p8ef:'',p8f0:'',
      p8f1:'',p8f2:'',p8f3:'',p8f4:'',p8f5:'',p8f6:'',p8f7:'',p8f8:'',
      p8f9:'',p8fa:'',p8fb:'',p8fc:'',p8fd:'',p8fe:'',p8ff:'',p900:'',
      p901:'',p902:'',p903:'',p904:'',p905:'',p906:'',p907:'',p908:'',
      p909:'',p90a:'',p90b:'',p90c:'',p90d:'',p90e:'',p90f:'',p910:'',
      p911:'',p912:'',p913:'',p914:'',p915:'',p916:'',p917:'',p918:'',
      p919:'',p91a:'',p91b:'',p91c:'',p91d:'',p91e:'',p91f:'',p920:'',
      p921:'',p922:'',p923:'',p924:'',p925:'',p926:'',p927:'',p928:'',
      p929:'',p92a:'',p92b:'',p92c:'',p92d:'',p92e:'',p92f:'',p930:'',
      p931:'',p932:'',p933:'',p934:'',p935:'',p936:'',p937:'',p938:'',
      p939:'',p93a:'',p93b:'',p93c:'',p93d:'',p93e:'',p93f:'',p940:'',
      p941:'',p942:'',p943:'',p944:'',p945:'',p946:'',p947:'',p948:'',
      p949:'',p94a:'',p94b:'',p94c:'',p94d:'',p94e:'',p94f:'',p950:'',
      p951:'',p952:'',p953:'',p954:'',p955:'',p956:'',p957:'',p958:'',
      p959:'',p95a:'',p95b:'',p95c:'',p95d:'',p95e:'',p95f:'',p960:'',
      p961:'',p962:'',p963:'',p964:'',p965:'',p966:'',p967:'',p968:'',
      p969:'',p96a:'',p96b:'',p96c:'',p96d:'',p96e:'',p96f:'',p970:'',
      p971:'',p972:'',p973:'',p974:'',p975:'',p976:'',p977:'',p978:'',
      p979:'',p97a:'',p97b:'',p97c:'',p97d:'',p97e:'',p97f:'',p980:'',
      p981:'',p982:'',p983:'',p984:'',p985:'',p986:'',p987:'',p988:'',
      p989:'',p98a:'',p98b:'',p98c:'',p98d:'',p98e:'',p98f:'',p990:'',
      p991:'',p992:'',p993:'',p994:'',p995:'',p996:'',p997:'',p998:'',
      p999:'',p99a:'',p99b:'',p99c:'',p99d:'',p99e:'',p99f:'',p9a0:'',
      p9a1:'',p9a2:'',p9a3:'',p9a4:'',p9a5:'',p9a6:'',p9a7:'',p9a8:'',
      p9a9:'',p9aa:'',p9ab:'',p9ac:'',p9ad:'',p9ae:'',p9af:'',p9b0:'',
      p9b1:'',p9b2:'',p9b3:'',p9b4:'',p9b5:'',p9b6:'',p9b7:'',p9b8:'',
      p9b9:'',p9ba:'',p9bb:'',p9bc:'',p9bd:'',p9be:'',p9bf:'',p9c0:'',
      p9c1:'',p9c2:'',p9c3:'',p9c4:'',p9c5:'',p9c6:'',p9c7:'',p9c8:'',
      p9c9:'',p9ca:'',p9cb:'',p9cc:'',p9cd:'',p9ce:'',p9cf:'',p9d0:'',
      p9d1:'',p9d2:'',p9d3:'',p9d4:'',p9d5:'',p9d6:'',p9d7:'',p9d8:'',
      p9d9:'',p9da:'',p9db:'',p9dc:'',p9dd:'',p9de:'',p9df:'',p9e0:'',
      p9e1:'',p9e2:'',p9e3:'',p9e4:'',p9e5:'',p9e6:'',p9e7:'',p9e8:'',
      p9e9:'',p9ea:'',p9eb:'',p9ec:'',p9ed:'',p9ee:'',p9ef:'',p9f0:'',
      p9f1:'',p9f2:'',p9f3:'',p9f4:'',p9f5:'',p9f6:'',p9f7:'',p9f8:'',
      p9f9:'',p9fa:'',p9fb:'',p9fc:'',p9fd:'',p9fe:'',p9ff:'',pa00:'',
      pa01:'',pa02:'',pa03:'',pa04:'',pa05:'',pa06:'',pa07:'',pa08:'',
      pa09:'',pa0a:'',pa0b:'',pa0c:'',pa0d:'',pa0e:'',pa0f:'',pa10:'',
      pa11:'',pa12:'',pa13:'',pa14:'',pa15:'',pa16:'',pa17:'',pa18:'',
      pa19:'',pa1a:'',pa1b:'',pa1c:'',pa1d:'',pa1e:'',pa1f:'',pa20:'',
      pa21:'',pa22:'',pa23:'',pa24:'',pa25:'',pa26:'',pa27:'',pa28:'',
      pa29:'',pa2a:'',pa2b:'',pa2c:'',pa2d:'',pa2e:'',pa2f:'',pa30:'',
      pa31:'',pa32:'',pa33:'',pa34:'',pa35:'',pa36:'',pa37:'',pa38:'',
      pa39:'',pa3a:'',pa3b:'',pa3c:'',pa3d:'',pa3e:'',pa3f:'',pa40:'',
      pa41:'',pa42:'',pa43:'',pa44:'',pa45:'',pa46:'',pa47:'',pa48:'',
      pa49:'',pa4a:'',pa4b:'',pa4c:'',pa4d:'',pa4e:'',pa4f:'',pa50:'',
      pa51:'',pa52:'',pa53:'',pa54:'',pa55:'',pa56:'',pa57:'',pa58:'',
      pa59:'',pa5a:'',pa5b:'',pa5c:'',pa5d:'',pa5e:'',pa5f:'',pa60:'',
      pa61:'',pa62:'',pa63:'',pa64:'',pa65:'',pa66:'',pa67:'',pa68:'',
      pa69:'',pa6a:'',pa6b:'',pa6c:'',pa6d:'',pa6e:'',pa6f:'',pa70:'',
      pa71:'',pa72:'',pa73:'',pa74:'',pa75:'',pa76:'',pa77:'',pa78:'',
      pa79:'',pa7a:'',pa7b:'',pa7c:'',pa7d:'',pa7e:'',pa7f:'',pa80:'',
      pa81:'',pa82:'',pa83:'',pa84:'',pa85:'',pa86:'',pa87:'',pa88:'',
      pa89:'',pa8a:'',pa8b:'',pa8c:'',pa8d:'',pa8e:'',pa8f:'',pa90:'',
      pa91:'',pa92:'',pa93:'',pa94:'',pa95:'',pa96:'',pa97:'',pa98:'',
      pa99:'',pa9a:'',pa9b:'',pa9c:'',pa9d:'',pa9e:'',pa9f:'',paa0:'',
      paa1:'',paa2:'',paa3:'',paa4:'',paa5:'',paa6:'',paa7:'',paa8:'',
      paa9:'',paaa:'',paab:'',paac:'',paad:'',paae:'',paaf:'',pab0:'',
      pab1:'',pab2:'',pab3:'',pab4:'',pab5:'',pab6:'',pab7:'',pab8:'',
      pab9:'',paba:'',pabb:'',pabc:'',pabd:'',pabe:'',pabf:'',pac0:'',
      pac1:'',pac2:'',pac3:'',pac4:'',pac5:'',pac6:'',pac7:'',pac8:'',
      pac9:'',paca:'',pacb:'',pacc:'',pacd:'',pace:'',pacf:'',pad0:'',
      pad1:'',pad2:'',pad3:'',pad4:'',pad5:'',pad6:'',pad7:'',pad8:'',
      pad9:'',pada:'',padb:'',padc:'',padd:'',pade:'',padf:'',pae0:'',
      pae1:'',pae2:'',pae3:'',pae4:'',pae5:'',pae6:'',pae7:'',pae8:'',
      pae9:'',paea:'',paeb:'',paec:'',paed:'',paee:'',paef:'',paf0:'',
      paf1:'',paf2:'',paf3:'',paf4:'',paf5:'',paf6:'',paf7:'',paf8:'',
      paf9:'',pafa:'',pafb:'',pafc:'',pafd:'',pafe:'',paff:'',pb00:'',
      pb01:'',pb02:'',pb03:'',pb04:'',pb05:'',pb06:'',pb07:'',pb08:'',
      pb09:'',pb0a:'',pb0b:'',pb0c:'',pb0d:'',pb0e:'',pb0f:'',pb10:'',
      pb11:'',pb12:'',pb13:'',pb14:'',pb15:'',pb16:'',pb17:'',pb18:'',
      pb19:'',pb1a:'',pb1b:'',pb1c:'',pb1d:'',pb1e:'',pb1f:'',pb20:'',
      pb21:'',pb22:'',pb23:'',pb24:'',pb25:'',pb26:'',pb27:'',pb28:'',
      pb29:'',pb2a:'',pb2b:'',pb2c:'',pb2d:'',pb2e:'',pb2f:'',pb30:'',
      pb31:'',pb32:'',pb33:'',pb34:'',pb35:'',pb36:'',pb37:'',pb38:'',
      pb39:'',pb3a:'',pb3b:'',pb3c:'',pb3d:'',pb3e:'',pb3f:'',pb40:'',
      pb41:'',pb42:'',pb43:'',pb44:'',pb45:'',pb46:'',pb47:'',pb48:'',
      pb49:'',pb4a:'',pb4b:'',pb4c:'',pb4d:'',pb4e:'',pb4f:'',pb50:'',
      pb51:'',pb52:'',pb53:'',pb54:'',pb55:'',pb56:'',pb57:'',pb58:'',
      pb59:'',pb5a:'',pb5b:'',pb5c:'',pb5d:'',pb5e:'',pb5f:'',pb60:'',
      pb61:'',pb62:'',pb63:'',pb64:'',pb65:'',pb66:'',pb67:'',pb68:'',
      pb69:'',pb6a:'',pb6b:'',pb6c:'',pb6d:'',pb6e:'',pb6f:'',pb70:'',
      pb71:'',pb72:'',pb73:'',pb74:'',pb75:'',pb76:'',pb77:'',pb78:'',
      pb79:'',pb7a:'',pb7b:'',pb7c:'',pb7d:'',pb7e:'',pb7f:'',pb80:'',
      pb81:'',pb82:'',pb83:'',pb84:'',pb85:'',pb86:'',pb87:'',pb88:'',
      pb89:'',pb8a:'',pb8b:'',pb8c:'',pb8d:'',pb8e:'',pb8f:'',pb90:'',
      pb91:'',pb92:'',pb93:'',pb94:'',pb95:'',pb96:'',pb97:'',pb98:'',
      pb99:'',pb9a:'',pb9b:'',pb9c:'',pb9d:'',pb9e:'',pb9f:'',pba0:'',
      pba1:'',pba2:'',pba3:'',pba4:'',pba5:'',pba6:'',pba7:'',pba8:'',
      pba9:'',pbaa:'',pbab:'',pbac:'',pbad:'',pbae:'',pbaf:'',pbb0:'',
      pbb1:'',pbb2:'',pbb3:'',pbb4:'',pbb5:'',pbb6:'',pbb7:'',pbb8:'',
      pbb9:'',pbba:'',pbbb:'',pbbc:'',pbbd:'',pbbe:'',pbbf:'',pbc0:'',
      pbc1:'',pbc2:'',pbc3:'',pbc4:'',pbc5:'',pbc6:'',pbc7:'',pbc8:'',
      pbc9:'',pbca:'',pbcb:'',pbcc:'',pbcd:'',pbce:'',pbcf:'',pbd0:'',
      pbd1:'',pbd2:'',pbd3:'',pbd4:'',pbd5:'',pbd6:'',pbd7:'',pbd8:'',
      pbd9:'',pbda:'',pbdb:'',pbdc:'',pbdd:'',pbde:'',pbdf:'',pbe0:'',
      pbe1:'',pbe2:'',pbe3:'',pbe4:'',pbe5:'',pbe6:'',pbe7:'',pbe8:'',
      pbe9:'',pbea:'',pbeb:'',pbec:'',pbed:'',pbee:'',pbef:'',pbf0:'',
      pbf1:'',pbf2:'',pbf3:'',pbf4:'',pbf5:'',pbf6:'',pbf7:'',pbf8:'',
      pbf9:'',pbfa:'',pbfb:'',pbfc:'',pbfd:'',pbfe:'',pbff:'',pc00:'',
      pc01:'',pc02:'',pc03:'',pc04:'',pc05:'',pc06:'',pc07:'',pc08:'',
      pc09:'',pc0a:'',pc0b:'',pc0c:'',pc0d:'',pc0e:'',pc0f:'',pc10:'',
      pc11:'',pc12:'',pc13:'',pc14:'',pc15:'',pc16:'',pc17:'',pc18:'',
      pc19:'',pc1a:'',pc1b:'',pc1c:'',pc1d:'',pc1e:'',pc1f:'',pc20:'',
      pc21:'',pc22:'',pc23:'',pc24:'',pc25:'',pc26:'',pc27:'',pc28:'',
      pc29:'',pc2a:'',pc2b:'',pc2c:'',pc2d:'',pc2e:'',pc2f:'',pc30:'',
      pc31:'',pc32:'',pc33:'',pc34:'',pc35:'',pc36:'',pc37:'',pc38:'',
      pc39:'',pc3a:'',pc3b:'',pc3c:'',pc3d:'',pc3e:'',pc3f:'',pc40:'',
      pc41:'',pc42:'',pc43:'',pc44:'',pc45:'',pc46:'',pc47:'',pc48:'',
      pc49:'',pc4a:'',pc4b:'',pc4c:'',pc4d:'',pc4e:'',pc4f:'',pc50:'',
      pc51:'',pc52:'',pc53:'',pc54:'',pc55:'',pc56:'',pc57:'',pc58:'',
      pc59:'',pc5a:'',pc5b:'',pc5c:'',pc5d:'',pc5e:'',pc5f:'',pc60:'',
      pc61:'',pc62:'',pc63:'',pc64:'',pc65:'',pc66:'',pc67:'',pc68:'',
      pc69:'',pc6a:'',pc6b:'',pc6c:'',pc6d:'',pc6e:'',pc6f:'',pc70:'',
      pc71:'',pc72:'',pc73:'',pc74:'',pc75:'',pc76:'',pc77:'',pc78:'',
      pc79:'',pc7a:'',pc7b:'',pc7c:'',pc7d:'',pc7e:'',pc7f:'',pc80:'',
      pc81:'',pc82:'',pc83:'',pc84:'',pc85:'',pc86:'',pc87:'',pc88:'',
      pc89:'',pc8a:'',pc8b:'',pc8c:'',pc8d:'',pc8e:'',pc8f:'',pc90:'',
      pc91:'',pc92:'',pc93:'',pc94:'',pc95:'',pc96:'',pc97:'',pc98:'',
      pc99:'',pc9a:'',pc9b:'',pc9c:'',pc9d:'',pc9e:'',pc9f:'',pca0:'',
      pca1:'',pca2:'',pca3:'',pca4:'',pca5:'',pca6:'',pca7:'',pca8:'',
      pca9:'',pcaa:'',pcab:'',pcac:'',pcad:'',pcae:'',pcaf:'',pcb0:'',
      pcb1:'',pcb2:'',pcb3:'',pcb4:'',pcb5:'',pcb6:'',pcb7:'',pcb8:'',
      pcb9:'',pcba:'',pcbb:'',pcbc:'',pcbd:'',pcbe:'',pcbf:'',pcc0:'',
      pcc1:'',pcc2:'',pcc3:'',pcc4:'',pcc5:'',pcc6:'',pcc7:'',pcc8:'',
      pcc9:'',pcca:'',pccb:'',pccc:'',pccd:'',pcce:'',pccf:'',pcd0:'',
      pcd1:'',pcd2:'',pcd3:'',pcd4:'',pcd5:'',pcd6:'',pcd7:'',pcd8:'',
      pcd9:'',pcda:'',pcdb:'',pcdc:'',pcdd:'',pcde:'',pcdf:'',pce0:'',
      pce1:'',pce2:'',pce3:'',pce4:'',pce5:'',pce6:'',pce7:'',pce8:'',
      pce9:'',pcea:'',pceb:'',pcec:'',pced:'',pcee:'',pcef:'',pcf0:'',
      pcf1:'',pcf2:'',pcf3:'',pcf4:'',pcf5:'',pcf6:'',pcf7:'',pcf8:'',
      pcf9:'',pcfa:'',pcfb:'',pcfc:'',pcfd:'',pcfe:'',pcff:'',pd00:'',
      pd01:'',pd02:'',pd03:'',pd04:'',pd05:'',pd06:'',pd07:'',pd08:'',
      pd09:'',pd0a:'',pd0b:'',pd0c:'',pd0d:'',pd0e:'',pd0f:'',pd10:'',
      pd11:'',pd12:'',pd13:'',pd14:'',pd15:'',pd16:'',pd17:'',pd18:'',
      pd19:'',pd1a:'',pd1b:'',pd1c:'',pd1d:'',pd1e:'',pd1f:'',pd20:'',
      pd21:'',pd22:'',pd23:'',pd24:'',pd25:'',pd26:'',pd27:'',pd28:'',
      pd29:'',pd2a:'',pd2b:'',pd2c:'',pd2d:'',pd2e:'',pd2f:'',pd30:'',
      pd31:'',pd32:'',pd33:'',pd34:'',pd35:'',pd36:'',pd37:'',pd38:'',
      pd39:'',pd3a:'',pd3b:'',pd3c:'',pd3d:'',pd3e:'',pd3f:'',pd40:'',
      pd41:'',pd42:'',pd43:'',pd44:'',pd45:'',pd46:'',pd47:'',pd48:'',
      pd49:'',pd4a:'',pd4b:'',pd4c:'',pd4d:'',pd4e:'',pd4f:'',pd50:'',
      pd51:'',pd52:'',pd53:'',pd54:'',pd55:'',pd56:'',pd57:'',pd58:'',
      pd59:'',pd5a:'',pd5b:'',pd5c:'',pd5d:'',pd5e:'',pd5f:'',pd60:'',
      pd61:'',pd62:'',pd63:'',pd64:'',pd65:'',pd66:'',pd67:'',pd68:'',
      pd69:'',pd6a:'',pd6b:'',pd6c:'',pd6d:'',pd6e:'',pd6f:'',pd70:'',
      pd71:'',pd72:'',pd73:'',pd74:'',pd75:'',pd76:'',pd77:'',pd78:'',
      pd79:'',pd7a:'',pd7b:'',pd7c:'',pd7d:'',pd7e:'',pd7f:'',pd80:'',
      pd81:'',pd82:'',pd83:'',pd84:'',pd85:'',pd86:'',pd87:'',pd88:'',
      pd89:'',pd8a:'',pd8b:'',pd8c:'',pd8d:'',pd8e:'',pd8f:'',pd90:'',
      pd91:'',pd92:'',pd93:'',pd94:'',pd95:'',pd96:'',pd97:'',pd98:'',
      pd99:'',pd9a:'',pd9b:'',pd9c:'',pd9d:'',pd9e:'',pd9f:'',pda0:'',
      pda1:'',pda2:'',pda3:'',pda4:'',pda5:'',pda6:'',pda7:'',pda8:'',
      pda9:'',pdaa:'',pdab:'',pdac:'',pdad:'',pdae:'',pdaf:'',pdb0:'',
      pdb1:'',pdb2:'',pdb3:'',pdb4:'',pdb5:'',pdb6:'',pdb7:'',pdb8:'',
      pdb9:'',pdba:'',pdbb:'',pdbc:'',pdbd:'',pdbe:'',pdbf:'',pdc0:'',
      pdc1:'',pdc2:'',pdc3:'',pdc4:'',pdc5:'',pdc6:'',pdc7:'',pdc8:'',
      pdc9:'',pdca:'',pdcb:'',pdcc:'',pdcd:'',pdce:'',pdcf:'',pdd0:'',
      pdd1:'',pdd2:'',pdd3:'',pdd4:'',pdd5:'',pdd6:'',pdd7:'',pdd8:'',
      pdd9:'',pdda:'',pddb:'',pddc:'',pddd:'',pdde:'',pddf:'',pde0:'',
      pde1:'',pde2:'',pde3:'',pde4:'',pde5:'',pde6:'',pde7:'',pde8:'',
      pde9:'',pdea:'',pdeb:'',pdec:'',pded:'',pdee:'',pdef:'',pdf0:'',
      pdf1:'',pdf2:'',pdf3:'',pdf4:'',pdf5:'',pdf6:'',pdf7:'',pdf8:'',
      pdf9:'',pdfa:'',pdfb:'',pdfc:'',pdfd:'',pdfe:'',pdff:'',pe00:'',
      pe01:'',pe02:'',pe03:'',pe04:'',pe05:'',pe06:'',pe07:'',pe08:'',
      pe09:'',pe0a:'',pe0b:'',pe0c:'',pe0d:'',pe0e:'',pe0f:'',pe10:'',
      pe11:'',pe12:'',pe13:'',pe14:'',pe15:'',pe16:'',pe17:'',pe18:'',
      pe19:'',pe1a:'',pe1b:'',pe1c:'',pe1d:'',pe1e:'',pe1f:'',pe20:'',
      pe21:'',pe22:'',pe23:'',pe24:'',pe25:'',pe26:'',pe27:'',pe28:'',
      pe29:'',pe2a:'',pe2b:'',pe2c:'',pe2d:'',pe2e:'',pe2f:'',pe30:'',
      pe31:'',pe32:'',pe33:'',pe34:'',pe35:'',pe36:'',pe37:'',pe38:'',
      pe39:'',pe3a:'',pe3b:'',pe3c:'',pe3d:'',pe3e:'',pe3f:'',pe40:'',
      pe41:'',pe42:'',pe43:'',pe44:'',pe45:'',pe46:'',pe47:'',pe48:'',
      pe49:'',pe4a:'',pe4b:'',pe4c:'',pe4d:'',pe4e:'',pe4f:'',pe50:'',
      pe51:'',pe52:'',pe53:'',pe54:'',pe55:'',pe56:'',pe57:'',pe58:'',
      pe59:'',pe5a:'',pe5b:'',pe5c:'',pe5d:'',pe5e:'',pe5f:'',pe60:'',
      pe61:'',pe62:'',pe63:'',pe64:'',pe65:'',pe66:'',pe67:'',pe68:'',
      pe69:'',pe6a:'',pe6b:'',pe6c:'',pe6d:'',pe6e:'',pe6f:'',pe70:'',
      pe71:'',pe72:'',pe73:'',pe74:'',pe75:'',pe76:'',pe77:'',pe78:'',
      pe79:'',pe7a:'',pe7b:'',pe7c:'',pe7d:'',pe7e:'',pe7f:'',pe80:'',
      pe81:'',pe82:'',pe83:'',pe84:'',pe85:'',pe86:'',pe87:'',pe88:'',
      pe89:'',pe8a:'',pe8b:'',pe8c:'',pe8d:'',pe8e:'',pe8f:'',pe90:'',
      pe91:'',pe92:'',pe93:'',pe94:'',pe95:'',pe96:'',pe97:'',pe98:'',
      pe99:'',pe9a:'',pe9b:'',pe9c:'',pe9d:'',pe9e:'',pe9f:'',pea0:'',
      pea1:'',pea2:'',pea3:'',pea4:'',pea5:'',pea6:'',pea7:'',pea8:'',
      pea9:'',peaa:'',peab:'',peac:'',pead:'',peae:'',peaf:'',peb0:'',
      peb1:'',peb2:'',peb3:'',peb4:'',peb5:'',peb6:'',peb7:'',peb8:'',
      peb9:'',peba:'',pebb:'',pebc:'',pebd:'',pebe:'',pebf:'',pec0:'',
      pec1:'',pec2:'',pec3:'',pec4:'',pec5:'',pec6:'',pec7:'',pec8:'',
      pec9:'',peca:'',pecb:'',pecc:'',pecd:'',pece:'',pecf:'',ped0:'',
      ped1:'',ped2:'',ped3:'',ped4:'',ped5:'',ped6:'',ped7:'',ped8:'',
      ped9:'',peda:'',pedb:'',pedc:'',pedd:'',pede:'',pedf:'',pee0:'',
      pee1:'',pee2:'',pee3:'',pee4:'',pee5:'',pee6:'',pee7:'',pee8:'',
      pee9:'',peea:'',peeb:'',peec:'',peed:'',peee:'',peef:'',pef0:'',
      pef1:'',pef2:'',pef3:'',pef4:'',pef5:'',pef6:'',pef7:'',pef8:'',
      pef9:'',pefa:'',pefb:'',pefc:'',pefd:'',pefe:'',peff:'',pf00:'',
      pf01:'',pf02:'',pf03:'',pf04:'',pf05:'',pf06:'',pf07:'',pf08:'',
      pf09:'',pf0a:'',pf0b:'',pf0c:'',pf0d:'',pf0e:'',pf0f:'',pf10:'',
      pf11:'',pf12:'',pf13:'',pf14:'',pf15:'',pf16:'',pf17:'',pf18:'',
      pf19:'',pf1a:'',pf1b:'',pf1c:'',pf1d:'',pf1e:'',pf1f:'',pf20:'',
      pf21:'',pf22:'',pf23:'',pf24:'',pf25:'',pf26:'',pf27:'',pf28:'',
      pf29:'',pf2a:'',pf2b:'',pf2c:'',pf2d:'',pf2e:'',pf2f:'',pf30:'',
      pf31:'',pf32:'',pf33:'',pf34:'',pf35:'',pf36:'',pf37:'',pf38:'',
      pf39:'',pf3a:'',pf3b:'',pf3c:'',pf3d:'',pf3e:'',pf3f:'',pf40:'',
      pf41:'',pf42:'',pf43:'',pf44:'',pf45:'',pf46:'',pf47:'',pf48:'',
      pf49:'',pf4a:'',pf4b:'',pf4c:'',pf4d:'',pf4e:'',pf4f:'',pf50:'',
      pf51:'',pf52:'',pf53:'',pf54:'',pf55:'',pf56:'',pf57:'',pf58:'',
      pf59:'',pf5a:'',pf5b:'',pf5c:'',pf5d:'',pf5e:'',pf5f:'',pf60:'',
      pf61:'',pf62:'',pf63:'',pf64:'',pf65:'',pf66:'',pf67:'',pf68:'',
      pf69:'',pf6a:'',pf6b:'',pf6c:'',pf6d:'',pf6e:'',pf6f:'',pf70:'',
      pf71:'',pf72:'',pf73:'',pf74:'',pf75:'',pf76:'',pf77:'',pf78:'',
      pf79:'',pf7a:'',pf7b:'',pf7c:'',pf7d:'',pf7e:'',pf7f:'',pf80:'',
      pf81:'',pf82:'',pf83:'',pf84:'',pf85:'',pf86:'',pf87:'',pf88:'',
      pf89:'',pf8a:'',pf8b:'',pf8c:'',pf8d:'',pf8e:'',pf8f:'',pf90:'',
      pf91:'',pf92:'',pf93:'',pf94:'',pf95:'',pf96:'',pf97:'',pf98:'',
      pf99:'',pf9a:'',pf9b:'',pf9c:'',pf9d:'',pf9e:'',pf9f:'',pfa0:'',
      pfa1:'',pfa2:'',pfa3:'',pfa4:'',pfa5:'',pfa6:'',pfa7:'',pfa8:'',
      pfa9:'',pfaa:'',pfab:'',pfac:'',pfad:'',pfae:'',pfaf:'',pfb0:'',
      pfb1:'',pfb2:'',pfb3:'',pfb4:'',pfb5:'',pfb6:'',pfb7:'',pfb8:'',
      pfb9:'',pfba:'',pfbb:'',pfbc:'',pfbd:'',pfbe:'',pfbf:'',pfc0:'',
      pfc1:'',pfc2:'',pfc3:'',pfc4:'',pfc5:'',pfc6:'',pfc7:'',pfc8:'',
      pfc9:'',pfca:'',pfcb:'',pfcc:'',pfcd:'',pfce:'',pfcf:'',pfd0:'',
      pfd1:'',pfd2:'',pfd3:'',pfd4:'',pfd5:'',pfd6:'',pfd7:'',pfd8:'',
      pfd9:'',pfda:'',pfdb:'',pfdc:'',pfdd:'',pfde:'',pfdf:'',pfe0:'',
      pfe1:'',pfe2:'',pfe3:'',pfe4:'',pfe5:'',pfe6:'',pfe7:'',pfe8:'',
      pfe9:'',pfea:'',pfeb:'',pfec:'',pfed:'',pfee:'',pfef:'',pff0:'',
      pff1:'',pff2:'',pff3:'',pff4:'',pff5:'',pff6:'',pff7:'',pff8:'',
      pff9:'',pffa:'',pffb:'',pffc:'',pffd:'',pffe:'',pfff:'',p1000:'',
      p1001:'',p1002:'',p1003:'',p1004:'',p1005:'',p1006:'',p1007:'',p1008:'',
      p1009:'',p100a:'',p100b:'',p100c:'',p100d:'',p100e:'',p100f:'',p1010:'',
      p1011:'',p1012:'',p1013:'',p1014:'',p1015:'',p1016:'',p1017:'',p1018:'',
      p1019:'',p101a:'',p101b:'',p101c:'',p101d:'',p101e:'',p101f:'',p1020:'',
      p1021:'',p1022:'',p1023:'',p1024:'',p1025:'',p1026:'',p1027:'',p1028:'',
      p1029:'',p102a:'',p102b:'',p102c:'',p102d:'',p102e:'',p102f:'',p1030:'',
      p1031:'',p1032:'',p1033:'',p1034:'',p1035:'',p1036:'',p1037:'',p1038:'',
      p1039:'',p103a:'',p103b:'',p103c:'',p103d:'',p103e:'',p103f:'',p1040:'',
      p1041:'',p1042:'',p1043:'',p1044:'',p1045:'',p1046:'',p1047:'',p1048:'',
      p1049:'',p104a:'',p104b:'',p104c:'',p104d:'',p104e:'',p104f:'',p1050:'',
      p1051:'',p1052:'',p1053:'',p1054:'',p1055:'',p1056:'',p1057:'',p1058:'',
      p1059:'',p105a:'',p105b:'',p105c:'',p105d:'',p105e:'',p105f:'',p1060:'',
      p1061:'',p1062:'',p1063:'',p1064:'',p1065:'',p1066:'',p1067:'',p1068:'',
      p1069:'',p106a:'',p106b:'',p106c:'',p106d:'',p106e:'',p106f:'',p1070:'',
      p1071:'',p1072:'',p1073:'',p1074:'',p1075:'',p1076:'',p1077:'',p1078:'',
      p1079:'',p107a:'',p107b:'',p107c:'',p107d:'',p107e:'',p107f:'',p1080:'',
      p1081:'',p1082:'',p1083:'',p1084:'',p1085:'',p1086:'',p1087:'',p1088:'',
      p1089:'',p108a:'',p108b:'',p108c:'',p108d:'',p108e:'',p108f:'',p1090:'',
      p1091:'',p1092:'',p1093:'',p1094:'',p1095:'',p1096:'',p1097:'',p1098:'',
      p1099:'',p109a:'',p109b:'',p109c:'',p109d:'',p109e:'',p109f:'',p10a0:'',
      p10a1:'',p10a2:'',p10a3:'',p10a4:'',p10a5:'',p10a6:'',p10a7:'',p10a8:'',
      p10a9:'',p10aa:'',p10ab:'',p10ac:'',p10ad:'',p10ae:'',p10af:'',p10b0:'',
      p10b1:'',p10b2:'',p10b3:'',p10b4:'',p10b5:'',p10b6:'',p10b7:'',p10b8:'',
      p10b9:'',p10ba:'',p10bb:'',p10bc:'',p10bd:'',p10be:'',p10bf:'',p10c0:'',
      p10c1:'',p10c2:'',p10c3:'',p10c4:'',p10c5:'',p10c6:'',p10c7:'',p10c8:'',
      p10c9:'',p10ca:'',p10cb:'',p10cc:'',p10cd:'',p10ce:'',p10cf:'',p10d0:'',
      p10d1:'',p10d2:'',p10d3:'',p10d4:'',p10d5:'',p10d6:'',p10d7:'',p10d8:'',
      p10d9:'',p10da:'',p10db:'',p10dc:'',p10dd:'',p10de:'',p10df:'',p10e0:'',
      p10e1:'',p10e2:'',p10e3:'',p10e4:'',p10e5:'',p10e6:'',p10e7:'',p10e8:'',
      p10e9:'',p10ea:'',p10eb:'',p10ec:'',p10ed:'',p10ee:'',p10ef:'',p10f0:'',
      p10f1:'',p10f2:'',p10f3:'',p10f4:'',p10f5:'',p10f6:'',p10f7:'',p10f8:'',
      p10f9:'',p10fa:'',p10fb:'',p10fc:'',p10fd:'',p10fe:'',p10ff:'',p1100:'',
      p1101:'',p1102:'',p1103:'',p1104:'',p1105:'',p1106:'',p1107:'',p1108:'',
      p1109:'',p110a:'',p110b:'',p110c:'',p110d:'',p110e:'',p110f:'',p1110:'',
      p1111:'',p1112:'',p1113:'',p1114:'',p1115:'',p1116:'',p1117:'',p1118:'',
      p1119:'',p111a:'',p111b:'',p111c:'',p111d:'',p111e:'',p111f:'',p1120:'',
      p1121:'',p1122:'',p1123:'',p1124:'',p1125:'',p1126:'',p1127:'',p1128:'',
      p1129:'',p112a:'',p112b:'',p112c:'',p112d:'',p112e:'',p112f:'',p1130:'',
      p1131:'',p1132:'',p1133:'',p1134:'',p1135:'',p1136:'',p1137:'',p1138:'',
      p1139:'',p113a:'',p113b:'',p113c:'',p113d:'',p113e:'',p113f:'',p1140:'',
      p1141:'',p1142:'',p1143:'',p1144:'',p1145:'',p1146:'',p1147:'',p1148:'',
      p1149:'',p114a:'',p114b:'',p114c:'',p114d:'',p114e:'',p114f:'',p1150:'',
      p1151:'',p1152:'',p1153:'',p1154:'',p1155:'',p1156:'',p1157:'',p1158:'',
      p1159:'',p115a:'',p115b:'',p115c:'',p115d:'',p115e:'',p115f:'',p1160:'',
      p1161:'',p1162:'',p1163:'',p1164:'',p1165:'',p1166:'',p1167:'',p1168:'',
      p1169:'',p116a:'',p116b:'',p116c:'',p116d:'',p116e:'',p116f:'',p1170:'',
      p1171:'',p1172:'',p1173:'',p1174:'',p1175:'',p1176:'',p1177:'',p1178:'',
      p1179:'',p117a:'',p117b:'',p117c:'',p117d:'',p117e:'',p117f:'',p1180:'',
      p1181:'',p1182:'',p1183:'',p1184:'',p1185:'',p1186:'',p1187:'',p1188:'',
      p1189:'',p118a:'',p118b:'',p118c:'',p118d:'',p118e:'',p118f:'',p1190:'',
      p1191:'',p1192:'',p1193:'',p1194:'',p1195:'',p1196:'',p1197:'',p1198:'',
      p1199:'',p119a:'',p119b:'',p119c:'',p119d:'',p119e:'',p119f:'',p11a0:'',
      p11a1:'',p11a2:'',p11a3:'',p11a4:'',p11a5:'',p11a6:'',p11a7:'',p11a8:'',
      p11a9:'',p11aa:'',p11ab:'',p11ac:'',p11ad:'',p11ae:'',p11af:'',p11b0:'',
      p11b1:'',p11b2:'',p11b3:'',p11b4:'',p11b5:'',p11b6:'',p11b7:'',p11b8:'',
      p11b9:'',p11ba:'',p11bb:'',p11bc:'',p11bd:'',p11be:'',p11bf:'',p11c0:'',
      p11c1:'',p11c2:'',p11c3:'',p11c4:'',p11c5:'',p11c6:'',p11c7:'',p11c8:'',
      p11c9:'',p11ca:'',p11cb:'',p11cc:'',p11cd:'',p11ce:'',p11cf:'',p11d0:'',
      p11d1:'',p11d2:'',p11d3:'',p11d4:'',p11d5:'',p11d6:'',p11d7:'',p11d8:'',
      p11d9:'',p11da:'',p11db:'',p11dc:'',p11dd:'',p11de:'',p11df:'',p11e0:'',
      p11e1:'',p11e2:'',p11e3:'',p11e4:'',p11e5:'',p11e6:'',p11e7:'',p11e8:'',
      p11e9:'',p11ea:'',p11eb:'',p11ec:'',p11ed:'',p11ee:'',p11ef:'',p11f0:'',
      p11f1:'',p11f2:'',p11f3:'',p11f4:'',p11f5:'',p11f6:'',p11f7:'',p11f8:'',
      p11f9:'',p11fa:'',p11fb:'',p11fc:'',p11fd:'',p11fe:'',p11ff:'',p1200:'',
      p1201:'',p1202:'',p1203:'',p1204:'',p1205:'',p1206:'',p1207:'',p1208:'',
      p1209:'',p120a:'',p120b:'',p120c:'',p120d:'',p120e:'',p120f:'',p1210:'',
      p1211:'',p1212:'',p1213:'',p1214:'',p1215:'',p1216:'',p1217:'',p1218:'',
      p1219:'',p121a:'',p121b:'',p121c:'',p121d:'',p121e:'',p121f:'',p1220:'',
      p1221:'',p1222:'',p1223:'',p1224:'',p1225:'',p1226:'',p1227:'',p1228:'',
      p1229:'',p122a:'',p122b:'',p122c:'',p122d:'',p122e:'',p122f:'',p1230:'',
      p1231:'',p1232:'',p1233:'',p1234:'',p1235:'',p1236:'',p1237:'',p1238:'',
      p1239:'',p123a:'',p123b:'',p123c:'',p123d:'',p123e:'',p123f:'',p1240:'',
      p1241:'',p1242:'',p1243:'',p1244:'',p1245:'',p1246:'',p1247:'',p1248:'',
      p1249:'',p124a:'',p124b:'',p124c:'',p124d:'',p124e:'',p124f:'',p1250:'',
      p1251:'',p1252:'',p1253:'',p1254:'',p1255:'',p1256:'',p1257:'',p1258:'',
      p1259:'',p125a:'',p125b:'',p125c:'',p125d:'',p125e:'',p125f:'',p1260:'',
      p1261:'',p1262:'',p1263:'',p1264:'',p1265:'',p1266:'',p1267:'',p1268:'',
      p1269:'',p126a:'',p126b:'',p126c:'',p126d:'',p126e:'',p126f:'',p1270:'',
      p1271:'',p1272:'',p1273:'',p1274:'',p1275:'',p1276:'',p1277:'',p1278:'',
      p1279:'',p127a:'',p127b:'',p127c:'',p127d:'',p127e:'',p127f:'',p1280:'',
      p1281:'',p1282:'',p1283:'',p1284:'',p1285:'',p1286:'',p1287:'',p1288:'',
      p1289:'',p128a:'',p128b:'',p128c:'',p128d:'',p128e:'',p128f:'',p1290:'',
      p1291:'',p1292:'',p1293:'',p1294:'',p1295:'',p1296:'',p1297:'',p1298:'',
      p1299:'',p129a:'',p129b:'',p129c:'',p129d:'',p129e:'',p129f:'',p12a0:'',
      p12a1:'',p12a2:'',p12a3:'',p12a4:'',p12a5:'',p12a6:'',p12a7:'',p12a8:'',
      p12a9:'',p12aa:'',p12ab:'',p12ac:'',p12ad:'',p12ae:'',p12af:'',p12b0:'',
      p12b1:'',p12b2:'',p12b3:'',p12b4:'',p12b5:'',p12b6:'',p12b7:'',p12b8:'',
      p12b9:'',p12ba:'',p12bb:'',p12bc:'',p12bd:'',p12be:'',p12bf:'',p12c0:'',
      p12c1:'',p12c2:'',p12c3:'',p12c4:'',p12c5:'',p12c6:'',p12c7:'',p12c8:'',
      p12c9:'',p12ca:'',p12cb:'',p12cc:'',p12cd:'',p12ce:'',p12cf:'',p12d0:'',
      p12d1:'',p12d2:'',p12d3:'',p12d4:'',p12d5:'',p12d6:'',p12d7:'',p12d8:'',
      p12d9:'',p12da:'',p12db:'',p12dc:'',p12dd:'',p12de:'',p12df:'',p12e0:'',
      p12e1:'',p12e2:'',p12e3:'',p12e4:'',p12e5:'',p12e6:'',p12e7:'',p12e8:'',
      p12e9:'',p12ea:'',p12eb:'',p12ec:'',p12ed:'',p12ee:'',p12ef:'',p12f0:'',
      p12f1:'',p12f2:'',p12f3:'',p12f4:'',p12f5:'',p12f6:'',p12f7:'',p12f8:'',
      p12f9:'',p12fa:'',p12fb:'',p12fc:'',p12fd:'',p12fe:'',p12ff:'',p1300:'',
      p1301:'',p1302:'',p1303:'',p1304:'',p1305:'',p1306:'',p1307:'',p1308:'',
      p1309:'',p130a:'',p130b:'',p130c:'',p130d:'',p130e:'',p130f:'',p1310:'',
      p1311:'',p1312:'',p1313:'',p1314:'',p1315:'',p1316:'',p1317:'',p1318:'',
      p1319:'',p131a:'',p131b:'',p131c:'',p131d:'',p131e:'',p131f:'',p1320:'',
      p1321:'',p1322:'',p1323:'',p1324:'',p1325:'',p1326:'',p1327:'',p1328:'',
      p1329:'',p132a:'',p132b:'',p132c:'',p132d:'',p132e:'',p132f:'',p1330:'',
      p1331:'',p1332:'',p1333:'',p1334:'',p1335:'',p1336:'',p1337:'',p1338:'',
      p1339:'',p133a:'',p133b:'',p133c:'',p133d:'',p133e:'',p133f:'',p1340:'',
      p1341:'',p1342:'',p1343:'',p1344:'',p1345:'',p1346:'',p1347:'',p1348:'',
      p1349:'',p134a:'',p134b:'',p134c:'',p134d:'',p134e:'',p134f:'',p1350:'',
      p1351:'',p1352:'',p1353:'',p1354:'',p1355:'',p1356:'',p1357:'',p1358:'',
      p1359:'',p135a:'',p135b:'',p135c:'',p135d:'',p135e:'',p135f:'',p1360:'',
      p1361:'',p1362:'',p1363:'',p1364:'',p1365:'',p1366:'',p1367:'',p1368:'',
      p1369:'',p136a:'',p136b:'',p136c:'',p136d:'',p136e:'',p136f:'',p1370:'',
      p1371:'',p1372:'',p1373:'',p1374:'',p1375:'',p1376:'',p1377:'',p1378:'',
      p1379:'',p137a:'',p137b:'',p137c:'',p137d:'',p137e:'',p137f:'',p1380:'',
      p1381:'',p1382:'',p1383:'',p1384:'',p1385:'',p1386:'',p1387:'',p1388:'',
      p1389:'',p138a:'',p138b:'',p138c:'',p138d:'',p138e:'',p138f:'',p1390:'',
      p1391:'',p1392:'',p1393:'',p1394:'',p1395:'',p1396:'',p1397:'',p1398:'',
      p1399:'',p139a:'',p139b:'',p139c:'',p139d:'',p139e:'',p139f:'',p13a0:'',
      p13a1:'',p13a2:'',p13a3:'',p13a4:'',p13a5:'',p13a6:'',p13a7:'',p13a8:'',
      p13a9:'',p13aa:'',p13ab:'',p13ac:'',p13ad:'',p13ae:'',p13af:'',p13b0:'',
      p13b1:'',p13b2:'',p13b3:'',p13b4:'',p13b5:'',p13b6:'',p13b7:'',p13b8:'',
      p13b9:'',p13ba:'',p13bb:'',p13bc:'',p13bd:'',p13be:'',p13bf:'',p13c0:'',
      p13c1:'',p13c2:'',p13c3:'',p13c4:'',p13c5:'',p13c6:'',p13c7:'',p13c8:'',
      p13c9:'',p13ca:'',p13cb:'',p13cc:'',p13cd:'',p13ce:'',p13cf:'',p13d0:'',
      p13d1:'',p13d2:'',p13d3:'',p13d4:'',p13d5:'',p13d6:'',p13d7:'',p13d8:'',
      p13d9:'',p13da:'',p13db:'',p13dc:'',p13dd:'',p13de:'',p13df:'',p13e0:'',
      p13e1:'',p13e2:'',p13e3:'',p13e4:'',p13e5:'',p13e6:'',p13e7:'',p13e8:'',
      p13e9:'',p13ea:'',p13eb:'',p13ec:'',p13ed:'',p13ee:'',p13ef:'',p13f0:'',
      p13f1:'',p13f2:'',p13f3:'',p13f4:'',p13f5:'',p13f6:'',p13f7:'',p13f8:'',
      p13f9:'',p13fa:'',p13fb:'',p13fc:'',p13fd:'',p13fe:'',p13ff:'',p1400:'',
      p1401:'',p1402:'',p1403:'',p1404:'',p1405:'',p1406:'',p1407:'',p1408:'',
      p1409:'',p140a:'',p140b:'',p140c:'',p140d:'',p140e:'',p140f:'',p1410:'',
      p1411:'',p1412:'',p1413:'',p1414:'',p1415:'',p1416:'',p1417:'',p1418:'',
      p1419:'',p141a:'',p141b:'',p141c:'',p141d:'',p141e:'',p141f:'',p1420:'',
      p1421:'',p1422:'',p1423:'',p1424:'',p1425:'',p1426:'',p1427:'',p1428:'',
      p1429:'',p142a:'',p142b:'',p142c:'',p142d:'',p142e:'',p142f:'',p1430:'',
      p1431:'',p1432:'',p1433:'',p1434:'',p1435:'',p1436:'',p1437:'',p1438:'',
      p1439:'',p143a:'',p143b:'',p143c:'',p143d:'',p143e:'',p143f:'',p1440:'',
      p1441:'',p1442:'',p1443:'',p1444:'',p1445:'',p1446:'',p1447:'',p1448:'',
      p1449:'',p144a:'',p144b:'',p144c:'',p144d:'',p144e:'',p144f:'',p1450:'',
      p1451:'',p1452:'',p1453:'',p1454:'',p1455:'',p1456:'',p1457:'',p1458:'',
      p1459:'',p145a:'',p145b:'',p145c:'',p145d:'',p145e:'',p145f:'',p1460:'',
      p1461:'',p1462:'',p1463:'',p1464:'',p1465:'',p1466:'',p1467:'',p1468:'',
      p1469:'',p146a:'',p146b:'',p146c:'',p146d:'',p146e:'',p146f:'',p1470:'',
      p1471:'',p1472:'',p1473:'',p1474:'',p1475:'',p1476:'',p1477:'',p1478:'',
      p1479:'',p147a:'',p147b:'',p147c:'',p147d:'',p147e:'',p147f:'',p1480:'',
      p1481:'',p1482:'',p1483:'',p1484:'',p1485:'',p1486:'',p1487:'',p1488:'',
      p1489:'',p148a:'',p148b:'',p148c:'',p148d:'',p148e:'',p148f:'',p1490:'',
      p1491:'',p1492:'',p1493:'',p1494:'',p1495:'',p1496:'',p1497:'',p1498:'',
      p1499:'',p149a:'',p149b:'',p149c:'',p149d:'',p149e:'',p149f:'',p14a0:'',
      p14a1:'',p14a2:'',p14a3:'',p14a4:'',p14a5:'',p14a6:'',p14a7:'',p14a8:'',
      p14a9:'',p14aa:'',p14ab:'',p14ac:'',p14ad:'',p14ae:'',p14af:'',p14b0:'',
      p14b1:'',p14b2:'',p14b3:'',p14b4:'',p14b5:'',p14b6:'',p14b7:'',p14b8:'',
      p14b9:'',p14ba:'',p14bb:'',p14bc:'',p14bd:'',p14be:'',p14bf:'',p14c0:'',
      p14c1:'',p14c2:'',p14c3:'',p14c4:'',p14c5:'',p14c6:'',p14c7:'',p14c8:'',
      p14c9:'',p14ca:'',p14cb:'',p14cc:'',p14cd:'',p14ce:'',p14cf:'',p14d0:'',
      p14d1:'',p14d2:'',p14d3:'',p14d4:'',p14d5:'',p14d6:'',p14d7:'',p14d8:'',
      p14d9:'',p14da:'',p14db:'',p14dc:'',p14dd:'',p14de:'',p14df:'',p14e0:'',
      p14e1:'',p14e2:'',p14e3:'',p14e4:'',p14e5:'',p14e6:'',p14e7:'',p14e8:'',
      p14e9:'',p14ea:'',p14eb:'',p14ec:'',p14ed:'',p14ee:'',p14ef:'',p14f0:'',
      p14f1:'',p14f2:'',p14f3:'',p14f4:'',p14f5:'',p14f6:'',p14f7:'',p14f8:'',
      p14f9:'',p14fa:'',p14fb:'',p14fc:'',p14fd:'',p14fe:'',p14ff:'',p1500:'',
      p1501:'',p1502:'',p1503:'',p1504:'',p1505:'',p1506:'',p1507:'',p1508:'',
      p1509:'',p150a:'',p150b:'',p150c:'',p150d:'',p150e:'',p150f:'',p1510:'',
      p1511:'',p1512:'',p1513:'',p1514:'',p1515:'',p1516:'',p1517:'',p1518:'',
      p1519:'',p151a:'',p151b:'',p151c:'',p151d:'',p151e:'',p151f:'',p1520:'',
      p1521:'',p1522:'',p1523:'',p1524:'',p1525:'',p1526:'',p1527:'',p1528:'',
      p1529:'',p152a:'',p152b:'',p152c:'',p152d:'',p152e:'',p152f:'',p1530:'',
      p1531:'',p1532:'',p1533:'',p1534:'',p1535:'',p1536:'',p1537:'',p1538:'',
      p1539:'',p153a:'',p153b:'',p153c:'',p153d:'',p153e:'',p153f:'',p1540:'',
      p1541:'',p1542:'',p1543:'',p1544:'',p1545:'',p1546:'',p1547:'',p1548:'',
      p1549:'',p154a:'',p154b:'',p154c:'',p154d:'',p154e:'',p154f:'',p1550:'',
      p1551:'',p1552:'',p1553:'',p1554:'',p1555:'',p1556:'',p1557:'',p1558:'',
      p1559:'',p155a:'',p155b:'',p155c:'',p155d:'',p155e:'',p155f:'',p1560:'',
      p1561:'',p1562:'',p1563:'',p1564:'',p1565:'',p1566:'',p1567:'',p1568:'',
      p1569:'',p156a:'',p156b:'',p156c:'',p156d:'',p156e:'',p156f:'',p1570:'',
      p1571:'',p1572:'',p1573:'',p1574:'',p1575:'',p1576:'',p1577:'',p1578:'',
      p1579:'',p157a:'',p157b:'',p157c:'',p157d:'',p157e:'',p157f:'',p1580:'',
      p1581:'',p1582:'',p1583:'',p1584:'',p1585:'',p1586:'',p1587:'',p1588:'',
      p1589:'',p158a:'',p158b:'',p158c:'',p158d:'',p158e:'',p158f:'',p1590:'',
      p1591:'',p1592:'',p1593:'',p1594:'',p1595:'',p1596:'',p1597:'',p1598:'',
      p1599:'',p159a:'',p159b:'',p159c:'',p159d:'',p159e:'',p159f:'',p15a0:'',
      p15a1:'',p15a2:'',p15a3:'',p15a4:'',p15a5:'',p15a6:'',p15a7:'',p15a8:'',
      p15a9:'',p15aa:'',p15ab:'',p15ac:'',p15ad:'',p15ae:'',p15af:'',p15b0:'',
      p15b1:'',p15b2:'',p15b3:'',p15b4:'',p15b5:'',p15b6:'',p15b7:'',p15b8:'',
      p15b9:'',p15ba:'',p15bb:'',p15bc:'',p15bd:'',p15be:'',p15bf:'',p15c0:'',
      p15c1:'',p15c2:'',p15c3:'',p15c4:'',p15c5:'',p15c6:'',p15c7:'',p15c8:'',
      p15c9:'',p15ca:'',p15cb:'',p15cc:'',p15cd:'',p15ce:'',p15cf:'',p15d0:'',
      p15d1:'',p15d2:'',p15d3:'',p15d4:'',p15d5:'',p15d6:'',p15d7:'',p15d8:'',
      p15d9:'',p15da:'',p15db:'',p15dc:'',p15dd:'',p15de:'',p15df:'',p15e0:'',
      p15e1:'',p15e2:'',p15e3:'',p15e4:'',p15e5:'',p15e6:'',p15e7:'',p15e8:'',
      p15e9:'',p15ea:'',p15eb:'',p15ec:'',p15ed:'',p15ee:'',p15ef:'',p15f0:'',
      p15f1:'',p15f2:'',p15f3:'',p15f4:'',p15f5:'',p15f6:'',p15f7:'',p15f8:'',
      p15f9:'',p15fa:'',p15fb:'',p15fc:'',p15fd:'',p15fe:'',p15ff:'',p1600:'',
      p1601:'',p1602:'',p1603:'',p1604:'',p1605:'',p1606:'',p1607:'',p1608:'',
      p1609:'',p160a:'',p160b:'',p160c:'',p160d:'',p160e:'',p160f:'',p1610:'',
      p1611:'',p1612:'',p1613:'',p1614:'',p1615:'',p1616:'',p1617:'',p1618:'',
      p1619:'',p161a:'',p161b:'',p161c:'',p161d:'',p161e:'',p161f:'',p1620:'',
      p1621:'',p1622:'',p1623:'',p1624:'',p1625:'',p1626:'',p1627:'',p1628:'',
      p1629:'',p162a:'',p162b:'',p162c:'',p162d:'',p162e:'',p162f:'',p1630:'',
      p1631:'',p1632:'',p1633:'',p1634:'',p1635:'',p1636:'',p1637:'',p1638:'',
      p1639:'',p163a:'',p163b:'',p163c:'',p163d:'',p163e:'',p163f:'',p1640:'',
      p1641:'',p1642:'',p1643:'',p1644:'',p1645:'',p1646:'',p1647:'',p1648:'',
      p1649:'',p164a:'',p164b:'',p164c:'',p164d:'',p164e:'',p164f:'',p1650:'',
      p1651:'',p1652:'',p1653:'',p1654:'',p1655:'',p1656:'',p1657:'',p1658:'',
      p1659:'',p165a:'',p165b:'',p165c:'',p165d:'',p165e:'',p165f:'',p1660:'',
      p1661:'',p1662:'',p1663:'',p1664:'',p1665:'',p1666:'',p1667:'',p1668:'',
      p1669:'',p166a:'',p166b:'',p166c:'',p166d:'',p166e:'',p166f:'',p1670:'',
      p1671:'',p1672:'',p1673:'',p1674:'',p1675:'',p1676:'',p1677:'',p1678:'',
      p1679:'',p167a:'',p167b:'',p167c:'',p167d:'',p167e:'',p167f:'',p1680:'',
      p1681:'',p1682:'',p1683:'',p1684:'',p1685:'',p1686:'',p1687:'',p1688:'',
      p1689:'',p168a:'',p168b:'',p168c:'',p168d:'',p168e:'',p168f:'',p1690:'',
      p1691:'',p1692:'',p1693:'',p1694:'',p1695:'',p1696:'',p1697:'',p1698:'',
      p1699:'',p169a:'',p169b:'',p169c:'',p169d:'',p169e:'',p169f:'',p16a0:'',
      p16a1:'',p16a2:'',p16a3:'',p16a4:'',p16a5:'',p16a6:'',p16a7:'',p16a8:'',
      p16a9:'',p16aa:'',p16ab:'',p16ac:'',p16ad:'',p16ae:'',p16af:'',p16b0:'',
      p16b1:'',p16b2:'',p16b3:'',p16b4:'',p16b5:'',p16b6:'',p16b7:'',p16b8:'',
      p16b9:'',p16ba:'',p16bb:'',p16bc:'',p16bd:'',p16be:'',p16bf:'',p16c0:'',
      p16c1:'',p16c2:'',p16c3:'',p16c4:'',p16c5:'',p16c6:'',p16c7:'',p16c8:'',
      p16c9:'',p16ca:'',p16cb:'',p16cc:'',p16cd:'',p16ce:'',p16cf:'',p16d0:'',
      p16d1:'',p16d2:'',p16d3:'',p16d4:'',p16d5:'',p16d6:'',p16d7:'',p16d8:'',
      p16d9:'',p16da:'',p16db:'',p16dc:'',p16dd:'',p16de:'',p16df:'',p16e0:'',
      p16e1:'',p16e2:'',p16e3:'',p16e4:'',p16e5:'',p16e6:'',p16e7:'',p16e8:'',
      p16e9:'',p16ea:'',p16eb:'',p16ec:'',p16ed:'',p16ee:'',p16ef:'',p16f0:'',
      p16f1:'',p16f2:'',p16f3:'',p16f4:'',p16f5:'',p16f6:'',p16f7:'',p16f8:'',
      p16f9:'',p16fa:'',p16fb:'',p16fc:'',p16fd:'',p16fe:'',p16ff:'',p1700:'',
      p1701:'',p1702:'',p1703:'',p1704:'',p1705:'',p1706:'',p1707:'',p1708:'',
      p1709:'',p170a:'',p170b:'',p170c:'',p170d:'',p170e:'',p170f:'',p1710:'',
      p1711:'',p1712:'',p1713:'',p1714:'',p1715:'',p1716:'',p1717:'',p1718:'',
      p1719:'',p171a:'',p171b:'',p171c:'',p171d:'',p171e:'',p171f:'',p1720:'',
      p1721:'',p1722:'',p1723:'',p1724:'',p1725:'',p1726:'',p1727:'',p1728:'',
      p1729:'',p172a:'',p172b:'',p172c:'',p172d:'',p172e:'',p172f:'',p1730:'',
      p1731:'',p1732:'',p1733:'',p1734:'',p1735:'',p1736:'',p1737:'',p1738:'',
      p1739:'',p173a:'',p173b:'',p173c:'',p173d:'',p173e:'',p173f:'',p1740:'',
      p1741:'',p1742:'',p1743:'',p1744:'',p1745:'',p1746:'',p1747:'',p1748:'',
      p1749:'',p174a:'',p174b:'',p174c:'',p174d:'',p174e:'',p174f:'',p1750:'',
      p1751:'',p1752:'',p1753:'',p1754:'',p1755:'',p1756:'',p1757:'',p1758:'',
      p1759:'',p175a:'',p175b:'',p175c:'',p175d:'',p175e:'',p175f:'',p1760:'',
      p1761:'',p1762:'',p1763:'',p1764:'',p1765:'',p1766:'',p1767:'',p1768:'',
      p1769:'',p176a:'',p176b:'',p176c:'',p176d:'',p176e:'',p176f:'',p1770:'',
      p1771:'',p1772:'',p1773:'',p1774:'',p1775:'',p1776:'',p1777:'',p1778:'',
      p1779:'',p177a:'',p177b:'',p177c:'',p177d:'',p177e:'',p177f:'',p1780:'',
      p1781:'',p1782:'',p1783:'',p1784:'',p1785:'',p1786:'',p1787:'',p1788:'',
      p1789:'',p178a:'',p178b:'',p178c:'',p178d:'',p178e:'',p178f:'',p1790:'',
      p1791:'',p1792:'',p1793:'',p1794:'',p1795:'',p1796:'',p1797:'',p1798:'',
      p1799:'',p179a:'',p179b:'',p179c:'',p179d:'',p179e:'',p179f:'',p17a0:'',
      p17a1:'',p17a2:'',p17a3:'',p17a4:'',p17a5:'',p17a6:'',p17a7:'',p17a8:'',
      p17a9:'',p17aa:'',p17ab:'',p17ac:'',p17ad:'',p17ae:'',p17af:'',p17b0:'',
      p17b1:'',p17b2:'',p17b3:'',p17b4:'',p17b5:'',p17b6:'',p17b7:'',p17b8:'',
      p17b9:'',p17ba:'',p17bb:'',p17bc:'',p17bd:'',p17be:'',p17bf:'',p17c0:'',
      p17c1:'',p17c2:'',p17c3:'',p17c4:'',p17c5:'',p17c6:'',p17c7:'',p17c8:'',
      p17c9:'',p17ca:'',p17cb:'',p17cc:'',p17cd:'',p17ce:'',p17cf:'',p17d0:'',
      p17d1:'',p17d2:'',p17d3:'',p17d4:'',p17d5:'',p17d6:'',p17d7:'',p17d8:'',
      p17d9:'',p17da:'',p17db:'',p17dc:'',p17dd:'',p17de:'',p17df:'',p17e0:'',
      p17e1:'',p17e2:'',p17e3:'',p17e4:'',p17e5:'',p17e6:'',p17e7:'',p17e8:'',
      p17e9:'',p17ea:'',p17eb:'',p17ec:'',p17ed:'',p17ee:'',p17ef:'',p17f0:'',
      p17f1:'',p17f2:'',p17f3:'',p17f4:'',p17f5:'',p17f6:'',p17f7:'',p17f8:'',
      p17f9:'',p17fa:'',p17fb:'',p17fc:'',p17fd:'',p17fe:'',p17ff:'',p1800:'',
      p1801:'',p1802:'',p1803:'',p1804:'',p1805:'',p1806:'',p1807:'',p1808:'',
      p1809:'',p180a:'',p180b:'',p180c:'',p180d:'',p180e:'',p180f:'',p1810:'',
      p1811:'',p1812:'',p1813:'',p1814:'',p1815:'',p1816:'',p1817:'',p1818:'',
      p1819:'',p181a:'',p181b:'',p181c:'',p181d:'',p181e:'',p181f:'',p1820:'',
      p1821:'',p1822:'',p1823:'',p1824:'',p1825:'',p1826:'',p1827:'',p1828:'',
      p1829:'',p182a:'',p182b:'',p182c:'',p182d:'',p182e:'',p182f:'',p1830:'',
      p1831:'',p1832:'',p1833:'',p1834:'',p1835:'',p1836:'',p1837:'',p1838:'',
      p1839:'',p183a:'',p183b:'',p183c:'',p183d:'',p183e:'',p183f:'',p1840:'',
      p1841:'',p1842:'',p1843:'',p1844:'',p1845:'',p1846:'',p1847:'',p1848:'',
      p1849:'',p184a:'',p184b:'',p184c:'',p184d:'',p184e:'',p184f:'',p1850:'',
      p1851:'',p1852:'',p1853:'',p1854:'',p1855:'',p1856:'',p1857:'',p1858:'',
      p1859:'',p185a:'',p185b:'',p185c:'',p185d:'',p185e:'',p185f:'',p1860:'',
      p1861:'',p1862:'',p1863:'',p1864:'',p1865:'',p1866:'',p1867:'',p1868:'',
      p1869:'',p186a:'',p186b:'',p186c:'',p186d:'',p186e:'',p186f:'',p1870:'',
      p1871:'',p1872:'',p1873:'',p1874:'',p1875:'',p1876:'',p1877:'',p1878:'',
      p1879:'',p187a:'',p187b:'',p187c:'',p187d:'',p187e:'',p187f:'',p1880:'',
      p1881:'',p1882:'',p1883:'',p1884:'',p1885:'',p1886:'',p1887:'',p1888:'',
      p1889:'',p188a:'',p188b:'',p188c:'',p188d:'',p188e:'',p188f:'',p1890:'',
      p1891:'',p1892:'',p1893:'',p1894:'',p1895:'',p1896:'',p1897:'',p1898:'',
      p1899:'',p189a:'',p189b:'',p189c:'',p189d:'',p189e:'',p189f:'',p18a0:'',
      p18a1:'',p18a2:'',p18a3:'',p18a4:'',p18a5:'',p18a6:'',p18a7:'',p18a8:'',
      p18a9:'',p18aa:'',p18ab:'',p18ac:'',p18ad:'',p18ae:'',p18af:'',p18b0:'',
      p18b1:'',p18b2:'',p18b3:'',p18b4:'',p18b5:'',p18b6:'',p18b7:'',p18b8:'',
      p18b9:'',p18ba:'',p18bb:'',p18bc:'',p18bd:'',p18be:'',p18bf:'',p18c0:'',
      p18c1:'',p18c2:'',p18c3:'',p18c4:'',p18c5:'',p18c6:'',p18c7:'',p18c8:'',
      p18c9:'',p18ca:'',p18cb:'',p18cc:'',p18cd:'',p18ce:'',p18cf:'',p18d0:'',
      p18d1:'',p18d2:'',p18d3:'',p18d4:'',p18d5:'',p18d6:'',p18d7:'',p18d8:'',
      p18d9:'',p18da:'',p18db:'',p18dc:'',p18dd:'',p18de:'',p18df:'',p18e0:'',
      p18e1:'',p18e2:'',p18e3:'',p18e4:'',p18e5:'',p18e6:'',p18e7:'',p18e8:'',
      p18e9:'',p18ea:'',p18eb:'',p18ec:'',p18ed:'',p18ee:'',p18ef:'',p18f0:'',
      p18f1:'',p18f2:'',p18f3:'',p18f4:'',p18f5:'',p18f6:'',p18f7:'',p18f8:'',
      p18f9:'',p18fa:'',p18fb:'',p18fc:'',p18fd:'',p18fe:'',p18ff:'',p1900:'',
      p1901:'',p1902:'',p1903:'',p1904:'',p1905:'',p1906:'',p1907:'',p1908:'',
      p1909:'',p190a:'',p190b:'',p190c:'',p190d:'',p190e:'',p190f:'',p1910:'',
      p1911:'',p1912:'',p1913:'',p1914:'',p1915:'',p1916:'',p1917:'',p1918:'',
      p1919:'',p191a:'',p191b:'',p191c:'',p191d:'',p191e:'',p191f:'',p1920:'',
      p1921:'',p1922:'',p1923:'',p1924:'',p1925:'',p1926:'',p1927:'',p1928:'',
      p1929:'',p192a:'',p192b:'',p192c:'',p192d:'',p192e:'',p192f:'',p1930:'',
      p1931:'',p1932:'',p1933:'',p1934:'',p1935:'',p1936:'',p1937:'',p1938:'',
      p1939:'',p193a:'',p193b:'',p193c:'',p193d:'',p193e:'',p193f:'',p1940:'',
      p1941:'',p1942:'',p1943:'',p1944:'',p1945:'',p1946:'',p1947:'',p1948:'',
      p1949:'',p194a:'',p194b:'',p194c:'',p194d:'',p194e:'',p194f:'',p1950:'',
      p1951:'',p1952:'',p1953:'',p1954:'',p1955:'',p1956:'',p1957:'',p1958:'',
      p1959:'',p195a:'',p195b:'',p195c:'',p195d:'',p195e:'',p195f:'',p1960:'',
      p1961:'',p1962:'',p1963:'',p1964:'',p1965:'',p1966:'',p1967:'',p1968:'',
      p1969:'',p196a:'',p196b:'',p196c:'',p196d:'',p196e:'',p196f:'',p1970:'',
      p1971:'',p1972:'',p1973:'',p1974:'',p1975:'',p1976:'',p1977:'',p1978:'',
      p1979:'',p197a:'',p197b:'',p197c:'',p197d:'',p197e:'',p197f:'',p1980:'',
      p1981:'',p1982:'',p1983:'',p1984:'',p1985:'',p1986:'',p1987:'',p1988:'',
      p1989:'',p198a:'',p198b:'',p198c:'',p198d:'',p198e:'',p198f:'',p1990:'',
      p1991:'',p1992:'',p1993:'',p1994:'',p1995:'',p1996:'',p1997:'',p1998:'',
      p1999:'',p199a:'',p199b:'',p199c:'',p199d:'',p199e:'',p199f:'',p19a0:'',
      p19a1:'',p19a2:'',p19a3:'',p19a4:'',p19a5:'',p19a6:'',p19a7:'',p19a8:'',
      p19a9:'',p19aa:'',p19ab:'',p19ac:'',p19ad:'',p19ae:'',p19af:'',p19b0:'',
      p19b1:'',p19b2:'',p19b3:'',p19b4:'',p19b5:'',p19b6:'',p19b7:'',p19b8:'',
      p19b9:'',p19ba:'',p19bb:'',p19bc:'',p19bd:'',p19be:'',p19bf:'',p19c0:'',
      p19c1:'',p19c2:'',p19c3:'',p19c4:'',p19c5:'',p19c6:'',p19c7:'',p19c8:'',
      p19c9:'',p19ca:'',p19cb:'',p19cc:'',p19cd:'',p19ce:'',p19cf:'',p19d0:'',
      p19d1:'',p19d2:'',p19d3:'',p19d4:'',p19d5:'',p19d6:'',p19d7:'',p19d8:'',
      p19d9:'',p19da:'',p19db:'',p19dc:'',p19dd:'',p19de:'',p19df:'',p19e0:'',
      p19e1:'',p19e2:'',p19e3:'',p19e4:'',p19e5:'',p19e6:'',p19e7:'',p19e8:'',
      p19e9:'',p19ea:'',p19eb:'',p19ec:'',p19ed:'',p19ee:'',p19ef:'',p19f0:'',
      p19f1:'',p19f2:'',p19f3:'',p19f4:'',p19f5:'',p19f6:'',p19f7:'',p19f8:'',
      p19f9:'',p19fa:'',p19fb:'',p19fc:'',p19fd:'',p19fe:'',p19ff:'',p1a00:'',
      p1a01:'',p1a02:'',p1a03:'',p1a04:'',p1a05:'',p1a06:'',p1a07:'',p1a08:'',
      p1a09:'',p1a0a:'',p1a0b:'',p1a0c:'',p1a0d:'',p1a0e:'',p1a0f:'',p1a10:'',
      p1a11:'',p1a12:'',p1a13:'',p1a14:'',p1a15:'',p1a16:'',p1a17:'',p1a18:'',
      p1a19:'',p1a1a:'',p1a1b:'',p1a1c:'',p1a1d:'',p1a1e:'',p1a1f:'',p1a20:'',
      p1a21:'',p1a22:'',p1a23:'',p1a24:'',p1a25:'',p1a26:'',p1a27:'',p1a28:'',
      p1a29:'',p1a2a:'',p1a2b:'',p1a2c:'',p1a2d:'',p1a2e:'',p1a2f:'',p1a30:'',
      p1a31:'',p1a32:'',p1a33:'',p1a34:'',p1a35:'',p1a36:'',p1a37:'',p1a38:'',
      p1a39:'',p1a3a:'',p1a3b:'',p1a3c:'',p1a3d:'',p1a3e:'',p1a3f:'',p1a40:'',
      p1a41:'',p1a42:'',p1a43:'',p1a44:'',p1a45:'',p1a46:'',p1a47:'',p1a48:'',
      p1a49:'',p1a4a:'',p1a4b:'',p1a4c:'',p1a4d:'',p1a4e:'',p1a4f:'',p1a50:'',
      p1a51:'',p1a52:'',p1a53:'',p1a54:'',p1a55:'',p1a56:'',p1a57:'',p1a58:'',
      p1a59:'',p1a5a:'',p1a5b:'',p1a5c:'',p1a5d:'',p1a5e:'',p1a5f:'',p1a60:'',
      p1a61:'',p1a62:'',p1a63:'',p1a64:'',p1a65:'',p1a66:'',p1a67:'',p1a68:'',
      p1a69:'',p1a6a:'',p1a6b:'',p1a6c:'',p1a6d:'',p1a6e:'',p1a6f:'',p1a70:'',
      p1a71:'',p1a72:'',p1a73:'',p1a74:'',p1a75:'',p1a76:'',p1a77:'',p1a78:'',
      p1a79:'',p1a7a:'',p1a7b:'',p1a7c:'',p1a7d:'',p1a7e:'',p1a7f:'',p1a80:'',
      p1a81:'',p1a82:'',p1a83:'',p1a84:'',p1a85:'',p1a86:'',p1a87:'',p1a88:'',
      p1a89:'',p1a8a:'',p1a8b:'',p1a8c:'',p1a8d:'',p1a8e:'',p1a8f:'',p1a90:'',
      p1a91:'',p1a92:'',p1a93:'',p1a94:'',p1a95:'',p1a96:'',p1a97:'',p1a98:'',
      p1a99:'',p1a9a:'',p1a9b:'',p1a9c:'',p1a9d:'',p1a9e:'',p1a9f:'',p1aa0:'',
      p1aa1:'',p1aa2:'',p1aa3:'',p1aa4:'',p1aa5:'',p1aa6:'',p1aa7:'',p1aa8:'',
      p1aa9:'',p1aaa:'',p1aab:'',p1aac:'',p1aad:'',p1aae:'',p1aaf:'',p1ab0:'',
      p1ab1:'',p1ab2:'',p1ab3:'',p1ab4:'',p1ab5:'',p1ab6:'',p1ab7:'',p1ab8:'',
      p1ab9:'',p1aba:'',p1abb:'',p1abc:'',p1abd:'',p1abe:'',p1abf:'',p1ac0:'',
      p1ac1:'',p1ac2:'',p1ac3:'',p1ac4:'',p1ac5:'',p1ac6:'',p1ac7:'',p1ac8:'',
      p1ac9:'',p1aca:'',p1acb:'',p1acc:'',p1acd:'',p1ace:'',p1acf:'',p1ad0:'',
      p1ad1:'',p1ad2:'',p1ad3:'',p1ad4:'',p1ad5:'',p1ad6:'',p1ad7:'',p1ad8:'',
      p1ad9:'',p1ada:'',p1adb:'',p1adc:'',p1add:'',p1ade:'',p1adf:'',p1ae0:'',
      p1ae1:'',p1ae2:'',p1ae3:'',p1ae4:'',p1ae5:'',p1ae6:'',p1ae7:'',p1ae8:'',
      p1ae9:'',p1aea:'',p1aeb:'',p1aec:'',p1aed:'',p1aee:'',p1aef:'',p1af0:'',
      p1af1:'',p1af2:'',p1af3:'',p1af4:'',p1af5:'',p1af6:'',p1af7:'',p1af8:'',
      p1af9:'',p1afa:'',p1afb:'',p1afc:'',p1afd:'',p1afe:'',p1aff:'',p1b00:'',
      p1b01:'',p1b02:'',p1b03:'',p1b04:'',p1b05:'',p1b06:'',p1b07:'',p1b08:'',
      p1b09:'',p1b0a:'',p1b0b:'',p1b0c:'',p1b0d:'',p1b0e:'',p1b0f:'',p1b10:'',
      p1b11:'',p1b12:'',p1b13:'',p1b14:'',p1b15:'',p1b16:'',p1b17:'',p1b18:'',
      p1b19:'',p1b1a:'',p1b1b:'',p1b1c:'',p1b1d:'',p1b1e:'',p1b1f:'',p1b20:'',
      p1b21:'',p1b22:'',p1b23:'',p1b24:'',p1b25:'',p1b26:'',p1b27:'',p1b28:'',
      p1b29:'',p1b2a:'',p1b2b:'',p1b2c:'',p1b2d:'',p1b2e:'',p1b2f:'',p1b30:'',
      p1b31:'',p1b32:'',p1b33:'',p1b34:'',p1b35:'',p1b36:'',p1b37:'',p1b38:'',
      p1b39:'',p1b3a:'',p1b3b:'',p1b3c:'',p1b3d:'',p1b3e:'',p1b3f:'',p1b40:'',
      p1b41:'',p1b42:'',p1b43:'',p1b44:'',p1b45:'',p1b46:'',p1b47:'',p1b48:'',
      p1b49:'',p1b4a:'',p1b4b:'',p1b4c:'',p1b4d:'',p1b4e:'',p1b4f:'',p1b50:'',
      p1b51:'',p1b52:'',p1b53:'',p1b54:'',p1b55:'',p1b56:'',p1b57:'',p1b58:'',
      p1b59:'',p1b5a:'',p1b5b:'',p1b5c:'',p1b5d:'',p1b5e:'',p1b5f:'',p1b60:'',
      p1b61:'',p1b62:'',p1b63:'',p1b64:'',p1b65:'',p1b66:'',p1b67:'',p1b68:'',
      p1b69:'',p1b6a:'',p1b6b:'',p1b6c:'',p1b6d:'',p1b6e:'',p1b6f:'',p1b70:'',
      p1b71:'',p1b72:'',p1b73:'',p1b74:'',p1b75:'',p1b76:'',p1b77:'',p1b78:'',
      p1b79:'',p1b7a:'',p1b7b:'',p1b7c:'',p1b7d:'',p1b7e:'',p1b7f:'',p1b80:'',
      p1b81:'',p1b82:'',p1b83:'',p1b84:'',p1b85:'',p1b86:'',p1b87:'',p1b88:'',
      p1b89:'',p1b8a:'',p1b8b:'',p1b8c:'',p1b8d:'',p1b8e:'',p1b8f:'',p1b90:'',
      p1b91:'',p1b92:'',p1b93:'',p1b94:'',p1b95:'',p1b96:'',p1b97:'',p1b98:'',
      p1b99:'',p1b9a:'',p1b9b:'',p1b9c:'',p1b9d:'',p1b9e:'',p1b9f:'',p1ba0:'',
      p1ba1:'',p1ba2:'',p1ba3:'',p1ba4:'',p1ba5:'',p1ba6:'',p1ba7:'',p1ba8:'',
      p1ba9:'',p1baa:'',p1bab:'',p1bac:'',p1bad:'',p1bae:'',p1baf:'',p1bb0:'',
      p1bb1:'',p1bb2:'',p1bb3:'',p1bb4:'',p1bb5:'',p1bb6:'',p1bb7:'',p1bb8:'',
      p1bb9:'',p1bba:'',p1bbb:'',p1bbc:'',p1bbd:'',p1bbe:'',p1bbf:'',p1bc0:'',
      p1bc1:'',p1bc2:'',p1bc3:'',p1bc4:'',p1bc5:'',p1bc6:'',p1bc7:'',p1bc8:'',
      p1bc9:'',p1bca:'',p1bcb:'',p1bcc:'',p1bcd:'',p1bce:'',p1bcf:'',p1bd0:'',
      p1bd1:'',p1bd2:'',p1bd3:'',p1bd4:'',p1bd5:'',p1bd6:'',p1bd7:'',p1bd8:'',
      p1bd9:'',p1bda:'',p1bdb:'',p1bdc:'',p1bdd:'',p1bde:'',p1bdf:'',p1be0:'',
      p1be1:'',p1be2:'',p1be3:'',p1be4:'',p1be5:'',p1be6:'',p1be7:'',p1be8:'',
      p1be9:'',p1bea:'',p1beb:'',p1bec:'',p1bed:'',p1bee:'',p1bef:'',p1bf0:'',
      p1bf1:'',p1bf2:'',p1bf3:'',p1bf4:'',p1bf5:'',p1bf6:'',p1bf7:'',p1bf8:'',
      p1bf9:'',p1bfa:'',p1bfb:'',p1bfc:'',p1bfd:'',p1bfe:'',p1bff:'',p1c00:'',
      p1c01:'',p1c02:'',p1c03:'',p1c04:'',p1c05:'',p1c06:'',p1c07:'',p1c08:'',
      p1c09:'',p1c0a:'',p1c0b:'',p1c0c:'',p1c0d:'',p1c0e:'',p1c0f:'',p1c10:'',
      p1c11:'',p1c12:'',p1c13:'',p1c14:'',p1c15:'',p1c16:'',p1c17:'',p1c18:'',
      p1c19:'',p1c1a:'',p1c1b:'',p1c1c:'',p1c1d:'',p1c1e:'',p1c1f:'',p1c20:'',
      p1c21:'',p1c22:'',p1c23:'',p1c24:'',p1c25:'',p1c26:'',p1c27:'',p1c28:'',
      p1c29:'',p1c2a:'',p1c2b:'',p1c2c:'',p1c2d:'',p1c2e:'',p1c2f:'',p1c30:'',
      p1c31:'',p1c32:'',p1c33:'',p1c34:'',p1c35:'',p1c36:'',p1c37:'',p1c38:'',
      p1c39:'',p1c3a:'',p1c3b:'',p1c3c:'',p1c3d:'',p1c3e:'',p1c3f:'',p1c40:'',
      p1c41:'',p1c42:'',p1c43:'',p1c44:'',p1c45:'',p1c46:'',p1c47:'',p1c48:'',
      p1c49:'',p1c4a:'',p1c4b:'',p1c4c:'',p1c4d:'',p1c4e:'',p1c4f:'',p1c50:'',
      p1c51:'',p1c52:'',p1c53:'',p1c54:'',p1c55:'',p1c56:'',p1c57:'',p1c58:'',
      p1c59:'',p1c5a:'',p1c5b:'',p1c5c:'',p1c5d:'',p1c5e:'',p1c5f:'',p1c60:'',
      p1c61:'',p1c62:'',p1c63:'',p1c64:'',p1c65:'',p1c66:'',p1c67:'',p1c68:'',
      p1c69:'',p1c6a:'',p1c6b:'',p1c6c:'',p1c6d:'',p1c6e:'',p1c6f:'',p1c70:'',
      p1c71:'',p1c72:'',p1c73:'',p1c74:'',p1c75:'',p1c76:'',p1c77:'',p1c78:'',
      p1c79:'',p1c7a:'',p1c7b:'',p1c7c:'',p1c7d:'',p1c7e:'',p1c7f:'',p1c80:'',
      p1c81:'',p1c82:'',p1c83:'',p1c84:'',p1c85:'',p1c86:'',p1c87:'',p1c88:'',
      p1c89:'',p1c8a:'',p1c8b:'',p1c8c:'',p1c8d:'',p1c8e:'',p1c8f:'',p1c90:'',
      p1c91:'',p1c92:'',p1c93:'',p1c94:'',p1c95:'',p1c96:'',p1c97:'',p1c98:'',
      p1c99:'',p1c9a:'',p1c9b:'',p1c9c:'',p1c9d:'',p1c9e:'',p1c9f:'',p1ca0:'',
      p1ca1:'',p1ca2:'',p1ca3:'',p1ca4:'',p1ca5:'',p1ca6:'',p1ca7:'',p1ca8:'',
      p1ca9:'',p1caa:'',p1cab:'',p1cac:'',p1cad:'',p1cae:'',p1caf:'',p1cb0:'',
      p1cb1:'',p1cb2:'',p1cb3:'',p1cb4:'',p1cb5:'',p1cb6:'',p1cb7:'',p1cb8:'',
      p1cb9:'',p1cba:'',p1cbb:'',p1cbc:'',p1cbd:'',p1cbe:'',p1cbf:'',p1cc0:'',
      p1cc1:'',p1cc2:'',p1cc3:'',p1cc4:'',p1cc5:'',p1cc6:'',p1cc7:'',p1cc8:'',
      p1cc9:'',p1cca:'',p1ccb:'',p1ccc:'',p1ccd:'',p1cce:'',p1ccf:'',p1cd0:'',
      p1cd1:'',p1cd2:'',p1cd3:'',p1cd4:'',p1cd5:'',p1cd6:'',p1cd7:'',p1cd8:'',
      p1cd9:'',p1cda:'',p1cdb:'',p1cdc:'',p1cdd:'',p1cde:'',p1cdf:'',p1ce0:'',
      p1ce1:'',p1ce2:'',p1ce3:'',p1ce4:'',p1ce5:'',p1ce6:'',p1ce7:'',p1ce8:'',
      p1ce9:'',p1cea:'',p1ceb:'',p1cec:'',p1ced:'',p1cee:'',p1cef:'',p1cf0:'',
      p1cf1:'',p1cf2:'',p1cf3:'',p1cf4:'',p1cf5:'',p1cf6:'',p1cf7:'',p1cf8:'',
      p1cf9:'',p1cfa:'',p1cfb:'',p1cfc:'',p1cfd:'',p1cfe:'',p1cff:'',p1d00:'',
      p1d01:'',p1d02:'',p1d03:'',p1d04:'',p1d05:'',p1d06:'',p1d07:'',p1d08:'',
      p1d09:'',p1d0a:'',p1d0b:'',p1d0c:'',p1d0d:'',p1d0e:'',p1d0f:'',p1d10:'',
      p1d11:'',p1d12:'',p1d13:'',p1d14:'',p1d15:'',p1d16:'',p1d17:'',p1d18:'',
      p1d19:'',p1d1a:'',p1d1b:'',p1d1c:'',p1d1d:'',p1d1e:'',p1d1f:'',p1d20:'',
      p1d21:'',p1d22:'',p1d23:'',p1d24:'',p1d25:'',p1d26:'',p1d27:'',p1d28:'',
      p1d29:'',p1d2a:'',p1d2b:'',p1d2c:'',p1d2d:'',p1d2e:'',p1d2f:'',p1d30:'',
      p1d31:'',p1d32:'',p1d33:'',p1d34:'',p1d35:'',p1d36:'',p1d37:'',p1d38:'',
      p1d39:'',p1d3a:'',p1d3b:'',p1d3c:'',p1d3d:'',p1d3e:'',p1d3f:'',p1d40:'',
      p1d41:'',p1d42:'',p1d43:'',p1d44:'',p1d45:'',p1d46:'',p1d47:'',p1d48:'',
      p1d49:'',p1d4a:'',p1d4b:'',p1d4c:'',p1d4d:'',p1d4e:'',p1d4f:'',p1d50:'',
      p1d51:'',p1d52:'',p1d53:'',p1d54:'',p1d55:'',p1d56:'',p1d57:'',p1d58:'',
      p1d59:'',p1d5a:'',p1d5b:'',p1d5c:'',p1d5d:'',p1d5e:'',p1d5f:'',p1d60:'',
      p1d61:'',p1d62:'',p1d63:'',p1d64:'',p1d65:'',p1d66:'',p1d67:'',p1d68:'',
      p1d69:'',p1d6a:'',p1d6b:'',p1d6c:'',p1d6d:'',p1d6e:'',p1d6f:'',p1d70:'',
      p1d71:'',p1d72:'',p1d73:'',p1d74:'',p1d75:'',p1d76:'',p1d77:'',p1d78:'',
      p1d79:'',p1d7a:'',p1d7b:'',p1d7c:'',p1d7d:'',p1d7e:'',p1d7f:'',p1d80:'',
      p1d81:'',p1d82:'',p1d83:'',p1d84:'',p1d85:'',p1d86:'',p1d87:'',p1d88:'',
      p1d89:'',p1d8a:'',p1d8b:'',p1d8c:'',p1d8d:'',p1d8e:'',p1d8f:'',p1d90:'',
      p1d91:'',p1d92:'',p1d93:'',p1d94:'',p1d95:'',p1d96:'',p1d97:'',p1d98:'',
      p1d99:'',p1d9a:'',p1d9b:'',p1d9c:'',p1d9d:'',p1d9e:'',p1d9f:'',p1da0:'',
      p1da1:'',p1da2:'',p1da3:'',p1da4:'',p1da5:'',p1da6:'',p1da7:'',p1da8:'',
      p1da9:'',p1daa:'',p1dab:'',p1dac:'',p1dad:'',p1dae:'',p1daf:'',p1db0:'',
      p1db1:'',p1db2:'',p1db3:'',p1db4:'',p1db5:'',p1db6:'',p1db7:'',p1db8:'',
      p1db9:'',p1dba:'',p1dbb:'',p1dbc:'',p1dbd:'',p1dbe:'',p1dbf:'',p1dc0:'',
      p1dc1:'',p1dc2:'',p1dc3:'',p1dc4:'',p1dc5:'',p1dc6:'',p1dc7:'',p1dc8:'',
      p1dc9:'',p1dca:'',p1dcb:'',p1dcc:'',p1dcd:'',p1dce:'',p1dcf:'',p1dd0:'',
      p1dd1:'',p1dd2:'',p1dd3:'',p1dd4:'',p1dd5:'',p1dd6:'',p1dd7:'',p1dd8:'',
      p1dd9:'',p1dda:'',p1ddb:'',p1ddc:'',p1ddd:'',p1dde:'',p1ddf:'',p1de0:'',
      p1de1:'',p1de2:'',p1de3:'',p1de4:'',p1de5:'',p1de6:'',p1de7:'',p1de8:'',
      p1de9:'',p1dea:'',p1deb:'',p1dec:'',p1ded:'',p1dee:'',p1def:'',p1df0:'',
      p1df1:'',p1df2:'',p1df3:'',p1df4:'',p1df5:'',p1df6:'',p1df7:'',p1df8:'',
      p1df9:'',p1dfa:'',p1dfb:'',p1dfc:'',p1dfd:'',p1dfe:'',p1dff:'',p1e00:'',
      p1e01:'',p1e02:'',p1e03:'',p1e04:'',p1e05:'',p1e06:'',p1e07:'',p1e08:'',
      p1e09:'',p1e0a:'',p1e0b:'',p1e0c:'',p1e0d:'',p1e0e:'',p1e0f:'',p1e10:'',
      p1e11:'',p1e12:'',p1e13:'',p1e14:'',p1e15:'',p1e16:'',p1e17:'',p1e18:'',
      p1e19:'',p1e1a:'',p1e1b:'',p1e1c:'',p1e1d:'',p1e1e:'',p1e1f:'',p1e20:'',
      p1e21:'',p1e22:'',p1e23:'',p1e24:'',p1e25:'',p1e26:'',p1e27:'',p1e28:'',
      p1e29:'',p1e2a:'',p1e2b:'',p1e2c:'',p1e2d:'',p1e2e:'',p1e2f:'',p1e30:'',
      p1e31:'',p1e32:'',p1e33:'',p1e34:'',p1e35:'',p1e36:'',p1e37:'',p1e38:'',
      p1e39:'',p1e3a:'',p1e3b:'',p1e3c:'',p1e3d:'',p1e3e:'',p1e3f:'',p1e40:'',
      p1e41:'',p1e42:'',p1e43:'',p1e44:'',p1e45:'',p1e46:'',p1e47:'',p1e48:'',
      p1e49:'',p1e4a:'',p1e4b:'',p1e4c:'',p1e4d:'',p1e4e:'',p1e4f:'',p1e50:'',
      p1e51:'',p1e52:'',p1e53:'',p1e54:'',p1e55:'',p1e56:'',p1e57:'',p1e58:'',
      p1e59:'',p1e5a:'',p1e5b:'',p1e5c:'',p1e5d:'',p1e5e:'',p1e5f:'',p1e60:'',
      p1e61:'',p1e62:'',p1e63:'',p1e64:'',p1e65:'',p1e66:'',p1e67:'',p1e68:'',
      p1e69:'',p1e6a:'',p1e6b:'',p1e6c:'',p1e6d:'',p1e6e:'',p1e6f:'',p1e70:'',
      p1e71:'',p1e72:'',p1e73:'',p1e74:'',p1e75:'',p1e76:'',p1e77:'',p1e78:'',
      p1e79:'',p1e7a:'',p1e7b:'',p1e7c:'',p1e7d:'',p1e7e:'',p1e7f:'',p1e80:'',
      p1e81:'',p1e82:'',p1e83:'',p1e84:'',p1e85:'',p1e86:'',p1e87:'',p1e88:'',
      p1e89:'',p1e8a:'',p1e8b:'',p1e8c:'',p1e8d:'',p1e8e:'',p1e8f:'',p1e90:'',
      p1e91:'',p1e92:'',p1e93:'',p1e94:'',p1e95:'',p1e96:'',p1e97:'',p1e98:'',
      p1e99:'',p1e9a:'',p1e9b:'',p1e9c:'',p1e9d:'',p1e9e:'',p1e9f:'',p1ea0:'',
      p1ea1:'',p1ea2:'',p1ea3:'',p1ea4:'',p1ea5:'',p1ea6:'',p1ea7:'',p1ea8:'',
      p1ea9:'',p1eaa:'',p1eab:'',p1eac:'',p1ead:'',p1eae:'',p1eaf:'',p1eb0:'',
      p1eb1:'',p1eb2:'',p1eb3:'',p1eb4:'',p1eb5:'',p1eb6:'',p1eb7:'',p1eb8:'',
      p1eb9:'',p1eba:'',p1ebb:'',p1ebc:'',p1ebd:'',p1ebe:'',p1ebf:'',p1ec0:'',
      p1ec1:'',p1ec2:'',p1ec3:'',p1ec4:'',p1ec5:'',p1ec6:'',p1ec7:'',p1ec8:'',
      p1ec9:'',p1eca:'',p1ecb:'',p1ecc:'',p1ecd:'',p1ece:'',p1ecf:'',p1ed0:'',
      p1ed1:'',p1ed2:'',p1ed3:'',p1ed4:'',p1ed5:'',p1ed6:'',p1ed7:'',p1ed8:'',
      p1ed9:'',p1eda:'',p1edb:'',p1edc:'',p1edd:'',p1ede:'',p1edf:'',p1ee0:'',
      p1ee1:'',p1ee2:'',p1ee3:'',p1ee4:'',p1ee5:'',p1ee6:'',p1ee7:'',p1ee8:'',
      p1ee9:'',p1eea:'',p1eeb:'',p1eec:'',p1eed:'',p1eee:'',p1eef:'',p1ef0:'',
      p1ef1:'',p1ef2:'',p1ef3:'',p1ef4:'',p1ef5:'',p1ef6:'',p1ef7:'',p1ef8:'',
      p1ef9:'',p1efa:'',p1efb:'',p1efc:'',p1efd:'',p1efe:'',p1eff:'',p1f00:''
    }
  }
  let object = createObject();
  %HeapObjectVerify(object);
  assertFalse(%HasFastProperties(object));
  assertEquals(Object.getPrototypeOf(object ), null);
  let keys = Object.keys(object);
  // modify original object
  object['new_property'] = {};
  object[1] = 12;
  %HeapObjectVerify(object);

  let object2  = createObject();
  %HeapObjectVerify(object2);
  assertFalse(object2 === object);
  assertFalse(%HasFastProperties(object2));
  assertEquals(Object.getPrototypeOf(object2), null);
  assertEquals(keys, Object.keys(object2));
});
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/object-prevent-extensions.js                                       0000664 0000000 0000000 00000074750 14746647661 0024214 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Tests the Object.preventExtensions method - ES 15.2.3.10

// Flags: --allow-natives-syntax


assertFalse(Object.isExtensible());

var obj1 = {};
// Extensible defaults to true.
assertTrue(Object.isExtensible(obj1));
Object.preventExtensions(obj1);

// Make sure the is_extensible flag is set.
assertFalse(Object.isExtensible(obj1));
obj1.x = 42;
assertEquals(undefined, obj1.x);

// Try adding a new element.
obj1[1] = 42;
assertEquals(undefined, obj1[1]);


// Try when the object has an existing property.
var obj2 = {};
assertTrue(Object.isExtensible(obj2));
obj2.x = 42;
assertEquals(42, obj2.x);
assertTrue(Object.isExtensible(obj2));

Object.preventExtensions(obj2);
assertEquals(42, obj2.x);

obj2.y = 42;
// obj2.y should still be undefined.
assertEquals(undefined, obj2.y);
// Make sure we can still write values to obj.x.
obj2.x = 43;
assertEquals(43, obj2.x)

obj2.y = new function() { return 42; };
// obj2.y should still be undefined.
assertEquals(undefined, obj2.y);
assertEquals(43, obj2.x)

try {
  Object.defineProperty(obj2, "y", {value: 42});
} catch (e) {
  assertTrue(/object is not extensible/.test(e));
}

// obj2.y should still be undefined.
assertEquals(undefined, obj2.y);
assertEquals(43, obj2.x);

obj2[1] = 42;
assertEquals(undefined, obj2[1]);

var arr = new Array();
arr[1] = 10;

Object.preventExtensions(arr);

arr[2] = 42;
assertEquals(10, arr[1]);

// We should still be able to change existing elements.
arr[1]= 42;
assertEquals(42, arr[1]);


// Test the the extensible flag is not inherited.
var parent = {};
parent.x = 42;
Object.preventExtensions(parent);

var child = Object.create(parent);

// We should be able to add new properties to the child object.
child.y = 42;

// This should have no influence on the parent class.
parent.y = 29;


// Test that attributes on functions are also handled correctly.
function foo() {
  return 42;
}

Object.preventExtensions(foo);

foo.x = 29;
assertEquals(undefined, foo.x);

// when Object.isExtensible(o) === false
// assignment should return right hand side value
var o = Object.preventExtensions({});
var v = o.v = 50;
assertEquals(undefined, o.v);
assertEquals(50, v);

// test same behavior as above, but for integer properties
var n = o[0] = 100;
assertEquals(undefined, o[0]);
assertEquals(100, n);

// Fast properties should remain fast
obj = { x: 42, y: 'foo' };
assertTrue(%HasFastProperties(obj));
Object.preventExtensions(obj);
assertFalse(Object.isExtensible(obj));
assertFalse(Object.isSealed(obj));
assertTrue(%HasFastProperties(obj));

// Non-extensible objects should share maps where possible
obj = { prop1: 1, prop2: 2 };
obj2 = { prop1: 3, prop2: 4 };
assertTrue(%HaveSameMap(obj, obj2));
Object.preventExtensions(obj);
Object.preventExtensions(obj2);
assertFalse(Object.isExtensible(obj));
assertFalse(Object.isExtensible(obj2));
assertFalse(Object.isSealed(obj));
assertFalse(Object.isSealed(obj2));
assertTrue(%HaveSameMap(obj, obj2));

// Non-extensible objects should share maps even when they have elements
obj = { prop1: 1, prop2: 2, 75: 'foo' };
obj2 = { prop1: 3, prop2: 4, 150: 'bar' };
assertTrue(%HaveSameMap(obj, obj2));
Object.preventExtensions(obj);
Object.preventExtensions(obj2);
assertFalse(Object.isExtensible(obj));
assertFalse(Object.isExtensible(obj2));
assertFalse(Object.isSealed(obj));
assertFalse(Object.isSealed(obj2));
assertTrue(%HaveSameMap(obj, obj2));

// Test packed element array built-in functions with preventExtensions.
obj = new Array(undefined, null, 1, -1, 'a', Symbol("test"));
assertTrue(%HasPackedElements(obj));
Object.preventExtensions(obj);
assertFalse(Object.isSealed(obj));
assertFalse(Object.isFrozen(obj));
assertFalse(Object.isExtensible(obj));
assertTrue(Array.isArray(obj));

// Verify that the length can't be written by builtins.
assertThrows(function() { obj.push(1); }, TypeError);
assertDoesNotThrow(function() { obj.shift(); });
assertThrows(function() { obj.unshift(1); }, TypeError);
assertThrows(function() { obj.splice(0, 0, 1); }, TypeError);
assertDoesNotThrow(function() {obj.splice(0, 0)});

// Verify search, filter, iterator
obj = new Array(undefined, null, 1, -1, 'a', Symbol("test"));
assertTrue(%HasPackedElements(obj));
Object.preventExtensions(obj);
assertFalse(Object.isSealed(obj));
assertFalse(Object.isFrozen(obj));
assertFalse(Object.isExtensible(obj));
assertTrue(Array.isArray(obj));
assertEquals(obj.lastIndexOf(1), 2);
assertEquals(obj.indexOf('a'), 4);
assertEquals(obj.indexOf(undefined), 0);
assertFalse(obj.includes(Symbol("test")));
assertTrue(obj.includes(undefined));
assertFalse(obj.includes(NaN));
assertTrue(obj.includes());
assertEquals(obj.find(x => x==0), undefined);
assertEquals(obj.findIndex(x => x=='a'), 4);
assertTrue(obj.some(x => typeof x == 'symbol'));
assertFalse(obj.every(x => x == -1));
var filteredArray = obj.filter(e => typeof e == "symbol");
assertEquals(filteredArray.length, 1);
assertEquals(obj.map(x => x), obj);
var countPositiveNumber = 0;
obj.forEach(function(item, index) {
  if (item === 1) {
    countPositiveNumber++;
    assertEquals(index, 2);
  }
});
assertEquals(countPositiveNumber, 1);
assertEquals(obj.length, obj.concat([]).length);
var iterator = obj.values();
assertEquals(iterator.next().value, undefined);
assertEquals(iterator.next().value, null);
var iterator = obj.keys();
assertEquals(iterator.next().value, 0);
assertEquals(iterator.next().value, 1);
var iterator = obj.entries();
assertEquals(iterator.next().value, [0, undefined]);
assertEquals(iterator.next().value, [1, null]);

// Verify that the value can be written
var length = obj.length;
for (var i = 0; i < length-1; i++) {
  obj[i] = 'new';
  assertEquals(obj[i], 'new');
}

// Verify flat, map, flatMap, join, reduce, reduceRight for non-extensible packed array
var arr = ['a', 'b', 'c'];
assertTrue(%HasPackedElements(arr));
Object.preventExtensions(arr);
assertFalse(Object.isSealed(obj));
assertFalse(Object.isFrozen(obj));
assertFalse(Object.isExtensible(obj));
assertTrue(Array.isArray(obj));
assertEquals(arr.map(x => [x]), [['a'], ['b'], ['c']]);
assertEquals(arr.flatMap(x => [x]), arr);
assertEquals(arr.flat(), arr);
assertEquals(arr.join('-'), "a-b-c");
const reducer = (accumulator, currentValue) => accumulator + currentValue;
assertEquals(arr.reduce(reducer), "abc");
assertEquals(arr.reduceRight(reducer), "cba");
assertEquals(arr.slice(0, 1), ['a']);

// Verify change content of non-extensible packed array
arr.sort();
assertEquals(arr.join(''), "abc");
arr.reverse();
assertEquals(arr.join(''), "cba");
arr.copyWithin(0, 1, 2);
assertEquals(arr.join(''),"bba");
arr.fill('d');
assertEquals(arr.join(''), "ddd");
arr.pop();
assertEquals(arr.join(''), "dd");

// Regression test with simple array
var arr = ['a'];
Object.preventExtensions(arr);
arr[0] = 'b';
assertEquals(arr[0], 'b');

// Test regression Array.concat with double
var arr = ['a'];
Object.preventExtensions(arr);
arr = arr.concat(0.5);
assertEquals(arr, ['a', 0.5]);
Object.preventExtensions(arr);
arr = arr.concat([1.5, 'b']);
assertEquals(arr, ['a', 0.5, 1.5, 'b']);

// Regression test with change length
var arr = ['a', 'b'];
Object.preventExtensions(arr);
assertEquals(arr.length, 2);
arr.length = 3;
assertEquals(arr.length, 3);
arr[2] = 'c';
assertEquals(arr[2], undefined);
arr.length = 1;
assertEquals(arr.length, 1);
assertEquals(arr[1], undefined);

// Test for holey array
// Test holey element array built-in functions with preventExtensions.
obj = [undefined, null, 1, , -1, 'a', Symbol("test")];
assertTrue(%HasHoleyElements(obj));
Object.preventExtensions(obj);
assertFalse(Object.isSealed(obj));
assertFalse(Object.isFrozen(obj));
assertFalse(Object.isExtensible(obj));
assertTrue(Array.isArray(obj));

// Verify that the length can't be written by builtins.
assertThrows(function() { obj.push(1); }, TypeError);
assertThrows(function() { obj.shift(); }, TypeError);
assertThrows(function() { obj.unshift(1); }, TypeError);
assertThrows(function() { obj.splice(0, 0, 1); }, TypeError);
assertDoesNotThrow(function() {obj.splice(0, 0)});

// Verify search, filter, iterator
obj = [undefined, null, 1, ,-1, 'a', Symbol("test")];
assertTrue(%HasHoleyElements(obj));
Object.preventExtensions(obj);
assertFalse(Object.isSealed(obj));
assertFalse(Object.isFrozen(obj));
assertFalse(Object.isExtensible(obj));
assertTrue(Array.isArray(obj));
assertEquals(obj.lastIndexOf(1), 2);
assertEquals(obj.indexOf('a'), 5);
assertEquals(obj.indexOf(undefined), 0);
assertFalse(obj.includes(Symbol("test")));
assertTrue(obj.includes(undefined));
assertFalse(obj.includes(NaN));
assertTrue(obj.includes());
assertEquals(obj.find(x => x==0), undefined);
assertEquals(obj.findIndex(x => x=='a'), 5);
assertTrue(obj.some(x => typeof x == 'symbol'));
assertFalse(obj.every(x => x == -1));
var filteredArray = obj.filter(e => typeof e == "symbol");
assertEquals(filteredArray.length, 1);
assertEquals(obj.map(x => x), obj);
var countPositiveNumber = 0;
obj.forEach(function(item, index) {
  if (item === 1) {
    countPositiveNumber++;
    assertEquals(index, 2);
  }
});
assertEquals(countPositiveNumber, 1);
assertEquals(obj.length, obj.concat([]).length);
var iterator = obj.values();
assertEquals(iterator.next().value, undefined);
assertEquals(iterator.next().value, null);
var iterator = obj.keys();
assertEquals(iterator.next().value, 0);
assertEquals(iterator.next().value, 1);
var iterator = obj.entries();
assertEquals(iterator.next().value, [0, undefined]);
assertEquals(iterator.next().value, [1, null]);

// Verify that the value can be written
var length = obj.length;
for (var i = 0; i < length-1; i++) {
  if (i==3) continue;
  obj[i] = 'new';
  assertEquals(obj[i], 'new');
}

// Verify flat, map, flatMap, join, reduce, reduceRight for non-extensible holey array
var arr = [, 'a', 'b', 'c'];
assertTrue(%HasHoleyElements(arr));
Object.preventExtensions(arr);
assertFalse(Object.isSealed(obj));
assertFalse(Object.isFrozen(obj));
assertFalse(Object.isExtensible(obj));
assertTrue(Array.isArray(obj));
assertEquals(arr.map(x => [x]), [, ['a'], ['b'], ['c']]);
assertEquals(arr.flatMap(x => [x]), ["a", "b", "c"]);
assertEquals(arr.flat(), ["a", "b", "c"]);
assertEquals(arr.join('-'), "-a-b-c");
const reducer1 = (accumulator, currentValue) => accumulator + currentValue;
assertEquals(arr.reduce(reducer1), "abc");
assertEquals(arr.reduceRight(reducer1), "cba");
assertEquals(arr.slice(0, 1), [,]);
assertEquals(arr.slice(1, 2), ["a"]);

// Verify change content of non-extensible holey array
assertThrows(function(){arr.sort();}, TypeError);
assertEquals(arr.join(''), "abc");
assertThrows(function(){arr.reverse();}, TypeError);
assertEquals(arr.join(''), "abc");
assertThrows(function(){arr.copyWithin(0, 1, 2);}, TypeError);
arr.copyWithin(1, 2, 3);
assertEquals(arr.join(''),"bbc");
assertThrows(function(){arr.fill('d');}, TypeError);
assertEquals(arr.join(''), "bbc");
arr.pop();
assertEquals(arr.join(''), "bb");

// Regression test with simple holey array
var arr = [, 'a'];
Object.preventExtensions(arr);
arr[1] = 'b';
assertEquals(arr[1], 'b');
arr[0] = 1;
assertEquals(arr[0], undefined);

// Test regression Array.concat with double
var arr = ['a', , 'b'];
Object.preventExtensions(arr);
arr = arr.concat(0.5);
assertEquals(arr, ['a', ,'b', 0.5]);
Object.preventExtensions(arr);
arr = arr.concat([1.5, 'c']);
assertEquals(arr, ['a', ,'b', 0.5, 1.5, 'c']);

// Regression test with change length
var arr = ['a', , 'b'];
Object.preventExtensions(arr);
assertEquals(arr.length, 3);
arr.length = 4;
assertEquals(arr.length, 4);
arr[3] = 'c';
assertEquals(arr[3], undefined);
arr.length = 2;
assertEquals(arr.length, 2);
assertEquals(arr[2], undefined);
assertEquals(arr.pop(), undefined);
assertEquals(arr.length, 1);
assertEquals(arr[1], undefined);

// Change length with holey entries at the end
var arr = ['a', ,];
Object.preventExtensions(arr);
assertEquals(arr.length, 2);
arr.length = 0;
assertEquals(arr.length, 0);
arr.length = 3;
assertEquals(arr.length, 3);
arr.length = 0;
assertEquals(arr.length, 0);

// Spread with array
var arr = ['a', 'b', 'c'];
Object.preventExtensions(arr);
var arrSpread = [...arr];
assertEquals(arrSpread.length, arr.length);
assertEquals(arrSpread[0], 'a');
assertEquals(arrSpread[1], 'b');
assertEquals(arrSpread[2], 'c');

// Spread with array-like
function returnArgs() {
  return Object.preventExtensions(arguments);
}
var arrLike = returnArgs('a', 'b', 'c');
assertFalse(Object.isExtensible(arrLike));
var arrSpread = [...arrLike];
assertEquals(arrSpread.length, arrLike.length);
assertEquals(arrSpread[0], 'a');
assertEquals(arrSpread[1], 'b');
assertEquals(arrSpread[2], 'c');

// Spread with holey
function countArgs() {
  return arguments.length;
}
var arr = [, 'b','c'];
Object.preventExtensions(arr);
assertEquals(countArgs(...arr), 3);
assertEquals(countArgs(...[...arr]), 3);
assertEquals(countArgs.apply(this, [...arr]), 3);
function checkUndefined() {
  return arguments[0] === undefined;
}
assertTrue(checkUndefined(...arr));
assertTrue(checkUndefined(...[...arr]));
assertTrue(checkUndefined.apply(this, [...arr]));

//
// Array.prototype.map
//
(function() {
  var a = Object.preventExtensions(['0','1','2','3','4']);

  // Simple use.
  var result = [1,2,3,4,5];
  assertArrayEquals(result, a.map(function(n) { return Number(n) + 1; }));

  // Use specified object as this object when calling the function.
  var o = { delta: 42 }
  result = [42,43,44,45,46];
  assertArrayEquals(result, a.map(function(n) { return this.delta + Number(n); }, o));

  // Modify original array.
  b = Object.preventExtensions(['0','1','2','3','4']);
  result = [1,2,3,4,5];
  assertArrayEquals(result,
      b.map(function(n, index, array) {
        array[index] = Number(n) + 1; return Number(n) + 1;
      }));
  assertArrayEquals(b, result);

  // Only loop through initial part of array and elements are not
  // added.
  a = Object.preventExtensions(['0','1','2','3','4']);
  result = [1,2,3,4,5];
  assertArrayEquals(result,
      a.map(function(n, index, array) { assertThrows(() => { array.push(n) }); return Number(n) + 1; }));
  assertArrayEquals(['0','1','2','3','4'], a);

  // Respect holes.
  a = new Array(20);
  a[1] = '2';
  Object.preventExtensions(a);
  a = Object.preventExtensions(a).map(function(n) { return 2*Number(n); });

  for (var i in a) {
    assertEquals(4, a[i]);
    assertEquals('1', i);
  }

  // Skip over missing properties.
  a = {
    "0": 1,
    "2": 2,
    length: 3
  };
  var received = [];
  assertArrayEquals([2, , 4],
      Array.prototype.map.call(Object.preventExtensions(a), function(n) {
        received.push(n);
        return n * 2;
      }));
  assertArrayEquals([1, 2], received);

  // Modify array prototype
  a = ['1', , 2];
  received = [];
  assertThrows(() => {
    Array.prototype.map.call(Object.preventExtensions(a), function(n) {
      a.__proto__ = null;
      received.push(n);
      return n * 2;
    });
  }, TypeError);
  assertArrayEquals([], received);

  // Create a new object in each function call when receiver is a
  // primitive value. See ECMA-262, Annex C.
  a = [];
  Object.preventExtensions(['1', '2']).map(function() { a.push(this) }, "");
  assertTrue(a[0] !== a[1]);

  // Do not create a new object otherwise.
  a = [];
  Object.preventExtensions(['1', '2']).map(function() { a.push(this) }, {});
  assertSame(a[0], a[1]);

  // In strict mode primitive values should not be coerced to an object.
  a = [];
  Object.preventExtensions(['1', '2']).map(function() { 'use strict'; a.push(this); }, "");
  assertEquals("", a[0]);
  assertEquals(a[0], a[1]);

})();


// Test for double element
// Test packed element array built-in functions with preventExtensions.
obj = new Array(-1.1, 0, 1, -1, 1.1);
assertTrue(%HasDoubleElements(obj));
Object.preventExtensions(obj);
assertFalse(Object.isSealed(obj));
assertFalse(Object.isFrozen(obj));
assertFalse(Object.isExtensible(obj));
assertTrue(Array.isArray(obj));

// Verify that the length can't be written by builtins.
assertThrows(function() { obj.push(1); }, TypeError);
assertDoesNotThrow(function() { obj.shift(); });
assertThrows(function() { obj.unshift(1); }, TypeError);
assertThrows(function() { obj.splice(0, 0, 1); }, TypeError);
assertDoesNotThrow(function() {obj.splice(0, 0)});

// Verify search, filter, iterator
obj = new Array(-1.1, 0, 1, -1, 1.1);
assertTrue(%HasDoubleElements(obj));
Object.preventExtensions(obj);
assertFalse(Object.isSealed(obj));
assertFalse(Object.isFrozen(obj));
assertFalse(Object.isExtensible(obj));
assertTrue(Array.isArray(obj));
assertEquals(obj.lastIndexOf(1), 2);
assertEquals(obj.indexOf(1.1), 4);
assertEquals(obj.indexOf(undefined), -1);
assertFalse(obj.includes(Symbol("test")));
assertFalse(obj.includes(undefined));
assertFalse(obj.includes(NaN));
assertFalse(obj.includes());
assertEquals(obj.find(x => x==0), 0);
assertEquals(obj.findIndex(x => x==1.1), 4);
assertFalse(obj.some(x => typeof x == 'symbol'));
assertFalse(obj.every(x => x == -1));
var filteredArray = obj.filter(e => typeof e == "symbol");
assertEquals(filteredArray.length, 0);
assertEquals(obj.map(x => x), obj);
var countPositiveNumber = 0;
obj.forEach(function(item, index) {
  if (item === 1) {
    countPositiveNumber++;
    assertEquals(index, 2);
  }
});
assertEquals(countPositiveNumber, 1);
assertEquals(obj.length, obj.concat([]).length);
var iterator = obj.values();
assertEquals(iterator.next().value, -1.1);
assertEquals(iterator.next().value, 0);
var iterator = obj.keys();
assertEquals(iterator.next().value, 0);
assertEquals(iterator.next().value, 1);
var iterator = obj.entries();
assertEquals(iterator.next().value, [0, -1.1]);
assertEquals(iterator.next().value, [1, 0]);

// Verify that the value can be written
var length = obj.length;
for (var i = 0; i < length-1; i++) {
  obj[i] = 'new';
  assertEquals(obj[i], 'new');
}

// Verify flat, map, flatMap, join, reduce, reduceRight for non-extensible packed array
var arr = [1.1, 0, 1];
assertTrue(%HasDoubleElements(arr));
Object.preventExtensions(arr);
assertFalse(Object.isSealed(obj));
assertFalse(Object.isFrozen(obj));
assertFalse(Object.isExtensible(obj));
assertTrue(Array.isArray(obj));
assertEquals(arr.map(x => [x]), [[1.1], [0], [1]]);
assertEquals(arr.flatMap(x => [x]), arr);
assertEquals(arr.flat(), arr);
assertEquals(arr.join('-'), "1.1-0-1");
assertEquals(arr.reduce(reducer), 2.1);
assertEquals(arr.reduceRight(reducer), 2.1);
assertEquals(arr.slice(0, 1), [1.1]);

// Verify change content of non-extensible packed array
arr.sort();
assertEquals(arr.join(''), "011.1");
arr.reverse();
assertEquals(arr.join(''), "1.110");
arr.copyWithin(0, 1, 2);
assertEquals(arr.join(''),"110");
arr.fill('d');
assertEquals(arr.join(''), "ddd");
arr.pop();
assertEquals(arr.join(''), "dd");

// Regression test with simple array
var arr = [1.1];
Object.preventExtensions(arr);
arr[0] = 'b';
assertEquals(arr[0], 'b');

// Test regression Array.concat with double
var arr = [1.1];
Object.preventExtensions(arr);
arr = arr.concat(0.5);
assertEquals(arr, [1.1, 0.5]);
Object.preventExtensions(arr);
arr = arr.concat([1.5, 'b']);
assertEquals(arr, [1.1, 0.5, 1.5, 'b']);

// Regression test with change length
var arr = [1.1, 0];
Object.preventExtensions(arr);
assertEquals(arr.length, 2);
arr.length = 3;
assertEquals(arr.length, 3);
arr[2] = 'c';
assertEquals(arr[2], undefined);
arr.length = 1;
assertEquals(arr.length, 1);
assertEquals(arr[1], undefined);

// Test for holey array
// Test holey element array built-in functions with preventExtensions.
obj = [-1.1, 0, 1, , -1, 1.1];
assertTrue(%HasDoubleElements(obj));
Object.preventExtensions(obj);
assertFalse(Object.isSealed(obj));
assertFalse(Object.isFrozen(obj));
assertFalse(Object.isExtensible(obj));
assertTrue(Array.isArray(obj));

// Verify that the length can't be written by builtins.
assertThrows(function() { obj.push(1); }, TypeError);
assertThrows(function() { obj.shift(); }, TypeError);
assertThrows(function() { obj.unshift(1); }, TypeError);
assertThrows(function() { obj.splice(0, 0, 1); }, TypeError);
assertDoesNotThrow(function() {obj.splice(0, 0)});

// Verify search, filter, iterator
obj = [-1.1, 0, 1, ,-1, 1.1];
assertTrue(%HasHoleyElements(obj));
Object.preventExtensions(obj);
assertFalse(Object.isSealed(obj));
assertFalse(Object.isFrozen(obj));
assertFalse(Object.isExtensible(obj));
assertTrue(Array.isArray(obj));
assertEquals(obj.lastIndexOf(1), 2);
assertEquals(obj.indexOf(1.1), 5);
assertEquals(obj.indexOf(undefined), -1);
assertFalse(obj.includes(Symbol("test")));
assertTrue(obj.includes(undefined));
assertFalse(obj.includes(NaN));
assertTrue(obj.includes());
assertEquals(obj.find(x => x==0), 0);
assertEquals(obj.findIndex(x => x==1.1), 5);
assertFalse(obj.some(x => typeof x == 'symbol'));
assertFalse(obj.every(x => x == -1));
var filteredArray = obj.filter(e => typeof e == "symbol");
assertEquals(filteredArray.length, 0);
assertEquals(obj.map(x => x), obj);
var countPositiveNumber = 0;
obj.forEach(function(item, index) {
  if (item === 1) {
    countPositiveNumber++;
    assertEquals(index, 2);
  }
});
assertEquals(countPositiveNumber, 1);
assertEquals(obj.length, obj.concat([]).length);
var iterator = obj.values();
assertEquals(iterator.next().value, -1.1);
assertEquals(iterator.next().value, 0);
var iterator = obj.keys();
assertEquals(iterator.next().value, 0);
assertEquals(iterator.next().value, 1);
var iterator = obj.entries();
assertEquals(iterator.next().value, [0, -1.1]);
assertEquals(iterator.next().value, [1, 0]);

// Verify that the value can be written
var length = obj.length;
for (var i = 0; i < length-1; i++) {
  if (i==3) continue;
  obj[i] = 'new';
  assertEquals(obj[i], 'new');
}

// Verify flat, map, flatMap, join, reduce, reduceRight for non-extensible holey array
var arr = [, 1.1, 0, 1];
assertTrue(%HasDoubleElements(arr));
Object.preventExtensions(arr);
assertFalse(Object.isSealed(obj));
assertFalse(Object.isFrozen(obj));
assertFalse(Object.isExtensible(obj));
assertTrue(Array.isArray(obj));
assertEquals(arr.map(x => [x]), [, [1.1], [0], [1]]);
assertEquals(arr.flatMap(x => [x]), [1.1, 0, 1]);
assertEquals(arr.flat(), [1.1, 0, 1]);
assertEquals(arr.join('-'), "-1.1-0-1");
assertEquals(arr.reduce(reducer1), 2.1);
assertEquals(arr.reduceRight(reducer1), 2.1);
assertEquals(arr.slice(0, 1), [,]);
assertEquals(arr.slice(1, 2), [1.1]);

// Verify change content of non-extensible holey array
assertThrows(function(){arr.sort();}, TypeError);
assertEquals(arr.join(''), "1.101");
assertThrows(function(){arr.reverse();}, TypeError);
assertEquals(arr.join(''), "1.101");
assertThrows(function(){arr.copyWithin(0, 1, 2);}, TypeError);
arr.copyWithin(1, 2, 3);
assertEquals(arr.join(''),"001");
assertThrows(function(){arr.fill('d');}, TypeError);
assertEquals(arr.join(''), "001");
arr.pop();
assertEquals(arr.join(''), "00");

// Regression test with simple holey array
var arr = [, 1.1];
Object.preventExtensions(arr);
arr[1] = 'b';
assertEquals(arr[1], 'b');
arr[0] = 1;
assertEquals(arr[0], undefined);

// Test regression Array.concat with double
var arr = [1.1, , 0];
Object.preventExtensions(arr);
arr = arr.concat(0.5);
assertEquals(arr, [1.1, , 0, 0.5]);
Object.preventExtensions(arr);
arr = arr.concat([1.5, 'c']);
assertEquals(arr, [1.1, , 0, 0.5, 1.5, 'c']);

// Regression test with change length
var arr = [1.1, , 0];
Object.preventExtensions(arr);
assertEquals(arr.length, 3);
arr.length = 4;
assertEquals(arr.length, 4);
arr[3] = 'c';
assertEquals(arr[3], undefined);
arr.length = 2;
assertEquals(arr.length, 2);
assertEquals(arr[2], undefined);
assertEquals(arr.pop(), undefined);
assertEquals(arr.length, 1);
assertEquals(arr[1], undefined);

// Change length with holey entries at the end
var arr = [1.1, ,];
Object.preventExtensions(arr);
assertEquals(arr.length, 2);
arr.length = 0;
assertEquals(arr.length, 0);
arr.length = 3;
assertEquals(arr.length, 3);
arr.length = 0;
assertEquals(arr.length, 0);

// Spread with array
var arr = [1.1, 0, -1];
Object.preventExtensions(arr);
var arrSpread = [...arr];
assertEquals(arrSpread.length, arr.length);
assertEquals(arrSpread[0], 1.1);
assertEquals(arrSpread[1], 0);
assertEquals(arrSpread[2], -1);

// Spread with array-like
function returnArgs() {
  return Object.preventExtensions(arguments);
}
var arrLike = returnArgs(1.1, 0, -1);
assertFalse(Object.isExtensible(arrLike));
var arrSpread = [...arrLike];
assertEquals(arrSpread.length, arrLike.length);
assertEquals(arrSpread[0], 1.1);
assertEquals(arrSpread[1], 0);
assertEquals(arrSpread[2], -1);

// Spread with holey
function countArgs() {
  return arguments.length;
}
var arr = [, 1.1, 0];
Object.preventExtensions(arr);
assertEquals(countArgs(...arr), 3);
assertEquals(countArgs(...[...arr]), 3);
assertEquals(countArgs.apply(this, [...arr]), 3);
function checkUndefined() {
  return arguments[0] === undefined;
}
assertTrue(checkUndefined(...arr));
assertTrue(checkUndefined(...[...arr]));
assertTrue(checkUndefined.apply(this, [...arr]));

//
// Array.prototype.map
//
(function() {
  var a = Object.preventExtensions([0.1,1,2,3,4]);

  // Simple use.
  var result = [1.1,2,3,4,5];
  assertArrayEquals(result, a.map(function(n) { return Number(n) + 1; }));

  // Use specified object as this object when calling the function.
  var o = { delta: 42 }
  result = [42.1,43,44,45,46];
  assertArrayEquals(result, a.map(function(n) { return this.delta + Number(n); }, o));

  // Modify original array.
  b = Object.preventExtensions([0.1,1,2,3,4]);
  result = [1.1,2,3,4,5];
  assertArrayEquals(result,
      b.map(function(n, index, array) {
        array[index] = Number(n) + 1; return Number(n) + 1;
      }));
  assertArrayEquals(b, result);

  // Only loop through initial part of array and elements are not
  // added.
  a = Object.preventExtensions([0.1,1,2,3,4]);
  result = [1.1,2,3,4,5];
  assertArrayEquals(result,
      a.map(function(n, index, array) { assertThrows(() => { array.push(n) }); return Number(n) + 1; }));
  assertArrayEquals([0.1,1,2,3,4], a);

  // Respect holes.
  a = new Array(20);
  a[1] = 1.1;
  Object.preventExtensions(a);
  a = Object.preventExtensions(a).map(function(n) { return 2*Number(n); });

  for (var i in a) {
    assertEquals(2.2, a[i]);
    assertEquals('1', i);
  }

  // Skip over missing properties.
  a = {
    "0": 1.1,
    "2": 2,
    length: 3
  };
  var received = [];
  assertArrayEquals([2.2, , 4],
      Array.prototype.map.call(Object.preventExtensions(a), function(n) {
        received.push(n);
        return n * 2;
      }));
  assertArrayEquals([1.1, 2], received);

  // Modify array prototype
  a = [1.1 , 2];
  received = [];
  assertThrows(() => {
    Array.prototype.map.call(Object.preventExtensions(a), function(n) {
      a.__proto__ = null;
      received.push(n);
      return n * 2;
    });
  }, TypeError);
  assertArrayEquals([], received);

  // Create a new object in each function call when receiver is a
  // primitive value. See ECMA-262, Annex C.
  a = [];
  Object.preventExtensions([1.1, 2]).map(function() { a.push(this) }, "");
  assertTrue(a[0] !== a[1]);

  // Do not create a new object otherwise.
  a = [];
  Object.preventExtensions([1.1, 2]).map(function() { a.push(this) }, {});
  assertSame(a[0], a[1]);

  // In strict mode primitive values should not be coerced to an object.
  a = [];
  Object.preventExtensions([1.1, 2]).map(function() { 'use strict'; a.push(this); }, "");
  assertEquals("", a[0]);
  assertEquals(a[0], a[1]);

})();

// Test regression with Object.defineProperty.
var obj = [];
obj.propertyA = 42;
obj[0] = true;
Object.preventExtensions(obj);
assertDoesNotThrow(function() {
  Object.defineProperty(obj, 'propertyA', {
    value: obj,
  });
});
assertEquals(obj, obj.propertyA);
assertDoesNotThrow(function() {
  Object.defineProperty(obj, 'propertyA', {
    value: obj,
    writable: false,
  });
});
obj.propertyA = 42;
assertEquals(obj.propertyA, obj);
assertThrows(function() {
  Object.defineProperty(obj, 'abc', {
    value: obj,
  });
}, TypeError);


// Handle IC store.
// For packed sealed object.
function packedStore() {
  let a = Object.preventExtensions([""]);
  a[0] = 0;
  assertEquals(a[0], 0);
}

packedStore();
packedStore();

// For holey sealed object.
function holeyStore() {
  let a = Object.preventExtensions([, ""]);
  a[0] = 0;
  assertEquals(a[0], undefined);
}

holeyStore();
holeyStore();

// Make sure IC store for holey is consistent.
let a = Object.preventExtensions([, ""]);
function foo() {
  a[1] = 0;
}

foo();
foo();
function bar() {
  a[0] = 1;
}
assertEquals(a, [, 0]);
bar();
assertEquals(a, [, 0]);
bar();
assertEquals(a, [, 0]);
function baz() {
  a[2] = 2;
}
assertEquals(a, [, 0]);
baz();
assertEquals(a, [, 0]);
baz();
assertEquals(a, [, 0]);

// Reconfigure data field (e.g. change representation).
function testReconfig() {
  var o = ['3'];
  function foo(i) { o.x = i; }
  foo("string");
  Object.preventExtensions(o);
  Object.seal(o);
  foo(0);
  %HeapObjectVerify(o);
  assertEquals(o.x, 0);
}
testReconfig();

// Seal proxy from nonextensible object.
PI = [];
PI[250] = PI;
Object.preventExtensions(PI);
assertFalse(Object.isExtensible(PI));
assertFalse(Object.isSealed(PI));
var proxy = new Proxy(PI, PI);
Object.seal(proxy);
assertFalse(Object.isFrozen(proxy));
assertTrue(Object.isSealed(proxy));

// Freeze proxy from nonextensible object.
PI = [];
PI[250] = PI;
Object.preventExtensions(PI);
assertFalse(Object.isExtensible(PI));
assertFalse(Object.isSealed(PI));
var proxy = new Proxy(PI, PI);
Object.freeze(proxy);
assertTrue(Object.isSealed(proxy));
assertTrue(Object.isFrozen(proxy));
                        node-23.7.0/deps/v8/test/mjsunit/object-seal-global.js                                              0000664 0000000 0000000 00000000402 14746647661 0022475 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

Object.seal(this);
assertTrue(Object.isSealed(this));
assertFalse(Object.isFrozen(this));
                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/object-seal.js                                                     0000664 0000000 0000000 00000115215 14746647661 0021250 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Tests the Object.seal and Object.isSealed methods - ES 19.1.2.17 and
// ES 19.1.2.13

// Flags: --allow-natives-syntax --turbofan --noalways-turbofan

// Test that we return obj if non-object is passed as argument
var non_objects = new Array(undefined, null, 1, -1, 0, 42.43, Symbol("test"));
for (var key in non_objects) {
  assertSame(non_objects[key], Object.seal(non_objects[key]));
}

// Test that isSealed always returns true for non-objects
for (var key in non_objects) {
  assertTrue(Object.isSealed(non_objects[key]));
}

// Test normal data properties.
var obj = { x: 42, z: 'foobar' };
var desc = Object.getOwnPropertyDescriptor(obj, 'x');
assertTrue(desc.writable);
assertTrue(desc.configurable);
assertEquals(42, desc.value);

desc = Object.getOwnPropertyDescriptor(obj, 'z');
assertTrue(desc.writable);
assertTrue(desc.configurable);
assertEquals('foobar', desc.value);

assertTrue(Object.isExtensible(obj));
assertFalse(Object.isSealed(obj));

Object.seal(obj);

// Make sure we are no longer extensible.
assertFalse(Object.isExtensible(obj));
assertTrue(Object.isSealed(obj));

// We should not be frozen, since we are still able to
// update values.
assertFalse(Object.isFrozen(obj));

// We should not allow new properties to be added.
obj.foo = 42;
assertEquals(obj.foo, undefined);

desc = Object.getOwnPropertyDescriptor(obj, 'x');
assertTrue(desc.writable);
assertFalse(desc.configurable);
assertEquals(42, desc.value);

desc = Object.getOwnPropertyDescriptor(obj, 'z');
assertTrue(desc.writable);
assertFalse(desc.configurable);
assertEquals("foobar", desc.value);

// Since writable is not affected by seal we should still be able to
// update the values.
obj.x = "43";
assertEquals("43", obj.x);

// Test on accessors.
var obj2 = {};
function get() { return 43; };
function set() {};
Object.defineProperty(obj2, 'x', { get: get, set: set, configurable: true });

desc = Object.getOwnPropertyDescriptor(obj2, 'x');
assertTrue(desc.configurable);
assertEquals(undefined, desc.value);
assertEquals(set, desc.set);
assertEquals(get, desc.get);

assertTrue(Object.isExtensible(obj2));
assertFalse(Object.isSealed(obj2));
Object.seal(obj2);

// Since this is an accessor property the object is now effectively both
// sealed and frozen (accessors has no writable attribute).
assertTrue(Object.isFrozen(obj2));
assertFalse(Object.isExtensible(obj2));
assertTrue(Object.isSealed(obj2));

desc = Object.getOwnPropertyDescriptor(obj2, 'x');
assertFalse(desc.configurable);
assertEquals(undefined, desc.value);
assertEquals(set, desc.set);
assertEquals(get, desc.get);

obj2.foo = 42;
assertEquals(obj2.foo, undefined);

// Test seal on arrays.
var arr = new Array(42,43);

desc = Object.getOwnPropertyDescriptor(arr, '0');
assertTrue(desc.configurable);
assertTrue(desc.writable);
assertEquals(42, desc.value);

desc = Object.getOwnPropertyDescriptor(arr, '1');
assertTrue(desc.configurable);
assertTrue(desc.writable);
assertEquals(43, desc.value);

assertTrue(Object.isExtensible(arr));
assertFalse(Object.isSealed(arr));
Object.seal(arr);
assertTrue(Object.isSealed(arr));
assertFalse(Object.isExtensible(arr));
// Since the values in the array is still writable this object
// is not frozen.
assertFalse(Object.isFrozen(arr));

desc = Object.getOwnPropertyDescriptor(arr, '0');
assertFalse(desc.configurable);
assertTrue(desc.writable);
assertEquals(42, desc.value);

desc = Object.getOwnPropertyDescriptor(arr, '1');
assertFalse(desc.configurable);
assertTrue(desc.writable);
assertEquals(43, desc.value);

arr[0] = 'foo';

// We should be able to overwrite the existing value.
assertEquals('foo', arr[0]);

// Test that isSealed returns the correct value even if configurable
// has been set to false on all properties manually and the extensible
// flag has also been set to false manually.
var obj3 = { x: 42, y: 'foo' };

assertFalse(Object.isFrozen(obj3));

Object.defineProperty(obj3, 'x', {configurable: false, writable: true});
Object.defineProperty(obj3, 'y', {configurable: false, writable: false});
Object.preventExtensions(obj3);

assertTrue(Object.isSealed(obj3));


// Make sure that an object that has a configurable property
// is not classified as sealed.
var obj4 = {};
Object.defineProperty(obj4, 'x', {configurable: true, writable: false});
Object.defineProperty(obj4, 'y', {configurable: false, writable: false});
Object.preventExtensions(obj4);

assertFalse(Object.isSealed(obj4));

// Make sure that Object.seal returns the sealed object.
var obj4 = {};
assertTrue(obj4 === Object.seal(obj4));

//
// Test that built-in array functions can't modify a sealed array.
//
obj = [1, 2, 3];
var objControl = [4, 5, 6];

// Allow these functions to set up monomorphic calls, using custom built-ins.
var push_call = function(a) { a.push(10); return a; }
var pop_call = function(a) { return a.pop(); }
for (var i = 0; i < 3; i++) {
  push_call(obj);
  pop_call(obj);
}

Object.seal(obj);
assertThrows(function() { push_call(obj); }, TypeError);
assertThrows(function() { pop_call(obj); }, TypeError);

// But the control object is fine at these sites.
assertDoesNotThrow(function() { push_call(objControl); });
assertDoesNotThrow(function() { pop_call(objControl); });

assertDoesNotThrow(function() { obj.push(); });
assertThrows(function() { obj.push(3); }, TypeError);
assertThrows(function() { obj.pop(); }, TypeError);
assertThrows(function() { obj.shift(3); }, TypeError);
assertDoesNotThrow(function() { obj.unshift(); });
assertThrows(function() { obj.unshift(1); }, TypeError);
assertThrows(function() { obj.splice(0, 0, 100, 101, 102); }, TypeError);
assertDoesNotThrow(function() { obj.splice(0,0); });

assertDoesNotThrow(function() { objControl.push(3); });
assertDoesNotThrow(function() { objControl.pop(); });
assertDoesNotThrow(function() { objControl.shift(3); });
assertDoesNotThrow(function() { objControl.unshift(); });
assertDoesNotThrow(function() { objControl.splice(0, 0, 100, 101, 102); });

// Verify that crankshaft still does the right thing.
obj = [1, 2, 3];

push_call = function(a) { a.push(1000); return a; };
%PrepareFunctionForOptimization(push_call);
// Include a call site that doesn't have a custom built-in.
var shift_call = function(a) { a.shift(1000); return a; };
%PrepareFunctionForOptimization(shift_call);
for (var i = 0; i < 3; i++) {
  push_call(obj);
  shift_call(obj);
}

%OptimizeFunctionOnNextCall(push_call);
%OptimizeFunctionOnNextCall(shift_call);
push_call(obj);
shift_call(obj);
assertOptimized(push_call);
assertOptimized(shift_call);
Object.seal(obj);
assertThrows(function() { push_call(obj); }, TypeError);
assertThrows(function() { shift_call(obj); }, TypeError);
assertUnoptimized(push_call);
assertUnoptimized(shift_call);
assertDoesNotThrow(function() { push_call(objControl); });
assertDoesNotThrow(function() { shift_call(objControl); });

// Verify special behavior of splice on sealed objects.
obj = [1,2,3];
Object.seal(obj);
assertDoesNotThrow(function() { obj.splice(0,1,100); });
assertEquals(100, obj[0]);
assertDoesNotThrow(function() { obj.splice(0,2,1,2); });
assertDoesNotThrow(function() { obj.splice(1,2,1,2); });
// Count of items to delete is clamped by length.
assertDoesNotThrow(function() { obj.splice(1,2000,1,2); });
assertThrows(function() { obj.splice(0,0,1); }, TypeError);
assertThrows(function() { obj.splice(1,2000,1,2,3); }, TypeError);

// Test that the enumerable attribute is unperturbed by sealing.
obj = { x: 42, y: 'foo' };
Object.defineProperty(obj, 'y', {enumerable: false});
Object.seal(obj);
assertTrue(Object.isSealed(obj));
assertFalse(Object.isFrozen(obj));
desc = Object.getOwnPropertyDescriptor(obj, 'x');
assertTrue(desc.enumerable);
desc = Object.getOwnPropertyDescriptor(obj, 'y');
assertFalse(desc.enumerable);

// Fast properties should remain fast
obj = { x: 42, y: 'foo' };
assertTrue(%HasFastProperties(obj));
Object.seal(obj);
assertTrue(Object.isSealed(obj));
assertFalse(Object.isFrozen(obj));
assertTrue(%HasFastProperties(obj));

// Sealed objects should share maps where possible
obj = { prop1: 1, prop2: 2 };
obj2 = { prop1: 3, prop2: 4 };
assertTrue(%HaveSameMap(obj, obj2));
Object.seal(obj);
Object.seal(obj2);
assertTrue(Object.isSealed(obj));
assertTrue(Object.isSealed(obj2));
assertFalse(Object.isFrozen(obj));
assertFalse(Object.isFrozen(obj2));
assertTrue(%HaveSameMap(obj, obj2));

// Sealed objects should share maps even when they have elements
obj = { prop1: 1, prop2: 2, 75: 'foo' };
obj2 = { prop1: 3, prop2: 4, 150: 'bar' };
assertTrue(%HaveSameMap(obj, obj2));
Object.seal(obj);
Object.seal(obj2);
assertTrue(Object.isSealed(obj));
assertTrue(Object.isSealed(obj2));
assertFalse(Object.isFrozen(obj));
assertFalse(Object.isFrozen(obj));
assertTrue(%HaveSameMap(obj, obj2));

// Setting elements after sealing should not be allowed
obj = { prop: 'thing' };
Object.seal(obj);
assertTrue(Object.isSealed(obj));
assertFalse(Object.isFrozen(obj));
obj[0] = 'hello';
assertFalse(obj.hasOwnProperty(0));

// Sealing an object in dictionary mode should work
// Also testing that getter/setter properties work after sealing
obj = { };
for (var i = 0; i < 100; ++i) {
  obj['x' + i] = i;
}
var accessorDidRun = false;
Object.defineProperty(obj, 'accessor', {
  get: function() { return 42 },
  set: function() { accessorDidRun = true },
  configurable: true,
  enumerable: true
});

assertFalse(%HasFastProperties(obj));
Object.seal(obj);
assertFalse(%HasFastProperties(obj));
assertTrue(Object.isSealed(obj));
assertFalse(Object.isFrozen(obj));
assertFalse(Object.isExtensible(obj));
for (var i = 0; i < 100; ++i) {
  desc = Object.getOwnPropertyDescriptor(obj, 'x' + i);
  assertFalse(desc.configurable);
}
assertEquals(42, obj.accessor);
assertFalse(accessorDidRun);
obj.accessor = 'ignored value';
assertTrue(accessorDidRun);

// Sealing arguments should work
var func = function(arg) {
  Object.seal(arguments);
  assertTrue(Object.isSealed(arguments));
};
func('hello', 'world');
func('goodbye', 'world');

// Sealing sparse arrays
var sparseArr = [0, 1];
sparseArr[10000] = 10000;
Object.seal(sparseArr);
assertTrue(Object.isSealed(sparseArr));

// Accessors on fast object should behavior properly after sealing
obj = {};
Object.defineProperty(obj, 'accessor', {
  get: function() { return 42 },
  set: function() { accessorDidRun = true },
  configurable: true,
  enumerable: true
});
assertTrue(%HasFastProperties(obj));
Object.seal(obj);
assertTrue(Object.isSealed(obj));
assertTrue(%HasFastProperties(obj));
assertEquals(42, obj.accessor);
accessorDidRun = false;
obj.accessor = 'ignored value';
assertTrue(accessorDidRun);

// Test for regression in mixed accessor/data property objects.
// The strict function is one such object.
assertTrue(Object.isSealed(Object.seal(function(){"use strict";})));

// Also test a simpler case
obj = {};
Object.defineProperty(obj, 'accessor2', {
  get: function() { return 42 },
  set: function() { accessorDidRun = true },
  configurable: true,
  enumerable: true
});
obj.data = 'foo';
assertTrue(%HasFastProperties(obj));
Object.seal(obj);
assertTrue(%HasFastProperties(obj));
assertTrue(Object.isSealed(obj));

function Sealed() {}
Object.seal(Sealed);
assertDoesNotThrow(function() { return new Sealed(); });
Sealed.prototype.prototypeExists = true;
assertTrue((new Sealed()).prototypeExists);

obj = new Int32Array(10);
Object.seal(obj);
assertTrue(Object.isSealed(obj));

// Test packed element array built-in functions with seal.
function testPackedSealedArray1(obj) {
  assertTrue(Object.isSealed(obj));
  assertFalse(Object.isFrozen(obj));
  assertTrue(Array.isArray(obj));

  // Verify that the length can't be written by builtins.
  assertThrows(function() { obj.pop(); }, TypeError);
  assertThrows(function() { obj.push(1); }, TypeError);
  assertThrows(function() { obj.shift(); }, TypeError);
  assertThrows(function() { obj.unshift(1); }, TypeError);
  assertThrows(function() { obj.splice(0); }, TypeError);
  assertDoesNotThrow(function() { obj.splice(0, 0); });

  // Verify search, filter, iterator
  obj = new Array(undefined, null, 1, -1, 'a', Symbol("test"));
  assertTrue(%HasPackedElements(obj));
  Object.seal(obj);
  assertTrue(Object.isSealed(obj));
  assertFalse(Object.isFrozen(obj));
  assertTrue(Array.isArray(obj));
  assertEquals(obj.lastIndexOf(1), 2);
  assertEquals(obj.indexOf('a'), 4);
  assertEquals(obj.indexOf(undefined), 0);
  assertFalse(obj.includes(Symbol("test")));
  assertTrue(obj.includes(undefined));
  assertFalse(obj.includes(NaN));
  assertTrue(obj.includes());
  assertEquals(obj.find(x => x==0), undefined);
  assertEquals(obj.findIndex(x => x=='a'), 4);
  assertTrue(obj.some(x => typeof x == 'symbol'));
  assertFalse(obj.every(x => x == -1));
  var filteredArray = obj.filter(e => typeof e == "symbol");
  assertEquals(filteredArray.length, 1);
  assertEquals(obj.map(x => x), obj);
  var countPositiveNumber = 0;
  obj.forEach(function(item, index) {
    if (item === 1) {
      countPositiveNumber++;
      assertEquals(index, 2);
    }
  });
  assertEquals(countPositiveNumber, 1);
  assertEquals(obj.length, obj.concat([]).length);
  var iterator = obj.values();
  assertEquals(iterator.next().value, undefined);
  assertEquals(iterator.next().value, null);
  var iterator = obj.keys();
  assertEquals(iterator.next().value, 0);
  assertEquals(iterator.next().value, 1);
  var iterator = obj.entries();
  assertEquals(iterator.next().value, [0, undefined]);
  assertEquals(iterator.next().value, [1, null]);

  // Verify that the value can be written
  var length = obj.length;
  for (var i = 0; i < length-1; i++) {
    obj[i] = 'new';
    assertEquals(obj[i], 'new');
  }
};
obj = new Array(undefined, null, 1, -1, 'a', Symbol("test"));
assertTrue(%HasPackedElements(obj));
Object.seal(obj);
testPackedSealedArray1(obj);

// Verify after transition from preventExtensions
obj = new Array(undefined, null, 1, -1, 'a', Symbol("test"));
assertTrue(%HasPackedElements(obj));
Object.preventExtensions(obj);
Object.seal(obj);
testPackedSealedArray1(obj);

// Verify flat, map, slice, flatMap, join, reduce, reduceRight for sealed packed array
function testPackedSealedArray2(arr) {
  assertTrue(Object.isSealed(arr));
  assertFalse(Object.isFrozen(arr));
  assertEquals(arr.map(x => [x]), [['a'], ['b'], ['c']]);
  assertEquals(arr.flatMap(x => [x]), arr);
  assertEquals(arr.flat(), arr);
  assertEquals(arr.join('-'), "a-b-c");
  const reducer = (accumulator, currentValue) => accumulator + currentValue;
  assertEquals(arr.reduce(reducer), "abc");
  assertEquals(arr.reduceRight(reducer), "cba");
  assertEquals(arr.slice(0, 1), ['a']);
  // Verify change content of sealed packed array
  arr.sort();
  assertEquals(arr.join(''), "abc");
  arr.reverse();
  assertEquals(arr.join(''), "cba");
  arr.copyWithin(0, 1, 2);
  assertEquals(arr.join(''),"bba");
  arr.fill('d');
  assertEquals(arr.join(''), "ddd");
}

var arr1 = new Array('a', 'b', 'c');
assertTrue(%HasPackedElements(arr1));
Object.seal(arr1);
testPackedSealedArray2(arr1);

var arr2 = new Array('a', 'b', 'c');
assertTrue(%HasPackedElements(arr2));
Object.preventExtensions(arr2);
Object.seal(arr2);
testPackedSealedArray2(arr2);

// Test regression with Object.defineProperty
var obj = [];
obj.propertyA = 42;
obj[0] = true;
Object.seal(obj);
assertDoesNotThrow(function() {
  Object.defineProperty(obj, 'propertyA', {
    value: obj,
  });
});
assertEquals(obj, obj.propertyA);
assertDoesNotThrow(function() {
  Object.defineProperty(obj, 'propertyA', {
    value: obj,
    writable: false,
  });
});
obj.propertyA = 42;
assertEquals(obj, obj.propertyA);
assertThrows(function() {
  Object.defineProperty(obj, 'abc', {
    value: obj,
  });
}, TypeError);

// Regression test with simple array
var arr = ['a'];
Object.seal(arr);
arr[0] = 'b';
assertEquals(arr[0], 'b');

// Test regression Array.concat with double
var arr = ['a'];
Object.seal(arr);
arr = arr.concat(0.5);
assertEquals(arr, ['a', 0.5]);
Object.seal(arr);
arr = arr.concat([1.5, 'b']);
assertEquals(arr, ['a', 0.5, 1.5, 'b']);

// Regression test with change length
var arr = ['a', 'b'];
Object.seal(arr);
assertEquals(arr.length, 2);
arr.length = 3;
assertEquals(arr.length, 3);
arr[2] = 'c';
assertEquals(arr[2], undefined);
arr.length = 1;
assertEquals(arr.length, 2);

// Start testing for holey element array
// Test holey element array built-in functions with seal.
function testHoleySealedArray1(obj) {
  assertTrue(Object.isSealed(obj));
  assertFalse(Object.isFrozen(obj));
  assertTrue(Array.isArray(obj));

  // Verify that the length can't be written by builtins.
  assertThrows(function() { obj.pop(); }, TypeError);
  assertThrows(function() { obj.push(1); }, TypeError);
  assertThrows(function() { obj.shift(); }, TypeError);
  assertThrows(function() { obj.unshift(1); }, TypeError);
  assertThrows(function() { obj.splice(0); }, TypeError);
  assertDoesNotThrow(function() { obj.splice(0, 0); });

  // Verify search, filter, iterator
  obj = [undefined, null, 1, , -1, 'a', Symbol("test")];
  assertTrue(%HasHoleyElements(obj));
  Object.seal(obj);
  assertTrue(Object.isSealed(obj));
  assertFalse(Object.isFrozen(obj));
  assertTrue(Array.isArray(obj));
  assertEquals(obj.lastIndexOf(1), 2);
  assertEquals(obj.indexOf('a'), 5);
  assertEquals(obj.indexOf(undefined), 0);
  assertFalse(obj.includes(Symbol("test")));
  assertTrue(obj.includes(undefined));
  assertFalse(obj.includes(NaN));
  assertTrue(obj.includes());
  assertEquals(obj.find(x => x==0), undefined);
  assertEquals(obj.findIndex(x => x=='a'), 5);
  assertTrue(obj.some(x => typeof x == 'symbol'));
  assertFalse(obj.every(x => x == -1));
  var filteredArray = obj.filter(e => typeof e == "symbol");
  assertEquals(filteredArray.length, 1);
  assertEquals(obj.map(x => x), obj);
  var countPositiveNumber = 0;
  obj.forEach(function(item, index) {
    if (item === 1) {
      countPositiveNumber++;
      assertEquals(index, 2);
    }
  });
  assertEquals(countPositiveNumber, 1);
  assertEquals(obj.length, obj.concat([]).length);
  var iterator = obj.values();
  assertEquals(iterator.next().value, undefined);
  assertEquals(iterator.next().value, null);
  var iterator = obj.keys();
  assertEquals(iterator.next().value, 0);
  assertEquals(iterator.next().value, 1);
  var iterator = obj.entries();
  assertEquals(iterator.next().value, [0, undefined]);
  assertEquals(iterator.next().value, [1, null]);

  // Verify that the value can be written
  var length = obj.length;
  for (var i = 0; i < length; i++) {
    if (i==3) continue;
    obj[i] = 'new';
    assertEquals(obj[i], 'new');
  }
};
obj = [undefined, null, 1, , -1, 'a', Symbol("test")];
assertTrue(%HasHoleyElements(obj));
Object.seal(obj);
testHoleySealedArray1(obj);

// Verify after transition from preventExtensions
obj = [undefined, null, 1, , -1, 'a', Symbol("test")];
assertTrue(%HasHoleyElements(obj));
Object.preventExtensions(obj);
Object.seal(obj);
testHoleySealedArray1(obj);

// Verify flat, map, slice, flatMap, join, reduce, reduceRight for sealed holey array
function testHoleySealedArray2(arr) {
  assertTrue(Object.isSealed(arr));
  assertFalse(Object.isFrozen(arr));
  assertEquals(arr.map(x => [x]), [, ['a'], ['b'], ['c']]);
  assertEquals(arr.flatMap(x => [x]), ["a", "b", "c"]);
  assertEquals(arr.flat(), ["a", "b", "c"]);
  assertEquals(arr.join('-'), "-a-b-c");
  const reducer = (accumulator, currentValue) => accumulator + currentValue;
  assertEquals(arr.reduce(reducer), "abc");
  assertEquals(arr.reduceRight(reducer), "cba");
  assertEquals(arr.slice(0, 1), [,]);
  assertEquals(arr.slice(1, 2), ["a"]);
  // Verify change content of sealed holey array
  assertThrows(function(){arr.sort();}, TypeError);
  assertEquals(arr.join(''), "abc");
  assertThrows(function(){arr.reverse();}, TypeError);
  assertEquals(arr.join(''), "abc");
  assertThrows(function(){arr.copyWithin(0, 1, 2);}, TypeError);
  assertEquals(arr.join(''),"abc");
  arr.copyWithin(1, 2, 3);
  assertEquals(arr.join(''),"bbc");
  assertThrows(function(){arr.fill('d');}, TypeError);
  assertEquals(arr.join(''), "bbc");
}

var arr1 = [, 'a', 'b', 'c'];
assertTrue(%HasHoleyElements(arr1));
Object.seal(arr1);
testHoleySealedArray2(arr1);

var arr2 = [, 'a', 'b', 'c'];
assertTrue(%HasHoleyElements(arr2));
Object.preventExtensions(arr2);
Object.seal(arr2);
testHoleySealedArray2(arr2);

// Test regression with Object.defineProperty
var obj = ['a', , 'b'];
obj.propertyA = 42;
obj[0] = true;
Object.seal(obj);
assertDoesNotThrow(function() {
  Object.defineProperty(obj, 'propertyA', {
    value: obj,
  });
});
assertEquals(obj, obj.propertyA);
assertDoesNotThrow(function() {
  Object.defineProperty(obj, 'propertyA', {
    value: obj,
    writable: false,
  });
});
obj.propertyA = 42;
assertEquals(obj, obj.propertyA);
assertThrows(function() {
  Object.defineProperty(obj, 'abc', {
    value: obj,
  });
}, TypeError);

// Regression test with simple holey array
var arr = [, 'a'];
Object.seal(arr);
arr[1] = 'b';
assertEquals(arr[1], 'b');
arr[0] = 1;
assertEquals(arr[0], undefined);

// Test regression Array.concat with double
var arr = ['a', , 'b'];
Object.seal(arr);
arr = arr.concat(0.5);
assertEquals(arr, ['a', ,'b', 0.5]);
Object.seal(arr);
arr = arr.concat([1.5, 'c']);
assertEquals(arr, ['a', ,'b', 0.5, 1.5, 'c']);

// Regression test with change length
var arr = ['a', ,'b'];
Object.seal(arr);
assertEquals(arr.length, 3);
arr.length = 4;
assertEquals(arr.length, 4);
arr[3] = 'c';
assertEquals(arr[3], undefined);
arr.length = 2;
assertEquals(arr.length, 3);

// Change length with holey entries at the end
var arr = ['a', ,];
Object.seal(arr);
assertEquals(arr.length, 2);
arr.length = 0;
assertEquals(arr.length, 1);
arr.length = 3;
assertEquals(arr.length, 3);
arr.length = 0;
assertEquals(arr.length, 1);

// Spread with array
var arr = ['a', 'b', 'c'];
Object.seal(arr);
var arrSpread = [...arr];
assertEquals(arrSpread.length, arr.length);
assertEquals(arrSpread[0], 'a');
assertEquals(arrSpread[1], 'b');
assertEquals(arrSpread[2], 'c');

// Spread with array-like
function returnArgs() {
  return Object.seal(arguments);
}
var arrLike = returnArgs('a', 'b', 'c');
assertTrue(Object.isSealed(arrLike));
var arrSpread = [...arrLike];
assertEquals(arrSpread.length, arrLike.length);
assertEquals(arrSpread[0], 'a');
assertEquals(arrSpread[1], 'b');
assertEquals(arrSpread[2], 'c');

// Spread with holey
function countArgs() {
  return arguments.length;
}
var arr = [, 'b','c'];
Object.seal(arr);
assertEquals(countArgs(...arr), 3);
assertEquals(countArgs(...[...arr]), 3);
assertEquals(countArgs.apply(this, [...arr]), 3);
function checkUndefined() {
  return arguments[0] === undefined;
}
assertTrue(checkUndefined(...arr));
assertTrue(checkUndefined(...[...arr]));
assertTrue(checkUndefined.apply(this, [...arr]));

//
// Array.prototype.map
//
(function() {
  var a = Object.seal(['0','1','2','3','4']);

  // Simple use.
  var result = [1,2,3,4,5];
  assertArrayEquals(result, a.map(function(n) { return Number(n) + 1; }));

  // Use specified object as this object when calling the function.
  var o = { delta: 42 }
  result = [42,43,44,45,46];
  assertArrayEquals(result, a.map(function(n) { return this.delta + Number(n); }, o));

  // Modify original array.
  b = Object.seal(['0','1','2','3','4']);
  result = [1,2,3,4,5];
  assertArrayEquals(result,
      b.map(function(n, index, array) {
        array[index] = Number(n) + 1; return Number(n) + 1;
      }));
  assertArrayEquals(b, result);

  // Only loop through initial part of array and elements are not
  // added.
  a = Object.seal(['0','1','2','3','4']);
  result = [1,2,3,4,5];
  assertArrayEquals(result,
      a.map(function(n, index, array) { assertThrows(() => { array.push(n) }); return Number(n) + 1; }));
  assertArrayEquals(['0','1','2','3','4'], a);

  // Respect holes.
  a = new Array(20);
  a[1] = '2';
  Object.seal(a);
  a = Object.seal(a).map(function(n) { return 2*Number(n); });

  for (var i in a) {
    assertEquals(4, a[i]);
    assertEquals('1', i);
  }

  // Skip over missing properties.
  a = {
    "0": 1,
    "2": 2,
    length: 3
  };
  var received = [];
  assertArrayEquals([2, , 4],
      Array.prototype.map.call(Object.seal(a), function(n) {
        received.push(n);
        return n * 2;
      }));
  assertArrayEquals([1, 2], received);

  // Modify array prototype
  a = ['1', , 2];
  received = [];
  assertThrows(() => {
    Array.prototype.map.call(Object.seal(a), function(n) {
      a.__proto__ = null;
      received.push(n);
      return n * 2;
    });
  }, TypeError);
  assertArrayEquals([], received);

  // Create a new object in each function call when receiver is a
  // primitive value. See ECMA-262, Annex C.
  a = [];
  Object.seal(['1', '2']).map(function() { a.push(this) }, "");
  assertTrue(a[0] !== a[1]);

  // Do not create a new object otherwise.
  a = [];
  Object.seal(['1', '2']).map(function() { a.push(this) }, {});
  assertSame(a[0], a[1]);

  // In strict mode primitive values should not be coerced to an object.
  a = [];
  Object.seal(['1', '2']).map(function() { 'use strict'; a.push(this); }, "");
  assertEquals("", a[0]);
  assertEquals(a[0], a[1]);

})();


// Test with double elements
// Test packed element array built-in functions with seal.
function testDoubleSealedArray1(obj) {
  assertTrue(Object.isSealed(obj));
  assertFalse(Object.isFrozen(obj));
  assertTrue(Array.isArray(obj));

  // Verify that the length can't be written by builtins.
  assertThrows(function() { obj.pop(); }, TypeError);
  assertThrows(function() { obj.push(1); }, TypeError);
  assertThrows(function() { obj.shift(); }, TypeError);
  assertThrows(function() { obj.unshift(1); }, TypeError);
  assertThrows(function() { obj.splice(0); }, TypeError);
  assertDoesNotThrow(function() { obj.splice(0, 0); });

  // Verify search, filter, iterator
  assertEquals(obj.lastIndexOf(1), 1);
  assertEquals(obj.indexOf(undefined), -1);
  assertFalse(obj.includes(Symbol("test")));
  assertTrue(obj.includes(1));
  assertTrue(obj.includes(-1.1));
  assertFalse(obj.includes());
  assertEquals(obj.find(x => x==0), undefined);
  assertEquals(obj.findIndex(x => x==2), 3);
  assertFalse(obj.some(x => typeof x == 'symbol'));
  assertFalse(obj.every(x => x == -1));
  var filteredArray = obj.filter(e => typeof e == "symbol");
  assertEquals(filteredArray.length, 0);
  assertEquals(obj.map(x => x), obj);
  var countPositiveNumber = 0;
  obj.forEach(function(item, index) {
    if (item === 1) {
      countPositiveNumber++;
      assertEquals(index, 1);
    }
  });
  assertEquals(countPositiveNumber, 1);
  assertEquals(obj.length, obj.concat([]).length);
  var iterator = obj.values();
  assertEquals(iterator.next().value, -1.1);
  assertEquals(iterator.next().value, 1);
  var iterator = obj.keys();
  assertEquals(iterator.next().value, 0);
  assertEquals(iterator.next().value, 1);
  var iterator = obj.entries();
  assertEquals(iterator.next().value, [0, -1.1]);
  assertEquals(iterator.next().value, [1, 1]);

  // Verify that the value can't be written
  var length = obj.length;
  for (var i = 0; i < length; i++) {
    obj[i] = 'new';
    assertEquals('new', obj[i]);
  }
}

obj = new Array(1.1, -1.1, 1, -1, 2);
assertTrue(%HasDoubleElements(obj));
Object.seal(obj);
testDoubleSealedArray1(obj);

// Verify change from non-extensible to sealed
obj = new Array(1.1, -1.1, 1, -1, 2);
assertTrue(%HasDoubleElements(obj));
Object.preventExtensions(obj);
Object.seal(obj);
assertTrue(Object.isSealed(obj));
testDoubleSealedArray1(obj);

// Verify flat, map, slice, flatMap, join, reduce, reduceRight for sealed packed array
function testDoubleSealedArray2(arr) {
  assertTrue(Object.isSealed(arr));
  assertTrue(Array.isArray(arr));
  assertEquals(arr.map(x => [x]), [[1], [1.1], [0]]);
  assertEquals(arr.flatMap(x => [x]), arr);
  assertEquals(arr.flat(), arr);
  assertEquals(arr.join('-'), "1-1.1-0");
  const reducer = (accumulator, currentValue) => accumulator + currentValue;
  assertEquals(arr.reduce(reducer), 2.1);
  assertEquals(arr.reduceRight(reducer), 2.1);
  assertEquals(arr.slice(0, 1), [1]);
}
var arr1 = new Array(1, 1.1, 0);
assertTrue(%HasDoubleElements(arr1));
Object.seal(arr1);
testDoubleSealedArray2(arr1);

// Verify change from non-extensible to sealed
var arr1 = new Array(1, 1.1, 0);
assertTrue(%HasDoubleElements(arr1));
Object.preventExtensions(arr1);
Object.seal(arr1);
testDoubleSealedArray2(arr1);

// Test regression with Object.defineProperty
var obj = [];
obj.propertyA = 42;
obj[0] = 1.1;
Object.seal(obj);
assertDoesNotThrow(function() {
  Object.defineProperty(obj, 'propertyA', {
    value: obj,
  });
});
assertEquals(obj, obj.propertyA);
assertDoesNotThrow(function() {
  Object.defineProperty(obj, 'propertyA', {
    value: obj,
    writable: false,
  });
});
obj.propertyA = 42;
assertEquals(obj, obj.propertyA);
assertThrows(function() {
  Object.defineProperty(obj, 'abc', {
    value: obj,
  });
}, TypeError);

// Regression test with simple array
var arr = [1.1];
Object.seal(arr);
arr[0] = 1;
assertEquals(arr[0], 1);

// Test regression Array.concat with double
var arr = [1.1];
Object.seal(arr);
arr = arr.concat(0.5);
assertEquals(arr, [1.1, 0.5]);
Object.seal(arr);
arr = arr.concat([1.5, 'b']);
assertEquals(arr, [1.1, 0.5, 1.5, 'b']);

// Regression test with change length
var arr = [1.1, 0];
Object.seal(arr);
assertEquals(arr.length, 2);
arr.length = 3;
assertEquals(arr.length, 3);
arr[2] = 'c';
assertEquals(arr[2], undefined);
arr.length = 1;
assertEquals(arr.length, 2);

// Start testing for holey double element array
// Test holey double element array built-in functions with seal.
function testHoleyDoubleSealedArray1() {
  assertTrue(Object.isSealed(obj));
  assertFalse(Object.isFrozen(obj));
  assertTrue(Array.isArray(obj));

  // Verify that the length can't be written by builtins.
  assertThrows(function() { obj.pop(); }, TypeError);
  assertThrows(function() { obj.push(1); }, TypeError);
  assertThrows(function() { obj.shift(); }, TypeError);
  assertThrows(function() { obj.unshift(1); }, TypeError);
  assertThrows(function() { obj.splice(0); }, TypeError);
  assertDoesNotThrow(function() { obj.splice(0, 0); });

  // Verify search, filter, iterator
  obj = [-1.1, 0, 1, , -1, 1.1];
  assertTrue(%HasHoleyElements(obj));
  Object.seal(obj);
  assertTrue(Object.isSealed(obj));
  assertFalse(Object.isFrozen(obj));
  assertTrue(Array.isArray(obj));
  assertEquals(obj.lastIndexOf(1), 2);
  assertEquals(obj.indexOf(1.1), 5);
  assertEquals(obj.indexOf(undefined), -1);
  assertFalse(obj.includes(Symbol("test")));
  assertTrue(obj.includes(undefined));
  assertFalse(obj.includes(NaN));
  assertTrue(obj.includes());
  assertEquals(obj.find(x => x==0), 0);
  assertEquals(obj.findIndex(x => x==1.1), 5);
  assertFalse(obj.some(x => typeof x == 'symbol'));
  assertFalse(obj.every(x => x == -1));
  var filteredArray = obj.filter(e => typeof e == "symbol");
  assertEquals(filteredArray.length, 0);
  assertEquals(obj.map(x => x), obj);
  var countPositiveNumber = 0;
  obj.forEach(function(item, index) {
    if (item === 1) {
      countPositiveNumber++;
      assertEquals(index, 2);
    }
  });
  assertEquals(countPositiveNumber, 1);
  assertEquals(obj.length, obj.concat([]).length);
  var iterator = obj.values();
  assertEquals(iterator.next().value, -1.1);
  assertEquals(iterator.next().value, 0);
  var iterator = obj.keys();
  assertEquals(iterator.next().value, 0);
  assertEquals(iterator.next().value, 1);
  var iterator = obj.entries();
  assertEquals(iterator.next().value, [0, -1.1]);
  assertEquals(iterator.next().value, [1, 0]);

  // Verify that the value can be written
  var length = obj.length;
  for (var i = 0; i < length; i++) {
    if (i==3) continue;
    obj[i] = 'new';
    assertEquals(obj[i], 'new');
  }
};

obj = [-1.1, 0, 1, , -1, 1.1];
assertTrue(%HasHoleyElements(obj));
Object.seal(obj);
testHoleyDoubleSealedArray1(obj);

// Verify change from non-extensible to sealed
obj = [-1.1, 0, 1, , -1, 1.1];
assertTrue(%HasHoleyElements(obj));
Object.preventExtensions(obj);
Object.seal(obj);
assertTrue(Object.isSealed(obj));
testHoleyDoubleSealedArray1(obj);

// Verify flat, map, slice, flatMap, join, reduce, reduceRight for sealed packed array
function testHoleyDoubleSealedArray2(arr) {
  assertTrue(Object.isSealed(arr));
  assertTrue(Array.isArray(arr));
  assertEquals(arr.map(x => [x]), [, [1.1], [1], [0]]);
  assertEquals(arr.flatMap(x => [x]), [1.1, 1, 0]);
  assertEquals(arr.flat(), [1.1, 1, 0]);
  assertEquals(arr.join('-'), "-1.1-1-0");
  const reducer = (accumulator, currentValue) => accumulator + currentValue;
  assertEquals(arr.reduce(reducer), 2.1);
  assertEquals(arr.reduceRight(reducer), 2.1);
  assertEquals(arr.slice(0, 1), [,]);
  assertEquals(arr.slice(1, 2), [1.1]);
}
var arr1 = [, 1.1, 1, 0];
assertTrue(%HasHoleyElements(arr1));
Object.seal(arr1);
testHoleyDoubleSealedArray2(arr1);

// Verify change from non-extensible to sealed
var arr1 = [, 1.1, 1, 0];
assertTrue(%HasHoleyElements(arr1));
Object.preventExtensions(arr1);
Object.seal(arr1);
testHoleyDoubleSealedArray2(arr1);

// Test regression with Object.defineProperty
var obj = [1.1, , 0];
obj.propertyA = 42;
obj[0] = 1.2;
Object.seal(obj);
assertDoesNotThrow(function() {
  Object.defineProperty(obj, 'propertyA', {
    value: obj,
  });
});
assertEquals(obj, obj.propertyA);
assertDoesNotThrow(function() {
  Object.defineProperty(obj, 'propertyA', {
    value: obj,
    writable: false,
  });
});
obj.propertyA = 42;
assertEquals(obj, obj.propertyA);
assertThrows(function() {
  Object.defineProperty(obj, 'abc', {
    value: obj,
  });
}, TypeError);

// Regression test with simple holey array
var arr = [, 1.1];
Object.seal(arr);
arr[1] = 'b';
assertEquals(arr[1], 'b');
arr[0] = 1;
assertEquals(arr[0], undefined);

// Test regression Array.concat with double
var arr = [1.1, , 0];
Object.seal(arr);
arr = arr.concat(0.5);
assertEquals(arr, [1.1, , 0, 0.5]);
Object.seal(arr);
arr = arr.concat([1.5, 'c']);
assertEquals(arr, [1.1, ,0, 0.5, 1.5, 'c']);

// Regression test with change length
var arr = [1.1, ,0];
Object.seal(arr);
assertEquals(arr.length, 3);
arr.length = 4;
assertEquals(arr.length, 4);
arr[3] = 'c';
assertEquals(arr[2], 0);
assertEquals(arr[3], undefined);
arr.length = 2;
assertEquals(arr.length, 3);

// Change length with holey entries at the end
var arr = [1.1, ,];
Object.seal(arr);
assertEquals(arr.length, 2);
arr.length = 0;
assertEquals(arr.length, 1);
arr.length = 3;
assertEquals(arr.length, 3);
arr.length = 0;
assertEquals(arr.length, 1);

// Spread with array
var arr = [1.1, 0, -1];
Object.seal(arr);
var arrSpread = [...arr];
assertEquals(arrSpread.length, arr.length);
assertEquals(arrSpread[0], 1.1);
assertEquals(arrSpread[1], 0);
assertEquals(arrSpread[2], -1);

// Spread with array-like
function returnArgs() {
  return Object.seal(arguments);
}
var arrLike = returnArgs(1.1, 0, -1);
assertTrue(Object.isSealed(arrLike));
var arrSpread = [...arrLike];
assertEquals(arrSpread.length, arrLike.length);
assertEquals(arrSpread[0], 1.1);
assertEquals(arrSpread[1], 0);
assertEquals(arrSpread[2], -1);

// Spread with holey
function countArgs() {
  return arguments.length;
}
var arr = [, 1.1, 0];
Object.seal(arr);
assertEquals(countArgs(...arr), 3);
assertEquals(countArgs(...[...arr]), 3);
assertEquals(countArgs.apply(this, [...arr]), 3);
function checkUndefined() {
  return arguments[0] === undefined;
}
assertTrue(checkUndefined(...arr));
assertTrue(checkUndefined(...[...arr]));
assertTrue(checkUndefined.apply(this, [...arr]));

//
// Array.prototype.map
//
(function() {
  var a = Object.seal([0.1,1,2,3,4]);

  // Simple use.
  var result = [1.1,2,3,4,5];
  assertArrayEquals(result, a.map(function(n) { return Number(n) + 1; }));

  // Use specified object as this object when calling the function.
  var o = { delta: 42 }
  result = [42.1,43,44,45,46];
  assertArrayEquals(result, a.map(function(n) { return this.delta + Number(n); }, o));

  // Modify original array.
  b = Object.seal([0.1,1,2,3,4]);
  result = [1.1,2,3,4,5];
  assertArrayEquals(result,
      b.map(function(n, index, array) {
        array[index] = Number(n) + 1; return Number(n) + 1;
      }));
  assertArrayEquals(b, result);

  // Only loop through initial part of array and elements are not
  // added.
  a = Object.seal([0.1,1,2,3,4]);
  result = [1.1,2,3,4,5];
  assertArrayEquals(result,
      a.map(function(n, index, array) { assertThrows(() => { array.push(n) }); return Number(n) + 1; }));
  assertArrayEquals([0.1,1,2,3,4], a);

  // Respect holes.
  a = new Array(20);
  a[1] = 1.1;
  Object.seal(a);
  a = Object.seal(a).map(function(n) { return 2*Number(n); });

  for (var i in a) {
    assertEquals(2.2, a[i]);
    assertEquals('1', i);
  }

  // Skip over missing properties.
  a = {
    "0": 1.1,
    "2": 2,
    length: 3
  };
  var received = [];
  assertArrayEquals([2.2, , 4],
      Array.prototype.map.call(Object.seal(a), function(n) {
        received.push(n);
        return n * 2;
      }));
  assertArrayEquals([1.1, 2], received);

  // Modify array prototype
  a = [1.1, , 2];
  received = [];
  assertThrows(() => {
    Array.prototype.map.call(Object.seal(a), function(n) {
      a.__proto__ = null;
      received.push(n);
      return n * 2;
    });
  }, TypeError);
  assertArrayEquals([], received);

  // Create a new object in each function call when receiver is a
  // primitive value. See ECMA-262, Annex C.
  a = [];
  Object.seal([1.1, 2]).map(function() { a.push(this) }, "");
  assertTrue(a[0] !== a[1]);

  // Do not create a new object otherwise.
  a = [];
  Object.seal([1.1, 2]).map(function() { a.push(this) }, {});
  assertSame(a[0], a[1]);

  // In strict mode primitive values should not be coerced to an object.
  a = [];
  Object.seal([1.1, 1.2]).map(function() { 'use strict'; a.push(this); }, "");
  assertEquals("", a[0]);
  assertEquals(a[0], a[1]);

})();
                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/object-toprimitive.js                                              0000664 0000000 0000000 00000007026 14746647661 0022677 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Test the ToPrimitive internal function used by ToNumber/ToString.
// Does it [[Get]] and [[Call]] the object's toString and valueOf properties
// correctly. Specifically, does it call [[Get]] only once per property.

var o1 = { toString: function() { return 42; },
           valueOf: function() { return "37"; } };
var n1 = Number(o1);
var s1 = String(o1);
assertTrue(typeof n1 == "number");
assertTrue(typeof s1 == "string");

var trace = [];
var valueOfValue = 42;
var toStringValue = "foo";
function traceValueOf () {
  trace.push("vo");
  return valueOfValue;
};
function traceToString() {
  trace.push("ts");
  return toStringValue;
};
var valueOfFunc = traceValueOf;
var toStringFunc = traceToString;

var ot = { get toString() { trace.push("gts");
                            return toStringFunc; },
           get valueOf() { trace.push("gvo");
                           return valueOfFunc; }
};

var nt = Number(ot);
assertEquals(42, nt);
assertEquals(["gvo","vo"], trace);

trace = [];
var st = String(ot);
assertEquals("foo", st);
assertEquals(["gts","ts"], trace);

trace = [];
valueOfValue = ["not primitive"];
var nt = Number(ot);
assertEquals(Number("foo"), nt);
assertEquals(["gvo", "vo", "gts", "ts"], trace);

trace = [];
valueOfValue = 42;
toStringValue = ["not primitive"];
var st = String(ot);
assertEquals(String(42), st);
assertEquals(["gts", "ts", "gvo", "vo"], trace);

trace = [];
valueOfValue = ["not primitive"];
assertThrows("Number(ot)", TypeError);
assertEquals(["gvo", "vo", "gts", "ts"], trace);


toStringFunc = "not callable";
trace = [];
valueOfValue = 42;
var st = String(ot);
assertEquals(String(42), st);
assertEquals(["gts", "gvo", "vo"], trace);

valueOfFunc = "not callable";
trace = [];
assertThrows("String(ot)", TypeError);
assertEquals(["gts", "gvo"], trace);

toStringFunc = traceToString;
toStringValue = "87";
trace = [];
var nt = Number(ot);
assertEquals(87, nt);
assertEquals(["gvo", "gts", "ts"], trace);

assertThrows('Number(Symbol())', TypeError);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/object-tostring-builtins.js                                        0000664 0000000 0000000 00000004416 14746647661 0024024 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Object.prototype.toString should return the correct values for instances of
// various built-in classes.
var funs = {
  Object:   [ Object ],
  Function: [ Function ],
  Array:    [ Array ],
  String:   [ String ],
  Boolean:  [ Boolean ],
  Number:   [ Number ],
  Date:     [ Date ],
  RegExp:   [ RegExp ],
  Error:    [ Error, TypeError, RangeError, SyntaxError, ReferenceError, EvalError, URIError ]
}
for (f in funs) {
  for (i in funs[f]) {
    assertEquals("[object " + f + "]",
                 Object.prototype.toString.call(new funs[f][i]),
                 funs[f][i]);
    assertEquals("[object Function]",
                 Object.prototype.toString.call(funs[f][i]),
                 funs[f][i]);
  }
}
                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/omit-constant-mapcheck.js                                          0000664 0000000 0000000 00000004601 14746647661 0023424 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax

var g1 = {a: 1};

function load() {
  return g1.a;
};
%PrepareFunctionForOptimization(load);
assertEquals(1, load());
assertEquals(1, load());
%OptimizeFunctionOnNextCall(load);
assertEquals(1, load());
delete g1.a;
assertEquals(undefined, load());

var g2 = {a: 2};

function load2() {
  return g2.a;
};
%PrepareFunctionForOptimization(load2);
assertEquals(2, load2());
assertEquals(2, load2());
%OptimizeFunctionOnNextCall(load2);
assertEquals(2, load2());
g2.b = 10;
g2.a = 5;
assertEquals(5, load2());

var g3 = {a: 2, b: 9, c: 1};

function store(v) {
  g3.a = v;
  return g3.a;
};
%PrepareFunctionForOptimization(store);
assertEquals(5, store(5));
assertEquals(8, store(8));
%OptimizeFunctionOnNextCall(store);
assertEquals(10, store(10));
delete g3.c;
store(7);
assertEquals({a: 7, b: 9}, g3);
                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/omit-default-ctors.js                                              0000664 0000000 0000000 00000026640 14746647661 0022605 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --omit-default-ctors

(function OmitDefaultBaseCtor() {
  class A {}  // default base ctor -> will be omitted
  class B extends A {}
  const o = new B();
  assertSame(B.prototype, o.__proto__);
})();

(function OmitDefaultDerivedCtor() {
  class A { constructor() {} }
  class B extends A {}  // default derived ctor -> will be omitted
  class C extends B {}
  const o = new C();
  assertSame(C.prototype, o.__proto__);
})();

(function OmitDefaultBaseAndDerivedCtor() {
  class A {} // default base ctor -> will be omitted
  class B extends A {}  // default derived ctor -> will be omitted
  class C extends B {}
  const o = new C();
  assertSame(C.prototype, o.__proto__);
})();

(function OmitDefaultBaseCtorWithExplicitSuper() {
  class A {}  // default base ctor -> will be omitted
  class B extends A { constructor() { super(); } }
  const o = new B();
  assertSame(B.prototype, o.__proto__);
})();

(function OmitDefaultDerivedCtorWithExplicitSuper() {
  class A { constructor() {} }
  class B extends A {}  // default derived ctor -> will be omitted
  class C extends B { constructor() { super(); } }
  const o = new C();
  assertSame(C.prototype, o.__proto__);
})();

(function OmitDefaultBaseAndDerivedCtorWithExplicitSuper() {
  class A {} // default base ctor -> will be omitted
  class B extends A {}  // default derived ctor -> will be omitted
  class C extends B { constructor() { super(); } }
  const o = new C();
  assertSame(C.prototype, o.__proto__);
})();

(function OmitDefaultBaseCtorWithExplicitSuperAndNonFinalSpread() {
  class A {}  // default base ctor -> will be omitted
  class B extends A { constructor(...args) { super(1, ...args, 2); } }
  const o = new B(3, 4);
  assertSame(B.prototype, o.__proto__);
})();

(function OmitDefaultDerivedCtorWithExplicitSuperAndNonFinalSpread() {
  class A { constructor() {} }
  class B extends A {}  // default derived ctor -> will be omitted
  class C extends B { constructor(...args) { super(1, ...args, 2); } }
  const o = new C(3, 4);
  assertSame(C.prototype, o.__proto__);
})();

(function OmitDefaultBaseAndDerivedCtorWithExplicitSuperAndNonFinalSpread() {
  class A {} // default base ctor -> will be omitted
  class B extends A {}  // default derived ctor -> will be omitted
  class C extends B { constructor(...args) { super(1, ...args, 2); } }
  const o = new C(3, 4);
  assertSame(C.prototype, o.__proto__);
})();

(function NonDefaultBaseConstructorCalled() {
  let ctorCallCount = 0;
  let lastArgs;
  class Base {
    constructor(...args) {
      ++ctorCallCount;
      this.baseTagged = true;
      lastArgs = args;
    }
  }
  // Nothing will be omitted.
  class A extends Base {}
  const a = new A(1, 2, 3);
  assertEquals(1, ctorCallCount);
  assertEquals([1, 2, 3], lastArgs);
  assertTrue(a.baseTagged);

  // 'A' default ctor will be omitted.
  class B1 extends A {}
  const b1 = new B1(4, 5, 6);
  assertEquals(2, ctorCallCount);
  assertEquals([4, 5, 6], lastArgs);
  assertTrue(b1.baseTagged);

  // The same test with non-final spread; 'A' default ctor will be omitted.
  class B2 extends A {
    constructor(...args) { super(1, ...args, 2); }
  }
  const b2 = new B2(4, 5, 6);
  assertEquals(3, ctorCallCount);
  assertEquals([1, 4, 5, 6, 2], lastArgs);
  assertTrue(b2.baseTagged);
})();

(function NonDefaultDerivedConstructorCalled() {
  let ctorCallCount = 0;
  let lastArgs;
  class Base {}
  class Derived extends Base {
    constructor(...args) {
      super();
      ++ctorCallCount;
      this.derivedTagged = true;
      lastArgs = args;
    }
  }
  // Nothing will be omitted.
  class A extends Derived {}
  const a = new A(1, 2, 3);
  assertEquals(1, ctorCallCount);
  assertEquals([1, 2, 3], lastArgs);
  assertTrue(a.derivedTagged);

  // 'A' default ctor will be omitted.
  class B1 extends A {}
  const b1 = new B1(4, 5, 6);
  assertEquals(2, ctorCallCount);
  assertEquals([4, 5, 6], lastArgs);
  assertTrue(b1.derivedTagged);

  // The same test with non-final spread. 'A' default ctor will be omitted.
  class B2 extends A {
    constructor(...args) { super(1, ...args, 2); }
  }
  const b2 = new B2(4, 5, 6);
  assertEquals(3, ctorCallCount);
  assertEquals([1, 4, 5, 6, 2], lastArgs);
  assertTrue(b2.derivedTagged);
})();

(function BaseFunctionCalled() {
  let baseFunctionCallCount = 0;
  function BaseFunction() {
    ++baseFunctionCallCount;
    this.baseTagged = true;
  }

  class A1 extends BaseFunction {}
  const a1 = new A1();
  assertEquals(1, baseFunctionCallCount);
  assertTrue(a1.baseTagged);

  class A2 extends BaseFunction {
    constructor(...args) { super(1, ...args, 2); }
  }
  const a2 = new A2();
  assertEquals(2, baseFunctionCallCount);
  assertTrue(a2.baseTagged);
})();

(function NonSuperclassCtor() {
  class A {};
  class B extends A {};
  class C extends B {};
  class D1 extends C {};
  class D2 extends C { constructor(...args) { super(1, ...args, 2); }}

  // Install an object which is not a constructor into the class hierarchy.
  C.__proto__ = {};

  assertThrows(() => { new C(); }, TypeError);
  assertThrows(() => { new D1(); }, TypeError);
  assertThrows(() => { new D2(); }, TypeError);
})();

(function ArgumentsEvaluatedBeforeNonSuperclassCtorDetected() {
  class A {};
  class B extends A {};
  class C extends B {};
  class D1 extends C {};
  class D2 extends C { constructor(...args) { super(1, ...args, 2); }}

  // Install an object which is not a constructor into the class hierarchy.
  C.__proto__ = {};

  let callCount = 0;
  function foo() {
    ++callCount;
  }

  assertThrows(() => { new C(foo()); }, TypeError);
  assertEquals(1, callCount);

  assertThrows(() => { new D1(foo()); }, TypeError);
  assertEquals(2, callCount);

  assertThrows(() => { new D2(foo()); }, TypeError);
  assertEquals(3, callCount);
})();

(function ArgumentsEvaluatedBeforeNonSuperclassCtorDetected2() {
  class A {};
  class B extends A {};
  class C extends B {};
  class D1 extends C {
    constructor() {
      super(foo());
    }
  };

  class D2 extends C {
    constructor(...args) {
      super(...args, foo());
    }
  };

  // Install an object which is not a constructor into the class hierarchy.
  C.__proto__ = {};

  let callCount = 0;
  function foo() {
    ++callCount;
  }

  assertThrows(() => { new D1(); }, TypeError);
  assertEquals(1, callCount);

  assertThrows(() => { new D2(); }, TypeError);
  assertEquals(2, callCount);
})();

(function EvaluatingArgumentsChangesClassHierarchy() {
  let ctorCallCount = 0;
  class A {};
  class B extends A { constructor() {
    super();
    ++ctorCallCount;
  }};
  class C extends B {};
  class D extends C {
    constructor() {
      super(foo());
    }
  };

  let fooCallCount = 0;
  function foo() {
    C.__proto__ = A;
    C.prototype.__proto__ = A.prototype;
    ++fooCallCount;
  }

  new D();
  assertEquals(1, fooCallCount);
  assertEquals(0, ctorCallCount);
})();

// The same test as the previous one, but with a ctor with a non-final spread.
(function EvaluatingArgumentsChangesClassHierarchyThisTimeWithNonFinalSpread() {
  let ctorCallCount = 0;
  class A {};
  class B extends A { constructor() {
    super();
    ++ctorCallCount;
  }};
  class C extends B {};
  class D extends C {
    constructor(...args) {
      super(...args, foo());
    }
  };

  let fooCallCount = 0;
  function foo() {
    C.__proto__ = A;
    C.prototype.__proto__ = A.prototype;
    ++fooCallCount;
  }

  new D();
  assertEquals(1, fooCallCount);
  assertEquals(0, ctorCallCount);
})();

(function BasePrivateField() {
  class A {
   #aBrand = true;
   isA() {
    return #aBrand in this;
   }
  };
  class B extends A {};
  class C1 extends B {};
  class C2 extends B { constructor(...args) { super(1, ...args, 2); }};

  const b = new B();
  assertTrue(b.isA());

  const c1 = new C1();
  assertTrue(c1.isA());

  const c2 = new C2();
  assertTrue(c2.isA());
})();

(function DerivedPrivateField() {
  class A {};
  class B extends A {
    #bBrand = true;
    isB() {
     return #bBrand in this;
    }
  };
  class C1 extends B {};
  class C2 extends B { constructor(...args) { super(1, ...args, 2); }};

  const c1 = new C1();
  assertTrue(c1.isB());

  const c2 = new C2();
  assertTrue(c2.isB());
})();

(function BasePrivateMethod() {
  class A {
   #m() { return 'private'; }
   callPrivate() {
    return this.#m();
   }
  };
  class B extends A {};
  class C1 extends B {};
  class C2 extends B { constructor(...args) { super(1, ...args, 2); }};

  const b = new B();
  assertEquals('private', b.callPrivate());

  const c1 = new C1();
  assertEquals('private', c1.callPrivate());

  const c2 = new C2();
  assertEquals('private', c2.callPrivate());
})();

(function DerivedPrivateMethod() {
  class A {};
  class B extends A {
    #m() { return 'private'; }
    callPrivate() {
     return this.#m();
    }
  };
  class C1 extends B {};
  class C2 extends B { constructor(...args) { super(1, ...args, 2); }};

  const c1 = new C1();
  assertEquals('private', c1.callPrivate());

  const c2 = new C2();
  assertEquals('private', c2.callPrivate());
})();

(function BasePrivateGetter() {
  class A {
   get #p() { return 'private'; }
   getPrivate() {
    return this.#p;
   }
  };
  class B extends A {};
  class C1 extends B {};
  class C2 extends B { constructor(...args) { super(1, ...args, 2); }};

  const b = new B();
  assertEquals('private', b.getPrivate());

  const c1 = new C1();
  assertEquals('private', c1.getPrivate());

  const c2 = new C2();
  assertEquals('private', c2.getPrivate());
})();

(function DerivedPrivateGetter() {
  class A {};
  class B extends A {
    get #p() { return 'private'; }
    getPrivate() {
     return this.#p;
    }
  };
  class C1 extends B {};
  class C2 extends B { constructor(...args) { super(1, ...args, 2); }};

  const c1 = new C1();
  assertEquals('private', c1.getPrivate());

  const c2 = new C2();
  assertEquals('private', c2.getPrivate());
})();

(function BasePrivateSetter() {
  class A {
   set #p(value) { this.secret = value; }
   setPrivate() {
    this.#p = 'private';
   }
  };
  class B extends A {};
  class C1 extends B {};
  class C2 extends B { constructor(...args) { super(1, ...args, 2); }};

  const b = new B();
  b.setPrivate();
  assertEquals('private', b.secret);

  const c1 = new C1();
  c1.setPrivate();
  assertEquals('private', c1.secret);

  const c2 = new C2();
  c2.setPrivate();
  assertEquals('private', c2.secret);
})();

(function DerivedPrivateSetter() {
  class A {};
  class B extends A {
    set #p(value) { this.secret = value; }
    setPrivate() {
     this.#p = 'private';
    }
  };
  class C1 extends B {};
  class C2 extends B { constructor(...args) { super(1, ...args, 2); }};

  const c1 = new C1();
  c1.setPrivate();
  assertEquals('private', c1.secret);

  const c2 = new C2();
  c2.setPrivate();
  assertEquals('private', c2.secret);
})();

(function BaseClassFields() {
  class A {
   aField = true;
  };
  class B extends A {};
  class C1 extends B {};
  class C2 extends B { constructor(...args) { super(1, ...args, 2); }};

  const b = new B();
  assertTrue(b.aField);

  const c1 = new C1();
  assertTrue(c1.aField);

  const c2 = new C2();
  assertTrue(c2.aField);
})();

(function DerivedClassFields() {
  class A {};
  class B extends A {
    bField = true;
  };
  class C1 extends B {};
  class C2 extends B { constructor(...args) { super(1, ...args, 2); }};

  const c1 = new C1();
  assertTrue(c1.bField);

  const c2 = new C2();
  assertTrue(c2.bField);
})();
                                                                                                node-23.7.0/deps/v8/test/mjsunit/opt-elements-kind.js                                               0000664 0000000 0000000 00000013333 14746647661 0022415 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax --expose-gc

// Limit the number of stress runs to reduce polymorphism it defeats some of the
// assumptions made about how elements transitions work because transition stubs
// end up going generic.
// Flags: --stress-runs=2

var elements_kind = {
  fast_smi_only             :  'fast smi only elements',
  fast                      :  'fast elements',
  fast_double               :  'fast double elements',
  dictionary                :  'dictionary elements',
  fixed_int32               :  'fixed int8 elements',
  fixed_uint8               :  'fixed uint8 elements',
  fixed_int16               :  'fixed int16 elements',
  fixed_uint16              :  'fixed uint16 elements',
  fixed_int32               :  'fixed int32 elements',
  fixed_uint32              :  'fixed uint32 elements',
  fixed_float32             :  'fixed float32 elements',
  fixed_float64             :  'fixed float64 elements',
  fixed_uint8_clamped       :  'fixed uint8_clamped elements'
}

function getKind(obj) {
  if (%HasSmiElements(obj)) return elements_kind.fast_smi_only;
  if (%HasObjectElements(obj)) return elements_kind.fast;
  if (%HasDoubleElements(obj)) return elements_kind.fast_double;
  if (%HasDictionaryElements(obj)) return elements_kind.dictionary;

  if (%HasFixedInt8Elements(obj)) {
    return elements_kind.fixed_int8;
  }
  if (%HasFixedUint8Elements(obj)) {
    return elements_kind.fixed_uint8;
  }
  if (%HasFixedInt16Elements(obj)) {
    return elements_kind.fixed_int16;
  }
  if (%HasFixedUint16Elements(obj)) {
    return elements_kind.fixed_uint16;
  }
  if (%HasFixedInt32Elements(obj)) {
    return elements_kind.fixed_int32;
  }
  if (%HasFixedUint32Elements(obj)) {
    return elements_kind.fixed_uint32;
  }
  if (%HasFixedFloat32Elements(obj)) {
    return elements_kind.fixed_float32;
  }
  if (%HasFixedFloat64Elements(obj)) {
    return elements_kind.fixed_float64;
  }
  if (%HasFixedUint8ClampedElements(obj)) {
    return elements_kind.fixed_uint8_clamped;
  }
}

function assertKind(expected, obj, name_opt) {
  assertEquals(expected, getKind(obj), name_opt);
}

%NeverOptimizeFunction(construct_smis);

// This code exists to eliminate the learning influence of AllocationSites
// on the following tests.
var __sequence = 0;
function make_array_string() {
  this.__sequence = this.__sequence + 1;
  return "/* " + this.__sequence + " */  [0, 0, 0];"
}
function make_array() {
  return eval(make_array_string());
}

%EnsureFeedbackVectorForFunction(construct_smis);
function construct_smis() {
  var a = make_array();
  a[0] = 0;  // Send the COW array map to the steak house.
  assertKind(elements_kind.fast_smi_only, a);
  return a;
}

%NeverOptimizeFunction(construct_doubles);
%EnsureFeedbackVectorForFunction(construct_doubles);
function construct_doubles() {
  var a = construct_smis();
  a[0] = 1.5;
  assertKind(elements_kind.fast_double, a);
  return a;
}

%NeverOptimizeFunction(convert_mixed);
%EnsureFeedbackVectorForFunction(convert_mixed);
function convert_mixed(array, value, kind) {
  array[1] = value;
  assertKind(kind, array);
  assertEquals(value, array[1]);
}

%PrepareFunctionForOptimization(test1);
function test1() {
  // Test transition chain SMI->DOUBLE->FAST (crankshafted function will
  // transition to FAST directly).
  var smis = construct_smis();
  convert_mixed(smis, 1.5, elements_kind.fast_double);

  var doubles = construct_doubles();
  convert_mixed(doubles, "three", elements_kind.fast);

  convert_mixed(construct_smis(), "three", elements_kind.fast);
  convert_mixed(construct_doubles(), "three", elements_kind.fast);

  if (%ICsAreEnabled()) {
    // Test that allocation sites allocate correct elements kind initially based
    // on previous transitions.
    smis = construct_smis();
    doubles = construct_doubles();
    convert_mixed(smis, 1, elements_kind.fast);
    convert_mixed(doubles, 1, elements_kind.fast);
    assertTrue(%HaveSameMap(smis, doubles));
  }
}

function clear_ic_state() {
  %ClearFunctionFeedback(construct_smis);
  %ClearFunctionFeedback(construct_doubles);
  %ClearFunctionFeedback(convert_mixed);
}

test1();
clear_ic_state();
test1();
clear_ic_state();
%OptimizeFunctionOnNextCall(test1);
test1();
clear_ic_state();
                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/optimized-array-every.js                                           0000664 0000000 0000000 00000033664 14746647661 0023337 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbo-inline-array-builtins --turbofan
// Flags: --no-always-turbofan --no-lazy-feedback-allocation

// TODO(v8:10195): Fix these tests s.t. we assert deoptimization occurs when
// expected (e.g. in a %DeoptimizeNow call), then remove
// --no-lazy-feedback-allocation.

// Early exit from every functions properly.
(() => {
  const a = [1, 2, 3, 4, 5];
  let result = 0;
  function earlyExit() {
    return a.every(v => {
      result += v;
      return v < 2;
    });
  }
  %PrepareFunctionForOptimization(earlyExit);
  assertFalse(earlyExit());
  earlyExit();
  %OptimizeFunctionOnNextCall(earlyExit);
  assertFalse(earlyExit());
  assertEquals(9, result);
})();

// Soft-deopt plus early exit.
(() => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  let result = 0;
  function softyPlusEarlyExit(deopt) {
     return a.every(v => {
       result += v;
       if (v === 4 && deopt) {
         a.abc = 25;
       }
       return v < 8;
     });
  }
  %PrepareFunctionForOptimization(softyPlusEarlyExit);
  assertFalse(softyPlusEarlyExit(false));
  softyPlusEarlyExit(false);
  %OptimizeFunctionOnNextCall(softyPlusEarlyExit);
  assertFalse(softyPlusEarlyExit(true));
  assertEquals(36*3, result);
})();

// Soft-deopt synced with early exit, which forces the lazy deoptimization
// continuation handler to exit.
(() => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  let called_values = [];
  function softyPlusEarlyExit(deopt) {
     called_values = [];
     return a.every(v => {
       called_values.push(v);
       if (v === 4 && deopt) {
         a.abc = 25;
         return false;
       }
       return v < 8;
     });
  }
  %PrepareFunctionForOptimization(softyPlusEarlyExit);
  assertFalse(softyPlusEarlyExit(false));
  assertArrayEquals([1, 2, 3, 4, 5, 6, 7, 8], called_values);
  softyPlusEarlyExit(false);
  %OptimizeFunctionOnNextCall(softyPlusEarlyExit);
  assertFalse(softyPlusEarlyExit(true));
  assertArrayEquals([1, 2, 3, 4], called_values);
})();

// Unknown field access leads to soft-deopt unrelated to every, should still
// lead to correct result.
(() => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
             20, 21, 22, 23, 24, 25];
  let result = 0;
  function eagerDeoptInCalled(deopt) {
    return a.every((v, i) => {
      if (i === 13 && deopt) {
        a.abc = 25;
      }
      result += v;
      return true;
    });
  }
  %PrepareFunctionForOptimization(eagerDeoptInCalled);
  eagerDeoptInCalled();
  eagerDeoptInCalled();
  %OptimizeFunctionOnNextCall(eagerDeoptInCalled);
  eagerDeoptInCalled();
  assertTrue(eagerDeoptInCalled(true));
  eagerDeoptInCalled();
  assertEquals(1625, result);
})();

// Length change detected during loop, must cause properly handled eager deopt.
(() => {
  let called_values;
  function eagerDeoptInCalled(deopt) {
    const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    called_values = [];
    return a.every((v,i) => {
      called_values.push(v);
      a.length = (i === 5 && deopt) ? 8 : 10;
      return true;
    });
  }
  %PrepareFunctionForOptimization(eagerDeoptInCalled);
  assertTrue(eagerDeoptInCalled());
  assertArrayEquals([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], called_values);
  eagerDeoptInCalled();
  %OptimizeFunctionOnNextCall(eagerDeoptInCalled);
  assertTrue(eagerDeoptInCalled());
  assertTrue(eagerDeoptInCalled(true));
  assertArrayEquals([1, 2, 3, 4, 5, 6, 7, 8], called_values);
  eagerDeoptInCalled();
})();

// Lazy deopt from a callback that changes the input array. Deopt in a callback
// execution that returns true.
(() => {
  const a = [1, 2, 3, 4, 5];
  function lazyChanger(deopt) {
    return a.every((v, i) => {
      if (i === 3 && deopt) {
        a[3] = 100;
        %DeoptimizeNow();
       }
      return true;
    });
  }
  %PrepareFunctionForOptimization(lazyChanger);
  assertTrue(lazyChanger());
  lazyChanger();
  %OptimizeFunctionOnNextCall(lazyChanger);
  assertTrue(lazyChanger(true));
  assertTrue(lazyChanger());
})();

// Lazy deopt from a callback that will always return true and no element is
// found. Verifies the lazy-after-callback continuation builtin.
(() => {
  const a = [1, 2, 3, 4, 5];
  function lazyChanger(deopt) {
    return a.every((v, i) => {
      if (i === 3 && deopt) {
        %DeoptimizeNow();
       }
      return true;
    });
  }
  %PrepareFunctionForOptimization(lazyChanger);
  assertTrue(lazyChanger());
  lazyChanger();
  %OptimizeFunctionOnNextCall(lazyChanger);
  assertTrue(lazyChanger(true));
  assertTrue(lazyChanger());
})();

// Lazy deopt from a callback that changes the input array. Deopt in a callback
// execution that returns true.
(() => {
  const a = [1, 2, 3, 4, 5];
  function lazyChanger(deopt) {
    return a.every((v, i) => {
      if (i === 2 && deopt) {
        a[3] = 100;
        %DeoptimizeNow();
       }
      return true;
    });
  }
  %PrepareFunctionForOptimization(lazyChanger);
  assertTrue(lazyChanger());
  lazyChanger();
  %OptimizeFunctionOnNextCall(lazyChanger);
  assertTrue(lazyChanger(true));
  assertTrue(lazyChanger());
})();

// Escape analyzed array
(() => {
  let result = 0;
  function eagerDeoptInCalled(deopt) {
    const a_noescape = [0, 1, 2, 3, 4, 5];
    a_noescape.every((v, i) => {
      result += v | 0;
      if (i === 13 && deopt) {
        a_noescape.length = 25;
      }
      return true;
    });
  }
  %PrepareFunctionForOptimization(eagerDeoptInCalled);
  eagerDeoptInCalled();
  eagerDeoptInCalled();
  %OptimizeFunctionOnNextCall(eagerDeoptInCalled);
  eagerDeoptInCalled();
  eagerDeoptInCalled(true);
  eagerDeoptInCalled();
  assertEquals(75, result);
})();

// Lazy deopt from runtime call from inlined callback function.
(() => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
             20, 21, 22, 23, 24, 25];
  let result = 0;
  function lazyDeopt(deopt) {
    a.every((v, i) => {
      result += i;
      if (i === 13 && deopt) {
        %DeoptimizeNow();
      }
      return true;
    });
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  lazyDeopt(true);
  lazyDeopt();
  assertEquals(1500, result);
})();

// Lazy deopt from runtime call from non-inline callback function.
(() => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
             20, 21, 22, 23, 24, 25];
  let result = 0;
  function lazyDeopt(deopt) {
    function callback(v, i) {
      result += i;
      if (i === 13 && deopt) {
        %DeoptimizeNow();
      }
      return true;
    }
    %NeverOptimizeFunction(callback);
    a.every(callback);
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  lazyDeopt(true);
  lazyDeopt();
  assertEquals(1500, result);
})();

// Call to a.every is done inside a try-catch block and the callback function
// being called actually throws.
(() => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
             20, 21, 22, 23, 24, 25];
  let caught = false;
  function lazyDeopt(deopt) {
    try {
      a.every((v, i) => {
        if (i === 1 && deopt) {
          throw("a");
        }
        return true;
      });
    } catch (e) {
      caught = true;
    }
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  assertDoesNotThrow(() => lazyDeopt(true));
  assertTrue(caught);
  lazyDeopt();
})();

// Call to a.every is done inside a try-catch block and the callback function
// being called actually throws, but the callback is not inlined.
(() => {
  let a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  let caught = false;
  function lazyDeopt(deopt) {
    function callback(v, i) {
      if (i === 1 && deopt) {
        throw("a");
      }
      return true;
    }
    %NeverOptimizeFunction(callback);
    try {
      a.every(callback);
    } catch (e) {
      caught = true;
    }
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  assertDoesNotThrow(() => lazyDeopt(true));
  assertTrue(caught);
  lazyDeopt();
})();

// Call to a.every is done inside a try-catch block and the callback function
// being called throws into a deoptimized caller function.
(function TestThrowIntoDeoptimizedOuter() {
  const a = [1, 2, 3, 4];
  function lazyDeopt(deopt) {
    function callback(v, i) {
      if (i === 1 && deopt) {
        %DeoptimizeFunction(lazyDeopt);
        throw "some exception";
      }
      return true;
    }
    %NeverOptimizeFunction(callback);
    let result = 0;
    try {
      result = a.every(callback);
    } catch (e) {
      assertEquals("some exception", e);
      result = "nope";
    }
    return result;
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  assertEquals(true, lazyDeopt(false));
  assertEquals(true, lazyDeopt(false));
  assertEquals("nope", lazyDeopt(true));
  assertEquals("nope", lazyDeopt(true));
  %OptimizeFunctionOnNextCall(lazyDeopt);
  assertEquals(true, lazyDeopt(false));
  assertEquals("nope", lazyDeopt(true));
})();

// An error generated inside the callback includes every in it's
// stack trace.
(() => {
  const re = /Array\.every/;
  function lazyDeopt(deopt) {
    const b = [1, 2, 3];
    let result = 0;
    b.every((v, i) => {
      result += v;
      if (i === 1) {
        const e = new Error();
        assertTrue(re.exec(e.stack) !== null);
      }
      return true;
    });
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
})();

// An error generated inside a non-inlined callback function also
// includes every in it's stack trace.
(() => {
  const re = /Array\.every/;
  function lazyDeopt(deopt) {
    const b = [1, 2, 3];
    let did_assert_error = false;
    let result = 0;
    function callback(v, i) {
      result += v;
      if (i === 1) {
        const e = new Error();
        assertTrue(re.exec(e.stack) !== null);
        did_assert_error = true;
      }
      return true;
    }
    %NeverOptimizeFunction(callback);
    b.every(callback);
    return did_assert_error;
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  assertTrue(lazyDeopt());
})();

// An error generated inside a recently deoptimized callback function
// includes every in it's stack trace.
(() => {
  const re = /Array\.every/;
  function lazyDeopt(deopt) {
    const b = [1, 2, 3];
    let did_assert_error = false;
    let result = 0;
    b.every((v, i) => {
      result += v;
      if (i === 1) {
        %DeoptimizeNow();
      } else if (i === 2) {
        const e = new Error();
        assertTrue(re.exec(e.stack) !== null);
        did_assert_error = true;
      }
      return true;
    });
    return did_assert_error;
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  assertTrue(lazyDeopt());
})();

// Verify that various exception edges are handled appropriately.
// The thrown Error object should always indicate it was created from
// an every call stack.
(() => {
  const re = /Array\.every/;
  const a = [1, 2, 3];
  let result = 0;
  function lazyDeopt() {
    a.every((v, i) => {
      result += i;
      if (i === 1) {
        %DeoptimizeFunction(lazyDeopt);
        throw new Error();
      }
      return true;
    });
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  assertThrows(() => lazyDeopt());
  assertThrows(() => lazyDeopt());
  try {
    lazyDeopt();
  } catch (e) {
    assertTrue(re.exec(e.stack) !== null);
  }
  %OptimizeFunctionOnNextCall(lazyDeopt);
  try {
    lazyDeopt();
  } catch (e) {
    assertTrue(re.exec(e.stack) !== null);
  }
})();

// Verify holes are skipped.
(() => {
  const a = [1, 2, , 3, 4];
  function withHoles() {
    const callback_values = [];
    a.every(v => {
      callback_values.push(v);
      return true;
    });
    return callback_values;
  }
  %PrepareFunctionForOptimization(withHoles);
  withHoles();
  withHoles();
  %OptimizeFunctionOnNextCall(withHoles);
  assertArrayEquals([1, 2, 3, 4], withHoles());
})();

(() => {
  const a = [1.5, 2.5, , 3.5, 4.5];
  function withHoles() {
    const callback_values = [];
    a.every(v => {
      callback_values.push(v);
      return true;
    });
    return callback_values;
  }
  %PrepareFunctionForOptimization(withHoles);
  withHoles();
  withHoles();
  %OptimizeFunctionOnNextCall(withHoles);
  assertArrayEquals([1.5, 2.5, 3.5, 4.5], withHoles());
})();

// Ensure that we handle side-effects between load and call.
(() => {
  function side_effect(a, b) { if (b) a.foo = 3; return a; }
  %NeverOptimizeFunction(side_effect);

  function unreliable(a, b) {
    return a.every(x => true, side_effect(a, b));
  }
  %PrepareFunctionForOptimization(unreliable);

  let a = [1, 2, 3];
  unreliable(a, false);
  unreliable(a, false);
  %OptimizeFunctionOnNextCall(unreliable);
  unreliable(a, false);
  // Now actually do change the map.
  unreliable(a, true);
})();

// Handle callback is not callable.
(() => {
  const a = [1, 2, 3, 4, 5];
  function notCallable() {
    return a.every(undefined);
  }
  %PrepareFunctionForOptimization(notCallable);

  assertThrows(notCallable, TypeError);
  try { notCallable(); } catch(e) { }
  %OptimizeFunctionOnNextCall(notCallable);
  assertThrows(notCallable, TypeError);
})();

// Messing with the Array prototype causes deoptimization.
(() => {
  const a = [1, 2, 3];
  let result = 0;
  function prototypeChanged() {
    a.every((v, i) => {
      result += v;
      return true;
    });
  }
  %PrepareFunctionForOptimization(prototypeChanged);
  prototypeChanged();
  prototypeChanged();
  %OptimizeFunctionOnNextCall(prototypeChanged);
  prototypeChanged();
  a.constructor = {};
  prototypeChanged();
  assertUnoptimized(prototypeChanged);
  assertEquals(24, result);
})();
                                                                            node-23.7.0/deps/v8/test/mjsunit/optimized-array-find.js                                            0000664 0000000 0000000 00000030667 14746647661 0023125 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbo-inline-array-builtins --turbofan
// Flags: --no-always-turbofan --no-lazy-feedback-allocation

// TODO(v8:10195): Fix these tests s.t. we assert deoptimization occurs when
// expected (e.g. in a %DeoptimizeNow call), then remove
// --no-lazy-feedback-allocation.

// Unknown field access leads to soft-deopt unrelated to find, should still
// lead to correct result.
(() => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
             20, 21, 22, 23, 24, 25];
  let result = 0;
  function eagerDeoptInCalled(deopt) {
    return a.find((v, i) => {
      if (i === 13 && deopt) {
        a.abc = 25;
      }
      result += v;
      return v === 20;
    });
  }
  %PrepareFunctionForOptimization(eagerDeoptInCalled);
  eagerDeoptInCalled();
  eagerDeoptInCalled();
  %OptimizeFunctionOnNextCall(eagerDeoptInCalled);
  eagerDeoptInCalled();
  assertEquals(20, eagerDeoptInCalled(true));
  eagerDeoptInCalled();
  assertEquals(1050, result);
})();

// Length change detected during loop, must cause properly handled eager deopt.
(() => {
  let called_values;
  function eagerDeoptInCalled(deopt) {
    const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    called_values = [];
    return a.find((v,i) => {
      called_values.push(v);
      a.length = (i === 5 && deopt) ? 8 : 10;
      return v === 9;
    });
  }
  %PrepareFunctionForOptimization(eagerDeoptInCalled);
  assertEquals(9, eagerDeoptInCalled());
  assertArrayEquals([1, 2, 3, 4, 5, 6, 7, 8, 9], called_values);
  eagerDeoptInCalled();
  %OptimizeFunctionOnNextCall(eagerDeoptInCalled);
  assertEquals(9, eagerDeoptInCalled());
  assertEquals(undefined, eagerDeoptInCalled(true));
  assertArrayEquals([1, 2, 3, 4, 5, 6, 7, 8, undefined, undefined],
                    called_values);
  eagerDeoptInCalled();
})();

// Lazy deopt from a callback that changes the input array. Deopt in a callback
// execution that returns true.
(() => {
  const a = [1, 2, 3, 4, 5];
  function lazyChanger(deopt) {
    return a.find((v, i) => {
      if (i === 3 && deopt) {
        a[3] = 100;
        %DeoptimizeNow();
       }
      return v > 3;
    });
  }
  %PrepareFunctionForOptimization(lazyChanger);
  assertEquals(4, lazyChanger());
  lazyChanger();
  %OptimizeFunctionOnNextCall(lazyChanger);
  assertEquals(4, lazyChanger(true));
  assertEquals(100, lazyChanger());
})();

// Lazy deopt from a callback that will always return false and no element is
// found. Verifies the lazy-after-callback continuation builtin.
(() => {
  const a = [1, 2, 3, 4, 5];
  function lazyChanger(deopt) {
    return a.find((v, i) => {
      if (i === 3 && deopt) {
        %DeoptimizeNow();
       }
      return false;
    });
  }
  %PrepareFunctionForOptimization(lazyChanger);
  assertEquals(undefined, lazyChanger());
  lazyChanger();
  %OptimizeFunctionOnNextCall(lazyChanger);
  assertEquals(undefined, lazyChanger(true));
  assertEquals(undefined, lazyChanger());
})();

// Lazy deopt from a callback that changes the input array. Deopt in a callback
// execution that returns false.
(() => {
  const a = [1, 2, 3, 4, 5];
  function lazyChanger(deopt) {
    return a.find((v, i) => {
      if (i === 2 && deopt) {
        a[3] = 100;
        %DeoptimizeNow();
       }
      return v > 3;
    });
  }
  %PrepareFunctionForOptimization(lazyChanger);
  assertEquals(4, lazyChanger());
  lazyChanger();
  %OptimizeFunctionOnNextCall(lazyChanger);
  assertEquals(100, lazyChanger(true));
  assertEquals(100, lazyChanger());
})();

// Escape analyzed array
(() => {
  let result = 0;
  function eagerDeoptInCalled(deopt) {
    const a_noescape = [0, 1, 2, 3, 4, 5];
    a_noescape.find((v, i) => {
      result += v | 0;
      if (i === 13 && deopt) {
        a_noescape.length = 25;
      }
      return false;
    });
  }
  %PrepareFunctionForOptimization(eagerDeoptInCalled);
  eagerDeoptInCalled();
  eagerDeoptInCalled();
  %OptimizeFunctionOnNextCall(eagerDeoptInCalled);
  eagerDeoptInCalled();
  eagerDeoptInCalled(true);
  eagerDeoptInCalled();
  assertEquals(75, result);
})();

// Lazy deopt from runtime call from inlined callback function.
(() => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
             20, 21, 22, 23, 24, 25];
  let result = 0;
  function lazyDeopt(deopt) {
    a.find((v, i) => {
      result += i;
      if (i === 13 && deopt) {
        %DeoptimizeNow();
      }
      return false;
    });
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  lazyDeopt(true);
  lazyDeopt();
  assertEquals(1500, result);
})();

// Lazy deopt from runtime call from non-inline callback function.
(() => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
             20, 21, 22, 23, 24, 25];
  let result = 0;
  function lazyDeopt(deopt) {
    function callback(v, i) {
      result += i;
      if (i === 13 && deopt) {
        %DeoptimizeNow();
      }
      return false;
    }
    %NeverOptimizeFunction(callback);
    a.find(callback);
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  lazyDeopt(true);
  lazyDeopt();
  assertEquals(1500, result);
})();

// Call to a.find is done inside a try-catch block and the callback function
// being called actually throws.
(() => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
             20, 21, 22, 23, 24, 25];
  let caught = false;
  function lazyDeopt(deopt) {
    try {
      a.find((v, i) => {
        if (i === 1 && deopt) {
          throw("a");
        }
        return false;
      });
    } catch (e) {
      caught = true;
    }
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  assertDoesNotThrow(() => lazyDeopt(true));
  assertTrue(caught);
  lazyDeopt();
})();

// Call to a.find is done inside a try-catch block and the callback function
// being called actually throws, but the callback is not inlined.
(() => {
  let a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  let caught = false;
  function lazyDeopt(deopt) {
    function callback(v, i) {
      if (i === 1 && deopt) {
        throw("a");
      }
      return false;
    }
    %NeverOptimizeFunction(callback);
    try {
      a.find(callback);
    } catch (e) {
      caught = true;
    }
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  assertDoesNotThrow(() => lazyDeopt(true));
  assertTrue(caught);
  lazyDeopt();
})();

// Call to a.find is done inside a try-catch block and the callback function
// being called throws into a deoptimized caller function.
(function TestThrowIntoDeoptimizedOuter() {
  const a = [1, 2, 3, 4];
  function lazyDeopt(deopt) {
    function callback(v, i) {
      if (i === 1 && deopt) {
        %DeoptimizeFunction(lazyDeopt);
        throw "some exception";
      }
      return v === 3;
    }
    %NeverOptimizeFunction(callback);
    let result = 0;
    try {
      result = a.find(callback);
    } catch (e) {
      assertEquals("some exception", e);
      result = "nope";
    }
    return result;
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  assertEquals(3, lazyDeopt(false));
  assertEquals(3, lazyDeopt(false));
  assertEquals("nope", lazyDeopt(true));
  assertEquals("nope", lazyDeopt(true));
  %OptimizeFunctionOnNextCall(lazyDeopt);
  assertEquals(3, lazyDeopt(false));
  assertEquals("nope", lazyDeopt(true));
})();

// An error generated inside the callback includes find in it's
// stack trace.
(() => {
  const re = /Array\.find/;
  function lazyDeopt(deopt) {
    const b = [1, 2, 3];
    let result = 0;
    b.find((v, i) => {
      result += v;
      if (i === 1) {
        const e = new Error();
        assertTrue(re.exec(e.stack) !== null);
      }
      return false;
    });
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
})();

// An error generated inside a non-inlined callback function also
// includes find in it's stack trace.
(() => {
  const re = /Array\.find/;
  function lazyDeopt(deopt) {
    const b = [1, 2, 3];
    let did_assert_error = false;
    let result = 0;
    function callback(v, i) {
      result += v;
      if (i === 1) {
        const e = new Error();
        assertTrue(re.exec(e.stack) !== null);
        did_assert_error = true;
      }
      return false;
    }
    %NeverOptimizeFunction(callback);
    b.find(callback);
    return did_assert_error;
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  assertTrue(lazyDeopt());
})();

// An error generated inside a recently deoptimized callback function
// includes find in it's stack trace.
(() => {
  const re = /Array\.find/;
  function lazyDeopt(deopt) {
    const b = [1, 2, 3];
    let did_assert_error = false;
    let result = 0;
    b.find((v, i) => {
      result += v;
      if (i === 1) {
        %DeoptimizeNow();
      } else if (i === 2) {
        const e = new Error();
        assertTrue(re.exec(e.stack) !== null);
        did_assert_error = true;
      }
      return false;
    });
    return did_assert_error;
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  assertTrue(lazyDeopt());
})();

// Verify that various exception edges are handled appropriately.
// The thrown Error object should always indicate it was created from
// a find call stack.
(() => {
  const re = /Array\.find/;
  const a = [1, 2, 3];
  let result = 0;
  function lazyDeopt() {
    a.find((v, i) => {
      result += i;
      if (i === 1) {
        %DeoptimizeFunction(lazyDeopt);
        throw new Error();
      }
      return false;
    });
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  assertThrows(() => lazyDeopt());
  assertThrows(() => lazyDeopt());
  try {
    lazyDeopt();
  } catch (e) {
    assertTrue(re.exec(e.stack) !== null);
  }
  %OptimizeFunctionOnNextCall(lazyDeopt);
  try {
    lazyDeopt();
  } catch (e) {
    assertTrue(re.exec(e.stack) !== null);
  }
})();

// Messing with the Array prototype causes deoptimization.
(() => {
  const a = [1, 2, 3];
  let result = 0;
  function prototypeChanged() {
    a.find((v, i) => {
      result += v;
      return false;
    });
  }
  %PrepareFunctionForOptimization(prototypeChanged);
  prototypeChanged();
  prototypeChanged();
  %OptimizeFunctionOnNextCall(prototypeChanged);
  prototypeChanged();
  a.constructor = {};
  prototypeChanged();
  assertUnoptimized(prototypeChanged);
  assertEquals(24, result);
})();

// Verify holes are replaced with undefined.
(() => {
  const a = [1, 2, , 3, 4];
  function withHoles() {
    const callback_values = [];
    a.find(v => {
      callback_values.push(v);
      return false;
    });
    return callback_values;
  }
  %PrepareFunctionForOptimization(withHoles);
  withHoles();
  withHoles();
  %OptimizeFunctionOnNextCall(withHoles);
  assertArrayEquals([1, 2, undefined, 3, 4], withHoles());
})();

(() => {
  const a = [1.5, 2.5, , 3.5, 4.5];
  function withHoles() {
    const callback_values = [];
    a.find(v => {
      callback_values.push(v);
      return false;
    });
    return callback_values;
  }
  %PrepareFunctionForOptimization(withHoles);
  withHoles();
  withHoles();
  %OptimizeFunctionOnNextCall(withHoles);
  assertArrayEquals([1.5, 2.5, undefined, 3.5, 4.5], withHoles());
})();

// Ensure that we handle side-effects between load and call.
(() => {
  function side_effect(a, b) { if (b) a.foo = 3; return a; }
  %NeverOptimizeFunction(side_effect);

  function unreliable(a, b) {
    return a.find(x => false, side_effect(a, b));
  }
  %PrepareFunctionForOptimization(unreliable);

  let a = [1, 2, 3];
  unreliable(a, false);
  unreliable(a, false);
  %OptimizeFunctionOnNextCall(unreliable);
  unreliable(a, false);
  // Now actually do change the map.
  unreliable(a, true);
})();

// Handle callback is not callable.
(() => {
  const a = [1, 2, 3, 4, 5];
  function notCallable() {
    return a.find(undefined);
  }
  %PrepareFunctionForOptimization(notCallable);

  assertThrows(notCallable, TypeError);
  try { notCallable(); } catch(e) { }
  %OptimizeFunctionOnNextCall(notCallable);
  assertThrows(notCallable, TypeError);
})();
                                                                         node-23.7.0/deps/v8/test/mjsunit/optimized-array-findindex.js                                       0000664 0000000 0000000 00000031061 14746647661 0024142 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbo-inline-array-builtins --turbofan
// Flags: --no-always-turbofan --no-lazy-feedback-allocation

// TODO(v8:10195): Fix these tests s.t. we assert deoptimization occurs when
// expected (e.g. in a %DeoptimizeNow call), then remove
// --no-lazy-feedback-allocation.

// Unknown field access leads to soft-deopt unrelated to findIndex, should still
// lead to correct result.
(() => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
             20, 21, 22, 23, 24, 25];
  let result = 0;
  function eagerDeoptInCalled(deopt) {
    return a.findIndex((v, i) => {
      if (i === 13 && deopt) {
        a.abc = 25;
      }
      result += v;
      return v === 20;
    });
  }
  %PrepareFunctionForOptimization(eagerDeoptInCalled);
  eagerDeoptInCalled();
  eagerDeoptInCalled();
  %OptimizeFunctionOnNextCall(eagerDeoptInCalled);
  eagerDeoptInCalled();
  assertEquals(19, eagerDeoptInCalled(true));
  eagerDeoptInCalled();
  assertEquals(1050, result);
})();

// Length change detected during loop, must cause properly handled eager deopt.
(() => {
  let called_values;
  function eagerDeoptInCalled(deopt) {
    const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    called_values = [];
    return a.findIndex((v,i) => {
      called_values.push(v);
      a.length = (i === 5 && deopt) ? 8 : 10;
      return v === 9;
    });
  }
  %PrepareFunctionForOptimization(eagerDeoptInCalled);
  assertEquals(8, eagerDeoptInCalled());
  assertArrayEquals([1, 2, 3, 4, 5, 6, 7, 8, 9], called_values);
  eagerDeoptInCalled();
  %OptimizeFunctionOnNextCall(eagerDeoptInCalled);
  assertEquals(8, eagerDeoptInCalled());
  assertEquals(-1, eagerDeoptInCalled(true));
  assertArrayEquals([1, 2, 3, 4, 5, 6, 7, 8, undefined, undefined],
                    called_values);
  eagerDeoptInCalled();
})();

// Lazy deopt from a callback that changes the input array. Deopt in a callback
// execution that returns true.
(() => {
  const a = [1, 2, 3, 4, 5];
  function lazyChanger(deopt) {
    return a.findIndex((v, i) => {
      if (i === 3 && deopt) {
        a[3] = 3;
        %DeoptimizeNow();
       }
      return v > 3;
    });
  }
  %PrepareFunctionForOptimization(lazyChanger);
  assertEquals(3, lazyChanger());
  lazyChanger();
  %OptimizeFunctionOnNextCall(lazyChanger);
  assertEquals(3, lazyChanger(true));
  assertEquals(4, lazyChanger());
})();

// Lazy deopt from a callback that will always return false and no element is
// found. Verifies the lazy-after-callback continuation builtin.
(() => {
  const a = [1, 2, 3, 4, 5];
  function lazyChanger(deopt) {
    return a.findIndex((v, i) => {
      if (i === 3 && deopt) {
        %DeoptimizeNow();
       }
      return false;
    });
  }
  %PrepareFunctionForOptimization(lazyChanger);
  assertEquals(-1, lazyChanger());
  lazyChanger();
  %OptimizeFunctionOnNextCall(lazyChanger);
  assertEquals(-1, lazyChanger(true));
  assertEquals(-1, lazyChanger());
})();

// Lazy deopt from a callback that changes the input array. Deopt in a callback
// execution that returns false.
(() => {
  const a = [1, 2, 3, 4, 5];
  function lazyChanger(deopt) {
    return a.findIndex((v, i) => {
      if (i === 2 && deopt) {
        a[3] = 2;
        %DeoptimizeNow();
       }
      return v > 3;
    });
  }
  %PrepareFunctionForOptimization(lazyChanger);
  assertEquals(3, lazyChanger());
  lazyChanger();
  %OptimizeFunctionOnNextCall(lazyChanger);
  assertEquals(4, lazyChanger(true));
  assertEquals(4, lazyChanger());
})();

// Escape analyzed array
(() => {
  let result = 0;
  function eagerDeoptInCalled(deopt) {
    const a_noescape = [0, 1, 2, 3, 4, 5];
    a_noescape.findIndex((v, i) => {
      result += v | 0;
      if (i === 13 && deopt) {
        a_noescape.length = 25;
      }
      return false;
    });
  }
  %PrepareFunctionForOptimization(eagerDeoptInCalled);
  eagerDeoptInCalled();
  eagerDeoptInCalled();
  %OptimizeFunctionOnNextCall(eagerDeoptInCalled);
  eagerDeoptInCalled();
  eagerDeoptInCalled(true);
  eagerDeoptInCalled();
  assertEquals(75, result);
})();

// Lazy deopt from runtime call from inlined callback function.
(() => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
             20, 21, 22, 23, 24, 25];
  let result = 0;
  function lazyDeopt(deopt) {
    a.findIndex((v, i) => {
      result += i;
      if (i === 13 && deopt) {
        %DeoptimizeNow();
      }
      return false;
    });
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  lazyDeopt(true);
  lazyDeopt();
  assertEquals(1500, result);
})();

// Lazy deopt from runtime call from non-inline callback function.
(() => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
             20, 21, 22, 23, 24, 25];
  let result = 0;
  function lazyDeopt(deopt) {
    function callback(v, i) {
      result += i;
      if (i === 13 && deopt) {
        %DeoptimizeNow();
      }
      return false;
    }
    %NeverOptimizeFunction(callback);
    a.findIndex(callback);
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  lazyDeopt(true);
  lazyDeopt();
  assertEquals(1500, result);
})();

// Call to a.findIndex is done inside a try-catch block and the callback function
// being called actually throws.
(() => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
             20, 21, 22, 23, 24, 25];
  let caught = false;
  function lazyDeopt(deopt) {
    try {
      a.findIndex((v, i) => {
        if (i === 1 && deopt) {
          throw("a");
        }
        return false;
      });
    } catch (e) {
      caught = true;
    }
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  assertDoesNotThrow(() => lazyDeopt(true));
  assertTrue(caught);
  lazyDeopt();
})();

// Call to a.findIndex is done inside a try-catch block and the callback function
// being called actually throws, but the callback is not inlined.
(() => {
  let a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  let caught = false;
  function lazyDeopt(deopt) {
    function callback(v, i) {
      if (i === 1 && deopt) {
        throw("a");
      }
      return false;
    }
    %NeverOptimizeFunction(callback);
    try {
      a.findIndex(callback);
    } catch (e) {
      caught = true;
    }
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  assertDoesNotThrow(() => lazyDeopt(true));
  assertTrue(caught);
  lazyDeopt();
})();

// Call to a.findIndex is done inside a try-catch block and the callback function
// being called throws into a deoptimized caller function.
(function TestThrowIntoDeoptimizedOuter() {
  const a = [1, 2, 3, 4];
  function lazyDeopt(deopt) {
    function callback(v, i) {
      if (i === 1 && deopt) {
        %DeoptimizeFunction(lazyDeopt);
        throw "some exception";
      }
      return v === 3;
    }
    %NeverOptimizeFunction(callback);
    let result = 0;
    try {
      result = a.findIndex(callback);
    } catch (e) {
      assertEquals("some exception", e);
      result = "nope";
    }
    return result;
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  assertEquals(2, lazyDeopt(false));
  assertEquals(2, lazyDeopt(false));
  assertEquals("nope", lazyDeopt(true));
  assertEquals("nope", lazyDeopt(true));
  %OptimizeFunctionOnNextCall(lazyDeopt);
  assertEquals(2, lazyDeopt(false));
  assertEquals("nope", lazyDeopt(true));
})();

// An error generated inside the callback includes findIndex in it's
// stack trace.
(() => {
  const re = /Array\.findIndex/;
  function lazyDeopt(deopt) {
    const b = [1, 2, 3];
    let result = 0;
    b.findIndex((v, i) => {
      result += v;
      if (i === 1) {
        const e = new Error();
        assertTrue(re.exec(e.stack) !== null);
      }
      return false;
    });
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
})();

// An error generated inside a non-inlined callback function also
// includes findIndex in it's stack trace.
(() => {
  const re = /Array\.findIndex/;
  function lazyDeopt(deopt) {
    const b = [1, 2, 3];
    let did_assert_error = false;
    let result = 0;
    function callback(v, i) {
      result += v;
      if (i === 1) {
        const e = new Error();
        assertTrue(re.exec(e.stack) !== null);
        did_assert_error = true;
      }
      return false;
    }
    %NeverOptimizeFunction(callback);
    b.findIndex(callback);
    return did_assert_error;
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  assertTrue(lazyDeopt());
})();

// An error generated inside a recently deoptimized callback function
// includes findIndex in it's stack trace.
(() => {
  const re = /Array\.findIndex/;
  function lazyDeopt(deopt) {
    const b = [1, 2, 3];
    let did_assert_error = false;
    let result = 0;
    b.findIndex((v, i) => {
      result += v;
      if (i === 1) {
        %DeoptimizeNow();
      } else if (i === 2) {
        const e = new Error();
        assertTrue(re.exec(e.stack) !== null);
        did_assert_error = true;
      }
      return false;
    });
    return did_assert_error;
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  assertTrue(lazyDeopt());
})();

// Verify that various exception edges are handled appropriately.
// The thrown Error object should always indicate it was created from
// a findIndex call stack.
(() => {
  const re = /Array\.findIndex/;
  const a = [1, 2, 3];
  let result = 0;
  function lazyDeopt() {
    a.findIndex((v, i) => {
      result += i;
      if (i === 1) {
        %DeoptimizeFunction(lazyDeopt);
        throw new Error();
      }
      return false;
    });
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  assertThrows(() => lazyDeopt());
  assertThrows(() => lazyDeopt());
  try {
    lazyDeopt();
  } catch (e) {
    assertTrue(re.exec(e.stack) !== null);
  }
  %OptimizeFunctionOnNextCall(lazyDeopt);
  try {
    lazyDeopt();
  } catch (e) {
    assertTrue(re.exec(e.stack) !== null);
  }
})();

// Messing with the Array prototype causes deoptimization.
(() => {
  const a = [1, 2, 3];
  let result = 0;
  function prototypeChanged() {
    a.findIndex((v, i) => {
      result += v;
      return false;
    });
  }
  %PrepareFunctionForOptimization(prototypeChanged);
  prototypeChanged();
  prototypeChanged();
  %OptimizeFunctionOnNextCall(prototypeChanged);
  prototypeChanged();
  a.constructor = {};
  prototypeChanged();
  assertUnoptimized(prototypeChanged);
  assertEquals(24, result);
})();

// Verify holes are replaced with undefined.
(() => {
  const a = [1, 2, , 3, 4];
  function withHoles() {
    const callback_values = [];
    a.findIndex(v => {
      callback_values.push(v);
      return false;
    });
    return callback_values;
  }
  %PrepareFunctionForOptimization(withHoles);
  withHoles();
  withHoles();
  %OptimizeFunctionOnNextCall(withHoles);
  assertArrayEquals([1, 2, undefined, 3, 4], withHoles());
})();

(() => {
  const a = [1.5, 2.5, , 3.5, 4.5];
  function withHoles() {
    const callback_values = [];
    a.findIndex(v => {
      callback_values.push(v);
      return false;
    });
    return callback_values;
  }
  %PrepareFunctionForOptimization(withHoles);
  withHoles();
  withHoles();
  %OptimizeFunctionOnNextCall(withHoles);
  assertArrayEquals([1.5, 2.5, undefined, 3.5, 4.5], withHoles());
})();

// Ensure that we handle side-effects between load and call.
(() => {
  function side_effect(a, b) { if (b) a.foo = 3; return a; }
  %NeverOptimizeFunction(side_effect);

  function unreliable(a, b) {
    return a.findIndex(x => false, side_effect(a, b));
  }
  %PrepareFunctionForOptimization(unreliable);

  let a = [1, 2, 3];
  unreliable(a, false);
  unreliable(a, false);
  %OptimizeFunctionOnNextCall(unreliable);
  unreliable(a, false);
  // Now actually do change the map.
  unreliable(a, true);
})();

// Handle callback is not callable.
(() => {
  const a = [1, 2, 3, 4, 5];
  function notCallable() {
    return a.findIndex(undefined);
  }
  %PrepareFunctionForOptimization(notCallable);

  assertThrows(notCallable, TypeError);
  try { notCallable(); } catch(e) { }
  %OptimizeFunctionOnNextCall(notCallable);
  assertThrows(notCallable, TypeError);
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/optimized-array-some.js                                            0000664 0000000 0000000 00000032665 14746647661 0023150 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbo-inline-array-builtins --turbofan
// Flags: --no-always-turbofan --no-lazy-feedback-allocation

// TODO(v8:10195): Fix these tests s.t. we assert deoptimization occurs when
// expected (e.g. in a %DeoptimizeNow call), then remove
// --no-lazy-feedback-allocation.

// Early exit from some functions properly.
(() => {
  const a = [1, 2, 3, 4, 5];
  let result = 0;
  function earlyExit() {
    return a.some(v => {
      result += v;
      return v > 2;
    });
  }
  %PrepareFunctionForOptimization(earlyExit);
  assertTrue(earlyExit());
  earlyExit();
  %OptimizeFunctionOnNextCall(earlyExit);
  assertTrue(earlyExit());
  assertEquals(18, result);
})();

// Soft-deopt plus early exit.
(() => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  let result = 0;
  function softyPlusEarlyExit(deopt) {
     return a.some(v => {
       result += v;
       if (v === 4 && deopt) {
         a.abc = 25;
       }
       return v > 7;
     });
  }
  %PrepareFunctionForOptimization(softyPlusEarlyExit);
  assertTrue(softyPlusEarlyExit(false));
  softyPlusEarlyExit(false);
  %OptimizeFunctionOnNextCall(softyPlusEarlyExit);
  assertTrue(softyPlusEarlyExit(true));
  assertEquals(36*3, result);
})();

// Soft-deopt synced with early exit, which forces the lazy deoptimization
// continuation handler to exit.
(() => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  let called_values = [];
  function softyPlusEarlyExit(deopt) {
     called_values = [];
     return a.some(v => {
       called_values.push(v);
       if (v === 4 && deopt) {
         a.abc = 25;
         return true;
       }
       return v > 7;
     });
  }
  %PrepareFunctionForOptimization(softyPlusEarlyExit);
  assertTrue(softyPlusEarlyExit(false));
  assertArrayEquals([1, 2, 3, 4, 5, 6, 7, 8], called_values);
  softyPlusEarlyExit(false);
  %OptimizeFunctionOnNextCall(softyPlusEarlyExit);
  assertTrue(softyPlusEarlyExit(true));
  assertArrayEquals([1, 2, 3, 4], called_values);
})();

// Unknown field access leads to soft-deopt unrelated to some, should still
// lead to correct result.
(() => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
             20, 21, 22, 23, 24, 25];
  let result = 0;
  function eagerDeoptInCalled(deopt) {
    return a.some((v, i) => {
      if (i === 13 && deopt) {
        a.abc = 25;
      }
      result += v;
      return false;
    });
  }
  %PrepareFunctionForOptimization(eagerDeoptInCalled);
  eagerDeoptInCalled();
  eagerDeoptInCalled();
  %OptimizeFunctionOnNextCall(eagerDeoptInCalled);
  eagerDeoptInCalled();
  assertFalse(eagerDeoptInCalled(true));
  eagerDeoptInCalled();
  assertEquals(1625, result);
})();

// Length change detected during loop, must cause properly handled eager deopt.
(() => {
  let called_values;
  function eagerDeoptInCalled(deopt) {
    const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
    called_values = [];
    return a.some((v,i) => {
      called_values.push(v);
      a.length = (i === 5 && deopt) ? 8 : 10;
      return false;
    });
  }
  %PrepareFunctionForOptimization(eagerDeoptInCalled);
  assertFalse(eagerDeoptInCalled());
  assertArrayEquals([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], called_values);
  eagerDeoptInCalled();
  %OptimizeFunctionOnNextCall(eagerDeoptInCalled);
  assertFalse(eagerDeoptInCalled());
  assertFalse(eagerDeoptInCalled(true));
  assertArrayEquals([1, 2, 3, 4, 5, 6, 7, 8], called_values);
  eagerDeoptInCalled();
})();

// Lazy deopt from a callback that changes the input array. Deopt in a callback
// execution that returns true.
(() => {
  const a = [1, 2, 3, 4, 5];
  function lazyChanger(deopt) {
    return a.some((v, i) => {
      if (i === 3 && deopt) {
        a[3] = 100;
        %DeoptimizeNow();
       }
      return false;
    });
  }
  %PrepareFunctionForOptimization(lazyChanger);
  assertFalse(lazyChanger());
  lazyChanger();
  %OptimizeFunctionOnNextCall(lazyChanger);
  assertFalse(lazyChanger(true));
  assertFalse(lazyChanger());
})();

// Lazy deopt from a callback that will always return false and no element is
// found. Verifies the lazy-after-callback continuation builtin.
(() => {
  const a = [1, 2, 3, 4, 5];
  function lazyChanger(deopt) {
    return a.some((v, i) => {
      if (i === 3 && deopt) {
        %DeoptimizeNow();
       }
      return false;
    });
  }
  %PrepareFunctionForOptimization(lazyChanger);
  assertFalse(lazyChanger());
  lazyChanger();
  %OptimizeFunctionOnNextCall(lazyChanger);
  assertFalse(lazyChanger(true));
  assertFalse(lazyChanger());
})();

// Lazy deopt from a callback that changes the input array. Deopt in a callback
// execution that returns false.
(() => {
  const a = [1, 2, 3, 4, 5];
  function lazyChanger(deopt) {
    return a.every((v, i) => {
      if (i === 2 && deopt) {
        a[3] = 100;
        %DeoptimizeNow();
       }
      return false;
    });
  }
  %PrepareFunctionForOptimization(lazyChanger);
  assertFalse(lazyChanger());
  lazyChanger();
  %OptimizeFunctionOnNextCall(lazyChanger);
  assertFalse(lazyChanger(true));
  assertFalse(lazyChanger());
})();

// Escape analyzed array
(() => {
  let result = 0;
  function eagerDeoptInCalled(deopt) {
    const a_noescape = [0, 1, 2, 3, 4, 5];
    a_noescape.some((v, i) => {
      result += v | 0;
      if (i === 13 && deopt) {
        a_noescape.length = 25;
      }
      return false;
    });
  }
  %PrepareFunctionForOptimization(eagerDeoptInCalled);
  eagerDeoptInCalled();
  eagerDeoptInCalled();
  %OptimizeFunctionOnNextCall(eagerDeoptInCalled);
  eagerDeoptInCalled();
  eagerDeoptInCalled(true);
  eagerDeoptInCalled();
  assertEquals(75, result);
})();

// Lazy deopt from runtime call from inlined callback function.
(() => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
             20, 21, 22, 23, 24, 25];
  let result = 0;
  function lazyDeopt(deopt) {
    a.some((v, i) => {
      result += i;
      if (i === 13 && deopt) {
        %DeoptimizeNow();
      }
      return false;
    });
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  lazyDeopt(true);
  lazyDeopt();
  assertEquals(1500, result);
})();

// Lazy deopt from runtime call from non-inline callback function.
(() => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
             20, 21, 22, 23, 24, 25];
  let result = 0;
  function lazyDeopt(deopt) {
    function callback(v, i) {
      result += i;
      if (i === 13 && deopt) {
        %DeoptimizeNow();
      }
      return false;
    }
    %NeverOptimizeFunction(callback);
    a.some(callback);
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  lazyDeopt(true);
  lazyDeopt();
  assertEquals(1500, result);
})();

// Call to a.some is done inside a try-catch block and the callback function
// being called actually throws.
(() => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
             20, 21, 22, 23, 24, 25];
  let caught = false;
  function lazyDeopt(deopt) {
    try {
      a.some((v, i) => {
        if (i === 1 && deopt) {
          throw("a");
        }
        return false;
      });
    } catch (e) {
      caught = true;
    }
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  assertDoesNotThrow(() => lazyDeopt(true));
  assertTrue(caught);
  lazyDeopt();
})();

// Call to a.some is done inside a try-catch block and the callback function
// being called actually throws, but the callback is not inlined.
(() => {
  let a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  let caught = false;
  function lazyDeopt(deopt) {
    function callback(v, i) {
      if (i === 1 && deopt) {
        throw("a");
      }
      return false;
    }
    %NeverOptimizeFunction(callback);
    try {
      a.some(callback);
    } catch (e) {
      caught = true;
    }
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  assertDoesNotThrow(() => lazyDeopt(true));
  assertTrue(caught);
  lazyDeopt();
})();

// Call to a.some is done inside a try-catch block and the callback function
// being called throws into a deoptimized caller function.
(function TestThrowIntoDeoptimizedOuter() {
  const a = [1, 2, 3, 4];
  function lazyDeopt(deopt) {
    function callback(v, i) {
      if (i === 1 && deopt) {
        %DeoptimizeFunction(lazyDeopt);
        throw "some exception";
      }
      return false;
    }
    %NeverOptimizeFunction(callback);
    let result = 0;
    try {
      result = a.some(callback);
    } catch (e) {
      assertEquals("some exception", e);
      result = "nope";
    }
    return result;
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  assertEquals(false, lazyDeopt(false));
  assertEquals(false, lazyDeopt(false));
  assertEquals("nope", lazyDeopt(true));
  assertEquals("nope", lazyDeopt(true));
  %OptimizeFunctionOnNextCall(lazyDeopt);
  assertEquals(false, lazyDeopt(false));
  assertEquals("nope", lazyDeopt(true));
})();

// An error generated inside the callback includes some in it's
// stack trace.
(() => {
  const re = /Array\.some/;
  function lazyDeopt(deopt) {
    const b = [1, 2, 3];
    let result = 0;
    b.some((v, i) => {
      result += v;
      if (i === 1) {
        const e = new Error();
        assertTrue(re.exec(e.stack) !== null);
      }
      return false;
    });
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
})();

// An error generated inside a non-inlined callback function also
// includes some in it's stack trace.
(() => {
  const re = /Array\.some/;
  function lazyDeopt(deopt) {
    const b = [1, 2, 3];
    let did_assert_error = false;
    let result = 0;
    function callback(v, i) {
      result += v;
      if (i === 1) {
        const e = new Error();
        assertTrue(re.exec(e.stack) !== null);
        did_assert_error = true;
      }
      return false;
    }
    %NeverOptimizeFunction(callback);
    b.some(callback);
    return did_assert_error;
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  assertTrue(lazyDeopt());
})();

// An error generated inside a recently deoptimized callback function
// includes some in it's stack trace.
(() => {
  const re = /Array\.some/;
  function lazyDeopt(deopt) {
    const b = [1, 2, 3];
    let did_assert_error = false;
    let result = 0;
    b.some((v, i) => {
      result += v;
      if (i === 1) {
        %DeoptimizeNow();
      } else if (i === 2) {
        const e = new Error();
        assertTrue(re.exec(e.stack) !== null);
        did_assert_error = true;
      }
      return false;
    });
    return did_assert_error;
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  assertTrue(lazyDeopt());
})();

// Verify that various exception edges are handled appropriately.
// The thrown Error object should always indicate it was created from
// a some call stack.
(() => {
  const re = /Array\.some/;
  const a = [1, 2, 3];
  let result = 0;
  function lazyDeopt() {
    a.some((v, i) => {
      result += i;
      if (i === 1) {
        %DeoptimizeFunction(lazyDeopt);
        throw new Error();
      }
      return false;
    });
  }
  %PrepareFunctionForOptimization(lazyDeopt);
  assertThrows(() => lazyDeopt());
  assertThrows(() => lazyDeopt());
  try {
    lazyDeopt();
  } catch (e) {
    assertTrue(re.exec(e.stack) !== null);
  }
  %OptimizeFunctionOnNextCall(lazyDeopt);
  try {
    lazyDeopt();
  } catch (e) {
    assertTrue(re.exec(e.stack) !== null);
  }
})();

// Messing with the Array prototype causes deoptimization.
(() => {
  const a = [1, 2, 3];
  let result = 0;
  function prototypeChanged() {
    a.some((v, i) => {
      result += v;
      return false;
    });
  }
  %PrepareFunctionForOptimization(prototypeChanged);
  prototypeChanged();
  prototypeChanged();
  %OptimizeFunctionOnNextCall(prototypeChanged);
  prototypeChanged();
  a.constructor = {};
  prototypeChanged();
  assertUnoptimized(prototypeChanged);
  assertEquals(24, result);
})();

// Verify holes are skipped.
(() => {
  const a = [1, 2, , 3, 4];
  function withHoles() {
    const callback_values = [];
    a.some(v => {
      callback_values.push(v);
      return false;
    });
    return callback_values;
  }
  %PrepareFunctionForOptimization(withHoles);
  withHoles();
  withHoles();
  %OptimizeFunctionOnNextCall(withHoles);
  assertArrayEquals([1, 2, 3, 4], withHoles());
})();

(() => {
  const a = [1.5, 2.5, , 3.5, 4.5];
  function withHoles() {
    const callback_values = [];
    a.some(v => {
      callback_values.push(v);
      return false;
    });
    return callback_values;
  }
  %PrepareFunctionForOptimization(withHoles);
  withHoles();
  withHoles();
  %OptimizeFunctionOnNextCall(withHoles);
  assertArrayEquals([1.5, 2.5, 3.5, 4.5], withHoles());
})();

// Handle callback is not callable.
(() => {
  const a = [1, 2, 3, 4, 5];
  function notCallable() {
    return a.some(undefined);
  }
  %PrepareFunctionForOptimization(notCallable);

  assertThrows(notCallable, TypeError);
  try { notCallable(); } catch(e) { }
  %OptimizeFunctionOnNextCall(notCallable);
  assertThrows(notCallable, TypeError);
})();
                                                                           node-23.7.0/deps/v8/test/mjsunit/optimized-filter.js                                                0000664 0000000 0000000 00000032732 14746647661 0022351 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --expose-gc --turbo-inline-array-builtins
// Flags: --turbofan --no-always-turbofan --no-lazy-feedback-allocation

// TODO(v8:10195): Fix these tests s.t. we assert deoptimization occurs when
// expected (e.g. in a %DeoptimizeNow call), then remove
// --no-lazy-feedback-allocation.

// Unknown field access leads to soft-deopt unrelated to filter, should still
// lead to correct result.
(function() {
  var a = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25];
  var result = 0;
  var eagerDeoptInCalled = function(deopt) {
    var callback = function(v,i,o) {
      if (i == 13 && deopt) {
        a.abc = 25;
      }

      // Ensure that the output array is smaller by shaving off the first
      // item.
      if (i === 0) return false;
      result += v;
      return true;
    }
    return a.filter(callback);
  };
  %PrepareFunctionForOptimization(eagerDeoptInCalled);
  eagerDeoptInCalled();
  eagerDeoptInCalled();
  %OptimizeFunctionOnNextCall(eagerDeoptInCalled);
  eagerDeoptInCalled();
  var deopt_result = eagerDeoptInCalled(true);
  assertEquals(a.slice(1), deopt_result);
  eagerDeoptInCalled();
  assertEquals(1620, result);
})();

// Length change detected during loop, must cause properly handled eager deopt.
(function() {
  var eagerDeoptInCalled = function(deopt) {
    var a = [1,2,3,4,5,6,7,8,9,10];
    var callback = function(v,i,o) {
      a.length = (i == 5 && deopt) ? 8 : 10;
      return i == 0 ? false : true;
    }
    return a.filter(callback);
  };
  %PrepareFunctionForOptimization(eagerDeoptInCalled);
  var like_a = [1,2,3,4,5,6,7,8,9,10];
  assertEquals(like_a.slice(1), eagerDeoptInCalled());
  eagerDeoptInCalled();
  %OptimizeFunctionOnNextCall(eagerDeoptInCalled);
  assertEquals(like_a.slice(1), eagerDeoptInCalled());
  assertEquals(like_a.slice(1).slice(0, 7), eagerDeoptInCalled(true));
  eagerDeoptInCalled();
})();

// Lazy deopt from a callback that changes the input array. Ensure that
// the value stored in the output array is from the original read.
(function() {
  var a = [1, 2, 3, 4, 5];
  var lazyChanger = function(deopt) {
    var callback = function(v,i,o) {
      if (i === 2 && deopt) {
        a[2] = 100;
        %DeoptimizeNow();
       }
      return true;
    }
    return a.filter(callback);
  };
  %PrepareFunctionForOptimization(lazyChanger);
  assertEquals(a, lazyChanger());
  lazyChanger();
  %OptimizeFunctionOnNextCall(lazyChanger);
  var deopt_result = lazyChanger(true);
  assertEquals([1, 2, 3, 4, 5], deopt_result);
  assertEquals([1, 2, 100, 4, 5], lazyChanger());
})();

// Lazy deopt from a callback that returns false at the deopt point.
// Ensure the non-selection is respected in the output array.
(function() {
  var a = [1, 2, 3, 4, 5];
  var lazyDeselection = function(deopt) {
    var callback = function(v,i,o) {
      if (i === 2 && deopt) {
        %DeoptimizeNow();
        return false;
       }
      return true;
    }
    return a.filter(callback);
  };
  %PrepareFunctionForOptimization(lazyDeselection);
  assertEquals(a, lazyDeselection());
  lazyDeselection();
  %OptimizeFunctionOnNextCall(lazyDeselection);
  var deopt_result = lazyDeselection(true);
  assertEquals([1, 2, 4, 5], deopt_result);
  assertEquals([1, 2, 3, 4, 5], lazyDeselection());
})();


// Escape analyzed array
(function() {
  var result = 0;
  var eagerDeoptInCalled = function(deopt) {
    var a_noescape = [0,1,2,3,4,5];
    var callback = function(v,i,o) {
      result += v;
      if (i == 13 && deopt) {
        a_noescape.length = 25;
      }
      return true;
    }
    a_noescape.filter(callback);
  };
  %PrepareFunctionForOptimization(eagerDeoptInCalled);
  eagerDeoptInCalled();
  eagerDeoptInCalled();
  %OptimizeFunctionOnNextCall(eagerDeoptInCalled);
  eagerDeoptInCalled();
  eagerDeoptInCalled(true);
  eagerDeoptInCalled();
  assertEquals(75, result);
})();

// Escape analyzed array where callback function isn't inlined, forcing a lazy
// deopt with GC that relies on the stashed-away return result fro the lazy
// deopt being properly stored in a place on the stack that gets GC'ed.
(function() {
  var result = 0;
  var lazyDeopt = function(deopt) {
    var b = [1,2,3];
    var callback = function(v,i,o) {
      result += i;
      if (i == 1 && deopt) {
        %DeoptimizeFunction(lazyDeopt);
      }
      gc(); gc();
      return true;
    };
    %NeverOptimizeFunction(callback);
    b.filter(callback);
  };
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  lazyDeopt(true);
  lazyDeopt();
})();

// Lazy deopt from runtime call from inlined callback function.
(function() {
  var a = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25];
  var result = 0;
  var lazyDeopt = function(deopt) {
    var callback = function(v,i,o) {
      result += i;
      if (i == 13 && deopt) {
          %DeoptimizeNow();
      }
      return true;
    }
    a.filter(callback);
  };
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  lazyDeopt(true);
  lazyDeopt();
  assertEquals(1500, result);
})();

// Lazy deopt from runtime call from non-inline callback function.
(function() {
  var a = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25];
  var result = 0;
  var lazyDeopt = function(deopt) {
    var callback = function(v,i,o) {
      result += i;
      if (i == 13 && deopt) {
          %DeoptimizeNow();
      }
      return true;
    };
    %NeverOptimizeFunction(callback);
    a.filter(callback);
  };
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  lazyDeopt(true);
  lazyDeopt();
  assertEquals(1500, result);
})();

(function() {
  var a = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25];
  var result = 0;
  var lazyDeopt = function(deopt) {
    var callback = function(v,i,o) {
      result += i;
      if (i == 13 && deopt) {
          %DeoptimizeNow();
          gc();
          gc();
          gc();
      }
      return true;
    }
    a.filter(callback);
  };
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  lazyDeopt(true);
  lazyDeopt();
  assertEquals(1500, result);
})();

// Call to a.filter is done inside a try-catch block and the callback function
// being called actually throws.
(function() {
  var a = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25];
  var caught = false;
  var result = 0;
  var lazyDeopt = function(deopt) {
    var callback = function(v,i,o) {
      result += i;
      if (i == 1 && deopt) {
        throw("a");
      }
      return true;
    }
    try {
      a.filter(callback);
    } catch (e) {
      caught = true;
    }
  };
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  assertDoesNotThrow(() => lazyDeopt(true));
  assertTrue(caught);
  lazyDeopt();
})();

// Call to a.filter is done inside a try-catch block and the callback function
// being called actually throws, but the callback is not inlined.
(function() {
  var a = [1,2,3,4,5,6,7,8,9,10];
  var caught = false;
  var result = 0;
  var lazyDeopt = function(deopt) {
    var callback = function(v,i,o) {
      result += i;
      if (i == 1 && deopt) {
        throw("a");
      }
      return true;
    };
    %NeverOptimizeFunction(callback);
    try {
      a.filter(callback);
    } catch (e) {
      caught = true;
    }
  };
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  assertDoesNotThrow(() => lazyDeopt(true));
  assertTrue(caught);
  lazyDeopt();
})();

// Call to a.filter is done inside a try-catch block and the callback function
// being called throws into a deoptimized caller function.
(function TestThrowIntoDeoptimizedOuter() {
  var a = [1,2,3,4];
  var lazyDeopt = function(deopt) {
    var callback = function(v,i,o) {
      if (i == 1 && deopt) {
        %DeoptimizeFunction(lazyDeopt);
        throw "some exception";
      }
      return true;
    };
    %NeverOptimizeFunction(callback);
    var result = 0;
    try {
      result = a.filter(callback);
    } catch (e) {
      assertEquals("some exception", e)
      result = "nope";
    }
    return result;
  };
  %PrepareFunctionForOptimization(lazyDeopt);
  assertEquals([1,2,3,4], lazyDeopt(false));
  assertEquals([1,2,3,4], lazyDeopt(false));
  assertEquals("nope", lazyDeopt(true));
  assertEquals("nope", lazyDeopt(true));
  %OptimizeFunctionOnNextCall(lazyDeopt);
  assertEquals([1,2,3,4], lazyDeopt(false));
  assertEquals("nope", lazyDeopt(true));
})();

// An error generated inside the callback includes filter in it's
// stack trace.
(function() {
  var re = /Array\.filter/;
  var lazyDeopt = function(deopt) {
    var b = [1,2,3];
    var result = 0;
    var callback = function(v,i,o) {
      result += v;
      if (i == 1) {
        var e = new Error();
        assertTrue(re.exec(e.stack) !== null);
      }
      return true;
    };
    var o = [1,2,3];
    b.filter(callback);
  };
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
})();

// An error generated inside a non-inlined callback function also
// includes filter in it's stack trace.
(function() {
  var re = /Array\.filter/;
  var lazyDeopt = function(deopt) {
    var b = [1,2,3];
    var result = 0;
    var callback = function(v,i,o) {
      result += v;
      if (i == 1) {
        var e = new Error();
        assertTrue(re.exec(e.stack) !== null);
      }
      return true;
    };
    %NeverOptimizeFunction(callback);
    var o = [1,2,3];
    b.filter(callback);
  };
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
})();

// An error generated inside a recently deoptimized callback function
// includes filter in it's stack trace.
(function() {
  var re = /Array\.filter/;
  var lazyDeopt = function(deopt) {
    var b = [1,2,3];
    var result = 0;
    var callback = function(v,i,o) {
      result += v;
      if (i == 1) {
        %DeoptimizeNow();
      } else if (i == 2) {
        var e = new Error();
        assertTrue(re.exec(e.stack) !== null);
      }
      return true;
    };
    var o = [1,2,3];
    b.filter(callback);
  };
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
})();

// Verify that various exception edges are handled appropriately.
// The thrown Error object should always indicate it was created from
// a filter call stack.
(function() {
  var re = /Array\.filter/;
  var a = [1,2,3];
  var result = 0;
  var lazyDeopt = function() {
    var callback = function(v,i,o) {
      result += i;
      if (i == 1) {
        %DeoptimizeFunction(lazyDeopt);
        throw new Error();
      }
      return true;
    };
    a.filter(callback);
  };
  %PrepareFunctionForOptimization(lazyDeopt);
  assertThrows(() => lazyDeopt());
  assertThrows(() => lazyDeopt());
  try {
    lazyDeopt();
  } catch (e) {
    assertTrue(re.exec(e.stack) !== null);
  }
  %OptimizeFunctionOnNextCall(lazyDeopt);
  try {
    lazyDeopt();
  } catch (e) {
    assertTrue(re.exec(e.stack) !== null);
  }
})();

// Verify holes are skipped.
(() => {
  const a = [1, 2, , 3, 4];
  let callback_values = [];
  function withHoles() {
    callback_values = [];
    return a.filter(v => {
      callback_values.push(v);
      return true;
    });
  }
  %PrepareFunctionForOptimization(withHoles);
  withHoles();
  withHoles();
  %OptimizeFunctionOnNextCall(withHoles);
  assertArrayEquals([1, 2, 3, 4], withHoles());
  assertArrayEquals([1, 2, 3, 4], callback_values);
})();

(() => {
  const a = [1.5, 2.5, , 3.5, 4.5];
  let callback_values = [];
  function withHoles() {
    callback_values = [];
    return a.filter(v => {
      callback_values.push(v);
      return true;
    });
  }
  %PrepareFunctionForOptimization(withHoles);
  withHoles();
  withHoles();
  %OptimizeFunctionOnNextCall(withHoles);
  assertArrayEquals([1.5, 2.5, 3.5, 4.5], withHoles());
  assertArrayEquals([1.5, 2.5, 3.5, 4.5], callback_values);
})();

// Ensure that we handle side-effects between load and call.
(() => {
  function side_effect(a, b) { if (b) a.foo = 3; return a; }
  %NeverOptimizeFunction(side_effect);

  function unreliable(a, b) {
    return a.filter(x => x % 2 === 0, side_effect(a, b));
  }

  %PrepareFunctionForOptimization(unreliable);
  let a = [1, 2, 3];
  unreliable(a, false);
  unreliable(a, false);
  %OptimizeFunctionOnNextCall(unreliable);
  unreliable(a, false);
  // Now actually do change the map.
  unreliable(a, true);
})();

// Messing with the Array species constructor causes deoptimization.
(function() {
  var result = 0;
  var a = [1,2,3];
  var species_breakage = function() {
    var callback = function(v,i,o) {
      result += v;
      return true;
    }
    a.filter(callback);
  };
  %PrepareFunctionForOptimization(species_breakage);
  species_breakage();
  species_breakage();
  %OptimizeFunctionOnNextCall(species_breakage);
  species_breakage();
  a.constructor = {};
  a.constructor[Symbol.species] = function() {};
  species_breakage();
  assertUnoptimized(species_breakage);
  assertEquals(24, result);
})();
                                      node-23.7.0/deps/v8/test/mjsunit/optimized-foreach-holey-2.js                                       0000664 0000000 0000000 00000001335 14746647661 0023743 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --expose-gc --turbo-inline-array-builtins

(function() {
  var result = 0;
  var proto_set_func = function(p, s) {
    %NeverOptimizeFunction(proto_set_func);
    if (s) {
      p[0] = 1;
    }
  }
  var f = function(s) {
    var b = [,,];
    proto_set_func(b.__proto__, s);
    b[1] = 0;
    b[2] = 2;
    var sum = function(v,i,o) {
      result += v;
    };
    b.forEach(sum);
  };
  %PrepareFunctionForOptimization(f);
  f();
  f();
  %OptimizeFunctionOnNextCall(f);
  f();
  f(true);
  f();
  assertEquals(12, result);
})();
                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/optimized-foreach-holey-3.js                                       0000664 0000000 0000000 00000001313 14746647661 0023740 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --expose-gc --turbo-inline-array-builtins

(function() {
var result = 0;
var proto_set_func = function(p, s) {
  %NeverOptimizeFunction(proto_set_func);
  if (s) {
    p[0] = 1;
  }
};
var f = function(s) {
  var b = [
    ,
    ,
  ];
  b[1] = 0;
  b[2] = 2;
  var sum = function(v, i, o) {
    if (i == 1) proto_set_func(b.__proto__, s);
    result += v;
  };
  b.forEach(sum);
};
;
%PrepareFunctionForOptimization(f);
f();
f();
%OptimizeFunctionOnNextCall(f);
f();
f(true);
f();
assertEquals(11, result);
})();
                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/optimized-foreach-holey.js                                         0000664 0000000 0000000 00000001071 14746647661 0023601 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --expose-gc --turbo-inline-array-builtins

(function() {
  var result = 0;
  var f = function() {
    var b = [,,];
    b[0] = 0;
    b[2] = 2;
    var sum = function(v,i,o) {
      result += i;
    };
    b.forEach(sum);
  };
  %PrepareFunctionForOptimization(f);
  f();
  f();
  %OptimizeFunctionOnNextCall(f);
  f();
  f();
  f();
  assertEquals(10, result);
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/optimized-foreach-polymorph.js                                     0000664 0000000 0000000 00000005330 14746647661 0024514 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --expose-gc --turbo-inline-array-builtins

var a = [0, 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,0,0];
var b = [{}, {}];
var c = [,,,,,2,3,4];
var d = [0.5,3,4];
var e = [,,,,0.5,3,4];

// Make sure that calls to forEach handle a certain degree of polymorphism (no
// hole check)
(function() {
  var result = 0;
  var polymorph1 = function(arg) {
    var sum = function(v,i,o) {
      result += i;
    }
    arg.forEach(sum);
  };
  %PrepareFunctionForOptimization(polymorph1);
  polymorph1(a);
  polymorph1(a);
  polymorph1(b);
  polymorph1(a);
  polymorph1(a);
  %OptimizeFunctionOnNextCall(polymorph1);
  polymorph1(a);
  polymorph1(b);
  assertEquals(1757, result);
})();

// Make sure that calls to forEach handle a certain degree of polymorphism.
(function() {
  var result = 0;
  var polymorph1 = function(arg) {
    var sum = function(v,i,o) {
      result += i;
    }
    arg.forEach(sum);
  };
  %PrepareFunctionForOptimization(polymorph1);
  polymorph1(a);
  polymorph1(a);
  polymorph1(b);
  polymorph1(a);
  polymorph1(c);
  polymorph1(a);
  %OptimizeFunctionOnNextCall(polymorph1);
  polymorph1(a);
  polymorph1(b);
  assertEquals(1775, result);
})();

// Make sure that calls to forEach with mixed object/double arrays don't inline
// forEach.
(function() {
  var result = 0;
  var polymorph1 = function(arg) {
    var sum = function(v,i,o) {
      result += i;
    }
    arg.forEach(sum);
  };
  %PrepareFunctionForOptimization(polymorph1);
  polymorph1(a);
  polymorph1(a);
  polymorph1(b);
  polymorph1(a);
  polymorph1(d);
  polymorph1(a);
  %OptimizeFunctionOnNextCall(polymorph1);
  polymorph1(a);
  polymorph1(b);
  assertEquals(1760, result);
})();

// Make sure that calls to forEach with double arrays get the right result
(function() {
  var result = 0;
  var polymorph1 = function(arg) {
    var sum = function(v,i,o) {
      result += v;
    }
    arg.forEach(sum);
  };
  %PrepareFunctionForOptimization(polymorph1);
  polymorph1(d);
  polymorph1(d);
  polymorph1(d);
  %OptimizeFunctionOnNextCall(polymorph1);
  polymorph1(d);
  polymorph1(d);
  assertEquals(37.5, result);
})();

// Make sure that calls to forEach with mixed double arrays get the right result
(function() {
  var result = 0;
  var polymorph1 = function(arg) {
    var sum = function(v,i,o) {
      result += v;
    }
    arg.forEach(sum);
  };
  %PrepareFunctionForOptimization(polymorph1);
  polymorph1(d);
  polymorph1(e);
  polymorph1(d);
  %OptimizeFunctionOnNextCall(polymorph1);
  polymorph1(d);
  polymorph1(e);
  assertEquals(37.5, result);
})();
                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/optimized-foreach.js                                               0000664 0000000 0000000 00000023227 14746647661 0022472 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --expose-gc --turbo-inline-array-builtins
// Flags: --no-lazy-feedback-allocation

// TODO(v8:10195): Fix these tests s.t. we assert deoptimization occurs when
// expected (e.g. in a %DeoptimizeNow call), then remove
// --no-lazy-feedback-allocation.

var a = [
  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13,
  14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 0,  0
];
var b = [
  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13,
  14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25
];
var c = [
  1,  2,  3,  4,  5,  6,  7,  8,  9,  10, 11, 12, 13,
  14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25
];

// Unknown field access leads to soft-deopt unrelated to forEach, should still
// lead to correct result.
(function() {
var result = 0;
var eagerDeoptInCalled = function(deopt) {
  var sum = function(v, i, o) {
    result += v;
    if (i == 13 && deopt) {
      a.abc = 25;
    }
  };
  a.forEach(sum);
};
%PrepareFunctionForOptimization(eagerDeoptInCalled);
eagerDeoptInCalled();
eagerDeoptInCalled();
%OptimizeFunctionOnNextCall(eagerDeoptInCalled);
eagerDeoptInCalled();
eagerDeoptInCalled(true);
eagerDeoptInCalled();
assertEquals(1500, result);
})();

// Length change detected during loop, must cause properly handled eager deopt.
(function() {
var result = 0;
var eagerDeoptInCalled = function(deopt) {
  var sum = function(v, i, o) {
    result += v;
    a.length = i == 13 && deopt ? 25 : 27;
  };
  a.forEach(sum);
};
%PrepareFunctionForOptimization(eagerDeoptInCalled);
eagerDeoptInCalled();
eagerDeoptInCalled();
%OptimizeFunctionOnNextCall(eagerDeoptInCalled);
eagerDeoptInCalled();
eagerDeoptInCalled(true);
eagerDeoptInCalled();
assertEquals(1500, result);
})();

// Escape analyzed array
(function() {
var result = 0;
var eagerDeoptInCalled = function(deopt) {
  var a_noescape = [0, 1, 2, 3, 4, 5];
  var sum = function(v, i, o) {
    result += v;
    if (i == 13 && deopt) {
      a_noescape.length = 25;
    }
  };
  a_noescape.forEach(sum);
};
%PrepareFunctionForOptimization(eagerDeoptInCalled);
eagerDeoptInCalled();
eagerDeoptInCalled();
%OptimizeFunctionOnNextCall(eagerDeoptInCalled);
eagerDeoptInCalled();
eagerDeoptInCalled(true);
eagerDeoptInCalled();
assertEquals(75, result);
})();

// Escape analyzed array where sum function isn't inlined, forcing a lazy deopt
// with GC that relies on the stashed-away return result fro the lazy deopt
// being properly stored in a place on the stack that gets GC'ed.
(function() {
var result = 0;
var lazyDeopt = function(deopt) {
  var b = [1, 2, 3];
  var sum = function(v, i, o) {
    result += i;
    if (i == 1 && deopt) {
      %DeoptimizeFunction(lazyDeopt);
    }
    gc();
    gc();
  };
  %NeverOptimizeFunction(sum);
  b.forEach(sum);
};
%PrepareFunctionForOptimization(lazyDeopt);
lazyDeopt();
lazyDeopt();
%OptimizeFunctionOnNextCall(lazyDeopt);
lazyDeopt();
lazyDeopt(true);
lazyDeopt();
})();

// Lazy deopt from runtime call from inlined callback function.
(function() {
var result = 0;
var lazyDeopt = function(deopt) {
  var sum = function(v, i, o) {
    result += i;
    if (i == 13 && deopt) {
      %DeoptimizeNow();
    }
  };
  b.forEach(sum);
};
%PrepareFunctionForOptimization(lazyDeopt);
lazyDeopt();
lazyDeopt();
%OptimizeFunctionOnNextCall(lazyDeopt);
lazyDeopt();
lazyDeopt(true);
lazyDeopt();
assertEquals(1500, result);
})();

// Lazy deopt from runtime call from non-inline callback function.
(function() {
var result = 0;
var lazyDeopt = function(deopt) {
  var sum = function(v, i, o) {
    result += i;
    if (i == 13 && deopt) {
      %DeoptimizeNow();
    }
  };
  %NeverOptimizeFunction(sum);
  b.forEach(sum);
};
%PrepareFunctionForOptimization(lazyDeopt);
lazyDeopt();
lazyDeopt();
%OptimizeFunctionOnNextCall(lazyDeopt);
lazyDeopt();
lazyDeopt(true);
lazyDeopt();
assertEquals(1500, result);
})();

(function() {
var result = 0;
var lazyDeopt = function(deopt) {
  var sum = function(v, i, o) {
    result += i;
    if (i == 13 && deopt) {
      %DeoptimizeNow();
      gc();
      gc();
      gc();
    }
  };
  c.forEach(sum);
};
%PrepareFunctionForOptimization(lazyDeopt);
lazyDeopt();
lazyDeopt();
%OptimizeFunctionOnNextCall(lazyDeopt);
lazyDeopt();
lazyDeopt(true);
lazyDeopt();
assertEquals(1500, result);
})();

// Call to a.forEach is done inside a try-catch block and the callback function
// being called actually throws.
(function() {
var caught = false;
var result = 0;
var lazyDeopt = function(deopt) {
  var sum = function(v, i, o) {
    result += i;
    if (i == 1 && deopt) {
      throw 'a';
    }
  };
  try {
    c.forEach(sum);
  } catch (e) {
    caught = true;
  }
};
%PrepareFunctionForOptimization(lazyDeopt);
lazyDeopt();
lazyDeopt();
%OptimizeFunctionOnNextCall(lazyDeopt);
lazyDeopt();
assertDoesNotThrow(lazyDeopt.bind(this, true));
assertTrue(caught);
lazyDeopt();
})();

// Call to a.forEach is done inside a try-catch block and the callback function
// being called actually throws, but the callback is not inlined.
(function() {
var caught = false;
var result = 0;
var lazyDeopt = function(deopt) {
  var sum = function(v, i, o) {
    result += i;
    if (i == 1 && deopt) {
      throw 'a';
    }
  };
  %NeverOptimizeFunction(sum);
  try {
    c.forEach(sum);
  } catch (e) {
    caught = true;
  }
};
%PrepareFunctionForOptimization(lazyDeopt);
lazyDeopt();
lazyDeopt();
%OptimizeFunctionOnNextCall(lazyDeopt);
lazyDeopt();
assertDoesNotThrow(lazyDeopt.bind(this, true));
assertTrue(caught);
lazyDeopt();
})();

// Call to a.forEach is done inside a try-catch block and the callback function
// being called throws into a deoptimized caller function.
(function TestThrowIntoDeoptimizedOuter() {
  var a = [1, 2, 3, 4];
  var lazyDeopt = function(deopt) {
    var sum = function(v, i, o) {
      result += v;
      if (i == 1 && deopt) {
        %DeoptimizeFunction(lazyDeopt);
        throw "some exception";
      }
    };
    %NeverOptimizeFunction(sum);
    var result = 0;
    try {
      a.forEach(sum);
    } catch (e) {
      assertEquals('some exception', e);
      result += 100;
    }
    return result;
  };
  ;
  %PrepareFunctionForOptimization(lazyDeopt);
  assertEquals(10, lazyDeopt(false));
  assertEquals(10, lazyDeopt(false));
  assertEquals(103, lazyDeopt(true));
  assertEquals(103, lazyDeopt(true));
  %OptimizeFunctionOnNextCall(lazyDeopt);
  assertEquals(10, lazyDeopt(false));
  assertEquals(103, lazyDeopt(true));
})();

(function() {
var re = /Array\.forEach/;
var lazyDeopt = function foobar(deopt) {
  var b = [1, 2, 3];
  var result = 0;
  var sum = function(v, i, o) {
    result += v;
    if (i == 1) {
      var e = new Error();
      assertTrue(re.exec(e.stack) !== null);
    }
  };
  var o = [1, 2, 3];
  b.forEach(sum);
};
%PrepareFunctionForOptimization(lazyDeopt);
lazyDeopt();
lazyDeopt();
%OptimizeFunctionOnNextCall(lazyDeopt);
lazyDeopt();
})();

(function() {
var re = /Array\.forEach/;
var lazyDeopt = function(deopt) {
  var b = [1, 2, 3];
  var result = 0;
  var sum = function(v, i, o) {
    result += v;
    if (i == 1) {
      var e = new Error();
      assertTrue(re.exec(e.stack) !== null);
    }
  };
  %NeverOptimizeFunction(sum);
  var o = [1, 2, 3];
  b.forEach(sum);
};
%PrepareFunctionForOptimization(lazyDeopt);
lazyDeopt();
lazyDeopt();
%OptimizeFunctionOnNextCall(lazyDeopt);
lazyDeopt();
})();

(function() {
var re = /Array\.forEach/;
var lazyDeopt = function(deopt) {
  var b = [1, 2, 3];
  var result = 0;
  var sum = function(v, i, o) {
    result += v;
    if (i == 1) {
      %DeoptimizeNow();
    } else if (i == 2) {
      var e = new Error();
      assertTrue(re.exec(e.stack) !== null);
    }
  };
  var o = [1, 2, 3];
  b.forEach(sum);
};
%PrepareFunctionForOptimization(lazyDeopt);
lazyDeopt();
lazyDeopt();
%OptimizeFunctionOnNextCall(lazyDeopt);
lazyDeopt();
})();

(function() {
var re = /Array\.forEach/;
var a = [1, 2, 3];
var result = 0;
var lazyDeopt = function() {
  var sum = function(v, i, o) {
    result += i;
    if (i == 1) {
      %DeoptimizeFunction(lazyDeopt);
      throw new Error();
    }
  };
  a.forEach(sum);
};
%PrepareFunctionForOptimization(lazyDeopt);
assertThrows(() => lazyDeopt());
assertThrows(() => lazyDeopt());
try {
  lazyDeopt();
} catch (e) {
  assertTrue(re.exec(e.stack) !== null);
}
%OptimizeFunctionOnNextCall(lazyDeopt);
try {
  lazyDeopt();
} catch (e) {
  assertTrue(re.exec(e.stack) !== null);
}
})();

// Verify holes are skipped.
(() => {
  const a = [1, 2, , 3, 4];
  function withHoles() {
    const callback_values = [];
    a.forEach(v => {
      callback_values.push(v);
    });
    return callback_values;
  };
  %PrepareFunctionForOptimization(withHoles);
  withHoles();
  withHoles();
  %OptimizeFunctionOnNextCall(withHoles);
  assertArrayEquals([1, 2, 3, 4], withHoles());
})();

(() => {
  const a = [1.5, 2.5, , 3.5, 4.5];
  function withHoles() {
    const callback_values = [];
    a.forEach(v => {
      callback_values.push(v);
    });
    return callback_values;
  };
  %PrepareFunctionForOptimization(withHoles);
  withHoles();
  withHoles();
  %OptimizeFunctionOnNextCall(withHoles);
  assertArrayEquals([1.5, 2.5, 3.5, 4.5], withHoles());
})();

// Ensure that we handle side-effects between load and call.
(() => {
  function side_effect(a, b) {
    if (b) a.foo = 3;
    return a;
  }
  %NeverOptimizeFunction(side_effect);

  function unreliable(a, b) {
    let sum = 0;
    return a.forEach(x => sum += x, side_effect(a, b));
  };
  %PrepareFunctionForOptimization(unreliable);
  let a = [1, 2, 3];
  unreliable(a, false);
  unreliable(a, false);
  %OptimizeFunctionOnNextCall(unreliable);
  unreliable(a, false);
  // Now actually do change the map.
  unreliable(a, true);
})();
                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/optimized-includes-polymorph.js                                    0000664 0000000 0000000 00000005415 14746647661 0024717 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

var o1 = {};
var o2 = {};
var a = [0, 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,0,0];
var b = [,,,,,2,3,4];
var c = [o1, o2];
var d = [,,, o2, o1];
var e = [0.5,3,4];
var f = [,,,,0.5,3,4];

function checkIncludes(ary, value) {
  return ary.includes(value)
}

function checkIndexOf(ary, value, expected) {
  return ary.indexOf(value) == expected;
}

function expectIncludes(ary, value) {
  assertTrue(checkIncludes(ary, value));
}

function expectNotIncludes(ary, value) {
  assertFalse(checkIncludes(ary, value));
}

function expectIndexOf(ary, value, expected) {
  assertTrue(checkIndexOf(ary, value, expected));
}

var testIncludes = {
  polymorphic: function() {
    expectIncludes(a, 21);
    expectIncludes(b, 4);
    expectIncludes(c, o2);
    expectIncludes(d, o1);
    expectNotIncludes(a, o1);
    expectNotIncludes(b, o2);
    expectNotIncludes(c, 3);
    expectNotIncludes(d, 4);
    },

  polymorphicDouble: function() {
    expectIncludes(e, 3);
    expectIncludes(f, 0.5);
    expectNotIncludes(e, 10);
    expectNotIncludes(f, 0.25);
  },

  polymorphicMixed: function() {
    expectIncludes(a, 21);
    expectIncludes(b, 4);
    expectIncludes(c, o2);
    expectIncludes(d, o1);
    expectIncludes(e, 3);
    expectIncludes(f, 0.5);
    expectNotIncludes(a, o1);
    expectNotIncludes(b, o2);
    expectNotIncludes(c, 3);
    expectNotIncludes(d, 4);
    expectNotIncludes(e, 10);
    expectNotIncludes(f, 0.25);
  },
};

var testIndexOf = {
  polymorphic: function() {
    expectIndexOf(a, 21, 21);
    expectIndexOf(b, 4, 7);
    expectIndexOf(c, o2, 1);
    expectIndexOf(d, o1, 4);
    expectIndexOf(a, o1, -1);
    expectIndexOf(b, o2, -1);
    expectIndexOf(c, 3, -1);
    expectIndexOf(d, 4, -1);
  },

  polymorphicDouble: function() {
    expectIndexOf(e, 3, 1);
    expectIndexOf(f, 0.5, 4);
    expectIndexOf(e, 10, -1);
    expectIndexOf(f, 0.25, -1);
  },

  polymorphicMixed: function() {
    expectIndexOf(a, 21, 21);
    expectIndexOf(b, 4, 7);
    expectIndexOf(c, o2, 1);
    expectIndexOf(d, o1, 4);
    expectIndexOf(e, 3, 1);
    expectIndexOf(f, 0.5, 4);
    expectIndexOf(a, o1, -1);
    expectIndexOf(b, o2, -1);
    expectIndexOf(c, 3, -1);
    expectIndexOf(d, 4, -1);
    expectIndexOf(e, 10, -1);
    expectIndexOf(f, 0.25, -1);
  },
};

function runTests(tests, func) {
  for (test in tests) {
    %DeoptimizeFunction(func);
    %ClearFunctionFeedback(func);
    %PrepareFunctionForOptimization(func);
    tests[test]();
    %OptimizeFunctionOnNextCall(func);
    tests[test]();
  }
}

runTests(testIncludes, checkIncludes)
runTests(testIndexOf, checkIndexOf)
                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/optimized-map.js                                                   0000664 0000000 0000000 00000036632 14746647661 0021644 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --expose-gc --turbo-inline-array-builtins
// Flags: --turbofan --no-always-turbofan --no-lazy-feedback-allocation

// TODO(v8:10195): Fix these tests s.t. we assert deoptimization occurs when
// expected (e.g. in a %DeoptimizeNow call), then remove
// --no-lazy-feedback-allocation.

var a = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,0,0];
var b = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25];
var c = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25];

// Unknown field access leads to soft-deopt unrelated to map, should still
// lead to correct result.
(function() {
  var result = 0;
  var eagerDeoptInCalled = function(deopt) {
    var callback = function(v,i,o) {
      result += v;
      if (i == 13 && deopt) {
        a.abc = 25;
      }
      return v;
    };
    %EnsureFeedbackVectorForFunction(callback);
    a.map(callback);
  };
  %PrepareFunctionForOptimization(eagerDeoptInCalled);
  eagerDeoptInCalled();
  eagerDeoptInCalled();
  %OptimizeFunctionOnNextCall(eagerDeoptInCalled);
  eagerDeoptInCalled();
  eagerDeoptInCalled(true);
  eagerDeoptInCalled();
  assertEquals(1500, result);
})();

// Length change detected during loop, must cause properly handled eager deopt.
(function() {
  var result = 0;
  var eagerDeoptInCalled = function(deopt) {
    var callback = function(v,i,o) {
      result += v;
      a.length = (i == 13 && deopt) ? 25 : 27;
      return v;
    };
    %EnsureFeedbackVectorForFunction(callback);
    a.map(callback);
  };
  %PrepareFunctionForOptimization(eagerDeoptInCalled);
  eagerDeoptInCalled();
  eagerDeoptInCalled();
  %OptimizeFunctionOnNextCall(eagerDeoptInCalled);
  eagerDeoptInCalled();
  eagerDeoptInCalled(true);
  eagerDeoptInCalled();
  assertEquals(1500, result);
})();

// Escape analyzed array
(function() {
  var result = 0;
  var eagerDeoptInCalled = function(deopt) {
    var a_noescape = [0,1,2,3,4,5];
    var callback = function(v,i,o) {
      result += v;
      if (i == 13 && deopt) {
        a_noescape.length = 25;
      }
      return v;
    };
    %EnsureFeedbackVectorForFunction(callback);
    a_noescape.map(callback);
  };
  %PrepareFunctionForOptimization(eagerDeoptInCalled);
  eagerDeoptInCalled();
  eagerDeoptInCalled();
  %OptimizeFunctionOnNextCall(eagerDeoptInCalled);
  eagerDeoptInCalled();
  eagerDeoptInCalled(true);
  eagerDeoptInCalled();
  assertEquals(75, result);
})();

// Escape analyzed array where callback function isn't inlined, forcing a lazy
// deopt with GC that relies on the stashed-away return result fro the lazy
// deopt being properly stored in a place on the stack that gets GC'ed.
(function() {
  var result = 0;
  var lazyDeopt = function(deopt) {
    var b = [1,2,3];
    var callback = function(v,i,o) {
      result += i;
      if (i == 1 && deopt) {
        %DeoptimizeFunction(lazyDeopt);
      }
      gc(); gc();
      return v;
    };
    %EnsureFeedbackVectorForFunction(callback);
    %NeverOptimizeFunction(callback);
    b.map(callback);
  };
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  lazyDeopt(true);
  lazyDeopt();
})();

// Escape analyzed array where callback function isn't inlined, forcing a lazy
// deopt. Check that the result of the callback function is passed correctly
// to the lazy deopt and that the final result of map is as expected.
(function() {
  var lazyDeopt = function(deopt) {
    var b = [1,2,3];
    var callback = function(v,i,o) {
      if (i == 1 && deopt) {
        %DeoptimizeFunction(lazyDeopt);
      }
      return 2 * v;
    };
    %EnsureFeedbackVectorForFunction(callback);
    %NeverOptimizeFunction(callback);
    return b.map(callback);
  };
  %PrepareFunctionForOptimization(lazyDeopt);
  assertEquals([2,4,6], lazyDeopt());
  assertEquals([2,4,6], lazyDeopt());
  %OptimizeFunctionOnNextCall(lazyDeopt);
  assertEquals([2,4,6], lazyDeopt(true));
})();

// Lazy deopt from runtime call from inlined callback function.
(function() {
  var result = 0;
  var lazyDeopt = function(deopt) {
    var callback = function(v,i,o) {
      result += i;
      if (i == 13 && deopt) {
          %DeoptimizeNow();
      }
      return v;
    };
    %EnsureFeedbackVectorForFunction(callback);
    b.map(callback);
  };
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  lazyDeopt(true);
  lazyDeopt();
  assertEquals(1500, result);
})();

// Lazy deopt from runtime call from non-inline callback function.
(function() {
  var result = 0;
  var lazyDeopt = function(deopt) {
    var callback = function(v,i,o) {
      result += i;
      if (i == 13 && deopt) {
          %DeoptimizeNow();
      }
      return v;
    };
    %EnsureFeedbackVectorForFunction(callback);
    %NeverOptimizeFunction(callback);
    b.map(callback);
  };
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  lazyDeopt(true);
  lazyDeopt();
  assertEquals(1500, result);
})();

(function() {
  var result = 0;
  var lazyDeopt = function(deopt) {
    var callback = function(v,i,o) {
      result += i;
      if (i == 13 && deopt) {
          %DeoptimizeNow();
          gc();
          gc();
          gc();
      }
      return v;
    };
    %EnsureFeedbackVectorForFunction(callback);
    c.map(callback);
  };
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  lazyDeopt(true);
  lazyDeopt();
  assertEquals(1500, result);
})();

// Call to a.map is done inside a try-catch block and the callback function
// being called actually throws.
(function() {
  var caught = false;
  var result = 0;
  var lazyDeopt = function(deopt) {
    var callback = function(v,i,o) {
      result += i;
      if (i == 1 && deopt) {
        throw("a");
      }
      return v;
    };
    %EnsureFeedbackVectorForFunction(callback);
    try {
      c.map(callback);
    } catch (e) {
      caught = true;
    }
  };
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  assertDoesNotThrow(lazyDeopt.bind(this, true));
  assertTrue(caught);
  lazyDeopt();
})();

// Call to a.map is done inside a try-catch block and the callback function
// being called actually throws, but the callback is not inlined.
(function() {
  var caught = false;
  var result = 0;
  var lazyDeopt = function(deopt) {
    var callback = function(v,i,o) {
      result += i;
      if (i == 1 && deopt) {
        throw("a");
      }
      return v;
    };
    %EnsureFeedbackVectorForFunction(callback);
    %NeverOptimizeFunction(callback);
    try {
      c.map(callback);
    } catch (e) {
      caught = true;
    }
  };
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
  assertDoesNotThrow(lazyDeopt.bind(this, true));
  assertTrue(caught);
  lazyDeopt();
})();

// Call to a.map is done inside a try-catch block and the callback function
// being called throws into a deoptimized caller function.
(function TestThrowIntoDeoptimizedOuter() {
  var a = [1,2,3,4];
  var lazyDeopt = function(deopt) {
    var callback = function(v,i,o) {
      if (i == 1 && deopt) {
        %DeoptimizeFunction(lazyDeopt);
        throw "some exception";
      }
      return 2 * v;
    };
    %EnsureFeedbackVectorForFunction(callback);
    %NeverOptimizeFunction(callback);
    var result = 0;
    try {
      result = a.map(callback);
    } catch (e) {
      assertEquals("some exception", e)
      result = "nope";
    }
    return result;
  };
  %PrepareFunctionForOptimization(lazyDeopt);
  assertEquals([2,4,6,8], lazyDeopt(false));
  assertEquals([2,4,6,8], lazyDeopt(false));
  assertEquals("nope", lazyDeopt(true));
  assertEquals("nope", lazyDeopt(true));
  %OptimizeFunctionOnNextCall(lazyDeopt);
  assertEquals([2,4,6,8], lazyDeopt(false));
  assertEquals("nope", lazyDeopt(true));
})();

(function() {
  var re = /Array\.map/;
  var lazyDeopt = function(deopt) {
    var b = [1,2,3];
    var result = 0;
    var callback = function(v,i,o) {
      result += v;
      if (i == 1) {
        var e = new Error();
        assertTrue(re.exec(e.stack) !== null);
      }
      return v;
    };
    %EnsureFeedbackVectorForFunction(callback);
    var o = [1,2,3];
    b.map(callback);
  };
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
})();

(function() {
  var re = /Array\.map/;
  var lazyDeopt = function(deopt) {
    var b = [1,2,3];
    var result = 0;
    var callback = function(v,i,o) {
      result += v;
      if (i == 1) {
        var e = new Error();
        assertTrue(re.exec(e.stack) !== null);
      }
      return v;
    };
    %EnsureFeedbackVectorForFunction(callback);
    %NeverOptimizeFunction(callback);
    var o = [1,2,3];
    b.map(callback);
  };
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
})();

(function() {
  var re = /Array\.map/;
  var lazyDeopt = function(deopt) {
    var b = [1,2,3];
    var result = 0;
    var callback = function(v,i,o) {
      result += v;
      if (i == 1) {
        %DeoptimizeNow();
      } else if (i == 2) {
        var e = new Error();
        assertTrue(re.exec(e.stack) !== null);
      }
      return v;
    };
    %EnsureFeedbackVectorForFunction(callback);
    var o = [1,2,3];
    b.map(callback);
  };
  %PrepareFunctionForOptimization(lazyDeopt);
  lazyDeopt();
  lazyDeopt();
  %OptimizeFunctionOnNextCall(lazyDeopt);
  lazyDeopt();
})();

(function() {
  var re = /Array\.map/;
  var a = [1,2,3];
  var result = 0;
  var lazyDeopt = function() {
    var callback = function(v,i,o) {
      result += i;
      if (i == 1) {
        %DeoptimizeFunction(lazyDeopt);
        throw new Error();
      }
      return v;
    };
    %EnsureFeedbackVectorForFunction(callback);
    a.map(callback);
  };
  %PrepareFunctionForOptimization(lazyDeopt);
  assertThrows(() => lazyDeopt());
  assertThrows(() => lazyDeopt());
  try {
    lazyDeopt();
  } catch (e) {
    assertTrue(re.exec(e.stack) !== null);
  }
  %OptimizeFunctionOnNextCall(lazyDeopt);
  try {
    lazyDeopt();
  } catch (e) {
    assertTrue(re.exec(e.stack) !== null);
  }
})();

// Verify that we remain in optimized code despite transitions in the output
// array.
(function() {
  var result = 0;
  var to_double = function() {
    var callback = function(v,i,o) {
      result += v;
      if (i < 5) {
        // First transition the output array to PACKED_DOUBLE_ELEMENTS.
        return v + 0.5;
      } else {
        // Then return smi values and make sure they can live in the double
        // array.
        return v;
      }
    };
    %EnsureFeedbackVectorForFunction(callback);
    return c.map(callback);
  };
  %PrepareFunctionForOptimization(to_double);
  to_double();
  to_double();
  %OptimizeFunctionOnNextCall(to_double);
  var output = to_double();
  assertTrue(%HasDoubleElements(output));
  assertEquals(1.5, output[0]);
  assertEquals(6, output[5]);
  assertEquals(975, result);
  assertOptimized(to_double);
})();

(function() {
  var result = 0;
  var to_fast = function() {
    var callback = function(v,i,o) {
      result += v;
      if (i < 5) {
        // First transition the output array to PACKED_DOUBLE_ELEMENTS.
        return v + 0.5;
      } else if (i < 10) {
        // Then return smi values and make sure they can live in the double
        // array.
        return v;
      } else {
        // Later, to PACKED_ELEMENTS.
        return v + 'hello';
      }
    };
    %EnsureFeedbackVectorForFunction(callback);
    return c.map(callback);
  };
  %PrepareFunctionForOptimization(to_fast);
  to_fast();
  to_fast();
  %OptimizeFunctionOnNextCall(to_fast);
  var output = to_fast();
  %HasObjectElements(output);
  assertEquals(975, result);
  assertEquals("11hello", output[10]);
  assertOptimized(to_fast);
})();

// TurboFan specializes on number results, ensure the code path is
// tested.
(function() {
  var a = [1, 2, 3];
  function double_results() {
    // TurboFan recognizes the result is a double.
    var callback = v => v + 0.5;
    %EnsureFeedbackVectorForFunction(callback);
    return a.map(callback);
  }
  %PrepareFunctionForOptimization(double_results);
  double_results();
  double_results();
  %OptimizeFunctionOnNextCall(double_results);
  double_results();
  assertEquals(1.5, double_results()[0]);
})();

// TurboFan specializes on non-number results, ensure the code path is
// tested.
(function() {
  var a = [1, 2, 3];
  function string_results() {
    // TurboFan recognizes the result is a string.
    var callback = v => "hello" + v.toString();
    return a.map(callback);
  }
  %PrepareFunctionForOptimization(string_results);
  string_results();
  string_results();
  %OptimizeFunctionOnNextCall(string_results);
  string_results();
  assertEquals("hello1", string_results()[0]);
})();

// Verify holes are not visited.
(() => {
  const a = [1, 2, , 3, 4];
  let callback_values = [];
  function withHoles() {
    callback_values = [];
    return a.map(v => {
      callback_values.push(v);
      return v;
    });
  }
  %PrepareFunctionForOptimization(withHoles);
  withHoles();
  withHoles();
  %OptimizeFunctionOnNextCall(withHoles);
  assertArrayEquals([1, 2, , 3, 4], withHoles());
  assertArrayEquals([1, 2, 3, 4], callback_values);
})();

(() => {
  const a = [1.5, 2.5, , 3.5, 4.5];
  let callback_values = [];
  function withHoles() {
    callback_values = [];
    return a.map(v => {
      callback_values.push(v);
      return v;
    });
  }
  %PrepareFunctionForOptimization(withHoles);
  withHoles();
  withHoles();
  %OptimizeFunctionOnNextCall(withHoles);
  assertArrayEquals([1.5, 2.5, , 3.5, 4.5], withHoles());
  assertArrayEquals([1.5, 2.5, 3.5, 4.5], callback_values);
})();

// Ensure that we handle side-effects between load and call.
(() => {
  function side_effect(a, b) { if (b) a.foo = 3; return a; }
  %NeverOptimizeFunction(side_effect);

  function unreliable(a, b) {
    return a.map(x => x * 2, side_effect(a, b));
  }

  let a = [1, 2, 3];
  %PrepareFunctionForOptimization(unreliable);
  unreliable(a, false);
  unreliable(a, false);
  %OptimizeFunctionOnNextCall(unreliable);
  unreliable(a, false);
  // Now actually do change the map.
  unreliable(a, true);
})();

// Messing with the Array species constructor causes deoptimization.
(function() {
  var result = 0;
  var a = [1,2,3];
  var species_breakage = function() {
    var callback = function(v,i,o) {
      result += v;
      return v;
    }
    a.map(callback);
  };
  %PrepareFunctionForOptimization(species_breakage);
  species_breakage();
  species_breakage();
  %OptimizeFunctionOnNextCall(species_breakage);
  species_breakage();
  a.constructor = {};
  a.constructor[Symbol.species] = function() {};
  species_breakage();
  assertUnoptimized(species_breakage);
  assertEquals(24, result);
})();

/////////////////////////////////////////////////////////////////////////
//
// Any tests added below species_breakage won't test optimized map calls
// because the array species constructor change disables inlining of
// Array.prototype.map across the isolate.
//
/////////////////////////////////////////////////////////////////////////
                                                                                                      node-23.7.0/deps/v8/test/mjsunit/optimized-reduce.js                                                0000664 0000000 0000000 00000004274 14746647661 0022333 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --expose-gc --turbo-inline-array-builtins
// Flags: --turbofan --no-always-turbofan

// Unknown field access leads to eager-deopt unrelated to reduce, should still
// lead to correct result.
(() => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  // For this particular eager deopt point to work, we need to dodge
  // TurboFan's soft-deopts through a non-inlined and non-optimized function
  // call to foo().
  function foo(o, deopt) { if (deopt) { o.abc = 3; }}
  %NeverOptimizeFunction(foo);
  function eagerDeoptInCalled(deopt) {
    return a.reduce((r, v, i, o) => {
      if (i === 7) {
        foo(a, deopt);
      }
      return r + "S";
    }, "H");
  }
  %PrepareFunctionForOptimization(eagerDeoptInCalled);
  eagerDeoptInCalled();
  eagerDeoptInCalled();
  %OptimizeFunctionOnNextCall(eagerDeoptInCalled);
  eagerDeoptInCalled();
  assertEquals("HSSSSSSSSSS", eagerDeoptInCalled(true));
})();

// Make sure we gracefully handle the case of an empty array in
// optimized code.
(function() {
  var nothingThere = function(only_holes) {
    var a = [1,2,,3];  // holey smi array.
    if (only_holes) {
      a = [,,,];  // also a holey smi array.
    }
    return a.reduce((r,v,i,o)=>r+v);
  };
  %PrepareFunctionForOptimization(nothingThere);
  nothingThere();
  nothingThere();
  %OptimizeFunctionOnNextCall(nothingThere);
  assertThrows(() => nothingThere(true));
})();

// An error generated inside the callback includes reduce in it's
// stack trace.
(function() {
  var re = /Array\.reduce/;
  var alwaysThrows = function() {
    var b = [,,,];
    var result = 0;
    var callback = function(r,v,i,o) {
      return r + v;
    };
    b.reduce(callback);
  }
  try {
    alwaysThrows();
  } catch (e) {
    assertTrue(re.exec(e.stack) !== null);
  }
  %PrepareFunctionForOptimization(alwaysThrows);
  try { alwaysThrows(); } catch (e) {}
  try { alwaysThrows(); } catch (e) {}
  %OptimizeFunctionOnNextCall(alwaysThrows);
  try {
    alwaysThrows();
  } catch (e) {
    assertTrue(re.exec(e.stack) !== null);
  }
})();
                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/test/mjsunit/optimized-reduceright.js                                           0000664 0000000 0000000 00000004345 14746647661 0023370 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --expose-gc --turbo-inline-array-builtins
// Flags: --turbofan --no-always-turbofan

// Unknown field access leads to eager-deopt unrelated to reduceright, should
// still lead to correct result.
(() => {
  const a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  // For this particular eager deopt point to work, we need to dodge
  // TurboFan's soft-deopts through a non-inlined and non-optimized function
  // call to foo().
  function foo(o, deopt) {
    if (deopt) {
      o.abc = 3;
    }
  }
  %NeverOptimizeFunction(foo);
  function eagerDeoptInCalled(deopt) {
    return a.reduceRight((r, v, i, o) => {
      if (i === 7) {
        foo(a, deopt);
      }
      return r + "S";
    }, "H");
  };
  %PrepareFunctionForOptimization(eagerDeoptInCalled);
  eagerDeoptInCalled();
  eagerDeoptInCalled();
  %OptimizeFunctionOnNextCall(eagerDeoptInCalled);
  eagerDeoptInCalled();
  assertEquals("HSSSSSSSSSS", eagerDeoptInCalled(true));
})();

// Make sure we gracefully handle the case of an empty array in
// optimized code.
(function() {
var nothingThere = function(only_holes) {
  var a = [1, 2, , 3];  // holey smi array.
  if (only_holes) {
    a = [
      ,
      ,
      ,
    ];  // also a holey smi array.
  }
  return a.reduceRight((r, v, i, o) => r + v);
};
;
%PrepareFunctionForOptimization(nothingThere);
nothingThere();
nothingThere();
%OptimizeFunctionOnNextCall(nothingThere);
assertThrows(() => nothingThere(true));
})();

// An error generated inside the callback includes reduce in it's
// stack trace.
(function() {
var re = /Array\.reduceRight/;
var alwaysThrows = function() {
  var b = [
    ,
    ,
    ,
  ];
  var result = 0;
  var callback = function(r, v, i, o) {
    return r + v;
  };
  b.reduceRight(callback);
};
;
%PrepareFunctionForOptimization(alwaysThrows);
try {
  alwaysThrows();
} catch (e) {
  assertTrue(re.exec(e.stack) !== null);
}
try {
  alwaysThrows();
} catch (e) {
}
try {
  alwaysThrows();
} catch (e) {
}
%OptimizeFunctionOnNextCall(alwaysThrows);
try {
  alwaysThrows();
} catch (e) {
  assertTrue(re.exec(e.stack) !== null);
}
})();
                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/optimized-string-includes.js                                       0000664 0000000 0000000 00000006742 14746647661 0024200 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan

(function optimize() {
  function f() {
    return 'abc'.includes('a');
  }
  %PrepareFunctionForOptimization(f);
  assertEquals(true, f());
  assertEquals(true, f());
  assertEquals(true, f());
  %OptimizeFunctionOnNextCall(f);
  assertEquals(true, f());
  assertOptimized(f);

  function f2() {
    return 'abc'.includes('a', 1);
  }
  %PrepareFunctionForOptimization(f2);
  assertEquals(false, f2());
  assertEquals(false, f2());
  assertEquals(false, f2());
  %OptimizeFunctionOnNextCall(f2);
  assertEquals(false, f2());
  assertOptimized(f2);

  function f3() {
    return 'abc'.includes('b');
  }
  %PrepareFunctionForOptimization(f3);
  assertEquals(true, f3());
  assertEquals(true, f3());
  assertEquals(true, f3());
  %OptimizeFunctionOnNextCall(f3);
  assertEquals(true, f3());
  assertOptimized(f3);

  function f4() {
    return 'abcbc'.includes('bc', 2);
  }
  %PrepareFunctionForOptimization(f4);
  assertEquals(true, f4());
  assertEquals(true, f4());
  assertEquals(true, f4());
  %OptimizeFunctionOnNextCall(f4);
  assertEquals(true, f4());
  assertOptimized(f4);

  function f5() {
    return 'abcbc'.includes('b', -1);
  }
  %PrepareFunctionForOptimization(f5);
  assertEquals(true, f5());
  assertEquals(true, f5());
  assertEquals(true, f5());
  %OptimizeFunctionOnNextCall(f5);
  assertEquals(true, f5());
  assertOptimized(f5);

  function f6() {
    return 'abcbc'.includes('b', -10737418);
  }
  %PrepareFunctionForOptimization(f6);
  assertEquals(true, f6());
  assertEquals(true, f6());
  assertEquals(true, f6());
  %OptimizeFunctionOnNextCall(f6);
  assertEquals(true, f6());
  assertOptimized(f6);
})();

(function optimizeOSR() {
  function f() {
    var result;
    for (var i = 0; i < 100000; i++) {
      result = 'abc'.includes('a');
    }
    return result;
  }
  assertEquals(true, f());

  function f2() {
    var result;
    for (var i = 0; i < 100000; i++) {
      result = 'abc'.includes('a', 1);
    }
    return result;
  }
  assertEquals(false, f2());

  function f3() {
    var result;
    for (var i = 0; i < 100000; i++) {
      result = 'abc'.includes('b');
    }
    return result;
  }
  assertEquals(true, f3());

  function f4() {
    var result;
    for (var i = 0; i < 100000; i++) {
      result = 'abcbc'.includes('bc', 2);
    }
    return result;
  }
  assertEquals(true, f4());
})();

(function bailout() {
  function f(str) {
    return String.prototype.includes.call(str, 'a')
  }
  %PrepareFunctionForOptimization(f);
  assertEquals(true, f('abc'));
  %OptimizeFunctionOnNextCall(f);
  assertEquals(true, f({
                 toString: () => {
                   return 'abc'
                 }
  }));
  assertUnoptimized(f);

  function f2(str) {
    return 'abc'.includes(str)
  }
  %PrepareFunctionForOptimization(f2);
  assertEquals(true, f2('a'));
  %OptimizeFunctionOnNextCall(f2);
  assertEquals(true, f2({
                 toString: () => {
                   return 'a'
                 }
               }));
  assertUnoptimized(f2);

  function f3(index) {
    return 'abc'.includes('a', index)
  }
  %PrepareFunctionForOptimization(f3);
  assertEquals(true, f3(0));
  %OptimizeFunctionOnNextCall(f3);
  assertEquals(true, f3({
                 valueOf: () => {
                   return 0
                 }
  }));
  assertUnoptimized(f3);
})();
                              node-23.7.0/deps/v8/test/mjsunit/optimized-typeof.js                                                0000664 0000000 0000000 00000004453 14746647661 0022371 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2011 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax

function typeofDirectly() {
  return typeof{} === 'undefined';
};
%PrepareFunctionForOptimization(typeofDirectly);
typeofDirectly();
typeofDirectly();
%OptimizeFunctionOnNextCall(typeofDirectly);
typeofDirectly();

function typeofViaVariable() {
  var foo = typeof{};
  return foo === "undefined";
};
%PrepareFunctionForOptimization(typeofViaVariable);
typeofViaVariable();
typeofViaVariable();
%OptimizeFunctionOnNextCall(typeofViaVariable);
typeofViaVariable();

function typeofMinifiedDirectly() {
  return typeof{}>'u';
};
%PrepareFunctionForOptimization(typeofMinifiedDirectly);
typeofMinifiedDirectly();
typeofMinifiedDirectly();
%OptimizeFunctionOnNextCall(typeofMinifiedDirectly);
typeofMinifiedDirectly();
                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/osr-elements-kind.js                                               0000664 0000000 0000000 00000013244 14746647661 0022417 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2012 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax --expose-gc

// Limit the number of stress runs to reduce polymorphism it defeats some of the
// assumptions made about how elements transitions work because transition stubs
// end up going generic.
// Flags: --stress-runs=1

var elements_kind = {
  fast_smi_only             :  'fast smi only elements',
  fast                      :  'fast elements',
  fast_double               :  'fast double elements',
  dictionary                :  'dictionary elements',
  fixed_int32               :  'fixed int8 elements',
  fixed_uint8               :  'fixed uint8 elements',
  fixed_int16               :  'fixed int16 elements',
  fixed_uint16              :  'fixed uint16 elements',
  fixed_int32               :  'fixed int32 elements',
  fixed_uint32              :  'fixed uint32 elements',
  fixed_float32             :  'fixed float32 elements',
  fixed_float64             :  'fixed float64 elements',
  fixed_uint8_clamped       :  'fixed uint8_clamped elements'
}

function getKind(obj) {
  if (%HasSmiElements(obj)) return elements_kind.fast_smi_only;
  if (%HasObjectElements(obj)) return elements_kind.fast;
  if (%HasDoubleElements(obj)) return elements_kind.fast_double;
  if (%HasDictionaryElements(obj)) return elements_kind.dictionary;

  if (%HasFixedInt8Elements(obj)) {
    return elements_kind.fixed_int8;
  }
  if (%HasFixedUint8Elements(obj)) {
    return elements_kind.fixed_uint8;
  }
  if (%HasFixedInt16Elements(obj)) {
    return elements_kind.fixed_int16;
  }
  if (%HasFixedUint16Elements(obj)) {
    return elements_kind.fixed_uint16;
  }
  if (%HasFixedInt32Elements(obj)) {
    return elements_kind.fixed_int32;
  }
  if (%HasFixedUint32Elements(obj)) {
    return elements_kind.fixed_uint32;
  }
  if (%HasFixedFloat32Elements(obj)) {
    return elements_kind.fixed_float32;
  }
  if (%HasFixedFloat64Elements(obj)) {
    return elements_kind.fixed_float64;
  }
  if (%HasFixedUint8ClampedElements(obj)) {
    return elements_kind.fixed_uint8_clamped;
  }
}

function assertKind(expected, obj, name_opt) {
  assertEquals(expected, getKind(obj), name_opt);
}

%EnsureFeedbackVectorForFunction(test_osr_elements_kind);
function test_osr_elements_kind() {
  %NeverOptimizeFunction(construct_smis);
  %NeverOptimizeFunction(construct_doubles);
  %NeverOptimizeFunction(convert_mixed);
  for (var i = 0; i < 10; i++) { if (i == 5) %OptimizeOsr(); }

  // This code exists to eliminate the learning influence of AllocationSites
  // on the following tests.
  var __sequence = 0;
  function make_array_string() {
    this.__sequence = this.__sequence + 1;
    return "/* " + this.__sequence + " */  [0, 0, 0];"
  }
  function make_array() {
    return eval(make_array_string());
  }

  %EnsureFeedbackVectorForFunction(construct_smis);
  function construct_smis() {
    var a = make_array();
    a[0] = 0;  // Send the COW array map to the steak house.
    assertKind(elements_kind.fast_smi_only, a);
    return a;
  }

  %EnsureFeedbackVectorForFunction(construct_doubles);
  function construct_doubles() {
    var a = construct_smis();
    a[0] = 1.5;
    assertKind(elements_kind.fast_double, a);
    return a;
  }

  // Test transition chain SMI->DOUBLE->FAST (optimized function will
  // transition to FAST directly).
  %EnsureFeedbackVectorForFunction(convert_mixed);
  function convert_mixed(array, value, kind) {
    array[1] = value;
    assertKind(kind, array);
    assertEquals(value, array[1]);
  }
  smis = construct_smis();
  convert_mixed(smis, 1.5, elements_kind.fast_double);

  doubles = construct_doubles();
  convert_mixed(doubles, "three", elements_kind.fast);

  convert_mixed(construct_smis(), "three", elements_kind.fast);
  convert_mixed(construct_doubles(), "three", elements_kind.fast);

  if (%ICsAreEnabled()) {
    // Test that allocation sites allocate correct elements kind initially based
    // on previous transitions.
    smis = construct_smis();
    doubles = construct_doubles();
    convert_mixed(smis, 1, elements_kind.fast);
    convert_mixed(doubles, 1, elements_kind.fast);
    assertTrue(%HaveSameMap(smis, doubles));
  }
}

// Throw away type information in the ICs for next stress run.
gc();
                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/outobject-double-for-in.js                                         0000664 0000000 0000000 00000004705 14746647661 0023517 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2012 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax

function DoubleContainer() {
  this.x0 = 0.5;
  this.x1 = undefined;
  this.x2 = undefined;
  this.x3 = undefined;
  this.x4 = undefined;
  this.x5 = undefined;
  this.x6 = undefined;
  this.x7 = 5;
  this.x8 = undefined;
  this.x9 = undefined;
  this.x10 = undefined;
  this.x11 = undefined;
  this.x12 = undefined;
  this.x13 = undefined;
  this.x14 = undefined;
  this.x15 = undefined;
  this.x16 = true;
  this.y = 2.5;
}

var z = new DoubleContainer();

function test_props(a) {
  for (var i in a) {
    assertTrue(i !== "x0" || a[i] === 0.5);
    assertTrue(i !== "y" || a[i] === 2.5);
    assertTrue(i !== "x12" || a[i] === undefined);
    assertTrue(i !== "x16" || a[i] === true);
    assertTrue(i !== "x7" || a[i] === 5);
  }
}

%PrepareFunctionForOptimization(test_props);
test_props(z);
test_props(z);
%OptimizeFunctionOnNextCall(test_props);
test_props(z);
                                                           node-23.7.0/deps/v8/test/mjsunit/override-read-only-property.js                                     0000664 0000000 0000000 00000005321 14746647661 0024445 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// According to ECMA-262, sections 8.6.2.2 and 8.6.2.3 you're not
// allowed to override read-only properties, not even if the read-only
// property is in the prototype chain.
//
// However, for compatibility with WebKit/JSC, we allow the overriding
// of read-only properties in prototype chains.

function F() {};
F.prototype = Number;

var original_number_max = Number.MAX_VALUE;

// Assignment to a property which does not exist on the object itself,
// but is read-only in a prototype does not take effect.
var f = new F();
assertEquals(original_number_max, f.MAX_VALUE);
f.MAX_VALUE = 42;
assertEquals(original_number_max, f.MAX_VALUE);

// Assignment to a property which does not exist on the object itself,
// but is read-only in a prototype does not take effect.
f = new F();
with (f) {
  MAX_VALUE = 42;
}
assertEquals(original_number_max, f.MAX_VALUE);

// Assignment to read-only property on the object itself is ignored.
Number.MAX_VALUE = 42;
assertEquals(original_number_max, Number.MAX_VALUE);

// G should be read-only on the global object and the assignment is
// ignored.
(function G() {
  eval("G = 42;");
  assertTrue(typeof G === 'function');
})();
                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/packed-elements.js                                                 0000664 0000000 0000000 00000007164 14746647661 0022124 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2012 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax

function test1() {
  var a = Array(8);
  assertTrue(%HasSmiOrObjectElements(a));
  assertTrue(%HasHoleyElements(a));
}

function test2() {
  var a = Array();
  assertTrue(%HasSmiOrObjectElements(a));
  assertFalse(%HasHoleyElements(a));
}

function test3() {
  var a = Array(1,2,3,4,5,6,7);
  assertTrue(%HasSmiOrObjectElements(a));
  assertFalse(%HasHoleyElements(a));
}

function test4() {
  var a = [1, 2, 3, 4];
  assertTrue(%HasSmiElements(a));
  assertFalse(%HasHoleyElements(a));
  var b = [1, 2,, 4];
  assertTrue(%HasSmiElements(b));
  assertTrue(%HasHoleyElements(b));
}

function test5() {
  var a = [1, 2, 3, 4.5];
  assertTrue(%HasDoubleElements(a));
  assertFalse(%HasHoleyElements(a));
  var b = [1,, 3.5, 4];
  assertTrue(%HasDoubleElements(b));
  assertTrue(%HasHoleyElements(b));
  var c = [1, 3.5,, 4];
  assertTrue(%HasDoubleElements(c));
  assertTrue(%HasHoleyElements(c));
}

function test6() {
  var x = new Object();
  var a = [1, 2, 3.5, x];
  assertTrue(%HasObjectElements(a));
  assertFalse(%HasHoleyElements(a));
  assertEquals(1, a[0]);
  assertEquals(2, a[1]);
  assertEquals(3.5, a[2]);
  assertEquals(x, a[3]);
  var b = [1,, 3.5, x];
  assertTrue(%HasObjectElements(b));
  assertTrue(%HasHoleyElements(b));
  assertEquals(1, b[0]);
  assertEquals(undefined, b[1]);
  assertEquals(3.5, b[2]);
  assertEquals(x, b[3]);
  var c = [1, 3.5, x,,];
  assertTrue(%HasObjectElements(c));
  assertTrue(%HasHoleyElements(c));
  assertEquals(1, c[0]);
  assertEquals(3.5, c[1]);
  assertEquals(x, c[2]);
  assertEquals(undefined, c[3]);
}

function test_with_optimization(f) {
  %PrepareFunctionForOptimization(f);
  for (i = 0; i < 3; ++i) f();
  // Cause the inlined Array() constructor to fall back to the runtime impl.
  %SimulateNewspaceFull();
  f();
  %OptimizeFunctionOnNextCall(f);
  f();
  %SimulateNewspaceFull();  // Make sure GC happens.
  f();
}

test_with_optimization(test1);
test_with_optimization(test2);
test_with_optimization(test3);
test_with_optimization(test4);
test_with_optimization(test5);
test_with_optimization(test6);
                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/parallel-compile-tasks.js                                          0000664 0000000 0000000 00000002664 14746647661 0023430 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --compiler-dispatcher --parallel-compile-tasks-for-eager-toplevel --use-external-strings

(function(a) {
 assertEquals(a, "IIFE");
})("IIFE");

(function(a, ...rest) {
 assertEquals(a, 1);
 assertEquals(rest.length, 2);
 assertEquals(rest[0], 2);
 assertEquals(rest[1], 3);
})(1,2,3);

var outer_var = 42;

function lazy_outer() {
 return 42;
}

var eager_outer = (function() { return 42; });

(function() {
 assertEquals(outer_var, 42);
 assertEquals(lazy_outer(), 42);
 assertEquals(eager_outer(), 42);
})();

var gen = (function*() {
 yield 1;
 yield 2;
})();

assertEquals(gen.next().value, 1);
assertEquals(gen.next().value, 2);

var result = (function recursive(a=0) {
 if (a == 1) {
  return 42;
 }
 return recursive(1);
})();

assertEquals(result, 42);

var a = 42;
var b;
var c = (a, b = (function z(){ return a+1; })());
assertEquals(b, 43);
assertEquals(c, 43);
var c = (a, b = (function z(){ return a+1; })()) => { return b; };
assertEquals(c(314), 315);

// http://crbug.com/898076
(function() {
  class foo {};
});  // Don't call IIFE so that it is compiled during idle time

// http://crbug.com/900535
(function() {
  "use asm";
  function bar(i, j) {
    i = i|0;
    j = j|0;
  }
  return {bar: bar};
});  // Don't call IIFE so that it is compiled during idle time
                                                                            node-23.7.0/deps/v8/test/mjsunit/parse-int-float.js                                                 0000664 0000000 0000000 00000011705 14746647661 0022064 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

assertEquals(0, parseInt('0'));
assertEquals(0, parseInt(' 0'));
assertEquals(0, parseInt(' 0 '));

assertEquals(77, parseInt('077'));
assertEquals(77, parseInt('  077'));
assertEquals(77, parseInt('  077   '));
assertEquals(-77, parseInt('  -077'));

assertEquals(3, parseInt('11', 2));
assertEquals(4, parseInt('11', 3));
assertEquals(4, parseInt('11', 3.8));

assertEquals(0x12, parseInt('0x12'));
assertEquals(0x12, parseInt('0x12', 16));
assertEquals(0x12, parseInt('0x12', 16.1));
assertEquals(0x12, parseInt('0x12', NaN));
assertTrue(isNaN(parseInt('0x  ')));
assertTrue(isNaN(parseInt('0x')));
assertTrue(isNaN(parseInt('0x  ', 16)));
assertTrue(isNaN(parseInt('0x', 16)));
assertEquals(12, parseInt('12aaa'));

assertEquals(0.1, parseFloat('0.1'));
assertEquals(0.1, parseFloat('0.1aaa'));
assertEquals(0, parseFloat('0aaa'));
assertEquals(0, parseFloat('0x12'));
assertEquals(77, parseFloat('077'));

assertEquals(Infinity, parseInt('1000000000000000000000000000000000000000000000'
    + '000000000000000000000000000000000000000000000000000000000000000000000000'
    + '000000000000000000000000000000000000000000000000000000000000000000000000'
    + '000000000000000000000000000000000000000000000000000000000000000000000000'
    + '000000000000000000000000000000000000000000000000000000000000000000000000'
    + '0000000000000'));

assertEquals(Infinity, parseInt('0x10000000000000000000000000000000000000000000'
    + '000000000000000000000000000000000000000000000000000000000000000000000000'
    + '000000000000000000000000000000000000000000000000000000000000000000000000'
    + '000000000000000000000000000000000000000000000000000000000000000000000000'
    + '000000000000000000000000000000000000000000000000000000000000000000000000'
    + '0000000000000'));


var i;
var y = 10;

for (i = 1; i < 21; i++) {
  var x = eval("1.2e" + i);
  assertEquals(Math.floor(x), parseInt(x));
  x = eval("1e" + i);
  assertEquals(x, y);
  y *= 10;
  assertEquals(Math.floor(x), parseInt(x));
  x = eval("-1e" + i);
  assertEquals(Math.ceil(x), parseInt(x));
  x = eval("-1.2e" + i);
  assertEquals(Math.ceil(x), parseInt(x));
}

for (i = 21; i < 53; i++) {
  var x = eval("1e" + i);
  assertEquals(1, parseInt(x));
  x = eval("-1e" + i);
  assertEquals(-1, parseInt(x));
}

assertTrue(isNaN(parseInt(0/0)));
assertTrue(isNaN(parseInt(1/0)), "parseInt Infinity");
assertTrue(isNaN(parseInt(-1/0)), "parseInt -Infinity");

assertTrue(isNaN(parseFloat(0/0)));
assertEquals(Infinity, parseFloat(1/0), "parseFloat Infinity");
assertEquals(-Infinity, parseFloat(-1/0), "parseFloat -Infinity");

var state;
var throwingRadix = { valueOf: function() { state = "throwingRadix"; throw null; } };
var throwingString = { toString: function() { state = "throwingString"; throw null; } };
state = null;
try { parseInt('123', throwingRadix); } catch (e) {}
assertEquals(state, "throwingRadix");

state = null;
try { parseInt(throwingString, 10); } catch (e) {}
assertEquals(state, "throwingString");

state = null;
try { parseInt(throwingString, throwingRadix); } catch (e) {}
assertEquals(state, "throwingString");

// And finally, check that the Harmony additions to the Number
// constructor is available:
assertTrue("parseInt" in Number);
assertTrue("parseFloat" in Number);
assertSame( Number.parseInt, parseInt);
assertSame(Number.parseFloat, parseFloat);
assertEquals(Number.parseFloat('0.1'), parseFloat('0.1'));
assertEquals(Number.parseInt('0xea'), parseInt('0xEA'));
                                                           node-23.7.0/deps/v8/test/mjsunit/parse-surrogates.js                                                0000664 0000000 0000000 00000000503 14746647661 0022357 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Test that the parser throws on unmatched surrogates.
assertThrows("var \uD801\uABCD;", SyntaxError);
assertThrows("'\\u000\uD801\uABCD'", SyntaxError);
                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/pixel-array-rounding.js                                            0000664 0000000 0000000 00000004031 14746647661 0023131 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2012 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax

var pixels = new Uint8ClampedArray(11);

function f() {
  for (var i = 0; i < 8; i++) {
    pixels[i] = (i * 1.1);
  }
  pixels[8] = 255.5;
  pixels[9] = NaN;
  pixels[10] = -0.5;
  return pixels[1] + pixels[6];
}

%PrepareFunctionForOptimization(f);
f();
f();
assertEquals(6, pixels[5]);
%OptimizeFunctionOnNextCall(f);
f();
assertEquals(6, pixels[5]);
assertEquals(255, pixels[8]);
assertEquals(0, pixels[9]);
assertEquals(0, pixels[10]);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/polymorph-arrays.js                                                0000664 0000000 0000000 00000014305 14746647661 0022406 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2011 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax
function init_array(a) {
  for (var i = 0; i < 10; ++i ){
    a[i] = i;
  }
}

function init_sparse_array(a) {
  for (var i = 0; i < 10; ++i ){
    a[i] = i;
  }
  a[200000] = 256;
  return %NormalizeElements(a);
}

function testPolymorphicLoads() {
  function make_polymorphic_load_function() {
    function load(a, i) {
      return a[i];
    }
    %PrepareFunctionForOptimization(load);

    var object_array = new Object;
    var sparse_object_array = new Object;
    var js_array = new Array(10);
    var sparse_js_array = %NormalizeElements([]);

    init_array(object_array);
    init_array(js_array);
    init_sparse_array(sparse_object_array);
    init_sparse_array(sparse_js_array);

    assertEquals(1, load(object_array, 1));
    assertEquals(1, load(js_array, 1));
    assertEquals(1, load(sparse_object_array, 1));
    assertEquals(1, load(sparse_js_array, 1));

    return load;
  }

  var object_array = new Object;
  var sparse_object_array = new Object;
  var js_array = new Array(10);
  var sparse_js_array = %NormalizeElements([]);

  init_array(object_array);
  init_array(js_array);
  init_sparse_array(sparse_object_array);
  init_sparse_array(sparse_js_array);

  load = make_polymorphic_load_function();
  assertEquals(undefined, load(js_array, new Object()));
  load = make_polymorphic_load_function();
  assertEquals(undefined, load(object_array, new Object()));
  load = make_polymorphic_load_function();
  assertEquals(undefined, load(sparse_js_array, new Object()));
  load = make_polymorphic_load_function();
  assertEquals(undefined, load(sparse_object_array, new Object()));

  // Try with optimizing compiler.
  load = make_polymorphic_load_function();
  %OptimizeFunctionOnNextCall(load);
  assertEquals(1, load(object_array, 1));
  assertEquals(1, load(js_array, 1));
  assertEquals(1, load(sparse_object_array, 1));
  assertEquals(1, load(sparse_js_array, 1));

  load = make_polymorphic_load_function();
  %OptimizeFunctionOnNextCall(load);
  assertEquals(undefined, load(js_array, new Object()));
  load = make_polymorphic_load_function();
  %OptimizeFunctionOnNextCall(load);
  assertEquals(undefined, load(object_array, new Object()));
  load = make_polymorphic_load_function();
  %OptimizeFunctionOnNextCall(load);
  assertEquals(undefined, load(sparse_js_array, new Object()));
  load = make_polymorphic_load_function();
  %OptimizeFunctionOnNextCall(load);
  assertEquals(undefined, load(sparse_object_array, new Object()));
}

function testPolymorphicStores() {
  function make_polymorphic_store_function() {
    function store(a, i, val) {
      a[i] = val;
    }
    %PrepareFunctionForOptimization(store);

    var object_array = new Object;
    var sparse_object_array = new Object;
    var js_array = new Array(10);
    var sparse_js_array = [];
    sparse_js_array.length = 200001;

    init_array(object_array);
    init_array(js_array);
    init_sparse_array(sparse_object_array);
    init_sparse_array(sparse_js_array);

    store(object_array, 1, 256);
    store(js_array, 1, 256);
    store(sparse_object_array, 1, 256);
    store(sparse_js_array, 1, 256);

    return store;
  }

  var object_array = new Object;
  var sparse_object_array = new Object;
  var js_array = new Array(10);
  var sparse_js_array = %NormalizeElements([]);
  sparse_js_array.length = 200001;
  assertTrue(%HasDictionaryElements(sparse_js_array));

  init_array(object_array);
  init_array(js_array);
  init_sparse_array(sparse_object_array);
  init_sparse_array(sparse_js_array);

  store = make_polymorphic_store_function();
  store(object_array, 2, 257);
  store = make_polymorphic_store_function();
  store(js_array, 2, 257);
  store = make_polymorphic_store_function();
  store(sparse_object_array, 2, 257);
  store = make_polymorphic_store_function();
  store(sparse_js_array, 2, 257);

  assertEquals(257, object_array[2]);
  assertEquals(257, js_array[2]);
  assertEquals(257, sparse_js_array[2]);
  assertEquals(257, sparse_object_array[2]);

  // Now try Crankshaft optimized polymorphic stores
  store = make_polymorphic_store_function();
  %OptimizeFunctionOnNextCall(store);
  store(object_array, 3, 258);
  store = make_polymorphic_store_function();
  %OptimizeFunctionOnNextCall(store);
  store(js_array, 3, 258);
  store = make_polymorphic_store_function();
  %OptimizeFunctionOnNextCall(store);
  store(sparse_object_array, 3, 258);
  store = make_polymorphic_store_function();
  %OptimizeFunctionOnNextCall(store);
  store(sparse_js_array, 3, 258);

  assertEquals(258, object_array[3]);
  assertEquals(258, js_array[3]);
  assertEquals(258, sparse_js_array[3]);
  assertEquals(258, sparse_object_array[3]);
}

testPolymorphicLoads();
testPolymorphicStores();
                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/prepare-missing-label-syntax-error.js                              0000664 0000000 0000000 00000000606 14746647661 0025712 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

assertThrows("function f() { break }", SyntaxError);
assertThrows("function f() { break a }", SyntaxError);
assertThrows("function f() { continue }", SyntaxError);
assertThrows("function f() { continue a }", SyntaxError);
                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/preparse-toplevel-strict-eval.js                                   0000664 0000000 0000000 00000000531 14746647661 0024756 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

"use strict";
var x = 1;
var g = eval("var y = 100; function h(s) { if (s) x = s; return x+y; }; h");

assertEquals(101, g());
assertEquals(102, g(2));
assertEquals(102, g(2));
                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/primitive-keyed-access.js                                          0000664 0000000 0000000 00000002136 14746647661 0023423 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

Object.defineProperty(Number.prototype, "0",
    { set: function(v) { set = v; }});
Object.defineProperty(String.prototype, "0",
    { set: function(v) { set = v; }});
Object.defineProperty(String.prototype, "3",
    { set: function(v) { set = v; }});

var set;
var n = 1;
set = 0;
n[0] = 100;
assertEquals(100, set);
var s = "bla";
s[0] = 200;
assertEquals(100, set);
s[3] = 300;
assertEquals(300, set);

assertThrows(function(){"use strict"; var o = "123"; o[1] = 10; });
assertThrows(function(){"use strict"; var o = ""; o[1] = 10; });
assertThrows(function(){"use strict"; var o = 1; o[1] = 10; });

assertThrows(function() {
  "use strict";
  var sym = Symbol('66');
  sym.a = 0;
});

assertThrows(function() {
  "use strict";
  var sym = Symbol('66');
  sym['a' + 'b'] = 0;
});

assertThrows(function() {
  "use strict";
  var sym = Symbol('66');
  sym[62] = 0;
});

assertThrows(function() {
  "use strict";
  var o = "bla";
  o["0"] = 1;
});
                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/print.js                                                           0000664 0000000 0000000 00000000464 14746647661 0020213 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

assertEquals("function", typeof print, "print should be defined");
assertEquals("function", typeof printErr, "printErr should be defined");
                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/promise-hooks.js                                                   0000664 0000000 0000000 00000021124 14746647661 0021652 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan --deopt-every-n-times=0 --ignore-unhandled-promises

let log = [];
let asyncId = 0;

function logEvent (type, args) {
  const promise = args[0];
  promise.asyncId = promise.asyncId || ++asyncId;
  log.push({
    type,
    promise,
    parent: args[1],
    argsLength: args.length
  })
}
function initHook(...args) {
  logEvent('init', args);
}
function resolveHook(...args) {
  logEvent('resolve', args);
}
function beforeHook(...args) {
  logEvent('before', args);
}
function afterHook(...args) {
  logEvent('after', args);
}

function printLog(message) {
  console.log(` --- ${message} --- `)
  for (const event of log) {
    console.log(JSON.stringify(event))
  }
}

let has_promise_hooks = false;
try {
  d8.promise.setHooks();
  has_promise_hooks = true;
} catch {
  has_promise_hooks = false;
}

function assertNextEvent(type, args) {
  const [ promiseOrId, parentOrId ] = args;
  const nextEvent = log.shift();

  assertEquals(type, nextEvent.type);
  assertEquals(type === 'init' ? 2 : 1, nextEvent.argsLength);

  assertTrue(nextEvent.promise instanceof Promise);
  if (promiseOrId instanceof Promise) {
    assertEquals(promiseOrId, nextEvent.promise);
  } else {
    assertTrue(typeof promiseOrId === 'number');
    assertEquals(promiseOrId, nextEvent.promise?.asyncId);
  }

  if (parentOrId instanceof Promise) {
    assertEquals(parentOrId, nextEvent.parent);
    assertTrue(nextEvent.parent instanceof Promise);
  } else if (typeof parentOrId === 'number') {
    assertEquals(parentOrId, nextEvent.parent?.asyncId);
    assertTrue(nextEvent.parent instanceof Promise);
  } else {
    assertEquals(undefined, parentOrId);
    assertEquals(undefined, nextEvent.parent);
  }
}
function assertEmptyLog() {
  assertEquals(0, log.length);
  asyncId = 0;
  log = [];
}

// Verify basic log structure of different promise behaviours
function basicTest() {
  d8.promise.setHooks(initHook, beforeHook, afterHook, resolveHook);

  // `new Promise(...)` triggers init event with correct promise
  var done, p1 = new Promise(r => done = r);
  %PerformMicrotaskCheckpoint();
  assertNextEvent('init', [ p1 ]);
  assertEmptyLog();

  // `promise.then(...)` triggers init event with correct promise and parent
  var p2 = p1.then(() => { });
  %PerformMicrotaskCheckpoint();
  assertNextEvent('init', [ p2, p1 ]);
  assertEmptyLog();

  // `resolve(...)` triggers resolve event and any already attached continuations
  done();
  %PerformMicrotaskCheckpoint();
  assertNextEvent('resolve', [ p1 ]);
  assertNextEvent('before', [ p2 ]);
  assertNextEvent('resolve', [ p2 ]);
  assertNextEvent('after', [ p2 ]);
  assertEmptyLog();

  // `reject(...)` triggers the resolve event
  var done, p3 = new Promise((_, r) => done = r);
  done();
  %PerformMicrotaskCheckpoint();
  assertNextEvent('init', [ p3 ]);
  assertNextEvent('resolve', [ p3 ]);
  assertEmptyLog();

  // `promise.catch(...)` triggers init event with correct promise and parent
  // When the promise is already completed, the continuation should also run
  // immediately at the next checkpoint.
  var p4 = p3.catch(() => { });
  %PerformMicrotaskCheckpoint();
  assertNextEvent('init', [ p4, p3 ]);
  assertNextEvent('before', [ p4 ]);
  assertNextEvent('resolve', [ p4 ]);
  assertNextEvent('after', [ p4 ]);
  assertEmptyLog();

  // Detach hooks
  d8.promise.setHooks();
}

// Exceptions thrown in hook handlers should not raise or reject
function exceptions() {
  function thrower() {
    throw new Error('unexpected!');
  }

  // Init hook
  d8.promise.setHooks(thrower);
  assertDoesNotThrow(() => {
    Promise.resolve()
      .catch(assertUnreachable);
  });
  %PerformMicrotaskCheckpoint();
  d8.promise.setHooks();

  // Before hook
  d8.promise.setHooks(undefined, thrower);
  assertDoesNotThrow(() => {
    Promise.resolve()
      .then(() => {})
      .catch(assertUnreachable);
  });
  %PerformMicrotaskCheckpoint();
  d8.promise.setHooks();

  // After hook
  d8.promise.setHooks(undefined, undefined, thrower);
  assertDoesNotThrow(() => {
    Promise.resolve()
      .then(() => {})
      .catch(assertUnreachable);
  });
  %PerformMicrotaskCheckpoint();
  d8.promise.setHooks();

  // Resolve hook
  d8.promise.setHooks(undefined, undefined, undefined, thrower);
  assertDoesNotThrow(() => {
    Promise.resolve()
      .catch(assertUnreachable);
  });
  %PerformMicrotaskCheckpoint();
  d8.promise.setHooks();

  // Resolve hook for a reject
  d8.promise.setHooks(undefined, undefined, undefined, thrower);
  assertDoesNotThrow(() => {
    Promise.reject()
      .then(assertUnreachable)
      .catch();
  });
  %PerformMicrotaskCheckpoint();
  d8.promise.setHooks();
}

// For now, expect the optimizer to bail out on async functions
// when context promise hooks are attached.
function optimizerBailout(test, verify) {
  // Warm up test method
  %PrepareFunctionForOptimization(test);
  assertUnoptimized(test);
  test();
  test();
  test();
  %PerformMicrotaskCheckpoint();

  // Prove transition to optimized code when no hooks are present
  assertUnoptimized(test);
  %OptimizeFunctionOnNextCall(test);
  test();
  assertOptimized(test);
  %PerformMicrotaskCheckpoint();

  // Verify that attaching hooks deopts the async function
  d8.promise.setHooks(initHook, beforeHook, afterHook, resolveHook);
  // assertUnoptimized(test);

  // Verify log structure of deoptimized call
  %PrepareFunctionForOptimization(test);
  test();
  %PerformMicrotaskCheckpoint();

  verify();

  // Optimize and verify log structure again
  %OptimizeFunctionOnNextCall(test);
  test();
  assertOptimized(test);
  %PerformMicrotaskCheckpoint();

  verify();

  d8.promise.setHooks();
}

function doTest () {
  optimizerBailout(async () => {
    await Promise.resolve();
  }, () => {
    assertNextEvent('init', [ 1 ]);
    assertNextEvent('init', [ 2 ]);
    assertNextEvent('resolve', [ 2 ]);
    assertNextEvent('init', [ 3, 2 ]);
    assertNextEvent('before', [ 3 ]);
    assertNextEvent('resolve', [ 1 ]);
    assertNextEvent('resolve', [ 3 ]);
    assertNextEvent('after', [ 3 ]);
    assertEmptyLog();
  });
  optimizerBailout(async () => {
    await Promise.reject();
  }, () => {
    assertNextEvent('init', [ 1 ]);
    assertNextEvent('init', [ 2 ]);
    assertNextEvent('resolve', [ 2 ]);
    assertNextEvent('init', [ 3, 2 ]);
    assertNextEvent('before', [ 3 ]);
    assertNextEvent('resolve', [ 1 ]);
    assertNextEvent('resolve', [ 3 ]);
    assertNextEvent('after', [ 3 ]);
    assertEmptyLog();
  });
  optimizerBailout(async () => {
    await { then (cb) { cb() } };
  }, () => {
    assertNextEvent('init', [ 1 ]);
    assertNextEvent('init', [ 2, 1 ]);
    assertNextEvent('init', [ 3, 2 ]);
    assertNextEvent('before', [ 2 ]);
    assertNextEvent('resolve', [ 2 ]);
    assertNextEvent('after', [ 2 ]);
    assertNextEvent('before', [ 3 ]);
    assertNextEvent('resolve', [ 1 ]);
    assertNextEvent('resolve', [ 3 ]);
    assertNextEvent('after', [ 3 ]);
    assertEmptyLog();
  });
  optimizerBailout(async () => {
    await { then (_, cb) { cb() } };
  }, () => {
    assertNextEvent('init', [ 1 ]);
    assertNextEvent('init', [ 2, 1 ]);
    assertNextEvent('init', [ 3, 2 ]);
    assertNextEvent('before', [ 2 ]);
    assertNextEvent('resolve', [ 2 ]);
    assertNextEvent('after', [ 2 ]);
    assertNextEvent('before', [ 3 ]);
    assertNextEvent('resolve', [ 1 ]);
    assertNextEvent('resolve', [ 3 ]);
    assertNextEvent('after', [ 3 ]);
    assertEmptyLog();
  });
  basicTest();
  exceptions();

  (function regress1126309() {
    function __f_16(test) {
      test();
      d8.promise.setHooks(undefined, () => {});
      %PerformMicrotaskCheckpoint();
      d8.promise.setHooks();
    }
    __f_16(async () => { await Promise.resolve()});
  })();

  (function boundFunction() {
    function hook() {};
    const bound = hook.bind(this);
    d8.promise.setHooks(bound, bound, bound, bound);
    Promise.resolve();
    Promise.reject();
    %PerformMicrotaskCheckpoint();
    d8.promise.setHooks();
  })();


  (function promiseAll() {
    let initCount = 0;
    d8.promise.setHooks(() => { initCount++});
    Promise.all([Promise.resolve(1)]);
    %PerformMicrotaskCheckpoint();
    assertEquals(initCount, 3);

    d8.promise.setHooks();
  })();

  (function overflow(){
    d8.promise.setHooks(() => { new Promise(()=>{}) });
    // Trigger overflow from JS code:
    Promise.all([Promise.resolve(1)]);
    %PerformMicrotaskCheckpoint();
    d8.promise.setHooks();
  });

}

if (has_promise_hooks) {
  doTest();
  d8.debugger.enable();
  doTest();
}
                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/promise-perform-all-resolve-lookup.js                              0000664 0000000 0000000 00000001176 14746647661 0025740 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Flags: --allow-natives-syntax --ignore-unhandled-promises

let count = 0;
class MyPromise extends Promise {
  static get resolve() {
    count++;
    return super.resolve;
  }
}

MyPromise.all([1, 2, 3, 4, 5]);
assertEquals(1, count);
%PerformMicrotaskCheckpoint();
assertEquals(1, count);

count = 0;
MyPromise.all([
  Promise.resolve(1),
  Promise.resolve(2),
  Promise.reject(3)
]);
assertEquals(1, count);
%PerformMicrotaskCheckpoint();
assertEquals(1, count);
                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/promise-perform-all-settled-resolve-lookup.js                      0000664 0000000 0000000 00000001160 14746647661 0027373 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Flags: --allow-natives-syntax

let count = 0;
class MyPromise extends Promise {
  static get resolve() {
    count++;
    return super.resolve;
  }
}

MyPromise.allSettled([1, 2, 3, 4, 5]);
assertEquals(1, count);
%PerformMicrotaskCheckpoint();
assertEquals(1, count);

count = 0;
MyPromise.allSettled([
  Promise.resolve(1),
  Promise.resolve(2),
  Promise.reject(3)
]);
assertEquals(1, count);
%PerformMicrotaskCheckpoint();
assertEquals(1, count);
                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/promise-perfrom-race-resolve-lookup.js                             0000664 0000000 0000000 00000001144 14746647661 0026075 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Flags: --allow-natives-syntax

let count = 0;
class MyPromise extends Promise {
  static get resolve() {
    count++;
    return super.resolve;
  }
}

MyPromise.race([1, 2, 3, 4, 5]);
assertEquals(1, count);
%PerformMicrotaskCheckpoint();
assertEquals(1, count);

count = 0;
MyPromise.race([
  Promise.resolve(1),
  Promise.resolve(2),
  Promise.reject(3)
]);
assertEquals(1, count);
%PerformMicrotaskCheckpoint();
assertEquals(1, count);
                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/property-load-across-eval.js                                       0000664 0000000 0000000 00000007070 14746647661 0024075 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Tests loading of properties across eval calls.

var x = 1;
function global_function() { return 'global'; }

// Test loading across an eval call that does not shadow variables.
function testNoShadowing() {
  var y = 2;
  function local_function() { return 'local'; }
  function f() {
    eval('1');
    assertEquals(1, x);
    try { typeof(asdf); } catch(e) { assertUnreachable(); }
    assertEquals(2, y);
    assertEquals('global', global_function());
    assertEquals('local', local_function());
    function g() {
      assertEquals(1, x);
      try { typeof(asdf); } catch(e) { assertUnreachable(); }
      assertEquals(2, y);
      assertEquals('global', global_function());
      assertEquals('local', local_function());
    }
    g();
  }
  f();
}

testNoShadowing();

// Test loading across eval calls that do not shadow variables.
function testNoShadowing2() {
  var y = 2;
  function local_function() { return 'local'; }
  eval('1');
  function f() {
    eval('1');
    assertEquals(1, x);
    assertEquals(2, y);
    assertEquals('global', global_function());
    assertEquals('local', local_function());
    function g() {
      assertEquals(1, x);
      assertEquals(2, y);
      assertEquals('global', global_function());
      assertEquals('local', local_function());
    }
    g();
  }
  f();
}

testNoShadowing2();

// Test loading across an eval call that shadows variables.
function testShadowing() {
  var y = 2;
  function local_function() { return 'local'; }
  function f() {
    eval('var x = 3; var y = 4;');
    assertEquals(3, x);
    assertEquals(4, y);
    eval('function local_function() { return "new_local"; }');
    eval('function global_function() { return "new_nonglobal"; }');
    assertEquals('new_nonglobal', global_function());
    assertEquals('new_local', local_function());
    function g() {
      assertEquals(3, x);
      assertEquals(4, y);
      assertEquals('new_nonglobal', global_function());
      assertEquals('new_local', local_function());
    }
    g();
  }
  f();
}

testShadowing();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/property-name-eval-arguments.js                                    0000664 0000000 0000000 00000001654 14746647661 0024613 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


(function TestSloppyMode() {
  var e = 1, a = 2;
  var o = {
    get eval() {
      return e;
    },
    set eval(v) {
      e = v;
    },
    get arguments() {
      return a;
    },
    set arguments(v) {
      a = v;
    },
  };

  assertEquals(1, o.eval);
  o.eval = 3;
  assertEquals(3, e);

  assertEquals(2, o.arguments);
  o.arguments = 4;
  assertEquals(4, a);
})();


(function TestStrictMode() {
  'use strict';

  var e = 1, a = 2;
  var o = {
    get eval() {
      return e;
    },
    set eval(v) {
      e = v;
    },
    get arguments() {
      return a;
    },
    set arguments(v) {
      a = v;
    },
  };

  assertEquals(1, o.eval);
  o.eval = 3;
  assertEquals(3, e);

  assertEquals(2, o.arguments);
  o.arguments = 4;
  assertEquals(4, a);
})();
                                                                                    node-23.7.0/deps/v8/test/mjsunit/property-object-key.js                                             0000664 0000000 0000000 00000003414 14746647661 0022773 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

var key = { toString: function() { return 'baz'; } }
var object = { baz: 42 };

assertEquals(42, object[key]);
object[key] = 87;
assertEquals(87, object[key]);
object[key]++;
assertEquals(88, object[key]);
                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/test/mjsunit/protector-cell/                                                    0000775 0000000 0000000 00000000000 14746647661 0021453 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/protector-cell/array-constructor-2.js                              0000664 0000000 0000000 00000001104 14746647661 0025645 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty([], "constructor", { value: {} });
assertFalse(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/protector-cell/array-constructor.js                                0000664 0000000 0000000 00000001121 14746647661 0025505 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty(Array.prototype, "constructor", { value: {} });
assertFalse(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/protector-cell/array-iterator-2.js                                 0000664 0000000 0000000 00000001070 14746647661 0025113 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
Object.defineProperty([], Symbol.iterator, { value: {} });
assertTrue(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertFalse(%ArrayIteratorProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/protector-cell/array-iterator.js                                   0000664 0000000 0000000 00000001105 14746647661 0024753 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
Object.defineProperty(Array.prototype, Symbol.iterator, { value: {} });
assertTrue(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertFalse(%ArrayIteratorProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/protector-cell/array-next-1.js                                     0000664 0000000 0000000 00000001066 14746647661 0024244 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
Object.defineProperty([].values(), "next", { value: {}})
assertTrue(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertFalse(%ArrayIteratorProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/protector-cell/array-next-2.js                                     0000664 0000000 0000000 00000001204 14746647661 0024237 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
const arrayIteratorPrototype = Object.getPrototypeOf([].values());
Object.defineProperty(arrayIteratorPrototype, "next", { value: {}})
assertTrue(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertFalse(%ArrayIteratorProtector());
                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/protector-cell/bigint64Array-species.js                            0000664 0000000 0000000 00000000643 14746647661 0026072 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%TypedArraySpeciesProtector());
class MyBigInt64Array extends BigInt64Array { }
Object.defineProperty(BigInt64Array, Symbol.species, { value: MyBigInt64Array });
assertFalse(%TypedArraySpeciesProtector());
                                                                                             node-23.7.0/deps/v8/test/mjsunit/protector-cell/biguint64Array-species.js                           0000664 0000000 0000000 00000000647 14746647661 0026263 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%TypedArraySpeciesProtector());
class MyBigUint64Array extends BigUint64Array { }
Object.defineProperty(BigUint64Array, Symbol.species, { value: MyBigUint64Array });
assertFalse(%TypedArraySpeciesProtector());
                                                                                         node-23.7.0/deps/v8/test/mjsunit/protector-cell/concat-spreadable.js.js                             0000664 0000000 0000000 00000000556 14746647661 0026001 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%IsConcatSpreadableProtector());
Object.defineProperty(Array, Symbol.isConcatSpreadable, { value: false });
assertFalse(%IsConcatSpreadableProtector());
                                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/protector-cell/float32Array-species.js                             0000664 0000000 0000000 00000000637 14746647661 0025721 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%TypedArraySpeciesProtector());
class MyFloat32Array extends Float32Array { }
Object.defineProperty(Float32Array, Symbol.species, { value: MyFloat32Array });
assertFalse(%TypedArraySpeciesProtector());
                                                                                                 node-23.7.0/deps/v8/test/mjsunit/protector-cell/float64Array-species.js                             0000664 0000000 0000000 00000000637 14746647661 0025726 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%TypedArraySpeciesProtector());
class MyFloat64Array extends Float64Array { }
Object.defineProperty(Float64Array, Symbol.species, { value: MyFloat64Array });
assertFalse(%TypedArraySpeciesProtector());
                                                                                                 node-23.7.0/deps/v8/test/mjsunit/protector-cell/int16Array-species.js                               0000664 0000000 0000000 00000000627 14746647661 0025407 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%TypedArraySpeciesProtector());
class MyInt16Array extends Int16Array { }
Object.defineProperty(Int16Array, Symbol.species, { value: MyInt16Array });
assertFalse(%TypedArraySpeciesProtector());
                                                                                                         node-23.7.0/deps/v8/test/mjsunit/protector-cell/int32Array-species.js                               0000664 0000000 0000000 00000000627 14746647661 0025405 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%TypedArraySpeciesProtector());
class MyInt32Array extends Int32Array { }
Object.defineProperty(Int32Array, Symbol.species, { value: MyInt32Array });
assertFalse(%TypedArraySpeciesProtector());
                                                                                                         node-23.7.0/deps/v8/test/mjsunit/protector-cell/int8array-species.js                                0000664 0000000 0000000 00000000623 14746647661 0025364 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%TypedArraySpeciesProtector());
class MyInt8Array extends Int8Array { }
Object.defineProperty(Int8Array, Symbol.species, { value: MyInt8Array });
assertFalse(%TypedArraySpeciesProtector());
                                                                                                             node-23.7.0/deps/v8/test/mjsunit/protector-cell/iterator.js                                         0000664 0000000 0000000 00000001246 14746647661 0023645 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
const iteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))
Object.defineProperty(iteratorPrototype, Symbol.iterator, { value: {} });
assertFalse(%SetIteratorProtector());
assertFalse(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/protector-cell/map-iterator-2.js                                   0000664 0000000 0000000 00000001151 14746647661 0024552 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
const mapIterator = new Map().values();
Object.defineProperty(mapIterator, Symbol.iterator, { value: {} });
assertTrue(%SetIteratorProtector());
assertFalse(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/protector-cell/map-iterator.js                                     0000664 0000000 0000000 00000001212 14746647661 0024411 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
const mapIteratorProto = Object.getPrototypeOf(new Map().values());
Object.defineProperty(mapIteratorProto, Symbol.iterator, { value: {} });
assertTrue(%SetIteratorProtector());
assertFalse(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/protector-cell/map-next-1.js                                       0000664 0000000 0000000 00000001140 14746647661 0023674 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
const mapIterator = new Map().values();
Object.defineProperty(mapIterator, "next", { value: {} });
assertTrue(%SetIteratorProtector());
assertFalse(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/protector-cell/map-next-2.js                                       0000664 0000000 0000000 00000001211 14746647661 0023674 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
const mapIteratorPrototype = Object.getPrototypeOf(new Map().values());
Object.defineProperty(mapIteratorPrototype, "next", { value: {} });
assertTrue(%SetIteratorProtector());
assertFalse(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/protector-cell/promise-constructor-2.js                            0000664 0000000 0000000 00000001123 14746647661 0026206 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty(Promise.prototype, "constructor", { value: {} });
assertTrue(%ArraySpeciesProtector());
assertFalse(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/protector-cell/promise-constructor.js                              0000664 0000000 0000000 00000001130 14746647661 0026045 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty(new Promise(() => { }), "constructor", { value: {} });
assertTrue(%ArraySpeciesProtector());
assertFalse(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/protector-cell/regexp-constructor-2.js                             0000664 0000000 0000000 00000001122 14746647661 0026021 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty(RegExp.prototype, "constructor", { value: {} });
assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertFalse(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/protector-cell/regexp-constructor.js                               0000664 0000000 0000000 00000001120 14746647661 0025660 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty(new RegExp(''), "constructor", { value: {} });
assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertFalse(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/protector-cell/set-iterator-1.js                                   0000664 0000000 0000000 00000001077 14746647661 0024576 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
Object.defineProperty(new Set(), Symbol.iterator, { value: {} });
assertFalse(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/protector-cell/set-iterator-2.js                                   0000664 0000000 0000000 00000001103 14746647661 0024565 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
Object.defineProperty(Set.prototype, Symbol.iterator, { value: {} });
assertFalse(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/protector-cell/set-iterator-3.js                                   0000664 0000000 0000000 00000001110 14746647661 0024564 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
Object.defineProperty(new Set().values(), Symbol.iterator, { value: {} });
assertFalse(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/protector-cell/set-iterator-4.js                                   0000664 0000000 0000000 00000001206 14746647661 0024573 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
const setIteratorPrototype = Object.getPrototypeOf(new Set().values())
Object.defineProperty(new Set(), Symbol.iterator, { value: {} });
assertFalse(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/protector-cell/set-next-1.js                                       0000664 0000000 0000000 00000001140 14746647661 0023712 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
const setIterator = new Set().values();
Object.defineProperty(setIterator, "next", { value: {} });
assertFalse(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/protector-cell/set-next-2.js                                       0000664 0000000 0000000 00000001211 14746647661 0023712 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
const setIteratorPrototype = Object.getPrototypeOf(new Set().values());
Object.defineProperty(setIteratorPrototype, "next", { value: {} });
assertFalse(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/protector-cell/species.js                                          0000664 0000000 0000000 00000001353 14746647661 0023446 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
class MyArray extends Array { }
Object.defineProperty(Array, Symbol.species, { value: MyArray });
assertFalse(%ArraySpeciesProtector());

assertTrue(%PromiseSpeciesProtector());
class MyPromise extends Promise { }
Object.defineProperty(Promise, Symbol.species, { value: MyPromise });
assertFalse(%PromiseSpeciesProtector());

assertTrue(%RegExpSpeciesProtector());
class MyRegExp extends RegExp { }
Object.defineProperty(RegExp, Symbol.species, { value: MyRegExp });
assertFalse(%RegExpSpeciesProtector());
                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-iterator.js                                  0000664 0000000 0000000 00000000544 14746647661 0025151 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringIteratorProtector());
Object.defineProperty(String.prototype, Symbol.iterator, { value: {} });
assertFalse(%StringIteratorProtector());
                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-next-1.js                                    0000664 0000000 0000000 00000001171 14746647661 0024431 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
var str = 'ott';
var iterator = str[Symbol.iterator]();
iterator.__proto__.next = () => ({value : undefined, done : true});
assertTrue(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertFalse(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-next-2.js                                    0000664 0000000 0000000 00000001157 14746647661 0024436 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertTrue(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
var str = 'ott';
var iterator = str[Symbol.iterator]();
iterator.next = () => ({value : undefined, done : true});
assertTrue(%SetIteratorProtector());
assertTrue(%MapIteratorProtector());
assertFalse(%StringIteratorProtector());
assertTrue(%ArrayIteratorProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-to-primitive-0.js                    0000664 0000000 0000000 00000001031 14746647661 0027553 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

// Setting toPrimitive on a string primitive doesn't invalidated the protector
// and also doesn't change the concatenation result.
let x = "old";
x[Symbol.toPrimitive] = () => { return 'new'; }

assertTrue(%StringWrapperToPrimitiveProtector());

assertEquals('got old', 'got ' + x);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-to-primitive-1.js                    0000664 0000000 0000000 00000000671 14746647661 0027565 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

let x = new String('old');

String.prototype[Symbol.toPrimitive] = function() {
  return 'new';
}

assertFalse(%StringWrapperToPrimitiveProtector());

assertEquals('got new', 'got ' + x);
                                                                       node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-to-primitive-10.js                   0000664 0000000 0000000 00000000737 14746647661 0027650 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

class MyString extends String {}

MyString.prototype[Symbol.toPrimitive] = function() {
  return 'new';
}

assertFalse(%StringWrapperToPrimitiveProtector());

let x = new MyString('old');

assertEquals('got new', 'got ' + x);
                                 node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-to-primitive-11.js                   0000664 0000000 0000000 00000000754 14746647661 0027650 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

class MyMiddle extends String {}

class MyString extends MyMiddle {
  [Symbol.toPrimitive]() {
    return 'new';
  }
}

assertFalse(%StringWrapperToPrimitiveProtector());

let x = new MyString('old');

assertEquals('got new', 'got ' + x);
                    node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-to-primitive-12.js                   0000664 0000000 0000000 00000001003 14746647661 0027635 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

class MyMiddle extends String {}

class MyString extends MyMiddle {}

MyString.prototype[Symbol.toPrimitive] = function() {
  return 'new';
}

assertFalse(%StringWrapperToPrimitiveProtector());

let x = new MyString('old');

assertEquals('got new', 'got ' + x);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-to-primitive-13.js                   0000664 0000000 0000000 00000000772 14746647661 0027652 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

function MyString() {}
MyString.prototype[Symbol.toPrimitive] = function() {
  return 'new';
}
MyString.__proto__ = String.prototype;

assertFalse(%StringWrapperToPrimitiveProtector());

let x = new MyString('old');
assertEquals('got new', 'got ' + x);
      node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-to-primitive-14.js                   0000664 0000000 0000000 00000000735 14746647661 0027652 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

class MyString {
 [Symbol.toPrimitive]() {
   return 'new';
  }
}
MyString.__proto__ = String.prototype;

assertFalse(%StringWrapperToPrimitiveProtector());

let x = new MyString('old');
assertEquals('got new', 'got ' + x);
                                   node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-to-primitive-15.js                   0000664 0000000 0000000 00000001072 14746647661 0027646 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

function MyString() {}
MyString.prototype[Symbol.toPrimitive] = function() {
  return 'new';
}
function MyMiddle() {}
MyString.__proto__ = MyMiddle.prototype;
MyMiddle.__proto__ = String.prototype;

assertFalse(%StringWrapperToPrimitiveProtector());

let x = new MyString('old');
assertEquals('got new', 'got ' + x);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-to-primitive-16.js                   0000664 0000000 0000000 00000001001 14746647661 0027637 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

class MyMiddle {}

class MyString extends MyMiddle {
 [Symbol.toPrimitive]() {
   return 'new';
  }
}
MyMiddle.__proto__ = String.prototype;

assertFalse(%StringWrapperToPrimitiveProtector());

let x = new MyString('old');
assertEquals('got new', 'got ' + x);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-to-primitive-17.js                   0000664 0000000 0000000 00000001265 14746647661 0027654 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

class MyNotString {
 [Symbol.toPrimitive]() {
   return 'new';
  }
}

let x = new MyNotString();
assertEquals('got new', 'got ' + x);

// Setting the toPrimitive symbol in a class unrelated to string wrappers won't
// invalidate the protector.
assertTrue(%StringWrapperToPrimitiveProtector());

// Also creating normal string wrappers won't invalidate the protector.
new String("nothing");
assertTrue(%StringWrapperToPrimitiveProtector());
                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-to-primitive-18.js                   0000664 0000000 0000000 00000001023 14746647661 0027645 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

class MyNotString {
 [Symbol.toPrimitive]() {
   return 'new';
  }
}

let x = Reflect.construct(String, ["old"], MyNotString);

// The protector is invalidated when we create the instance.
assertFalse(%StringWrapperToPrimitiveProtector());

assertEquals('got new', 'got ' + x);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-to-primitive-19.js                   0000664 0000000 0000000 00000001422 14746647661 0027651 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

class MyNotString {
 [Symbol.toPrimitive]() {
   return 'new';
  }
}

let x1 = Reflect.construct(String, ["old"]);

// The protector is not invalidated when calling Reflect.construct without a
// separate new.target.
assertTrue(%StringWrapperToPrimitiveProtector());

assertEquals('got old', 'got ' + x1);

let x2 = Reflect.construct(MyNotString, ["old"], String);

// The protector is not invalidated when not constructing string wrappers.
assertTrue(%StringWrapperToPrimitiveProtector());

assertThrows(() => { 'throws ' + x2; });
                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-to-primitive-2.js                    0000664 0000000 0000000 00000000643 14746647661 0027565 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

let x = new String('old');

x[Symbol.toPrimitive] = () => { return 'new' };

assertFalse(%StringWrapperToPrimitiveProtector());

assertEquals('got new', 'got ' + x);
                                                                                             node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-to-primitive-20.js                   0000664 0000000 0000000 00000001365 14746647661 0027647 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --sparkplug --no-always-sparkplug

assertTrue(%StringWrapperToPrimitiveProtector());

function createStringWrapper(newTarget) {
  return Reflect.construct(String, ["content"], newTarget);
}

%PrepareFunctionForOptimization(createStringWrapper);
%CompileBaseline(createStringWrapper);

class X {
  [Symbol.toPrimitive]() {
    return 'new';
  }
}
let x = createStringWrapper(X);

// The protector is also invalidated when we call Reflect.construct from baseline code.
assertFalse(%StringWrapperToPrimitiveProtector());

assertEquals('got new', 'got ' + x);
                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-to-primitive-21.js                   0000664 0000000 0000000 00000001464 14746647661 0027650 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --maglev

assertTrue(%StringWrapperToPrimitiveProtector());

function createStringWrapper(newTarget) {
  return Reflect.construct(String, ["content"], newTarget);
}

%PrepareFunctionForOptimization(createStringWrapper);
createStringWrapper(String);
%OptimizeMaglevOnNextCall(createStringWrapper);

class X {
  [Symbol.toPrimitive]() {
    return 'new';
  }
}

assertTrue(%StringWrapperToPrimitiveProtector());

let x = createStringWrapper(X);

// The protector is also invalidated when we call Reflect.construct from Maglev code.
assertFalse(%StringWrapperToPrimitiveProtector());

assertEquals('got new', 'got ' + x);
                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-to-primitive-22.js                   0000664 0000000 0000000 00000001520 14746647661 0027642 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan

assertTrue(%StringWrapperToPrimitiveProtector());

function createStringWrapper(newTarget) {
  return Reflect.construct(String, ["content"], newTarget);
}

%PrepareFunctionForOptimization(createStringWrapper);
createStringWrapper(String);
%OptimizeFunctionOnNextCall(createStringWrapper);

class X {
  [Symbol.toPrimitive]() {
    return 'new';
  }
}

assertTrue(%StringWrapperToPrimitiveProtector());

let x = createStringWrapper(X);

// The protector is also invalidated when we call Reflect.construct from optimized code.
assertFalse(%StringWrapperToPrimitiveProtector());

assertEquals('got new', 'got ' + x);
                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-to-primitive-3.js                    0000664 0000000 0000000 00000000747 14746647661 0027573 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

let x = new String('old');

Object.defineProperty(String.prototype, Symbol.toPrimitive,
                      {value: () => { return 'new' }});

assertFalse(%StringWrapperToPrimitiveProtector());

assertEquals('got new', 'got ' + x);
                         node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-to-primitive-4.js                    0000664 0000000 0000000 00000000730 14746647661 0027564 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

let x = new String('old');

Object.defineProperty(x, Symbol.toPrimitive,
                      {value: () => { return 'new' }});

assertFalse(%StringWrapperToPrimitiveProtector());

assertEquals('got new', 'got ' + x);
                                        node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-to-primitive-5.js                    0000664 0000000 0000000 00000000670 14746647661 0027570 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

let x = new String('old');

x.__proto__ = {
  [Symbol.toPrimitive]() {
    return 'new';
  },
};

assertFalse(%StringWrapperToPrimitiveProtector());

assertEquals('got new', 'got ' + x);
                                                                        node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-to-primitive-6.js                    0000664 0000000 0000000 00000000671 14746647661 0027572 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

let x = new String('old');

Object.prototype[Symbol.toPrimitive] = function() {
  return 'new';
}

assertFalse(%StringWrapperToPrimitiveProtector());

assertEquals('got new', 'got ' + x);
                                                                       node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-to-primitive-7.js                    0000664 0000000 0000000 00000000747 14746647661 0027577 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

let x = new String('old');

Object.defineProperty(Object.prototype, Symbol.toPrimitive,
                      {value: () => { return 'new' }});

assertFalse(%StringWrapperToPrimitiveProtector());

assertEquals('got new', 'got ' + x);
                         node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-to-primitive-8.js                    0000664 0000000 0000000 00000000707 14746647661 0027574 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

let x = new String('old');

String.prototype.__proto__ = {
  [Symbol.toPrimitive]() {
    return 'new';
  },
};

assertFalse(%StringWrapperToPrimitiveProtector());

assertEquals('got new', 'got ' + x);
                                                         node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-to-primitive-9.js                    0000664 0000000 0000000 00000000710 14746647661 0027567 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

class MyString extends String {
  [Symbol.toPrimitive]() {
    return 'new';
  }
}

assertFalse(%StringWrapperToPrimitiveProtector());

let x = new MyString('old');

assertEquals('got new', 'got ' + x);
                                                        node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-to-string-0.js                       0000664 0000000 0000000 00000001356 14746647661 0027063 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

// Setting toString on a string wrapper doesn't invalidated the protector
// and also doesn't change the concatenation result.
let x = new String('old');
x.toString = () => { return 'new1'; }

// Neither does setting toString on String.prototype.
String.prototype.toString = () => { return 'new2'; }

// Neither does setting toString on Object.prototype.
Object.prototype.toString = () => { return 'new3'; }

assertTrue(%StringWrapperToPrimitiveProtector());

assertEquals('got old', 'got ' + x);
                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-value-of-0.js                        0000664 0000000 0000000 00000001011 14746647661 0026637 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

// Setting valueOf on a string primitive doesn't invalidated the protector
// and also doesn't change the concatenation result.
let x = "old";
x.valueOf = () => { return 'new'; }

assertTrue(%StringWrapperToPrimitiveProtector());

assertEquals('got old', 'got ' + x);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-value-of-1.js                        0000664 0000000 0000000 00000000655 14746647661 0026655 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

let x = new String('old');

String.prototype.valueOf = function() {
  return 'new';
}

assertFalse(%StringWrapperToPrimitiveProtector());

assertEquals('got new', 'got ' + x);
                                                                                   node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-value-of-2.js                        0000664 0000000 0000000 00000000627 14746647661 0026655 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

let x = new String('old');

x.valueOf = () => { return 'new' };

assertFalse(%StringWrapperToPrimitiveProtector());

assertEquals('got new', 'got ' + x);
                                                                                                         node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-value-of-3.js                        0000664 0000000 0000000 00000000736 14746647661 0026657 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

let x = new String('old');

Object.defineProperty(String.prototype, 'valueOf',
                      {value: () => { return 'new' }});

assertFalse(%StringWrapperToPrimitiveProtector());

assertEquals('got new', 'got ' + x);
                                  node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-value-of-4.js                        0000664 0000000 0000000 00000000717 14746647661 0026657 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

let x = new String('old');

Object.defineProperty(x, 'valueOf',
                      {value: () => { return 'new' }});

assertFalse(%StringWrapperToPrimitiveProtector());

assertEquals('got new', 'got ' + x);
                                                 node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-value-of-5.js                        0000664 0000000 0000000 00000000652 14746647661 0026656 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

let x = new String('old');

x.__proto__ = {
  valueOf() {
    return 'new';
  }
};

assertFalse(%StringWrapperToPrimitiveProtector());

assertEquals('got new', 'got ' + x);
                                                                                      node-23.7.0/deps/v8/test/mjsunit/protector-cell/string-wrapper-value-of-6.js                        0000664 0000000 0000000 00000001003 14746647661 0026646 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%StringWrapperToPrimitiveProtector());

let x = new String('old');

delete String.prototype.valueOf;

assertFalse(%StringWrapperToPrimitiveProtector());

// If valueOf doesn't exist, then toString is used.
String.prototype.toString = function() { return 'new'; };

assertEquals('got new', 'got ' + x);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/protector-cell/typedarray-constructor-1.js                         0000664 0000000 0000000 00000001122 14746647661 0026712 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty(new Int8Array(8), "constructor", { value: {} });
assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertFalse(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/protector-cell/typedarray-constructor-10.js                        0000664 0000000 0000000 00000001127 14746647661 0026777 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty(new BigUint64Array(8), "constructor", { value: {} });
assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertFalse(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/protector-cell/typedarray-constructor-2.js                         0000664 0000000 0000000 00000001123 14746647661 0026714 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty(new Uint8Array(8), "constructor", { value: {} });
assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertFalse(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/protector-cell/typedarray-constructor-3.js                         0000664 0000000 0000000 00000001123 14746647661 0026715 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty(new Int16Array(8), "constructor", { value: {} });
assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertFalse(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/protector-cell/typedarray-constructor-4.js                         0000664 0000000 0000000 00000001124 14746647661 0026717 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty(new Uint16Array(8), "constructor", { value: {} });
assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertFalse(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/protector-cell/typedarray-constructor-5.js                         0000664 0000000 0000000 00000001123 14746647661 0026717 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty(new Int32Array(8), "constructor", { value: {} });
assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertFalse(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/protector-cell/typedarray-constructor-6.js                         0000664 0000000 0000000 00000001124 14746647661 0026721 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty(new Uint32Array(8), "constructor", { value: {} });
assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertFalse(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/protector-cell/typedarray-constructor-7.js                         0000664 0000000 0000000 00000001125 14746647661 0026723 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty(new Float32Array(8), "constructor", { value: {} });
assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertFalse(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/protector-cell/typedarray-constructor-8.js                         0000664 0000000 0000000 00000001125 14746647661 0026724 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty(new Float64Array(8), "constructor", { value: {} });
assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertFalse(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/protector-cell/typedarray-constructor-9.js                         0000664 0000000 0000000 00000001126 14746647661 0026726 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty(new BigInt64Array(8), "constructor", { value: {} });
assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertFalse(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/protector-cell/typedarray-prototype-constructor-1.js               0000664 0000000 0000000 00000001125 14746647661 0030760 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty(Int8Array.prototype, "constructor", { value: {} });
assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertFalse(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/protector-cell/typedarray-prototype-constructor-10.js              0000664 0000000 0000000 00000001132 14746647661 0031036 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty(BigUint64Array.prototype, "constructor", { value: {} });
assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertFalse(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/protector-cell/typedarray-prototype-constructor-2.js               0000664 0000000 0000000 00000001126 14746647661 0030762 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty(Uint8Array.prototype, "constructor", { value: {} });
assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertFalse(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/protector-cell/typedarray-prototype-constructor-3.js               0000664 0000000 0000000 00000001126 14746647661 0030763 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty(Int16Array.prototype, "constructor", { value: {} });
assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertFalse(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/protector-cell/typedarray-prototype-constructor-4.js               0000664 0000000 0000000 00000001127 14746647661 0030765 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty(Uint16Array.prototype, "constructor", { value: {} });
assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertFalse(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/protector-cell/typedarray-prototype-constructor-5.js               0000664 0000000 0000000 00000001126 14746647661 0030765 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty(Int32Array.prototype, "constructor", { value: {} });
assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertFalse(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/protector-cell/typedarray-prototype-constructor-6.js               0000664 0000000 0000000 00000001127 14746647661 0030767 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty(Uint32Array.prototype, "constructor", { value: {} });
assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertFalse(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/protector-cell/typedarray-prototype-constructor-7.js               0000664 0000000 0000000 00000001130 14746647661 0030762 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty(Float32Array.prototype, "constructor", { value: {} });
assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertFalse(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/protector-cell/typedarray-prototype-constructor-8.js               0000664 0000000 0000000 00000001130 14746647661 0030763 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty(Float64Array.prototype, "constructor", { value: {} });
assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertFalse(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/protector-cell/typedarray-prototype-constructor-9.js               0000664 0000000 0000000 00000001131 14746647661 0030765 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertTrue(%TypedArraySpeciesProtector());
Object.defineProperty(BigInt64Array.prototype, "constructor", { value: {} });
assertTrue(%ArraySpeciesProtector());
assertTrue(%PromiseSpeciesProtector());
assertTrue(%RegExpSpeciesProtector());
assertFalse(%TypedArraySpeciesProtector());
                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/protector-cell/uint16Array-species.js                              0000664 0000000 0000000 00000000633 14746647661 0025571 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%TypedArraySpeciesProtector());
class MyUint16Array extends Uint16Array { }
Object.defineProperty(Uint16Array, Symbol.species, { value: MyUint16Array });
assertFalse(%TypedArraySpeciesProtector());
                                                                                                     node-23.7.0/deps/v8/test/mjsunit/protector-cell/uint32Array-species.js                              0000664 0000000 0000000 00000000633 14746647661 0025567 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%TypedArraySpeciesProtector());
class MyUint32Array extends Uint32Array { }
Object.defineProperty(Uint32Array, Symbol.species, { value: MyUint32Array });
assertFalse(%TypedArraySpeciesProtector());
                                                                                                     node-23.7.0/deps/v8/test/mjsunit/protector-cell/uint8Array-species.js                               0000664 0000000 0000000 00000000627 14746647661 0025515 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

assertTrue(%TypedArraySpeciesProtector());
class MyUint8Array extends Uint8Array { }
Object.defineProperty(Uint8Array, Symbol.species, { value: MyUint8Array });
assertFalse(%TypedArraySpeciesProtector());
                                                                                                         node-23.7.0/deps/v8/test/mjsunit/proto-accessor-not-accessible.js                                   0000664 0000000 0000000 00000003100 14746647661 0024701 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Accessors for __proto__ are defined in Object.prototype (spec:
// https://tc39.es/ecma262/#sec-object.prototype.__proto__ ). If
// Object.prototype is not in the prototype chain of an object, the accessors
// are not accessible. In particular, __proto__ is treated as a normal property
// and the special meaning (that getting __proto__ would return the prototype
// and setting __proto__ would change the prototype) is lost.

function testObjectWithNullProto(object) {
  assertNull(Object.getPrototypeOf(object));

  // The __proto__ getter is not accessible.
  assertEquals(undefined, object.__proto__);

  // The __proto__ setter is not accessible. Setting __proto__ will create a
  // normal property called __proto__ and not change the prototype.
  object.__proto__ = {};
  assertNull(Object.getPrototypeOf(object));

  // Object.setPrototypeOf can still be used for really setting the prototype.
  const proto1 = {};
  Object.setPrototypeOf(object, proto1);

  // Now the accessors are accessible again.
  assertEquals(proto1, object.__proto__);

  const proto2 = {};
  object.__proto__ = proto2;
  assertEquals(proto2, object.__proto__);
}

(function TestObjectCreatedWithObjectCreate() {
  testObjectWithNullProto(Object.create(null));
})();

(function TestProtoSetToNullAfterCreation() {
  let object_with_null_proto = {};
  object_with_null_proto.__proto__ = null;
  testObjectWithNullProto(Object.create(null));
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/proto-accessor.js                                                  0000664 0000000 0000000 00000012470 14746647661 0022022 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Fake Symbol if undefined, allowing test to run in non-Harmony mode as well.
this.Symbol = typeof Symbol != 'undefined' ? Symbol : String;


function TestSetProtoValueCyclic() {
  var objects = [
    Object.prototype, {},
    Array.prototype, [],
    Error.prototype, new TypeError,
    // etc ...
  ];
  for (var i = 0; i < objects.length; i += 2) {
    var object = objects[i];
    var value = objects[i + 1];
    assertThrows(function() {
      object.__proto__ = value;
    }, TypeError);
  }
};
TestSetProtoValueCyclic();


var desc = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__");
var getProto = desc.get;
var setProto = desc.set;

function TestNoPoisonPill() {
  assertEquals("function", typeof desc.get);
  assertEquals("function", typeof desc.set);
  assertDoesNotThrow("desc.get.call({})");
  assertDoesNotThrow("desc.set.call({}, {})");

  var obj = {};
  var obj2 = {};
  desc.set.call(obj, obj2);
  assertEquals(obj.__proto__, obj2);
  assertEquals(desc.get.call(obj), obj2);
}
TestNoPoisonPill();


function TestRedefineObjectPrototypeProtoGetter() {
  Object.defineProperty(Object.prototype, "__proto__", {
    get: function() {
      return 42;
    }
  });
  assertEquals({}.__proto__, 42);
  assertEquals(desc.get.call({}), Object.prototype);

  var desc2 = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__");
  assertEquals(desc2.get.call({}), 42);
  assertEquals(desc2.set.call({}), undefined);

  Object.defineProperty(Object.prototype, "__proto__", {
    set: function(x) {}
  });
  var desc3 = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__");
  assertEquals(desc3.get.call({}), 42);
  assertEquals(desc3.set.call({}), undefined);
}
TestRedefineObjectPrototypeProtoGetter();


function TestRedefineObjectPrototypeProtoSetter() {
  Object.defineProperty(Object.prototype, "__proto__", { set: undefined });
  assertThrows(function() {
    "use strict";
    var o = {};
    var p = {};
    o.__proto__ = p;
  }, TypeError);
}
TestRedefineObjectPrototypeProtoSetter();


function TestGetProtoOfValues() {
  assertEquals(getProto.call(1), Number.prototype);
  assertEquals(getProto.call(true), Boolean.prototype);
  assertEquals(getProto.call(false), Boolean.prototype);
  assertEquals(getProto.call('s'), String.prototype);
  assertEquals(getProto.call(Symbol()), Symbol.prototype);

  assertThrows(function() { getProto.call(null); }, TypeError);
  assertThrows(function() { getProto.call(undefined); }, TypeError);
}
TestGetProtoOfValues();


var values = [1, true, false, 's', Symbol()];


function TestSetProtoOfValues() {
  var proto = {};
  for (var i = 0; i < values.length; i++) {
    assertEquals(setProto.call(values[i], proto), undefined);
  }

  assertThrows(function() { setProto.call(null, proto); }, TypeError);
  assertThrows(function() { setProto.call(undefined, proto); }, TypeError);
}
TestSetProtoOfValues();


function TestSetProtoToValue() {
  var object = {};
  var proto = {};
  setProto.call(object, proto);

  var valuesWithUndefined = values.concat(undefined);

  for (var i = 0; i < valuesWithUndefined.length; i++) {
    assertEquals(setProto.call(object, valuesWithUndefined[i]), undefined);
    assertEquals(getProto.call(object), proto);
  }

  // null is the only valid value that can be used as a [[Prototype]].
  assertEquals(setProto.call(object, null), undefined);
  assertEquals(getProto.call(object), null);
}
TestSetProtoToValue();


function TestDeleteProto() {
  assertTrue(delete Object.prototype.__proto__);
  var o = {};
  var p = {};
  o.__proto__ = p;
  assertEquals(Object.getPrototypeOf(o), Object.prototype);
  var desc4 = Object.getOwnPropertyDescriptor(o, "__proto__");
  assertTrue(desc4.configurable);
  assertTrue(desc4.enumerable);
  assertTrue(desc4.writable);
  assertEquals(desc4.value, p);
}
TestDeleteProto();
                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/proto-elements-add-during-foreach.js                               0000664 0000000 0000000 00000001633 14746647661 0025454 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

(()=>{
  var a = [0,1,2,,,,7];
  var proto = {}
  a.__proto__ = proto;
  var visits = 0;
  Array.prototype.forEach.call(a, (v,i,o) => { ++visits; proto[4] = 4; });
  assertEquals(5, visits);
})();

// We have a fast path for arrays with the initial array prototype.
// If elements are inserted into the initial array prototype as we traverse
// a holey array, we should gracefully exit the fast path.
(()=>{
  let a = [1, 2, 3,,,, 7];
  function poison(v, i) {
    if (i === 2) {
      [].__proto__[4] = 3;
    }
    return v*v;
  }
  a.forEach(poison);
})();

// Same, but for a double array.
(()=>{
  let a = [1, 2.5, 3,,,, 7];
  function poison(v, i) {
    if (i === 2) {
      [].__proto__[4] = 3;
    }
    return v*v;
  }
  a.forEach(poison);
})();
                                                                                                     node-23.7.0/deps/v8/test/mjsunit/proto.js                                                           0000664 0000000 0000000 00000003265 14746647661 0020224 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

var o1 = { x: 12 };

var o2 = { x: 12, y: 13 };
delete o2.x;  // normalize

assertTrue(o1.__proto__ === o2.__proto__);
                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/prototype-arity.js                                                 0000664 0000000 0000000 00000003715 14746647661 0022254 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

const types = [
  [Object, "{}"],
  [String, "\"abc\""],
  [RegExp, "/abc/"],
  [WeakMap, "(new WeakMap())"],
  [WeakSet, "(new WeakSet())"],
  [Map, "(new Map())"],
  [Set, "(new Set())"],
  [Function, "(function f() {return 1})"],
  [Array, "[1,2,3, {}]"],
  [Boolean, "(new Boolean())"],
  [Symbol, "(new Symbol())"],
  [BigInt, "(new BigInt(42))"],
  [Math, "Math"],
  [Date, "(new Date())"],
  [Promise, "(new Promise())"],
  [Reflect, "Reflect"],
  [Proxy, "(new Proxy({}, {}))"],
];

if (typeof Intl == "object") {
  types.push([Intl, "Intl"]);
  types.push([Intl.Collator, "Intl.Collator"]);
  types.push([Intl.ListFormat, "Intl.ListFormat"]);
  types.push([Intl.NumberFormat, "Intl.NumberFormat"]);
  types.push([Intl.PluralRules, "Intl.PluralRules"]);
  types.push([Intl.RelativeTimeFormat, "Intl.RelativeTimeFormat"]);
}

const callTemplate = () => {
  function f() {
    return constr_exp.propCall(args)
  }
  %PrepareFunctionForOptimization(f);
  try { f(); } catch (e) {}
  try { f(); } catch (e) {}
  %OptimizeFunctionOnNextCall(f);
  try { f(); } catch (e) {}
}

const mkCall = (constr_exp, propCall) => {
  const arrowFunction = callTemplate.toString().replace("constr_exp", constr_exp).replace("propCall", propCall).replace("args", "");
  return `(${arrowFunction})();`;
}

for ([type, constr_exp, blocklist] of types) {
  const proto = type.prototype || type;
  for (const f of Object.getOwnPropertyNames(proto)) {
    const d = Object.getOwnPropertyDescriptor(proto, f);
    if (d.get || d.set || (typeof proto[f]) != "function") continue;
    const source = mkCall(constr_exp, f);
    try {
      eval(source);
    } catch (err) {
      // Exceptions are OK.
      console.log(`EXN ${err} for ${type.toString()} ${f}`)
      console.log(source);
      continue;
    }
  }
}
                                                   node-23.7.0/deps/v8/test/mjsunit/prototype-changes.js                                               0000664 0000000 0000000 00000002053 14746647661 0022526 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

function A() {
  this.a = "a";
}
var a = new A();

function B() {
  this.b = "b";
}
B.prototype = a;

function C() {
  this.c = "c";
}
C.prototype = new B();

var c = new C();

function f(expected) {
  var result = c.z;
  assertEquals(expected, result);
};
%PrepareFunctionForOptimization(f);
f(undefined);
f(undefined);
%OptimizeFunctionOnNextCall(f);
f(undefined);
a.z = "z";
f("z");
f("z");

// Test updating .__proto__ pointers.
var p1 = {foo: 1.5};
var p2 = {};
p2.__proto__ = p1;
var p3 = {};
p3.__proto__ = p2;
var o = {};
o.__proto__ = p3;

for (var i = 0; i < 2; i++) o.foo;  // Force registration.

var p1a = {foo: 1.7};
p2.__proto__ = p1a;

function g(o, expected) {
  var result = o.foo;
  assertEquals(expected, result);
}

g(o, 1.7);
g(o, 1.7);
g(o, 1.7);
Object.defineProperty(p1a, 'foo', {
  get: function() {
    return 'foo';
  }
});
g(o, "foo");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/prototype-non-existing.js                                          0000664 0000000 0000000 00000002755 14746647661 0023551 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

// Dictionary object in the prototype chain.
(function() {
  function A() {
    this.z = "a";
  }
  var a = new A();

  function B() {
    this.b = "b";
  }
  B.prototype = a;
  var b = new B();

  // Ensure b stays slow.
  for (var i = 0; i < 1200; i++) {
    b["b"+i] = 0;
  }
  assertFalse(%HasFastProperties(b));

  function C() {
    this.c = "c";
  }
  C.prototype = b;
  var c = new C();

  function f(expected) {
    assertFalse(%HasFastProperties(b));
    var result = c.z;
    assertEquals(expected, result);
  }
  %PrepareFunctionForOptimization(f);
  f("a");
  f("a");
  f("a");
  %OptimizeFunctionOnNextCall(f);
  f("a");

  a.z = "z";
  f("z");
  f("z");
  f("z");

  b.z = "bz";
  f("bz");
  f("bz");
  f("bz");
})();


// Global object in the prototype chain.
(function() {
  var global = this;

  function A() {
    this.z = "a";
  }
  A.prototype = global.__proto__;
  var a = new A();

  global.__proto__ = a;

  function C() {
    this.c = "c";
  }
  C.prototype = global;
  var c = new C();

  function f(expected) {
    var result = c.z;
    assertEquals(expected, result);
  }
  %PrepareFunctionForOptimization(f);
  f("a");
  f("a");
  f("a");
  %OptimizeFunctionOnNextCall(f);
  f("a");

  a.z = "z";
  f("z");
  f("z");
  f("z");

  global.z = "bz";
  f("bz");
  f("bz");
  f("bz");
})();
                   node-23.7.0/deps/v8/test/mjsunit/prototype.js                                                       0000664 0000000 0000000 00000005377 14746647661 0021134 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function A() { }
function B() { }
function C() { }

function NewC() {
  A.prototype = {};
  B.prototype = new A();
  C.prototype = new B();
  var result = new C();
  result.A = A.prototype;
  result.B = B.prototype;
  result.C = C.prototype;
  return result;
}

// Check that we can read properties defined in prototypes.
var c = NewC();
c.A.x = 1;
c.B.y = 2;
c.C.z = 3;
assertEquals(1, c.x);
assertEquals(2, c.y);
assertEquals(3, c.z);

var c = NewC();
c.A.x = 0;
for (var i = 0; i < 2; i++) {
  assertEquals(i, c.x);
  c.B.x = 1;
}


// Regression test:
// Make sure we preserve the prototype of an object in the face of map transitions.

function D() {
  this.d = 1;
}
var p = new Object();
p.y = 1;
new D();

D.prototype = p
assertEquals(1, (new D).y);


// Regression test:
// Make sure that arrays and functions in the prototype chain works;
// check length.
function X() { }
function Y() { }

X.prototype = function(a,b) { };
Y.prototype = [1,2,3];

assertEquals(2, (new X).length);
assertEquals(3, (new Y).length);


// Test setting the length of an object where the prototype is from an array.
var test = new Object;
test.__proto__ = (new Array()).__proto__;
test.length = 14;
assertEquals(14, test.length);
                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/proxy-super-return-define-property-trap.js                         0000664 0000000 0000000 00000001145 14746647661 0026764 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --no-lazy-feedback-allocation
Proxy.prototype = Object.prototype;

let logs = [];

class Z extends Proxy {
  constructor() {
    super({}, {
      set() {
        logs.push("set");
        return true;
      },
      defineProperty() {
        logs.push("defineProperty");
        return true;
      }
    })
  }
  a = 1;
}

new Z();
assertEquals(["defineProperty"], logs);

logs = [];
new Z();
assertEquals(["defineProperty"], logs);
                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/rab-gsab-transfer-to-worker.js                                     0000664 0000000 0000000 00000015605 14746647661 0024311 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

(function TransferArrayBuffer() {
  function workerCode() {
    onmessage = function({data:msg}) {
      const ab = msg.data;
      postMessage(ab.byteLength + ' ' + ab.maxByteLength);
      postMessage(ab.resizable + ' ' + ab.growable);
    }
  }

  const worker = new Worker(workerCode, {type: 'function'});

  const ab = new ArrayBuffer(16);
  worker.postMessage({data: ab}, [ab]);
  assertEquals('16 16', worker.getMessage());
  assertEquals('false undefined', worker.getMessage());

  const rab = new ArrayBuffer(16, {maxByteLength: 1024});
  worker.postMessage({data: rab}, [rab]);
  assertEquals('16 1024', worker.getMessage());
  assertEquals('true undefined', worker.getMessage());

  const sab = new SharedArrayBuffer(16);
  worker.postMessage({data: sab});
  assertEquals('16 16', worker.getMessage());
  assertEquals('undefined false', worker.getMessage());

  const gsab = new SharedArrayBuffer(16, {maxByteLength: 1024});
  worker.postMessage({data: gsab});
  assertEquals('16 1024', worker.getMessage());
  assertEquals('undefined true', worker.getMessage());
})();

(function TransferLengthTrackingRabBackedTypedArray() {
  function workerCode() {
    onmessage = function({data:msg}) {
      postMessage(msg.data.length);
      msg.data.buffer.resize(150);
      postMessage(msg.data.length);
    }
  }

  const worker = new Worker(workerCode, {type: 'function'});
  const rab = new ArrayBuffer(16, {maxByteLength: 1024});
  const ta = new Uint8Array(rab);
  worker.postMessage({data: ta}, [rab]);
  assertEquals(16, worker.getMessage());
  assertEquals(150, worker.getMessage());
})();

(function TransferLengthTrackingGsabBackedTypedArray() {
  function workerCode() {
    onmessage = function({data:msg}) {
      postMessage(msg.data.length);
      msg.data.buffer.grow(150);
      postMessage(msg.data.length);
    }
  }

  const worker = new Worker(workerCode, {type: 'function'});
  const gsab = new SharedArrayBuffer(16, {maxByteLength: 1024});
  const ta = new Uint8Array(gsab);
  worker.postMessage({data: ta});
  assertEquals(16, worker.getMessage());
  assertEquals(150, worker.getMessage());
})();

(function TransferFixedLengthRabBackedTypedArray() {
  function workerCode() {
    onmessage = function({data:msg}) {
      const ta = msg.data;
      postMessage(`${ta.length} ${ta[0]} ${ta[1]} ${ta[2]}`);
      ta.buffer.resize(2);
      postMessage(`${ta.length}`);
    }
  }

  const worker = new Worker(workerCode, {type: 'function'});
  const rab = new ArrayBuffer(16, {maxByteLength: 1024});
  const ta = new Uint8Array(rab, 0, 10);
  ta[0] = 30;
  ta[1] = 11;
  ta[2] = 22;
  worker.postMessage({data: ta}, [rab]);
  assertEquals('10 30 11 22', worker.getMessage());
  assertEquals('0', worker.getMessage());
})();

(function TransferOutOfBoundsFixedLengthTypedArray() {
  function workerCode() {
  }

  const worker = new Worker(workerCode, {type: 'function'});
  const rab = new ArrayBuffer(16, {maxByteLength: 1024});
  const ta = new Uint8Array(rab, 0, 10);
  rab.resize(0);
  assertThrows(() => { worker.postMessage({data: ta}, [rab]) });
})();

(function TransferGsabBackedFixedLengthTypedArray() {
  function workerCode() {
    onmessage = function({data:msg}) {
      const ta = msg.data;
      postMessage(`${ta.length} ${ta[0]} ${ta[1]} ${ta[2]}`);
      ta.buffer.grow(20);
      postMessage(`${ta.length} ${ta[0]} ${ta[1]} ${ta[2]}`);
    }
  }

  const worker = new Worker(workerCode, {type: 'function'});

  const gsab = new SharedArrayBuffer(16, {maxByteLength: 1024});
  const ta = new Uint8Array(gsab, 0, 10);
  ta[0] = 30;
  ta[1] = 11;
  ta[2] = 22;
  worker.postMessage({data: ta});
  assertEquals('10 30 11 22', worker.getMessage());
  assertEquals('10 30 11 22', worker.getMessage());
})();

(function TransferLengthTrackingDataView() {
  function workerCode() {
    onmessage = function({data:msg}) {
      const dv = msg.data;
      postMessage(dv.byteLength);
      dv.buffer.resize(150);
      postMessage(dv.byteLength);
    }
  }

  const worker = new Worker(workerCode, {type: 'function'});
  const rab = new ArrayBuffer(16, {maxByteLength: 1024});
  const dv = new DataView(rab);
  worker.postMessage({data: dv}, [rab]);
  assertEquals(16, worker.getMessage());
  assertEquals(150, worker.getMessage());
})();

(function TransferFixedLengthDataView() {
  function workerCode() {
    onmessage = function({data:msg}) {
      const dv = msg.data;
      postMessage(`${dv.byteLength} ${dv.getUint8(0)} ${dv.getUint8(1)}`);
      dv.buffer.resize(2);
      try {
        dv.byteLength;
      } catch(e) {
        postMessage('byteLength getter threw');
      }
    }
  }

  const worker = new Worker(workerCode, {type: 'function'});
  const rab = new ArrayBuffer(16, {maxByteLength: 1024});
  const ta = new Uint8Array(rab);
  ta[0] = 30;
  ta[1] = 11;
  worker.postMessage({data: new DataView(rab, 0, 10)}, [rab]);
  assertEquals('10 30 11', worker.getMessage());
  assertEquals('byteLength getter threw', worker.getMessage());
})();

(function TransferOutOfBoundsDataView1() {
  function workerCode() {}

  const worker = new Worker(workerCode, {type: 'function'});
  const rab = new ArrayBuffer(16, {maxByteLength: 1024});
  const dv = new Uint8Array(rab, 0, 10);
  rab.resize(0);
  assertThrows(() => { worker.postMessage({data: dv}, [rab]) });
})();

(function TransferOutOfBoundsDataView2() {
  function workerCode() {}

  const worker = new Worker(workerCode, {type: 'function'});
  const rab = new ArrayBuffer(16, {maxByteLength: 1024});
  const dv = new Uint8Array(rab, 2);
  rab.resize(1);
  assertThrows(() => { worker.postMessage({data: dv}, [rab]) });
})();

(function TransferZeroLengthDataView1() {
  function workerCode() {
    onmessage = function({data:msg}) {
      const dv = msg.data;
      postMessage(`${dv.byteLength}`);
    }
  }

  const worker = new Worker(workerCode, {type: 'function'});
  const rab = new ArrayBuffer(16, {maxByteLength: 1024});

  worker.postMessage({data: new DataView(rab, 16)}, [rab]);
  assertEquals('0', worker.getMessage());
})();

(function TransferZeroLengthDataView2() {
  function workerCode() {
    onmessage = function({data:msg}) {
      const dv = msg.data;
      postMessage(`${dv.byteLength}`);
    }
  }

  const worker = new Worker(workerCode, {type: 'function'});
  const rab = new ArrayBuffer(16, {maxByteLength: 1024});

  worker.postMessage({data: new DataView(rab, 16, 0)}, [rab]);
  assertEquals('0', worker.getMessage());
})();

(function TransferZeroLengthDataView3() {
  function workerCode() {
    onmessage = function({data:msg}) {
      const dv = msg.data;
      postMessage(`${dv.byteLength}`);
    }
  }

  const worker = new Worker(workerCode, {type: 'function'});
  const rab = new ArrayBuffer(16, {maxByteLength: 1024});

  worker.postMessage({data: new DataView(rab, 5, 0)}, [rab]);
  assertEquals('0', worker.getMessage());
})();
                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/rab-gsab-valueserializer.js                                        0000664 0000000 0000000 00000001132 14746647661 0023732 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

"use strict";

(function FlagMismatch() {
  // Length tracking TA, buffer not resizable.
  const data1 = new Uint8Array([255, 15, 66, 4, 3, 5, 7, 11, 86, 66, 1, 2, 1]);
  assertThrows(() => { d8.serializer.deserialize(data1.buffer); });

  // RAB backed TA, buffer not resizable.
  const data2 = new Uint8Array([255, 15, 66, 4, 3, 5, 7, 11, 86, 66, 1, 2, 2]);
  assertThrows(() => { d8.serializer.deserialize(data2.buffer); });
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/random-bit-correlations.js                                         0000664 0000000 0000000 00000005621 14746647661 0023615 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Overwrite the random seed provided by the test runner to make this test less
// flaky. Due to flag contradiction checking, this requires
// --allow-overwriting-for-next-flag to avoid an error.
// Flags: --allow-overwriting-for-next-flag --random-seed=20
// Flags: --noalways-turbofan --predictable

(function() {
  var kHistory = 2;
  var kRepeats = 100;
  var history = new Uint32Array(kHistory);

  function random() {
    return (Math.random() * Math.pow(2, 32)) >>> 0;
  }

  function ChiSquared(m, n) {
    var ys_minus_np1 = (m - n / 2.0);
    var chi_squared_1 = ys_minus_np1 * ys_minus_np1 * 2.0 / n;
    var ys_minus_np2 = ((n - m) - n / 2.0);
    var chi_squared_2 = ys_minus_np2 * ys_minus_np2 * 2.0 / n;
    return chi_squared_1 + chi_squared_2;
  }
  for (var predictor_bit = -2; predictor_bit < 32; predictor_bit++) {
    // The predicted bit is one of the bits from the PRNG.
    for (var random_bit = 0; random_bit < 32; random_bit++) {
      for (var ago = 0; ago < kHistory; ago++) {
        // We don't want to check whether each bit predicts itself.
        if (ago == 0 && predictor_bit == random_bit) continue;
        // Enter the new random value into the history
        for (var i = ago; i >= 0; i--) {
          history[i] = random();
        }
        // Find out how many of the bits are the same as the prediction bit.
        var m = 0;
        for (var i = 0; i < kRepeats; i++) {
          for (var j = ago - 1; j >= 0; j--) history[j + 1] = history[j];
          history[0] = random();
          var predicted;
          if (predictor_bit >= 0) {
            predicted = (history[ago] >> predictor_bit) & 1;
          } else {
            predicted = predictor_bit == -2 ? 0 : 1;
          }
          var bit = (history[0] >> random_bit) & 1;
          if (bit == predicted) m++;
        }
        // Chi squared analysis for k = 2 (2, states: same/not-same) and one
        // degree of freedom (k - 1).
        var chi_squared = ChiSquared(m, kRepeats);
        if (chi_squared > 24) {
          var percent = Math.floor(m * 100.0 / kRepeats);
          if (predictor_bit < 0) {
            var bit_value = predictor_bit == -2 ? 0 : 1;
            print(`Bit ${random_bit} is ${bit_value} ${percent}% of the time`);
          } else {
            print(`Bit ${random_bit} is the same as bit ${predictor_bit} ` +
              `${ago} ago ${percent}% of the time`);
          }
        }
        // For 1 degree of freedom this corresponds to 1 in a million.  We are
        // running ~8000 tests, so that would be surprising.
        assertTrue(chi_squared <= 24);
        // If the predictor bit is a fixed 0 or 1 then it makes no sense to
        // repeat the test with a different age.
        if (predictor_bit < 0) break;
      }
    }
  }
})();
                                                                                                               node-23.7.0/deps/v8/test/mjsunit/readonly-accessor.js                                               0000664 0000000 0000000 00000000352 14746647661 0022470 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var foo = {};
foo.__proto__ = new String("bar");
foo.length = 20;
                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/readonly.js                                                        0000664 0000000 0000000 00000016253 14746647661 0020677 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2011 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax
// This test manually triggers optimization, no need for stress modes.
// Flags: --noalways-turbofan

// Different ways to create an object.

function CreateFromLiteral() {
  return {};
}

function CreateFromObject() {
  return new Object();
}

function CreateDefault() {
  return Object.create(Object.prototype);
}

function CreateFromConstructor(proto) {
  function C() {}
  new C().b = 9;  // Make sure that we can have an in-object property.
  C.prototype = proto;
  return function() {
    return new C();
  };
}

function CreateFromApi(proto) {
  return function() {
    return Object.create(proto);
  };
}

function CreateWithProperty(proto) {
  function C() {
    this.a = -100;
  }
  C.prototype = proto;
  return function() {
    return new C();
  };
}

var bases = [CreateFromLiteral, CreateFromObject, CreateDefault];
var inherits = [CreateFromConstructor, CreateFromApi, CreateWithProperty];
var constructs = [CreateFromConstructor, CreateFromApi];

function TestAllCreates(f) {
  // The depth of the prototype chain up the.
  for (var depth = 0; depth < 3; ++depth) {
    // Introduce readonly-ness this far up the chain.
    for (var up = 0; up <= depth; ++up) {
      // Try different construction methods.
      for (var k = 0; k < constructs.length; ++k) {
        // Construct a fresh prototype chain from above functions.
        for (var i = 0; i < bases.length; ++i) {
          var p = bases[i]();
          // There may be a preexisting property under the insertion point...
          for (var j = 0; j < depth - up; ++j) {
            p = inherits[Math.floor(inherits.length * Math.random())](p)();
          }
          // ...but not above it.
          for (var j = 0; j < up; ++j) {
            p = constructs[Math.floor(constructs.length * Math.random())](p)();
          }
          // Create a fresh constructor.
          var c = constructs[k](p);
          f(function() {
            var o = c();
            o.up = o;
            for (var j = 0; j < up; ++j) o.up = Object.getPrototypeOf(o.up);
            return o;
          });
        }
      }
    }
  }
}


// Different ways to make a property read-only.

function ReadonlyByNonwritableDataProperty(o, name) {
  Object.defineProperty(o, name, {value: -41, writable: false});
}

function ReadonlyByAccessorPropertyWithoutSetter(o, name) {
  Object.defineProperty(o, name, {
    get: function() {
      return -42;
    }
  });
}

function ReadonlyByGetter(o, name) {
  o.__defineGetter__('a', function() {
    return -43;
  });
}

function ReadonlyByFreeze(o, name) {
  o[name] = -44;
  Object.freeze(o);
}

function ReadonlyByProto(o, name) {
  var p = Object.create(o.__proto__);
  Object.defineProperty(p, name, {value: -45, writable: false});
  o.__proto__ = p;
}

// TODO(neis,cbruni): Enable once the necessary traps work again.
// Allow Proxy to be undefined, so test can run in non-Harmony mode as well.
var global = this;

function ReadonlyByProxy(o, name) {
  if (!global.Proxy) return ReadonlyByFreeze(o, name);  // Dummy.
  var p = new global.Proxy({}, {
    getPropertyDescriptor: function() {
      return {value: -46, writable: false, configurable: true};
    }
  });

  o.__proto__ = p;
}

var readonlys = [
  ReadonlyByNonwritableDataProperty, ReadonlyByAccessorPropertyWithoutSetter,
  ReadonlyByGetter, ReadonlyByFreeze, ReadonlyByProto  // ReadonlyByProxy
];

function TestAllReadonlys(f) {
  // Provide various methods to making a property read-only.
  for (var i = 0; i < readonlys.length; ++i) {
    print('  readonly =', i);
    f(readonlys[i]);
  }
}


// Different use scenarios.

function Assign(o, x) {
  o.a = x;
};
%PrepareFunctionForOptimization(Assign);
function AssignStrict(o, x) {
  "use strict";
  o.a = x;
};
%PrepareFunctionForOptimization(AssignStrict);
function TestAllModes(f) {
  for (var strict = 0; strict < 2; ++strict) {
    print(" strict =", strict);
    f(strict);
  }
}

function TestAllScenarios(f) {
  for (var t = 0; t < 100; t = 2 * t + 1) {
    print('t =', t);
    f(function(strict, create, readonly) {
      // Make sure that the assignments are monomorphic.
      %DeoptimizeFunction(Assign);
      %DeoptimizeFunction(AssignStrict);
      %ClearFunctionFeedback(Assign);
      %ClearFunctionFeedback(AssignStrict);
      %PrepareFunctionForOptimization(Assign);
      %PrepareFunctionForOptimization(AssignStrict);
      for (var i = 0; i < t; ++i) {
        var o = create();
        assertFalse("a" in o && !("a" in o.__proto__));
        if (strict === 0)
          Assign(o, i);
        else
          AssignStrict(o, i);
        assertEquals(i, o.a);
      }
      %OptimizeFunctionOnNextCall(Assign);
      %OptimizeFunctionOnNextCall(AssignStrict);
      var o = create();
      assertFalse("a" in o && !("a" in o.__proto__));
      readonly(o.up, "a");
      assertTrue("a" in o);
      if (strict === 0)
        Assign(o, t + 1);
      else

        assertThrows(function() {
          AssignStrict(o, t + 1);
        }, TypeError);
      assertTrue(o.a < 0);
    });
  }
}


// Runner.

TestAllScenarios(function(scenario) {
  TestAllModes(function(strict) {
    TestAllReadonlys(function(readonly) {
      TestAllCreates(function(create) {
        scenario(strict, create, readonly);
      });
    });
  });
});

// Extra test forcing bailout.

function Assign2(o, x) {
  o.a = x;
};
%PrepareFunctionForOptimization(Assign2);
(function() {
var p = CreateFromConstructor(Object.prototype)();
var c = CreateFromConstructor(p);
for (var i = 0; i < 3; ++i) {
  var o = c();
  Assign2(o, i);
  assertEquals(i, o.a);
}
%OptimizeFunctionOnNextCall(Assign2);
ReadonlyByNonwritableDataProperty(p, "a");
var o = c();
Assign2(o, 0);
assertTrue(o.a < 0);
})();
                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/realm-property-access.js                                           0000664 0000000 0000000 00000001243 14746647661 0023274 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var r = Realm.create();
var f = Realm.eval(r, "function f() { return this }; f()");
assertEquals(f, Realm.global(r));

// Cross-origin property access throws
assertThrows(() => f.a, TypeError);
assertThrows(() => { 'use strict'; f.a = 1 }, TypeError);

var r2 = Realm.createAllowCrossRealmAccess();
var f2 = Realm.eval(r2, "function f() { return this }; f()");
assertEquals(f2, Realm.global(r2));

// Same-origin property access doesn't throw
assertEquals(undefined, f2.a);
f2.a = 1;
assertEquals(1, f2.a);
                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/receiver-in-with-calls.js                                          0000664 0000000 0000000 00000004046 14746647661 0023334 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// When invoking functions from within a 'with' statement, we must set
// the receiver to the object where we found the function.

(function () {
  var x = { get_this: function() { return this; } };
  assertTrue(x === x.get_this());
  with (x) assertTrue(x === get_this());
})();


assertTrue({ f: function() {
  function g() { return this; };
  return eval("g")();
} }.f() == this);


assertTrue({ f: function() {
  function g() { return this; };
  return eval("g()");
} }.f() == this);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/recursive-store-opt.js                                             0000664 0000000 0000000 00000003372 14746647661 0023021 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --allow-natives-syntax

function g() {
  this.x = this;
}

function f() {
  return new g();
};
%PrepareFunctionForOptimization(f);
f();
f();
%OptimizeFunctionOnNextCall(f);
f();
                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/regexp-14098.js                                                    0000664 0000000 0000000 00000002044 14746647661 0021030 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --enable-experimental-regexp-engine
// Flags: --no-default-to-experimental-regexp-engine

// An example where the Experimental regexp engine
// used to disagree with the backtracking engine and the specification
// for nullable quantifiers.
// v8:14098
var str = "ab";

// executed by the Experimental engine (l flag)
var exp_repetitions = /(?:a?b??){0,2}/l;
var exp_empty_star = /(?:a?b??)*/l;

// executed by the backtracking engine
var bt_empty_star = /(?:a?b??)*/;

// The engines should both match "ab":
// The first star repetition should match 'a'
// because ignoring 'b' has highest-priority.
// Then the greedy star should be entered again.
// Then the second repetition should match 'b',
// a non-empty repetition of the star.

assertEquals(["ab"], bt_empty_star.exec(str));
assertEquals(['ab'], exp_empty_star.exec(str));
assertEquals(['ab'], exp_repetitions.exec(str));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/regexp-UC16.js                                                     0000664 0000000 0000000 00000005175 14746647661 0021031 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// UC16
// Characters used:
// "\u03a3\u03c2\u03c3\u039b\u03bb" - Sigma, final sigma, sigma, Lambda, lamda
assertEquals("x\u03a3\u03c3x,\u03a3",
              String(/x(.)\1x/i.exec("x\u03a3\u03c3x")), "backref-UC16");
assertFalse(/x(...)\1/i.test("x\u03a3\u03c2\u03c3\u03c2\u03c3"),
            "\\1 ASCII, string short");
assertTrue(/\u03a3((?:))\1\1x/i.test("\u03c2x"), "backref-UC16-empty");
assertTrue(/x(?:...|(...))\1x/i.test("x\u03a3\u03c2\u03c3x"),
           "backref-UC16-uncaptured");
assertTrue(/x(?:...|(...))\1x/i.test("x\u03c2\u03c3\u039b\u03a3\u03c2\u03bbx"),
           "backref-UC16-backtrack");
var longUC16String = "x\u03a3\u03c2\u039b\u03c2\u03c3\u03bb\u03c3\u03a3\u03bb";
assertEquals(longUC16String + "," + longUC16String.substring(1,4),
             String(/x(...)\1\1/i.exec(longUC16String)),
             "backref-UC16-twice");

assertFalse(/\xc1/i.test('fooA'), "quickcheck-uc16-pattern-ascii-subject");
assertFalse(/[\xe9]/.test('i'), "charclass-uc16-pattern-ascii-subject");
assertFalse(/\u5e74|\u6708/.test('t'), "alternation-uc16-pattern-ascii-subject");
                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/regexp-backtrack-limit.js                                          0000664 0000000 0000000 00000002141 14746647661 0023402 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --no-enable-experimental-regexp-engine
// Flags: --no-enable-experimental-regexp-engine-on-excessive-backtracks

const kNoBacktrackLimit = 0;  // To match JSRegExp::kNoBacktrackLimit.
const re0 = %NewRegExpWithBacktrackLimit("(\\d+)+x", "", kNoBacktrackLimit);
const re1 = %NewRegExpWithBacktrackLimit("(\\d+)+x", "", 50);

// Backtracks remain below the limit on this subject string.
{
  let s = "3333ax3333x";
  assertArrayEquals(["3333x", "3333"], re0.exec(s));
  assertEquals(["3333x", "3333"], re1.exec(s));
}

// A longer subject exceeds the limit.
{
  let s = "333333333ax3333x";
  assertArrayEquals(["3333x", "3333"], re0.exec(s));
  assertEquals(null, re1.exec(s));
}

// ATOM regexp construction with a limit; in this case the limit should just be
// ignored, ATOMs never backtrack.
{
  const re = %NewRegExpWithBacktrackLimit("ax", "", 50);
  let s = "3333ax3333x";
  assertArrayEquals(["ax"], re.exec(s));
}
                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/regexp-cache-replace.js                                            0000664 0000000 0000000 00000003554 14746647661 0023026 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Tests that regexp caching isn't messing things up.

var re1 = /(o)/g;
assertEquals("FxxBar", "FooBar".replace(re1, "x"));
assertEquals("o", RegExp.$1);
assertTrue(/(x)/.test("abcxdef"));
assertEquals("x", RegExp.$1);
assertEquals("FxxBar", "FooBar".replace(re1, "x"));
assertEquals("o", RegExp.$1);
                                                                                                                                                    node-23.7.0/deps/v8/test/mjsunit/regexp-call-as-function.js                                         0000664 0000000 0000000 00000003607 14746647661 0023510 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Test that regular expressions can be called as functions.  Calling
// a regular expression as a function corresponds to calling it's exec
// method.

var regexp = /a(b)(c)/;
var subject = "xyzabcde";
var expected = 'abc,b,c';
assertEquals(expected, String(regexp.exec(subject)));
assertThrows(function(){ regexp(subject); });
                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/regexp-capture-3.js                                                0000664 0000000 0000000 00000017457 14746647661 0022164 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2012 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function oneMatch(re) {
  "abcd".replace(re, function() { });
  assertEquals("abcd", RegExp.input);
  assertEquals("a", RegExp.leftContext);
  assertEquals("b", RegExp.lastMatch);
  assertEquals("", RegExp.lastParen);
  assertEquals(undefined, RegExp.lastIndex);
  assertEquals(undefined, RegExp.index);
  assertEquals("cd", RegExp.rightContext);
  for (var i = 1; i < 10; i++) {
    assertEquals("", RegExp['$' + i]);
  }
}

oneMatch(/b/);
oneMatch(/b/g);

"abcdabcd".replace(/b/g, function() { });
assertEquals("abcdabcd", RegExp.input);
assertEquals("abcda", RegExp.leftContext);
assertEquals("b", RegExp.lastMatch);
assertEquals("", RegExp.lastParen);
assertEquals(undefined, RegExp.lastIndex);
assertEquals(undefined, RegExp.index);
assertEquals("cd", RegExp.rightContext);
for (var i = 1; i < 10; i++) {
  assertEquals("", RegExp['$' + i]);
}

function captureMatch(re) {
  "abcd".replace(re, function() { });
  assertEquals("abcd", RegExp.input);
  assertEquals("a", RegExp.leftContext);
  assertEquals("bc", RegExp.lastMatch);
  assertEquals("c", RegExp.lastParen);
  assertEquals(undefined, RegExp.lastIndex);
  assertEquals(undefined, RegExp.index);
  assertEquals("d", RegExp.rightContext);
  assertEquals('b', RegExp.$1);
  assertEquals('c', RegExp.$2);
  for (var i = 3; i < 10; i++) {
    assertEquals("", RegExp['$' + i]);
  }
}

captureMatch(/(b)(c)/);
captureMatch(/(b)(c)/g);

"abcdabcd".replace(/(b)(c)/g, function() { });
assertEquals("abcdabcd", RegExp.input);
assertEquals("abcda", RegExp.leftContext);
assertEquals("bc", RegExp.lastMatch);
assertEquals("c", RegExp.lastParen);
assertEquals(undefined, RegExp.lastIndex);
assertEquals(undefined, RegExp.index);
assertEquals("d", RegExp.rightContext);
assertEquals('b', RegExp.$1);
assertEquals('c', RegExp.$2);
for (var i = 3; i < 10; i++) {
  assertEquals("", RegExp['$' + i]);
}


function Override() {
  // Set the internal lastMatchInfoOverride.  After calling this we do a normal
  // match and verify the override was cleared and that we record the new
  // captures.
  "abcdabcd".replace(/(b)(c)/g, function() { });
}


function TestOverride(input, expect, property, re_src) {
  var re = new RegExp(re_src);
  var re_g = new RegExp(re_src, "g");

  function OverrideCase(fn) {
    Override();
    fn();
    assertEquals(expect, RegExp[property]);
  }

  OverrideCase(function() { return input.replace(re, "x"); });
  OverrideCase(function() { return input.replace(re_g, "x"); });
  OverrideCase(function() { return input.replace(re, ""); });
  OverrideCase(function() { return input.replace(re_g, ""); });
  OverrideCase(function() { return input.match(re); });
  OverrideCase(function() { return input.match(re_g); });
  OverrideCase(function() { return re.test(input); });
  OverrideCase(function() { return re_g.test(input); });
}

var input = "bar.foo baz......";
var re_str = "(ba.).*?f";
TestOverride(input, "bar", "$1", re_str);

input = "foo bar baz";
var re_str = "bar";
TestOverride(input, "bar", "$&", re_str);


function no_last_match(fn) {
  fn();
  assertEquals("hestfisk", RegExp.$1);
}

/(hestfisk)/.test("There's no such thing as a hestfisk!");

no_last_match(function() { "foo".replace("f", ""); });
no_last_match(function() { "foo".replace("f", "f"); });
no_last_match(function() { "foo".split("o"); });

var base = "In the music.  In the music.  ";
var cons = base + base + base + base;
no_last_match(function() { cons.replace("x", "y"); });
no_last_match(function() { cons.replace("e", "E"); });


// Here's one that matches once, then tries to match again, but fails.
// Verify that the last match info is from the last match, not from the
// failure that came after.
"bar.foo baz......".replace(/(ba.).*?f/g, function() { return "x";});
assertEquals("bar", RegExp.$1);


// A test that initially does a zero width match, but later does a non-zero
// width match.
var a = "foo bar baz".replace(/^|bar/g, "");
assertEquals("foo  baz", a);

a = "foo bar baz".replace(/^|bar/g, "*");
assertEquals("*foo * baz", a);

// We test FilterASCII using regexps that will backtrack forever.  Since
// a regexp with a non-ASCII character in it can never match an ASCII
// string we can test that the relevant node is removed by verifying that
// there is no hang.
function NoHang(re) {
  "This is an ASCII string that could take forever".match(re);
}

NoHang(/(((.*)*)*x)Ā/);  // Continuation after loop is filtered, so is loop.
NoHang(/(((.*)*)*Ā)foo/);  // Body of loop filtered.
NoHang(/Ā(((.*)*)*x)/);   // Everything after a filtered character is filtered.
NoHang(/(((.*)*)*x)Ā/);   // Everything before a filtered character is filtered.
NoHang(/[ćăĀ](((.*)*)*x)/);   // Everything after a filtered class is filtered.
NoHang(/(((.*)*)*x)[ćăĀ]/);   // Everything before a filtered class is filtered.
NoHang(/[^\x00-\xff](((.*)*)*x)/);   // After negated class.
NoHang(/(((.*)*)*x)[^\x00-\xff]/);   // Before negated class.
NoHang(/(?!(((.*)*)*x)Ā)foo/);  // Negative lookahead is filtered.
NoHang(/(?!(((.*)*)*x))Ā/);  // Continuation branch of negative lookahead.
NoHang(/(?=(((.*)*)*x)Ā)foo/);  // Positive lookahead is filtered.
NoHang(/(?=(((.*)*)*x))Ā/);  // Continuation branch of positive lookahead.
NoHang(/(?=Ā)(((.*)*)*x)/);  // Positive lookahead also prunes continuation.
NoHang(/(æ|ø|Ā)(((.*)*)*x)/);  // All branches of alternation are filtered.
NoHang(/(a|b|(((.*)*)*x))Ā/);  // 1 out of 3 branches pruned.
NoHang(/(a|(((.*)*)*x)ă|(((.*)*)*x)Ā)/);  // 2 out of 3 branches pruned.

var s = "Don't prune based on a repetition of length 0";
assertEquals(null, s.match(/å{1,1}prune/));
assertEquals("prune", (s.match(/å{0,0}prune/)[0]));

// Some very deep regexps where FilterASCII gives up in order not to make the
// stack overflow.
var regex6 = /a*\u0100*\w/;
var input0 = "a";
regex6.exec(input0);

var re = "\u0100*\\w";

for (var i = 0; i < 200; i++) re = "a*" + re;

var regex7 = new RegExp(re);
regex7.exec(input0);

var regex8 = new RegExp(re, "i");
regex8.exec(input0);

re = "[\u0100]*\\w";
for (var i = 0; i < 200; i++) re = "a*" + re;

var regex9 = new RegExp(re);
regex9.exec(input0);

var regex10 = new RegExp(re, "i");
regex10.exec(input0);

var regex11 = /^(?:[^\u0000-\u0080]|[0-9a-z?,.!&\s#()])+$/i;
regex11.exec(input0);

var regex12 = /u(\xf0{8}?\D*?|( ? !)$h??(|)*?(||)+?\6((?:\W\B|--\d-*-|)?$){0, }?|^Y( ? !1)\d+)+a/;
regex12.exec("");
                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/regexp-capture.js                                                  0000664 0000000 0000000 00000005555 14746647661 0022020 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Tests from http://blog.stevenlevithan.com/archives/npcg-javascript

assertEquals(true, /(x)?\1y/.test("y"));
assertEquals(["y", undefined], /(x)?\1y/.exec("y"));
assertEquals(["y", undefined], /(x)?y/.exec("y"));
assertEquals(["y", undefined], "y".match(/(x)?\1y/));
assertEquals(["y", undefined], "y".match(/(x)?y/));
assertEquals(["y"], "y".match(/(x)?\1y/g));
assertEquals(["", undefined, ""], "y".split(/(x)?\1y/));
assertEquals(["", undefined, ""], "y".split(/(x)?y/));
assertEquals(0, "y".search(/(x)?\1y/));
assertEquals("z", "y".replace(/(x)?\1y/, "z"));
assertEquals("", "y".replace(/(x)?y/, "$1"));
assertEquals("undefined", "y".replace(/(x)?\1y/,
    function($0, $1){
        return String($1);
    }));
assertEquals("undefined", "y".replace(/(x)?y/,
    function($0, $1){
        return String($1);
    }));
assertEquals("undefined", "y".replace(/(x)?y/,
    function($0, $1){
        return $1;
    }));

// See https://bugzilla.mozilla.org/show_bug.cgi?id=476146
assertEquals(["bbc", "b"], /^(b+|a){1,2}?bc/.exec("bbc"));
assertEquals(["bbaa", "a", "", "a"],
             /((\3|b)\2(a)){2,}/.exec("bbaababbabaaaaabbaaaabba"));

// From crbug.com/128821 - don't hang:
"".match(/((a|i|A|I|u|o|U|O)(s|c|b|c|d|f|g|h|j|k|l|m|n|p|q|r|s|t|v|w|x|y|z|B|C|D|F|G|H|J|K|L|M|N|P|Q|R|S|T|V|W|X|Y|Z)*) de\/da([.,!?\s]|$)/);
                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/regexp-captures.js                                                 0000664 0000000 0000000 00000003623 14746647661 0022175 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

var re = /^(((N({)?)|(R)|(U)|(V)|(B)|(H)|(n((n)|(r)|(v)|(h))?)|(r(r)?)|(v)|(b((n)|(b))?)|(h))|((Y)|(A)|(E)|(o(u)?)|(p(u)?)|(q(u)?)|(s)|(t)|(u)|(w)|(x(u)?)|(y)|(z)|(a((T)|(A)|(L))?)|(c)|(e)|(f(u)?)|(g(u)?)|(i)|(j)|(l)|(m(u)?)))+/;
var r = new RegExp(re)
var str = "Avtnennan gunzvmu pubExnY nEvln vaTxh rmuhguhaTxnY"
assertTrue(r.test(str));
                                                                                                             node-23.7.0/deps/v8/test/mjsunit/regexp-compile.js                                                  0000664 0000000 0000000 00000004112 14746647661 0021771 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Test that we don't cache the result of a regexp match across a
// compile event.
var re = /x/;
assertEquals("a.yb", "axyb".replace(re, "."));

re.compile("y");
assertEquals("ax.b", "axyb".replace(re, "."));

re.compile("(x)");

assertEquals(["x", "x"], re.exec("axyb"));

re.compile("(y)");

assertEquals(["y", "y"], re.exec("axyb"));

assertEquals(2, re.compile.length);

// If RegExp parsing fails, the RegExp is not modified
var r = /./; try { r.compile('? invalid'); } catch(err){}
assertEquals("/./", r.toString());
                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/regexp-experimental.js                                             0000664 0000000 0000000 00000011641 14746647661 0023043 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --default-to-experimental-regexp-engine

function Test(regexp, subject, expectedResult, expectedLastIndex) {
  assertEquals(%RegexpTypeTag(regexp), "EXPERIMENTAL");
  var result = regexp.exec(subject);
  if (result instanceof Array && expectedResult instanceof Array) {
    assertArrayEquals(expectedResult, result);
  } else {
    assertEquals(expectedResult, result);
  }
  assertEquals(expectedLastIndex, regexp.lastIndex);
}

function AssertUnsupported(regexp) {
  assertNotEquals(%RegexpTypeTag(regexp), 'EXPERIMENTAL');
}

// The empty regexp.
Test(new RegExp(""), "asdf", [""], 0);

// Plain patterns without special operators.
Test(/asdf1/, "123asdf1xyz", ["asdf1"], 0);
// Escaped operators, otherwise plain string:
Test(/\*\.\(\[\]\?/, "123*.([]?123", ["*.([]?"], 0);
// Some two byte values:
Test(/쁰d섊/, "123쁰d섊abc", ["쁰d섊"], 0);
// A pattern with surrogates but without unicode flag:
Test(/💩f/, "123💩f", ["💩f"], 0);

// Disjunctions.
Test(/asdf|123/, "xyz123asdf", ["123"], 0);
Test(/asdf|123|fj|f|a/, "da123", ["a"], 0);
Test(/|123/, "123", [""], 0);

// Character ranges.
Test(/[abc]/, "123asdf", ["a"], 0);
Test(/[0-9]/, "asdf123xyz", ["1"], 0);
Test(/[^0-9]/, "123!xyz", ["!"], 0);
Test(/\w\d/, "?a??a3!!!", ["a3"], 0);
// [💩] without unicode flag is a character range matching one of the two
// surrogate characters that make up 💩.  The leading surrogate is 0xD83D.
Test(/[💩]/, "f💩", [String.fromCodePoint(0xD83D)], 0);

// Greedy and non-greedy quantifiers.
Test(/x*/, "asdfxk", [""], 0);
Test(/xx*a/, "xxa", ["xxa"], 0);
Test(/x*[xa]/, "xxaa", ["xxa"], 0);
Test(/x*?[xa]/, "xxaa", ["x"], 0);
Test(/x*?a/, "xxaa", ["xxa"], 0);
Test(/x+a/, "axxa", ["xxa"], 0);
Test(/x+?[ax]/, "axxa", ["xx"], 0);
Test(/xx?[xa]/, "xxaa", ["xxa"], 0);
Test(/xx??[xa]/, "xxaa", ["xx"], 0);
Test(/xx??a/, "xxaa", ["xxa"], 0);
Test(/x{4}/, "xxxxxxxxx", ["xxxx"], 0);
Test(/x{4,}/, "xxxxxxxxx", ["xxxxxxxxx"], 0);
Test(/x{4,}?/, "xxxxxxxxx", ["xxxx"], 0);
Test(/x{2,4}/, "xxxxxxxxx", ["xxxx"], 0);
Test(/x{2,4}?/, "xxxxxxxxx", ["xx"], 0);

// Non-capturing groups and nested operators.
Test(/(?:)/, "asdf", [""], 0);
Test(/(?:asdf)/, "123asdfxyz", ["asdf"], 0);
Test(/(?:asdf)|123/, "xyz123asdf", ["123"], 0);
Test(/asdf(?:[0-9]|(?:xy|x)*)*/, "kkkasdf5xyx8xyyky", ["asdf5xyx8xy"], 0);

// Capturing groups.
Test(/()/, "asdf", ["", ""], 0);
Test(/(123)/, "asdf123xyz", ["123", "123"], 0);
Test(/asdf(123)xyz/, "asdf123xyz", ["asdf123xyz", "123"], 0);
Test(/(123|xyz)/, "123", ["123", "123"], 0);
Test(/(123|xyz)/, "xyz", ["xyz", "xyz"], 0);
Test(/(123)|(xyz)/, "123", ["123", "123", undefined], 0);
Test(/(123)|(xyz)/, "xyz", ["xyz", undefined, "xyz"], 0);
Test(/(?:(123)|(xyz))*/, "xyz123", ["xyz123", "123", undefined], 0);
Test(/((123)|(xyz)*)*/, "xyz123xyz", ["xyz123xyz", "xyz", undefined, "xyz"], 0);

// Assertions.
Test(/asdf\b/, "asdf---", ["asdf"], 0);
Test(/asdf\b/, "asdfg", null, 0);
Test(/asd[fg]\B/, "asdf asdgg", ["asdg"], 0);
Test(/^asd[fg]/, "asdf asdgg", ["asdf"], 0);
Test(/asd[fg]$/, "asdf asdg", ["asdg"], 0);

// The global flag.
Test(/asdf/g, "fjasdfkkasdf", ["asdf"], 6);

// The sticky flag.
var r = /asdf/y;
r.lastIndex = 2;
Test(r, "fjasdfkkasdf", ["asdf"], 6);

// The multiline flag.
Test(/^a/m, "x\na", ["a"], 0);
Test(/x$/m, "x\na", ["x"], 0);

// The dotall flag.
Test(/asdf.xyz/s, 'asdf\nxyz', ['asdf\nxyz'], 0);

// Lookbehinds.
Test(/ab(?<=a(?<=a)b)c/, 'abc', ['abc'], 0);
Test(/ab(?<=a(?<=a)b)(c)/, 'abc', ['abc', 'c'], 0);

// Negative lookbehind.
Test(/ab(?<=b)c/, 'abc', ['abc'], 0);
Test(/ab(?<=a(?<!b)b)c/, 'abc', ['abc'], 0);
Test(/ab(?<=a(?<!(b))b)c/, 'abc', ['abc', undefined], 0);
Test(/ab(?<=a(?<!b)b)(c)/, 'abc', ['abc', 'c'], 0);
Test(/ab(?<=a(?<!(b))b)(c)/, 'abc', ['abc', undefined, 'c'], 0);

// Global and Sticky flags are not yet supported in combination with lookbehinds
AssertUnsupported(/ab(?<=b)c/g);
AssertUnsupported(/ab(?<=b)c/y);

// Capture reset with quantifiers
Test(/(?:(a)|b)*/, 'aba', ['aba', 'a'], 0);
Test(/(?:(a)|b)+/, 'aba', ['aba', 'a'], 0);
Test(/(?:(a)|b){2,8}/, 'aba', ['aba', 'a'], 0);
Test(/(?:(a)|b)*/, 'abb', ['abb', undefined], 0);
Test(/(?:(a)|b)+/, 'abb', ['abb', undefined], 0);
Test(/(?:(a)|b){2,8}/, 'abb', ['abb', undefined], 0);

Test(/(?:(?:(a)|b)+|c)*/, 'abc', ['abc', undefined], 0);
Test(/(?:(?:(a)|b)+?|c)+/, 'aba', ['aba', 'a'], 0);
Test(/(?:(?:(a)|b){2,}|c)*/, 'abcabc', ['abcabc', undefined], 0);
Test(/(?:(?:(a)|b){1}|c){3,4}/, 'abcabc', ['abca', 'a'], 0);
Test(/(?:(?:(a)|b)*?|c)+?/, 'abcaac', ['', undefined], 0);
Test(/(?:(?:(a)|b)+|c){3}/, 'bbcbac', ['bbcba', 'a'], 0);

// This test allows to detect abnormal memory usage. Itself cannot check the
// consumption or trigger an out-of-memory error, but it creates a detectable
// anomaly.
Test(/(((((a?)+)+)+)+)b/, ('a'.repeat(100000)), null, 0);
                                                                                               node-23.7.0/deps/v8/test/mjsunit/regexp-fallback-large-default.js                                   0000664 0000000 0000000 00000001603 14746647661 0024614 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax
// Flags: --no-enable-experimental-regexp-engine
// Flags: --enable-experimental-regexp-engine-on-excessive-backtracks
// Flags: --regexp-backtracks-before-fallback=1000000000

// This test is similar to regexp-fallback.js but with
// large--regexp-backtracks-before-fallback value.
//
// If the backtrack limit from --regexp-backtracks-before-fallback is larger
// than an explicit limit, then we should take the explicit limit.
let regexp = %NewRegExpWithBacktrackLimit(".+".repeat(100) + "x", "", 5000);
let subject = "a".repeat(100) + "x" + "a".repeat(99);
let result = ["a".repeat(100) + "x"];

assertArrayEquals(result, regexp.exec(subject));
assertArrayEquals(result, regexp.exec(subject));
                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/regexp-fallback.js                                                 0000664 0000000 0000000 00000003145 14746647661 0022105 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax
// Flags: --no-enable-experimental-regexp-engine
// Flags: --enable-experimental-regexp-engine-on-excessive-backtracks
// Flags: --regexp-tier-up --regexp-tier-up-ticks 1

// We should report accurate results on patterns for which irregexp suffers
// from catastrophic backtracking.
let regexp = new RegExp("a+".repeat(100) + "x");
let match = "a".repeat(100) + "x";
let subject = match.repeat(3);

// First for the irregexp interpreter:
assertArrayEquals([match], regexp.exec(subject));
// Now for native irregexp:
assertArrayEquals([match], regexp.exec(subject));

// Now the same again with String.replace and a replacement function to
// exercise the RegExpGlobalCache.
regexp = new RegExp(regexp.source, "g");
assertEquals("", subject.replace(regexp, function () { return ""; }));
assertEquals("", subject.replace(regexp, function () { return ""; }));

// If an explicit backtrack limit is larger than the default, then we should
// take the default limit.
regexp = %NewRegExpWithBacktrackLimit(regexp.source, "", 1000000000)
assertArrayEquals([match], regexp.exec(subject));
assertArrayEquals([match], regexp.exec(subject));

// If the experimental engine can't handle a regexp with an explicit backtrack
// limit, we should abort and return null on excessive backtracking.
regexp = %NewRegExpWithBacktrackLimit(regexp.source + "(?=a)", "", 100)
assertEquals(null, regexp.exec(subject));
assertEquals(null, regexp.exec(subject));
                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/regexp-global.js                                                   0000664 0000000 0000000 00000023060 14746647661 0021604 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2012 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


// Test that an optional capture is cleared between two matches.
var str = "ABX X";
str = str.replace(/(\w)?X/g, function(match, capture) {
                               assertTrue(match.indexOf(capture) >= 0 ||
                                           capture === undefined);
                               return capture ? capture.toLowerCase() : "-";
                             });
assertEquals("Ab -", str);

// Test zero-length matches.
str = "Als Gregor Samsa eines Morgens";
str = str.replace(/\b/g, function(match, capture) {
                           return "/";
                         });
assertEquals("/Als/ /Gregor/ /Samsa/ /eines/ /Morgens/", str);

// Test zero-length matches that have non-zero-length sub-captures.
str = "It was a pleasure to burn.";
str = str.replace(/(?=(\w+))\b/g, function(match, capture) {
                                    return capture.length;
                                  });
assertEquals("2It 3was 1a 8pleasure 2to 4burn.", str);

// Test multiple captures.
str = "Try not. Do, or do not. There is no try.";
str = str.replace(/(not?)|(do)|(try)/gi,
                  function(match, c1, c2, c3) {
                    assertTrue((c1 === undefined && c2 === undefined) ||
                               (c2 === undefined && c3 === undefined) ||
                               (c1 === undefined && c3 === undefined));
                    if (c1) return "-";
                    if (c2) return "+";
                    if (c3) return "="
                  });
assertEquals("= -. +, or + -. There is - =.", str);

// Test multiple alternate captures.
str = "FOUR LEGS GOOD, TWO LEGS BAD!";
str = str.replace(/(FOUR|TWO) LEGS (GOOD|BAD)/g,
                  function(match, num_legs, likeability) {
                    assertTrue(num_legs !== undefined);
                    assertTrue(likeability !== undefined);
                    if (num_legs == "FOUR") assertTrue(likeability == "GOOD");
                    if (num_legs == "TWO") assertTrue(likeability == "BAD");
                    return match.length - 10;
                  });
assertEquals("4, 2!", str);


// The same tests with UC16.

//Test that an optional capture is cleared between two matches.
str = "AB\u1234 \u1234";
str = str.replace(/(\w)?\u1234/g,
                  function(match, capture) {
                    assertTrue(match.indexOf(capture) >= 0 ||
                               capture === undefined);
                    return capture ? capture.toLowerCase() : "-";
                  });
assertEquals("Ab -", str);

// Test zero-length matches.
str = "Als \u2623\u2642 eines Morgens";
str = str.replace(/\b/g, function(match, capture) {
                           return "/";
                         });
assertEquals("/Als/ \u2623\u2642 /eines/ /Morgens/", str);

// Test zero-length matches that have non-zero-length sub-captures.
str = "It was a pleasure to \u70e7.";
str = str.replace(/(?=(\w+))\b/g, function(match, capture) {
                                    return capture.length;
                                  });
assertEquals("2It 3was 1a 8pleasure 2to \u70e7.", str);

// Test multiple captures.
str = "Try not. D\u26aa, or d\u26aa not. There is no try.";
str = str.replace(/(not?)|(d\u26aa)|(try)/gi,
                  function(match, c1, c2, c3) {
                    assertTrue((c1 === undefined && c2 === undefined) ||
                               (c2 === undefined && c3 === undefined) ||
                               (c1 === undefined && c3 === undefined));
                    if (c1) return "-";
                    if (c2) return "+";
                    if (c3) return "="
                  });
assertEquals("= -. +, or + -. There is - =.", str);

// Test multiple alternate captures.
str = "FOUR \u817f GOOD, TWO \u817f BAD!";
str = str.replace(/(FOUR|TWO) \u817f (GOOD|BAD)/g,
                  function(match, num_legs, likeability) {
                    assertTrue(num_legs !== undefined);
                    assertTrue(likeability !== undefined);
                    if (num_legs == "FOUR") assertTrue(likeability == "GOOD");
                    if (num_legs == "TWO") assertTrue(likeability == "BAD");
                    return match.length - 7;
                  });
assertEquals("4, 2!", str);

// Test capture that is a real substring.
var str = "Beasts of England, beasts of Ireland";
str = str.replace(/(.*)/g, function(match) { return '~'; });
assertEquals("~~", str);

// Test zero-length matches that have non-zero-length sub-captures that do not
// start at the match start position.
str = "up up up up";
str = str.replace(/\b(?=u(p))/g, function(match, capture) {
                                    return capture.length;
                                  });

assertEquals("1up 1up 1up 1up", str);


// Create regexp that has a *lot* of captures.
var re_string = "(a)";
for (var i = 0; i < 500; i++) {
  re_string = "(" + re_string + ")";
}
re_string = re_string + "1";
// re_string = "(((...((a))...)))1"

var regexps = new Array();
var last_match_expectations = new Array();
var first_capture_expectations = new Array();

// Atomic regexp.
regexps.push(/a1/g);
last_match_expectations.push("a1");
first_capture_expectations.push("");
// Small regexp (no capture);
regexps.push(/\w1/g);
last_match_expectations.push("a1");
first_capture_expectations.push("");
// Small regexp (one capture).
regexps.push(/(a)1/g);
last_match_expectations.push("a1");
first_capture_expectations.push("a");
// Large regexp (a lot of captures).
regexps.push(new RegExp(re_string, "g"));
last_match_expectations.push("a1");
first_capture_expectations.push("a");

function test_replace(result_expectation,
                      subject,
                      regexp,
                      replacement) {
  for (var i = 0; i < regexps.length; i++) {
    // Overwrite last match info.
    "deadbeef".replace(/(dead)beef/, "$1holeycow");
    // Conduct tests.
    assertEquals(result_expectation, subject.replace(regexps[i], replacement));
    if (subject.length == 0) {
      assertEquals("deadbeef", RegExp.lastMatch);
      assertEquals("dead", RegExp["$1"]);
    } else {
      assertEquals(last_match_expectations[i], RegExp.lastMatch);
      assertEquals(first_capture_expectations[i], RegExp["$1"]);
    }
  }
}


function test_match(result_expectation,
                    subject,
                    regexp) {
  for (var i = 0; i < regexps.length; i++) {
    // Overwrite last match info.
    "deadbeef".replace(/(dead)beef/, "$1holeycow");
    // Conduct tests.
    if (result_expectation == null) {
      assertNull(subject.match(regexps[i]));
    } else {
      assertArrayEquals(result_expectation, subject.match(regexps[i]));
    }
    if (subject.length == 0) {
      assertEquals("deadbeef", RegExp.lastMatch);
      assertEquals("dead", RegExp["$1"]);
    } else {
      assertEquals(last_match_expectations[i], RegExp.lastMatch);
      assertEquals(first_capture_expectations[i], RegExp["$1"]);
    }
  }
}


// Test for different number of matches.
for (var m = 0; m < 33; m++) {
  // Create string that matches m times.
  var subject = "";
  var test_1_expectation = "";
  var test_2_expectation = "";
  var test_3_expectation = (m == 0) ? null : new Array();
  for (var i = 0; i < m; i++) {
    subject += "a11";
    test_1_expectation += "x1";
    test_2_expectation += "1";
    test_3_expectation.push("a1");
  }

  // Test 1a: String.replace with string.
  test_replace(test_1_expectation, subject, /a1/g, "x");

  // Test 1b: String.replace with function.
  function f() { return "x"; }
  test_replace(test_1_expectation, subject, /a1/g, f);

  // Test 2a: String.replace with empty string.
  test_replace(test_2_expectation, subject, /a1/g, "");

  // Test 3a: String.match.
  test_match(test_3_expectation, subject, /a1/g);
}


// Test String hashing (compiling regular expression includes hashing).
var crosscheck = "\x80";
for (var i = 0; i < 12; i++) crosscheck += crosscheck;
new RegExp(crosscheck);

var subject = "ascii~only~string~here~";
var replacement = "\x80";
var result = subject.replace(/~/g, replacement);
for (var i = 0; i < 5; i++) result += result;
new RegExp(result);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/regexp-indexof.js                                                  0000664 0000000 0000000 00000007042 14746647661 0022002 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

function CheckMatch(re, str, matches) {
  assertEquals(matches.length > 0, re.test(str));
  var result = str.match(re);
  if (matches.length > 0) {
    assertEquals(matches.length, result.length);
    var lastExpected;
    var lastFrom;
    var lastLength;
    for (var idx = 0; idx < matches.length; idx++) {
      var from = matches[idx][0];
      var length = matches[idx][1];
      var expected = str.substr(from, length);
      var name = str + "[" + from + ".." + (from+length) + "]";
      assertEquals(expected, result[idx], name);
      if (re.global || idx == 0) {
        lastExpected = expected;
        lastFrom = from;
        lastLength = length;
      }
    }
    assertEquals(lastExpected, RegExp.lastMatch, "lastMatch");
    assertEquals(str.substr(0, lastFrom), RegExp.leftContext, "leftContext");
    assertEquals(
        str.substr(lastFrom + lastLength), RegExp.rightContext, "rightContext");
  } else {
    assertTrue(result === null);
  }
}

CheckMatch(/abc/, "xxxabcxxxabcxxx", [[3, 3]]);
CheckMatch(/abc/g, "xxxabcxxxabcxxx", [[3, 3], [9, 3]]);
CheckMatch(/abc/, "xxxabababcxxxabcxxx", [[7, 3]]);
CheckMatch(/abc/g, "abcabcabc", [[0, 3], [3, 3], [6, 3]]);
CheckMatch(/aba/g, "ababababa", [[0, 3], [4, 3]]);
CheckMatch(/foo/g, "ofooofoooofofooofo", [[1, 3], [5, 3], [12, 3]]);
CheckMatch(/foobarbaz/, "xx", []);
CheckMatch(new RegExp(""), "xxx", [[0, 0]]);
CheckMatch(/abc/, "abababa", []);

assertEquals("xxxdefxxxdefxxx", "xxxabcxxxabcxxx".replace(/abc/g, "def"));
assertEquals("o-o-oofo-ofo", "ofooofoooofofooofo".replace(/foo/g, "-"));
assertEquals("deded", "deded".replace(/x/g, "-"));
assertEquals("-a-b-c-d-e-f-", "abcdef".replace(new RegExp("", "g"), "-"));

CheckMatch(/a(.)/, "xyzzyabxyzzzyacxyzzy", [[5, 2], [6, 1]]);
CheckMatch(/a(.)/g, "xyzzyabxyzzyacxyzzy", [[5, 2], [12, 2]]);

CheckMatch(/a|(?:)/g, "aba", [[0, 1], [1, 0], [2, 1], [3, 0]]);
CheckMatch(/a|(?:)/g, "baba", [[0, 0], [1, 1], [2, 0], [3, 1], [4, 0]]);
CheckMatch(/a|(?:)/g, "bab", [[0, 0], [1, 1], [2, 0], [3, 0]]);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/regexp-lastIndex.js                                                0000664 0000000 0000000 00000001445 14746647661 0022302 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// lastIndex is set only for global or sticky RegExps. On failure to find
// a match, it is set to 0. If a set fails, then it acts as if in strict mode
// and throws.

var re = /x/g;
Object.defineProperty(re, 'lastIndex', {writable: false});
assertThrows(() => re.exec(""), TypeError);
assertThrows(() => re.exec("x"), TypeError);

var re = /x/y;
Object.defineProperty(re, 'lastIndex', {writable: false});
assertThrows(() => re.exec(""), TypeError);
assertThrows(() => re.exec("x"), TypeError);

var re = /x/;
Object.defineProperty(re, 'lastIndex', {writable: false});
assertEquals(null, re.exec(""));
assertEquals(["x"], re.exec("x"));
                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/regexp-linear-flag.js                                              0000664 0000000 0000000 00000003114 14746647661 0022523 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax
// Flags: --enable-experimental-regexp-engine
// Flags: --no-default-to-experimental-regexp-engine
// Flags: --no-force-slow-path

// We shouldn't assign the experimental engine to regexps without 'l' flag.
assertNotEquals("EXPERIMENTAL", %RegexpTypeTag(/asdf/));
assertNotEquals("EXPERIMENTAL", %RegexpTypeTag(/123|asdf/));
assertNotEquals("EXPERIMENTAL", %RegexpTypeTag(/(a*)*x/));
assertNotEquals("EXPERIMENTAL", %RegexpTypeTag(/(a*)\1/));

// We should assign the experimental engine to regexps with 'l' flag.
assertEquals("EXPERIMENTAL", %RegexpTypeTag(/asdf/l));
assertEquals("EXPERIMENTAL", %RegexpTypeTag(/123|asdf/l));
assertEquals("EXPERIMENTAL", %RegexpTypeTag(/(a*)*x/l));

// We should throw if a regexp with 'l' flag can't be handled by the
// experimental engine.
assertThrows(() => /(a*)\1/l, SyntaxError);

// The flags field of a regexp should be sorted.
assertEquals("glmsy", (/asdf/lymsg).flags);

// The 'linear' member should be set according to the linear flag.
assertTrue((/asdf/lymsg).linear);
assertFalse((/asdf/ymsg).linear);

// The new fields installed on the regexp prototype map shouldn't make
// unmodified regexps slow.
assertTrue(%RegexpIsUnmodified(/asdf/));
assertTrue(%RegexpIsUnmodified(/asdf/l));

// Redefined .linear should reflect in flags.
{
  let re = /./;
  Object.defineProperty(re, "linear", { get: function() { return true; } });
  assertEquals("l", re.flags);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/test/mjsunit/regexp-lookahead.js                                                0000664 0000000 0000000 00000012117 14746647661 0022274 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Tests captures in positive and negative look-ahead in regular expressions.

function stringEscape(string) {
  // Converts string to source literal.
  return '"' + string.replace(/["\\]/g, "\\$1") + '"';
}

function testRE(re, input, expected_result) {
  var testName = re + ".test(" + stringEscape(input) +")";
  if (expected_result) {
    assertTrue(re.test(input), testName);
  } else {
    assertFalse(re.test(input), testName);
  }
}

function execRE(re, input, expected_result) {
  var testName = re + ".exec('" + stringEscape(input) +"')";
  assertEquals(expected_result, re.exec(input), testName);
}

// Test of simple positive lookahead.

var re = /^(?=a)/;
testRE(re, "a", true);
testRE(re, "b", false);
execRE(re, "a", [""]);

re = /^(?=\woo)f\w/;
testRE(re, "foo", true);
testRE(re, "boo", false);
testRE(re, "fao", false);
testRE(re, "foa", false);
execRE(re, "foo", ["fo"]);

re = /(?=\w).(?=\W)/;
testRE(re, ".a! ", true);
testRE(re, ".! ", false);
testRE(re, ".ab! ", true);
execRE(re, ".ab! ", ["b"]);

re = /(?=f(?=[^f]o))../;
testRE(re, ", foo!", true);
testRE(re, ", fo!", false);
testRE(re, ", ffo", false);
execRE(re, ", foo!", ["fo"]);

// Positive lookahead with captures.
re = /^[^\'\"]*(?=([\'\"])).*\1(\w+)\1/;
testRE(re, "  'foo' ", true);
testRE(re, '  "foo" ', true);
testRE(re, " \" 'foo' ", false);
testRE(re, " ' \"foo\" ", false);
testRE(re, "  'foo\" ", false);
testRE(re, "  \"foo' ", false);
execRE(re, "  'foo' ", ["  'foo'", "'", "foo"]);
execRE(re, '  "foo" ', ['  "foo"', '"', 'foo']);

// Captures are cleared on backtrack past the look-ahead.
re = /^(?:(?=(.))a|b)\1$/;
testRE(re, "aa", true);
testRE(re, "b", true);
testRE(re, "bb", false);
testRE(re, "a", false);
execRE(re, "aa", ["aa", "a"]);
execRE(re, "b", ["b", undefined]);

re = /^(?=(.)(?=(.)\1\2)\2\1)\1\2/;
testRE(re, "abab", true);
testRE(re, "ababxxxxxxxx", true);
testRE(re, "aba", false);
execRE(re, "abab", ["ab", "a", "b"]);

re = /^(?:(?=(.))a|b|c)$/;
testRE(re, "a", true);
testRE(re, "b", true);
testRE(re, "c", true);
testRE(re, "d", false);
execRE(re, "a", ["a", "a"]);
execRE(re, "b", ["b", undefined]);
execRE(re, "c", ["c", undefined]);

execRE(/^(?=(b))b/, "b", ["b", "b"]);
execRE(/^(?:(?=(b))|a)b/, "ab", ["ab", undefined]);
execRE(/^(?:(?=(b)(?:(?=(c))|d))|)bd/, "bd", ["bd", "b", undefined]);



// Test of Negative Look-Ahead.

re = /(?!x)./;
testRE(re, "y", true);
testRE(re, "x", false);
execRE(re, "y", ["y"]);

re = /(?!(\d))|\d/;
testRE(re, "4", true);
execRE(re, "4", ["4", undefined]);
execRE(re, "x", ["", undefined]);


// Test mixed nested look-ahead with captures.

re = /^(?=(x)(?=(y)))/;
testRE(re, "xy", true);
testRE(re, "xz", false);
execRE(re, "xy", ["", "x", "y"]);

re = /^(?!(x)(?!(y)))/;
testRE(re, "xy", true);
testRE(re, "xz", false);
execRE(re, "xy", ["", undefined, undefined]);

re = /^(?=(x)(?!(y)))/;
testRE(re, "xz", true);
testRE(re, "xy", false)
execRE(re, "xz", ["", "x", undefined]);

re = /^(?!(x)(?=(y)))/;
testRE(re, "xz", true);
testRE(re, "xy", false);
execRE(re, "xz", ["", undefined, undefined]);

re = /^(?=(x)(?!(y)(?=(z))))/;
testRE(re, "xaz", true);
testRE(re, "xya", true);
testRE(re, "xyz", false);
testRE(re, "a", false);
execRE(re, "xaz", ["", "x", undefined, undefined]);
execRE(re, "xya", ["", "x", undefined, undefined]);

re = /^(?!(x)(?=(y)(?!(z))))/;
testRE(re, "a", true);
testRE(re, "xa", true);
testRE(re, "xyz", true);
testRE(re, "xya", false);
execRE(re, "a", ["", undefined, undefined, undefined]);
execRE(re, "xa", ["", undefined, undefined, undefined]);
execRE(re, "xyz", ["", undefined, undefined, undefined]);
                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/regexp-loop-capture.js                                             0000664 0000000 0000000 00000003306 14746647661 0022757 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

assertEquals(["abc",undefined,undefined,"c"], /(?:(a)|(b)|(c))+/.exec("abc"));
assertEquals(["ab",undefined], /(?:(a)|b)*/.exec("ab"));
                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/regexp-multiline.js                                                0000664 0000000 0000000 00000007470 14746647661 0022355 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/**
 * @fileoverview Check that various regexp constructs work as intended.
 * Particularly those regexps that use ^ and $.
 */

assertTrue(/^bar/.test("bar"));
assertTrue(/^bar/.test("bar\nfoo"));
assertFalse(/^bar/.test("foo\nbar"));
assertTrue(/^bar/m.test("bar"));
assertTrue(/^bar/m.test("bar\nfoo"));
assertTrue(/^bar/m.test("foo\nbar"));

assertTrue(/bar$/.test("bar"));
assertFalse(/bar$/.test("bar\nfoo"));
assertTrue(/bar$/.test("foo\nbar"));
assertTrue(/bar$/m.test("bar"));
assertTrue(/bar$/m.test("bar\nfoo"));
assertTrue(/bar$/m.test("foo\nbar"));

assertFalse(/^bxr/.test("bar"));
assertFalse(/^bxr/.test("bar\nfoo"));
assertFalse(/^bxr/m.test("bar"));
assertFalse(/^bxr/m.test("bar\nfoo"));
assertFalse(/^bxr/m.test("foo\nbar"));

assertFalse(/bxr$/.test("bar"));
assertFalse(/bxr$/.test("foo\nbar"));
assertFalse(/bxr$/m.test("bar"));
assertFalse(/bxr$/m.test("bar\nfoo"));
assertFalse(/bxr$/m.test("foo\nbar"));


assertTrue(/^.*$/.test(""));
assertTrue(/^.*$/.test("foo"));
assertFalse(/^.*$/.test("\n"));
assertTrue(/^.*$/m.test("\n"));

assertTrue(/^[\s]*$/.test(" "));
assertTrue(/^[\s]*$/.test("\n"));

assertTrue(/^[^]*$/.test(""));
assertTrue(/^[^]*$/.test("foo"));
assertTrue(/^[^]*$/.test("\n"));

assertTrue(/^([()\s]|.)*$/.test("()\n()"));
assertTrue(/^([()\n]|.)*$/.test("()\n()"));
assertFalse(/^([()]|.)*$/.test("()\n()"));
assertTrue(/^([()]|.)*$/m.test("()\n()"));
assertTrue(/^([()]|.)*$/m.test("()\n"));
assertTrue(/^[()]*$/m.test("()\n."));

assertTrue(/^[\].]*$/.test("...]..."));


function check_case(lc, uc) {
  var a = new RegExp("^" + lc + "$");
  assertFalse(a.test(uc));
  a = new RegExp("^" + lc + "$", "i");
  assertTrue(a.test(uc));

  var A = new RegExp("^" + uc + "$");
  assertFalse(A.test(lc));
  A = new RegExp("^" + uc + "$", "i");
  assertTrue(A.test(lc));

  a = new RegExp("^[" + lc + "]$");
  assertFalse(a.test(uc));
  a = new RegExp("^[" + lc + "]$", "i");
  assertTrue(a.test(uc));

  A = new RegExp("^[" + uc + "]$");
  assertFalse(A.test(lc));
  A = new RegExp("^[" + uc + "]$", "i");
  assertTrue(A.test(lc));
}


check_case("a", "A");
// Aring
check_case(String.fromCharCode(229), String.fromCharCode(197));
// Russian G
check_case(String.fromCharCode(0x413), String.fromCharCode(0x433));


assertThrows("a = new RegExp('[z-a]');");
                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/regexp-no-linear-flag.js                                           0000664 0000000 0000000 00000001613 14746647661 0023137 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax
// Flags: --no-enable-experimental-regexp-engine

// We shouldn't recognize the 'l' flag.
assertThrows(() => new RegExp("asdf", "l"), SyntaxError)
assertThrows(() => new RegExp("123|xyz", "l"), SyntaxError)
assertThrows(() => new RegExp("((a*)*)*", "yls"), SyntaxError)
assertThrows(() => new RegExp("((a*)*)*\1", "l"), SyntaxError)

// RegExps shouldn't have a 'linear' property.
assertFalse(RegExp.prototype.hasOwnProperty('linear'));
assertFalse(/123/.hasOwnProperty('linear'));

// Redefined .linear shouldn't reflect in flags without
// --enable-experimental-regexp-engine.
{
  let re = /./;
  Object.defineProperty(re, "linear", { get: function() { return true; } });
  assertEquals("", re.flags);
}
                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/regexp-override-exec.js                                            0000664 0000000 0000000 00000001067 14746647661 0023110 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var s = "baa";

assertEquals(1, s.search(/a/));
assertEquals(["aa"], s.match(/a./));
assertEquals(["b", "", ""], s.split(/a/));

let o = { index : 3, 0 : "x" };

RegExp.prototype.exec = () => { return o; }
assertEquals(3, s.search(/a/));
assertEquals(o, s.match(/a./));
assertEquals("baar", s.replace(/a./, "r"));

RegExp.prototype.exec = () => { return null; }
assertEquals(["baa"], s.split(/a/));
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/regexp-override-symbol-match-all.js                                0000664 0000000 0000000 00000000510 14746647661 0025321 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var s = "baa";

assertEquals([["b"], ["a"], ["a"]], [...s.matchAll(/./g)]);

RegExp.prototype[Symbol.matchAll] = () => 42;
assertEquals(42, s.matchAll(/a./g));
                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/regexp-override-symbol-match.js                                    0000664 0000000 0000000 00000000452 14746647661 0024560 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var s = "baa";

assertEquals(["aa"], s.match(/a./));

RegExp.prototype[Symbol.match] = () => 42;
assertEquals(42, s.match(/a./));
                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/regexp-override-symbol-replace.js                                  0000664 0000000 0000000 00000000463 14746647661 0025101 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var s = "baa";

assertEquals("bca", s.replace(/a/, "c"));

RegExp.prototype[Symbol.replace] = () => 42;
assertEquals(42, s.replace(/a./));
                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/regexp-override-symbol-search.js                                   0000664 0000000 0000000 00000000446 14746647661 0024734 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var s = "baa";

assertEquals(1, s.search(/a/));

RegExp.prototype[Symbol.search] = () => 42;
assertEquals(42, s.search(/a/));
                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/regexp-override-symbol-split.js                                    0000664 0000000 0000000 00000000460 14746647661 0024616 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var s = "baa";

assertEquals(["b", "", ""], s.split(/a/));

RegExp.prototype[Symbol.split] = () => 42;
assertEquals(42, s.split(/a./));
                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/regexp-regexpexec.js                                               0000664 0000000 0000000 00000000514 14746647661 0022502 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Test that the fallback path in RegExpExec executes the default exec
// implementation.
delete RegExp.prototype.exec;
assertEquals("b", "aba".replace(/a/g, ""));
                                                                                                                                                                                    node-23.7.0/deps/v8/test/mjsunit/regexp-results-cache.js                                            0000664 0000000 0000000 00000007426 14746647661 0023116 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2012 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Long string to trigger caching.
var string =
"Friends, Romans, countrymen, lend me your ears!  \
 I come to bury Caesar, not to praise him.        \
 The evil that men do lives after them,           \
 The good is oft interred with their bones;       \
 So let it be with Caesar. The noble Brutus       \
 Hath told you Caesar was ambitious;              \
 If it were so, it was a grievous fault,          \
 And grievously hath Caesar answer'd it.          \
 Here, under leave of Brutus and the rest-        \
 For Brutus is an honorable man;                  \
 So are they all, all honorable men-              \
 Come I to speak in Caesar's funeral.             \
 He was my friend, faithful and just to me;       \
 But Brutus says he was ambitious,                \
 And Brutus is an honorable man.                  \
 He hath brought many captives home to Rome,      \
 Whose ransoms did the general coffers fill.      \
 Did this in Caesar seem ambitious?               \
 When that the poor have cried, Caesar hath wept; \
 Ambition should be made of sterner stuff:        \
 Yet Brutus says he was ambitious,                \
 And Brutus is an honorable man.                  \
 You all did see that on the Lupercal             \
 I thrice presented him a kingly crown,           \
 Which he did thrice refuse. Was this ambition?   \
 Yet Brutus says he was ambitious,                \
 And sure he is an honorable man.                 \
 I speak not to disprove what Brutus spoke,       \
 But here I am to speak what I do know.           \
 You all did love him once, not without cause;    \
 What cause withholds you then to mourn for him?  \
 O judgement, thou art fled to brutish beasts,    \
 And men have lost their reason. Bear with me;    \
 My heart is in the coffin there with Caesar,     \
 And I must pause till it come back to me.";

var replaced = string.replace(/\b\w+\b/g, function() { return "foo"; });
for (var i = 0; i < 3; i++) {
  assertEquals(replaced,
               string.replace(/\b\w+\b/g, function() { return "foo"; }));
}

// Check that the result is in a COW array.
var words = string.split(" ");
assertEquals("Friends,", words[0]);
words[0] = "Enemies,";
words = string.split(" ");
assertEquals("Friends,", words[0]);
                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/regexp-sort.js                                                     0000664 0000000 0000000 00000004025 14746647661 0021333 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

function Test(lower, upper) {
  var lx = lower + "x";
  var ux = upper + "x";
  var lp = lower + "|";
  var uxp = upper + "x|";
  assertEquals(lx, new RegExp(uxp + lp + lower + "cat", "i").exec(lx) + "");
  assertEquals(ux, new RegExp(uxp + lp + lower + "cat", "i").exec(ux) + "");
  assertEquals(lower, new RegExp(lp + uxp + lower + "cat", "i").exec(lx) + "");
  assertEquals(upper, new RegExp(lp + uxp + lower + "cat", "i").exec(ux) + "");
}

function TestFail(lower, upper) {
  var lx = lower + "x";
  var ux = upper + "x";
  var lp = lower + "|";
  var uxp = upper + "x|";
  assertEquals(lower, new RegExp(uxp + lp + lower + "cat", "i").exec(lx) + "");
  assertEquals(ux, new RegExp(uxp + lp + lower + "cat", "i").exec(ux) + "");
  assertEquals(lower, new RegExp(lp + uxp + lower + "cat", "i").exec(lx) + "");
  assertEquals(ux, new RegExp(lp + uxp + lower + "cat", "i").exec(ux) + "");
}

Test("a", "A");
Test("0", "0");
TestFail("a", "b");
// Small and capital o-umlaut
Test(String.fromCharCode(0xf6), String.fromCharCode(0xd6));
// Small and capital kha.
Test(String.fromCharCode(0x445), String.fromCharCode(0x425));
// Small and capital y-umlaut.
Test(String.fromCharCode(0xff), String.fromCharCode(0x178));
// Small and large Greek mu.
Test(String.fromCharCode(0x3bc), String.fromCharCode(0x39c));
// Micron and large Greek mu.
Test(String.fromCharCode(0xb5), String.fromCharCode(0x39c));
// Micron and small Greek mu.
Test(String.fromCharCode(0xb5), String.fromCharCode(0x3bc));
// German double s and capital S. These are not equivalent since one is double.
TestFail(String.fromCharCode(0xdf), "S");
// Small i and Turkish capital dotted I. These are not equivalent due to
// 21.2.2.8.2 section 3g.  One is below 128 and the other is above 127.
TestFail("i", String.fromCharCode(0x130));
// Small dotless i and I. These are not equivalent either.
TestFail(String.fromCharCode(0x131), "I");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/regexp-stack-overflow.js                                           0000664 0000000 0000000 00000000554 14746647661 0023315 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --stack-size=100

var re = /\w/;
re.test("a");  // Trigger regexp compile.

function rec() {
  try {
    return rec();
  } catch (e) {
    return re.test("b");
  }
}

assertTrue(rec());
                                                                                                                                                    node-23.7.0/deps/v8/test/mjsunit/regexp-standalones.js                                              0000664 0000000 0000000 00000006127 14746647661 0022664 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* Many of the Mozilla regexp tests used 'toSource' to test their
 * results.  Since we don't currently support toSource, those tests
 * are disabled and standalone versions are included here.
 */

// Tests from ecma_3/RegExp/regress-78156.js
var string = 'aaa\n789\r\nccc\r\n345';
var pattern = /^\d/gm;
var result = string.match(pattern);
assertEquals(2, result.length, "1");
assertEquals('7', result[0], "2");
assertEquals('3', result[1], "3");

pattern = /\d$/gm;
result = string.match(pattern);
assertEquals(2, result.length, "4");
assertEquals('9', result[0], "5");
assertEquals('5', result[1], "6");

string = 'aaa\n789\r\nccc\r\nddd';
pattern = /^\d/gm;
result = string.match(pattern);
assertEquals(1, result.length, "7");
assertEquals('7', result[0], "8");

pattern = /\d$/gm;
result = string.match(pattern);
assertEquals(1, result.length, "9");
assertEquals('9', result[0], "10");

// Tests from ecma_3/RegExp/regress-72964.js
pattern = /[\S]+/;
string = '\u00BF\u00CD\u00BB\u00A7';
result = string.match(pattern);
assertEquals(1, result.length, "11");
assertEquals(string, result[0], "12");

string = '\u00BF\u00CD \u00BB\u00A7';
result = string.match(pattern);
assertEquals(1, result.length, "13");
assertEquals('\u00BF\u00CD', result[0], "14");

string = '\u4e00\uac00\u4e03\u4e00';
result = string.match(pattern);
assertEquals(1, result.length, "15");
assertEquals(string, result[0], "16");

string = '\u4e00\uac00 \u4e03\u4e00';
result = string.match(pattern);
assertEquals(1, result.length, "17");
assertEquals('\u4e00\uac00', result[0], "18");
                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/regexp-static.js                                                   0000664 0000000 0000000 00000014040 14746647661 0021631 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Test the (deprecated as of JS 1.5) properties of the RegExp function.
var re = /((\d+)\.(\d+))/;
var s = 'abc123.456def';

re.exec(s);

assertEquals(s, RegExp.input);
assertEquals('123.456', RegExp.lastMatch);
assertEquals('456', RegExp.lastParen);
assertEquals('abc', RegExp.leftContext);
assertEquals('def', RegExp.rightContext);

assertEquals(s, RegExp['$_']);
assertEquals('123.456', RegExp['$&']);
assertEquals('456', RegExp['$+']);
assertEquals('abc', RegExp['$`']);
assertEquals('def', RegExp["$'"]);

assertEquals('123.456', RegExp['$1']);
assertEquals('123', RegExp['$2']);
assertEquals('456', RegExp['$3']);
for (var i = 4; i < 10; ++i) {
  assertEquals('', RegExp['$' + i]);
}

// They should be read only.
RegExp['$1'] = 'fisk';
assertEquals('123.456', RegExp['$1']);

// String.prototype.match and String.prototype.replace (when given a
// regexp) and also RegExp.prototype.test should all behave as if
// RegExp.prototype.exec were called.
s = 'ghi789.012jkl';
s.match(re);
assertEquals(s, RegExp.input);
assertEquals('789.012', RegExp.lastMatch);
assertEquals('012', RegExp.lastParen);
assertEquals('ghi', RegExp.leftContext);
assertEquals('jkl', RegExp.rightContext);
assertEquals(s, RegExp['$_']);
assertEquals('789.012', RegExp['$&']);
assertEquals('012', RegExp['$+']);
assertEquals('ghi', RegExp['$`']);
assertEquals('jkl', RegExp["$'"]);
assertEquals('789.012', RegExp['$1']);
assertEquals('789', RegExp['$2']);
assertEquals('012', RegExp['$3']);
for (var i = 4; i < 10; ++i) {
  assertEquals('', RegExp['$' + i]);
}

s = 'abc123.456def';
s.replace(re, 'whocares');
assertEquals(s, RegExp.input);
assertEquals('123.456', RegExp.lastMatch);
assertEquals('456', RegExp.lastParen);
assertEquals('abc', RegExp.leftContext);
assertEquals('def', RegExp.rightContext);
assertEquals(s, RegExp['$_']);
assertEquals('123.456', RegExp['$&']);
assertEquals('456', RegExp['$+']);
assertEquals('abc', RegExp['$`']);
assertEquals('def', RegExp["$'"]);
assertEquals('123.456', RegExp['$1']);
assertEquals('123', RegExp['$2']);
assertEquals('456', RegExp['$3']);
for (var i = 4; i < 10; ++i) {
  assertEquals('', RegExp['$' + i]);
}

s = 'ghi789.012jkl';
re.test(s);
assertEquals(s, RegExp.input);
assertEquals('789.012', RegExp.lastMatch);
assertEquals('012', RegExp.lastParen);
assertEquals('ghi', RegExp.leftContext);
assertEquals('jkl', RegExp.rightContext);
assertEquals(s, RegExp['$_']);
assertEquals('789.012', RegExp['$&']);
assertEquals('012', RegExp['$+']);
assertEquals('ghi', RegExp['$`']);
assertEquals('jkl', RegExp["$'"]);
assertEquals('789.012', RegExp['$1']);
assertEquals('789', RegExp['$2']);
assertEquals('012', RegExp['$3']);
for (var i = 4; i < 10; ++i) {
  assertEquals('', RegExp['$' + i]);
}

// String.prototype.replace must interleave matching and replacing when a
// global regexp is matched and replaced with the result of a function, in
// case the function uses the static properties of the regexp constructor.
re = /(.)/g;
function f() { return RegExp.$1; };
assertEquals('dddd', 'abcd'.replace(re, f));

// lastParen where the last parenthesis didn't match.
assertEquals(["foo",undefined], /foo(?:a(x))?/.exec("foobx"),
             "lastParen setup");
assertEquals("", RegExp.lastParen, "lastParen");

// The same test for $1 to $9.
for (var i = 1; i <= 9; i++) {
  var haystack = "foo";
  var re_text = "^foo";
  for (var j = 0; j < i - 1; j++) {
    haystack += "x";
    re_text += "(x)";
  }
  re_text += "(?:a(x))?";
  haystack += "bx";
  var re = new RegExp(re_text);
  assertTrue(re.test(haystack), "$" + i + " setup");
  for (var j = 1; j < i - 1; j++) {
    assertEquals("x", RegExp['$' + j], "$" + j + " in $" + i + " setup");
  }
  assertEquals("", RegExp['$' + (i)], "$" + i);
}

RegExp.input = Number();
assertTrue(typeof RegExp.input == typeof String(), "RegExp.input coerces values to booleans");

// Ensure that we save the correct string as the last subject when
// we do a match on a sliced string (the top one not the underlying).
var foo = "lsdfj sldkfj sdklfj læsdfjl sdkfjlsdk fjsdl fjsdljskdj flsj flsdkj flskd regexp: /foobar/\nldkfj sdlkfj sdkl";
assertTrue(/^([a-z]+): (.*)/.test(foo.substring(foo.indexOf("regexp:"))), "regexp: setup");
assertEquals("regexp", RegExp.$1, "RegExp.$1");


// Check that calling with no argument is the same as calling with undefined.
assertTrue(/^undefined$/.test());
assertEquals(["undefined"], /^undefined$/.exec());

assertThrows(
    () => { RegExp.prototype.test.call("xyz", "foo"); },
    TypeError,
    'Method RegExp.prototype.test called on incompatible receiver xyz');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/regexp-string-methods.js                                           0000664 0000000 0000000 00000004173 14746647661 0023317 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2009 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
//