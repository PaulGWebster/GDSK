, , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , , , , , , , , , , , , , , , , , , , , , , , , , ,1,1,1,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, , , , , , , , , , , , ,
  , , , , , , , , , , , , , ,1,1,1,1,1,1,1, ,1,1,1,1,1,1,1,1,1,1,
 1,1,1,1,1,1,1,1, , , , , , , , , , , , , , , , , , , , , , , , ,
  , ,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, , , , ,
  , , , , , , , , , , , , , , , , , , , , , ,1,1,1,1, ,1, ,1,1,1,
 1,1,1,1, ,1,1,1,1,1,1,1,1,1,1,1, , , , , , , , , , , , , , , , ,
  , , , , , , , , , ,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
 1,1,1,1, , , , , , , , , , , , , , , , , , , , , , , , , , ,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, , , , , , , , ,
  , , , , , , , , , , , , , , , , , ,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1, , , , , , , , , , , , , , , , , , , , ,
  , , , , , ,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
  , , , , , , , , , , , , , , , , , , , , , , , , , ,1,1,1,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, , , , , , , , , , , , ,
  , , , , , , , , , , , , , ,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
 1,1,1,1,1,1,1,1, , , , , , , , , , , , , , , , , , , , , , , , ,
  , ,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, , , , ,
  , , , , , , , , , , , , , , , , , , , , , ,1,1,1,1,1,1,1,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, , , , , , , , , , , , , , , , ,
  , , , , , , , , , ,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
 1,1,1,1,1,1, , , , , , , , , , , , , , , , , , , , , , , , , , ,
  , ,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, ,1,1,1,1,
 1,1, , , , , , , , , , , , , , , , , , , , , , , , , , ,1,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, ,1,1,1,1,1,1, , , , ,
  , , , , , , , , , , , , , , , , , , , , , ,1,1,1,1,1,1,1,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, ,1,1,1,1,1,1, , , , , , , , , , ,
  , , , , , , , , , , , , , , , ,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
 1,1,1,1,1,1,1,1,1, ,1,1,1,1,1,1, , , , , , , , , , , , , , , , ,
  , , , , , , , , , ,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
 1,1,1, ,1,1,1,1,1,1, ,1];
}
                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/unused-context-in-with.js                                          0000664 0000000 0000000 00000000425 14746647661 0023416 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

var x = 1;
function foo(object) {
  with(object) {
    x;
  }
  return 100;
}

assertEquals(100,foo("str"));
                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/unusual-constructor.js                                             0000664 0000000 0000000 00000003324 14746647661 0023134 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

var threw = false;
try {
  var obj = new (Function.__proto__)();
} catch (e) {
  assertInstanceof(e, TypeError);
  threw = true;
}
assertTrue(threw);
                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/uri.js                                                             0000664 0000000 0000000 00000010046 14746647661 0017653 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Tests of URI encoding and decoding.

assertEquals("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_.!~*'();/?:@&=+$,#",
             encodeURI("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_.!~*'();/?:@&=+$,#"));

var cc1 = 0x007D;
var s1 = String.fromCharCode(cc1);
var cc2 = 0x0000;
var s2 = String.fromCharCode(cc2);
var cc3 = 0x0080;
var s3 = String.fromCharCode(cc3);
var cc4 = 0x0555;
var s4 = String.fromCharCode(cc4);
var cc5 = 0x07FF;
var s5 = String.fromCharCode(cc5);
var cc6 = 0x0800;
var s6 = String.fromCharCode(cc6);
var cc7 = 0xAEEE;
var s7 = String.fromCharCode(cc7);
var cc8_1 = 0xD800;
var cc8_2 = 0xDC00;
var s8 = String.fromCharCode(cc8_1)+String.fromCharCode(cc8_2);
var cc9_1 = 0xDBFF;
var cc9_2 = 0xDFFF;
var s9 = String.fromCharCode(cc9_1)+String.fromCharCode(cc9_2);
var cc10 = 0xE000;
var s10 = String.fromCharCode(cc10);

assertEquals('%7D', encodeURI(s1));
assertEquals('%00', encodeURI(s2));
assertEquals('%C2%80', encodeURI(s3));
assertEquals('%D5%95', encodeURI(s4));
assertEquals('%DF%BF', encodeURI(s5));
assertEquals('%E0%A0%80', encodeURI(s6));
assertEquals('%EA%BB%AE', encodeURI(s7));
assertEquals('%F0%90%80%80', encodeURI(s8));
assertEquals('%F4%8F%BF%BF', encodeURI(s9));
assertEquals('%EE%80%80', encodeURI(s10));

assertEquals(cc1, decodeURI(encodeURI(s1)).charCodeAt(0));
assertEquals(cc2, decodeURI(encodeURI(s2)).charCodeAt(0));
assertEquals(cc3, decodeURI(encodeURI(s3)).charCodeAt(0));
assertEquals(cc4, decodeURI(encodeURI(s4)).charCodeAt(0));
assertEquals(cc5, decodeURI(encodeURI(s5)).charCodeAt(0));
assertEquals(cc6, decodeURI(encodeURI(s6)).charCodeAt(0));
assertEquals(cc7, decodeURI(encodeURI(s7)).charCodeAt(0));
assertEquals(cc8_1, decodeURI(encodeURI(s8)).charCodeAt(0));
assertEquals(cc8_2, decodeURI(encodeURI(s8)).charCodeAt(1));
assertEquals(cc9_1, decodeURI(encodeURI(s9)).charCodeAt(0));
assertEquals(cc9_2, decodeURI(encodeURI(s9)).charCodeAt(1));
assertEquals(cc10, decodeURI(encodeURI(s10)).charCodeAt(0));

assertEquals("", decodeURI(""));
assertEquals("", encodeURI(""));

function test(string) {
  assertEquals(string, decodeURI(encodeURI(string)));
}

test("\u1234\u0123\uabcd");
test("abcd");
test("ab<\u1234\u0123");
test("ab\u1234<\u0123");


(function TestDeleteCharCodeAt() {
  assertEquals('abc', encodeURI('abc'));
  assertEquals('abc', decodeURI('abc'));
  assertTrue(delete String.prototype.charCodeAt);
  assertTrue(delete String.prototype.charAt);
  assertEquals('abc', encodeURI('abc'));
  assertEquals('abc', decodeURI('abc'));
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/value-callic-prototype-change.js                                   0000664 0000000 0000000 00000005430 14746647661 0024704 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Test that the inline caches correctly detect that constant
// functions on value prototypes change.

function testString() {
  function f(s, expected) {
    var result = s.toString();
    assertEquals(expected, result);
  };

  for (var i = 0; i < 10; i++) {
    var s = String.fromCharCode(i);
    f(s, s);
  }

  String.prototype.toString = function() { return "ostehaps"; };

  for (var i = 0; i < 10; i++) {
    var s = String.fromCharCode(i);
    f(s, "ostehaps");
  }
}

testString();


function testNumber() {
  Number.prototype.toString = function() { return 0; };

  function f(n, expected) {
    var result = n.toString();
    assertEquals(expected, result);
  };

  for (var i = 0; i < 10; i++) {
    f(i, 0);
  }

  Number.prototype.toString = function() { return 42; };

  for (var i = 0; i < 10; i++) {
    f(i, 42);
  }
}

testNumber();


function testBoolean() {
  Boolean.prototype.toString = function() { return 0; };

  function f(b, expected) {
    var result = b.toString();
    assertEquals(expected, result);
  };

  for (var i = 0; i < 10; i++) {
    f((i % 2 == 0), 0);
  }

  Boolean.prototype.toString = function() { return 42; };

  for (var i = 0; i < 10; i++) {
    f((i % 2 == 0), 42);
  }
}

testBoolean();
                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/value-helper.js                                                    0000664 0000000 0000000 00000013713 14746647661 0021451 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

const float32_array = [
  -2.70497e+38,
  -1.4698e+37,
  -1.22813e+35,
  -1.20555e+35,
  -1.34584e+34,
  -1.0079e+32,
  -6.49364e+26,
  -3.06077e+25,
  -1.46821e+25,
  -1.17658e+23,
  -1.9617e+22,
  -2.7357e+20,
  -9223372036854775808.0,  // INT64_MIN
  -1.48708e+13,
  -1.89633e+12,
  -4.66622e+11,
  -2.22581e+11,
  -1.45381e+10,
  -2147483904.0,  // First float32 after INT32_MIN
  -2147483648.0,  // INT32_MIN
  -2147483520.0,  // Last float32 before INT32_MIN
  -1.3956e+09,
  -1.32951e+09,
  -1.30721e+09,
  -1.19756e+09,
  -9.26822e+08,
  -6.35647e+08,
  -4.00037e+08,
  -1.81227e+08,
  -5.09256e+07,
  -964300.0,
  -192446.0,
  -28455.0,
  -27194.0,
  -26401.0,
  -20575.0,
  -17069.0,
  -9167.0,
  -960.178,
  -113.0,
  -62.0,
  -15.0,
  -7.0,
  -1.0,
  -0.0256635,
  -4.60374e-07,
  -3.63759e-10,
  -4.30175e-14,
  -5.27385e-15,
  -1.5707963267948966,
  -1.48084e-15,
  -2.220446049250313e-16,
  -1.05755e-19,
  -3.2995e-21,
  -1.67354e-23,
  -1.11885e-23,
  -1.78506e-30,
  -5.07594e-31,
  -3.65799e-31,
  -1.43718e-34,
  -1.27126e-38,
  -0.0,
  0.0,
  1.17549e-38,
  1.56657e-37,
  4.08512e-29,
  3.31357e-28,
  6.25073e-22,
  4.1723e-13,
  1.44343e-09,
  1.5707963267948966,
  5.27004e-08,
  9.48298e-08,
  5.57888e-07,
  4.89988e-05,
  0.244326,
  1.0,
  12.4895,
  19.0,
  47.0,
  106.0,
  538.324,
  564.536,
  819.124,
  7048.0,
  12611.0,
  19878.0,
  20309.0,
  797056.0,
  1.77219e+09,
  2147483648.0,  // INT32_MAX + 1
  2147483904.0,  // INT32_MAX + 1 and significand = 1.
  4294967296.0,  // UINT32_MAX + 1
  1.51116e+11,
  4.18193e+13,
  3.59167e+16,
  9223372036854775808.0,   // INT64_MAX + 1
  18446744073709551616.0,  // UINT64_MAX + 1
  3.38211e+19,
  2.67488e+20,
  1.78831e+21,
  9.20914e+21,
  8.35654e+23,
  1.4495e+24,
  5.94015e+25,
  4.43608e+30,
  2.44502e+33,
  2.61152e+33,
  1.38178e+37,
  1.71306e+37,
  3.31899e+38,
  3.40282e+38,
];

const float64_array = [
  -2e66,
  -2.220446049250313e-16,
  -9223373136366403584.0,
  -9223372036854775808.0,  // INT64_MIN
  -2147483649.5,
  -2147483648.25,
  -2147483648.0,
  -2147483647.875,
  -2147483647.125,
  -2147483647.0,
  -999.75,
  -2e66,
  -1.75,
  -1.5707963267948966,
  -1.0,
  -0.5,
  -0.0,
  0.0,
  3e-88,
  0.125,
  0.25,
  0.375,
  0.5,
  1.0,
  1.17549e-38,
  1.56657e-37,
  1.0000001,
  1.25,
  1.5707963267948966,
  2,
  3.1e7,
  5.125,
  6.25,
  888,
  982983.25,
  2147483647.0,
  2147483647.375,
  2147483647.75,
  2147483648.0,
  2147483648.25,
  2147483649.25,
  9223372036854775808.0,  // INT64_MAX + 1
  9223373136366403584.0,
  18446744073709551616.0,  // UINT64_MAX + 1
  2e66,
  Number.MAX_SAFE_INTEGER,
  Number.MIN_SAFE_INTEGER,
  Number.MAX_VALUE,
  Number.MIN_VALUE,
  Number.NaN,
  Number.NEGATIVE_INFINITY,
  Number.POSITIVE_INFINITY,
];

const int8_array = new Int8Array([
  0,
  1,
  2,
  127,
  126,
  64,
  63,
  16,
  15,
  14,
  -128,
  -127,
  -64,
  -63,
  -16,
  -15,
  -14,
  -2,
  -1
]);

const int16_array = new Int16Array([
  0,
  1,
  2,
  32767,
  32766,
  16384,
  16383,
  256,
  255,
  254,
  -32768,
  -32767,
  -16384,
  -16383,
  -256,
  -255,
  -254,
  -2,
  -1
]);

const int32_array = new Int32Array([
  0x00000000,
  0x00000001,
  0xFFFFFFFF,
  0x1B09788B,
  0x04C5FCE8,
  0xCC0DE5BF,
  0x00000002,
  0x00000003,
  0x00000004,
  0x00000005,
  0x00000008,
  0x00000009,
  0x273A798E,
  0x187937A3,
  0xECE3AF83,
  0x5495A16B,
  0x0B668ECC,
  0x11223344,
  0x0000009E,
  0x00000043,
  0x0000AF73,
  0x0000116B,
  0x00658ECC,
  0x002B3B4C,
  0x88776655,
  0x70000000,
  0x07200000,
  0x7FFFFFFF,
  0x56123761,
  0x7FFFFF00,
  0x761C4761,
  0x80000000,
  0x88888888,
  0xA0000000,
  0xDDDDDDDD,
  0xE0000000,
  0xEEEEEEEE,
  0xFFFFFFFD,
  0xF0000000,
  0x007FFFFF,
  0x003FFFFF,
  0x001FFFFF,
  0x000FFFFF,
  0x0007FFFF,
  0x0003FFFF,
  0x0001FFFF,
  0x0000FFFF,
  0x00007FFF,
  0x00003FFF,
  0x00001FFF,
  0x00000FFF,
  0x000007FF,
  0x000003FF,
  0x000001FF,
  // Bit pattern of a quiet NaN and signaling NaN, with or without
  // additional payload.
  0x7FC00000,
  0x7F800000,
  0x7FFFFFFF,
  0x7F876543
]);

const uint64_array = new BigUint64Array([
  "0x00000000",
  "0x00000001",
  "0xFFFFFFFF",
  "0x1B09788B",
  "0x04C5FCE8",
  "0xCC0DE5BF",
  "0x00000002",
  "0x00000003",
  "0x00000004",
  "0x00000005",
  "0x00000008",
  "0x00000009",
  "0xFFFFFFFFFFFFFFFF",
  "0xFFFFFFFFFFFFFFFE",
  "0xFFFFFFFFFFFFFFFD",
  "0x0000000000000000",
  "0x0000000100000000",
  "0xFFFFFFFF00000000",
  "0x1B09788B00000000",
  "0x04C5FCE800000000",
  "0xCC0DE5BF00000000",
  "0x0000000200000000",
  "0x0000000300000000",
  "0x0000000400000000",
  "0x0000000500000000",
  "0x0000000800000000",
  "0x0000000900000000",
  "0x273A798E187937A3",
  "0xECE3AF835495A16B",
  "0x0B668ECC11223344",
  "0x0000009E",
  "0x00000043",
  "0x0000AF73",
  "0x0000116B",
  "0x00658ECC",
  "0x002B3B4C",
  "0x88776655",
  "0x70000000",
  "0x07200000",
  "0x7FFFFFFF",
  "0x56123761",
  "0x7FFFFF00",
  "0x761C4761EEEEEEEE",
  "0x80000000EEEEEEEE",
  "0x88888888DDDDDDDD",
  "0xA0000000DDDDDDDD",
  "0xDDDDDDDDAAAAAAAA",
  "0xE0000000AAAAAAAA",
  "0xEEEEEEEEEEEEEEEE",
  "0xFFFFFFFDEEEEEEEE",
  "0xF0000000DDDDDDDD",
  "0x007FFFFFDDDDDDDD",
  "0x003FFFFFAAAAAAAA",
  "0x001FFFFFAAAAAAAA",
  "0x000FFFFF",
  "0x0007FFFF",
  "0x0003FFFF",
  "0x0001FFFF",
  "0x0000FFFF",
  "0x00007FFF",
  "0x00003FFF",
  "0x00001FFF",
  "0x00000FFF",
  "0x000007FF",
  "0x000003FF",
  "0x000001FF",
  "0x00003FFFFFFFFFFF",
  "0x00001FFFFFFFFFFF",
  "0x00000FFFFFFFFFFF",
  "0x000007FFFFFFFFFF",
  "0x000003FFFFFFFFFF",
  "0x000001FFFFFFFFFF",
  "0x8000008000000000",
  "0x8000008000000001",
  "0x8000000000000400",
  "0x8000000000000401",
  "0x0000000000000020",
  "0x8000000000000000",  // int64_t min
  "0x7FFFFFFFFFFFFFFF",  // int64_t max
  // Bit pattern of a quiet NaN and signaling NaN, with or without
  // additional payload.
  "0x7FF8000000000000",
  "0x7FF0000000000000",
  "0x7FF8123456789ABC",
  "0x7FF7654321FEDCBA"
]);
                                                     node-23.7.0/deps/v8/test/mjsunit/value-of.js                                                        0000664 0000000 0000000 00000004256 14746647661 0020600 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2010 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

let valueOf = Object.prototype.valueOf;

assertEquals('object', typeof valueOf.call(true));
assertEquals('object', typeof valueOf.call(false));
assertEquals('object', typeof valueOf.call(1.23));
assertEquals('object', typeof valueOf.call(0));
assertEquals('object', typeof valueOf.call('a'));
assertEquals('object', typeof valueOf.call(Symbol.isConcatSpreadable));
assertThrows(() => valueOf.call(undefined), TypeError);
assertThrows(() => valueOf.call(null), TypeError);

function MyException() { }
var o = new Object();
o.valueOf = function() { throw new MyException(); }

assertThrows(function() { o + 1 }, MyException);
                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/value-serializer.js                                                0000664 0000000 0000000 00000003077 14746647661 0022345 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Test the basic d8 value serializer interface
// Flags: --js-float16array

var largeArray = [];
largeArray[0xFFFF00] = 123;

let proto_obj = { fn1() { return 1 } }
let obj_with_enum_cache = {
  __proto__: proto_obj,
  a: 1,
  b: 2,
  c: "c"
};

for (let k in obj_with_enum_cache) {
  // do something
  obj_with_enum_cache.a += obj_with_enum_cache.fn1();
}
let string_1 = "aasdfasdfasdfasdf asd fa sdf asdf as dfa sdf asd f"
let string_2 = "aasdfasdfasdfasdf asd fa sdf UC16\u2028asdf as dfa sdf asd f"
var objects = [
    true, false, null, undefined,
    1, -1, 1.1, -2.2, -0, 0,
    9007199254740991.0, 9007199254740991.0 + 10,
    -9007199254740992.0, -9007199254740992.0 - 10,
    Infinity, -Infinity, NaN,
    string_1, string_1+"b", string_1.slice(1),
    string_2, string_2+"b", string_2.slice(1),
    {}, {1:1}, {a:1}, {1:1, 2:2}, Object.create(null),
    obj_with_enum_cache,
    [], [{}, {}], [1, 1, 1], [1.1, 1.1, 1.1, 1.1, 2], largeArray,
    // new Proxy({},{}),
    new Date(), new String(" a"),
    new Uint8Array(12), new Float16Array([1, 2, 3, 4, 5]),
    new Float16Array([NaN, Infinity, -Infinity]),
    new Float32Array([1, 2, 4, 5]),
    new Uint8ClampedArray(2048),
    /asdf/, new RegExp(),
    new Map(), new Set(),

];

for (var o of objects) {
  const serialised = d8.serializer.serialize(o)
  const deserialised = d8.serializer.deserialize(serialised);
  assertEquals(typeof deserialised, typeof o);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/value-wrapper-accessor.js                                          0000664 0000000 0000000 00000006451 14746647661 0023453 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2014 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// When calling user-defined accessors on strings, booleans or
// numbers, we should create a wrapper object in sloppy mode.

// Flags: --allow-natives-syntax

function test(object, prototype) {
  var result;
  Object.defineProperty(prototype, "nonstrict", {
    get: function() { result = this; },
    set: function(v) { result = this; }
  });
  Object.defineProperty(prototype, "strict", {
    get: function() { "use strict"; result = this; },
    set: function(v) { "use strict"; result = this; }
  });

  (function() {
    function nonstrict(s) {
      return s.nonstrict;
    }
    function strict(s) {
      return s.strict;
    }

    %PrepareFunctionForOptimization(nonstrict);
    nonstrict(object);
    nonstrict(object);
    %OptimizeFunctionOnNextCall(nonstrict);
    result = undefined;
    nonstrict(object);
    assertEquals("object", typeof result);

    %PrepareFunctionForOptimization(strict);
    strict(object);
    strict(object);
    %OptimizeFunctionOnNextCall(strict);
    result = undefined;
    strict(object);
    assertEquals(typeof object, typeof result);
  })();

  (function() {
    function nonstrict(s) {
      return s.nonstrict = 10;
    }
    function strict(s) {
      return s.strict = 10;
    }

    %PrepareFunctionForOptimization(nonstrict);
    nonstrict(object);
    nonstrict(object);
    %OptimizeFunctionOnNextCall(nonstrict);
    result = undefined;
    nonstrict(object);
    assertEquals("object", typeof result);

    %PrepareFunctionForOptimization(strict);
    strict(object);
    strict(object);
    %OptimizeFunctionOnNextCall(strict);
    result = undefined;
    strict(object);
    assertEquals(object, result);
  })();
}

test(1, Number.prototype);
test("string", String.prototype);
test(true, Boolean.prototype);
                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/value-wrapper.js                                                   0000664 0000000 0000000 00000014000 14746647661 0021640 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// When calling user-defined functions on strings, booleans or
// numbers, we should create a wrapper object.

// When running the tests use loops to ensure that the call site moves through
// the different IC states and that both the runtime system and the generated
// IC code is tested.

function RunTests() {
  for (var i = 0; i < 10; i++) {
    assertEquals('object', 'xxx'.TypeOfThis());
    assertEquals('object', true.TypeOfThis(2,3));
    assertEquals('object', false.TypeOfThis());
    assertEquals('object', (42).TypeOfThis());
    assertEquals('object', (3.14).TypeOfThis());
  }

  for (var i = 0; i < 10; i++) {
    assertEquals('object', 'xxx'['TypeOfThis']());
    assertEquals('object', true['TypeOfThis']());
    assertEquals('object', false['TypeOfThis']());
    assertEquals('object', (42)['TypeOfThis']());
    assertEquals('object', (3.14)['TypeOfThis']());
  }

  function CallTypeOfThis(obj) {
    assertEquals('object', obj.TypeOfThis());
  }

  for (var i = 0; i < 10; i++) {
    CallTypeOfThis('xxx');
    CallTypeOfThis(true);
    CallTypeOfThis(false);
    CallTypeOfThis(42);
    CallTypeOfThis(3.14);
  }

  function TestWithWith(obj) {
    with (obj) {
      for (var i = 0; i < 10; i++) {
        assertEquals('object', TypeOfThis());
      }
    }
  }

  TestWithWith('xxx');
  TestWithWith(true);
  TestWithWith(false);
  TestWithWith(42);
  TestWithWith(3.14);

  for (var i = 0; i < 10; i++) {
    assertEquals('object', true[7]());
    assertEquals('object', false[7]());
    assertEquals('object', (42)[7]());
    assertEquals('object', (3.14)[7]());
  }

  for (var i = 0; i < 10; i++) {
    assertEquals('object', typeof 'xxx'.ObjectValueOf());
    assertEquals('object', typeof true.ObjectValueOf());
    assertEquals('object', typeof false.ObjectValueOf());
    assertEquals('object', typeof (42).ObjectValueOf());
    assertEquals('object', typeof (3.14).ObjectValueOf());
  }

  for (var i = 0; i < 10; i++) {
    assertEquals('[object String]', 'xxx'.ObjectToString());
    assertEquals('[object Boolean]', true.ObjectToString());
    assertEquals('[object Boolean]', false.ObjectToString());
    assertEquals('[object Number]', (42).ObjectToString());
    assertEquals('[object Number]', (3.14).ObjectToString());
  }
}

function TypeOfThis() { return typeof this; }

// Test with normal setup of prototype.
String.prototype.TypeOfThis = TypeOfThis;
Boolean.prototype.TypeOfThis = TypeOfThis;
Number.prototype.TypeOfThis = TypeOfThis;
Boolean.prototype[7] = TypeOfThis;
Number.prototype[7] = TypeOfThis;

String.prototype.ObjectValueOf = Object.prototype.valueOf;
Boolean.prototype.ObjectValueOf = Object.prototype.valueOf;
Number.prototype.ObjectValueOf = Object.prototype.valueOf;

String.prototype.ObjectToString = Object.prototype.toString;
Boolean.prototype.ObjectToString = Object.prototype.toString;
Number.prototype.ObjectToString = Object.prototype.toString;

RunTests();

// Run test after properties have been set to a different value.
String.prototype.TypeOfThis = 'x';
Boolean.prototype.TypeOfThis = 'x';
Number.prototype.TypeOfThis = 'x';
Boolean.prototype[7] = 'x';
Number.prototype[7] = 'x';

String.prototype.TypeOfThis = TypeOfThis;
Boolean.prototype.TypeOfThis = TypeOfThis;
Number.prototype.TypeOfThis = TypeOfThis;
Boolean.prototype[7] = TypeOfThis;
Number.prototype[7] = TypeOfThis;

RunTests();

// Force the prototype into slow case and run the test again.
delete String.prototype.TypeOfThis;
delete Boolean.prototype.TypeOfThis;
delete Number.prototype.TypeOfThis;
Boolean.prototype[7];
Number.prototype[7];

String.prototype.TypeOfThis = TypeOfThis;
Boolean.prototype.TypeOfThis = TypeOfThis;
Number.prototype.TypeOfThis = TypeOfThis;
Boolean.prototype[7] = TypeOfThis;
Number.prototype[7] = TypeOfThis;

RunTests();

// According to ES3 15.3.4.3 the this value passed to Function.prototyle.apply
// should wrapped. According to ES5 it should not.
assertEquals('object', TypeOfThis.apply('xxx', []));
assertEquals('object', TypeOfThis.apply(true, []));
assertEquals('object', TypeOfThis.apply(false, []));
assertEquals('object', TypeOfThis.apply(42, []));
assertEquals('object', TypeOfThis.apply(3.14, []));

// According to ES3 15.3.4.3 the this value passed to Function.prototyle.call
// should wrapped. According to ES5 it should not.
assertEquals('object', TypeOfThis.call('xxx'));
assertEquals('object', TypeOfThis.call(true));
assertEquals('object', TypeOfThis.call(false));
assertEquals('object', TypeOfThis.call(42));
assertEquals('object', TypeOfThis.call(3.14));
node-23.7.0/deps/v8/test/mjsunit/var.js                                                             0000664 0000000 0000000 00000004703 14746647661 0017647 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2008 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

assertTrue(!x && typeof x == 'undefined');
assertTrue(!y && typeof y == 'undefined');
if (false) { var x = 42; }
if (true)  { var y = 87; }
assertTrue(!x && typeof x == 'undefined');
assertEquals(87, y);

assertTrue(!z && typeof z == 'undefined');
if (false) { var z; }
assertTrue(!z && typeof z == 'undefined');

assertThrows("var \u2E2F;", SyntaxError);
assertThrows("var \\u2E2F;", SyntaxError);

assertDoesNotThrow("var \u2118;");
assertDoesNotThrow("var \\u2118;");
assertDoesNotThrow("var \u212E;");
assertDoesNotThrow("var \\u212E;");
assertDoesNotThrow("var \u309B;");
assertDoesNotThrow("var \\u309B;");
assertDoesNotThrow("var \u309C;");
assertDoesNotThrow("var \\u309C;");

assertDoesNotThrow("var $\u00B7;");
assertDoesNotThrow("var $\u0387;");
assertDoesNotThrow("var $\u1369;");
assertDoesNotThrow("var $\u1370;");
assertDoesNotThrow("var $\u1371;");
assertDoesNotThrow("var $\u19DA;");
                                                             node-23.7.0/deps/v8/test/mjsunit/verify-assert-false.js                                             0000664 0000000 0000000 00000003170 14746647661 0022747 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --expose-trigger-failure

triggerAssertFalse();
                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/verify-check-false.js                                              0000664 0000000 0000000 00000003167 14746647661 0022531 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//     * Neither the name of Google Inc. nor the names of its
//       contributors may be used to endorse or promote products derived
//       from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

// Flags: --expose-trigger-failure

triggerCheckFalse();
                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/verify-no-fail.js                                                  0000664 0000000 0000000 00000000320 14746647661 0021675 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --no-fail

assertTrue(false);
                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/wasm/                                                              0000775 0000000 0000000 00000000000 14746647661 0017464 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/wasm/OWNERS                                                        0000664 0000000 0000000 00000000036 14746647661 0020423 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        file:../../../src/wasm/OWNERS
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/wasm/adapter-frame.js                                              0000664 0000000 0000000 00000020706 14746647661 0022537 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

const JS = false;  // for testing the tests.
const WRONG1 = 0x0DEDFACE;
const WRONG2 = 0x0DEDBABE;
const WRONG3 = 0x0DEDD011

function makeSelect(type, args, which) {
  if (JS) {
    // For testing the tests.
    return function() {
      var val = +arguments[which];
      print("  " + val);
      if (type == kWasmI32) return val | 0;
      if (type == kWasmF32) return Math.fround(val);
      if (type == kWasmF64) return val;
      return undefined;
    }
  }

  var builder = new WasmModuleBuilder();
  var params = [];
  for (var i = 0; i < args; i++) params.push(type);
  builder.addFunction("select", makeSig(params, [type]))
    .addBody([kExprLocalGet, which])
    .exportFunc();

  return builder.instantiate().exports.select;
}

const inputs = [
  -1, 0, 2.2, 3.3, 3000.11, Infinity, -Infinity, NaN
];

(function TestInt1() {
  print("i32 1(0)...");
  var C = function(v) { return v | 0; }
  var select1 = makeSelect(kWasmI32, 1, 0);

  for (val of inputs) {
    assertEquals(C(val), select1(val));

    // under args
    assertEquals(C(undefined), select1());
    // over args
    assertEquals(C(val), select1(val, WRONG1));
    assertEquals(C(val), select1(val, WRONG1, WRONG2));
  }
})();

(function TestInt2() {
  print("i32 2(0)...");
  var C = function(v) { return v | 0; }
  var select = makeSelect(kWasmI32, 2, 0);

  for (val of inputs) {
    assertEquals(C(val), select(val, WRONG1));

    // under args
    assertEquals(C(undefined), select());
    assertEquals(C(val), select(val));
    // over args
    assertEquals(C(val), select(val, WRONG1, WRONG2));
    assertEquals(C(val), select(val, WRONG1, WRONG2, WRONG3));
  }

  print("i32 2(1)...");
  var select = makeSelect(kWasmI32, 2, 1);

  for (val of inputs) {
    assertEquals(C(val), select(WRONG1, val));

    // under args
    assertEquals(C(undefined), select());
    assertEquals(C(undefined), select(val));
    // over args
    assertEquals(C(val), select(WRONG1, val));
    assertEquals(C(val), select(WRONG1, val, WRONG2));
    assertEquals(C(val), select(WRONG1, val, WRONG2, WRONG3));
  }
})();

(function TestInt3() {
  print("i32 3(0)...");
  var C = function(v) { return v | 0; }
  var select = makeSelect(kWasmI32, 3, 0);

  for (val of inputs) {
    assertEquals(C(val), select(val, WRONG1, WRONG2));

    // under args
    assertEquals(C(undefined), select());
    assertEquals(C(val), select(val));
    assertEquals(C(val), select(val, WRONG1));
    // over args
    assertEquals(C(val), select(val, WRONG1, WRONG2, WRONG3));
  }

  print("i32 3(1)...");
  var select = makeSelect(kWasmI32, 3, 1);

  for (val of inputs) {
    assertEquals(val | 0, select(WRONG1, val, WRONG2));

    // under args
    assertEquals(C(undefined), select());
    assertEquals(C(undefined), select(0xDEDFACE));
    assertEquals(C(val), select(WRONG1, val));
    // over args
    assertEquals(C(val), select(WRONG1, val, WRONG2, WRONG3));
  }

  print("i32 3(2)...");
  var select = makeSelect(kWasmI32, 3, 2);

  for (val of inputs) {
    assertEquals(C(val), select(WRONG1, WRONG2, val));

    // under args
    assertEquals(C(undefined), select());
    assertEquals(C(undefined), select(0xDEDFACE));
    assertEquals(C(undefined), select(WRONG1, WRONG2));
    // over args
    assertEquals(C(val), select(WRONG1, WRONG2, val, WRONG3));
  }
})();

(function TestFloat32_1() {
  print("f32 1(0)...");
  var C = function(v) { return Math.fround(v); }
  var select1 = makeSelect(kWasmF32, 1, 0);

  for (val of inputs) {
    assertEquals(C(val), select1(val));

    // under args
    assertEquals(C(undefined), select1());
    // over args
    assertEquals(C(val), select1(val, WRONG1));
    assertEquals(C(val), select1(val, WRONG1, WRONG2));
  }
})();

(function TestFloat32_2() {
  print("f32 2(0)...");
  var C = function(v) { return Math.fround(v); }
  var select = makeSelect(kWasmF32, 2, 0);

  for (val of inputs) {
    assertEquals(C(val), select(val, WRONG1));

    // under args
    assertEquals(C(undefined), select());
    assertEquals(C(val), select(val));
    // over args
    assertEquals(C(val), select(val, WRONG1, WRONG2));
    assertEquals(C(val), select(val, WRONG1, WRONG2, WRONG3));
  }

  print("f32 2(1)...");
  var select = makeSelect(kWasmF32, 2, 1);

  for (val of inputs) {
    assertEquals(C(val), select(WRONG1, val));

    // under args
    assertEquals(C(undefined), select());
    assertEquals(C(undefined), select(val));
    // over args
    assertEquals(C(val), select(WRONG1, val));
    assertEquals(C(val), select(WRONG1, val, WRONG2));
    assertEquals(C(val), select(WRONG1, val, WRONG2, WRONG3));
  }
})();

(function TestFloat32_2() {
  print("f32 3(0)...");
  var C = function(v) { return Math.fround(v); }
  var select = makeSelect(kWasmF32, 3, 0);

  for (val of inputs) {
    assertEquals(C(val), select(val, WRONG1, WRONG2));

    // under args
    assertEquals(C(undefined), select());
    assertEquals(C(val), select(val));
    assertEquals(C(val), select(val, WRONG1));
    // over args
    assertEquals(C(val), select(val, WRONG1, WRONG2, WRONG3));
  }

  print("f32 3(1)...");
  var select = makeSelect(kWasmF32, 3, 1);

  for (val of inputs) {
    assertEquals(C(val), select(WRONG1, val, WRONG2));

    // under args
    assertEquals(C(undefined), select());
    assertEquals(C(undefined), select(0xDEDFACE));
    assertEquals(C(val), select(WRONG1, val));
    // over args
    assertEquals(C(val), select(WRONG1, val, WRONG2, WRONG3));
  }

  print("f32 3(2)...");
  var select = makeSelect(kWasmF32, 3, 2);

  for (val of inputs) {
    assertEquals(C(val), select(WRONG1, WRONG2, val));

    // under args
    assertEquals(C(undefined), select());
    assertEquals(C(undefined), select(0xDEDFACE));
    assertEquals(C(undefined), select(WRONG1, WRONG2));
    // over args
    assertEquals(C(val), select(WRONG1, WRONG2, val, WRONG3));
  }
})();


(function TestFloat64_1() {
  print("f64 1(0)...");
  var C = function(v) { return +v; }
  var select1 = makeSelect(kWasmF64, 1, 0);

  for (val of inputs) {
    assertEquals(C(val), select1(val));

    // under args
    assertEquals(C(undefined), select1());
    // over args
    assertEquals(C(val), select1(val, WRONG1));
    assertEquals(C(val), select1(val, WRONG1, WRONG2));
  }
})();

(function TestFloat64_2() {
  print("f64 2(0)...");
  var C = function(v) { return +v; }
  var select = makeSelect(kWasmF64, 2, 0);

  for (val of inputs) {
    assertEquals(C(val), select(val, WRONG1));

    // under args
    assertEquals(C(undefined), select());
    assertEquals(C(val), select(val));
    // over args
    assertEquals(C(val), select(val, WRONG1, WRONG2));
    assertEquals(C(val), select(val, WRONG1, WRONG2, WRONG3));
  }

  print("f64 2(1)...");
  var select = makeSelect(kWasmF64, 2, 1);

  for (val of inputs) {
    assertEquals(C(val), select(WRONG1, val));

    // under args
    assertEquals(C(undefined), select());
    assertEquals(C(undefined), select(val));
    // over args
    assertEquals(C(val), select(WRONG1, val));
    assertEquals(C(val), select(WRONG1, val, WRONG2));
    assertEquals(C(val), select(WRONG1, val, WRONG2, WRONG3));
  }
})();

(function TestFloat64_2() {
  print("f64 3(0)...");
  var C = function(v) { return +v; }
  var select = makeSelect(kWasmF64, 3, 0);

  for (val of inputs) {
    assertEquals(C(val), select(val, WRONG1, WRONG2));

    // under args
    assertEquals(C(undefined), select());
    assertEquals(C(val), select(val));
    assertEquals(C(val), select(val, WRONG1));
    // over args
    assertEquals(C(val), select(val, WRONG1, WRONG2, WRONG3));
  }

  print("f64 3(1)...");
  var select = makeSelect(kWasmF64, 3, 1);

  for (val of inputs) {
    assertEquals(C(val), select(WRONG1, val, WRONG2));

    // under args
    assertEquals(C(undefined), select());
    assertEquals(C(undefined), select(0xDEDFACE));
    assertEquals(C(val), select(WRONG1, val));
    // over args
    assertEquals(C(val), select(WRONG1, val, WRONG2, WRONG3));
  }

  print("f64 3(2)...");
  var select = makeSelect(kWasmF64, 3, 2);

  for (val of inputs) {
    assertEquals(C(val), select(WRONG1, WRONG2, val));

    // under args
    assertEquals(C(undefined), select());
    assertEquals(C(undefined), select(0xDEDFACE));
    assertEquals(C(undefined), select(WRONG1, WRONG2));
    // over args
    assertEquals(C(val), select(WRONG1, WRONG2, val, WRONG3));
  }
})();
                                                          node-23.7.0/deps/v8/test/mjsunit/wasm/add-getters.js                                                0000664 0000000 0000000 00000004263 14746647661 0022232 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function testAddGetter(object, name, val) {
  Object.defineProperty(object, name, { get: function() { return val; } });
  assertSame(val, object[name]);
}

function testAddGetterFails(object, name, val) {
  function assign() {
    Object.defineProperty(object, name, { get: function() { return val; } });
  }
  assertThrows(assign, TypeError);
}

function testAddGetterBothWays(object, name, val) {
  print("Object.defineProperty");
  Object.defineProperty(object, name, { get: function() { return val; } });
  print("object.__defineGetter__");
  object.__defineGetter__(name, () => val);
  assertSame(val, object[name]);
}

function testFailToAddGetter(object, name, val) {
  assertThrows(() => Object.defineProperty(object, name, { get: function() { return val; } }));
}

testAddGetter(testAddGetter, "name", 11);

function makeBuilder() {
  var builder = new WasmModuleBuilder();

  builder.addFunction("f", kSig_v_v)
    .addBody([])
    .exportFunc();
  return builder;
}

(function TestAddGetterToFunction() {
  print("TestAddGetterToFunction...");
  var builder = makeBuilder();
  var f = builder.instantiate().exports.f;
  testAddGetterBothWays(f, "name", "foo");
  testAddGetter(f, "blam", "baz");
})();

(function TestAddGetterToModule() {
  print("TestAddGetterToModule...");
  var builder = makeBuilder();
  var module = new WebAssembly.Module(builder.toBuffer());
  testAddGetter(module, "exports", 290);
  testAddGetter(module, "xyz", new Object());
})();

(function TestAddGetterToInstance() {
  print("TestAddGetterToInstance...");
  var builder = makeBuilder();
  var instance = builder.instantiate();
  testAddGetter(instance, "exports", 290);
  testAddGetter(instance, "xyz", new Object());
})();

(function TestAddGetterToExports() {
  print("TestAddGetterToExports...");
  var builder = makeBuilder();
  var exports = builder.instantiate().exports;
  testFailToAddGetter(exports, "f", 9834);
  testAddGetterFails(exports, "nag", new Number(2));
})();
                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/anyfunc.js                                                    0000664 0000000 0000000 00000015746 14746647661 0021502 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --expose-gc

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function testAnyFuncIdentityFunction() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.addFunction('main', kSig_a_a)
      .addBody([kExprLocalGet, 0])
      .exportFunc();

  const instance = builder.instantiate();

  assertThrows(() => instance.exports.main(print), TypeError);
  assertThrows(() => instance.exports.main({'hello': 'world'}), TypeError);
  assertSame(
      instance.exports.main, instance.exports.main(instance.exports.main));
})();

(function testPassAnyFuncToImportedFunction() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const sig_index = builder.addType(kSig_v_a);
  const imp_index = builder.addImport('q', 'func', sig_index);
  builder.addFunction('main', sig_index)
      .addBody([kExprLocalGet, 0, kExprCallFunction, imp_index])
      .exportFunc();

  const main = builder.instantiate({q: {func: checkFunction}}).exports.main;

  function checkFunction(value) {
    assertSame(main, value);
  }

  main(main);
})();

(function testPassAnyFuncWithGCWithLocals() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const ref_sig = builder.addType(kSig_v_a);
  const void_sig = builder.addType(kSig_v_v);
  const imp_index = builder.addImport('q', 'func', ref_sig);
  const gc_index = builder.addImport('q', 'gc', void_sig);
  // First call the gc, then check if the object still exists.
  builder.addFunction('main', ref_sig)
      .addLocals(kWasmAnyFunc, 10)
      .addBody([
        kExprLocalGet,     0,
        kExprLocalSet,     1,  // Set local
        kExprLocalGet,     0,
        kExprLocalSet,     2,  // Set local
        kExprLocalGet,     0,
        kExprLocalSet,     3,  // Set local
        kExprLocalGet,     0,
        kExprLocalSet,     4,  // Set local
        kExprLocalGet,     0,
        kExprLocalSet,     5,  // Set local
        kExprLocalGet,     0,
        kExprLocalSet,     6,  // Set local
        kExprLocalGet,     0,
        kExprLocalSet,     7,  // Set local
        kExprLocalGet,     0,
        kExprLocalSet,     8,  // Set local
        kExprLocalGet,     0,
        kExprLocalSet,     9,  // Set local
        kExprLocalGet,     0,
        kExprLocalSet,     10,        // Set local
        kExprCallFunction, gc_index,  // call gc
        kExprLocalGet,     9,
        kExprCallFunction, imp_index  // call import
      ])
      .exportFunc();

  const main =
      builder.instantiate({q: {func: checkFunction, gc: gc}}).exports.main;

  function checkFunction(value) {
    assertSame(main, value);
  }

  main(main);
})();

(function testPassAnyFuncWithGC() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const ref_sig = builder.addType(kSig_v_a);
  const void_sig = builder.addType(kSig_v_v);
  const imp_index = builder.addImport('q', 'func', ref_sig);
  const gc_index = builder.addImport('q', 'gc', void_sig);
  // First call the gc, then check if the object still exists.
  builder.addFunction('main', ref_sig)
      .addBody([
        kExprCallFunction, gc_index,                    // call gc
        kExprLocalGet, 0, kExprCallFunction, imp_index  // call import
      ])
      .exportFunc();

  function checkFunction(value) {
    assertSame(main, value);
  }

  const main =
      builder.instantiate({q: {func: checkFunction, gc: gc}}).exports.main;

  main(main);
})();

(function testPassAnyFuncWithGCInWrapper() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const kSig_a_iai =
      makeSig([kWasmI32, kWasmAnyFunc, kWasmI32], [kWasmAnyFunc]);
  const sig_index = builder.addType(kSig_a_iai);
  builder.addFunction('main', sig_index)
      .addBody([kExprLocalGet, 1])
      .exportFunc();

  const main = builder.instantiate().exports.main;

  const triggerGCParam = {
    valueOf: () => {
      gc();
      return 17;
    }
  };

  const result = main(triggerGCParam, main, triggerGCParam);
  assertSame(main, result);
})();

(function testAnyFuncDefaultValue() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const sig_index = builder.addType(kSig_a_v);
  builder.addFunction('main', sig_index)
      .addLocals(kWasmAnyFunc, 1)
      .addBody([kExprLocalGet, 0])
      .exportFunc();

  const main = builder.instantiate().exports.main;
  assertEquals(null, main());
})();

(function testAssignNullToAnyFuncLocal() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const sig_index = builder.addType(kSig_a_a);
  builder.addFunction('main', sig_index)
      .addBody([kExprRefNull, kAnyFuncCode, kExprLocalSet, 0, kExprLocalGet, 0])
      .exportFunc();

  const main = builder.instantiate().exports.main;
  assertEquals(null, main(main));
})();

(function testImplicitReturnNullAsAnyFunc() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const sig_index = builder.addType(kSig_a_v);
  builder.addFunction('main', sig_index)
      .addBody([kExprRefNull, kAnyFuncCode])
      .exportFunc();

  const main = builder.instantiate().exports.main;
  assertEquals(null, main());
})();

(function testExplicitReturnNullAsAnyFunc() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const sig_index = builder.addType(kSig_a_v);
  builder.addFunction('main', sig_index)
      .addBody([kExprRefNull, kAnyFuncCode, kExprReturn])
      .exportFunc();

  const main = builder.instantiate().exports.main;
  assertEquals(null, main());
})();

(function testRefFuncOutOfBounds() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.addFunction('main', kSig_a_v).addBody([kExprRefFunc, 10]);

  assertThrows(() => builder.toModule(), WebAssembly.CompileError);
})();

(function testRefFuncIsCallable() {
  print(arguments.callee.name);
  const expected = 54;
  const builder = new WasmModuleBuilder();
  const function_index = builder.addFunction('hidden', kSig_i_v)
                             .addBody([kExprI32Const, expected])
                             .index;
  builder.addDeclarativeElementSegment([function_index]);
  builder.addFunction('main', kSig_a_v)
      .addBody([kExprRefFunc, function_index])
      .exportFunc();

  const instance = builder.instantiate();
  assertEquals(expected, instance.exports.main()());
})();

(function testRefFuncPreservesIdentity() {
  print(arguments.callee.name);
  const expected = 54;
  const builder = new WasmModuleBuilder();
  const foo = builder.addFunction('foo', kSig_i_v)
                  .addBody([kExprI32Const, expected])
                  .exportFunc();
  builder.addDeclarativeElementSegment([foo.index]);
  builder.addFunction('main', kSig_a_v)
      .addBody([kExprRefFunc, foo.index])
      .exportFunc();

  const instance = builder.instantiate();
  assertSame(instance.exports.foo, instance.exports.main());
})();
                          node-23.7.0/deps/v8/test/mjsunit/wasm/array-bulk-operations.js                                      0000664 0000000 0000000 00000042232 14746647661 0024257 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestArrayFillImmutable() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let array = builder.addArray(kWasmI32, false);

  // Parameters: array, starting index, value, length.
  builder.addFunction(
      "array_fill",
      makeSig([wasmRefNullType(array), kWasmI32, kWasmI32, kWasmI32], []))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1,
              kExprLocalGet, 2, kExprLocalGet, 3,
              kGCPrefix, kExprArrayFill, array])
    .exportFunc();

  assertThrows(() => builder.instantiate(), WebAssembly.CompileError,
               /immediate array type #0 is immutable/);
})();

(function TestArrayFill() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let struct = builder.addStruct([makeField(kWasmI32, true)]);
  let array = builder.addArray(wasmRefNullType(struct), true);
  let array16 = builder.addArray(kWasmI16, true);

  builder.addFunction(
      "make_array", makeSig([kWasmI32], [wasmRefType(array)]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprArrayNewDefault, array])
    .exportFunc();

  builder.addFunction(
      "array_get", makeSig([wasmRefNullType(array), kWasmI32], [kWasmI32]))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1,
              kGCPrefix, kExprArrayGet, array,
              kGCPrefix, kExprStructGet, struct, 0])
    .exportFunc();

  // Parameters: array, starting index, value in struct, length.
  builder.addFunction(
      "array_fill",
      makeSig([wasmRefNullType(array), kWasmI32, kWasmI32, kWasmI32], []))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1,
              kExprLocalGet, 2, kGCPrefix, kExprStructNew, struct,
              kExprLocalGet, 3, kGCPrefix, kExprArrayFill, array])
    .exportFunc();

  builder.addFunction("array_fill_i16", kSig_i_v).exportFunc()
    .addLocals(wasmRefType(array16), 1)
    .addBody([
      kExprI32Const, 4,  // Array length for allocation.
      kGCPrefix, kExprArrayNewDefault, array16,
      kExprLocalTee, 0,  // Array (for fill).
      kExprI32Const, 0,  // Offset (for fill).
      kExprI32Const, 42,  // Value (for fill).
      kExprI32Const, 4,  // Length (for fill).
      kGCPrefix, kExprArrayFill, array16,
      kExprLocalGet, 0,  // Array (for get).
      kExprI32Const, 0,  // Index (for get).
      kGCPrefix, kExprArrayGetS, array16,
    ]);

  let wasm = builder.instantiate().exports;

  assertTraps(kTrapNullDereference, () => wasm.array_fill(null, 10, 20, 30));

  let array_obj = wasm.make_array(8);

  assertTraps(kTrapArrayOutOfBounds,
              () => wasm.array_fill(array_obj, 5, 42, 4));
  // Out-of-bounds array.fill traps even if length is 0, if the index is greater
  // than array.len.
  assertTraps(kTrapArrayOutOfBounds,
              () => wasm.array_fill(array_obj, 10, 42, 0));
  // Overflow of (index + length) traps.
  assertTraps(kTrapArrayOutOfBounds,
              () => wasm.array_fill(array_obj, 5, 42, -1));

  wasm.array_fill(array_obj, 2, 42, 3);
  assertTraps(kTrapNullDereference, () => wasm.array_get(array_obj, 0));
  assertTraps(kTrapNullDereference, () => wasm.array_get(array_obj, 1));
  assertEquals(42, wasm.array_get(array_obj, 2));
  assertEquals(42, wasm.array_get(array_obj, 3));
  assertEquals(42, wasm.array_get(array_obj, 4));
  assertTraps(kTrapNullDereference, () => wasm.array_get(array_obj, 5));
  assertTraps(kTrapNullDereference, () => wasm.array_get(array_obj, 6));
  assertTraps(kTrapNullDereference, () => wasm.array_get(array_obj, 7));

  // Index = array.len and length = 0 works, it just does nothing.
  wasm.array_fill(array_obj, 8, 42, 0)

  wasm.array_fill(array_obj, 4, 54, 2);
  assertTraps(kTrapNullDereference, () => wasm.array_get(array_obj, 0));
  assertTraps(kTrapNullDereference, () => wasm.array_get(array_obj, 1));
  assertEquals(42, wasm.array_get(array_obj, 2));
  assertEquals(42, wasm.array_get(array_obj, 3));
  assertEquals(54, wasm.array_get(array_obj, 4));
  assertEquals(54, wasm.array_get(array_obj, 5));
  assertTraps(kTrapNullDereference, () => wasm.array_get(array_obj, 6));
  assertTraps(kTrapNullDereference, () => wasm.array_get(array_obj, 7));

  assertEquals(42, wasm.array_fill_i16());
})();

(function TestArrayNewNonNullable() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let struct = builder.addStruct([makeField(kWasmI32, true)]);
  let array = builder.addArray(wasmRefType(struct), true);

  builder.addFunction(
      "make_array", makeSig([wasmRefType(struct), kWasmI32],
                            [wasmRefType(array)]))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1,
              kGCPrefix, kExprArrayNew, array])
    .exportFunc();

  builder.addFunction(
      "array_get", makeSig([wasmRefNullType(array), kWasmI32],
                           [wasmRefType(struct)]))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1,
              kGCPrefix, kExprArrayGet, array])
    .exportFunc();

  builder.addFunction(
      "make_struct", makeSig([], [wasmRefType(struct)]))
    .addBody([kGCPrefix, kExprStructNewDefault, struct])
    .exportFunc();

  let wasm = builder.instantiate().exports;

  let length = 50;  // Enough to go through initialization builtin.
  let struct_obj = wasm.make_struct();
  let array_obj = wasm.make_array(struct_obj, length);

  for (let i = 0; i < length; i++) {
    assertEquals(struct_obj, wasm.array_get(array_obj, i));
  }
})();

(function TestArrayInitData() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let array = builder.addArray(kWasmI16, true);

  builder.addMemory(10, 10);

  let passive = builder.addPassiveDataSegment([0, 1, 2, 3, 4, 5]);
  let active = builder.addActiveDataSegment(0, [kExprI32Const, 0],
                                            [6, 7, 8, 9]);

  builder.addFunction(
      "make_array", makeSig([kWasmI32], [wasmRefType(array)]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprArrayNewDefault, array])
    .exportFunc();

  builder.addFunction(
      "init_passive",
      makeSig([wasmRefNullType(array), kWasmI32, kWasmI32, kWasmI32], []))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprLocalGet, 2,
              kExprLocalGet, 3, kGCPrefix, kExprArrayInitData, array, passive])
    .exportFunc();

  builder.addFunction(
      "init_active",
      makeSig([wasmRefNullType(array), kWasmI32, kWasmI32, kWasmI32], []))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprLocalGet, 2,
              kExprLocalGet, 3, kGCPrefix, kExprArrayInitData, array, active])
    .exportFunc();

  builder.addFunction(
      "array_get", makeSig([wasmRefNullType(array), kWasmI32], [kWasmI32]))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1,
              kGCPrefix, kExprArrayGetS, array])
    .exportFunc();

  builder.addFunction("data_drop", kSig_v_v)
    .addBody([kNumericPrefix, kExprDataDrop, passive])
    .exportFunc();

  let wasm = builder.instantiate().exports;

  let array_length = 10;

  assertTraps(kTrapNullDereference, () => wasm.init_passive(null, 0, 0, 0));

  let array_obj = wasm.make_array(array_length);

  for (i = 0; i < array_length; i++) {
    assertEquals(0, wasm.array_get(array_obj, i));
  }

  // Does nothing.
  wasm.init_active(array_obj, 0, 0, 0);
  // Active segments count as dropped.
  assertTraps(kTrapDataSegmentOutOfBounds,
              () => wasm.init_active(array_obj, 0, 0, 1));
  // Loading 0 bytes from the end of data segment does nothing.
  wasm.init_passive(array_obj, 0, 6, 0);
  // Loading 0 bytes to the end of the array does nothing.
  wasm.init_passive(array_obj, array_length, 0, 0);
  // Loading 0 bytes beyond the end of data segment traps.
  assertTraps(kTrapDataSegmentOutOfBounds,
              () => wasm.init_passive(array_obj, 0, 7, 0));
  // Loading 0 bytes beyond the end of array traps.
  assertTraps(kTrapArrayOutOfBounds,
              () => wasm.init_passive(array_obj, array_length + 1, 1, 1));

  // Out-of-bounds data segment.
  assertTraps(kTrapDataSegmentOutOfBounds,
              () => wasm.init_passive(array_obj, 1, 2, 3));
  // Out-of-bounds data segment with out-of-smi-range segment offset.
  assertTraps(kTrapDataSegmentOutOfBounds,
              () => wasm.init_passive(array_obj, 1, 0x80000000, 0));
  // Out-of-bounds array.
  assertTraps(kTrapArrayOutOfBounds,
              () => wasm.init_passive(array_obj, array_length - 1, 0, 2));
  // Out-of-bounds array with out-of-smi-range length.
  assertTraps(kTrapArrayOutOfBounds,
              () => wasm.init_passive(array_obj, 0, 0, 0x80000000));

  // Load [[1, 2], [3, 4]] at index 5 of array.
  wasm.init_passive(array_obj, 5, 1, 2);

  assertEquals(0, wasm.array_get(array_obj, 0));
  assertEquals(0, wasm.array_get(array_obj, 1));
  assertEquals(0, wasm.array_get(array_obj, 2));
  assertEquals(0, wasm.array_get(array_obj, 3));
  assertEquals(0, wasm.array_get(array_obj, 4));
  // Bytes will be loaded in little-endian order.
  assertEquals(0x0201, wasm.array_get(array_obj, 5));
  assertEquals(0x0403, wasm.array_get(array_obj, 6));
  assertEquals(0, wasm.array_get(array_obj, 7));
  assertEquals(0, wasm.array_get(array_obj, 8));
  assertEquals(0, wasm.array_get(array_obj, 9));

  // Now drop the segment.
  wasm.data_drop();
  assertTraps(kTrapDataSegmentOutOfBounds,
              () => wasm.init_passive(array_obj, 5, 1, 2));
})();

(function TestArrayInitDataLengthOverflow() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let array = builder.addArray(kWasmI64, true);

  let passive = builder.addPassiveDataSegment([0, 1, 2, 3, 4, 5]);

  builder.addFunction(
      "make_array", makeSig([kWasmI32], [wasmRefType(array)]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprArrayNewDefault, array])
    .exportFunc();

  builder.addFunction(
      "init_passive",
      makeSig([wasmRefNullType(array), kWasmI32, kWasmI32, kWasmI32], []))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprLocalGet, 2,
              kExprLocalGet, 3, kGCPrefix, kExprArrayInitData, array, passive])
    .exportFunc();

  let wasm = builder.instantiate().exports;

  let array_length = 10;

  let array_obj = wasm.make_array(array_length);

  // Out-of-bounds array: length is within Smi range, but computation of length
  // in bytes causes 32-bit overflow.
  assertTraps(kTrapArrayOutOfBounds,
              () => wasm.init_passive(array_obj, array_length - 1, 0,
                                      0x20000000));
})();

(function TestArrayInitDataImmutable() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let array = builder.addArray(kWasmI16, false);

  let passive = builder.addPassiveDataSegment([0, 1, 2, 3, 4, 5]);

  builder.addFunction(
      "init_passive",
      makeSig([wasmRefNullType(array), kWasmI32, kWasmI32, kWasmI32], []))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprLocalGet, 2,
              kExprLocalGet, 3, kGCPrefix, kExprArrayInitData, array, passive])
    .exportFunc();

  assertThrows(() => builder.instantiate(), WebAssembly.CompileError,
               /array.init_data can only be used with mutable arrays/);
})();

(function TestArrayInitElem() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let sig = builder.addType(kSig_i_i);
  let array = builder.addArray(wasmRefNullType(sig), true);

  let table = builder.addTable(wasmRefNullType(sig), 10, 10);

  let elem1 = builder.addFunction("succ", kSig_i_i)
      .addBody([kExprLocalGet, 0, kExprI32Const, 1, kExprI32Add]);
  let elem2 = builder.addFunction("pred", kSig_i_i)
      .addBody([kExprLocalGet, 0, kExprI32Const, 1, kExprI32Sub]);

  let passive = builder.addPassiveElementSegment(
    [[kExprRefNull, sig], [kExprRefFunc, elem1.index],
     [kExprRefFunc, elem2.index], [kExprRefFunc, elem1.index]],
    wasmRefNullType(sig));
  let active = builder.addActiveElementSegment(
    table, [kExprI32Const, 0], [[kExprRefFunc, elem1.index]],
    wasmRefNullType(sig));

  builder.addFunction(
      "make_array", makeSig([kWasmI32], [wasmRefType(array)]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprArrayNewDefault, array])
    .exportFunc();

  builder.addFunction(
      "init_passive",
      makeSig([wasmRefNullType(array), kWasmI32, kWasmI32, kWasmI32], []))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprLocalGet, 2,
              kExprLocalGet, 3, kGCPrefix, kExprArrayInitElem, array, passive])
    .exportFunc();

  builder.addFunction(
      "init_active",
      makeSig([wasmRefNullType(array), kWasmI32, kWasmI32, kWasmI32], []))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprLocalGet, 2,
              kExprLocalGet, 3, kGCPrefix, kExprArrayInitElem, array, active])
    .exportFunc();

  builder.addFunction(
      "array_get", makeSig([wasmRefNullType(array), kWasmI32],
                           [wasmRefNullType(sig)]))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1,
              kGCPrefix, kExprArrayGet, array])
    .exportFunc();

  builder.addFunction("elem_drop", kSig_v_v)
    .addBody([kNumericPrefix, kExprElemDrop, passive])
    .exportFunc();

  let wasm = builder.instantiate().exports;

  let array_length = 10;

  assertTraps(kTrapNullDereference, () => wasm.init_passive(null, 0, 0, 0));

  let array_obj = wasm.make_array(array_length);

  for (i = 0; i < array_length; i++) {
    assertEquals(null, wasm.array_get(array_obj, i));
  }

  // Does nothing.
  wasm.init_active(array_obj, 0, 0, 0);
  // Active segments count as dropped.
  assertTraps(kTrapElementSegmentOutOfBounds,
              () => wasm.init_active(array_obj, 0, 0, 1));
  // Loading 0 elements from the end of element segment does nothing.
  wasm.init_passive(array_obj, 0, 4, 0);
  // Loading 0 elements to the end of the array does nothing.
  wasm.init_passive(array_obj, array_length, 0, 0);
  // Loading 0 elements beyond the end of data segment traps.
  assertTraps(kTrapElementSegmentOutOfBounds,
              () => wasm.init_passive(array_obj, 0, 5, 0));
  // Loading 0 elements beyond the end of array traps.
  assertTraps(kTrapArrayOutOfBounds,
              () => wasm.init_passive(array_obj, array_length + 1, 1, 1));

  // Out-of-bounds element segment.
  assertTraps(kTrapElementSegmentOutOfBounds,
              () => wasm.init_passive(array_obj, 1, 2, 3));
  // Out-of-bounds element segment with out-of-smi-bounds segment offset.
  assertTraps(kTrapElementSegmentOutOfBounds,
              () => wasm.init_passive(array_obj, 1, 0x80000000, 0));
  // Out-of-bounds array.
  assertTraps(kTrapArrayOutOfBounds,
              () => wasm.init_passive(array_obj, array_length - 1, 0, 2));
  // Out-of-bounds array with out-of-smi-bounds length
  assertTraps(kTrapArrayOutOfBounds,
              () => wasm.init_passive(array_obj, array_length - 1, 0,
                                      0x80000000));

  // Load the last three elements of the element segment at index 5.
  wasm.init_passive(array_obj, 5, 1, 3);

  assertEquals(null, wasm.array_get(array_obj, 0));
  assertEquals(null, wasm.array_get(array_obj, 1));
  assertEquals(null, wasm.array_get(array_obj, 2));
  assertEquals(null, wasm.array_get(array_obj, 3));
  assertEquals(null, wasm.array_get(array_obj, 4));
  assertEquals(11, wasm.array_get(array_obj, 5)(10));
  assertEquals(9, wasm.array_get(array_obj, 6)(10));
  assertEquals(11, wasm.array_get(array_obj, 7)(10));
  assertEquals(null, wasm.array_get(array_obj, 8));
  assertEquals(null, wasm.array_get(array_obj, 9));

  // Now drop the segment.
  wasm.elem_drop();
  assertTraps(kTrapElementSegmentOutOfBounds,
              () => wasm.init_passive(array_obj, 5, 1, 3));
})();

(function TestArrayInitElemImmutable() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let array = builder.addArray(kWasmFuncRef, false);

  let elem1 = builder.addFunction("succ", kSig_i_i)
      .addBody([kExprLocalGet, 0, kExprI32Const, 1, kExprI32Add]);
  let elem2 = builder.addFunction("pred", kSig_i_i)
      .addBody([kExprLocalGet, 0, kExprI32Const, 1, kExprI32Sub]);

  let passive = builder.addPassiveDataSegment([elem1.index, elem2.index,
                                               elem1.index, elem2.index]);

  builder.addFunction(
      "init_passive",
      makeSig([wasmRefNullType(array), kWasmI32, kWasmI32, kWasmI32], []))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprLocalGet, 2,
              kExprLocalGet, 3, kGCPrefix, kExprArrayInitElem, array, passive])
    .exportFunc();

  assertThrows(() => builder.instantiate(), WebAssembly.CompileError,
               /array.init_elem can only be used with mutable arrays/);
})();

(function TestArrayCopyLargeI64Array() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let array = builder.addArray(kWasmI64, true);

  builder.addFunction(
      // initial value, length, index to check
      "main", makeSig([kWasmI64, kWasmI32, kWasmI32], [kWasmI64]))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1,
              kGCPrefix, kExprArrayNew, array,
              kExprLocalGet, 2, kGCPrefix, kExprArrayGet, array])
    .exportFunc();

  let instance = builder.instantiate();

  assertEquals(1234n, instance.exports.main(1234n, 1000, 0));
  assertEquals(-2345n, instance.exports.main(-2345n, 2000, 1000));
  assertEquals(42n, instance.exports.main(42n, 2000, 1999));
})();
                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/wasm/array-copy-benchmark.js                                       0000664 0000000 0000000 00000015406 14746647661 0024046 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --no-liftoff

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// This is benchmark to investigate at which point it is more efficient to call
// a memcpy-based builtin for array.copy, rather than copying
// element-by-element.
// How to run:
// - Set {iterations} to a high number to get better measurements
// - Change the value of {length} to find point at which the builtin becomes
//   faster.
// - Change {array_type} if you want to test different types.
// Right now, the limit is found to be around 10.
(function ArrayCopyBenchmark() {

  let array_length = 10;
  let iterations = 1;

  var builder = new WasmModuleBuilder();
  let struct_index = builder.addStruct([makeField(kWasmI32, true),
                                        makeField(kWasmI8, false)]);
  // Also try wasmRefNullType(struct_index), other numeric types.
  let array_type = kWasmI32;
  var array_index = builder.addArray(array_type, true);
  var from = builder.addGlobal(wasmRefNullType(array_index), true, false);
  var to = builder.addGlobal(wasmRefNullType(array_index), true, false);

  builder.addFunction("init", kSig_v_v)
    .addBody([
      ...wasmI32Const(array_length),
      kGCPrefix, kExprArrayNewDefault, array_index,
      kExprGlobalSet, from.index,
      ...wasmI32Const(array_length),
      kGCPrefix, kExprArrayNewDefault, array_index,
      kExprGlobalSet, to.index
    ])
    .exportFunc();

  builder.addFunction("array_copy", kSig_v_v)
    .addLocals(kWasmI32, 1)
    .addBody([
      kExprLoop, kWasmVoid,
        kExprGlobalGet, to.index,
        ...wasmI32Const(0),
        kExprGlobalGet, from.index,
        ...wasmI32Const(0),
        ...wasmI32Const(array_length),
        kGCPrefix, kExprArrayCopy, array_index, array_index,
        // Outer loop: run everything {iterations} times.
        kExprLocalGet, 0, kExprI32Const, 1, kExprI32Add, kExprLocalSet, 0,
        kExprLocalGet, 0, ...wasmI32Const(iterations), kExprI32LtS,
        kExprBrIf, 0,
      kExprEnd])
    .exportFunc();

  builder.addFunction("loop_copy", kSig_v_v)
    .addLocals(wasmRefType(array_index), 2)
    .addLocals(kWasmI32, 2)
    .addBody([
      kExprLoop, kWasmVoid,
        ...wasmI32Const(0),
        kExprLocalSet, 2,
        kExprGlobalGet, from.index, kExprRefAsNonNull, kExprLocalSet, 0,
        kExprGlobalGet, to.index, kExprRefAsNonNull, kExprLocalSet, 1,
        kExprLoop, kWasmVoid,
          kExprLocalGet, 1,  // array
          kExprLocalGet, 2,  // index
          // value
          kExprLocalGet, 0, kExprLocalGet, 2,
          kGCPrefix, kExprArrayGet, array_index,
          // array.set
          kGCPrefix, kExprArraySet, array_index,
          // index++
          kExprLocalGet, 2, kExprI32Const, 1, kExprI32Add, kExprLocalSet, 2,
          // if (index < array_length) goto loop;
          kExprLocalGet, 2, ...wasmI32Const(array_length), kExprI32LtU,
          kExprBrIf, 0,
        kExprEnd,
      // Outer loop: run everything {iterations} times.
      kExprLocalGet, 3, kExprI32Const, 3, kExprI32Add, kExprLocalSet, 3,
      kExprLocalGet, 3, ...wasmI32Const(iterations), kExprI32LtS,
      kExprBrIf, 0,
      kExprEnd])
    .exportFunc();

  var instance = builder.instantiate({});

  instance.exports.init();
  print("Array length: " + array_length + ", #iterations: " + iterations);
  {
    let before = Date.now();
    instance.exports.array_copy();
    let after = Date.now();
    print("array.copy: " + (after - before) + "ms");
  }
  {
    let before = Date.now();
    instance.exports.loop_copy();
    let after = Date.now();
    print("loop copy: " + (after - before) + "ms");
  }
})();

// The following two benchmarks measure the efficiency of array allocation.
// Change the three first parameters of each benchmarks to measure different
// array sizes, iterations, and element types.
(function ArrayNewDefaultBenchmark() {
  let array_length = 10;
  let iterations = 1
  let test_object_type = false;

  var builder = new WasmModuleBuilder();
  let struct_index = builder.addStruct([makeField(kWasmI32, true),
                                        makeField(kWasmI8, true)]);
  let array_type = test_object_type ? wasmRefNullType(struct_index) : kWasmI32;
  var array_index = builder.addArray(array_type, true);

  let array_new = builder.addFunction(
      "array_new", makeSig([], [wasmRefNullType(array_index)]))
    .addBody([
      ...wasmI32Const(array_length),
      kGCPrefix, kExprArrayNewDefault, array_index])
    .exportFunc();

  builder.addFunction("loop_array_new", kSig_v_v)
    .addLocals(wasmRefNullType(array_index), 1)
    .addLocals(kWasmI32, 1)
    .addBody([
      kExprLoop, kWasmVoid,
        kExprCallFunction, array_new.index,
        kExprLocalSet, 0,
        kExprLocalGet, 1, kExprI32Const, 1, kExprI32Add, kExprLocalTee, 1,
        ...wasmI32Const(iterations), kExprI32LtS,
        kExprBrIf, 0,
      kExprEnd])
    .exportFunc();

  var instance = builder.instantiate({});

  print(`Type: ${test_object_type ? "object" : "i32"}, array length: ` +
        `${array_length}, #iterations: ${iterations}`);
  let before = Date.now();
  instance.exports.loop_array_new();
  let after = Date.now();
  print(`array.new_default: ${after - before} ms`);
})();

(function ArrayNewBenchmark() {
  let array_length = 10;
  let iterations = 1;
  let test_object_type = true;

  var builder = new WasmModuleBuilder();
  let struct_index = builder.addStruct([makeField(kWasmI32, true),
                                        makeField(kWasmI8, true)]);
  let array_type = test_object_type ? wasmRefNullType(struct_index) : kWasmI32;
  var array_index = builder.addArray(array_type, true);

  let array_new = builder.addFunction(
      "array_new", makeSig([], [wasmRefNullType(array_index)]))
    .addBody([
      ...(test_object_type ? [kGCPrefix, kExprStructNewDefault, struct_index]
                           : wasmI32Const(10)),
      ...wasmI32Const(array_length),
      kGCPrefix, kExprArrayNew, array_index])
    .exportFunc();

  builder.addFunction("loop_array_new", kSig_v_v)
    .addLocals(wasmRefNullType(array_index), 1)
    .addLocals(kWasmI32, 1)
    .addBody([
      kExprLoop, kWasmVoid,
        kExprCallFunction, array_new.index,
        kExprLocalSet, 0,
        kExprLocalGet, 1, kExprI32Const, 1, kExprI32Add, kExprLocalTee, 1,
        ...wasmI32Const(iterations), kExprI32LtS,
        kExprBrIf, 0,
      kExprEnd])
    .exportFunc();

  var instance = builder.instantiate({});

  print(`Type: ${test_object_type ? "object" : "i32"}, array length: ` +
        `${array_length}, #iterations: ${iterations}`);
  let before = Date.now();
  instance.exports.loop_array_new();
  let after = Date.now();
  print(`array.new: ${after - before} ms`);
})();
                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/wasm/array-copy-errors.js                                          0000664 0000000 0000000 00000004737 14746647661 0023435 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");


(function TestArrayCopyErrorReasons() {
  var builder = new WasmModuleBuilder();
  let array = builder.addArray(kWasmI32, true);

  // The array.copy has two different reasons to trap. (null dereference, oob)
  // All compilers should emit the same reason in all cases. Which one doesn't
  // really matter and could be changed in the future, e.g. if it improves
  // generated code.
  builder.addFunction("tgtNullSrcNull", kSig_v_v)
    .addBody([
      kExprRefNull, array,  // target array (nullptr)
      kExprI32Const, 2,     // target index
      kExprRefNull, array,  // source array (nullptr)
      kExprI32Const, 2,     // source index
      kExprI32Const, 2,     // length
      kGCPrefix, kExprArrayCopy, array, array,
  ]).exportFunc();

  builder.addFunction("tgtOobSrcNull", kSig_v_v)
    .addBody([
      kExprI32Const, 4, kGCPrefix, kExprArrayNewDefault, array,  // target array
      kExprI32Const, 42,    // target index (out of bounds)
      kExprRefNull, array,  // source array (nullptr)
      kExprI32Const, 2,     // source index
      kExprI32Const, 2,     // length
      kGCPrefix, kExprArrayCopy, array, array,
  ]).exportFunc();

  builder.addFunction("tgtNullSrcOob", kSig_v_v)
    .addBody([
      kExprRefNull, array,  // target array (nullptr)
      kExprI32Const, 2,     // target index
      kExprI32Const, 4, kGCPrefix, kExprArrayNewDefault, array,  // source array
      kExprI32Const, 42,    // source index (out of bounds)
      kExprI32Const, 2,     // length
      kGCPrefix, kExprArrayCopy, array, array,
  ]).exportFunc();

  builder.addFunction("tgtOobSrcOob", kSig_v_v)
    .addBody([
      kExprI32Const, 4, kGCPrefix, kExprArrayNewDefault, array,  // target array
      kExprI32Const, 42,    // target index (out of bounds)
      kExprI32Const, 4, kGCPrefix, kExprArrayNewDefault, array,  // source array
      kExprI32Const, 42,    // source index (out of bounds)
      kExprI32Const, 2,     // length
      kGCPrefix, kExprArrayCopy, array, array,
  ]).exportFunc();

  let wasm = builder.instantiate().exports;
  assertTraps(kTrapNullDereference, wasm.tgtNullSrcNull);
  assertTraps(kTrapArrayOutOfBounds, wasm.tgtOobSrcNull);
  assertTraps(kTrapNullDereference, wasm.tgtNullSrcOob);
  assertTraps(kTrapArrayOutOfBounds, wasm.tgtOobSrcOob);
})();
                                 node-23.7.0/deps/v8/test/mjsunit/wasm/array-init-from-segment.js                                    0000664 0000000 0000000 00000035200 14746647661 0024502 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestArrayNewElem() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct_type_index = builder.addStruct([makeField(kWasmI32, false)]);
  let struct_type = wasmRefNullType(struct_type_index);
  let array_type_index = builder.addArray(struct_type, true);

  function makeStruct(element) {
    return [...wasmI32Const(element),
            kGCPrefix, kExprStructNew, struct_type_index];
  }

  let table = builder.addTable(kWasmAnyRef, 10, 10);

  let elems = [10, -10, 42, 55];

  let passive_segment = builder.addPassiveElementSegment(
    [makeStruct(elems[0]), makeStruct(elems[1]),
     [kExprRefNull, struct_type_index]],
    struct_type);

  let active_segment = builder.addActiveElementSegment(
      table, wasmI32Const(0), [makeStruct(elems[2]), makeStruct(elems[3])],
      struct_type);

  function generator(name, segment) {
    builder.addFunction(name, makeSig([kWasmI32, kWasmI32, kWasmI32], [kWasmI32]))
      .addBody([
        kExprLocalGet, 0,  // offset
        kExprLocalGet, 1,  // length
        kGCPrefix, kExprArrayNewElem, array_type_index, segment,
        kExprLocalGet, 2,  // index in the array
        kGCPrefix, kExprArrayGet, array_type_index,
        kGCPrefix, kExprStructGet, struct_type_index, 0])
      .exportFunc()
  }

  // Respective segment elements should be pointer-identical.
  builder.addFunction("identical", makeSig([kWasmI32, kWasmI32], [kWasmI32]))
    .addBody([
      kExprI32Const, 0,  // offset
      kExprLocalGet, 0,  // length
      kGCPrefix, kExprArrayNewElem, array_type_index, passive_segment,
      kExprLocalGet, 1,  // index in the array
      kGCPrefix, kExprArrayGet, array_type_index,

      kExprI32Const, 0,  // offset
      kExprLocalGet, 0,  // length
      kGCPrefix, kExprArrayNewElem, array_type_index, passive_segment,
      kExprLocalGet, 1,  // index in the array
      kGCPrefix, kExprArrayGet, array_type_index,

      kExprRefEq])
    .exportFunc()

  generator("init_and_get", passive_segment);
  generator("init_and_get_active", active_segment);

  builder.addFunction("drop", kSig_v_v)
    .addBody([kNumericPrefix, kExprElemDrop, passive_segment])
    .exportFunc();

  let instance = builder.instantiate();

  let init_and_get = instance.exports.init_and_get;
  let init_and_get_active = instance.exports.init_and_get_active;
  // Initializing from a passive segment works. The third element is null, so
  // we get a null dereference.
  assertEquals(elems[0], init_and_get(0, 3, 0));
  assertEquals(elems[1], init_and_get(0, 3, 1));
  assertTraps(kTrapNullDereference, () => init_and_get(0, 3, 2));
  // The array has the correct length.
  assertTraps(kTrapArrayOutOfBounds, () => init_and_get(0, 3, 3));
  // Too large arrays are disallowed, in and out of Smi range.
  assertTraps(kTrapArrayTooLarge, () => init_and_get(0, 1000000000, 10));
  assertTraps(kTrapArrayTooLarge, () => init_and_get(0, 1 << 31, 10));
  // Element is out of bounds.
  assertTraps(kTrapElementSegmentOutOfBounds, () => init_and_get(0, 5, 0));
  // Element index out of Smi range.
  assertTraps(kTrapElementSegmentOutOfBounds,
              () => init_and_get(0x80000000, 0, 0));
  // Respective segment elements should be pointer-identical.
  assertEquals(1, instance.exports.identical(3, 0));
  // Now drop the segment.
  instance.exports.drop();
  // A 0-length array should still be created...
  assertTraps(kTrapArrayOutOfBounds, () => init_and_get(0, 0, 0));
  // ... but not a longer one.
  assertTraps(kTrapElementSegmentOutOfBounds, () => init_and_get(0, 1, 0));
  // Same holds for an active segment.
  assertTraps(kTrapArrayOutOfBounds, () => init_and_get_active(0, 0, 0));
  assertTraps(kTrapElementSegmentOutOfBounds,
              () => init_and_get_active(0, 1, 0));
})();

// TODO(14034): Reenable when we have constant array.new_elem.
/*
(function TestArrayNewElemConstant() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct_type_index = builder.addStruct([makeField(kWasmI32, false)]);
  let struct_type = wasmRefNullType(struct_type_index);
  let array_type_index = builder.addArray(struct_type, true);
  let array_type = wasmRefNullType(array_type_index);

  function makeStruct(element) {
    return [...wasmI32Const(element),
            kGCPrefix, kExprStructNew, struct_type_index];
  }

  builder.addTable(kWasmAnyRef, 10, 10);
  let table = 0;

  let elems = [10, -10, 42, 55];

  let passive_segment = builder.addPassiveElementSegment(
    [makeStruct(elems[0]), makeStruct(elems[1]),
     [kExprRefNull, struct_type_index]],
    struct_type);

  let active_segment = builder.addActiveElementSegment(
      0, wasmI32Const(0), [makeStruct(elems[2]), makeStruct(elems[3])],
      struct_type);

  let array_segment = builder.addPassiveElementSegment(
    [[...wasmI32Const(0), ...wasmI32Const(3),
      kGCPrefix, kExprArrayNewElem,
      array_type_index, passive_segment],
     [...wasmI32Const(0), ...wasmI32Const(0),
      kGCPrefix, kExprArrayNewElem,
      array_type_index, active_segment]],
    array_type);

  builder.addFunction("init", kSig_v_v)
    .addBody([kExprI32Const, 0, kExprI32Const, 0, kExprI32Const, 2,
              kNumericPrefix, kExprTableInit, array_segment, table])
    .exportFunc();

  builder.addFunction("table_get", makeSig([kWasmI32, kWasmI32], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,  // offset in table
      kExprTableGet, table,
      kGCPrefix, kExprRefCast, array_type_index,
      kExprLocalGet, 1,  // index in the array
      kGCPrefix, kExprArrayGet, array_type_index,
      kGCPrefix, kExprStructGet, struct_type_index, 0])
    .exportFunc()

  builder.addFunction("drop", kSig_v_v)
    .addBody([kNumericPrefix, kExprElemDrop, passive_segment])
    .exportFunc();

  let instance = builder.instantiate();

  // First, initialize the table.
  instance.exports.init();
  let table_get = instance.exports.table_get;
  // Initializing from a passive segment works. The third element is null, so
  // we get a null dereference.
  assertEquals(elems[0], table_get(0, 0));
  assertEquals(elems[1], table_get(0, 1));
  assertTraps(kTrapNullDereference, () => table_get(0, 2));
  // The array has the correct length.
  assertTraps(kTrapArrayOutOfBounds, () => table_get(0, 3));
  // The array generated from the active segment should have length 0.
  assertTraps(kTrapArrayOutOfBounds, () => table_get(1, 0));
  // Now drop the segment with the array elements and reload the table.
  instance.exports.drop();
  instance.exports.init();
  // Nothing should change: a constant expression should not observe the dropped
  // segments.
  assertEquals(elems[0], table_get(0, 0));
  assertEquals(elems[1], table_get(0, 1));
  assertTraps(kTrapNullDereference, () => table_get(0, 2));
  assertTraps(kTrapArrayOutOfBounds, () => table_get(0, 3));
})();
*/

(function TestArrayNewElemMistypedSegment() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct_type_index = builder.addStruct([makeField(kWasmI32, false)]);
  let struct_type = wasmRefNullType(struct_type_index);
  let array_type_index = builder.addArray(struct_type, true);

  let passive_segment = builder.addPassiveElementSegment([
    [kExprRefNull, array_type_index]],
    wasmRefNullType(array_type_index));

  builder.addFunction("mistyped", makeSig([kWasmI32, kWasmI32], [kWasmI32]))
      .addBody([
        kExprI32Const, 0,  // offset
        kExprLocalGet, 0,  // length
        kGCPrefix, kExprArrayNewElem, array_type_index,
        passive_segment,
        kExprLocalGet, 1,  // index in the array
        kGCPrefix, kExprArrayGet, array_type_index,
        kGCPrefix, kExprStructGet, struct_type_index, 0])
      .exportFunc()

  assertThrows(() => builder.instantiate(), WebAssembly.CompileError,
               /segment type.*is not a subtype of array element type.*/);
})();

// TODO(14034): Reenable when we have constant array.new_elem.
/*
// Element segments are defined after globals, so currently it is not valid
// to refer to an element segment in the global section.
(function TestArrayNewFixedFromElemInGlobal() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct_type_index = builder.addStruct([makeField(kWasmI32, false)]);
  let struct_type = wasmRefNullType(struct_type_index);
  let array_type_index = builder.addArray(struct_type, true);

  let passive_segment = builder.addPassiveElementSegment([
    [kExprRefNull, struct_type_index]],
    struct_type_index);

  builder.addGlobal(
    wasmRefNullType(array_type_index), false, false,
    [...wasmI32Const(0), ...wasmI32Const(1),
     kGCPrefix, kExprArrayNewElem,
     array_type_index, passive_segment]);

  assertThrows(() => builder.instantiate(), WebAssembly.CompileError,
               /invalid element segment index/);
})();

(function TestArrayNewElemConstantArrayTooLarge() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct_type_index = builder.addStruct([makeField(kWasmI32, false)]);
  let struct_type = wasmRefNullType(struct_type_index);
  let array_type_index = builder.addArray(struct_type, true);
  let array_type = wasmRefNullType(array_type_index);

  function makeStruct(element) {
    return [...wasmI32Const(element),
            kGCPrefix, kExprStructNew, struct_type_index];
  }

  builder.addTable(kWasmAnyRef, 10, 10);
  let table = 0;

  let elems = [10, -10];

  let passive_segment = builder.addPassiveElementSegment(
    [makeStruct(elems[0]), makeStruct(elems[1]),
     [kExprRefNull, struct_type_index]],
    struct_type);

  let array_segment = builder.addPassiveElementSegment(
    [[...wasmI32Const(0), ...wasmI32Const(1 << 30),
      kGCPrefix, kExprArrayNewElem,
      array_type_index, passive_segment]],
    array_type
  );

  builder.addFunction("init", kSig_v_v)
    .addBody([kExprI32Const, 0, kExprI32Const, 0, kExprI32Const, 1,
              kNumericPrefix, kExprTableInit, array_segment, table])
    .exportFunc();

  let instance = builder.instantiate();
  assertTraps(kTrapArrayTooLarge, () => instance.exports.init());
})();

(function TestArrayNewElemConstantElementSegmentOutOfBounds() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct_type_index = builder.addStruct([makeField(kWasmI32, false)]);
  let struct_type = wasmRefNullType(struct_type_index);
  let array_type_index = builder.addArray(struct_type, true);
  let array_type = wasmRefNullType(array_type_index);

  function makeStruct(element) {
    return [...wasmI32Const(element),
            kGCPrefix, kExprStructNew, struct_type_index];
  }

  builder.addTable(kWasmAnyRef, 10, 10);
  let table = 0;

  let elems = [10, -10];

  let passive_segment = builder.addPassiveElementSegment(
    [makeStruct(elems[0]), makeStruct(elems[1]),
     [kExprRefNull, struct_type_index]],
    struct_type);

  let array_segment = builder.addPassiveElementSegment(
    [[...wasmI32Const(0), ...wasmI32Const(10),
      kGCPrefix, kExprArrayNewElem,
      array_type_index, passive_segment]],
    array_type
  );

  builder.addFunction("init", kSig_v_v)
    .addBody([kExprI32Const, 0, kExprI32Const, 0, kExprI32Const, 1,
              kNumericPrefix, kExprTableInit, array_segment, table])
    .exportFunc();

  let instance = builder.instantiate();
  assertTraps(kTrapElementSegmentOutOfBounds, () => instance.exports.init());
})();

(function TestArrayNewElemConstantActiveSegment() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct_type_index = builder.addStruct([makeField(kWasmI32, false)]);
  let struct_type = wasmRefNullType(struct_type_index);
  let array_type_index = builder.addArray(struct_type, true);
  let array_type = wasmRefNullType(array_type_index);

  function makeStruct(element) {
    return [...wasmI32Const(element),
            kGCPrefix, kExprStructNew, struct_type_index];
  }

  builder.addTable(kWasmAnyRef, 10, 10);
  let table = 0;

  let elems = [10, -10];

  let active_segment = builder.addActiveElementSegment(
    table, wasmI32Const(0),
    [makeStruct(elems[0]), makeStruct(elems[1]),
     [kExprRefNull, struct_type_index]],
    struct_type);

  let array_segment = builder.addPassiveElementSegment(
    [[...wasmI32Const(0), ...wasmI32Const(3),
      kGCPrefix, kExprArrayNewElem,
      array_type_index, active_segment]],
    array_type
  );

  builder.addFunction("init", kSig_v_v)
    .addBody([kExprI32Const, 0, kExprI32Const, 0, kExprI32Const, 1,
              kNumericPrefix, kExprTableInit, array_segment, table])
    .exportFunc();

  let instance = builder.instantiate();
  // An active segment counts as having 0 length.
  assertTraps(kTrapElementSegmentOutOfBounds, () => instance.exports.init());
})();
*/

(function TestArrayNewData() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let array_type_index = builder.addArray(kWasmI16, true);

  let dummy_byte = 0xff;
  let element_0 = 1000;
  let element_1 = -2222;

  let data_segment = builder.addPassiveDataSegment(
    [dummy_byte, element_0 & 0xff, (element_0 >> 8) & 0xff,
     element_1 & 0xff, (element_1 >> 8) & 0xff]);

  // TODO(14034): Reenable when we have constant array.new_data.
  /*
  let global = builder.addGlobal(
    wasmRefType(array_type_index), true, false,
    [...wasmI32Const(1), ...wasmI32Const(2),
     kGCPrefix, kExprArrayNewData, array_type_index, data_segment],
    builder);

  builder.addFunction("global_get", kSig_i_i)
    .addBody([
      kExprGlobalGet, global.index,
      kExprLocalGet, 0,
      kGCPrefix, kExprArrayGetS, array_type_index])
    .exportFunc();
  */

  // parameters: (segment offset, array length, array index)
  builder.addFunction("init_from_data", kSig_i_iii)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1,
      kGCPrefix, kExprArrayNewData,
      array_type_index, data_segment,
      kExprLocalGet, 2,
      kGCPrefix, kExprArrayGetS, array_type_index])
    .exportFunc();

  builder.addFunction("drop_segment", kSig_v_v)
    .addBody([kNumericPrefix, kExprDataDrop, data_segment])
    .exportFunc();

  let instance = builder.instantiate();

  // TODO(14034): Reenable when we have constant array.new_elem.
  // assertEquals(element_0, instance.exports.global_get(0));
  // assertEquals(element_1, instance.exports.global_get(1));

  let init = instance.exports.init_from_data;

  assertEquals(element_0, init(1, 2, 0));
  assertEquals(element_1, init(1, 2, 1));

  assertTraps(kTrapArrayTooLarge, () => init(1, 1000000000, 0));
  assertTraps(kTrapDataSegmentOutOfBounds, () => init(2, 2, 0));

  instance.exports.drop_segment();

  assertTraps(kTrapDataSegmentOutOfBounds, () => init(1, 2, 0));
})();
                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/wasm/asm-wasm-copy.js                                              0000664 0000000 0000000 00000001463 14746647661 0022523 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

(function TestCopyBug() {
  // This was tickling a register allocation issue with
  // idiv in embenchen/copy.
  function asmModule(){
    'use asm';
    function func() {
      var ret = 0;
      var x = 1, y = 0, z = 0;
      var a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0;
      do {
        y = (x + 0) | 0;
        z = (y | 0) % 2 | 0;
        ret = (y + z + a + b + c + d + e + f + g) | 0;
      } while(0);
      return ret | 0;
    }
    return { func: func };
  }
  var wasm = asmModule();
  var js = eval('(' + asmModule.toString().replace('use asm', '') + ')')();
  assertEquals(js.func(), wasm.func());
})();
                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/asm-wasm-deopt.js                                             0000664 0000000 0000000 00000001211 14746647661 0022653 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --validate-asm --allow-natives-syntax

(function TestDeoptimizeArgMismatch() {
  function deopt() {
    %DeoptimizeFunction(test);
  }
  function Module(global, env, buffer) {
    "use asm";
    var deopt = env.deopt;
    function _main(i4, i5) {
      i4 = i4 | 0;
      i5 = i5 | 0;
      deopt();
      return i5 | 0;
    }
    return {'_main': _main}
  }
  function test() {
    var wasm = Module(null, {'deopt': deopt});
    wasm._main(0, 0, 0);
  }
  test();
})();
                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/wasm/asm-wasm-exception-in-tonumber.js                             0000664 0000000 0000000 00000010224 14746647661 0025777 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --validate-asm

var filename = '(?:[^ ]+/)?test/mjsunit/wasm/asm-wasm-exception-in-tonumber.js';
filename = filename.replace(/\//g, '[/\\\\]');

function verifyStack(frames, expected) {
  assertTrue(frames.length >= expected.length, 'too few frames');
  print('frames on detailed stack (' + frames.length + '):');
  frames.forEach((fr, i) => print('[' + i + '] ' + fr));
  expected.forEach(function(exp, i) {
    assertEquals(
        exp[0], frames[i].getFunctionName(), '[' + i + '].getFunctionName()');
    assertEquals(
        exp[1], frames[i].getColumnNumber(), '[' + i + '].getColumnNumber()');
  });
}

function verifyPreformattedStack(e, expected_lines) {
  print('preformatted stack: ' + e.stack);
  var lines = e.stack.split('\n');
  assertTrue(lines.length >= expected_lines.length, 'too few lines');
  for (var i = 0; i < expected_lines.length; ++i) {
    assertMatches(expected_lines[i], lines[i], 'line ' + i);
  }
}

function sym(return_sym) {
  if (return_sym) return Symbol();
  throw Error("user-thrown");
}

function generateAsmJsInteger(stdlib, foreign) {
  'use asm';
  var sym = foreign.sym;
  function callSym(i) {
    i=i|0;
    return sym(i|0) | 0;
  }
  return callSym;
}

function generateAsmJsDouble(stdlib, foreign) {
  'use asm';
  var sym = foreign.sym;
  function callSym(i) {
    i=i|0;
    return +sym(i|0);
  }
  return callSym;
}

function testHelper(use_asm_js, check_detailed, expected, input, source) {
  if (check_detailed) {
    Error.prepareStackTrace = (error, frames) => frames;
  } else {
    delete Error.prepareStackTrace;
  }

  var fn_code = '(' + source.toString() + ')({}, {sym: sym})';
  if (!use_asm_js) fn_code = fn_code.replace('use asm', '');
  //print('executing:\n' + fn_code);
  var asm_js_fn = eval(fn_code);
  try {
    asm_js_fn(input);
  } catch (e) {
    if (check_detailed) {
      verifyStack(e.stack, expected);
    } else {
      verifyPreformattedStack(e, expected);
    }
  }
}

function testAll(expected_stack, expected_frames, input, source) {
  for (use_asm_js = 0; use_asm_js <= 1; ++use_asm_js) {
    for (test_detailed = 0; test_detailed <= 1; ++test_detailed) {
      print('\nConfig: asm ' + use_asm_js + '; detailed ' + test_detailed);
      testHelper(
          use_asm_js, test_detailed,
          test_detailed ? expected_frames : expected_stack, input, source);
    }
  }
}

(function testStackForThrowAtIntegerCall() {
  var expected_stack = [
    '^Error: user-thrown$',
    '^ *at sym \\(' + filename + ':\\d+:9\\)$',
    '^ *at callSym \\(eval at testHelper \\(' + filename +
        ':\\d+:19\\), <anonymous>:\\d+:12\\)$',
  ];
  var expected_frames = [
      //  function   pos
      [      "sym",    9],
      [  "callSym",   12],
  ];

  testAll(expected_stack, expected_frames, 0, generateAsmJsInteger);
})();

(function testStackForThrowAtIntegerConversion() {
  var expected_stack = [
    '^TypeError: Cannot convert a Symbol value to a number$',
    '^ *at callSym \\(eval at testHelper \\(' + filename +
        ':\\d+:19\\), <anonymous>:\\d+:21\\)$',
  ];
  var expected_frames = [
      //  function   pos
      [  "callSym",   21],
  ];

  testAll(expected_stack, expected_frames, 1, generateAsmJsInteger);
})();

(function testStackForThrowAtDoubleCall() {
  var expected_stack = [
    '^Error: user-thrown$',
    '^ *at sym \\(' + filename + ':\\d+:9\\)$',
    '^ *at callSym \\(eval at testHelper \\(' + filename +
        ':\\d+:19\\), <anonymous>:\\d+:13\\)$',
  ];
  var expected_frames = [
      //  function   pos
      [      "sym",    9],
      [  "callSym",   13],
  ];

  testAll(expected_stack, expected_frames, 0, generateAsmJsDouble);
})();

(function testStackForThrowAtDoubleConversion() {
  var expected_stack = [
    '^TypeError: Cannot convert a Symbol value to a number$',
    '^ *at callSym \\(eval at testHelper \\(' + filename +
        ':\\d+:19\\), <anonymous>:\\d+:12\\)$',
  ];
  var expected_frames = [
      //  function   pos
      [  "callSym",   12],
  ];

  testAll(expected_stack, expected_frames, 1, generateAsmJsDouble);
})();
                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/wasm/asm-wasm-expr.js                                              0000664 0000000 0000000 00000007226 14746647661 0022532 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --validate-asm --allow-natives-syntax

var selectedTest = undefined;
//selectedTest = 16;

function skip(a) {
  return selectedTest != undefined ? a != selectedTest : false;
}

const assign_in_stmt = [
  "if (E) =",
  "if (=) E",
  "if (E) E; else =",
  "for (=; E; S) S",
  "for (E; =; S) S",
  "for (E; E; =) E",
  "for (E; E; E) =",
  "do { = } while(E)",
  "do { S } while (=)",
];
const assign_in_expr = [
  "i32_func(=) | 0",
  "(=) ? E : E",
  "E ? (=) : E",
  "E ? E : (=)",
  "(=) + E",
  "E + (=)",
  "imul(=, E)",
  "imul(E, =)",
  "~(=)",
  "(=) | 0",
  "(=), E",
  "E, (=)",
  "E, E, (=)",
  "E, (=), E",
  "(=), E, E",
];

const stdlib = {
  Math: Math,
  Int8Array: Int8Array,
  Int16Array: Int16Array,
  Int32Array: Int32Array,
  Uint8Array: Uint8Array,
  Uint16Array: Uint16Array,
  Uint32Array: Uint32Array,
  Float32Array: Float32Array,
  Float64Array: Float64Array,
};

const buffer = new ArrayBuffer(65536);

// Template for a module.
function MODULE_TEMPLATE(stdlib, foreign, buffer) {
  "use asm";
  var imul = stdlib.Math.imul;
  var fround = stdlib.Math.fround;
  var M = new stdlib.Int32Array(buffer);
  var G = 0;

  function void_func() {}
  function i32_func(a) {
    a = a | 0;
    return a | 0;
  }

  FUNC_DECL
  return {main: main};
}

// Template for main function.
{
  function main(i32, f32, f64) {
    i32 = i32 | 0;
    f32 = fround(f32);
    f64 = +f64;
    FUNC_BODY
  }
}

function RunAsmJsTest(asmfunc, expect) {
  var asm_source = asmfunc.toString();
  var nonasm_source = asm_source.replace(new RegExp("use asm"), "");

  print("Testing " + asmfunc.name + " (js)...");
  var js_module = eval("(" + nonasm_source + ")")(stdlib, {}, buffer);
  expect(js_module);

  print("Testing " + asmfunc.name + " (asm.js)...");
  var asm_module = asmfunc(stdlib, {}, buffer);
  assertTrue(%IsAsmWasmCode(asmfunc));
  expect(asm_module);
}

var test = 0;

function DoTheTests(expr, assign, stmt) {
  // ==== Expression assignment tests ========================================
  for (let e of assign_in_expr) {
    if (skip(++test)) continue;
    var orig = e;
    e = e.replace(/=/g, assign);
    e = e.replace(/E/g, expr);
    e = e.replace(/S/g, stmt);
    var str = main.toString().replace("FUNC_BODY", "return (" + e + ") | 0;");
    var asm_source = MODULE_TEMPLATE.toString().replace("FUNC_DECL", str);
    doTest(asm_source, "(" + test + ") " + e);
  }

  // ==== Statement assignment tests =========================================
  for (let e of assign_in_stmt) {
    if (skip(++test)) continue;
    var orig = e;
    e = e.replace(/=/g, assign);
    e = e.replace(/E/g, expr);
    e = e.replace(/S/g, stmt);
    var str = main.toString().replace("FUNC_BODY",  e + "; return 0;");
    var asm_source = MODULE_TEMPLATE.toString().replace("FUNC_DECL", str);
    doTest(asm_source, "(" + test + ") " + e);
  }

  function doTest(asm_source, orig) {
    var nonasm_source = asm_source.replace(new RegExp("use asm"), "");
    print("Testing JS:    " + orig);
    var js_module = eval("(" + nonasm_source + ")")(stdlib, {}, buffer);
    expect(js_module);

    print("Testing ASMJS: " + orig);
    var asmfunc = eval("(" + asm_source + ")");
    var asm_module = asmfunc(stdlib, {}, buffer);
    assertTrue(%IsAsmWasmCode(asmfunc));
    expect(asm_module);
  }

  function expect(module) { module.main(0, 0, 0); print("  ok"); return true; }
}

DoTheTests("(i32 | 0)", "i32 = 0", "void_func()");
DoTheTests("G", "G = 0", "void_func()");
DoTheTests("G", "G = 0", "G");
DoTheTests("(M[0] | 0)", "M[0] = 0", "void_func()");
                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/wasm/asm-wasm-f32.js                                               0000664 0000000 0000000 00000010623 14746647661 0022141 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --validate-asm --allow-natives-syntax

function WrapInAsmModule(func) {
  function MODULE_NAME(stdlib) {
    "use asm";
    var fround = stdlib.Math.fround;
    var Math_ceil = stdlib.Math.ceil;
    var Math_floor = stdlib.Math.floor;
    var Math_sqrt = stdlib.Math.sqrt;
    var Math_abs = stdlib.Math.abs;
    var Math_min = stdlib.Math.min;
    var Math_max = stdlib.Math.max;

    FUNC_BODY
    return {main: FUNC_NAME};
  }

  var source = MODULE_NAME.toString()
    .replace(/MODULE_NAME/g, func.name + "_module")
    .replace(/FUNC_BODY/g, func.toString())
    .replace(/FUNC_NAME/g, func.name);
  return eval("(" + source + ")");
}

function RunAsmJsTest(asmfunc, expect) {
  var asm_source = asmfunc.toString();
  var nonasm_source = asm_source.replace(new RegExp("use asm"), "");
  var stdlib = {Math: Math};

  print("Testing " + asmfunc.name + " (js)...");
  var js_module = eval("(" + nonasm_source + ")")(stdlib);
  expect(js_module);

  print("Testing " + asmfunc.name + " (asm.js)...");
  var asm_module = asmfunc(stdlib);
  assertTrue(%IsAsmWasmCode(asmfunc));
  expect(asm_module);
}

var fround = Math.fround;
var Math_ceil = Math.ceil;
var Math_floor = Math.floor;
var Math_sqrt = Math.sqrt;
var Math_abs = Math.abs;
var Math_min = Math.min;
var Math_max = Math.max;

function f32_add(a, b) {
  a = fround(a);
  b = fround(b);
  return fround(fround(a) + fround(b));
}

function f32_sub(a, b) {
  a = fround(a);
  b = fround(b);
  return fround(fround(a) - fround(b));
}

function f32_mul(a, b) {
  a = fround(a);
  b = fround(b);
  return fround(fround(a) * fround(b));
}

function f32_div(a, b) {
  a = fround(a);
  b = fround(b);
  return fround(fround(a) / fround(b));
}

function f32_ceil(a) {
  a = fround(a);
  return fround(Math_ceil(fround(a)));
}

function f32_floor(a) {
  a = fround(a);
  return fround(Math_floor(fround(a)));
}

function f32_sqrt(a) {
  a = fround(a);
  return fround(Math_sqrt(fround(a)));
}

function f32_abs(a) {
  a = fround(a);
  return fround(Math_abs(fround(a)));
}

function f32_min(a, b) {
  a = fround(a);
  b = fround(b);
  return fround(Math_min(fround(a), fround(b)));
}

function f32_max(a, b) {
  a = fround(a);
  b = fround(b);
  return fround(Math_max(fround(a), fround(b)));
}

function f32_eq(a, b) {
  a = fround(a);
  b = fround(b);
  if (fround(a) == fround(b)) {
    return 1;
  }
  return 0;
}

function f32_ne(a, b) {
  a = fround(a);
  b = fround(b);
  if (fround(a) != fround(b)) {
    return 1;
  }
  return 0;
}

function f32_lt(a, b) {
  a = fround(a);
  b = fround(b);
  if (fround(a) < fround(b)) {
    return 1;
  }
  return 0;
}

function f32_lteq(a, b) {
  a = fround(a);
  b = fround(b);
  if (fround(a) <= fround(b)) {
    return 1;
  }
  return 0;
}

function f32_gt(a, b) {
  a = fround(a);
  b = fround(b);
  if (fround(a) > fround(b)) {
    return 1;
  }
  return 0;
}

function f32_gteq(a, b) {
  a = fround(a);
  b = fround(b);
  if (fround(a) >= fround(b)) {
    return 1;
  }
  return 0;
}

function f32_neg(a) {
  a = fround(a);
  return fround(-a);
}


var inputs = [
  0, 1,
  NaN,
  Infinity,
  -Infinity,
  2147483646,
  2147483647,
  2147483648,
  2147483649,
  4026531840, // 0xf0000000
  4294967293, // 0xfffffffd
  4294967295, // 0xffffffff
  -0, -1,
  -2147483646,
  -2147483647,
  -2147483648,
  -2147483649,
  0.1,
  1.1e-2,
  1.6e-13
];

var funcs = [
  f32_add, f32_sub, f32_mul, f32_div, f32_ceil, f32_floor, f32_sqrt, f32_abs,
  f32_min, f32_max, f32_eq, f32_ne, f32_lt, f32_lteq, f32_gt, f32_gteq, f32_neg
];

(function () {
  for (func of funcs) {
    RunAsmJsTest(WrapInAsmModule(func), function (module) {
      if (func.length == 1) {
        for (a of inputs) {
          assertEquals(func(a), module.main(a));
          assertEquals(func(a / 11), module.main(a / 11));
          assertEquals(func(a / 430.9), module.main(a / 430.9));
          assertEquals(func(a / -31.1), module.main(a / -31.1));
        }
      } else {
        for (a of inputs) {
          for (b of inputs) {
            assertEquals(func(a, b), module.main(a, b));
            assertEquals(func(a / 11,  b), module.main(a / 11, b));
            assertEquals(func(a, b / 420.9), module.main(a, b / 420.9));
            assertEquals(func(a / -31.1, b), module.main(a / -31.1, b));
          }
        }
      }
    });
  }

})();
                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/asm-wasm-f64.js                                               0000664 0000000 0000000 00000012174 14746647661 0022151 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --validate-asm --allow-natives-syntax

function WrapInAsmModule(func) {
  function MODULE_NAME(stdlib) {
    "use asm";
    var Math_ceil = stdlib.Math.ceil;
    var Math_floor = stdlib.Math.floor;
    var Math_sqrt = stdlib.Math.sqrt;
    var Math_abs = stdlib.Math.abs;
    var Math_min = stdlib.Math.min;
    var Math_max = stdlib.Math.max;
    var Math_acos = stdlib.Math.acos;
    var Math_asin = stdlib.Math.asin;
    var Math_atan = stdlib.Math.atan;
    var Math_cos = stdlib.Math.cos;
    var Math_sin = stdlib.Math.sin;
    var Math_tan = stdlib.Math.tan;
    var Math_exp = stdlib.Math.exp;
    var Math_log = stdlib.Math.log;
    var Math_atan2 = stdlib.Math.atan2;

    FUNC_BODY
    return {main: FUNC_NAME};
  }

  var source = MODULE_NAME.toString()
    .replace(/MODULE_NAME/g, func.name + "_module")
    .replace(/FUNC_BODY/g, func.toString())
    .replace(/FUNC_NAME/g, func.name);
  return eval("(" + source + ")");
}

function RunAsmJsTest(asmfunc, expect) {
  var asm_source = asmfunc.toString();
  var nonasm_source = asm_source.replace(new RegExp("use asm"), "");
  var stdlib = {Math: Math};

  print("Testing " + asmfunc.name + " (js)...");
  var js_module = eval("(" + nonasm_source + ")")(stdlib);
  expect(js_module);

  print("Testing " + asmfunc.name + " (asm.js)...");
  var asm_module = asmfunc(stdlib);
  assertTrue(%IsAsmWasmCode(asmfunc));
  expect(asm_module);
}

const Math_ceil = Math.ceil;
const Math_floor = Math.floor;
const Math_sqrt = Math.sqrt;
const Math_abs = Math.abs;
const Math_min = Math.min;
const Math_max = Math.max;
const Math_acos = Math.acos;
const Math_asin = Math.asin;
const Math_atan = Math.atan;
const Math_cos = Math.cos;
const Math_sin = Math.sin;
const Math_tan = Math.tan;
const Math_exp = Math.exp;
const Math_log = Math.log;
const Math_atan2 = Math.atan2;

function f64_add(a, b) {
  a = +a;
  b = +b;
  return +(+a + +b);
}

function f64_sub(a, b) {
  a = +a;
  b = +b;
  return +(+a - +b);
}

function f64_mul(a, b) {
  a = +a;
  b = +b;
  return +(+a * +b);
}

function f64_div(a, b) {
  a = +a;
  b = +b;
  return +(+a / +b);
}

function f64_eq(a, b) {
  a = +a;
  b = +b;
  if (+a == +b) {
    return 1;
  }
  return 0;
}

function f64_ne(a, b) {
  a = +a;
  b = +b;
  if (+a != +b) {
    return 1;
  }
  return 0;
}

function f64_lt(a, b) {
  a = +a;
  b = +b;
  if (+a < +b) {
    return 1;
  }
  return 0;
}

function f64_lteq(a, b) {
  a = +a;
  b = +b;
  if (+a <= +b) {
    return 1;
  }
  return 0;
}

function f64_gt(a, b) {
  a = +a;
  b = +b;
  if (+a > +b) {
    return 1;
  }
  return 0;
}

function f64_gteq(a, b) {
  a = +a;
  b = +b;
  if (+a >= +b) {
    return 1;
  }
  return 0;
}

function f64_ceil(a) {
  a = +a;
  return +(Math_ceil(+a));
}

function f64_floor(a) {
  a = +a;
  return +(Math_floor(+a));
}

function f64_sqrt(a) {
  a = +a;
  return +(Math_sqrt(+a));
}

function f64_abs(a) {
  a = +a;
  return +(Math_abs(+a));
}

function f64_min(a, b) {
  a = +a;
  b = +b;
  return +(Math_min(+a, +b));
}

function f64_max(a, b) {
  a = +a;
  b = +b;
  return +(Math_max(+a, +b));
}

function f64_acos(a) {
  a = +a;
  return +Math_acos(+a);
}

function f64_asin(a) {
  a = +a;
  return +Math_asin(+a);
}

function f64_atan(a) {
  a = +a;
  return +Math_atan(+a);
}

function f64_cos(a) {
  a = +a;
  return +Math_cos(+a);
}

function f64_sin(a) {
  a = +a;
  return +Math_sin(+a);
}

function f64_tan(a) {
  a = +a;
  return +Math_tan(+a);
}

function f64_exp(a) {
  a = +a;
  return +Math_exp(+a);
}

function f64_log(a) {
  a = +a;
  return +Math_log(+a);
}

function f64_atan2(a, b) {
  a = +a;
  b = +b;
  return +Math_atan2(+a, +b);
}

function f64_neg(a) {
  a = +a;
  return +(-a);
}


var inputs = [
  0, 1,
  NaN,
  Infinity,
  -Infinity,
  2147483646,
  2147483647,
  2147483648,
  2147483649,
  4026531840, // 0xf0000000
  4294967293, // 0xfffffffd
  4294967295, // 0xffffffff
  -0, -1,
  -2147483646,
  -2147483647,
  -2147483648,
  -2147483649,
  0.1,
  1.1e-2,
  1.6e-13
];

var funcs = [
  f64_add,  f64_sub, f64_mul,  f64_div,  f64_eq,    f64_ne,   f64_lt,
  f64_lteq, f64_gt,  f64_gteq, f64_ceil, f64_floor, f64_sqrt, f64_abs,
  f64_neg,  f64_min, f64_max,  f64_acos, f64_asin,  f64_atan, f64_cos,
  f64_sin,  f64_tan, f64_exp,  f64_log,  f64_atan2,
];

(function () {
  for (func of funcs) {
    RunAsmJsTest(WrapInAsmModule(func), function (module) {
      if (func.length == 1) {
        for (a of inputs) {
          assertEquals(func(a), module.main(a));
          assertEquals(func(a / 10), module.main(a / 10));
          assertEquals(func(a / 440.9), module.main(a / 440.9));
          assertEquals(func(a / -33.1), module.main(a / -33.1));
        }
      } else {
        for (a of inputs) {
          for (b of inputs) {
            assertEquals(func(a, b), module.main(a, b));
            assertEquals(func(a / 10,  b), module.main(a / 10, b));
            assertEquals(func(a, b / 440.9), module.main(a, b / 440.9));
            assertEquals(func(a / -33.1, b), module.main(a / -33.1, b));
          }
        }
      }
    });
  }
})();
                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/test/mjsunit/wasm/asm-wasm-heap.js                                              0000664 0000000 0000000 00000013661 14746647661 0022471 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --validate-asm --allow-natives-syntax

const stdlib = {
  Math: Math,
  Int8Array: Int8Array,
  Int16Array: Int16Array,
  Int32Array: Int32Array,
  Uint8Array: Uint8Array,
  Uint16Array: Uint16Array,
  Uint32Array: Uint32Array,
  Float32Array: Float32Array,
  Float64Array: Float64Array,
};

const buffer = new ArrayBuffer(65536);
const BASE = 1000000000;

const OOB_INDEXES = [
  buffer.byteLength,
  buffer.byteLength + 1,
  buffer.byteLength + 2,
  buffer.byteLength + 3,
  buffer.byteLength + 4,
  buffer.byteLength + 5,
  buffer.byteLength + 6,
  buffer.byteLength + 7,
  buffer.byteLength + 8,
  buffer.byteLength + 9,
  buffer.byteLength + 10,
  0x80000000,
  0x80000004,
  0xF0000000,
  0xFFFFFFFF,
  0xFFFFFFFE,
  -1, -2, -3, -4, -5, -6, -7, -8
];

function resetBuffer() {
  var view = new Int32Array(buffer);
  for (var i = 0; i < view.length; i++) {
    view[i] = BASE | (i << 2);
  }
}
resetBuffer();


function checkView(view, load, shift) {
  for (var i = 0; i < 300; i++) {
    assertEquals(view[i >> shift], load(i));
  }
}

function RunAsmJsTest(asmfunc, expect) {
  var asm_source = asmfunc.toString();
  var nonasm_source = asm_source.replace(new RegExp("use asm"), "");

  print("Testing " + asmfunc.name + " (js)...");
  var js_module = eval("(" + nonasm_source + ")")(stdlib, {}, buffer);
  expect(js_module);

  print("Testing " + asmfunc.name + " (asm.js)...");
  var asm_module = asmfunc(stdlib, {}, buffer);
  assertTrue(%IsAsmWasmCode(asmfunc));
  expect(asm_module);
}

function LoadAt_i32(stdlib, foreign, buffer) {
  "use asm";
  var HEAP32 = new stdlib.Int32Array(buffer);
  function load(a) {
    a = a | 0;
    return HEAP32[a >> 2] | 0;
  }
  return {load: load};
}

RunAsmJsTest(LoadAt_i32, function(module) {
  var load = module.load;
  assertEquals(BASE, load(0));
  assertEquals(BASE | 0x30, load(0x30));
  assertEquals(BASE | 0x704, load(0x704));
  assertEquals(BASE | 0x704, load(0x705));
  assertEquals(BASE | 0x704, load(0x706));
  assertEquals(BASE | 0x704, load(0x707));

  var length = buffer.byteLength;
  assertEquals(BASE | (length - 4), load(length - 4));
  assertEquals(BASE | (length - 4), load(length - 4 + 1));
  assertEquals(BASE | (length - 4), load(length - 4 + 2));
  assertEquals(BASE | (length - 4), load(length - 4 + 3));

  for (index of OOB_INDEXES) assertEquals(0, load(index));
  checkView(new Int32Array(buffer), load, 2);
});

function LoadAt_i16(stdlib, foreign, buffer) {
  "use asm";
  var HEAP16 = new stdlib.Int16Array(buffer);
  function load(a) {
    a = a | 0;
    return HEAP16[a >> 1] | 0;
  }
  return {load: load};
}

RunAsmJsTest(LoadAt_i16, function(module) {
  var load = module.load;
  var LOWER = (BASE << 16) >> 16;
  var UPPER = BASE >> 16;
  assertEquals(LOWER, load(0));
  assertEquals(UPPER, load(2));

  assertEquals(LOWER | 0x30, load(0x30));
  assertEquals(UPPER, load(0x32));

  assertEquals(LOWER | 0x504, load(0x504));
  assertEquals(LOWER | 0x504, load(0x505));

  assertEquals(UPPER, load(0x706));
  assertEquals(UPPER, load(0x707));

  var length = buffer.byteLength;
  assertEquals(LOWER | (length - 4), load(length - 4));
  assertEquals(LOWER | (length - 4), load(length - 4 + 1));
  assertEquals(UPPER, load(length - 4 + 2));
  assertEquals(UPPER, load(length - 4 + 3));

  for (index of OOB_INDEXES) assertEquals(0, load(index));
  checkView(new Int16Array(buffer), load, 1);
});

function LoadAt_u16(stdlib, foreign, buffer) {
  "use asm";
  var HEAP16 = new stdlib.Uint16Array(buffer);
  function load(a) {
    a = a | 0;
    return HEAP16[a >> 1] | 0;
  }
  return {load: load};
}

RunAsmJsTest(LoadAt_u16, function(module) {
  var load = module.load;
  for (index of OOB_INDEXES) assertEquals(0, load(index));
  checkView(new Uint16Array(buffer), load, 1);
});

function LoadAt_i8(stdlib, foreign, buffer) {
  "use asm";
  var HEAP8 = new stdlib.Int8Array(buffer);
  function load(a) {
    a = a | 0;
    return HEAP8[a >> 0] | 0;
  }
  return {load: load};
}

RunAsmJsTest(LoadAt_i8, function(module) {
  var load = module.load;
  for (index of OOB_INDEXES) assertEquals(0, load(index));
  checkView(new Int8Array(buffer), load, 0);
});

function LoadAt_u8(stdlib, foreign, buffer) {
  "use asm";
  var HEAP8 = new stdlib.Uint8Array(buffer);
  function load(a) {
    a = a | 0;
    return HEAP8[a >> 0] | 0;
  }
  return {load: load};
}

RunAsmJsTest(LoadAt_u8, function(module) {
  var load = module.load;
  for (index of OOB_INDEXES) assertEquals(0, load(index));
  checkView(new Uint8Array(buffer), load, 0);
});


function LoadAt_u32(stdlib, foreign, buffer) {
  "use asm";
  var HEAP32 = new stdlib.Uint32Array(buffer);
  function load(a) {
    a = a | 0;
    return +(HEAP32[a >> 2] >>> 0);
  }
  return {load: load};
}

RunAsmJsTest(LoadAt_u32, function(module) {
  var load = module.load;
  for (index of OOB_INDEXES) assertEquals(0, load(index));
  checkView(new Uint32Array(buffer), load, 2);
});

function LoadAt_f32(stdlib, foreign, buffer) {
  "use asm";
  var HEAP32 = new stdlib.Float32Array(buffer);
  var fround = stdlib.Math.fround;
  function load(a) {
    a = a | 0;
    return fround(HEAP32[a >> 2]);
  }
  return {load: load};
}

RunAsmJsTest(LoadAt_f32, function(module) {
  var load = module.load;
  for (index of OOB_INDEXES) assertEquals(NaN, load(index));
  checkView(new Float32Array(buffer), load, 2);
});

function LoadAt_f64(stdlib, foreign, buffer) {
  "use asm";
  var HEAP64 = new stdlib.Float64Array(buffer);
  function load(a) {
    a = a | 0;
    return +HEAP64[a >> 3];
  }
  return {load: load};
}

RunAsmJsTest(LoadAt_f64, function(module) {
  var load = module.load;
  for (index of OOB_INDEXES) assertEquals(NaN, load(index));
  checkView(new Float64Array(buffer), load, 3);
});

// TODO(titzer): constant heap indexes
// TODO(titzer): heap accesses with offsets and arithmetic
// TODO(titzer): [i >> K] where K is greater than log(size)
                                                                               node-23.7.0/deps/v8/test/mjsunit/wasm/asm-wasm-i32.js                                               0000664 0000000 0000000 00000010172 14746647661 0022143 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --validate-asm --allow-natives-syntax

function WrapInAsmModule(func) {
  function MODULE_NAME(stdlib) {
    "use asm";
    var imul = stdlib.Math.imul;
    var Math_max = stdlib.Math.max;
    var Math_min = stdlib.Math.min;
    var Math_abs = stdlib.Math.abs;

    FUNC_BODY
    return {main: FUNC_NAME};
  }

  var source = MODULE_NAME.toString()
    .replace(/MODULE_NAME/g, func.name + "_module")
    .replace(/FUNC_BODY/g, func.toString())
    .replace(/FUNC_NAME/g, func.name);
  return eval("(" + source + ")");
}

function RunAsmJsTest(asmfunc, expect) {
  var asm_source = asmfunc.toString();
  var nonasm_source = asm_source.replace(new RegExp("use asm"), "");
  var stdlib = {Math: Math};

  print("Testing " + asmfunc.name + " (js)...");
  var js_module = eval("(" + nonasm_source + ")")(stdlib);
  expect(js_module);

  print("Testing " + asmfunc.name + " (asm.js)...");
  var asm_module = asmfunc(stdlib);
  assertTrue(%IsAsmWasmCode(asmfunc));
  expect(asm_module);
}

const imul = Math.imul;
const Math_max = Math.max;
const Math_min = Math.min;
const Math_abs = Math.abs;

function i32_add(a, b) {
  a = a | 0;
  b = b | 0;
  return (a + b) | 0;
}

function i32_sub(a, b) {
  a = a | 0;
  b = b | 0;
  return (a - b) | 0;
}

function i32_mul(a, b) {
  a = a | 0;
  b = b | 0;
  return imul(a, b) | 0;
}

function i32_div(a, b) {
  a = a | 0;
  b = b | 0;
  return ((a | 0) / (b | 0)) | 0;
}

function i32_mod(a, b) {
  a = a | 0;
  b = b | 0;
  return ((a | 0) % (b | 0)) | 0;
}

function i32_and(a, b) {
  a = a | 0;
  b = b | 0;
  return (a & b) | 0;
}

function i32_or(a, b) {
  a = a | 0;
  b = b | 0;
  return (a | b) | 0;
}

function i32_xor(a, b) {
  a = a | 0;
  b = b | 0;
  return (a ^ b) | 0;
}

function i32_shl(a, b) {
  a = a | 0;
  b = b | 0;
  return (a << b) | 0;
}

function i32_shr(a, b) {
  a = a | 0;
  b = b | 0;
  return (a >> b) | 0;
}

function i32_sar(a, b) {
  a = a | 0;
  b = b | 0;
  return (a >>> b) | 0;
}

function i32_eq(a, b) {
  a = a | 0;
  b = b | 0;
  if ((a | 0) == (b | 0)) {
    return 1;
  }
  return 0;
}

function i32_ne(a, b) {
  a = a | 0;
  b = b | 0;
  if ((a | 0) < (b | 0)) {
    return 1;
  }
  return 0;
}

function i32_lt(a, b) {
  a = a | 0;
  b = b | 0;
  if ((a | 0) < (b | 0)) {
    return 1;
  }
  return 0;
}

function i32_lteq(a, b) {
  a = a | 0;
  b = b | 0;
  if ((a | 0) <= (b | 0)) {
    return 1;
  }
  return 0;
}

function i32_gt(a, b) {
  a = a | 0;
  b = b | 0;
  if ((a | 0) > (b | 0)) {
    return 1;
  }
  return 0;
}

function i32_gteq(a, b) {
  a = a | 0;
  b = b | 0;
  if ((a | 0) >= (b | 0)) {
    return 1;
  }
  return 0;
}

function i32_min(a, b) {
  a = a | 0;
  b = b | 0;
  return Math_min(a | 0, b | 0) | 0;
}

function i32_max(a, b) {
  a = a | 0;
  b = b | 0;
  return Math_max(a | 0, b | 0) | 0;
}

function i32_abs(a) {
  a = a | 0;
  return Math_abs(a | 0) | 0;
}

function i32_neg(a) {
  a = a | 0;
  return (-a) | 0;
}

function i32_invert(a) {
  a = a | 0;
  return (~a) | 0;
}

var inputs = [
  0, 1, 2, 3, 4,
  2147483646,
  2147483647, // max positive int32
  2147483648, // overflow max positive int32
  0x0000009e, 0x00000043, 0x0000af73, 0x0000116b, 0x00658ecc, 0x002b3b4c,
  0xeeeeeeee, 0xfffffffd, 0xf0000000, 0x007fffff, 0x0003ffff, 0x00001fff,
  -1, -2, -3, -4,
  -2147483647,
  -2147483648, // min negative int32
  -2147483649, // overflow min negative int32
];

var funcs = [
  i32_add,
  i32_sub,
  i32_mul,
  i32_div,
  i32_mod,
  i32_and,
  i32_or,
  i32_xor,
  i32_shl,
  i32_shr,
  i32_sar,
  i32_eq,
  i32_ne,
  i32_lt,
  i32_lteq,
  i32_gt,
  i32_gteq,
  i32_min,
  i32_max,
  i32_abs,
  i32_neg,
  i32_invert,
];

(function () {
  for (func of funcs) {
    RunAsmJsTest(WrapInAsmModule(func), function (module) {
      if (func.length == 1) {
        for (a of inputs) {
          assertEquals(func(a), module.main(a));
        }
      } else {
        for (a of inputs) {
          for (b of inputs) {
            assertEquals(func(a, b), module.main(a, b));
          }
        }
      }
    });
  }

})();
                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/wasm/asm-wasm-imports.js                                           0000664 0000000 0000000 00000010403 14746647661 0023240 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --validate-asm --allow-natives-syntax

var stdlib = this;

function assertValidAsm(func) {
  assertTrue(%IsAsmWasmCode(func), "must be valid asm code");
}

function assertWasm(expected, func, ffi) {
  print("Testing " + func.name + "...");
  assertEquals(
      expected, func(stdlib, ffi, new ArrayBuffer(1024)).caller());
  assertValidAsm(func);
}


function TestForeignFunctions() {
  function AsmModule(stdlib, foreign, buffer) {
    "use asm";

    var setVal = foreign.setVal;
    var getVal = foreign.getVal;

    function caller(initial_value, new_value) {
      initial_value = initial_value|0;
      new_value = new_value|0;
      if ((getVal()|0) == (initial_value|0)) {
        setVal(new_value|0);
        return getVal()|0;
      }
      return 0;
    }

    return {caller:caller};
  }

  function ffi(initial_val) {
    var val = initial_val;

    function getVal() {
      return val;
    }

    function setVal(new_val) {
      val = new_val;
    }

    return {getVal:getVal, setVal:setVal};
  }

  var foreign = new ffi(23);

  var module = AsmModule({Math: Math}, foreign, null);
  assertValidAsm(AsmModule);

  assertEquals(103, module.caller(23, 103));
}

print("TestForeignFunctions...");
TestForeignFunctions();


function TestForeignFunctionMultipleUse() {
  function AsmModule(stdlib, foreign, buffer) {
    "use asm";

    var getVal = foreign.getVal;

    function caller(int_val, double_val) {
      int_val = int_val|0;
      double_val = +double_val;
      if ((getVal()|0) == (int_val|0)) {
        if ((+getVal()) == (+double_val)) {
          return 89;
        }
      }
      return 0;
    }

    return {caller:caller};
  }

  function ffi() {
    function getVal() {
      return 83.25;
    }

    return {getVal:getVal};
  }

  var foreign = new ffi();

  var module_decl = eval('(' + AsmModule.toString() + ')');
  var module = module_decl(stdlib, foreign, null);
  assertValidAsm(module_decl);

  assertEquals(89, module.caller(83, 83.25));
}

print("TestForeignFunctionMultipleUse...");
TestForeignFunctionMultipleUse();

function TestForeignVariables() {
  function AsmModule(stdlib, foreign, buffer) {
    "use asm";

    var i1 = foreign.foo | 0;
    var f1 = +foreign.bar;
    var i2 = foreign.baz | 0;
    var f2 = +foreign.baz;

    function geti1() {
      return i1|0;
    }

    function getf1() {
      return +f1;
    }

    function geti2() {
      return i2|0;
    }

    function getf2() {
      return +f2;
    }

    return {geti1:geti1, getf1:getf1, geti2:geti2, getf2:getf2};
  }

  function TestCase(env, i1, f1, i2, f2) {
    print("Testing foreign variables...");
    var module_decl = eval('(' + AsmModule.toString() + ')');
    var module = module_decl(stdlib, env);
    assertValidAsm(module_decl);
    assertEquals(i1, module.geti1());
    assertEquals(f1, module.getf1());
    assertEquals(i2, module.geti2());
    assertEquals(f2, module.getf2());
  }

  // Check normal operation.
  TestCase({foo: 123, bar: 234.5, baz: 345.7}, 123, 234.5, 345, 345.7);
  // Check partial operation.
  TestCase({baz: 345.7}, 0, NaN, 345, 345.7);
  // Check that undefined values are converted to proper defaults.
  TestCase({qux: 999}, 0, NaN, 0, NaN);
  // Check that true values are converted properly.
  TestCase({foo: true, bar: true, baz: true}, 1, 1.0, 1, 1.0);
  // Check that false values are converted properly.
  TestCase({foo: false, bar: false, baz: false}, 0, 0, 0, 0);
  // Check that null values are converted properly.
  TestCase({foo: null, bar: null, baz: null}, 0, 0, 0, 0);
  // Check that string values are converted properly.
  TestCase({foo: 'hi', bar: 'there', baz: 'dude'}, 0, NaN, 0, NaN);
  TestCase({foo: '0xff', bar: '234', baz: '456.1'}, 255, 234, 456, 456.1);
  // Check that function values are converted properly.
  TestCase({foo: TestCase, bar: TestCase, qux: TestCase}, 0, NaN, 0, NaN);
}

print("TestForeignVariables...");
TestForeignVariables();


function TestGlobalBlock(stdlib, foreign, buffer) {
  "use asm";

  var x = foreign.x | 0, y = foreign.y | 0;

  function test() {
    return (x + y) | 0;
  }

  return {caller: test};
}

assertWasm(15, TestGlobalBlock, { x: 4, y: 11 });
                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/asm-wasm-literals.js                                          0000664 0000000 0000000 00000022101 14746647661 0023360 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --validate-asm --allow-natives-syntax

function RunAsmJsTest(asmfunc, expect) {
  var asm_source = asmfunc.toString();
  var nonasm_source = asm_source.replace(new RegExp("use asm"), "");
  var stdlib = {Math: Math};

  print("Testing " + asmfunc.name + " (js)...");
  var js_module = eval("(" + nonasm_source + ")")(stdlib);
  expect(js_module);

  print("Testing " + asmfunc.name + " (asm.js)...");
  var asm_module = asmfunc(stdlib);
  assertTrue(%IsAsmWasmCode(asmfunc));
  expect(asm_module);
}

function PositiveIntLiterals() {
  "use asm";
  function f0() { return 0; }
  function f1() { return 1; }
  function f4() { return 4; }
  function f64() { return 64; }
  function f127() { return 127; }
  function f128() { return 128; }
  function f256() { return 256; }
  function f1000() { return 1000; }
  function f2000000() { return 2000000; }
  function fmax() { return 2147483647; }
  return {f0: f0, f1: f1, f4: f4, f64: f64, f127: f127, f128: f128,
          f256: f256, f1000: f1000, f2000000: f2000000, fmax: fmax};
}

RunAsmJsTest(PositiveIntLiterals, function(module) {
  assertEquals(0, module.f0());
  assertEquals(1, module.f1());
  assertEquals(1, module.f1());
  assertEquals(4, module.f4());
  assertEquals(64, module.f64());
  assertEquals(128, module.f128());
  assertEquals(256, module.f256());
  assertEquals(1000, module.f1000());
  assertEquals(2000000, module.f2000000());
  assertEquals(2147483647, module.fmax());
});

function NegativeIntLiterals() {
  "use asm";
  function f1() { return -1; }
  function f4() { return -4; }
  function f64() { return -64; }
  function f127() { return -127; }
  function f128() { return -128; }
  function f256() { return -256; }
  function f1000() { return -1000; }
  function f2000000() { return -2000000; }
  function fmin() { return -2147483648; }
  return {f1: f1, f4: f4, f64: f64, f127: f127, f128: f128,
          f256: f256, f1000: f1000, f2000000: f2000000, fmin: fmin};
}

RunAsmJsTest(NegativeIntLiterals, function (module) {
  assertEquals(-1, module.f1());
  assertEquals(-4, module.f4());
  assertEquals(-64, module.f64());
  assertEquals(-127, module.f127());
  assertEquals(-128, module.f128());
  assertEquals(-256, module.f256());
  assertEquals(-1000, module.f1000());
  assertEquals(-2000000, module.f2000000());
  assertEquals(-2147483648, module.fmin());
});

function PositiveUnsignedLiterals() {
  "use asm";
  function f0() { return +(0 >>> 0); }
  function f1() { return +(1 >>> 0); }
  function f4() { return +(4 >>> 0); }
  function f64() { return +(64 >>> 0); }
  function f127() { return +(127 >>> 0); }
  function f128() { return +(128 >>> 0); }
  function f256() { return +(256 >>> 0); }
  function f1000() { return +(1000 >>> 0); }
  function f2000000() { return +(2000000 >>> 0); }
  function fmax() { return +(2147483647 >>> 0); }
  return {f0: f0, f1: f1, f4: f4, f64: f64, f127: f127, f128: f128,
          f256: f256, f1000: f1000, f2000000: f2000000, fmax: fmax};
}

RunAsmJsTest(PositiveUnsignedLiterals, function (module) {
  assertEquals(0, module.f0());
  assertEquals(1, module.f1());
  assertEquals(4, module.f4());
  assertEquals(64, module.f64());
  assertEquals(128, module.f128());
  assertEquals(256, module.f256());
  assertEquals(1000, module.f1000());
  assertEquals(2000000, module.f2000000());
  assertEquals(2147483647, module.fmax());
});

function LargeUnsignedLiterals() {
  "use asm";
  function a() {
    var x = 2147483648;
    return +(x >>> 0);
  }
  function b() {
    var x = 2147483649;
    return +(x >>> 0);
  }
  function c() {
    var x = 0x80000000;
    return +(x >>> 0);
  }
  function d() {
    var x = 0x80000001;
    return +(x >>> 0);
  }
  function e() {
    var x = 0xffffffff;
    return +(x >>> 0);
  }
  return {a: a, b: b, c: c, d: d, e: e};
}

RunAsmJsTest(LargeUnsignedLiterals, function(module) {
  assertEquals(2147483648, module.a());
  assertEquals(2147483649, module.b());
  assertEquals(0x80000000, module.c());
  assertEquals(0x80000001, module.d());
  assertEquals(0xffffffff, module.e());
});

function ManyI32() {
  "use asm";
  function main() {
    var a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0, h = 0, i = 0, j = 0;
    a =          1 +          -2 +          3 +          -4 | 0;
    b =         11 +         -22 +         33 +         -44 | 0;
    c =        111 +        -222 +        333 +        -444 | 0;
    d =       1111 +       -2222 +       3333 +       -4444 | 0;
    e =      11111 +      -22222 +      33333 +      -44444 | 0;
    f =     155555 +     -266666 +     377777 +     -488888 | 0;
    g =    1155555 +    -2266666 +    3377777 +    -4488888 | 0;
    h =   11155555 +   -22266666 +   33377777 +   -44488888 | 0;
    i =  111155555 +  -222266666 +  333377777 +  -444488888 | 0;
    j = (
      0x1        + 0x2        + 0x4        + 0x8       +
      0x10       + 0x20       + 0x40       + 0x80      +
      0x10F      + 0x200      + 0x400      + 0x800     +
      0x10E0     + 0x20F0     + 0x4000     + 0x8000    +
      0x10D00    + 0x20E00    + 0x400F0    + 0x80002   +
      0x10C000   + 0x20D000   + 0x400E00   + 0x800030  +
      0x10B0000  + 0x20C0000  + 0x400D000  + 0x8000400 +
      0x10A00000 + 0x20B00000 + 0x400C0000 + 0x80005000
    ) | 0;
    return (a + b + c + d + e + f + g + h + i + j) | 0;
  }
  return {main: main};
}

RunAsmJsTest(ManyI32, function(module) {
  assertEquals(-222411306, module.main());
});


function ManyF64a() {
  "use asm";
  function main() {
    var a = 0.0, b = 0.0, c = 0.0, d = 0.0,
        e = 0.0, f = 0.0, g = 0.0, h = 0.0, i = 0.0;
    a = +(       0.1 +         -0.2 +         0.3 +         -0.4);
    b = +(       1.1 +         -2.2 +        0.33 +         -4.4);
    c = +(      11.1 +        -22.2 +        3.33 +        -4.44);
    d = +(     111.1 +       -222.2 +       33.33 +       -4.444);
    e = +(    1111.1 +      -2222.2 +      333.33 +      -4.4444);
    f = +(   15555.5 +     -26666.6 +     3777.77 +     -4.88888);
    g = +(  115555.5 +    -226666.6 +    33777.77 +    -4.488888);
    h = +( 1115555.5 +   -2226666.6 +   333777.77 +   -4.4488888);
    i = +(11115555.5 +  -22226666.6 +  3333777.77 +  -4.44488888);
    return +(a + b + c + d + e + f + g + h + i);
  }
  return {main: main};
}

RunAsmJsTest(ManyF64a, function(module) {
  assertEquals(-8640233.599945681, module.main());
});

function ManyF64b() {
  "use asm";
  function k1() { return +(1.0e-25 + 3.0e-25 + 5.0e-25 + 6.0e-25 + 9.0e-25); }
  function k2() { return +(1.0e-20 + 3.0e-20 + 5.0e-20 + 6.0e-20 + 9.0e-20); }
  function k3() { return +(1.0e-15 + 3.0e-15 + 5.0e-15 + 6.0e-15 + 9.0e-15); }
  function k4() { return +(1.0e-10 + 3.0e-10 + 5.0e-10 + 6.0e-10 + 9.0e-10); }
  function k5() { return +(1.0e-5 + 3.0e-5 + 5.0e-5 + 6.0e-5 + 9.0e-5); }
  function k6() { return +(1.1e+0 + 3.1e+0 + 5.1e+0 + 6.1e+0 + 9.1e+0); }

  return {k1: k1, k2: k2, k3: k3, k4: k4, k5: k5, k6: k6};
}

RunAsmJsTest(ManyF64b, function(module) {
  assertEquals(2.4e-24, module.k1());
  assertEquals(2.4e-19, module.k2());
  assertEquals(2.4e-14, module.k3());
  assertEquals(2.4e-9, module.k4());
  assertEquals(0.00024000000000000003, module.k5());
  assertEquals(24.5, module.k6());
});


function ManyF64c() {
  "use asm";
  function k1() { return +(1.0e+25 + 3.0e+25 + 5.0e+25 + 6.0e+25 + 9.0e+25); }
  function k2() { return +(1.0e+20 + 3.0e+20 + 5.0e+20 + 6.0e+20 + 9.0e+20); }
  function k3() { return +(1.0e+15 + 3.0e+15 + 5.0e+15 + 6.0e+15 + 9.0e+15); }
  function k4() { return +(1.0e+10 + 3.0e+10 + 5.0e+10 + 6.0e+10 + 9.0e+10); }
  function k5() { return +(1.0e+5 + 3.0e+5 + 5.0e+5 + 6.0e+5 + 9.0e+5); }
  function k6() { return +(1.4e+0 + 3.4e+0 + 5.4e+0 + 6.4e+0 + 9.4e+0); }

  return {k1: k1, k2: k2, k3: k3, k4: k4, k5: k5, k6: k6};
}

RunAsmJsTest(ManyF64c, function(module) {
  assertEquals(2.4000000000000004e+26, module.k1());
  assertEquals(2.4e+21, module.k2());
  assertEquals(2.4e+16, module.k3());
  assertEquals(2.4e+11, module.k4());
  assertEquals(2.4e+6, module.k5());
  assertEquals(26, module.k6());
});

function ManyF32a(stdlib) {
  "use asm";
  var F = stdlib.Math.fround;

  function k1() { return F(F(1.0e-25) + F(5.0e-25) + F(6.0e-25) + F(9.0e-25)); }
  function k2() { return F(F(1.0e-20) + F(5.0e-20) + F(6.0e-20) + F(9.0e-20)); }
  function k3() { return F(F(1.0e-15) + F(5.0e-15) + F(6.0e-15) + F(9.0e-15)); }
  function k4() { return F(F(1.0e-10) + F(5.0e-10) + F(6.0e-10) + F(9.0e-10)); }
  function k5() { return F(F(1.0e-5)  + F(5.0e-5)  + F(6.0e-5)  + F(9.0e-5)); }
  function k6() { return F(F(1.1e+0)  + F(5.1e+0)  + F(6.1e+0)  + F(9.1e+0)); }

  return {k1: k1, k2: k2, k3: k3, k4: k4, k5: k5, k6: k6};
}

if (false) {
  // TODO(bradnelson): fails validation of F32 literals somehow.
RunAsmJsTest(ManyF32a, function(module) {
  assertEquals(2.0999999917333043e-24, module.k1());
  assertEquals(2.099999868734112e-19, module.k2());
  assertEquals(2.099999997029825e-14, module.k3());
  assertEquals(2.099999951710174e-9, module.k4());
  assertEquals(0.0002099999983329326, module.k5());
  assertEquals(21.399999618530273, module.k6());
});
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/wasm/asm-wasm-math-intrinsic.js                                    0000664 0000000 0000000 00000014114 14746647661 0024477 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --validate-asm  --allow-natives-syntax

function verbose(args) {
  // print(...args);
}

//=============================================
// Global count of failures
//=============================================
let numFailures = 0;

function reportFailure(name, vals, m, w) {
  print('  error: ' + name + '(' + vals + ') == ' + w + ', expected ' + m);
  numFailures++;
}

let inputs = [
  1 / 0,
  -1 / 0,
  0 / 0,
  -2.70497e+38,
  -1.4698e+37,
  -1.22813e+35,
  -1.34584e+34,
  -1.0079e+32,
  -6.49364e+26,
  -3.06077e+25,
  -1.46821e+25,
  -1.17658e+23,
  -1.9617e+22,
  -2.7357e+20,
  -9223372036854775808.0,  // INT64_MIN
  -1.48708e+13,
  -1.89633e+12,
  -4.66622e+11,
  -2.22581e+11,
  -1.45381e+10,
  -2147483904.0,  // First float32 after INT32_MIN
  -2147483648.0,  // INT32_MIN
  -2147483520.0,  // Last float32 before INT32_MIN
  -1.3956e+09,
  -1.32951e+09,
  -1.30721e+09,
  -1.19756e+09,
  -9.26822e+08,
  -5.09256e+07,
  -964300.0,
  -192446.0,
  -28455.0,
  -27194.0,
  -20575.0,
  -17069.0,
  -9167.0,
  -960.178,
  -113.0,
  -62.0,
  -15.0,
  -7.0,
  -1.0,
  -0.0256635,
  -4.60374e-07,
  -3.63759e-10,
  -4.30175e-14,
  -5.27385e-15,
  -1.5707963267948966,
  -1.48084e-15,
  -2.220446049250313e-16,
  -1.05755e-19,
  -3.2995e-21,
  -1.67354e-23,
  -1.11885e-23,
  -1.78506e-30,
  -1.43718e-34,
  -1.27126e-38,
  -0.0,
  3e-88,
  -2e66,
  0.0,
  2e66,
  1.17549e-38,
  1.56657e-37,
  4.08512e-29,
  6.25073e-22,
  4.1723e-13,
  1.44343e-09,
  1.5707963267948966,
  5.27004e-08,
  9.48298e-08,
  5.57888e-07,
  4.89988e-05,
  0.244326,
  1.0,
  12.4895,
  19.0,
  47.0,
  106.0,
  538.324,
  564.536,
  819.124,
  7048.0,
  12611.0,
  19878.0,
  20309.0,
  797056.0,
  1.77219e+09,
  2147483648.0,  // INT32_MAX + 1
  4294967296.0,  // UINT32_MAX + 1
  1.51116e+11,
  4.18193e+13,
  3.59167e+16,
  9223372036854775808.0,   // INT64_MAX + 1
  18446744073709551616.0,  // UINT64_MAX + 1
  3.38211e+19,
  2.67488e+20,
  1.78831e+21,
  9.20914e+21,
  8.35654e+23,
  1.4495e+24,
  5.94015e+25,
  4.43608e+30,
  2.44502e+33,
  1.38178e+37,
  1.71306e+37,
  3.31899e+38,
  3.40282e+38,
];

let stdlib = this;

// Module template for generating f64 unop functions.
function ModuleTemplate_f64_unop(stdlib) {
  'use asm';

  var Stdlib = stdlib.Math.NAME;

  function NAME(a) {
    a = +a;
    return +Stdlib(a);
  }

  return {NAME: NAME};
}

// Module template for generating f64 binop functions.
function ModuleTemplate_f64_binop(stdlib) {
  'use asm';

  var Stdlib = stdlib.Math.NAME;

  function NAME(a, b) {
    a = +a;
    b = +b;
    return +Stdlib(a, b);
  }

  return {NAME: NAME};
}

// Module template for generating f64 unop functions.
function ModuleTemplate_f32_unop(stdlib) {
  'use asm';

  var Stdlib = stdlib.Math.NAME;
  var fround = stdlib.Math.fround;

  function NAME(a) {
    a = fround(a);
    return fround(Stdlib(a));
  }

  return {NAME: NAME};
}

// Module template for generating f64 binop functions.
function ModuleTemplate_f32_binop(stdlib) {
  'use asm';

  var Stdlib = stdlib.Math.NAME;
  var fround = stdlib.Math.fround;

  function NAME(a, b) {
    a = fround(a);
    b = fround(b);
    return fround(Stdlib(a, b));
  }

  return {NAME: NAME};
}

function instantiateTemplate(func, name) {
  let src = func.toString();
  src = src.replace(/NAME/g, name);
  let module = eval('(' + src + ')');
  let instance = module(stdlib);
  assertTrue(%IsAsmWasmCode(module));

  let asm_func = instance[name];
  if (typeof asm_func != 'function') throw 'asm[' + full_name + '] not found';
  return asm_func;
}

function genUnop(name, f32) {
  return instantiateTemplate(
      f32 ? ModuleTemplate_f32_unop : ModuleTemplate_f64_unop, name);
}

function genBinop(name, f32) {
  return instantiateTemplate(
      f32 ? ModuleTemplate_f32_binop : ModuleTemplate_f64_binop, name);
}

function assertUnop(name, math_func, asm_func) {
  for (val of inputs) {
    verbose('  ', val);
    let m = math_func(val);
    let w = asm_func(val);
    if (!deepEquals(m, w)) reportFailure(name, [val], m, w);
  }
}

function assertBinop(name, math_func, asm_func) {
  let inputs2 = [1, 0.5, -1, -0.5, 0, -0, 1 / 0, -1 / 0, 0 / 0];
  for (val of inputs) {
    verbose('  ', val);
    for (val2 of inputs2) {
      verbose('    ', val2);
      let m = math_func(val, val2);
      let w = asm_func(val, val2);
      if (!deepEquals(m, w)) reportFailure(name, [val, val2], m, w);
      m = math_func(val2, val);
      w = asm_func(val2, val);
      if (!deepEquals(m, w)) reportFailure(name, [val2, val], m, w);
    }
  }
}

(function TestF64() {
  let f64_intrinsics = [
    'acos',  'asin', 'atan', 'cos',   'sin',   'tan',  'exp', 'log',
    'atan2', 'pow',  'ceil', 'floor', 'sqrt',  'min',  'max', 'abs',
    'min',   'max',  'abs',  'ceil',  'floor', 'sqrt',
  ];

  for (let name of f64_intrinsics) {
    let math_func = Math[name];
    print('Testing (f64) Math.' + name);
    switch (math_func.length) {
      case 1: {
        let asm_func = genUnop(name, false);
        assertUnop('(f64)' + name, math_func, asm_func);
        break;
      }
      case 2: {
        let asm_func = genBinop(name, false);
        assertBinop('(f64)' + name, math_func, asm_func);
        break;
      }
      default:
        throw 'Unexpected param count: ' + func.length;
    }
  }
})();

(function TestF32() {
  let f32_intrinsics = ['min', 'max', 'abs', 'ceil', 'floor', 'sqrt'];

  for (let name of f32_intrinsics) {
    let r = Math.fround, f = Math[name];
    print('Testing (f32) Math.' + name);
    switch (f.length) {
      case 1: {
        let asm_func = genUnop(name, true);
        let math_func = (val) => r(f(r(val)));
        assertUnop('(f32)' + name, math_func, asm_func);
        break;
      }
      case 2: {
        let asm_func = genBinop(name, true);
        let math_func = (v1, v2) => r(f(r(v1), r(v2)));
        assertBinop('(f32)' + name, math_func, asm_func);
        break;
      }
      default:
        throw 'Unexpected param count: ' + func.length;
    }
  }
})();

assertEquals(0, numFailures);
                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/test/mjsunit/wasm/asm-wasm-memory.js                                            0000664 0000000 0000000 00000011767 14746647661 0023071 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --validate-asm --allow-natives-syntax

var stdlib = this;
let kMinHeapSize = 4096;

function assertValidAsm(func) {
  assertTrue(%IsAsmWasmCode(func), "must be valid asm code");
}

function assertWasm(expected, func, ffi) {
  print("Testing " + func.name + "...");
  assertEquals(
      expected, func(stdlib, ffi, new ArrayBuffer(kMinHeapSize)).caller());
  assertValidAsm(func);
}


function TestInt32HeapAccess(stdlib, foreign, buffer) {
  "use asm";

  var m = new stdlib.Int32Array(buffer);
  function caller() {
    var i = 4;

    m[0] = (i + 1) | 0;
    m[i >> 2] = ((m[0]|0) + 1) | 0;
    m[2] = ((m[i >> 2]|0) + 1) | 0;
    return m[2] | 0;
  }

  return {caller: caller};
}

assertWasm(7, TestInt32HeapAccess);


function TestInt32HeapAccessExternal() {
  var memory = new ArrayBuffer(kMinHeapSize);
  var memory_int32 = new Int32Array(memory);
  var module_decl = eval('(' + TestInt32HeapAccess.toString() + ')');
  var module = module_decl(stdlib, null, memory);
  assertValidAsm(module_decl);
  assertEquals(7, module.caller());
  assertEquals(7, memory_int32[2]);
}

TestInt32HeapAccessExternal();


function TestHeapAccessIntTypes() {
  var types = [
    [Int8Array, 'Int8Array', '>> 0'],
    [Uint8Array, 'Uint8Array', '>> 0'],
    [Int16Array, 'Int16Array', '>> 1'],
    [Uint16Array, 'Uint16Array', '>> 1'],
    [Int32Array, 'Int32Array', '>> 2'],
    [Uint32Array, 'Uint32Array', '>> 2'],
  ];
  for (var i = 0; i < types.length; i++) {
    var code = TestInt32HeapAccess.toString();
    code = code.replace('Int32Array', types[i][1]);
    code = code.replace(/>> 2/g, types[i][2]);
    var memory = new ArrayBuffer(kMinHeapSize);
    var memory_view = new types[i][0](memory);
    var module_decl = eval('(' + code + ')');
    var module = module_decl(stdlib, null, memory);
    assertValidAsm(module_decl);
    assertEquals(7, module.caller());
    assertEquals(7, memory_view[2]);
    assertValidAsm(module_decl);
  }
}

TestHeapAccessIntTypes();


function TestFloatHeapAccess(stdlib, foreign, buffer) {
  "use asm";

  var f32 = new stdlib.Float32Array(buffer);
  var f64 = new stdlib.Float64Array(buffer);
  var fround = stdlib.Math.fround;
  function caller() {
    var i = 8;
    var j = 8;
    var v = 6.0;

    f64[2] = v + 1.0;
    f64[i >> 3] = +f64[2] + 1.0;
    f64[j >> 3] = +f64[j >> 3] + 1.0;
    i = +f64[i >> 3] == 9.0;
    return i|0;
  }

  return {caller: caller};
}

assertWasm(1, TestFloatHeapAccess);


function TestFloatHeapAccessExternal() {
  var memory = new ArrayBuffer(kMinHeapSize);
  var memory_float64 = new Float64Array(memory);
  var module_decl = eval('(' + TestFloatHeapAccess.toString() + ')');
  var module = module_decl(stdlib, null, memory);
  assertValidAsm(module_decl);
  assertEquals(1, module.caller());
  assertEquals(9.0, memory_float64[1]);
}

TestFloatHeapAccessExternal();


(function() {
  function TestByteHeapAccessCompat(stdlib, foreign, buffer) {
    "use asm";

    var HEAP8 = new stdlib.Uint8Array(buffer);
    var HEAP32 = new stdlib.Int32Array(buffer);

    function store(i, v) {
      i = i | 0;
      v = v | 0;
      HEAP32[i >> 2] = v;
    }

    function storeb(i, v) {
      i = i | 0;
      v = v | 0;
      HEAP8[i | 0] = v;
    }

    function load(i) {
      i = i | 0;
      return HEAP8[i] | 0;
    }

    function iload(i) {
      i = i | 0;
      return HEAP8[HEAP32[i >> 2] | 0] | 0;
    }

    return {load: load, iload: iload, store: store, storeb: storeb};
  }

  var memory = new ArrayBuffer(kMinHeapSize);
  var module_decl = eval('(' + TestByteHeapAccessCompat.toString() + ')');
  var m = module_decl(stdlib, null, memory);
  assertValidAsm(module_decl);
  m.store(0, 20);
  m.store(4, 21);
  m.store(8, 22);
  m.storeb(20, 123);
  m.storeb(21, 42);
  m.storeb(22, 77);
  assertEquals(123, m.load(20));
  assertEquals(42, m.load(21));
  assertEquals(77, m.load(22));
  assertEquals(123, m.iload(0));
  assertEquals(42, m.iload(4));
  assertEquals(77, m.iload(8));
})();


function TestIntishAssignment(stdlib, foreign, heap) {
  "use asm";
  var HEAP32 = new stdlib.Int32Array(heap);
  function func() {
    var a = 1;
    var b = 2;
    HEAP32[0] = a + b;
    return HEAP32[0] | 0;
  }
  return {caller: func};
}

assertWasm(3, TestIntishAssignment);


function TestFloatishAssignment(stdlib, foreign, heap) {
  "use asm";
  var HEAPF32 = new stdlib.Float32Array(heap);
  var fround = stdlib.Math.fround;
  function func() {
    var a = fround(1.0);
    var b = fround(2.0);
    HEAPF32[0] = a + b;
    return +HEAPF32[0];
  }
  return {caller: func};
}

assertWasm(3, TestFloatishAssignment);


function TestDoubleToFloatAssignment(stdlib, foreign, heap) {
  "use asm";
  var HEAPF32 = new stdlib.Float32Array(heap);
  var fround = stdlib.Math.fround;
  function func() {
    var a = 1.23;
    HEAPF32[0] = a;
    return +HEAPF32[0];
  }
  return {caller: func};
}

assertWasm(Math.fround(1.23), TestDoubleToFloatAssignment);
         node-23.7.0/deps/v8/test/mjsunit/wasm/asm-wasm-names.js                                             0000664 0000000 0000000 00000001330 14746647661 0022645 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --validate-asm

function Module(stdlib, foreign, buffer) {
  "use asm";
  function foo() {}
  return {bar: foo};
}

var func = Module({}, {}, new ArrayBuffer(65536)).bar;
assertEquals("Module", Module.name);
assertEquals("foo", func.name);
assertEquals("function foo() {}", func.toString());

function imp() {}
function Module2(stdlib, imports) {
  "use asm";
  var imp = imports.imp;
  function bar() {}
  return {bar: bar};
}

var bar = Module2({}, {imp: imp}).bar;
assertEquals("bar", bar.name);
assertEquals("function bar() {}", bar.toString());
                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/wasm/asm-wasm-stack.js                                             0000664 0000000 0000000 00000011722 14746647661 0022655 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --validate-asm --allow-natives-syntax

var filename = '(?:[^ ]+/)?test/mjsunit/wasm/asm-wasm-stack.js';
filename = filename.replace(/\//g, '[/\\\\]');

function checkPreformattedStack(e, expected_lines) {
  print('preformatted stack: ' + e.stack);
  var lines = e.stack.split('\n');
  assertEquals(expected_lines.length, lines.length);
  for (var i = 0; i < lines.length; ++i) {
    assertMatches(expected_lines[i], lines[i], 'line ' + i);
  }
}

function printCallsites(stack) {
  print('callsite objects (size ' + stack.length + '):');
  for (var i = 0; i < stack.length; ++i) {
    var s = stack[i];
    print(
        ' [' + i + '] ' + s.getFunctionName() + ' (' + s.getFileName() + ':' +
        s.getLineNumber() + ':' + s.getColumnNumber() + ')');
  }
}

function checkCallsiteArray(stack, expected) {
  assertEquals(expected.length, stack.length, 'stack size');
  for (var i = 0; i < expected.length; ++i) {
    var cs = stack[i];
    assertMatches('^' + filename + '$', cs.getFileName(), 'file name at ' + i);
    assertEquals(expected[i][0], cs.getFunctionName(), 'function name at ' + i);
    assertEquals(expected[i][1], cs.getLineNumber(), 'line number at ' + i);
    assertEquals(expected[i][2], cs.getColumnNumber(), 'column number at ' + i);
    assertNotNull(cs.getThis(), 'receiver should be global');
    assertEquals(stack[0].getThis(), cs.getThis(), 'receiver should be global');
  }
}

function checkFunctionsOnCallsites(e, expected) {
  printCallsites(e.stack);
  checkCallsiteArray(e.stack, expected);
}

function checkTopFunctionsOnCallsites(e, expected) {
  printCallsites(e.stack);
  assertTrue(
      e.stack.length >= expected.length, 'expected at least ' +
          expected.length + ' callsites, got ' + e.stack.length);
  checkCallsiteArray(e.stack.slice(0, expected.length), expected);
}

function throwException() {
  throw new Error('exception from JS');
}

function generateWasmFromAsmJs(stdlib, foreign) {
  'use asm';
  var throwFunc = foreign.throwFunc;
  function callThrow() {
    throwFunc();
  }
  function redirectFun(i) {
    i = i | 0;
    switch (i | 0) {
      case 0: callThrow(); break;
      case 1: redirectFun(0); break;
      case 2: redirectFun(1); break;
      case 3: funTable[i & 0](2); break;
      case 4: forwardFun(); break;
    }
  }
  function forwardFun() {
    redirectFun(3);
  }
  var funTable = [ redirectFun ];
  return redirectFun;
}

(function PreformattedStackTraceFromJS() {
  var fun = generateWasmFromAsmJs(this, {throwFunc: throwException});
  assertTrue(%IsWasmCode(fun));
  var e = null;
  try {
    fun(0);
  } catch (ex) {
    e = ex;
  }
  assertInstanceof(e, Error, 'exception should have been thrown');
  checkPreformattedStack(e, [
    '^Error: exception from JS$',
    '^ *at throwException \\(' + filename + ':56:9\\)$',
    '^ *at callThrow \\(' + filename + ':63:5\\)$',
    '^ *at redirectFun \\(' + filename + ':68:15\\)$',
    '^ *at PreformattedStackTraceFromJS \\(' + filename + ':87:5\\)$',
    '^ *at ' + filename + ':100:3$'
  ]);
})();

// Now collect the Callsite objects instead of just a string.
Error.prepareStackTrace = function(error, frames) {
  return frames;
};

(function CallsiteObjectsFromJS() {
  var fun = generateWasmFromAsmJs(this, {throwFunc: throwException});
  assertTrue(%IsWasmCode(fun));
  var e = null;
  try {
    fun(4);
  } catch (ex) {
    e = ex;
  }
  assertInstanceof(e, Error, 'exception should have been thrown');
  checkFunctionsOnCallsites(e, [
    ['throwException', 56, 9],          // --
    ['callThrow', 63, 5],               // --
    ['redirectFun', 68, 15],            // --
    ['redirectFun', 69, 15],            // --
    ['redirectFun', 70, 15],            // --
    ['redirectFun', 71, 30],            // --
    ['forwardFun', 76, 5],             // --
    ['redirectFun', 72, 15],            // --
    ['CallsiteObjectsFromJS', 112, 5],  // --
    [null, 129, 3]
  ]);
})();

function generateOverflowWasmFromAsmJs() {
  'use asm';
  function f(a) {
    a = a | 0;
    return f(a) | 0;
  }
  return f;
}

(function StackOverflowPosition() {
  var fun = generateOverflowWasmFromAsmJs();
  assertTrue(%IsWasmCode(fun));
  var e = null;
  try {
    fun(23);
  } catch (ex) {
    e = ex;
  }
  assertInstanceof(e, RangeError, 'RangeError should have been thrown');
  checkTopFunctionsOnCallsites(e, [
    ['f', 133,  3],  // --
    ['f', 135, 12],  // --
    ['f', 135, 12],  // --
    ['f', 135, 12]   // --
  ]);
})();

(function EnclosingFunctionOffsets() {
  const fun = generateWasmFromAsmJs(this, {throwFunc: throwException});
  assertTrue(%IsWasmCode(fun));
  let e = null;
  try {
    fun(0);
  } catch (ex) {
    e = ex;
  }
  assertEquals(68, e.stack[2].getLineNumber());
  assertEquals(15, e.stack[2].getColumnNumber());
  assertEquals(65, e.stack[2].getEnclosingLineNumber());
  assertEquals(3, e.stack[2].getEnclosingColumnNumber());
})();
                                              node-23.7.0/deps/v8/test/mjsunit/wasm/asm-wasm-stdlib.js                                            0000664 0000000 0000000 00000033164 14746647661 0023035 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --validate-asm --allow-natives-syntax

var stdlib = this;

function assertValidAsm(func) {
  assertTrue(%IsAsmWasmCode(func));
}

(function TestStdlibConstants() {
  function Module(stdlib) {
    "use asm";

    var StdlibInfinity = stdlib.Infinity;
    var StdlibNaN = stdlib.NaN;
    var StdlibMathE = stdlib.Math.E;
    var StdlibMathLN10 = stdlib.Math.LN10;
    var StdlibMathLN2 = stdlib.Math.LN2;
    var StdlibMathLOG2E = stdlib.Math.LOG2E;
    var StdlibMathLOG10E = stdlib.Math.LOG10E;
    var StdlibMathPI = stdlib.Math.PI;
    var StdlibMathSQRT1_2 = stdlib.Math.SQRT1_2;
    var StdlibMathSQRT2 = stdlib.Math.SQRT2;

    function caller() {
      if (StdlibInfinity != 1.0 / 0.0) return 0;
      if (StdlibMathE != 2.718281828459045) return 0;
      if (StdlibMathLN10 != 2.302585092994046) return 0;
      if (StdlibMathLN2 != 0.6931471805599453) return 0;
      if (StdlibMathLOG2E != 1.4426950408889634) return 0;
      if (StdlibMathLOG10E != 0.4342944819032518) return 0;
      if (StdlibMathPI != 3.141592653589793) return 0;
      if (StdlibMathSQRT1_2 != 0.7071067811865476) return 0;
      if (StdlibMathSQRT2 != 1.4142135623730951) return 0;
      return 1;
    }

    function nanCheck() {
      return +StdlibNaN;
    }

    return {caller:caller, nanCheck:nanCheck};
  }

  var m = Module(stdlib);
  assertValidAsm(Module);
  assertEquals(1, m.caller());
  assertTrue(isNaN(m.nanCheck()));
})();


var stdlib = this;
var stdlib_root_members = [
  'Infinity',
  'NaN',
];
var stdlib_math_members = [
  'E',
  'LN10',
  'LN2',
  'LOG2E',
  'LOG10E',
  'PI',
  'SQRT1_2',
  'SQRT2',
  'ceil',
  'clz32',
  'floor',
  'sqrt',
  'abs',
  'min',
  'max',
  'acos',
  'asin',
  'atan',
  'cos',
  'sin',
  'tan',
  'exp',
  'log',
  'atan2',
  'pow',
  'imul',
  'fround',
];


(function TestBadStdlib() {
  function Module(stdlib) {
    "use asm";
    var foo = stdlib.NaN;
    return {};
  }
  for (var i = 0; i < stdlib_root_members.length; ++i) {
    var member = stdlib_root_members[i];
    var stdlib = {};
    stdlib[member] = 0;
    print(member);
    var code = Module.toString().replace('NaN', member);
    var decl = eval('(' + code + ')');
    decl(stdlib);
    assertFalse(%IsAsmWasmCode(decl));
  }
  for (var i = 0; i < stdlib_math_members.length; ++i) {
    var member = stdlib_math_members[i];
    var stdlib = {Math:{}};
    stdlib['Math'][member] = 0;
    print(member);
    var code = Module.toString().replace('NaN', 'Math.' + member);
    var decl = eval('(' + code + ')');
    decl(stdlib);
    assertFalse(%IsAsmWasmCode(decl));
  }
})();


(function TestMissingNaNStdlib() {
  function Module(stdlib) {
    "use asm";
    var foo = stdlib.NaN;
    return {};
  }
  for (var i = 0; i < stdlib_root_members.length; ++i) {
    var member = stdlib_root_members[i];
    var code = Module.toString().replace('NaN', member);
    var decl = eval('(' + code + ')');
    decl({});
    assertFalse(%IsAsmWasmCode(decl));
  }
  for (var i = 0; i < stdlib_math_members.length; ++i) {
    var member = stdlib_math_members[i];
    var code = Module.toString().replace('NaN', 'Math.' + member);
    var decl = eval('(' + code + ')');
    assertThrows(function() {
      decl({});
      assertFalse(%IsAsmWasmCode(decl));
    });
  }
})();


(function TestStdlibFunctionsInside() {
  function Module(stdlib) {
    "use asm";

    var StdlibMathCeil = stdlib.Math.ceil;
    var StdlibMathClz32 = stdlib.Math.clz32;
    var StdlibMathFloor = stdlib.Math.floor;
    var StdlibMathSqrt = stdlib.Math.sqrt;
    var StdlibMathAbs = stdlib.Math.abs;
    var StdlibMathMin = stdlib.Math.min;
    var StdlibMathMax = stdlib.Math.max;

    var StdlibMathAcos = stdlib.Math.acos;
    var StdlibMathAsin = stdlib.Math.asin;
    var StdlibMathAtan = stdlib.Math.atan;
    var StdlibMathCos = stdlib.Math.cos;
    var StdlibMathSin = stdlib.Math.sin;
    var StdlibMathTan = stdlib.Math.tan;
    var StdlibMathExp = stdlib.Math.exp;
    var StdlibMathLog = stdlib.Math.log;

    var StdlibMathAtan2 = stdlib.Math.atan2;
    var StdlibMathPow = stdlib.Math.pow;
    var StdlibMathImul = stdlib.Math.imul;

    var fround = stdlib.Math.fround;

    function deltaEqual(x, y) {
      x = +x;
      y = +y;
      var t = 0.0;
      t = x - y;
      if (t < 0.0) {
        t = t * -1.0;
      }
      return (t < 1.0e-13) | 0;
    }

    function caller() {
      if (!(deltaEqual(+StdlibMathSqrt(123.0), 11.090536506409418)|0)) return 0;
      if (fround(StdlibMathSqrt(fround(256.0))) != fround(16.0)) return 0;
      if (+StdlibMathCeil(123.7) != 124.0) return 0;
      if (fround(StdlibMathCeil(fround(123.7))) != fround(124.0)) return 0;
      if (+StdlibMathFloor(123.7) != 123.0) return 0;
      if (fround(StdlibMathFloor(fround(123.7))) != fround(123.0)) return 0;
      if (+StdlibMathAbs(-123.0) != 123.0) return 0;
      if (fround(StdlibMathAbs(fround(-123.0))) != fround(123.0)) return 0;
      if (+StdlibMathMin(123.4, 1236.4) != 123.4) return 0;
      if (fround(StdlibMathMin(fround(123.4),
            fround(1236.4))) != fround(123.4)) return 0;
      if (+StdlibMathMax(123.4, 1236.4) != 1236.4) return 0;
      if (fround(StdlibMathMax(fround(123.4), fround(1236.4)))
          != fround(1236.4)) return 0;

      if (!(deltaEqual(+StdlibMathAcos(0.1), 1.4706289056333368)|0)) return 0;
      if (!(deltaEqual(+StdlibMathAsin(0.2), 0.2013579207903308)|0)) return 0;
      if (!(deltaEqual(+StdlibMathAtan(0.2), 0.19739555984988078)|0)) return 0;
      if (!(deltaEqual(+StdlibMathCos(0.2), 0.9800665778412416)|0)) return 0;
      if (!(deltaEqual(+StdlibMathSin(0.2), 0.19866933079506122)|0)) return 0;
      if (!(deltaEqual(+StdlibMathTan(0.2), 0.20271003550867250)|0)) return 0;
      if (!(deltaEqual(+StdlibMathExp(0.2), 1.2214027581601699)|0)) return 0;
      if (!(deltaEqual(+StdlibMathLog(0.2), -1.6094379124341003)|0)) return 0;
      if ((StdlibMathClz32(134217728)|0) != 4) return 0;

      if ((StdlibMathImul(6, 7)|0) != 42) return 0;
      if (!(deltaEqual(+StdlibMathAtan2(6.0, 7.0), 0.7086262721276703)|0))
        return 0;
      if (+StdlibMathPow(6.0, 7.0) != 279936.0) return 0;

      return 1;
    }

    return {caller:caller};
  }

  var m = Module(stdlib);
  assertValidAsm(Module);
  assertEquals(1, m.caller());
})();


(function TestStdlibFunctionOutside() {
  function looseEqual(x, y, delta) {
    if (delta === undefined) {
      delta = 1.0e-10;
    }
    if (isNaN(x) && isNaN(y)) {
      return true;
    }
    if (!isFinite(x) && !isFinite(y)) {
      return true;
    }
    x = +x;
    y = +y;
    var t = 0.0;
    t = x - y;
    if (t < 0.0) {
      t = t * -1.0;
    }
    return (t < delta) | 0;
  }

  function plainEqual(x, y) {
    if (isNaN(x) && isNaN(y)) {
      return true;
    }
    return x === y;
  }

  function Module(stdlib) {
    "use asm";
    var ceil = stdlib.Math.ceil;
    var floor = stdlib.Math.floor;
    var sqrt = stdlib.Math.sqrt;
    var abs = stdlib.Math.abs;
    var fround = stdlib.Math.fround;
    var fround2 = stdlib.Math.fround;

    var acos = stdlib.Math.acos;
    var asin = stdlib.Math.asin;
    var atan = stdlib.Math.atan;
    var cos = stdlib.Math.cos;
    var sin = stdlib.Math.sin;
    var tan = stdlib.Math.tan;
    var exp = stdlib.Math.exp;
    var log = stdlib.Math.log;

    var atan2 = stdlib.Math.atan2;
    var pow = stdlib.Math.pow;
    var imul = stdlib.Math.imul;
    var min = stdlib.Math.min;
    var max = stdlib.Math.max;

    function ceil_f64(x) { x = +x; return +ceil(x); }
    function ceil_f32(x) { x = fround(x); return fround(ceil(x)); }

    function floor_f64(x) { x = +x; return +floor(x); }
    function floor_f32(x) { x = fround(x); return fround(floor(x)); }

    function sqrt_f64(x) { x = +x; return +sqrt(x); }
    function sqrt_f32(x) { x = fround(x); return fround(sqrt(x)); }

    function abs_f64(x) { x = +x; return +abs(x); }
    function abs_f32(x) { x = fround(x); return fround(abs(x)); }
    function abs_i32(x) { x = x | 0; return abs(x|0) | 0; }

    function acos_f64(x) { x = +x; return +acos(x); }
    function asin_f64(x) { x = +x; return +asin(x); }
    function atan_f64(x) { x = +x; return +atan(x); }
    function cos_f64(x) { x = +x; return +cos(x); }
    function sin_f64(x) { x = +x; return +sin(x); }
    function tan_f64(x) { x = +x; return +tan(x); }
    function exp_f64(x) { x = +x; return +exp(x); }
    function log_f64(x) { x = +x; return +log(x); }

    function atan2_f64(x, y) { x = +x; y = +y; return +atan2(x, y); }
    function pow_f64(x, y) { x = +x; y = +y; return +atan2(x, y); }

    function imul_i32(x, y) { x = x | 0; y = y | 0; return imul(x, y) | 0; }
    function imul_u32(x, y) {
      x = x | 0; y = y | 0; return imul(x>>>0, y>>>0) | 0; }

    // type -> f32
    function fround_i32(x) { x = x | 0; return fround(x|0); }
    function fround_u32(x) { x = x | 0; return fround(x>>>0); }
    function fround_f32(x) { x = fround(x); return fround(x); }
    function fround_f64(x) { x = +x; return fround(x); }

    // type -> f32 -> type
    function fround2_i32(x) { x = x | 0; return ~~fround2(x|0) | 0; }
    function fround2_u32(x) { x = x | 0; return ~~fround2(x>>>0) | 0; }
    function fround2_f32(x) { x = fround2(x); return fround2(x); }
    function fround2_f64(x) { x = +x; return +fround2(x); }

    function min_i32(x, y) { x = x | 0; y = y | 0; return min(x|0, y|0) | 0; }
    function min_f32(x, y) {
      x = fround(x); y = fround(y); return fround(min(x, y)); }
    function min_f64(x, y) { x = +x; y = +y; return +min(x, y); }

    function max_i32(x, y) { x = x | 0; y = y | 0; return max(x|0, y|0) | 0; }
    function max_f32(x, y) {
      x = fround(x); y = fround(y); return fround(max(x, y)); }
    function max_f64(x, y) { x = +x; y = +y; return +max(x, y); }

    return {
      ceil_f64: ceil_f64,
      ceil_f32: ceil_f32,
      floor_f64: floor_f64,
      floor_f32: floor_f32,
      sqrt_f64: sqrt_f64,
      sqrt_f32: sqrt_f32,
      abs_f64: abs_f64,
      abs_f32: abs_f32,
      abs_i32: abs_i32,
      acos_f64: acos_f64,
      asin_f64: asin_f64,
      atan_f64: atan_f64,
      cos_f64: cos_f64,
      sin_f64: sin_f64,
      tan_f64: tan_f64,
      exp_f64: exp_f64,
      log_f64: log_f64,
      imul_i32: imul_i32,
      imul_u32: imul_u32,
      fround_i32: fround_i32,
      fround_u32: fround_u32,
      fround_f32: fround_f32,
      fround_f64: fround_f64,
      fround2_i32: fround2_i32,
      fround2_u32: fround2_u32,
      fround2_f32: fround2_f32,
      fround2_f64: fround2_f64,
      min_i32: min_i32,
      min_f32: min_f32,
      min_f64: min_f64,
      max_i32: max_i32,
      max_f32: max_f32,
      max_f64: max_f64,
    };
  }
  var m = Module(stdlib);
  assertValidAsm(Module);
  var values = {
    i32: [
      0, 1, -1, 123, 456, -123, -456,
      0x40000000, 0x7FFFFFFF, -0x80000000,
    ],
    u32: [
      0, 1, 123, 456,
      0x40000000, 0x7FFFFFFF, 0xFFFFFFFF, 0x80000000,
    ],
    f32: [
      0, -0, 1, -1, 0.25, 0.125, 0.9, -0.9, 1.414,
      0x7F, -0x80, -0x8000, -0x80000000,
      0x7FFF, 0x7FFFFFFF, Infinity, -Infinity, NaN,
    ],
    f64: [
      0, -0, 1, -1, 0.25, 0.125, 0.9, -0.9, 1.414,
      0x7F, -0x80, -0x8000, -0x80000000,
      0x7FFF, 0x7FFFFFFF, Infinity, -Infinity, NaN,
    ],
  };
  var converts = {
    i32: function(x) { return x | 0; },
    u32: function(x) { return x >>> 0; },
    f32: function(x) { return Math.fround(x); },
    f64: function(x) { return x; },
  };
  var two_args = {atan2: true, pow: true, imul: true,
                  min: true, max: true};
  var funcs = {
    ceil: ['f32', 'f64'],
    floor: ['f32', 'f64'],
    sqrt: ['f32', 'f64'],
    abs: ['i32', 'f32', 'f64'],
    acos: ['f64'],
    asin: ['f64'],
    atan: ['f64'],
    cos: ['f64'],
    sin: ['f64'],
    tan: ['f64'],
    exp: ['f64'],
    log: ['f64'],
    imul: ['i32', 'u32'],
    fround: ['i32', 'u32', 'f32', 'f64'],
    min: ['i32', 'f32', 'f64'],
    max: ['i32', 'f32', 'f64'],
  };
  var per_func_equals = {
    // JS uses fdlib for these, so they may not match.
    // ECMAscript does not required them to have a particular precision.
    exp_f64: function(x, y) { return looseEqual(x, y, 1e55); },
    sqrt_f32: function(x, y) { return looseEqual(x, y, 1e-5); },
    cos_f64: looseEqual,
    sin_f64: looseEqual,
    tan_f64: looseEqual,
    // TODO(bradnelson):
    // Figure out why some builds (avx2, rel_ng) return a uint.
    imul_u32: function(x, y) { return (x | 0) === (y | 0); },
  };
  for (var func in funcs) {
    var types = funcs[func];
    for (var i = 0; i < types.length; i++) {
      var type = types[i];
      var interesting = values[type];
      for (var j = 0; j < interesting.length; j++) {
        for (var k = 0; k < interesting.length; k++) {
          var val0 = interesting[j];
          var val1 = interesting[k];
          var name = func + '_' + type;
          if (func === 'fround') {
            // fround returns f32 regardless of input.
            var expected = Math[func](val0);
            var actual = m[name](val0);
          } else if (two_args[func]) {
            var expected = converts[type](Math[func](val0, val1));
            var actual = m[name](val0, val1);
          } else {
            var expected = converts[type](Math[func](val0, val1));
            var actual = m[name](val0, val1);
          }
          var compare = per_func_equals[name];
          if (compare === undefined) {
            compare = plainEqual;
          }
          assertTrue(typeof(compare) === 'function');
          if (!compare(expected, actual)) {
            print(expected + ' !== ' + actual + ' for ' + name +
                  ' with input ' + val0 + ' ' + val1);
            assertTrue(false);
          }
        }
      }
    }
  }
})();
                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/wasm/asm-wasm-switch.js                                            0000664 0000000 0000000 00000024205 14746647661 0023051 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --validate-asm --allow-natives-syntax

function assertValidAsm(func) {
  assertTrue(%IsAsmWasmCode(func));
}

(function TestSwitch0() {
  function asmModule() {
    "use asm"

    function caller() {
      var ret = 0;
      var x = 7;
      switch (x|0) {
        case 1: {
          return 0;
        }
        case 7: {
          ret = 5;
          break;
        }
        default: return 0;
      }
      return ret|0;
    }

    return {caller:caller};
  }
  var wasm = asmModule();
  assertValidAsm(asmModule);
  assertEquals(5, wasm.caller());
})();

(function TestSwitch() {
  function asmModule() {
    "use asm"

    function caller() {
      var ret = 0;
      var x = 7;
      switch (x|0) {
        case 1: return 0;
        case 7: {
          ret = 12;
          break;
        }
        default: return 0;
      }
      switch (x|0) {
        case 1: return 0;
        case 8: return 0;
        default: ret = (ret + 11)|0;
      }
      return ret|0;
    }

    return {caller:caller};
  }
  var wasm = asmModule();
  assertValidAsm(asmModule);
  assertEquals(23, wasm.caller());
})();

(function TestSwitchFallthrough() {
  function asmModule() {
    "use asm"

    function caller() {
      var x = 17;
      var ret = 0;
      switch (x|0) {
        case 17:
        case 14: ret = 39;
        case 1: ret = (ret + 3)|0;
        case 4: break;
        default: ret = (ret + 1)|0;
      }
      return ret|0;
    }

    return {caller:caller};
  }
  var wasm = asmModule();
  assertValidAsm(asmModule);
  assertEquals(42, wasm.caller());
})();

(function TestNestedSwitch() {
  function asmModule() {
    "use asm"

    function caller() {
      var x = 3;
      var y = -13;
      switch (x|0) {
        case 1: return 0;
        case 3: {
          switch (y|0) {
            case 2: return 0;
            case -13: return 43;
            default: return 0;
          }
        }
        default: return 0;
      }
      return 0;
    }

    return {caller:caller};
  }
  var wasm = asmModule();
  assertValidAsm(asmModule);
  assertEquals(43, wasm.caller());
})();

(function TestSwitchWithDefaultOnly() {
  function asmModule() {
    "use asm";
    function main(x) {
      x = x|0;
      switch(x|0) {
        default: return -10;
      }
      return 0;
    }
    return {
      main: main,
    };
  }
  var wasm = asmModule();
  assertValidAsm(asmModule);
  assertEquals(-10, wasm.main(2));
  assertEquals(-10, wasm.main(54));
})();

(function TestEmptySwitch() {
  function asmModule() {
    "use asm";
    function main(x) {
      x = x|0;
      switch(x|0) {
      }
      return 73;
    }
    return {
      main: main,
    };
  }
  var wasm = asmModule();
  assertValidAsm(asmModule);
  assertEquals(73, wasm.main(7));
})();

(function TestSwitchWithBrTable() {
  function asmModule() {
    "use asm";
    function main(x) {
      x = x|0;
      switch(x|0) {
        case 14: return 23;
        case 12: return 25;
        case 15: return 29;
        case 19: return 34;
        case 18: return 17;
        case 16: return 16;
        default: return -1;
      }
      return 0;
    }
    return {
      main: main,
    };
  }
  var wasm = asmModule();
  assertValidAsm(asmModule);
  assertEquals(25, wasm.main(12));
  assertEquals(23, wasm.main(14));
  assertEquals(29, wasm.main(15));
  assertEquals(16, wasm.main(16));
  assertEquals(17, wasm.main(18));
  assertEquals(34, wasm.main(19));
  assertEquals(-1, wasm.main(-1));
})();

(function TestSwitchWithBalancedTree() {
  function asmModule() {
    "use asm";
    function main(x) {
      x = x|0;
      switch(x|0) {
        case 5: return 52;
        case 1: return 11;
        case 6: return 63;
        case 9: return 19;
        case -4: return -4;
      }
      return 0;
    }
    return {
      main: main,
    };
  }
  var wasm = asmModule();
  assertValidAsm(asmModule);
  assertEquals(-4, wasm.main(-4));
  assertEquals(11, wasm.main(1));
  assertEquals(52, wasm.main(5));
  assertEquals(63, wasm.main(6));
  assertEquals(19, wasm.main(9));
  assertEquals(0, wasm.main(11));
})();

(function TestSwitchHybrid() {
  function asmModule() {
    "use asm";
    function main(x) {
      x = x|0;
      switch(x|0) {
        case 1: return -4;
        case 2: return 23;
        case 3: return 32;
        case 4: return 14;
        case 7: return 17;
        case 10: return 10;
        case 11: return 121;
        case 12: return 112;
        case 13: return 31;
        case 16: return 16;
        default: return -1;
      }
      return 0;
    }
    return {
      main: main,
    };
  }
  var wasm = asmModule();
  assertValidAsm(asmModule);
  assertEquals(-4, wasm.main(1));
  assertEquals(23, wasm.main(2));
  assertEquals(32, wasm.main(3));
  assertEquals(14, wasm.main(4));
  assertEquals(17, wasm.main(7));
  assertEquals(10, wasm.main(10));
  assertEquals(121, wasm.main(11));
  assertEquals(112, wasm.main(12));
  assertEquals(31, wasm.main(13));
  assertEquals(16, wasm.main(16));
  assertEquals(-1, wasm.main(20));
})();

(function TestSwitchFallthroughWithBrTable() {
  function asmModule() {
    "use asm";
    function main(x) {
      x = x|0;
      var ret = 0;
      switch(x|0) {
        case 1: {
          ret = 21;
          break;
        }
        case 2: {
          ret = 12;
          break;
        }
        case 3: {
          ret = 43;
        }
        case 4: {
          ret = 54;
          break;
        }
        default: {
          ret = 10;
          break;
        }
      }
      return ret|0;
    }
    return {
      main: main,
    };
  }
  var wasm = asmModule();
  assertValidAsm(asmModule);
  assertEquals(12, wasm.main(2));
  assertEquals(10, wasm.main(10));
  assertEquals(54, wasm.main(3));
})();

(function TestSwitchFallthroughHybrid() {
  function asmModule() {
    "use asm";
    function main(x) {
      x = x|0;
      var ret = 0;
      switch(x|0) {
        case 1: {
          ret = 1;
          break;
        }
        case 2: {
          ret = 2;
          break;
        }
        case 3: {
          ret = 3;
          break;
        }
        case 4: {
          ret = 4;
        }
        case 7: {
          ret = 7;
          break;
        }
        case 10: {
          ret = 10;
        }
        case 16: {
          ret = 16;
          break;
        }
        case 17: {
          ret = 17;
          break;
        }
        case 18: {
          ret = 18;
          break;
        }
        case 19: {
          ret = 19;
        }
        default: {
          ret = -1;
          break;
        }
      }
      return ret|0;
    }
    return {
      main: main,
    };
  }
  var wasm = asmModule();
  assertValidAsm(asmModule);
  assertEquals(7, wasm.main(4));
  assertEquals(16, wasm.main(10));
  assertEquals(-1, wasm.main(19));
  assertEquals(-1, wasm.main(23));
})();

(function TestSwitchHybridWithNoDefault() {
  function asmModule() {
    "use asm";
    function main(x) {
      x = x|0;
      var ret = 19;
      switch(x|0) {
        case 1: {
          ret = 1;
          break;
        }
        case 2: {
          ret = 2;
          break;
        }
        case 3: {
          ret = 3;
          break;
        }
        case 4: {
          ret = 4;
          break;
        }
        case 7: {
          ret = 7;
          break;
        }
      }
      return ret|0;
    }
    return {
      main: main,
    };
  }
  var wasm = asmModule();
  assertValidAsm(asmModule);
  assertEquals(2, wasm.main(2));
  assertEquals(7, wasm.main(7));
  assertEquals(19, wasm.main(-1));
})();

(function TestLargeSwitch() {
  function LargeSwitchGenerator(begin, end, gap, handle_case) {
    var str = "function asmModule() {\
      \"use asm\";\
      function main(x) {\
        x = x|0;\
        switch(x|0) {";
    for (var i = begin; i <= end; i = i + gap) {
      str = str.concat("case ", i.toString(), ": ", handle_case(i));
    }
    str = str.concat("default: return -1;\
        }\
        return -2;\
      }\
      return {main: main}; }");

    var decl = eval('(' + str + ')');
    var wasm = decl();
    assertValidAsm(decl);
    return wasm;
  }

  var handle_case = function(k) {
    return "return ".concat(k, ";");
  }
  var wasm = LargeSwitchGenerator(0, 513, 1, handle_case);
  for (var i = 0; i <= 513; i++) {
    assertEquals(i, wasm.main(i));
  }
  assertEquals(-1, wasm.main(-1));

  wasm = LargeSwitchGenerator(0, 1024, 3, handle_case);
  for (var i = 0; i <= 1024; i = i + 3) {
    assertEquals(i, wasm.main(i));
  }
  assertEquals(-1, wasm.main(-1));

  wasm = LargeSwitchGenerator(-2147483648, -2147483000, 1, handle_case);
  for (var i = -2147483648; i <= -2147483000; i++) {
    assertEquals(i, wasm.main(i));
  }
  assertEquals(-1, wasm.main(-1));
  assertEquals(-1, wasm.main(214748647));

  wasm = LargeSwitchGenerator(-2147483648, -2147483000, 3, handle_case);
  for (var i = -2147483648; i <= -2147483000; i = i + 3) {
    assertEquals(i, wasm.main(i));
  }
  assertEquals(-1, wasm.main(-1));
  assertEquals(-1, wasm.main(214748647));

  wasm = LargeSwitchGenerator(2147483000, 2147483647, 1, handle_case);
  for (var i = 2147483000; i <= 2147483647; i++) {
    assertEquals(i, wasm.main(i));
  }
  assertEquals(-1, wasm.main(-1));
  assertEquals(-1, wasm.main(-214748647));

  wasm = LargeSwitchGenerator(2147483000, 2147483647, 4, handle_case);
  for (var i = 2147483000; i <= 2147483647; i = i + 4) {
    assertEquals(i, wasm.main(i));
  }
  assertEquals(-1, wasm.main(-1));
  assertEquals(-1, wasm.main(-214748647));

  handle_case = function(k) {
    if (k != 7) return "return ".concat(k, ";");
    else return "break;";
  }
  wasm = LargeSwitchGenerator(0, 1499, 7, handle_case);
  for (var i = 0; i <= 1499; i = i + 7) {
    if (i == 7) assertEquals(-2, wasm.main(i));
    else assertEquals(i, wasm.main(i));
  }
  assertEquals(-1, wasm.main(-1));

  handle_case = function(k) {
    if (k != 56) return "break;";
    else return "return 23;";
  }
  wasm = LargeSwitchGenerator(0, 638, 2, handle_case);
  for (var i = 0; i <= 638; i = i + 2) {
    if (i == 56) assertEquals(23, wasm.main(i));
    else assertEquals(-2, wasm.main(i));
  }
  assertEquals(-1, wasm.main(-1));
})();
                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/wasm/asm-wasm-u32.js                                               0000664 0000000 0000000 00000007535 14746647661 0022170 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --validate-asm --allow-natives-syntax

function WrapInAsmModule(func) {
  function MODULE_NAME(stdlib) {
    "use asm";
    var imul = stdlib.Math.imul;

    FUNC_BODY
    return {main: FUNC_NAME};
  }

  var source = MODULE_NAME.toString()
    .replace(/MODULE_NAME/g, func.name + "_module")
    .replace(/FUNC_BODY/g, func.toString())
    .replace(/FUNC_NAME/g, func.name);
  return eval("(" + source + ")");
}

function RunAsmJsTest(asmfunc, expect) {
  var asm_source = asmfunc.toString();
  var nonasm_source = asm_source.replace(new RegExp("use asm"), "");
  var stdlib = {Math: Math};

  print("Testing " + asmfunc.name + " (js)...");
  var js_module = eval("(" + nonasm_source + ")")(stdlib);
  expect(js_module);

  print("Testing " + asmfunc.name + " (asm.js)...");
  var asm_module = asmfunc(stdlib);
  assertTrue(%IsAsmWasmCode(asmfunc));
  expect(asm_module);
}

const imul = Math.imul;

function u32_add(a, b) {
  a = a | 0;
  b = b | 0;
  return +(((a >>> 0) + (b >>> 0)) >>> 0);
}

function u32_sub(a, b) {
  a = a | 0;
  b = b | 0;
  return +(((a >>> 0) - (b >>> 0)) >>> 0);
}

function u32_mul(a, b) {
  a = a | 0;
  b = b | 0;
  return +imul(a >>> 0, b >>> 0);
}

function u32_div(a, b) {
  a = a | 0;
  b = b | 0;
  return +(((a >>> 0) / (b >>> 0)) >>> 0);
}

function u32_mod(a, b) {
  a = a | 0;
  b = b | 0;
  return +(((a >>> 0) % (b >>> 0)) >>> 0);
}

function u32_and(a, b) {
  a = a | 0;
  b = b | 0;
  return +((a >>> 0) & (b >>> 0));
}

function u32_or(a, b) {
  a = a | 0;
  b = b | 0;
  return +((a >>> 0) | (b >>> 0));
}

function u32_xor(a, b) {
  a = a | 0;
  b = b | 0;
  return +((a >>> 0) ^ (b >>> 0));
}

function u32_shl(a, b) {
  a = a | 0;
  b = b | 0;
  return +((a >>> 0) << (b >>> 0));
}

function u32_shr(a, b) {
  a = a | 0;
  b = b | 0;
  return +((a >>> 0) >> (b >>> 0));
}

function u32_sar(a, b) {
  a = a | 0;
  b = b | 0;
  return ((a >>> 0) >>> (b >>> 0)) | 0;
}

function u32_eq(a, b) {
  a = a | 0;
  b = b | 0;
  if ((a >>> 0) == (b >>> 0)) {
    return 1;
  }
  return 0;
}

function u32_ne(a, b) {
  a = a | 0;
  b = b | 0;
  if ((a >>> 0) < (b >>> 0)) {
    return 1;
  }
  return 0;
}

function u32_lt(a, b) {
  a = a | 0;
  b = b | 0;
  if ((a >>> 0) < (b >>> 0)) {
    return 1;
  }
  return 0;
}

function u32_lteq(a, b) {
  a = a | 0;
  b = b | 0;
  if ((a >>> 0) <= (b >>> 0)) {
    return 1;
  }
  return 0;
}

function u32_gt(a, b) {
  a = a | 0;
  b = b | 0;
  if ((a >>> 0) > (b >>> 0)) {
    return 1;
  }
  return 0;
}

function u32_gteq(a, b) {
  a = a | 0;
  b = b | 0;
  if ((a >>> 0) >= (b >>> 0)) {
    return 1;
  }
  return 0;
}

function u32_neg(a) {
  a = a | 0;
  return (-a) | 0;
}

function u32_invert(a) {
  a = a | 0;
  return (~a) | 0;
}


var inputs = [
  0, 1, 2, 3, 4,
  2147483646,
  2147483647, // max positive int32
  2147483648, // overflow max positive int32
  0x0000009e, 0x00000043, 0x0000af73, 0x0000116b, 0x00658ecc, 0x002b3b4c,
  0xeeeeeeee, 0xfffffffd, 0xf0000000, 0x007fffff, 0x0003ffff, 0x00001fff,
  -1, -2, -3, -4,
  -2147483647,
  -2147483648, // min negative int32
  -2147483649, // overflow min negative int32
];

var funcs = [
  u32_add,
  u32_sub,
  u32_div,
  u32_mod,
// TODO(titzer): u32_mul crashes turbofan in asm.js mode
  u32_and,
  u32_or,
  u32_xor,
  u32_shl,
  u32_shr,
  u32_sar,
  u32_eq,
  u32_ne,
  u32_lt,
  u32_lteq,
  u32_gt,
  u32_gteq,
  u32_neg,
  u32_invert,
  // TODO(titzer): u32_min
  // TODO(titzer): u32_max
  // TODO(titzer): u32_abs
];

(function () {
  for (func of funcs) {
    RunAsmJsTest(WrapInAsmModule(func), function (module) {
      for (a of inputs) {
        for (b of inputs) {
          var expected = func(a, b);
          assertEquals(expected, module.main(a, b));
        }
      }
    });
  }

})();
                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/wasm/asm-wasm.js                                                   0000664 0000000 0000000 00000053370 14746647661 0021557 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --validate-asm --allow-natives-syntax

var stdlib = this;
let kMinHeapSize = 4096;

function assertValidAsm(func) {
  assertTrue(%IsAsmWasmCode(func), "must be valid asm code");
}

function assertWasm(expected, func, ffi) {
  print("Testing " + func.name + "...");
  assertEquals(
      expected, func(stdlib, ffi, new ArrayBuffer(kMinHeapSize)).caller());
  assertValidAsm(func);
}

function EmptyTest(a, b, c) {
  "use asm";
  function caller() {
    empty();
    return 11;
  }
  function empty() {
  }
  return {caller: caller};
}

assertWasm(11, EmptyTest);

function VoidReturnTest(a, b, c) {
  "use asm";
  function caller() {
    empty();
    return 19;
  }
  function empty() {
    var x = 0;
    if (x) return;
  }
  return {caller: caller};
}

assertWasm(19, VoidReturnTest);

function IntTest(a, b, c) {
  "use asm";
  function sum(a, b) {
    a = a|0;
    b = b|0;
    var c = 0;
    var d = 3.0;
    var e = 0;
    e = ~~d;  // double conversion
    c = (b + 1)|0
    return (a + c + 1)|0;
  }

  function caller() {
    return sum(77,22) | 0;
  }

  return {caller: caller};
}

assertWasm(101,IntTest);


function Float64Test() {
  "use asm";
  function sum(a, b) {
    a = +a;
    b = +b;
    return +(a + b);
  }

  function caller() {
    var a = 0.0;
    var ret = 0;
    a = +sum(70.1,10.2);
    if (a == 80.3) {
      ret = 1|0;
    } else {
      ret = 0|0;
    }
    return ret|0;
  }

  return {caller: caller};
}

assertWasm(1, Float64Test);


function BadModule() {
  "use asm";
  function caller(a, b) {
    a = a|0;
    b = b+0;
    var c = 0;
    c = (b + 1)|0
    return (a + c + 1)|0;
  }

  function caller() {
    return call(1, 2)|0;
  }

  return {caller: caller};
}

assertFalse(%IsAsmWasmCode(BadModule));


function TestReturnInBlock() {
  "use asm";

  function caller() {
    if(1) {
      {
        {
          return 1;
        }
      }
    }
    return 0;
  }

  return {caller: caller};
}

assertWasm(1, TestReturnInBlock);


function TestAddSimple() {
  "use asm";

  function caller() {
    var x = 0;
    x = (x + 1)|0;
    return x|0;
  }

  return {caller: caller};
}

assertWasm(1, TestAddSimple);


function TestWhileSimple() {
  "use asm";

  function caller() {
    var x = 0;
    while((x|0) < 5) {
      x = (x + 1)|0;
    }
    return x|0;
  }

  return {caller: caller};
}

assertWasm(5, TestWhileSimple);


function TestWhileWithoutBraces() {
  "use asm";

  function caller() {
    var x = 0;
    while((x|0) <= 3)
      x = (x + 1)|0;
    return x|0;
  }

  return {caller: caller};
}

assertWasm(4, TestWhileWithoutBraces);


function TestReturnInWhile() {
  "use asm";

  function caller() {
    var x = 0;
    while((x|0) < 10) {
      x = (x + 6)|0;
      return x|0;
    }
    return x|0;
  }

  return {caller: caller};
}

assertWasm(6, TestReturnInWhile);


function TestReturnInWhileWithoutBraces() {
  "use asm";

  function caller() {
    var x = 0;
    while((x|0) < 5)
      return 7;
    return x|0;
  }

  return {caller: caller};
}

assertWasm(7, TestReturnInWhileWithoutBraces);


function TestBreakInIf() {
  "use asm";

  function caller() {
    label: {
      if(1) break label;
      return 11;
    }
    return 12;
  }

  return {caller: caller};
}

assertWasm(12, TestBreakInIf);

function TestBreakInIfInDoWhileFalse() {
  "use asm";

  function caller() {
    do {
      if(1) break;
      return 11;
    } while(0);
    return 12;
  }

  return {caller: caller};
}

assertWasm(12, TestBreakInIfInDoWhileFalse);

function TestBreakInElse() {
  "use asm";

  function caller() {
    do {
      if(0) ;
      else break;
      return 14;
    } while(0);
    return 15;
  }

  return {caller: caller};
}

assertWasm(15, TestBreakInElse);

function TestBreakInWhile() {
  "use asm";

  function caller() {
    while(1) {
      break;
    }
    return 8;
  }

  return {caller: caller};
}

assertWasm(8, TestBreakInWhile);


function TestBreakInIfInWhile() {
  "use asm";

  function caller() {
    while(1) {
      if (1) break;
      else break;
    }
    return 8;
  }

  return {caller: caller};
}

assertWasm(8, TestBreakInIfInWhile);

function TestBreakInNestedWhile() {
  "use asm";

  function caller() {
    var x = 1.0;
    var ret = 0;
    while(x < 1.5) {
      while(1)
        break;
      x = +(x + 0.25);
    }
    if (x == 1.5) {
      ret = 9;
    }
    return ret|0;
  }

  return {caller: caller};
}

assertWasm(9, TestBreakInNestedWhile);


function TestBreakInBlock() {
  "use asm";

  function caller() {
    var x = 0;
    abc: {
      x = 10;
      if ((x|0) == 10) {
        break abc;
      }
      x = 20;
    }
    return x|0;
  }

  return {caller: caller};
}

assertWasm(10, TestBreakInBlock);


function TestBreakInNamedWhile() {
  "use asm";

  function caller() {
    var x = 0;
    outer: while (1) {
      x = (x + 1)|0;
      while ((x|0) == 11) {
        break outer;
      }
    }
    return x|0;
  }

  return {caller: caller};
}

assertWasm(11, TestBreakInNamedWhile);


function TestContinue() {
  "use asm";

  function caller() {
    var x = 5;
    var ret = 0;
    while ((x|0) >= 0) {
      x = (x - 1)|0;
      if ((x|0) == 2) {
        continue;
      }
      ret = (ret - 1)|0;
    }
    return ret|0;
  }

  return {caller: caller};
}

assertWasm(-5, TestContinue);


function TestContinueInNamedWhile() {
  "use asm";

  function caller() {
    var x = 5;
    var y = 0;
    var ret = 0;
    outer: while ((x|0) > 0) {
      x = (x - 1)|0;
      y = 0;
      while ((y|0) < 5) {
        if ((x|0) == 3) {
          continue outer;
        }
        ret = (ret + 1)|0;
        y = (y + 1)|0;
      }
    }
    return ret|0;
  }

  return {caller: caller};
}

assertWasm(20, TestContinueInNamedWhile);


function TestContinueInDoWhileFalse() {
  "use asm";

  function caller() {
    do {
      continue;
    } while (0);
    return 47;
  }

  return {caller: caller};
}

assertWasm(47, TestContinueInDoWhileFalse);


function TestContinueInForLoop() {
  "use asm";

  function caller() {
    var i = 0;
    for (; (i|0) < 10; i = (i+1)|0) {
      continue;
    }
    return 4711;
  }

  return {caller: caller};
}

assertWasm(4711, TestContinueInForLoop);


function TestNot() {
  "use asm";

  function caller() {
    var a = 0;
    a = !(2 > 3);
    return a | 0;
  }

  return {caller:caller};
}

assertWasm(1, TestNot);


function TestNotEquals() {
  "use asm";

  function caller() {
    var a = 3;
    if ((a|0) != 2) {
      return 21;
    }
    return 0;
  }

  return {caller:caller};
}

assertWasm(21, TestNotEquals);


function TestUnsignedComparison() {
  "use asm";

  function caller() {
    var a = 0xffffffff;
    if ((a>>>0) > (0>>>0)) {
      return 22;
    }
    return 0;
  }

  return {caller:caller};
}

assertWasm(22, TestUnsignedComparison);


function TestMixedAdd() {
  "use asm";

  function caller() {
    var a = 0x80000000;
    var b = 0x7fffffff;
    var c = 0;
    c = ((a>>>0) + b)|0;
    if ((c >>> 0) > (0>>>0)) {
      if ((c|0) < 0) {
        return 23;
      }
    }
    return 0;
  }

  return {caller:caller};
}

assertWasm(23, TestMixedAdd);




function TestConvertI32() {
  "use asm";

  function caller() {
    var a = 1.5;
    if ((~~(a + a)) == 3) {
      return 24;
    }
    return 0;
  }

  return {caller:caller};
}

assertWasm(24, TestConvertI32);


function TestConvertF64FromInt() {
  "use asm";

  function caller() {
    var a = 1;
    if ((+((a + a)|0)) > 1.5) {
      return 25;
    }
    return 0;
  }

  return {caller:caller};
}

assertWasm(25, TestConvertF64FromInt);


function TestConvertF64FromUnsigned() {
  "use asm";

  function caller() {
    var a = 0xffffffff;
    if ((+(a>>>0)) > 0.0) {
      if((+(a|0)) < 0.0) {
        return 26;
      }
    }
    return 0;
  }

  return {caller:caller};
}

assertWasm(26, TestConvertF64FromUnsigned);


function TestModInt() {
  "use asm";

  function caller() {
    var a = -83;
    var b = 28;
    return ((a|0)%(b|0))|0;
  }

  return {caller:caller};
}

assertWasm(-27,TestModInt);


function TestModUnsignedInt() {
  "use asm";

  function caller() {
    var a = 0x80000000;  //2147483648
    var b = 10;
    return ((a>>>0)%(b>>>0))|0;
  }

  return {caller:caller};
}

assertWasm(8, TestModUnsignedInt);


function TestModDouble() {
  "use asm";

  function caller() {
    var a = 5.25;
    var b = 2.5;
    if (a%b == 0.25) {
      return 28;
    }
    return 0;
  }

  return {caller:caller};
}

assertWasm(28, TestModDouble);


function TestModDoubleNegative() {
  "use asm";

  function caller() {
    var a = -34359738368.25;
    var b = 2.5;
    if (a%b == -0.75) {
      return 28;
    }
    return 0;
  }

  return {caller:caller};
}

assertWasm(28, TestModDoubleNegative);


(function () {
function TestNamedFunctions() {
  "use asm";

  var a = 0.0;
  var b = 0.0;

  function add() {
    return +(a + b);
  }

  function init() {
    a = 43.25;
    b = 34.25;
  }

  return {init:init,
          add:add};
}

var module_decl = eval('(' + TestNamedFunctions.toString() + ')');
var module = module_decl(stdlib);
assertValidAsm(module_decl);
module.init();
assertEquals(77.5, module.add());
})();


(function () {
function TestGlobalsWithInit() {
  "use asm";

  var a = 43.25;
  var b = 34.25;

  function add() {
    return +(a + b);
  }

  return {add:add};
}

var module_decl = eval('(' + TestGlobalsWithInit.toString() + ')');
var module = module_decl(stdlib);
assertValidAsm(module_decl);
assertEquals(77.5, module.add());
})();

function TestForLoop() {
  "use asm"

  function caller() {
    var ret = 0;
    var i = 0;
    for (i = 2; (i|0) <= 10; i = (i+1)|0) {
      ret = (ret + i) | 0;
    }
    return ret|0;
  }

  return {caller:caller};
}

assertWasm(54, TestForLoop);


function TestForLoopWithoutInit() {
  "use asm"

  function caller() {
    var ret = 0;
    var i = 0;
    for (; (i|0) < 10; i = (i+1)|0) {
      ret = (ret + 10) | 0;
    }
    return ret|0;
  }

  return {caller:caller};
}

assertWasm(100,TestForLoopWithoutInit);


function TestForLoopWithoutCondition() {
  "use asm"

  function caller() {
    var ret = 0;
    var i = 0;
    for (i=1;; i = (i+1)|0) {
      ret = (ret + i) | 0;
      if ((i|0) == 11) {
        break;
      }
    }
    return ret|0;
  }

  return {caller:caller};
}

assertWasm(66, TestForLoopWithoutCondition);


function TestForLoopWithoutNext() {
  "use asm"

  function caller() {
    var i = 0;
    for (i=1; (i|0) < 41;) {
      i = (i + 1) | 0;
    }
    return i|0;
  }

  return {caller:caller};
}

assertWasm(41, TestForLoopWithoutNext);


function TestForLoopWithoutBody() {
  "use asm"

  function caller() {
    var i = 0;
    for (i=1; (i|0) < 45 ; i = (i+1)|0) {
    }
    return i|0;
  }

  return {caller:caller};
}

assertWasm(45, TestForLoopWithoutBody);


function TestDoWhile() {
  "use asm"

  function caller() {
    var i = 0;
    var ret = 21;
    do {
      ret = (ret + ret)|0;
      i = (i + 1)|0;
    } while ((i|0) < 2);
    return ret|0;
  }

  return {caller:caller};
}

assertWasm(84, TestDoWhile);


function TestConditional() {
  "use asm"

  function caller() {
    var x = 1;
    return (((x|0) > 0) ? 41 : 71)|0;
  }

  return {caller:caller};
}

assertWasm(41, TestConditional);


function TestInitFunctionWithNoGlobals() {
  "use asm";
  function caller() {
    return 51;
  }
  return {caller:caller};
}

assertWasm(51, TestInitFunctionWithNoGlobals);


(function () {
function TestExportNameDifferentFromFunctionName() {
  "use asm";
  function caller() {
    return 55;
  }
  return {alt_caller:caller};
}

var module_decl = eval(
  '(' + TestExportNameDifferentFromFunctionName.toString() + ')');
var module = module_decl(stdlib);
assertValidAsm(module_decl);
assertEquals(55, module.alt_caller());
})();


function TestFunctionTableSingleFunction() {
  "use asm";

  function dummy() {
    return 71;
  }

  function caller() {
    // TODO(jpp): the parser optimizes function_table[0&0] to function table[0].
    var v = 0;
    return function_table[v&0]() | 0;
  }

  var function_table = [dummy]

  return {caller:caller};
}

assertWasm(71, TestFunctionTableSingleFunction);


function TestFunctionTableMultipleFunctions() {
  "use asm";

  function inc1(x) {
    x = x|0;
    return (x+1)|0;
  }

  function inc2(x) {
    x = x|0;
    return (x+2)|0;
  }

  function caller() {
    var i = 0, j = 1;
    if ((function_table[i&1](50)|0) == 51) {
      if ((function_table[j&1](60)|0) == 62) {
        return 73;
      }
    }
    return 0;
  }

  var function_table = [inc1, inc2]

  return {caller:caller};
}

assertWasm(73, TestFunctionTableMultipleFunctions);


(function () {
function TestFunctionTable(stdlib, foreign, buffer) {
  "use asm";

  function add(a, b) {
    a = a|0;
    b = b|0;
    return (a+b)|0;
  }

  function sub(a, b) {
    a = a|0;
    b = b|0;
    return (a-b)|0;
  }

  function inc(a) {
    a = a|0;
    return (a+1)|0;
  }

  function caller(table_id, fun_id, arg1, arg2) {
    table_id = table_id|0;
    fun_id = fun_id|0;
    arg1 = arg1|0;
    arg2 = arg2|0;
    if ((table_id|0) == 0) {
      return funBin[fun_id&3](arg1, arg2)|0;
    } else if ((table_id|0) == 1) {
      return fun[fun_id&0](arg1)|0;
    }
    return 0;
  }

  var funBin = [add, sub, sub, add];
  var fun = [inc];

  return {caller:caller};
}

print("TestFunctionTable...");
var module = TestFunctionTable(stdlib);
assertEquals(55, module.caller(0, 0, 33, 22));
assertEquals(11, module.caller(0, 1, 33, 22));
assertEquals(9, module.caller(0, 2, 54, 45));
assertEquals(99, module.caller(0, 3, 54, 45));
assertEquals(23, module.caller(0, 4, 12, 11));
assertEquals(31, module.caller(1, 0, 30, 11));
})();


(function TestComma() {
  function CommaModule() {
    "use asm";

    function ifunc(a, b) {
      a = +a;
      b = b | 0;
      return (a, b) | 0;
    }

    function dfunc(a, b) {
      a = a | 0;
      b = +b;
      return +(a, b);
    }

    return {ifunc: ifunc, dfunc: dfunc};
  }

  var module_decl = eval('(' + CommaModule.toString() + ')');
  var m = module_decl(stdlib);
  assertValidAsm(module_decl);
  assertEquals(123, m.ifunc(456.7, 123));
  assertEquals(123.4, m.dfunc(456, 123.4));
})();


function TestFloatAsDouble(stdlib) {
  "use asm";
  var fround = stdlib.Math.fround;
  function func() {
    var x = fround(1.0);
    return +fround(x);
  }
  return {caller: func};
}
assertWasm(1, TestFloatAsDouble);


function TestOr() {
  "use asm";
  function func() {
    var x = 1;
    var y = 2;
    return (x | y) | 0;
  }
  return {caller: func};
}

assertWasm(3, TestOr);


function TestAnd() {
  "use asm";
  function func() {
    var x = 3;
    var y = 2;
    return (x & y) | 0;
  }
  return {caller: func};
}

assertWasm(2, TestAnd);


function TestXor() {
  "use asm";
  function func() {
    var x = 3;
    var y = 2;
    return (x ^ y) | 0;
  }
  return {caller: func};
}

assertWasm(1, TestXor);


function TestIntegerMultiplyBothWays(stdlib, foreign, heap) {
  "use asm";
  function func() {
    var a = 1;
    return (((a * 3)|0) + ((4 * a)|0)) | 0;
  }
  return {caller: func};
}

assertWasm(7, TestIntegerMultiplyBothWays);


(function TestBadAssignDoubleFromIntish() {
  function Module(stdlib, foreign, heap) {
    "use asm";
    function func() {
      var a = 1;
      var b = 3.0;
      b = a;
    }
    return {func: func};
  }
  print("TestBadAssignDoubleFromIntish...");
  Module(stdlib);
  assertFalse(%IsAsmWasmCode(Module));
})();


(function TestBadAssignIntFromDouble() {
  function Module(stdlib, foreign, heap) {
    "use asm";
    function func() {
      var a = 1;
      var b = 3.0;
      a = b;
    }
    return {func: func};
  }
  print("TestBadAssignIntFromDouble...");
  Module(stdlib);
  assertFalse(%IsAsmWasmCode(Module));
})();


(function TestBadMultiplyIntish() {
  function Module(stdlib, foreign, heap) {
    "use asm";
    function func() {
      var a = 1;
      return ((a + a) * 4) | 0;
    }
    return {func: func};
  }
  print("TestBadMultiplyIntish...");
  Module(stdlib);
  assertFalse(%IsAsmWasmCode(Module));
})();


(function TestBadCastFromInt() {
  function Module(stdlib, foreign, heap) {
    "use asm";
    function func() {
      var a = 1;
      return +a;
    }
    return {func: func};
  }
  print("TestBadCastFromInt...");
  Module(stdlib);
  assertFalse(%IsAsmWasmCode(Module));
})();


function TestAndNegative() {
  "use asm";
  function func() {
    var x = 1;
    var y = 2;
    var z = 0;
    z = x + y & -1;
    return z | 0;
  }
  return {caller: func};
}

assertWasm(3, TestAndNegative);


function TestNegativeDouble() {
  "use asm";
  function func() {
    var x = -34359738368.25;
    var y = -2.5;
    return +(x + y);
  }
  return {caller: func};
}

assertWasm(-34359738370.75, TestNegativeDouble);


(function TestBadAndDouble() {
  function Module() {
    "use asm";
    function func() {
      var x = 1.0;
      var y = 2.0;
      return (x & y) | 0;
    }
    return {func: func};
  }

  Module(stdlib);
  assertFalse(%IsAsmWasmCode(Module));
})();


(function TestBadExportKey() {
  function Module() {
    "use asm";
    function func() {
    }
    return {123: func};
  }

  Module(stdlib);
  assertFalse(%IsAsmWasmCode(Module));
})();


/*
// TODO(bradnelson): Technically invalid, but useful to cover unicode, revises
// and re-enable.
(function TestUnicodeExportKey() {
  function Module() {
    "use asm";
    function func() {
      return 42;
    }
    return {"\u00d1\u00e6": func};
  }

  var m = Module(stdlib);
  assertEquals(42, m.());
  assertValidAsm(Module);
})();
*/


function TestAndIntAndHeapValue(stdlib, foreign, buffer) {
  "use asm";
  var HEAP32 = new stdlib.Int32Array(buffer);
  function func() {
    var x = 0;
    x = HEAP32[0] & -1;
    return x | 0;
  }
  return {caller: func};
}

assertWasm(0, TestAndIntAndHeapValue);


function TestOutOfBoundsConversion($a,$b,$c){'use asm';
  function aaa() {
    var f = 0.0;
    var a = 0;
    f = 5616315000.000001;
    a = ~~f >>>0;
    return a | 0;
  }
  return { caller : aaa };
}

assertWasm(1321347704, TestOutOfBoundsConversion);


(function TestUnsignedLiterals() {
  function asmModule() {
    "use asm";
    function u0xffffffff() {
      var f = 0xffffffff;
      return +(f >>> 0);
    }
    function u0x80000000() {
      var f = 0x80000000;
      return +(f >>> 0);
    }
    function u0x87654321() {
      var f = 0x87654321;
      return +(f >>> 0);
    }
    return {
      u0xffffffff: u0xffffffff,
      u0x80000000: u0x80000000,
      u0x87654321: u0x87654321,
    };
  }
  var decl = eval('(' + asmModule.toString() + ')');
  var wasm = decl(stdlib);
  assertValidAsm(decl);
  assertEquals(0xffffffff, wasm.u0xffffffff());
  assertEquals(0x80000000, wasm.u0x80000000());
  assertEquals(0x87654321, wasm.u0x87654321());
})();


function TestIfWithUnsigned() {
  "use asm";
  function main() {
    if (2147483658) { // 2^31 + 10
      return 231;
    }
    return 0;
  }
  return {caller:main};
}

assertWasm(231, TestIfWithUnsigned);


function TestLoopsWithUnsigned() {
  "use asm";
  function main() {
    var val = 1;
    var count = 0;
    for (val = 2147483648; 2147483648;) {
      val = 2147483649;
      break;
    }
    while (val>>>0) {
      val = (val + 1) | 0;
      count = (count + 1)|0;
      if ((count|0) == 9) {
        break;
      }
    }
    count = 0;
    do {
      val = (val + 2) | 0;
      count = (count + 1)|0;
      if ((count|0) == 5) {
        break;
      }
    } while (0xffffffff);
    if ((val>>>0) == 2147483668) {
      return 323;
    }
    return 0;
  }
  return {caller:main};
}

assertWasm(323, TestLoopsWithUnsigned);


function TestSingleFunctionModule() {
  "use asm";
  function add(a, b) {
    a = a | 0;
    b = b | 0;
    return (a + b) | 0;
  }
  return add;
}

assertEquals(7, TestSingleFunctionModule()(3, 4));


function TestNotZero() {
  "use asm";
  function caller() {
    if (!0) {
      return 44;
    } else {
      return 55;
    }
    return 0;
  }
  return {caller: caller};
}

assertWasm(44, TestNotZero);


function TestNotOne() {
  "use asm";
  function caller() {
    if (!1) {
      return 44;
    } else {
      return 55;
    }
    return 0;
  }
  return {caller: caller};
}

assertWasm(55, TestNotOne);


function TestDotfulFloat(stdlib) {
  "use asm";
  var fround = stdlib.Math.fround;
  var foo = fround(55.0);
  function caller() {
    return +foo;
  }
  return {caller: caller};
}

assertWasm(55, TestDotfulFloat);


function TestDotfulLocalFloat(stdlib) {
  "use asm";
  var fround = stdlib.Math.fround;
  function caller() {
    var foo = fround(55.0);
    return +foo;
  }
  return {caller: caller};
}

assertWasm(55, TestDotfulLocalFloat);


function TestDotlessFloat(stdlib) {
  "use asm";
  var fround = stdlib.Math.fround;
  var foo = fround(55);
  function caller() {
    return +foo;
  }
  return {caller: caller};
}

assertWasm(55, TestDotlessFloat);


function TestDotlessLocalFloat(stdlib) {
  "use asm";
  var fround = stdlib.Math.fround;
  function caller() {
    var foo = fround(55);
    return +foo;
  }
  return {caller: caller};
}

assertWasm(55, TestDotlessLocalFloat);


function TestFloatGlobals(stdlib) {
  "use asm";
  var fround = stdlib.Math.fround;
  var foo = fround(1.25);
  function caller() {
    foo = fround(foo + fround(1.0));
    foo = fround(foo + fround(1.0));
    return +foo;
  }
  return {caller: caller};
}

assertWasm(3.25, TestFloatGlobals);


(function TestExportTwice() {
  function asmModule() {
    "use asm";
    function foo() {
      return 42;
    }
    return {bar: foo, baz: foo};
  }
  var m = asmModule();
  assertEquals(42, m.bar());
  assertEquals(42, m.baz());
})();

(function TestGenerator() {
  function* asmModule() {
    "use asm";
    function foo() {
      return 42;
    }
    return {foo: foo};
  }
  asmModule();
  assertFalse(%IsAsmWasmCode(asmModule));
})();

(function TestAsyncFunction() {
  async function asmModule() {
    "use asm";
    function foo() {
      return 42;
    }
    return {foo: foo};
  }
  asmModule();
  assertFalse(%IsAsmWasmCode(asmModule));
})();
                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/wasm/asm-with-wasm-off.js                                          0000664 0000000 0000000 00000001075 14746647661 0023273 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --noexpose-wasm --validate-asm --allow-natives-syntax

// NOTE: This is in its own file because it calls %DisallowWasmCodegen, which
// messes with the isolate's state.
(function testAsmWithWasmOff() {
  %DisallowWasmCodegen(true);
  function Module() {
    'use asm';
    function foo() {
      return 0;
    }
    return {foo: foo};
  }
  Module();
  assertTrue(%IsAsmWasmCode(Module));
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/wasm/async-compile.js                                              0000664 0000000 0000000 00000006173 14746647661 0022574 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

async function assertCompiles(buffer) {
  var module = await WebAssembly.compile(buffer);
  assertInstanceof(module, WebAssembly.Module);
}

function assertCompileError(buffer, msg) {
  if (typeof msg == 'string') {
    msg = 'WebAssembly.compile(): ' + msg;
  } else {
    assertInstanceof(msg, RegExp);
  }
  return assertThrowsAsync(
      WebAssembly.compile(buffer), WebAssembly.CompileError, msg);
}

assertPromiseResult(async function basicCompile() {
  let ok_buffer = (() => {
    var builder = new WasmModuleBuilder();
    builder.addFunction('f', kSig_i_v)
        .addBody([kExprI32Const, 42])
        .exportAs('f');
    return builder.toBuffer();
  })();

  // The OK buffer validates and can be made into a module.
  assertTrue(WebAssembly.validate(ok_buffer));
  let ok_module = new WebAssembly.Module(ok_buffer);
  assertTrue(ok_module instanceof WebAssembly.Module);

  // The bad buffer does not validate and cannot be made into a module.
  let bad_buffer = new ArrayBuffer(0);
  assertFalse(WebAssembly.validate(bad_buffer));
  assertThrows(
      () => new WebAssembly.Module(bad_buffer), WebAssembly.CompileError);

  let kNumCompiles = 3;

  // Three compilations of the OK module should succeed.
  for (var i = 0; i < kNumCompiles; i++) {
    await assertCompiles(ok_buffer);
  }

  // Three compilations of the bad module should fail.
  for (var i = 0; i < kNumCompiles; i++) {
    await assertCompileError(bad_buffer, 'BufferSource argument is empty');
  }
}());

assertPromiseResult(async function badFunctionInTheMiddle() {
  // We had an error where an exception was generated by a background task and
  // later thrown in a foreground task. The handle to the exception died
  // between, since the HandleScope was left.
  // This test reproduced that error.
  let builder = new WasmModuleBuilder();
  let sig = builder.addType(kSig_i_v);
  for (var i = 0; i < 10; ++i) {
    builder.addFunction('a' + i, sig).addBody([kExprI32Const, 42]);
  }
  builder.addFunction('bad', sig).addBody([]);
  for (var i = 0; i < 10; ++i) {
    builder.addFunction('b' + i, sig).addBody([kExprI32Const, 42]);
  }
  let buffer = builder.toBuffer();
  await assertCompileError(
      buffer,
      'Compiling function #10:\"bad\" failed: ' +
          'expected 1 elements on the stack for fallthru, found 0 @+94');
}());

assertPromiseResult(async function importWithoutCode() {
  // Regression test for https://crbug.com/898310.
  let builder = new WasmModuleBuilder();
  builder.addImport('m', 'q', kSig_i_i);
  await builder.asyncInstantiate({'m': {'q': i => i}});
}());

assertPromiseResult(async function invalidSectionCode() {
  let kInvalidSectionCode = 61;
  let builder = new WasmModuleBuilder();
  builder.addExplicitSection([kInvalidSectionCode, 0]);
  let buffer = builder.toBuffer();

  // Async and streaming decoder disagree on the error message, so accept both.
  await assertCompileError(buffer, /(unknown|invalid) section code/);
}());
                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/wasm/atomic-alignment-checks.js                                    0000664 0000000 0000000 00000001443 14746647661 0024512 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function TestI32AtomicAddAlignmentCheck() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addMemory(32, 128);

  builder.addFunction(`main`,
                      makeSig([kWasmI32, kWasmI32], [kWasmI32]))
  .addBody([
    kExprLocalGet, 0,
    kExprLocalGet, 1,
    kAtomicPrefix, kExprI32AtomicAdd, 1, 0,
  ]).exportFunc();

  assertThrows(() => builder.instantiate(), WebAssembly.CompileError,
    /Compiling function #0:"main" failed: invalid alignment for atomic operation; expected alignment is 2, actual alignment is 1/);
})();
                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/atomic-wait-multi-memory.js                                   0000664 0000000 0000000 00000007766 14746647661 0024716 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-multi-memory

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

const builder = new WasmModuleBuilder();
const mem0_idx = builder.addImportedMemory('imp', 'mem0', 0, 20, 'shared');
const mem1_idx = builder.addImportedMemory('imp', 'mem1', 0, 20, 'shared');
for (let mem_idx of [mem0_idx, mem1_idx]) {
  builder.addFunction(`notify${mem_idx}`, kSig_i_ii)
      .addBody([
        kExprLocalGet, 0,                                   // -
        kExprLocalGet, 1,                                   // -
        kAtomicPrefix, kExprAtomicNotify, 0x42, mem_idx, 0  // -
      ])
      .exportFunc();
  builder.addFunction(`wait${mem_idx}`, kSig_i_iii)
      .addBody([
        kExprLocalGet, 0,  // -
        kExprLocalGet, 1,  // -
        kExprLocalGet, 2,  // -
        // Convert to i64 and multiply by 1e6 (ms -> ns).
        kExprI64UConvertI32,                                 // -
        ...wasmI64Const(1e6),                                // -
        kExprI64Mul,                                         // -
        kAtomicPrefix, kExprI32AtomicWait, 0x42, mem_idx, 0  // -
      ])
      .exportFunc();
}
const module = builder.toModule();

const mem0 = new WebAssembly.Memory({initial: 1, maximum: 1, shared: true});
const mem1 = new WebAssembly.Memory({initial: 2, maximum: 2, shared: true});

const mem0_value = 0;
const mem1_value = 1;
new Uint32Array(mem1.buffer).fill(mem1_value);

const imports = {
  imp: {mem0: mem0, mem1: mem1}
};
const instance = new WebAssembly.Instance(module, imports);
const {notify0, notify1, wait0, wait1} = instance.exports;

const k10Ms = 10;
const k10s = 10000;

(function TestWaitNotEqual() {
  print(arguments.callee.name);
  assertEquals(kAtomicWaitNotEqual, wait0(0, mem0_value + 1, k10Ms));
  assertEquals(kAtomicWaitNotEqual, wait1(0, mem1_value + 1, k10Ms));
})();

(function TestWaitTimeout() {
  print(arguments.callee.name);
  assertEquals(kAtomicWaitTimedOut, wait0(0, mem0_value, k10Ms));
  assertEquals(kAtomicWaitTimedOut, wait1(0, mem1_value, k10Ms));
})();

(function TestWakeUpWorker() {
  print(arguments.callee.name);
  function workerCode() {
    instance = undefined;
    onmessage = function({data:msg}) {
      if (!instance) {
        instance = new WebAssembly.Instance(msg.module, msg.imports);
        postMessage('instantiated');
        return;
      }
      if (msg.action === 'wait0' || msg.action === 'wait1') {
        let result = instance.exports[msg.action](...msg.arguments);
        print(`[worker] ${msg.action} ->: ${result}`);
        postMessage(result);
        return;
      }
      postMessage(`Invalid action: ${msg.action}`);
    }
  }
  let worker = new Worker(workerCode, {type: 'function'});

  worker.postMessage({module: module, imports: imports});
  assertEquals('instantiated', worker.getMessage());

  const offset = 48;
  for (let [mem_idx, mem_value] of [
           [mem0_idx, mem0_value], [mem1_idx, mem1_value]]) {
    print(`- memory ${mem_idx}`);

    // Test "not equals".
    worker.postMessage(
        {action: `wait${mem_idx}`, arguments: [offset, mem_value + 1, k10Ms]});
    assertEquals(kAtomicWaitNotEqual, worker.getMessage());

    // Test "timed out".
    worker.postMessage(
        {action: `wait${mem_idx}`, arguments: [offset, mem_value, k10Ms]});
    assertEquals(kAtomicWaitTimedOut, worker.getMessage());

    // Test "ok".
    worker.postMessage(
        {action: `wait${mem_idx}`, arguments: [offset, mem_value, k10s]});
    const started = performance.now();
    let notify = mem_idx == 0 ? notify0 : notify1;
    let notified;
    while ((notified = notify(offset, 1)) === 0) {
      const now = performance.now();
      if (now - started > k10s) {
        throw new Error('Could not notify worker within 10s');
      }
    }
    assertEquals(1, notified);
    assertEquals(kAtomicWaitOk, worker.getMessage());
  }

  worker.terminate();
})();
          node-23.7.0/deps/v8/test/mjsunit/wasm/atomics-memory64.js                                           0000664 0000000 0000000 00000027153 14746647661 0023151 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-memory64 --allow-natives-syntax

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function allowOOM(fn) {
  try {
    fn();
  } catch (e) {
    const is_oom =
        (e instanceof RangeError) && e.message.includes('Out of memory');
    if (!is_oom) throw e;
  }
}

function CreateBigSharedWasmMemory64(num_pages) {
  let builder = new WasmModuleBuilder();
  builder.addMemory64(num_pages, num_pages, true);
  builder.exportMemoryAs('memory');
  return builder.instantiate().exports.memory;
}

function WasmAtomicNotify(memory, offset, index, num) {
  let builder = new WasmModuleBuilder();
  let pages = memory.buffer.byteLength / kPageSize;
  builder.addImportedMemory("m", "memory", pages, pages, "shared", "memory64");
  builder.addFunction("main", makeSig([kWasmF64, kWasmI32], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kExprI64SConvertF64,
      kExprLocalGet, 1,
      kAtomicPrefix,
      kExprAtomicNotify, /* alignment */ 2, ...wasmSignedLeb64(offset, 10)])
    .exportAs("main");

  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module, {m: {memory}});
  return instance.exports.main(index, num);
}

function WasmI32AtomicWait(memory, offset, index, val, timeout) {
  let builder = new WasmModuleBuilder();
  let pages = memory.buffer.byteLength / kPageSize;
  builder.addImportedMemory("m", "memory", pages, pages, "shared", "memory64");
  builder.addFunction("main",
    makeSig([kWasmF64, kWasmI32, kWasmF64], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kExprI64SConvertF64,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprI64SConvertF64,
      kAtomicPrefix,
      kExprI32AtomicWait, /* alignment */ 2, ...wasmSignedLeb64(offset, 10)])
      .exportAs("main");

  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module, {m: {memory}});
  return instance.exports.main(index, val, timeout);
}

function WasmI64AtomicWait(memory, offset, index, val_low,
                                   val_high, timeout) {
  let builder = new WasmModuleBuilder();
  let pages = memory.buffer.byteLength / kPageSize;
  builder.addImportedMemory("m", "memory", pages, pages, "shared", "memory64");
  // Wrapper for I64AtomicWait that takes two I32 values and combines to into
  // I64 for the instruction parameter.
  builder.addFunction("main",
    makeSig([kWasmF64, kWasmI32, kWasmI32, kWasmF64], [kWasmI32]))
    .addLocals(kWasmI64, 1)
    .addBody([
      kExprLocalGet, 1,
      kExprI64UConvertI32,
      kExprI64Const, 32,
      kExprI64Shl,
      kExprLocalGet, 2,
      kExprI64UConvertI32,
      kExprI64Ior,
      kExprLocalSet, 4, // Store the created I64 value in local
      kExprLocalGet, 0,
      kExprI64SConvertF64,
      kExprLocalGet, 4,
      kExprLocalGet, 3,
      kExprI64SConvertF64,
      kAtomicPrefix,
      kExprI64AtomicWait, /* alignment */ 3, ...wasmSignedLeb64(offset, 10)])
      .exportAs("main");

  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module, {m: {memory}});
  return instance.exports.main(index, val_high, val_low, timeout);
}

function TestAtomicI32Wait(pages, offset) {
  if (!%IsAtomicsWaitAllowed()) return;
  print(arguments.callee.name);

  let memory = CreateBigSharedWasmMemory64(pages);

  assertEquals(kAtomicWaitNotEqual, WasmI32AtomicWait(memory, offset, 0, 42, -1));
  assertEquals(kAtomicWaitTimedOut, WasmI32AtomicWait(memory, offset, 0, 0, 0));
  assertEquals(kAtomicWaitNotEqual, WasmI32AtomicWait(memory, 0, offset, 42, -1));
  assertEquals(kAtomicWaitTimedOut, WasmI32AtomicWait(memory, 0, offset, 0, 0));

  let i32a = new Int32Array(memory.buffer);
  i32a[offset / 4] = 1;

  assertEquals(kAtomicWaitNotEqual, WasmI32AtomicWait(memory, offset, 0, 0, -1));
  assertEquals(kAtomicWaitTimedOut, WasmI32AtomicWait(memory, offset, 0, 1, 0));
  assertEquals(kAtomicWaitNotEqual, WasmI32AtomicWait(memory, 0, offset, 0, -1));
  assertEquals(kAtomicWaitTimedOut, WasmI32AtomicWait(memory, 0, offset, 1, 0));
}

function TestAtomicI64Wait(pages, offset) {
  if (!%IsAtomicsWaitAllowed()) return;
  print(arguments.callee.name);

  let memory = CreateBigSharedWasmMemory64(pages);
  assertEquals(kAtomicWaitNotEqual, WasmI64AtomicWait(memory, offset, 0, 42, 0, -1));
  assertEquals(kAtomicWaitTimedOut, WasmI64AtomicWait(memory, offset, 0, 0, 0, 0));
  assertEquals(kAtomicWaitNotEqual, WasmI64AtomicWait(memory, 0, offset, 42, 0, -1));
  assertEquals(kAtomicWaitTimedOut, WasmI64AtomicWait(memory, 0, offset, 0, 0, 0));

  let i32a = new Int32Array(memory.buffer);
  i32a[offset / 4] = 1;
  i32a[(offset / 4) + 1] = 2;

  assertEquals(kAtomicWaitNotEqual, WasmI64AtomicWait(memory, offset, 0, 2, 1, -1));
  assertEquals(kAtomicWaitTimedOut, WasmI64AtomicWait(memory, offset, 0, 1, 2, 0));
  assertEquals(kAtomicWaitNotEqual, WasmI64AtomicWait(memory, 0, offset, 2, 1, -1));
  assertEquals(kAtomicWaitTimedOut, WasmI64AtomicWait(memory, 0, offset, 1, 2, 0));
}

//// WORKER ONLY TESTS

function TestWasmAtomicsInWorkers(OFFSET, INDEX, PAGES) {
  // This test creates 4 workers that wait on consecutive (8 byte separated to
  // satisfy alignments for all kinds of wait) memory locations to test various
  // wait/wake combinations. For each combination, each thread waits 3 times
  // expecting all 4 threads to be woken with wake(4) in first iteration, all 4
  // to be woken with wake(5) in second iteration and, 3 and 1 to be woken in
  // third iteration.
  print(arguments.callee.name);

  const INDEX_JS = OFFSET + INDEX;
  let memory = CreateBigSharedWasmMemory64(PAGES);
  let i32a = new Int32Array(memory.buffer);
  const numWorkers = 4;

  let workerScript = `onmessage = function({data:msg}) {
    d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
    ${WasmI32AtomicWait.toString()}
    ${WasmI64AtomicWait.toString()}
    let id = msg.id;
    let memory = msg.memory;
    let INDEX = msg.INDEX;
    let OFFSET = msg.OFFSET;
    let INDEX_JS = OFFSET + INDEX;
    let i32a = new Int32Array(memory.buffer);
    // Indices are divided by 4 for Atomics.wait to convert them to index
    // for Int32Array.
    // For wasm-wake numWorkers threads.
    let result = Atomics.wait(i32a, INDEX_JS / 4, 0);
    postMessage(result);
    // For wasm-wake numWorkers + 1 threads.
    result = Atomics.wait(i32a, (INDEX_JS + 8) / 4, 0);
    postMessage(result);
    // For wasm-wake numWorkers - 1 threads.
    result = Atomics.wait(i32a, (INDEX_JS + 16) / 4, 0);
    postMessage(result);
    // For js-wake numWorkers threads.
    result = WasmI32AtomicWait(memory, OFFSET, INDEX + 24, 0, -1);
    postMessage(result);
    // For js-wake numWorkers + 1 threads.
    result = WasmI32AtomicWait(memory, OFFSET, INDEX + 32, 0, -1);
    postMessage(result);
    // For js-wake numWorkers - 1 threads.
    result = WasmI32AtomicWait(memory, OFFSET, INDEX + 40, 0, -1);
    postMessage(result);
    // For wasm-wake numWorkers threads.
    result = WasmI32AtomicWait(memory, OFFSET, INDEX + 48, 0, -1);
    postMessage(result);
    // For wasm-wake numWorkers + 1 threads.
    result = WasmI32AtomicWait(memory, OFFSET, INDEX + 56, 0, -1);
    postMessage(result);
    // For wasm-wake numWorkers - 1 threads.
    result = WasmI32AtomicWait(memory, OFFSET, INDEX + 64, 0, -1);
    postMessage(result);
    // For js-wake numWorkers threads.
    result = WasmI64AtomicWait(memory, OFFSET, INDEX + 72, 0, 0, -1);
    postMessage(result);
    // For js-wake numWorkers + 1 threads.
    result = WasmI64AtomicWait(memory, OFFSET, INDEX + 80, 0, 0, -1);
    postMessage(result);
    // For js-wake numWorkers - 1 threads.
    result = WasmI64AtomicWait(memory, OFFSET, INDEX + 88, 0, 0, -1);
    postMessage(result);
    // For wasm-wake numWorkers threads.
    result = WasmI64AtomicWait(memory, OFFSET, INDEX + 96, 0, 0, -1);
    postMessage(result);
    // For wasm-wake numWorkers + 1 threads.
    result = WasmI64AtomicWait(memory, OFFSET, INDEX + 104, 0, 0, -1);
    postMessage(result);
    // For wasm-wake numWorkers - 1 threads.
    result = WasmI64AtomicWait(memory, OFFSET, INDEX + 112, 0, 0, -1);
    postMessage(result);
  };`;

  let waitForAllWorkers = function(index) {
    while (%AtomicsNumWaitersForTesting(i32a, index / 4) != numWorkers) {}
  }

  let jsWakeCheck = function(index, num, workers, msg) {
    waitForAllWorkers(index);
    let indexJs = index / 4;
    if (num >= numWorkers) {
      // If numWorkers or more is passed to wake, numWorkers workers should be
      // woken.
      assertEquals(numWorkers, Atomics.notify(i32a, indexJs, num));
    } else {
      // If num < numWorkers is passed to wake, num workers should be woken.
      // Then the remaining workers are woken for the next part.
      assertEquals(num, Atomics.notify(i32a, indexJs, num));
      assertEquals(numWorkers-num, Atomics.notify(i32a, indexJs, numWorkers));
    }
    for (let id = 0; id < numWorkers; id++) {
      assertEquals(msg, workers[id].getMessage());
    }
  };

  let wasmWakeCheck = function(offset, index, num, workers, msg) {
    waitForAllWorkers(offset + index);
    if (num >= numWorkers) {
      assertEquals(numWorkers, WasmAtomicNotify(memory, offset, index, num));
    } else {
      assertEquals(num, WasmAtomicNotify(memory, offset, index, num));
      assertEquals(numWorkers-num,
                   WasmAtomicNotify(memory, offset, index, numWorkers));
    }
    for (let id = 0; id < numWorkers; id++) {
      assertEquals(msg, workers[id].getMessage());
    }
  };

  let workers = [];
  for (let id = 0; id < numWorkers; id++) {
    workers[id] = new Worker(workerScript, {type: 'string'});
    workers[id].postMessage({id, memory, INDEX, OFFSET});
  }

  wasmWakeCheck(OFFSET, INDEX + 0, numWorkers, workers, "ok");
  wasmWakeCheck(OFFSET, INDEX + 8, numWorkers + 1, workers, "ok");
  wasmWakeCheck(OFFSET, INDEX + 16, numWorkers - 1, workers, "ok");

  jsWakeCheck(INDEX_JS + 24, numWorkers, workers, kAtomicWaitOk);
  jsWakeCheck(INDEX_JS + 32, numWorkers + 1, workers, kAtomicWaitOk);
  jsWakeCheck(INDEX_JS + 40, numWorkers - 1, workers, kAtomicWaitOk);

  wasmWakeCheck(OFFSET, INDEX + 48, numWorkers, workers, kAtomicWaitOk);
  wasmWakeCheck(OFFSET, INDEX + 56, numWorkers + 1, workers, kAtomicWaitOk);
  wasmWakeCheck(OFFSET, INDEX + 64, numWorkers - 1, workers, kAtomicWaitOk);

  jsWakeCheck(INDEX_JS + 72, numWorkers, workers, kAtomicWaitOk);
  jsWakeCheck(INDEX_JS + 80, numWorkers + 1, workers, kAtomicWaitOk);
  jsWakeCheck(INDEX_JS + 88, numWorkers - 1, workers, kAtomicWaitOk);

  wasmWakeCheck(OFFSET, INDEX + 96,  numWorkers, workers, kAtomicWaitOk);
  wasmWakeCheck(OFFSET, INDEX + 104, numWorkers + 1, workers, kAtomicWaitOk);
  wasmWakeCheck(OFFSET, INDEX + 112, numWorkers - 1, workers, kAtomicWaitOk);

  for (let id = 0; id < numWorkers; id++) {
    workers[id].terminate();
  }
}

const OFFSET = 4000;
const MEM_PAGES = 100;

const GB = 1024 * 1024 * 1024;
const BIG_OFFSET = 4294970000;
const BIG_MEM_PAGES = 5 * GB / kPageSize;

(function(){
  TestAtomicI32Wait(MEM_PAGES, OFFSET);
  TestAtomicI64Wait(MEM_PAGES, OFFSET);

  if (this.Worker) {
    TestWasmAtomicsInWorkers(OFFSET, 0, MEM_PAGES);
    TestWasmAtomicsInWorkers(0, OFFSET, MEM_PAGES);
  }
})();

// Tests require Big memory >4GB, they may fail because of OOM.
(function(){
  allowOOM(() => TestAtomicI32Wait(BIG_MEM_PAGES, BIG_OFFSET));
  allowOOM(() => TestAtomicI64Wait(BIG_MEM_PAGES, BIG_OFFSET));

  if (this.Worker) {
    allowOOM(() => TestWasmAtomicsInWorkers(BIG_OFFSET, 0, BIG_MEM_PAGES));
    allowOOM(() => TestWasmAtomicsInWorkers(0, BIG_OFFSET, BIG_MEM_PAGES));
  }
})();
                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/wasm/atomics-non-shared.js                                         0000664 0000000 0000000 00000010272 14746647661 0023517 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// TODO(gdeepti): If non-shared atomics are moving forward, ensure that
// the tests here are more comprehensive -i.e. reuse atomics.js/atomics64.js
// and cctests to run on both shared/non-shared memory.

(function TestCompileGenericAtomicOp() {
  print(arguments.callee.name);
  let memory = new WebAssembly.Memory({initial: 0, maximum: 10});
  let builder = new WasmModuleBuilder();
  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kAtomicPrefix,
      kExprI32AtomicAdd, 2, 0]);
  builder.addImportedMemory("m", "imported_mem");
  let module = new WebAssembly.Module(builder.toBuffer());
})();

(function TestCompileWasmAtomicNotify() {
  print(arguments.callee.name);
  let memory = new WebAssembly.Memory({initial: 0, maximum: 10});
  let builder = new WasmModuleBuilder();
  builder.addImportedMemory("m", "memory", 0, 20);
  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kAtomicPrefix,
      kExprAtomicNotify, 2, 0])
    .exportAs("main");
  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module, {m: {memory}});
})();

(function TestCompileWasmI32AtomicWait() {
  print(arguments.callee.name);
  let memory = new WebAssembly.Memory({initial: 0, maximum: 10});
  let builder = new WasmModuleBuilder();
  builder.addImportedMemory("m", "memory", 0, 20);
  builder.addFunction("main",
    makeSig([kWasmI32, kWasmI32, kWasmF64], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprI64SConvertF64,
      kAtomicPrefix,
      kExprI32AtomicWait, 2, 0])
      .exportAs("main");
  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module, {m: {memory}});
})();

(function TestWasmAtomicNotifyResult() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addImportedMemory("m", "memory", 0, 20);
  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kAtomicPrefix,
      kExprAtomicNotify, 2, 0])
    .exportAs("main");

  // Instantiate module, get function exports
  let module = new WebAssembly.Module(builder.toBuffer());
  let memory = new WebAssembly.Memory({initial: 1, maximum: 1});
  let instance = new WebAssembly.Instance(module, {m: {memory}});
  assertEquals(0, instance.exports.main(0, 100));
})();

(function TestWasmI32AtomicWaitTraps() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addImportedMemory("m", "memory", 0, 20);
  builder.addFunction("main",
    makeSig([kWasmI32, kWasmI32, kWasmF64], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprI64SConvertF64,
      kAtomicPrefix,
      kExprI32AtomicWait, 2, 0])
      .exportAs("main");

  // Instantiate module, get function exports
  let module = new WebAssembly.Module(builder.toBuffer());
  let memory = new WebAssembly.Memory({initial: 1, maximum: 1});
  let instance = new WebAssembly.Instance(module, {m: {memory}});
  assertThrows(() => instance.exports.main(0, 5, 0), WebAssembly.RuntimeError);
})();

(function TestWasmI64AtomicWaitTraps() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addImportedMemory("m", "memory", 0, 20);
  builder.addFunction("main",
    makeSig([kWasmI32, kWasmI32, kWasmF64], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI64UConvertI32,
      kExprLocalGet, 2,
      kExprI64SConvertF64,
      kAtomicPrefix,
      kExprI64AtomicWait, 3, 0])
      .exportAs("main");

  // Instantiate module, get function exports
  let module = new WebAssembly.Module(builder.toBuffer());
  let memory = new WebAssembly.Memory({initial: 1, maximum: 1});
  let instance = new WebAssembly.Instance(module, {m: {memory}});
  assertThrows(() => instance.exports.main(0, 5, 0), WebAssembly.RuntimeError);
})();
                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/wasm/atomics-stress.js                                             0000664 0000000 0000000 00000035232 14746647661 0023007 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This test might time out if the search space for a sequential
// interleaving becomes to large. However, it should never fail.
// Note that results of this test are flaky by design. While the test is
// deterministic with a fixed seed, bugs may introduce non-determinism.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

const kDebug = false;

const kSequenceLength = 256;
const kNumberOfWorker = 4;
const kNumberOfSteps = 10000000;

const kFirstOpcodeWithInput = 3;
const kFirstOpcodeWithoutOutput = 3;
const kLastOpcodeWithoutOutput = 5;

const opCodes = [
  kExprI32AtomicLoad,     kExprI32AtomicLoad8U,     kExprI32AtomicLoad16U,
  kExprI32AtomicStore,    kExprI32AtomicStore8U,    kExprI32AtomicStore16U,
  kExprI32AtomicAdd,      kExprI32AtomicAdd8U,      kExprI32AtomicAdd16U,
  kExprI32AtomicSub,      kExprI32AtomicSub8U,      kExprI32AtomicSub16U,
  kExprI32AtomicAnd,      kExprI32AtomicAnd8U,      kExprI32AtomicAnd16U,
  kExprI32AtomicOr,       kExprI32AtomicOr8U,       kExprI32AtomicOr16U,
  kExprI32AtomicXor,      kExprI32AtomicXor8U,      kExprI32AtomicXor16U,
  kExprI32AtomicExchange, kExprI32AtomicExchange8U, kExprI32AtomicExchange16U
];

const opCodeNames = [
  'kExprI32AtomicLoad',       'kExprI32AtomicLoad8U',
  'kExprI32AtomicLoad16U',    'kExprI32AtomicStore',
  'kExprI32AtomicStore8U',    'kExprI32AtomicStore16U',
  'kExprI32AtomicAdd',        'kExprI32AtomicAdd8U',
  'kExprI32AtomicAdd16U',     'kExprI32AtomicSub',
  'kExprI32AtomicSub8U',      'kExprI32AtomicSub16U',
  'kExprI32AtomicAnd',        'kExprI32AtomicAnd8U',
  'kExprI32AtomicAnd16U',     'kExprI32AtomicOr',
  'kExprI32AtomicOr8U',       'kExprI32AtomicOr16U',
  'kExprI32AtomicXor',        'kExprI32AtomicXor8U',
  'kExprI32AtomicXor16U',     'kExprI32AtomicExchange',
  'kExprI32AtomicExchange8U', 'kExprI32AtomicExchange16U'
];

let kMaxMemPages = 10;
let gSharedMemory =
    new WebAssembly.Memory({initial: 1, maximum: kMaxMemPages, shared: true});
let gSharedMemoryView = new Int32Array(gSharedMemory.buffer);

let gPrivateMemory =
    new WebAssembly.Memory({initial: 1, maximum: kMaxMemPages, shared: true});
let gPrivateMemoryView = new Int32Array(gPrivateMemory.buffer);

class Operation {
  constructor(opcode, input, offset) {
    this.opcode = opcode != undefined ? opcode : Operation.nextOpcode();
    this.size = Operation.opcodeToSize(this.opcode);
    this.input = input != undefined ? input : Operation.inputForSize(this.size);
    this.offset =
        offset != undefined ? offset : Operation.offsetForSize(this.size);
  }

  static nextOpcode() {
    let random = Math.random();
    return Math.floor(random * opCodes.length);
  }

  static opcodeToSize(opcode) {
    // Instructions are ordered in 32, 8, 16 bits size
    return [32, 8, 16][opcode % 3];
  }

  static opcodeToAlignment(opcode) {
    // Instructions are ordered in 32, 8, 16 bits size
    return [2, 0, 1][opcode % 3];
  }

  static inputForSize(size) {
    let random = Math.random();
    // Avoid 32 bit overflow for integer here :(
    return Math.floor(random * (1 << (size - 1)) * 2);
  }

  static offsetForSize(size) {
    // Pick an offset in bytes between 0 and 7.
    let offset = Math.floor(Math.random() * 8);
    // Make sure the offset matches the required alignment by masking out the
    // lower bits.
    let size_in_bytes = size / 8;
    let mask = ~(size_in_bytes - 1);
    return offset & mask;
  }

  get wasmOpcode() {
    // [opcode, alignment, offset]
    return [
      opCodes[this.opcode], Operation.opcodeToAlignment(this.opcode),
      this.offset
    ];
  }

  get hasInput() {
    return this.opcode >= kFirstOpcodeWithInput;
  }

  get hasOutput() {
    return this.opcode < kFirstOpcodeWithoutOutput ||
        this.opcode > kLastOpcodeWithoutOutput;
  }

  truncateResultBits(low, high) {
    // Shift the lower part. For offsets greater four it drops out of the
    // visible window.
    let shiftedL = this.offset >= 4 ? 0 : low >>> (this.offset * 8);
    // The higher part is zero for offset 0, left shifted for [1..3] and right
    // shifted for [4..7].
    let shiftedH = this.offset == 0 ?
        0 :
        this.offset >= 4 ? high >>> (this.offset - 4) * 8 :
                           high << ((4 - this.offset) * 8);
    let value = shiftedL | shiftedH;

    switch (this.size) {
      case 8:
        return value & 0xFF;
      case 16:
        return value & 0xFFFF;
      case 32:
        return value;
      default:
        throw 'Unexpected size: ' + this.size;
    }
  }

  static get builder() {
    if (!Operation.__builder) {
      let builder = new WasmModuleBuilder();
      builder.addImportedMemory('m', 'imported_mem', 0, kMaxMemPages, 'shared');
      Operation.__builder = builder;
    }
    return Operation.__builder;
  }

  static get exports() {
    if (!Operation.__instance) {
      return {};
    }
    return Operation.__instance.exports;
  }

  static set instance(instance) {
    Operation.__instance = instance;
  }

  compute(state) {
    let evalFun = Operation.exports[this.key];
    if (!evalFun) {
      let builder = Operation.builder;
      let body = [
        // Load address of low 32 bits.
        kExprI32Const, 0,
        // Load expected value.
        kExprLocalGet, 0, kExprI32StoreMem, 2, 0,
        // Load address of high 32 bits.
        kExprI32Const, 4,
        // Load expected value.
        kExprLocalGet, 1, kExprI32StoreMem, 2, 0,
        // Load address of where our window starts.
        kExprI32Const, 0,
        // Load input if there is one.
        ...(this.hasInput ? [kExprLocalGet, 2] : []),
        // Perform operation.
        kAtomicPrefix, ...this.wasmOpcode,
        // Drop output if it had any.
        ...(this.hasOutput ? [kExprDrop] : []),
        // Load resulting value.
        kExprI32Const, 0, kExprI32LoadMem, 2, 0,
        // Return.
        kExprReturn
      ]
      builder.addFunction(this.key, kSig_i_iii)
          .addBody(body)
          .exportAs(this.key);
      // Instantiate module, get function exports.
      let module = new WebAssembly.Module(builder.toBuffer());
      Operation.instance =
          new WebAssembly.Instance(module, {m: {imported_mem: gPrivateMemory}});
      evalFun = Operation.exports[this.key];
    }
    let result = evalFun(state.low, state.high, this.input);
    let ta = gPrivateMemoryView;
    if (kDebug) {
      print(
          state.high + ':' + state.low + ' ' + this.toString() + ' -> ' +
          ta[1] + ':' + ta[0]);
    }
    if (result != ta[0]) throw '!';
    return {low: ta[0], high: ta[1]};
  }

  toString() {
    return opCodeNames[this.opcode] + '[+' + this.offset + '] ' + this.input;
  }

  get key() {
    return this.opcode + '-' + this.offset;
  }
}

class State {
  constructor(low, high, indices, count) {
    this.low = low;
    this.high = high;
    this.indices = indices;
    this.count = count;
  }

  isFinal() {
    return (this.count == kNumberOfWorker * kSequenceLength);
  }

  toString() {
    return this.high + ':' + this.low + ' @ ' + this.indices;
  }
}

function makeSequenceOfOperations(size) {
  let result = new Array(size);
  for (let i = 0; i < size; i++) {
    result[i] = new Operation();
  }
  return result;
}

function toSLeb128(val) {
  let result = [];
  while (true) {
    let v = val & 0x7f;
    val = val >> 7;
    let msbIsSet = (v & 0x40) || false;
    if (((val == 0) && !msbIsSet) || ((val == -1) && msbIsSet)) {
      result.push(v);
      break;
    }
    result.push(v | 0x80);
  }
  return result;
}

function generateFunctionBodyForSequence(sequence) {
  // We expect the int32* to perform ops on as arg 0 and
  // the int32* for our value log as arg1. Argument 2 gives
  // an int32* we use to count down spinning workers.
  let body = [];
  // Initially, we spin until all workers start running.
  if (!kDebug) {
    body.push(
        // Decrement the wait count.
        kExprLocalGet, 2, kExprI32Const, 1, kAtomicPrefix, kExprI32AtomicSub, 2,
        0,
        // Spin until zero.
        kExprLoop, kWasmVoid, kExprLocalGet, 2, kAtomicPrefix,
        kExprI32AtomicLoad, 2, 0, kExprI32Const, 0, kExprI32GtU, kExprBrIf, 0,
        kExprEnd);
  }
  for (let operation of sequence) {
    body.push(
        // Pre-load address of results sequence pointer for later.
        kExprLocalGet, 1,
        // Load address where atomic pointers are stored.
        kExprLocalGet, 0,
        // Load the second argument if it had any.
        ...(operation.hasInput ?
                [kExprI32Const, ...toSLeb128(operation.input)] :
                []),
        // Perform operation
        kAtomicPrefix, ...operation.wasmOpcode,
        // Generate fake output in needed.
        ...(operation.hasOutput ? [] : [kExprI32Const, 0]),
        // Store read intermediate to sequence.
        kExprI32StoreMem, 2, 0,
        // Increment result sequence pointer.
        kExprLocalGet, 1, kExprI32Const, 4, kExprI32Add, kExprLocalSet, 1);
  }
  // Return end of sequence index.
  body.push(kExprLocalGet, 1, kExprReturn);
  return body;
}

function getSequence(start, end) {
  return new Int32Array(
      gSharedMemory.buffer, start,
      (end - start) / Int32Array.BYTES_PER_ELEMENT);
}

function spawnWorkers() {
  function workerCode() {
    onmessage = function({data:msg}) {
      if (msg.module) {
        let module = msg.module;
        let mem = msg.mem;
        this.instance = new WebAssembly.Instance(module, {m: {imported_mem: mem}});
        postMessage({instantiated: true});
      } else {
        let address = msg.address;
        let sequence = msg.sequence;
        let index = msg.index;
        let spin = msg.spin;
        let result = instance.exports["worker" + index](address, sequence, spin);
        postMessage({index: index, sequence: sequence, result: result});
      }
    }
  }

  let workers = [];
  for (let i = 0; i < kNumberOfWorker; i++) {
    let worker = new Worker(workerCode, {type: 'function'});
    workers.push(worker);
  }
  return workers;
}

function instantiateModuleInWorkers(workers) {
  for (let worker of workers) {
    worker.postMessage({module: module, mem: gSharedMemory});
    let msg = worker.getMessage();
    if (!msg.instantiated) throw 'Worker failed to instantiate';
  }
}

function executeSequenceInWorkers(workers) {
  for (i = 0; i < workers.length; i++) {
    let worker = workers[i];
    worker.postMessage({
      index: i,
      address: 0,
      spin: 16,
      sequence: 32 + ((kSequenceLength * 4) + 32) * i
    });
    // In debug mode, keep execution sequential.
    if (kDebug) {
      let msg = worker.getMessage();
      results[msg.index] = getSequence(msg.sequence, msg.result);
    }
  }
}

function selectMatchingWorkers(state) {
  let matching = [];
  let indices = state.indices;
  for (let i = 0; i < indices.length; i++) {
    let index = indices[i];
    if (index >= kSequenceLength) continue;
    // We need to project the expected value to the number of bits this
    // operation will read at runtime.
    let expected =
        sequences[i][index].truncateResultBits(state.low, state.high);
    let hasOutput = sequences[i][index].hasOutput;
    if (!hasOutput || (results[i][index] == expected)) {
      matching.push(i);
    }
  }
  return matching;
}

function computeNextState(state, advanceIdx) {
  let newIndices = state.indices.slice();
  let sequence = sequences[advanceIdx];
  let operation = sequence[state.indices[advanceIdx]];
  newIndices[advanceIdx]++;
  let {low, high} = operation.compute(state);
  return new State(low, high, newIndices, state.count + 1);
}

function findSequentialOrdering() {
  let startIndices = new Array(results.length);
  let steps = 0;
  startIndices.fill(0);
  let matchingStates = [new State(0, 0, startIndices, 0)];
  while (matchingStates.length > 0) {
    let current = matchingStates.pop();
    if (kDebug) {
      print(current);
    }
    let matchingResults = selectMatchingWorkers(current);
    if (matchingResults.length == 0) {
      continue;
    }
    for (let match of matchingResults) {
      let newState = computeNextState(current, match);
      if (newState.isFinal()) {
        return true;
      }
      matchingStates.push(newState);
    }
    if (steps++ > kNumberOfSteps) {
      print('Search timed out, aborting...');
      return true;
    }
  }
  // We have no options left.
  return false;
}

// Helpful for debugging failed tests.
function loadSequencesFromStrings(inputs) {
  let reverseOpcodes = {};
  for (let i = 0; i < opCodeNames.length; i++) {
    reverseOpcodes[opCodeNames[i]] = i;
  }
  let sequences = [];
  let parseRE = /([a-zA-Z0-9]*)\[\+([0-9])\] ([\-0-9]*)/;
  for (let input of inputs) {
    let parts = input.split(',');
    let sequence = [];
    for (let part of parts) {
      let parsed = parseRE.exec(part);
      sequence.push(
          new Operation(reverseOpcodes[parsed[1]], parsed[3], parsed[2] | 0));
    }
    sequences.push(sequence);
  }
  return sequences;
}

// Helpful for debugging failed tests.
function loadResultsFromStrings(inputs) {
  let results = [];
  for (let input of inputs) {
    let parts = input.split(',');
    let result = [];
    for (let number of parts) {
      result.push(number | 0);
    }
    results.push(result);
  }
  return results;
}

let sequences = [];
let results = [];

let builder = new WasmModuleBuilder();
builder.addImportedMemory('m', 'imported_mem', 0, kMaxMemPages, 'shared');

for (let i = 0; i < kNumberOfWorker; i++) {
  sequences[i] = makeSequenceOfOperations(kSequenceLength);
  builder.addFunction('worker' + i, kSig_i_iii)
      .addBody(generateFunctionBodyForSequence(sequences[i]))
      .exportAs('worker' + i);
}

// Instantiate module, get function exports.
let module = new WebAssembly.Module(builder.toBuffer());
let instance =
    new WebAssembly.Instance(module, {m: {imported_mem: gSharedMemory}});

// Spawn off the workers and run the sequences.
let workers = spawnWorkers();
// Set spin count.
gSharedMemoryView[4] = kNumberOfWorker;
instantiateModuleInWorkers(workers);
executeSequenceInWorkers(workers);

if (!kDebug) {
  // Collect results, d8 style.
  for (let worker of workers) {
    let msg = worker.getMessage();
    results[msg.index] = getSequence(msg.sequence, msg.result);
  }
}

// Terminate all workers.
for (let worker of workers) {
  worker.terminate();
}

// In debug mode, print sequences and results.
if (kDebug) {
  for (let result of results) {
    print(result);
  }

  for (let sequence of sequences) {
    print(sequence);
  }
}

// Try to reconstruct a sequential ordering.
let passed = findSequentialOrdering();

if (passed) {
  print('PASS');
} else {
  for (let i = 0; i < kNumberOfWorker; i++) {
    print('Worker ' + i);
    print(sequences[i]);
    print(results[i]);
  }
  print('FAIL');
  quit(-1);
}
                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/wasm/atomics.js                                                    0000664 0000000 0000000 00000061010 14746647661 0021457 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

const kMemtypeSize64 = 8;
const kMemtypeSize32 = 4;
const kMemtypeSize16 = 2;
const kMemtypeSize8 = 1;

function Add(a, b) { return a + b; }
function Sub(a, b) { return a - b; }
function And(a, b) { return a & b; }
function Or(a, b) { return a | b; }
function Xor(a, b) { return a ^ b; }
function Exchange(a, b) { return b; }

let maxSize = 10;
let memory = new WebAssembly.Memory({initial: 1, maximum: maxSize, shared: true});

function GetAtomicBinOpFunction(wasmExpression, alignment, offset) {
  let builder = new WasmModuleBuilder();
  builder.addImportedMemory("m", "imported_mem", 0, maxSize, "shared");
  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kAtomicPrefix,
      wasmExpression, alignment, offset])
    .exportAs("main");

  // Instantiate module, get function exports
  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module,
        {m: {imported_mem: memory}});
  return instance.exports.main;
}

function GetI64AtomicBinOpFunction(wasmExpression, alignment, offset) {
  const kSig_l_il = makeSig([kWasmI32, kWasmI64], [kWasmI64]);
  let builder = new WasmModuleBuilder();
  builder.addImportedMemory("m", "imported_mem", 0, maxSize, "shared");
  builder.addFunction("main", kSig_l_il)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kAtomicPrefix,
      wasmExpression, alignment, offset
    ])
    .exportAs("main");

  // Instantiate module, get function exports
  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module,
        {m: {imported_mem: memory}});
  return instance.exports.main;
}

function GetAtomicCmpExchangeFunction(wasmExpression, alignment, offset) {
  let builder = new WasmModuleBuilder();
  builder.addImportedMemory("m", "imported_mem", 0, maxSize, "shared");
  builder.addFunction("main", kSig_i_iii)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kAtomicPrefix,
      wasmExpression, alignment, ...wasmSignedLeb(offset, 5)])
    .exportAs("main");

  // Instantiate module, get function exports
  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module,
        {m: {imported_mem: memory}});
  return instance.exports.main;
}

function GetAtomicLoadFunction(wasmExpression, alignment, offset) {
  let builder = new WasmModuleBuilder();
  builder.addImportedMemory("m", "imported_mem", 0, maxSize, "shared");
  builder.addFunction("main", kSig_i_i)
    .addBody([
      kExprLocalGet, 0,
      kAtomicPrefix,
      wasmExpression, alignment, offset])
    .exportAs("main");

  // Instantiate module, get function exports
  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module,
        {m: {imported_mem: memory}});
  return instance.exports.main;
}

function GetAtomicStoreFunction(wasmExpression, alignment, offset) {
  let builder = new WasmModuleBuilder();
  builder.addImportedMemory("m", "imported_mem", 0, maxSize, "shared");
  builder.addFunction("main", kSig_v_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kAtomicPrefix,
      wasmExpression, alignment, offset])
    .exportAs("main");

  // Instantiate module, get function exports
  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module,
        {m: {imported_mem: memory}});
  return instance.exports.main;
}

function VerifyBoundsCheck64(func, memtype_size) {
  const kPageSize = 65536;
  // Test out of bounds at boundary
  for (let i = memory.buffer.byteLength - memtype_size + 1;
       i < memory.buffer.byteLength + memtype_size + 4; i++) {
    assertTrapsOneOf(
      // If an underlying platform uses traps for a bounds check,
      // kTrapUnalignedAccess will be thrown before kTrapMemOutOfBounds.
      // Otherwise, kTrapMemOutOfBounds will be first.
      [kTrapMemOutOfBounds, kTrapUnalignedAccess],
      () => func(i, 5n, 10n)
    );
  }
  // Test out of bounds at maximum + 1
  assertTraps(kTrapMemOutOfBounds, () => func((maxSize + 1) * kPageSize, 5n, 1n));
}

function VerifyBoundsCheck(func, memtype_size) {
  const kPageSize = 65536;
  // Test out of bounds at boundary
  for (let i = memory.buffer.byteLength - memtype_size + 1;
       i < memory.buffer.byteLength + memtype_size + 4; i++) {
    assertTrapsOneOf(
      // If an underlying platform uses traps for a bounds check,
      // kTrapUnalignedAccess will be thrown before kTrapMemOutOfBounds.
      // Otherwise, kTrapMemOutOfBounds will be first.
      [kTrapMemOutOfBounds, kTrapUnalignedAccess],
      () => func(i, 5, 10)
    );
  }
  // Test out of bounds at maximum + 1
  assertTraps(kTrapMemOutOfBounds, () => func((maxSize + 1) * kPageSize, 5, 1));
}

// Test many elements in the small range, make bigger steps later. This is still
// O(2^n), but takes 213 steps to reach 2^32.
const inc = i => i + Math.floor(i/10) + 1;

function Test32Op(operation, func) {
  let i32 = new Uint32Array(memory.buffer);
  for (let i = 0; i < i32.length; i = inc(i)) {
    let expected = 0x9cedf00d;
    let value = 0x11111111;
    i32[i] = expected;
    assertEquals(expected, func(i * kMemtypeSize32, value) >>> 0);
    assertEquals(operation(expected, value) >>> 0, i32[i]);
  }
  VerifyBoundsCheck(func, kMemtypeSize32);
}

function Test16Op(operation, func) {
  let i16 = new Uint16Array(memory.buffer);
  for (let i = 0; i < i16.length; i = inc(i)) {
    let expected = 0xd00d;
    let value = 0x1111;
    i16[i] = expected;
    assertEquals(expected, func(i * kMemtypeSize16, value));
    assertEquals(operation(expected, value), i16[i]);
  }
  VerifyBoundsCheck(func, kMemtypeSize16);
}

function Test8Op(operation, func) {
  let i8 = new Uint8Array(memory.buffer);
  for (let i = 0; i < i8.length; i = inc(i)) {
    let expected = 0xbe;
    let value = 0x12;
    i8[i] = expected;
    assertEquals(expected, func(i * kMemtypeSize8, value));
    assertEquals(operation(expected, value), i8[i]);
  }
  VerifyBoundsCheck(func, kMemtypeSize8, 10);
}

function Test64Op(operation, func) {
  let i64 = new BigUint64Array(memory.buffer);
  for (let i = 0; i < i64.length; i = inc(i)) {
    let expected = 987659876543210n;
    let value = 111111111111111n;
    i64[i] = expected;
    assertEquals(expected, func(i * kMemtypeSize64, value));
    assertEquals(operation(expected, value), i64[i]);
  }
  VerifyBoundsCheck64(func, kMemtypeSize64);
}

function Test32Op64(operation, func) {
  let i32 = new Uint32Array(memory.buffer);
  for (let i = 0; i < i32.length; i = inc(i)) {
    let expected = 123456;
    let value = 111111n;
    i32[i] = expected;
    assertEquals(expected, Number(func(i * kMemtypeSize32, value)));
    assertEquals(operation(expected, Number(value)), i32[i]);
  }
  VerifyBoundsCheck64(func, kMemtypeSize32);
}

function Test16Op64(operation, func) {
  let i16 = new Uint16Array(memory.buffer);
  for (let i = 0; i < i16.length; i = inc(i)) {
    let expected = 0xd00d;
    let value = 0x1111n;
    i16[i] = expected;
    assertEquals(expected, Number(func(i * kMemtypeSize16, value)));
    assertEquals(operation(expected, Number(value)), i16[i]);
  }
  VerifyBoundsCheck64(func, kMemtypeSize16);
}

function Test8Op64(operation, func) {
  let i8 = new Uint8Array(memory.buffer);
  for (let i = 0; i < i8.length; i = inc(i)) {
    let expected = 0xbe;
    let value = 0x12n;
    i8[i] = expected;
    assertEquals(expected, Number(func(i * kMemtypeSize8, value)));
    assertEquals(operation(expected, Number(value)), i8[i]);
  }
  VerifyBoundsCheck64(func, kMemtypeSize8, 10);
}

(function TestAtomicAdd() {
  print(arguments.callee.name);
  let wasmAdd = GetAtomicBinOpFunction(kExprI32AtomicAdd, 2, 0);
  Test32Op(Add, wasmAdd);
})();

(function TestAtomicAdd16U() {
  print(arguments.callee.name);
  let wasmAdd = GetAtomicBinOpFunction(kExprI32AtomicAdd16U, 1, 0);
  Test16Op(Add, wasmAdd);
})();

(function TestAtomicAdd8U() {
  print(arguments.callee.name);
  let wasmAdd = GetAtomicBinOpFunction(kExprI32AtomicAdd8U, 0, 0);
  Test8Op(Add, wasmAdd);
})();

(function TestI64AtomicAdd() {
  print(arguments.callee.name);
  let wasmAdd = GetI64AtomicBinOpFunction(kExprI64AtomicAdd, 3, 0);
  Test64Op(Add, wasmAdd);
})();

(function TestI64AtomicAdd32U() {
  print(arguments.callee.name);
  let wasmAdd = GetI64AtomicBinOpFunction(kExprI64AtomicAdd32U, 2, 0);
  Test32Op64(Add, wasmAdd);
})();

(function TestI64AtomicAdd16U() {
  print(arguments.callee.name);
  let wasmAdd = GetI64AtomicBinOpFunction(kExprI64AtomicAdd16U, 1, 0);
  Test16Op64(Add, wasmAdd);
})();

(function TestI64AtomicAdd8U() {
  print(arguments.callee.name);
  let wasmAdd = GetI64AtomicBinOpFunction(kExprI64AtomicAdd8U, 0, 0);
  Test8Op64(Add, wasmAdd);
})();

(function TestAtomicSub() {
  print(arguments.callee.name);
  let wasmSub = GetAtomicBinOpFunction(kExprI32AtomicSub, 2, 0);
  Test32Op(Sub, wasmSub);
})();

(function TestAtomicSub16U() {
  print(arguments.callee.name);
  let wasmSub = GetAtomicBinOpFunction(kExprI32AtomicSub16U, 1, 0);
  Test16Op(Sub, wasmSub);
})();

(function TestAtomicSub8U() {
  print(arguments.callee.name);
  let wasmSub = GetAtomicBinOpFunction(kExprI32AtomicSub8U, 0, 0);
  Test8Op(Sub, wasmSub);
})();

(function TestI64AtomicSub() {
  print(arguments.callee.name);
  let wasmSub = GetI64AtomicBinOpFunction(kExprI64AtomicSub, 3, 0);
  Test64Op(Sub, wasmSub);
})();

(function TestI64AtomicSub32U() {
  print(arguments.callee.name);
  let wasmSub = GetI64AtomicBinOpFunction(kExprI64AtomicSub32U, 2, 0);
  Test32Op64(Sub, wasmSub);
})();

(function TestI64AtomicSub16U() {
  print(arguments.callee.name);
  let wasmSub = GetI64AtomicBinOpFunction(kExprI64AtomicSub16U, 1, 0);
  Test16Op64(Sub, wasmSub);
})();

(function TestI64AtomicSub8U() {
  print(arguments.callee.name);
  let wasmSub = GetI64AtomicBinOpFunction(kExprI64AtomicSub8U, 0, 0);
  Test8Op64(Sub, wasmSub);
})();

(function TestAtomicAnd() {
  print(arguments.callee.name);
  let wasmAnd = GetAtomicBinOpFunction(kExprI32AtomicAnd, 2, 0);
  Test32Op(And, wasmAnd);
})();

(function TestAtomicAnd16U() {
  print(arguments.callee.name);
  let wasmAnd = GetAtomicBinOpFunction(kExprI32AtomicAnd16U, 1, 0);
  Test16Op(And, wasmAnd);
})();

(function TestAtomicAnd8U() {
  print(arguments.callee.name);
  let wasmAnd = GetAtomicBinOpFunction(kExprI32AtomicAnd8U, 0, 0);
  Test8Op(And, wasmAnd);
})();

(function TestI64AtomicAnd() {
  print(arguments.callee.name);
  let wasmAnd = GetI64AtomicBinOpFunction(kExprI64AtomicAnd, 3, 0);
  Test64Op(And, wasmAnd);
})();

(function TestI64AtomicAnd32U() {
  print(arguments.callee.name);
  let wasmAnd = GetI64AtomicBinOpFunction(kExprI64AtomicAnd32U, 2, 0);
  Test32Op64(And, wasmAnd);
})();

(function TestI64AtomicAnd16U() {
  print(arguments.callee.name);
  let wasmAnd = GetI64AtomicBinOpFunction(kExprI64AtomicAnd16U, 1, 0);
  Test16Op64(And, wasmAnd);
})();

(function TestI64AtomicAnd8U() {
  print(arguments.callee.name);
  let wasmAnd = GetI64AtomicBinOpFunction(kExprI64AtomicAnd8U, 0, 0);
  Test8Op64(And, wasmAnd);
})();

(function TestAtomicOr() {
  print(arguments.callee.name);
  let wasmOr = GetAtomicBinOpFunction(kExprI32AtomicOr, 2, 0);
  Test32Op(Or, wasmOr);
})();

(function TestAtomicOr16U() {
  print(arguments.callee.name);
  let wasmOr = GetAtomicBinOpFunction(kExprI32AtomicOr16U, 1, 0);
  Test16Op(Or, wasmOr);
})();

(function TestAtomicOr8U() {
  print(arguments.callee.name);
  let wasmOr = GetAtomicBinOpFunction(kExprI32AtomicOr8U, 0, 0);
  Test8Op(Or, wasmOr);
})();

(function TestI64AtomicOr() {
  print(arguments.callee.name);
  let wasmOr = GetI64AtomicBinOpFunction(kExprI64AtomicOr, 3, 0);
  Test64Op(Or, wasmOr);
})();

(function TestI64AtomicOr32U() {
  print(arguments.callee.name);
  let wasmOr = GetI64AtomicBinOpFunction(kExprI64AtomicOr32U, 2, 0);
  Test32Op64(Or, wasmOr);
})();

(function TestI64AtomicOr16U() {
  print(arguments.callee.name);
  let wasmOr = GetI64AtomicBinOpFunction(kExprI64AtomicOr16U, 1, 0);
  Test16Op64(Or, wasmOr);
})();

(function TestI64AtomicOr8U() {
  print(arguments.callee.name);
  let wasmOr = GetI64AtomicBinOpFunction(kExprI64AtomicOr8U, 0, 0);
  Test8Op64(Or, wasmOr);
})();

(function TestAtomicXor() {
  print(arguments.callee.name);
  let wasmXor = GetAtomicBinOpFunction(kExprI32AtomicXor, 2, 0);
  Test32Op(Xor, wasmXor);
})();

(function TestAtomicXor16U() {
  print(arguments.callee.name);
  let wasmXor = GetAtomicBinOpFunction(kExprI32AtomicXor16U, 1, 0);
  Test16Op(Xor, wasmXor);
})();

(function TestAtomicXor8U() {
  print(arguments.callee.name);
  let wasmXor = GetAtomicBinOpFunction(kExprI32AtomicXor8U, 0, 0);
  Test8Op(Xor, wasmXor);
})();

(function TestI64AtomicXor() {
  print(arguments.callee.name);
  let wasmXor = GetI64AtomicBinOpFunction(kExprI64AtomicXor, 3, 0);
  Test64Op(Xor, wasmXor);
})();

(function TestI64AtomicXor32U() {
  print(arguments.callee.name);
  let wasmXor = GetI64AtomicBinOpFunction(kExprI64AtomicXor32U, 2, 0);
  Test32Op64(Xor, wasmXor);
})();

(function TestI64AtomicXor16U() {
  print(arguments.callee.name);
  let wasmXor = GetI64AtomicBinOpFunction(kExprI64AtomicXor16U, 1, 0);
  Test16Op64(Xor, wasmXor);
})();

(function TestI64AtomicXor8U() {
  print(arguments.callee.name);
  let wasmXor = GetI64AtomicBinOpFunction(kExprI64AtomicXor8U, 0, 0);
  Test8Op64(Xor, wasmXor);
})();

(function TestAtomicExchange() {
  print(arguments.callee.name);
  let wasmExchange = GetAtomicBinOpFunction(kExprI32AtomicExchange, 2, 0);
  Test32Op(Exchange, wasmExchange);
})();

(function TestAtomicExchange16U() {
  print(arguments.callee.name);
  let wasmExchange = GetAtomicBinOpFunction(kExprI32AtomicExchange16U, 1, 0);
  Test16Op(Exchange, wasmExchange);
})();

(function TestAtomicExchange8U() {
  print(arguments.callee.name);
  let wasmExchange = GetAtomicBinOpFunction(kExprI32AtomicExchange8U, 0, 0);
  Test8Op(Exchange, wasmExchange);
})();

(function TestI64AtomicExchange() {
  print(arguments.callee.name);
  let wasmExchange = GetI64AtomicBinOpFunction(kExprI64AtomicExchange, 3, 0);
  Test64Op(Exchange, wasmExchange);
})();

(function TestI64AtomicExchange32U() {
  print(arguments.callee.name);
  let wasmExchange = GetI64AtomicBinOpFunction(kExprI64AtomicExchange32U, 2, 0);
  Test32Op64(Exchange, wasmExchange);
})();

(function TestI64AtomicExchange16U() {
  print(arguments.callee.name);
  let wasmExchange = GetI64AtomicBinOpFunction(kExprI64AtomicExchange16U, 1, 0);
  Test16Op64(Exchange, wasmExchange);
})();

(function TestI64AtomicExchange8U() {
  print(arguments.callee.name);
  let wasmExchange = GetI64AtomicBinOpFunction(kExprI64AtomicExchange8U, 0, 0);
  Test8Op64(Exchange, wasmExchange);
})();


function TestCmpExchange(func, buffer, params, size, offset = 0) {
  for (let i = 0; i + (offset / size) < buffer.length; i = inc(i)) {
    for (let j = 0; j < params.length; j++) {
      for (let k = 0; k < params.length; k++) {
        buffer[i + (offset / size)] = params[j];
        let loaded = func(i * size, params[k], params[j]) >>> 0;
        let expected = (params[k] == loaded) ? params[j] : loaded;
        assertEquals(loaded, params[j]);
        assertEquals(expected, buffer[i + (offset / size)]);
      }
    }
  }
  VerifyBoundsCheck(func, size);
}

(function TestAtomicCompareExchange() {
  print(arguments.callee.name);
  // Offset is big enough to not fit in a 12-bit immediate on arm64, but small
  // enough to fit in the maxSize wasm pages.
  const offset = 0x1234;
  let wasmCmpExchange =
      GetAtomicCmpExchangeFunction(kExprI32AtomicCompareExchange, 2, offset);
  let i32 = new Uint32Array(memory.buffer);
  let params = [0x00000001, 0x00000555, 0x00099999, 0xffffffff];
  TestCmpExchange(wasmCmpExchange, i32, params, kMemtypeSize32, offset);
})();

(function TestAtomicCompareExchange16U() {
  print(arguments.callee.name);
  let wasmCmpExchange =
      GetAtomicCmpExchangeFunction(kExprI32AtomicCompareExchange16U, 1, 0);
  let i16 = new Uint16Array(memory.buffer);
  let params = [0x0001, 0x0555, 0x9999];
  TestCmpExchange(wasmCmpExchange, i16, params, kMemtypeSize16);
})();

(function TestAtomicCompareExchange8U() {
  print(arguments.callee.name);
  let wasmCmpExchange =
      GetAtomicCmpExchangeFunction(kExprI32AtomicCompareExchange8U, 0, 0);
  let i8 = new Uint8Array(memory.buffer);
  let params = [0x01, 0x0d, 0xf9];
  TestCmpExchange(wasmCmpExchange, i8, params, kMemtypeSize8);
})();

function TestLoad(func, buffer, value, size) {
  for (let i = 0; i < buffer.length; i = inc(i)) {
    buffer[i] = value;
    assertEquals(value, func(i * size) >>> 0);
  }
  VerifyBoundsCheck(func, size);
}

(function TestAtomicLoad() {
  print(arguments.callee.name);
  let wasmLoad = GetAtomicLoadFunction(kExprI32AtomicLoad, 2, 0);
  let i32 = new Uint32Array(memory.buffer);
  let value = 0xacedaced;
  TestLoad(wasmLoad, i32, value, kMemtypeSize32);
})();

(function TestAtomicLoad16U() {
  print(arguments.callee.name);
  let wasmLoad = GetAtomicLoadFunction(kExprI32AtomicLoad16U, 1, 0);
  let i16 = new Uint16Array(memory.buffer);
  let value = 0xaced;
  TestLoad(wasmLoad, i16, value, kMemtypeSize16);
})();

(function TestAtomicLoad8U() {
  print(arguments.callee.name);
  let wasmLoad = GetAtomicLoadFunction(kExprI32AtomicLoad8U, 0, 0);
  let i8 = new Uint8Array(memory.buffer);
  let value = 0xac;
  TestLoad(wasmLoad, i8, value, kMemtypeSize8);
})();

function TestStore(func, buffer, value, size) {
  for (let i = 0; i < buffer.length; i = inc(i)) {
    func(i * size, value)
    assertEquals(value, buffer[i]);
  }
  VerifyBoundsCheck(func, size);
}

(function TestAtomicStore() {
  print(arguments.callee.name);
  let wasmStore = GetAtomicStoreFunction(kExprI32AtomicStore, 2, 0);
  let i32 = new Uint32Array(memory.buffer);
  let value = 0xacedaced;
  TestStore(wasmStore, i32, value, kMemtypeSize32);
})();

(function TestAtomicStore16U() {
  print(arguments.callee.name);
  let wasmStore = GetAtomicStoreFunction(kExprI32AtomicStore16U, 1, 0);
  let i16 = new Uint16Array(memory.buffer);
  let value = 0xaced;
  TestStore(wasmStore, i16, value, kMemtypeSize16);
})();

(function TestAtomicStore8U() {
  print(arguments.callee.name);
  let wasmStore = GetAtomicStoreFunction(kExprI32AtomicStore8U, 0, 0);
  let i8 = new Uint8Array(memory.buffer);
  let value = 0xac;
  TestCmpExchange(wasmStore, i8, value, kMemtypeSize8);
})();

(function TestAtomicLoadStoreOffset() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  let memory = new WebAssembly.Memory({
    initial: 16, maximum: 128, shared: true});
  builder.addImportedMemory("m", "imported_mem", 16, 128, "shared");
  builder.addFunction("loadStore", kSig_i_v)
    .addBody([
      kExprI32Const, 16,
      kExprI32Const, 20,
      kAtomicPrefix,
      kExprI32AtomicStore, 2, 0xFC, 0xFF, 0x3a,
      kExprI32Const, 16,
      kAtomicPrefix,
      kExprI32AtomicLoad, 2, 0xFC, 0xFF, 0x3a])
    .exportAs("loadStore");
  builder.addFunction("storeOob", kSig_v_v)
    .addBody([
      kExprI32Const, 16,
      kExprI32Const, 20,
      kAtomicPrefix,
      kExprI32AtomicStore, 2, 0xFC, 0xFF, 0xFF, 0x3a])
    .exportAs("storeOob");
  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = (new WebAssembly.Instance(module,
        {m: {imported_mem: memory}}));
  let buf = memory.buffer;
  assertEquals(20, instance.exports.loadStore());
  assertTraps(kTrapMemOutOfBounds, instance.exports.storeOob);
})();

(function TestAtomicOpinLoop() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  let memory = new WebAssembly.Memory({
    initial: 16, maximum: 128, shared: true});
  builder.addImportedMemory("m", "imported_mem", 16, 128, "shared");
  builder.addFunction("main", kSig_i_v)
    .addBody([
      kExprLoop, kWasmVoid,
        kExprI32Const, 16,
        kExprI32Const, 20,
        kAtomicPrefix,
        kExprI32AtomicStore, 2, 0,
        kExprI32Const, 16,
        kAtomicPrefix,
        kExprI32AtomicLoad, 2, 0,
        kExprReturn,
      kExprEnd,
      kExprI32Const, 0
    ])
    .exportFunc();
  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = (new WebAssembly.Instance(module,
        {m: {imported_mem: memory}}));
  assertEquals(20, instance.exports.main());
})();

(function TestUnalignedAtomicAccesses() {
  print(arguments.callee.name);
  let wasmAdd = GetAtomicBinOpFunction(kExprI32AtomicAdd, 2, 17);
  assertTraps(kTrapUnalignedAccess, () => wasmAdd(4, 1001));
  let wasmLoad = GetAtomicLoadFunction(kExprI32AtomicLoad16U, 1, 0);
  assertTraps(kTrapUnalignedAccess, () => wasmLoad(15));
  let wasmStore = GetAtomicStoreFunction(kExprI32AtomicStore, 2, 0);
  assertTraps(kTrapUnalignedAccess, () => wasmStore(22, 5));
  let wasmCmpExchange =
      GetAtomicCmpExchangeFunction(kExprI32AtomicCompareExchange, 2, 0x16);
  assertTraps(kTrapUnalignedAccess, () => wasmCmpExchange(11, 6, 5));

  // Building functions with bad alignment should fail to compile
  assertThrows(() => GetAtomicBinOpFunction(kExprI32AtomicSub16U, 3, 0),
      WebAssembly.CompileError);
})();

function CmpExchgLoop(opcode, alignment) {
  print("TestI64AtomicCompareExchangeLoop" + alignment);
  let builder = new WasmModuleBuilder();
  builder.addImportedMemory("m", "imported_mem", 0, 2, "shared");
  builder.addFunction("main", makeSig([kWasmI32], []))
      .addLocals(kWasmI64, 2)
      .addBody([
        kExprLoop, kWasmVoid,
          kExprLocalGet, 0,
          kExprLocalGet, 1,
          kExprLocalGet, 2,
          kAtomicPrefix, opcode, alignment, 0,
          kExprLocalGet, 1,
          kExprI64Ne,
          kExprBrIf, 0,
          kExprEnd
      ])
      .exportFunc();
  let mem = new WebAssembly.Memory({initial: 2, maximum: 2, shared: true});
  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module, {m: {imported_mem: mem}});
}

(function TestAtomicCompareExchgLoop() {
  CmpExchgLoop(kExprI64AtomicCompareExchange, 3);
  CmpExchgLoop(kExprI64AtomicCompareExchange32U, 2);
  CmpExchgLoop(kExprI64AtomicCompareExchange16U, 1);
  CmpExchgLoop(kExprI64AtomicCompareExchange8U, 0);
})();

(function TestIllegalAtomicOp() {
  // Regression test for https://crbug.com/1381330.
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction('main', kSig_v_v).addBody([
    kAtomicPrefix, 0x90, 0x0f
  ]);
  assertEquals(false, WebAssembly.validate(builder.toBuffer()));
  assertThrows(
      () => builder.toModule(), WebAssembly.CompileError,
      /invalid atomic opcode: 0xfe790/);
})();

(function TestConsistentErrorReporting() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.addMemory(1, 32);
  builder.addFunction("atomicStore", makeSig([kWasmI32], []))
    .addBody([
      kExprLocalGet, 0,
      kExprI64Const, 42, // A dummy value to be stored.
      kAtomicPrefix, kExprI64AtomicStore, /*align*/ 0x03, /*offset*/ 0x00,
    ]).exportFunc();
  builder.addFunction("atomicLoad", makeSig([kWasmI32], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      kAtomicPrefix, kExprI64AtomicLoad, /*align*/ 0x03, /*offset*/ 0x00,
    ]).exportFunc();
  builder.addFunction("atomicAdd", makeSig([kWasmI32], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kExprI32Const, 42,
      kAtomicPrefix, kExprI32AtomicAdd, /*align*/ 0x02, /*offset*/ 0x00,
    ]).exportFunc();
  builder.addFunction("atomicCompareExchange", makeSig([kWasmI32], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kExprI32Const, 12,
      kExprI32Const, 23,
      kAtomicPrefix, kExprI32AtomicCompareExchange,
      /*align*/ 0x02, /*offset*/ 0x00,
    ]).exportFunc();
  builder.addFunction("atomicWait", makeSig([kWasmI32], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kExprI32Const, 12,
      kExprI64Const, 23,
      kAtomicPrefix, kExprI32AtomicWait, /*align*/ 0x02, /*offset*/ 0x00,
    ]).exportFunc();
  builder.addFunction("atomicNotify", makeSig([kWasmI32], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kExprI32Const, 12,
      kAtomicPrefix, kExprAtomicNotify, /*align*/ 0x02, /*offset*/ 0x00,
    ]).exportFunc();


  const wasm = builder.instantiate().exports;

  let unaligned = 1;
  let oob = 1024 * 1024;
  for (let test of [
      "atomicStore", "atomicLoad", "atomicAdd", "atomicCompareExchange",
      "atomicWait", "atomicNotify"]) {
    print(`- test ${test}`);
    let fct = wasm[test];
    assertTraps(kTrapUnalignedAccess, () => fct(unaligned));
    assertTraps(kTrapMemOutOfBounds, () => fct(oob));
    // If an atomic operation is both unaligned and out of bounds, the unaligned
    // error is reported.
    assertTraps(kTrapUnalignedAccess, () => fct(unaligned + oob));
  }
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/wasm/atomics64-stress.js                                           0000664 0000000 0000000 00000040301 14746647661 0023152 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// This test might time out if the search space for a sequential
// interleaving becomes to large. However, it should never fail.
// Note that results of this test are flaky by design. While the test is
// deterministic with a fixed seed, bugs may introduce non-determinism.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

const kDebug = false;

const kSequenceLength = 256;
const kNumberOfWorker = 4;
const kNumberOfSteps = 10000000;

const kFirstOpcodeWithInput = 4;
const kFirstOpcodeWithoutOutput = 4;
const kLastOpcodeWithoutOutput = 7;

const opCodes = [
  kExprI64AtomicLoad,        kExprI64AtomicLoad8U,     kExprI64AtomicLoad16U,
  kExprI64AtomicLoad32U,     kExprI64AtomicStore,      kExprI64AtomicStore8U,
  kExprI64AtomicStore16U,    kExprI64AtomicStore32U,   kExprI64AtomicAdd,
  kExprI64AtomicAdd8U,       kExprI64AtomicAdd16U,     kExprI64AtomicAdd32U,
  kExprI64AtomicSub,         kExprI64AtomicSub8U,      kExprI64AtomicSub16U,
  kExprI64AtomicSub32U,      kExprI64AtomicAnd,        kExprI64AtomicAnd8U,
  kExprI64AtomicAnd16U,      kExprI64AtomicAnd32U,     kExprI64AtomicOr,
  kExprI64AtomicOr8U,        kExprI64AtomicOr16U,      kExprI64AtomicOr32U,
  kExprI64AtomicXor,         kExprI64AtomicXor8U,      kExprI64AtomicXor16U,
  kExprI64AtomicXor32U,      kExprI64AtomicExchange,   kExprI64AtomicExchange8U,
  kExprI64AtomicExchange16U, kExprI64AtomicExchange32U
];

const opCodeNames = [
  'kExprI64AtomicLoad',        'kExprI64AtomicLoad8U',
  'kExprI64AtomicLoad16U',     'kExprI64AtomicLoad32U',
  'kExprI64AtomicStore',       'kExprI64AtomicStore8U',
  'kExprI64AtomicStore16U',    'kExprI64AtomicStore32U',
  'kExprI64AtomicAdd',         'kExprI64AtomicAdd8U',
  'kExprI64AtomicAdd16U',      'kExprI64AtomicAdd32U',
  'kExprI64AtomicSub',         'kExprI64AtomicSub8U',
  'kExprI64AtomicSub16U',      'kExprI64AtomicSub32U',
  'kExprI64AtomicAnd',         'kExprI64AtomicAnd8U',
  'kExprI64AtomicAnd16U',      'kExprI64AtomicAnd32U',
  'kExprI64AtomicOr',          'kExprI64AtomicOr8U',
  'kExprI64AtomicOr16U',       'kExprI64AtomicOr32U',
  'kExprI64AtomicXor',         'kExprI64AtomicXor8U',
  'kExprI64AtomicXor16U',      'kExprI64AtomicXor32U',
  'kExprI64AtomicExchange',    'kExprI64AtomicExchange8U',
  'kExprI64AtomicExchange16U', 'kExprI64AtomicExchange32U'
];

let kMaxMemPages = 10;
let gSharedMemory =
    new WebAssembly.Memory({initial: 1, maximum: kMaxMemPages, shared: true});
let gSharedMemoryView = new Int32Array(gSharedMemory.buffer);

let gPrivateMemory =
    new WebAssembly.Memory({initial: 1, maximum: kMaxMemPages, shared: true});
let gPrivateMemoryView = new Int32Array(gPrivateMemory.buffer);

const kMaxInt32 = (1 << 31) * 2;

class Operation {
  constructor(opcode, low_input, high_input, offset) {
    this.opcode = opcode != undefined ? opcode : Operation.nextOpcode();
    this.size = Operation.opcodeToSize(this.opcode);
    if (low_input == undefined) {
      [low_input, high_input] = Operation.inputForSize(this.size);
    }
    this.low_input = low_input;
    this.high_input = high_input;
    this.offset =
        offset != undefined ? offset : Operation.offsetForSize(this.size);
  }

  static nextOpcode() {
    let random = Math.random();
    return Math.floor(random * opCodes.length);
  }

  static opcodeToSize(opcode) {
    // Instructions are ordered in 64, 8, 16, 32 bits size
    return [64, 8, 16, 32][opcode % 4];
  }

  static opcodeToAlignment(opcode) {
    // Instructions are ordered in 64, 8, 16, 32 bits size
    return [3, 0, 1, 2][opcode % 4];
  }

  static inputForSize(size) {
    if (size <= 32) {
      let random = Math.random();
      // Avoid 32 bit overflow for integer here :(
      return [Math.floor(random * (1 << (size - 1)) * 2), 0];
    }
    return [
      Math.floor(Math.random() * kMaxInt32),
      Math.floor(Math.random() * kMaxInt32)
    ];
  }

  static offsetForSize(size) {
    // Pick an offset in bytes between 0 and 8.
    let offset = Math.floor(Math.random() * 8);
    // Make sure the offset matches the required alignment by masking out the
    // lower bits.
    let size_in_bytes = size / 8;
    let mask = ~(size_in_bytes - 1);
    return offset & mask;
  }

  get wasmOpcode() {
    // [opcode, alignment, offset]
    return [
      opCodes[this.opcode], Operation.opcodeToAlignment(this.opcode),
      this.offset
    ];
  }

  get hasInput() {
    return this.opcode >= kFirstOpcodeWithInput;
  }

  get hasOutput() {
    return this.opcode < kFirstOpcodeWithoutOutput ||
        this.opcode > kLastOpcodeWithoutOutput;
  }

  truncateResultBits(low, high) {
    if (this.size == 64)
      return [low, high]

          // Shift the lower part. For offsets greater four it drops out of the
          // visible window.
          let shiftedL = this.offset >= 4 ? 0 : low >>> (this.offset * 8);
    // The higher part is zero for offset 0, left shifted for [1..3] and right
    // shifted for [4..7].
    let shiftedH = this.offset == 0 ?
        0 :
        this.offset >= 4 ? high >>> (this.offset - 4) * 8 :
                           high << ((4 - this.offset) * 8);
    let value = shiftedL | shiftedH;

    switch (this.size) {
      case 8:
        return [value & 0xFF, 0];
      case 16:
        return [value & 0xFFFF, 0];
      case 32:
        return [value, 0];
      default:
        throw 'Unexpected size: ' + this.size;
    }
  }

  static get builder() {
    if (!Operation.__builder) {
      let builder = new WasmModuleBuilder();
      builder.addImportedMemory('m', 'imported_mem', 0, kMaxMemPages, 'shared');
      Operation.__builder = builder;
    }
    return Operation.__builder;
  }

  static get exports() {
    if (!Operation.__instance) {
      return {};
    }
    return Operation.__instance.exports;
  }

  static get memory() {
    return Operation.exports.mem;
  }

  static set instance(instance) {
    Operation.__instance = instance;
  }

  compute(state) {
    let evalFun = Operation.exports[this.key];
    if (!evalFun) {
      let builder = Operation.builder;
      let body = [
        // Load address of low 32 bits.
        kExprI32Const, 0,
        // Load expected value.
        kExprLocalGet, 0, kExprI32StoreMem, 2, 0,
        // Load address of high 32 bits.
        kExprI32Const, 4,
        // Load expected value.
        kExprLocalGet, 1, kExprI32StoreMem, 2, 0,
        // Load address of where our window starts.
        kExprI32Const, 0,
        // Load input if there is one.
        ...(this.hasInput ?
                [
                  kExprLocalGet, 3, kExprI64UConvertI32, kExprI64Const, 32,
                  kExprI64Shl, kExprLocalGet, 2, kExprI64UConvertI32,
                  kExprI64Ior
                ] :
                []),
        // Perform operation.
        kAtomicPrefix, ...this.wasmOpcode,
        // Drop output if it had any.
        ...(this.hasOutput ? [kExprDrop] : []),
        // Return.
        kExprReturn
      ]
      builder.addFunction(this.key, kSig_v_iiii)
          .addBody(body)
          .exportAs(this.key);
      // Instantiate module, get function exports.
      let module = new WebAssembly.Module(builder.toBuffer());
      Operation.instance =
          new WebAssembly.Instance(module, {m: {imported_mem: gPrivateMemory}});
      evalFun = Operation.exports[this.key];
    }
    evalFun(state.low, state.high, this.low_input, this.high_input);
    let ta = gPrivateMemoryView;
    if (kDebug) {
      print(
          state.high + ':' + state.low + ' ' + this.toString() + ' -> ' +
          ta[1] + ':' + ta[0]);
    }
    return {low: ta[0], high: ta[1]};
  }

  toString() {
    return opCodeNames[this.opcode] + '[+' + this.offset + '] ' +
        this.high_input + ':' + this.low_input;
  }

  get key() {
    return this.opcode + '-' + this.offset;
  }
}

class State {
  constructor(low, high, indices, count) {
    this.low = low;
    this.high = high;
    this.indices = indices;
    this.count = count;
  }

  isFinal() {
    return (this.count == kNumberOfWorker * kSequenceLength);
  }

  toString() {
    return this.high + ':' + this.low + ' @ ' + this.indices;
  }
}

function makeSequenceOfOperations(size) {
  let result = new Array(size);
  for (let i = 0; i < size; i++) {
    result[i] = new Operation();
  }
  return result;
}

function toSLeb128(low, high) {
  let result = [];
  while (true) {
    let v = low & 0x7f;
    // For low, fill up with zeros, high will add extra bits.
    low = low >>> 7;
    if (high != 0) {
      let shiftIn = high << (32 - 7);
      low = low | shiftIn;
      // For high, fill up with ones, so that we keep trailing one.
      high = high >> 7;
    }
    let msbIsSet = (v & 0x40) || false;
    if (((low == 0) && (high == 0) && !msbIsSet) ||
        ((low == -1) && (high == -1) && msbIsSet)) {
      result.push(v);
      break;
    }
    result.push(v | 0x80);
  }
  return result;
}

function generateFunctionBodyForSequence(sequence) {
  // We expect the int64* to perform ops on as arg 0 and
  // the int64* for our value log as arg1. Argument 2 gives
  // an int32* we use to count down spinning workers.
  let body = [];
  // Initially, we spin until all workers start running.
  if (!kDebug) {
    body.push(
        // Decrement the wait count.
        kExprLocalGet, 2, kExprI32Const, 1, kAtomicPrefix, kExprI32AtomicSub, 2,
        0,
        // Spin until zero.
        kExprLoop, kWasmVoid, kExprLocalGet, 2, kAtomicPrefix,
        kExprI32AtomicLoad, 2, 0, kExprI32Const, 0, kExprI32GtU, kExprBrIf, 0,
        kExprEnd);
  }
  for (let operation of sequence) {
    body.push(
        // Pre-load address of results sequence pointer for later.
        kExprLocalGet, 1,
        // Load address where atomic pointers are stored.
        kExprLocalGet, 0,
        // Load the second argument if it had any.
        ...(operation.hasInput ?
                [
                  kExprI64Const,
                  ...toSLeb128(operation.low_input, operation.high_input)
                ] :
                []),
        // Perform operation
        kAtomicPrefix, ...operation.wasmOpcode,
        // Generate fake output in needed.
        ...(operation.hasOutput ? [] : [kExprI64Const, 0]),
        // Store read intermediate to sequence.
        kExprI64StoreMem, 3, 0,
        // Increment result sequence pointer.
        kExprLocalGet, 1, kExprI32Const, 8, kExprI32Add, kExprLocalSet, 1);
  }
  // Return end of sequence index.
  body.push(kExprLocalGet, 1, kExprReturn);
  return body;
}

function getSequence(start, end) {
  return new Int32Array(
      gSharedMemory.buffer, start,
      (end - start) / Int32Array.BYTES_PER_ELEMENT);
}

function spawnWorkers() {
  let workers = [];
  for (let i = 0; i < kNumberOfWorker; i++) {
    let worker = new Worker(
        `onmessage = function({data:msg}) {
            if (msg.module) {
              let module = msg.module;
              let mem = msg.mem;
              this.instance = new WebAssembly.Instance(module, {m: {imported_mem: mem}});
              postMessage({instantiated: true});
            } else {
              let address = msg.address;
              let sequence = msg.sequence;
              let index = msg.index;
              let spin = msg.spin;
              let result = instance.exports["worker" + index](address, sequence, spin);
              postMessage({index: index, sequence: sequence, result: result});
            }
        }`,
        {type: 'string'});
    workers.push(worker);
  }
  return workers;
}

function instantiateModuleInWorkers(workers) {
  for (let worker of workers) {
    worker.postMessage({module: module, mem: gSharedMemory});
    let msg = worker.getMessage();
    if (!msg.instantiated) throw 'Worker failed to instantiate';
  }
}

function executeSequenceInWorkers(workers) {
  for (i = 0; i < workers.length; i++) {
    let worker = workers[i];
    worker.postMessage({
      index: i,
      address: 0,
      spin: 16,
      sequence: 32 + ((kSequenceLength * 8) + 32) * i
    });
    // In debug mode, keep execution sequential.
    if (kDebug) {
      let msg = worker.getMessage();
      results[msg.index] = getSequence(msg.sequence, msg.result);
    }
  }
}

function selectMatchingWorkers(state) {
  let matching = [];
  let indices = state.indices;
  for (let i = 0; i < indices.length; i++) {
    let index = indices[i];
    if (index >= kSequenceLength) continue;
    // We need to project the expected value to the number of bits this
    // operation will read at runtime.
    let [expected_low, expected_high] =
        sequences[i][index].truncateResultBits(state.low, state.high);
    let hasOutput = sequences[i][index].hasOutput;
    if (!hasOutput ||
        ((results[i][index * 2] == expected_low) &&
         (results[i][index * 2 + 1] == expected_high))) {
      matching.push(i);
    }
  }
  return matching;
}

function computeNextState(state, advanceIdx) {
  let newIndices = state.indices.slice();
  let sequence = sequences[advanceIdx];
  let operation = sequence[state.indices[advanceIdx]];
  newIndices[advanceIdx]++;
  let {low, high} = operation.compute(state);

  return new State(low, high, newIndices, state.count + 1);
}

function findSequentialOrdering() {
  let startIndices = new Array(results.length);
  let steps = 0;
  startIndices.fill(0);
  let matchingStates = [new State(0, 0, startIndices, 0)];
  while (matchingStates.length > 0) {
    let current = matchingStates.pop();
    if (kDebug) {
      print(current);
    }
    let matchingResults = selectMatchingWorkers(current);
    if (matchingResults.length == 0) {
      continue;
    }
    for (let match of matchingResults) {
      let newState = computeNextState(current, match);
      if (newState.isFinal()) {
        return true;
      }
      matchingStates.push(newState);
    }
    if (steps++ > kNumberOfSteps) {
      print('Search timed out, aborting...');
      return true;
    }
  }
  // We have no options left.
  return false;
}

// Helpful for debugging failed tests.
function loadSequencesFromStrings(inputs) {
  let reverseOpcodes = {};
  for (let i = 0; i < opCodeNames.length; i++) {
    reverseOpcodes[opCodeNames[i]] = i;
  }
  let sequences = [];
  let parseRE = /([a-zA-Z0-9]*)\[\+([0-9])\] ([\-0-9]*)/;
  for (let input of inputs) {
    let parts = input.split(',');
    let sequence = [];
    for (let part of parts) {
      let parsed = parseRE.exec(part);
      sequence.push(
          new Operation(reverseOpcodes[parsed[1]], parsed[3], parsed[2] | 0));
    }
    sequences.push(sequence);
  }
  return sequences;
}

// Helpful for debugging failed tests.
function loadResultsFromStrings(inputs) {
  let results = [];
  for (let input of inputs) {
    let parts = input.split(',');
    let result = [];
    for (let number of parts) {
      result.push(number | 0);
    }
    results.push(result);
  }
  return results;
}

let sequences = [];
let results = [];

let builder = new WasmModuleBuilder();
builder.addImportedMemory('m', 'imported_mem', 0, kMaxMemPages, 'shared');

for (let i = 0; i < kNumberOfWorker; i++) {
  sequences[i] = makeSequenceOfOperations(kSequenceLength);
  builder.addFunction('worker' + i, kSig_i_iii)
      .addBody(generateFunctionBodyForSequence(sequences[i]))
      .exportAs('worker' + i);
}

// Instantiate module, get function exports.
let module = new WebAssembly.Module(builder.toBuffer());
let instance =
    new WebAssembly.Instance(module, {m: {imported_mem: gSharedMemory}});

// Spawn off the workers and run the sequences.
let workers = spawnWorkers();
// Set spin count.
gSharedMemoryView[4] = kNumberOfWorker;
instantiateModuleInWorkers(workers);
executeSequenceInWorkers(workers);

if (!kDebug) {
  // Collect results, d8 style.
  for (let worker of workers) {
    let msg = worker.getMessage();
    results[msg.index] = getSequence(msg.sequence, msg.result);
  }
}

// Terminate all workers.
for (let worker of workers) {
  worker.terminate();
}

// In debug mode, print sequences and results.
if (kDebug) {
  for (let result of results) {
    print(result);
  }

  for (let sequence of sequences) {
    print(sequence);
  }
}

// Try to reconstruct a sequential ordering.
let passed = findSequentialOrdering();

if (passed) {
  print('PASS');
} else {
  for (let i = 0; i < kNumberOfWorker; i++) {
    print('Worker ' + i);
    print(sequences[i]);
    print(results[i]);
  }
  print('FAIL');
  quit(-1);
}
                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/wasm/bigint-i64-to-imported-js-func.js                             0000664 0000000 0000000 00000001542 14746647661 0025504 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestWasmI64ToJSBigIntImportedFunc() {
  var builder = new WasmModuleBuilder();

  var a_index = builder
    .addImport("a", "a", kSig_l_l) // i64 -> i64

  builder
    .addFunction("fn", kSig_l_v) // () -> i64
    .addBody([
      kExprI64Const, 0x7,
      kExprCallFunction, a_index
    ])
    .exportFunc();

  a_was_called = false;

  var module = builder.instantiate({
    a: {
      a(param) {
        assertEquals(typeof param, "bigint");
        assertEquals(param, 7n);
        a_was_called = true;
        return 12n;
      },
    }
  });

  assertEquals(module.exports.fn(), 12n);

  assertTrue(a_was_called);
})();
                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/wasm/bigint-opt.js                                                 0000664 0000000 0000000 00000002211 14746647661 0022072 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan --turbo-inline-js-wasm-calls

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

let builder = new WasmModuleBuilder();

builder
    .addFunction("f", kSig_v_l) // i64 -> ()
    .addBody([])
    .exportFunc();

let module = builder.instantiate();

function TestBigIntTruncatedToWord64(x) {
  return module.exports.f(x + x);
}

let bi = (2n ** (2n ** 29n + 2n ** 29n - 1n));

// Expect BigIntTooBig for adding bi to itself
assertThrows(() => TestBigIntTruncatedToWord64(bi), RangeError);

%PrepareFunctionForOptimization(TestBigIntTruncatedToWord64);
TestBigIntTruncatedToWord64(1n);
TestBigIntTruncatedToWord64(2n);
%OptimizeFunctionOnNextCall(TestBigIntTruncatedToWord64);

// After optimization, bi should be checked as BigInt and
// truncated to Word64, which is then passed to Int64Add.
// Thus no BigIntTooBig exception is expected.
TestBigIntTruncatedToWord64(bi);
assertOptimized(TestBigIntTruncatedToWord64);
                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/wasm/bigint-rematerialize.js                                       0000664 0000000 0000000 00000002072 14746647661 0024132 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan --turbo-inline-js-wasm-calls

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

let builder = new WasmModuleBuilder();

builder
    .addFunction("f", kSig_l_v) // () -> i64
    .addBody([
      kExprI64Const, 0,
      kExprI64Const, 1,
      kExprI64Sub, // -1
    ])
    .exportFunc();

let module = builder.instantiate();

function f(x) {
  let y = module.exports.f();
  try {
    return x + y;
  } catch(_) {
    return y;
  }
}

%PrepareFunctionForOptimization(f);
assertEquals(0n, f(1n));
assertEquals(1n, f(2n));
%OptimizeFunctionOnNextCall(f);
assertEquals(0n, f(1n));
assertOptimized(f);
// After optimization, the result of the js wasm call is stored in word64 and
// passed to StateValues without conversion. Rematerialization will happen
// in deoptimizer.
assertEquals(-1n, f(0));
if (%Is64Bit()) {
  assertUnoptimized(f);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/wasm/bigint.js                                                     0000664 0000000 0000000 00000010724 14746647661 0021302 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestWasmI64ToJSBigInt() {
  let builder = new WasmModuleBuilder();

  builder
    .addFunction("fn", kSig_l_v) // () -> i64
    .addBody([
      kExprI64Const, 0x3,
    ])
    .exportFunc();

  let module = builder.instantiate();

  assertEquals(typeof module.exports.fn(), "bigint");
  assertEquals(module.exports.fn(), 3n);
})();

(function TestJSBigIntToWasmI64Global() {
  let builder = new WasmModuleBuilder();

  let a_global_index = builder
    .addImportedGlobal("mod", "a", kWasmI64);

  let b_global_index = builder
    .addImportedGlobal("mod", "b", kWasmI64);

  builder
    .addExportOfKind('a', kExternalGlobal, a_global_index)
    .addExportOfKind('b', kExternalGlobal, b_global_index)

  let module = builder.instantiate({
    mod: {
      a: 1n,
      b: 2n ** 63n,
    }
  });

  assertEquals(module.exports.a.value, 1n);
  assertEquals(module.exports.b.value, - (2n ** 63n));
})();

(function TestJSBigIntGlobalImportInvalidType() {
  let builder = new WasmModuleBuilder();
  builder.addImportedGlobal("mod", "a", kWasmI64);
  assertThrows(() => builder.instantiate({mod: { a: {} } }), WebAssembly.LinkError);
})();

(function TestJSBigIntToWasmI64MutableGlobal() {
  let builder = new WasmModuleBuilder();

  let a_global_index = builder
    .addImportedGlobal("mod", "a", kWasmI64, /* mutable = */ true)

  builder
    .addExportOfKind('a', kExternalGlobal, a_global_index);

  // as non object
  let fn = () => builder.instantiate({
    mod: {
      a: 1n,
    }
  });

  assertThrows(fn, WebAssembly.LinkError);

  // as WebAssembly.Global object
  let module = builder.instantiate({
    mod: {
      a: new WebAssembly.Global({ value: "i64", mutable: true }, 1n),
    }
  });

  assertEquals(module.exports.a.value, 1n);
})();

(function TestJSBigIntToWasmI64Identity() {
  let builder = new WasmModuleBuilder();

  builder
    .addFunction("f", kSig_l_l) // i64 -> i64
    .addBody([
      kExprLocalGet, 0,
    ])
    .exportFunc();

  let module = builder.instantiate();
  let f = module.exports.f;

  assertEquals(f(0n), 0n);
  assertEquals(f(123n), 123n);
  assertEquals(f(-123n), -123n);

  assertEquals(f("5"), 5n);

  assertThrows(() => f(5), TypeError);
})();

(function TestJSBigIntToWasmI64Projection() {
  let builder = new WasmModuleBuilder();

  builder
    .addFunction("f", kSig_l_ll) // i64 -> i64
    .addBody([
      kExprLocalGet, 1,
    ])
    .exportFunc();

  let module = builder.instantiate();
  let f = module.exports.f;

  assertEquals(f(1n, 0n), 0n);
  assertEquals(f(1n, 123n), 123n);
  assertEquals(f(1n, -123n), -123n);

  assertEquals(f(1n, "5"), 5n);

  assertThrows(() => f(1n, 5), TypeError);
})();

(function TestI64Global() {
  let argument = { "value": "i64", "mutable": true };
  let global = new WebAssembly.Global(argument);

  assertEquals(global.value, 0n); // initial value

  global.value = 123n;
  assertEquals(global.valueOf(), 123n);

  global.value = 2n ** 63n;
  assertEquals(global.valueOf(), - (2n ** 63n));
})();

(function TestI64GlobalValueOf() {
  let argument = { "value": "i64" };

  // as literal
  let global = new WebAssembly.Global(argument, {
    valueOf() {
      return 123n;
    }
  });
  assertEquals(global.value, 123n);

  // as string
  let global2 = new WebAssembly.Global(argument, {
    valueOf() {
      return "321";
    }
  });
  assertEquals(global2.value, 321n);
})();

(function TestInvalidValtypeGlobalErrorMessage() {
  let argument = { "value": "some string" };
  assertThrows(() => new WebAssembly.Global(argument), TypeError);

  try {
    new WebAssembly.Global(argument);
  } catch (e) {
    assertContains("'value' must be a WebAssembly type", e.message);
  }
})();

(function TestGlobalI64ValueWrongType() {
  let argument = { "value": "i64" };
  assertThrows(() => new WebAssembly.Global(argument, 666), TypeError);
})();

(function TestGlobalI64SetWrongType() {
  let argument = { "value": "i64", "mutable": true };
  let global = new WebAssembly.Global(argument);

  assertThrows(() => global.value = 1, TypeError);
})();

(function TestFuncParamF64PassingBigInt() {
  let builder = new WasmModuleBuilder();

  builder
      .addFunction("f", kSig_v_d) // f64 -> ()
      .addBody([])
      .exportFunc();

  let module = builder.instantiate();

  assertThrows(() => module.exports.f(123n), TypeError);
})();
                                            node-23.7.0/deps/v8/test/mjsunit/wasm/bit-shift-right.js                                            0000664 0000000 0000000 00000010255 14746647661 0023031 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

let builder = new WasmModuleBuilder();
let fcts = [
  builder.addFunction('i64_shr_u_dynamic',
                      makeSig([kWasmI64, kWasmI64], [kWasmI64]))
  .exportFunc().addBody([
    kExprLocalGet, 0,
    kExprLocalGet, 1,
    kExprI64ShrU,
  ]),
  builder.addFunction('i64_shr_u_by_negative_48',
                      makeSig([kWasmI64], [kWasmI64]))
  .exportFunc().addBody([
    kExprLocalGet, 0,
    ...wasmI64Const(-48),
    kExprI64ShrU,
  ]),
  builder.addFunction('i64_shr_s_dynamic',
                      makeSig([kWasmI64, kWasmI64], [kWasmI64]))
  .exportFunc().addBody([
    kExprLocalGet, 0,
    kExprLocalGet, 1,
    kExprI64ShrS,
  ]),
  builder.addFunction('i64_shr_s_by_negative_48',
                      makeSig([kWasmI64], [kWasmI64]))
  .exportFunc().addBody([
    kExprLocalGet, 0,
    ...wasmI64Const(-48),
    kExprI64ShrS,
  ]),
  builder.addFunction('i32_shr_u_dynamic',
                      makeSig([kWasmI32, kWasmI32], [kWasmI32]))
  .exportFunc().addBody([
    kExprLocalGet, 0,
    kExprLocalGet, 1,
    kExprI32ShrU,
  ]),
  builder.addFunction('i32_shr_u_by_negative_22',
                      makeSig([kWasmI32], [kWasmI32]))
  .exportFunc().addBody([
    kExprLocalGet, 0,
    ...wasmI32Const(-22),
    kExprI32ShrU,
  ]),
  builder.addFunction('i32_shr_s_dynamic',
                      makeSig([kWasmI32, kWasmI32], [kWasmI32]))
  .exportFunc().addBody([
    kExprLocalGet, 0,
    kExprLocalGet, 1,
    kExprI32ShrS,
  ]),
  builder.addFunction('i32_shr_s_by_negative_22',
                      makeSig([kWasmI32], [kWasmI32]))
  .exportFunc().addBody([
    kExprLocalGet, 0,
    ...wasmI32Const(-22),
    kExprI32ShrS,
  ]),
];

let instance = builder.instantiate();
let wasm = instance.exports;

let testFct = () => {
  // i64.shr_u
  assertEquals(0n, wasm.i64_shr_u_dynamic(0n, 0n));
  assertEquals(1n, wasm.i64_shr_u_dynamic(3n, 1n));
  assertEquals(-1n, wasm.i64_shr_u_dynamic(-1n, 64n));
  assertEquals(-1n, wasm.i64_shr_u_dynamic(-1n, -64n));
  assertEquals(1n, wasm.i64_shr_u_dynamic(-1n, 63n));
  assertEquals(1n, wasm.i64_shr_u_dynamic(-1n, -1n));
  assertEquals(BigInt(2 ** 32 - 1), wasm.i64_shr_u_dynamic(-1n, -32n));
  assertEquals(8n, wasm.i64_shr_u_dynamic(16n, 65n));
  assertEquals(8n, wasm.i64_shr_u_dynamic(16n, -127n));

  assertEquals(0n, wasm.i64_shr_u_by_negative_48(123n));
  assertEquals(BigInt(2 ** 48 - 1), wasm.i64_shr_u_by_negative_48(-1n));
  assertEquals(4n, wasm.i64_shr_u_by_negative_48(BigInt(2 ** 18)))

  // i64.shr_s
  assertEquals(0n, wasm.i64_shr_s_dynamic(0n, 0n));
  assertEquals(1n, wasm.i64_shr_s_dynamic(3n, 1n));
  assertEquals(-1n, wasm.i64_shr_s_dynamic(-1n, 64n));
  assertEquals(-1n, wasm.i64_shr_s_dynamic(-1n, -64n));
  assertEquals(-1n, wasm.i64_shr_s_dynamic(-8n, 63n));
  assertEquals(-4n, wasm.i64_shr_s_dynamic(-8n, -63n));
  assertEquals(-1n, wasm.i64_shr_s_dynamic(-16n, -2n));

  assertEquals(0n, wasm.i64_shr_s_by_negative_48(123n));
  assertEquals(-BigInt(2 ** 16),
      wasm.i64_shr_s_by_negative_48(-BigInt(2 ** 32)));

  // i32.shr_u
  assertEquals(0, wasm.i32_shr_u_dynamic(0, 0));
  assertEquals(1, wasm.i32_shr_u_dynamic(3, 1));
  assertEquals(-1, wasm.i32_shr_u_dynamic(-1, 32));
  assertEquals(-1, wasm.i32_shr_u_dynamic(-1, -32));
  assertEquals((1 << 17) - 1, wasm.i32_shr_u_dynamic(-1, 15));

  assertEquals(123, wasm.i32_shr_u_by_negative_22((123 << 10) + 456));
  assertEquals((1 << 22) - 123, wasm.i32_shr_u_by_negative_22(-123 << 10));

  // i32.shr_s
  assertEquals(0, wasm.i32_shr_s_dynamic(0, 0));
  assertEquals(1, wasm.i32_shr_s_dynamic(3, 1));
  assertEquals(-1, wasm.i32_shr_s_dynamic(-1, 32));
  assertEquals(-1, wasm.i32_shr_s_dynamic(-1, -32));
  assertEquals(-123, wasm.i32_shr_s_dynamic(-123 << 15, 15));

  assertEquals(123, wasm.i32_shr_s_by_negative_22((123 << 10) + 456));
  assertEquals(-123, wasm.i32_shr_s_by_negative_22((-123 << 10) + 456));
};

for (let i = 0; i < 20; i++) testFct();
for (let fct of fcts) {
  %WasmTierUpFunction(wasm[fct.name]);
}
testFct();
                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/wasm/bounds-check-64bit.js                                         0000664 0000000 0000000 00000002055 14746647661 0023317 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

const builder = new WasmModuleBuilder();
builder.addMemory(1, undefined);
builder.addFunction('load', kSig_i_ii)
    .addBody([
        kExprLocalGet, 0,
        kExprI64SConvertI32,
        kExprLocalGet, 1,
        kExprI64SConvertI32,
        kExprI64Shl,
        kExprI32ConvertI64,
    kExprI32LoadMem, 0, 0])
    .exportFunc();

const module = builder.instantiate();
let start = 12;
let address = start;
for (i = 0; i < 64; i++) {
  // This is the address which will be accessed in the code. We cannot use
  // shifts to calculate the address because JS shifts work on 32-bit integers.
  print(`address=${address}`);
  if (address < kPageSize) {
    assertEquals(0, module.exports.load(start, i));
  } else {
    assertTraps(kTrapMemOutOfBounds, _ => { module.exports.load(start, i);});
  }
  address = (address * 2) % 4294967296;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/wasm/bounds-check-turbofan.js                                      0000664 0000000 0000000 00000001412 14746647661 0024203 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

const builder = new WasmModuleBuilder();
builder.addMemory(1, undefined);
builder.addFunction('load', kSig_i_i)
    .addBody([
        kExprLocalGet, 0,
    kExprI32LoadMem, 0, 100])
    .exportFunc();

const load = builder.instantiate().exports.load;
%WasmTierUpFunction(load);
// 100 is added as part of the load instruction above
// Last valid address (64k - 100 - 4)
assertEquals(0, load(0x10000 - 100 - 4));
// First invalid address (64k - 100)
assertTraps(kTrapMemOutOfBounds, _ => { load(0x10000 - 100);});
                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/wasm/br-table-no-stack-rewrite.js                                  0000664 0000000 0000000 00000002202 14746647661 0024702 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

// Test that we don't rewrite the stack types when iterating over the targets
// for a br_table instrunction.
(function BrTable() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let funcT = builder.addType(makeSig([], []));
  let table = builder.addTable(
    wasmRefNullType(funcT), 1, 1, [kExprRefNull, funcT]);
  let returnsFuncT = builder.addType(makeSig([], [wasmRefNullType(funcT)]));
  let returnsFuncRef = builder.addType(makeSig([], [kWasmFuncRef]));
  builder.addFunction("br_table", makeSig([kWasmI32], [kWasmFuncRef]))
    .addBody([
      kExprBlock, returnsFuncRef,
        kExprBlock, returnsFuncT,
          kExprI32Const, 0,
          kExprTableGet, table.index,
          kExprLocalGet, 0,
          kExprBrTable, 2, 1, 1, 0,
        kExprEnd,
      kExprEnd,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(null, wasm.br_table(0));
})();
                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/wasm/bulk-memory.js                                                0000664 0000000 0000000 00000017721 14746647661 0022275 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function TestPassiveDataSegment() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.addMemory(1, 1);
  builder.addPassiveDataSegment([0, 1, 2]);
  builder.addPassiveDataSegment([3, 4]);

  // Should not throw.
  builder.instantiate();
})();

(function TestPassiveElementSegment() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.addFunction('f', kSig_v_v).addBody([]);
  builder.setTableBounds(1, 1);
  builder.addPassiveElementSegment([0, 0, 0]);
  builder.addPassiveElementSegment([0, 0]);

  // Should not throw.
  builder.instantiate();
})();

function getMemoryInit(mem, segment_data) {
  const builder = new WasmModuleBuilder();
  builder.addImportedMemory('', 'mem', 0);
  builder.addPassiveDataSegment(segment_data);
  builder.addFunction('init', kSig_v_iii)
      .addBody([
        kExprLocalGet, 0,  // Dest.
        kExprLocalGet, 1,  // Source.
        kExprLocalGet, 2,  // Size in bytes.
        kNumericPrefix, kExprMemoryInit,
        0,  // Data segment index.
        0,  // Memory index.
      ])
      .exportAs('init');
  return builder.instantiate({'': {mem}}).exports.init;
}

(function TestMemoryInitOutOfBoundsGrow() {
  print(arguments.callee.name);
  const mem = new WebAssembly.Memory({initial: 1});
  // Create a data segment that has a length of kPageSize.
  const memoryInit = getMemoryInit(mem, new Array(kPageSize));

  mem.grow(1);

  // Works properly after grow.
  memoryInit(kPageSize, 0, 1000);

  // Traps at new boundary.
  assertTraps(
      kTrapMemOutOfBounds, () => memoryInit(kPageSize + 1, 0, kPageSize));
})();

(function TestMemoryInitOnActiveSegment() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.addMemory(1);
  builder.addPassiveDataSegment([1, 2, 3]);
  builder.addActiveDataSegment(0, [kExprI32Const, 0], [4, 5, 6]);
  builder.addFunction('init', kSig_v_i)
      .addBody([
        kExprI32Const, 0,  // Dest.
        kExprI32Const, 0,  // Source.
        kExprLocalGet, 0,  // Size in bytes.
        kNumericPrefix, kExprMemoryInit,
        1,  // Data segment index.
        0,  // Memory index.
      ])
      .exportAs('init');

  // Instantiation succeeds, because using memory.init with an active segment
  // is a trap, not a validation error.
  const instance = builder.instantiate();

  // Initialization succeeds, because source address and size are 0
  // which is valid on a dropped segment.
  instance.exports.init(0);

  // Initialization fails, because the segment is implicitly dropped.
  assertTraps(kTrapMemOutOfBounds, () => instance.exports.init(1));
})();

(function TestDataDropOnActiveSegment() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.addMemory(1);
  builder.addPassiveDataSegment([1, 2, 3]);
  builder.addActiveDataSegment(0, [kExprI32Const, 0], [4, 5, 6]);
  builder.addFunction('drop', kSig_v_v)
      .addBody([
        kNumericPrefix, kExprDataDrop,
        1,  // Data segment index.
      ])
      .exportAs('drop');

  const instance = builder.instantiate();
  // Drop on passive segment is equivalent to double drop which is allowed.
  instance.exports.drop();
})();

function getMemoryCopy(mem) {
  const builder = new WasmModuleBuilder();
  builder.addImportedMemory("", "mem", 0);
  builder.addFunction("copy", kSig_v_iii).addBody([
    kExprLocalGet, 0,  // Dest.
    kExprLocalGet, 1,  // Source.
    kExprLocalGet, 2,  // Size in bytes.
    kNumericPrefix, kExprMemoryCopy, 0, 0,
  ]).exportAs("copy");
  return builder.instantiate({'': {mem}}).exports.copy;
}

(function TestMemoryCopyOutOfBoundsGrow() {
  print(arguments.callee.name);
  const mem = new WebAssembly.Memory({initial: 1});
  const memoryCopy = getMemoryCopy(mem);

  mem.grow(1);

  // Works properly after grow.
  memoryCopy(0, kPageSize, 1000);

  // Traps at new boundary.
  assertTraps(
      kTrapMemOutOfBounds, () => memoryCopy(0, kPageSize + 1, kPageSize));
})();

function getMemoryFill(mem) {
  const builder = new WasmModuleBuilder();
  builder.addImportedMemory("", "mem", 0);
  builder.addFunction("fill", kSig_v_iii).addBody([
    kExprLocalGet, 0,  // Dest.
    kExprLocalGet, 1,  // Byte value.
    kExprLocalGet, 2,  // Size.
    kNumericPrefix, kExprMemoryFill, 0,
  ]).exportAs("fill");
  return builder.instantiate({'': {mem}}).exports.fill;
}

(function TestMemoryFillOutOfBoundsGrow() {
  print(arguments.callee.name);
  const mem = new WebAssembly.Memory({initial: 1});
  const memoryFill = getMemoryFill(mem);
  const v = 123;

  mem.grow(1);

  // Works properly after grow.
  memoryFill(kPageSize, v, 1000);

  // Traps at new boundary.
  assertTraps(
      kTrapMemOutOfBounds, () => memoryFill(kPageSize + 1, v, kPageSize));
})();

(function TestElemDropActive() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.setTableBounds(5, 5);
  builder.addActiveElementSegment(0, wasmI32Const(0), [0, 0, 0]);
  builder.addFunction('drop', kSig_v_v)
      .addBody([
        kNumericPrefix, kExprElemDrop,
        0,  // Element segment index.
      ])
      .exportAs('drop');

  const instance = builder.instantiate();
  // Segment already got dropped after initialization and is therefore
  // not active anymore.
  instance.exports.drop();
})();

(function TestLazyDataSegmentBoundsCheck() {
  print(arguments.callee.name);
  const memory = new WebAssembly.Memory({initial: 1});
  const view = new Uint8Array(memory.buffer);
  const builder = new WasmModuleBuilder();
  builder.addImportedMemory('m', 'memory', 1);
  builder.addActiveDataSegment(0, wasmI32Const(kPageSize - 1), [42, 42]);
  builder.addActiveDataSegment(0, [kExprI32Const, 0], [111, 111]);

  assertEquals(0, view[kPageSize - 1]);

  // Instantiation fails, memory remains unmodified.
  assertThrows(
      () => builder.instantiate({m: {memory}}), WebAssembly.RuntimeError);

  assertEquals(0, view[kPageSize - 1]);
  // The second segment is not initialized.
  assertEquals(0, view[0]);
})();

(function TestLazyDataAndElementSegments() {
  print(arguments.callee.name);
  const table = new WebAssembly.Table({initial: 1, element: 'anyfunc'});
  const memory = new WebAssembly.Memory({initial: 1});
  const view = new Uint8Array(memory.buffer);
  const builder = new WasmModuleBuilder();

  builder.addImportedMemory('m', 'memory', 1);
  builder.addImportedTable('m', 'table', 1);
  const f = builder.addFunction('f', kSig_i_v).addBody([kExprI32Const, 42]);

  const tableIndex = 0;
  builder.addActiveElementSegment(
      tableIndex,
      wasmI32Const(0),
      [f.index, f.index]);
  builder.addActiveDataSegment(0, [kExprI32Const, 0], [42]);

  // Instantiation fails, but still modifies the table. The memory is not
  // modified, since data segments are initialized after element segments.
  assertThrows(
      () => builder.instantiate({m: {memory, table}}),
      WebAssembly.RuntimeError);

  assertEquals(0, view[0]);
})();

(function TestPassiveDataSegmentNoMemory() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.addPassiveDataSegment([0, 1, 2]);

  // Should not throw.
  builder.instantiate();
})();

(function TestPassiveElementSegmentNoMemory() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.addFunction('f', kSig_v_v).addBody([]);
  builder.addPassiveElementSegment([0, 0, 0]);

  // Should not throw.
  builder.instantiate();
})();

(function TestIllegalNumericOpcode() {
  // Regression test for https://crbug.com/1382816.
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction('main', kSig_v_v).addBody([kNumericPrefix, 0x90, 0x0f]);
  assertEquals(false, WebAssembly.validate(builder.toBuffer()));
  assertThrows(
      () => builder.toModule(), WebAssembly.CompileError,
      /invalid numeric opcode: 0xfc790/);
})();
                                               node-23.7.0/deps/v8/test/mjsunit/wasm/call-ref.js                                                   0000664 0000000 0000000 00000017061 14746647661 0021514 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-type-reflection

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestImportedRefCall() {
  print(arguments.callee.name);
  var exporting_instance = (function () {
    var builder = new WasmModuleBuilder();

    builder.addFunction("addition", kSig_i_ii)
      .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
      .exportFunc();

    return builder.instantiate({});
  })();

  var instance = (function () {
    var builder = new WasmModuleBuilder();

    var sig_index = builder.addType(kSig_i_ii);

    var imported_js_api_function_index =
      builder.addImport("imports", "js_api_mul", sig_index);

    var imported_js_function_index =
      builder.addImport("imports", "js_add", sig_index);

    var imported_wasm_function_index =
      builder.addImport("imports", "wasm_add", sig_index);

    var locally_defined_function =
      builder.addFunction("sub", sig_index)
        .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Sub])
        .exportFunc();

    builder.addFunction("main", makeSig(
      [wasmRefType(sig_index), kWasmI32, kWasmI32], [kWasmI32]))
      .addBody([kExprLocalGet, 1, kExprLocalGet, 2, kExprLocalGet, 0,
                kExprCallRef, sig_index])
      .exportFunc();

    builder.addFunction("test_local", kSig_i_v)
      .addBody([kExprI32Const, 55, kExprI32Const, 42,
                kExprRefFunc, locally_defined_function.index,
                kExprCallRef, sig_index])
      .exportFunc();

    builder.addFunction("test_js_import", kSig_i_v)
      .addBody([kExprI32Const, 15, kExprI32Const, 42,
                kExprRefFunc, imported_js_function_index,
                kExprCallRef, sig_index])
      .exportFunc();

    builder.addFunction("test_wasm_import", kSig_i_v)
      .addBody([kExprI32Const, 15, kExprI32Const, 42,
                kExprRefFunc, imported_wasm_function_index,
                kExprCallRef, sig_index])
      .exportFunc();

    builder.addFunction("test_js_api_import", kSig_i_v)
      .addBody([kExprI32Const, 3, kExprI32Const, 7,
                kExprRefFunc, imported_js_api_function_index,
                kExprCallRef, sig_index])
      .exportFunc();

    builder.addExport("reexported_js_function", imported_js_function_index);

    // Just to make these functions eligible for call_ref.
    builder.addDeclarativeElementSegment([imported_wasm_function_index,
                                          imported_js_api_function_index]);

    return builder.instantiate({imports: {
      js_add: function(a, b) { return a + b; },
      wasm_add: exporting_instance.exports.addition,
      js_api_mul: new WebAssembly.Function(
          {parameters:['i32', 'i32'], results: ['i32']},
          function(a, b) { return a * b; })
    }});
  })();

  // Check that the modules exist.
  assertTrue(!!exporting_instance);
  assertTrue(!!instance);

  print("--locally defined func--");
  assertEquals(13, instance.exports.test_local());
  print("--locally defined exported func--")
  assertEquals(5, instance.exports.main(instance.exports.sub, 12, 7));

  print("--imported js func--");
  assertEquals(57, instance.exports.test_js_import());
  print("--imported and reexported js func--")
  assertEquals(19, instance.exports.main(
    instance.exports.reexported_js_function, 12, 7));

  print("--imported function from another module--");
  assertEquals(57, instance.exports.test_wasm_import());
  print("--not imported function defined in another module--");
  assertEquals(19, instance.exports.main(
    exporting_instance.exports.addition, 12, 7));

  print("--imported WebAssembly.Function--")
  assertEquals(21, instance.exports.test_js_api_import());
  print("--not imported WebAssembly.Function--")
  assertEquals(-5, instance.exports.main(
    new WebAssembly.Function(
      {parameters:['i32', 'i32'], results: ['i32']},
      function(a, b) { return a - b; }),
    10, 15));
  print("--not imported WebAssembly.Function, arity mismatch--")
  assertEquals(100, instance.exports.main(
    new WebAssembly.Function(
      {parameters:['i32', 'i32'], results: ['i32']},
      function(a) { return a * a; }),
    10, 15));
})();

(function TestFromJSSlowPath() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  var sig_index = builder.addType(kSig_i_i);

  builder.addFunction("main", makeSig(
      [wasmRefType(sig_index), kWasmI32], [kWasmI32]))
      .addBody([kExprLocalGet, 1, kExprLocalGet, 0, kExprCallRef, sig_index])
      .exportFunc();

  var instance = builder.instantiate({});

  var fun = new WebAssembly.Function(
      { parameters: ['i32'], results: ['i32'] }, (a) => undefined);
  // {undefined} is converted to 0.
  assertEquals(0, instance.exports.main(fun, 1000));
})();

(function TestImportedFunctionSubtyping() {
  print(arguments.callee.name);
  var exporting_instance = (function () {
    var builder = new WasmModuleBuilder();
    let super_struct = builder.addStruct([makeField(kWasmI32, true)]);
    let sub_struct = builder.addStruct(
      [makeField(kWasmI32, true), makeField(kWasmI64, true)], super_struct);
    let super_sig = builder.addType(makeSig([wasmRefNullType(sub_struct)],
                                            [kWasmI32]), kNoSuperType, false)
    let sub_sig = builder.addType(makeSig([wasmRefNullType(super_struct)],
                                          [kWasmI32]), super_sig)

    builder.addFunction("exported_function", sub_sig)
      .addBody([kExprLocalGet, 0, kGCPrefix, kExprStructGet, super_struct, 0])
      .exportFunc();

    return builder.instantiate({});
  })();

  var builder = new WasmModuleBuilder();
  // These should canonicalize to the same types as the exporting instance.
  let super_struct = builder.addStruct([makeField(kWasmI32, true)]);
  let sub_struct = builder.addStruct(
    [makeField(kWasmI32, true), makeField(kWasmI64, true)], super_struct);
  let super_sig = builder.addType(
    makeSig([wasmRefNullType(sub_struct)], [kWasmI32]), kNoSuperType, false);
  builder.addImport("m", "f", super_sig);

  // Import is a function of the declared type.
  return builder.instantiate({m: {f:
      exporting_instance.exports.exported_function}});
})();

(function TestJSFunctionCanonicallyDifferent() {
  print(arguments.callee.name);

  let imp = new WebAssembly.Function({parameters: ["i32"], results: ["i32"]},
                                     x => x + 1);

  (function () {
    var builder = new WasmModuleBuilder();
    let sig = builder.addType(kSig_i_i);

    builder.addImport("m", "f", sig);

    // This succeeds
    builder.instantiate({m: {f: imp}});
  })();

  (function () {
    var builder = new WasmModuleBuilder();
    let sig = builder.addType(kSig_i_i, kNoSuperType, false);
    let sig_sub = builder.addType(kSig_i_i, sig);

    builder.addImport("m", "f", sig_sub);

    // Import is a function of the declared type.
    assertThrows(() => builder.instantiate({m: {f: imp}}),
                 WebAssembly.LinkError,
                 /imported function does not match the expected type/);
  })();

  (function () {
    var builder = new WasmModuleBuilder();
    builder.startRecGroup();
    let sig_in_group = builder.addType(kSig_i_i);
    builder.addType(kSig_i_v);
    builder.endRecGroup();

    builder.addImport("m", "f", sig_in_group);

    // Import is a function of the declared type.
    assertThrows(() => builder.instantiate({m: {f: imp}}),
                 WebAssembly.LinkError,
                 /imported function does not match the expected type/);
  })();
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/wasm/call_indirect.js                                              0000664 0000000 0000000 00000015411 14746647661 0022620 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function TestCallIndirectJSFunction() {
  print(arguments.callee.name);
  let js_function = function(a, b, c) { return c ? a : b; };

  let test = function(is_tail_call) {
    const builder = new WasmModuleBuilder();

    builder.addType(kSig_i_i);
    let sig = builder.addType(kSig_i_iii);

    let callee = builder.addImport("m", "f", kSig_i_iii);

    let table = builder.addTable(kWasmFuncRef, 10, 10);

    builder.addActiveElementSegment(table.index, wasmI32Const(0), [callee]);

    let left = -2;
    let right = 3;

    builder.addFunction("main", kSig_i_i)
      .addBody([...wasmI32Const(left), ...wasmI32Const(right), kExprLocalGet, 0,
                ...wasmI32Const(0),
                is_tail_call ? kExprReturnCallIndirect : kExprCallIndirect,
                sig, table.index])
      .exportFunc();

    let instance = builder.instantiate({m: {f: js_function}});

    assertEquals(left, instance.exports.main(1));
    assertEquals(right, instance.exports.main(0));
  }

  test(true);
  test(false);
})();

(function TestCallIndirectIsorecursiveTypeCanonicalization() {
  print(arguments.callee.name);

  let exporting_instance = (function() {
    const builder = new WasmModuleBuilder();

    let struct_mistyped = builder.addStruct([]);

    let struct = builder.addStruct([makeField(kWasmI32, true)]);

    let sig_mistyped = builder.addType(
        makeSig([wasmRefNullType(struct_mistyped)], [kWasmI32]));
    let sig = builder.addType(makeSig([wasmRefNullType(struct)], [kWasmI32]));

    builder.addFunction("export", sig)
      .addBody([kExprLocalGet, 0, kGCPrefix, kExprStructGet, struct, 0,
                ...wasmI32Const(0), kExprI32GeS])
      .exportFunc();

    builder.addFunction("export_mistyped", sig_mistyped)
      .addBody([...wasmI32Const(0)])
      .exportFunc();

    return builder.instantiate();
  })();

  const builder = new WasmModuleBuilder();

  // Have these in the reverse order than before.
  let struct = builder.addStruct([makeField(kWasmI32, true)]);
  let struct_mistyped = builder.addStruct([]);

  let sig = builder.addType(makeSig([wasmRefNullType(struct)], [kWasmI32]));
  let sig_identical = builder.addType(
      makeSig([wasmRefNullType(struct)], [kWasmI32]));
  let sig_mistyped = builder.addType(
      makeSig([wasmRefNullType(struct_mistyped)], [kWasmI32]));

  let imported = builder.addImport("m", "imp", sig);
  let imported_mistyped = builder.addImport("m", "imp_m", sig_mistyped);

  let local1 = builder.addFunction("local1", sig)
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprStructGet, struct, 0,
              ...wasmI32Const(0), kExprI32LtS])
    .index;

  let local2 = builder.addFunction("local2", sig_identical)
      .addBody([kExprLocalGet, 0, kGCPrefix, kExprStructGet, struct, 0,
                ...wasmI32Const(0), kExprI32Eq])
      .index;

  let mistyped = builder.addFunction("mistyped", kSig_i_i)
    .addBody([kExprLocalGet, 0])
    .index;

  let table_size = 10;
  let table = builder.addTable(kWasmFuncRef, table_size, table_size);

  builder.addActiveElementSegment(
    table.index, wasmI32Const(0),
    [[kExprRefFunc, imported], [kExprRefFunc, imported_mistyped],
     [kExprRefFunc, local1], [kExprRefFunc, local2], [kExprRefFunc, mistyped]],
    table.type);

  // Params: Struct field, table index
  builder.addFunction("main", kSig_i_ii)
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprStructNew, struct,
              kExprLocalGet, 1, kExprCallIndirect, sig, table.index])
    .exportFunc();

  let importing_instance =
    builder.instantiate(
      {m: {imp: exporting_instance.exports.export,
           imp_m: exporting_instance.exports.export_mistyped}});

  assertEquals(1, importing_instance.exports.main(10, imported))
  assertEquals(0, importing_instance.exports.main(-5, imported))
  assertEquals(0, importing_instance.exports.main(10, local1))
  assertEquals(1, importing_instance.exports.main(-5, local1))
  assertEquals(0, importing_instance.exports.main(10, local2))
  assertEquals(1, importing_instance.exports.main(0, local2))
  // Mistyped entries
  assertTraps(kTrapFuncSigMismatch,
              () => importing_instance.exports.main(10, mistyped));
  assertTraps(kTrapFuncSigMismatch,
              () => importing_instance.exports.main(10, imported_mistyped));
  // Null entry
  assertTraps(kTrapFuncSigMismatch,
              () => importing_instance.exports.main(10, table_size - 1));
  assertTraps(kTrapTableOutOfBounds,
              () => importing_instance.exports.main(10, table_size));
})();

(function TestSubtyping() {
  print(arguments.callee.name);

  // This test is the same as https://github.com/WebAssembly/gc/pull/526,
  // rewritten in WasmModuleBuilder syntax.

  const builder = new WasmModuleBuilder();

  let t1 = builder.addType(kSig_v_v, kNoSuperType, false);
  let t2 = builder.addType(kSig_v_v, t1, false);
  let t3 = builder.addType(kSig_v_v, t2, false);
  let t4 = builder.addType(kSig_v_v, kNoSuperType, true);

  let f2 = builder.addFunction('f2', t2).addBody([]);
  let f3 = builder.addFunction('f3', t3).addBody([]);
  let tab0 = builder.addTable(wasmRefNullType(t2), 2).index;
  builder.addActiveElementSegment(
      tab0, wasmI32Const(0),
      [[kExprRefFunc, f2.index], [kExprRefFunc, f3.index]], wasmRefType(t2));

  builder.addFunction('run', kSig_v_v).exportFunc().addBody([
    // The immediate type being a supertype of the table type (and hence
    // also of the table elements) is okay.
    kExprI32Const, 0,
    kExprCallIndirect, t1, tab0,
    kExprI32Const, 1,
    kExprCallIndirect, t1, tab0,
    // The immediate type being equal to the type of the table and its
    // elements is okay.
    kExprI32Const, 0,
    kExprCallIndirect, t2, tab0,
    kExprI32Const, 1,
    kExprCallIndirect, t2, tab0,
    // The immediate type being a subtype of the table type is okay,
    // as long as the requested element matches that subtype.
    kExprI32Const, 1,
    kExprCallIndirect, t3, tab0,
  ]);

  builder.addFunction('fail1', kSig_v_v).exportFunc().addBody([
    // The immediate type is a subtype of the table type here, but the
    // retrieved element can't be downcast to it.
    kExprI32Const, 0,
    kExprCallIndirect, t3, tab0,
  ]);
  builder.addFunction('fail2', kSig_v_v).exportFunc().addBody([
    // The immediate type is entirely unrelated to the table type here.
    // This validates, but traps at runtime.
    kExprI32Const, 0,
    kExprCallIndirect, t4, tab0,
  ]);

  let instance = builder.instantiate();
  instance.exports.run();  // Does not trap.
  assertTraps(kTrapFuncSigMismatch, () => instance.exports.fail1());
  assertTraps(kTrapFuncSigMismatch, () => instance.exports.fail2());
})();
                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/wasm/calls.js                                                      0000664 0000000 0000000 00000005577 14746647661 0021136 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function assertModule(module, memsize) {
  // Check the module exists.
  assertFalse(module === undefined);
  assertFalse(module === null);
  assertFalse(module === 0);
  assertEquals("object", typeof module);

  // Check the memory is an ArrayBuffer.
  var mem = module.exports.memory;
  assertFalse(mem === undefined);
  assertFalse(mem === null);
  assertFalse(mem === 0);
  assertEquals("object", typeof mem);
  assertTrue(mem instanceof WebAssembly.Memory);
  var buf = mem.buffer;
  assertTrue(buf instanceof ArrayBuffer);
  assertEquals(memsize, buf.byteLength);
  for (var i = 0; i < 4; i++) {
    module.exports.memory = 0;  // should be ignored
    mem.buffer = 0; // should be ignored
    assertSame(mem, module.exports.memory);
    assertSame(buf, mem.buffer);
  }
}

function assertFunction(module, func) {
  assertEquals("object", typeof module.exports);

  var exp = module.exports[func];
  assertFalse(exp === undefined);
  assertFalse(exp === null);
  assertFalse(exp === 0);
  assertEquals("function", typeof exp);
  return exp;
}

(function SubTest() {

  var builder = new WasmModuleBuilder();

  builder.addMemory(1, 1);
  builder.exportMemoryAs("memory");
  builder.addFunction("sub", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,             // --
      kExprLocalGet, 1,             // --
      kExprI32Sub,                  // --
    ])
    .exportFunc()

  var module = builder.instantiate();
  assertModule(module, kPageSize);

  // Check the properties of the sub function.
  var sub = assertFunction(module, "sub");
  assertEquals(-55, sub(33, 88));
  assertEquals(-55555, sub(33333, 88888));
  assertEquals(-5555555, sub(3333333, 8888888));
})();


(function NopTest() {

  var builder = new WasmModuleBuilder();

  var kPages = 2;
  builder.addMemory(kPages, kPages);
  builder.exportMemoryAs("memory");
  builder.addFunction("nop", kSig_v_v)
    .addBody([kExprNop])
    .exportFunc();

  var module = builder.instantiate();
  assertModule(module, kPageSize * kPages);

  var nop = assertFunction(module, "nop");
  assertEquals(undefined, nop());
})();


(function testLt() {
  var builder = new WasmModuleBuilder();

  var kPages = 3;
  builder.addMemory(kPages, kPages);
  builder.exportMemoryAs("memory");
  builder.addFunction("flt", kSig_i_dd)
    .addBody([
      kExprLocalGet, 0,     // --
      kExprLocalGet, 1,     // --
      kExprF64Lt            // --
    ])                      // --
    .exportFunc();

  var module = builder.instantiate();
  assertModule(module, kPageSize * kPages);

  var flt = assertFunction(module, "flt");
  assertEquals(1, flt(-2, -1));
  assertEquals(0, flt(7.3, 7.1));
  assertEquals(1, flt(7.1, 7.3));
})();
                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/wasm/code-flushing-single-isolate.js                               0000664 0000000 0000000 00000002356 14746647661 0025474 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --allow-natives-syntax --wasm-lazy-compilation

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

const builder = new WasmModuleBuilder();
builder.addFunction('f1', kSig_i_i).addBody([kExprLocalGet, 0]).exportFunc();
builder.addFunction('f2', kSig_i_i).addBody([kExprLocalGet, 0]).exportFunc();
builder.addFunction('f3', kSig_i_i).addBody([kExprLocalGet, 0]).exportFunc();

const exports = builder.instantiate().exports;

exports.f1(1);
exports.f2(2);
exports.f3(3);

assertTrue(%IsLiftoffFunction(exports.f1));
assertTrue(%IsLiftoffFunction(exports.f2));
assertTrue(%IsLiftoffFunction(exports.f3));

assertTrue(%FlushLiftoffCode() > 0);

assertTrue(%IsUncompiledWasmFunction(exports.f1));
assertTrue(%IsUncompiledWasmFunction(exports.f2));
assertTrue(%IsUncompiledWasmFunction(exports.f3));

exports.f1(1);
exports.f2(2);
exports.f3(3);

%WasmTierUpFunction(exports.f3);

assertTrue(%FlushLiftoffCode() > 0);

assertTrue(%IsUncompiledWasmFunction(exports.f1));
assertTrue(%IsUncompiledWasmFunction(exports.f2));
assertTrue(%IsTurboFanFunction(exports.f3));
                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/wasm/code-flushing.js                                              0000664 0000000 0000000 00000001511 14746647661 0022547 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --allow-natives-syntax --wasm-lazy-compilation

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

const builder = new WasmModuleBuilder();
builder.addFunction('f1', kSig_i_i).addBody([kExprLocalGet, 0]).exportFunc();
builder.addFunction('f2', kSig_i_i).addBody([kExprLocalGet, 0]).exportFunc();
builder.addFunction('f3', kSig_i_i).addBody([kExprLocalGet, 0]).exportFunc();

const exports = builder.instantiate().exports;

exports.f1(1);
exports.f2(2);
exports.f3(3);

%FlushLiftoffCode();

exports.f1(1);
exports.f2(2);
exports.f3(3);

%WasmTierUpFunction(exports.f3);

%FlushLiftoffCode();

exports.f1(1);
exports.f2(2);
exports.f3(3);
                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/wasm/code-space-overflow.js                                        0000664 0000000 0000000 00000003453 14746647661 0023673 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-max-code-space-size-mb=1
// Disable lazy compilation, so we actually generate a lot of code at once.
// Flags: --no-wasm-lazy-compilation
// Limit the number of background threads, so each thread generates more code.
// Flags: --wasm-num-compilation-tasks=2

// This is a regression test for https://crbug.com/v8/13436. If a single
// background thread generates more code than fits in a single code space, we
// need to split it into multiple code spaces.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

const start = performance.now();
function time(name) {
  const ms_since_start = (performance.now() - start).toFixed(1).padStart(7);
  print(`[${ms_since_start}] ${name}`);
}

// At the time of writing this test (Nov 2022), this module generated ~20MB of
// code on x64 and ~18MB on arm64.
const builder = new WasmModuleBuilder();
const kNumFunctions = 1500;
// Build a large body. Then append one instruction to get different code per
// function (for the case that we decide to merge identical code objects in the
// future).
time('Build function template.');
let body_template = [kExprLocalGet, 0];
for (let i = 0; i < kNumFunctions; ++i) {
  body_template.push(kExprCallFunction, ...wasmSignedLeb(i));
}
time(`Adding ${kNumFunctions} functions`);
for (let i = 0; i < kNumFunctions; ++i) {
  if (i != 0 && i % 100 == 0) time(`... added ${i} functions`);
  let body = body_template.concat([...wasmI32Const(i), kExprI32Add, kExprEnd]);
  builder.addFunction('f' + i, kSig_i_i).addBodyWithEnd(body);
}
time('Building buffer.');
const wasm_buf = builder.toBuffer();
time('Compiling Wasm module.');
new WebAssembly.Module(wasm_buf);
                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/wasm/committed-code-exhaustion.js                                  0000664 0000000 0000000 00000001172 14746647661 0025105 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-max-committed-code-mb=1

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

// We only have 1 MB code space. This is enough for the code below, but for all
// 1000 modules, it requires several GCs to get rid of the old code.
const builder = new WasmModuleBuilder();
builder.addFunction('main', kSig_i_i).addBody([kExprLocalGet, 0]);
const buffer = builder.toBuffer();

for (let i = 0; i < 1000; ++i) {
  new WebAssembly.Module(buffer);
}
                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/wasm/compare-exchange-stress.js                                    0000664 0000000 0000000 00000016721 14746647661 0024560 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

const kSequenceLength = 8192;
const kNumberOfWorkers = 4;
const kBitMask = kNumberOfWorkers - 1;
const kMemoryAddress = 0;
const kSequenceStartAddress = 32;

function makeWorkerCodeForOpcode(compareExchangeOpcode, size, functionName,
    builder) {
    let loadMemOpcode = kTrapUnreachable;
    let alignLog2;
    switch (size) {
        case 32:
            loadMemOpcode = kExprI32LoadMem;
            alignLog2 = 2;
            break;
        case 16:
            loadMemOpcode = kExprI32LoadMem16U;
            alignLog2 = 1;
            break;
        case 8:
            loadMemOpcode = kExprI32LoadMem8U;
            alignLog2 = 0;
            break;
        default:
            throw "!";
    }
    const kArgMemoryCell = 0; // target for atomic ops
    const kArgSequencePtr = 1; // address of sequence
    const kArgSeqenceLength = 2; // lenght of sequence
    const kArgWorkerId = 3; // id of this worker
    const kArgBitMask = 4; // mask to extract worker id from value
    const kLocalCurrentOffset = 5; // current position in sequence in bytes
    const kLocalExpectedValue = 6; // the value we are waiting for
    const kLocalNextValue = 7; // the value to write in the update
    let body = [
        // Turn sequence length to equivalent in bytes.
        kExprLocalGet, kArgSeqenceLength,
        kExprI32Const, size / 8,
        kExprI32Mul,
        kExprLocalSet, kArgSeqenceLength,
        // Outer block so we have something to jump for return.
        ...[kExprBlock, kWasmVoid,
            // Set counter to 0.
            kExprI32Const, 0,
            kExprLocalSet, kLocalCurrentOffset,
            // Outer loop until maxcount.
            ...[kExprLoop, kWasmVoid,
                // Find the next value to wait for.
                ...[kExprLoop, kWasmVoid,
                    // Check end of sequence.
                    kExprLocalGet, kLocalCurrentOffset,
                    kExprLocalGet, kArgSeqenceLength,
                    kExprI32Eq,
                    kExprBrIf, 2, // return
                    ...[kExprBlock, kWasmVoid,
                        // Load next value.
                        kExprLocalGet, kArgSequencePtr,
                        kExprLocalGet, kLocalCurrentOffset,
                        kExprI32Add,
                        loadMemOpcode, 0, 0,
                        // Mask off bits.
                        kExprLocalGet, kArgBitMask,
                        kExprI32And,
                        // Compare with worker id.
                        kExprLocalGet, kArgWorkerId,
                        kExprI32Eq,
                        kExprBrIf, 0,
                        // Not found, increment position.
                        kExprLocalGet, kLocalCurrentOffset,
                        kExprI32Const, size / 8,
                        kExprI32Add,
                        kExprLocalSet, kLocalCurrentOffset,
                        kExprBr, 1,
                        kExprEnd
                    ],
                    // Found, end loop.
                    kExprEnd
                ],
                // Load expected value to local.
                kExprLocalGet, kArgSequencePtr,
                kExprLocalGet, kLocalCurrentOffset,
                kExprI32Add,
                loadMemOpcode, 0, 0,
                kExprLocalSet, kLocalExpectedValue,
                // Load value after expected one.
                kExprLocalGet, kArgSequencePtr,
                kExprLocalGet, kLocalCurrentOffset,
                kExprI32Add,
                kExprI32Const, size / 8,
                kExprI32Add,
                loadMemOpcode, 0, 0,
                kExprLocalSet, kLocalNextValue,
                // Hammer on memory until value found.
                ...[kExprLoop, kWasmVoid,
                    // Load address.
                    kExprLocalGet, kArgMemoryCell,
                    // Load expected value.
                    kExprLocalGet, kLocalExpectedValue,
                    // Load updated value.
                    kExprLocalGet, kLocalNextValue,
                    // Try update.
                    kAtomicPrefix, compareExchangeOpcode, alignLog2, 0,
                    // Load expected value.
                    kExprLocalGet, kLocalExpectedValue,
                    // Spin if not what expected.
                    kExprI32Ne,
                    kExprBrIf, 0,
                    kExprEnd
                ],
                // Next iteration of loop.
                kExprLocalGet, kLocalCurrentOffset,
                kExprI32Const, size / 8,
                kExprI32Add,
                kExprLocalSet, kLocalCurrentOffset,
                kExprBr, 0,
                kExprEnd
            ], // outer loop
            kExprEnd
        ], // the block
        kExprReturn
    ];
    builder.addFunction(functionName, makeSig([kWasmI32, kWasmI32, kWasmI32,
            kWasmI32, kWasmI32
        ], []))
        .addLocals(kWasmI32, 3)
        .addBody(body)
        .exportAs(functionName);
}

function generateSequence(typedarray, start, count) {
    let end = count + start;
    for (let i = start; i < end; i++) {
        typedarray[i] = Math.floor(Math.random() * 256);
    }
}

function spawnWorker(module, memory, address, sequence) {
    let workers = [];
    for (let i = 0; i < kNumberOfWorkers; i++) {
        let worker = new Worker(
            `onmessage = function({data:msg}) {
                this.instance = new WebAssembly.Instance(msg.module,
                    {m: {imported_mem: msg.memory}});
                instance.exports.worker(msg.address, msg.sequence,
                    msg.sequenceLength, msg.workerId, msg.bitMask);
                postMessage({workerId: msg.workerId});
            }`,
            {type: 'string'}
        );
        workers.push(worker);
        worker.postMessage({
            module: module,
            memory: memory,
            address: address,
            sequence: sequence,
            sequenceLength: kSequenceLength,
            workerId: i,
            bitMask: kBitMask
        });
    }
    return workers;
}

function waitForWorkers(workers) {
    for (let worker of workers) {
        worker.getMessage();
        worker.terminate();
    }
}

function testOpcode(opcode, opcodeSize) {
    print("Testing I32AtomicCompareExchange" + opcodeSize);
    let builder = new WasmModuleBuilder();
    builder.addImportedMemory("m", "imported_mem", 0, 1, "shared");

    makeWorkerCodeForOpcode(opcode, opcodeSize, "worker", builder);

    let memory = new WebAssembly.Memory({
        initial: 1,
        maximum: 1,
        shared: true
    });
    let memoryView = new Uint8Array(memory.buffer);
    let numBytes = opcodeSize / 8;
    generateSequence(
        memoryView, kSequenceStartAddress, kSequenceLength * numBytes);

    // Write the first element of the sequence to memory, such that the workers
    // can start running as soon as they are spawned.
    memoryView.copyWithin(
        kMemoryAddress, kSequenceStartAddress,
        kSequenceStartAddress + numBytes);

    let module = new WebAssembly.Module(builder.toBuffer());
    let workers =
        spawnWorker(module, memory, kMemoryAddress, kSequenceStartAddress);

    waitForWorkers(workers);

    print("DONE");
}

testOpcode(kExprI32AtomicCompareExchange, 32);
testOpcode(kExprI32AtomicCompareExchange16U, 16);
testOpcode(kExprI32AtomicCompareExchange8U, 8);
                                               node-23.7.0/deps/v8/test/mjsunit/wasm/compare-exchange64-stress.js                                  0000664 0000000 0000000 00000017343 14746647661 0024733 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

const kSequenceLength = 8192;
const kNumberOfWorkers = 4;
const kBitMask = kNumberOfWorkers - 1;
const kMemoryAddress = 0;
const kSequenceStartAddress = 32;

function makeWorkerCodeForOpcode(compareExchangeOpcode, size, functionName,
    builder) {
    let loadMemOpcode = kTrapUnreachable;
    let alignLog2;
    switch (size) {
        case 64:
            loadMemOpcode = kExprI64LoadMem;
            alignLog2 = 3;
            break;
        case 32:
            loadMemOpcode = kExprI64LoadMem32U;
            alignLog2 = 2;
            break;
        case 16:
            loadMemOpcode = kExprI64LoadMem16U;
            alignLog2 = 1;
            break;
        case 8:
            loadMemOpcode = kExprI64LoadMem8U;
            alignLog2 = 0;
            break;
        default:
            throw "!";
    }
    const kArgMemoryCell = 0; // target for atomic ops
    const kArgSequencePtr = 1; // address of sequence
    const kArgSeqenceLength = 2; // lenght of sequence
    const kArgWorkerId = 3; // id of this worker
    const kArgBitMask = 4; // mask to extract worker id from value
    const kLocalCurrentOffset = 5; // current position in sequence in bytes
    const kLocalExpectedValue = 6; // the value we are waiting for
    const kLocalNextValue = 7; // the value to write in the update
    let body = [
        // Turn sequence length to equivalent in bytes.
        kExprLocalGet, kArgSeqenceLength,
        kExprI32Const, size / 8,
        kExprI32Mul,
        kExprLocalSet, kArgSeqenceLength,
        // Outer block so we have something to jump for return.
        ...[kExprBlock, kWasmVoid,
            // Set counter to 0.
            kExprI32Const, 0,
            kExprLocalSet, kLocalCurrentOffset,
            // Outer loop until maxcount.
            ...[kExprLoop, kWasmVoid,
                // Find the next value to wait for.
                ...[kExprLoop, kWasmVoid,
                    // Check end of sequence.
                    kExprLocalGet, kLocalCurrentOffset,
                    kExprLocalGet, kArgSeqenceLength,
                    kExprI32Eq,
                    kExprBrIf, 2, // return
                    ...[kExprBlock, kWasmVoid,
                        // Load next value.
                        kExprLocalGet, kArgSequencePtr,
                        kExprLocalGet, kLocalCurrentOffset,
                        kExprI32Add,
                        loadMemOpcode, 0, 0,
                        // Mask off bits.
                        kExprLocalGet, kArgBitMask,
                        kExprI64UConvertI32,
                        kExprI64And,
                        // Compare with worker id.
                        kExprLocalGet, kArgWorkerId,
                        kExprI64UConvertI32,
                        kExprI64Eq,
                        kExprBrIf, 0,
                        // Not found, increment position.
                        kExprLocalGet, kLocalCurrentOffset,
                        kExprI32Const, size / 8,
                        kExprI32Add,
                        kExprLocalSet, kLocalCurrentOffset,
                        kExprBr, 1,
                        kExprEnd
                    ],
                    // Found, end loop.
                    kExprEnd
                ],
                // Load expected value to local.
                kExprLocalGet, kArgSequencePtr,
                kExprLocalGet, kLocalCurrentOffset,
                kExprI32Add,
                loadMemOpcode, 0, 0,
                kExprLocalSet, kLocalExpectedValue,
                // Load value after expected one.
                kExprLocalGet, kArgSequencePtr,
                kExprLocalGet, kLocalCurrentOffset,
                kExprI32Add,
                kExprI32Const, size / 8,
                kExprI32Add,
                loadMemOpcode, 0, 0,
                kExprLocalSet, kLocalNextValue,
                // Hammer on memory until value found.
                ...[kExprLoop, kWasmVoid,
                    // Load address.
                    kExprLocalGet, kArgMemoryCell,
                    // Load expected value.
                    kExprLocalGet, kLocalExpectedValue,
                    // Load updated value.
                    kExprLocalGet, kLocalNextValue,
                    // Try update.
                    kAtomicPrefix, compareExchangeOpcode, alignLog2, 0,
                    // Load expected value.
                    kExprLocalGet, kLocalExpectedValue,
                    // Spin if not what expected.
                    kExprI64Ne,
                    kExprBrIf, 0,
                    kExprEnd
                ],
                // Next iteration of loop.
                kExprLocalGet, kLocalCurrentOffset,
                kExprI32Const, size / 8,
                kExprI32Add,
                kExprLocalSet, kLocalCurrentOffset,
                kExprBr, 0,
                kExprEnd
            ], // outer loop
            kExprEnd
        ], // the block
        kExprReturn
    ];
    builder.addFunction(functionName, makeSig([kWasmI32, kWasmI32, kWasmI32,
            kWasmI32, kWasmI32
        ], []))
        .addLocals(kWasmI32, 1).addLocals(kWasmI64, 2)
        .addBody(body)
        .exportAs(functionName);
}

function generateSequence(typedarray, start, count) {
    let end = count + start;
    for (let i = start; i < end; i++) {
        typedarray[i] = Math.floor(Math.random() * 256);
    }
}

function spawnWorker(module, memory, address, sequence) {
    let workers = [];
    for (let i = 0; i < kNumberOfWorkers; i++) {
        let worker = new Worker(
            `onmessage = function({data:msg}) {
                this.instance = new WebAssembly.Instance(msg.module,
                    {m: {imported_mem: msg.memory}});
                instance.exports.worker(msg.address, msg.sequence, msg.sequenceLength, msg.workerId,
                    msg.bitMask);
                postMessage({workerId: msg.workerId});
            }`,
            {type: 'string'}
        );
        workers.push(worker);
        worker.postMessage({
            module: module,
            memory: memory,
            address: address,
            sequence: sequence,
            sequenceLength: kSequenceLength,
            workerId: i,
            bitMask: kBitMask
        });
    }
    return workers;
}

function waitForWorkers(workers) {
    for (let worker of workers) {
        worker.getMessage();
        worker.terminate();
    }
}

function testOpcode(opcode, opcodeSize) {
    print("Testing I64AtomicCompareExchange" + opcodeSize);
    let builder = new WasmModuleBuilder();
    builder.addImportedMemory("m", "imported_mem", 0, 2, "shared");

    makeWorkerCodeForOpcode(opcode, opcodeSize, "worker", builder);

    let memory = new WebAssembly.Memory({
        initial: 2,
        maximum: 2,
        shared: true
    });
    let memoryView = new Uint8Array(memory.buffer);
    let numBytes = opcodeSize / 8;
    generateSequence(
        memoryView, kSequenceStartAddress, kSequenceLength * numBytes);

    // Write the first element of the sequence to memory, such that the workers
    // can start running as soon as they are spawned.
    memoryView.copyWithin(
        kMemoryAddress, kSequenceStartAddress,
        kSequenceStartAddress + numBytes);

    let module = new WebAssembly.Module(builder.toBuffer());
    let workers =
        spawnWorker(module, memory, kMemoryAddress, kSequenceStartAddress);

    waitForWorkers(workers);

    print("DONE");
}

testOpcode(kExprI64AtomicCompareExchange, 64);
testOpcode(kExprI64AtomicCompareExchange32U, 32);
testOpcode(kExprI64AtomicCompareExchange16U, 16);
testOpcode(kExprI64AtomicCompareExchange8U, 8);
                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/compilation-hints-async-compilation.js                        0000664 0000000 0000000 00000005705 14746647661 0027121 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file.

// Flags: --experimental-wasm-compilation-hints

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function testCompileWithBadLazyHint() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction('id', kSig_i_i)
         .addBody([kExprLocalGet, 0])
         .setCompilationHint(kCompilationHintStrategyLazy,
                             kCompilationHintTierOptimized,
                             kCompilationHintTierBaseline)
         .exportFunc();
  let bytes = builder.toBuffer();
  assertPromiseResult(WebAssembly.compile(bytes)
    .then(assertUnreachable,
          error => assertEquals("WebAssembly.compile(): Invalid compilation " +
          "hint 0x19 (forbidden downgrade) @+49", error.message)));
})();

(function testCompileWithBadLazyFunctionBody() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction('id', kSig_i_l)
         .addBody([kExprLocalGet, 0])
         .setCompilationHint(kCompilationHintStrategyLazy,
                             kCompilationHintTierDefault,
                             kCompilationHintTierDefault)
         .exportFunc();
  let bytes = builder.toBuffer();
  assertPromiseResult(WebAssembly.compile(bytes).then(
      assertUnreachable,
      error => assertEquals(
          'WebAssembly.compile(): Compiling function #0:"id" failed: type ' +
              'error in fallthru[0] (expected i32, got i64) @+56',
          error.message)));
})();

(function testCompileEmptyModule() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let bytes = builder.toBuffer();
  assertPromiseResult(WebAssembly.compile(bytes));
})();

(function testCompileLazyModule() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction('id', kSig_i_i)
         .addBody([kExprLocalGet, 0])
         .setCompilationHint(kCompilationHintStrategyLazy,
                             kCompilationHintTierDefault,
                             kCompilationHintTierDefault)
         .exportFunc();
  let bytes = builder.toBuffer();
  assertPromiseResult(WebAssembly.instantiate(bytes)
    .then(({module, instance}) => assertEquals(42, instance.exports.id(42))));
})();

(function testCompileLazyBaselineEagerTopTierModule() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction('id', kSig_i_i)
         .addBody([kExprLocalGet, 0])
         .setCompilationHint(kCompilationHintStrategyLazyBaselineEagerTopTier,
                             kCompilationHintTierDefault,
                             kCompilationHintTierDefault)
         .exportFunc();
  let bytes = builder.toBuffer();
  assertPromiseResult(WebAssembly.instantiate(bytes)
    .then(({module, instance}) => assertEquals(42, instance.exports.id(42))));
})();
                                                           node-23.7.0/deps/v8/test/mjsunit/wasm/compilation-hints-decoder.js                                  0000664 0000000 0000000 00000014207 14746647661 0025072 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file.

// Flags: --experimental-wasm-compilation-hints

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function testDecodeCompilationHintsSectionNoDowngrade() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addImport('mod', 'pow', kSig_i_ii);
  builder.addFunction('upow', kSig_i_i)
         .addBody([kExprLocalGet, 0,
                   kExprLocalGet, 0,
                   kExprCallFunction, 0])
         .setCompilationHint(kCompilationHintStrategyLazy,
                             kCompilationHintTierOptimized,
                             kCompilationHintTierBaseline)
         .exportFunc();
  assertThrows(() => builder.instantiate({mod: {pow: Math.pow}}),
               WebAssembly.CompileError,
               "WebAssembly.Module(): Invalid compilation hint 0x19 " +
               "(forbidden downgrade) @+70");
})();

(function testDecodeCompilationHintsSectionNoTiering() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addImport('mod', 'pow', kSig_i_ii);
  builder.addFunction('upow', kSig_i_i)
         .addBody([kExprLocalGet, 0,
                   kExprLocalGet, 0,
                   kExprCallFunction, 0])
         .setCompilationHint(kCompilationHintStrategyDefault,
                             kCompilationHintTierBaseline,
                             kCompilationHintTierBaseline)
         .exportFunc();
  builder.addFunction('upow2', kSig_i_i)
         .addBody([kExprLocalGet, 0,
                   kExprLocalGet, 0,
                   kExprCallFunction, 0])
  builder.addFunction('upow3', kSig_i_i)
         .addBody([kExprLocalGet, 0,
                   kExprLocalGet, 0,
                   kExprCallFunction, 0])
  let instance = builder.instantiate({mod: {pow: Math.pow}});
  assertEquals(27, instance.exports.upow(3))
})();

(function testDecodeCompilationHintsSectionUpgrade() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addImport('mod', 'pow', kSig_i_ii);
  builder.addFunction('upow2', kSig_i_i)
         .addBody([kExprLocalGet, 0,
                   kExprLocalGet, 0,
                   kExprCallFunction, 0])
  builder.addFunction('upow3', kSig_i_i)
         .addBody([kExprLocalGet, 0,
                   kExprLocalGet, 0,
                   kExprCallFunction, 0])
  builder.addFunction('upow', kSig_i_i)
         .addBody([kExprLocalGet, 0,
                   kExprLocalGet, 0,
                   kExprCallFunction, 0])
         .setCompilationHint(kCompilationHintStrategyEager,
                             kCompilationHintTierBaseline,
                             kCompilationHintTierOptimized)
         .exportFunc();
  let instance = builder.instantiate({mod: {pow: Math.pow}});
  assertEquals(27, instance.exports.upow(3))
})();

(function testDecodeCompilationHintsSectionNoImport() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction('sq', kSig_i_i)
         .addBody([kExprLocalGet, 0,
                   kExprLocalGet, 0,
                   kExprI32Mul])
         .setCompilationHint(kCompilationHintStrategyEager,
                             kCompilationHintTierDefault,
                             kCompilationHintTierOptimized)
         .exportFunc();
  let instance = builder.instantiate();
  assertEquals(9, instance.exports.sq(3))
})();

(function testDecodeCompilationHintsSectionNoExport() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction('sq', kSig_i_i)
         .addBody([kExprLocalGet, 0,
                   kExprLocalGet, 0,
                   kExprI32Mul])
         .setCompilationHint(kCompilationHintStrategyEager,
                             kCompilationHintTierDefault,
                             kCompilationHintTierOptimized);
  builder.instantiate();
})();

(function testDecodeCompilationHintsSectionTopTierDefault() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction('sq', kSig_i_i)
         .addBody([kExprLocalGet, 0,
                   kExprLocalGet, 0,
                   kExprI32Mul])
         .setCompilationHint(kCompilationHintStrategyEager,
                             kCompilationHintTierOptimized,
                             kCompilationHintTierDefault)
         .exportFunc();
  let instance = builder.instantiate();
  assertEquals(9, instance.exports.sq(3))
})();

(function testDecodeCompilationHintsLazyBaselineEagerTopTier() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction('sq', kSig_i_i)
         .addBody([kExprLocalGet, 0,
                   kExprLocalGet, 0,
                   kExprI32Mul])
         .setCompilationHint(kCompilationHintStrategyLazyBaselineEagerTopTier,
                             kCompilationHintTierOptimized,
                             kCompilationHintTierDefault)
         .exportFunc();
  builder.instantiate();
})();

(function testDecodeIllegalCompilationHintBaselineTier() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let kIllegalHintTier = 0x03;
  builder.addFunction('func', kSig_i_i)
      .addBody([kExprUnreachable])
      .setCompilationHint(
          kCompilationHintStrategyDefault, kIllegalHintTier,
          kCompilationHintTierDefault);
  assertThrows(
      () => builder.instantiate(), WebAssembly.CompileError,
      new RegExp(
          'WebAssembly.Module\\(\\): Invalid compilation hint 0x0c ' +
          '\\(invalid tier 0x03\\)'));
})();

(function testDecodeIllegalCompilationHintTopTier() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let kIllegalHintTier = 0x03;
  builder.addFunction('func', kSig_i_i)
      .addBody([kExprUnreachable])
      .setCompilationHint(
          kCompilationHintStrategyDefault, kCompilationHintTierDefault,
          kIllegalHintTier);
  assertThrows(
      () => builder.instantiate(), WebAssembly.CompileError,
      new RegExp(
          'WebAssembly.Module\\(\\): Invalid compilation hint 0x30 ' +
          '\\(invalid tier 0x03\\)'));
})();
                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/wasm/compilation-hints-ignored.js                                  0000664 0000000 0000000 00000001563 14746647661 0025115 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function testIgnoreCompilationHintsSectionUnlessEnabled() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addImport('mod', 'pow', kSig_i_ii);
  builder.addFunction('upow', kSig_i_i)
         .addBody([kExprLocalGet, 0,
                   kExprLocalGet, 0,
                   kExprCallFunction, 0])
         .setCompilationHint(kCompilationHintStrategyDefault,
                             kCompilationHintTierBaseline,
                             kCompilationHintTierBaseline)
         .exportFunc();
  let instance = builder.instantiate({mod: {pow: Math.pow}});
  assertEquals(27, instance.exports.upow(3))
})();
                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/compilation-hints-lazy-validation.js                          0000664 0000000 0000000 00000002637 14746647661 0026600 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file.

// Flags: --experimental-wasm-compilation-hints --wasm-lazy-validation

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function testInstantiateLazyValidation() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction('id', kSig_i_i)
         .addBody([kExprLocalGet, 0,
                   kExprI64Const, 1,
                   kExprI32Mul])
         .setCompilationHint(kCompilationHintStrategyLazy,
                             kCompilationHintTierBaseline,
                             kCompilationHintTierBaseline)
         .exportFunc();

  let expected_error_msg = "Compiling function #0:\"id\" failed: i32.mul[1] " +
                           "expected type i32, found i64.const of type i64 " +
                           "@+56";
  let assertCompileErrorOnInvocation = function(instance) {
    assertThrows(() => instance.exports.id(3),
                 WebAssembly.CompileError,
                 expected_error_msg)
  };

  // Synchronous case.
  let instance = builder.instantiate();
  assertCompileErrorOnInvocation(instance);

  // Asynchronous case.
  let bytes = builder.toBuffer();
  assertPromiseResult(WebAssembly.instantiate(bytes)
    .then(p => assertCompileErrorOnInvocation(p.instance)));
})();
                                                                                                 node-23.7.0/deps/v8/test/mjsunit/wasm/compilation-hints-streaming-compilation.js                    0000664 0000000 0000000 00000013015 14746647661 0027766 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file.

// Flags: --experimental-wasm-compilation-hints --wasm-test-streaming

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function testInstantiateStreamingWithLazyHint() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addImport('mod', 'pow', kSig_i_ii);
  builder.addFunction('upow', kSig_i_i)
         .addBody([kExprLocalGet, 0,
                   kExprLocalGet, 0,
                   kExprCallFunction, 0])
  builder.addFunction('upow2', kSig_i_i)
         .addBody([kExprLocalGet, 0,
                   kExprLocalGet, 0,
                   kExprCallFunction, 0])
         .setCompilationHint(kCompilationHintStrategyLazy,
                             kCompilationHintTierDefault,
                             kCompilationHintTierDefault)
         .exportFunc();
  let bytes = builder.toBuffer();
  assertPromiseResult(WebAssembly.instantiateStreaming(Promise.resolve(bytes),
                                                       {mod: {pow: Math.pow}})
    .then(({module, instance}) => assertEquals(27, instance.exports.upow2(3))));
})();

(function testInstantiateStreamingWithBadLazyHint() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addImport('mod', 'pow', kSig_i_ii);
  builder.addFunction('upow', kSig_i_i)
         .addBody([kExprLocalGet, 0,
                   kExprLocalGet, 0,
                   kExprCallFunction, 0])
  builder.addFunction('upow2', kSig_i_i)
         .addBody([kExprLocalGet, 0,
                   kExprLocalGet, 0,
                   kExprCallFunction, 0])
         .setCompilationHint(kCompilationHintStrategyLazy,
                             kCompilationHintTierOptimized,
                             kCompilationHintTierBaseline)
         .exportFunc();
  let bytes = builder.toBuffer();
  assertPromiseResult(WebAssembly.instantiateStreaming(Promise.resolve(bytes),
                                                       {mod: {pow: Math.pow}})
    .then(assertUnreachable,
          error => assertEquals("WebAssembly.instantiateStreaming(): Invalid " +
                                "compilation hint 0x19 (forbidden downgrade) " +
                                "@+78",
                                error.message)));
})();

(function testInstantiateStreamingWithBadLazyFunctionBody() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addImport('mod', 'pow', kSig_f_ff);
  builder.addFunction('upow', kSig_i_i)
         .addBody([kExprLocalGet, 0,
                   kExprLocalGet, 0,
                   kExprCallFunction, 0])
  builder.addFunction('upow2', kSig_i_i)
         .addBody([kExprLocalGet, 0,
                   kExprLocalGet, 0,
                   kExprCallFunction, 0])
         .setCompilationHint(kCompilationHintStrategyLazy,
                             kCompilationHintTierDefault,
                             kCompilationHintTierDefault)
         .exportFunc();
  let bytes = builder.toBuffer();
  assertPromiseResult(
      WebAssembly
          .instantiateStreaming(Promise.resolve(bytes), {mod: {pow: Math.pow}})
          .then(
              assertUnreachable,
              error => assertEquals(
                  'WebAssembly.instantiateStreaming(): Compiling ' +
                      'function #1:"upow" failed: call[0] ' +
                      'expected type f32, found local.get of type ' +
                      'i32 @+83',
                  error.message)));
})();

(function testInstantiateStreamingEmptyModule() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addImport('mod', 'pow', kSig_i_ii);
  let bytes = builder.toBuffer();
  assertPromiseResult(WebAssembly.instantiateStreaming(Promise.resolve(bytes),
                                                       {mod: {pow: Math.pow}}));
})();

(function testInstantiateStreamingLazyModule() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addImport('mod', 'pow', kSig_i_ii);
  builder.addFunction('upow', kSig_i_i)
         .addBody([kExprLocalGet, 0,
                   kExprLocalGet, 0,
                   kExprCallFunction, 0])
         .setCompilationHint(kCompilationHintStrategyLazy,
                             kCompilationHintTierDefault,
                             kCompilationHintTierDefault)
         .exportFunc();
  let bytes = builder.toBuffer();
  assertPromiseResult(WebAssembly.instantiateStreaming(Promise.resolve(bytes),
                                                       {mod: {pow: Math.pow}})
    .then(({module, instance}) => assertEquals(27, instance.exports.upow(3))));
})();

(function testInstantiateStreamingLazyBaselineModule() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addImport('mod', 'pow', kSig_i_ii);
  builder.addFunction('upow', kSig_i_i)
         .addBody([kExprLocalGet, 0,
                   kExprLocalGet, 0,
                   kExprCallFunction, 0])
         .setCompilationHint(kCompilationHintStrategyLazyBaselineEagerTopTier,
                             kCompilationHintTierDefault,
                             kCompilationHintTierDefault)
         .exportFunc();
  let bytes = builder.toBuffer();
  assertPromiseResult(WebAssembly.instantiateStreaming(Promise.resolve(bytes),
                                                       {mod: {pow: Math.pow}})
    .then(({module, instance}) => assertEquals(27, instance.exports.upow(3))));
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/wasm/compilation-hints-streaming-lazy-validation.js                0000664 0000000 0000000 00000002543 14746647661 0030563 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file.

// Flags: --experimental-wasm-compilation-hints --wasm-test-streaming --wasm-lazy-validation

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function testInstantiateStreamingLazyValidation() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction('id', kSig_i_i)
         .addBody([kExprLocalGet, 0,
                   kExprI64Const, 1,
                   kExprI32Mul])
         .setCompilationHint(kCompilationHintStrategyLazy,
                             kCompilationHintTierDefault,
                             kCompilationHintTierDefault)
         .exportFunc();

  let expected_error_msg = "Compiling function #0:\"id\" failed: i32.mul[1] " +
                           "expected type i32, found i64.const of type i64 " +
                           "@+56";
  let assertCompileErrorOnInvocation = function(instance) {
    assertThrows(() => instance.exports.id(3),
                 WebAssembly.CompileError,
                 expected_error_msg)
  };

  let bytes = builder.toBuffer();
  assertPromiseResult(WebAssembly.instantiateStreaming(Promise.resolve(bytes))
    .then(({module, instance}) => assertCompileErrorOnInvocation(instance)));
})();
                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/compilation-hints-sync-compilation.js                         0000664 0000000 0000000 00000004737 14746647661 0026764 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file.

// Flags: --experimental-wasm-compilation-hints

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function testCompileWithBadLazyHint() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction('id', kSig_i_i)
         .addBody([kExprLocalGet, 0])
         .setCompilationHint(kCompilationHintStrategyLazy,
                             kCompilationHintTierOptimized,
                             kCompilationHintTierBaseline)
         .exportFunc();
  assertThrows(() => builder.toModule(),
    WebAssembly.CompileError,
    "WebAssembly.Module(): Invalid compilation hint 0x19 " +
    "(forbidden downgrade) @+49");
})();

(function testCompileWithBadLazyFunctionBody() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction('id', kSig_i_l)
         .addBody([kExprLocalGet, 0])
         .setCompilationHint(kCompilationHintStrategyLazy,
                             kCompilationHintTierDefault,
                             kCompilationHintTierDefault)
         .exportFunc();
  assertThrows(() => builder.toModule(),
    WebAssembly.CompileError,
    "WebAssembly.Module(): Compiling function #0:\"id\" failed: type error " +
    "in fallthru[0] (expected i32, got i64) @+56");
})();

(function testCompileEmptyModule() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.toModule();
})();

(function testCompileLazyModule() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction('id', kSig_i_i)
         .addBody([kExprLocalGet, 0])
         .setCompilationHint(kCompilationHintStrategyLazy,
                             kCompilationHintTierDefault,
                             kCompilationHintTierDefault)
         .exportFunc();
  assertEquals(42, builder.instantiate().exports.id(42));
})();

(function testCompileLazyBaselineEagerTopTierModule() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction('id', kSig_i_i)
         .addBody([kExprLocalGet, 0])
         .setCompilationHint(kCompilationHintStrategyLazyBaselineEagerTopTier,
                             kCompilationHintTierDefault,
                             kCompilationHintTierDefault)
         .exportFunc();
  assertEquals(42, builder.instantiate().exports.id(42));
})();
                                 node-23.7.0/deps/v8/test/mjsunit/wasm/compilation-limits-asm.js                                     0000664 0000000 0000000 00000001171 14746647661 0024415 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --validate-asm

// Compilation limits for wasm are not enforced for asm->wasm.
%SetWasmCompileControls(0, false);

function AsmModule() {
  "use asm";
  function xxx() { return 43; }
  function yyy() { return 43; }
  function zzz() { return 43; }
  function main() { return 43; }

  return {main: main};
}

assertEquals(43, AsmModule(
    undefined, undefined, new ArrayBuffer(1024)).main());
assertTrue(%IsAsmWasmCode(AsmModule));
                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/wasm/compilation-limits.js                                         0000664 0000000 0000000 00000003710 14746647661 0023640 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

%SetWasmCompileControls(100000, true);
%SetWasmCompileControls(100000, false);

let buffer = (() => {
  let builder = new WasmModuleBuilder();
  builder.addFunction("f", kSig_i_v)
    .addBody([kExprI32Const, 42])
    .exportAs("f");
  return builder.toBuffer();
})();

let ok_module = new WebAssembly.Module(buffer);
assertTrue(ok_module instanceof WebAssembly.Module);
assertEquals(42, new WebAssembly.Instance(ok_module).exports.f());

failWithMessage = msg => %AbortJS(msg);

async function SuccessfulTest() {
  print("SuccessfulTest...");
  %SetWasmCompileControls(buffer.byteLength, true);
  %SetWasmInstantiateControls();
  let m = new WebAssembly.Module(buffer);
  let i = new WebAssembly.Instance(m);
  assertEquals(i.exports.f(), 42);
}

async function FailSyncCompile() {
  print("FailSyncCompile...");
  %SetWasmCompileControls(buffer.byteLength - 1, true);
  assertThrows(() => new WebAssembly.Module(buffer), RangeError);

  print("  wait");
  try {
    let m = await WebAssembly.compile(buffer);
    print("  cont");
    assertTrue(m instanceof WebAssembly.Module);
  } catch (e) {
    print("  catch");
    assertUnreachable();
  }
}

async function FailSyncInstantiate() {
  print("FailSyncInstantiate...");
  %SetWasmCompileControls(buffer.byteLength - 1, true);
  assertThrows(() => new WebAssembly.Instance(ok_module), RangeError);

  print("  wait");
  try {
    let i = await WebAssembly.instantiate(ok_module);
    print("  cont");
    assertTrue(i instanceof WebAssembly.Instance);
  } catch (e) {
    print("  catch: " + e);
    assertUnreachable();
  }
}

async function TestAll() {
  await SuccessfulTest();
  await FailSyncCompile();
  await FailSyncInstantiate();
}

assertPromiseResult(TestAll());
                                                        node-23.7.0/deps/v8/test/mjsunit/wasm/compiled-module-management.js                                 0000664 0000000 0000000 00000005106 14746647661 0025215 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --expose-gc --allow-natives-syntax

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// Use global variables for all values where the test wants to maintain strict
// control over value lifetime. Using local variables would not give sufficient
// guarantees of the value lifetime.
var module;
var instance1;
var instance2;
var instance3;
var instance4;

(function CompiledModuleInstancesInitialize1to3() {
  var builder = new WasmModuleBuilder();

  builder.addMemory(1, 1);
  builder.addImport("", "getValue", kSig_i_v);
  builder.addFunction("f", kSig_i_v)
    .addBody([
      kExprCallFunction, 0
    ]).exportFunc();

  module = new WebAssembly.Module(builder.toBuffer());

  print("Initial instances=0");
  assertEquals(0, %WasmGetNumberOfInstances(module));
  instance1 = new WebAssembly.Instance(module, {"": {getValue: () => 1}});

  print("Initial instances=1");
  assertEquals(1, %WasmGetNumberOfInstances(module));
  instance2 = new WebAssembly.Instance(module, {"": {getValue: () => 2}});

  print("Initial instances=2");
  assertEquals(2, %WasmGetNumberOfInstances(module));
  instance3 = new WebAssembly.Instance(module, {"": {getValue: () => 3}});

  print("Initial instances=3");
  assertEquals(3, %WasmGetNumberOfInstances(module));
})();

(function CompiledModuleInstancesClear1() {
  assertEquals(1, instance1.exports.f());
  instance1 = null;
})();

// Note that two GC's are required because weak slots clearing is deferred.
gc();
gc();
print("After gc instances=2");
assertEquals(2, %WasmGetNumberOfInstances(module));

(function CompiledModuleInstancesClear3() {
  assertEquals(3, instance3.exports.f());
  instance3 = null;
})();

// Note that two GC's are required because weak slots clearing is deferred.
gc();
gc();
print("After gc instances=1");
assertEquals(1, %WasmGetNumberOfInstances(module));

(function CompiledModuleInstancesClear2() {
  assertEquals(2, instance2.exports.f());
  instance2 = null;
})();

// Note that two GC's are required because weak slots clearing is deferred.
gc();
gc();
print("After gc instances=0");
assertEquals(0, %WasmGetNumberOfInstances(module));

(function CompiledModuleInstancesInitialize4AndClearModule() {
  instance4 = new WebAssembly.Instance(module, {"": {getValue: () => 4}});
  assertEquals(4, instance4.exports.f());
  module = null;
  instance4 = null;
})();

// Note that two GC's are required because weak slots clearing is deferred.
gc();
gc();
                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/wasm/compiled-module-serialization.js                              0000664 0000000 0000000 00000033431 14746647661 0025760 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Force TurboFan code for serialization.
// Flags: --expose-wasm --allow-natives-syntax --expose-gc --no-liftoff
// Flags: --no-wasm-lazy-compilation

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function SerializeAndDeserializeModule() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  builder.addImportedMemory("", "memory", 1);
  var kSig_v_i = makeSig([kWasmI32], []);
  var signature = builder.addType(kSig_v_i);
  builder.addImport("", "some_value", kSig_i_v);
  builder.addImport("", "writer", signature);

  builder.addFunction("main", kSig_i_i)
    .addBody([
      kExprLocalGet, 0,
      kExprI32LoadMem, 0, 0,
      kExprI32Const, 1,
      kExprCallIndirect, signature, kTableZero,
      kExprLocalGet,0,
      kExprI32LoadMem,0, 0,
      kExprCallFunction, 0,
      kExprI32Add
    ]).exportFunc();

  // writer(mem[i]);
  // return mem[i] + some_value();
  builder.addFunction("_wrap_writer", signature)
    .addBody([
      kExprLocalGet, 0,
      kExprCallFunction, 1]);
  builder.appendToTable([2, 3]);

  var wire_bytes = builder.toBuffer();
  var module = new WebAssembly.Module(wire_bytes);
  var mem_1 = new WebAssembly.Memory({initial: 1});
  var view_1 = new Int32Array(mem_1.buffer);
  view_1[0] = 42;
  var outval_1;
  var i1 = new WebAssembly.Instance(module, {"":
                                             {some_value: () => 1,
                                              writer: (x) => outval_1 = x ,
                                              memory: mem_1}
                                            });

  assertEquals(43, i1.exports.main(0));

  assertEquals(42, outval_1);
  var buff = %SerializeWasmModule(module);
  module = null;
  gc();
  module = %DeserializeWasmModule(buff, wire_bytes);

  var mem_2 = new WebAssembly.Memory({initial: 2});
  var view_2 = new Int32Array(mem_2.buffer);

  view_2[0] = 50;

  var outval_2;
  var i2 = new WebAssembly.Instance(module, {"":
                                             {some_value: () => 1,
                                              writer: (x) => outval_2 = x ,
                                              memory: mem_2}
                                            });

  assertEquals(51, i2.exports.main(0));

  assertEquals(50, outval_2);
  // The instances don't share memory through deserialization.
  assertEquals(43, i1.exports.main(0));
})();

(function DeserializeInvalidObject() {
  print(arguments.callee.name);
  const invalid_buffer = new ArrayBuffer(10);
  const invalid_buffer_view = new Uint8Array(10);

  module = %DeserializeWasmModule(invalid_buffer, invalid_buffer_view);
  assertEquals(module, undefined);
})();

(function RelationBetweenModuleAndClone() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("main", kSig_i_v)
    .addBody([kExprI32Const, 42])
    .exportFunc();

  var wire_bytes = builder.toBuffer();
  var compiled_module = new WebAssembly.Module(wire_bytes);
  var serialized = %SerializeWasmModule(compiled_module);
  var clone = %DeserializeWasmModule(serialized, wire_bytes);

  assertNotNull(clone);
  assertFalse(clone == undefined);
  assertFalse(clone == compiled_module);
  assertEquals(clone.constructor, compiled_module.constructor);
})();

(function SerializeWrappersWithSameSignature() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("main", kSig_i_v)
    .addBody([kExprI32Const, 42])
    .exportFunc();
  builder.addFunction("main_same_signature", kSig_i_v)
    .addBody([kExprI32Const, 23])
    .exportFunc();

  var wire_bytes = builder.toBuffer();
  var compiled_module = new WebAssembly.Module(wire_bytes);
  var serialized = %SerializeWasmModule(compiled_module);
  var clone = %DeserializeWasmModule(serialized, wire_bytes);

  assertNotNull(clone);
  assertFalse(clone == undefined);
  assertFalse(clone == compiled_module);
  assertEquals(clone.constructor, compiled_module.constructor);
})();

(function SerializeAfterInstantiation() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("main", kSig_i_v)
    .addBody([kExprI32Const, 42])
    .exportFunc();

  var wire_bytes = builder.toBuffer()
  var compiled_module = new WebAssembly.Module(wire_bytes);
  var instance1 = new WebAssembly.Instance(compiled_module);
  var instance2 = new WebAssembly.Instance(compiled_module);
  var serialized = %SerializeWasmModule(compiled_module);
  var clone = %DeserializeWasmModule(serialized, wire_bytes);

  assertNotNull(clone);
  assertFalse(clone == undefined);
  assertFalse(clone == compiled_module);
  assertEquals(clone.constructor, compiled_module.constructor);
  var instance3 = new WebAssembly.Instance(clone);
  assertFalse(instance3 == undefined);
})();


(function SerializeAfterInstantiationWithMemory() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addImportedMemory("", "memory", 1);
  builder.addFunction("main", kSig_i_v)
    .addBody([kExprI32Const, 42])
    .exportFunc();

  var wire_bytes = builder.toBuffer()
  var compiled_module = new WebAssembly.Module(wire_bytes);
  var mem_1 = new WebAssembly.Memory({initial: 1});
  var ffi =  {"":{memory:mem_1}};
  var instance1 = new WebAssembly.Instance(compiled_module, ffi);
  var serialized = %SerializeWasmModule(compiled_module);
  var clone = %DeserializeWasmModule(serialized, wire_bytes);

  assertNotNull(clone);
  assertFalse(clone == undefined);
  assertFalse(clone == compiled_module);
  assertEquals(clone.constructor, compiled_module.constructor);
  var instance2 = new WebAssembly.Instance(clone, ffi);
  assertFalse(instance2 == undefined);
})();

(function GlobalsArePrivateBetweenClones() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  builder.addGlobal(kWasmI32, true, false);
  builder.addFunction("read", kSig_i_v)
    .addBody([
      kExprGlobalGet, 0])
    .exportFunc();

  builder.addFunction("write", kSig_v_i)
    .addBody([
      kExprLocalGet, 0,
      kExprGlobalSet, 0])
    .exportFunc();

  var wire_bytes = builder.toBuffer();
  var module = new WebAssembly.Module(wire_bytes);
  var i1 = new WebAssembly.Instance(module);
  // serialize and replace module
  var buff = %SerializeWasmModule(module);
  var module_clone = %DeserializeWasmModule(buff, wire_bytes);
  var i2 = new WebAssembly.Instance(module_clone);
  i1.exports.write(1);
  i2.exports.write(2);
  assertEquals(1, i1.exports.read());
  assertEquals(2, i2.exports.read());
})();

(function SharedTableTest() {
  print(arguments.callee.name);
  let kTableSize = 3;
  var sig_index1;

  function MakeTableExportingModule(constant) {
    // A module that defines a table and exports it.
    var builder = new WasmModuleBuilder();
    builder.addType(kSig_i_i);
    builder.addType(kSig_i_ii);
    sig_index1 = builder.addType(kSig_i_v);
    var f1 = builder.addFunction("f1", sig_index1)
        .addBody([kExprI32Const, constant]);

    builder.addFunction("main", kSig_i_ii)
      .addBody([
        kExprLocalGet, 0,   // --
        kExprCallIndirect, sig_index1, kTableZero])  // --
      .exportAs("main");

    builder.setTableBounds(kTableSize, kTableSize);
    builder.addActiveElementSegment(0, wasmI32Const(0), [f1.index]);
    builder.addExportOfKind("table", kExternalTable, 0);

    return new WebAssembly.Module(builder.toBuffer());
  }
  var m1 = MakeTableExportingModule(11);

  // Module {m2} imports the table and adds {f2}.
  var builder = new WasmModuleBuilder();
  builder.addType(kSig_i_ii);
  var sig_index2 = builder.addType(kSig_i_v);
  var f2 = builder.addFunction("f2", sig_index2)
    .addBody([kExprI32Const, 22]);

  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,   // --
      kExprCallIndirect, sig_index2, kTableZero])  // --
    .exportAs("main");

  builder.addImportedTable("z", "table", kTableSize, kTableSize);
  builder.addActiveElementSegment(0, wasmI32Const(1), [f2.index]);
  var m2_bytes = builder.toBuffer();
  var m2 = new WebAssembly.Module(m2_bytes);

  assertFalse(sig_index1 == sig_index2);

  var i1 = new WebAssembly.Instance(m1);
  var i2 = new WebAssembly.Instance(m2, {z: {table: i1.exports.table}});

  var serialized_m2 = %SerializeWasmModule(m2);
  var m2_clone = %DeserializeWasmModule(serialized_m2, m2_bytes);

  var m3 = MakeTableExportingModule(33);
  var i3 = new WebAssembly.Instance(m3);
  var i2_prime = new WebAssembly.Instance(m2_clone,
                                          {z: {table: i3.exports.table}});

  assertEquals(11, i1.exports.main(0));
  assertEquals(11, i2.exports.main(0));

  assertEquals(22, i1.exports.main(1));
  assertEquals(22, i2.exports.main(1));

  assertEquals(33, i3.exports.main(0));
  assertEquals(33, i2_prime.exports.main(0));

  assertThrows(() => i1.exports.main(2));
  assertThrows(() => i2.exports.main(2));
  assertThrows(() => i1.exports.main(3));
  assertThrows(() => i2.exports.main(3));
})();

(function StackOverflowAfterSerialization() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  var fun = builder.addFunction('main', kSig_v_v);
  fun.addBody([kExprCallFunction, fun.index]);
  fun.exportFunc();

  var wire_bytes = builder.toBuffer();
  var module = new WebAssembly.Module(wire_bytes);
  var buffer = %SerializeWasmModule(module);
  module = %DeserializeWasmModule(buffer, wire_bytes);
  var instance = new WebAssembly.Instance(module);

  assertThrows(instance.exports.main, RangeError);
})();

(function TrapAfterDeserialization() {
  print(arguments.callee.name);
  function GenerateSerializedModule() {
    const builder = new WasmModuleBuilder();
    builder.addMemory(1, 1);
    builder.addFunction('main', kSig_i_i)
        .addBody([kExprLocalGet, 0, kExprI32LoadMem, 0, 0])
        .exportFunc();
    const wire_bytes = builder.toBuffer();
    const module = new WebAssembly.Module(wire_bytes);
    const buffer = %SerializeWasmModule(module);
    return [wire_bytes, buffer];
  }
  const [wire_bytes, buffer] = GenerateSerializedModule();
  module = %DeserializeWasmModule(buffer, wire_bytes);
  const instance = new WebAssembly.Instance(module);

  assertEquals(0, instance.exports.main(0));
  assertEquals(0, instance.exports.main(kPageSize - 4));
  assertTraps(
      kTrapMemOutOfBounds, _ => instance.exports.main(kPageSize - 3));
})();

(function DirectCallAfterSerialization() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  var fun1 = builder.addFunction('fun1', kSig_i_v)
      .addBody([kExprI32Const, 23]);
  var fun2 = builder.addFunction('fun2', kSig_i_v)
      .addBody([kExprI32Const, 42]);
  builder.addFunction('main', kSig_i_v)
      .addBody([kExprCallFunction, fun1.index,
                kExprCallFunction, fun2.index,
                kExprI32Add])
      .exportFunc();

  var wire_bytes = builder.toBuffer();
  var module = new WebAssembly.Module(wire_bytes);
  var buffer = %SerializeWasmModule(module);
  module = %DeserializeWasmModule(buffer, wire_bytes);
  var instance = new WebAssembly.Instance(module);

  assertEquals(65, instance.exports.main());
})();

(function ImportCallAfterSerialization() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  var fun_import = builder.addImport("", "my_import", kSig_i_v);
  var fun = builder.addFunction('fun', kSig_i_v)
      .addBody([kExprI32Const, 23]);
  builder.addFunction('main', kSig_i_v)
      .addBody([kExprCallFunction, fun.index,
                kExprCallFunction, fun_import,
                kExprI32Add])
      .exportFunc();

  var wire_bytes = builder.toBuffer();
  var module = new WebAssembly.Module(wire_bytes);
  var buffer = %SerializeWasmModule(module);
  module = %DeserializeWasmModule(buffer, wire_bytes);
  var instance = new WebAssembly.Instance(module, {"": {my_import: () => 42 }});

  assertEquals(65, instance.exports.main());
})();

(function BranchTableAfterSerialization() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.addFunction('main', kSig_i_i)
      .addBody([kExprBlock, kWasmVoid,
                  kExprBlock, kWasmVoid,
                    kExprBlock, kWasmVoid,
                      kExprBlock, kWasmVoid,
                        kExprBlock, kWasmVoid,
                          kExprBlock, kWasmVoid,
                            kExprBlock, kWasmVoid,
                              kExprLocalGet, 0,
                              kExprBrTable, 6, 0, 1, 2, 3, 4, 5, 6,
                            kExprEnd,
                            kExprI32Const, 3,
                            kExprReturn,
                          kExprEnd,
                          kExprI32Const, 7,
                          kExprReturn,
                        kExprEnd,
                        kExprI32Const, 9,
                        kExprReturn,
                      kExprEnd,
                      kExprI32Const, 11,
                      kExprReturn,
                    kExprEnd,
                    kExprI32Const, 23,
                    kExprReturn,
                  kExprEnd,
                  kExprI32Const, 35,
                  kExprReturn,
                kExprEnd,
                kExprI32Const, 42,
                kExprReturn])
      .exportFunc();

  var wire_bytes = builder.toBuffer();
  var module = new WebAssembly.Module(wire_bytes);
  var buffer = %SerializeWasmModule(module);
  module = %DeserializeWasmModule(buffer, wire_bytes);
  var instance = new WebAssembly.Instance(module);

  assertEquals(3, instance.exports.main(0));
  assertEquals(7, instance.exports.main(1));
  assertEquals(9, instance.exports.main(2));
  assertEquals(11, instance.exports.main(3));
  assertEquals(23, instance.exports.main(4));
  assertEquals(35, instance.exports.main(5));
  assertEquals(42, instance.exports.main(6));
  assertEquals(42, instance.exports.main(9));
})();
                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/wasm/data-segments.js                                              0000664 0000000 0000000 00000003745 14746647661 0022567 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

var debug = false;

function SimpleDataSegmentTest(offset) {
  print("SimpleDataSegmentTest(" + offset + ")...");
  var builder = new WasmModuleBuilder();
  builder.addMemory(1, 1);
  builder.addFunction("load", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprI32LoadMem, 0, 0])
    .exportAs("load");
  builder.addActiveDataSegment(0, wasmI32Const(offset), [9, 9, 9, 9]);

  var buffer = builder.toBuffer(debug);
  var instance = new WebAssembly.Instance(new WebAssembly.Module(buffer));
  for (var i = offset - 20; i < offset + 20; i += 4) {
    if (i < 0) continue;
    var expected = (i == offset) ? 151587081 : 0;
    assertEquals(expected, instance.exports.load(i));
  }
}

SimpleDataSegmentTest(0);
SimpleDataSegmentTest(4);
SimpleDataSegmentTest(12);
SimpleDataSegmentTest(1064);

function GlobalImportedInitTest(pad) {
  print("GlobalImportedInitTest(" + pad + ")...");
  var builder = new WasmModuleBuilder();
  builder.addMemory(1, 1);

  var g = builder.addImportedGlobal("mod", "offset", kWasmI32);

  while (pad-- > 0) builder.addGlobal(kWasmI32, false, false);  // pad

  builder.addFunction("load", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprI32LoadMem, 0, 0])
    .exportAs("load");
  builder.addActiveDataSegment(0, [kExprGlobalGet, g], [5, 5, 5, 5]);

  var buffer = builder.toBuffer(debug);
  var module = new WebAssembly.Module(buffer);

  for (var offset of [0, 12, 192, 1024]) {
    var instance = new WebAssembly.Instance(module, {mod: {offset: offset}});
    for (var i = offset - 20; i < offset + 20; i += 4) {
      if (i < 0) continue;
      var expected = i == offset ? 84215045 : 0;
      assertEquals(expected, instance.exports.load(i));
    }
  }
}

GlobalImportedInitTest(0);
GlobalImportedInitTest(1);
GlobalImportedInitTest(4);
                           node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/                                                        0000775 0000000 0000000 00000000000 14746647661 0020577 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-call-indirect.js                                  0000664 0000000 0000000 00000003627 14746647661 0024770 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-deopt --allow-natives-syntax --turboshaft-wasm
// Flags: --experimental-wasm-inlining --liftoff
// Flags: --turboshaft-wasm-instruction-selection-staged --no-jit-fuzzing
// Flags: --wasm-inlining-call-indirect

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestDeoptCallIndirect() {
  var builder = new WasmModuleBuilder();
  let funcRefT = builder.addType(kSig_i_ii);

  let add = builder.addFunction("add", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
    .exportFunc();
  let mul = builder.addFunction("mul", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Mul])
    .exportFunc();

  let table = builder.addTable(kWasmFuncRef, 2);
  builder.addActiveElementSegment(table.index, wasmI32Const(0), [
    [kExprRefFunc, add.index],
    [kExprRefFunc, mul.index],
  ], kWasmFuncRef);

  let mainSig =
    makeSig([kWasmI32, kWasmI32, kWasmI32], [kWasmI32]);
  builder.addFunction("main", mainSig)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprCallIndirect, funcRefT, table.index,
  ]).exportFunc();

  let wasm = builder.instantiate().exports;
  add = 0;
  mul = 1;
  assertEquals(42, wasm.main(12, 30, add));
  %WasmTierUpFunction(wasm.main);
  // Tier up.
  assertEquals(42, wasm.main(12, 30, add));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
  // Deopt.
  assertEquals(-360, wasm.main(12, -30, mul));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.main));
  }
  assertEquals(42, wasm.main(12, 30, add));
  // Re-optimize.
  %WasmTierUpFunction(wasm.main);
  assertEquals(360, wasm.main(12, 30, mul));
  assertEquals(42, wasm.main(12, 30, add));
 })();
                                                                                                         node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-dynamic-tierup.js                                 0000664 0000000 0000000 00000004633 14746647661 0025206 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-deopt --allow-natives-syntax --turboshaft-wasm
// Flags: --experimental-wasm-inlining --liftoff
// Flags: --turboshaft-wasm-instruction-selection-staged
// Flags: --wasm-tiering-budget=1000 --wasm-dynamic-tiering
// Flags: --no-predictable

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestDeoptTieringBudget() {
  // This can be non-zero in certain variants (e.g. `code_serializer`).
  let initialDeoptCount = %WasmDeoptsExecutedCount();

  var builder = new WasmModuleBuilder();
  let funcRefT = builder.addType(kSig_i_ii);

  builder.addFunction("add", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
    .exportFunc();
  builder.addFunction("mul", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Mul])
    .exportFunc();
  let mainSig =
    makeSig([kWasmI32, kWasmI32, wasmRefType(funcRefT)], [kWasmI32]);
  builder.addFunction("main", mainSig)
    .addLocals(kWasmI32, 1)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprCallRef, funcRefT,
  ]).exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(initialDeoptCount, %WasmDeoptsExecutedCount());
  print("Running until tier up");
  while (!%IsTurboFanFunction(wasm.main)) {
    assertEquals(42, wasm.main(12, 30, wasm.add));
  }
  assertEquals(initialDeoptCount, %WasmDeoptsExecutedCount());
  print("Tierup reached");
  // Cause deopt.
  assertEquals(360, wasm.main(12, 30, wasm.mul));
  assertEquals(initialDeoptCount + 1, %WasmDeoptsExecutedCount());
  print("Deopt reached");
  // Run again until tierup.
  while (!%IsTurboFanFunction(wasm.main)) {
    assertEquals(42, wasm.main(12, 30, wasm.add));
    assertEquals(360, wasm.main(12, 30, wasm.mul));
  }
  print("Tiered up again");
  // If we are very unlucky, there can still be compilations with old feedback
  // queued in the background that re-trigger new deopts with the wasm.mul
  // target. Therefore we can't assert that the deopt count is still 1.
  assertTrue(initialDeoptCount + %WasmDeoptsExecutedCount() < 20);
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
  assertEquals(42, wasm.main(12, 30, wasm.add));
  assertEquals(360, wasm.main(12, 30, wasm.mul));
})();
                                                                                                     node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-feedback-states.js                                0000664 0000000 0000000 00000010024 14746647661 0025270 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-deopt --allow-natives-syntax --turboshaft-wasm
// Flags: --experimental-wasm-inlining --liftoff
// Flags: --turboshaft-wasm-instruction-selection-staged --no-jit-fuzzing

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// Test progressing through the different "states" of feedback:
// - monomorphic
// - polymorphic (2-4 targets)
// - megamorphic
(function TestDeoptCallRef() {
  var builder = new WasmModuleBuilder();
  let funcRefT = builder.addType(kSig_i_ii);

  builder.addFunction("add", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
    .exportFunc();
  builder.addFunction("mul", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Mul])
    .exportFunc();
  builder.addFunction("sub", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Sub])
    .exportFunc();
  builder.addFunction("first", funcRefT)
    .addBody([kExprLocalGet, 0])
    .exportFunc();
  builder.addFunction("second", funcRefT)
    .addBody([kExprLocalGet, 1])
    .exportFunc();
  builder.addFunction("equals", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Eq,])
    .exportFunc();

  let mainSig =
    makeSig([kWasmI32, kWasmI32, wasmRefType(funcRefT)], [kWasmI32]);
  builder.addFunction("main", mainSig)
    .addLocals(kWasmI32, 1)
    .addBody([
      // Set the local to some value.
      kExprI32Const, 1,
      kExprLocalSet, 3,

      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprCallRef, funcRefT,

      // Use the local after the deopt point.
      kExprLocalGet, 3,
      kExprI32Mul,
  ]).exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(42, wasm.main(12, 30, wasm.add));
  %WasmTierUpFunction(wasm.main);
  print("tierup");
  assertEquals(42, wasm.main(12, 30, wasm.add));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
  print("non-deopt call succeeded, now causing deopt");
  assertEquals(360, wasm.main(12, 30, wasm.mul));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.main));
  }
  print("deopt happened");
  assertEquals(42, wasm.main(12, 30, wasm.add));
  print("collect more feedback in liftoff");
  assertEquals(-18, wasm.main(12, 30, wasm.sub));
  print("re-opt");
  %WasmTierUpFunction(wasm.main);
  assertEquals(360, wasm.main(12, 30, wasm.mul));
  assertEquals(42, wasm.main(12, 30, wasm.add));
  assertEquals(-18, wasm.main(12, 30, wasm.sub));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
  assertEquals(12, wasm.main(12, 30, wasm.first));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.main));
  }
  print("deopt happened");
  print("re-opt with maximum polymorphism");
  %WasmTierUpFunction(wasm.main);
  assertEquals(360, wasm.main(12, 30, wasm.mul));
  assertEquals(42, wasm.main(12, 30, wasm.add));
  assertEquals(-18, wasm.main(12, 30, wasm.sub));
  assertEquals(12, wasm.main(12, 30, wasm.first));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
  assertEquals(30, wasm.main(12, 30, wasm.second));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.main));
  }
  print("deopt happened");
  print("reopt again");
  %WasmTierUpFunction(wasm.main);
  // All previous call targets still succeed.
  assertEquals(360, wasm.main(12, 30, wasm.mul));
  assertEquals(42, wasm.main(12, 30, wasm.add));
  assertEquals(-18, wasm.main(12, 30, wasm.sub));
  assertEquals(12, wasm.main(12, 30, wasm.first));
  assertEquals(30, wasm.main(12, 30, wasm.second));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
  // Previously unseen call targets do not cause a deopt any more.
  assertEquals(1, wasm.main(42, 42, wasm.equals));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-inlined-param-stack-slots.js                      0000664 0000000 0000000 00000004604 14746647661 0027237 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-deopt --allow-natives-syntax --turboshaft-wasm --liftoff
// Flags: --experimental-wasm-inlining --wasm-inlining-ignore-call-counts
// Flags: --turboshaft-wasm-instruction-selection-staged --no-jit-fuzzing

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// This test case tests th scenario where the optimized function "main" doesn't
// have any parameter stack slots while the inner-most inlined function
// "innerInlinee" has multiple ones.
(function TestDeoptManyParameterStackSlotsInInlinedFunctionButNotInOuter() {
  var builder = new WasmModuleBuilder();
  let funcRefT = builder.addType(kSig_i_ii);

  builder.addFunction("add", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
    .exportFunc();
  builder.addFunction("mul", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Mul])
    .exportFunc();

  let sigInner = makeSig([wasmRefType(funcRefT), kWasmI32, kWasmI32, kWasmI32,
    kWasmI32, kWasmI32, kWasmI32, kWasmI32, kWasmI32, kWasmI32, kWasmI32,
    kWasmI32, kWasmI32], [kWasmI32]);

  let innerInlinee = builder.addFunction("innerInlinee", sigInner)
  .addBody([
    kExprLocalGet, 1,
    kExprLocalGet, 2,
    kExprLocalGet, 0,
    kExprCallRef, funcRefT,
  ]);

  let sigCallRef =
    makeSig([wasmRefType(funcRefT)], [kWasmI32]);

  let outerInlinee = builder.addFunction("outerInlinee", sigCallRef)
  .addBody([
    kExprLocalGet, 0, kExprI32Const, 30, kExprI32Const, 12, kExprI32Const, 0,
    kExprI32Const, 0, kExprI32Const, 0, kExprI32Const, 0, kExprI32Const, 0,
    kExprI32Const, 0, kExprI32Const, 0, kExprI32Const, 0, kExprI32Const, 0,
    kExprI32Const, 0,
    kExprCallFunction, innerInlinee.index,
  ]);

  builder.addFunction("main", sigCallRef)
    .addBody([
      kExprLocalGet, 0,
      kExprCallFunction, outerInlinee.index,
  ]).exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(42, wasm.main(wasm.add));
  %WasmTierUpFunction(wasm.main);
  // tierup.
  assertEquals(42, wasm.main(wasm.add));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
  // deopt.
  assertEquals(360, wasm.main(wasm.mul));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.main));
  }
})();
                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-inlined-stacktrace.js                             0000664 0000000 0000000 00000005510 14746647661 0026013 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-deopt --allow-natives-syntax --turboshaft-wasm
// Flags: --experimental-wasm-inlining --liftoff
// Flags: --turboshaft-wasm-instruction-selection-staged
// Flags: --wasm-inlining-ignore-call-counts --no-jit-fuzzing

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestDeoptInlinedStacktrace() {
  var builder = new WasmModuleBuilder();
  let funcRefT = builder.addType(kSig_i_ii);

  builder.addFunction("add", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
    .exportFunc();
  builder.addFunction("div", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32DivS])
    .exportFunc();

  let mainSig =
    makeSig([kWasmI32, kWasmI32, wasmRefType(funcRefT)], [kWasmI32]);
  let inlinee = builder.addFunction("inlinee", mainSig)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprCallRef, funcRefT,
  ]).exportFunc();

  builder.addFunction("main", mainSig)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprCallFunction, inlinee.index,
  ]).exportFunc();

  let wasm = builder.instantiate().exports;
  // Collect feedback.
  assertEquals(42, wasm.main(12, 30, wasm.add));
  // Trigger tierup.
  %WasmTierUpFunction(wasm.main);
  assertEquals(42, wasm.main(12, 30, wasm.add));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
  // Trigger deopt which then calls a target that throws, i.e. the stack trace
  // contains frames created by the deoptimizer.
  try {
    wasm.main(10, 0, wasm.div);
    assertUnreachable();
  } catch (error) {
    verifyException(error);
  }
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.main));
  }
  // Rerun unoptimized which should produce the same result.
  try {
    wasm.main(10, 0, wasm.div);
    assertUnreachable();
  } catch (error) {
    verifyException(error);
  }
  %WasmTierUpFunction(wasm.main);
  // Rerun optimized which should also produce the same result and not deopt.
  try {
    wasm.main(10, 0, wasm.div);
    assertUnreachable();
  } catch (error) {
    verifyException(error);
  }
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }

  function verifyException(error) {
    assertMatches(/RuntimeError: divide by zero/, error + "");
    let stack = error.stack.split("\n");
    let expected = [
      /RuntimeError: divide by zero/,
      /at div .*wasm-function\[1\]:0x59/,
      /at inlinee .*wasm-function\[2\]:0x63/,
      /at main .*wasm-function\[3\]:0x6e/,
    ];
    for (let i = 0; i < expected.length; ++i) {
      assertMatches(expected[i], stack[i]);
    }
  }
})();
                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-inlined.js                                        0000664 0000000 0000000 00000007045 14746647661 0023676 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-deopt --allow-natives-syntax --turboshaft-wasm
// Flags: --experimental-wasm-inlining --liftoff
// Flags: --turboshaft-wasm-instruction-selection-staged
// Flags: --wasm-inlining-ignore-call-counts --no-jit-fuzzing
// Flags: --wasm-inlining-call-indirect

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestDeoptInlined() {
  let inlineeIndex = 2;
  let sig = 1;
  // These different tests define the call "kind" for the inlining of the
  // function called "inlinee", not the speculative inlining for add / mul.
  let tests = [
    {name: "callDirect", ops: [kExprCallFunction, inlineeIndex]},
    {name: "callRef", ops: [kExprRefFunc, inlineeIndex, kExprCallRef, sig]},
    {name: "callIndirect",
     ops: [kExprI32Const, 0, kExprCallIndirect, sig, kTableZero]},
    {name: "returnCall", ops: [kExprReturnCall, inlineeIndex]},
    {name: "returnCallRef",
     ops: [kExprRefFunc, inlineeIndex, kExprReturnCallRef, sig]},
    {name: "returnCallIndirect",
     ops: [kExprI32Const, 0, kExprReturnCallIndirect, sig, kTableZero]},
  ];

  for (let test of tests) {
    print(`test ${test.name}`);
    var builder = new WasmModuleBuilder();
    let funcRefT = builder.addType(kSig_i_ii);

    builder.addFunction("add", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
    .exportFunc();
    builder.addFunction("mul", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Mul])
    .exportFunc();

    let mainSig = builder.addType(makeSig([kWasmI32, kWasmI32,
      wasmRefType(funcRefT)], [kWasmI32]));
    assertEquals(sig, mainSig);
    let inlinee = builder.addFunction("inlinee", mainSig)
      .addBody([
        kExprLocalGet, 1,
        kExprI32Const, 1,
        kExprI32Add,
        kExprLocalTee, 1,
        kExprLocalGet, 0,
        kExprI32Const, 1,
        kExprI32Add,
        kExprLocalTee, 0,
        kExprLocalGet, 2,
        kExprCallRef, funcRefT,
    ]).exportFunc();
    assertEquals(inlinee.index, inlineeIndex);

    builder.addFunction(test.name, mainSig)
      .addLocals(kWasmI32, 1)
      .addBody([
        kExprLocalGet, 0,
        kExprI32Const, 1,
        kExprI32Add,
        kExprLocalGet, 1,
        kExprI32Const, 1,
        kExprI32Add,
        kExprLocalGet, 2,
        ...test.ops,
    ]).exportFunc();

    let table = builder.addTable(kWasmFuncRef, 1);
    builder.addActiveElementSegment(table.index, wasmI32Const(0),
      [[kExprRefFunc, inlinee.index]], kWasmFuncRef);

    let wasm = builder.instantiate().exports;

    let fct = wasm[test.name];
    assertEquals(46, fct(12, 30, wasm.add));
    // Tier up.
    %WasmTierUpFunction(fct);
    assertEquals(46, fct(12, 30, wasm.add));
    if (%IsWasmTieringPredictable()) {
      assertTrue(%IsTurboFanFunction(fct));
    }
    // Cause deopt.
    assertEquals(14 * 32, fct(12, 30, wasm.mul));
    // Deopt happened.
    if (%IsWasmTieringPredictable()) assertFalse(%IsTurboFanFunction(fct));
    assertEquals(46, fct(12, 30, wasm.add));
    // Trigger re-opt.
    %WasmTierUpFunction(fct);
    // Both call targets are used in the re-optimized function, so they don't
    // trigger new deopts.
    assertEquals(46, fct(12, 30, wasm.add));
    if (%IsWasmTieringPredictable()) {
      assertTrue(%IsTurboFanFunction(fct));
    }
    assertEquals(14 * 32, fct(12, 30, wasm.mul));
    if (%IsWasmTieringPredictable()) {
      assertTrue(%IsTurboFanFunction(fct));
    }
  }
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-int64-values.js                                   0000664 0000000 0000000 00000010235 14746647661 0024510 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-deopt --allow-natives-syntax --turboshaft-wasm
// Flags: --experimental-wasm-inlining --liftoff
// Flags: --turboshaft-wasm-instruction-selection-staged --no-jit-fuzzing

// Test for different types of stack, local and literal values.
d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// Similar to deopt-value-types.js but focused on int64 which requires int64
// lowering.
(function TestDeoptTypesInt64Values() {
  var builder = new WasmModuleBuilder();
  let funcRefT = builder.addType(kSig_v_v);

  builder.addFunction("nop1", funcRefT).addBody([]).exportFunc();
  builder.addFunction("nop2", funcRefT).addBody([]).exportFunc();

  let mainSig = makeSig([kWasmI64, wasmRefType(funcRefT)], [kWasmI64]);

  let localConstant = (0x1n << 32n) + 0x2n;
  let valueStackConstant = (0x12345n << 32n) + 0x54321n;
  let addedValue = 123n;
  let subtractedValue = 321n;
  let argumentValue = 0x1234567887654321n;

  builder.addFunction("main", mainSig)
    .addLocals(kWasmI64, 3)
    .addBody([
      // Add a constant value as a local.
      ...wasmI64Const(localConstant),
      kExprLocalSet, 2,
      // Add a non-constant value as a local.
      kExprLocalGet, 0,
      ...wasmI64Const(addedValue),
      kExprI64Add,
      kExprLocalSet, 3,
      // Push a constant value to the value stack.
      ...wasmI64Const(valueStackConstant),
      // Push a non-constant value to the value stack.
      kExprLocalGet, 0,
      ...wasmI64Const(subtractedValue),
      kExprI64Sub,

      // Perform the call_ref.
      kExprLocalGet, 1,
      kExprCallRef, funcRefT,

      // Use the locals in the now potentially deoptimized execution.
      kExprLocalGet, 0, // the argument
      kExprLocalGet, 2, // the constant local
      kExprLocalGet, 3, // the non-constant local
      kExprLocalGet, 4,  // an uninitialized local (0)
      kExprI64Add,
      kExprI64Add,
      kExprI64Add,
      kExprI64Add,
      kExprI64Add,
  ]).exportFunc();

  let wasm = builder.instantiate().exports;
  let expected = localConstant + valueStackConstant + addedValue
                 - subtractedValue + argumentValue * 3n;
  assertEquals(expected, wasm.main(argumentValue, wasm.nop1));
  %WasmTierUpFunction(wasm.main);
  assertEquals(expected, wasm.main(argumentValue, wasm.nop1));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
  // Deopt happened, the result should still be the same.
  assertEquals(expected, wasm.main(argumentValue, wasm.nop2));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.main));
  }
})();

(function TestInlinedI64Params() {
  let builder = new WasmModuleBuilder();
  let funcRefT = builder.addType(makeSig([kWasmI64, kWasmI64], [kWasmI64]));

  builder.addFunction("add", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI64Add]).exportFunc();
  builder.addFunction("sub", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI64Sub]).exportFunc();

  let callerSig =
    makeSig([kWasmI64, kWasmI64, wasmRefType(funcRefT)], [kWasmI64]);

  let inlinee = builder.addFunction("inlinee", callerSig)
    .addBody([
    kExprLocalGet, 0,
    kExprLocalGet, 1,
    kExprLocalGet, 2,
    kExprCallRef, funcRefT,
  ]).exportFunc();

  builder.addFunction("main", callerSig)
  .addBody([
    kExprLocalGet, 0,
    kExprLocalGet, 1,
    kExprLocalGet, 2,
    kExprCallFunction, inlinee.index,
]).exportFunc();

  let wasm = builder.instantiate({}).exports;

  assertEquals(43n, wasm.main(1n, 42n, wasm.add));
  %WasmTierUpFunction(wasm.main);
  assertEquals(43n, wasm.main(1n, 42n, wasm.add));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
  assertEquals(-41n, wasm.main(1n, 42n, wasm.sub));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.main));
  }
  %WasmTierUpFunction(wasm.main);
  assertEquals(43n, wasm.main(1n, 42n, wasm.add));
  assertEquals(-41n, wasm.main(1n, 42n, wasm.sub));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
})();
                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-large-i31ref-constant.js                          0000664 0000000 0000000 00000003160 14746647661 0026256 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --wasm-deopt --turboshaft-wasm
// Flags: --turboshaft-future --liftoff --no-jit-fuzzing

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

const builder = new WasmModuleBuilder();
let calleeSig = builder.addType(
  makeSig([wasmRefType(kWasmI31Ref)], [kWasmI32]));

builder.addFunction("getS", calleeSig).addBody([
  kExprLocalGet, 0, kGCPrefix, kExprI31GetS,
]).exportFunc();

builder.addFunction("getU", calleeSig).addBody([
  kExprLocalGet, 0, kGCPrefix, kExprI31GetU,
]).exportFunc();

builder.addFunction("main", makeSig([wasmRefType(calleeSig)], [kWasmI32]))
.addBody([
  ...wasmI32Const(1689912565),
  kGCPrefix, kExprRefI31,
  kExprLocalGet, 0,
  kExprCallRef, calleeSig,
]).exportFunc();

const instance = builder.instantiate({});
assertEquals(-457571083, instance.exports.main(instance.exports.getS));
%WasmTierUpFunction(instance.exports.main);
// Test value produced by DeoptimizerLiteral constant.
assertEquals(1689912565, instance.exports.main(instance.exports.getU));
if (%IsWasmTieringPredictable()) {
  assertFalse(%IsTurboFanFunction(instance.exports.main));
}
// Test value produced by Liftoff.
assertEquals(1689912565, instance.exports.main(instance.exports.getU));
%WasmTierUpFunction(instance.exports.main);
// Test value produced by Turboshaft.
assertEquals(1689912565, instance.exports.main(instance.exports.getU));
if (%IsWasmTieringPredictable()) {
  assertTrue(%IsTurboFanFunction(instance.exports.main));
}
                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-many-params-many-locals-s128.js                   0000664 0000000 0000000 00000007576 14746647661 0027422 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-deopt --allow-natives-syntax --turboshaft-wasm
// Flags: --experimental-wasm-inlining --liftoff
// Flags: --turboshaft-wasm-instruction-selection-staged
// Flags: --wasm-inlining-ignore-call-counts --no-jit-fuzzing

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestManyParamsManyLocals() {
  // x86-64 has 16 XMM registers, so we need a few values to run out of
  // registers and end up with stack slots.
  let paramCount = 21;
  let builder = new WasmModuleBuilder();
  let calleeParams = new Array(paramCount).fill(kWasmS128);
  let funcRefT = builder.addType(makeSig(calleeParams, [kWasmS128]));

  builder.addFunction("add", funcRefT)
    .addBody(generateCalleeBody(kExprI32x4Add)).exportFunc();
  builder.addFunction("sub", funcRefT)
    .addBody(generateCalleeBody(kExprI32x4Sub)).exportFunc();
  builder.addFunction("max", funcRefT)
    .addBody(generateCalleeBody(kExprI32x4MaxU)).exportFunc();

  let deoptingFct = builder.addFunction(
      "deopting", makeSig([...calleeParams, wasmRefType(funcRefT)], [kWasmI32]))
    .addBody([
      // Push the arguments for the second call from the caller.
      ...pushArgs(paramCount + 1),
      // Create new local arguments for the first call.
      ...createArgs(paramCount),
      kExprLocalGet, paramCount,
      kExprCallRef, funcRefT,
      kExprLocalSet, 2,
      kExprCallRef, funcRefT,
      // Add both call_ref results and sum up the lanes.
      kExprLocalGet, 2,
      ...SimdInstr(kExprI32x4Add),
      kExprLocalTee, 2,
      kSimdPrefix, kExprI32x4ExtractLane, 0,
      kExprLocalGet, 2,
      kSimdPrefix, kExprI32x4ExtractLane, 1,
      kExprLocalGet, 2,
      kSimdPrefix, kExprI32x4ExtractLane, 2,
      kExprLocalGet, 2,
      kSimdPrefix, kExprI32x4ExtractLane, 3,
      kExprI32Add,
      kExprI32Add,
      kExprI32Add,
    ]).exportFunc();

  let mainParams = [kWasmI32, wasmRefType(funcRefT)];
  builder.addFunction("main", makeSig(mainParams, [kWasmI32]))
    .addLocals(kWasmS128, 1)
    .addBody([
      ...createArgs(paramCount),
      kExprLocalGet, 1,
      kExprCallFunction, deoptingFct.index,
  ]).exportFunc();

  // [0, 1, ..., paramCount - 1]
  let values = [...Array(paramCount).keys()];
  let expectedSum = values.reduce((a, b) => a + b) * 4 * 2;
  let expectedDiff = values.reduce((a, b) => a - b) * 4 * 2;
  let expectedMax = (paramCount - 1) * 4 * 2;
  assertEquals(expectedSum, -expectedDiff);

  let wasm = builder.instantiate().exports;
  assertEquals(expectedSum, wasm.main(0, wasm.add));
  %WasmTierUpFunction(wasm.deopting);
  assertEquals(expectedSum, wasm.main(0, wasm.add));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.deopting));
  }
  assertEquals(expectedDiff, wasm.main(0, wasm.sub));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.deopting));
  }

  // Repeat the test but this time with an additional layer of inlining.
  %WasmTierUpFunction(wasm.main);
  assertEquals(expectedSum, wasm.main(0, wasm.add));
  assertEquals(expectedDiff, wasm.main(0, wasm.sub));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
  assertEquals(expectedMax, wasm.main(0, wasm.max));

  function generateCalleeBody(binop) {
    let result = [kExprLocalGet, 0];
    for (let i = 1; i < paramCount; ++i) {
      result.push(kExprLocalGet, i, ...SimdInstr(binop));
    }
    return result;
  }

  function createArgs(paramCount) {
    let result = [];
    for (let i = 0; i < paramCount; ++i) {
      result.push(kExprI32Const, i, kSimdPrefix, kExprI32x4Splat);
    }
    return result;
  }

  function pushArgs(paramCount) {
    let result = [];
    for (let i = 0; i < paramCount; ++i) {
      result.push(kExprLocalGet, i);
    }
    return result;
  }
})();
                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-many-params-tagged.js                             0000664 0000000 0000000 00000013203 14746647661 0025723 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-deopt --allow-natives-syntax --turboshaft-wasm
// Flags: --experimental-wasm-inlining --liftoff --expose-gc
// Flags: --turboshaft-wasm-instruction-selection-staged
// Flags: --wasm-inlining-ignore-call-counts --wasm-inlining-factor=30
// Flags: --wasm-inlining-budget=100000 --no-jit-fuzzing

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// Test deopt with many params with different types, some tagged, some untagged.
(function TestManyParamsTagged() {
  let create = (function() {
    let builder = new WasmModuleBuilder();
    let struct = builder.addStruct([makeField(kWasmI32, false)]);
    let array = builder.addArray(kWasmI32, true);
    builder.addFunction("struct", makeSig([kWasmI32], [wasmRefType(struct)]))
      .addBody([
        kExprLocalGet, 0,
        kGCPrefix, kExprStructNew, struct,
      ]).exportFunc();
    builder.addFunction("array", makeSig([kWasmI32], [wasmRefType(array)]))
      .addBody([
        kExprLocalGet, 0,
        kGCPrefix, kExprArrayNewFixed, array, 1,
      ]).exportFunc();
    return builder.instantiate().exports;
  })();

  let paramCount = 30;
  let builder = new WasmModuleBuilder();
  let struct = builder.addStruct([makeField(kWasmI32, false)]);
  let array = builder.addArray(kWasmI32, true);

  let types = [
    {type: kWasmI32, toI32: [], fromI32: (v) => v},
    {type: wasmRefType(struct), toI32: [kGCPrefix, kExprStructGet, struct, 0],
     fromI32: (v) => create.struct(v)},
    {type: kWasmF64, toI32: [kExprI32SConvertF64], fromI32: (v) => v},
    {type: wasmRefType(array),
     toI32: [kExprI32Const, 0, kGCPrefix, kExprArrayGet, array],
     fromI32: (v) => create.array(v)},
    {type: kWasmF32, toI32: [kExprI32SConvertF32], fromI32: (v) => v},
    {type: kWasmI31Ref, toI32: [kGCPrefix, kExprI31GetS], fromI32: (v) => v},
    {type: kWasmI64, toI32: [kExprI32ConvertI64], fromI32: (v) => BigInt(v)},
  ];

  let calleeParams = new Array(paramCount).fill()
    .map((_, i) => types[i % types.length].type);
  let funcRefT = builder.addType(makeSig(calleeParams, [kWasmI32]));

  let gcImport = builder.addImport("i", "gc", makeSig([], []));
  builder.addFunction("add", funcRefT)
    .addBody(generateCalleeBody(kExprI32Add)).exportFunc();
  builder.addFunction("sub", funcRefT)
    .addBody(generateCalleeBody(kExprI32Sub)).exportFunc();
  builder.addFunction("add2", funcRefT)
    .addBody(generateCalleeBody(kExprI32Add)).exportFunc();
  builder.addFunction("addGC", funcRefT)
    .addBody([
      kExprCallFunction, gcImport,
      ...generateCalleeBody(kExprI32Add)
    ]).exportFunc();

  let mainParams = [...calleeParams, wasmRefType(funcRefT)];
  let main = builder.addFunction("main", makeSig(mainParams, [kWasmI32]))
    .addBody([
      ...pushArgs(paramCount + 1),
      kExprCallRef, funcRefT,
      // Repeat it to make sure that the parameter slots are still valid.
      ...pushArgs(paramCount + 1),
      kExprCallRef, funcRefT,
      // Add both results
      kExprI32Add,
  ]).exportFunc();

  // The outer params just contain an extra dummy param in the beginning, so
  // they don't align with the parameters of the inner function.
  let outerParams = [kWasmI32, ...mainParams];
  builder.addFunction("outerDirect", makeSig(outerParams, [kWasmI32]))
  .addBody([
    ...pushArgs(paramCount + 2),
    kExprCallFunction, main.index,
    kExprReturn,
]).exportFunc();

  // [0, 1, ..., paramCount - 1]
  let values = [...Array(paramCount).keys()];
  let valuesTyped = values.map((_, i) => types[i % types.length].fromI32(i));
  let expectedSum = 2 * values.reduce((a, b) => a + b);
  let expectedDiff = 2 * values.reduce((a, b) => a - b);
  assertEquals(expectedSum, -expectedDiff);

  let wasm = builder.instantiate({i: {gc}}).exports;
  assertEquals(expectedSum, wasm.main(...valuesTyped, wasm.add));
  %WasmTierUpFunction(wasm.main);
  assertEquals(expectedSum, wasm.main(...valuesTyped, wasm.add));
  if (%IsWasmTieringPredictable()) {
   assertTrue(%IsTurboFanFunction(wasm.main));
  }
  assertEquals(expectedDiff, wasm.main(...valuesTyped, wasm.sub));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.main));
  }

  // Repeat the test but this time with an additional layer of inlining.
  assertEquals(expectedSum, wasm.outerDirect(42, ...valuesTyped, wasm.add));
  %WasmTierUpFunction(wasm.outerDirect);
  assertEquals(expectedSum, wasm.outerDirect(42, ...valuesTyped, wasm.add));
  assertEquals(expectedDiff, wasm.outerDirect(42, ...valuesTyped, wasm.sub));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.outerDirect));
  }
  assertEquals(expectedSum, wasm.outerDirect(42, ...valuesTyped, wasm.add2));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.outerDirect));
  }
  %WasmTierUpFunction(wasm.outerDirect);
  assertEquals(expectedSum, wasm.outerDirect(42, ...valuesTyped, wasm.add2));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.outerDirect));
  }
  assertEquals(expectedSum, wasm.outerDirect(42, ...valuesTyped, wasm.addGC));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.outerDirect));
  }

  function generateCalleeBody(binop) {
    let result = [kExprLocalGet, 0, ...types[0].toI32];
    for (let i = 1; i < paramCount; ++i) {
      result.push(kExprLocalGet, i, ...types[i % types.length].toI32, binop);
    }
    return result;
  }

  function pushArgs(paramCount) {
    let result = [];
    for (let i = 0; i < paramCount; ++i) {
      result.push(kExprLocalGet, i);
    }
    return result;
  }
})();
                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-many-params.js                                    0000664 0000000 0000000 00000004137 14746647661 0024500 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-deopt --allow-natives-syntax --turboshaft-wasm
// Flags: --experimental-wasm-inlining --liftoff
// Flags: --turboshaft-wasm-instruction-selection-staged
// Flags: --wasm-inlining-ignore-call-counts --no-jit-fuzzing

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestManyParams() {
  let paramCount = 12;
  let builder = new WasmModuleBuilder();
  let calleeParams = new Array(paramCount).fill(kWasmI32);
  let funcRefT = builder.addType(makeSig(calleeParams, [kWasmI32]));

  builder.addFunction("add", funcRefT)
    .addBody(generateCalleeBody(kExprI32Add)).exportFunc();
  builder.addFunction("sub", funcRefT)
    .addBody(generateCalleeBody(kExprI32Sub)).exportFunc();

  let mainParams = [...calleeParams, wasmRefType(funcRefT)];
  builder.addFunction("main", makeSig(mainParams, [kWasmI32]))
    .addBody([
      ...pushArgs(paramCount + 1),
      kExprCallRef, funcRefT,
  ]).exportFunc();

  // [0, 1, ..., paramCount - 1]
  let values = [...Array(paramCount).keys()];
  let expectedSum = values.reduce((a, b) => a + b);
  let expectedDiff = values.reduce((a, b) => a - b);
  assertEquals(expectedSum, -expectedDiff);

  let wasm = builder.instantiate().exports;
  assertEquals(expectedSum, wasm.main(...values, wasm.add));
  %WasmTierUpFunction(wasm.main);
  assertEquals(expectedSum, wasm.main(...values, wasm.add));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
  assertEquals(expectedDiff, wasm.main(...values, wasm.sub));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.main));
  }


  function generateCalleeBody(binop) {
    let result = [kExprLocalGet, 0];
    for (let i = 1; i < paramCount; ++i) {
      result.push(kExprLocalGet, i, binop);
    }
    return result;
  }

  function pushArgs(paramCount) {
    let result = [];
    for (let i = 0; i < paramCount; ++i) {
      result.push(kExprLocalGet, i);
    }
    return result;
  }
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-many-results.js                                   0000664 0000000 0000000 00000010654 14746647661 0024717 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-deopt --allow-natives-syntax --turboshaft-wasm
// Flags: --experimental-wasm-inlining --liftoff --expose-gc
// Flags: --turboshaft-wasm-instruction-selection-staged
// Flags: --wasm-inlining-ignore-call-counts --wasm-inlining-factor=30
// Flags: --wasm-inlining-budget=100000 --no-jit-fuzzing

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// Test deopt with many results with different types.
(function TestManyResults() {

  let returnCount = 25;
  let builder = new WasmModuleBuilder();
  let struct = builder.addStruct([makeField(kWasmI32, false)]);
  let array = builder.addArray(kWasmI32, true);

  let gcImport = builder.addImport("i", "gc", makeSig([], []));

  let createStruct = builder.addFunction("struct",
      makeSig([kWasmI32], [wasmRefType(struct)]))
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprStructNew, struct,
    ]).exportFunc();
  let createArray = builder.addFunction("array",
      makeSig([kWasmI32], [wasmRefType(array)]))
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprArrayNewFixed, array, 1,
    ]).exportFunc();

  let types = [
    {type: kWasmI32, toI32: [], fromI32: []},
    {type: wasmRefType(struct), toI32: [kGCPrefix, kExprStructGet, struct, 0],
     fromI32: [kExprCallFunction, createStruct.index]},
    {type: kWasmF64, toI32: [kExprI32SConvertF64],
     fromI32: [kExprF64SConvertI32]},
    {type: wasmRefType(array),
     toI32: [kExprI32Const, 0, kGCPrefix, kExprArrayGet, array],
     fromI32: [kExprCallFunction, createArray.index]},
    {type: kWasmF32, toI32: [kExprI32SConvertF32],
     fromI32: [kExprF32SConvertI32]},
    {type: kWasmI31Ref, toI32: [kGCPrefix, kExprI31GetS],
     fromI32: [kGCPrefix, kExprRefI31]},
    {type: kWasmI64, toI32: [kExprI32ConvertI64],
     fromI32: [kExprI64SConvertI32]},
  ];

  let calleeReturns = new Array(returnCount).fill()
    .map((_, i) => types[i % types.length].type);
  let funcRefT = builder.addType(makeSig([], calleeReturns));

  builder.addFunction("one", funcRefT)
    .addBody(generateCalleeBody(1)).exportFunc();
  builder.addFunction("two", funcRefT)
    .addBody(generateCalleeBody(2)).exportFunc();
  builder.addFunction("threeGC", funcRefT)
    .addBody([
      kExprCallFunction, gcImport,
      ...generateCalleeBody(3)
    ]).exportFunc();
  builder.addFunction("four", funcRefT)
    .addBody(generateCalleeBody(4)).exportFunc();

  let main = builder.addFunction("passThrough",
      makeSig([wasmRefType(funcRefT)], calleeReturns))
    .addBody([
      kExprLocalGet, 0,
      kExprCallRef, funcRefT,
  ]).exportFunc();

  builder.addFunction("passThroughExport",
      makeSig([wasmRefType(funcRefT)], [kWasmI32]))
    .addLocals(kWasmI32, 1)
    .addBody([
      kExprLocalGet, 0,
      kExprCallFunction, main.index,
      ...combine(),
    ]).exportFunc();

  let expectedOne = returnCount * (returnCount + 1) / 2;
  let expectedTwo = expectedOne + returnCount;
  let expectedThree = expectedTwo + returnCount;
  let expectedFour = expectedThree + returnCount;

  let wasm = builder.instantiate({i: {gc}}).exports;
  assertEquals(expectedOne, wasm.passThroughExport(wasm.one));
  %WasmTierUpFunction(wasm.passThrough);
  assertEquals(expectedTwo, wasm.passThroughExport(wasm.two));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.passThrough));
  }
  %WasmTierUpFunction(wasm.passThrough);
  assertEquals(expectedThree, wasm.passThroughExport(wasm.threeGC));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.passThrough));
  }
  // This time tier up the outer function.
  %WasmTierUpFunction(wasm.passThroughExport);
  assertEquals(expectedFour, wasm.passThroughExport(wasm.four));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.passThrough));
  }

  function generateCalleeBody(value) {
    let result = [];
    for (let i = 0; i < returnCount; ++i) {
      result.push(...wasmI32Const(value++), ...types[i % types.length].fromI32);
    }
    return result;
  }

  function combine() {
    let result = [];
    for (let i = 0; i < returnCount; ++i) {
      result.push(
        ...types[(returnCount - i - 1) % types.length].toI32,
        kExprLocalGet, 1,
        kExprI32Add,
        kExprLocalSet, 1
      );
    }
    result.push(kExprLocalGet, 1);
    return result;
  }
})();
                                                                                    node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-memory-access.js                                  0000664 0000000 0000000 00000003676 14746647661 0025031 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-deopt --allow-natives-syntax --turboshaft-wasm
// Flags: --experimental-wasm-inlining --liftoff
// Flags: --turboshaft-wasm-instruction-selection-staged --no-jit-fuzzing

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestDeoptMemoryStart() {
  var builder = new WasmModuleBuilder();
  let funcRefT = builder.addType(kSig_i_ii);

  builder.addMemory(1, 1);

  builder.addFunction("add", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
    .exportFunc();
  builder.addFunction("mul", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Mul])
    .exportFunc();


  let mainSig =
    makeSig([kWasmI32, kWasmI32, wasmRefType(funcRefT)], [kWasmI32]);
  builder.addFunction("main", mainSig)
    .addBody([
      // Store some value in the memory.
      kExprI32Const, 24,            // index
      ...wasmI32Const(0x12345678),  // value
      kExprI32StoreMem, 0, 0,
      // Perform the call_ref with potential deopt.
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprCallRef, funcRefT,
      // Load back the value and check that it's the same.
      // Note that the cached memory start should have been invalidated by the
      // call_ref, so this should reload the memory start.
      kExprI32Const, 24,
      kExprI32LoadMem, 0, 0,
      ...wasmI32Const(0x12345678),
      kExprI32Ne,
      kExprIf, kWasmVoid,
        kExprUnreachable,
      kExprEnd,
  ]).exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(42, wasm.main(12, 30, wasm.add));
  %WasmTierUpFunction(wasm.main);
  assertEquals(42, wasm.main(12, 30, wasm.add));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
  assertEquals(360, wasm.main(12, 30, wasm.mul));
})();
                                                                  node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-metrics.js                                        0000664 0000000 0000000 00000004542 14746647661 0023721 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-deopt --allow-natives-syntax --turboshaft-wasm
// Flags: --experimental-wasm-inlining --liftoff
// Flags: --turboshaft-wasm-instruction-selection-staged --no-jit-fuzzing

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestDeoptMetrics() {
  // This can be non-zero in certain variants (e.g. `code_serializer`).
  const initialDeoptCount = %WasmDeoptsExecutedCount();

  let builder = new WasmModuleBuilder();
  let funcRefT = builder.addType(kSig_i_ii);

  builder.addFunction("add", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
    .exportFunc();
  builder.addFunction("mul", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Mul])
    .exportFunc();
  let mainSig =
    makeSig([kWasmI32, kWasmI32, wasmRefType(funcRefT)], [kWasmI32]);
  builder.addFunction("main", mainSig)
    .addLocals(kWasmI32, 1)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprCallRef, funcRefT,
  ]).exportFunc();

  let wasm = builder.instantiate().exports;
  const initialDeoptCountMain = %WasmDeoptsExecutedForFunction(wasm.main);
  assertEquals(initialDeoptCount, %WasmDeoptsExecutedCount());
  assertEquals(42, wasm.main(12, 30, wasm.add));
  %WasmTierUpFunction(wasm.main);
  assertEquals(initialDeoptCount, %WasmDeoptsExecutedCount());
  assertEquals(360, wasm.main(12, 30, wasm.mul));
  assertEquals(initialDeoptCount + 1, %WasmDeoptsExecutedCount());
  %WasmTierUpFunction(wasm.main);
  assertEquals(42, wasm.main(12, 30, wasm.add));
  assertEquals(360, wasm.main(12, 30, wasm.mul));
  assertEquals(initialDeoptCount + 1, %WasmDeoptsExecutedCount());
  assertEquals(0, %WasmDeoptsExecutedForFunction(wasm.add));
  assertEquals(0, %WasmDeoptsExecutedForFunction(wasm.mul));
  assertEquals(initialDeoptCountMain + 1,
               %WasmDeoptsExecutedForFunction(wasm.main));

  // A new instance shares the same counters for deopts.
  let wasm2 = builder.instantiate().exports;
  assertEquals(0, %WasmDeoptsExecutedForFunction(wasm2.add));
  assertEquals(0, %WasmDeoptsExecutedForFunction(wasm2.mul));
  assertEquals(initialDeoptCountMain + 1,
               %WasmDeoptsExecutedForFunction(wasm2.main));
})();
                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-minimal.js                                        0000664 0000000 0000000 00000004322 14746647661 0023675 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-deopt --allow-natives-syntax --turboshaft-wasm
// Flags: --experimental-wasm-inlining --liftoff
// Flags: --turboshaft-wasm-instruction-selection-staged --no-jit-fuzzing

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// Minimal test case for a wasm deopt.
// The following flags can help:
// --trace-deopt-verbose (information about the deopt input and output frames)
// --print-wasm-code (prints some information about the generated deopt data)
// --nodebug-code (keeps the generated code small)
// --code-comments (helpful comments in generated code if enabled in gn args)
(function TestDeoptMinimalCallRef() {
  var builder = new WasmModuleBuilder();
  let funcRefT = builder.addType(kSig_i_ii);

  builder.addFunction("add", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
    .exportFunc();
  builder.addFunction("mul", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Mul])
    .exportFunc();

  let mainSig =
    makeSig([kWasmI32, wasmRefType(funcRefT)], [kWasmI32]);
  builder.addFunction("main", mainSig)
    .addBody([
      kExprI32Const, 12,
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprCallRef, funcRefT,
  ]).exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(42, wasm.main(30, wasm.add));
  %WasmTierUpFunction(wasm.main);
  // tierup.
  assertEquals(42, wasm.main(30, wasm.add));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
  // Non-deopt call succeeded, now causing deopt.
  assertEquals(360, wasm.main(30, wasm.mul));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.main));
  }
  // Deopt happened, executions are now in liftoff.
  assertEquals(42, wasm.main(30, wasm.add));
  // Re-opt.
  %WasmTierUpFunction(wasm.main);
  // There is feedback for both targets, they do not trigger new deopts.
  assertEquals(360, wasm.main(30, wasm.mul));
  assertEquals(42, wasm.main(30, wasm.add));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
})();
                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-multi-instance-different-callee.js                0000664 0000000 0000000 00000004115 14746647661 0030372 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-deopt --allow-natives-syntax --no-jit-fuzzing --liftoff
// Flags: --turboshaft-wasm-instruction-selection-staged --turboshaft-wasm

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

const builder = new WasmModuleBuilder();
let calleeSig = builder.addType(makeSig([], [kWasmI32]));
let mainSig = builder.addType(makeSig([wasmRefType(calleeSig)], [kWasmI32]));

builder.addFunction("a", calleeSig)
  .exportFunc()
  .addBody([kExprI32Const, 1]);

builder.addFunction("b", calleeSig)
  .exportFunc()
  .addBody([kExprI32Const, 2]);

builder.addFunction("main", mainSig).exportFunc()
  .addBody([
    kExprLocalGet, 0,
    kExprCallRef, calleeSig,
  ]);

const instanceA = builder.instantiate({});
const instanceB = builder.instantiate({});

instanceA.exports.main(instanceA.exports.a);
%WasmTierUpFunction(instanceA.exports.main);
instanceA.exports.main(instanceA.exports.a);
if (%IsWasmTieringPredictable()) {
  assertTrue(%IsTurboFanFunction(instanceA.exports.main));
}

// This triggers a deopt as the callee is not function a and the optimized code
// is shared with instanceA.
instanceB.exports.main(instanceB.exports.b);
if (%IsWasmTieringPredictable()) {
  assertFalse(%IsTurboFanFunction(instanceB.exports.main));
}
// This re-optimizes the function with the feedback from instanceB.
// To prevent deopt loops, it must also keep the feedback from instanceA.
%WasmTierUpFunction(instanceB.exports.main);
instanceB.exports.main(instanceB.exports.b);
if (%IsWasmTieringPredictable()) {
  assertTrue(%IsTurboFanFunction(instanceA.exports.main));
}
// Calling a or b does not trigger a deopt.
instanceA.exports.main(instanceA.exports.a);
instanceA.exports.main(instanceA.exports.b);
instanceB.exports.main(instanceB.exports.a);
instanceB.exports.main(instanceB.exports.b);
if (%IsWasmTieringPredictable()) {
  assertTrue(%IsTurboFanFunction(instanceA.exports.main));
  assertTrue(%IsTurboFanFunction(instanceB.exports.main));
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-multi-instance-inlined.js                         0000664 0000000 0000000 00000010240 14746647661 0026617 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-deopt --allow-natives-syntax --no-jit-fuzzing --liftoff
// Flags: --turboshaft-wasm-instruction-selection-staged --turboshaft-wasm
// Flags: --wasm-inlining-ignore-call-counts --wasm-inlining-factor=15

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function TestMultipleModulesUninlineableTargets() {
  const builder = new WasmModuleBuilder();
  let calleeSig = builder.addType(makeSig([], [kWasmI32]));
  let mainSig = builder.addType(makeSig([wasmRefType(calleeSig)], [kWasmI32]));
  let callee0 = builder.addFunction("callee_0", calleeSig)
    .exportFunc()
    .addBody([kExprI32Const, 42]);

  let inlinee = builder.addFunction("inlinee", mainSig).addBody([
    // Trigger the deopt.
    kExprLocalGet, 0,
    kExprCallRef, calleeSig,
  ]);

  builder.addFunction("main", mainSig).exportFunc()
    .addBody([
      // Call the inlinee.
      kExprLocalGet, 0,
      kExprCallFunction, inlinee.index,
      // Just performing a call which triggers an update of the feedback vector.
      kExprRefFunc, callee0.index,
      kExprCallRef, calleeSig,
      kExprI32Add,
    ]);

  const instance = builder.instantiate({});

  assertEquals(84, instance.exports.main(instance.exports.callee_0));
  %WasmTierUpFunction(instance.exports.main);
  assertEquals(84, instance.exports.main(instance.exports.callee_0));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(instance.exports.main));
  }

  const instance2 = builder.instantiate({});
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(instance2.exports.main));
  }
  assertEquals(84, instance2.exports.main(instance.exports.callee_0));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(instance2.exports.main));
  }
  // Run it one more time, so that the call count to inlinee is > 0 for
  // instance2 as otherwise the feedback doesn't get updated.
  assertEquals(84, instance2.exports.main(instance.exports.callee_0));
  %WasmTierUpFunction(instance2.exports.main);
  assertEquals(84, instance2.exports.main(instance.exports.callee_0));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(instance2.exports.main));
  }
})();

(function TestMultipleModulesUninlineableTargetsRecursiveFrames() {
  const builder = new WasmModuleBuilder();
  let calleeSig = builder.addType(makeSig([], [kWasmI32]));
  let mainSig =
    builder.addType(makeSig([kWasmI32, wasmRefType(calleeSig)], [kWasmI32]));
  let callee0 = builder.addFunction("callee_0", calleeSig)
    .exportFunc()
    .addBody([kExprI32Const, 42]);

  let mainIndex = callee0.index + 1;
  let main = builder.addFunction("main", mainSig).exportFunc()
    .addBody([
      // Call itself recursively.
      kExprLocalGet, 0,
      kExprIf, kWasmVoid,
        kExprLocalGet, 0,
        kExprI32Const, 1,
        kExprI32Sub,
        kExprLocalGet, 1,
        kExprCallFunction, mainIndex,
        kExprDrop,
      kExprEnd,
      // Perform the deopting call_ref. (Only the inner-most frame will trigger
      // it and deopt the outer frames for all inlined frames.)
      kExprLocalGet, 1,
      kExprCallRef, calleeSig,
    ]);
  assertEquals(mainIndex, main.index);

  const instance = builder.instantiate({});

  assertEquals(42, instance.exports.main(7, instance.exports.callee_0));
  %WasmTierUpFunction(instance.exports.main);
  assertEquals(42, instance.exports.main(7, instance.exports.callee_0));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(instance.exports.main));
  }

  const instance2 = builder.instantiate({});
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(instance2.exports.main));
  }
  assertEquals(42, instance2.exports.main(7, instance.exports.callee_0));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(instance2.exports.main));
  }
  %WasmTierUpFunction(instance2.exports.main);
  assertEquals(42, instance2.exports.main(7, instance.exports.callee_0));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(instance2.exports.main));
  }
})();
                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-multi-instance.js                                 0000664 0000000 0000000 00000006134 14746647661 0025206 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-deopt --allow-natives-syntax --no-jit-fuzzing --liftoff
// Flags: --turboshaft-wasm-instruction-selection-staged
// Flags: --wasm-inlining-call-indirect --turboshaft-wasm

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function TestCallRef() {
  const builder = new WasmModuleBuilder();
  let calleeSig = builder.addType(makeSig([], [kWasmI32]));
  let mainSig = builder.addType(makeSig([wasmRefType(calleeSig)], [kWasmI32]));
  builder.addFunction("callee_0", calleeSig)
    .exportFunc()
    .addBody([kExprI32Const, 42]);

  builder.addFunction("main", mainSig).exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprCallRef, calleeSig,
    ]);

  const instance = builder.instantiate({});

  instance.exports.main(instance.exports.callee_0);
  %WasmTierUpFunction(instance.exports.main);
  instance.exports.main(instance.exports.callee_0);
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(instance.exports.main));
  }

  const instance2 = builder.instantiate({});
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(instance2.exports.main));
  }
  instance2.exports.main(instance.exports.callee_0);
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(instance2.exports.main));
  }
  %WasmTierUpFunction(instance2.exports.main);
  instance2.exports.main(instance.exports.callee_0);
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(instance2.exports.main));
  }
})();

(function TestCallIndirect() {
  const builder = new WasmModuleBuilder();
  let calleeSig = builder.addType(makeSig([], [kWasmI32]));
  let mainSig = builder.addType(makeSig([kWasmI32], [kWasmI32]));
  let callee1 = builder.addFunction("callee1", calleeSig)
    .exportFunc()
    .addBody([kExprI32Const, 42]);
  let callee2 = builder.addFunction("callee2", calleeSig)
    .exportFunc()
    .addBody([kExprI32Const, 10]);

  let table = builder.addTable(kWasmFuncRef, 2);
  builder.addActiveElementSegment(table.index, wasmI32Const(0), [
      [kExprRefFunc, callee1.index],
      [kExprRefFunc, callee2.index],
    ], kWasmFuncRef);


  builder.addFunction("main", mainSig).exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprCallIndirect, calleeSig, table.index,
    ]);

  const instance = builder.instantiate({});

  instance.exports.main(0);
  %WasmTierUpFunction(instance.exports.main);
  instance.exports.main(0);
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(instance.exports.main));
  }

  const instance2 = builder.instantiate({});
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(instance2.exports.main));
  }
  instance2.exports.main(1);
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(instance2.exports.main));
  }
  %WasmTierUpFunction(instance2.exports.main);
  instance2.exports.main(1);
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(instance2.exports.main));
  }
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-multiple.js                                       0000664 0000000 0000000 00000004207 14746647661 0024104 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-deopt --allow-natives-syntax --turboshaft-wasm
// Flags: --experimental-wasm-inlining --liftoff
// Flags: --turboshaft-wasm-instruction-selection-staged --no-jit-fuzzing

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// Simple test containing more than one deopt point.
(function TestMultipleDeoptPoints() {
  var builder = new WasmModuleBuilder();
  let funcRefT = builder.addType(kSig_i_ii);

  builder.addFunction("add", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
    .exportFunc();
  builder.addFunction("mul", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Mul])
    .exportFunc();

  let mainSig = makeSig(
    [kWasmI32, kWasmI32, wasmRefType(funcRefT), kWasmI32,
     wasmRefType(funcRefT)], [kWasmI32]);

  builder.addFunction("main", mainSig)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprCallRef, funcRefT,
      kExprLocalGet, 3,
      kExprLocalGet, 4,
      kExprCallRef, funcRefT,
  ]).exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals((1 + 2) * 3, wasm.main(1, 2, wasm.add, 3, wasm.mul));
  %WasmTierUpFunction(wasm.main);
  assertEquals((1 + 2) * 3, wasm.main(1, 2, wasm.add, 3, wasm.mul));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
  // New target on 2nd call_ref.
  assertEquals((1 + 2) + 3, wasm.main(1, 2, wasm.add, 3, wasm.add));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.main));
  }
  %WasmTierUpFunction(wasm.main);
  // New target on 1st call_ref.
  assertEquals((1 * 2) * 3, wasm.main(1, 2, wasm.mul, 3, wasm.mul));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.main));
  }
  %WasmTierUpFunction(wasm.main);
  // New combination but no new targets.
  assertEquals((1 * 2) + 3, wasm.main(1, 2, wasm.mul, 3, wasm.add));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
})();
                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-nan.js                                            0000664 0000000 0000000 00000012743 14746647661 0023031 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-deopt --allow-natives-syntax --turboshaft-wasm
// Flags: --experimental-wasm-inlining --liftoff
// Flags: --turboshaft-wasm-instruction-selection-staged --no-jit-fuzzing

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestDeoptSignalingNanFloat32Literal() {
  var builder = new WasmModuleBuilder();
  let funcRefT = builder.addType(makeSig([kWasmF32], [kWasmI32]));

  builder.addFunction("justOne", funcRefT)
    .addBody([kExprI32Const, 1])
    .exportFunc();
  builder.addFunction("reinterpretF32", funcRefT)
    .addBody([kExprLocalGet, 0, kExprI32ReinterpretF32])
    .exportFunc();

  let mainSig =
    makeSig([wasmRefType(funcRefT)], [kWasmI32]);
  builder.addFunction("main", mainSig)
    .addBody([
      ...wasmF32ConstSignalingNaN(),
      kExprLocalGet, 0,
      kExprCallRef, funcRefT,
  ]).exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(1, wasm.main(wasm.justOne));
  %WasmTierUpFunction(wasm.main);
  assertEquals(1, wasm.main(wasm.justOne));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
  assertEquals(0x7fa7a1b9, wasm.main(wasm.reinterpretF32));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.main));
  }
  %WasmTierUpFunction(wasm.main);
  assertEquals(0x7fa7a1b9, wasm.main(wasm.reinterpretF32));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
})();

(function TestDeoptSignalingNanFloat32Value() {
  var builder = new WasmModuleBuilder();
  let funcRefT = builder.addType(makeSig([kWasmF32], [kWasmI32]));
  let mem = builder.addMemory(1, 1);
  builder.addActiveDataSegment(
    mem.index, [kExprI32Const, 0], [0xb9, 0xa1, 0xa7, 0x7f]);

  builder.addFunction("justOne", funcRefT)
    .addBody([kExprI32Const, 1])
    .exportFunc();
  builder.addFunction("reinterpretF32", funcRefT)
    .addBody([kExprLocalGet, 0, kExprI32ReinterpretF32])
    .exportFunc();

  let mainSig =
    makeSig([wasmRefType(funcRefT)], [kWasmI32]);
  builder.addFunction("main", mainSig)
    .addBody([
      kExprI32Const, 0,
      kExprF32LoadMem, 0, 0,
      kExprLocalGet, 0,
      kExprCallRef, funcRefT,
  ]).exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(1, wasm.main(wasm.justOne));
  %WasmTierUpFunction(wasm.main);
  assertEquals(1, wasm.main(wasm.justOne));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
  assertEquals(0x7fa7a1b9, wasm.main(wasm.reinterpretF32));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.main));
  }
  %WasmTierUpFunction(wasm.main);
  assertEquals(0x7fa7a1b9, wasm.main(wasm.reinterpretF32));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
})();

(function TestDeoptSignalingNanFloat64Literal() {
  var builder = new WasmModuleBuilder();
  let funcRefT = builder.addType(makeSig([kWasmF64], [kWasmI64]));

  builder.addFunction("justOne", funcRefT)
    .addBody([kExprI64Const, 1])
    .exportFunc();
  builder.addFunction("reinterpretF64", funcRefT)
    .addBody([kExprLocalGet, 0, kExprI64ReinterpretF64])
    .exportFunc();

  let mainSig =
    makeSig([wasmRefType(funcRefT)], [kWasmI64]);
  builder.addFunction("main", mainSig)
    .addBody([
      ...wasmF64ConstSignalingNaN(),
      kExprLocalGet, 0,
      kExprCallRef, funcRefT,
  ]).exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(1n, wasm.main(wasm.justOne));
  %WasmTierUpFunction(wasm.main);
  assertEquals(1n, wasm.main(wasm.justOne));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
  assertEquals(0x7ff4000000000000n, wasm.main(wasm.reinterpretF64));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.main));
  }
  %WasmTierUpFunction(wasm.main);
  assertEquals(0x7ff4000000000000n, wasm.main(wasm.reinterpretF64));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
})();

(function TestDeoptSignalingNanFloat64Value() {
  var builder = new WasmModuleBuilder();
  let funcRefT = builder.addType(makeSig([kWasmF64], [kWasmI64]));
  let mem = builder.addMemory(1, 1);
  builder.addActiveDataSegment(
    mem.index, [kExprI32Const, 0],
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf4, 0x7f]);

  builder.addFunction("justOne", funcRefT)
    .addBody([kExprI64Const, 1])
    .exportFunc();
  builder.addFunction("reinterpretF32", funcRefT)
    .addBody([kExprLocalGet, 0, kExprI64ReinterpretF64])
    .exportFunc();

  let mainSig =
    makeSig([wasmRefType(funcRefT)], [kWasmI64]);
  builder.addFunction("main", mainSig)
    .addBody([
      kExprI32Const, 0,
      kExprF64LoadMem, 0, 0,
      kExprLocalGet, 0,
      kExprCallRef, funcRefT,
  ]).exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(1n, wasm.main(wasm.justOne));
  %WasmTierUpFunction(wasm.main);
  assertEquals(1n, wasm.main(wasm.justOne));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
  assertEquals(0x7ff4000000000000n, wasm.main(wasm.reinterpretF32));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.main));
  }
  %WasmTierUpFunction(wasm.main);
  assertEquals(0x7ff4000000000000n, wasm.main(wasm.reinterpretF32));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
})();
                             node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-non-inlineable-target.js                          0000664 0000000 0000000 00000007601 14746647661 0026430 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-deopt --allow-natives-syntax --turboshaft-wasm --liftoff
// Flags: --experimental-wasm-inlining
// Flags: --turboshaft-wasm-instruction-selection-staged --no-jit-fuzzing
// Flags: --wasm-inlining-call-indirect

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function TestDeoptWithNonInlineableTargetCallRef() {
  var builder = new WasmModuleBuilder();
  let funcRefT = builder.addType(kSig_i_ii);

  let importMul = builder.addImport('m', 'mul', funcRefT);
  builder.addExport('mul', importMul);
  let mul = (a, b) => a * b;

  builder.addFunction('add', funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
    .exportFunc();

  let mainSig =
    makeSig([kWasmI32, wasmRefType(funcRefT)], [kWasmI32]);
  builder.addFunction('main', mainSig)
    .addBody([
      kExprI32Const, 12,
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprCallRef, funcRefT,
  ]).exportFunc();

  let wasm = builder.instantiate({m: {mul}}).exports;
  assertEquals(42, wasm.main(30, wasm.add));
  %WasmTierUpFunction(wasm.main);
  // Tier-up.
  assertEquals(42, wasm.main(30, wasm.add));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
  // Non-deopt call succeeded, now causing deopt with imported function.
  assertEquals(360, wasm.main(30, wasm.mul));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.main));
  }
  // Deopt happened, executions are now in Liftoff.
  assertEquals(42, wasm.main(30, wasm.add));
  // Re-opt.
  %WasmTierUpFunction(wasm.main);
  // There should be feedback for both targets (one of them being
  // non-inlineable), they should not trigger new deopts.
  assertEquals(360, wasm.main(30, wasm.mul));
  assertEquals(42, wasm.main(30, wasm.add));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
})();

(function TestDeoptWithNonInlineableTargetCallIndirect() {
  var builder = new WasmModuleBuilder();
  let funcRefT = builder.addType(kSig_i_ii);

  let importMul = builder.addImport('m', 'mul', funcRefT);
  builder.addExport('mul', importMul);
  let mul = (a, b) => a * b;

  let add = builder.addFunction('add', funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
    .exportFunc();

  let table = builder.addTable(kWasmFuncRef, 2);
  builder.addActiveElementSegment(table.index, wasmI32Const(0), [
    [kExprRefFunc, add.index],
    [kExprRefFunc, importMul],
  ], kWasmFuncRef);

  let mainSig =
    makeSig([kWasmI32, kWasmI32, kWasmI32], [kWasmI32]);
  builder.addFunction('main', mainSig)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprCallIndirect, funcRefT, table.index,
  ]).exportFunc();

  let wasm = builder.instantiate({m: {mul}}).exports;

  let addTableIndex = 0;
  let mulTableIndex = 1;
  assertEquals(42, wasm.main(12, 30, addTableIndex));
  %WasmTierUpFunction(wasm.main);
  // Tier-up.
  assertEquals(42, wasm.main(12, 30, addTableIndex));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
  // Non-deopt call succeeded, now causing deopt with imported function.
  assertEquals(360, wasm.main(12, 30, mulTableIndex));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.main));
  }
  // Deopt happened, executions are now in Liftoff.
  assertEquals(42, wasm.main(12, 30, addTableIndex));
  // Re-opt.
  %WasmTierUpFunction(wasm.main);
  // There should be feedback for both targets (one of them being
  // non-inlineable), they should not trigger new deopts.
  assertEquals(360, wasm.main(12, 30, mulTableIndex));
  assertEquals(42, wasm.main(12, 30, addTableIndex));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
})();
                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-non-inlined-target.js                             0000664 0000000 0000000 00000004441 14746647661 0025747 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-deopt --allow-natives-syntax --turboshaft-wasm
// Flags: --experimental-wasm-inlining --liftoff
// Flags: --turboshaft-wasm-instruction-selection-staged --no-jit-fuzzing

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestNonInlinedTarget() {
  let builder = new WasmModuleBuilder();
  let funcRefT = builder.addType(makeSig([kWasmI32, kWasmI32], [kWasmI32]));

  builder.addFunction("add", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add]).exportFunc();
  builder.addFunction("sub", funcRefT)
  .addBody([
    // Some useless instructions to make this non-inlined due to size.
    ...wasmS128Const(100, 200), kExprDrop,
    ...wasmS128Const(100, 200), kExprDrop,
    ...wasmS128Const(100, 200), kExprDrop,
    ...wasmS128Const(100, 200), kExprDrop,
    kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Sub]).exportFunc();
  builder.addFunction("mul", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Mul]).exportFunc();

  let mainParams = [kWasmI32, kWasmI32, wasmRefType(funcRefT)];
  builder.addFunction("main", makeSig(mainParams, [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprCallRef, funcRefT,
  ]).exportFunc();

  let wasm = builder.instantiate().exports;
  // Add call feedback for add().
  assertEquals(30, wasm.main(10, 20, wasm.add));
  %WasmTierUpFunction(wasm.main);
  assertEquals(30, wasm.main(10, 20, wasm.add));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
  // Call with new target causing a deopt.
  assertEquals(-10, wasm.main(10, 20, wasm.sub));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.main));
  }
  // Re-opt. Due to the size of sub(), the target will not be inlined.
  // This causes sub() to take the slow call_ref implementation and no deopt
  // point is created.
  %WasmTierUpFunction(wasm.main);
  // Calling with a new call target therefore doesn't trigger a deopt.
  assertEquals(200, wasm.main(10, 20, wasm.mul));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
})();
                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-signal-handler.js                                 0000664 0000000 0000000 00000003327 14746647661 0025143 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-deopt --allow-natives-syntax --turboshaft-wasm
// Flags: --experimental-wasm-inlining --liftoff
// Flags: --turboshaft-wasm-instruction-selection-staged

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// The signal handler itself is completely unrelated to deopts. Still, when
// performing a deopt, the g_thread_in_wasm_code needs to be unset when calling
// into the deoptimizer.
(function TestDeoptSignalHandler() {
  var builder = new WasmModuleBuilder();
  let funcRefT = builder.addType(kSig_i_ii);

  builder.addFunction("add", funcRefT)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
    .exportFunc();
  builder.addFunction("zero", funcRefT)
    .addBody([kExprI32Const, 0])
    .exportFunc();


  let mainSig =
    makeSig([kWasmI32, kWasmI32, wasmRefType(funcRefT)], [kWasmI32]);
  builder.addFunction("main", mainSig)
    .addLocals(kWasmI32, 1)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprCallRef, funcRefT,
      kExprLocalTee, 3,
      kExprI32Eqz,
      kExprIf, kWasmVoid,
        kExprRefNull, kArrayRefCode,
        kGCPrefix, kExprArrayLen, // traps,
        kExprUnreachable,
      kExprEnd,
      kExprLocalGet, 3,
  ]).exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(42, wasm.main(12, 30, wasm.add));
  %WasmTierUpFunction(wasm.main);
  assertEquals(42, wasm.main(12, 30, wasm.add));
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.main));
  }
  assertThrows(() => wasm.main(12, 30, wasm.zero));
})();
                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-tail-call-parent-frame.js                         0000664 0000000 0000000 00000004271 14746647661 0026473 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-deopt --allow-natives-syntax --turboshaft-wasm
// Flags: --experimental-wasm-inlining --liftoff --no-jit-fuzzing
// Flags: --turboshaft-wasm-instruction-selection-staged
// Flags: --wasm-inlining-ignore-call-counts --wasm-inlining-factor=15

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// This test case covers a bug where a return call would result in not adding
// the parent FrameState to the deopt node. It is correct that the frame with
// the return call should be skipped (due to the nature of tail calls), however,
// any inlined parent frames of the return call (in this case the main function)
// need to be included.
//
// So, in this particular case at the deopt there should be a FrameState for:
// - inlinee1 (just prior to the callRef)
// - main (just behind the call) as a parent of inlinee1's FrameState
// But no FrameState for inlinee2.
(function TestDeoptInlinedReturnCall() {
  var builder = new WasmModuleBuilder();
  let funcRefT = builder.addType(kSig_v_v);

  builder.addFunction("c1", funcRefT).addBody([]).exportFunc();
  builder.addFunction("c2", funcRefT).addBody([]).exportFunc();

  let inlineeSig = makeSig([wasmRefType(funcRefT)], []);
  let inlinee1 = builder.addFunction("inlinee1", inlineeSig).addBody([
    kExprLocalGet, 0,
    kExprCallRef, funcRefT, // the deopt point.
  ]);
  let inlinee2 = builder.addFunction("inlinee2", inlineeSig).addBody([
    kExprLocalGet, 0,
    kExprReturnCall, inlinee1.index,
  ]);

  let mainSig =
    makeSig([wasmRefType(funcRefT)], [kWasmI32]);
  builder.addFunction("main", mainSig)
    .addLocals(kWasmI32, 1)
    .addBody([
      ...wasmI32Const(1234567),
      kExprLocalSet, 1,
      kExprLocalGet, 0,
      kExprCallFunction, inlinee2.index,
      kExprLocalGet, 1,
  ]).exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(1234567, wasm.main(wasm.c1));
  %WasmTierUpFunction(wasm.main);
  assertEquals(1234567, wasm.main(wasm.c2));
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.main));
  }
})();
                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-untagged-parameters-s128.js                       0000664 0000000 0000000 00000006201 14746647661 0026677 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-staging --wasm-deopt --turboshaft-wasm --liftoff
// Flags: --wasm-inlining-factor=15 --allow-natives-syntax --no-jit-fuzzing

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

// This test case covers a bug where the deoptimizer didn't correctly count the
// amount of parameter stack slots if there aren't any tagged stack slots
// present and there is at least one S128 parameter passed via stack slots.
// This test case reproduces this exact situation on x64, so all comments assume
// wasm calling conventions on x64.

const builder = new WasmModuleBuilder();
let calleeSig = builder.addType(makeSig([kWasmI32], [kWasmI32]));
let callee0 = builder.addFunction("callee0", calleeSig).addBody([
  kExprLocalGet, 0,
]);
let callee1 = builder.addFunction("callee1", calleeSig).addBody([
  kExprLocalGet, 0,
]);

let $global0 = builder.addGlobal(kWasmI32, true, false, wasmI32Const(0));
let $table0 = builder.addTable(kWasmFuncRef, 2, 2);
let $segment0 = builder.addActiveElementSegment($table0.index, wasmI32Const(0),
  [[kExprRefFunc, callee0.index], [kExprRefFunc, callee1.index]], kWasmFuncRef);

let fctToOptimize = builder.addFunction("fctToOptimize", makeSig(
    [ // Parameters
      // 6 S128 values passed in registers xmm1 - xmm6 (see wasm-linkage.h).
      kWasmS128, kWasmS128, kWasmS128, kWasmS128, kWasmS128, kWasmS128,
      // 1 S128 value passed on the stack needing 2! stack slots.
      kWasmS128,
      // 6 i32 values passed in general purpose registers.
      kWasmI32, kWasmI32, kWasmI32, kWasmI32, kWasmI32, kWasmI32,
      // 1 i32 value passed on the stack needing 1 stack slot.
      kWasmI32
    ],
    [kWasmI32]))
  .addBody([
    // Perform a call to either callee0 or callee1 and pass the i32 value from
    // the stack to the callee. Both callees will simply return that value.
    kExprLocalGet, 13,
    kExprGlobalGet, $global0.index,
    kExprTableGet, $table0.index,
    kGCPrefix, kExprRefCast, calleeSig,
    kExprCallRef, calleeSig,
  ]).exportFunc();

builder.addFunction("main", kSig_i_i).addBody([
    kExprLocalGet, 0,  // $var0
    kExprGlobalSet, $global0.index,
    kExprI32Const, 0,
    kSimdPrefix, kExprI8x16Splat,
    kExprI32Const, 0,
    kSimdPrefix, kExprI8x16Splat,
    kExprI32Const, 0,
    kSimdPrefix, kExprI8x16Splat,
    kExprI32Const, 0,
    kSimdPrefix, kExprI8x16Splat,
    kExprI32Const, 0,
    kSimdPrefix, kExprI8x16Splat,
    kExprI32Const, 0,
    kSimdPrefix, kExprI8x16Splat,
    kExprI32Const, 0,
    kSimdPrefix, kExprI8x16Splat,
    kExprI32Const, 2,
    ...wasmI32Const(3),
    ...wasmI32Const(4),
    kExprI32Const, 5,
    ...wasmI32Const(6),
    kExprI32Const, 7,
    // Pass the call index as the last parameter which will be passed via a
    // stack slot.
    kExprLocalGet, 0,
    kExprCallFunction, fctToOptimize.index,
  ]).exportFunc();


const instance = builder.instantiate({});
assertEquals(0, instance.exports.main(0));
%WasmTierUpFunction(instance.exports.fctToOptimize);
assertEquals(1, instance.exports.main(1));
                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-untagged-parameters.js                            0000664 0000000 0000000 00000003421 14746647661 0026205 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-staging --allow-natives-syntax --turboshaft-wasm --wasm-deopt
// Flags: --liftoff

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function TestDeoptWithUntaggedStackSlotsOnly() {
  const builder = new WasmModuleBuilder();
  let calleeSig = builder.addType(kSig_v_v);

  let callee0 = builder.addFunction("c0", kSig_v_v).addBody([]);
  let callee1 = builder.addFunction("c1", kSig_v_v).addBody([]);

  let $table0 = builder.addTable(wasmRefNullType(calleeSig), 2, 2);
  builder.addActiveElementSegment($table0.index, wasmI32Const(0),
    [[kExprRefFunc, callee0.index], [kExprRefFunc, callee1.index]],
    wasmRefNullType(calleeSig));

  // The function uses the first argument as the call target in the table and
  // then adds up all the parameters. The call_ref with the callee is only used
  // to trigger the deopt.
  let mainSig = builder.addType(makeSig([
    kWasmI32, kWasmI32, kWasmI32, kWasmI32, kWasmI32, kWasmI32, kWasmI32],
    [kWasmI32]));
  builder.addFunction("main", mainSig).addBody([
    kExprLocalGet, 0,
    kExprTableGet, $table0.index,
    kExprCallRef, calleeSig,
    kExprLocalGet, 0,
    kExprLocalGet, 1,
    kExprLocalGet, 2,
    kExprLocalGet, 3,
    kExprLocalGet, 4,
    kExprLocalGet, 5,
    kExprLocalGet, 6,
    kExprI32Add,
    kExprI32Add,
    kExprI32Add,
    kExprI32Add,
    kExprI32Add,
    kExprI32Add,
  ]).exportFunc();

  const instance = builder.instantiate({});
  const wasm = instance.exports;
  assertEquals(0+1+2+3+4+5+6, wasm.main(0, 1, 2, 3, 4, 5, 6));
  %WasmTierUpFunction(wasm.main);
  assertEquals(1+1+2+3+4+5+6, wasm.main(1, 1, 2, 3, 4, 5, 6));
})();
                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/wasm/deopt/deopt-value-types.js                                    0000664 0000000 0000000 00000016326 14746647661 0024534 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-deopt --allow-natives-syntax --turboshaft-wasm
// Flags: --experimental-wasm-inlining --liftoff
// Flags: --turboshaft-wasm-instruction-selection-staged --no-jit-fuzzing

// Test for different types of stack, local and literal values.
d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestDeoptTypesLiteralsInLocals() {
  var builder = new WasmModuleBuilder();
  let funcRefT = builder.addType(kSig_v_v);

  builder.addFunction("nop1", funcRefT).addBody([]).exportFunc();
  builder.addFunction("nop2", funcRefT).addBody([]).exportFunc();

  let mainSig = makeSig([wasmRefType(funcRefT)], [kWasmF64]);

  builder.addFunction("literals", mainSig)
    .addLocals(kWasmI32, 1)
    .addLocals(kWasmI64, 1)
    .addLocals(kWasmF32, 1)
    .addLocals(kWasmF64, 1)
    .addLocals(kWasmI31Ref, 2)
    .addLocals(kWasmS128, 1)
    .addBody([
      // Initialize the locals with non-default literal values.
      ...wasmI32Const(32),
      kExprLocalSet, 1,
      ...wasmI64Const(64),
      kExprLocalSet, 2,
      ...wasmF32Const(3.2),
      kExprLocalSet, 3,
      ...wasmF64Const(6.4),
      kExprLocalSet, 4,
      ...wasmI32Const(31),
      kGCPrefix, kExprRefI31,
      kExprLocalSet, 5,
      kExprRefNull, kI31RefCode,
      kExprLocalSet, 6,
      ...wasmS128Const(127, 129),
      kExprLocalSet, 7,

      // Perform the call_ref.
      kExprLocalGet, 0,
      kExprCallRef, funcRefT,

      // Use the locals in the now potentially deoptimized execution.
      kExprLocalGet, 1,
      kExprF64SConvertI32,
      kExprLocalGet, 2,
      kExprF64SConvertI64,
      kExprLocalGet, 3,
      kExprF64ConvertF32,
      kExprLocalGet, 4,
      kExprLocalGet, 5,
      kGCPrefix, kExprI31GetS,
      kExprF64SConvertI32,
      kExprLocalGet, 6,
      kExprRefIsNull,
      kExprF64SConvertI32,
      kExprLocalGet, 7,
      kSimdPrefix, kExprF64x2ExtractLane, 0,
      kExprLocalGet, 7,
      kSimdPrefix, kExprF64x2ExtractLane, 1,
      kExprF64Add,
      kExprF64Add,
      kExprF64Add,
      kExprF64Add,
      kExprF64Add,
      kExprF64Add,
      kExprF64Add,
  ]).exportFunc();

  let wasm = builder.instantiate().exports;
  let expected = 32 + 64 + 3.2 + 6.4 + 31 + 1 + 127 + 129;
  let delta = 1e-4;
  assertEqualsDelta(expected, wasm.literals(wasm.nop1), delta);
  %WasmTierUpFunction(wasm.literals);
  assertEqualsDelta(expected, wasm.literals(wasm.nop1), delta);
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.literals));
  }
  // Deopt happened, the result should still be the same.
  assertEqualsDelta(expected, wasm.literals(wasm.nop2), delta);
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.literals));
  }
})();

(function TestDeoptTypesLiteralsOnValueStack() {
  var builder = new WasmModuleBuilder();
  let funcRefT = builder.addType(kSig_v_v);

  builder.addFunction("nop1", funcRefT).addBody([]).exportFunc();
  builder.addFunction("nop2", funcRefT).addBody([]).exportFunc();

  let mainSig = makeSig([wasmRefType(funcRefT)], [kWasmF64]);

  builder.addFunction("literals", mainSig)
    .addLocals(kWasmI32, 1)
    .addLocals(kWasmI64, 1)
    .addLocals(kWasmF32, 1)
    .addLocals(kWasmF64, 1)
    .addLocals(kWasmI31Ref, 2)
    .addLocals(kWasmS128, 1)
    .addBody([
      ...wasmI32Const(32),
      ...wasmI64Const(64),
      ...wasmF32Const(3.2),
      ...wasmF64Const(6.4),
      ...wasmI32Const(31),
      kGCPrefix, kExprRefI31,
      kExprRefNull, kI31RefCode,
      ...wasmS128Const(127, 129),

      // Perform the call_ref.
      kExprLocalGet, 0,
      kExprCallRef, funcRefT,

      // Use the values.
      kExprLocalSet, 7,
      kExprLocalSet, 6,
      kExprLocalSet, 5,
      kExprLocalSet, 4,
      kExprLocalSet, 3,
      kExprLocalSet, 2,
      kExprF64SConvertI32,
      kExprLocalGet, 2,
      kExprF64SConvertI64,
      kExprLocalGet, 3,
      kExprF64ConvertF32,
      kExprLocalGet, 4,
      kExprLocalGet, 5,
      kGCPrefix, kExprI31GetS,
      kExprF64SConvertI32,
      kExprLocalGet, 6,
      kExprRefIsNull,
      kExprF64SConvertI32,
      kExprLocalGet, 7,
      kSimdPrefix, kExprF64x2ExtractLane, 0,
      kExprLocalGet, 7,
      kSimdPrefix, kExprF64x2ExtractLane, 1,
      kExprF64Add,
      kExprF64Add,
      kExprF64Add,
      kExprF64Add,
      kExprF64Add,
      kExprF64Add,
      kExprF64Add,
  ]).exportFunc();

  let wasm = builder.instantiate().exports;
  let expected = 32 + 64 + 3.2 + 6.4 + 31 + 1 + 127 + 129;
  let delta = 1e-4;
  assertEqualsDelta(expected, wasm.literals(wasm.nop1), delta);
  %WasmTierUpFunction(wasm.literals);
  assertEqualsDelta(expected, wasm.literals(wasm.nop1), delta);
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.literals));
  }
  // Deopt happened, the result should still be the same.
  assertEqualsDelta(expected, wasm.literals(wasm.nop2), delta);
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.literals));
  }
})();

(function TestDeoptTypesNonLiterals() {
  var builder = new WasmModuleBuilder();
  let funcRefT = builder.addType(kSig_v_v);

  builder.addFunction("nop1", funcRefT).addBody([]).exportFunc();
  builder.addFunction("nop2", funcRefT).addBody([]).exportFunc();

  let mainSig = makeSig([kWasmI32, wasmRefType(funcRefT)], [kWasmF64]);

  builder.addFunction("locals", mainSig)
    .addLocals(kWasmI32, 1)
    .addLocals(kWasmI64, 1)
    .addLocals(kWasmF32, 1)
    .addLocals(kWasmF64, 1)
    .addLocals(kWasmI31Ref, 1)
    .addLocals(kWasmS128, 1)
    .addBody([
      // Initialize the locals with non-default non-literal values.
      kExprLocalGet, 0,
      kExprLocalTee, 2,
      kExprI64SConvertI32,
      kExprLocalTee, 3,
      kExprF32SConvertI64,
      kExprLocalTee, 4,
      kExprF64ConvertF32,
      kExprLocalSet, 5,
      kExprLocalGet, 0,
      kGCPrefix, kExprRefI31,
      kExprLocalSet, 6,
      kExprLocalGet, 0,
      kExprF64SConvertI32,
      kSimdPrefix, kExprF64x2Splat,
      kExprLocalSet, 7,

      // Perform the call_ref.
      kExprLocalGet, 1,
      kExprCallRef, funcRefT,

      // Use the locals in the now potentially deoptimized stack.
      kExprLocalGet, 2,
      kExprF64SConvertI32,
      kExprLocalGet, 3,
      kExprF64SConvertI64,
      kExprLocalGet, 4,
      kExprF64ConvertF32,
      kExprLocalGet, 5,
      kExprLocalGet, 6,
      kGCPrefix, kExprI31GetS,
      kExprF64SConvertI32,
      kExprLocalGet, 7,
      kSimdPrefix, kExprF64x2ExtractLane, 0,
      kExprLocalGet, 7,
      kSimdPrefix, kExprF64x2ExtractLane, 1,
      kExprF64Add,
      kExprF64Add,
      kExprF64Add,
      kExprF64Add,
      kExprF64Add,
      kExprF64Add,
  ]).exportFunc();

  let wasm = builder.instantiate().exports;
  let delta = 1e-4;
  assertEqualsDelta(42 * 7, wasm.locals(42, wasm.nop1), delta);
  %WasmTierUpFunction(wasm.locals);
  assertEqualsDelta(42 * 7, wasm.locals(42, wasm.nop1), delta);
  if (%IsWasmTieringPredictable()) {
    assertTrue(%IsTurboFanFunction(wasm.locals));
  }
  // Deopt happened, the result should still be the same.
  assertEqualsDelta(42 * 7, wasm.locals(42, wasm.nop2), delta);
  if (%IsWasmTieringPredictable()) {
    assertFalse(%IsTurboFanFunction(wasm.locals));
  }
})();
                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/wasm/disable-trap-handler.js                                       0000664 0000000 0000000 00000000530 14746647661 0024002 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --no-wasm-trap-handler

// This test makes sure that --no-wasm-trap-handler has the correct effect.

assertFalse(%IsWasmTrapHandlerEnabled());
                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/wasm/disallow-codegen.js                                           0000664 0000000 0000000 00000007737 14746647661 0023260 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --allow-natives-syntax

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

let kReturnValue = 19;

let buffer = (function CreateBuffer() {
  let builder = new WasmModuleBuilder();
  builder.addMemory(1, 1);
  builder.addFunction('main', kSig_i_v)
      .addBody([kExprI32Const, kReturnValue])
      .exportFunc();

  return builder.toBuffer();
})();

%DisallowWasmCodegen(true);

function SyncTestOk() {
  print('sync module compile (ok)...');
  %DisallowWasmCodegen(false);
  let module = new WebAssembly.Module(buffer);
  assertInstanceof(module, WebAssembly.Module);
}

function SyncTestWasmFail() {
  print('sync wasm module compile (fail)...');
  %DisallowWasmCodegen(true);
  try {
    let module = new WebAssembly.Module(buffer);
    assertUnreachable();
  } catch (e) {
    print("  " + e);
    assertInstanceof(e, WebAssembly.CompileError);
  }
}

async function AsyncTestOk() {
  print('async module compile (ok)...');
  %DisallowWasmCodegen(false);
  let promise = WebAssembly.compile(buffer);
  assertPromiseResult(
    promise, module => assertInstanceof(module, WebAssembly.Module));
}

async function AsyncTestWithInstantiateOk() {
  print('async module instantiate (ok)...');
  %DisallowWasmCodegen(false);
  let promise = WebAssembly.instantiate(buffer);
  assertPromiseResult(
      promise,
      module => assertInstanceof(module.instance, WebAssembly.Instance));
}

async function AsyncTestWasmFail() {
  print('async wasm module compile (fail)...');
  %DisallowWasmCodegen(true);
  try {
    let m = await WebAssembly.compile(buffer);
    assertUnreachable();
  } catch (e) {
    print("  " + e);
    assertInstanceof(e, WebAssembly.CompileError);
  }
}

async function AsyncTestWasmWithInstantiateFail() {
  print('async wasm module instantiate (fail)...');
  %DisallowWasmCodegen(true);
  try {
    let m = await WebAssembly.instantiate(buffer);
    assertUnreachable();
  } catch (e) {
    print("  " + e);
    assertInstanceof(e, WebAssembly.CompileError);
  }
}

async function StreamingTestOk() {
  print('streaming module compile (ok)...');
  // TODO(titzer): compileStreaming must be supplied by embedder.
  // (and it takes a response, not a buffer)
  %DisallowWasmCodegen(false);
  if ("Function" != typeof WebAssembly.compileStreaming) {
    print("  no embedder for streaming compilation");
    return;
  }
  let promise = WebAssembly.compileStreaming(buffer);
  await assertPromiseResult(
    promise, module => assertInstanceof(module, WebAssembly.Module));
}

async function StreamingTestFail() {
  print('streaming module compile (fail)...');
  %DisallowWasmCodegen(false);
  // TODO(titzer): compileStreaming must be supplied by embedder.
  // (and it takes a response, not a buffer)
  if ("Function" != typeof WebAssembly.compileStreaming) {
    print("  no embedder for streaming compilation");
    return;
  }
  try {
    let m = await WebAssembly.compileStreaming(buffer);
    assertUnreachable();
  } catch (e) {
    print("  " + e);
    assertInstanceof(e, WebAssembly.CompileError);
  }
}


async function StreamingTestWasmFail() {
  print('streaming wasm module compile (fail)...');
  %DisallowWasmCodegen(true);
  // TODO(titzer): compileStreaming must be supplied by embedder.
  // (and it takes a response, not a buffer)
  if ("Function" != typeof WebAssembly.compileStreaming) {
    print("  no embedder for streaming compilation");
    return;
  }
  try {
    let m = await WebAssembly.compileStreaming(buffer);
    assertUnreachable();
  } catch (e) {
    print("  " + e);
    assertInstanceof(e, WebAssembly.CompileError);
  }
}

async function RunAll() {
  SyncTestOk();
  AsyncTestOk();
  await StreamingTestOk();
  await StreamingTestFail();
  SyncTestWasmFail();
  await AsyncTestWasmFail();
  await AsyncTestWasmWithInstantiateFail();
  await StreamingTestWasmFail()
}

assertPromiseResult(RunAll());
                                 node-23.7.0/deps/v8/test/mjsunit/wasm/divrem-trap.js                                                0000664 0000000 0000000 00000003315 14746647661 0022256 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --expose-gc --allow-natives-syntax

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

var assertTraps = function(messageId, code) {
  assertThrows(code, WebAssembly.RuntimeError, kTrapMsgs[messageId]);
}


function makeBinop(opcode) {
  var builder = new WasmModuleBuilder();

  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,           // --
      kExprLocalGet, 1,           // --
      opcode,                     // --
    ])
    .exportFunc();

  return builder.instantiate().exports.main;
}

var divs = makeBinop(kExprI32DivS);
var divu = makeBinop(kExprI32DivU);

assertEquals( 33, divs( 333, 10));
assertEquals(-33, divs(-336, 10));

assertEquals(       44, divu( 445, 10));
assertEquals(429496685, divu(-446, 10));

assertTraps(kTrapDivByZero, "divs(100, 0);");
assertTraps(kTrapDivByZero, "divs(-1009, 0);");

assertTraps(kTrapDivByZero, "divu(200, 0);");
assertTraps(kTrapDivByZero, "divu(-2009, 0);");

assertTraps(kTrapDivUnrepresentable, "divs(0x80000000, -1)");
assertEquals(0, divu(0x80000000, -1));


var rems = makeBinop(kExprI32RemS);
var remu = makeBinop(kExprI32RemU);

assertEquals( 3, rems( 333, 10));
assertEquals(-6, rems(-336, 10));

assertEquals( 5, remu( 445, 10));
assertEquals( 3, remu(-443, 10));

assertTraps(kTrapRemByZero, "rems(100, 0);");
assertTraps(kTrapRemByZero, "rems(-1009, 0);");

assertTraps(kTrapRemByZero, "remu(200, 0);");
assertTraps(kTrapRemByZero, "remu(-2009, 0);");

assertEquals(-2147483648, remu(0x80000000, -1));
assertEquals(0, rems(0x80000000, -1));
                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/wasm/element-segments-with-reftypes.js                             0000664 0000000 0000000 00000007540 14746647661 0026114 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function TestGlobalGetElement() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let table = builder.addTable(kWasmFuncRef, 10, 10).exportAs('table');
  let f0 = builder.addFunction('double', kSig_i_i).addBody([
    kExprLocalGet, 0, kExprLocalGet, 0, kExprI32Add
  ]);
  let f1 = builder.addFunction('inc', kSig_i_i).addBody([
    kExprLocalGet, 0, kExprI32Const, 1, kExprI32Add
  ]);
  let global0 =
      builder.addGlobal(kWasmFuncRef, false, false, [kExprRefFunc, f0.index]);
  let global1 =
      builder.addGlobal(kWasmFuncRef, false, false, [kExprRefFunc, f1.index]);
  // At instantiation, table[0] = global0, table[1] = global1.
  builder.addActiveElementSegment(
      table.index, wasmI32Const(0),
      [[kExprGlobalGet, global0.index], [kExprGlobalGet, global1.index]],
      kWasmFuncRef);

  let passive = builder.addPassiveElementSegment(
      [[kExprGlobalGet, global0.index], [kExprGlobalGet, global1.index]],
      kWasmFuncRef);

  // table[2] = global0, table[3] = global1.
  builder.addFunction('init', kSig_v_v)
      .addBody([
        kExprI32Const, 2,  // table index
        kExprI32Const, 0,  // element index
        kExprI32Const, 2,  // length
        kNumericPrefix, kExprTableInit, passive, table.index])
      .exportFunc();

  let instance = builder.instantiate({});

  instance.exports.init();
  assertEquals(instance.exports.table.get(0)(10), 20);
  assertEquals(instance.exports.table.get(1)(10), 11);
  assertEquals(instance.exports.table.get(2)(10), 20);
  assertEquals(instance.exports.table.get(3)(10), 11);
})();

(function TestTypedFunctionElementSegment() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = builder.addType(kSig_i_i);

  let f0 = builder.addFunction('double', sig).addBody([
    kExprLocalGet, 0, kExprLocalGet, 0, kExprI32Add
  ]);
  let f1 = builder.addFunction('inc', sig).addBody([
    kExprLocalGet, 0, kExprI32Const, 1, kExprI32Add
  ]);

  let table =
      builder.addTable(wasmRefType(sig), 10, 10, [kExprRefFunc, f0.index])
          .exportAs('table');

  builder.addActiveElementSegment(
      table.index, wasmI32Const(0),
      [[kExprRefFunc, f0.index], [kExprRefFunc, f1.index]],
      wasmRefType(sig));

  let passive = builder.addPassiveElementSegment(
      [[kExprRefFunc, f0.index], [kExprRefFunc, f1.index]],
      wasmRefType(sig));

  builder.addFunction('init', kSig_v_v)
      .addBody([
        kExprI32Const, 2,  // table index
        kExprI32Const, 0,  // element index
        kExprI32Const, 2,  // length
        kNumericPrefix, kExprTableInit, passive, table.index
      ])
      .exportFunc();

  let instance = builder.instantiate({});

  instance.exports.init();
  assertEquals(instance.exports.table.get(0)(10), 20);
  assertEquals(instance.exports.table.get(1)(10), 11);
  assertEquals(instance.exports.table.get(2)(10), 20);
  assertEquals(instance.exports.table.get(3)(10), 11);
})();

// Test that mutable globals cannot be used in element segments, even with
// wasm-gc.
(function TestMutableGlobalInElementSegment() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let global = builder.addImportedGlobal("m", "g", kWasmFuncRef, true);
  let table = builder.addTable(kWasmFuncRef, 10, 10);
  builder.addActiveElementSegment(
      table.index, wasmI32Const(0),
      [[kExprGlobalGet, global]], kWasmFuncRef);
  builder.addExportOfKind("table", kExternalTable, table.index);

  assertThrows(
    () => builder.instantiate({m : {g :
        new WebAssembly.Global({value: "anyfunc", mutable: true}, null)}}),
    WebAssembly.CompileError,
    /mutable globals cannot be used in constant expressions/);
})();
                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/wasm/embenchen/                                                    0000775 0000000 0000000 00000000000 14746647661 0021410 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/wasm/embenchen/README                                              0000664 0000000 0000000 00000000215 14746647661 0022266 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        This directory contains versions of test/mjsunit/asm/embenchen
modified to work with the current state of the asm->wasm
conversion plumbing.
                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/wasm/embenchen/box2d.js                                            0000664 0000000 0000000 00002413265 14746647661 0023001 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Modified embenchen to direct to asm-wasm.
// Flags: --validate-asm --allow-natives-syntax

var EXPECTED_OUTPUT =
  /frame averages: .+ \+- .+, range: .+ to .+ \n/;
var Module = {
  arguments: [1],
  print: function(x) {Module.printBuffer += x + '\n';},
  preRun: [function() {Module.printBuffer = ''}],
  postRun: [function() {
    assertTrue(EXPECTED_OUTPUT.test(Module.printBuffer));
  }],
};
// The Module object: Our interface to the outside world. We import
// and export values on it, and do the work to get that through
// closure compiler if necessary. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to do an eval in order to handle the closure compiler
// case, where this code here is minified but Module was defined
// elsewhere (e.g. case 4 above). We also need to check if Module
// already exists (e.g. case 3 above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module;
if (!Module) Module = (typeof Module !== 'undefined' ? Module : null) || {};

// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = {};
for (var key in Module) {
  if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
  }
}

// The environment setup code below is customized to use Module.
// *** Environment setup code ***
var ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof require === 'function';
var ENVIRONMENT_IS_WEB = typeof window === 'object';
var ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

if (ENVIRONMENT_IS_NODE) {
  // Expose functionality in the same simple way that the shells work
  // Note that we pollute the global namespace here, otherwise we break in node
  if (!Module['print']) Module['print'] = function print(x) {
    process['stdout'].write(x + '\n');
  };
  if (!Module['printErr']) Module['printErr'] = function printErr(x) {
    process['stderr'].write(x + '\n');
  };

  var nodeFS = require('fs');
  var nodePath = require('path');

  Module['read'] = function read(filename, binary) {
    filename = nodePath['normalize'](filename);
    var ret = nodeFS['readFileSync'](filename);
    // The path is absolute if the normalized version is the same as the resolved.
    if (!ret && filename != nodePath['resolve'](filename)) {
      filename = path.join(__dirname, '..', 'src', filename);
      ret = nodeFS['readFileSync'](filename);
    }
    if (ret && !binary) ret = ret.toString();
    return ret;
  };

  Module['readBinary'] = function readBinary(filename) { return Module['read'](filename, true) };

  Module['load'] = function load(f) {
    globalEval(read(f));
  };

  Module['arguments'] = process['argv'].slice(2);

  module['exports'] = Module;
}
else if (ENVIRONMENT_IS_SHELL) {
  if (!Module['print']) Module['print'] = print;
  if (typeof printErr != 'undefined') Module['printErr'] = printErr; // not present in v8 or older sm

  if (typeof read != 'undefined') {
    Module['read'] = read;
  } else {
    Module['read'] = function read() { throw 'no read() available (jsc?)' };
  }

  Module['readBinary'] = function readBinary(f) {
    return read(f, 'binary');
  };

  if (typeof scriptArgs != 'undefined') {
    Module['arguments'] = scriptArgs;
  } else if (typeof arguments != 'undefined') {
    Module['arguments'] = arguments;
  }

  this['Module'] = Module;

  eval("if (typeof gc === 'function' && gc.toString().indexOf('[native code]') > 0) var gc = undefined"); // wipe out the SpiderMonkey shell 'gc' function, which can confuse closure (uses it as a minified name, and it is then initted to a non-falsey value unexpectedly)
}
else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  Module['read'] = function read(url) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, false);
    xhr.send(null);
    return xhr.responseText;
  };

  if (typeof arguments != 'undefined') {
    Module['arguments'] = arguments;
  }

  if (typeof console !== 'undefined') {
    if (!Module['print']) Module['print'] = function print(x) {
      console.log(x);
    };
    if (!Module['printErr']) Module['printErr'] = function printErr(x) {
      console.log(x);
    };
  } else {
    // Probably a worker, and without console.log. We can do very little here...
    var TRY_USE_DUMP = false;
    if (!Module['print']) Module['print'] = (TRY_USE_DUMP && (typeof(dump) !== "undefined") ? (function(x) {
      dump(x);
    }) : (function(x) {
      // self.postMessage(x); // enable this if you want stdout to be sent as messages
    }));
  }

  if (ENVIRONMENT_IS_WEB) {
    window['Module'] = Module;
  } else {
    Module['load'] = importScripts;
  }
}
else {
  // Unreachable because SHELL is dependant on the others
  throw 'Unknown runtime environment. Where are we?';
}

function globalEval(x) {
  eval.call(null, x);
}
if (!Module['load'] == 'undefined' && Module['read']) {
  Module['load'] = function load(f) {
    globalEval(Module['read'](f));
  };
}
if (!Module['print']) {
  Module['print'] = function(){};
}
if (!Module['printErr']) {
  Module['printErr'] = Module['print'];
}
if (!Module['arguments']) {
  Module['arguments'] = [];
}
// *** Environment setup code ***

// Closure helpers
Module.print = Module['print'];
Module.printErr = Module['printErr'];

// Callbacks
Module['preRun'] = [];
Module['postRun'] = [];

// Merge back in the overrides
for (var key in moduleOverrides) {
  if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
  }
}



// === Auto-generated preamble library stuff ===

//========================================
// Runtime code shared with compiler
//========================================

var Runtime = {
  stackSave: function () {
    return STACKTOP;
  },
  stackRestore: function (stackTop) {
    STACKTOP = stackTop;
  },
  forceAlign: function (target, quantum) {
    quantum = quantum || 4;
    if (quantum == 1) return target;
    if (isNumber(target) && isNumber(quantum)) {
      return Math.ceil(target/quantum)*quantum;
    } else if (isNumber(quantum) && isPowerOfTwo(quantum)) {
      return '(((' +target + ')+' + (quantum-1) + ')&' + -quantum + ')';
    }
    return 'Math.ceil((' + target + ')/' + quantum + ')*' + quantum;
  },
  isNumberType: function (type) {
    return type in Runtime.INT_TYPES || type in Runtime.FLOAT_TYPES;
  },
  isPointerType: function isPointerType(type) {
  return type[type.length-1] == '*';
},
  isStructType: function isStructType(type) {
  if (isPointerType(type)) return false;
  if (isArrayType(type)) return true;
  if (/<?\{ ?[^}]* ?\}>?/.test(type)) return true; // { i32, i8 } etc. - anonymous struct types
  // See comment in isStructPointerType()
  return type[0] == '%';
},
  INT_TYPES: {"i1":0,"i8":0,"i16":0,"i32":0,"i64":0},
  FLOAT_TYPES: {"float":0,"double":0},
  or64: function (x, y) {
    var l = (x | 0) | (y | 0);
    var h = (Math.round(x / 4294967296) | Math.round(y / 4294967296)) * 4294967296;
    return l + h;
  },
  and64: function (x, y) {
    var l = (x | 0) & (y | 0);
    var h = (Math.round(x / 4294967296) & Math.round(y / 4294967296)) * 4294967296;
    return l + h;
  },
  xor64: function (x, y) {
    var l = (x | 0) ^ (y | 0);
    var h = (Math.round(x / 4294967296) ^ Math.round(y / 4294967296)) * 4294967296;
    return l + h;
  },
  getNativeTypeSize: function (type) {
    switch (type) {
      case 'i1': case 'i8': return 1;
      case 'i16': return 2;
      case 'i32': return 4;
      case 'i64': return 8;
      case 'float': return 4;
      case 'double': return 8;
      default: {
        if (type[type.length-1] === '*') {
          return Runtime.QUANTUM_SIZE; // A pointer
        } else if (type[0] === 'i') {
          var bits = parseInt(type.substr(1));
          assert(bits % 8 === 0);
          return bits/8;
        } else {
          return 0;
        }
      }
    }
  },
  getNativeFieldSize: function (type) {
    return Math.max(Runtime.getNativeTypeSize(type), Runtime.QUANTUM_SIZE);
  },
  dedup: function dedup(items, ident) {
  var seen = {};
  if (ident) {
    return items.filter(function(item) {
      if (seen[item[ident]]) return false;
      seen[item[ident]] = true;
      return true;
    });
  } else {
    return items.filter(function(item) {
      if (seen[item]) return false;
      seen[item] = true;
      return true;
    });
  }
},
  set: function set() {
  var args = typeof arguments[0] === 'object' ? arguments[0] : arguments;
  var ret = {};
  for (var i = 0; i < args.length; i++) {
    ret[args[i]] = 0;
  }
  return ret;
},
  STACK_ALIGN: 8,
  getAlignSize: function (type, size, vararg) {
    // we align i64s and doubles on 64-bit boundaries, unlike x86
    if (!vararg && (type == 'i64' || type == 'double')) return 8;
    if (!type) return Math.min(size, 8); // align structures internally to 64 bits
    return Math.min(size || (type ? Runtime.getNativeFieldSize(type) : 0), Runtime.QUANTUM_SIZE);
  },
  calculateStructAlignment: function calculateStructAlignment(type) {
    type.flatSize = 0;
    type.alignSize = 0;
    var diffs = [];
    var prev = -1;
    var index = 0;
    type.flatIndexes = type.fields.map(function(field) {
      index++;
      var size, alignSize;
      if (Runtime.isNumberType(field) || Runtime.isPointerType(field)) {
        size = Runtime.getNativeTypeSize(field); // pack char; char; in structs, also char[X]s.
        alignSize = Runtime.getAlignSize(field, size);
      } else if (Runtime.isStructType(field)) {
        if (field[1] === '0') {
          // this is [0 x something]. When inside another structure like here, it must be at the end,
          // and it adds no size
          // XXX this happens in java-nbody for example... assert(index === type.fields.length, 'zero-length in the middle!');
          size = 0;
          if (Types.types[field]) {
            alignSize = Runtime.getAlignSize(null, Types.types[field].alignSize);
          } else {
            alignSize = type.alignSize || QUANTUM_SIZE;
          }
        } else {
          size = Types.types[field].flatSize;
          alignSize = Runtime.getAlignSize(null, Types.types[field].alignSize);
        }
      } else if (field[0] == 'b') {
        // bN, large number field, like a [N x i8]
        size = field.substr(1)|0;
        alignSize = 1;
      } else if (field[0] === '<') {
        // vector type
        size = alignSize = Types.types[field].flatSize; // fully aligned
      } else if (field[0] === 'i') {
        // illegal integer field, that could not be legalized because it is an internal structure field
        // it is ok to have such fields, if we just use them as markers of field size and nothing more complex
        size = alignSize = parseInt(field.substr(1))/8;
        assert(size % 1 === 0, 'cannot handle non-byte-size field ' + field);
      } else {
        assert(false, 'invalid type for calculateStructAlignment');
      }
      if (type.packed) alignSize = 1;
      type.alignSize = Math.max(type.alignSize, alignSize);
      var curr = Runtime.alignMemory(type.flatSize, alignSize); // if necessary, place this on aligned memory
      type.flatSize = curr + size;
      if (prev >= 0) {
        diffs.push(curr-prev);
      }
      prev = curr;
      return curr;
    });
    if (type.name_ && type.name_[0] === '[') {
      // arrays have 2 elements, so we get the proper difference. then we scale here. that way we avoid
      // allocating a potentially huge array for [999999 x i8] etc.
      type.flatSize = parseInt(type.name_.substr(1))*type.flatSize/2;
    }
    type.flatSize = Runtime.alignMemory(type.flatSize, type.alignSize);
    if (diffs.length == 0) {
      type.flatFactor = type.flatSize;
    } else if (Runtime.dedup(diffs).length == 1) {
      type.flatFactor = diffs[0];
    }
    type.needsFlattening = (type.flatFactor != 1);
    return type.flatIndexes;
  },
  generateStructInfo: function (struct, typeName, offset) {
    var type, alignment;
    if (typeName) {
      offset = offset || 0;
      type = (typeof Types === 'undefined' ? Runtime.typeInfo : Types.types)[typeName];
      if (!type) return null;
      if (type.fields.length != struct.length) {
        printErr('Number of named fields must match the type for ' + typeName + ': possibly duplicate struct names. Cannot return structInfo');
        return null;
      }
      alignment = type.flatIndexes;
    } else {
      var type = { fields: struct.map(function(item) { return item[0] }) };
      alignment = Runtime.calculateStructAlignment(type);
    }
    var ret = {
      __size__: type.flatSize
    };
    if (typeName) {
      struct.forEach(function(item, i) {
        if (typeof item === 'string') {
          ret[item] = alignment[i] + offset;
        } else {
          // embedded struct
          var key;
          for (var k in item) key = k;
          ret[key] = Runtime.generateStructInfo(item[key], type.fields[i], alignment[i]);
        }
      });
    } else {
      struct.forEach(function(item, i) {
        ret[item[1]] = alignment[i];
      });
    }
    return ret;
  },
  dynCall: function (sig, ptr, args) {
    if (args && args.length) {
      if (!args.splice) args = Array.prototype.slice.call(args);
      args.splice(0, 0, ptr);
      return Module['dynCall_' + sig].apply(null, args);
    } else {
      return Module['dynCall_' + sig].call(null, ptr);
    }
  },
  functionPointers: [],
  addFunction: function (func) {
    for (var i = 0; i < Runtime.functionPointers.length; i++) {
      if (!Runtime.functionPointers[i]) {
        Runtime.functionPointers[i] = func;
        return 2*(1 + i);
      }
    }
    throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';
  },
  removeFunction: function (index) {
    Runtime.functionPointers[(index-2)/2] = null;
  },
  getAsmConst: function (code, numArgs) {
    // code is a constant string on the heap, so we can cache these
    if (!Runtime.asmConstCache) Runtime.asmConstCache = {};
    var func = Runtime.asmConstCache[code];
    if (func) return func;
    var args = [];
    for (var i = 0; i < numArgs; i++) {
      args.push(String.fromCharCode(36) + i); // $0, $1 etc
    }
    var source = Pointer_stringify(code);
    if (source[0] === '"') {
      // tolerate EM_ASM("..code..") even though EM_ASM(..code..) is correct
      if (source.indexOf('"', 1) === source.length-1) {
        source = source.substr(1, source.length-2);
      } else {
        // something invalid happened, e.g. EM_ASM("..code($0)..", input)
        abort('invalid EM_ASM input |' + source + '|. Please use EM_ASM(..code..) (no quotes) or EM_ASM({ ..code($0).. }, input) (to input values)');
      }
    }
    try {
      var evalled = eval('(function(' + args.join(',') + '){ ' + source + ' })'); // new Function does not allow upvars in node
    } catch(e) {
      Module.printErr('error in executing inline EM_ASM code: ' + e + ' on: \n\n' + source + '\n\nwith args |' + args + '| (make sure to use the right one out of EM_ASM, EM_ASM_ARGS, etc.)');
      throw e;
    }
    return Runtime.asmConstCache[code] = evalled;
  },
  warnOnce: function (text) {
    if (!Runtime.warnOnce.shown) Runtime.warnOnce.shown = {};
    if (!Runtime.warnOnce.shown[text]) {
      Runtime.warnOnce.shown[text] = 1;
      Module.printErr(text);
    }
  },
  funcWrappers: {},
  getFuncWrapper: function (func, sig) {
    assert(sig);
    if (!Runtime.funcWrappers[func]) {
      Runtime.funcWrappers[func] = function dynCall_wrapper() {
        return Runtime.dynCall(sig, func, arguments);
      };
    }
    return Runtime.funcWrappers[func];
  },
  UTF8Processor: function () {
    var buffer = [];
    var needed = 0;
    this.processCChar = function (code) {
      code = code & 0xFF;

      if (buffer.length == 0) {
        if ((code & 0x80) == 0x00) {        // 0xxxxxxx
          return String.fromCharCode(code);
        }
        buffer.push(code);
        if ((code & 0xE0) == 0xC0) {        // 110xxxxx
          needed = 1;
        } else if ((code & 0xF0) == 0xE0) { // 1110xxxx
          needed = 2;
        } else {                            // 11110xxx
          needed = 3;
        }
        return '';
      }

      if (needed) {
        buffer.push(code);
        needed--;
        if (needed > 0) return '';
      }

      var c1 = buffer[0];
      var c2 = buffer[1];
      var c3 = buffer[2];
      var c4 = buffer[3];
      var ret;
      if (buffer.length == 2) {
        ret = String.fromCharCode(((c1 & 0x1F) << 6)  | (c2 & 0x3F));
      } else if (buffer.length == 3) {
        ret = String.fromCharCode(((c1 & 0x0F) << 12) | ((c2 & 0x3F) << 6)  | (c3 & 0x3F));
      } else {
        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        var codePoint = ((c1 & 0x07) << 18) | ((c2 & 0x3F) << 12) |
                        ((c3 & 0x3F) << 6)  | (c4 & 0x3F);
        ret = String.fromCharCode(
          Math.floor((codePoint - 0x10000) / 0x400) + 0xD800,
          (codePoint - 0x10000) % 0x400 + 0xDC00);
      }
      buffer.length = 0;
      return ret;
    }
    this.processJSString = function processJSString(string) {
      /* TODO: use TextEncoder when present,
        var encoder = new TextEncoder();
        encoder['encoding'] = "utf-8";
        var utf8Array = encoder['encode'](aMsg.data);
      */
      string = unescape(encodeURIComponent(string));
      var ret = [];
      for (var i = 0; i < string.length; i++) {
        ret.push(string.charCodeAt(i));
      }
      return ret;
    }
  },
  getCompilerSetting: function (name) {
    throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work';
  },
  stackAlloc: function (size) { var ret = STACKTOP;STACKTOP = (STACKTOP + size)|0;STACKTOP = (((STACKTOP)+7)&-8); return ret; },
  staticAlloc: function (size) { var ret = STATICTOP;STATICTOP = (STATICTOP + size)|0;STATICTOP = (((STATICTOP)+7)&-8); return ret; },
  dynamicAlloc: function (size) { var ret = DYNAMICTOP;DYNAMICTOP = (DYNAMICTOP + size)|0;DYNAMICTOP = (((DYNAMICTOP)+7)&-8); if (DYNAMICTOP >= TOTAL_MEMORY) enlargeMemory();; return ret; },
  alignMemory: function (size,quantum) { var ret = size = Math.ceil((size)/(quantum ? quantum : 8))*(quantum ? quantum : 8); return ret; },
  makeBigInt: function (low,high,unsigned) { var ret = (unsigned ? ((+((low>>>0)))+((+((high>>>0)))*(+4294967296))) : ((+((low>>>0)))+((+((high|0)))*(+4294967296)))); return ret; },
  GLOBAL_BASE: 8,
  QUANTUM_SIZE: 4,
  __dummy__: 0
}


Module['Runtime'] = Runtime;









//========================================
// Runtime essentials
//========================================

var __THREW__ = 0; // Used in checking for thrown exceptions.

var ABORT = false; // whether we are quitting the application. no code should run after this. set in exit() and abort()
var EXITSTATUS = 0;

var undef = 0;
// tempInt is used for 32-bit signed values or smaller. tempBigInt is used
// for 32-bit unsigned values or more than 32 bits. TODO: audit all uses of tempInt
var tempValue, tempInt, tempBigInt, tempInt2, tempBigInt2, tempPair, tempBigIntI, tempBigIntR, tempBigIntS, tempBigIntP, tempBigIntD, tempDouble, tempFloat;
var tempI64, tempI64b;
var tempRet0, tempRet1, tempRet2, tempRet3, tempRet4, tempRet5, tempRet6, tempRet7, tempRet8, tempRet9;

function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed: ' + text);
  }
}

var globalScope = this;

// C calling interface. A convenient way to call C functions (in C files, or
// defined with extern "C").
//
// Note: LLVM optimizations can inline and remove functions, after which you will not be
//       able to call them. Closure can also do so. To avoid that, add your function to
//       the exports using something like
//
//         -s EXPORTED_FUNCTIONS='["_main", "_myfunc"]'
//
// @param ident      The name of the C function (note that C++ functions will be name-mangled - use extern "C")
// @param returnType The return type of the function, one of the JS types 'number', 'string' or 'array' (use 'number' for any C pointer, and
//                   'array' for JavaScript arrays and typed arrays; note that arrays are 8-bit).
// @param argTypes   An array of the types of arguments for the function (if there are no arguments, this can be ommitted). Types are as in returnType,
//                   except that 'array' is not possible (there is no way for us to know the length of the array)
// @param args       An array of the arguments to the function, as native JS values (as in returnType)
//                   Note that string arguments will be stored on the stack (the JS string will become a C string on the stack).
// @return           The return value, as a native JS value (as in returnType)
function ccall(ident, returnType, argTypes, args) {
  return ccallFunc(getCFunc(ident), returnType, argTypes, args);
}
Module["ccall"] = ccall;

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  try {
    var func = Module['_' + ident]; // closure exported function
    if (!func) func = eval('_' + ident); // explicit lookup
  } catch(e) {
  }
  assert(func, 'Cannot call unknown function ' + ident + ' (perhaps LLVM optimizations or closure removed it?)');
  return func;
}

// Internal function that does a C call using a function, not an identifier
function ccallFunc(func, returnType, argTypes, args) {
  var stack = 0;
  function toC(value, type) {
    if (type == 'string') {
      if (value === null || value === undefined || value === 0) return 0; // null string
      value = intArrayFromString(value);
      type = 'array';
    }
    if (type == 'array') {
      if (!stack) stack = Runtime.stackSave();
      var ret = Runtime.stackAlloc(value.length);
      writeArrayToMemory(value, ret);
      return ret;
    }
    return value;
  }
  function fromC(value, type) {
    if (type == 'string') {
      return Pointer_stringify(value);
    }
    assert(type != 'array');
    return value;
  }
  var i = 0;
  var cArgs = args ? args.map(function(arg) {
    return toC(arg, argTypes[i++]);
  }) : [];
  var ret = fromC(func.apply(null, cArgs), returnType);
  if (stack) Runtime.stackRestore(stack);
  return ret;
}

// Returns a native JS wrapper for a C function. This is similar to ccall, but
// returns a function you can call repeatedly in a normal way. For example:
//
//   var my_function = cwrap('my_c_function', 'number', ['number', 'number']);
//   alert(my_function(5, 22));
//   alert(my_function(99, 12));
//
function cwrap(ident, returnType, argTypes) {
  var func = getCFunc(ident);
  return function() {
    return ccallFunc(func, returnType, argTypes, Array.prototype.slice.call(arguments));
  }
}
Module["cwrap"] = cwrap;

// Sets a value in memory in a dynamic way at run-time. Uses the
// type data. This is the same as makeSetValue, except that
// makeSetValue is done at compile-time and generates the needed
// code then, whereas this function picks the right code at
// run-time.
// Note that setValue and getValue only do *aligned* writes and reads!
// Note that ccall uses JS types as for defining types, while setValue and
// getValue need LLVM types ('i8', 'i32') - this is a lower-level operation
function setValue(ptr, value, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': HEAP8[(ptr)]=value; break;
      case 'i8': HEAP8[(ptr)]=value; break;
      case 'i16': HEAP16[((ptr)>>1)]=value; break;
      case 'i32': HEAP32[((ptr)>>2)]=value; break;
      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= (+1) ? (tempDouble > (+0) ? ((Math_min((+(Math_floor((tempDouble)/(+4294967296)))), (+4294967295)))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/(+4294967296))))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)]=value; break;
      case 'double': HEAPF64[((ptr)>>3)]=value; break;
      default: abort('invalid type for setValue: ' + type);
    }
}
Module['setValue'] = setValue;

// Parallel to setValue.
function getValue(ptr, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': return HEAP8[(ptr)];
      case 'i8': return HEAP8[(ptr)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return HEAPF64[((ptr)>>3)];
      default: abort('invalid type for setValue: ' + type);
    }
  return null;
}
Module['getValue'] = getValue;

var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call
var ALLOC_STATIC = 2; // Cannot be freed
var ALLOC_DYNAMIC = 3; // Cannot be freed except through sbrk
var ALLOC_NONE = 4; // Do not allocate
Module['ALLOC_NORMAL'] = ALLOC_NORMAL;
Module['ALLOC_STACK'] = ALLOC_STACK;
Module['ALLOC_STATIC'] = ALLOC_STATIC;
Module['ALLOC_DYNAMIC'] = ALLOC_DYNAMIC;
Module['ALLOC_NONE'] = ALLOC_NONE;

// allocate(): This is for internal use. You can use it yourself as well, but the interface
//             is a little tricky (see docs right below). The reason is that it is optimized
//             for multiple syntaxes to save space in generated code. So you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setValue(), and so forth.
// @slab: An array of data, or a number. If a number, then the size of the block to allocate,
//        in *bytes* (note that this is sometimes confusing: the next parameter does not
//        affect this!)
// @types: Either an array of types, one for each byte (or 0 if no type at that position),
//         or a single type which is used for the entire block. This only matters if there
//         is initial data - if @slab is a number, then this does not matter at all and is
//         ignored.
// @allocator: How to allocate memory, see ALLOC_*
function allocate(slab, types, allocator, ptr) {
  var zeroinit, size;
  if (typeof slab === 'number') {
    zeroinit = true;
    size = slab;
  } else {
    zeroinit = false;
    size = slab.length;
  }

  var singleType = typeof types === 'string' ? types : null;

  var ret;
  if (allocator == ALLOC_NONE) {
    ret = ptr;
  } else {
    ret = [_malloc, Runtime.stackAlloc, Runtime.staticAlloc, Runtime.dynamicAlloc][allocator === undefined ? ALLOC_STATIC : allocator](Math.max(size, singleType ? 1 : types.length));
  }

  if (zeroinit) {
    var ptr = ret, stop;
    assert((ret & 3) == 0);
    stop = ret + (size & ~3);
    for (; ptr < stop; ptr += 4) {
      HEAP32[((ptr)>>2)]=0;
    }
    stop = ret + size;
    while (ptr < stop) {
      HEAP8[((ptr++)|0)]=0;
    }
    return ret;
  }

  if (singleType === 'i8') {
    if (slab.subarray || slab.slice) {
      HEAPU8.set(slab, ret);
    } else {
      HEAPU8.set(new Uint8Array(slab), ret);
    }
    return ret;
  }

  var i = 0, type, typeSize, previousType;
  while (i < size) {
    var curr = slab[i];

    if (typeof curr === 'function') {
      curr = Runtime.getFunctionIndex(curr);
    }

    type = singleType || types[i];
    if (type === 0) {
      i++;
      continue;
    }

    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

    setValue(ret+i, curr, type);

    // no need to look up size unless type changes, so cache it
    if (previousType !== type) {
      typeSize = Runtime.getNativeTypeSize(type);
      previousType = type;
    }
    i += typeSize;
  }

  return ret;
}
Module['allocate'] = allocate;

function Pointer_stringify(ptr, /* optional */ length) {
  // TODO: use TextDecoder
  // Find the length, and check for UTF while doing so
  var hasUtf = false;
  var t;
  var i = 0;
  while (1) {
    t = HEAPU8[(((ptr)+(i))|0)];
    if (t >= 128) hasUtf = true;
    else if (t == 0 && !length) break;
    i++;
    if (length && i == length) break;
  }
  if (!length) length = i;

  var ret = '';

  if (!hasUtf) {
    var MAX_CHUNK = 1024; // split up into chunks, because .apply on a huge string can overflow the stack
    var curr;
    while (length > 0) {
      curr = String.fromCharCode.apply(String, HEAPU8.subarray(ptr, ptr + Math.min(length, MAX_CHUNK)));
      ret = ret ? ret + curr : curr;
      ptr += MAX_CHUNK;
      length -= MAX_CHUNK;
    }
    return ret;
  }

  var utf8 = new Runtime.UTF8Processor();
  for (i = 0; i < length; i++) {
    t = HEAPU8[(((ptr)+(i))|0)];
    ret += utf8.processCChar(t);
  }
  return ret;
}
Module['Pointer_stringify'] = Pointer_stringify;

// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.
function UTF16ToString(ptr) {
  var i = 0;

  var str = '';
  while (1) {
    var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
    if (codeUnit == 0)
      return str;
    ++i;
    // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
    str += String.fromCharCode(codeUnit);
  }
}
Module['UTF16ToString'] = UTF16ToString;

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF16LE form. The copy will require at most (str.length*2+1)*2 bytes of space in the HEAP.
function stringToUTF16(str, outPtr) {
  for(var i = 0; i < str.length; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    HEAP16[(((outPtr)+(i*2))>>1)]=codeUnit;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP16[(((outPtr)+(str.length*2))>>1)]=0;
}
Module['stringToUTF16'] = stringToUTF16;

// Given a pointer 'ptr' to a null-terminated UTF32LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.
function UTF32ToString(ptr) {
  var i = 0;

  var str = '';
  while (1) {
    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0)
      return str;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
}
Module['UTF32ToString'] = UTF32ToString;

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF32LE form. The copy will require at most (str.length+1)*4 bytes of space in the HEAP,
// but can use less, since str.length does not return the number of characters in the string, but the number of UTF-16 code units in the string.
function stringToUTF32(str, outPtr) {
  var iChar = 0;
  for(var iCodeUnit = 0; iCodeUnit < str.length; ++iCodeUnit) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    var codeUnit = str.charCodeAt(iCodeUnit); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++iCodeUnit);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    HEAP32[(((outPtr)+(iChar*4))>>2)]=codeUnit;
    ++iChar;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP32[(((outPtr)+(iChar*4))>>2)]=0;
}
Module['stringToUTF32'] = stringToUTF32;

function demangle(func) {
  var i = 3;
  // params, etc.
  var basicTypes = {
    'v': 'void',
    'b': 'bool',
    'c': 'char',
    's': 'short',
    'i': 'int',
    'l': 'long',
    'f': 'float',
    'd': 'double',
    'w': 'wchar_t',
    'a': 'signed char',
    'h': 'unsigned char',
    't': 'unsigned short',
    'j': 'unsigned int',
    'm': 'unsigned long',
    'x': 'long long',
    'y': 'unsigned long long',
    'z': '...'
  };
  var subs = [];
  var first = true;
  function dump(x) {
    //return;
    if (x) Module.print(x);
    Module.print(func);
    var pre = '';
    for (var a = 0; a < i; a++) pre += ' ';
    Module.print (pre + '^');
  }
  function parseNested() {
    i++;
    if (func[i] === 'K') i++; // ignore const
    var parts = [];
    while (func[i] !== 'E') {
      if (func[i] === 'S') { // substitution
        i++;
        var next = func.indexOf('_', i);
        var num = func.substring(i, next) || 0;
        parts.push(subs[num] || '?');
        i = next+1;
        continue;
      }
      if (func[i] === 'C') { // constructor
        parts.push(parts[parts.length-1]);
        i += 2;
        continue;
      }
      var size = parseInt(func.substr(i));
      var pre = size.toString().length;
      if (!size || !pre) { i--; break; } // counter i++ below us
      var curr = func.substr(i + pre, size);
      parts.push(curr);
      subs.push(curr);
      i += pre + size;
    }
    i++; // skip E
    return parts;
  }
  function parse(rawList, limit, allowVoid) { // main parser
    limit = limit || Infinity;
    var ret = '', list = [];
    function flushList() {
      return '(' + list.join(', ') + ')';
    }
    var name;
    if (func[i] === 'N') {
      // namespaced N-E
      name = parseNested().join('::');
      limit--;
      if (limit === 0) return rawList ? [name] : name;
    } else {
      // not namespaced
      if (func[i] === 'K' || (first && func[i] === 'L')) i++; // ignore const and first 'L'
      var size = parseInt(func.substr(i));
      if (size) {
        var pre = size.toString().length;
        name = func.substr(i + pre, size);
        i += pre + size;
      }
    }
    first = false;
    if (func[i] === 'I') {
      i++;
      var iList = parse(true);
      var iRet = parse(true, 1, true);
      ret += iRet[0] + ' ' + name + '<' + iList.join(', ') + '>';
    } else {
      ret = name;
    }
    paramLoop: while (i < func.length && limit-- > 0) {
      //dump('paramLoop');
      var c = func[i++];
      if (c in basicTypes) {
        list.push(basicTypes[c]);
      } else {
        switch (c) {
          case 'P': list.push(parse(true, 1, true)[0] + '*'); break; // pointer
          case 'R': list.push(parse(true, 1, true)[0] + '&'); break; // reference
          case 'L': { // literal
            i++; // skip basic type
            var end = func.indexOf('E', i);
            var size = end - i;
            list.push(func.substr(i, size));
            i += size + 2; // size + 'EE'
            break;
          }
          case 'A': { // array
            var size = parseInt(func.substr(i));
            i += size.toString().length;
            if (func[i] !== '_') throw '?';
            i++; // skip _
            list.push(parse(true, 1, true)[0] + ' [' + size + ']');
            break;
          }
          case 'E': break paramLoop;
          default: ret += '?' + c; break paramLoop;
        }
      }
    }
    if (!allowVoid && list.length === 1 && list[0] === 'void') list = []; // avoid (void)
    if (rawList) {
      if (ret) {
        list.push(ret + '?');
      }
      return list;
    } else {
      return ret + flushList();
    }
  }
  try {
    // Special-case the entry point, since its name differs from other name mangling.
    if (func == 'Object._main' || func == '_main') {
      return 'main()';
    }
    if (typeof func === 'number') func = Pointer_stringify(func);
    if (func[0] !== '_') return func;
    if (func[1] !== '_') return func; // C function
    if (func[2] !== 'Z') return func;
    switch (func[3]) {
      case 'n': return 'operator new()';
      case 'd': return 'operator delete()';
    }
    return parse();
  } catch(e) {
    return func;
  }
}

function demangleAll(text) {
  return text.replace(/__Z[\w\d_]+/g, function(x) { var y = demangle(x); return x === y ? x : (x + ' [' + y + ']') });
}

function stackTrace() {
  var stack = new Error().stack;
  return stack ? demangleAll(stack) : '(no stack trace available)'; // Stack trace is not available at least on IE10 and Safari 6.
}

// Memory management

var PAGE_SIZE = 4096;
function alignMemoryPage(x) {
  return (x+4095)&-4096;
}

var HEAP;
var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;

var STATIC_BASE = 0, STATICTOP = 0, staticSealed = false; // static area
var STACK_BASE = 0, STACKTOP = 0, STACK_MAX = 0; // stack area
var DYNAMIC_BASE = 0, DYNAMICTOP = 0; // dynamic area handled by sbrk

function enlargeMemory() {
  abort('Cannot enlarge memory arrays. Either (1) compile with -s TOTAL_MEMORY=X with X higher than the current value ' + TOTAL_MEMORY + ', (2) compile with ALLOW_MEMORY_GROWTH which adjusts the size at runtime but prevents some optimizations, or (3) set Module.TOTAL_MEMORY before the program runs.');
}

var TOTAL_STACK = Module['TOTAL_STACK'] || 5242880;
var TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 134217728;
var FAST_MEMORY = Module['FAST_MEMORY'] || 2097152;

var totalMemory = 4096;
while (totalMemory < TOTAL_MEMORY || totalMemory < 2*TOTAL_STACK) {
  if (totalMemory < 16*1024*1024) {
    totalMemory *= 2;
  } else {
    totalMemory += 16*1024*1024
  }
}
if (totalMemory !== TOTAL_MEMORY) {
  Module.printErr('increasing TOTAL_MEMORY to ' + totalMemory + ' to be more reasonable');
  TOTAL_MEMORY = totalMemory;
}

// Initialize the runtime's memory
// check for full engine support (use string 'subarray' to avoid closure compiler confusion)
assert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && !!(new Int32Array(1)['subarray']) && !!(new Int32Array(1)['set']),
       'JS engine does not provide full typed array support');

var buffer = new ArrayBuffer(TOTAL_MEMORY);
HEAP8 = new Int8Array(buffer);
HEAP16 = new Int16Array(buffer);
HEAP32 = new Int32Array(buffer);
HEAPU8 = new Uint8Array(buffer);
HEAPU16 = new Uint16Array(buffer);
HEAPU32 = new Uint32Array(buffer);
HEAPF32 = new Float32Array(buffer);
HEAPF64 = new Float64Array(buffer);

// Endianness check (note: assumes compiler arch was little-endian)
HEAP32[0] = 255;
assert(HEAPU8[0] === 255 && HEAPU8[3] === 0, 'Typed arrays 2 must be run on a little-endian system');

Module['HEAP'] = HEAP;
Module['HEAP8'] = HEAP8;
Module['HEAP16'] = HEAP16;
Module['HEAP32'] = HEAP32;
Module['HEAPU8'] = HEAPU8;
Module['HEAPU16'] = HEAPU16;
Module['HEAPU32'] = HEAPU32;
Module['HEAPF32'] = HEAPF32;
Module['HEAPF64'] = HEAPF64;

function callRuntimeCallbacks(callbacks) {
  while(callbacks.length > 0) {
    var callback = callbacks.shift();
    if (typeof callback == 'function') {
      callback();
      continue;
    }
    var func = callback.func;
    if (typeof func === 'number') {
      if (callback.arg === undefined) {
        Runtime.dynCall('v', func);
      } else {
        Runtime.dynCall('vi', func, [callback.arg]);
      }
    } else {
      func(callback.arg === undefined ? null : callback.arg);
    }
  }
}

var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the runtime has exited

var runtimeInitialized = false;

function preRun() {
  // compatibility - merge in anything from Module['preRun'] at this time
  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPRERUN__);
}

function ensureInitRuntime() {
  if (runtimeInitialized) return;
  runtimeInitialized = true;
  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
  callRuntimeCallbacks(__ATMAIN__);
}

function exitRuntime() {
  callRuntimeCallbacks(__ATEXIT__);
}

function postRun() {
  // compatibility - merge in anything from Module['postRun'] at this time
  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}
Module['addOnPreRun'] = Module.addOnPreRun = addOnPreRun;

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}
Module['addOnInit'] = Module.addOnInit = addOnInit;

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}
Module['addOnPreMain'] = Module.addOnPreMain = addOnPreMain;

function addOnExit(cb) {
  __ATEXIT__.unshift(cb);
}
Module['addOnExit'] = Module.addOnExit = addOnExit;

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}
Module['addOnPostRun'] = Module.addOnPostRun = addOnPostRun;

// Tools

// This processes a JS string into a C-line array of numbers, 0-terminated.
// For LLVM-originating strings, see parser.js:parseLLVMString function
function intArrayFromString(stringy, dontAddNull, length /* optional */) {
  var ret = (new Runtime.UTF8Processor()).processJSString(stringy);
  if (length) {
    ret.length = length;
  }
  if (!dontAddNull) {
    ret.push(0);
  }
  return ret;
}
Module['intArrayFromString'] = intArrayFromString;

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}
Module['intArrayToString'] = intArrayToString;

// Write a Javascript array to somewhere in the heap
function writeStringToMemory(string, buffer, dontAddNull) {
  var array = intArrayFromString(string, dontAddNull);
  var i = 0;
  while (i < array.length) {
    var chr = array[i];
    HEAP8[(((buffer)+(i))|0)]=chr;
    i = i + 1;
  }
}
Module['writeStringToMemory'] = writeStringToMemory;

function writeArrayToMemory(array, buffer) {
  for (var i = 0; i < array.length; i++) {
    HEAP8[(((buffer)+(i))|0)]=array[i];
  }
}
Module['writeArrayToMemory'] = writeArrayToMemory;

function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; i++) {
    HEAP8[(((buffer)+(i))|0)]=str.charCodeAt(i);
  }
  if (!dontAddNull) HEAP8[(((buffer)+(str.length))|0)]=0;
}
Module['writeAsciiToMemory'] = writeAsciiToMemory;

function unSign(value, bits, ignore) {
  if (value >= 0) {
    return value;
  }
  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts
                    : Math.pow(2, bits)         + value;
}
function reSign(value, bits, ignore) {
  if (value <= 0) {
    return value;
  }
  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32
                        : Math.pow(2, bits-1);
  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
                                                       // TODO: In i64 mode 1, resign the two parts separately and safely
    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
  }
  return value;
}

// check for imul support, and also for correctness ( https://bugs.webkit.org/show_bug.cgi?id=126345 )
if (!Math['imul'] || Math['imul'](0xffffffff, 5) !== -5) Math['imul'] = function imul(a, b) {
  var ah  = a >>> 16;
  var al = a & 0xffff;
  var bh  = b >>> 16;
  var bl = b & 0xffff;
  return (al*bl + ((ah*bl + al*bh) << 16))|0;
};
Math.imul = Math['imul'];


var Math_abs = Math.abs;
var Math_cos = Math.cos;
var Math_sin = Math.sin;
var Math_tan = Math.tan;
var Math_acos = Math.acos;
var Math_asin = Math.asin;
var Math_atan = Math.atan;
var Math_atan2 = Math.atan2;
var Math_exp = Math.exp;
var Math_log = Math.log;
var Math_sqrt = Math.sqrt;
var Math_ceil = Math.ceil;
var Math_floor = Math.floor;
var Math_pow = Math.pow;
var Math_imul = Math.imul;
var Math_fround = Math.fround;
var Math_min = Math.min;

// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// PRE_RUN_ADDITIONS (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled

function addRunDependency(id) {
  runDependencies++;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
}
Module['addRunDependency'] = addRunDependency;
function removeRunDependency(id) {
  runDependencies--;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}
Module['removeRunDependency'] = removeRunDependency;

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data


var memoryInitializer = null;

// === Body ===
var __ZTVN10__cxxabiv117__class_type_infoE = 7024;
var __ZTVN10__cxxabiv120__si_class_type_infoE = 7064;




STATIC_BASE = 8;

STATICTOP = STATIC_BASE + Runtime.alignMemory(7731);
/* global initializers */ __ATINIT__.push();


/* memory initializer */ allocate([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,232,118,72,0,0,0,0,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,101,114,114,111,114,58,32,37,100,92,110,0,0,0,0,0,102,114,97,109,101,32,97,118,101,114,97,103,101,115,58,32,37,46,51,102,32,43,45,32,37,46,51,102,44,32,114,97,110,103,101,58,32,37,46,51,102,32,116,111,32,37,46,51,102,32,10,0,0,0,0,0,105,102,32,40,77,111,100,117,108,101,46,114,101,112,111,114,116,67,111,109,112,108,101,116,105,111,110,41,32,77,111,100,117,108,101,46,114,101,112,111,114,116,67,111,109,112,108,101,116,105,111,110,40,41,0,0,114,101,115,112,111,110,115,105,118,101,32,109,97,105,110,32,108,111,111,112,0,0,0,0,0,0,0,0,56,1,0,0,1,0,0,0,2,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,49,49,98,50,69,100,103,101,83,104,97,112,101,0,0,0,55,98,50,83,104,97,112,101,0,0,0,0,0,0,0,0,120,27,0,0,32,1,0,0,160,27,0,0,16,1,0,0,48,1,0,0,0,0,0,0,66,111,120,50,68,47,67,111,108,108,105,115,105,111,110,47,83,104,97,112,101,115,47,98,50,80,111,108,121,103,111,110,83,104,97,112,101,46,99,112,112,0,0,0,0,0,0,0,48,46,48,102,32,60,61,32,108,111,119,101,114,32,38,38,32,108,111,119,101,114,32,60,61,32,105,110,112,117,116,46,109,97,120,70,114,97,99,116,105,111,110,0,0,0,0,0,82,97,121,67,97,115,116,0,109,95,118,101,114,116,101,120,67,111,117,110,116,32,62,61,32,51,0,0,0,0,0,0,67,111,109,112,117,116,101,77,97,115,115,0,0,0,0,0,97,114,101,97,32,62,32,49,46,49,57,50,48,57,50,57,48,101,45,48,55,70,0,0,0,0,0,0,48,2,0,0,3,0,0,0,4,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,2,0,0,0,49,52,98,50,80,111,108,121,103,111,110,83,104,97,112,101,0,0,0,0,0,0,0,0,160,27,0,0,24,2,0,0,48,1,0,0,0,0,0,0,16,0,0,0,32,0,0,0,64,0,0,0,96,0,0,0,128,0,0,0,160,0,0,0,192,0,0,0,224,0,0,0,0,1,0,0,64,1,0,0,128,1,0,0,192,1,0,0,0,2,0,0,128,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,106,32,60,32,98,50,95,98,108,111,99,107,83,105,122,101,115,0,0,0,0,0,0,0,66,111,120,50,68,47,67,111,109,109,111,110,47,98,50,66,108,111,99,107,65,108,108,111,99,97,116,111,114,46,99,112,112,0,0,0,0,0,0,0,98,50,66,108,111,99,107,65,108,108,111,99,97,116,111,114,0,0,0,0,0,0,0,0,48,32,60,32,115,105,122,101,0,0,0,0,0,0,0,0,65,108,108,111,99,97,116,101,0,0,0,0,0,0,0,0,48,32,60,61,32,105,110,100,101,120,32,38,38,32,105,110,100,101,120,32,60,32,98,50,95,98,108,111,99,107,83,105,122,101,115,0,0,0,0,0,98,108,111,99,107,67,111,117,110,116,32,42,32,98,108,111,99,107,83,105,122,101,32,60,61,32,98,50,95,99,104,117,110,107,83,105,122,101,0,0,70,114,101,101,0,0,0,0,98,100,45,62,112,111,115,105,116,105,111,110,46,73,115,86,97,108,105,100,40,41,0,0,66,111,120,50,68,47,68,121,110,97,109,105,99,115,47,98,50,66,111,100,121,46,99,112,112,0,0,0,0,0,0,0,98,50,66,111,100,121,0,0,98,100,45,62,108,105,110,101,97,114,86,101,108,111,99,105,116,121,46,73,115,86,97,108,105,100,40,41,0,0,0,0,98,50,73,115,86,97,108,105,100,40,98,100,45,62,97,110,103,108,101,41,0,0,0,0,98,50,73,115,86,97,108,105,100,40,98,100,45,62,97,110,103,117,108,97,114,86,101,108,111,99,105,116,121,41,0,0,98,50,73,115,86,97,108,105,100,40,98,100,45,62,97,110,103,117,108,97,114,68,97,109,112,105,110,103,41,32,38,38,32,98,100,45,62,97,110,103,117,108,97,114,68,97,109,112,105,110,103,32,62,61,32,48,46,48,102,0,0,0,0,0,98,50,73,115,86,97,108,105,100,40,98,100,45,62,108,105,110,101,97,114,68,97,109,112,105,110,103,41,32,38,38,32,98,100,45,62,108,105,110,101,97,114,68,97,109,112,105,110,103,32,62,61,32,48,46,48,102,0,0,0,0,0,0,0,109,95,119,111,114,108,100,45,62,73,115,76,111,99,107,101,100,40,41,32,61,61,32,102,97,108,115,101,0,0,0,0,67,114,101,97,116,101,70,105,120,116,117,114,101,0,0,0,109,95,116,121,112,101,32,61,61,32,98,50,95,100,121,110,97,109,105,99,66,111,100,121,0,0,0,0,0,0,0,0,82,101,115,101,116,77,97,115,115,68,97,116,97,0,0,0,109,95,73,32,62,32,48,46,48,102,0,0,0,0,0,0,0,10,0,0,0,0,0,0,240,7,0,0,0,0,0,0,48,32,60,61,32,112,114,111,120,121,73,100,32,38,38,32,112,114,111,120,121,73,100,32,60,32,109,95,110,111,100,101,67,97,112,97,99,105,116,121,0,0,0,0,0,0,0,0,46,47,66,111,120,50,68,47,67,111,108,108,105,115,105,111,110,47,98,50,68,121,110,97,109,105,99,84,114,101,101,46,104,0,0,0,0,0,0,0,71,101,116,85,115,101,114,68,97,116,97,0,0,0,0,0,71,101,116,70,97,116,65,65,66,66,0,0,0,0,0,0,0,0,0,0,32,8,0,0,5,0,0,0,6,0,0,0,1,0,0,0,2,0,0,0,1,0,0,0,2,0,0,0,49,55,98,50,67,111,110,116,97,99,116,76,105,115,116,101,110,101,114,0,0,0,0,0,120,27,0,0,8,8,0,0,109,95,112,114,111,120,121,67,111,117,110,116,32,61,61,32,48,0,0,0,0,0,0,0,66,111,120,50,68,47,68,121,110,97,109,105,99,115,47,98,50,70,105,120,116,117,114,101,46,99,112,112,0,0,0,0,67,114,101,97,116,101,80,114,111,120,105,101,115,0,0,0,73,115,76,111,99,107,101,100,40,41,32,61,61,32,102,97,108,115,101,0,0,0,0,0,66,111,120,50,68,47,68,121,110,97,109,105,99,115,47,98,50,87,111,114,108,100,46,99,112,112,0,0,0,0,0,0,67,114,101,97,116,101,66,111,100,121,0,0,0,0,0,0,98,45,62,73,115,65,99,116,105,118,101,40,41,32,61,61,32,116,114,117,101,0,0,0,83,111,108,118,101,0,0,0,115,116,97,99,107,67,111,117,110,116,32,60,32,115,116,97,99,107,83,105,122,101,0,0,116,121,112,101,65,32,61,61,32,98,50,95,100,121,110,97,109,105,99,66,111,100,121,32,124,124,32,116,121,112,101,66,32,61,61,32,98,50,95,100,121,110,97,109,105,99,66,111,100,121,0,0,0,0,0,0,83,111,108,118,101,84,79,73,0,0,0,0,0,0,0,0,97,108,112,104,97,48,32,60,32,49,46,48,102,0,0,0,46,47,66,111,120,50,68,47,67,111,109,109,111,110,47,98,50,77,97,116,104,46,104,0,65,100,118,97,110,99,101,0,109,95,106,111,105,110,116,67,111,117,110,116,32,60,32,109,95,106,111,105,110,116,67,97,112,97,99,105,116,121,0,0,46,47,66,111,120,50,68,47,68,121,110,97,109,105,99,115,47,98,50,73,115,108,97,110,100,46,104,0,0,0,0,0,65,100,100,0,0,0,0,0,109,95,99,111,110,116,97,99,116,67,111,117,110,116,32,60,32,109,95,99,111,110,116,97,99,116,67,97,112,97,99,105,116,121,0,0,0,0,0,0,109,95,98,111,100,121,67,111,117,110,116,32,60,32,109,95,98,111,100,121,67,97,112,97,99,105,116,121,0,0,0,0,0,0,0,0,40,10,0,0,7,0,0,0,8,0,0,0,3,0,0,0,0,0,0,0,49,53,98,50,67,111,110,116,97,99,116,70,105,108,116,101,114,0,0,0,0,0,0,0,120,27,0,0,16,10,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,48,32,60,61,32,105,110,100,101,120,32,38,38,32,105,110,100,101,120,32,60,32,99,104,97,105,110,45,62,109,95,99,111,117,110,116,0,0,0,0,66,111,120,50,68,47,67,111,108,108,105,115,105,111,110,47,98,50,68,105,115,116,97,110,99,101,46,99,112,112,0,0,83,101,116,0,0,0,0,0,102,97,108,115,101,0,0,0,98,50,68,105,115,116,97,110,99,101,0,0,0,0,0,0,71,101,116,77,101,116,114,105,99,0,0,0,0,0,0,0,71,101,116,87,105,116,110,101,115,115,80,111,105,110,116,115,0,0,0,0,0,0,0,0,48,32,60,61,32,105,110,100,101,120,32,38,38,32,105,110,100,101,120,32,60,32,109,95,99,111,117,110,116,0,0,0,46,47,66,111,120,50,68,47,67,111,108,108,105,115,105,111,110,47,98,50,68,105,115,116,97,110,99,101,46,104,0,0,71,101,116,86,101,114,116,101,120,0,0,0,0,0,0,0,71,101,116,67,108,111,115,101,115,116,80,111,105,110,116,0,99,97,99,104,101,45,62,99,111,117,110,116,32,60,61,32,51,0,0,0,0,0,0,0,82,101,97,100,67,97,99,104,101,0,0,0,0,0,0,0,109,95,110,111,100,101,67,111,117,110,116,32,61,61,32,109,95,110,111,100,101,67,97,112,97,99,105,116,121,0,0,0,66,111,120,50,68,47,67,111,108,108,105,115,105,111,110,47,98,50,68,121,110,97,109,105,99,84,114,101,101,46,99,112,112,0,0,0,0,0,0,0,65,108,108,111,99,97,116,101,78,111,100,101,0,0,0,0,48,32,60,61,32,110,111,100,101,73,100,32,38,38,32,110,111,100,101,73,100,32,60,32,109,95,110,111,100,101,67,97,112,97,99,105,116,121,0,0,70,114,101,101,78,111,100,101,0,0,0,0,0,0,0,0,48,32,60,32,109,95,110,111,100,101,67,111,117,110,116,0,48,32,60,61,32,112,114,111,120,121,73,100,32,38,38,32,112,114,111,120,121,73,100,32,60,32,109,95,110,111,100,101,67,97,112,97,99,105,116,121,0,0,0,0,0,0,0,0,109,95,110,111,100,101,115,91,112,114,111,120,121,73,100,93,46,73,115,76,101,97,102,40,41,0,0,0,0,0,0,0,77,111,118,101,80,114,111,120,121,0,0,0,0,0,0,0,99,104,105,108,100,49,32,33,61,32,40,45,49,41,0,0,73,110,115,101,114,116,76,101,97,102,0,0,0,0,0,0,99,104,105,108,100,50,32,33,61,32,40,45,49,41,0,0,105,65,32,33,61,32,40,45,49,41,0,0,0,0,0,0,66,97,108,97,110,99,101,0,48,32,60,61,32,105,66,32,38,38,32,105,66,32,60,32,109,95,110,111,100,101,67,97,112,97,99,105,116,121,0,0,48,32,60,61,32,105,67,32,38,38,32,105,67,32,60,32,109,95,110,111,100,101,67,97,112,97,99,105,116,121,0,0,48,32,60,61,32,105,70,32,38,38,32,105,70,32,60,32,109,95,110,111,100,101,67,97,112,97,99,105,116,121,0,0,48,32,60,61,32,105,71,32,38,38,32,105,71,32,60,32,109,95,110,111,100,101,67,97,112,97,99,105,116,121,0,0,109,95,110,111,100,101,115,91,67,45,62,112,97,114,101,110,116,93,46,99,104,105,108,100,50,32,61,61,32,105,65,0,48,32,60,61,32,105,68,32,38,38,32,105,68,32,60,32,109,95,110,111,100,101,67,97,112,97,99,105,116,121,0,0,48,32,60,61,32,105,69,32,38,38,32,105,69,32,60,32,109,95,110,111,100,101,67,97,112,97,99,105,116,121,0,0,109,95,110,111,100,101,115,91,66,45,62,112,97,114,101,110,116,93,46,99,104,105,108,100,50,32,61,61,32,105,65,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,116,97,114,103,101,116,32,62,32,116,111,108,101,114,97,110,99,101,0,0,0,0,0,0,66,111,120,50,68,47,67,111,108,108,105,115,105,111,110,47,98,50,84,105,109,101,79,102,73,109,112,97,99,116,46,99,112,112,0,0,0,0,0,0,98,50,84,105,109,101,79,102,73,109,112,97,99,116,0,0,102,97,108,115,101,0,0,0,69,118,97,108,117,97,116,101,0,0,0,0,0,0,0,0,48,32,60,61,32,105,110,100,101,120,32,38,38,32,105,110,100,101,120,32,60,32,109,95,99,111,117,110,116,0,0,0,46,47,66,111,120,50,68,47,67,111,108,108,105,115,105,111,110,47,98,50,68,105,115,116,97,110,99,101,46,104,0,0,71,101,116,86,101,114,116,101,120,0,0,0,0,0,0,0,70,105,110,100,77,105,110,83,101,112,97,114,97,116,105,111,110,0,0,0,0,0,0,0,48,32,60,32,99,111,117,110,116,32,38,38,32,99,111,117,110,116,32,60,32,51,0,0,73,110,105,116,105,97,108,105,122,101,0,0,0,0,0,0,0,0,0,0,0,0,0,0,109,95,105,110,100,101,120,32,61,61,32,48,0,0,0,0,66,111,120,50,68,47,67,111,109,109,111,110,47,98,50,83,116,97,99,107,65,108,108,111,99,97,116,111,114,46,99,112,112,0,0,0,0,0,0,0,126,98,50,83,116,97,99,107,65,108,108,111,99,97,116,111,114,0,0,0,0,0,0,0,109,95,101,110,116,114,121,67,111,117,110,116,32,61,61,32,48,0,0,0,0,0,0,0,109,95,101,110,116,114,121,67,111,117,110,116,32,60,32,98,50,95,109,97,120,83,116,97,99,107,69,110,116,114,105,101,115,0,0,0,0,0,0,0,65,108,108,111,99,97,116,101,0,0,0,0,0,0,0,0,109,95,101,110,116,114,121,67,111,117,110,116,32,62,32,48,0,0,0,0,0,0,0,0,70,114,101,101,0,0,0,0,112,32,61,61,32,101,110,116,114,121,45,62,100,97,116,97,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,48,32,60,61,32,116,121,112,101,49,32,38,38,32,116,121,112,101,49,32,60,32,98,50,83,104,97,112,101,58,58,101,95,116,121,112,101,67,111,117,110,116,0,0,0,0,0,0,66,111,120,50,68,47,68,121,110,97,109,105,99,115,47,67,111,110,116,97,99,116,115,47,98,50,67,111,110,116,97,99,116,46,99,112,112,0,0,0,48,32,60,61,32,116,121,112,101,50,32,38,38,32,116,121,112,101,50,32,60,32,98,50,83,104,97,112,101,58,58,101,95,116,121,112,101,67,111,117,110,116,0,0,0,0,0,0,67,114,101,97,116,101,0,0,115,95,105,110,105,116,105,97,108,105,122,101,100,32,61,61,32,116,114,117,101,0,0,0,68,101,115,116,114,111,121,0,48,32,60,61,32,116,121,112,101,65,32,38,38,32,116,121,112,101,66,32,60,32,98,50,83,104,97,112,101,58,58,101,95,116,121,112,101,67,111,117,110,116,0,0,0,0,0,0,0,0,0,0,120,17,0,0,1,0,0,0,9,0,0,0,10,0,0,0,0,0,0,0,57,98,50,67,111,110,116,97,99,116,0,0,0,0,0,0,120,27,0,0,104,17,0,0,0,0,0,0,104,18,0,0,3,0,0,0,11,0,0,0,12,0,0,0,0,0,0,0,109,95,102,105,120,116,117,114,101,65,45,62,71,101,116,84,121,112,101,40,41,32,61,61,32,98,50,83,104,97,112,101,58,58,101,95,101,100,103,101,0,0,0,0,0,0,0,0,66,111,120,50,68,47,68,121,110,97,109,105,99,115,47,67,111,110,116,97,99,116,115,47,98,50,69,100,103,101,65,110,100,67,105,114,99,108,101,67,111,110,116,97,99,116,46,99,112,112,0,0,0,0,0,0,98,50,69,100,103,101,65,110,100,67,105,114,99,108,101,67,111,110,116,97,99,116,0,0,109,95,102,105,120,116,117,114,101,66,45,62,71,101,116,84,121,112,101,40,41,32,61,61,32,98,50,83,104,97,112,101,58,58,101,95,99,105,114,99,108,101,0,0,0,0,0,0,50,50,98,50,69,100,103,101,65,110,100,67,105,114,99,108,101,67,111,110,116,97,99,116,0,0,0,0,0,0,0,0,160,27,0,0,72,18,0,0,120,17,0,0,0,0,0,0,0,0,0,0,96,19,0,0,4,0,0,0,13,0,0,0,14,0,0,0,0,0,0,0,109,95,102,105,120,116,117,114,101,65,45,62,71,101,116,84,121,112,101,40,41,32,61,61,32,98,50,83,104,97,112,101,58,58,101,95,101,100,103,101,0,0,0,0,0,0,0,0,66,111,120,50,68,47,68,121,110,97,109,105,99,115,47,67,111,110,116,97,99,116,115,47,98,50,69,100,103,101,65,110,100,80,111,108,121,103,111,110,67,111,110,116,97,99,116,46,99,112,112,0,0,0,0,0,98,50,69,100,103,101,65,110,100,80,111,108,121,103,111,110,67,111,110,116,97,99,116,0,109,95,102,105,120,116,117,114,101,66,45,62,71,101,116,84,121,112,101,40,41,32,61,61,32,98,50,83,104,97,112,101,58,58,101,95,112,111,108,121,103,111,110,0,0,0,0,0,50,51,98,50,69,100,103,101,65,110,100,80,111,108,121,103,111,110,67,111,110,116,97,99,116,0,0,0,0,0,0,0,160,27,0,0,64,19,0,0,120,17,0,0,0,0,0,0,0,0,0,0,96,20,0,0,5,0,0,0,15,0,0,0,16,0,0,0,0,0,0,0,109,95,102,105,120,116,117,114,101,65,45,62,71,101,116,84,121,112,101,40,41,32,61,61,32,98,50,83,104,97,112,101,58,58,101,95,112,111,108,121,103,111,110,0,0,0,0,0,66,111,120,50,68,47,68,121,110,97,109,105,99,115,47,67,111,110,116,97,99,116,115,47,98,50,80,111,108,121,103,111,110,65,110,100,67,105,114,99,108,101,67,111,110,116,97,99,116,46,99,112,112,0,0,0,98,50,80,111,108,121,103,111,110,65,110,100,67,105,114,99,108,101,67,111,110,116,97,99,116,0,0,0,0,0,0,0,109,95,102,105,120,116,117,114,101,66,45,62,71,101,116,84,121,112,101,40,41,32,61,61,32,98,50,83,104,97,112,101,58,58,101,95,99,105,114,99,108,101,0,0,0,0,0,0,50,53,98,50,80,111,108,121,103,111,110,65,110,100,67,105,114,99,108,101,67,111,110,116,97,99,116,0,0,0,0,0,160,27,0,0,64,20,0,0,120,17,0,0,0,0,0,0,0,0,0,0,72,21,0,0,6,0,0,0,17,0,0,0,18,0,0,0,0,0,0,0,109,95,102,105,120,116,117,114,101,65,45,62,71,101,116,84,121,112,101,40,41,32,61,61,32,98,50,83,104,97,112,101,58,58,101,95,112,111,108,121,103,111,110,0,0,0,0,0,66,111,120,50,68,47,68,121,110,97,109,105,99,115,47,67,111,110,116,97,99,116,115,47,98,50,80,111,108,121,103,111,110,67,111,110,116,97,99,116,46,99,112,112,0,0,0,0,98,50,80,111,108,121,103,111,110,67,111,110,116,97,99,116,0,0,0,0,0,0,0,0,109,95,102,105,120,116,117,114,101,66,45,62,71,101,116,84,121,112,101,40,41,32,61,61,32,98,50,83,104,97,112,101,58,58,101,95,112,111,108,121,103,111,110,0,0,0,0,0,49,54,98,50,80,111,108,121,103,111,110,67,111,110,116,97,99,116,0,0,0,0,0,0,160,27,0,0,48,21,0,0,120,17,0,0,0,0,0,0,116,111,105,73,110,100,101,120,65,32,60,32,109,95,98,111,100,121,67,111,117,110,116,0,66,111,120,50,68,47,68,121,110,97,109,105,99,115,47,98,50,73,115,108,97,110,100,46,99,112,112,0,0,0,0,0,83,111,108,118,101,84,79,73,0,0,0,0,0,0,0,0,116,111,105,73,110,100,101,120,66,32,60,32,109,95,98,111,100,121,67,111,117,110,116,0,100,101,110,32,62,32,48,46,48,102,0,0,0,0,0,0,66,111,120,50,68,47,67,111,108,108,105,115,105,111,110,47,98,50,67,111,108,108,105,100,101,69,100,103,101,46,99,112,112,0,0,0,0,0,0,0,98,50,67,111,108,108,105,100,101,69,100,103,101,65,110,100,67,105,114,99,108,101,0,0,48,32,60,61,32,101,100,103,101,49,32,38,38,32,101,100,103,101,49,32,60,32,112,111,108,121,49,45,62,109,95,118,101,114,116,101,120,67,111,117,110,116,0,0,0,0,0,0,66,111,120,50,68,47,67,111,108,108,105,115,105,111,110,47,98,50,67,111,108,108,105,100,101,80,111,108,121,103,111,110,46,99,112,112,0,0,0,0,98,50,70,105,110,100,73,110,99,105,100,101,110,116,69,100,103,101,0,0,0,0,0,0,98,50,69,100,103,101,83,101,112,97,114,97,116,105,111,110,0,0,0,0,0,0,0,0,0,0,0,0,120,23,0,0,7,0,0,0,19,0,0,0,20,0,0,0,0,0,0,0,109,95,102,105,120,116,117,114,101,65,45,62,71,101,116,84,121,112,101,40,41,32,61,61,32,98,50,83,104,97,112,101,58,58,101,95,99,104,97,105,110,0,0,0,0,0,0,0,66,111,120,50,68,47,68,121,110,97,109,105,99,115,47,67,111,110,116,97,99,116,115,47,98,50,67,104,97,105,110,65,110,100,67,105,114,99,108,101,67,111,110,116,97,99,116,46,99,112,112,0,0,0,0,0,98,50,67,104,97,105,110,65,110,100,67,105,114,99,108,101,67,111,110,116,97,99,116,0,109,95,102,105,120,116,117,114,101,66,45,62,71,101,116,84,121,112,101,40,41,32,61,61,32,98,50,83,104,97,112,101,58,58,101,95,99,105,114,99,108,101,0,0,0,0,0,0,50,51,98,50,67,104,97,105,110,65,110,100,67,105,114,99,108,101,67,111,110,116,97,99,116,0,0,0,0,0,0,0,160,27,0,0,88,23,0,0,120,17,0,0,0,0,0,0,0,0,0,0,120,24,0,0,8,0,0,0,21,0,0,0,22,0,0,0,0,0,0,0,109,95,102,105,120,116,117,114,101,65,45,62,71,101,116,84,121,112,101,40,41,32,61,61,32,98,50,83,104,97,112,101,58,58,101,95,99,104,97,105,110,0,0,0,0,0,0,0,66,111,120,50,68,47,68,121,110,97,109,105,99,115,47,67,111,110,116,97,99,116,115,47,98,50,67,104,97,105,110,65,110,100,80,111,108,121,103,111,110,67,111,110,116,97,99,116,46,99,112,112,0,0,0,0,98,50,67,104,97,105,110,65,110,100,80,111,108,121,103,111,110,67,111,110,116,97,99,116,0,0,0,0,0,0,0,0,109,95,102,105,120,116,117,114,101,66,45,62,71,101,116,84,121,112,101,40,41,32,61,61,32,98,50,83,104,97,112,101,58,58,101,95,112,111,108,121,103,111,110,0,0,0,0,0,50,52,98,50,67,104,97,105,110,65,110,100,80,111,108,121,103,111,110,67,111,110,116,97,99,116,0,0,0,0,0,0,160,27,0,0,88,24,0,0,120,17,0,0,0,0,0,0,0,0,0,0,88,25,0,0,9,0,0,0,23,0,0,0,24,0,0,0,0,0,0,0,109,95,102,105,120,116,117,114,101,65,45,62,71,101,116,84,121,112,101,40,41,32,61,61,32,98,50,83,104,97,112,101,58,58,101,95,99,105,114,99,108,101,0,0,0,0,0,0,66,111,120,50,68,47,68,121,110,97,109,105,99,115,47,67,111,110,116,97,99,116,115,47,98,50,67,105,114,99,108,101,67,111,110,116,97,99,116,46,99,112,112,0,0,0,0,0,98,50,67,105,114,99,108,101,67,111,110,116,97,99,116,0,109,95,102,105,120,116,117,114,101,66,45,62,71,101,116,84,121,112,101,40,41,32,61,61,32,98,50,83,104,97,112,101,58,58,101,95,99,105,114,99,108,101,0,0,0,0,0,0,49,53,98,50,67,105,114,99,108,101,67,111,110,116,97,99,116,0,0,0,0,0,0,0,160,27,0,0,64,25,0,0,120,17,0,0,0,0,0,0,112,111,105,110,116,67,111,117,110,116,32,62,32,48,0,0,66,111,120,50,68,47,68,121,110,97,109,105,99,115,47,67,111,110,116,97,99,116,115,47,98,50,67,111,110,116,97,99,116,83,111,108,118,101,114,46,99,112,112,0,0,0,0,0,98,50,67,111,110,116,97,99,116,83,111,108,118,101,114,0,109,97,110,105,102,111,108,100,45,62,112,111,105,110,116,67,111,117,110,116,32,62,32,48,0,0,0,0,0,0,0,0,73,110,105,116,105,97,108,105,122,101,86,101,108,111,99,105,116,121,67,111,110,115,116,114,97,105,110,116,115,0,0,0,112,111,105,110,116,67,111,117,110,116,32,61,61,32,49,32,124,124,32,112,111,105,110,116,67,111,117,110,116,32,61,61,32,50,0,0,0,0,0,0,83,111,108,118,101,86,101,108,111,99,105,116,121,67,111,110,115,116,114,97,105,110,116,115,0,0,0,0,0,0,0,0,97,46,120,32,62,61,32,48,46,48,102,32,38,38,32,97,46,121,32,62,61,32,48,46,48,102,0,0,0,0,0,0,112,99,45,62,112,111,105,110,116,67,111,117,110,116,32,62,32,48,0,0,0,0,0,0,73,110,105,116,105,97,108,105,122,101,0,0,0,0,0,0,66,111,120,50,68,47,67,111,108,108,105,115,105,111,110,47,83,104,97,112,101,115,47,98,50,67,104,97,105,110,83,104,97,112,101,46,99,112,112,0,48,32,60,61,32,105,110,100,101,120,32,38,38,32,105,110,100,101,120,32,60,32,109,95,99,111,117,110,116,32,45,32,49,0,0,0,0,0,0,0,71,101,116,67,104,105,108,100,69,100,103,101,0,0,0,0,83,116,57,116,121,112,101,95,105,110,102,111,0,0,0,0,120,27,0,0,232,26,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,54,95,95,115,104,105,109,95,116,121,112,101,95,105,110,102,111,69,0,0,0,0,0,0,0,0,160,27,0,0,0,27,0,0,248,26,0,0,0,0,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,55,95,95,99,108,97,115,115,95,116,121,112,101,95,105,110,102,111,69,0,0,0,0,0,0,0,160,27,0,0,56,27,0,0,40,27,0,0,0,0,0,0,0,0,0,0,96,27,0,0,25,0,0,0,26,0,0,0,27,0,0,0,28,0,0,0,4,0,0,0,1,0,0,0,1,0,0,0,10,0,0,0,0,0,0,0,232,27,0,0,25,0,0,0,29,0,0,0,27,0,0,0,28,0,0,0,4,0,0,0,2,0,0,0,2,0,0,0,11,0,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,50,48,95,95,115,105,95,99,108,97,115,115,95,116,121,112,101,95,105,110,102,111,69,0,0,0,0,160,27,0,0,192,27,0,0,96,27,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,40,30,0,0,30,0,0,0,31,0,0,0,3,0,0,0,0,0,0,0,115,116,100,58,58,98,97,100,95,97,108,108,111,99,0,0,83,116,57,98,97,100,95,97,108,108,111,99,0,0,0,0,160,27,0,0,24,30,0,0,0,0,0,0,0,0,0,0], "i8", ALLOC_NONE, Runtime.GLOBAL_BASE);




var tempDoublePtr = Runtime.alignMemory(allocate(12, "i8", ALLOC_STATIC), 8);

assert(tempDoublePtr % 8 == 0);

function copyTempFloat(ptr) { // functions, because inlining this code increases code size too much

  HEAP8[tempDoublePtr] = HEAP8[ptr];

  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];

  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];

  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];

}

function copyTempDouble(ptr) {

  HEAP8[tempDoublePtr] = HEAP8[ptr];

  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];

  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];

  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];

  HEAP8[tempDoublePtr+4] = HEAP8[ptr+4];

  HEAP8[tempDoublePtr+5] = HEAP8[ptr+5];

  HEAP8[tempDoublePtr+6] = HEAP8[ptr+6];

  HEAP8[tempDoublePtr+7] = HEAP8[ptr+7];

}


  function _emscripten_set_main_loop(func, fps, simulateInfiniteLoop, arg) {
      Module['noExitRuntime'] = true;

      Browser.mainLoop.runner = function Browser_mainLoop_runner() {
        if (ABORT) return;
        if (Browser.mainLoop.queue.length > 0) {
          var start = Date.now();
          var blocker = Browser.mainLoop.queue.shift();
          blocker.func(blocker.arg);
          if (Browser.mainLoop.remainingBlockers) {
            var remaining = Browser.mainLoop.remainingBlockers;
            var next = remaining%1 == 0 ? remaining-1 : Math.floor(remaining);
            if (blocker.counted) {
              Browser.mainLoop.remainingBlockers = next;
            } else {
              // not counted, but move the progress along a tiny bit
              next = next + 0.5; // do not steal all the next one's progress
              Browser.mainLoop.remainingBlockers = (8*remaining + next)/9;
            }
          }
          console.log('main loop blocker "' + blocker.name + '" took ' + (Date.now() - start) + ' ms'); //, left: ' + Browser.mainLoop.remainingBlockers);
          Browser.mainLoop.updateStatus();
          setTimeout(Browser.mainLoop.runner, 0);
          return;
        }
        if (Browser.mainLoop.shouldPause) {
          // catch pauses from non-main loop sources
          Browser.mainLoop.paused = true;
          Browser.mainLoop.shouldPause = false;
          return;
        }

        // Signal GL rendering layer that processing of a new frame is about to start. This helps it optimize
        // VBO double-buffering and reduce GPU stalls.

        if (Browser.mainLoop.method === 'timeout' && Module.ctx) {
          Module.printErr('Looks like you are rendering without using requestAnimationFrame for the main loop. You should use 0 for the frame rate in emscripten_set_main_loop in order to use requestAnimationFrame, as that can greatly improve your frame rates!');
          Browser.mainLoop.method = ''; // just warn once per call to set main loop
        }

        if (Module['preMainLoop']) {
          Module['preMainLoop']();
        }

        try {
          if (typeof arg !== 'undefined') {
            Runtime.dynCall('vi', func, [arg]);
          } else {
            Runtime.dynCall('v', func);
          }
        } catch (e) {
          if (e instanceof ExitStatus) {
            return;
          } else {
            if (e && typeof e === 'object' && e.stack) Module.printErr('exception thrown: ' + [e, e.stack]);
            throw e;
          }
        }

        if (Module['postMainLoop']) {
          Module['postMainLoop']();
        }

        if (Browser.mainLoop.shouldPause) {
          // catch pauses from the main loop itself
          Browser.mainLoop.paused = true;
          Browser.mainLoop.shouldPause = false;
          return;
        }
        Browser.mainLoop.scheduler();
      }
      if (fps && fps > 0) {
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler() {
          setTimeout(Browser.mainLoop.runner, 1000/fps); // doing this each time means that on exception, we stop
        };
        Browser.mainLoop.method = 'timeout';
      } else {
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler() {
          Browser.requestAnimationFrame(Browser.mainLoop.runner);
        };
        Browser.mainLoop.method = 'rAF';
      }
      Browser.mainLoop.scheduler();

      if (simulateInfiniteLoop) {
        throw 'SimulateInfiniteLoop';
      }
    }

  var _cosf=Math_cos;

  function ___cxa_pure_virtual() {
      ABORT = true;
      throw 'Pure virtual function called!';
    }

  function _time(ptr) {
      var ret = Math.floor(Date.now()/1000);
      if (ptr) {
        HEAP32[((ptr)>>2)]=ret;
      }
      return ret;
    }

  function ___assert_fail(condition, filename, line, func) {
      ABORT = true;
      throw 'Assertion failed: ' + Pointer_stringify(condition) + ', at: ' + [filename ? Pointer_stringify(filename) : 'unknown filename', line, func ? Pointer_stringify(func) : 'unknown function'] + ' at ' + stackTrace();
    }


  function __ZSt18uncaught_exceptionv() { // std::uncaught_exception()
      return !!__ZSt18uncaught_exceptionv.uncaught_exception;
    }



  function ___cxa_is_number_type(type) {
      var isNumber = false;
      try { if (type == __ZTIi) isNumber = true } catch(e){}
      try { if (type == __ZTIj) isNumber = true } catch(e){}
      try { if (type == __ZTIl) isNumber = true } catch(e){}
      try { if (type == __ZTIm) isNumber = true } catch(e){}
      try { if (type == __ZTIx) isNumber = true } catch(e){}
      try { if (type == __ZTIy) isNumber = true } catch(e){}
      try { if (type == __ZTIf) isNumber = true } catch(e){}
      try { if (type == __ZTId) isNumber = true } catch(e){}
      try { if (type == __ZTIe) isNumber = true } catch(e){}
      try { if (type == __ZTIc) isNumber = true } catch(e){}
      try { if (type == __ZTIa) isNumber = true } catch(e){}
      try { if (type == __ZTIh) isNumber = true } catch(e){}
      try { if (type == __ZTIs) isNumber = true } catch(e){}
      try { if (type == __ZTIt) isNumber = true } catch(e){}
      return isNumber;
    }function ___cxa_does_inherit(definiteType, possibilityType, possibility) {
      if (possibility == 0) return false;
      if (possibilityType == 0 || possibilityType == definiteType)
        return true;
      var possibility_type_info;
      if (___cxa_is_number_type(possibilityType)) {
        possibility_type_info = possibilityType;
      } else {
        var possibility_type_infoAddr = HEAP32[((possibilityType)>>2)] - 8;
        possibility_type_info = HEAP32[((possibility_type_infoAddr)>>2)];
      }
      switch (possibility_type_info) {
      case 0: // possibility is a pointer
        // See if definite type is a pointer
        var definite_type_infoAddr = HEAP32[((definiteType)>>2)] - 8;
        var definite_type_info = HEAP32[((definite_type_infoAddr)>>2)];
        if (definite_type_info == 0) {
          // Also a pointer; compare base types of pointers
          var defPointerBaseAddr = definiteType+8;
          var defPointerBaseType = HEAP32[((defPointerBaseAddr)>>2)];
          var possPointerBaseAddr = possibilityType+8;
          var possPointerBaseType = HEAP32[((possPointerBaseAddr)>>2)];
          return ___cxa_does_inherit(defPointerBaseType, possPointerBaseType, possibility);
        } else
          return false; // one pointer and one non-pointer
      case 1: // class with no base class
        return false;
      case 2: // class with base class
        var parentTypeAddr = possibilityType + 8;
        var parentType = HEAP32[((parentTypeAddr)>>2)];
        return ___cxa_does_inherit(definiteType, parentType, possibility);
      default:
        return false; // some unencountered type
      }
    }



  var ___cxa_last_thrown_exception=0;function ___resumeException(ptr) {
      if (!___cxa_last_thrown_exception) { ___cxa_last_thrown_exception = ptr; }
      throw ptr + " - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.";
    }

  var ___cxa_exception_header_size=8;function ___cxa_find_matching_catch(thrown, throwntype) {
      if (thrown == -1) thrown = ___cxa_last_thrown_exception;
      header = thrown - ___cxa_exception_header_size;
      if (throwntype == -1) throwntype = HEAP32[((header)>>2)];
      var typeArray = Array.prototype.slice.call(arguments, 2);

      // If throwntype is a pointer, this means a pointer has been
      // thrown. When a pointer is thrown, actually what's thrown
      // is a pointer to the pointer. We'll dereference it.
      if (throwntype != 0 && !___cxa_is_number_type(throwntype)) {
        var throwntypeInfoAddr= HEAP32[((throwntype)>>2)] - 8;
        var throwntypeInfo= HEAP32[((throwntypeInfoAddr)>>2)];
        if (throwntypeInfo == 0)
          thrown = HEAP32[((thrown)>>2)];
      }
      // The different catch blocks are denoted by different types.
      // Due to inheritance, those types may not precisely match the
      // type of the thrown object. Find one which matches, and
      // return the type of the catch block which should be called.
      for (var i = 0; i < typeArray.length; i++) {
        if (___cxa_does_inherit(typeArray[i], throwntype, thrown))
          return ((asm["setTempRet0"](typeArray[i]),thrown)|0);
      }
      // Shouldn't happen unless we have bogus data in typeArray
      // or encounter a type for which emscripten doesn't have suitable
      // typeinfo defined. Best-efforts match just in case.
      return ((asm["setTempRet0"](throwntype),thrown)|0);
    }function ___cxa_throw(ptr, type, destructor) {
      if (!___cxa_throw.initialized) {
        try {
          HEAP32[((__ZTVN10__cxxabiv119__pointer_type_infoE)>>2)]=0; // Workaround for libcxxabi integration bug
        } catch(e){}
        try {
          HEAP32[((__ZTVN10__cxxabiv117__class_type_infoE)>>2)]=1; // Workaround for libcxxabi integration bug
        } catch(e){}
        try {
          HEAP32[((__ZTVN10__cxxabiv120__si_class_type_infoE)>>2)]=2; // Workaround for libcxxabi integration bug
        } catch(e){}
        ___cxa_throw.initialized = true;
      }
      var header = ptr - ___cxa_exception_header_size;
      HEAP32[((header)>>2)]=type;
      HEAP32[(((header)+(4))>>2)]=destructor;
      ___cxa_last_thrown_exception = ptr;
      if (!("uncaught_exception" in __ZSt18uncaught_exceptionv)) {
        __ZSt18uncaught_exceptionv.uncaught_exception = 1;
      } else {
        __ZSt18uncaught_exceptionv.uncaught_exception++;
      }
      throw ptr + " - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.";
    }


  Module["_memset"] = _memset;



  function __exit(status) {
      // void _exit(int status);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/exit.html
      Module['exit'](status);
    }function _exit(status) {
      __exit(status);
    }function __ZSt9terminatev() {
      _exit(-1234);
    }

  function _abort() {
      Module['abort']();
    }





  var ERRNO_CODES={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};

  var ERRNO_MESSAGES={0:"Success",1:"Not super-user",2:"No such file or directory",3:"No such process",4:"Interrupted system call",5:"I/O error",6:"No such device or address",7:"Arg list too long",8:"Exec format error",9:"Bad file number",10:"No children",11:"No more processes",12:"Not enough core",13:"Permission denied",14:"Bad address",15:"Block device required",16:"Mount device busy",17:"File exists",18:"Cross-device link",19:"No such device",20:"Not a directory",21:"Is a directory",22:"Invalid argument",23:"Too many open files in system",24:"Too many open files",25:"Not a typewriter",26:"Text file busy",27:"File too large",28:"No space left on device",29:"Illegal seek",30:"Read only file system",31:"Too many links",32:"Broken pipe",33:"Math arg out of domain of func",34:"Math result not representable",35:"File locking deadlock error",36:"File or path name too long",37:"No record locks available",38:"Function not implemented",39:"Directory not empty",40:"Too many symbolic links",42:"No message of desired type",43:"Identifier removed",44:"Channel number out of range",45:"Level 2 not synchronized",46:"Level 3 halted",47:"Level 3 reset",48:"Link number out of range",49:"Protocol driver not attached",50:"No CSI structure available",51:"Level 2 halted",52:"Invalid exchange",53:"Invalid request descriptor",54:"Exchange full",55:"No anode",56:"Invalid request code",57:"Invalid slot",59:"Bad font file fmt",60:"Device not a stream",61:"No data (for no delay io)",62:"Timer expired",63:"Out of streams resources",64:"Machine is not on the network",65:"Package not installed",66:"The object is remote",67:"The link has been severed",68:"Advertise error",69:"Srmount error",70:"Communication error on send",71:"Protocol error",72:"Multihop attempted",73:"Cross mount point (not really error)",74:"Trying to read unreadable message",75:"Value too large for defined data type",76:"Given log. name not unique",77:"f.d. invalid for this operation",78:"Remote address changed",79:"Can   access a needed shared lib",80:"Accessing a corrupted shared lib",81:".lib section in a.out corrupted",82:"Attempting to link in too many libs",83:"Attempting to exec a shared library",84:"Illegal byte sequence",86:"Streams pipe error",87:"Too many users",88:"Socket operation on non-socket",89:"Destination address required",90:"Message too long",91:"Protocol wrong type for socket",92:"Protocol not available",93:"Unknown protocol",94:"Socket type not supported",95:"Not supported",96:"Protocol family not supported",97:"Address family not supported by protocol family",98:"Address already in use",99:"Address not available",100:"Network interface is not configured",101:"Network is unreachable",102:"Connection reset by network",103:"Connection aborted",104:"Connection reset by peer",105:"No buffer space available",106:"Socket is already connected",107:"Socket is not connected",108:"Can't send after socket shutdown",109:"Too many references",110:"Connection timed out",111:"Connection refused",112:"Host is down",113:"Host is unreachable",114:"Socket already connected",115:"Connection already in progress",116:"Stale file handle",122:"Quota exceeded",123:"No medium (in tape drive)",125:"Operation canceled",130:"Previous owner died",131:"State not recoverable"};


  var ___errno_state=0;function ___setErrNo(value) {
      // For convenient setting and returning of errno.
      HEAP32[((___errno_state)>>2)]=value;
      return value;
    }

  var PATH={splitPath:function (filename) {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },normalizeArray:function (parts, allowAboveRoot) {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
          for (; up--; up) {
            parts.unshift('..');
          }
        }
        return parts;
      },normalize:function (path) {
        var isAbsolute = path.charAt(0) === '/',
            trailingSlash = path.substr(-1) === '/';
        // Normalize the path
        path = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },dirname:function (path) {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // No dirname whatsoever
          return '.';
        }
        if (dir) {
          // It has a dirname, strip trailing slash
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },basename:function (path) {
        // EMSCRIPTEN return '/'' for '/', not an empty string
        if (path === '/') return '/';
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },extname:function (path) {
        return PATH.splitPath(path)[3];
      },join:function () {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join('/'));
      },join2:function (l, r) {
        return PATH.normalize(l + '/' + r);
      },resolve:function () {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? arguments[i] : FS.cwd();
          // Skip empty and invalid entries
          if (typeof path !== 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            continue;
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = path.charAt(0) === '/';
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter(function(p) {
          return !!p;
        }), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },relative:function (from, to) {
        from = PATH.resolve(from).substr(1);
        to = PATH.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      }};

  var TTY={ttys:[],init:function () {
        // https://github.com/kripken/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY
        //   // device, it always assumes it's a TTY device. because of this, we're forcing
        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible
        //   // with text files until FS.init can be refactored.
        //   process['stdin']['setEncoding']('utf8');
        // }
      },shutdown:function () {
        // https://github.com/kripken/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
        //   process['stdin']['pause']();
        // }
      },register:function (dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },stream_ops:{open:function (stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
          }
          stream.tty = tty;
          stream.seekable = false;
        },close:function (stream) {
          // flush any pending line data
          if (stream.tty.output.length) {
            stream.tty.ops.put_char(stream.tty, 10);
          }
        },read:function (stream, buffer, offset, length, pos /* ignored */) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },write:function (stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(ERRNO_CODES.ENXIO);
          }
          for (var i = 0; i < length; i++) {
            try {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO);
            }
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }},default_tty_ops:{get_char:function (tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              result = process['stdin']['read']();
              if (!result) {
                if (process['stdin']['_readableState'] && process['stdin']['_readableState']['ended']) {
                  return null;  // EOF
                }
                return undefined;  // no data available
              }
            } else if (typeof window != 'undefined' &&
              typeof window.prompt == 'function') {
              // Browser.
              result = window.prompt('Input: ');  // returns null on cancel
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              // Command line.
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },put_char:function (tty, val) {
          if (val === null || val === 10) {
            Module['print'](tty.output.join(''));
            tty.output = [];
          } else {
            tty.output.push(TTY.utf8.processCChar(val));
          }
        }},default_tty1_ops:{put_char:function (tty, val) {
          if (val === null || val === 10) {
            Module['printErr'](tty.output.join(''));
            tty.output = [];
          } else {
            tty.output.push(TTY.utf8.processCChar(val));
          }
        }}};

  var MEMFS={ops_table:null,CONTENT_OWNING:1,CONTENT_FLEXIBLE:2,CONTENT_FIXED:3,mount:function (mount) {
        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createNode:function (parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          // no supported
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            },
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.contents = [];
          node.contentMode = MEMFS.CONTENT_FLEXIBLE;
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        // add the new node to the parent
        if (parent) {
          parent.contents[name] = node;
        }
        return node;
      },ensureFlexible:function (node) {
        if (node.contentMode !== MEMFS.CONTENT_FLEXIBLE) {
          var contents = node.contents;
          node.contents = Array.prototype.slice.call(contents);
          node.contentMode = MEMFS.CONTENT_FLEXIBLE;
        }
      },node_ops:{getattr:function (node) {
          var attr = {};
          // device numbers reuse inode numbers.
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.contents.length;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
          //       but this is not required by the standard.
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },setattr:function (node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.ensureFlexible(node);
            var contents = node.contents;
            if (attr.size < contents.length) contents.length = attr.size;
            else while (attr.size > contents.length) contents.push(0);
          }
        },lookup:function (parent, name) {
          throw FS.genericErrors[ERRNO_CODES.ENOENT];
        },mknod:function (parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },rename:function (old_node, new_dir, new_name) {
          // if we're overwriting a directory at new_name, make sure it's empty.
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
              }
            }
          }
          // do the internal rewiring
          delete old_node.parent.contents[old_node.name];
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          old_node.parent = new_dir;
        },unlink:function (parent, name) {
          delete parent.contents[name];
        },rmdir:function (parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
          }
          delete parent.contents[name];
        },readdir:function (node) {
          var entries = ['.', '..']
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },symlink:function (parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);
          node.link = oldpath;
          return node;
        },readlink:function (node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          return node.link;
        }},stream_ops:{read:function (stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          assert(size >= 0);
          if (size > 8 && contents.subarray) { // non-trivial, and typed array
            buffer.set(contents.subarray(position, position + size), offset);
          } else
          {
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          }
          return size;
        },write:function (stream, buffer, offset, length, position, canOwn) {
          var node = stream.node;
          node.timestamp = Date.now();
          var contents = node.contents;
          if (length && contents.length === 0 && position === 0 && buffer.subarray) {
            // just replace it with the new data
            if (canOwn && offset === 0) {
              node.contents = buffer; // this could be a subarray of Emscripten HEAP, or allocated from some other source.
              node.contentMode = (buffer.buffer === HEAP8.buffer) ? MEMFS.CONTENT_OWNING : MEMFS.CONTENT_FIXED;
            } else {
              node.contents = new Uint8Array(buffer.subarray(offset, offset+length));
              node.contentMode = MEMFS.CONTENT_FIXED;
            }
            return length;
          }
          MEMFS.ensureFlexible(node);
          var contents = node.contents;
          while (contents.length < position) contents.push(0);
          for (var i = 0; i < length; i++) {
            contents[position + i] = buffer[offset + i];
          }
          return length;
        },llseek:function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {  // SEEK_CUR.
            position += stream.position;
          } else if (whence === 2) {  // SEEK_END.
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.contents.length;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          stream.ungotten = [];
          stream.position = position;
          return position;
        },allocate:function (stream, offset, length) {
          MEMFS.ensureFlexible(stream.node);
          var contents = stream.node.contents;
          var limit = offset + length;
          while (limit > contents.length) contents.push(0);
        },mmap:function (stream, buffer, offset, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          // Only make a new copy when MAP_PRIVATE is specified.
          if ( !(flags & 2) &&
                (contents.buffer === buffer || contents.buffer === buffer.buffer) ) {
            // We can't emulate MAP_SHARED when the file is not backed by the buffer
            // we're mapping to (e.g. the HEAP buffer).
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            // Try to avoid unnecessary slices.
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = _malloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(ERRNO_CODES.ENOMEM);
            }
            buffer.set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        }}};

  var IDBFS={dbs:{},indexedDB:function () {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },DB_VERSION:21,DB_STORE_NAME:"FILE_DATA",mount:function (mount) {
        // reuse all of the core MEMFS functionality
        return MEMFS.mount.apply(null, arguments);
      },syncfs:function (mount, populate, callback) {
        IDBFS.getLocalSet(mount, function(err, local) {
          if (err) return callback(err);

          IDBFS.getRemoteSet(mount, function(err, remote) {
            if (err) return callback(err);

            var src = populate ? remote : local;
            var dst = populate ? local : remote;

            IDBFS.reconcile(src, dst, callback);
          });
        });
      },getDB:function (name, callback) {
        // check the cache first
        var db = IDBFS.dbs[name];
        if (db) {
          return callback(null, db);
        }

        var req;
        try {
          req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION);
        } catch (e) {
          return callback(e);
        }
        req.onupgradeneeded = function(e) {
          var db = e.target.result;
          var transaction = e.target.transaction;

          var fileStore;

          if (db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {
            fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME);
          } else {
            fileStore = db.createObjectStore(IDBFS.DB_STORE_NAME);
          }

          fileStore.createIndex('timestamp', 'timestamp', { unique: false });
        };
        req.onsuccess = function() {
          db = req.result;

          // add to the cache
          IDBFS.dbs[name] = db;
          callback(null, db);
        };
        req.onerror = function() {
          callback(this.error);
        };
      },getLocalSet:function (mount, callback) {
        var entries = {};

        function isRealDir(p) {
          return p !== '.' && p !== '..';
        };
        function toAbsolute(root) {
          return function(p) {
            return PATH.join2(root, p);
          }
        };

        var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));

        while (check.length) {
          var path = check.pop();
          var stat;

          try {
            stat = FS.stat(path);
          } catch (e) {
            return callback(e);
          }

          if (FS.isDir(stat.mode)) {
            check.push.apply(check, FS.readdir(path).filter(isRealDir).map(toAbsolute(path)));
          }

          entries[path] = { timestamp: stat.mtime };
        }

        return callback(null, { type: 'local', entries: entries });
      },getRemoteSet:function (mount, callback) {
        var entries = {};

        IDBFS.getDB(mount.mountpoint, function(err, db) {
          if (err) return callback(err);

          var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readonly');
          transaction.onerror = function() { callback(this.error); };

          var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
          var index = store.index('timestamp');

          index.openKeyCursor().onsuccess = function(event) {
            var cursor = event.target.result;

            if (!cursor) {
              return callback(null, { type: 'remote', db: db, entries: entries });
            }

            entries[cursor.primaryKey] = { timestamp: cursor.key };

            cursor.continue();
          };
        });
      },loadLocalEntry:function (path, callback) {
        var stat, node;

        try {
          var lookup = FS.lookupPath(path);
          node = lookup.node;
          stat = FS.stat(path);
        } catch (e) {
          return callback(e);
        }

        if (FS.isDir(stat.mode)) {
          return callback(null, { timestamp: stat.mtime, mode: stat.mode });
        } else if (FS.isFile(stat.mode)) {
          return callback(null, { timestamp: stat.mtime, mode: stat.mode, contents: node.contents });
        } else {
          return callback(new Error('node type not supported'));
        }
      },storeLocalEntry:function (path, entry, callback) {
        try {
          if (FS.isDir(entry.mode)) {
            FS.mkdir(path, entry.mode);
          } else if (FS.isFile(entry.mode)) {
            FS.writeFile(path, entry.contents, { encoding: 'binary', canOwn: true });
          } else {
            return callback(new Error('node type not supported'));
          }

          FS.utime(path, entry.timestamp, entry.timestamp);
        } catch (e) {
          return callback(e);
        }

        callback(null);
      },removeLocalEntry:function (path, callback) {
        try {
          var lookup = FS.lookupPath(path);
          var stat = FS.stat(path);

          if (FS.isDir(stat.mode)) {
            FS.rmdir(path);
          } else if (FS.isFile(stat.mode)) {
            FS.unlink(path);
          }
        } catch (e) {
          return callback(e);
        }

        callback(null);
      },loadRemoteEntry:function (store, path, callback) {
        var req = store.get(path);
        req.onsuccess = function(event) { callback(null, event.target.result); };
        req.onerror = function() { callback(this.error); };
      },storeRemoteEntry:function (store, path, entry, callback) {
        var req = store.put(entry, path);
        req.onsuccess = function() { callback(null); };
        req.onerror = function() { callback(this.error); };
      },removeRemoteEntry:function (store, path, callback) {
        var req = store.delete(path);
        req.onsuccess = function() { callback(null); };
        req.onerror = function() { callback(this.error); };
      },reconcile:function (src, dst, callback) {
        var total = 0;

        var create = [];
        Object.keys(src.entries).forEach(function (key) {
          var e = src.entries[key];
          var e2 = dst.entries[key];
          if (!e2 || e.timestamp > e2.timestamp) {
            create.push(key);
            total++;
          }
        });

        var remove = [];
        Object.keys(dst.entries).forEach(function (key) {
          var e = dst.entries[key];
          var e2 = src.entries[key];
          if (!e2) {
            remove.push(key);
            total++;
          }
        });

        if (!total) {
          return callback(null);
        }

        var errored = false;
        var completed = 0;
        var db = src.type === 'remote' ? src.db : dst.db;
        var transaction = db.transaction([IDBFS.DB_STORE_NAME], 'readwrite');
        var store = transaction.objectStore(IDBFS.DB_STORE_NAME);

        function done(err) {
          if (err) {
            if (!done.errored) {
              done.errored = true;
              return callback(err);
            }
            return;
          }
          if (++completed >= total) {
            return callback(null);
          }
        };

        transaction.onerror = function() { done(this.error); };

        // sort paths in ascending order so directory entries are created
        // before the files inside them
        create.sort().forEach(function (path) {
          if (dst.type === 'local') {
            IDBFS.loadRemoteEntry(store, path, function (err, entry) {
              if (err) return done(err);
              IDBFS.storeLocalEntry(path, entry, done);
            });
          } else {
            IDBFS.loadLocalEntry(path, function (err, entry) {
              if (err) return done(err);
              IDBFS.storeRemoteEntry(store, path, entry, done);
            });
          }
        });

        // sort paths in descending order so files are deleted before their
        // parent directories
        remove.sort().reverse().forEach(function(path) {
          if (dst.type === 'local') {
            IDBFS.removeLocalEntry(path, done);
          } else {
            IDBFS.removeRemoteEntry(store, path, done);
          }
        });
      }};

  var NODEFS={isWindows:false,staticInit:function () {
        NODEFS.isWindows = !!process.platform.match(/^win/);
      },mount:function (mount) {
        assert(ENVIRONMENT_IS_NODE);
        return NODEFS.createNode(null, '/', NODEFS.getMode(mount.opts.root), 0);
      },createNode:function (parent, name, mode, dev) {
        if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var node = FS.createNode(parent, name, mode);
        node.node_ops = NODEFS.node_ops;
        node.stream_ops = NODEFS.stream_ops;
        return node;
      },getMode:function (path) {
        var stat;
        try {
          stat = fs.lstatSync(path);
          if (NODEFS.isWindows) {
            // On Windows, directories return permission bits 'rw-rw-rw-', even though they have 'rwxrwxrwx', so
            // propagate write bits to execute bits.
            stat.mode = stat.mode | ((stat.mode & 146) >> 1);
          }
        } catch (e) {
          if (!e.code) throw e;
          throw new FS.ErrnoError(ERRNO_CODES[e.code]);
        }
        return stat.mode;
      },realPath:function (node) {
        var parts = [];
        while (node.parent !== node) {
          parts.push(node.name);
          node = node.parent;
        }
        parts.push(node.mount.opts.root);
        parts.reverse();
        return PATH.join.apply(null, parts);
      },flagsToPermissionStringMap:{0:"r",1:"r+",2:"r+",64:"r",65:"r+",66:"r+",129:"rx+",193:"rx+",514:"w+",577:"w",578:"w+",705:"wx",706:"wx+",1024:"a",1025:"a",1026:"a+",1089:"a",1090:"a+",1153:"ax",1154:"ax+",1217:"ax",1218:"ax+",4096:"rs",4098:"rs+"},flagsToPermissionString:function (flags) {
        if (flags in NODEFS.flagsToPermissionStringMap) {
          return NODEFS.flagsToPermissionStringMap[flags];
        } else {
          return flags;
        }
      },node_ops:{getattr:function (node) {
          var path = NODEFS.realPath(node);
          var stat;
          try {
            stat = fs.lstatSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          // node.js v0.10.20 doesn't report blksize and blocks on Windows. Fake them with default blksize of 4096.
          // See http://support.microsoft.com/kb/140365
          if (NODEFS.isWindows && !stat.blksize) {
            stat.blksize = 4096;
          }
          if (NODEFS.isWindows && !stat.blocks) {
            stat.blocks = (stat.size+stat.blksize-1)/stat.blksize|0;
          }
          return {
            dev: stat.dev,
            ino: stat.ino,
            mode: stat.mode,
            nlink: stat.nlink,
            uid: stat.uid,
            gid: stat.gid,
            rdev: stat.rdev,
            size: stat.size,
            atime: stat.atime,
            mtime: stat.mtime,
            ctime: stat.ctime,
            blksize: stat.blksize,
            blocks: stat.blocks
          };
        },setattr:function (node, attr) {
          var path = NODEFS.realPath(node);
          try {
            if (attr.mode !== undefined) {
              fs.chmodSync(path, attr.mode);
              // update the common node structure mode as well
              node.mode = attr.mode;
            }
            if (attr.timestamp !== undefined) {
              var date = new Date(attr.timestamp);
              fs.utimesSync(path, date, date);
            }
            if (attr.size !== undefined) {
              fs.truncateSync(path, attr.size);
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },lookup:function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          var mode = NODEFS.getMode(path);
          return NODEFS.createNode(parent, name, mode);
        },mknod:function (parent, name, mode, dev) {
          var node = NODEFS.createNode(parent, name, mode, dev);
          // create the backing node for this in the fs root as well
          var path = NODEFS.realPath(node);
          try {
            if (FS.isDir(node.mode)) {
              fs.mkdirSync(path, node.mode);
            } else {
              fs.writeFileSync(path, '', { mode: node.mode });
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          return node;
        },rename:function (oldNode, newDir, newName) {
          var oldPath = NODEFS.realPath(oldNode);
          var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
          try {
            fs.renameSync(oldPath, newPath);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },unlink:function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          try {
            fs.unlinkSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },rmdir:function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          try {
            fs.rmdirSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },readdir:function (node) {
          var path = NODEFS.realPath(node);
          try {
            return fs.readdirSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },symlink:function (parent, newName, oldPath) {
          var newPath = PATH.join2(NODEFS.realPath(parent), newName);
          try {
            fs.symlinkSync(oldPath, newPath);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },readlink:function (node) {
          var path = NODEFS.realPath(node);
          try {
            return fs.readlinkSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        }},stream_ops:{open:function (stream) {
          var path = NODEFS.realPath(stream.node);
          try {
            if (FS.isFile(stream.node.mode)) {
              stream.nfd = fs.openSync(path, NODEFS.flagsToPermissionString(stream.flags));
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },close:function (stream) {
          try {
            if (FS.isFile(stream.node.mode) && stream.nfd) {
              fs.closeSync(stream.nfd);
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
        },read:function (stream, buffer, offset, length, position) {
          // FIXME this is terrible.
          var nbuffer = new Buffer(length);
          var res;
          try {
            res = fs.readSync(stream.nfd, nbuffer, 0, length, position);
          } catch (e) {
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          if (res > 0) {
            for (var i = 0; i < res; i++) {
              buffer[offset + i] = nbuffer[i];
            }
          }
          return res;
        },write:function (stream, buffer, offset, length, position) {
          // FIXME this is terrible.
          var nbuffer = new Buffer(buffer.subarray(offset, offset + length));
          var res;
          try {
            res = fs.writeSync(stream.nfd, nbuffer, 0, length, position);
          } catch (e) {
            throw new FS.ErrnoError(ERRNO_CODES[e.code]);
          }
          return res;
        },llseek:function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {  // SEEK_CUR.
            position += stream.position;
          } else if (whence === 2) {  // SEEK_END.
            if (FS.isFile(stream.node.mode)) {
              try {
                var stat = fs.fstatSync(stream.nfd);
                position += stat.size;
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES[e.code]);
              }
            }
          }

          if (position < 0) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }

          stream.position = position;
          return position;
        }}};

  var _stdin=allocate(1, "i32*", ALLOC_STATIC);

  var _stdout=allocate(1, "i32*", ALLOC_STATIC);

  var _stderr=allocate(1, "i32*", ALLOC_STATIC);

  function _fflush(stream) {
      // int fflush(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fflush.html
      // we don't currently perform any user-space buffering of data
    }var FS={root:null,mounts:[],devices:[null],streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,ErrnoError:null,genericErrors:{},handleFSError:function (e) {
        if (!(e instanceof FS.ErrnoError)) throw e + ' : ' + stackTrace();
        return ___setErrNo(e.errno);
      },lookupPath:function (path, opts) {
        path = PATH.resolve(FS.cwd(), path);
        opts = opts || {};

        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        for (var key in defaults) {
          if (opts[key] === undefined) {
            opts[key] = defaults[key];
          }
        }

        if (opts.recurse_count > 8) {  // max recursive lookup of 8
          throw new FS.ErrnoError(ERRNO_CODES.ELOOP);
        }

        // split the path
        var parts = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), false);

        // start at the root
        var current = FS.root;
        var current_path = '/';

        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            // stop resolving
            break;
          }

          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);

          // jump to the mount's root node if this is a mountpoint
          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }

          // by default, lookupPath will not follow a symlink if it is the final path component.
          // setting opts.follow = true will override this behavior.
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH.resolve(PATH.dirname(current_path), link);

              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
              current = lookup.node;

              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
                throw new FS.ErrnoError(ERRNO_CODES.ELOOP);
              }
            }
          }
        }

        return { path: current_path, node: current };
      },getPath:function (node) {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },hashName:function (parentid, name) {
        var hash = 0;


        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },hashAddNode:function (node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },hashRemoveNode:function (node) {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },lookupNode:function (parent, name) {
        var err = FS.mayLookup(parent);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        // if we failed to find it in the cache, call into the VFS
        return FS.lookup(parent, name);
      },createNode:function (parent, name, mode, rdev) {
        if (!FS.FSNode) {
          FS.FSNode = function(parent, name, mode, rdev) {
            if (!parent) {
              parent = this;  // root node sets parent to itself
            }
            this.parent = parent;
            this.mount = parent.mount;
            this.mounted = null;
            this.id = FS.nextInode++;
            this.name = name;
            this.mode = mode;
            this.node_ops = {};
            this.stream_ops = {};
            this.rdev = rdev;
          };

          FS.FSNode.prototype = {};

          // compatibility
          var readMode = 292 | 73;
          var writeMode = 146;

          // NOTE we must use Object.defineProperties instead of individual calls to
          // Object.defineProperty in order to make closure compiler happy
          Object.defineProperties(FS.FSNode.prototype, {
            read: {
              get: function() { return (this.mode & readMode) === readMode; },
              set: function(val) { val ? this.mode |= readMode : this.mode &= ~readMode; }
            },
            write: {
              get: function() { return (this.mode & writeMode) === writeMode; },
              set: function(val) { val ? this.mode |= writeMode : this.mode &= ~writeMode; }
            },
            isFolder: {
              get: function() { return FS.isDir(this.mode); },
            },
            isDevice: {
              get: function() { return FS.isChrdev(this.mode); },
            },
          });
        }

        var node = new FS.FSNode(parent, name, mode, rdev);

        FS.hashAddNode(node);

        return node;
      },destroyNode:function (node) {
        FS.hashRemoveNode(node);
      },isRoot:function (node) {
        return node === node.parent;
      },isMountpoint:function (node) {
        return !!node.mounted;
      },isFile:function (mode) {
        return (mode & 61440) === 32768;
      },isDir:function (mode) {
        return (mode & 61440) === 16384;
      },isLink:function (mode) {
        return (mode & 61440) === 40960;
      },isChrdev:function (mode) {
        return (mode & 61440) === 8192;
      },isBlkdev:function (mode) {
        return (mode & 61440) === 24576;
      },isFIFO:function (mode) {
        return (mode & 61440) === 4096;
      },isSocket:function (mode) {
        return (mode & 49152) === 49152;
      },flagModes:{"r":0,"rs":1052672,"r+":2,"w":577,"wx":705,"xw":705,"w+":578,"wx+":706,"xw+":706,"a":1089,"ax":1217,"xa":1217,"a+":1090,"ax+":1218,"xa+":1218},modeStringToFlags:function (str) {
        var flags = FS.flagModes[str];
        if (typeof flags === 'undefined') {
          throw new Error('Unknown file open mode: ' + str);
        }
        return flags;
      },flagsToPermissionString:function (flag) {
        var accmode = flag & 2097155;
        var perms = ['r', 'w', 'rw'][accmode];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },nodePermissions:function (node, perms) {
        if (FS.ignorePermissions) {
          return 0;
        }
        // return 0 if any user, group or owner bits are set.
        if (perms.indexOf('r') !== -1 && !(node.mode & 292)) {
          return ERRNO_CODES.EACCES;
        } else if (perms.indexOf('w') !== -1 && !(node.mode & 146)) {
          return ERRNO_CODES.EACCES;
        } else if (perms.indexOf('x') !== -1 && !(node.mode & 73)) {
          return ERRNO_CODES.EACCES;
        }
        return 0;
      },mayLookup:function (dir) {
        return FS.nodePermissions(dir, 'x');
      },mayCreate:function (dir, name) {
        try {
          var node = FS.lookupNode(dir, name);
          return ERRNO_CODES.EEXIST;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },mayDelete:function (dir, name, isdir) {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var err = FS.nodePermissions(dir, 'wx');
        if (err) {
          return err;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return ERRNO_CODES.ENOTDIR;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return ERRNO_CODES.EBUSY;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return ERRNO_CODES.EISDIR;
          }
        }
        return 0;
      },mayOpen:function (node, flags) {
        if (!node) {
          return ERRNO_CODES.ENOENT;
        }
        if (FS.isLink(node.mode)) {
          return ERRNO_CODES.ELOOP;
        } else if (FS.isDir(node.mode)) {
          if ((flags & 2097155) !== 0 ||  // opening for write
              (flags & 512)) {
            return ERRNO_CODES.EISDIR;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },MAX_OPEN_FDS:4096,nextfd:function (fd_start, fd_end) {
        fd_start = fd_start || 0;
        fd_end = fd_end || FS.MAX_OPEN_FDS;
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(ERRNO_CODES.EMFILE);
      },getStream:function (fd) {
        return FS.streams[fd];
      },createStream:function (stream, fd_start, fd_end) {
        if (!FS.FSStream) {
          FS.FSStream = function(){};
          FS.FSStream.prototype = {};
          // compatibility
          Object.defineProperties(FS.FSStream.prototype, {
            object: {
              get: function() { return this.node; },
              set: function(val) { this.node = val; }
            },
            isRead: {
              get: function() { return (this.flags & 2097155) !== 1; }
            },
            isWrite: {
              get: function() { return (this.flags & 2097155) !== 0; }
            },
            isAppend: {
              get: function() { return (this.flags & 1024); }
            }
          });
        }
        if (0) {
          // reuse the object
          stream.__proto__ = FS.FSStream.prototype;
        } else {
          var newStream = new FS.FSStream();
          for (var p in stream) {
            newStream[p] = stream[p];
          }
          stream = newStream;
        }
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },closeStream:function (fd) {
        FS.streams[fd] = null;
      },getStreamFromPtr:function (ptr) {
        return FS.streams[ptr - 1];
      },getPtrForStream:function (stream) {
        return stream ? stream.fd + 1 : 0;
      },chrdev_stream_ops:{open:function (stream) {
          var device = FS.getDevice(stream.node.rdev);
          // override node's stream ops with the device's
          stream.stream_ops = device.stream_ops;
          // forward the open call
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },llseek:function () {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }},major:function (dev) {
        return ((dev) >> 8);
      },minor:function (dev) {
        return ((dev) & 0xff);
      },makedev:function (ma, mi) {
        return ((ma) << 8 | (mi));
      },registerDevice:function (dev, ops) {
        FS.devices[dev] = { stream_ops: ops };
      },getDevice:function (dev) {
        return FS.devices[dev];
      },getMounts:function (mount) {
        var mounts = [];
        var check = [mount];

        while (check.length) {
          var m = check.pop();

          mounts.push(m);

          check.push.apply(check, m.mounts);
        }

        return mounts;
      },syncfs:function (populate, callback) {
        if (typeof(populate) === 'function') {
          callback = populate;
          populate = false;
        }

        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;

        function done(err) {
          if (err) {
            if (!done.errored) {
              done.errored = true;
              return callback(err);
            }
            return;
          }
          if (++completed >= mounts.length) {
            callback(null);
          }
        };

        // sync all mounts
        mounts.forEach(function (mount) {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },mount:function (type, opts, mountpoint) {
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;

        if (root && FS.root) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });

          mountpoint = lookup.path;  // use the absolute path
          node = lookup.node;

          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
          }

          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
          }
        }

        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: []
        };

        // create a root node for the fs
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;

        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          // set as a mountpoint
          node.mounted = mount;

          // add the new mount to the current mount's children
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }

        return mountRoot;
      },unmount:function (mountpoint) {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });

        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }

        // destroy the nodes for this mount, and all its child mounts
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);

        Object.keys(FS.nameTable).forEach(function (hash) {
          var current = FS.nameTable[hash];

          while (current) {
            var next = current.name_next;

            if (mounts.indexOf(current.mount) !== -1) {
              FS.destroyNode(current);
            }

            current = next;
          }
        });

        // no longer a mountpoint
        node.mounted = null;

        // remove this mount from the child mounts
        var idx = node.mount.mounts.indexOf(mount);
        assert(idx !== -1);
        node.mount.mounts.splice(idx, 1);
      },lookup:function (parent, name) {
        return parent.node_ops.lookup(parent, name);
      },mknod:function (path, mode, dev) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var err = FS.mayCreate(parent, name);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },create:function (path, mode) {
        mode = mode !== undefined ? mode : 438 /* 0666 */;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },mkdir:function (path, mode) {
        mode = mode !== undefined ? mode : 511 /* 0777 */;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },mkdev:function (path, mode, dev) {
        if (typeof(dev) === 'undefined') {
          dev = mode;
          mode = 438 /* 0666 */;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },symlink:function (oldpath, newpath) {
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        var newname = PATH.basename(newpath);
        var err = FS.mayCreate(parent, newname);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },rename:function (old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;
        try {
          lookup = FS.lookupPath(old_path, { parent: true });
          old_dir = lookup.node;
          lookup = FS.lookupPath(new_path, { parent: true });
          new_dir = lookup.node;
        } catch (e) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(ERRNO_CODES.EXDEV);
        }
        // source must exist
        var old_node = FS.lookupNode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = PATH.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        // new path should not be an ancestor of the old path
        relative = PATH.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = FS.isDir(old_node.mode);
        var err = FS.mayDelete(old_dir, old_name, isdir);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        err = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          err = FS.nodePermissions(old_dir, 'w');
          if (err) {
            throw new FS.ErrnoError(err);
          }
        }
        // remove the node from the lookup hash
        FS.hashRemoveNode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          FS.hashAddNode(old_node);
        }
      },rmdir:function (path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var err = FS.mayDelete(parent, name, true);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
      },readdir:function (path) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
        }
        return node.node_ops.readdir(node);
      },unlink:function (path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var err = FS.mayDelete(parent, name, false);
        if (err) {
          // POSIX says unlink should set EPERM, not EISDIR
          if (err === ERRNO_CODES.EISDIR) err = ERRNO_CODES.EPERM;
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
      },readlink:function (path) {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return link.node_ops.readlink(link);
      },stat:function (path, dontFollow) {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return node.node_ops.getattr(node);
      },lstat:function (path) {
        return FS.stat(path, true);
      },chmod:function (path, mode, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },lchmod:function (path, mode) {
        FS.chmod(path, mode, true);
      },fchmod:function (fd, mode) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        FS.chmod(stream.node, mode);
      },chown:function (path, uid, gid, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          // we ignore the uid / gid for now
        });
      },lchown:function (path, uid, gid) {
        FS.chown(path, uid, gid, true);
      },fchown:function (fd, uid, gid) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        FS.chown(stream.node, uid, gid);
      },truncate:function (path, len) {
        if (len < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var err = FS.nodePermissions(node, 'w');
        if (err) {
          throw new FS.ErrnoError(err);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },ftruncate:function (fd, len) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        FS.truncate(stream.node, len);
      },utime:function (path, atime, mtime) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },open:function (path, flags, mode, fd_start, fd_end) {
        flags = typeof flags === 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode === 'undefined' ? 438 /* 0666 */ : mode;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path === 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            // ignore
          }
        }
        // perhaps we need to create the node
        if ((flags & 64)) {
          if (node) {
            // if O_CREAT and O_EXCL are set, error out if the node already exists
            if ((flags & 128)) {
              throw new FS.ErrnoError(ERRNO_CODES.EEXIST);
            }
          } else {
            // node doesn't exist, try to create it
            node = FS.mknod(path, mode, 0);
          }
        }
        if (!node) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        // can't truncate a device
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        // check permissions
        var err = FS.mayOpen(node, flags);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        // do truncation if necessary
        if ((flags & 512)) {
          FS.truncate(node, 0);
        }
        // we've already handled these, don't pass down to the underlying vfs
        flags &= ~(128 | 512);

        // register the stream with the filesystem
        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),  // we want the absolute path to the node
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        }, fd_start, fd_end);
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
            Module['printErr']('read file: ' + path);
          }
        }
        return stream;
      },close:function (stream) {
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
      },llseek:function (stream, offset, whence) {
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        return stream.stream_ops.llseek(stream, offset, whence);
      },read:function (stream, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var seeking = true;
        if (typeof position === 'undefined') {
          position = stream.position;
          seeking = false;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },write:function (stream, buffer, offset, length, position, canOwn) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var seeking = true;
        if (typeof position === 'undefined') {
          position = stream.position;
          seeking = false;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        if (stream.flags & 1024) {
          // seek to the end before writing in append mode
          FS.llseek(stream, 0, 2);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        return bytesWritten;
      },allocate:function (stream, offset, length) {
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },mmap:function (stream, buffer, offset, length, position, prot, flags) {
        // TODO if PROT is PROT_WRITE, make sure we have write access
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(ERRNO_CODES.EACCES);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
        }
        return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);
      },ioctl:function (stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTTY);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },readFile:function (path, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'r';
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = '';
          var utf8 = new Runtime.UTF8Processor();
          for (var i = 0; i < length; i++) {
            ret += utf8.processCChar(buf[i]);
          }
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },writeFile:function (path, data, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'w';
        opts.encoding = opts.encoding || 'utf8';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var stream = FS.open(path, opts.flags, opts.mode);
        if (opts.encoding === 'utf8') {
          var utf8 = new Runtime.UTF8Processor();
          var buf = new Uint8Array(utf8.processJSString(data));
          FS.write(stream, buf, 0, buf.length, 0, opts.canOwn);
        } else if (opts.encoding === 'binary') {
          FS.write(stream, data, 0, data.length, 0, opts.canOwn);
        }
        FS.close(stream);
      },cwd:function () {
        return FS.currentPath;
      },chdir:function (path) {
        var lookup = FS.lookupPath(path, { follow: true });
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
        }
        var err = FS.nodePermissions(lookup.node, 'x');
        if (err) {
          throw new FS.ErrnoError(err);
        }
        FS.currentPath = lookup.path;
      },createDefaultDirectories:function () {
        FS.mkdir('/tmp');
      },createDefaultDevices:function () {
        // create /dev
        FS.mkdir('/dev');
        // setup /dev/null
        FS.registerDevice(FS.makedev(1, 3), {
          read: function() { return 0; },
          write: function() { return 0; }
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using Module['printErr']
        // so we register a second tty just for it.
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },createStandardStreams:function () {
        // TODO deprecate the old functionality of a single
        // input / output callback and that utilizes FS.createDevice
        // and instead require a unique set of stream ops

        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }

        // open default streams for the stdin, stdout and stderr devices
        var stdin = FS.open('/dev/stdin', 'r');
        HEAP32[((_stdin)>>2)]=FS.getPtrForStream(stdin);
        assert(stdin.fd === 0, 'invalid handle for stdin (' + stdin.fd + ')');

        var stdout = FS.open('/dev/stdout', 'w');
        HEAP32[((_stdout)>>2)]=FS.getPtrForStream(stdout);
        assert(stdout.fd === 1, 'invalid handle for stdout (' + stdout.fd + ')');

        var stderr = FS.open('/dev/stderr', 'w');
        HEAP32[((_stderr)>>2)]=FS.getPtrForStream(stderr);
        assert(stderr.fd === 2, 'invalid handle for stderr (' + stderr.fd + ')');
      },ensureErrnoError:function () {
        if (FS.ErrnoError) return;
        FS.ErrnoError = function ErrnoError(errno) {
          this.errno = errno;
          for (var key in ERRNO_CODES) {
            if (ERRNO_CODES[key] === errno) {
              this.code = key;
              break;
            }
          }
          this.message = ERRNO_MESSAGES[errno];
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
        [ERRNO_CODES.ENOENT].forEach(function(code) {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },staticInit:function () {
        FS.ensureErrnoError();

        FS.nameTable = new Array(4096);

        FS.mount(MEMFS, {}, '/');

        FS.createDefaultDirectories();
        FS.createDefaultDevices();
      },init:function (input, output, error) {
        assert(!FS.init.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');
        FS.init.initialized = true;

        FS.ensureErrnoError();

        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];

        FS.createStandardStreams();
      },quit:function () {
        FS.init.initialized = false;
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },getMode:function (canRead, canWrite) {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },joinPath:function (parts, forceRelative) {
        var path = PATH.join.apply(null, parts);
        if (forceRelative && path[0] == '/') path = path.substr(1);
        return path;
      },absolutePath:function (relative, base) {
        return PATH.resolve(base, relative);
      },standardizePath:function (path) {
        return PATH.normalize(path);
      },findObject:function (path, dontResolveLastLink) {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
          return ret.object;
        } else {
          ___setErrNo(ret.error);
          return null;
        }
      },analyzePath:function (path, dontResolveLastLink) {
        // operate from within the context of the symlink's target
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },createFolder:function (parent, name, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.mkdir(path, mode);
      },createPath:function (parent, path, canRead, canWrite) {
        parent = typeof parent === 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            // ignore EEXIST
          }
          parent = current;
        }
        return current;
      },createFile:function (parent, name, properties, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },createDataFile:function (parent, name, data, canRead, canWrite, canOwn) {
        var path = name ? PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name) : parent;
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data === 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          // make sure we can write to the file
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 'w');
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },createDevice:function (parent, name, input, output) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        // Create a fake device that a set of stream ops to emulate
        // the old behavior.
        FS.registerDevice(dev, {
          open: function(stream) {
            stream.seekable = false;
          },
          close: function(stream) {
            // flush any pending line data
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: function(stream, buffer, offset, length, pos /* ignored */) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES.EIO);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: function(stream, buffer, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES.EIO);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },createLink:function (parent, name, target, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        return FS.symlink(target, path);
      },forceLoadFile:function (obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        var success = true;
        if (typeof XMLHttpRequest !== 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (Module['read']) {
          // Command-line.
          try {
            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
            //          read() will try to parse UTF8.
            obj.contents = intArrayFromString(Module['read'](obj.url), true);
          } catch (e) {
            success = false;
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
        if (!success) ___setErrNo(ERRNO_CODES.EIO);
        return success;
      },createLazyFile:function (parent, name, url, canRead, canWrite) {
        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = []; // Loaded chunks. Index is the chunk number
        }
        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
          if (idx > this.length-1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = Math.floor(idx / this.chunkSize);
          return this.getter(chunkNum)[chunkOffset];
        }
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        }
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
            // Find length
            var xhr = new XMLHttpRequest();
            xhr.open('HEAD', url, false);
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            var datalength = Number(xhr.getResponseHeader("Content-length"));
            var header;
            var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
            var chunkSize = 1024*1024; // Chunk size in bytes

            if (!hasByteServing) chunkSize = datalength;

            // Function to get a range from the remote URL.
            var doXHR = (function(from, to) {
              if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
              if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");

              // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
              var xhr = new XMLHttpRequest();
              xhr.open('GET', url, false);
              if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);

              // Some hints to the browser that we want binary data.
              if (typeof Uint8Array != 'undefined') xhr.responseType = 'arraybuffer';
              if (xhr.overrideMimeType) {
                xhr.overrideMimeType('text/plain; charset=x-user-defined');
              }

              xhr.send(null);
              if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
              if (xhr.response !== undefined) {
                return new Uint8Array(xhr.response || []);
              } else {
                return intArrayFromString(xhr.responseText || '', true);
              }
            });
            var lazyArray = this;
            lazyArray.setDataGetter(function(chunkNum) {
              var start = chunkNum * chunkSize;
              var end = (chunkNum+1) * chunkSize - 1; // including this byte
              end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
              if (typeof(lazyArray.chunks[chunkNum]) === "undefined") {
                lazyArray.chunks[chunkNum] = doXHR(start, end);
              }
              if (typeof(lazyArray.chunks[chunkNum]) === "undefined") throw new Error("doXHR failed!");
              return lazyArray.chunks[chunkNum];
            });

            this._length = datalength;
            this._chunkSize = chunkSize;
            this.lengthKnown = true;
        }
        if (typeof XMLHttpRequest !== 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          Object.defineProperty(lazyArray, "length", {
              get: function() {
                  if(!this.lengthKnown) {
                      this.cacheLength();
                  }
                  return this._length;
              }
          });
          Object.defineProperty(lazyArray, "chunkSize", {
              get: function() {
                  if(!this.lengthKnown) {
                      this.cacheLength();
                  }
                  return this._chunkSize;
              }
          });

          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }

        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        // This is a total hack, but I want to get this lazy file code out of the
        // core of MEMFS. If we want to keep this lazy file concept I feel it should
        // be its own thin LAZYFS proxying calls to MEMFS.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach(function(key) {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            if (!FS.forceLoadFile(node)) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO);
            }
            return fn.apply(null, arguments);
          };
        });
        // use a custom read function
        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {
          if (!FS.forceLoadFile(node)) {
            throw new FS.ErrnoError(ERRNO_CODES.EIO);
          }
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          assert(size >= 0);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        };
        node.stream_ops = stream_ops;
        return node;
      },createPreloadedFile:function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn) {
        Browser.init();
        // TODO we should allow people to just pass in a complete filename instead
        // of parent and name being that we just join them anyways
        var fullname = name ? PATH.resolve(PATH.join2(parent, name)) : parent;
        function processData(byteArray) {
          function finish(byteArray) {
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            }
            if (onload) onload();
            removeRunDependency('cp ' + fullname);
          }
          var handled = false;
          Module['preloadPlugins'].forEach(function(plugin) {
            if (handled) return;
            if (plugin['canHandle'](fullname)) {
              plugin['handle'](byteArray, fullname, finish, function() {
                if (onerror) onerror();
                removeRunDependency('cp ' + fullname);
              });
              handled = true;
            }
          });
          if (!handled) finish(byteArray);
        }
        addRunDependency('cp ' + fullname);
        if (typeof url == 'string') {
          Browser.asyncLoad(url, function(byteArray) {
            processData(byteArray);
          }, onerror);
        } else {
          processData(url);
        }
      },indexedDB:function () {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },DB_NAME:function () {
        return 'EM_FS_' + window.location.pathname;
      },DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:function (paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
          console.log('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);
            putRequest.onsuccess = function putRequest_onsuccess() { ok++; if (ok + fail == total) finish() };
            putRequest.onerror = function putRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },loadFilesFromDB:function (paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror; // no database to load from
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch(e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var getRequest = files.get(path);
            getRequest.onsuccess = function getRequest_onsuccess() {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = function getRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      }};




  function _mkport() { throw 'TODO' }var SOCKFS={mount:function (mount) {
        return FS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createSocket:function (family, type, protocol) {
        var streaming = type == 1;
        if (protocol) {
          assert(streaming == (protocol == 6)); // if SOCK_STREAM, must be tcp
        }

        // create our internal socket structure
        var sock = {
          family: family,
          type: type,
          protocol: protocol,
          server: null,
          peers: {},
          pending: [],
          recv_queue: [],
          sock_ops: SOCKFS.websocket_sock_ops
        };

        // create the filesystem node to store the socket structure
        var name = SOCKFS.nextname();
        var node = FS.createNode(SOCKFS.root, name, 49152, 0);
        node.sock = sock;

        // and the wrapping stream that enables library functions such
        // as read and write to indirectly interact with the socket
        var stream = FS.createStream({
          path: name,
          node: node,
          flags: FS.modeStringToFlags('r+'),
          seekable: false,
          stream_ops: SOCKFS.stream_ops
        });

        // map the new stream to the socket structure (sockets have a 1:1
        // relationship with a stream)
        sock.stream = stream;

        return sock;
      },getSocket:function (fd) {
        var stream = FS.getStream(fd);
        if (!stream || !FS.isSocket(stream.node.mode)) {
          return null;
        }
        return stream.node.sock;
      },stream_ops:{poll:function (stream) {
          var sock = stream.node.sock;
          return sock.sock_ops.poll(sock);
        },ioctl:function (stream, request, varargs) {
          var sock = stream.node.sock;
          return sock.sock_ops.ioctl(sock, request, varargs);
        },read:function (stream, buffer, offset, length, position /* ignored */) {
          var sock = stream.node.sock;
          var msg = sock.sock_ops.recvmsg(sock, length);
          if (!msg) {
            // socket is closed
            return 0;
          }
          buffer.set(msg.buffer, offset);
          return msg.buffer.length;
        },write:function (stream, buffer, offset, length, position /* ignored */) {
          var sock = stream.node.sock;
          return sock.sock_ops.sendmsg(sock, buffer, offset, length);
        },close:function (stream) {
          var sock = stream.node.sock;
          sock.sock_ops.close(sock);
        }},nextname:function () {
        if (!SOCKFS.nextname.current) {
          SOCKFS.nextname.current = 0;
        }
        return 'socket[' + (SOCKFS.nextname.current++) + ']';
      },websocket_sock_ops:{createPeer:function (sock, addr, port) {
          var ws;

          if (typeof addr === 'object') {
            ws = addr;
            addr = null;
            port = null;
          }

          if (ws) {
            // for sockets that've already connected (e.g. we're the server)
            // we can inspect the _socket property for the address
            if (ws._socket) {
              addr = ws._socket.remoteAddress;
              port = ws._socket.remotePort;
            }
            // if we're just now initializing a connection to the remote,
            // inspect the url property
            else {
              var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
              if (!result) {
                throw new Error('WebSocket URL must be in the format ws(s)://address:port');
              }
              addr = result[1];
              port = parseInt(result[2], 10);
            }
          } else {
            // create the actual websocket object and connect
            try {
              // runtimeConfig gets set to true if WebSocket runtime configuration is available.
              var runtimeConfig = (Module['websocket'] && ('object' === typeof Module['websocket']));

              // The default value is 'ws://' the replace is needed because the compiler replaces "//" comments with '#'
              // comments without checking context, so we'd end up with ws:#, the replace swaps the "#" for "//" again.
              var url = 'ws:#'.replace('#', '//');

              if (runtimeConfig) {
                if ('string' === typeof Module['websocket']['url']) {
                  url = Module['websocket']['url']; // Fetch runtime WebSocket URL config.
                }
              }

              if (url === 'ws://' || url === 'wss://') { // Is the supplied URL config just a prefix, if so complete it.
                url = url + addr + ':' + port;
              }

              // Make the WebSocket subprotocol (Sec-WebSocket-Protocol) default to binary if no configuration is set.
              var subProtocols = 'binary'; // The default value is 'binary'

              if (runtimeConfig) {
                if ('string' === typeof Module['websocket']['subprotocol']) {
                  subProtocols = Module['websocket']['subprotocol']; // Fetch runtime WebSocket subprotocol config.
                }
              }

              // The regex trims the string (removes spaces at the beginning and end, then splits the string by
              // <any space>,<any space> into an Array. Whitespace removal is important for Websockify and ws.
              subProtocols = subProtocols.replace(/^ +| +$/g,"").split(/ *, */);

              // The node ws library API for specifying optional subprotocol is slightly different than the browser's.
              var opts = ENVIRONMENT_IS_NODE ? {'protocol': subProtocols.toString()} : subProtocols;

              // If node we use the ws library.
              var WebSocket = ENVIRONMENT_IS_NODE ? require('ws') : window['WebSocket'];
              ws = new WebSocket(url, opts);
              ws.binaryType = 'arraybuffer';
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES.EHOSTUNREACH);
            }
          }


          var peer = {
            addr: addr,
            port: port,
            socket: ws,
            dgram_send_queue: []
          };

          SOCKFS.websocket_sock_ops.addPeer(sock, peer);
          SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);

          // if this is a bound dgram socket, send the port number first to allow
          // us to override the ephemeral port reported to us by remotePort on the
          // remote end.
          if (sock.type === 2 && typeof sock.sport !== 'undefined') {
            peer.dgram_send_queue.push(new Uint8Array([
                255, 255, 255, 255,
                'p'.charCodeAt(0), 'o'.charCodeAt(0), 'r'.charCodeAt(0), 't'.charCodeAt(0),
                ((sock.sport & 0xff00) >> 8) , (sock.sport & 0xff)
            ]));
          }

          return peer;
        },getPeer:function (sock, addr, port) {
          return sock.peers[addr + ':' + port];
        },addPeer:function (sock, peer) {
          sock.peers[peer.addr + ':' + peer.port] = peer;
        },removePeer:function (sock, peer) {
          delete sock.peers[peer.addr + ':' + peer.port];
        },handlePeerEvents:function (sock, peer) {
          var first = true;

          var handleOpen = function () {
            try {
              var queued = peer.dgram_send_queue.shift();
              while (queued) {
                peer.socket.send(queued);
                queued = peer.dgram_send_queue.shift();
              }
            } catch (e) {
              // not much we can do here in the way of proper error handling as we've already
              // lied and said this data was sent. shut it down.
              peer.socket.close();
            }
          };

          function handleMessage(data) {
            assert(typeof data !== 'string' && data.byteLength !== undefined);  // must receive an ArrayBuffer
            data = new Uint8Array(data);  // make a typed array view on the array buffer


            // if this is the port message, override the peer's port with it
            var wasfirst = first;
            first = false;
            if (wasfirst &&
                data.length === 10 &&
                data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 &&
                data[4] === 'p'.charCodeAt(0) && data[5] === 'o'.charCodeAt(0) && data[6] === 'r'.charCodeAt(0) && data[7] === 't'.charCodeAt(0)) {
              // update the peer's port and it's key in the peer map
              var newport = ((data[8] << 8) | data[9]);
              SOCKFS.websocket_sock_ops.removePeer(sock, peer);
              peer.port = newport;
              SOCKFS.websocket_sock_ops.addPeer(sock, peer);
              return;
            }

            sock.recv_queue.push({ addr: peer.addr, port: peer.port, data: data });
          };

          if (ENVIRONMENT_IS_NODE) {
            peer.socket.on('open', handleOpen);
            peer.socket.on('message', function(data, flags) {
              if (!flags.binary) {
                return;
              }
              handleMessage((new Uint8Array(data)).buffer);  // copy from node Buffer -> ArrayBuffer
            });
            peer.socket.on('error', function() {
              // don't throw
            });
          } else {
            peer.socket.onopen = handleOpen;
            peer.socket.onmessage = function peer_socket_onmessage(event) {
              handleMessage(event.data);
            };
          }
        },poll:function (sock) {
          if (sock.type === 1 && sock.server) {
            // listen sockets should only say they're available for reading
            // if there are pending clients.
            return sock.pending.length ? (64 | 1) : 0;
          }

          var mask = 0;
          var dest = sock.type === 1 ?  // we only care about the socket state for connection-based sockets
            SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) :
            null;

          if (sock.recv_queue.length ||
              !dest ||  // connection-less sockets are always ready to read
              (dest && dest.socket.readyState === dest.socket.CLOSING) ||
              (dest && dest.socket.readyState === dest.socket.CLOSED)) {  // let recv return 0 once closed
            mask |= (64 | 1);
          }

          if (!dest ||  // connection-less sockets are always ready to write
              (dest && dest.socket.readyState === dest.socket.OPEN)) {
            mask |= 4;
          }

          if ((dest && dest.socket.readyState === dest.socket.CLOSING) ||
              (dest && dest.socket.readyState === dest.socket.CLOSED)) {
            mask |= 16;
          }

          return mask;
        },ioctl:function (sock, request, arg) {
          switch (request) {
            case 21531:
              var bytes = 0;
              if (sock.recv_queue.length) {
                bytes = sock.recv_queue[0].data.length;
              }
              HEAP32[((arg)>>2)]=bytes;
              return 0;
            default:
              return ERRNO_CODES.EINVAL;
          }
        },close:function (sock) {
          // if we've spawned a listen server, close it
          if (sock.server) {
            try {
              sock.server.close();
            } catch (e) {
            }
            sock.server = null;
          }
          // close any peer connections
          var peers = Object.keys(sock.peers);
          for (var i = 0; i < peers.length; i++) {
            var peer = sock.peers[peers[i]];
            try {
              peer.socket.close();
            } catch (e) {
            }
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
          }
          return 0;
        },bind:function (sock, addr, port) {
          if (typeof sock.saddr !== 'undefined' || typeof sock.sport !== 'undefined') {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);  // already bound
          }
          sock.saddr = addr;
          sock.sport = port || _mkport();
          // in order to emulate dgram sockets, we need to launch a listen server when
          // binding on a connection-less socket
          // note: this is only required on the server side
          if (sock.type === 2) {
            // close the existing server if it exists
            if (sock.server) {
              sock.server.close();
              sock.server = null;
            }
            // swallow error operation not supported error that occurs when binding in the
            // browser where this isn't supported
            try {
              sock.sock_ops.listen(sock, 0);
            } catch (e) {
              if (!(e instanceof FS.ErrnoError)) throw e;
              if (e.errno !== ERRNO_CODES.EOPNOTSUPP) throw e;
            }
          }
        },connect:function (sock, addr, port) {
          if (sock.server) {
            throw new FS.ErrnoError(ERRNO_CODS.EOPNOTSUPP);
          }

          // TODO autobind
          // if (!sock.addr && sock.type == 2) {
          // }

          // early out if we're already connected / in the middle of connecting
          if (typeof sock.daddr !== 'undefined' && typeof sock.dport !== 'undefined') {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (dest) {
              if (dest.socket.readyState === dest.socket.CONNECTING) {
                throw new FS.ErrnoError(ERRNO_CODES.EALREADY);
              } else {
                throw new FS.ErrnoError(ERRNO_CODES.EISCONN);
              }
            }
          }

          // add the socket to our peer list and set our
          // destination address / port to match
          var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
          sock.daddr = peer.addr;
          sock.dport = peer.port;

          // always "fail" in non-blocking mode
          throw new FS.ErrnoError(ERRNO_CODES.EINPROGRESS);
        },listen:function (sock, backlog) {
          if (!ENVIRONMENT_IS_NODE) {
            throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
          }
          if (sock.server) {
             throw new FS.ErrnoError(ERRNO_CODES.EINVAL);  // already listening
          }
          var WebSocketServer = require('ws').Server;
          var host = sock.saddr;
          sock.server = new WebSocketServer({
            host: host,
            port: sock.sport
            // TODO support backlog
          });

          sock.server.on('connection', function(ws) {
            if (sock.type === 1) {
              var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);

              // create a peer on the new socket
              var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
              newsock.daddr = peer.addr;
              newsock.dport = peer.port;

              // push to queue for accept to pick up
              sock.pending.push(newsock);
            } else {
              // create a peer on the listen socket so calling sendto
              // with the listen socket and an address will resolve
              // to the correct client
              SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            }
          });
          sock.server.on('closed', function() {
            sock.server = null;
          });
          sock.server.on('error', function() {
            // don't throw
          });
        },accept:function (listensock) {
          if (!listensock.server) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          var newsock = listensock.pending.shift();
          newsock.stream.flags = listensock.stream.flags;
          return newsock;
        },getname:function (sock, peer) {
          var addr, port;
          if (peer) {
            if (sock.daddr === undefined || sock.dport === undefined) {
              throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
            }
            addr = sock.daddr;
            port = sock.dport;
          } else {
            // TODO saddr and sport will be set for bind()'d UDP sockets, but what
            // should we be returning for TCP sockets that've been connect()'d?
            addr = sock.saddr || 0;
            port = sock.sport || 0;
          }
          return { addr: addr, port: port };
        },sendmsg:function (sock, buffer, offset, length, addr, port) {
          if (sock.type === 2) {
            // connection-less sockets will honor the message address,
            // and otherwise fall back to the bound destination address
            if (addr === undefined || port === undefined) {
              addr = sock.daddr;
              port = sock.dport;
            }
            // if there was no address to fall back to, error out
            if (addr === undefined || port === undefined) {
              throw new FS.ErrnoError(ERRNO_CODES.EDESTADDRREQ);
            }
          } else {
            // connection-based sockets will only use the bound
            addr = sock.daddr;
            port = sock.dport;
          }

          // find the peer for the destination address
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);

          // early out if not connected with a connection-based socket
          if (sock.type === 1) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
            } else if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
            }
          }

          // create a copy of the incoming data to send, as the WebSocket API
          // doesn't work entirely with an ArrayBufferView, it'll just send
          // the entire underlying buffer
          var data;
          if (buffer instanceof Array || buffer instanceof ArrayBuffer) {
            data = buffer.slice(offset, offset + length);
          } else {  // ArrayBufferView
            data = buffer.buffer.slice(buffer.byteOffset + offset, buffer.byteOffset + offset + length);
          }

          // if we're emulating a connection-less dgram socket and don't have
          // a cached connection, queue the buffer to send upon connect and
          // lie, saying the data was sent now.
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
              // if we're not connected, open a new connection
              if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
              }
              dest.dgram_send_queue.push(data);
              return length;
            }
          }

          try {
            // send the actual data
            dest.socket.send(data);
            return length;
          } catch (e) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
        },recvmsg:function (sock, length) {
          // http://pubs.opengroup.org/onlinepubs/7908799/xns/recvmsg.html
          if (sock.type === 1 && sock.server) {
            // tcp servers should not be recv()'ing on the listen socket
            throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
          }

          var queued = sock.recv_queue.shift();
          if (!queued) {
            if (sock.type === 1) {
              var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);

              if (!dest) {
                // if we have a destination address but are not connected, error out
                throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
              }
              else if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                // return null if the socket has closed
                return null;
              }
              else {
                // else, our socket is in a valid state but truly has nothing available
                throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
              }
            } else {
              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
            }
          }

          // queued.data will be an ArrayBuffer if it's unadulterated, but if it's
          // requeued TCP data it'll be an ArrayBufferView
          var queuedLength = queued.data.byteLength || queued.data.length;
          var queuedOffset = queued.data.byteOffset || 0;
          var queuedBuffer = queued.data.buffer || queued.data;
          var bytesRead = Math.min(length, queuedLength);
          var res = {
            buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
            addr: queued.addr,
            port: queued.port
          };


          // push back any unread data for TCP connections
          if (sock.type === 1 && bytesRead < queuedLength) {
            var bytesRemaining = queuedLength - bytesRead;
            queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
            sock.recv_queue.unshift(queued);
          }

          return res;
        }}};function _send(fd, buf, len, flags) {
      var sock = SOCKFS.getSocket(fd);
      if (!sock) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      // TODO honor flags
      return _write(fd, buf, len);
    }

  function _pwrite(fildes, buf, nbyte, offset) {
      // ssize_t pwrite(int fildes, const void *buf, size_t nbyte, off_t offset);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/write.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      try {
        var slab = HEAP8;
        return FS.write(stream, slab, buf, nbyte, offset);
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }function _write(fildes, buf, nbyte) {
      // ssize_t write(int fildes, const void *buf, size_t nbyte);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/write.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }


      try {
        var slab = HEAP8;
        return FS.write(stream, slab, buf, nbyte);
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }

  function _fileno(stream) {
      // int fileno(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fileno.html
      stream = FS.getStreamFromPtr(stream);
      if (!stream) return -1;
      return stream.fd;
    }function _fwrite(ptr, size, nitems, stream) {
      // size_t fwrite(const void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fwrite.html
      var bytesToWrite = nitems * size;
      if (bytesToWrite == 0) return 0;
      var fd = _fileno(stream);
      var bytesWritten = _write(fd, ptr, bytesToWrite);
      if (bytesWritten == -1) {
        var streamObj = FS.getStreamFromPtr(stream);
        if (streamObj) streamObj.error = true;
        return 0;
      } else {
        return Math.floor(bytesWritten / size);
      }
    }



  Module["_strlen"] = _strlen;

  function __reallyNegative(x) {
      return x < 0 || (x === 0 && (1/x) === -Infinity);
    }function __formatString(format, varargs) {
      var textIndex = format;
      var argIndex = 0;
      function getNextArg(type) {
        // NOTE: Explicitly ignoring type safety. Otherwise this fails:
        //       int x = 4; printf("%c\n", (char)x);
        var ret;
        if (type === 'double') {
          ret = HEAPF64[(((varargs)+(argIndex))>>3)];
        } else if (type == 'i64') {
          ret = [HEAP32[(((varargs)+(argIndex))>>2)],
                 HEAP32[(((varargs)+(argIndex+4))>>2)]];

        } else {
          type = 'i32'; // varargs are always i32, i64, or double
          ret = HEAP32[(((varargs)+(argIndex))>>2)];
        }
        argIndex += Runtime.getNativeFieldSize(type);
        return ret;
      }

      var ret = [];
      var curr, next, currArg;
      while(1) {
        var startTextIndex = textIndex;
        curr = HEAP8[(textIndex)];
        if (curr === 0) break;
        next = HEAP8[((textIndex+1)|0)];
        if (curr == 37) {
          // Handle flags.
          var flagAlwaysSigned = false;
          var flagLeftAlign = false;
          var flagAlternative = false;
          var flagZeroPad = false;
          var flagPadSign = false;
          flagsLoop: while (1) {
            switch (next) {
              case 43:
                flagAlwaysSigned = true;
                break;
              case 45:
                flagLeftAlign = true;
                break;
              case 35:
                flagAlternative = true;
                break;
              case 48:
                if (flagZeroPad) {
                  break flagsLoop;
                } else {
                  flagZeroPad = true;
                  break;
                }
              case 32:
                flagPadSign = true;
                break;
              default:
                break flagsLoop;
            }
            textIndex++;
            next = HEAP8[((textIndex+1)|0)];
          }

          // Handle width.
          var width = 0;
          if (next == 42) {
            width = getNextArg('i32');
            textIndex++;
            next = HEAP8[((textIndex+1)|0)];
          } else {
            while (next >= 48 && next <= 57) {
              width = width * 10 + (next - 48);
              textIndex++;
              next = HEAP8[((textIndex+1)|0)];
            }
          }

          // Handle precision.
          var precisionSet = false, precision = -1;
          if (next == 46) {
            precision = 0;
            precisionSet = true;
            textIndex++;
            next = HEAP8[((textIndex+1)|0)];
            if (next == 42) {
              precision = getNextArg('i32');
              textIndex++;
            } else {
              while(1) {
                var precisionChr = HEAP8[((textIndex+1)|0)];
                if (precisionChr < 48 ||
                    precisionChr > 57) break;
                precision = precision * 10 + (precisionChr - 48);
                textIndex++;
              }
            }
            next = HEAP8[((textIndex+1)|0)];
          }
          if (precision < 0) {
            precision = 6; // Standard default.
            precisionSet = false;
          }

          // Handle integer sizes. WARNING: These assume a 32-bit architecture!
          var argSize;
          switch (String.fromCharCode(next)) {
            case 'h':
              var nextNext = HEAP8[((textIndex+2)|0)];
              if (nextNext == 104) {
                textIndex++;
                argSize = 1; // char (actually i32 in varargs)
              } else {
                argSize = 2; // short (actually i32 in varargs)
              }
              break;
            case 'l':
              var nextNext = HEAP8[((textIndex+2)|0)];
              if (nextNext == 108) {
                textIndex++;
                argSize = 8; // long long
              } else {
                argSize = 4; // long
              }
              break;
            case 'L': // long long
            case 'q': // int64_t
            case 'j': // intmax_t
              argSize = 8;
              break;
            case 'z': // size_t
            case 't': // ptrdiff_t
            case 'I': // signed ptrdiff_t or unsigned size_t
              argSize = 4;
              break;
            default:
              argSize = null;
          }
          if (argSize) textIndex++;
          next = HEAP8[((textIndex+1)|0)];

          // Handle type specifier.
          switch (String.fromCharCode(next)) {
            case 'd': case 'i': case 'u': case 'o': case 'x': case 'X': case 'p': {
              // Integer.
              var signed = next == 100 || next == 105;
              argSize = argSize || 4;
              var currArg = getNextArg('i' + (argSize * 8));
              var argText;
              // Flatten i64-1 [low, high] into a (slightly rounded) double
              if (argSize == 8) {
                currArg = Runtime.makeBigInt(currArg[0], currArg[1], next == 117);
              }
              // Truncate to requested size.
              if (argSize <= 4) {
                var limit = Math.pow(256, argSize) - 1;
                currArg = (signed ? reSign : unSign)(currArg & limit, argSize * 8);
              }
              // Format the number.
              var currAbsArg = Math.abs(currArg);
              var prefix = '';
              if (next == 100 || next == 105) {
                argText = reSign(currArg, 8 * argSize, 1).toString(10);
              } else if (next == 117) {
                argText = unSign(currArg, 8 * argSize, 1).toString(10);
                currArg = Math.abs(currArg);
              } else if (next == 111) {
                argText = (flagAlternative ? '0' : '') + currAbsArg.toString(8);
              } else if (next == 120 || next == 88) {
                prefix = (flagAlternative && currArg != 0) ? '0x' : '';
                if (currArg < 0) {
                  // Represent negative numbers in hex as 2's complement.
                  currArg = -currArg;
                  argText = (currAbsArg - 1).toString(16);
                  var buffer = [];
                  for (var i = 0; i < argText.length; i++) {
                    buffer.push((0xF - parseInt(argText[i], 16)).toString(16));
                  }
                  argText = buffer.join('');
                  while (argText.length < argSize * 2) argText = 'f' + argText;
                } else {
                  argText = currAbsArg.toString(16);
                }
                if (next == 88) {
                  prefix = prefix.toUpperCase();
                  argText = argText.toUpperCase();
                }
              } else if (next == 112) {
                if (currAbsArg === 0) {
                  argText = '(nil)';
                } else {
                  prefix = '0x';
                  argText = currAbsArg.toString(16);
                }
              }
              if (precisionSet) {
                while (argText.length < precision) {
                  argText = '0' + argText;
                }
              }

              // Add sign if needed
              if (currArg >= 0) {
                if (flagAlwaysSigned) {
                  prefix = '+' + prefix;
                } else if (flagPadSign) {
                  prefix = ' ' + prefix;
                }
              }

              // Move sign to prefix so we zero-pad after the sign
              if (argText.charAt(0) == '-') {
                prefix = '-' + prefix;
                argText = argText.substr(1);
              }

              // Add padding.
              while (prefix.length + argText.length < width) {
                if (flagLeftAlign) {
                  argText += ' ';
                } else {
                  if (flagZeroPad) {
                    argText = '0' + argText;
                  } else {
                    prefix = ' ' + prefix;
                  }
                }
              }

              // Insert the result into the buffer.
              argText = prefix + argText;
              argText.split('').forEach(function(chr) {
                ret.push(chr.charCodeAt(0));
              });
              break;
            }
            case 'f': case 'F': case 'e': case 'E': case 'g': case 'G': {
              // Float.
              var currArg = getNextArg('double');
              var argText;
              if (isNaN(currArg)) {
                argText = 'nan';
                flagZeroPad = false;
              } else if (!isFinite(currArg)) {
                argText = (currArg < 0 ? '-' : '') + 'inf';
                flagZeroPad = false;
              } else {
                var isGeneral = false;
                var effectivePrecision = Math.min(precision, 20);

                // Convert g/G to f/F or e/E, as per:
                // http://pubs.opengroup.org/onlinepubs/9699919799/functions/printf.html
                if (next == 103 || next == 71) {
                  isGeneral = true;
                  precision = precision || 1;
                  var exponent = parseInt(currArg.toExponential(effectivePrecision).split('e')[1], 10);
                  if (precision > exponent && exponent >= -4) {
                    next = ((next == 103) ? 'f' : 'F').charCodeAt(0);
                    precision -= exponent + 1;
                  } else {
                    next = ((next == 103) ? 'e' : 'E').charCodeAt(0);
                    precision--;
                  }
                  effectivePrecision = Math.min(precision, 20);
                }

                if (next == 101 || next == 69) {
                  argText = currArg.toExponential(effectivePrecision);
                  // Make sure the exponent has at least 2 digits.
                  if (/[eE][-+]\d$/.test(argText)) {
                    argText = argText.slice(0, -1) + '0' + argText.slice(-1);
                  }
                } else if (next == 102 || next == 70) {
                  argText = currArg.toFixed(effectivePrecision);
                  if (currArg === 0 && __reallyNegative(currArg)) {
                    argText = '-' + argText;
                  }
                }

                var parts = argText.split('e');
                if (isGeneral && !flagAlternative) {
                  // Discard trailing zeros and periods.
                  while (parts[0].length > 1 && parts[0].indexOf('.') != -1 &&
                         (parts[0].slice(-1) == '0' || parts[0].slice(-1) == '.')) {
                    parts[0] = parts[0].slice(0, -1);
                  }
                } else {
                  // Make sure we have a period in alternative mode.
                  if (flagAlternative && argText.indexOf('.') == -1) parts[0] += '.';
                  // Zero pad until required precision.
                  while (precision > effectivePrecision++) parts[0] += '0';
                }
                argText = parts[0] + (parts.length > 1 ? 'e' + parts[1] : '');

                // Capitalize 'E' if needed.
                if (next == 69) argText = argText.toUpperCase();

                // Add sign.
                if (currArg >= 0) {
                  if (flagAlwaysSigned) {
                    argText = '+' + argText;
                  } else if (flagPadSign) {
                    argText = ' ' + argText;
                  }
                }
              }

              // Add padding.
              while (argText.length < width) {
                if (flagLeftAlign) {
                  argText += ' ';
                } else {
                  if (flagZeroPad && (argText[0] == '-' || argText[0] == '+')) {
                    argText = argText[0] + '0' + argText.slice(1);
                  } else {
                    argText = (flagZeroPad ? '0' : ' ') + argText;
                  }
                }
              }

              // Adjust case.
              if (next < 97) argText = argText.toUpperCase();

              // Insert the result into the buffer.
              argText.split('').forEach(function(chr) {
                ret.push(chr.charCodeAt(0));
              });
              break;
            }
            case 's': {
              // String.
              var arg = getNextArg('i8*');
              var argLength = arg ? _strlen(arg) : '(null)'.length;
              if (precisionSet) argLength = Math.min(argLength, precision);
              if (!flagLeftAlign) {
                while (argLength < width--) {
                  ret.push(32);
                }
              }
              if (arg) {
                for (var i = 0; i < argLength; i++) {
                  ret.push(HEAPU8[((arg++)|0)]);
                }
              } else {
                ret = ret.concat(intArrayFromString('(null)'.substr(0, argLength), true));
              }
              if (flagLeftAlign) {
                while (argLength < width--) {
                  ret.push(32);
                }
              }
              break;
            }
            case 'c': {
              // Character.
              if (flagLeftAlign) ret.push(getNextArg('i8'));
              while (--width > 0) {
                ret.push(32);
              }
              if (!flagLeftAlign) ret.push(getNextArg('i8'));
              break;
            }
            case 'n': {
              // Write the length written so far to the next parameter.
              var ptr = getNextArg('i32*');
              HEAP32[((ptr)>>2)]=ret.length;
              break;
            }
            case '%': {
              // Literal percent sign.
              ret.push(curr);
              break;
            }
            default: {
              // Unknown specifiers remain untouched.
              for (var i = startTextIndex; i < textIndex + 2; i++) {
                ret.push(HEAP8[(i)]);
              }
            }
          }
          textIndex += 2;
          // TODO: Support a/A (hex float) and m (last error) specifiers.
          // TODO: Support %1${specifier} for arg selection.
        } else {
          ret.push(curr);
          textIndex += 1;
        }
      }
      return ret;
    }function _fprintf(stream, format, varargs) {
      // int fprintf(FILE *restrict stream, const char *restrict format, ...);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/printf.html
      var result = __formatString(format, varargs);
      var stack = Runtime.stackSave();
      var ret = _fwrite(allocate(result, 'i8', ALLOC_STACK), 1, result.length, stream);
      Runtime.stackRestore(stack);
      return ret;
    }function _printf(format, varargs) {
      // int printf(const char *restrict format, ...);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/printf.html
      var stdout = HEAP32[((_stdout)>>2)];
      return _fprintf(stdout, format, varargs);
    }

  var _sinf=Math_sin;


  var _sqrtf=Math_sqrt;

  var _floorf=Math_floor;


  function _fputs(s, stream) {
      // int fputs(const char *restrict s, FILE *restrict stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fputs.html
      var fd = _fileno(stream);
      return _write(fd, s, _strlen(s));
    }

  function _fputc(c, stream) {
      // int fputc(int c, FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fputc.html
      var chr = unSign(c & 0xFF);
      HEAP8[((_fputc.ret)|0)]=chr;
      var fd = _fileno(stream);
      var ret = _write(fd, _fputc.ret, 1);
      if (ret == -1) {
        var streamObj = FS.getStreamFromPtr(stream);
        if (streamObj) streamObj.error = true;
        return -1;
      } else {
        return chr;
      }
    }function _puts(s) {
      // int puts(const char *s);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/puts.html
      // NOTE: puts() always writes an extra newline.
      var stdout = HEAP32[((_stdout)>>2)];
      var ret = _fputs(s, stdout);
      if (ret < 0) {
        return ret;
      } else {
        var newlineRet = _fputc(10, stdout);
        return (newlineRet < 0) ? -1 : ret + 1;
      }
    }

  function _clock() {
      if (_clock.start === undefined) _clock.start = Date.now();
      return Math.floor((Date.now() - _clock.start) * (1000000/1000));
    }


  var ___cxa_caught_exceptions=[];function ___cxa_begin_catch(ptr) {
      __ZSt18uncaught_exceptionv.uncaught_exception--;
      ___cxa_caught_exceptions.push(___cxa_last_thrown_exception);
      return ptr;
    }

  function ___errno_location() {
      return ___errno_state;
    }


  function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.set(HEAPU8.subarray(src, src+num), dest);
      return dest;
    }
  Module["_memcpy"] = _memcpy;

  function __ZNSt9exceptionD2Ev() {}

  var Browser={mainLoop:{scheduler:null,method:"",shouldPause:false,paused:false,queue:[],pause:function () {
          Browser.mainLoop.shouldPause = true;
        },resume:function () {
          if (Browser.mainLoop.paused) {
            Browser.mainLoop.paused = false;
            Browser.mainLoop.scheduler();
          }
          Browser.mainLoop.shouldPause = false;
        },updateStatus:function () {
          if (Module['setStatus']) {
            var message = Module['statusMessage'] || 'Please wait...';
            var remaining = Browser.mainLoop.remainingBlockers;
            var expected = Browser.mainLoop.expectedBlockers;
            if (remaining) {
              if (remaining < expected) {
                Module['setStatus'](message + ' (' + (expected - remaining) + '/' + expected + ')');
              } else {
                Module['setStatus'](message);
              }
            } else {
              Module['setStatus']('');
            }
          }
        }},isFullScreen:false,pointerLock:false,moduleContextCreatedCallbacks:[],workers:[],init:function () {
        if (!Module["preloadPlugins"]) Module["preloadPlugins"] = []; // needs to exist even in workers

        if (Browser.initted || ENVIRONMENT_IS_WORKER) return;
        Browser.initted = true;

        try {
          new Blob();
          Browser.hasBlobConstructor = true;
        } catch(e) {
          Browser.hasBlobConstructor = false;
          console.log("warning: no blob constructor, cannot create blobs with mimetypes");
        }
        Browser.BlobBuilder = typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : (typeof WebKitBlobBuilder != "undefined" ? WebKitBlobBuilder : (!Browser.hasBlobConstructor ? console.log("warning: no BlobBuilder") : null));
        Browser.URLObject = typeof window != "undefined" ? (window.URL ? window.URL : window.webkitURL) : undefined;
        if (!Module.noImageDecoding && typeof Browser.URLObject === 'undefined') {
          console.log("warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available.");
          Module.noImageDecoding = true;
        }

        // Support for plugins that can process preloaded files. You can add more of these to
        // your app by creating and appending to Module.preloadPlugins.
        //
        // Each plugin is asked if it can handle a file based on the file's name. If it can,
        // it is given the file's raw data. When it is done, it calls a callback with the file's
        // (possibly modified) data. For example, a plugin might decompress a file, or it
        // might create some side data structure for use later (like an Image element, etc.).

        var imagePlugin = {};
        imagePlugin['canHandle'] = function imagePlugin_canHandle(name) {
          return !Module.noImageDecoding && /\.(jpg|jpeg|png|bmp)$/i.test(name);
        };
        imagePlugin['handle'] = function imagePlugin_handle(byteArray, name, onload, onerror) {
          var b = null;
          if (Browser.hasBlobConstructor) {
            try {
              b = new Blob([byteArray], { type: Browser.getMimetype(name) });
              if (b.size !== byteArray.length) { // Safari bug #118630
                // Safari's Blob can only take an ArrayBuffer
                b = new Blob([(new Uint8Array(byteArray)).buffer], { type: Browser.getMimetype(name) });
              }
            } catch(e) {
              Runtime.warnOnce('Blob constructor present but fails: ' + e + '; falling back to blob builder');
            }
          }
          if (!b) {
            var bb = new Browser.BlobBuilder();
            bb.append((new Uint8Array(byteArray)).buffer); // we need to pass a buffer, and must copy the array to get the right data range
            b = bb.getBlob();
          }
          var url = Browser.URLObject.createObjectURL(b);
          var img = new Image();
          img.onload = function img_onload() {
            assert(img.complete, 'Image ' + name + ' could not be decoded');
            var canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            Module["preloadedImages"][name] = canvas;
            Browser.URLObject.revokeObjectURL(url);
            if (onload) onload(byteArray);
          };
          img.onerror = function img_onerror(event) {
            console.log('Image ' + url + ' could not be decoded');
            if (onerror) onerror();
          };
          img.src = url;
        };
        Module['preloadPlugins'].push(imagePlugin);

        var audioPlugin = {};
        audioPlugin['canHandle'] = function audioPlugin_canHandle(name) {
          return !Module.noAudioDecoding && name.substr(-4) in { '.ogg': 1, '.wav': 1, '.mp3': 1 };
        };
        audioPlugin['handle'] = function audioPlugin_handle(byteArray, name, onload, onerror) {
          var done = false;
          function finish(audio) {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = audio;
            if (onload) onload(byteArray);
          }
          function fail() {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = new Audio(); // empty shim
            if (onerror) onerror();
          }
          if (Browser.hasBlobConstructor) {
            try {
              var b = new Blob([byteArray], { type: Browser.getMimetype(name) });
            } catch(e) {
              return fail();
            }
            var url = Browser.URLObject.createObjectURL(b); // XXX we never revoke this!
            var audio = new Audio();
            audio.addEventListener('canplaythrough', function() { finish(audio) }, false); // use addEventListener due to chromium bug 124926
            audio.onerror = function audio_onerror(event) {
              if (done) return;
              console.log('warning: browser could not fully decode audio ' + name + ', trying slower base64 approach');
              function encode64(data) {
                var BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                var PAD = '=';
                var ret = '';
                var leftchar = 0;
                var leftbits = 0;
                for (var i = 0; i < data.length; i++) {
                  leftchar = (leftchar << 8) | data[i];
                  leftbits += 8;
                  while (leftbits >= 6) {
                    var curr = (leftchar >> (leftbits-6)) & 0x3f;
                    leftbits -= 6;
                    ret += BASE[curr];
                  }
                }
                if (leftbits == 2) {
                  ret += BASE[(leftchar&3) << 4];
                  ret += PAD + PAD;
                } else if (leftbits == 4) {
                  ret += BASE[(leftchar&0xf) << 2];
                  ret += PAD;
                }
                return ret;
              }
              audio.src = 'data:audio/x-' + name.substr(-3) + ';base64,' + encode64(byteArray);
              finish(audio); // we don't wait for confirmation this worked - but it's worth trying
            };
            audio.src = url;
            // workaround for chrome bug 124926 - we do not always get oncanplaythrough or onerror
            Browser.safeSetTimeout(function() {
              finish(audio); // try to use it even though it is not necessarily ready to play
            }, 10000);
          } else {
            return fail();
          }
        };
        Module['preloadPlugins'].push(audioPlugin);

        // Canvas event setup

        var canvas = Module['canvas'];

        // forced aspect ratio can be enabled by defining 'forcedAspectRatio' on Module
        // Module['forcedAspectRatio'] = 4 / 3;

        canvas.requestPointerLock = canvas['requestPointerLock'] ||
                                    canvas['mozRequestPointerLock'] ||
                                    canvas['webkitRequestPointerLock'] ||
                                    canvas['msRequestPointerLock'] ||
                                    function(){};
        canvas.exitPointerLock = document['exitPointerLock'] ||
                                 document['mozExitPointerLock'] ||
                                 document['webkitExitPointerLock'] ||
                                 document['msExitPointerLock'] ||
                                 function(){}; // no-op if function does not exist
        canvas.exitPointerLock = canvas.exitPointerLock.bind(document);

        function pointerLockChange() {
          Browser.pointerLock = document['pointerLockElement'] === canvas ||
                                document['mozPointerLockElement'] === canvas ||
                                document['webkitPointerLockElement'] === canvas ||
                                document['msPointerLockElement'] === canvas;
        }

        document.addEventListener('pointerlockchange', pointerLockChange, false);
        document.addEventListener('mozpointerlockchange', pointerLockChange, false);
        document.addEventListener('webkitpointerlockchange', pointerLockChange, false);
        document.addEventListener('mspointerlockchange', pointerLockChange, false);

        if (Module['elementPointerLock']) {
          canvas.addEventListener("click", function(ev) {
            if (!Browser.pointerLock && canvas.requestPointerLock) {
              canvas.requestPointerLock();
              ev.preventDefault();
            }
          }, false);
        }
      },createContext:function (canvas, useWebGL, setInModule, webGLContextAttributes) {
        var ctx;
        var errorInfo = '?';
        function onContextCreationError(event) {
          errorInfo = event.statusMessage || errorInfo;
        }
        try {
          if (useWebGL) {
            var contextAttributes = {
              antialias: false,
              alpha: false
            };

            if (webGLContextAttributes) {
              for (var attribute in webGLContextAttributes) {
                contextAttributes[attribute] = webGLContextAttributes[attribute];
              }
            }


            canvas.addEventListener('webglcontextcreationerror', onContextCreationError, false);
            try {
              ['experimental-webgl', 'webgl'].some(function(webglId) {
                return ctx = canvas.getContext(webglId, contextAttributes);
              });
            } finally {
              canvas.removeEventListener('webglcontextcreationerror', onContextCreationError, false);
            }
          } else {
            ctx = canvas.getContext('2d');
          }
          if (!ctx) throw ':(';
        } catch (e) {
          Module.print('Could not create canvas: ' + [errorInfo, e]);
          return null;
        }
        if (useWebGL) {
          // Set the background of the WebGL canvas to black
          canvas.style.backgroundColor = "black";

          // Warn on context loss
          canvas.addEventListener('webglcontextlost', function(event) {
            alert('WebGL context lost. You will need to reload the page.');
          }, false);
        }
        if (setInModule) {
          GLctx = Module.ctx = ctx;
          Module.useWebGL = useWebGL;
          Browser.moduleContextCreatedCallbacks.forEach(function(callback) { callback() });
          Browser.init();
        }
        return ctx;
      },destroyContext:function (canvas, useWebGL, setInModule) {},fullScreenHandlersInstalled:false,lockPointer:undefined,resizeCanvas:undefined,requestFullScreen:function (lockPointer, resizeCanvas) {
        Browser.lockPointer = lockPointer;
        Browser.resizeCanvas = resizeCanvas;
        if (typeof Browser.lockPointer === 'undefined') Browser.lockPointer = true;
        if (typeof Browser.resizeCanvas === 'undefined') Browser.resizeCanvas = false;

        var canvas = Module['canvas'];
        function fullScreenChange() {
          Browser.isFullScreen = false;
          var canvasContainer = canvas.parentNode;
          if ((document['webkitFullScreenElement'] || document['webkitFullscreenElement'] ||
               document['mozFullScreenElement'] || document['mozFullscreenElement'] ||
               document['fullScreenElement'] || document['fullscreenElement'] ||
               document['msFullScreenElement'] || document['msFullscreenElement'] ||
               document['webkitCurrentFullScreenElement']) === canvasContainer) {
            canvas.cancelFullScreen = document['cancelFullScreen'] ||
                                      document['mozCancelFullScreen'] ||
                                      document['webkitCancelFullScreen'] ||
                                      document['msExitFullscreen'] ||
                                      document['exitFullscreen'] ||
                                      function() {};
            canvas.cancelFullScreen = canvas.cancelFullScreen.bind(document);
            if (Browser.lockPointer) canvas.requestPointerLock();
            Browser.isFullScreen = true;
            if (Browser.resizeCanvas) Browser.setFullScreenCanvasSize();
          } else {

            // remove the full screen specific parent of the canvas again to restore the HTML structure from before going full screen
            canvasContainer.parentNode.insertBefore(canvas, canvasContainer);
            canvasContainer.parentNode.removeChild(canvasContainer);

            if (Browser.resizeCanvas) Browser.setWindowedCanvasSize();
          }
          if (Module['onFullScreen']) Module['onFullScreen'](Browser.isFullScreen);
          Browser.updateCanvasDimensions(canvas);
        }

        if (!Browser.fullScreenHandlersInstalled) {
          Browser.fullScreenHandlersInstalled = true;
          document.addEventListener('fullscreenchange', fullScreenChange, false);
          document.addEventListener('mozfullscreenchange', fullScreenChange, false);
          document.addEventListener('webkitfullscreenchange', fullScreenChange, false);
          document.addEventListener('MSFullscreenChange', fullScreenChange, false);
        }

        // create a new parent to ensure the canvas has no siblings. this allows browsers to optimize full screen performance when its parent is the full screen root
        var canvasContainer = document.createElement("div");
        canvas.parentNode.insertBefore(canvasContainer, canvas);
        canvasContainer.appendChild(canvas);

        // use parent of canvas as full screen root to allow aspect ratio correction (Firefox stretches the root to screen size)
        canvasContainer.requestFullScreen = canvasContainer['requestFullScreen'] ||
                                            canvasContainer['mozRequestFullScreen'] ||
                                            canvasContainer['msRequestFullscreen'] ||
                                           (canvasContainer['webkitRequestFullScreen'] ? function() { canvasContainer['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']) } : null);
        canvasContainer.requestFullScreen();
      },requestAnimationFrame:function requestAnimationFrame(func) {
        if (typeof window === 'undefined') { // Provide fallback to setTimeout if window is undefined (e.g. in Node.js)
          setTimeout(func, 1000/60);
        } else {
          if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = window['requestAnimationFrame'] ||
                                           window['mozRequestAnimationFrame'] ||
                                           window['webkitRequestAnimationFrame'] ||
                                           window['msRequestAnimationFrame'] ||
                                           window['oRequestAnimationFrame'] ||
                                           window['setTimeout'];
          }
          window.requestAnimationFrame(func);
        }
      },safeCallback:function (func) {
        return function() {
          if (!ABORT) return func.apply(null, arguments);
        };
      },safeRequestAnimationFrame:function (func) {
        return Browser.requestAnimationFrame(function() {
          if (!ABORT) func();
        });
      },safeSetTimeout:function (func, timeout) {
        return setTimeout(function() {
          if (!ABORT) func();
        }, timeout);
      },safeSetInterval:function (func, timeout) {
        return setInterval(function() {
          if (!ABORT) func();
        }, timeout);
      },getMimetype:function (name) {
        return {
          'jpg': 'image/jpeg',
          'jpeg': 'image/jpeg',
          'png': 'image/png',
          'bmp': 'image/bmp',
          'ogg': 'audio/ogg',
          'wav': 'audio/wav',
          'mp3': 'audio/mpeg'
        }[name.substr(name.lastIndexOf('.')+1)];
      },getUserMedia:function (func) {
        if(!window.getUserMedia) {
          window.getUserMedia = navigator['getUserMedia'] ||
                                navigator['mozGetUserMedia'];
        }
        window.getUserMedia(func);
      },getMovementX:function (event) {
        return event['movementX'] ||
               event['mozMovementX'] ||
               event['webkitMovementX'] ||
               0;
      },getMovementY:function (event) {
        return event['movementY'] ||
               event['mozMovementY'] ||
               event['webkitMovementY'] ||
               0;
      },getMouseWheelDelta:function (event) {
        return Math.max(-1, Math.min(1, event.type === 'DOMMouseScroll' ? event.detail : -event.wheelDelta));
      },mouseX:0,mouseY:0,mouseMovementX:0,mouseMovementY:0,calculateMouseEvent:function (event) { // event should be mousemove, mousedown or mouseup
        if (Browser.pointerLock) {
          // When the pointer is locked, calculate the coordinates
          // based on the movement of the mouse.
          // Workaround for Firefox bug 764498
          if (event.type != 'mousemove' &&
              ('mozMovementX' in event)) {
            Browser.mouseMovementX = Browser.mouseMovementY = 0;
          } else {
            Browser.mouseMovementX = Browser.getMovementX(event);
            Browser.mouseMovementY = Browser.getMovementY(event);
          }

          // check if SDL is available
          if (typeof SDL != "undefined") {
    Browser.mouseX = SDL.mouseX + Browser.mouseMovementX;
    Browser.mouseY = SDL.mouseY + Browser.mouseMovementY;
          } else {
    // just add the mouse delta to the current absolut mouse position
    // FIXME: ideally this should be clamped against the canvas size and zero
    Browser.mouseX += Browser.mouseMovementX;
    Browser.mouseY += Browser.mouseMovementY;
          }
        } else {
          // Otherwise, calculate the movement based on the changes
          // in the coordinates.
          var rect = Module["canvas"].getBoundingClientRect();
          var x, y;

          // Neither .scrollX or .pageXOffset are defined in a spec, but
          // we prefer .scrollX because it is currently in a spec draft.
          // (see: http://www.w3.org/TR/2013/WD-cssom-view-20131217/)
          var scrollX = ((typeof window.scrollX !== 'undefined') ? window.scrollX : window.pageXOffset);
          var scrollY = ((typeof window.scrollY !== 'undefined') ? window.scrollY : window.pageYOffset);
          if (event.type == 'touchstart' ||
              event.type == 'touchend' ||
              event.type == 'touchmove') {
            var t = event.touches.item(0);
            if (t) {
              x = t.pageX - (scrollX + rect.left);
              y = t.pageY - (scrollY + rect.top);
            } else {
              return;
            }
          } else {
            x = event.pageX - (scrollX + rect.left);
            y = event.pageY - (scrollY + rect.top);
          }

          // the canvas might be CSS-scaled compared to its backbuffer;
          // SDL-using content will want mouse coordinates in terms
          // of backbuffer units.
          var cw = Module["canvas"].width;
          var ch = Module["canvas"].height;
          x = x * (cw / rect.width);
          y = y * (ch / rect.height);

          Browser.mouseMovementX = x - Browser.mouseX;
          Browser.mouseMovementY = y - Browser.mouseY;
          Browser.mouseX = x;
          Browser.mouseY = y;
        }
      },xhrLoad:function (url, onload, onerror) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'arraybuffer';
        xhr.onload = function xhr_onload() {
          if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
            onload(xhr.response);
          } else {
            onerror();
          }
        };
        xhr.onerror = onerror;
        xhr.send(null);
      },asyncLoad:function (url, onload, onerror, noRunDep) {
        Browser.xhrLoad(url, function(arrayBuffer) {
          assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
          onload(new Uint8Array(arrayBuffer));
          if (!noRunDep) removeRunDependency('al ' + url);
        }, function(event) {
          if (onerror) {
            onerror();
          } else {
            throw 'Loading data file "' + url + '" failed.';
          }
        });
        if (!noRunDep) addRunDependency('al ' + url);
      },resizeListeners:[],updateResizeListeners:function () {
        var canvas = Module['canvas'];
        Browser.resizeListeners.forEach(function(listener) {
          listener(canvas.width, canvas.height);
        });
      },setCanvasSize:function (width, height, noUpdates) {
        var canvas = Module['canvas'];
        Browser.updateCanvasDimensions(canvas, width, height);
        if (!noUpdates) Browser.updateResizeListeners();
      },windowedWidth:0,windowedHeight:0,setFullScreenCanvasSize:function () {
        // check if SDL is available
        if (typeof SDL != "undefined") {
    var flags = HEAPU32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)];
    flags = flags | 0x00800000; // set SDL_FULLSCREEN flag
    HEAP32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)]=flags
        }
        Browser.updateResizeListeners();
      },setWindowedCanvasSize:function () {
        // check if SDL is available
        if (typeof SDL != "undefined") {
    var flags = HEAPU32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)];
    flags = flags & ~0x00800000; // clear SDL_FULLSCREEN flag
    HEAP32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)]=flags
        }
        Browser.updateResizeListeners();
      },updateCanvasDimensions:function (canvas, wNative, hNative) {
        if (wNative && hNative) {
          canvas.widthNative = wNative;
          canvas.heightNative = hNative;
        } else {
          wNative = canvas.widthNative;
          hNative = canvas.heightNative;
        }
        var w = wNative;
        var h = hNative;
        if (Module['forcedAspectRatio'] && Module['forcedAspectRatio'] > 0) {
          if (w/h < Module['forcedAspectRatio']) {
            w = Math.round(h * Module['forcedAspectRatio']);
          } else {
            h = Math.round(w / Module['forcedAspectRatio']);
          }
        }
        if (((document['webkitFullScreenElement'] || document['webkitFullscreenElement'] ||
             document['mozFullScreenElement'] || document['mozFullscreenElement'] ||
             document['fullScreenElement'] || document['fullscreenElement'] ||
             document['msFullScreenElement'] || document['msFullscreenElement'] ||
             document['webkitCurrentFullScreenElement']) === canvas.parentNode) && (typeof screen != 'undefined')) {
           var factor = Math.min(screen.width / w, screen.height / h);
           w = Math.round(w * factor);
           h = Math.round(h * factor);
        }
        if (Browser.resizeCanvas) {
          if (canvas.width  != w) canvas.width  = w;
          if (canvas.height != h) canvas.height = h;
          if (typeof canvas.style != 'undefined') {
            canvas.style.removeProperty( "width");
            canvas.style.removeProperty("height");
          }
        } else {
          if (canvas.width  != wNative) canvas.width  = wNative;
          if (canvas.height != hNative) canvas.height = hNative;
          if (typeof canvas.style != 'undefined') {
            if (w != wNative || h != hNative) {
              canvas.style.setProperty( "width", w + "px", "important");
              canvas.style.setProperty("height", h + "px", "important");
            } else {
              canvas.style.removeProperty( "width");
              canvas.style.removeProperty("height");
            }
          }
        }
      }};

  function _sbrk(bytes) {
      // Implement a Linux-like 'memory area' for our 'process'.
      // Changes the size of the memory area by |bytes|; returns the
      // address of the previous top ('break') of the memory area
      // We control the "dynamic" memory - DYNAMIC_BASE to DYNAMICTOP
      var self = _sbrk;
      if (!self.called) {
        DYNAMICTOP = alignMemoryPage(DYNAMICTOP); // make sure we start out aligned
        self.called = true;
        assert(Runtime.dynamicAlloc);
        self.alloc = Runtime.dynamicAlloc;
        Runtime.dynamicAlloc = function() { abort('cannot dynamically allocate, sbrk now has control') };
      }
      var ret = DYNAMICTOP;
      if (bytes != 0) self.alloc(bytes);
      return ret;  // Previous break location.
    }

  function _sysconf(name) {
      // long sysconf(int name);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/sysconf.html
      switch(name) {
        case 30: return PAGE_SIZE;
        case 132:
        case 133:
        case 12:
        case 137:
        case 138:
        case 15:
        case 235:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 149:
        case 13:
        case 10:
        case 236:
        case 153:
        case 9:
        case 21:
        case 22:
        case 159:
        case 154:
        case 14:
        case 77:
        case 78:
        case 139:
        case 80:
        case 81:
        case 79:
        case 82:
        case 68:
        case 67:
        case 164:
        case 11:
        case 29:
        case 47:
        case 48:
        case 95:
        case 52:
        case 51:
        case 46:
          return 200809;
        case 27:
        case 246:
        case 127:
        case 128:
        case 23:
        case 24:
        case 160:
        case 161:
        case 181:
        case 182:
        case 242:
        case 183:
        case 184:
        case 243:
        case 244:
        case 245:
        case 165:
        case 178:
        case 179:
        case 49:
        case 50:
        case 168:
        case 169:
        case 175:
        case 170:
        case 171:
        case 172:
        case 97:
        case 76:
        case 32:
        case 173:
        case 35:
          return -1;
        case 176:
        case 177:
        case 7:
        case 155:
        case 8:
        case 157:
        case 125:
        case 126:
        case 92:
        case 93:
        case 129:
        case 130:
        case 131:
        case 94:
        case 91:
          return 1;
        case 74:
        case 60:
        case 69:
        case 70:
        case 4:
          return 1024;
        case 31:
        case 42:
        case 72:
          return 32;
        case 87:
        case 26:
        case 33:
          return 2147483647;
        case 34:
        case 1:
          return 47839;
        case 38:
        case 36:
          return 99;
        case 43:
        case 37:
          return 2048;
        case 0: return 2097152;
        case 3: return 65536;
        case 28: return 32768;
        case 44: return 32767;
        case 75: return 16384;
        case 39: return 1000;
        case 89: return 700;
        case 71: return 256;
        case 40: return 255;
        case 2: return 100;
        case 180: return 64;
        case 25: return 20;
        case 5: return 16;
        case 6: return 6;
        case 73: return 4;
        case 84: return 1;
      }
      ___setErrNo(ERRNO_CODES.EINVAL);
      return -1;
    }

  function _emscripten_run_script(ptr) {
      eval(Pointer_stringify(ptr));
    }


  function _malloc(bytes) {
      /* Over-allocate to make sure it is byte-aligned by 8.
       * This will leak memory, but this is only the dummy
       * implementation (replaced by dlmalloc normally) so
       * not an issue.
       */
      var ptr = Runtime.dynamicAlloc(bytes + 8);
      return (ptr+8) & 0xFFFFFFF8;
    }
  Module["_malloc"] = _malloc;function ___cxa_allocate_exception(size) {
      var ptr = _malloc(size + ___cxa_exception_header_size);
      return ptr + ___cxa_exception_header_size;
    }

  function _emscripten_cancel_main_loop() {
      Browser.mainLoop.scheduler = null;
      Browser.mainLoop.shouldPause = true;
    }

  var __ZTISt9exception=allocate([allocate([1,0,0,0,0,0,0], "i8", ALLOC_STATIC)+8, 0], "i32", ALLOC_STATIC);
FS.staticInit();__ATINIT__.unshift({ func: function() { if (!Module["noFSInit"] && !FS.init.initialized) FS.init() } });__ATMAIN__.push({ func: function() { FS.ignorePermissions = false } });__ATEXIT__.push({ func: function() { FS.quit() } });Module["FS_createFolder"] = FS.createFolder;Module["FS_createPath"] = FS.createPath;Module["FS_createDataFile"] = FS.createDataFile;Module["FS_createPreloadedFile"] = FS.createPreloadedFile;Module["FS_createLazyFile"] = FS.createLazyFile;Module["FS_createLink"] = FS.createLink;Module["FS_createDevice"] = FS.createDevice;
___errno_state = Runtime.staticAlloc(4); HEAP32[((___errno_state)>>2)]=0;
__ATINIT__.unshift({ func: function() { TTY.init() } });__ATEXIT__.push({ func: function() { TTY.shutdown() } });TTY.utf8 = new Runtime.UTF8Processor();
if (ENVIRONMENT_IS_NODE) { var fs = require("fs"); NODEFS.staticInit(); }
__ATINIT__.push({ func: function() { SOCKFS.root = FS.mount(SOCKFS, {}, null); } });
_fputc.ret = allocate([0], "i8", ALLOC_STATIC);
Module["requestFullScreen"] = function Module_requestFullScreen(lockPointer, resizeCanvas) { Browser.requestFullScreen(lockPointer, resizeCanvas) };
  Module["requestAnimationFrame"] = function Module_requestAnimationFrame(func) { Browser.requestAnimationFrame(func) };
  Module["setCanvasSize"] = function Module_setCanvasSize(width, height, noUpdates) { Browser.setCanvasSize(width, height, noUpdates) };
  Module["pauseMainLoop"] = function Module_pauseMainLoop() { Browser.mainLoop.pause() };
  Module["resumeMainLoop"] = function Module_resumeMainLoop() { Browser.mainLoop.resume() };
  Module["getUserMedia"] = function Module_getUserMedia() { Browser.getUserMedia() }
STACK_BASE = STACKTOP = Runtime.alignMemory(STATICTOP);

staticSealed = true; // seal the static portion of memory

STACK_MAX = STACK_BASE + 5242880;

DYNAMIC_BASE = DYNAMICTOP = Runtime.alignMemory(STACK_MAX);

assert(DYNAMIC_BASE < TOTAL_MEMORY, "TOTAL_MEMORY not big enough for stack");


var Math_min = Math.min;
function invoke_iiii(index,a1,a2,a3) {
  try {
    return Module["dynCall_iiii"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_viiiii(index,a1,a2,a3,a4,a5) {
  try {
    Module["dynCall_viiiii"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_vi(index,a1) {
  try {
    Module["dynCall_vi"](index,a1);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_vii(index,a1,a2) {
  try {
    Module["dynCall_vii"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_ii(index,a1) {
  try {
    return Module["dynCall_ii"](index,a1);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_viii(index,a1,a2,a3) {
  try {
    Module["dynCall_viii"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_v(index) {
  try {
    Module["dynCall_v"](index);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_viid(index,a1,a2,a3) {
  try {
    Module["dynCall_viid"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_viiiiii(index,a1,a2,a3,a4,a5,a6) {
  try {
    Module["dynCall_viiiiii"](index,a1,a2,a3,a4,a5,a6);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_iii(index,a1,a2) {
  try {
    return Module["dynCall_iii"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_iiiiii(index,a1,a2,a3,a4,a5) {
  try {
    return Module["dynCall_iiiiii"](index,a1,a2,a3,a4,a5);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_viiii(index,a1,a2,a3,a4) {
  try {
    Module["dynCall_viiii"](index,a1,a2,a3,a4);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function asmPrintInt(x, y) {
  Module.print('int ' + x + ',' + y);// + ' ' + new Error().stack);
}
function asmPrintFloat(x, y) {
  Module.print('float ' + x + ',' + y);// + ' ' + new Error().stack);
}
// EMSCRIPTEN_START_ASM
var ModuleFunc;
var asm = (ModuleFunc = function(global, env, buffer) {
  'use asm';
  var HEAP8 = new global.Int8Array(buffer);
  var HEAP16 = new global.Int16Array(buffer);
  var HEAP32 = new global.Int32Array(buffer);
  var HEAPU8 = new global.Uint8Array(buffer);
  var HEAPU16 = new global.Uint16Array(buffer);
  var HEAPU32 = new global.Uint32Array(buffer);
  var HEAPF32 = new global.Float32Array(buffer);
  var HEAPF64 = new global.Float64Array(buffer);

  var STACKTOP=env.STACKTOP|0;
  var STACK_MAX=env.STACK_MAX|0;
  var tempDoublePtr=env.tempDoublePtr|0;
  var ABORT=env.ABORT|0;
  var __ZTISt9exception=env.__ZTISt9exception|0;

  var __THREW__ = 0;
  var threwValue = 0;
  var setjmpId = 0;
  var undef = 0;
  var nan = +env.NaN, inf = +env.Infinity;
  var tempInt = 0, tempBigInt = 0, tempBigIntP = 0, tempBigIntS = 0, tempBigIntR = 0.0, tempBigIntI = 0, tempBigIntD = 0, tempValue = 0, tempDouble = 0.0;

  var tempRet0 = 0;
  var tempRet1 = 0;
  var tempRet2 = 0;
  var tempRet3 = 0;
  var tempRet4 = 0;
  var tempRet5 = 0;
  var tempRet6 = 0;
  var tempRet7 = 0;
  var tempRet8 = 0;
  var tempRet9 = 0;
  var Math_floor=global.Math.floor;
  var Math_abs=global.Math.abs;
  var Math_sqrt=global.Math.sqrt;
  var Math_pow=global.Math.pow;
  var Math_cos=global.Math.cos;
  var Math_sin=global.Math.sin;
  var Math_tan=global.Math.tan;
  var Math_acos=global.Math.acos;
  var Math_asin=global.Math.asin;
  var Math_atan=global.Math.atan;
  var Math_atan2=global.Math.atan2;
  var Math_exp=global.Math.exp;
  var Math_log=global.Math.log;
  var Math_ceil=global.Math.ceil;
  var Math_imul=global.Math.imul;
  var abort=env.abort;
  var assert=env.assert;
  var asmPrintInt=env.asmPrintInt;
  var asmPrintFloat=env.asmPrintFloat;
  var Math_min=env.min;
  var invoke_iiii=env.invoke_iiii;
  var invoke_viiiii=env.invoke_viiiii;
  var invoke_vi=env.invoke_vi;
  var invoke_vii=env.invoke_vii;
  var invoke_ii=env.invoke_ii;
  var invoke_viii=env.invoke_viii;
  var invoke_v=env.invoke_v;
  var invoke_viid=env.invoke_viid;
  var invoke_viiiiii=env.invoke_viiiiii;
  var invoke_iii=env.invoke_iii;
  var invoke_iiiiii=env.invoke_iiiiii;
  var invoke_viiii=env.invoke_viiii;
  var ___cxa_throw=env.___cxa_throw;
  var _emscripten_run_script=env._emscripten_run_script;
  var _cosf=env._cosf;
  var _send=env._send;
  var __ZSt9terminatev=env.__ZSt9terminatev;
  var __reallyNegative=env.__reallyNegative;
  var ___cxa_is_number_type=env.___cxa_is_number_type;
  var ___assert_fail=env.___assert_fail;
  var ___cxa_allocate_exception=env.___cxa_allocate_exception;
  var ___cxa_find_matching_catch=env.___cxa_find_matching_catch;
  var _fflush=env._fflush;
  var _pwrite=env._pwrite;
  var ___setErrNo=env.___setErrNo;
  var _sbrk=env._sbrk;
  var ___cxa_begin_catch=env.___cxa_begin_catch;
  var _sinf=env._sinf;
  var _fileno=env._fileno;
  var ___resumeException=env.___resumeException;
  var __ZSt18uncaught_exceptionv=env.__ZSt18uncaught_exceptionv;
  var _sysconf=env._sysconf;
  var _clock=env._clock;
  var _emscripten_memcpy_big=env._emscripten_memcpy_big;
  var _puts=env._puts;
  var _mkport=env._mkport;
  var _floorf=env._floorf;
  var _sqrtf=env._sqrtf;
  var _write=env._write;
  var _emscripten_set_main_loop=env._emscripten_set_main_loop;
  var ___errno_location=env.___errno_location;
  var __ZNSt9exceptionD2Ev=env.__ZNSt9exceptionD2Ev;
  var _printf=env._printf;
  var ___cxa_does_inherit=env.___cxa_does_inherit;
  var __exit=env.__exit;
  var _fputc=env._fputc;
  var _abort=env._abort;
  var _fwrite=env._fwrite;
  var _time=env._time;
  var _fprintf=env._fprintf;
  var _emscripten_cancel_main_loop=env._emscripten_cancel_main_loop;
  var __formatString=env.__formatString;
  var _fputs=env._fputs;
  var _exit=env._exit;
  var ___cxa_pure_virtual=env.___cxa_pure_virtual;
  var tempFloat = 0.0;

// EMSCRIPTEN_START_FUNCS
function _malloc(i12) {
 i12 = i12 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0;
 i1 = STACKTOP;
 do {
  if (i12 >>> 0 < 245) {
   if (i12 >>> 0 < 11) {
    i12 = 16;
   } else {
    i12 = i12 + 11 & -8;
   }
   i20 = i12 >>> 3;
   i18 = HEAP32[1790] | 0;
   i21 = i18 >>> i20;
   if ((i21 & 3 | 0) != 0) {
    i6 = (i21 & 1 ^ 1) + i20 | 0;
    i5 = i6 << 1;
    i3 = 7200 + (i5 << 2) | 0;
    i5 = 7200 + (i5 + 2 << 2) | 0;
    i7 = HEAP32[i5 >> 2] | 0;
    i2 = i7 + 8 | 0;
    i4 = HEAP32[i2 >> 2] | 0;
    do {
     if ((i3 | 0) != (i4 | 0)) {
      if (i4 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
       _abort();
      }
      i8 = i4 + 12 | 0;
      if ((HEAP32[i8 >> 2] | 0) == (i7 | 0)) {
       HEAP32[i8 >> 2] = i3;
       HEAP32[i5 >> 2] = i4;
       break;
      } else {
       _abort();
      }
     } else {
      HEAP32[1790] = i18 & ~(1 << i6);
     }
    } while (0);
    i32 = i6 << 3;
    HEAP32[i7 + 4 >> 2] = i32 | 3;
    i32 = i7 + (i32 | 4) | 0;
    HEAP32[i32 >> 2] = HEAP32[i32 >> 2] | 1;
    i32 = i2;
    STACKTOP = i1;
    return i32 | 0;
   }
   if (i12 >>> 0 > (HEAP32[7168 >> 2] | 0) >>> 0) {
    if ((i21 | 0) != 0) {
     i7 = 2 << i20;
     i7 = i21 << i20 & (i7 | 0 - i7);
     i7 = (i7 & 0 - i7) + -1 | 0;
     i2 = i7 >>> 12 & 16;
     i7 = i7 >>> i2;
     i6 = i7 >>> 5 & 8;
     i7 = i7 >>> i6;
     i5 = i7 >>> 2 & 4;
     i7 = i7 >>> i5;
     i4 = i7 >>> 1 & 2;
     i7 = i7 >>> i4;
     i3 = i7 >>> 1 & 1;
     i3 = (i6 | i2 | i5 | i4 | i3) + (i7 >>> i3) | 0;
     i7 = i3 << 1;
     i4 = 7200 + (i7 << 2) | 0;
     i7 = 7200 + (i7 + 2 << 2) | 0;
     i5 = HEAP32[i7 >> 2] | 0;
     i2 = i5 + 8 | 0;
     i6 = HEAP32[i2 >> 2] | 0;
     do {
      if ((i4 | 0) != (i6 | 0)) {
       if (i6 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
        _abort();
       }
       i8 = i6 + 12 | 0;
       if ((HEAP32[i8 >> 2] | 0) == (i5 | 0)) {
        HEAP32[i8 >> 2] = i4;
        HEAP32[i7 >> 2] = i6;
        break;
       } else {
        _abort();
       }
      } else {
       HEAP32[1790] = i18 & ~(1 << i3);
      }
     } while (0);
     i6 = i3 << 3;
     i4 = i6 - i12 | 0;
     HEAP32[i5 + 4 >> 2] = i12 | 3;
     i3 = i5 + i12 | 0;
     HEAP32[i5 + (i12 | 4) >> 2] = i4 | 1;
     HEAP32[i5 + i6 >> 2] = i4;
     i6 = HEAP32[7168 >> 2] | 0;
     if ((i6 | 0) != 0) {
      i5 = HEAP32[7180 >> 2] | 0;
      i8 = i6 >>> 3;
      i9 = i8 << 1;
      i6 = 7200 + (i9 << 2) | 0;
      i7 = HEAP32[1790] | 0;
      i8 = 1 << i8;
      if ((i7 & i8 | 0) != 0) {
       i7 = 7200 + (i9 + 2 << 2) | 0;
       i8 = HEAP32[i7 >> 2] | 0;
       if (i8 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
        _abort();
       } else {
        i28 = i7;
        i27 = i8;
       }
      } else {
       HEAP32[1790] = i7 | i8;
       i28 = 7200 + (i9 + 2 << 2) | 0;
       i27 = i6;
      }
      HEAP32[i28 >> 2] = i5;
      HEAP32[i27 + 12 >> 2] = i5;
      HEAP32[i5 + 8 >> 2] = i27;
      HEAP32[i5 + 12 >> 2] = i6;
     }
     HEAP32[7168 >> 2] = i4;
     HEAP32[7180 >> 2] = i3;
     i32 = i2;
     STACKTOP = i1;
     return i32 | 0;
    }
    i18 = HEAP32[7164 >> 2] | 0;
    if ((i18 | 0) != 0) {
     i2 = (i18 & 0 - i18) + -1 | 0;
     i31 = i2 >>> 12 & 16;
     i2 = i2 >>> i31;
     i30 = i2 >>> 5 & 8;
     i2 = i2 >>> i30;
     i32 = i2 >>> 2 & 4;
     i2 = i2 >>> i32;
     i6 = i2 >>> 1 & 2;
     i2 = i2 >>> i6;
     i3 = i2 >>> 1 & 1;
     i3 = HEAP32[7464 + ((i30 | i31 | i32 | i6 | i3) + (i2 >>> i3) << 2) >> 2] | 0;
     i2 = (HEAP32[i3 + 4 >> 2] & -8) - i12 | 0;
     i6 = i3;
     while (1) {
      i5 = HEAP32[i6 + 16 >> 2] | 0;
      if ((i5 | 0) == 0) {
       i5 = HEAP32[i6 + 20 >> 2] | 0;
       if ((i5 | 0) == 0) {
        break;
       }
      }
      i6 = (HEAP32[i5 + 4 >> 2] & -8) - i12 | 0;
      i4 = i6 >>> 0 < i2 >>> 0;
      i2 = i4 ? i6 : i2;
      i6 = i5;
      i3 = i4 ? i5 : i3;
     }
     i6 = HEAP32[7176 >> 2] | 0;
     if (i3 >>> 0 < i6 >>> 0) {
      _abort();
     }
     i4 = i3 + i12 | 0;
     if (!(i3 >>> 0 < i4 >>> 0)) {
      _abort();
     }
     i5 = HEAP32[i3 + 24 >> 2] | 0;
     i7 = HEAP32[i3 + 12 >> 2] | 0;
     do {
      if ((i7 | 0) == (i3 | 0)) {
       i8 = i3 + 20 | 0;
       i7 = HEAP32[i8 >> 2] | 0;
       if ((i7 | 0) == 0) {
        i8 = i3 + 16 | 0;
        i7 = HEAP32[i8 >> 2] | 0;
        if ((i7 | 0) == 0) {
         i26 = 0;
         break;
        }
       }
       while (1) {
        i10 = i7 + 20 | 0;
        i9 = HEAP32[i10 >> 2] | 0;
        if ((i9 | 0) != 0) {
         i7 = i9;
         i8 = i10;
         continue;
        }
        i10 = i7 + 16 | 0;
        i9 = HEAP32[i10 >> 2] | 0;
        if ((i9 | 0) == 0) {
         break;
        } else {
         i7 = i9;
         i8 = i10;
        }
       }
       if (i8 >>> 0 < i6 >>> 0) {
        _abort();
       } else {
        HEAP32[i8 >> 2] = 0;
        i26 = i7;
        break;
       }
      } else {
       i8 = HEAP32[i3 + 8 >> 2] | 0;
       if (i8 >>> 0 < i6 >>> 0) {
        _abort();
       }
       i6 = i8 + 12 | 0;
       if ((HEAP32[i6 >> 2] | 0) != (i3 | 0)) {
        _abort();
       }
       i9 = i7 + 8 | 0;
       if ((HEAP32[i9 >> 2] | 0) == (i3 | 0)) {
        HEAP32[i6 >> 2] = i7;
        HEAP32[i9 >> 2] = i8;
        i26 = i7;
        break;
       } else {
        _abort();
       }
      }
     } while (0);
     do {
      if ((i5 | 0) != 0) {
       i7 = HEAP32[i3 + 28 >> 2] | 0;
       i6 = 7464 + (i7 << 2) | 0;
       if ((i3 | 0) == (HEAP32[i6 >> 2] | 0)) {
        HEAP32[i6 >> 2] = i26;
        if ((i26 | 0) == 0) {
         HEAP32[7164 >> 2] = HEAP32[7164 >> 2] & ~(1 << i7);
         break;
        }
       } else {
        if (i5 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
         _abort();
        }
        i6 = i5 + 16 | 0;
        if ((HEAP32[i6 >> 2] | 0) == (i3 | 0)) {
         HEAP32[i6 >> 2] = i26;
        } else {
         HEAP32[i5 + 20 >> 2] = i26;
        }
        if ((i26 | 0) == 0) {
         break;
        }
       }
       if (i26 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
        _abort();
       }
       HEAP32[i26 + 24 >> 2] = i5;
       i5 = HEAP32[i3 + 16 >> 2] | 0;
       do {
        if ((i5 | 0) != 0) {
         if (i5 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
          _abort();
         } else {
          HEAP32[i26 + 16 >> 2] = i5;
          HEAP32[i5 + 24 >> 2] = i26;
          break;
         }
        }
       } while (0);
       i5 = HEAP32[i3 + 20 >> 2] | 0;
       if ((i5 | 0) != 0) {
        if (i5 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
         _abort();
        } else {
         HEAP32[i26 + 20 >> 2] = i5;
         HEAP32[i5 + 24 >> 2] = i26;
         break;
        }
       }
      }
     } while (0);
     if (i2 >>> 0 < 16) {
      i32 = i2 + i12 | 0;
      HEAP32[i3 + 4 >> 2] = i32 | 3;
      i32 = i3 + (i32 + 4) | 0;
      HEAP32[i32 >> 2] = HEAP32[i32 >> 2] | 1;
     } else {
      HEAP32[i3 + 4 >> 2] = i12 | 3;
      HEAP32[i3 + (i12 | 4) >> 2] = i2 | 1;
      HEAP32[i3 + (i2 + i12) >> 2] = i2;
      i6 = HEAP32[7168 >> 2] | 0;
      if ((i6 | 0) != 0) {
       i5 = HEAP32[7180 >> 2] | 0;
       i8 = i6 >>> 3;
       i9 = i8 << 1;
       i6 = 7200 + (i9 << 2) | 0;
       i7 = HEAP32[1790] | 0;
       i8 = 1 << i8;
       if ((i7 & i8 | 0) != 0) {
        i7 = 7200 + (i9 + 2 << 2) | 0;
        i8 = HEAP32[i7 >> 2] | 0;
        if (i8 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
         _abort();
        } else {
         i25 = i7;
         i24 = i8;
        }
       } else {
        HEAP32[1790] = i7 | i8;
        i25 = 7200 + (i9 + 2 << 2) | 0;
        i24 = i6;
       }
       HEAP32[i25 >> 2] = i5;
       HEAP32[i24 + 12 >> 2] = i5;
       HEAP32[i5 + 8 >> 2] = i24;
       HEAP32[i5 + 12 >> 2] = i6;
      }
      HEAP32[7168 >> 2] = i2;
      HEAP32[7180 >> 2] = i4;
     }
     i32 = i3 + 8 | 0;
     STACKTOP = i1;
     return i32 | 0;
    }
   }
  } else {
   if (!(i12 >>> 0 > 4294967231)) {
    i24 = i12 + 11 | 0;
    i12 = i24 & -8;
    i26 = HEAP32[7164 >> 2] | 0;
    if ((i26 | 0) != 0) {
     i25 = 0 - i12 | 0;
     i24 = i24 >>> 8;
     if ((i24 | 0) != 0) {
      if (i12 >>> 0 > 16777215) {
       i27 = 31;
      } else {
       i31 = (i24 + 1048320 | 0) >>> 16 & 8;
       i32 = i24 << i31;
       i30 = (i32 + 520192 | 0) >>> 16 & 4;
       i32 = i32 << i30;
       i27 = (i32 + 245760 | 0) >>> 16 & 2;
       i27 = 14 - (i30 | i31 | i27) + (i32 << i27 >>> 15) | 0;
       i27 = i12 >>> (i27 + 7 | 0) & 1 | i27 << 1;
      }
     } else {
      i27 = 0;
     }
     i30 = HEAP32[7464 + (i27 << 2) >> 2] | 0;
     L126 : do {
      if ((i30 | 0) == 0) {
       i29 = 0;
       i24 = 0;
      } else {
       if ((i27 | 0) == 31) {
        i24 = 0;
       } else {
        i24 = 25 - (i27 >>> 1) | 0;
       }
       i29 = 0;
       i28 = i12 << i24;
       i24 = 0;
       while (1) {
        i32 = HEAP32[i30 + 4 >> 2] & -8;
        i31 = i32 - i12 | 0;
        if (i31 >>> 0 < i25 >>> 0) {
         if ((i32 | 0) == (i12 | 0)) {
          i25 = i31;
          i29 = i30;
          i24 = i30;
          break L126;
         } else {
          i25 = i31;
          i24 = i30;
         }
        }
        i31 = HEAP32[i30 + 20 >> 2] | 0;
        i30 = HEAP32[i30 + (i28 >>> 31 << 2) + 16 >> 2] | 0;
        i29 = (i31 | 0) == 0 | (i31 | 0) == (i30 | 0) ? i29 : i31;
        if ((i30 | 0) == 0) {
         break;
        } else {
         i28 = i28 << 1;
        }
       }
      }
     } while (0);
     if ((i29 | 0) == 0 & (i24 | 0) == 0) {
      i32 = 2 << i27;
      i26 = i26 & (i32 | 0 - i32);
      if ((i26 | 0) == 0) {
       break;
      }
      i32 = (i26 & 0 - i26) + -1 | 0;
      i28 = i32 >>> 12 & 16;
      i32 = i32 >>> i28;
      i27 = i32 >>> 5 & 8;
      i32 = i32 >>> i27;
      i30 = i32 >>> 2 & 4;
      i32 = i32 >>> i30;
      i31 = i32 >>> 1 & 2;
      i32 = i32 >>> i31;
      i29 = i32 >>> 1 & 1;
      i29 = HEAP32[7464 + ((i27 | i28 | i30 | i31 | i29) + (i32 >>> i29) << 2) >> 2] | 0;
     }
     if ((i29 | 0) != 0) {
      while (1) {
       i27 = (HEAP32[i29 + 4 >> 2] & -8) - i12 | 0;
       i26 = i27 >>> 0 < i25 >>> 0;
       i25 = i26 ? i27 : i25;
       i24 = i26 ? i29 : i24;
       i26 = HEAP32[i29 + 16 >> 2] | 0;
       if ((i26 | 0) != 0) {
        i29 = i26;
        continue;
       }
       i29 = HEAP32[i29 + 20 >> 2] | 0;
       if ((i29 | 0) == 0) {
        break;
       }
      }
     }
     if ((i24 | 0) != 0 ? i25 >>> 0 < ((HEAP32[7168 >> 2] | 0) - i12 | 0) >>> 0 : 0) {
      i4 = HEAP32[7176 >> 2] | 0;
      if (i24 >>> 0 < i4 >>> 0) {
       _abort();
      }
      i2 = i24 + i12 | 0;
      if (!(i24 >>> 0 < i2 >>> 0)) {
       _abort();
      }
      i3 = HEAP32[i24 + 24 >> 2] | 0;
      i6 = HEAP32[i24 + 12 >> 2] | 0;
      do {
       if ((i6 | 0) == (i24 | 0)) {
        i6 = i24 + 20 | 0;
        i5 = HEAP32[i6 >> 2] | 0;
        if ((i5 | 0) == 0) {
         i6 = i24 + 16 | 0;
         i5 = HEAP32[i6 >> 2] | 0;
         if ((i5 | 0) == 0) {
          i22 = 0;
          break;
         }
        }
        while (1) {
         i8 = i5 + 20 | 0;
         i7 = HEAP32[i8 >> 2] | 0;
         if ((i7 | 0) != 0) {
          i5 = i7;
          i6 = i8;
          continue;
         }
         i7 = i5 + 16 | 0;
         i8 = HEAP32[i7 >> 2] | 0;
         if ((i8 | 0) == 0) {
          break;
         } else {
          i5 = i8;
          i6 = i7;
         }
        }
        if (i6 >>> 0 < i4 >>> 0) {
         _abort();
        } else {
         HEAP32[i6 >> 2] = 0;
         i22 = i5;
         break;
        }
       } else {
        i5 = HEAP32[i24 + 8 >> 2] | 0;
        if (i5 >>> 0 < i4 >>> 0) {
         _abort();
        }
        i7 = i5 + 12 | 0;
        if ((HEAP32[i7 >> 2] | 0) != (i24 | 0)) {
         _abort();
        }
        i4 = i6 + 8 | 0;
        if ((HEAP32[i4 >> 2] | 0) == (i24 | 0)) {
         HEAP32[i7 >> 2] = i6;
         HEAP32[i4 >> 2] = i5;
         i22 = i6;
         break;
        } else {
         _abort();
        }
       }
      } while (0);
      do {
       if ((i3 | 0) != 0) {
        i4 = HEAP32[i24 + 28 >> 2] | 0;
        i5 = 7464 + (i4 << 2) | 0;
        if ((i24 | 0) == (HEAP32[i5 >> 2] | 0)) {
         HEAP32[i5 >> 2] = i22;
         if ((i22 | 0) == 0) {
          HEAP32[7164 >> 2] = HEAP32[7164 >> 2] & ~(1 << i4);
          break;
         }
        } else {
         if (i3 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
          _abort();
         }
         i4 = i3 + 16 | 0;
         if ((HEAP32[i4 >> 2] | 0) == (i24 | 0)) {
          HEAP32[i4 >> 2] = i22;
         } else {
          HEAP32[i3 + 20 >> 2] = i22;
         }
         if ((i22 | 0) == 0) {
          break;
         }
        }
        if (i22 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
         _abort();
        }
        HEAP32[i22 + 24 >> 2] = i3;
        i3 = HEAP32[i24 + 16 >> 2] | 0;
        do {
         if ((i3 | 0) != 0) {
          if (i3 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
           _abort();
          } else {
           HEAP32[i22 + 16 >> 2] = i3;
           HEAP32[i3 + 24 >> 2] = i22;
           break;
          }
         }
        } while (0);
        i3 = HEAP32[i24 + 20 >> 2] | 0;
        if ((i3 | 0) != 0) {
         if (i3 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
          _abort();
         } else {
          HEAP32[i22 + 20 >> 2] = i3;
          HEAP32[i3 + 24 >> 2] = i22;
          break;
         }
        }
       }
      } while (0);
      L204 : do {
       if (!(i25 >>> 0 < 16)) {
        HEAP32[i24 + 4 >> 2] = i12 | 3;
        HEAP32[i24 + (i12 | 4) >> 2] = i25 | 1;
        HEAP32[i24 + (i25 + i12) >> 2] = i25;
        i4 = i25 >>> 3;
        if (i25 >>> 0 < 256) {
         i6 = i4 << 1;
         i3 = 7200 + (i6 << 2) | 0;
         i5 = HEAP32[1790] | 0;
         i4 = 1 << i4;
         if ((i5 & i4 | 0) != 0) {
          i5 = 7200 + (i6 + 2 << 2) | 0;
          i4 = HEAP32[i5 >> 2] | 0;
          if (i4 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
           _abort();
          } else {
           i21 = i5;
           i20 = i4;
          }
         } else {
          HEAP32[1790] = i5 | i4;
          i21 = 7200 + (i6 + 2 << 2) | 0;
          i20 = i3;
         }
         HEAP32[i21 >> 2] = i2;
         HEAP32[i20 + 12 >> 2] = i2;
         HEAP32[i24 + (i12 + 8) >> 2] = i20;
         HEAP32[i24 + (i12 + 12) >> 2] = i3;
         break;
        }
        i3 = i25 >>> 8;
        if ((i3 | 0) != 0) {
         if (i25 >>> 0 > 16777215) {
          i3 = 31;
         } else {
          i31 = (i3 + 1048320 | 0) >>> 16 & 8;
          i32 = i3 << i31;
          i30 = (i32 + 520192 | 0) >>> 16 & 4;
          i32 = i32 << i30;
          i3 = (i32 + 245760 | 0) >>> 16 & 2;
          i3 = 14 - (i30 | i31 | i3) + (i32 << i3 >>> 15) | 0;
          i3 = i25 >>> (i3 + 7 | 0) & 1 | i3 << 1;
         }
        } else {
         i3 = 0;
        }
        i6 = 7464 + (i3 << 2) | 0;
        HEAP32[i24 + (i12 + 28) >> 2] = i3;
        HEAP32[i24 + (i12 + 20) >> 2] = 0;
        HEAP32[i24 + (i12 + 16) >> 2] = 0;
        i4 = HEAP32[7164 >> 2] | 0;
        i5 = 1 << i3;
        if ((i4 & i5 | 0) == 0) {
         HEAP32[7164 >> 2] = i4 | i5;
         HEAP32[i6 >> 2] = i2;
         HEAP32[i24 + (i12 + 24) >> 2] = i6;
         HEAP32[i24 + (i12 + 12) >> 2] = i2;
         HEAP32[i24 + (i12 + 8) >> 2] = i2;
         break;
        }
        i4 = HEAP32[i6 >> 2] | 0;
        if ((i3 | 0) == 31) {
         i3 = 0;
        } else {
         i3 = 25 - (i3 >>> 1) | 0;
        }
        L225 : do {
         if ((HEAP32[i4 + 4 >> 2] & -8 | 0) != (i25 | 0)) {
          i3 = i25 << i3;
          while (1) {
           i6 = i4 + (i3 >>> 31 << 2) + 16 | 0;
           i5 = HEAP32[i6 >> 2] | 0;
           if ((i5 | 0) == 0) {
            break;
           }
           if ((HEAP32[i5 + 4 >> 2] & -8 | 0) == (i25 | 0)) {
            i18 = i5;
            break L225;
           } else {
            i3 = i3 << 1;
            i4 = i5;
           }
          }
          if (i6 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
           _abort();
          } else {
           HEAP32[i6 >> 2] = i2;
           HEAP32[i24 + (i12 + 24) >> 2] = i4;
           HEAP32[i24 + (i12 + 12) >> 2] = i2;
           HEAP32[i24 + (i12 + 8) >> 2] = i2;
           break L204;
          }
         } else {
          i18 = i4;
         }
        } while (0);
        i4 = i18 + 8 | 0;
        i3 = HEAP32[i4 >> 2] | 0;
        i5 = HEAP32[7176 >> 2] | 0;
        if (i18 >>> 0 < i5 >>> 0) {
         _abort();
        }
        if (i3 >>> 0 < i5 >>> 0) {
         _abort();
        } else {
         HEAP32[i3 + 12 >> 2] = i2;
         HEAP32[i4 >> 2] = i2;
         HEAP32[i24 + (i12 + 8) >> 2] = i3;
         HEAP32[i24 + (i12 + 12) >> 2] = i18;
         HEAP32[i24 + (i12 + 24) >> 2] = 0;
         break;
        }
       } else {
        i32 = i25 + i12 | 0;
        HEAP32[i24 + 4 >> 2] = i32 | 3;
        i32 = i24 + (i32 + 4) | 0;
        HEAP32[i32 >> 2] = HEAP32[i32 >> 2] | 1;
       }
      } while (0);
      i32 = i24 + 8 | 0;
      STACKTOP = i1;
      return i32 | 0;
     }
    }
   } else {
    i12 = -1;
   }
  }
 } while (0);
 i18 = HEAP32[7168 >> 2] | 0;
 if (!(i12 >>> 0 > i18 >>> 0)) {
  i3 = i18 - i12 | 0;
  i2 = HEAP32[7180 >> 2] | 0;
  if (i3 >>> 0 > 15) {
   HEAP32[7180 >> 2] = i2 + i12;
   HEAP32[7168 >> 2] = i3;
   HEAP32[i2 + (i12 + 4) >> 2] = i3 | 1;
   HEAP32[i2 + i18 >> 2] = i3;
   HEAP32[i2 + 4 >> 2] = i12 | 3;
  } else {
   HEAP32[7168 >> 2] = 0;
   HEAP32[7180 >> 2] = 0;
   HEAP32[i2 + 4 >> 2] = i18 | 3;
   i32 = i2 + (i18 + 4) | 0;
   HEAP32[i32 >> 2] = HEAP32[i32 >> 2] | 1;
  }
  i32 = i2 + 8 | 0;
  STACKTOP = i1;
  return i32 | 0;
 }
 i18 = HEAP32[7172 >> 2] | 0;
 if (i12 >>> 0 < i18 >>> 0) {
  i31 = i18 - i12 | 0;
  HEAP32[7172 >> 2] = i31;
  i32 = HEAP32[7184 >> 2] | 0;
  HEAP32[7184 >> 2] = i32 + i12;
  HEAP32[i32 + (i12 + 4) >> 2] = i31 | 1;
  HEAP32[i32 + 4 >> 2] = i12 | 3;
  i32 = i32 + 8 | 0;
  STACKTOP = i1;
  return i32 | 0;
 }
 do {
  if ((HEAP32[1908] | 0) == 0) {
   i18 = _sysconf(30) | 0;
   if ((i18 + -1 & i18 | 0) == 0) {
    HEAP32[7640 >> 2] = i18;
    HEAP32[7636 >> 2] = i18;
    HEAP32[7644 >> 2] = -1;
    HEAP32[7648 >> 2] = -1;
    HEAP32[7652 >> 2] = 0;
    HEAP32[7604 >> 2] = 0;
    HEAP32[1908] = (_time(0) | 0) & -16 ^ 1431655768;
    break;
   } else {
    _abort();
   }
  }
 } while (0);
 i20 = i12 + 48 | 0;
 i25 = HEAP32[7640 >> 2] | 0;
 i21 = i12 + 47 | 0;
 i22 = i25 + i21 | 0;
 i25 = 0 - i25 | 0;
 i18 = i22 & i25;
 if (!(i18 >>> 0 > i12 >>> 0)) {
  i32 = 0;
  STACKTOP = i1;
  return i32 | 0;
 }
 i24 = HEAP32[7600 >> 2] | 0;
 if ((i24 | 0) != 0 ? (i31 = HEAP32[7592 >> 2] | 0, i32 = i31 + i18 | 0, i32 >>> 0 <= i31 >>> 0 | i32 >>> 0 > i24 >>> 0) : 0) {
  i32 = 0;
  STACKTOP = i1;
  return i32 | 0;
 }
 L269 : do {
  if ((HEAP32[7604 >> 2] & 4 | 0) == 0) {
   i26 = HEAP32[7184 >> 2] | 0;
   L271 : do {
    if ((i26 | 0) != 0) {
     i24 = 7608 | 0;
     while (1) {
      i27 = HEAP32[i24 >> 2] | 0;
      if (!(i27 >>> 0 > i26 >>> 0) ? (i23 = i24 + 4 | 0, (i27 + (HEAP32[i23 >> 2] | 0) | 0) >>> 0 > i26 >>> 0) : 0) {
       break;
      }
      i24 = HEAP32[i24 + 8 >> 2] | 0;
      if ((i24 | 0) == 0) {
       i13 = 182;
       break L271;
      }
     }
     if ((i24 | 0) != 0) {
      i25 = i22 - (HEAP32[7172 >> 2] | 0) & i25;
      if (i25 >>> 0 < 2147483647) {
       i13 = _sbrk(i25 | 0) | 0;
       i26 = (i13 | 0) == ((HEAP32[i24 >> 2] | 0) + (HEAP32[i23 >> 2] | 0) | 0);
       i22 = i13;
       i24 = i25;
       i23 = i26 ? i13 : -1;
       i25 = i26 ? i25 : 0;
       i13 = 191;
      } else {
       i25 = 0;
      }
     } else {
      i13 = 182;
     }
    } else {
     i13 = 182;
    }
   } while (0);
   do {
    if ((i13 | 0) == 182) {
     i23 = _sbrk(0) | 0;
     if ((i23 | 0) != (-1 | 0)) {
      i24 = i23;
      i22 = HEAP32[7636 >> 2] | 0;
      i25 = i22 + -1 | 0;
      if ((i25 & i24 | 0) == 0) {
       i25 = i18;
      } else {
       i25 = i18 - i24 + (i25 + i24 & 0 - i22) | 0;
      }
      i24 = HEAP32[7592 >> 2] | 0;
      i26 = i24 + i25 | 0;
      if (i25 >>> 0 > i12 >>> 0 & i25 >>> 0 < 2147483647) {
       i22 = HEAP32[7600 >> 2] | 0;
       if ((i22 | 0) != 0 ? i26 >>> 0 <= i24 >>> 0 | i26 >>> 0 > i22 >>> 0 : 0) {
        i25 = 0;
        break;
       }
       i22 = _sbrk(i25 | 0) | 0;
       i13 = (i22 | 0) == (i23 | 0);
       i24 = i25;
       i23 = i13 ? i23 : -1;
       i25 = i13 ? i25 : 0;
       i13 = 191;
      } else {
       i25 = 0;
      }
     } else {
      i25 = 0;
     }
    }
   } while (0);
   L291 : do {
    if ((i13 | 0) == 191) {
     i13 = 0 - i24 | 0;
     if ((i23 | 0) != (-1 | 0)) {
      i17 = i23;
      i14 = i25;
      i13 = 202;
      break L269;
     }
     do {
      if ((i22 | 0) != (-1 | 0) & i24 >>> 0 < 2147483647 & i24 >>> 0 < i20 >>> 0 ? (i19 = HEAP32[7640 >> 2] | 0, i19 = i21 - i24 + i19 & 0 - i19, i19 >>> 0 < 2147483647) : 0) {
       if ((_sbrk(i19 | 0) | 0) == (-1 | 0)) {
        _sbrk(i13 | 0) | 0;
        break L291;
       } else {
        i24 = i19 + i24 | 0;
        break;
       }
      }
     } while (0);
     if ((i22 | 0) != (-1 | 0)) {
      i17 = i22;
      i14 = i24;
      i13 = 202;
      break L269;
     }
    }
   } while (0);
   HEAP32[7604 >> 2] = HEAP32[7604 >> 2] | 4;
   i13 = 199;
  } else {
   i25 = 0;
   i13 = 199;
  }
 } while (0);
 if ((((i13 | 0) == 199 ? i18 >>> 0 < 2147483647 : 0) ? (i17 = _sbrk(i18 | 0) | 0, i16 = _sbrk(0) | 0, (i16 | 0) != (-1 | 0) & (i17 | 0) != (-1 | 0) & i17 >>> 0 < i16 >>> 0) : 0) ? (i15 = i16 - i17 | 0, i14 = i15 >>> 0 > (i12 + 40 | 0) >>> 0, i14) : 0) {
  i14 = i14 ? i15 : i25;
  i13 = 202;
 }
 if ((i13 | 0) == 202) {
  i15 = (HEAP32[7592 >> 2] | 0) + i14 | 0;
  HEAP32[7592 >> 2] = i15;
  if (i15 >>> 0 > (HEAP32[7596 >> 2] | 0) >>> 0) {
   HEAP32[7596 >> 2] = i15;
  }
  i15 = HEAP32[7184 >> 2] | 0;
  L311 : do {
   if ((i15 | 0) != 0) {
    i21 = 7608 | 0;
    while (1) {
     i16 = HEAP32[i21 >> 2] | 0;
     i19 = i21 + 4 | 0;
     i20 = HEAP32[i19 >> 2] | 0;
     if ((i17 | 0) == (i16 + i20 | 0)) {
      i13 = 214;
      break;
     }
     i18 = HEAP32[i21 + 8 >> 2] | 0;
     if ((i18 | 0) == 0) {
      break;
     } else {
      i21 = i18;
     }
    }
    if (((i13 | 0) == 214 ? (HEAP32[i21 + 12 >> 2] & 8 | 0) == 0 : 0) ? i15 >>> 0 >= i16 >>> 0 & i15 >>> 0 < i17 >>> 0 : 0) {
     HEAP32[i19 >> 2] = i20 + i14;
     i2 = (HEAP32[7172 >> 2] | 0) + i14 | 0;
     i3 = i15 + 8 | 0;
     if ((i3 & 7 | 0) == 0) {
      i3 = 0;
     } else {
      i3 = 0 - i3 & 7;
     }
     i32 = i2 - i3 | 0;
     HEAP32[7184 >> 2] = i15 + i3;
     HEAP32[7172 >> 2] = i32;
     HEAP32[i15 + (i3 + 4) >> 2] = i32 | 1;
     HEAP32[i15 + (i2 + 4) >> 2] = 40;
     HEAP32[7188 >> 2] = HEAP32[7648 >> 2];
     break;
    }
    if (i17 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
     HEAP32[7176 >> 2] = i17;
    }
    i19 = i17 + i14 | 0;
    i16 = 7608 | 0;
    while (1) {
     if ((HEAP32[i16 >> 2] | 0) == (i19 | 0)) {
      i13 = 224;
      break;
     }
     i18 = HEAP32[i16 + 8 >> 2] | 0;
     if ((i18 | 0) == 0) {
      break;
     } else {
      i16 = i18;
     }
    }
    if ((i13 | 0) == 224 ? (HEAP32[i16 + 12 >> 2] & 8 | 0) == 0 : 0) {
     HEAP32[i16 >> 2] = i17;
     i6 = i16 + 4 | 0;
     HEAP32[i6 >> 2] = (HEAP32[i6 >> 2] | 0) + i14;
     i6 = i17 + 8 | 0;
     if ((i6 & 7 | 0) == 0) {
      i6 = 0;
     } else {
      i6 = 0 - i6 & 7;
     }
     i7 = i17 + (i14 + 8) | 0;
     if ((i7 & 7 | 0) == 0) {
      i13 = 0;
     } else {
      i13 = 0 - i7 & 7;
     }
     i15 = i17 + (i13 + i14) | 0;
     i8 = i6 + i12 | 0;
     i7 = i17 + i8 | 0;
     i10 = i15 - (i17 + i6) - i12 | 0;
     HEAP32[i17 + (i6 + 4) >> 2] = i12 | 3;
     L348 : do {
      if ((i15 | 0) != (HEAP32[7184 >> 2] | 0)) {
       if ((i15 | 0) == (HEAP32[7180 >> 2] | 0)) {
        i32 = (HEAP32[7168 >> 2] | 0) + i10 | 0;
        HEAP32[7168 >> 2] = i32;
        HEAP32[7180 >> 2] = i7;
        HEAP32[i17 + (i8 + 4) >> 2] = i32 | 1;
        HEAP32[i17 + (i32 + i8) >> 2] = i32;
        break;
       }
       i12 = i14 + 4 | 0;
       i18 = HEAP32[i17 + (i12 + i13) >> 2] | 0;
       if ((i18 & 3 | 0) == 1) {
        i11 = i18 & -8;
        i16 = i18 >>> 3;
        do {
         if (!(i18 >>> 0 < 256)) {
          i9 = HEAP32[i17 + ((i13 | 24) + i14) >> 2] | 0;
          i19 = HEAP32[i17 + (i14 + 12 + i13) >> 2] | 0;
          do {
           if ((i19 | 0) == (i15 | 0)) {
            i19 = i13 | 16;
            i18 = i17 + (i12 + i19) | 0;
            i16 = HEAP32[i18 >> 2] | 0;
            if ((i16 | 0) == 0) {
             i18 = i17 + (i19 + i14) | 0;
             i16 = HEAP32[i18 >> 2] | 0;
             if ((i16 | 0) == 0) {
              i5 = 0;
              break;
             }
            }
            while (1) {
             i20 = i16 + 20 | 0;
             i19 = HEAP32[i20 >> 2] | 0;
             if ((i19 | 0) != 0) {
              i16 = i19;
              i18 = i20;
              continue;
             }
             i19 = i16 + 16 | 0;
             i20 = HEAP32[i19 >> 2] | 0;
             if ((i20 | 0) == 0) {
              break;
             } else {
              i16 = i20;
              i18 = i19;
             }
            }
            if (i18 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
             _abort();
            } else {
             HEAP32[i18 >> 2] = 0;
             i5 = i16;
             break;
            }
           } else {
            i18 = HEAP32[i17 + ((i13 | 8) + i14) >> 2] | 0;
            if (i18 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
             _abort();
            }
            i16 = i18 + 12 | 0;
            if ((HEAP32[i16 >> 2] | 0) != (i15 | 0)) {
             _abort();
            }
            i20 = i19 + 8 | 0;
            if ((HEAP32[i20 >> 2] | 0) == (i15 | 0)) {
             HEAP32[i16 >> 2] = i19;
             HEAP32[i20 >> 2] = i18;
             i5 = i19;
             break;
            } else {
             _abort();
            }
           }
          } while (0);
          if ((i9 | 0) != 0) {
           i16 = HEAP32[i17 + (i14 + 28 + i13) >> 2] | 0;
           i18 = 7464 + (i16 << 2) | 0;
           if ((i15 | 0) == (HEAP32[i18 >> 2] | 0)) {
            HEAP32[i18 >> 2] = i5;
            if ((i5 | 0) == 0) {
             HEAP32[7164 >> 2] = HEAP32[7164 >> 2] & ~(1 << i16);
             break;
            }
           } else {
            if (i9 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
             _abort();
            }
            i16 = i9 + 16 | 0;
            if ((HEAP32[i16 >> 2] | 0) == (i15 | 0)) {
             HEAP32[i16 >> 2] = i5;
            } else {
             HEAP32[i9 + 20 >> 2] = i5;
            }
            if ((i5 | 0) == 0) {
             break;
            }
           }
           if (i5 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
            _abort();
           }
           HEAP32[i5 + 24 >> 2] = i9;
           i15 = i13 | 16;
           i9 = HEAP32[i17 + (i15 + i14) >> 2] | 0;
           do {
            if ((i9 | 0) != 0) {
             if (i9 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
              _abort();
             } else {
              HEAP32[i5 + 16 >> 2] = i9;
              HEAP32[i9 + 24 >> 2] = i5;
              break;
             }
            }
           } while (0);
           i9 = HEAP32[i17 + (i12 + i15) >> 2] | 0;
           if ((i9 | 0) != 0) {
            if (i9 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
             _abort();
            } else {
             HEAP32[i5 + 20 >> 2] = i9;
             HEAP32[i9 + 24 >> 2] = i5;
             break;
            }
           }
          }
         } else {
          i5 = HEAP32[i17 + ((i13 | 8) + i14) >> 2] | 0;
          i12 = HEAP32[i17 + (i14 + 12 + i13) >> 2] | 0;
          i18 = 7200 + (i16 << 1 << 2) | 0;
          if ((i5 | 0) != (i18 | 0)) {
           if (i5 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
            _abort();
           }
           if ((HEAP32[i5 + 12 >> 2] | 0) != (i15 | 0)) {
            _abort();
           }
          }
          if ((i12 | 0) == (i5 | 0)) {
           HEAP32[1790] = HEAP32[1790] & ~(1 << i16);
           break;
          }
          if ((i12 | 0) != (i18 | 0)) {
           if (i12 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
            _abort();
           }
           i16 = i12 + 8 | 0;
           if ((HEAP32[i16 >> 2] | 0) == (i15 | 0)) {
            i9 = i16;
           } else {
            _abort();
           }
          } else {
           i9 = i12 + 8 | 0;
          }
          HEAP32[i5 + 12 >> 2] = i12;
          HEAP32[i9 >> 2] = i5;
         }
        } while (0);
        i15 = i17 + ((i11 | i13) + i14) | 0;
        i10 = i11 + i10 | 0;
       }
       i5 = i15 + 4 | 0;
       HEAP32[i5 >> 2] = HEAP32[i5 >> 2] & -2;
       HEAP32[i17 + (i8 + 4) >> 2] = i10 | 1;
       HEAP32[i17 + (i10 + i8) >> 2] = i10;
       i5 = i10 >>> 3;
       if (i10 >>> 0 < 256) {
        i10 = i5 << 1;
        i2 = 7200 + (i10 << 2) | 0;
        i9 = HEAP32[1790] | 0;
        i5 = 1 << i5;
        if ((i9 & i5 | 0) != 0) {
         i9 = 7200 + (i10 + 2 << 2) | 0;
         i5 = HEAP32[i9 >> 2] | 0;
         if (i5 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
          _abort();
         } else {
          i3 = i9;
          i4 = i5;
         }
        } else {
         HEAP32[1790] = i9 | i5;
         i3 = 7200 + (i10 + 2 << 2) | 0;
         i4 = i2;
        }
        HEAP32[i3 >> 2] = i7;
        HEAP32[i4 + 12 >> 2] = i7;
        HEAP32[i17 + (i8 + 8) >> 2] = i4;
        HEAP32[i17 + (i8 + 12) >> 2] = i2;
        break;
       }
       i3 = i10 >>> 8;
       if ((i3 | 0) != 0) {
        if (i10 >>> 0 > 16777215) {
         i3 = 31;
        } else {
         i31 = (i3 + 1048320 | 0) >>> 16 & 8;
         i32 = i3 << i31;
         i30 = (i32 + 520192 | 0) >>> 16 & 4;
         i32 = i32 << i30;
         i3 = (i32 + 245760 | 0) >>> 16 & 2;
         i3 = 14 - (i30 | i31 | i3) + (i32 << i3 >>> 15) | 0;
         i3 = i10 >>> (i3 + 7 | 0) & 1 | i3 << 1;
        }
       } else {
        i3 = 0;
       }
       i4 = 7464 + (i3 << 2) | 0;
       HEAP32[i17 + (i8 + 28) >> 2] = i3;
       HEAP32[i17 + (i8 + 20) >> 2] = 0;
       HEAP32[i17 + (i8 + 16) >> 2] = 0;
       i9 = HEAP32[7164 >> 2] | 0;
       i5 = 1 << i3;
       if ((i9 & i5 | 0) == 0) {
        HEAP32[7164 >> 2] = i9 | i5;
        HEAP32[i4 >> 2] = i7;
        HEAP32[i17 + (i8 + 24) >> 2] = i4;
        HEAP32[i17 + (i8 + 12) >> 2] = i7;
        HEAP32[i17 + (i8 + 8) >> 2] = i7;
        break;
       }
       i4 = HEAP32[i4 >> 2] | 0;
       if ((i3 | 0) == 31) {
        i3 = 0;
       } else {
        i3 = 25 - (i3 >>> 1) | 0;
       }
       L444 : do {
        if ((HEAP32[i4 + 4 >> 2] & -8 | 0) != (i10 | 0)) {
         i3 = i10 << i3;
         while (1) {
          i5 = i4 + (i3 >>> 31 << 2) + 16 | 0;
          i9 = HEAP32[i5 >> 2] | 0;
          if ((i9 | 0) == 0) {
           break;
          }
          if ((HEAP32[i9 + 4 >> 2] & -8 | 0) == (i10 | 0)) {
           i2 = i9;
           break L444;
          } else {
           i3 = i3 << 1;
           i4 = i9;
          }
         }
         if (i5 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
          _abort();
         } else {
          HEAP32[i5 >> 2] = i7;
          HEAP32[i17 + (i8 + 24) >> 2] = i4;
          HEAP32[i17 + (i8 + 12) >> 2] = i7;
          HEAP32[i17 + (i8 + 8) >> 2] = i7;
          break L348;
         }
        } else {
         i2 = i4;
        }
       } while (0);
       i4 = i2 + 8 | 0;
       i3 = HEAP32[i4 >> 2] | 0;
       i5 = HEAP32[7176 >> 2] | 0;
       if (i2 >>> 0 < i5 >>> 0) {
        _abort();
       }
       if (i3 >>> 0 < i5 >>> 0) {
        _abort();
       } else {
        HEAP32[i3 + 12 >> 2] = i7;
        HEAP32[i4 >> 2] = i7;
        HEAP32[i17 + (i8 + 8) >> 2] = i3;
        HEAP32[i17 + (i8 + 12) >> 2] = i2;
        HEAP32[i17 + (i8 + 24) >> 2] = 0;
        break;
       }
      } else {
       i32 = (HEAP32[7172 >> 2] | 0) + i10 | 0;
       HEAP32[7172 >> 2] = i32;
       HEAP32[7184 >> 2] = i7;
       HEAP32[i17 + (i8 + 4) >> 2] = i32 | 1;
      }
     } while (0);
     i32 = i17 + (i6 | 8) | 0;
     STACKTOP = i1;
     return i32 | 0;
    }
    i3 = 7608 | 0;
    while (1) {
     i2 = HEAP32[i3 >> 2] | 0;
     if (!(i2 >>> 0 > i15 >>> 0) ? (i11 = HEAP32[i3 + 4 >> 2] | 0, i10 = i2 + i11 | 0, i10 >>> 0 > i15 >>> 0) : 0) {
      break;
     }
     i3 = HEAP32[i3 + 8 >> 2] | 0;
    }
    i3 = i2 + (i11 + -39) | 0;
    if ((i3 & 7 | 0) == 0) {
     i3 = 0;
    } else {
     i3 = 0 - i3 & 7;
    }
    i2 = i2 + (i11 + -47 + i3) | 0;
    i2 = i2 >>> 0 < (i15 + 16 | 0) >>> 0 ? i15 : i2;
    i3 = i2 + 8 | 0;
    i4 = i17 + 8 | 0;
    if ((i4 & 7 | 0) == 0) {
     i4 = 0;
    } else {
     i4 = 0 - i4 & 7;
    }
    i32 = i14 + -40 - i4 | 0;
    HEAP32[7184 >> 2] = i17 + i4;
    HEAP32[7172 >> 2] = i32;
    HEAP32[i17 + (i4 + 4) >> 2] = i32 | 1;
    HEAP32[i17 + (i14 + -36) >> 2] = 40;
    HEAP32[7188 >> 2] = HEAP32[7648 >> 2];
    HEAP32[i2 + 4 >> 2] = 27;
    HEAP32[i3 + 0 >> 2] = HEAP32[7608 >> 2];
    HEAP32[i3 + 4 >> 2] = HEAP32[7612 >> 2];
    HEAP32[i3 + 8 >> 2] = HEAP32[7616 >> 2];
    HEAP32[i3 + 12 >> 2] = HEAP32[7620 >> 2];
    HEAP32[7608 >> 2] = i17;
    HEAP32[7612 >> 2] = i14;
    HEAP32[7620 >> 2] = 0;
    HEAP32[7616 >> 2] = i3;
    i4 = i2 + 28 | 0;
    HEAP32[i4 >> 2] = 7;
    if ((i2 + 32 | 0) >>> 0 < i10 >>> 0) {
     while (1) {
      i3 = i4 + 4 | 0;
      HEAP32[i3 >> 2] = 7;
      if ((i4 + 8 | 0) >>> 0 < i10 >>> 0) {
       i4 = i3;
      } else {
       break;
      }
     }
    }
    if ((i2 | 0) != (i15 | 0)) {
     i2 = i2 - i15 | 0;
     i3 = i15 + (i2 + 4) | 0;
     HEAP32[i3 >> 2] = HEAP32[i3 >> 2] & -2;
     HEAP32[i15 + 4 >> 2] = i2 | 1;
     HEAP32[i15 + i2 >> 2] = i2;
     i3 = i2 >>> 3;
     if (i2 >>> 0 < 256) {
      i4 = i3 << 1;
      i2 = 7200 + (i4 << 2) | 0;
      i5 = HEAP32[1790] | 0;
      i3 = 1 << i3;
      if ((i5 & i3 | 0) != 0) {
       i4 = 7200 + (i4 + 2 << 2) | 0;
       i3 = HEAP32[i4 >> 2] | 0;
       if (i3 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
        _abort();
       } else {
        i7 = i4;
        i8 = i3;
       }
      } else {
       HEAP32[1790] = i5 | i3;
       i7 = 7200 + (i4 + 2 << 2) | 0;
       i8 = i2;
      }
      HEAP32[i7 >> 2] = i15;
      HEAP32[i8 + 12 >> 2] = i15;
      HEAP32[i15 + 8 >> 2] = i8;
      HEAP32[i15 + 12 >> 2] = i2;
      break;
     }
     i3 = i2 >>> 8;
     if ((i3 | 0) != 0) {
      if (i2 >>> 0 > 16777215) {
       i3 = 31;
      } else {
       i31 = (i3 + 1048320 | 0) >>> 16 & 8;
       i32 = i3 << i31;
       i30 = (i32 + 520192 | 0) >>> 16 & 4;
       i32 = i32 << i30;
       i3 = (i32 + 245760 | 0) >>> 16 & 2;
       i3 = 14 - (i30 | i31 | i3) + (i32 << i3 >>> 15) | 0;
       i3 = i2 >>> (i3 + 7 | 0) & 1 | i3 << 1;
      }
     } else {
      i3 = 0;
     }
     i7 = 7464 + (i3 << 2) | 0;
     HEAP32[i15 + 28 >> 2] = i3;
     HEAP32[i15 + 20 >> 2] = 0;
     HEAP32[i15 + 16 >> 2] = 0;
     i4 = HEAP32[7164 >> 2] | 0;
     i5 = 1 << i3;
     if ((i4 & i5 | 0) == 0) {
      HEAP32[7164 >> 2] = i4 | i5;
      HEAP32[i7 >> 2] = i15;
      HEAP32[i15 + 24 >> 2] = i7;
      HEAP32[i15 + 12 >> 2] = i15;
      HEAP32[i15 + 8 >> 2] = i15;
      break;
     }
     i4 = HEAP32[i7 >> 2] | 0;
     if ((i3 | 0) == 31) {
      i3 = 0;
     } else {
      i3 = 25 - (i3 >>> 1) | 0;
     }
     L499 : do {
      if ((HEAP32[i4 + 4 >> 2] & -8 | 0) != (i2 | 0)) {
       i3 = i2 << i3;
       while (1) {
        i7 = i4 + (i3 >>> 31 << 2) + 16 | 0;
        i5 = HEAP32[i7 >> 2] | 0;
        if ((i5 | 0) == 0) {
         break;
        }
        if ((HEAP32[i5 + 4 >> 2] & -8 | 0) == (i2 | 0)) {
         i6 = i5;
         break L499;
        } else {
         i3 = i3 << 1;
         i4 = i5;
        }
       }
       if (i7 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
        _abort();
       } else {
        HEAP32[i7 >> 2] = i15;
        HEAP32[i15 + 24 >> 2] = i4;
        HEAP32[i15 + 12 >> 2] = i15;
        HEAP32[i15 + 8 >> 2] = i15;
        break L311;
       }
      } else {
       i6 = i4;
      }
     } while (0);
     i4 = i6 + 8 | 0;
     i3 = HEAP32[i4 >> 2] | 0;
     i2 = HEAP32[7176 >> 2] | 0;
     if (i6 >>> 0 < i2 >>> 0) {
      _abort();
     }
     if (i3 >>> 0 < i2 >>> 0) {
      _abort();
     } else {
      HEAP32[i3 + 12 >> 2] = i15;
      HEAP32[i4 >> 2] = i15;
      HEAP32[i15 + 8 >> 2] = i3;
      HEAP32[i15 + 12 >> 2] = i6;
      HEAP32[i15 + 24 >> 2] = 0;
      break;
     }
    }
   } else {
    i32 = HEAP32[7176 >> 2] | 0;
    if ((i32 | 0) == 0 | i17 >>> 0 < i32 >>> 0) {
     HEAP32[7176 >> 2] = i17;
    }
    HEAP32[7608 >> 2] = i17;
    HEAP32[7612 >> 2] = i14;
    HEAP32[7620 >> 2] = 0;
    HEAP32[7196 >> 2] = HEAP32[1908];
    HEAP32[7192 >> 2] = -1;
    i2 = 0;
    do {
     i32 = i2 << 1;
     i31 = 7200 + (i32 << 2) | 0;
     HEAP32[7200 + (i32 + 3 << 2) >> 2] = i31;
     HEAP32[7200 + (i32 + 2 << 2) >> 2] = i31;
     i2 = i2 + 1 | 0;
    } while ((i2 | 0) != 32);
    i2 = i17 + 8 | 0;
    if ((i2 & 7 | 0) == 0) {
     i2 = 0;
    } else {
     i2 = 0 - i2 & 7;
    }
    i32 = i14 + -40 - i2 | 0;
    HEAP32[7184 >> 2] = i17 + i2;
    HEAP32[7172 >> 2] = i32;
    HEAP32[i17 + (i2 + 4) >> 2] = i32 | 1;
    HEAP32[i17 + (i14 + -36) >> 2] = 40;
    HEAP32[7188 >> 2] = HEAP32[7648 >> 2];
   }
  } while (0);
  i2 = HEAP32[7172 >> 2] | 0;
  if (i2 >>> 0 > i12 >>> 0) {
   i31 = i2 - i12 | 0;
   HEAP32[7172 >> 2] = i31;
   i32 = HEAP32[7184 >> 2] | 0;
   HEAP32[7184 >> 2] = i32 + i12;
   HEAP32[i32 + (i12 + 4) >> 2] = i31 | 1;
   HEAP32[i32 + 4 >> 2] = i12 | 3;
   i32 = i32 + 8 | 0;
   STACKTOP = i1;
   return i32 | 0;
  }
 }
 HEAP32[(___errno_location() | 0) >> 2] = 12;
 i32 = 0;
 STACKTOP = i1;
 return i32 | 0;
}
function __ZN12b2EPCollider7CollideEP10b2ManifoldPK11b2EdgeShapeRK11b2TransformPK14b2PolygonShapeS7_(i12, i2, i16, i5, i8, i6) {
 i12 = i12 | 0;
 i2 = i2 | 0;
 i16 = i16 | 0;
 i5 = i5 | 0;
 i8 = i8 | 0;
 i6 = i6 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i7 = 0, i9 = 0, i10 = 0, i11 = 0, i13 = 0, i14 = 0, i15 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, d22 = 0.0, d23 = 0.0, d24 = 0.0, d25 = 0.0, d26 = 0.0, d27 = 0.0, d28 = 0.0, i29 = 0, d30 = 0.0, d31 = 0.0, d32 = 0.0, d33 = 0.0, i34 = 0, i35 = 0, d36 = 0.0, d37 = 0.0, i38 = 0, d39 = 0.0, i40 = 0, i41 = 0;
 i1 = STACKTOP;
 STACKTOP = STACKTOP + 144 | 0;
 i18 = i1 + 128 | 0;
 i11 = i1 + 24 | 0;
 i9 = i1 + 72 | 0;
 i10 = i1 + 48 | 0;
 i3 = i1;
 i4 = i12 + 132 | 0;
 d28 = +HEAPF32[i5 + 12 >> 2];
 d37 = +HEAPF32[i6 + 8 >> 2];
 d23 = +HEAPF32[i5 + 8 >> 2];
 d27 = +HEAPF32[i6 + 12 >> 2];
 d22 = d28 * d37 - d23 * d27;
 d27 = d37 * d23 + d28 * d27;
 d37 = +d22;
 d26 = +d27;
 d25 = +HEAPF32[i6 >> 2] - +HEAPF32[i5 >> 2];
 d36 = +HEAPF32[i6 + 4 >> 2] - +HEAPF32[i5 + 4 >> 2];
 d24 = d28 * d25 + d23 * d36;
 d25 = d28 * d36 - d23 * d25;
 d23 = +d24;
 d36 = +d25;
 i5 = i4;
 HEAPF32[i5 >> 2] = d23;
 HEAPF32[i5 + 4 >> 2] = d36;
 i5 = i12 + 140 | 0;
 HEAPF32[i5 >> 2] = d37;
 HEAPF32[i5 + 4 >> 2] = d26;
 i5 = i12 + 144 | 0;
 d26 = +HEAPF32[i8 + 12 >> 2];
 i7 = i12 + 140 | 0;
 d37 = +HEAPF32[i8 + 16 >> 2];
 d24 = d24 + (d27 * d26 - d22 * d37);
 i6 = i12 + 136 | 0;
 d25 = d26 * d22 + d27 * d37 + d25;
 d37 = +d24;
 d27 = +d25;
 i34 = i12 + 148 | 0;
 HEAPF32[i34 >> 2] = d37;
 HEAPF32[i34 + 4 >> 2] = d27;
 i34 = i16 + 28 | 0;
 i29 = HEAP32[i34 >> 2] | 0;
 i34 = HEAP32[i34 + 4 >> 2] | 0;
 i14 = i12 + 156 | 0;
 HEAP32[i14 >> 2] = i29;
 HEAP32[i14 + 4 >> 2] = i34;
 i14 = i12 + 164 | 0;
 i17 = i16 + 12 | 0;
 i40 = HEAP32[i17 >> 2] | 0;
 i17 = HEAP32[i17 + 4 >> 2] | 0;
 i13 = i14;
 HEAP32[i13 >> 2] = i40;
 HEAP32[i13 + 4 >> 2] = i17;
 i13 = i12 + 172 | 0;
 i20 = i16 + 20 | 0;
 i41 = HEAP32[i20 >> 2] | 0;
 i20 = HEAP32[i20 + 4 >> 2] | 0;
 i38 = i13;
 HEAP32[i38 >> 2] = i41;
 HEAP32[i38 + 4 >> 2] = i20;
 i38 = i16 + 36 | 0;
 i35 = HEAP32[i38 >> 2] | 0;
 i38 = HEAP32[i38 + 4 >> 2] | 0;
 i19 = i12 + 180 | 0;
 HEAP32[i19 >> 2] = i35;
 HEAP32[i19 + 4 >> 2] = i38;
 i19 = (HEAP8[i16 + 44 | 0] | 0) != 0;
 i21 = (HEAP8[i16 + 45 | 0] | 0) != 0;
 d27 = (HEAP32[tempDoublePtr >> 2] = i41, +HEAPF32[tempDoublePtr >> 2]);
 d37 = (HEAP32[tempDoublePtr >> 2] = i40, +HEAPF32[tempDoublePtr >> 2]);
 d22 = d27 - d37;
 d26 = (HEAP32[tempDoublePtr >> 2] = i20, +HEAPF32[tempDoublePtr >> 2]);
 i20 = i12 + 168 | 0;
 d36 = (HEAP32[tempDoublePtr >> 2] = i17, +HEAPF32[tempDoublePtr >> 2]);
 d23 = d26 - d36;
 d28 = +Math_sqrt(+(d22 * d22 + d23 * d23));
 d33 = (HEAP32[tempDoublePtr >> 2] = i29, +HEAPF32[tempDoublePtr >> 2]);
 d32 = (HEAP32[tempDoublePtr >> 2] = i34, +HEAPF32[tempDoublePtr >> 2]);
 d31 = (HEAP32[tempDoublePtr >> 2] = i35, +HEAPF32[tempDoublePtr >> 2]);
 d30 = (HEAP32[tempDoublePtr >> 2] = i38, +HEAPF32[tempDoublePtr >> 2]);
 if (!(d28 < 1.1920928955078125e-7)) {
  d39 = 1.0 / d28;
  d22 = d22 * d39;
  d23 = d23 * d39;
 }
 i16 = i12 + 196 | 0;
 d28 = -d22;
 HEAPF32[i16 >> 2] = d23;
 i17 = i12 + 200 | 0;
 HEAPF32[i17 >> 2] = d28;
 d28 = (d24 - d37) * d23 + (d25 - d36) * d28;
 if (i19) {
  d37 = d37 - d33;
  d36 = d36 - d32;
  d39 = +Math_sqrt(+(d37 * d37 + d36 * d36));
  if (!(d39 < 1.1920928955078125e-7)) {
   d39 = 1.0 / d39;
   d37 = d37 * d39;
   d36 = d36 * d39;
  }
  d39 = -d37;
  HEAPF32[i12 + 188 >> 2] = d36;
  HEAPF32[i12 + 192 >> 2] = d39;
  i29 = d23 * d37 - d22 * d36 >= 0.0;
  d32 = (d24 - d33) * d36 + (d25 - d32) * d39;
 } else {
  i29 = 0;
  d32 = 0.0;
 }
 L10 : do {
  if (!i21) {
   if (!i19) {
    i41 = d28 >= 0.0;
    HEAP8[i12 + 248 | 0] = i41 & 1;
    i19 = i12 + 212 | 0;
    if (i41) {
     i15 = 64;
     break;
    } else {
     i15 = 65;
     break;
    }
   }
   i19 = d32 >= 0.0;
   if (i29) {
    if (!i19) {
     i41 = d28 >= 0.0;
     HEAP8[i12 + 248 | 0] = i41 & 1;
     i19 = i12 + 212 | 0;
     if (!i41) {
      d37 = +-d23;
      d39 = +d22;
      i38 = i19;
      HEAPF32[i38 >> 2] = d37;
      HEAPF32[i38 + 4 >> 2] = d39;
      i38 = i16;
      i40 = HEAP32[i38 >> 2] | 0;
      i38 = HEAP32[i38 + 4 >> 2] | 0;
      i41 = i12 + 228 | 0;
      HEAP32[i41 >> 2] = i40;
      HEAP32[i41 + 4 >> 2] = i38;
      i41 = i12 + 236 | 0;
      HEAPF32[i41 >> 2] = -(HEAP32[tempDoublePtr >> 2] = i40, +HEAPF32[tempDoublePtr >> 2]);
      HEAPF32[i41 + 4 >> 2] = d39;
      break;
     }
    } else {
     HEAP8[i12 + 248 | 0] = 1;
     i19 = i12 + 212 | 0;
    }
    i41 = i16;
    i40 = HEAP32[i41 + 4 >> 2] | 0;
    i38 = i19;
    HEAP32[i38 >> 2] = HEAP32[i41 >> 2];
    HEAP32[i38 + 4 >> 2] = i40;
    i38 = i12 + 188 | 0;
    i40 = HEAP32[i38 + 4 >> 2] | 0;
    i41 = i12 + 228 | 0;
    HEAP32[i41 >> 2] = HEAP32[i38 >> 2];
    HEAP32[i41 + 4 >> 2] = i40;
    d37 = +-+HEAPF32[i16 >> 2];
    d39 = +-+HEAPF32[i17 >> 2];
    i41 = i12 + 236 | 0;
    HEAPF32[i41 >> 2] = d37;
    HEAPF32[i41 + 4 >> 2] = d39;
    break;
   } else {
    if (i19) {
     i41 = d28 >= 0.0;
     HEAP8[i12 + 248 | 0] = i41 & 1;
     i19 = i12 + 212 | 0;
     if (i41) {
      i38 = i16;
      i41 = HEAP32[i38 >> 2] | 0;
      i38 = HEAP32[i38 + 4 >> 2] | 0;
      i40 = i19;
      HEAP32[i40 >> 2] = i41;
      HEAP32[i40 + 4 >> 2] = i38;
      i40 = i12 + 228 | 0;
      HEAP32[i40 >> 2] = i41;
      HEAP32[i40 + 4 >> 2] = i38;
      d37 = +-(HEAP32[tempDoublePtr >> 2] = i41, +HEAPF32[tempDoublePtr >> 2]);
      d39 = +d22;
      i41 = i12 + 236 | 0;
      HEAPF32[i41 >> 2] = d37;
      HEAPF32[i41 + 4 >> 2] = d39;
      break;
     }
    } else {
     HEAP8[i12 + 248 | 0] = 0;
     i19 = i12 + 212 | 0;
    }
    d39 = +-d23;
    d37 = +d22;
    i38 = i19;
    HEAPF32[i38 >> 2] = d39;
    HEAPF32[i38 + 4 >> 2] = d37;
    i38 = i16;
    i40 = HEAP32[i38 + 4 >> 2] | 0;
    i41 = i12 + 228 | 0;
    HEAP32[i41 >> 2] = HEAP32[i38 >> 2];
    HEAP32[i41 + 4 >> 2] = i40;
    d37 = +-+HEAPF32[i12 + 188 >> 2];
    d39 = +-+HEAPF32[i12 + 192 >> 2];
    i41 = i12 + 236 | 0;
    HEAPF32[i41 >> 2] = d37;
    HEAPF32[i41 + 4 >> 2] = d39;
    break;
   }
  } else {
   d33 = d31 - d27;
   d31 = d30 - d26;
   d30 = +Math_sqrt(+(d33 * d33 + d31 * d31));
   if (d30 < 1.1920928955078125e-7) {
    d30 = d33;
   } else {
    d39 = 1.0 / d30;
    d30 = d33 * d39;
    d31 = d31 * d39;
   }
   d39 = -d30;
   i34 = i12 + 204 | 0;
   HEAPF32[i34 >> 2] = d31;
   i35 = i12 + 208 | 0;
   HEAPF32[i35 >> 2] = d39;
   i38 = d22 * d31 - d23 * d30 > 0.0;
   d24 = (d24 - d27) * d31 + (d25 - d26) * d39;
   if (!i19) {
    i19 = d28 >= 0.0;
    if (!i21) {
     HEAP8[i12 + 248 | 0] = i19 & 1;
     i15 = i12 + 212 | 0;
     if (i19) {
      i19 = i15;
      i15 = 64;
      break;
     } else {
      i19 = i15;
      i15 = 65;
      break;
     }
    }
    if (i38) {
     if (!i19) {
      i41 = d24 >= 0.0;
      HEAP8[i12 + 248 | 0] = i41 & 1;
      i19 = i12 + 212 | 0;
      if (!i41) {
       d37 = +-d23;
       d39 = +d22;
       i38 = i19;
       HEAPF32[i38 >> 2] = d37;
       HEAPF32[i38 + 4 >> 2] = d39;
       i38 = i12 + 228 | 0;
       HEAPF32[i38 >> 2] = d37;
       HEAPF32[i38 + 4 >> 2] = d39;
       i38 = i16;
       i40 = HEAP32[i38 + 4 >> 2] | 0;
       i41 = i12 + 236 | 0;
       HEAP32[i41 >> 2] = HEAP32[i38 >> 2];
       HEAP32[i41 + 4 >> 2] = i40;
       break;
      }
     } else {
      HEAP8[i12 + 248 | 0] = 1;
      i19 = i12 + 212 | 0;
     }
     i41 = i16;
     i40 = HEAP32[i41 + 4 >> 2] | 0;
     i38 = i19;
     HEAP32[i38 >> 2] = HEAP32[i41 >> 2];
     HEAP32[i38 + 4 >> 2] = i40;
     d37 = +-+HEAPF32[i16 >> 2];
     d39 = +-+HEAPF32[i17 >> 2];
     i38 = i12 + 228 | 0;
     HEAPF32[i38 >> 2] = d37;
     HEAPF32[i38 + 4 >> 2] = d39;
     i38 = i12 + 204 | 0;
     i40 = HEAP32[i38 + 4 >> 2] | 0;
     i41 = i12 + 236 | 0;
     HEAP32[i41 >> 2] = HEAP32[i38 >> 2];
     HEAP32[i41 + 4 >> 2] = i40;
     break;
    } else {
     if (i19) {
      i41 = d24 >= 0.0;
      HEAP8[i12 + 248 | 0] = i41 & 1;
      i19 = i12 + 212 | 0;
      if (i41) {
       i40 = i16;
       i38 = HEAP32[i40 >> 2] | 0;
       i40 = HEAP32[i40 + 4 >> 2] | 0;
       i41 = i19;
       HEAP32[i41 >> 2] = i38;
       HEAP32[i41 + 4 >> 2] = i40;
       d37 = +-(HEAP32[tempDoublePtr >> 2] = i38, +HEAPF32[tempDoublePtr >> 2]);
       d39 = +d22;
       i41 = i12 + 228 | 0;
       HEAPF32[i41 >> 2] = d37;
       HEAPF32[i41 + 4 >> 2] = d39;
       i41 = i12 + 236 | 0;
       HEAP32[i41 >> 2] = i38;
       HEAP32[i41 + 4 >> 2] = i40;
       break;
      }
     } else {
      HEAP8[i12 + 248 | 0] = 0;
      i19 = i12 + 212 | 0;
     }
     d39 = +-d23;
     d37 = +d22;
     i38 = i19;
     HEAPF32[i38 >> 2] = d39;
     HEAPF32[i38 + 4 >> 2] = d37;
     d37 = +-+HEAPF32[i12 + 204 >> 2];
     d39 = +-+HEAPF32[i12 + 208 >> 2];
     i38 = i12 + 228 | 0;
     HEAPF32[i38 >> 2] = d37;
     HEAPF32[i38 + 4 >> 2] = d39;
     i38 = i16;
     i40 = HEAP32[i38 + 4 >> 2] | 0;
     i41 = i12 + 236 | 0;
     HEAP32[i41 >> 2] = HEAP32[i38 >> 2];
     HEAP32[i41 + 4 >> 2] = i40;
     break;
    }
   }
   if (i29 & i38) {
    if (!(d32 >= 0.0) & !(d28 >= 0.0)) {
     i41 = d24 >= 0.0;
     HEAP8[i12 + 248 | 0] = i41 & 1;
     i19 = i12 + 212 | 0;
     if (!i41) {
      d37 = +-d23;
      d39 = +d22;
      i41 = i19;
      HEAPF32[i41 >> 2] = d37;
      HEAPF32[i41 + 4 >> 2] = d39;
      i41 = i12 + 228 | 0;
      HEAPF32[i41 >> 2] = d37;
      HEAPF32[i41 + 4 >> 2] = d39;
      i41 = i12 + 236 | 0;
      HEAPF32[i41 >> 2] = d37;
      HEAPF32[i41 + 4 >> 2] = d39;
      break;
     }
    } else {
     HEAP8[i12 + 248 | 0] = 1;
     i19 = i12 + 212 | 0;
    }
    i38 = i16;
    i40 = HEAP32[i38 + 4 >> 2] | 0;
    i41 = i19;
    HEAP32[i41 >> 2] = HEAP32[i38 >> 2];
    HEAP32[i41 + 4 >> 2] = i40;
    i41 = i12 + 188 | 0;
    i40 = HEAP32[i41 + 4 >> 2] | 0;
    i38 = i12 + 228 | 0;
    HEAP32[i38 >> 2] = HEAP32[i41 >> 2];
    HEAP32[i38 + 4 >> 2] = i40;
    i38 = i12 + 204 | 0;
    i40 = HEAP32[i38 + 4 >> 2] | 0;
    i41 = i12 + 236 | 0;
    HEAP32[i41 >> 2] = HEAP32[i38 >> 2];
    HEAP32[i41 + 4 >> 2] = i40;
    break;
   }
   if (i29) {
    do {
     if (!(d32 >= 0.0)) {
      if (d28 >= 0.0) {
       i41 = d24 >= 0.0;
       HEAP8[i12 + 248 | 0] = i41 & 1;
       i19 = i12 + 212 | 0;
       if (i41) {
        break;
       }
      } else {
       HEAP8[i12 + 248 | 0] = 0;
       i19 = i12 + 212 | 0;
      }
      d37 = +-d23;
      d39 = +d22;
      i41 = i19;
      HEAPF32[i41 >> 2] = d37;
      HEAPF32[i41 + 4 >> 2] = d39;
      d39 = +-+HEAPF32[i34 >> 2];
      d37 = +-+HEAPF32[i35 >> 2];
      i41 = i12 + 228 | 0;
      HEAPF32[i41 >> 2] = d39;
      HEAPF32[i41 + 4 >> 2] = d37;
      d37 = +-+HEAPF32[i16 >> 2];
      d39 = +-+HEAPF32[i17 >> 2];
      i41 = i12 + 236 | 0;
      HEAPF32[i41 >> 2] = d37;
      HEAPF32[i41 + 4 >> 2] = d39;
      break L10;
     } else {
      HEAP8[i12 + 248 | 0] = 1;
      i19 = i12 + 212 | 0;
     }
    } while (0);
    i38 = i16;
    i40 = HEAP32[i38 + 4 >> 2] | 0;
    i41 = i19;
    HEAP32[i41 >> 2] = HEAP32[i38 >> 2];
    HEAP32[i41 + 4 >> 2] = i40;
    i41 = i12 + 188 | 0;
    i40 = HEAP32[i41 + 4 >> 2] | 0;
    i38 = i12 + 228 | 0;
    HEAP32[i38 >> 2] = HEAP32[i41 >> 2];
    HEAP32[i38 + 4 >> 2] = i40;
    i38 = i16;
    i40 = HEAP32[i38 + 4 >> 2] | 0;
    i41 = i12 + 236 | 0;
    HEAP32[i41 >> 2] = HEAP32[i38 >> 2];
    HEAP32[i41 + 4 >> 2] = i40;
    break;
   }
   if (!i38) {
    if (!(!(d32 >= 0.0) | !(d28 >= 0.0))) {
     i41 = d24 >= 0.0;
     HEAP8[i12 + 248 | 0] = i41 & 1;
     i19 = i12 + 212 | 0;
     if (i41) {
      i40 = i16;
      i38 = HEAP32[i40 >> 2] | 0;
      i40 = HEAP32[i40 + 4 >> 2] | 0;
      i41 = i19;
      HEAP32[i41 >> 2] = i38;
      HEAP32[i41 + 4 >> 2] = i40;
      i41 = i12 + 228 | 0;
      HEAP32[i41 >> 2] = i38;
      HEAP32[i41 + 4 >> 2] = i40;
      i41 = i12 + 236 | 0;
      HEAP32[i41 >> 2] = i38;
      HEAP32[i41 + 4 >> 2] = i40;
      break;
     }
    } else {
     HEAP8[i12 + 248 | 0] = 0;
     i19 = i12 + 212 | 0;
    }
    d37 = +-d23;
    d39 = +d22;
    i41 = i19;
    HEAPF32[i41 >> 2] = d37;
    HEAPF32[i41 + 4 >> 2] = d39;
    d39 = +-+HEAPF32[i34 >> 2];
    d37 = +-+HEAPF32[i35 >> 2];
    i41 = i12 + 228 | 0;
    HEAPF32[i41 >> 2] = d39;
    HEAPF32[i41 + 4 >> 2] = d37;
    d37 = +-+HEAPF32[i12 + 188 >> 2];
    d39 = +-+HEAPF32[i12 + 192 >> 2];
    i41 = i12 + 236 | 0;
    HEAPF32[i41 >> 2] = d37;
    HEAPF32[i41 + 4 >> 2] = d39;
    break;
   }
   do {
    if (!(d24 >= 0.0)) {
     if (d32 >= 0.0) {
      i41 = d28 >= 0.0;
      HEAP8[i12 + 248 | 0] = i41 & 1;
      i19 = i12 + 212 | 0;
      if (i41) {
       break;
      }
     } else {
      HEAP8[i12 + 248 | 0] = 0;
      i19 = i12 + 212 | 0;
     }
     d37 = +-d23;
     d39 = +d22;
     i41 = i19;
     HEAPF32[i41 >> 2] = d37;
     HEAPF32[i41 + 4 >> 2] = d39;
     d39 = +-+HEAPF32[i16 >> 2];
     d37 = +-+HEAPF32[i17 >> 2];
     i41 = i12 + 228 | 0;
     HEAPF32[i41 >> 2] = d39;
     HEAPF32[i41 + 4 >> 2] = d37;
     d37 = +-+HEAPF32[i12 + 188 >> 2];
     d39 = +-+HEAPF32[i12 + 192 >> 2];
     i41 = i12 + 236 | 0;
     HEAPF32[i41 >> 2] = d37;
     HEAPF32[i41 + 4 >> 2] = d39;
     break L10;
    } else {
     HEAP8[i12 + 248 | 0] = 1;
     i19 = i12 + 212 | 0;
    }
   } while (0);
   i38 = i16;
   i40 = HEAP32[i38 + 4 >> 2] | 0;
   i41 = i19;
   HEAP32[i41 >> 2] = HEAP32[i38 >> 2];
   HEAP32[i41 + 4 >> 2] = i40;
   i41 = i16;
   i40 = HEAP32[i41 + 4 >> 2] | 0;
   i38 = i12 + 228 | 0;
   HEAP32[i38 >> 2] = HEAP32[i41 >> 2];
   HEAP32[i38 + 4 >> 2] = i40;
   i38 = i12 + 204 | 0;
   i40 = HEAP32[i38 + 4 >> 2] | 0;
   i41 = i12 + 236 | 0;
   HEAP32[i41 >> 2] = HEAP32[i38 >> 2];
   HEAP32[i41 + 4 >> 2] = i40;
  }
 } while (0);
 if ((i15 | 0) == 64) {
  i38 = i16;
  i41 = HEAP32[i38 >> 2] | 0;
  i38 = HEAP32[i38 + 4 >> 2] | 0;
  i40 = i19;
  HEAP32[i40 >> 2] = i41;
  HEAP32[i40 + 4 >> 2] = i38;
  d37 = +-(HEAP32[tempDoublePtr >> 2] = i41, +HEAPF32[tempDoublePtr >> 2]);
  d39 = +d22;
  i41 = i12 + 228 | 0;
  HEAPF32[i41 >> 2] = d37;
  HEAPF32[i41 + 4 >> 2] = d39;
  i41 = i12 + 236 | 0;
  HEAPF32[i41 >> 2] = d37;
  HEAPF32[i41 + 4 >> 2] = d39;
 } else if ((i15 | 0) == 65) {
  d37 = +-d23;
  d39 = +d22;
  i40 = i19;
  HEAPF32[i40 >> 2] = d37;
  HEAPF32[i40 + 4 >> 2] = d39;
  i40 = i16;
  i38 = HEAP32[i40 >> 2] | 0;
  i40 = HEAP32[i40 + 4 >> 2] | 0;
  i41 = i12 + 228 | 0;
  HEAP32[i41 >> 2] = i38;
  HEAP32[i41 + 4 >> 2] = i40;
  i41 = i12 + 236 | 0;
  HEAP32[i41 >> 2] = i38;
  HEAP32[i41 + 4 >> 2] = i40;
 }
 i21 = i8 + 148 | 0;
 i34 = i12 + 128 | 0;
 HEAP32[i34 >> 2] = HEAP32[i21 >> 2];
 if ((HEAP32[i21 >> 2] | 0) > 0) {
  i19 = 0;
  do {
   d33 = +HEAPF32[i5 >> 2];
   d37 = +HEAPF32[i8 + (i19 << 3) + 20 >> 2];
   d39 = +HEAPF32[i7 >> 2];
   d36 = +HEAPF32[i8 + (i19 << 3) + 24 >> 2];
   d32 = +(+HEAPF32[i4 >> 2] + (d33 * d37 - d39 * d36));
   d36 = +(d37 * d39 + d33 * d36 + +HEAPF32[i6 >> 2]);
   i41 = i12 + (i19 << 3) | 0;
   HEAPF32[i41 >> 2] = d32;
   HEAPF32[i41 + 4 >> 2] = d36;
   d36 = +HEAPF32[i5 >> 2];
   d32 = +HEAPF32[i8 + (i19 << 3) + 84 >> 2];
   d33 = +HEAPF32[i7 >> 2];
   d39 = +HEAPF32[i8 + (i19 << 3) + 88 >> 2];
   d37 = +(d36 * d32 - d33 * d39);
   d39 = +(d32 * d33 + d36 * d39);
   i41 = i12 + (i19 << 3) + 64 | 0;
   HEAPF32[i41 >> 2] = d37;
   HEAPF32[i41 + 4 >> 2] = d39;
   i19 = i19 + 1 | 0;
  } while ((i19 | 0) < (HEAP32[i21 >> 2] | 0));
 }
 i21 = i12 + 244 | 0;
 HEAPF32[i21 >> 2] = .019999999552965164;
 i19 = i2 + 60 | 0;
 HEAP32[i19 >> 2] = 0;
 i29 = i12 + 248 | 0;
 i35 = HEAP32[i34 >> 2] | 0;
 if ((i35 | 0) <= 0) {
  STACKTOP = i1;
  return;
 }
 d23 = +HEAPF32[i12 + 164 >> 2];
 d26 = +HEAPF32[i20 >> 2];
 d24 = +HEAPF32[i12 + 212 >> 2];
 d27 = +HEAPF32[i12 + 216 >> 2];
 d22 = 3.4028234663852886e+38;
 i20 = 0;
 do {
  d25 = d24 * (+HEAPF32[i12 + (i20 << 3) >> 2] - d23) + d27 * (+HEAPF32[i12 + (i20 << 3) + 4 >> 2] - d26);
  d22 = d25 < d22 ? d25 : d22;
  i20 = i20 + 1 | 0;
 } while ((i20 | 0) != (i35 | 0));
 if (d22 > .019999999552965164) {
  STACKTOP = i1;
  return;
 }
 __ZN12b2EPCollider24ComputePolygonSeparationEv(i18, i12);
 i20 = HEAP32[i18 >> 2] | 0;
 if ((i20 | 0) != 0) {
  d23 = +HEAPF32[i18 + 8 >> 2];
  if (d23 > +HEAPF32[i21 >> 2]) {
   STACKTOP = i1;
   return;
  }
  if (d23 > d22 * .9800000190734863 + .0010000000474974513) {
   i18 = HEAP32[i18 + 4 >> 2] | 0;
   i35 = i2 + 56 | 0;
   if ((i20 | 0) == 1) {
    i18 = i11;
    i15 = 77;
   } else {
    HEAP32[i35 >> 2] = 2;
    i40 = i14;
    i41 = HEAP32[i40 + 4 >> 2] | 0;
    i38 = i11;
    HEAP32[i38 >> 2] = HEAP32[i40 >> 2];
    HEAP32[i38 + 4 >> 2] = i41;
    i38 = i11 + 8 | 0;
    HEAP8[i38] = 0;
    i41 = i18 & 255;
    HEAP8[i38 + 1 | 0] = i41;
    HEAP8[i38 + 2 | 0] = 0;
    HEAP8[i38 + 3 | 0] = 1;
    i38 = i13;
    i40 = HEAP32[i38 + 4 >> 2] | 0;
    i13 = i11 + 12 | 0;
    HEAP32[i13 >> 2] = HEAP32[i38 >> 2];
    HEAP32[i13 + 4 >> 2] = i40;
    i13 = i11 + 20 | 0;
    HEAP8[i13] = 0;
    HEAP8[i13 + 1 | 0] = i41;
    HEAP8[i13 + 2 | 0] = 0;
    HEAP8[i13 + 3 | 0] = 1;
    HEAP32[i9 >> 2] = i18;
    i13 = i18 + 1 | 0;
    i16 = (i13 | 0) < (HEAP32[i34 >> 2] | 0) ? i13 : 0;
    HEAP32[i9 + 4 >> 2] = i16;
    i17 = i12 + (i18 << 3) | 0;
    i13 = HEAP32[i17 >> 2] | 0;
    i17 = HEAP32[i17 + 4 >> 2] | 0;
    i29 = i9 + 8 | 0;
    HEAP32[i29 >> 2] = i13;
    HEAP32[i29 + 4 >> 2] = i17;
    i16 = i12 + (i16 << 3) | 0;
    i29 = HEAP32[i16 >> 2] | 0;
    i16 = HEAP32[i16 + 4 >> 2] | 0;
    i20 = i9 + 16 | 0;
    HEAP32[i20 >> 2] = i29;
    HEAP32[i20 + 4 >> 2] = i16;
    i20 = i12 + (i18 << 3) + 64 | 0;
    i12 = HEAP32[i20 >> 2] | 0;
    i20 = HEAP32[i20 + 4 >> 2] | 0;
    i14 = i9 + 24 | 0;
    HEAP32[i14 >> 2] = i12;
    HEAP32[i14 + 4 >> 2] = i20;
    i14 = 0;
   }
  } else {
   i15 = 75;
  }
 } else {
  i15 = 75;
 }
 if ((i15 | 0) == 75) {
  i18 = i11;
  i35 = i2 + 56 | 0;
  i15 = 77;
 }
 do {
  if ((i15 | 0) == 77) {
   HEAP32[i35 >> 2] = 1;
   i15 = HEAP32[i34 >> 2] | 0;
   if ((i15 | 0) > 1) {
    d23 = +HEAPF32[i12 + 216 >> 2];
    d22 = +HEAPF32[i12 + 212 >> 2];
    i34 = 0;
    d24 = d22 * +HEAPF32[i12 + 64 >> 2] + d23 * +HEAPF32[i12 + 68 >> 2];
    i35 = 1;
    while (1) {
     d25 = d22 * +HEAPF32[i12 + (i35 << 3) + 64 >> 2] + d23 * +HEAPF32[i12 + (i35 << 3) + 68 >> 2];
     i20 = d25 < d24;
     i34 = i20 ? i35 : i34;
     i35 = i35 + 1 | 0;
     if ((i35 | 0) < (i15 | 0)) {
      d24 = i20 ? d25 : d24;
     } else {
      break;
     }
    }
   } else {
    i34 = 0;
   }
   i20 = i34 + 1 | 0;
   i40 = (i20 | 0) < (i15 | 0) ? i20 : 0;
   i41 = i12 + (i34 << 3) | 0;
   i38 = HEAP32[i41 + 4 >> 2] | 0;
   i35 = i11;
   HEAP32[i35 >> 2] = HEAP32[i41 >> 2];
   HEAP32[i35 + 4 >> 2] = i38;
   i35 = i11 + 8 | 0;
   HEAP8[i35] = 0;
   HEAP8[i35 + 1 | 0] = i34;
   HEAP8[i35 + 2 | 0] = 1;
   HEAP8[i35 + 3 | 0] = 0;
   i35 = i12 + (i40 << 3) | 0;
   i38 = HEAP32[i35 + 4 >> 2] | 0;
   i41 = i11 + 12 | 0;
   HEAP32[i41 >> 2] = HEAP32[i35 >> 2];
   HEAP32[i41 + 4 >> 2] = i38;
   i41 = i11 + 20 | 0;
   HEAP8[i41] = 0;
   HEAP8[i41 + 1 | 0] = i40;
   HEAP8[i41 + 2 | 0] = 1;
   HEAP8[i41 + 3 | 0] = 0;
   if ((HEAP8[i29] | 0) == 0) {
    HEAP32[i9 >> 2] = 1;
    HEAP32[i9 + 4 >> 2] = 0;
    i11 = i13;
    i13 = HEAP32[i11 >> 2] | 0;
    i11 = HEAP32[i11 + 4 >> 2] | 0;
    i29 = i9 + 8 | 0;
    HEAP32[i29 >> 2] = i13;
    HEAP32[i29 + 4 >> 2] = i11;
    i29 = HEAP32[i14 >> 2] | 0;
    i14 = HEAP32[i14 + 4 >> 2] | 0;
    i12 = i9 + 16 | 0;
    HEAP32[i12 >> 2] = i29;
    HEAP32[i12 + 4 >> 2] = i14;
    i12 = (HEAPF32[tempDoublePtr >> 2] = -+HEAPF32[i16 >> 2], HEAP32[tempDoublePtr >> 2] | 0);
    i20 = (HEAPF32[tempDoublePtr >> 2] = -+HEAPF32[i17 >> 2], HEAP32[tempDoublePtr >> 2] | 0);
    i16 = i9 + 24 | 0;
    HEAP32[i16 >> 2] = i12;
    HEAP32[i16 + 4 >> 2] = i20;
    i16 = i14;
    i17 = i11;
    i11 = i18;
    i18 = 1;
    i14 = 1;
    break;
   } else {
    HEAP32[i9 >> 2] = 0;
    HEAP32[i9 + 4 >> 2] = 1;
    i17 = i14;
    i11 = HEAP32[i17 >> 2] | 0;
    i17 = HEAP32[i17 + 4 >> 2] | 0;
    i29 = i9 + 8 | 0;
    HEAP32[i29 >> 2] = i11;
    HEAP32[i29 + 4 >> 2] = i17;
    i29 = HEAP32[i13 >> 2] | 0;
    i13 = HEAP32[i13 + 4 >> 2] | 0;
    i20 = i9 + 16 | 0;
    HEAP32[i20 >> 2] = i29;
    HEAP32[i20 + 4 >> 2] = i13;
    i20 = i16;
    i12 = HEAP32[i20 >> 2] | 0;
    i20 = HEAP32[i20 + 4 >> 2] | 0;
    i16 = i9 + 24 | 0;
    HEAP32[i16 >> 2] = i12;
    HEAP32[i16 + 4 >> 2] = i20;
    i16 = i13;
    i13 = i11;
    i11 = i18;
    i18 = 0;
    i14 = 1;
    break;
   }
  }
 } while (0);
 d30 = (HEAP32[tempDoublePtr >> 2] = i20, +HEAPF32[tempDoublePtr >> 2]);
 d39 = (HEAP32[tempDoublePtr >> 2] = i12, +HEAPF32[tempDoublePtr >> 2]);
 d31 = (HEAP32[tempDoublePtr >> 2] = i13, +HEAPF32[tempDoublePtr >> 2]);
 d32 = (HEAP32[tempDoublePtr >> 2] = i17, +HEAPF32[tempDoublePtr >> 2]);
 d33 = (HEAP32[tempDoublePtr >> 2] = i29, +HEAPF32[tempDoublePtr >> 2]);
 d37 = (HEAP32[tempDoublePtr >> 2] = i16, +HEAPF32[tempDoublePtr >> 2]);
 i41 = i9 + 32 | 0;
 i16 = i9 + 24 | 0;
 i13 = i9 + 28 | 0;
 d39 = -d39;
 HEAPF32[i41 >> 2] = d30;
 HEAPF32[i9 + 36 >> 2] = d39;
 i20 = i9 + 44 | 0;
 d36 = -d30;
 i17 = i20;
 HEAPF32[i17 >> 2] = d36;
 HEAP32[i17 + 4 >> 2] = i12;
 i17 = i9 + 8 | 0;
 i15 = i9 + 12 | 0;
 d39 = d30 * d31 + d32 * d39;
 HEAPF32[i9 + 40 >> 2] = d39;
 i29 = i9 + 52 | 0;
 HEAPF32[i29 >> 2] = d33 * d36 + (HEAP32[tempDoublePtr >> 2] = i12, +HEAPF32[tempDoublePtr >> 2]) * d37;
 if ((__Z19b2ClipSegmentToLineP12b2ClipVertexPKS_RK6b2Vec2fi(i10, i11, i41, d39, i18) | 0) < 2) {
  STACKTOP = i1;
  return;
 }
 if ((__Z19b2ClipSegmentToLineP12b2ClipVertexPKS_RK6b2Vec2fi(i3, i10, i20, +HEAPF32[i29 >> 2], HEAP32[i9 + 4 >> 2] | 0) | 0) < 2) {
  STACKTOP = i1;
  return;
 }
 i10 = i2 + 40 | 0;
 if (i14) {
  i40 = i16;
  i41 = HEAP32[i40 >> 2] | 0;
  i40 = HEAP32[i40 + 4 >> 2] | 0;
  i35 = i10;
  HEAP32[i35 >> 2] = i41;
  HEAP32[i35 + 4 >> 2] = i40;
  i35 = i17;
  i40 = HEAP32[i35 >> 2] | 0;
  i35 = HEAP32[i35 + 4 >> 2] | 0;
  i38 = i2 + 48 | 0;
  HEAP32[i38 >> 2] = i40;
  HEAP32[i38 + 4 >> 2] = i35;
  d23 = (HEAP32[tempDoublePtr >> 2] = i40, +HEAPF32[tempDoublePtr >> 2]);
  d22 = (HEAP32[tempDoublePtr >> 2] = i41, +HEAPF32[tempDoublePtr >> 2]);
  d24 = +HEAPF32[i15 >> 2];
  d25 = +HEAPF32[i13 >> 2];
  d28 = +HEAPF32[i3 >> 2];
  d27 = +HEAPF32[i3 + 4 >> 2];
  d26 = +HEAPF32[i21 >> 2];
  if (!((d28 - d23) * d22 + (d27 - d24) * d25 <= d26)) {
   d28 = d26;
   i8 = 0;
  } else {
   d37 = d28 - +HEAPF32[i4 >> 2];
   d36 = d27 - +HEAPF32[i6 >> 2];
   d33 = +HEAPF32[i5 >> 2];
   d28 = +HEAPF32[i7 >> 2];
   d39 = +(d37 * d33 + d36 * d28);
   d28 = +(d33 * d36 - d37 * d28);
   i8 = i2;
   HEAPF32[i8 >> 2] = d39;
   HEAPF32[i8 + 4 >> 2] = d28;
   HEAP32[i2 + 16 >> 2] = HEAP32[i3 + 8 >> 2];
   d28 = +HEAPF32[i21 >> 2];
   i8 = 1;
  }
  d26 = +HEAPF32[i3 + 12 >> 2];
  d27 = +HEAPF32[i3 + 16 >> 2];
  if ((d26 - d23) * d22 + (d27 - d24) * d25 <= d28) {
   d36 = d26 - +HEAPF32[i4 >> 2];
   d33 = d27 - +HEAPF32[i6 >> 2];
   d32 = +HEAPF32[i5 >> 2];
   d39 = +HEAPF32[i7 >> 2];
   d37 = +(d36 * d32 + d33 * d39);
   d39 = +(d32 * d33 - d36 * d39);
   i41 = i2 + (i8 * 20 | 0) | 0;
   HEAPF32[i41 >> 2] = d37;
   HEAPF32[i41 + 4 >> 2] = d39;
   HEAP32[i2 + (i8 * 20 | 0) + 16 >> 2] = HEAP32[i3 + 20 >> 2];
   i8 = i8 + 1 | 0;
  }
 } else {
  i38 = HEAP32[i9 >> 2] | 0;
  i35 = i8 + (i38 << 3) + 84 | 0;
  i41 = HEAP32[i35 + 4 >> 2] | 0;
  i40 = i10;
  HEAP32[i40 >> 2] = HEAP32[i35 >> 2];
  HEAP32[i40 + 4 >> 2] = i41;
  i38 = i8 + (i38 << 3) + 20 | 0;
  i40 = HEAP32[i38 + 4 >> 2] | 0;
  i41 = i2 + 48 | 0;
  HEAP32[i41 >> 2] = HEAP32[i38 >> 2];
  HEAP32[i41 + 4 >> 2] = i40;
  d22 = +HEAPF32[i17 >> 2];
  d23 = +HEAPF32[i16 >> 2];
  d24 = +HEAPF32[i15 >> 2];
  d25 = +HEAPF32[i13 >> 2];
  d26 = +HEAPF32[i21 >> 2];
  if (!((+HEAPF32[i3 >> 2] - d22) * d23 + (+HEAPF32[i3 + 4 >> 2] - d24) * d25 <= d26)) {
   i8 = 0;
  } else {
   i40 = i3;
   i8 = HEAP32[i40 + 4 >> 2] | 0;
   i41 = i2;
   HEAP32[i41 >> 2] = HEAP32[i40 >> 2];
   HEAP32[i41 + 4 >> 2] = i8;
   i41 = i3 + 8 | 0;
   i8 = i2 + 16 | 0;
   HEAP8[i8 + 2 | 0] = HEAP8[i41 + 3 | 0] | 0;
   HEAP8[i8 + 3 | 0] = HEAP8[i41 + 2 | 0] | 0;
   HEAP8[i8] = HEAP8[i41 + 1 | 0] | 0;
   HEAP8[i8 + 1 | 0] = HEAP8[i41] | 0;
   d26 = +HEAPF32[i21 >> 2];
   i8 = 1;
  }
  i4 = i3 + 12 | 0;
  if ((+HEAPF32[i4 >> 2] - d22) * d23 + (+HEAPF32[i3 + 16 >> 2] - d24) * d25 <= d26) {
   i38 = i4;
   i41 = HEAP32[i38 + 4 >> 2] | 0;
   i40 = i2 + (i8 * 20 | 0) | 0;
   HEAP32[i40 >> 2] = HEAP32[i38 >> 2];
   HEAP32[i40 + 4 >> 2] = i41;
   i40 = i3 + 20 | 0;
   i41 = i2 + (i8 * 20 | 0) + 16 | 0;
   HEAP8[i41 + 2 | 0] = HEAP8[i40 + 3 | 0] | 0;
   HEAP8[i41 + 3 | 0] = HEAP8[i40 + 2 | 0] | 0;
   HEAP8[i41] = HEAP8[i40 + 1 | 0] | 0;
   HEAP8[i41 + 1 | 0] = HEAP8[i40] | 0;
   i8 = i8 + 1 | 0;
  }
 }
 HEAP32[i19 >> 2] = i8;
 STACKTOP = i1;
 return;
}
function __ZN7b2World8SolveTOIERK10b2TimeStep(i30, i11) {
 i30 = i30 | 0;
 i11 = i11 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0, i38 = 0, i39 = 0, i40 = 0, i41 = 0, d42 = 0.0, i43 = 0, i44 = 0, i45 = 0, i46 = 0, i47 = 0, i48 = 0, i49 = 0, i50 = 0, i51 = 0, i52 = 0, i53 = 0, i54 = 0, i55 = 0, i56 = 0, i57 = 0, i58 = 0, i59 = 0, i60 = 0, i61 = 0, i62 = 0, i63 = 0, i64 = 0, i65 = 0, i66 = 0, d67 = 0.0, d68 = 0.0, d69 = 0.0, d70 = 0.0, d71 = 0.0, d72 = 0.0;
 i1 = STACKTOP;
 STACKTOP = STACKTOP + 336 | 0;
 i3 = i1 + 284 | 0;
 i6 = i1 + 152 | 0;
 i5 = i1 + 144 | 0;
 i4 = i1 + 108 | 0;
 i8 = i1 + 72 | 0;
 i7 = i1 + 64 | 0;
 i14 = i1 + 24 | 0;
 i9 = i1;
 i10 = i30 + 102872 | 0;
 i13 = i30 + 102944 | 0;
 __ZN8b2IslandC2EiiiP16b2StackAllocatorP17b2ContactListener(i3, 64, 32, 0, i30 + 68 | 0, HEAP32[i13 >> 2] | 0);
 i2 = i30 + 102995 | 0;
 if ((HEAP8[i2] | 0) != 0) {
  i15 = HEAP32[i30 + 102952 >> 2] | 0;
  if ((i15 | 0) != 0) {
   do {
    i66 = i15 + 4 | 0;
    HEAP16[i66 >> 1] = HEAP16[i66 >> 1] & 65534;
    HEAPF32[i15 + 60 >> 2] = 0.0;
    i15 = HEAP32[i15 + 96 >> 2] | 0;
   } while ((i15 | 0) != 0);
  }
  i15 = i30 + 102932 | 0;
  i16 = HEAP32[i15 >> 2] | 0;
  if ((i16 | 0) != 0) {
   do {
    i66 = i16 + 4 | 0;
    HEAP32[i66 >> 2] = HEAP32[i66 >> 2] & -34;
    HEAP32[i16 + 128 >> 2] = 0;
    HEAPF32[i16 + 132 >> 2] = 1.0;
    i16 = HEAP32[i16 + 12 >> 2] | 0;
   } while ((i16 | 0) != 0);
  }
 } else {
  i15 = i30 + 102932 | 0;
 }
 i25 = i3 + 28 | 0;
 i26 = i3 + 36 | 0;
 i27 = i3 + 32 | 0;
 i28 = i3 + 40 | 0;
 i29 = i3 + 8 | 0;
 i24 = i3 + 44 | 0;
 i23 = i3 + 12 | 0;
 i22 = i7 + 4 | 0;
 i21 = i9 + 4 | 0;
 i20 = i9 + 8 | 0;
 i19 = i9 + 16 | 0;
 i18 = i11 + 12 | 0;
 i17 = i9 + 12 | 0;
 i16 = i9 + 20 | 0;
 i39 = i30 + 102994 | 0;
 i37 = i6 + 16 | 0;
 i36 = i6 + 20 | 0;
 i35 = i6 + 24 | 0;
 i34 = i6 + 44 | 0;
 i33 = i6 + 48 | 0;
 i32 = i6 + 52 | 0;
 i41 = i6 + 28 | 0;
 i31 = i6 + 56 | 0;
 i40 = i6 + 92 | 0;
 i30 = i6 + 128 | 0;
 i38 = i5 + 4 | 0;
 L11 : while (1) {
  i47 = HEAP32[i15 >> 2] | 0;
  if ((i47 | 0) == 0) {
   i4 = 36;
   break;
  } else {
   d42 = 1.0;
   i44 = 0;
  }
  do {
   i48 = i47 + 4 | 0;
   i43 = HEAP32[i48 >> 2] | 0;
   do {
    if ((i43 & 4 | 0) != 0 ? (HEAP32[i47 + 128 >> 2] | 0) <= 8 : 0) {
     if ((i43 & 32 | 0) == 0) {
      i43 = HEAP32[i47 + 48 >> 2] | 0;
      i45 = HEAP32[i47 + 52 >> 2] | 0;
      if ((HEAP8[i43 + 38 | 0] | 0) != 0) {
       break;
      }
      if ((HEAP8[i45 + 38 | 0] | 0) != 0) {
       break;
      }
      i46 = HEAP32[i43 + 8 >> 2] | 0;
      i50 = HEAP32[i45 + 8 >> 2] | 0;
      i53 = HEAP32[i46 >> 2] | 0;
      i52 = HEAP32[i50 >> 2] | 0;
      if (!((i53 | 0) == 2 | (i52 | 0) == 2)) {
       i4 = 16;
       break L11;
      }
      i51 = HEAP16[i46 + 4 >> 1] | 0;
      i49 = HEAP16[i50 + 4 >> 1] | 0;
      if (!((i51 & 2) != 0 & (i53 | 0) != 0 | (i49 & 2) != 0 & (i52 | 0) != 0)) {
       break;
      }
      if (!((i51 & 8) != 0 | (i53 | 0) != 2 | ((i49 & 8) != 0 | (i52 | 0) != 2))) {
       break;
      }
      i51 = i46 + 28 | 0;
      i52 = i46 + 60 | 0;
      d68 = +HEAPF32[i52 >> 2];
      i49 = i50 + 28 | 0;
      i53 = i50 + 60 | 0;
      d67 = +HEAPF32[i53 >> 2];
      if (!(d68 < d67)) {
       if (d67 < d68) {
        if (!(d67 < 1.0)) {
         i4 = 25;
         break L11;
        }
        d67 = (d68 - d67) / (1.0 - d67);
        i66 = i50 + 36 | 0;
        d69 = 1.0 - d67;
        d71 = +(+HEAPF32[i66 >> 2] * d69 + d67 * +HEAPF32[i50 + 44 >> 2]);
        d70 = +(d69 * +HEAPF32[i50 + 40 >> 2] + d67 * +HEAPF32[i50 + 48 >> 2]);
        HEAPF32[i66 >> 2] = d71;
        HEAPF32[i66 + 4 >> 2] = d70;
        i66 = i50 + 52 | 0;
        HEAPF32[i66 >> 2] = d69 * +HEAPF32[i66 >> 2] + d67 * +HEAPF32[i50 + 56 >> 2];
        HEAPF32[i53 >> 2] = d68;
        d67 = d68;
       } else {
        d67 = d68;
       }
      } else {
       if (!(d68 < 1.0)) {
        i4 = 21;
        break L11;
       }
       d71 = (d67 - d68) / (1.0 - d68);
       i66 = i46 + 36 | 0;
       d70 = 1.0 - d71;
       d68 = +(+HEAPF32[i66 >> 2] * d70 + d71 * +HEAPF32[i46 + 44 >> 2]);
       d69 = +(d70 * +HEAPF32[i46 + 40 >> 2] + d71 * +HEAPF32[i46 + 48 >> 2]);
       HEAPF32[i66 >> 2] = d68;
       HEAPF32[i66 + 4 >> 2] = d69;
       i66 = i46 + 52 | 0;
       HEAPF32[i66 >> 2] = d70 * +HEAPF32[i66 >> 2] + d71 * +HEAPF32[i46 + 56 >> 2];
       HEAPF32[i52 >> 2] = d67;
      }
      if (!(d67 < 1.0)) {
       i4 = 28;
       break L11;
      }
      i66 = HEAP32[i47 + 56 >> 2] | 0;
      i46 = HEAP32[i47 + 60 >> 2] | 0;
      HEAP32[i37 >> 2] = 0;
      HEAP32[i36 >> 2] = 0;
      HEAPF32[i35 >> 2] = 0.0;
      HEAP32[i34 >> 2] = 0;
      HEAP32[i33 >> 2] = 0;
      HEAPF32[i32 >> 2] = 0.0;
      __ZN15b2DistanceProxy3SetEPK7b2Shapei(i6, HEAP32[i43 + 12 >> 2] | 0, i66);
      __ZN15b2DistanceProxy3SetEPK7b2Shapei(i41, HEAP32[i45 + 12 >> 2] | 0, i46);
      i43 = i31 + 0 | 0;
      i45 = i51 + 0 | 0;
      i46 = i43 + 36 | 0;
      do {
       HEAP32[i43 >> 2] = HEAP32[i45 >> 2];
       i43 = i43 + 4 | 0;
       i45 = i45 + 4 | 0;
      } while ((i43 | 0) < (i46 | 0));
      i43 = i40 + 0 | 0;
      i45 = i49 + 0 | 0;
      i46 = i43 + 36 | 0;
      do {
       HEAP32[i43 >> 2] = HEAP32[i45 >> 2];
       i43 = i43 + 4 | 0;
       i45 = i45 + 4 | 0;
      } while ((i43 | 0) < (i46 | 0));
      HEAPF32[i30 >> 2] = 1.0;
      __Z14b2TimeOfImpactP11b2TOIOutputPK10b2TOIInput(i5, i6);
      if ((HEAP32[i5 >> 2] | 0) == 3) {
       d67 = d67 + (1.0 - d67) * +HEAPF32[i38 >> 2];
       d67 = d67 < 1.0 ? d67 : 1.0;
      } else {
       d67 = 1.0;
      }
      HEAPF32[i47 + 132 >> 2] = d67;
      HEAP32[i48 >> 2] = HEAP32[i48 >> 2] | 32;
     } else {
      d67 = +HEAPF32[i47 + 132 >> 2];
     }
     if (d67 < d42) {
      d42 = d67;
      i44 = i47;
     }
    }
   } while (0);
   i47 = HEAP32[i47 + 12 >> 2] | 0;
  } while ((i47 | 0) != 0);
  if ((i44 | 0) == 0 | d42 > .9999988079071045) {
   i4 = 36;
   break;
  }
  i47 = HEAP32[(HEAP32[i44 + 48 >> 2] | 0) + 8 >> 2] | 0;
  i48 = HEAP32[(HEAP32[i44 + 52 >> 2] | 0) + 8 >> 2] | 0;
  i49 = i47 + 28 | 0;
  i43 = i4 + 0 | 0;
  i45 = i49 + 0 | 0;
  i46 = i43 + 36 | 0;
  do {
   HEAP32[i43 >> 2] = HEAP32[i45 >> 2];
   i43 = i43 + 4 | 0;
   i45 = i45 + 4 | 0;
  } while ((i43 | 0) < (i46 | 0));
  i50 = i48 + 28 | 0;
  i43 = i8 + 0 | 0;
  i45 = i50 + 0 | 0;
  i46 = i43 + 36 | 0;
  do {
   HEAP32[i43 >> 2] = HEAP32[i45 >> 2];
   i43 = i43 + 4 | 0;
   i45 = i45 + 4 | 0;
  } while ((i43 | 0) < (i46 | 0));
  i43 = i47 + 60 | 0;
  d67 = +HEAPF32[i43 >> 2];
  if (!(d67 < 1.0)) {
   i4 = 38;
   break;
  }
  d70 = (d42 - d67) / (1.0 - d67);
  i57 = i47 + 36 | 0;
  d67 = 1.0 - d70;
  i52 = i47 + 44 | 0;
  i53 = i47 + 48 | 0;
  d71 = +HEAPF32[i57 >> 2] * d67 + d70 * +HEAPF32[i52 >> 2];
  d72 = d67 * +HEAPF32[i47 + 40 >> 2] + d70 * +HEAPF32[i53 >> 2];
  d69 = +d71;
  d68 = +d72;
  HEAPF32[i57 >> 2] = d69;
  HEAPF32[i57 + 4 >> 2] = d68;
  i57 = i47 + 52 | 0;
  i51 = i47 + 56 | 0;
  d70 = d67 * +HEAPF32[i57 >> 2] + d70 * +HEAPF32[i51 >> 2];
  HEAPF32[i57 >> 2] = d70;
  HEAPF32[i43 >> 2] = d42;
  i57 = i47 + 44 | 0;
  HEAPF32[i57 >> 2] = d69;
  HEAPF32[i57 + 4 >> 2] = d68;
  HEAPF32[i51 >> 2] = d70;
  d68 = +Math_sin(+d70);
  i57 = i47 + 20 | 0;
  HEAPF32[i57 >> 2] = d68;
  d70 = +Math_cos(+d70);
  i56 = i47 + 24 | 0;
  HEAPF32[i56 >> 2] = d70;
  i58 = i47 + 12 | 0;
  i55 = i47 + 28 | 0;
  d69 = +HEAPF32[i55 >> 2];
  i54 = i47 + 32 | 0;
  d67 = +HEAPF32[i54 >> 2];
  d71 = +(d71 - (d70 * d69 - d68 * d67));
  d67 = +(d72 - (d68 * d69 + d70 * d67));
  i43 = i58;
  HEAPF32[i43 >> 2] = d71;
  HEAPF32[i43 + 4 >> 2] = d67;
  i43 = i48 + 60 | 0;
  d67 = +HEAPF32[i43 >> 2];
  if (!(d67 < 1.0)) {
   i4 = 40;
   break;
  }
  d70 = (d42 - d67) / (1.0 - d67);
  i64 = i48 + 36 | 0;
  d72 = 1.0 - d70;
  i61 = i48 + 44 | 0;
  i60 = i48 + 48 | 0;
  d71 = +HEAPF32[i64 >> 2] * d72 + d70 * +HEAPF32[i61 >> 2];
  d67 = d72 * +HEAPF32[i48 + 40 >> 2] + d70 * +HEAPF32[i60 >> 2];
  d69 = +d71;
  d68 = +d67;
  HEAPF32[i64 >> 2] = d69;
  HEAPF32[i64 + 4 >> 2] = d68;
  i64 = i48 + 52 | 0;
  i59 = i48 + 56 | 0;
  d70 = d72 * +HEAPF32[i64 >> 2] + d70 * +HEAPF32[i59 >> 2];
  HEAPF32[i64 >> 2] = d70;
  HEAPF32[i43 >> 2] = d42;
  i64 = i48 + 44 | 0;
  HEAPF32[i64 >> 2] = d69;
  HEAPF32[i64 + 4 >> 2] = d68;
  HEAPF32[i59 >> 2] = d70;
  d68 = +Math_sin(+d70);
  i64 = i48 + 20 | 0;
  HEAPF32[i64 >> 2] = d68;
  d70 = +Math_cos(+d70);
  i63 = i48 + 24 | 0;
  HEAPF32[i63 >> 2] = d70;
  i65 = i48 + 12 | 0;
  i62 = i48 + 28 | 0;
  d69 = +HEAPF32[i62 >> 2];
  i66 = i48 + 32 | 0;
  d72 = +HEAPF32[i66 >> 2];
  d71 = +(d71 - (d70 * d69 - d68 * d72));
  d72 = +(d67 - (d68 * d69 + d70 * d72));
  i43 = i65;
  HEAPF32[i43 >> 2] = d71;
  HEAPF32[i43 + 4 >> 2] = d72;
  __ZN9b2Contact6UpdateEP17b2ContactListener(i44, HEAP32[i13 >> 2] | 0);
  i43 = i44 + 4 | 0;
  i45 = HEAP32[i43 >> 2] | 0;
  HEAP32[i43 >> 2] = i45 & -33;
  i46 = i44 + 128 | 0;
  HEAP32[i46 >> 2] = (HEAP32[i46 >> 2] | 0) + 1;
  if ((i45 & 6 | 0) != 6) {
   HEAP32[i43 >> 2] = i45 & -37;
   i43 = i49 + 0 | 0;
   i45 = i4 + 0 | 0;
   i46 = i43 + 36 | 0;
   do {
    HEAP32[i43 >> 2] = HEAP32[i45 >> 2];
    i43 = i43 + 4 | 0;
    i45 = i45 + 4 | 0;
   } while ((i43 | 0) < (i46 | 0));
   i43 = i50 + 0 | 0;
   i45 = i8 + 0 | 0;
   i46 = i43 + 36 | 0;
   do {
    HEAP32[i43 >> 2] = HEAP32[i45 >> 2];
    i43 = i43 + 4 | 0;
    i45 = i45 + 4 | 0;
   } while ((i43 | 0) < (i46 | 0));
   d69 = +HEAPF32[i51 >> 2];
   d71 = +Math_sin(+d69);
   HEAPF32[i57 >> 2] = d71;
   d69 = +Math_cos(+d69);
   HEAPF32[i56 >> 2] = d69;
   d72 = +HEAPF32[i55 >> 2];
   d70 = +HEAPF32[i54 >> 2];
   d68 = +(+HEAPF32[i52 >> 2] - (d69 * d72 - d71 * d70));
   d70 = +(+HEAPF32[i53 >> 2] - (d71 * d72 + d69 * d70));
   HEAPF32[i58 >> 2] = d68;
   HEAPF32[i58 + 4 >> 2] = d70;
   d70 = +HEAPF32[i59 >> 2];
   d68 = +Math_sin(+d70);
   HEAPF32[i64 >> 2] = d68;
   d70 = +Math_cos(+d70);
   HEAPF32[i63 >> 2] = d70;
   d69 = +HEAPF32[i62 >> 2];
   d72 = +HEAPF32[i66 >> 2];
   d71 = +(+HEAPF32[i61 >> 2] - (d70 * d69 - d68 * d72));
   d72 = +(+HEAPF32[i60 >> 2] - (d68 * d69 + d70 * d72));
   i66 = i65;
   HEAPF32[i66 >> 2] = d71;
   HEAPF32[i66 + 4 >> 2] = d72;
   continue;
  }
  i45 = i47 + 4 | 0;
  i46 = HEAPU16[i45 >> 1] | 0;
  if ((i46 & 2 | 0) == 0) {
   HEAP16[i45 >> 1] = i46 | 2;
   HEAPF32[i47 + 144 >> 2] = 0.0;
  }
  i46 = i48 + 4 | 0;
  i49 = HEAPU16[i46 >> 1] | 0;
  if ((i49 & 2 | 0) == 0) {
   HEAP16[i46 >> 1] = i49 | 2;
   HEAPF32[i48 + 144 >> 2] = 0.0;
  }
  HEAP32[i25 >> 2] = 0;
  HEAP32[i26 >> 2] = 0;
  HEAP32[i27 >> 2] = 0;
  if ((HEAP32[i28 >> 2] | 0) <= 0) {
   i4 = 48;
   break;
  }
  i49 = i47 + 8 | 0;
  HEAP32[i49 >> 2] = 0;
  i51 = HEAP32[i25 >> 2] | 0;
  HEAP32[(HEAP32[i29 >> 2] | 0) + (i51 << 2) >> 2] = i47;
  i51 = i51 + 1 | 0;
  HEAP32[i25 >> 2] = i51;
  if ((i51 | 0) >= (HEAP32[i28 >> 2] | 0)) {
   i4 = 50;
   break;
  }
  i50 = i48 + 8 | 0;
  HEAP32[i50 >> 2] = i51;
  i51 = HEAP32[i25 >> 2] | 0;
  HEAP32[(HEAP32[i29 >> 2] | 0) + (i51 << 2) >> 2] = i48;
  HEAP32[i25 >> 2] = i51 + 1;
  i51 = HEAP32[i26 >> 2] | 0;
  if ((i51 | 0) >= (HEAP32[i24 >> 2] | 0)) {
   i4 = 52;
   break;
  }
  HEAP32[i26 >> 2] = i51 + 1;
  HEAP32[(HEAP32[i23 >> 2] | 0) + (i51 << 2) >> 2] = i44;
  HEAP16[i45 >> 1] = HEAPU16[i45 >> 1] | 1;
  HEAP16[i46 >> 1] = HEAPU16[i46 >> 1] | 1;
  HEAP32[i43 >> 2] = HEAP32[i43 >> 2] | 1;
  HEAP32[i7 >> 2] = i47;
  HEAP32[i22 >> 2] = i48;
  i44 = 1;
  while (1) {
   L58 : do {
    if ((HEAP32[i47 >> 2] | 0) == 2 ? (i12 = HEAP32[i47 + 112 >> 2] | 0, (i12 | 0) != 0) : 0) {
     i47 = i47 + 4 | 0;
     i51 = i12;
     do {
      if ((HEAP32[i25 >> 2] | 0) == (HEAP32[i28 >> 2] | 0)) {
       break L58;
      }
      if ((HEAP32[i26 >> 2] | 0) == (HEAP32[i24 >> 2] | 0)) {
       break L58;
      }
      i52 = HEAP32[i51 + 4 >> 2] | 0;
      i53 = i52 + 4 | 0;
      do {
       if ((HEAP32[i53 >> 2] & 1 | 0) == 0) {
        i48 = HEAP32[i51 >> 2] | 0;
        if (((HEAP32[i48 >> 2] | 0) == 2 ? (HEAP16[i47 >> 1] & 8) == 0 : 0) ? (HEAP16[i48 + 4 >> 1] & 8) == 0 : 0) {
         break;
        }
        if ((HEAP8[(HEAP32[i52 + 48 >> 2] | 0) + 38 | 0] | 0) == 0 ? (HEAP8[(HEAP32[i52 + 52 >> 2] | 0) + 38 | 0] | 0) == 0 : 0) {
         i54 = i48 + 28 | 0;
         i43 = i14 + 0 | 0;
         i45 = i54 + 0 | 0;
         i46 = i43 + 36 | 0;
         do {
          HEAP32[i43 >> 2] = HEAP32[i45 >> 2];
          i43 = i43 + 4 | 0;
          i45 = i45 + 4 | 0;
         } while ((i43 | 0) < (i46 | 0));
         i43 = i48 + 4 | 0;
         if ((HEAP16[i43 >> 1] & 1) == 0) {
          i45 = i48 + 60 | 0;
          d67 = +HEAPF32[i45 >> 2];
          if (!(d67 < 1.0)) {
           i4 = 67;
           break L11;
          }
          d70 = (d42 - d67) / (1.0 - d67);
          i65 = i48 + 36 | 0;
          d72 = 1.0 - d70;
          d71 = +HEAPF32[i65 >> 2] * d72 + d70 * +HEAPF32[i48 + 44 >> 2];
          d67 = d72 * +HEAPF32[i48 + 40 >> 2] + d70 * +HEAPF32[i48 + 48 >> 2];
          d69 = +d71;
          d68 = +d67;
          HEAPF32[i65 >> 2] = d69;
          HEAPF32[i65 + 4 >> 2] = d68;
          i65 = i48 + 52 | 0;
          i66 = i48 + 56 | 0;
          d70 = d72 * +HEAPF32[i65 >> 2] + d70 * +HEAPF32[i66 >> 2];
          HEAPF32[i65 >> 2] = d70;
          HEAPF32[i45 >> 2] = d42;
          i65 = i48 + 44 | 0;
          HEAPF32[i65 >> 2] = d69;
          HEAPF32[i65 + 4 >> 2] = d68;
          HEAPF32[i66 >> 2] = d70;
          d68 = +Math_sin(+d70);
          HEAPF32[i48 + 20 >> 2] = d68;
          d70 = +Math_cos(+d70);
          HEAPF32[i48 + 24 >> 2] = d70;
          d69 = +HEAPF32[i48 + 28 >> 2];
          d72 = +HEAPF32[i48 + 32 >> 2];
          d71 = +(d71 - (d70 * d69 - d68 * d72));
          d72 = +(d67 - (d68 * d69 + d70 * d72));
          i66 = i48 + 12 | 0;
          HEAPF32[i66 >> 2] = d71;
          HEAPF32[i66 + 4 >> 2] = d72;
         }
         __ZN9b2Contact6UpdateEP17b2ContactListener(i52, HEAP32[i13 >> 2] | 0);
         i45 = HEAP32[i53 >> 2] | 0;
         if ((i45 & 4 | 0) == 0) {
          i43 = i54 + 0 | 0;
          i45 = i14 + 0 | 0;
          i46 = i43 + 36 | 0;
          do {
           HEAP32[i43 >> 2] = HEAP32[i45 >> 2];
           i43 = i43 + 4 | 0;
           i45 = i45 + 4 | 0;
          } while ((i43 | 0) < (i46 | 0));
          d70 = +HEAPF32[i48 + 56 >> 2];
          d68 = +Math_sin(+d70);
          HEAPF32[i48 + 20 >> 2] = d68;
          d70 = +Math_cos(+d70);
          HEAPF32[i48 + 24 >> 2] = d70;
          d69 = +HEAPF32[i48 + 28 >> 2];
          d72 = +HEAPF32[i48 + 32 >> 2];
          d71 = +(+HEAPF32[i48 + 44 >> 2] - (d70 * d69 - d68 * d72));
          d72 = +(+HEAPF32[i48 + 48 >> 2] - (d68 * d69 + d70 * d72));
          i66 = i48 + 12 | 0;
          HEAPF32[i66 >> 2] = d71;
          HEAPF32[i66 + 4 >> 2] = d72;
          break;
         }
         if ((i45 & 2 | 0) == 0) {
          i43 = i54 + 0 | 0;
          i45 = i14 + 0 | 0;
          i46 = i43 + 36 | 0;
          do {
           HEAP32[i43 >> 2] = HEAP32[i45 >> 2];
           i43 = i43 + 4 | 0;
           i45 = i45 + 4 | 0;
          } while ((i43 | 0) < (i46 | 0));
          d70 = +HEAPF32[i48 + 56 >> 2];
          d68 = +Math_sin(+d70);
          HEAPF32[i48 + 20 >> 2] = d68;
          d70 = +Math_cos(+d70);
          HEAPF32[i48 + 24 >> 2] = d70;
          d69 = +HEAPF32[i48 + 28 >> 2];
          d72 = +HEAPF32[i48 + 32 >> 2];
          d71 = +(+HEAPF32[i48 + 44 >> 2] - (d70 * d69 - d68 * d72));
          d72 = +(+HEAPF32[i48 + 48 >> 2] - (d68 * d69 + d70 * d72));
          i66 = i48 + 12 | 0;
          HEAPF32[i66 >> 2] = d71;
          HEAPF32[i66 + 4 >> 2] = d72;
          break;
         }
         HEAP32[i53 >> 2] = i45 | 1;
         i45 = HEAP32[i26 >> 2] | 0;
         if ((i45 | 0) >= (HEAP32[i24 >> 2] | 0)) {
          i4 = 74;
          break L11;
         }
         HEAP32[i26 >> 2] = i45 + 1;
         HEAP32[(HEAP32[i23 >> 2] | 0) + (i45 << 2) >> 2] = i52;
         i45 = HEAPU16[i43 >> 1] | 0;
         if ((i45 & 1 | 0) == 0) {
          HEAP16[i43 >> 1] = i45 | 1;
          if ((HEAP32[i48 >> 2] | 0) != 0 ? (i45 & 2 | 0) == 0 : 0) {
           HEAP16[i43 >> 1] = i45 | 3;
           HEAPF32[i48 + 144 >> 2] = 0.0;
          }
          i43 = HEAP32[i25 >> 2] | 0;
          if ((i43 | 0) >= (HEAP32[i28 >> 2] | 0)) {
           i4 = 80;
           break L11;
          }
          HEAP32[i48 + 8 >> 2] = i43;
          i66 = HEAP32[i25 >> 2] | 0;
          HEAP32[(HEAP32[i29 >> 2] | 0) + (i66 << 2) >> 2] = i48;
          HEAP32[i25 >> 2] = i66 + 1;
         }
        }
       }
      } while (0);
      i51 = HEAP32[i51 + 12 >> 2] | 0;
     } while ((i51 | 0) != 0);
    }
   } while (0);
   if ((i44 | 0) >= 2) {
    break;
   }
   i47 = HEAP32[i7 + (i44 << 2) >> 2] | 0;
   i44 = i44 + 1 | 0;
  }
  d72 = (1.0 - d42) * +HEAPF32[i11 >> 2];
  HEAPF32[i9 >> 2] = d72;
  HEAPF32[i21 >> 2] = 1.0 / d72;
  HEAPF32[i20 >> 2] = 1.0;
  HEAP32[i19 >> 2] = 20;
  HEAP32[i17 >> 2] = HEAP32[i18 >> 2];
  HEAP8[i16] = 0;
  __ZN8b2Island8SolveTOIERK10b2TimeStepii(i3, i9, HEAP32[i49 >> 2] | 0, HEAP32[i50 >> 2] | 0);
  i44 = HEAP32[i25 >> 2] | 0;
  if ((i44 | 0) > 0) {
   i43 = 0;
   do {
    i45 = HEAP32[(HEAP32[i29 >> 2] | 0) + (i43 << 2) >> 2] | 0;
    i66 = i45 + 4 | 0;
    HEAP16[i66 >> 1] = HEAP16[i66 >> 1] & 65534;
    if ((HEAP32[i45 >> 2] | 0) == 2) {
     __ZN6b2Body19SynchronizeFixturesEv(i45);
     i44 = HEAP32[i45 + 112 >> 2] | 0;
     if ((i44 | 0) != 0) {
      do {
       i66 = (HEAP32[i44 + 4 >> 2] | 0) + 4 | 0;
       HEAP32[i66 >> 2] = HEAP32[i66 >> 2] & -34;
       i44 = HEAP32[i44 + 12 >> 2] | 0;
      } while ((i44 | 0) != 0);
     }
     i44 = HEAP32[i25 >> 2] | 0;
    }
    i43 = i43 + 1 | 0;
   } while ((i43 | 0) < (i44 | 0));
  }
  __ZN16b2ContactManager15FindNewContactsEv(i10);
  if ((HEAP8[i39] | 0) != 0) {
   i4 = 92;
   break;
  }
 }
 if ((i4 | 0) == 16) {
  ___assert_fail(2288, 2184, 641, 2344);
 } else if ((i4 | 0) == 21) {
  ___assert_fail(2360, 2376, 723, 2400);
 } else if ((i4 | 0) == 25) {
  ___assert_fail(2360, 2376, 723, 2400);
 } else if ((i4 | 0) == 28) {
  ___assert_fail(2360, 2184, 676, 2344);
 } else if ((i4 | 0) == 36) {
  HEAP8[i2] = 1;
  __ZN8b2IslandD2Ev(i3);
  STACKTOP = i1;
  return;
 } else if ((i4 | 0) == 38) {
  ___assert_fail(2360, 2376, 723, 2400);
 } else if ((i4 | 0) == 40) {
  ___assert_fail(2360, 2376, 723, 2400);
 } else if ((i4 | 0) == 48) {
  ___assert_fail(2520, 2440, 54, 2472);
 } else if ((i4 | 0) == 50) {
  ___assert_fail(2520, 2440, 54, 2472);
 } else if ((i4 | 0) == 52) {
  ___assert_fail(2480, 2440, 62, 2472);
 } else if ((i4 | 0) == 67) {
  ___assert_fail(2360, 2376, 723, 2400);
 } else if ((i4 | 0) == 74) {
  ___assert_fail(2480, 2440, 62, 2472);
 } else if ((i4 | 0) == 80) {
  ___assert_fail(2520, 2440, 54, 2472);
 } else if ((i4 | 0) == 92) {
  HEAP8[i2] = 0;
  __ZN8b2IslandD2Ev(i3);
  STACKTOP = i1;
  return;
 }
}
function __ZNSt3__16__sortIRPFbRK6b2PairS3_EPS1_EEvT0_S8_T_(i5, i8, i1) {
 i5 = i5 | 0;
 i8 = i8 | 0;
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i6 = 0, i7 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i2 = i3;
 L1 : while (1) {
  i7 = i8;
  i4 = i8 + -12 | 0;
  L3 : while (1) {
   i9 = i5;
   i11 = i7 - i9 | 0;
   switch ((i11 | 0) / 12 | 0 | 0) {
   case 4:
    {
     i6 = 14;
     break L1;
    }
   case 2:
    {
     i6 = 4;
     break L1;
    }
   case 3:
    {
     i6 = 6;
     break L1;
    }
   case 5:
    {
     i6 = 15;
     break L1;
    }
   case 1:
   case 0:
    {
     i6 = 67;
     break L1;
    }
   default:
    {}
   }
   if ((i11 | 0) < 372) {
    i6 = 21;
    break L1;
   }
   i12 = (i11 | 0) / 24 | 0;
   i10 = i5 + (i12 * 12 | 0) | 0;
   do {
    if ((i11 | 0) > 11988) {
     i14 = (i11 | 0) / 48 | 0;
     i11 = i5 + (i14 * 12 | 0) | 0;
     i14 = i5 + ((i14 + i12 | 0) * 12 | 0) | 0;
     i12 = __ZNSt3__17__sort4IRPFbRK6b2PairS3_EPS1_EEjT0_S8_S8_S8_T_(i5, i11, i10, i14, i1) | 0;
     if (FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i4, i14) | 0) {
      HEAP32[i2 + 0 >> 2] = HEAP32[i14 + 0 >> 2];
      HEAP32[i2 + 4 >> 2] = HEAP32[i14 + 4 >> 2];
      HEAP32[i2 + 8 >> 2] = HEAP32[i14 + 8 >> 2];
      HEAP32[i14 + 0 >> 2] = HEAP32[i4 + 0 >> 2];
      HEAP32[i14 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
      HEAP32[i14 + 8 >> 2] = HEAP32[i4 + 8 >> 2];
      HEAP32[i4 + 0 >> 2] = HEAP32[i2 + 0 >> 2];
      HEAP32[i4 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
      HEAP32[i4 + 8 >> 2] = HEAP32[i2 + 8 >> 2];
      i13 = i12 + 1 | 0;
      if (FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i14, i10) | 0) {
       HEAP32[i2 + 0 >> 2] = HEAP32[i10 + 0 >> 2];
       HEAP32[i2 + 4 >> 2] = HEAP32[i10 + 4 >> 2];
       HEAP32[i2 + 8 >> 2] = HEAP32[i10 + 8 >> 2];
       HEAP32[i10 + 0 >> 2] = HEAP32[i14 + 0 >> 2];
       HEAP32[i10 + 4 >> 2] = HEAP32[i14 + 4 >> 2];
       HEAP32[i10 + 8 >> 2] = HEAP32[i14 + 8 >> 2];
       HEAP32[i14 + 0 >> 2] = HEAP32[i2 + 0 >> 2];
       HEAP32[i14 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
       HEAP32[i14 + 8 >> 2] = HEAP32[i2 + 8 >> 2];
       i13 = i12 + 2 | 0;
       if (FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i10, i11) | 0) {
        HEAP32[i2 + 0 >> 2] = HEAP32[i11 + 0 >> 2];
        HEAP32[i2 + 4 >> 2] = HEAP32[i11 + 4 >> 2];
        HEAP32[i2 + 8 >> 2] = HEAP32[i11 + 8 >> 2];
        HEAP32[i11 + 0 >> 2] = HEAP32[i10 + 0 >> 2];
        HEAP32[i11 + 4 >> 2] = HEAP32[i10 + 4 >> 2];
        HEAP32[i11 + 8 >> 2] = HEAP32[i10 + 8 >> 2];
        HEAP32[i10 + 0 >> 2] = HEAP32[i2 + 0 >> 2];
        HEAP32[i10 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
        HEAP32[i10 + 8 >> 2] = HEAP32[i2 + 8 >> 2];
        if (FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i11, i5) | 0) {
         HEAP32[i2 + 0 >> 2] = HEAP32[i5 + 0 >> 2];
         HEAP32[i2 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
         HEAP32[i2 + 8 >> 2] = HEAP32[i5 + 8 >> 2];
         HEAP32[i5 + 0 >> 2] = HEAP32[i11 + 0 >> 2];
         HEAP32[i5 + 4 >> 2] = HEAP32[i11 + 4 >> 2];
         HEAP32[i5 + 8 >> 2] = HEAP32[i11 + 8 >> 2];
         HEAP32[i11 + 0 >> 2] = HEAP32[i2 + 0 >> 2];
         HEAP32[i11 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
         HEAP32[i11 + 8 >> 2] = HEAP32[i2 + 8 >> 2];
         i12 = i12 + 4 | 0;
        } else {
         i12 = i12 + 3 | 0;
        }
       } else {
        i12 = i13;
       }
      } else {
       i12 = i13;
      }
     }
    } else {
     i15 = FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i10, i5) | 0;
     i11 = FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i4, i10) | 0;
     if (!i15) {
      if (!i11) {
       i12 = 0;
       break;
      }
      HEAP32[i2 + 0 >> 2] = HEAP32[i10 + 0 >> 2];
      HEAP32[i2 + 4 >> 2] = HEAP32[i10 + 4 >> 2];
      HEAP32[i2 + 8 >> 2] = HEAP32[i10 + 8 >> 2];
      HEAP32[i10 + 0 >> 2] = HEAP32[i4 + 0 >> 2];
      HEAP32[i10 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
      HEAP32[i10 + 8 >> 2] = HEAP32[i4 + 8 >> 2];
      HEAP32[i4 + 0 >> 2] = HEAP32[i2 + 0 >> 2];
      HEAP32[i4 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
      HEAP32[i4 + 8 >> 2] = HEAP32[i2 + 8 >> 2];
      if (!(FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i10, i5) | 0)) {
       i12 = 1;
       break;
      }
      HEAP32[i2 + 0 >> 2] = HEAP32[i5 + 0 >> 2];
      HEAP32[i2 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
      HEAP32[i2 + 8 >> 2] = HEAP32[i5 + 8 >> 2];
      HEAP32[i5 + 0 >> 2] = HEAP32[i10 + 0 >> 2];
      HEAP32[i5 + 4 >> 2] = HEAP32[i10 + 4 >> 2];
      HEAP32[i5 + 8 >> 2] = HEAP32[i10 + 8 >> 2];
      HEAP32[i10 + 0 >> 2] = HEAP32[i2 + 0 >> 2];
      HEAP32[i10 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
      HEAP32[i10 + 8 >> 2] = HEAP32[i2 + 8 >> 2];
      i12 = 2;
      break;
     }
     if (i11) {
      HEAP32[i2 + 0 >> 2] = HEAP32[i5 + 0 >> 2];
      HEAP32[i2 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
      HEAP32[i2 + 8 >> 2] = HEAP32[i5 + 8 >> 2];
      HEAP32[i5 + 0 >> 2] = HEAP32[i4 + 0 >> 2];
      HEAP32[i5 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
      HEAP32[i5 + 8 >> 2] = HEAP32[i4 + 8 >> 2];
      HEAP32[i4 + 0 >> 2] = HEAP32[i2 + 0 >> 2];
      HEAP32[i4 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
      HEAP32[i4 + 8 >> 2] = HEAP32[i2 + 8 >> 2];
      i12 = 1;
      break;
     }
     HEAP32[i2 + 0 >> 2] = HEAP32[i5 + 0 >> 2];
     HEAP32[i2 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
     HEAP32[i2 + 8 >> 2] = HEAP32[i5 + 8 >> 2];
     HEAP32[i5 + 0 >> 2] = HEAP32[i10 + 0 >> 2];
     HEAP32[i5 + 4 >> 2] = HEAP32[i10 + 4 >> 2];
     HEAP32[i5 + 8 >> 2] = HEAP32[i10 + 8 >> 2];
     HEAP32[i10 + 0 >> 2] = HEAP32[i2 + 0 >> 2];
     HEAP32[i10 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
     HEAP32[i10 + 8 >> 2] = HEAP32[i2 + 8 >> 2];
     if (FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i4, i10) | 0) {
      HEAP32[i2 + 0 >> 2] = HEAP32[i10 + 0 >> 2];
      HEAP32[i2 + 4 >> 2] = HEAP32[i10 + 4 >> 2];
      HEAP32[i2 + 8 >> 2] = HEAP32[i10 + 8 >> 2];
      HEAP32[i10 + 0 >> 2] = HEAP32[i4 + 0 >> 2];
      HEAP32[i10 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
      HEAP32[i10 + 8 >> 2] = HEAP32[i4 + 8 >> 2];
      HEAP32[i4 + 0 >> 2] = HEAP32[i2 + 0 >> 2];
      HEAP32[i4 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
      HEAP32[i4 + 8 >> 2] = HEAP32[i2 + 8 >> 2];
      i12 = 2;
     } else {
      i12 = 1;
     }
    }
   } while (0);
   do {
    if (FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i5, i10) | 0) {
     i13 = i4;
    } else {
     i13 = i4;
     while (1) {
      i13 = i13 + -12 | 0;
      if ((i5 | 0) == (i13 | 0)) {
       break;
      }
      if (FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i13, i10) | 0) {
       i6 = 50;
       break;
      }
     }
     if ((i6 | 0) == 50) {
      i6 = 0;
      HEAP32[i2 + 0 >> 2] = HEAP32[i5 + 0 >> 2];
      HEAP32[i2 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
      HEAP32[i2 + 8 >> 2] = HEAP32[i5 + 8 >> 2];
      HEAP32[i5 + 0 >> 2] = HEAP32[i13 + 0 >> 2];
      HEAP32[i5 + 4 >> 2] = HEAP32[i13 + 4 >> 2];
      HEAP32[i5 + 8 >> 2] = HEAP32[i13 + 8 >> 2];
      HEAP32[i13 + 0 >> 2] = HEAP32[i2 + 0 >> 2];
      HEAP32[i13 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
      HEAP32[i13 + 8 >> 2] = HEAP32[i2 + 8 >> 2];
      i12 = i12 + 1 | 0;
      break;
     }
     i10 = i5 + 12 | 0;
     if (!(FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i5, i4) | 0)) {
      if ((i10 | 0) == (i4 | 0)) {
       i6 = 67;
       break L1;
      }
      while (1) {
       i9 = i10 + 12 | 0;
       if (FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i5, i10) | 0) {
        break;
       }
       if ((i9 | 0) == (i4 | 0)) {
        i6 = 67;
        break L1;
       } else {
        i10 = i9;
       }
      }
      HEAP32[i2 + 0 >> 2] = HEAP32[i10 + 0 >> 2];
      HEAP32[i2 + 4 >> 2] = HEAP32[i10 + 4 >> 2];
      HEAP32[i2 + 8 >> 2] = HEAP32[i10 + 8 >> 2];
      HEAP32[i10 + 0 >> 2] = HEAP32[i4 + 0 >> 2];
      HEAP32[i10 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
      HEAP32[i10 + 8 >> 2] = HEAP32[i4 + 8 >> 2];
      HEAP32[i4 + 0 >> 2] = HEAP32[i2 + 0 >> 2];
      HEAP32[i4 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
      HEAP32[i4 + 8 >> 2] = HEAP32[i2 + 8 >> 2];
      i10 = i9;
     }
     if ((i10 | 0) == (i4 | 0)) {
      i6 = 67;
      break L1;
     } else {
      i9 = i4;
     }
     while (1) {
      while (1) {
       i11 = i10 + 12 | 0;
       if (FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i5, i10) | 0) {
        break;
       } else {
        i10 = i11;
       }
      }
      do {
       i9 = i9 + -12 | 0;
      } while (FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i5, i9) | 0);
      if (!(i10 >>> 0 < i9 >>> 0)) {
       i5 = i10;
       continue L3;
      }
      HEAP32[i2 + 0 >> 2] = HEAP32[i10 + 0 >> 2];
      HEAP32[i2 + 4 >> 2] = HEAP32[i10 + 4 >> 2];
      HEAP32[i2 + 8 >> 2] = HEAP32[i10 + 8 >> 2];
      HEAP32[i10 + 0 >> 2] = HEAP32[i9 + 0 >> 2];
      HEAP32[i10 + 4 >> 2] = HEAP32[i9 + 4 >> 2];
      HEAP32[i10 + 8 >> 2] = HEAP32[i9 + 8 >> 2];
      HEAP32[i9 + 0 >> 2] = HEAP32[i2 + 0 >> 2];
      HEAP32[i9 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
      HEAP32[i9 + 8 >> 2] = HEAP32[i2 + 8 >> 2];
      i10 = i11;
     }
    }
   } while (0);
   i11 = i5 + 12 | 0;
   L47 : do {
    if (i11 >>> 0 < i13 >>> 0) {
     while (1) {
      i15 = i11;
      while (1) {
       i11 = i15 + 12 | 0;
       if (FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i15, i10) | 0) {
        i15 = i11;
       } else {
        i14 = i13;
        break;
       }
      }
      do {
       i14 = i14 + -12 | 0;
      } while (!(FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i14, i10) | 0));
      if (i15 >>> 0 > i14 >>> 0) {
       i11 = i15;
       break L47;
      }
      HEAP32[i2 + 0 >> 2] = HEAP32[i15 + 0 >> 2];
      HEAP32[i2 + 4 >> 2] = HEAP32[i15 + 4 >> 2];
      HEAP32[i2 + 8 >> 2] = HEAP32[i15 + 8 >> 2];
      HEAP32[i15 + 0 >> 2] = HEAP32[i14 + 0 >> 2];
      HEAP32[i15 + 4 >> 2] = HEAP32[i14 + 4 >> 2];
      HEAP32[i15 + 8 >> 2] = HEAP32[i14 + 8 >> 2];
      HEAP32[i14 + 0 >> 2] = HEAP32[i2 + 0 >> 2];
      HEAP32[i14 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
      HEAP32[i14 + 8 >> 2] = HEAP32[i2 + 8 >> 2];
      i13 = i14;
      i10 = (i10 | 0) == (i15 | 0) ? i14 : i10;
      i12 = i12 + 1 | 0;
     }
    }
   } while (0);
   if ((i11 | 0) != (i10 | 0) ? FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i10, i11) | 0 : 0) {
    HEAP32[i2 + 0 >> 2] = HEAP32[i11 + 0 >> 2];
    HEAP32[i2 + 4 >> 2] = HEAP32[i11 + 4 >> 2];
    HEAP32[i2 + 8 >> 2] = HEAP32[i11 + 8 >> 2];
    HEAP32[i11 + 0 >> 2] = HEAP32[i10 + 0 >> 2];
    HEAP32[i11 + 4 >> 2] = HEAP32[i10 + 4 >> 2];
    HEAP32[i11 + 8 >> 2] = HEAP32[i10 + 8 >> 2];
    HEAP32[i10 + 0 >> 2] = HEAP32[i2 + 0 >> 2];
    HEAP32[i10 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
    HEAP32[i10 + 8 >> 2] = HEAP32[i2 + 8 >> 2];
    i12 = i12 + 1 | 0;
   }
   if ((i12 | 0) == 0) {
    i12 = __ZNSt3__127__insertion_sort_incompleteIRPFbRK6b2PairS3_EPS1_EEbT0_S8_T_(i5, i11, i1) | 0;
    i10 = i11 + 12 | 0;
    if (__ZNSt3__127__insertion_sort_incompleteIRPFbRK6b2PairS3_EPS1_EEbT0_S8_T_(i10, i8, i1) | 0) {
     i6 = 62;
     break;
    }
    if (i12) {
     i5 = i10;
     continue;
    }
   }
   i15 = i11;
   if ((i15 - i9 | 0) >= (i7 - i15 | 0)) {
    i6 = 66;
    break;
   }
   __ZNSt3__16__sortIRPFbRK6b2PairS3_EPS1_EEvT0_S8_T_(i5, i11, i1);
   i5 = i11 + 12 | 0;
  }
  if ((i6 | 0) == 62) {
   i6 = 0;
   if (i12) {
    i6 = 67;
    break;
   } else {
    i8 = i11;
    continue;
   }
  } else if ((i6 | 0) == 66) {
   i6 = 0;
   __ZNSt3__16__sortIRPFbRK6b2PairS3_EPS1_EEvT0_S8_T_(i11 + 12 | 0, i8, i1);
   i8 = i11;
   continue;
  }
 }
 if ((i6 | 0) == 4) {
  if (!(FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i4, i5) | 0)) {
   STACKTOP = i3;
   return;
  }
  HEAP32[i2 + 0 >> 2] = HEAP32[i5 + 0 >> 2];
  HEAP32[i2 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
  HEAP32[i2 + 8 >> 2] = HEAP32[i5 + 8 >> 2];
  HEAP32[i5 + 0 >> 2] = HEAP32[i4 + 0 >> 2];
  HEAP32[i5 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
  HEAP32[i5 + 8 >> 2] = HEAP32[i4 + 8 >> 2];
  HEAP32[i4 + 0 >> 2] = HEAP32[i2 + 0 >> 2];
  HEAP32[i4 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
  HEAP32[i4 + 8 >> 2] = HEAP32[i2 + 8 >> 2];
  STACKTOP = i3;
  return;
 } else if ((i6 | 0) == 6) {
  i6 = i5 + 12 | 0;
  i15 = FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i6, i5) | 0;
  i7 = FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i4, i6) | 0;
  if (!i15) {
   if (!i7) {
    STACKTOP = i3;
    return;
   }
   HEAP32[i2 + 0 >> 2] = HEAP32[i6 + 0 >> 2];
   HEAP32[i2 + 4 >> 2] = HEAP32[i6 + 4 >> 2];
   HEAP32[i2 + 8 >> 2] = HEAP32[i6 + 8 >> 2];
   HEAP32[i6 + 0 >> 2] = HEAP32[i4 + 0 >> 2];
   HEAP32[i6 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
   HEAP32[i6 + 8 >> 2] = HEAP32[i4 + 8 >> 2];
   HEAP32[i4 + 0 >> 2] = HEAP32[i2 + 0 >> 2];
   HEAP32[i4 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
   HEAP32[i4 + 8 >> 2] = HEAP32[i2 + 8 >> 2];
   if (!(FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i6, i5) | 0)) {
    STACKTOP = i3;
    return;
   }
   HEAP32[i2 + 0 >> 2] = HEAP32[i5 + 0 >> 2];
   HEAP32[i2 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
   HEAP32[i2 + 8 >> 2] = HEAP32[i5 + 8 >> 2];
   HEAP32[i5 + 0 >> 2] = HEAP32[i6 + 0 >> 2];
   HEAP32[i5 + 4 >> 2] = HEAP32[i6 + 4 >> 2];
   HEAP32[i5 + 8 >> 2] = HEAP32[i6 + 8 >> 2];
   HEAP32[i6 + 0 >> 2] = HEAP32[i2 + 0 >> 2];
   HEAP32[i6 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
   HEAP32[i6 + 8 >> 2] = HEAP32[i2 + 8 >> 2];
   STACKTOP = i3;
   return;
  }
  if (i7) {
   HEAP32[i2 + 0 >> 2] = HEAP32[i5 + 0 >> 2];
   HEAP32[i2 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
   HEAP32[i2 + 8 >> 2] = HEAP32[i5 + 8 >> 2];
   HEAP32[i5 + 0 >> 2] = HEAP32[i4 + 0 >> 2];
   HEAP32[i5 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
   HEAP32[i5 + 8 >> 2] = HEAP32[i4 + 8 >> 2];
   HEAP32[i4 + 0 >> 2] = HEAP32[i2 + 0 >> 2];
   HEAP32[i4 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
   HEAP32[i4 + 8 >> 2] = HEAP32[i2 + 8 >> 2];
   STACKTOP = i3;
   return;
  }
  HEAP32[i2 + 0 >> 2] = HEAP32[i5 + 0 >> 2];
  HEAP32[i2 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
  HEAP32[i2 + 8 >> 2] = HEAP32[i5 + 8 >> 2];
  HEAP32[i5 + 0 >> 2] = HEAP32[i6 + 0 >> 2];
  HEAP32[i5 + 4 >> 2] = HEAP32[i6 + 4 >> 2];
  HEAP32[i5 + 8 >> 2] = HEAP32[i6 + 8 >> 2];
  HEAP32[i6 + 0 >> 2] = HEAP32[i2 + 0 >> 2];
  HEAP32[i6 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
  HEAP32[i6 + 8 >> 2] = HEAP32[i2 + 8 >> 2];
  if (!(FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i4, i6) | 0)) {
   STACKTOP = i3;
   return;
  }
  HEAP32[i2 + 0 >> 2] = HEAP32[i6 + 0 >> 2];
  HEAP32[i2 + 4 >> 2] = HEAP32[i6 + 4 >> 2];
  HEAP32[i2 + 8 >> 2] = HEAP32[i6 + 8 >> 2];
  HEAP32[i6 + 0 >> 2] = HEAP32[i4 + 0 >> 2];
  HEAP32[i6 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
  HEAP32[i6 + 8 >> 2] = HEAP32[i4 + 8 >> 2];
  HEAP32[i4 + 0 >> 2] = HEAP32[i2 + 0 >> 2];
  HEAP32[i4 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
  HEAP32[i4 + 8 >> 2] = HEAP32[i2 + 8 >> 2];
  STACKTOP = i3;
  return;
 } else if ((i6 | 0) == 14) {
  __ZNSt3__17__sort4IRPFbRK6b2PairS3_EPS1_EEjT0_S8_S8_S8_T_(i5, i5 + 12 | 0, i5 + 24 | 0, i4, i1) | 0;
  STACKTOP = i3;
  return;
 } else if ((i6 | 0) == 15) {
  i6 = i5 + 12 | 0;
  i7 = i5 + 24 | 0;
  i8 = i5 + 36 | 0;
  __ZNSt3__17__sort4IRPFbRK6b2PairS3_EPS1_EEjT0_S8_S8_S8_T_(i5, i6, i7, i8, i1) | 0;
  if (!(FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i4, i8) | 0)) {
   STACKTOP = i3;
   return;
  }
  HEAP32[i2 + 0 >> 2] = HEAP32[i8 + 0 >> 2];
  HEAP32[i2 + 4 >> 2] = HEAP32[i8 + 4 >> 2];
  HEAP32[i2 + 8 >> 2] = HEAP32[i8 + 8 >> 2];
  HEAP32[i8 + 0 >> 2] = HEAP32[i4 + 0 >> 2];
  HEAP32[i8 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
  HEAP32[i8 + 8 >> 2] = HEAP32[i4 + 8 >> 2];
  HEAP32[i4 + 0 >> 2] = HEAP32[i2 + 0 >> 2];
  HEAP32[i4 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
  HEAP32[i4 + 8 >> 2] = HEAP32[i2 + 8 >> 2];
  if (!(FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i8, i7) | 0)) {
   STACKTOP = i3;
   return;
  }
  HEAP32[i2 + 0 >> 2] = HEAP32[i7 + 0 >> 2];
  HEAP32[i2 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
  HEAP32[i2 + 8 >> 2] = HEAP32[i7 + 8 >> 2];
  HEAP32[i7 + 0 >> 2] = HEAP32[i8 + 0 >> 2];
  HEAP32[i7 + 4 >> 2] = HEAP32[i8 + 4 >> 2];
  HEAP32[i7 + 8 >> 2] = HEAP32[i8 + 8 >> 2];
  HEAP32[i8 + 0 >> 2] = HEAP32[i2 + 0 >> 2];
  HEAP32[i8 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
  HEAP32[i8 + 8 >> 2] = HEAP32[i2 + 8 >> 2];
  if (!(FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i7, i6) | 0)) {
   STACKTOP = i3;
   return;
  }
  HEAP32[i2 + 0 >> 2] = HEAP32[i6 + 0 >> 2];
  HEAP32[i2 + 4 >> 2] = HEAP32[i6 + 4 >> 2];
  HEAP32[i2 + 8 >> 2] = HEAP32[i6 + 8 >> 2];
  HEAP32[i6 + 0 >> 2] = HEAP32[i7 + 0 >> 2];
  HEAP32[i6 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
  HEAP32[i6 + 8 >> 2] = HEAP32[i7 + 8 >> 2];
  HEAP32[i7 + 0 >> 2] = HEAP32[i2 + 0 >> 2];
  HEAP32[i7 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
  HEAP32[i7 + 8 >> 2] = HEAP32[i2 + 8 >> 2];
  if (!(FUNCTION_TABLE_iii[HEAP32[i1 >> 2] & 3](i6, i5) | 0)) {
   STACKTOP = i3;
   return;
  }
  HEAP32[i2 + 0 >> 2] = HEAP32[i5 + 0 >> 2];
  HEAP32[i2 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
  HEAP32[i2 + 8 >> 2] = HEAP32[i5 + 8 >> 2];
  HEAP32[i5 + 0 >> 2] = HEAP32[i6 + 0 >> 2];
  HEAP32[i5 + 4 >> 2] = HEAP32[i6 + 4 >> 2];
  HEAP32[i5 + 8 >> 2] = HEAP32[i6 + 8 >> 2];
  HEAP32[i6 + 0 >> 2] = HEAP32[i2 + 0 >> 2];
  HEAP32[i6 + 4 >> 2] = HEAP32[i2 + 4 >> 2];
  HEAP32[i6 + 8 >> 2] = HEAP32[i2 + 8 >> 2];
  STACKTOP = i3;
  return;
 } else if ((i6 | 0) == 21) {
  __ZNSt3__118__insertion_sort_3IRPFbRK6b2PairS3_EPS1_EEvT0_S8_T_(i5, i8, i1);
  STACKTOP = i3;
  return;
 } else if ((i6 | 0) == 67) {
  STACKTOP = i3;
  return;
 }
}
function _free(i7) {
 i7 = i7 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0;
 i1 = STACKTOP;
 if ((i7 | 0) == 0) {
  STACKTOP = i1;
  return;
 }
 i15 = i7 + -8 | 0;
 i16 = HEAP32[7176 >> 2] | 0;
 if (i15 >>> 0 < i16 >>> 0) {
  _abort();
 }
 i13 = HEAP32[i7 + -4 >> 2] | 0;
 i12 = i13 & 3;
 if ((i12 | 0) == 1) {
  _abort();
 }
 i8 = i13 & -8;
 i6 = i7 + (i8 + -8) | 0;
 do {
  if ((i13 & 1 | 0) == 0) {
   i19 = HEAP32[i15 >> 2] | 0;
   if ((i12 | 0) == 0) {
    STACKTOP = i1;
    return;
   }
   i15 = -8 - i19 | 0;
   i13 = i7 + i15 | 0;
   i12 = i19 + i8 | 0;
   if (i13 >>> 0 < i16 >>> 0) {
    _abort();
   }
   if ((i13 | 0) == (HEAP32[7180 >> 2] | 0)) {
    i2 = i7 + (i8 + -4) | 0;
    if ((HEAP32[i2 >> 2] & 3 | 0) != 3) {
     i2 = i13;
     i11 = i12;
     break;
    }
    HEAP32[7168 >> 2] = i12;
    HEAP32[i2 >> 2] = HEAP32[i2 >> 2] & -2;
    HEAP32[i7 + (i15 + 4) >> 2] = i12 | 1;
    HEAP32[i6 >> 2] = i12;
    STACKTOP = i1;
    return;
   }
   i18 = i19 >>> 3;
   if (i19 >>> 0 < 256) {
    i2 = HEAP32[i7 + (i15 + 8) >> 2] | 0;
    i11 = HEAP32[i7 + (i15 + 12) >> 2] | 0;
    i14 = 7200 + (i18 << 1 << 2) | 0;
    if ((i2 | 0) != (i14 | 0)) {
     if (i2 >>> 0 < i16 >>> 0) {
      _abort();
     }
     if ((HEAP32[i2 + 12 >> 2] | 0) != (i13 | 0)) {
      _abort();
     }
    }
    if ((i11 | 0) == (i2 | 0)) {
     HEAP32[1790] = HEAP32[1790] & ~(1 << i18);
     i2 = i13;
     i11 = i12;
     break;
    }
    if ((i11 | 0) != (i14 | 0)) {
     if (i11 >>> 0 < i16 >>> 0) {
      _abort();
     }
     i14 = i11 + 8 | 0;
     if ((HEAP32[i14 >> 2] | 0) == (i13 | 0)) {
      i17 = i14;
     } else {
      _abort();
     }
    } else {
     i17 = i11 + 8 | 0;
    }
    HEAP32[i2 + 12 >> 2] = i11;
    HEAP32[i17 >> 2] = i2;
    i2 = i13;
    i11 = i12;
    break;
   }
   i17 = HEAP32[i7 + (i15 + 24) >> 2] | 0;
   i18 = HEAP32[i7 + (i15 + 12) >> 2] | 0;
   do {
    if ((i18 | 0) == (i13 | 0)) {
     i19 = i7 + (i15 + 20) | 0;
     i18 = HEAP32[i19 >> 2] | 0;
     if ((i18 | 0) == 0) {
      i19 = i7 + (i15 + 16) | 0;
      i18 = HEAP32[i19 >> 2] | 0;
      if ((i18 | 0) == 0) {
       i14 = 0;
       break;
      }
     }
     while (1) {
      i21 = i18 + 20 | 0;
      i20 = HEAP32[i21 >> 2] | 0;
      if ((i20 | 0) != 0) {
       i18 = i20;
       i19 = i21;
       continue;
      }
      i20 = i18 + 16 | 0;
      i21 = HEAP32[i20 >> 2] | 0;
      if ((i21 | 0) == 0) {
       break;
      } else {
       i18 = i21;
       i19 = i20;
      }
     }
     if (i19 >>> 0 < i16 >>> 0) {
      _abort();
     } else {
      HEAP32[i19 >> 2] = 0;
      i14 = i18;
      break;
     }
    } else {
     i19 = HEAP32[i7 + (i15 + 8) >> 2] | 0;
     if (i19 >>> 0 < i16 >>> 0) {
      _abort();
     }
     i16 = i19 + 12 | 0;
     if ((HEAP32[i16 >> 2] | 0) != (i13 | 0)) {
      _abort();
     }
     i20 = i18 + 8 | 0;
     if ((HEAP32[i20 >> 2] | 0) == (i13 | 0)) {
      HEAP32[i16 >> 2] = i18;
      HEAP32[i20 >> 2] = i19;
      i14 = i18;
      break;
     } else {
      _abort();
     }
    }
   } while (0);
   if ((i17 | 0) != 0) {
    i18 = HEAP32[i7 + (i15 + 28) >> 2] | 0;
    i16 = 7464 + (i18 << 2) | 0;
    if ((i13 | 0) == (HEAP32[i16 >> 2] | 0)) {
     HEAP32[i16 >> 2] = i14;
     if ((i14 | 0) == 0) {
      HEAP32[7164 >> 2] = HEAP32[7164 >> 2] & ~(1 << i18);
      i2 = i13;
      i11 = i12;
      break;
     }
    } else {
     if (i17 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
      _abort();
     }
     i16 = i17 + 16 | 0;
     if ((HEAP32[i16 >> 2] | 0) == (i13 | 0)) {
      HEAP32[i16 >> 2] = i14;
     } else {
      HEAP32[i17 + 20 >> 2] = i14;
     }
     if ((i14 | 0) == 0) {
      i2 = i13;
      i11 = i12;
      break;
     }
    }
    if (i14 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
     _abort();
    }
    HEAP32[i14 + 24 >> 2] = i17;
    i16 = HEAP32[i7 + (i15 + 16) >> 2] | 0;
    do {
     if ((i16 | 0) != 0) {
      if (i16 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
       _abort();
      } else {
       HEAP32[i14 + 16 >> 2] = i16;
       HEAP32[i16 + 24 >> 2] = i14;
       break;
      }
     }
    } while (0);
    i15 = HEAP32[i7 + (i15 + 20) >> 2] | 0;
    if ((i15 | 0) != 0) {
     if (i15 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
      _abort();
     } else {
      HEAP32[i14 + 20 >> 2] = i15;
      HEAP32[i15 + 24 >> 2] = i14;
      i2 = i13;
      i11 = i12;
      break;
     }
    } else {
     i2 = i13;
     i11 = i12;
    }
   } else {
    i2 = i13;
    i11 = i12;
   }
  } else {
   i2 = i15;
   i11 = i8;
  }
 } while (0);
 if (!(i2 >>> 0 < i6 >>> 0)) {
  _abort();
 }
 i12 = i7 + (i8 + -4) | 0;
 i13 = HEAP32[i12 >> 2] | 0;
 if ((i13 & 1 | 0) == 0) {
  _abort();
 }
 if ((i13 & 2 | 0) == 0) {
  if ((i6 | 0) == (HEAP32[7184 >> 2] | 0)) {
   i21 = (HEAP32[7172 >> 2] | 0) + i11 | 0;
   HEAP32[7172 >> 2] = i21;
   HEAP32[7184 >> 2] = i2;
   HEAP32[i2 + 4 >> 2] = i21 | 1;
   if ((i2 | 0) != (HEAP32[7180 >> 2] | 0)) {
    STACKTOP = i1;
    return;
   }
   HEAP32[7180 >> 2] = 0;
   HEAP32[7168 >> 2] = 0;
   STACKTOP = i1;
   return;
  }
  if ((i6 | 0) == (HEAP32[7180 >> 2] | 0)) {
   i21 = (HEAP32[7168 >> 2] | 0) + i11 | 0;
   HEAP32[7168 >> 2] = i21;
   HEAP32[7180 >> 2] = i2;
   HEAP32[i2 + 4 >> 2] = i21 | 1;
   HEAP32[i2 + i21 >> 2] = i21;
   STACKTOP = i1;
   return;
  }
  i11 = (i13 & -8) + i11 | 0;
  i12 = i13 >>> 3;
  do {
   if (!(i13 >>> 0 < 256)) {
    i10 = HEAP32[i7 + (i8 + 16) >> 2] | 0;
    i15 = HEAP32[i7 + (i8 | 4) >> 2] | 0;
    do {
     if ((i15 | 0) == (i6 | 0)) {
      i13 = i7 + (i8 + 12) | 0;
      i12 = HEAP32[i13 >> 2] | 0;
      if ((i12 | 0) == 0) {
       i13 = i7 + (i8 + 8) | 0;
       i12 = HEAP32[i13 >> 2] | 0;
       if ((i12 | 0) == 0) {
        i9 = 0;
        break;
       }
      }
      while (1) {
       i14 = i12 + 20 | 0;
       i15 = HEAP32[i14 >> 2] | 0;
       if ((i15 | 0) != 0) {
        i12 = i15;
        i13 = i14;
        continue;
       }
       i14 = i12 + 16 | 0;
       i15 = HEAP32[i14 >> 2] | 0;
       if ((i15 | 0) == 0) {
        break;
       } else {
        i12 = i15;
        i13 = i14;
       }
      }
      if (i13 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
       _abort();
      } else {
       HEAP32[i13 >> 2] = 0;
       i9 = i12;
       break;
      }
     } else {
      i13 = HEAP32[i7 + i8 >> 2] | 0;
      if (i13 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
       _abort();
      }
      i14 = i13 + 12 | 0;
      if ((HEAP32[i14 >> 2] | 0) != (i6 | 0)) {
       _abort();
      }
      i12 = i15 + 8 | 0;
      if ((HEAP32[i12 >> 2] | 0) == (i6 | 0)) {
       HEAP32[i14 >> 2] = i15;
       HEAP32[i12 >> 2] = i13;
       i9 = i15;
       break;
      } else {
       _abort();
      }
     }
    } while (0);
    if ((i10 | 0) != 0) {
     i12 = HEAP32[i7 + (i8 + 20) >> 2] | 0;
     i13 = 7464 + (i12 << 2) | 0;
     if ((i6 | 0) == (HEAP32[i13 >> 2] | 0)) {
      HEAP32[i13 >> 2] = i9;
      if ((i9 | 0) == 0) {
       HEAP32[7164 >> 2] = HEAP32[7164 >> 2] & ~(1 << i12);
       break;
      }
     } else {
      if (i10 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
       _abort();
      }
      i12 = i10 + 16 | 0;
      if ((HEAP32[i12 >> 2] | 0) == (i6 | 0)) {
       HEAP32[i12 >> 2] = i9;
      } else {
       HEAP32[i10 + 20 >> 2] = i9;
      }
      if ((i9 | 0) == 0) {
       break;
      }
     }
     if (i9 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
      _abort();
     }
     HEAP32[i9 + 24 >> 2] = i10;
     i6 = HEAP32[i7 + (i8 + 8) >> 2] | 0;
     do {
      if ((i6 | 0) != 0) {
       if (i6 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
        _abort();
       } else {
        HEAP32[i9 + 16 >> 2] = i6;
        HEAP32[i6 + 24 >> 2] = i9;
        break;
       }
      }
     } while (0);
     i6 = HEAP32[i7 + (i8 + 12) >> 2] | 0;
     if ((i6 | 0) != 0) {
      if (i6 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
       _abort();
      } else {
       HEAP32[i9 + 20 >> 2] = i6;
       HEAP32[i6 + 24 >> 2] = i9;
       break;
      }
     }
    }
   } else {
    i9 = HEAP32[i7 + i8 >> 2] | 0;
    i7 = HEAP32[i7 + (i8 | 4) >> 2] | 0;
    i8 = 7200 + (i12 << 1 << 2) | 0;
    if ((i9 | 0) != (i8 | 0)) {
     if (i9 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
      _abort();
     }
     if ((HEAP32[i9 + 12 >> 2] | 0) != (i6 | 0)) {
      _abort();
     }
    }
    if ((i7 | 0) == (i9 | 0)) {
     HEAP32[1790] = HEAP32[1790] & ~(1 << i12);
     break;
    }
    if ((i7 | 0) != (i8 | 0)) {
     if (i7 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
      _abort();
     }
     i8 = i7 + 8 | 0;
     if ((HEAP32[i8 >> 2] | 0) == (i6 | 0)) {
      i10 = i8;
     } else {
      _abort();
     }
    } else {
     i10 = i7 + 8 | 0;
    }
    HEAP32[i9 + 12 >> 2] = i7;
    HEAP32[i10 >> 2] = i9;
   }
  } while (0);
  HEAP32[i2 + 4 >> 2] = i11 | 1;
  HEAP32[i2 + i11 >> 2] = i11;
  if ((i2 | 0) == (HEAP32[7180 >> 2] | 0)) {
   HEAP32[7168 >> 2] = i11;
   STACKTOP = i1;
   return;
  }
 } else {
  HEAP32[i12 >> 2] = i13 & -2;
  HEAP32[i2 + 4 >> 2] = i11 | 1;
  HEAP32[i2 + i11 >> 2] = i11;
 }
 i6 = i11 >>> 3;
 if (i11 >>> 0 < 256) {
  i7 = i6 << 1;
  i3 = 7200 + (i7 << 2) | 0;
  i8 = HEAP32[1790] | 0;
  i6 = 1 << i6;
  if ((i8 & i6 | 0) != 0) {
   i6 = 7200 + (i7 + 2 << 2) | 0;
   i7 = HEAP32[i6 >> 2] | 0;
   if (i7 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
    _abort();
   } else {
    i4 = i6;
    i5 = i7;
   }
  } else {
   HEAP32[1790] = i8 | i6;
   i4 = 7200 + (i7 + 2 << 2) | 0;
   i5 = i3;
  }
  HEAP32[i4 >> 2] = i2;
  HEAP32[i5 + 12 >> 2] = i2;
  HEAP32[i2 + 8 >> 2] = i5;
  HEAP32[i2 + 12 >> 2] = i3;
  STACKTOP = i1;
  return;
 }
 i4 = i11 >>> 8;
 if ((i4 | 0) != 0) {
  if (i11 >>> 0 > 16777215) {
   i4 = 31;
  } else {
   i20 = (i4 + 1048320 | 0) >>> 16 & 8;
   i21 = i4 << i20;
   i19 = (i21 + 520192 | 0) >>> 16 & 4;
   i21 = i21 << i19;
   i4 = (i21 + 245760 | 0) >>> 16 & 2;
   i4 = 14 - (i19 | i20 | i4) + (i21 << i4 >>> 15) | 0;
   i4 = i11 >>> (i4 + 7 | 0) & 1 | i4 << 1;
  }
 } else {
  i4 = 0;
 }
 i5 = 7464 + (i4 << 2) | 0;
 HEAP32[i2 + 28 >> 2] = i4;
 HEAP32[i2 + 20 >> 2] = 0;
 HEAP32[i2 + 16 >> 2] = 0;
 i7 = HEAP32[7164 >> 2] | 0;
 i6 = 1 << i4;
 L199 : do {
  if ((i7 & i6 | 0) != 0) {
   i5 = HEAP32[i5 >> 2] | 0;
   if ((i4 | 0) == 31) {
    i4 = 0;
   } else {
    i4 = 25 - (i4 >>> 1) | 0;
   }
   L204 : do {
    if ((HEAP32[i5 + 4 >> 2] & -8 | 0) != (i11 | 0)) {
     i4 = i11 << i4;
     i7 = i5;
     while (1) {
      i6 = i7 + (i4 >>> 31 << 2) + 16 | 0;
      i5 = HEAP32[i6 >> 2] | 0;
      if ((i5 | 0) == 0) {
       break;
      }
      if ((HEAP32[i5 + 4 >> 2] & -8 | 0) == (i11 | 0)) {
       i3 = i5;
       break L204;
      } else {
       i4 = i4 << 1;
       i7 = i5;
      }
     }
     if (i6 >>> 0 < (HEAP32[7176 >> 2] | 0) >>> 0) {
      _abort();
     } else {
      HEAP32[i6 >> 2] = i2;
      HEAP32[i2 + 24 >> 2] = i7;
      HEAP32[i2 + 12 >> 2] = i2;
      HEAP32[i2 + 8 >> 2] = i2;
      break L199;
     }
    } else {
     i3 = i5;
    }
   } while (0);
   i5 = i3 + 8 | 0;
   i4 = HEAP32[i5 >> 2] | 0;
   i6 = HEAP32[7176 >> 2] | 0;
   if (i3 >>> 0 < i6 >>> 0) {
    _abort();
   }
   if (i4 >>> 0 < i6 >>> 0) {
    _abort();
   } else {
    HEAP32[i4 + 12 >> 2] = i2;
    HEAP32[i5 >> 2] = i2;
    HEAP32[i2 + 8 >> 2] = i4;
    HEAP32[i2 + 12 >> 2] = i3;
    HEAP32[i2 + 24 >> 2] = 0;
    break;
   }
  } else {
   HEAP32[7164 >> 2] = i7 | i6;
   HEAP32[i5 >> 2] = i2;
   HEAP32[i2 + 24 >> 2] = i5;
   HEAP32[i2 + 12 >> 2] = i2;
   HEAP32[i2 + 8 >> 2] = i2;
  }
 } while (0);
 i21 = (HEAP32[7192 >> 2] | 0) + -1 | 0;
 HEAP32[7192 >> 2] = i21;
 if ((i21 | 0) == 0) {
  i2 = 7616 | 0;
 } else {
  STACKTOP = i1;
  return;
 }
 while (1) {
  i2 = HEAP32[i2 >> 2] | 0;
  if ((i2 | 0) == 0) {
   break;
  } else {
   i2 = i2 + 8 | 0;
  }
 }
 HEAP32[7192 >> 2] = -1;
 STACKTOP = i1;
 return;
}
function __ZNSt3__127__insertion_sort_incompleteIRPFbRK6b2PairS3_EPS1_EEbT0_S8_T_(i3, i4, i2) {
 i3 = i3 | 0;
 i4 = i4 | 0;
 i2 = i2 | 0;
 var i1 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0;
 i1 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i7 = i1 + 12 | 0;
 i6 = i1;
 switch ((i4 - i3 | 0) / 12 | 0 | 0) {
 case 5:
  {
   i6 = i3 + 12 | 0;
   i8 = i3 + 24 | 0;
   i5 = i3 + 36 | 0;
   i4 = i4 + -12 | 0;
   __ZNSt3__17__sort4IRPFbRK6b2PairS3_EPS1_EEjT0_S8_S8_S8_T_(i3, i6, i8, i5, i2) | 0;
   if (!(FUNCTION_TABLE_iii[HEAP32[i2 >> 2] & 3](i4, i5) | 0)) {
    i10 = 1;
    STACKTOP = i1;
    return i10 | 0;
   }
   HEAP32[i7 + 0 >> 2] = HEAP32[i5 + 0 >> 2];
   HEAP32[i7 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
   HEAP32[i7 + 8 >> 2] = HEAP32[i5 + 8 >> 2];
   HEAP32[i5 + 0 >> 2] = HEAP32[i4 + 0 >> 2];
   HEAP32[i5 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
   HEAP32[i5 + 8 >> 2] = HEAP32[i4 + 8 >> 2];
   HEAP32[i4 + 0 >> 2] = HEAP32[i7 + 0 >> 2];
   HEAP32[i4 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
   HEAP32[i4 + 8 >> 2] = HEAP32[i7 + 8 >> 2];
   if (!(FUNCTION_TABLE_iii[HEAP32[i2 >> 2] & 3](i5, i8) | 0)) {
    i10 = 1;
    STACKTOP = i1;
    return i10 | 0;
   }
   HEAP32[i7 + 0 >> 2] = HEAP32[i8 + 0 >> 2];
   HEAP32[i7 + 4 >> 2] = HEAP32[i8 + 4 >> 2];
   HEAP32[i7 + 8 >> 2] = HEAP32[i8 + 8 >> 2];
   HEAP32[i8 + 0 >> 2] = HEAP32[i5 + 0 >> 2];
   HEAP32[i8 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
   HEAP32[i8 + 8 >> 2] = HEAP32[i5 + 8 >> 2];
   HEAP32[i5 + 0 >> 2] = HEAP32[i7 + 0 >> 2];
   HEAP32[i5 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
   HEAP32[i5 + 8 >> 2] = HEAP32[i7 + 8 >> 2];
   if (!(FUNCTION_TABLE_iii[HEAP32[i2 >> 2] & 3](i8, i6) | 0)) {
    i10 = 1;
    STACKTOP = i1;
    return i10 | 0;
   }
   HEAP32[i7 + 0 >> 2] = HEAP32[i6 + 0 >> 2];
   HEAP32[i7 + 4 >> 2] = HEAP32[i6 + 4 >> 2];
   HEAP32[i7 + 8 >> 2] = HEAP32[i6 + 8 >> 2];
   HEAP32[i6 + 0 >> 2] = HEAP32[i8 + 0 >> 2];
   HEAP32[i6 + 4 >> 2] = HEAP32[i8 + 4 >> 2];
   HEAP32[i6 + 8 >> 2] = HEAP32[i8 + 8 >> 2];
   HEAP32[i8 + 0 >> 2] = HEAP32[i7 + 0 >> 2];
   HEAP32[i8 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
   HEAP32[i8 + 8 >> 2] = HEAP32[i7 + 8 >> 2];
   if (!(FUNCTION_TABLE_iii[HEAP32[i2 >> 2] & 3](i6, i3) | 0)) {
    i10 = 1;
    STACKTOP = i1;
    return i10 | 0;
   }
   HEAP32[i7 + 0 >> 2] = HEAP32[i3 + 0 >> 2];
   HEAP32[i7 + 4 >> 2] = HEAP32[i3 + 4 >> 2];
   HEAP32[i7 + 8 >> 2] = HEAP32[i3 + 8 >> 2];
   HEAP32[i3 + 0 >> 2] = HEAP32[i6 + 0 >> 2];
   HEAP32[i3 + 4 >> 2] = HEAP32[i6 + 4 >> 2];
   HEAP32[i3 + 8 >> 2] = HEAP32[i6 + 8 >> 2];
   HEAP32[i6 + 0 >> 2] = HEAP32[i7 + 0 >> 2];
   HEAP32[i6 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
   HEAP32[i6 + 8 >> 2] = HEAP32[i7 + 8 >> 2];
   i10 = 1;
   STACKTOP = i1;
   return i10 | 0;
  }
 case 4:
  {
   __ZNSt3__17__sort4IRPFbRK6b2PairS3_EPS1_EEjT0_S8_S8_S8_T_(i3, i3 + 12 | 0, i3 + 24 | 0, i4 + -12 | 0, i2) | 0;
   i10 = 1;
   STACKTOP = i1;
   return i10 | 0;
  }
 case 3:
  {
   i5 = i3 + 12 | 0;
   i4 = i4 + -12 | 0;
   i10 = FUNCTION_TABLE_iii[HEAP32[i2 >> 2] & 3](i5, i3) | 0;
   i6 = FUNCTION_TABLE_iii[HEAP32[i2 >> 2] & 3](i4, i5) | 0;
   if (!i10) {
    if (!i6) {
     i10 = 1;
     STACKTOP = i1;
     return i10 | 0;
    }
    HEAP32[i7 + 0 >> 2] = HEAP32[i5 + 0 >> 2];
    HEAP32[i7 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
    HEAP32[i7 + 8 >> 2] = HEAP32[i5 + 8 >> 2];
    HEAP32[i5 + 0 >> 2] = HEAP32[i4 + 0 >> 2];
    HEAP32[i5 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
    HEAP32[i5 + 8 >> 2] = HEAP32[i4 + 8 >> 2];
    HEAP32[i4 + 0 >> 2] = HEAP32[i7 + 0 >> 2];
    HEAP32[i4 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
    HEAP32[i4 + 8 >> 2] = HEAP32[i7 + 8 >> 2];
    if (!(FUNCTION_TABLE_iii[HEAP32[i2 >> 2] & 3](i5, i3) | 0)) {
     i10 = 1;
     STACKTOP = i1;
     return i10 | 0;
    }
    HEAP32[i7 + 0 >> 2] = HEAP32[i3 + 0 >> 2];
    HEAP32[i7 + 4 >> 2] = HEAP32[i3 + 4 >> 2];
    HEAP32[i7 + 8 >> 2] = HEAP32[i3 + 8 >> 2];
    HEAP32[i3 + 0 >> 2] = HEAP32[i5 + 0 >> 2];
    HEAP32[i3 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
    HEAP32[i3 + 8 >> 2] = HEAP32[i5 + 8 >> 2];
    HEAP32[i5 + 0 >> 2] = HEAP32[i7 + 0 >> 2];
    HEAP32[i5 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
    HEAP32[i5 + 8 >> 2] = HEAP32[i7 + 8 >> 2];
    i10 = 1;
    STACKTOP = i1;
    return i10 | 0;
   }
   if (i6) {
    HEAP32[i7 + 0 >> 2] = HEAP32[i3 + 0 >> 2];
    HEAP32[i7 + 4 >> 2] = HEAP32[i3 + 4 >> 2];
    HEAP32[i7 + 8 >> 2] = HEAP32[i3 + 8 >> 2];
    HEAP32[i3 + 0 >> 2] = HEAP32[i4 + 0 >> 2];
    HEAP32[i3 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
    HEAP32[i3 + 8 >> 2] = HEAP32[i4 + 8 >> 2];
    HEAP32[i4 + 0 >> 2] = HEAP32[i7 + 0 >> 2];
    HEAP32[i4 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
    HEAP32[i4 + 8 >> 2] = HEAP32[i7 + 8 >> 2];
    i10 = 1;
    STACKTOP = i1;
    return i10 | 0;
   }
   HEAP32[i7 + 0 >> 2] = HEAP32[i3 + 0 >> 2];
   HEAP32[i7 + 4 >> 2] = HEAP32[i3 + 4 >> 2];
   HEAP32[i7 + 8 >> 2] = HEAP32[i3 + 8 >> 2];
   HEAP32[i3 + 0 >> 2] = HEAP32[i5 + 0 >> 2];
   HEAP32[i3 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
   HEAP32[i3 + 8 >> 2] = HEAP32[i5 + 8 >> 2];
   HEAP32[i5 + 0 >> 2] = HEAP32[i7 + 0 >> 2];
   HEAP32[i5 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
   HEAP32[i5 + 8 >> 2] = HEAP32[i7 + 8 >> 2];
   if (!(FUNCTION_TABLE_iii[HEAP32[i2 >> 2] & 3](i4, i5) | 0)) {
    i10 = 1;
    STACKTOP = i1;
    return i10 | 0;
   }
   HEAP32[i7 + 0 >> 2] = HEAP32[i5 + 0 >> 2];
   HEAP32[i7 + 4 >> 2] = HEAP32[i5 + 4 >> 2];
   HEAP32[i7 + 8 >> 2] = HEAP32[i5 + 8 >> 2];
   HEAP32[i5 + 0 >> 2] = HEAP32[i4 + 0 >> 2];
   HEAP32[i5 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
   HEAP32[i5 + 8 >> 2] = HEAP32[i4 + 8 >> 2];
   HEAP32[i4 + 0 >> 2] = HEAP32[i7 + 0 >> 2];
   HEAP32[i4 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
   HEAP32[i4 + 8 >> 2] = HEAP32[i7 + 8 >> 2];
   i10 = 1;
   STACKTOP = i1;
   return i10 | 0;
  }
 case 2:
  {
   i4 = i4 + -12 | 0;
   if (!(FUNCTION_TABLE_iii[HEAP32[i2 >> 2] & 3](i4, i3) | 0)) {
    i10 = 1;
    STACKTOP = i1;
    return i10 | 0;
   }
   HEAP32[i7 + 0 >> 2] = HEAP32[i3 + 0 >> 2];
   HEAP32[i7 + 4 >> 2] = HEAP32[i3 + 4 >> 2];
   HEAP32[i7 + 8 >> 2] = HEAP32[i3 + 8 >> 2];
   HEAP32[i3 + 0 >> 2] = HEAP32[i4 + 0 >> 2];
   HEAP32[i3 + 4 >> 2] = HEAP32[i4 + 4 >> 2];
   HEAP32[i3 + 8 >> 2] = HEAP32[i4 + 8 >> 2];
   HEAP32[i4 + 0 >> 2] = HEAP32[i7 + 0 >> 2];
   HEAP32[i4 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
   HEAP32[i4 + 8 >> 2] = HEAP32[i7 + 8 >> 2];
   i10 = 1;
   STACKTOP = i1;
   return i10 | 0;
  }
 case 1:
 case 0:
  {
   i10 = 1;
   STACKTOP = i1;
   return i10 | 0;
  }
 default:
  {
   i9 = i3 + 24 | 0;
   i10 = i3 + 12 | 0;
   i11 = FUNCTION_TABLE_iii[HEAP32[i2 >> 2] & 3](i10, i3) | 0;
   i8 = FUNCTION_TABLE_iii[HEAP32[i2 >> 2] & 3](i9, i10) | 0;
   do {
    if (i11) {
     if (i8) {
      HEAP32[i7 + 0 >> 2] = HEAP32[i3 + 0 >> 2];
      HEAP32[i7 + 4 >> 2] = HEAP32[i3 + 4 >> 2];
      HEAP32[i7 + 8 >> 2] = HEAP32[i3 + 8 >> 2];
      HEAP32[i3 + 0 >> 2] = HEAP32[i9 + 0 >> 2];
      HEAP32[i3 + 4 >> 2] = HEAP32[i9 + 4 >> 2];
      HEAP32[i3 + 8 >> 2] = HEAP32[i9 + 8 >> 2];
      HEAP32[i9 + 0 >> 2] = HEAP32[i7 + 0 >> 2];
      HEAP32[i9 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
      HEAP32[i9 + 8 >> 2] = HEAP32[i7 + 8 >> 2];
      break;
     }
     HEAP32[i7 + 0 >> 2] = HEAP32[i3 + 0 >> 2];
     HEAP32[i7 + 4 >> 2] = HEAP32[i3 + 4 >> 2];
     HEAP32[i7 + 8 >> 2] = HEAP32[i3 + 8 >> 2];
     HEAP32[i3 + 0 >> 2] = HEAP32[i10 + 0 >> 2];
     HEAP32[i3 + 4 >> 2] = HEAP32[i10 + 4 >> 2];
     HEAP32[i3 + 8 >> 2] = HEAP32[i10 + 8 >> 2];
     HEAP32[i10 + 0 >> 2] = HEAP32[i7 + 0 >> 2];
     HEAP32[i10 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
     HEAP32[i10 + 8 >> 2] = HEAP32[i7 + 8 >> 2];
     if (FUNCTION_TABLE_iii[HEAP32[i2 >> 2] & 3](i9, i10) | 0) {
      HEAP32[i7 + 0 >> 2] = HEAP32[i10 + 0 >> 2];
      HEAP32[i7 + 4 >> 2] = HEAP32[i10 + 4 >> 2];
      HEAP32[i7 + 8 >> 2] = HEAP32[i10 + 8 >> 2];
      HEAP32[i10 + 0 >> 2] = HEAP32[i9 + 0 >> 2];
      HEAP32[i10 + 4 >> 2] = HEAP32[i9 + 4 >> 2];
      HEAP32[i10 + 8 >> 2] = HEAP32[i9 + 8 >> 2];
      HEAP32[i9 + 0 >> 2] = HEAP32[i7 + 0 >> 2];
      HEAP32[i9 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
      HEAP32[i9 + 8 >> 2] = HEAP32[i7 + 8 >> 2];
     }
    } else {
     if (i8) {
      HEAP32[i7 + 0 >> 2] = HEAP32[i10 + 0 >> 2];
      HEAP32[i7 + 4 >> 2] = HEAP32[i10 + 4 >> 2];
      HEAP32[i7 + 8 >> 2] = HEAP32[i10 + 8 >> 2];
      HEAP32[i10 + 0 >> 2] = HEAP32[i9 + 0 >> 2];
      HEAP32[i10 + 4 >> 2] = HEAP32[i9 + 4 >> 2];
      HEAP32[i10 + 8 >> 2] = HEAP32[i9 + 8 >> 2];
      HEAP32[i9 + 0 >> 2] = HEAP32[i7 + 0 >> 2];
      HEAP32[i9 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
      HEAP32[i9 + 8 >> 2] = HEAP32[i7 + 8 >> 2];
      if (FUNCTION_TABLE_iii[HEAP32[i2 >> 2] & 3](i10, i3) | 0) {
       HEAP32[i7 + 0 >> 2] = HEAP32[i3 + 0 >> 2];
       HEAP32[i7 + 4 >> 2] = HEAP32[i3 + 4 >> 2];
       HEAP32[i7 + 8 >> 2] = HEAP32[i3 + 8 >> 2];
       HEAP32[i3 + 0 >> 2] = HEAP32[i10 + 0 >> 2];
       HEAP32[i3 + 4 >> 2] = HEAP32[i10 + 4 >> 2];
       HEAP32[i3 + 8 >> 2] = HEAP32[i10 + 8 >> 2];
       HEAP32[i10 + 0 >> 2] = HEAP32[i7 + 0 >> 2];
       HEAP32[i10 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
       HEAP32[i10 + 8 >> 2] = HEAP32[i7 + 8 >> 2];
      }
     }
    }
   } while (0);
   i7 = i3 + 36 | 0;
   if ((i7 | 0) == (i4 | 0)) {
    i11 = 1;
    STACKTOP = i1;
    return i11 | 0;
   }
   i8 = 0;
   while (1) {
    if (FUNCTION_TABLE_iii[HEAP32[i2 >> 2] & 3](i7, i9) | 0) {
     HEAP32[i6 + 0 >> 2] = HEAP32[i7 + 0 >> 2];
     HEAP32[i6 + 4 >> 2] = HEAP32[i7 + 4 >> 2];
     HEAP32[i6 + 8 >> 2] = HEAP32[i7 + 8 >> 2];
     i10 = i7;
     while (1) {
      HEAP32[i10 + 0 >> 2] = HEAP32[i9 + 0 >> 2];
      HEAP32[i10 + 4 >> 2] = HEAP32[i9 + 4 >> 2];
      HEAP32[i10 + 8 >> 2] = HEAP32[i9 + 8 >> 2];
      if ((i9 | 0) == (i3 | 0)) {
       break;
      }
      i10 = i9 + -12 | 0;
      if (FUNCTION_TABLE_iii[HEAP32[i2 >> 2] & 3](i6, i10) | 0) {
       i11 = i9;
       i9 = i10;
       i10 = i11;
      } else {
       break;
      }
     }
     HEAP32[i9 + 0 >> 2] = HEAP32[i6 + 0 >> 2];
     HEAP32[i9 + 4 >> 2] = HEAP32[i6 + 4 >> 2];
     HEAP32[i9 + 8 >> 2] = HEAP32[i6 + 8 >> 2];
     i8 = i8 + 1 | 0;
     if ((i8 | 0) == 8) {
      break;
     }
    }
    i9 = i7 + 12 | 0;
    if ((i9 | 0) == (i4 | 0)) {
     i2 = 1;
     i5 = 35;
     break;
    } else {
     i11 = i7;
     i7 = i9;
     i9 = i11;
    }
   }
   if ((i5 | 0) == 35) {
    STACKTOP = i1;
    return i2 | 0;
   }
   i11 = (i7 + 12 | 0) == (i4 | 0);
   STACKTOP = i1;
   return i11 | 0;
  }
 }
 return 0;
}
function __ZN13b2DynamicTree7BalanceEi(i11, i6) {
 i11 = i11 | 0;
 i6 = i6 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, d19 = 0.0, i20 = 0, i21 = 0, d22 = 0.0, d23 = 0.0, d24 = 0.0, d25 = 0.0;
 i1 = STACKTOP;
 if ((i6 | 0) == -1) {
  ___assert_fail(3216, 2944, 382, 3232);
 }
 i5 = HEAP32[i11 + 4 >> 2] | 0;
 i13 = i5 + (i6 * 36 | 0) | 0;
 i18 = i5 + (i6 * 36 | 0) + 24 | 0;
 i8 = HEAP32[i18 >> 2] | 0;
 if ((i8 | 0) == -1) {
  i21 = i6;
  STACKTOP = i1;
  return i21 | 0;
 }
 i2 = i5 + (i6 * 36 | 0) + 32 | 0;
 if ((HEAP32[i2 >> 2] | 0) < 2) {
  i21 = i6;
  STACKTOP = i1;
  return i21 | 0;
 }
 i20 = i5 + (i6 * 36 | 0) + 28 | 0;
 i7 = HEAP32[i20 >> 2] | 0;
 if (!((i8 | 0) > -1)) {
  ___assert_fail(3240, 2944, 392, 3232);
 }
 i12 = HEAP32[i11 + 12 >> 2] | 0;
 if ((i8 | 0) >= (i12 | 0)) {
  ___assert_fail(3240, 2944, 392, 3232);
 }
 if (!((i7 | 0) > -1 & (i7 | 0) < (i12 | 0))) {
  ___assert_fail(3272, 2944, 393, 3232);
 }
 i9 = i5 + (i8 * 36 | 0) | 0;
 i10 = i5 + (i7 * 36 | 0) | 0;
 i3 = i5 + (i7 * 36 | 0) + 32 | 0;
 i4 = i5 + (i8 * 36 | 0) + 32 | 0;
 i14 = (HEAP32[i3 >> 2] | 0) - (HEAP32[i4 >> 2] | 0) | 0;
 if ((i14 | 0) > 1) {
  i21 = i5 + (i7 * 36 | 0) + 24 | 0;
  i14 = HEAP32[i21 >> 2] | 0;
  i18 = i5 + (i7 * 36 | 0) + 28 | 0;
  i15 = HEAP32[i18 >> 2] | 0;
  i16 = i5 + (i14 * 36 | 0) | 0;
  i17 = i5 + (i15 * 36 | 0) | 0;
  if (!((i14 | 0) > -1 & (i14 | 0) < (i12 | 0))) {
   ___assert_fail(3304, 2944, 407, 3232);
  }
  if (!((i15 | 0) > -1 & (i15 | 0) < (i12 | 0))) {
   ___assert_fail(3336, 2944, 408, 3232);
  }
  HEAP32[i21 >> 2] = i6;
  i21 = i5 + (i6 * 36 | 0) + 20 | 0;
  i12 = i5 + (i7 * 36 | 0) + 20 | 0;
  HEAP32[i12 >> 2] = HEAP32[i21 >> 2];
  HEAP32[i21 >> 2] = i7;
  i12 = HEAP32[i12 >> 2] | 0;
  do {
   if (!((i12 | 0) == -1)) {
    i11 = i5 + (i12 * 36 | 0) + 24 | 0;
    if ((HEAP32[i11 >> 2] | 0) == (i6 | 0)) {
     HEAP32[i11 >> 2] = i7;
     break;
    }
    i11 = i5 + (i12 * 36 | 0) + 28 | 0;
    if ((HEAP32[i11 >> 2] | 0) == (i6 | 0)) {
     HEAP32[i11 >> 2] = i7;
     break;
    } else {
     ___assert_fail(3368, 2944, 424, 3232);
    }
   } else {
    HEAP32[i11 >> 2] = i7;
   }
  } while (0);
  i11 = i5 + (i14 * 36 | 0) + 32 | 0;
  i12 = i5 + (i15 * 36 | 0) + 32 | 0;
  if ((HEAP32[i11 >> 2] | 0) > (HEAP32[i12 >> 2] | 0)) {
   HEAP32[i18 >> 2] = i14;
   HEAP32[i20 >> 2] = i15;
   HEAP32[i5 + (i15 * 36 | 0) + 20 >> 2] = i6;
   d19 = +HEAPF32[i9 >> 2];
   d22 = +HEAPF32[i17 >> 2];
   d19 = d19 < d22 ? d19 : d22;
   d23 = +HEAPF32[i5 + (i8 * 36 | 0) + 4 >> 2];
   d22 = +HEAPF32[i5 + (i15 * 36 | 0) + 4 >> 2];
   d24 = +d19;
   d23 = +(d23 < d22 ? d23 : d22);
   i21 = i13;
   HEAPF32[i21 >> 2] = d24;
   HEAPF32[i21 + 4 >> 2] = d23;
   d23 = +HEAPF32[i5 + (i8 * 36 | 0) + 8 >> 2];
   d24 = +HEAPF32[i5 + (i15 * 36 | 0) + 8 >> 2];
   d22 = +HEAPF32[i5 + (i8 * 36 | 0) + 12 >> 2];
   d25 = +HEAPF32[i5 + (i15 * 36 | 0) + 12 >> 2];
   d23 = +(d23 > d24 ? d23 : d24);
   d24 = +(d22 > d25 ? d22 : d25);
   i21 = i5 + (i6 * 36 | 0) + 8 | 0;
   HEAPF32[i21 >> 2] = d23;
   HEAPF32[i21 + 4 >> 2] = d24;
   d24 = +HEAPF32[i16 >> 2];
   d22 = +HEAPF32[i5 + (i6 * 36 | 0) + 4 >> 2];
   d23 = +HEAPF32[i5 + (i14 * 36 | 0) + 4 >> 2];
   d19 = +(d19 < d24 ? d19 : d24);
   d22 = +(d22 < d23 ? d22 : d23);
   i21 = i10;
   HEAPF32[i21 >> 2] = d19;
   HEAPF32[i21 + 4 >> 2] = d22;
   d22 = +HEAPF32[i5 + (i6 * 36 | 0) + 8 >> 2];
   d19 = +HEAPF32[i5 + (i14 * 36 | 0) + 8 >> 2];
   d23 = +HEAPF32[i5 + (i6 * 36 | 0) + 12 >> 2];
   d24 = +HEAPF32[i5 + (i14 * 36 | 0) + 12 >> 2];
   d19 = +(d22 > d19 ? d22 : d19);
   d25 = +(d23 > d24 ? d23 : d24);
   i5 = i5 + (i7 * 36 | 0) + 8 | 0;
   HEAPF32[i5 >> 2] = d19;
   HEAPF32[i5 + 4 >> 2] = d25;
   i4 = HEAP32[i4 >> 2] | 0;
   i5 = HEAP32[i12 >> 2] | 0;
   i4 = ((i4 | 0) > (i5 | 0) ? i4 : i5) + 1 | 0;
   HEAP32[i2 >> 2] = i4;
   i2 = HEAP32[i11 >> 2] | 0;
   i2 = (i4 | 0) > (i2 | 0) ? i4 : i2;
  } else {
   HEAP32[i18 >> 2] = i15;
   HEAP32[i20 >> 2] = i14;
   HEAP32[i5 + (i14 * 36 | 0) + 20 >> 2] = i6;
   d19 = +HEAPF32[i9 >> 2];
   d22 = +HEAPF32[i16 >> 2];
   d19 = d19 < d22 ? d19 : d22;
   d23 = +HEAPF32[i5 + (i8 * 36 | 0) + 4 >> 2];
   d24 = +HEAPF32[i5 + (i14 * 36 | 0) + 4 >> 2];
   d22 = +d19;
   d23 = +(d23 < d24 ? d23 : d24);
   i21 = i13;
   HEAPF32[i21 >> 2] = d22;
   HEAPF32[i21 + 4 >> 2] = d23;
   d23 = +HEAPF32[i5 + (i8 * 36 | 0) + 8 >> 2];
   d24 = +HEAPF32[i5 + (i14 * 36 | 0) + 8 >> 2];
   d22 = +HEAPF32[i5 + (i8 * 36 | 0) + 12 >> 2];
   d25 = +HEAPF32[i5 + (i14 * 36 | 0) + 12 >> 2];
   d23 = +(d23 > d24 ? d23 : d24);
   d24 = +(d22 > d25 ? d22 : d25);
   i21 = i5 + (i6 * 36 | 0) + 8 | 0;
   HEAPF32[i21 >> 2] = d23;
   HEAPF32[i21 + 4 >> 2] = d24;
   d24 = +HEAPF32[i17 >> 2];
   d22 = +HEAPF32[i5 + (i6 * 36 | 0) + 4 >> 2];
   d23 = +HEAPF32[i5 + (i15 * 36 | 0) + 4 >> 2];
   d19 = +(d19 < d24 ? d19 : d24);
   d23 = +(d22 < d23 ? d22 : d23);
   i21 = i10;
   HEAPF32[i21 >> 2] = d19;
   HEAPF32[i21 + 4 >> 2] = d23;
   d23 = +HEAPF32[i5 + (i6 * 36 | 0) + 8 >> 2];
   d19 = +HEAPF32[i5 + (i15 * 36 | 0) + 8 >> 2];
   d22 = +HEAPF32[i5 + (i6 * 36 | 0) + 12 >> 2];
   d24 = +HEAPF32[i5 + (i15 * 36 | 0) + 12 >> 2];
   d19 = +(d23 > d19 ? d23 : d19);
   d25 = +(d22 > d24 ? d22 : d24);
   i5 = i5 + (i7 * 36 | 0) + 8 | 0;
   HEAPF32[i5 >> 2] = d19;
   HEAPF32[i5 + 4 >> 2] = d25;
   i4 = HEAP32[i4 >> 2] | 0;
   i5 = HEAP32[i11 >> 2] | 0;
   i4 = ((i4 | 0) > (i5 | 0) ? i4 : i5) + 1 | 0;
   HEAP32[i2 >> 2] = i4;
   i2 = HEAP32[i12 >> 2] | 0;
   i2 = (i4 | 0) > (i2 | 0) ? i4 : i2;
  }
  HEAP32[i3 >> 2] = i2 + 1;
  i21 = i7;
  STACKTOP = i1;
  return i21 | 0;
 }
 if (!((i14 | 0) < -1)) {
  i21 = i6;
  STACKTOP = i1;
  return i21 | 0;
 }
 i21 = i5 + (i8 * 36 | 0) + 24 | 0;
 i14 = HEAP32[i21 >> 2] | 0;
 i20 = i5 + (i8 * 36 | 0) + 28 | 0;
 i15 = HEAP32[i20 >> 2] | 0;
 i17 = i5 + (i14 * 36 | 0) | 0;
 i16 = i5 + (i15 * 36 | 0) | 0;
 if (!((i14 | 0) > -1 & (i14 | 0) < (i12 | 0))) {
  ___assert_fail(3400, 2944, 467, 3232);
 }
 if (!((i15 | 0) > -1 & (i15 | 0) < (i12 | 0))) {
  ___assert_fail(3432, 2944, 468, 3232);
 }
 HEAP32[i21 >> 2] = i6;
 i21 = i5 + (i6 * 36 | 0) + 20 | 0;
 i12 = i5 + (i8 * 36 | 0) + 20 | 0;
 HEAP32[i12 >> 2] = HEAP32[i21 >> 2];
 HEAP32[i21 >> 2] = i8;
 i12 = HEAP32[i12 >> 2] | 0;
 do {
  if (!((i12 | 0) == -1)) {
   i11 = i5 + (i12 * 36 | 0) + 24 | 0;
   if ((HEAP32[i11 >> 2] | 0) == (i6 | 0)) {
    HEAP32[i11 >> 2] = i8;
    break;
   }
   i11 = i5 + (i12 * 36 | 0) + 28 | 0;
   if ((HEAP32[i11 >> 2] | 0) == (i6 | 0)) {
    HEAP32[i11 >> 2] = i8;
    break;
   } else {
    ___assert_fail(3464, 2944, 484, 3232);
   }
  } else {
   HEAP32[i11 >> 2] = i8;
  }
 } while (0);
 i12 = i5 + (i14 * 36 | 0) + 32 | 0;
 i11 = i5 + (i15 * 36 | 0) + 32 | 0;
 if ((HEAP32[i12 >> 2] | 0) > (HEAP32[i11 >> 2] | 0)) {
  HEAP32[i20 >> 2] = i14;
  HEAP32[i18 >> 2] = i15;
  HEAP32[i5 + (i15 * 36 | 0) + 20 >> 2] = i6;
  d19 = +HEAPF32[i10 >> 2];
  d22 = +HEAPF32[i16 >> 2];
  d19 = d19 < d22 ? d19 : d22;
  d23 = +HEAPF32[i5 + (i7 * 36 | 0) + 4 >> 2];
  d22 = +HEAPF32[i5 + (i15 * 36 | 0) + 4 >> 2];
  d24 = +d19;
  d23 = +(d23 < d22 ? d23 : d22);
  i21 = i13;
  HEAPF32[i21 >> 2] = d24;
  HEAPF32[i21 + 4 >> 2] = d23;
  d23 = +HEAPF32[i5 + (i7 * 36 | 0) + 8 >> 2];
  d22 = +HEAPF32[i5 + (i15 * 36 | 0) + 8 >> 2];
  d24 = +HEAPF32[i5 + (i7 * 36 | 0) + 12 >> 2];
  d25 = +HEAPF32[i5 + (i15 * 36 | 0) + 12 >> 2];
  d22 = +(d23 > d22 ? d23 : d22);
  d24 = +(d24 > d25 ? d24 : d25);
  i21 = i5 + (i6 * 36 | 0) + 8 | 0;
  HEAPF32[i21 >> 2] = d22;
  HEAPF32[i21 + 4 >> 2] = d24;
  d24 = +HEAPF32[i17 >> 2];
  d23 = +HEAPF32[i5 + (i6 * 36 | 0) + 4 >> 2];
  d22 = +HEAPF32[i5 + (i14 * 36 | 0) + 4 >> 2];
  d19 = +(d19 < d24 ? d19 : d24);
  d22 = +(d23 < d22 ? d23 : d22);
  i21 = i9;
  HEAPF32[i21 >> 2] = d19;
  HEAPF32[i21 + 4 >> 2] = d22;
  d22 = +HEAPF32[i5 + (i6 * 36 | 0) + 8 >> 2];
  d23 = +HEAPF32[i5 + (i14 * 36 | 0) + 8 >> 2];
  d19 = +HEAPF32[i5 + (i6 * 36 | 0) + 12 >> 2];
  d24 = +HEAPF32[i5 + (i14 * 36 | 0) + 12 >> 2];
  d22 = +(d22 > d23 ? d22 : d23);
  d25 = +(d19 > d24 ? d19 : d24);
  i5 = i5 + (i8 * 36 | 0) + 8 | 0;
  HEAPF32[i5 >> 2] = d22;
  HEAPF32[i5 + 4 >> 2] = d25;
  i3 = HEAP32[i3 >> 2] | 0;
  i5 = HEAP32[i11 >> 2] | 0;
  i3 = ((i3 | 0) > (i5 | 0) ? i3 : i5) + 1 | 0;
  HEAP32[i2 >> 2] = i3;
  i2 = HEAP32[i12 >> 2] | 0;
  i2 = (i3 | 0) > (i2 | 0) ? i3 : i2;
 } else {
  HEAP32[i20 >> 2] = i15;
  HEAP32[i18 >> 2] = i14;
  HEAP32[i5 + (i14 * 36 | 0) + 20 >> 2] = i6;
  d19 = +HEAPF32[i10 >> 2];
  d22 = +HEAPF32[i17 >> 2];
  d19 = d19 < d22 ? d19 : d22;
  d23 = +HEAPF32[i5 + (i7 * 36 | 0) + 4 >> 2];
  d24 = +HEAPF32[i5 + (i14 * 36 | 0) + 4 >> 2];
  d22 = +d19;
  d24 = +(d23 < d24 ? d23 : d24);
  i21 = i13;
  HEAPF32[i21 >> 2] = d22;
  HEAPF32[i21 + 4 >> 2] = d24;
  d24 = +HEAPF32[i5 + (i7 * 36 | 0) + 8 >> 2];
  d23 = +HEAPF32[i5 + (i14 * 36 | 0) + 8 >> 2];
  d22 = +HEAPF32[i5 + (i7 * 36 | 0) + 12 >> 2];
  d25 = +HEAPF32[i5 + (i14 * 36 | 0) + 12 >> 2];
  d23 = +(d24 > d23 ? d24 : d23);
  d24 = +(d22 > d25 ? d22 : d25);
  i21 = i5 + (i6 * 36 | 0) + 8 | 0;
  HEAPF32[i21 >> 2] = d23;
  HEAPF32[i21 + 4 >> 2] = d24;
  d24 = +HEAPF32[i16 >> 2];
  d23 = +HEAPF32[i5 + (i6 * 36 | 0) + 4 >> 2];
  d22 = +HEAPF32[i5 + (i15 * 36 | 0) + 4 >> 2];
  d19 = +(d19 < d24 ? d19 : d24);
  d22 = +(d23 < d22 ? d23 : d22);
  i21 = i9;
  HEAPF32[i21 >> 2] = d19;
  HEAPF32[i21 + 4 >> 2] = d22;
  d22 = +HEAPF32[i5 + (i6 * 36 | 0) + 8 >> 2];
  d23 = +HEAPF32[i5 + (i15 * 36 | 0) + 8 >> 2];
  d19 = +HEAPF32[i5 + (i6 * 36 | 0) + 12 >> 2];
  d24 = +HEAPF32[i5 + (i15 * 36 | 0) + 12 >> 2];
  d22 = +(d22 > d23 ? d22 : d23);
  d25 = +(d19 > d24 ? d19 : d24);
  i5 = i5 + (i8 * 36 | 0) + 8 | 0;
  HEAPF32[i5 >> 2] = d22;
  HEAPF32[i5 + 4 >> 2] = d25;
  i3 = HEAP32[i3 >> 2] | 0;
  i5 = HEAP32[i12 >> 2] | 0;
  i3 = ((i3 | 0) > (i5 | 0) ? i3 : i5) + 1 | 0;
  HEAP32[i2 >> 2] = i3;
  i2 = HEAP32[i11 >> 2] | 0;
  i2 = (i3 | 0) > (i2 | 0) ? i3 : i2;
 }
 HEAP32[i4 >> 2] = i2 + 1;
 i21 = i8;
 STACKTOP = i1;
 return i21 | 0;
}
function __Z10b2DistanceP16b2DistanceOutputP14b2SimplexCachePK15b2DistanceInput(i2, i5, i3) {
 i2 = i2 | 0;
 i5 = i5 | 0;
 i3 = i3 | 0;
 var i1 = 0, i4 = 0, i6 = 0, d7 = 0.0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, d16 = 0.0, d17 = 0.0, d18 = 0.0, d19 = 0.0, i20 = 0, d21 = 0.0, d22 = 0.0, i23 = 0, d24 = 0.0, d25 = 0.0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, d36 = 0.0, d37 = 0.0, d38 = 0.0, i39 = 0, i40 = 0, i41 = 0, i42 = 0, d43 = 0.0, d44 = 0.0, d45 = 0.0, i46 = 0;
 i1 = STACKTOP;
 STACKTOP = STACKTOP + 176 | 0;
 i11 = i1 + 152 | 0;
 i10 = i1 + 136 | 0;
 i4 = i1 + 24 | 0;
 i14 = i1 + 12 | 0;
 i15 = i1;
 HEAP32[652] = (HEAP32[652] | 0) + 1;
 i9 = i3 + 28 | 0;
 i31 = i3 + 56 | 0;
 HEAP32[i11 + 0 >> 2] = HEAP32[i31 + 0 >> 2];
 HEAP32[i11 + 4 >> 2] = HEAP32[i31 + 4 >> 2];
 HEAP32[i11 + 8 >> 2] = HEAP32[i31 + 8 >> 2];
 HEAP32[i11 + 12 >> 2] = HEAP32[i31 + 12 >> 2];
 i31 = i3 + 72 | 0;
 HEAP32[i10 + 0 >> 2] = HEAP32[i31 + 0 >> 2];
 HEAP32[i10 + 4 >> 2] = HEAP32[i31 + 4 >> 2];
 HEAP32[i10 + 8 >> 2] = HEAP32[i31 + 8 >> 2];
 HEAP32[i10 + 12 >> 2] = HEAP32[i31 + 12 >> 2];
 __ZN9b2Simplex9ReadCacheEPK14b2SimplexCachePK15b2DistanceProxyRK11b2TransformS5_S8_(i4, i5, i3, i11, i9, i10);
 i9 = i4 + 108 | 0;
 i31 = HEAP32[i9 >> 2] | 0;
 if ((i31 | 0) == 3 | (i31 | 0) == 2 | (i31 | 0) == 1) {
  i8 = i4 + 16 | 0;
  i6 = i4 + 20 | 0;
  d17 = +HEAPF32[i11 + 12 >> 2];
  d18 = +HEAPF32[i11 + 8 >> 2];
  i13 = i3 + 16 | 0;
  i12 = i3 + 20 | 0;
  d16 = +HEAPF32[i11 >> 2];
  d21 = +HEAPF32[i11 + 4 >> 2];
  d19 = +HEAPF32[i10 + 12 >> 2];
  d22 = +HEAPF32[i10 + 8 >> 2];
  i23 = i3 + 44 | 0;
  i20 = i3 + 48 | 0;
  d24 = +HEAPF32[i10 >> 2];
  d25 = +HEAPF32[i10 + 4 >> 2];
  i11 = i4 + 52 | 0;
  i10 = i4 + 56 | 0;
  i30 = i4 + 16 | 0;
  i27 = i4 + 36 | 0;
  i26 = i4 + 52 | 0;
  i29 = i4 + 24 | 0;
  i28 = i4 + 60 | 0;
  i33 = 0;
  L3 : while (1) {
   i32 = (i31 | 0) > 0;
   if (i32) {
    i34 = 0;
    do {
     HEAP32[i14 + (i34 << 2) >> 2] = HEAP32[i4 + (i34 * 36 | 0) + 28 >> 2];
     HEAP32[i15 + (i34 << 2) >> 2] = HEAP32[i4 + (i34 * 36 | 0) + 32 >> 2];
     i34 = i34 + 1 | 0;
    } while ((i34 | 0) != (i31 | 0));
   }
   do {
    if ((i31 | 0) == 2) {
     i46 = i30;
     d45 = +HEAPF32[i46 >> 2];
