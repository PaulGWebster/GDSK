S.root.mount);
        var completed = 0;

        function done(err) {
          if (err) {
            if (!done.errored) {
              done.errored = true;
              return callback(err);
            }
            return;
          }
          if (++completed >= mounts.length) {
            callback(null);
          }
        };

        // sync all mounts
        mounts.forEach(function (mount) {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },mount:function (type, opts, mountpoint) {
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;

        if (root && FS.root) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });

          mountpoint = lookup.path;  // use the absolute path
          node = lookup.node;

          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
          }

          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
          }
        }

        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: []
        };

        // create a root node for the fs
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;

        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          // set as a mountpoint
          node.mounted = mount;

          // add the new mount to the current mount's children
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }

        return mountRoot;
      },unmount:function (mountpoint) {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });

        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }

        // destroy the nodes for this mount, and all its child mounts
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);

        Object.keys(FS.nameTable).forEach(function (hash) {
          var current = FS.nameTable[hash];

          while (current) {
            var next = current.name_next;

            if (mounts.indexOf(current.mount) !== -1) {
              FS.destroyNode(current);
            }

            current = next;
          }
        });

        // no longer a mountpoint
        node.mounted = null;

        // remove this mount from the child mounts
        var idx = node.mount.mounts.indexOf(mount);
        assert(idx !== -1);
        node.mount.mounts.splice(idx, 1);
      },lookup:function (parent, name) {
        return parent.node_ops.lookup(parent, name);
      },mknod:function (path, mode, dev) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var err = FS.mayCreate(parent, name);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },create:function (path, mode) {
        mode = mode !== undefined ? mode : 438 /* 0666 */;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },mkdir:function (path, mode) {
        mode = mode !== undefined ? mode : 511 /* 0777 */;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },mkdev:function (path, mode, dev) {
        if (typeof(dev) === 'undefined') {
          dev = mode;
          mode = 438 /* 0666 */;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },symlink:function (oldpath, newpath) {
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        var newname = PATH.basename(newpath);
        var err = FS.mayCreate(parent, newname);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },rename:function (old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;
        try {
          lookup = FS.lookupPath(old_path, { parent: true });
          old_dir = lookup.node;
          lookup = FS.lookupPath(new_path, { parent: true });
          new_dir = lookup.node;
        } catch (e) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(ERRNO_CODES.EXDEV);
        }
        // source must exist
        var old_node = FS.lookupNode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = PATH.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        // new path should not be an ancestor of the old path
        relative = PATH.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = FS.isDir(old_node.mode);
        var err = FS.mayDelete(old_dir, old_name, isdir);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        err = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          err = FS.nodePermissions(old_dir, 'w');
          if (err) {
            throw new FS.ErrnoError(err);
          }
        }
        // remove the node from the lookup hash
        FS.hashRemoveNode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          FS.hashAddNode(old_node);
        }
      },rmdir:function (path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var err = FS.mayDelete(parent, name, true);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
      },readdir:function (path) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
        }
        return node.node_ops.readdir(node);
      },unlink:function (path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var err = FS.mayDelete(parent, name, false);
        if (err) {
          // POSIX says unlink should set EPERM, not EISDIR
          if (err === ERRNO_CODES.EISDIR) err = ERRNO_CODES.EPERM;
          throw new FS.ErrnoError(err);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
      },readlink:function (path) {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        return link.node_ops.readlink(link);
      },stat:function (path, dontFollow) {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        return node.node_ops.getattr(node);
      },lstat:function (path) {
        return FS.stat(path, true);
      },chmod:function (path, mode, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },lchmod:function (path, mode) {
        FS.chmod(path, mode, true);
      },fchmod:function (fd, mode) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        FS.chmod(stream.node, mode);
      },chown:function (path, uid, gid, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          // we ignore the uid / gid for now
        });
      },lchown:function (path, uid, gid) {
        FS.chown(path, uid, gid, true);
      },fchown:function (fd, uid, gid) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        FS.chown(stream.node, uid, gid);
      },truncate:function (path, len) {
        if (len < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(ERRNO_CODES.EPERM);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var err = FS.nodePermissions(node, 'w');
        if (err) {
          throw new FS.ErrnoError(err);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },ftruncate:function (fd, len) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        FS.truncate(stream.node, len);
      },utime:function (path, atime, mtime) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },open:function (path, flags, mode, fd_start, fd_end) {
        flags = typeof flags === 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode === 'undefined' ? 438 /* 0666 */ : mode;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path === 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            // ignore
          }
        }
        // perhaps we need to create the node
        if ((flags & 64)) {
          if (node) {
            // if O_CREAT and O_EXCL are set, error out if the node already exists
            if ((flags & 128)) {
              throw new FS.ErrnoError(ERRNO_CODES.EEXIST);
            }
          } else {
            // node doesn't exist, try to create it
            node = FS.mknod(path, mode, 0);
          }
        }
        if (!node) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOENT);
        }
        // can't truncate a device
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        // check permissions
        var err = FS.mayOpen(node, flags);
        if (err) {
          throw new FS.ErrnoError(err);
        }
        // do truncation if necessary
        if ((flags & 512)) {
          FS.truncate(node, 0);
        }
        // we've already handled these, don't pass down to the underlying vfs
        flags &= ~(128 | 512);

        // register the stream with the filesystem
        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),  // we want the absolute path to the node
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        }, fd_start, fd_end);
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
            Module['printErr']('read file: ' + path);
          }
        }
        return stream;
      },close:function (stream) {
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
      },llseek:function (stream, offset, whence) {
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        return stream.stream_ops.llseek(stream, offset, whence);
      },read:function (stream, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var seeking = true;
        if (typeof position === 'undefined') {
          position = stream.position;
          seeking = false;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },write:function (stream, buffer, offset, length, position, canOwn) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.EISDIR);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        var seeking = true;
        if (typeof position === 'undefined') {
          position = stream.position;
          seeking = false;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);
        }
        if (stream.flags & 1024) {
          // seek to the end before writing in append mode
          FS.llseek(stream, 0, 2);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        return bytesWritten;
      },allocate:function (stream, offset, length) {
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(ERRNO_CODES.EBADF);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },mmap:function (stream, buffer, offset, length, position, prot, flags) {
        // TODO if PROT is PROT_WRITE, make sure we have write access
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(ERRNO_CODES.EACCES);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(ERRNO_CODES.ENODEV);
        }
        return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);
      },ioctl:function (stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTTY);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },readFile:function (path, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'r';
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = '';
          var utf8 = new Runtime.UTF8Processor();
          for (var i = 0; i < length; i++) {
            ret += utf8.processCChar(buf[i]);
          }
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },writeFile:function (path, data, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'w';
        opts.encoding = opts.encoding || 'utf8';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var stream = FS.open(path, opts.flags, opts.mode);
        if (opts.encoding === 'utf8') {
          var utf8 = new Runtime.UTF8Processor();
          var buf = new Uint8Array(utf8.processJSString(data));
          FS.write(stream, buf, 0, buf.length, 0, opts.canOwn);
        } else if (opts.encoding === 'binary') {
          FS.write(stream, data, 0, data.length, 0, opts.canOwn);
        }
        FS.close(stream);
      },cwd:function () {
        return FS.currentPath;
      },chdir:function (path) {
        var lookup = FS.lookupPath(path, { follow: true });
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
        }
        var err = FS.nodePermissions(lookup.node, 'x');
        if (err) {
          throw new FS.ErrnoError(err);
        }
        FS.currentPath = lookup.path;
      },createDefaultDirectories:function () {
        FS.mkdir('/tmp');
      },createDefaultDevices:function () {
        // create /dev
        FS.mkdir('/dev');
        // setup /dev/null
        FS.registerDevice(FS.makedev(1, 3), {
          read: function() { return 0; },
          write: function() { return 0; }
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using Module['printErr']
        // so we register a second tty just for it.
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },createStandardStreams:function () {
        // TODO deprecate the old functionality of a single
        // input / output callback and that utilizes FS.createDevice
        // and instead require a unique set of stream ops

        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }

        // open default streams for the stdin, stdout and stderr devices
        var stdin = FS.open('/dev/stdin', 'r');
        HEAP32[((_stdin)>>2)]=FS.getPtrForStream(stdin);
        assert(stdin.fd === 0, 'invalid handle for stdin (' + stdin.fd + ')');

        var stdout = FS.open('/dev/stdout', 'w');
        HEAP32[((_stdout)>>2)]=FS.getPtrForStream(stdout);
        assert(stdout.fd === 1, 'invalid handle for stdout (' + stdout.fd + ')');

        var stderr = FS.open('/dev/stderr', 'w');
        HEAP32[((_stderr)>>2)]=FS.getPtrForStream(stderr);
        assert(stderr.fd === 2, 'invalid handle for stderr (' + stderr.fd + ')');
      },ensureErrnoError:function () {
        if (FS.ErrnoError) return;
        FS.ErrnoError = function ErrnoError(errno) {
          this.errno = errno;
          for (var key in ERRNO_CODES) {
            if (ERRNO_CODES[key] === errno) {
              this.code = key;
              break;
            }
          }
          this.message = ERRNO_MESSAGES[errno];
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
        [ERRNO_CODES.ENOENT].forEach(function(code) {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },staticInit:function () {
        FS.ensureErrnoError();

        FS.nameTable = new Array(4096);

        FS.mount(MEMFS, {}, '/');

        FS.createDefaultDirectories();
        FS.createDefaultDevices();
      },init:function (input, output, error) {
        assert(!FS.init.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');
        FS.init.initialized = true;

        FS.ensureErrnoError();

        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];

        FS.createStandardStreams();
      },quit:function () {
        FS.init.initialized = false;
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },getMode:function (canRead, canWrite) {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },joinPath:function (parts, forceRelative) {
        var path = PATH.join.apply(null, parts);
        if (forceRelative && path[0] == '/') path = path.substr(1);
        return path;
      },absolutePath:function (relative, base) {
        return PATH.resolve(base, relative);
      },standardizePath:function (path) {
        return PATH.normalize(path);
      },findObject:function (path, dontResolveLastLink) {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
          return ret.object;
        } else {
          ___setErrNo(ret.error);
          return null;
        }
      },analyzePath:function (path, dontResolveLastLink) {
        // operate from within the context of the symlink's target
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },createFolder:function (parent, name, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.mkdir(path, mode);
      },createPath:function (parent, path, canRead, canWrite) {
        parent = typeof parent === 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            // ignore EEXIST
          }
          parent = current;
        }
        return current;
      },createFile:function (parent, name, properties, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },createDataFile:function (parent, name, data, canRead, canWrite, canOwn) {
        var path = name ? PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name) : parent;
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data === 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          // make sure we can write to the file
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 'w');
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },createDevice:function (parent, name, input, output) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        // Create a fake device that a set of stream ops to emulate
        // the old behavior.
        FS.registerDevice(dev, {
          open: function(stream) {
            stream.seekable = false;
          },
          close: function(stream) {
            // flush any pending line data
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: function(stream, buffer, offset, length, pos /* ignored */) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES.EIO);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: function(stream, buffer, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(ERRNO_CODES.EIO);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },createLink:function (parent, name, target, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        return FS.symlink(target, path);
      },forceLoadFile:function (obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        var success = true;
        if (typeof XMLHttpRequest !== 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (Module['read']) {
          // Command-line.
          try {
            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
            //          read() will try to parse UTF8.
            obj.contents = intArrayFromString(Module['read'](obj.url), true);
          } catch (e) {
            success = false;
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
        if (!success) ___setErrNo(ERRNO_CODES.EIO);
        return success;
      },createLazyFile:function (parent, name, url, canRead, canWrite) {
        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = []; // Loaded chunks. Index is the chunk number
        }
        LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {
          if (idx > this.length-1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = Math.floor(idx / this.chunkSize);
          return this.getter(chunkNum)[chunkOffset];
        }
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        }
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
            // Find length
            var xhr = new XMLHttpRequest();
            xhr.open('HEAD', url, false);
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            var datalength = Number(xhr.getResponseHeader("Content-length"));
            var header;
            var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
            var chunkSize = 1024*1024; // Chunk size in bytes

            if (!hasByteServing) chunkSize = datalength;

            // Function to get a range from the remote URL.
            var doXHR = (function(from, to) {
              if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
              if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");

              // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
              var xhr = new XMLHttpRequest();
              xhr.open('GET', url, false);
              if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);

              // Some hints to the browser that we want binary data.
              if (typeof Uint8Array != 'undefined') xhr.responseType = 'arraybuffer';
              if (xhr.overrideMimeType) {
                xhr.overrideMimeType('text/plain; charset=x-user-defined');
              }

              xhr.send(null);
              if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
              if (xhr.response !== undefined) {
                return new Uint8Array(xhr.response || []);
              } else {
                return intArrayFromString(xhr.responseText || '', true);
              }
            });
            var lazyArray = this;
            lazyArray.setDataGetter(function(chunkNum) {
              var start = chunkNum * chunkSize;
              var end = (chunkNum+1) * chunkSize - 1; // including this byte
              end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
              if (typeof(lazyArray.chunks[chunkNum]) === "undefined") {
                lazyArray.chunks[chunkNum] = doXHR(start, end);
              }
              if (typeof(lazyArray.chunks[chunkNum]) === "undefined") throw new Error("doXHR failed!");
              return lazyArray.chunks[chunkNum];
            });

            this._length = datalength;
            this._chunkSize = chunkSize;
            this.lengthKnown = true;
        }
        if (typeof XMLHttpRequest !== 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          Object.defineProperty(lazyArray, "length", {
              get: function() {
                  if(!this.lengthKnown) {
                      this.cacheLength();
                  }
                  return this._length;
              }
          });
          Object.defineProperty(lazyArray, "chunkSize", {
              get: function() {
                  if(!this.lengthKnown) {
                      this.cacheLength();
                  }
                  return this._chunkSize;
              }
          });

          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }

        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        // This is a total hack, but I want to get this lazy file code out of the
        // core of MEMFS. If we want to keep this lazy file concept I feel it should
        // be its own thin LAZYFS proxying calls to MEMFS.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach(function(key) {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            if (!FS.forceLoadFile(node)) {
              throw new FS.ErrnoError(ERRNO_CODES.EIO);
            }
            return fn.apply(null, arguments);
          };
        });
        // use a custom read function
        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {
          if (!FS.forceLoadFile(node)) {
            throw new FS.ErrnoError(ERRNO_CODES.EIO);
          }
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          assert(size >= 0);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        };
        node.stream_ops = stream_ops;
        return node;
      },createPreloadedFile:function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn) {
        Browser.init();
        // TODO we should allow people to just pass in a complete filename instead
        // of parent and name being that we just join them anyways
        var fullname = name ? PATH.resolve(PATH.join2(parent, name)) : parent;
        function processData(byteArray) {
          function finish(byteArray) {
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            }
            if (onload) onload();
            removeRunDependency('cp ' + fullname);
          }
          var handled = false;
          Module['preloadPlugins'].forEach(function(plugin) {
            if (handled) return;
            if (plugin['canHandle'](fullname)) {
              plugin['handle'](byteArray, fullname, finish, function() {
                if (onerror) onerror();
                removeRunDependency('cp ' + fullname);
              });
              handled = true;
            }
          });
          if (!handled) finish(byteArray);
        }
        addRunDependency('cp ' + fullname);
        if (typeof url == 'string') {
          Browser.asyncLoad(url, function(byteArray) {
            processData(byteArray);
          }, onerror);
        } else {
          processData(url);
        }
      },indexedDB:function () {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },DB_NAME:function () {
        return 'EM_FS_' + window.location.pathname;
      },DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:function (paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
          console.log('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);
            putRequest.onsuccess = function putRequest_onsuccess() { ok++; if (ok + fail == total) finish() };
            putRequest.onerror = function putRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },loadFilesFromDB:function (paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror; // no database to load from
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch(e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var getRequest = files.get(path);
            getRequest.onsuccess = function getRequest_onsuccess() {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = function getRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      }};




  function _mkport() { throw 'TODO' }var SOCKFS={mount:function (mount) {
        return FS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createSocket:function (family, type, protocol) {
        var streaming = type == 1;
        if (protocol) {
          assert(streaming == (protocol == 6)); // if SOCK_STREAM, must be tcp
        }

        // create our internal socket structure
        var sock = {
          family: family,
          type: type,
          protocol: protocol,
          server: null,
          peers: {},
          pending: [],
          recv_queue: [],
          sock_ops: SOCKFS.websocket_sock_ops
        };

        // create the filesystem node to store the socket structure
        var name = SOCKFS.nextname();
        var node = FS.createNode(SOCKFS.root, name, 49152, 0);
        node.sock = sock;

        // and the wrapping stream that enables library functions such
        // as read and write to indirectly interact with the socket
        var stream = FS.createStream({
          path: name,
          node: node,
          flags: FS.modeStringToFlags('r+'),
          seekable: false,
          stream_ops: SOCKFS.stream_ops
        });

        // map the new stream to the socket structure (sockets have a 1:1
        // relationship with a stream)
        sock.stream = stream;

        return sock;
      },getSocket:function (fd) {
        var stream = FS.getStream(fd);
        if (!stream || !FS.isSocket(stream.node.mode)) {
          return null;
        }
        return stream.node.sock;
      },stream_ops:{poll:function (stream) {
          var sock = stream.node.sock;
          return sock.sock_ops.poll(sock);
        },ioctl:function (stream, request, varargs) {
          var sock = stream.node.sock;
          return sock.sock_ops.ioctl(sock, request, varargs);
        },read:function (stream, buffer, offset, length, position /* ignored */) {
          var sock = stream.node.sock;
          var msg = sock.sock_ops.recvmsg(sock, length);
          if (!msg) {
            // socket is closed
            return 0;
          }
          buffer.set(msg.buffer, offset);
          return msg.buffer.length;
        },write:function (stream, buffer, offset, length, position /* ignored */) {
          var sock = stream.node.sock;
          return sock.sock_ops.sendmsg(sock, buffer, offset, length);
        },close:function (stream) {
          var sock = stream.node.sock;
          sock.sock_ops.close(sock);
        }},nextname:function () {
        if (!SOCKFS.nextname.current) {
          SOCKFS.nextname.current = 0;
        }
        return 'socket[' + (SOCKFS.nextname.current++) + ']';
      },websocket_sock_ops:{createPeer:function (sock, addr, port) {
          var ws;

          if (typeof addr === 'object') {
            ws = addr;
            addr = null;
            port = null;
          }

          if (ws) {
            // for sockets that've already connected (e.g. we're the server)
            // we can inspect the _socket property for the address
            if (ws._socket) {
              addr = ws._socket.remoteAddress;
              port = ws._socket.remotePort;
            }
            // if we're just now initializing a connection to the remote,
            // inspect the url property
            else {
              var result = /ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);
              if (!result) {
                throw new Error('WebSocket URL must be in the format ws(s)://address:port');
              }
              addr = result[1];
              port = parseInt(result[2], 10);
            }
          } else {
            // create the actual websocket object and connect
            try {
              // runtimeConfig gets set to true if WebSocket runtime configuration is available.
              var runtimeConfig = (Module['websocket'] && ('object' === typeof Module['websocket']));

              // The default value is 'ws://' the replace is needed because the compiler replaces "//" comments with '#'
              // comments without checking context, so we'd end up with ws:#, the replace swaps the "#" for "//" again.
              var url = 'ws:#'.replace('#', '//');

              if (runtimeConfig) {
                if ('string' === typeof Module['websocket']['url']) {
                  url = Module['websocket']['url']; // Fetch runtime WebSocket URL config.
                }
              }

              if (url === 'ws://' || url === 'wss://') { // Is the supplied URL config just a prefix, if so complete it.
                url = url + addr + ':' + port;
              }

              // Make the WebSocket subprotocol (Sec-WebSocket-Protocol) default to binary if no configuration is set.
              var subProtocols = 'binary'; // The default value is 'binary'

              if (runtimeConfig) {
                if ('string' === typeof Module['websocket']['subprotocol']) {
                  subProtocols = Module['websocket']['subprotocol']; // Fetch runtime WebSocket subprotocol config.
                }
              }

              // The regex trims the string (removes spaces at the beginning and end, then splits the string by
              // <any space>,<any space> into an Array. Whitespace removal is important for Websockify and ws.
              subProtocols = subProtocols.replace(/^ +| +$/g,"").split(/ *, */);

              // The node ws library API for specifying optional subprotocol is slightly different than the browser's.
              var opts = ENVIRONMENT_IS_NODE ? {'protocol': subProtocols.toString()} : subProtocols;

              // If node we use the ws library.
              var WebSocket = ENVIRONMENT_IS_NODE ? require('ws') : window['WebSocket'];
              ws = new WebSocket(url, opts);
              ws.binaryType = 'arraybuffer';
            } catch (e) {
              throw new FS.ErrnoError(ERRNO_CODES.EHOSTUNREACH);
            }
          }


          var peer = {
            addr: addr,
            port: port,
            socket: ws,
            dgram_send_queue: []
          };

          SOCKFS.websocket_sock_ops.addPeer(sock, peer);
          SOCKFS.websocket_sock_ops.handlePeerEvents(sock, peer);

          // if this is a bound dgram socket, send the port number first to allow
          // us to override the ephemeral port reported to us by remotePort on the
          // remote end.
          if (sock.type === 2 && typeof sock.sport !== 'undefined') {
            peer.dgram_send_queue.push(new Uint8Array([
                255, 255, 255, 255,
                'p'.charCodeAt(0), 'o'.charCodeAt(0), 'r'.charCodeAt(0), 't'.charCodeAt(0),
                ((sock.sport & 0xff00) >> 8) , (sock.sport & 0xff)
            ]));
          }

          return peer;
        },getPeer:function (sock, addr, port) {
          return sock.peers[addr + ':' + port];
        },addPeer:function (sock, peer) {
          sock.peers[peer.addr + ':' + peer.port] = peer;
        },removePeer:function (sock, peer) {
          delete sock.peers[peer.addr + ':' + peer.port];
        },handlePeerEvents:function (sock, peer) {
          var first = true;

          var handleOpen = function () {
            try {
              var queued = peer.dgram_send_queue.shift();
              while (queued) {
                peer.socket.send(queued);
                queued = peer.dgram_send_queue.shift();
              }
            } catch (e) {
              // not much we can do here in the way of proper error handling as we've already
              // lied and said this data was sent. shut it down.
              peer.socket.close();
            }
          };

          function handleMessage(data) {
            assert(typeof data !== 'string' && data.byteLength !== undefined);  // must receive an ArrayBuffer
            data = new Uint8Array(data);  // make a typed array view on the array buffer


            // if this is the port message, override the peer's port with it
            var wasfirst = first;
            first = false;
            if (wasfirst &&
                data.length === 10 &&
                data[0] === 255 && data[1] === 255 && data[2] === 255 && data[3] === 255 &&
                data[4] === 'p'.charCodeAt(0) && data[5] === 'o'.charCodeAt(0) && data[6] === 'r'.charCodeAt(0) && data[7] === 't'.charCodeAt(0)) {
              // update the peer's port and it's key in the peer map
              var newport = ((data[8] << 8) | data[9]);
              SOCKFS.websocket_sock_ops.removePeer(sock, peer);
              peer.port = newport;
              SOCKFS.websocket_sock_ops.addPeer(sock, peer);
              return;
            }

            sock.recv_queue.push({ addr: peer.addr, port: peer.port, data: data });
          };

          if (ENVIRONMENT_IS_NODE) {
            peer.socket.on('open', handleOpen);
            peer.socket.on('message', function(data, flags) {
              if (!flags.binary) {
                return;
              }
              handleMessage((new Uint8Array(data)).buffer);  // copy from node Buffer -> ArrayBuffer
            });
            peer.socket.on('error', function() {
              // don't throw
            });
          } else {
            peer.socket.onopen = handleOpen;
            peer.socket.onmessage = function peer_socket_onmessage(event) {
              handleMessage(event.data);
            };
          }
        },poll:function (sock) {
          if (sock.type === 1 && sock.server) {
            // listen sockets should only say they're available for reading
            // if there are pending clients.
            return sock.pending.length ? (64 | 1) : 0;
          }

          var mask = 0;
          var dest = sock.type === 1 ?  // we only care about the socket state for connection-based sockets
            SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport) :
            null;

          if (sock.recv_queue.length ||
              !dest ||  // connection-less sockets are always ready to read
              (dest && dest.socket.readyState === dest.socket.CLOSING) ||
              (dest && dest.socket.readyState === dest.socket.CLOSED)) {  // let recv return 0 once closed
            mask |= (64 | 1);
          }

          if (!dest ||  // connection-less sockets are always ready to write
              (dest && dest.socket.readyState === dest.socket.OPEN)) {
            mask |= 4;
          }

          if ((dest && dest.socket.readyState === dest.socket.CLOSING) ||
              (dest && dest.socket.readyState === dest.socket.CLOSED)) {
            mask |= 16;
          }

          return mask;
        },ioctl:function (sock, request, arg) {
          switch (request) {
            case 21531:
              var bytes = 0;
              if (sock.recv_queue.length) {
                bytes = sock.recv_queue[0].data.length;
              }
              HEAP32[((arg)>>2)]=bytes;
              return 0;
            default:
              return ERRNO_CODES.EINVAL;
          }
        },close:function (sock) {
          // if we've spawned a listen server, close it
          if (sock.server) {
            try {
              sock.server.close();
            } catch (e) {
            }
            sock.server = null;
          }
          // close any peer connections
          var peers = Object.keys(sock.peers);
          for (var i = 0; i < peers.length; i++) {
            var peer = sock.peers[peers[i]];
            try {
              peer.socket.close();
            } catch (e) {
            }
            SOCKFS.websocket_sock_ops.removePeer(sock, peer);
          }
          return 0;
        },bind:function (sock, addr, port) {
          if (typeof sock.saddr !== 'undefined' || typeof sock.sport !== 'undefined') {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);  // already bound
          }
          sock.saddr = addr;
          sock.sport = port || _mkport();
          // in order to emulate dgram sockets, we need to launch a listen server when
          // binding on a connection-less socket
          // note: this is only required on the server side
          if (sock.type === 2) {
            // close the existing server if it exists
            if (sock.server) {
              sock.server.close();
              sock.server = null;
            }
            // swallow error operation not supported error that occurs when binding in the
            // browser where this isn't supported
            try {
              sock.sock_ops.listen(sock, 0);
            } catch (e) {
              if (!(e instanceof FS.ErrnoError)) throw e;
              if (e.errno !== ERRNO_CODES.EOPNOTSUPP) throw e;
            }
          }
        },connect:function (sock, addr, port) {
          if (sock.server) {
            throw new FS.ErrnoError(ERRNO_CODS.EOPNOTSUPP);
          }

          // TODO autobind
          // if (!sock.addr && sock.type == 2) {
          // }

          // early out if we're already connected / in the middle of connecting
          if (typeof sock.daddr !== 'undefined' && typeof sock.dport !== 'undefined') {
            var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);
            if (dest) {
              if (dest.socket.readyState === dest.socket.CONNECTING) {
                throw new FS.ErrnoError(ERRNO_CODES.EALREADY);
              } else {
                throw new FS.ErrnoError(ERRNO_CODES.EISCONN);
              }
            }
          }

          // add the socket to our peer list and set our
          // destination address / port to match
          var peer = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
          sock.daddr = peer.addr;
          sock.dport = peer.port;

          // always "fail" in non-blocking mode
          throw new FS.ErrnoError(ERRNO_CODES.EINPROGRESS);
        },listen:function (sock, backlog) {
          if (!ENVIRONMENT_IS_NODE) {
            throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);
          }
          if (sock.server) {
             throw new FS.ErrnoError(ERRNO_CODES.EINVAL);  // already listening
          }
          var WebSocketServer = require('ws').Server;
          var host = sock.saddr;
          sock.server = new WebSocketServer({
            host: host,
            port: sock.sport
            // TODO support backlog
          });

          sock.server.on('connection', function(ws) {
            if (sock.type === 1) {
              var newsock = SOCKFS.createSocket(sock.family, sock.type, sock.protocol);

              // create a peer on the new socket
              var peer = SOCKFS.websocket_sock_ops.createPeer(newsock, ws);
              newsock.daddr = peer.addr;
              newsock.dport = peer.port;

              // push to queue for accept to pick up
              sock.pending.push(newsock);
            } else {
              // create a peer on the listen socket so calling sendto
              // with the listen socket and an address will resolve
              // to the correct client
              SOCKFS.websocket_sock_ops.createPeer(sock, ws);
            }
          });
          sock.server.on('closed', function() {
            sock.server = null;
          });
          sock.server.on('error', function() {
            // don't throw
          });
        },accept:function (listensock) {
          if (!listensock.server) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
          var newsock = listensock.pending.shift();
          newsock.stream.flags = listensock.stream.flags;
          return newsock;
        },getname:function (sock, peer) {
          var addr, port;
          if (peer) {
            if (sock.daddr === undefined || sock.dport === undefined) {
              throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
            }
            addr = sock.daddr;
            port = sock.dport;
          } else {
            // TODO saddr and sport will be set for bind()'d UDP sockets, but what
            // should we be returning for TCP sockets that've been connect()'d?
            addr = sock.saddr || 0;
            port = sock.sport || 0;
          }
          return { addr: addr, port: port };
        },sendmsg:function (sock, buffer, offset, length, addr, port) {
          if (sock.type === 2) {
            // connection-less sockets will honor the message address,
            // and otherwise fall back to the bound destination address
            if (addr === undefined || port === undefined) {
              addr = sock.daddr;
              port = sock.dport;
            }
            // if there was no address to fall back to, error out
            if (addr === undefined || port === undefined) {
              throw new FS.ErrnoError(ERRNO_CODES.EDESTADDRREQ);
            }
          } else {
            // connection-based sockets will only use the bound
            addr = sock.daddr;
            port = sock.dport;
          }

          // find the peer for the destination address
          var dest = SOCKFS.websocket_sock_ops.getPeer(sock, addr, port);

          // early out if not connected with a connection-based socket
          if (sock.type === 1) {
            if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
              throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
            } else if (dest.socket.readyState === dest.socket.CONNECTING) {
              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
            }
          }

          // create a copy of the incoming data to send, as the WebSocket API
          // doesn't work entirely with an ArrayBufferView, it'll just send
          // the entire underlying buffer
          var data;
          if (buffer instanceof Array || buffer instanceof ArrayBuffer) {
            data = buffer.slice(offset, offset + length);
          } else {  // ArrayBufferView
            data = buffer.buffer.slice(buffer.byteOffset + offset, buffer.byteOffset + offset + length);
          }

          // if we're emulating a connection-less dgram socket and don't have
          // a cached connection, queue the buffer to send upon connect and
          // lie, saying the data was sent now.
          if (sock.type === 2) {
            if (!dest || dest.socket.readyState !== dest.socket.OPEN) {
              // if we're not connected, open a new connection
              if (!dest || dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                dest = SOCKFS.websocket_sock_ops.createPeer(sock, addr, port);
              }
              dest.dgram_send_queue.push(data);
              return length;
            }
          }

          try {
            // send the actual data
            dest.socket.send(data);
            return length;
          } catch (e) {
            throw new FS.ErrnoError(ERRNO_CODES.EINVAL);
          }
        },recvmsg:function (sock, length) {
          // http://pubs.opengroup.org/onlinepubs/7908799/xns/recvmsg.html
          if (sock.type === 1 && sock.server) {
            // tcp servers should not be recv()'ing on the listen socket
            throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
          }

          var queued = sock.recv_queue.shift();
          if (!queued) {
            if (sock.type === 1) {
              var dest = SOCKFS.websocket_sock_ops.getPeer(sock, sock.daddr, sock.dport);

              if (!dest) {
                // if we have a destination address but are not connected, error out
                throw new FS.ErrnoError(ERRNO_CODES.ENOTCONN);
              }
              else if (dest.socket.readyState === dest.socket.CLOSING || dest.socket.readyState === dest.socket.CLOSED) {
                // return null if the socket has closed
                return null;
              }
              else {
                // else, our socket is in a valid state but truly has nothing available
                throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
              }
            } else {
              throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);
            }
          }

          // queued.data will be an ArrayBuffer if it's unadulterated, but if it's
          // requeued TCP data it'll be an ArrayBufferView
          var queuedLength = queued.data.byteLength || queued.data.length;
          var queuedOffset = queued.data.byteOffset || 0;
          var queuedBuffer = queued.data.buffer || queued.data;
          var bytesRead = Math.min(length, queuedLength);
          var res = {
            buffer: new Uint8Array(queuedBuffer, queuedOffset, bytesRead),
            addr: queued.addr,
            port: queued.port
          };


          // push back any unread data for TCP connections
          if (sock.type === 1 && bytesRead < queuedLength) {
            var bytesRemaining = queuedLength - bytesRead;
            queued.data = new Uint8Array(queuedBuffer, queuedOffset + bytesRead, bytesRemaining);
            sock.recv_queue.unshift(queued);
          }

          return res;
        }}};function _send(fd, buf, len, flags) {
      var sock = SOCKFS.getSocket(fd);
      if (!sock) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      // TODO honor flags
      return _write(fd, buf, len);
    }

  function _pwrite(fildes, buf, nbyte, offset) {
      // ssize_t pwrite(int fildes, const void *buf, size_t nbyte, off_t offset);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/write.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }
      try {
        var slab = HEAP8;
        return FS.write(stream, slab, buf, nbyte, offset);
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }function _write(fildes, buf, nbyte) {
      // ssize_t write(int fildes, const void *buf, size_t nbyte);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/write.html
      var stream = FS.getStream(fildes);
      if (!stream) {
        ___setErrNo(ERRNO_CODES.EBADF);
        return -1;
      }


      try {
        var slab = HEAP8;
        return FS.write(stream, slab, buf, nbyte);
      } catch (e) {
        FS.handleFSError(e);
        return -1;
      }
    }

  function _fileno(stream) {
      // int fileno(FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fileno.html
      stream = FS.getStreamFromPtr(stream);
      if (!stream) return -1;
      return stream.fd;
    }function _fwrite(ptr, size, nitems, stream) {
      // size_t fwrite(const void *restrict ptr, size_t size, size_t nitems, FILE *restrict stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fwrite.html
      var bytesToWrite = nitems * size;
      if (bytesToWrite == 0) return 0;
      var fd = _fileno(stream);
      var bytesWritten = _write(fd, ptr, bytesToWrite);
      if (bytesWritten == -1) {
        var streamObj = FS.getStreamFromPtr(stream);
        if (streamObj) streamObj.error = true;
        return 0;
      } else {
        return Math.floor(bytesWritten / size);
      }
    }



  Module["_strlen"] = _strlen;

  function __reallyNegative(x) {
      return x < 0 || (x === 0 && (1/x) === -Infinity);
    }function __formatString(format, varargs) {
      var textIndex = format;
      var argIndex = 0;
      function getNextArg(type) {
        // NOTE: Explicitly ignoring type safety. Otherwise this fails:
        //       int x = 4; printf("%c\n", (char)x);
        var ret;
        if (type === 'double') {
          ret = HEAPF64[(((varargs)+(argIndex))>>3)];
        } else if (type == 'i64') {
          ret = [HEAP32[(((varargs)+(argIndex))>>2)],
                 HEAP32[(((varargs)+(argIndex+4))>>2)]];

        } else {
          type = 'i32'; // varargs are always i32, i64, or double
          ret = HEAP32[(((varargs)+(argIndex))>>2)];
        }
        argIndex += Runtime.getNativeFieldSize(type);
        return ret;
      }

      var ret = [];
      var curr, next, currArg;
      while(1) {
        var startTextIndex = textIndex;
        curr = HEAP8[(textIndex)];
        if (curr === 0) break;
        next = HEAP8[((textIndex+1)|0)];
        if (curr == 37) {
          // Handle flags.
          var flagAlwaysSigned = false;
          var flagLeftAlign = false;
          var flagAlternative = false;
          var flagZeroPad = false;
          var flagPadSign = false;
          flagsLoop: while (1) {
            switch (next) {
              case 43:
                flagAlwaysSigned = true;
                break;
              case 45:
                flagLeftAlign = true;
                break;
              case 35:
                flagAlternative = true;
                break;
              case 48:
                if (flagZeroPad) {
                  break flagsLoop;
                } else {
                  flagZeroPad = true;
                  break;
                }
              case 32:
                flagPadSign = true;
                break;
              default:
                break flagsLoop;
            }
            textIndex++;
            next = HEAP8[((textIndex+1)|0)];
          }

          // Handle width.
          var width = 0;
          if (next == 42) {
            width = getNextArg('i32');
            textIndex++;
            next = HEAP8[((textIndex+1)|0)];
          } else {
            while (next >= 48 && next <= 57) {
              width = width * 10 + (next - 48);
              textIndex++;
              next = HEAP8[((textIndex+1)|0)];
            }
          }

          // Handle precision.
          var precisionSet = false, precision = -1;
          if (next == 46) {
            precision = 0;
            precisionSet = true;
            textIndex++;
            next = HEAP8[((textIndex+1)|0)];
            if (next == 42) {
              precision = getNextArg('i32');
              textIndex++;
            } else {
              while(1) {
                var precisionChr = HEAP8[((textIndex+1)|0)];
                if (precisionChr < 48 ||
                    precisionChr > 57) break;
                precision = precision * 10 + (precisionChr - 48);
                textIndex++;
              }
            }
            next = HEAP8[((textIndex+1)|0)];
          }
          if (precision < 0) {
            precision = 6; // Standard default.
            precisionSet = false;
          }

          // Handle integer sizes. WARNING: These assume a 32-bit architecture!
          var argSize;
          switch (String.fromCharCode(next)) {
            case 'h':
              var nextNext = HEAP8[((textIndex+2)|0)];
              if (nextNext == 104) {
                textIndex++;
                argSize = 1; // char (actually i32 in varargs)
              } else {
                argSize = 2; // short (actually i32 in varargs)
              }
              break;
            case 'l':
              var nextNext = HEAP8[((textIndex+2)|0)];
              if (nextNext == 108) {
                textIndex++;
                argSize = 8; // long long
              } else {
                argSize = 4; // long
              }
              break;
            case 'L': // long long
            case 'q': // int64_t
            case 'j': // intmax_t
              argSize = 8;
              break;
            case 'z': // size_t
            case 't': // ptrdiff_t
            case 'I': // signed ptrdiff_t or unsigned size_t
              argSize = 4;
              break;
            default:
              argSize = null;
          }
          if (argSize) textIndex++;
          next = HEAP8[((textIndex+1)|0)];

          // Handle type specifier.
          switch (String.fromCharCode(next)) {
            case 'd': case 'i': case 'u': case 'o': case 'x': case 'X': case 'p': {
              // Integer.
              var signed = next == 100 || next == 105;
              argSize = argSize || 4;
              var currArg = getNextArg('i' + (argSize * 8));
              var argText;
              // Flatten i64-1 [low, high] into a (slightly rounded) double
              if (argSize == 8) {
                currArg = Runtime.makeBigInt(currArg[0], currArg[1], next == 117);
              }
              // Truncate to requested size.
              if (argSize <= 4) {
                var limit = Math.pow(256, argSize) - 1;
                currArg = (signed ? reSign : unSign)(currArg & limit, argSize * 8);
              }
              // Format the number.
              var currAbsArg = Math.abs(currArg);
              var prefix = '';
              if (next == 100 || next == 105) {
                argText = reSign(currArg, 8 * argSize, 1).toString(10);
              } else if (next == 117) {
                argText = unSign(currArg, 8 * argSize, 1).toString(10);
                currArg = Math.abs(currArg);
              } else if (next == 111) {
                argText = (flagAlternative ? '0' : '') + currAbsArg.toString(8);
              } else if (next == 120 || next == 88) {
                prefix = (flagAlternative && currArg != 0) ? '0x' : '';
                if (currArg < 0) {
                  // Represent negative numbers in hex as 2's complement.
                  currArg = -currArg;
                  argText = (currAbsArg - 1).toString(16);
                  var buffer = [];
                  for (var i = 0; i < argText.length; i++) {
                    buffer.push((0xF - parseInt(argText[i], 16)).toString(16));
                  }
                  argText = buffer.join('');
                  while (argText.length < argSize * 2) argText = 'f' + argText;
                } else {
                  argText = currAbsArg.toString(16);
                }
                if (next == 88) {
                  prefix = prefix.toUpperCase();
                  argText = argText.toUpperCase();
                }
              } else if (next == 112) {
                if (currAbsArg === 0) {
                  argText = '(nil)';
                } else {
                  prefix = '0x';
                  argText = currAbsArg.toString(16);
                }
              }
              if (precisionSet) {
                while (argText.length < precision) {
                  argText = '0' + argText;
                }
              }

              // Add sign if needed
              if (currArg >= 0) {
                if (flagAlwaysSigned) {
                  prefix = '+' + prefix;
                } else if (flagPadSign) {
                  prefix = ' ' + prefix;
                }
              }

              // Move sign to prefix so we zero-pad after the sign
              if (argText.charAt(0) == '-') {
                prefix = '-' + prefix;
                argText = argText.substr(1);
              }

              // Add padding.
              while (prefix.length + argText.length < width) {
                if (flagLeftAlign) {
                  argText += ' ';
                } else {
                  if (flagZeroPad) {
                    argText = '0' + argText;
                  } else {
                    prefix = ' ' + prefix;
                  }
                }
              }

              // Insert the result into the buffer.
              argText = prefix + argText;
              argText.split('').forEach(function(chr) {
                ret.push(chr.charCodeAt(0));
              });
              break;
            }
            case 'f': case 'F': case 'e': case 'E': case 'g': case 'G': {
              // Float.
              var currArg = getNextArg('double');
              var argText;
              if (isNaN(currArg)) {
                argText = 'nan';
                flagZeroPad = false;
              } else if (!isFinite(currArg)) {
                argText = (currArg < 0 ? '-' : '') + 'inf';
                flagZeroPad = false;
              } else {
                var isGeneral = false;
                var effectivePrecision = Math.min(precision, 20);

                // Convert g/G to f/F or e/E, as per:
                // http://pubs.opengroup.org/onlinepubs/9699919799/functions/printf.html
                if (next == 103 || next == 71) {
                  isGeneral = true;
                  precision = precision || 1;
                  var exponent = parseInt(currArg.toExponential(effectivePrecision).split('e')[1], 10);
                  if (precision > exponent && exponent >= -4) {
                    next = ((next == 103) ? 'f' : 'F').charCodeAt(0);
                    precision -= exponent + 1;
                  } else {
                    next = ((next == 103) ? 'e' : 'E').charCodeAt(0);
                    precision--;
                  }
                  effectivePrecision = Math.min(precision, 20);
                }

                if (next == 101 || next == 69) {
                  argText = currArg.toExponential(effectivePrecision);
                  // Make sure the exponent has at least 2 digits.
                  if (/[eE][-+]\d$/.test(argText)) {
                    argText = argText.slice(0, -1) + '0' + argText.slice(-1);
                  }
                } else if (next == 102 || next == 70) {
                  argText = currArg.toFixed(effectivePrecision);
                  if (currArg === 0 && __reallyNegative(currArg)) {
                    argText = '-' + argText;
                  }
                }

                var parts = argText.split('e');
                if (isGeneral && !flagAlternative) {
                  // Discard trailing zeros and periods.
                  while (parts[0].length > 1 && parts[0].indexOf('.') != -1 &&
                         (parts[0].slice(-1) == '0' || parts[0].slice(-1) == '.')) {
                    parts[0] = parts[0].slice(0, -1);
                  }
                } else {
                  // Make sure we have a period in alternative mode.
                  if (flagAlternative && argText.indexOf('.') == -1) parts[0] += '.';
                  // Zero pad until required precision.
                  while (precision > effectivePrecision++) parts[0] += '0';
                }
                argText = parts[0] + (parts.length > 1 ? 'e' + parts[1] : '');

                // Capitalize 'E' if needed.
                if (next == 69) argText = argText.toUpperCase();

                // Add sign.
                if (currArg >= 0) {
                  if (flagAlwaysSigned) {
                    argText = '+' + argText;
                  } else if (flagPadSign) {
                    argText = ' ' + argText;
                  }
                }
              }

              // Add padding.
              while (argText.length < width) {
                if (flagLeftAlign) {
                  argText += ' ';
                } else {
                  if (flagZeroPad && (argText[0] == '-' || argText[0] == '+')) {
                    argText = argText[0] + '0' + argText.slice(1);
                  } else {
                    argText = (flagZeroPad ? '0' : ' ') + argText;
                  }
                }
              }

              // Adjust case.
              if (next < 97) argText = argText.toUpperCase();

              // Insert the result into the buffer.
              argText.split('').forEach(function(chr) {
                ret.push(chr.charCodeAt(0));
              });
              break;
            }
            case 's': {
              // String.
              var arg = getNextArg('i8*');
              var argLength = arg ? _strlen(arg) : '(null)'.length;
              if (precisionSet) argLength = Math.min(argLength, precision);
              if (!flagLeftAlign) {
                while (argLength < width--) {
                  ret.push(32);
                }
              }
              if (arg) {
                for (var i = 0; i < argLength; i++) {
                  ret.push(HEAPU8[((arg++)|0)]);
                }
              } else {
                ret = ret.concat(intArrayFromString('(null)'.substr(0, argLength), true));
              }
              if (flagLeftAlign) {
                while (argLength < width--) {
                  ret.push(32);
                }
              }
              break;
            }
            case 'c': {
              // Character.
              if (flagLeftAlign) ret.push(getNextArg('i8'));
              while (--width > 0) {
                ret.push(32);
              }
              if (!flagLeftAlign) ret.push(getNextArg('i8'));
              break;
            }
            case 'n': {
              // Write the length written so far to the next parameter.
              var ptr = getNextArg('i32*');
              HEAP32[((ptr)>>2)]=ret.length;
              break;
            }
            case '%': {
              // Literal percent sign.
              ret.push(curr);
              break;
            }
            default: {
              // Unknown specifiers remain untouched.
              for (var i = startTextIndex; i < textIndex + 2; i++) {
                ret.push(HEAP8[(i)]);
              }
            }
          }
          textIndex += 2;
          // TODO: Support a/A (hex float) and m (last error) specifiers.
          // TODO: Support %1${specifier} for arg selection.
        } else {
          ret.push(curr);
          textIndex += 1;
        }
      }
      return ret;
    }function _fprintf(stream, format, varargs) {
      // int fprintf(FILE *restrict stream, const char *restrict format, ...);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/printf.html
      var result = __formatString(format, varargs);
      var stack = Runtime.stackSave();
      var ret = _fwrite(allocate(result, 'i8', ALLOC_STACK), 1, result.length, stream);
      Runtime.stackRestore(stack);
      return ret;
    }function _printf(format, varargs) {
      // int printf(const char *restrict format, ...);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/printf.html
      var stdout = HEAP32[((_stdout)>>2)];
      return _fprintf(stdout, format, varargs);
    }


  function _fputs(s, stream) {
      // int fputs(const char *restrict s, FILE *restrict stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fputs.html
      var fd = _fileno(stream);
      return _write(fd, s, _strlen(s));
    }

  function _fputc(c, stream) {
      // int fputc(int c, FILE *stream);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/fputc.html
      var chr = unSign(c & 0xFF);
      HEAP8[((_fputc.ret)|0)]=chr;
      var fd = _fileno(stream);
      var ret = _write(fd, _fputc.ret, 1);
      if (ret == -1) {
        var streamObj = FS.getStreamFromPtr(stream);
        if (streamObj) streamObj.error = true;
        return -1;
      } else {
        return chr;
      }
    }function _puts(s) {
      // int puts(const char *s);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/puts.html
      // NOTE: puts() always writes an extra newline.
      var stdout = HEAP32[((_stdout)>>2)];
      var ret = _fputs(s, stdout);
      if (ret < 0) {
        return ret;
      } else {
        var newlineRet = _fputc(10, stdout);
        return (newlineRet < 0) ? -1 : ret + 1;
      }
    }

  function _sysconf(name) {
      // long sysconf(int name);
      // http://pubs.opengroup.org/onlinepubs/009695399/functions/sysconf.html
      switch(name) {
        case 30: return PAGE_SIZE;
        case 132:
        case 133:
        case 12:
        case 137:
        case 138:
        case 15:
        case 235:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 149:
        case 13:
        case 10:
        case 236:
        case 153:
        case 9:
        case 21:
        case 22:
        case 159:
        case 154:
        case 14:
        case 77:
        case 78:
        case 139:
        case 80:
        case 81:
        case 79:
        case 82:
        case 68:
        case 67:
        case 164:
        case 11:
        case 29:
        case 47:
        case 48:
        case 95:
        case 52:
        case 51:
        case 46:
          return 200809;
        case 27:
        case 246:
        case 127:
        case 128:
        case 23:
        case 24:
        case 160:
        case 161:
        case 181:
        case 182:
        case 242:
        case 183:
        case 184:
        case 243:
        case 244:
        case 245:
        case 165:
        case 178:
        case 179:
        case 49:
        case 50:
        case 168:
        case 169:
        case 175:
        case 170:
        case 171:
        case 172:
        case 97:
        case 76:
        case 32:
        case 173:
        case 35:
          return -1;
        case 176:
        case 177:
        case 7:
        case 155:
        case 8:
        case 157:
        case 125:
        case 126:
        case 92:
        case 93:
        case 129:
        case 130:
        case 131:
        case 94:
        case 91:
          return 1;
        case 74:
        case 60:
        case 69:
        case 70:
        case 4:
          return 1024;
        case 31:
        case 42:
        case 72:
          return 32;
        case 87:
        case 26:
        case 33:
          return 2147483647;
        case 34:
        case 1:
          return 47839;
        case 38:
        case 36:
          return 99;
        case 43:
        case 37:
          return 2048;
        case 0: return 2097152;
        case 3: return 65536;
        case 28: return 32768;
        case 44: return 32767;
        case 75: return 16384;
        case 39: return 1000;
        case 89: return 700;
        case 71: return 256;
        case 40: return 255;
        case 2: return 100;
        case 180: return 64;
        case 25: return 20;
        case 5: return 16;
        case 6: return 6;
        case 73: return 4;
        case 84: return 1;
      }
      ___setErrNo(ERRNO_CODES.EINVAL);
      return -1;
    }


  Module["_memset"] = _memset;

  function ___errno_location() {
      return ___errno_state;
    }

  function _abort() {
      Module['abort']();
    }

  var Browser={mainLoop:{scheduler:null,method:"",shouldPause:false,paused:false,queue:[],pause:function () {
          Browser.mainLoop.shouldPause = true;
        },resume:function () {
          if (Browser.mainLoop.paused) {
            Browser.mainLoop.paused = false;
            Browser.mainLoop.scheduler();
          }
          Browser.mainLoop.shouldPause = false;
        },updateStatus:function () {
          if (Module['setStatus']) {
            var message = Module['statusMessage'] || 'Please wait...';
            var remaining = Browser.mainLoop.remainingBlockers;
            var expected = Browser.mainLoop.expectedBlockers;
            if (remaining) {
              if (remaining < expected) {
                Module['setStatus'](message + ' (' + (expected - remaining) + '/' + expected + ')');
              } else {
                Module['setStatus'](message);
              }
            } else {
              Module['setStatus']('');
            }
          }
        }},isFullScreen:false,pointerLock:false,moduleContextCreatedCallbacks:[],workers:[],init:function () {
        if (!Module["preloadPlugins"]) Module["preloadPlugins"] = []; // needs to exist even in workers

        if (Browser.initted || ENVIRONMENT_IS_WORKER) return;
        Browser.initted = true;

        try {
          new Blob();
          Browser.hasBlobConstructor = true;
        } catch(e) {
          Browser.hasBlobConstructor = false;
          console.log("warning: no blob constructor, cannot create blobs with mimetypes");
        }
        Browser.BlobBuilder = typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : (typeof WebKitBlobBuilder != "undefined" ? WebKitBlobBuilder : (!Browser.hasBlobConstructor ? console.log("warning: no BlobBuilder") : null));
        Browser.URLObject = typeof window != "undefined" ? (window.URL ? window.URL : window.webkitURL) : undefined;
        if (!Module.noImageDecoding && typeof Browser.URLObject === 'undefined') {
          console.log("warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available.");
          Module.noImageDecoding = true;
        }

        // Support for plugins that can process preloaded files. You can add more of these to
        // your app by creating and appending to Module.preloadPlugins.
        //
        // Each plugin is asked if it can handle a file based on the file's name. If it can,
        // it is given the file's raw data. When it is done, it calls a callback with the file's
        // (possibly modified) data. For example, a plugin might decompress a file, or it
        // might create some side data structure for use later (like an Image element, etc.).

        var imagePlugin = {};
        imagePlugin['canHandle'] = function imagePlugin_canHandle(name) {
          return !Module.noImageDecoding && /\.(jpg|jpeg|png|bmp)$/i.test(name);
        };
        imagePlugin['handle'] = function imagePlugin_handle(byteArray, name, onload, onerror) {
          var b = null;
          if (Browser.hasBlobConstructor) {
            try {
              b = new Blob([byteArray], { type: Browser.getMimetype(name) });
              if (b.size !== byteArray.length) { // Safari bug #118630
                // Safari's Blob can only take an ArrayBuffer
                b = new Blob([(new Uint8Array(byteArray)).buffer], { type: Browser.getMimetype(name) });
              }
            } catch(e) {
              Runtime.warnOnce('Blob constructor present but fails: ' + e + '; falling back to blob builder');
            }
          }
          if (!b) {
            var bb = new Browser.BlobBuilder();
            bb.append((new Uint8Array(byteArray)).buffer); // we need to pass a buffer, and must copy the array to get the right data range
            b = bb.getBlob();
          }
          var url = Browser.URLObject.createObjectURL(b);
          var img = new Image();
          img.onload = function img_onload() {
            assert(img.complete, 'Image ' + name + ' could not be decoded');
            var canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            Module["preloadedImages"][name] = canvas;
            Browser.URLObject.revokeObjectURL(url);
            if (onload) onload(byteArray);
          };
          img.onerror = function img_onerror(event) {
            console.log('Image ' + url + ' could not be decoded');
            if (onerror) onerror();
          };
          img.src = url;
        };
        Module['preloadPlugins'].push(imagePlugin);

        var audioPlugin = {};
        audioPlugin['canHandle'] = function audioPlugin_canHandle(name) {
          return !Module.noAudioDecoding && name.substr(-4) in { '.ogg': 1, '.wav': 1, '.mp3': 1 };
        };
        audioPlugin['handle'] = function audioPlugin_handle(byteArray, name, onload, onerror) {
          var done = false;
          function finish(audio) {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = audio;
            if (onload) onload(byteArray);
          }
          function fail() {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = new Audio(); // empty shim
            if (onerror) onerror();
          }
          if (Browser.hasBlobConstructor) {
            try {
              var b = new Blob([byteArray], { type: Browser.getMimetype(name) });
            } catch(e) {
              return fail();
            }
            var url = Browser.URLObject.createObjectURL(b); // XXX we never revoke this!
            var audio = new Audio();
            audio.addEventListener('canplaythrough', function() { finish(audio) }, false); // use addEventListener due to chromium bug 124926
            audio.onerror = function audio_onerror(event) {
              if (done) return;
              console.log('warning: browser could not fully decode audio ' + name + ', trying slower base64 approach');
              function encode64(data) {
                var BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                var PAD = '=';
                var ret = '';
                var leftchar = 0;
                var leftbits = 0;
                for (var i = 0; i < data.length; i++) {
                  leftchar = (leftchar << 8) | data[i];
                  leftbits += 8;
                  while (leftbits >= 6) {
                    var curr = (leftchar >> (leftbits-6)) & 0x3f;
                    leftbits -= 6;
                    ret += BASE[curr];
                  }
                }
                if (leftbits == 2) {
                  ret += BASE[(leftchar&3) << 4];
                  ret += PAD + PAD;
                } else if (leftbits == 4) {
                  ret += BASE[(leftchar&0xf) << 2];
                  ret += PAD;
                }
                return ret;
              }
              audio.src = 'data:audio/x-' + name.substr(-3) + ';base64,' + encode64(byteArray);
              finish(audio); // we don't wait for confirmation this worked - but it's worth trying
            };
            audio.src = url;
            // workaround for chrome bug 124926 - we do not always get oncanplaythrough or onerror
            Browser.safeSetTimeout(function() {
              finish(audio); // try to use it even though it is not necessarily ready to play
            }, 10000);
          } else {
            return fail();
          }
        };
        Module['preloadPlugins'].push(audioPlugin);

        // Canvas event setup

        var canvas = Module['canvas'];

        // forced aspect ratio can be enabled by defining 'forcedAspectRatio' on Module
        // Module['forcedAspectRatio'] = 4 / 3;

        canvas.requestPointerLock = canvas['requestPointerLock'] ||
                                    canvas['mozRequestPointerLock'] ||
                                    canvas['webkitRequestPointerLock'] ||
                                    canvas['msRequestPointerLock'] ||
                                    function(){};
        canvas.exitPointerLock = document['exitPointerLock'] ||
                                 document['mozExitPointerLock'] ||
                                 document['webkitExitPointerLock'] ||
                                 document['msExitPointerLock'] ||
                                 function(){}; // no-op if function does not exist
        canvas.exitPointerLock = canvas.exitPointerLock.bind(document);

        function pointerLockChange() {
          Browser.pointerLock = document['pointerLockElement'] === canvas ||
                                document['mozPointerLockElement'] === canvas ||
                                document['webkitPointerLockElement'] === canvas ||
                                document['msPointerLockElement'] === canvas;
        }

        document.addEventListener('pointerlockchange', pointerLockChange, false);
        document.addEventListener('mozpointerlockchange', pointerLockChange, false);
        document.addEventListener('webkitpointerlockchange', pointerLockChange, false);
        document.addEventListener('mspointerlockchange', pointerLockChange, false);

        if (Module['elementPointerLock']) {
          canvas.addEventListener("click", function(ev) {
            if (!Browser.pointerLock && canvas.requestPointerLock) {
              canvas.requestPointerLock();
              ev.preventDefault();
            }
          }, false);
        }
      },createContext:function (canvas, useWebGL, setInModule, webGLContextAttributes) {
        var ctx;
        var errorInfo = '?';
        function onContextCreationError(event) {
          errorInfo = event.statusMessage || errorInfo;
        }
        try {
          if (useWebGL) {
            var contextAttributes = {
              antialias: false,
              alpha: false
            };

            if (webGLContextAttributes) {
              for (var attribute in webGLContextAttributes) {
                contextAttributes[attribute] = webGLContextAttributes[attribute];
              }
            }


            canvas.addEventListener('webglcontextcreationerror', onContextCreationError, false);
            try {
              ['experimental-webgl', 'webgl'].some(function(webglId) {
                return ctx = canvas.getContext(webglId, contextAttributes);
              });
            } finally {
              canvas.removeEventListener('webglcontextcreationerror', onContextCreationError, false);
            }
          } else {
            ctx = canvas.getContext('2d');
          }
          if (!ctx) throw ':(';
        } catch (e) {
          Module.print('Could not create canvas: ' + [errorInfo, e]);
          return null;
        }
        if (useWebGL) {
          // Set the background of the WebGL canvas to black
          canvas.style.backgroundColor = "black";

          // Warn on context loss
          canvas.addEventListener('webglcontextlost', function(event) {
            alert('WebGL context lost. You will need to reload the page.');
          }, false);
        }
        if (setInModule) {
          GLctx = Module.ctx = ctx;
          Module.useWebGL = useWebGL;
          Browser.moduleContextCreatedCallbacks.forEach(function(callback) { callback() });
          Browser.init();
        }
        return ctx;
      },destroyContext:function (canvas, useWebGL, setInModule) {},fullScreenHandlersInstalled:false,lockPointer:undefined,resizeCanvas:undefined,requestFullScreen:function (lockPointer, resizeCanvas) {
        Browser.lockPointer = lockPointer;
        Browser.resizeCanvas = resizeCanvas;
        if (typeof Browser.lockPointer === 'undefined') Browser.lockPointer = true;
        if (typeof Browser.resizeCanvas === 'undefined') Browser.resizeCanvas = false;

        var canvas = Module['canvas'];
        function fullScreenChange() {
          Browser.isFullScreen = false;
          var canvasContainer = canvas.parentNode;
          if ((document['webkitFullScreenElement'] || document['webkitFullscreenElement'] ||
               document['mozFullScreenElement'] || document['mozFullscreenElement'] ||
               document['fullScreenElement'] || document['fullscreenElement'] ||
               document['msFullScreenElement'] || document['msFullscreenElement'] ||
               document['webkitCurrentFullScreenElement']) === canvasContainer) {
            canvas.cancelFullScreen = document['cancelFullScreen'] ||
                                      document['mozCancelFullScreen'] ||
                                      document['webkitCancelFullScreen'] ||
                                      document['msExitFullscreen'] ||
                                      document['exitFullscreen'] ||
                                      function() {};
            canvas.cancelFullScreen = canvas.cancelFullScreen.bind(document);
            if (Browser.lockPointer) canvas.requestPointerLock();
            Browser.isFullScreen = true;
            if (Browser.resizeCanvas) Browser.setFullScreenCanvasSize();
          } else {

            // remove the full screen specific parent of the canvas again to restore the HTML structure from before going full screen
            canvasContainer.parentNode.insertBefore(canvas, canvasContainer);
            canvasContainer.parentNode.removeChild(canvasContainer);

            if (Browser.resizeCanvas) Browser.setWindowedCanvasSize();
          }
          if (Module['onFullScreen']) Module['onFullScreen'](Browser.isFullScreen);
          Browser.updateCanvasDimensions(canvas);
        }

        if (!Browser.fullScreenHandlersInstalled) {
          Browser.fullScreenHandlersInstalled = true;
          document.addEventListener('fullscreenchange', fullScreenChange, false);
          document.addEventListener('mozfullscreenchange', fullScreenChange, false);
          document.addEventListener('webkitfullscreenchange', fullScreenChange, false);
          document.addEventListener('MSFullscreenChange', fullScreenChange, false);
        }

        // create a new parent to ensure the canvas has no siblings. this allows browsers to optimize full screen performance when its parent is the full screen root
        var canvasContainer = document.createElement("div");
        canvas.parentNode.insertBefore(canvasContainer, canvas);
        canvasContainer.appendChild(canvas);

        // use parent of canvas as full screen root to allow aspect ratio correction (Firefox stretches the root to screen size)
        canvasContainer.requestFullScreen = canvasContainer['requestFullScreen'] ||
                                            canvasContainer['mozRequestFullScreen'] ||
                                            canvasContainer['msRequestFullscreen'] ||
                                           (canvasContainer['webkitRequestFullScreen'] ? function() { canvasContainer['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']) } : null);
        canvasContainer.requestFullScreen();
      },requestAnimationFrame:function requestAnimationFrame(func) {
        if (typeof window === 'undefined') { // Provide fallback to setTimeout if window is undefined (e.g. in Node.js)
          setTimeout(func, 1000/60);
        } else {
          if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = window['requestAnimationFrame'] ||
                                           window['mozRequestAnimationFrame'] ||
                                           window['webkitRequestAnimationFrame'] ||
                                           window['msRequestAnimationFrame'] ||
                                           window['oRequestAnimationFrame'] ||
                                           window['setTimeout'];
          }
          window.requestAnimationFrame(func);
        }
      },safeCallback:function (func) {
        return function() {
          if (!ABORT) return func.apply(null, arguments);
        };
      },safeRequestAnimationFrame:function (func) {
        return Browser.requestAnimationFrame(function() {
          if (!ABORT) func();
        });
      },safeSetTimeout:function (func, timeout) {
        return setTimeout(function() {
          if (!ABORT) func();
        }, timeout);
      },safeSetInterval:function (func, timeout) {
        return setInterval(function() {
          if (!ABORT) func();
        }, timeout);
      },getMimetype:function (name) {
        return {
          'jpg': 'image/jpeg',
          'jpeg': 'image/jpeg',
          'png': 'image/png',
          'bmp': 'image/bmp',
          'ogg': 'audio/ogg',
          'wav': 'audio/wav',
          'mp3': 'audio/mpeg'
        }[name.substr(name.lastIndexOf('.')+1)];
      },getUserMedia:function (func) {
        if(!window.getUserMedia) {
          window.getUserMedia = navigator['getUserMedia'] ||
                                navigator['mozGetUserMedia'];
        }
        window.getUserMedia(func);
      },getMovementX:function (event) {
        return event['movementX'] ||
               event['mozMovementX'] ||
               event['webkitMovementX'] ||
               0;
      },getMovementY:function (event) {
        return event['movementY'] ||
               event['mozMovementY'] ||
               event['webkitMovementY'] ||
               0;
      },getMouseWheelDelta:function (event) {
        return Math.max(-1, Math.min(1, event.type === 'DOMMouseScroll' ? event.detail : -event.wheelDelta));
      },mouseX:0,mouseY:0,mouseMovementX:0,mouseMovementY:0,calculateMouseEvent:function (event) { // event should be mousemove, mousedown or mouseup
        if (Browser.pointerLock) {
          // When the pointer is locked, calculate the coordinates
          // based on the movement of the mouse.
          // Workaround for Firefox bug 764498
          if (event.type != 'mousemove' &&
              ('mozMovementX' in event)) {
            Browser.mouseMovementX = Browser.mouseMovementY = 0;
          } else {
            Browser.mouseMovementX = Browser.getMovementX(event);
            Browser.mouseMovementY = Browser.getMovementY(event);
          }

          // check if SDL is available
          if (typeof SDL != "undefined") {
    Browser.mouseX = SDL.mouseX + Browser.mouseMovementX;
    Browser.mouseY = SDL.mouseY + Browser.mouseMovementY;
          } else {
    // just add the mouse delta to the current absolut mouse position
    // FIXME: ideally this should be clamped against the canvas size and zero
    Browser.mouseX += Browser.mouseMovementX;
    Browser.mouseY += Browser.mouseMovementY;
          }
        } else {
          // Otherwise, calculate the movement based on the changes
          // in the coordinates.
          var rect = Module["canvas"].getBoundingClientRect();
          var x, y;

          // Neither .scrollX or .pageXOffset are defined in a spec, but
          // we prefer .scrollX because it is currently in a spec draft.
          // (see: http://www.w3.org/TR/2013/WD-cssom-view-20131217/)
          var scrollX = ((typeof window.scrollX !== 'undefined') ? window.scrollX : window.pageXOffset);
          var scrollY = ((typeof window.scrollY !== 'undefined') ? window.scrollY : window.pageYOffset);
          if (event.type == 'touchstart' ||
              event.type == 'touchend' ||
              event.type == 'touchmove') {
            var t = event.touches.item(0);
            if (t) {
              x = t.pageX - (scrollX + rect.left);
              y = t.pageY - (scrollY + rect.top);
            } else {
              return;
            }
          } else {
            x = event.pageX - (scrollX + rect.left);
            y = event.pageY - (scrollY + rect.top);
          }

          // the canvas might be CSS-scaled compared to its backbuffer;
          // SDL-using content will want mouse coordinates in terms
          // of backbuffer units.
          var cw = Module["canvas"].width;
          var ch = Module["canvas"].height;
          x = x * (cw / rect.width);
          y = y * (ch / rect.height);

          Browser.mouseMovementX = x - Browser.mouseX;
          Browser.mouseMovementY = y - Browser.mouseY;
          Browser.mouseX = x;
          Browser.mouseY = y;
        }
      },xhrLoad:function (url, onload, onerror) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, true);
        xhr.responseType = 'arraybuffer';
        xhr.onload = function xhr_onload() {
          if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
            onload(xhr.response);
          } else {
            onerror();
          }
        };
        xhr.onerror = onerror;
        xhr.send(null);
      },asyncLoad:function (url, onload, onerror, noRunDep) {
        Browser.xhrLoad(url, function(arrayBuffer) {
          assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
          onload(new Uint8Array(arrayBuffer));
          if (!noRunDep) removeRunDependency('al ' + url);
        }, function(event) {
          if (onerror) {
            onerror();
          } else {
            throw 'Loading data file "' + url + '" failed.';
          }
        });
        if (!noRunDep) addRunDependency('al ' + url);
      },resizeListeners:[],updateResizeListeners:function () {
        var canvas = Module['canvas'];
        Browser.resizeListeners.forEach(function(listener) {
          listener(canvas.width, canvas.height);
        });
      },setCanvasSize:function (width, height, noUpdates) {
        var canvas = Module['canvas'];
        Browser.updateCanvasDimensions(canvas, width, height);
        if (!noUpdates) Browser.updateResizeListeners();
      },windowedWidth:0,windowedHeight:0,setFullScreenCanvasSize:function () {
        // check if SDL is available
        if (typeof SDL != "undefined") {
    var flags = HEAPU32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)];
    flags = flags | 0x00800000; // set SDL_FULLSCREEN flag
    HEAP32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)]=flags
        }
        Browser.updateResizeListeners();
      },setWindowedCanvasSize:function () {
        // check if SDL is available
        if (typeof SDL != "undefined") {
    var flags = HEAPU32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)];
    flags = flags & ~0x00800000; // clear SDL_FULLSCREEN flag
    HEAP32[((SDL.screen+Runtime.QUANTUM_SIZE*0)>>2)]=flags
        }
        Browser.updateResizeListeners();
      },updateCanvasDimensions:function (canvas, wNative, hNative) {
        if (wNative && hNative) {
          canvas.widthNative = wNative;
          canvas.heightNative = hNative;
        } else {
          wNative = canvas.widthNative;
          hNative = canvas.heightNative;
        }
        var w = wNative;
        var h = hNative;
        if (Module['forcedAspectRatio'] && Module['forcedAspectRatio'] > 0) {
          if (w/h < Module['forcedAspectRatio']) {
            w = Math.round(h * Module['forcedAspectRatio']);
          } else {
            h = Math.round(w / Module['forcedAspectRatio']);
          }
        }
        if (((document['webkitFullScreenElement'] || document['webkitFullscreenElement'] ||
             document['mozFullScreenElement'] || document['mozFullscreenElement'] ||
             document['fullScreenElement'] || document['fullscreenElement'] ||
             document['msFullScreenElement'] || document['msFullscreenElement'] ||
             document['webkitCurrentFullScreenElement']) === canvas.parentNode) && (typeof screen != 'undefined')) {
           var factor = Math.min(screen.width / w, screen.height / h);
           w = Math.round(w * factor);
           h = Math.round(h * factor);
        }
        if (Browser.resizeCanvas) {
          if (canvas.width  != w) canvas.width  = w;
          if (canvas.height != h) canvas.height = h;
          if (typeof canvas.style != 'undefined') {
            canvas.style.removeProperty( "width");
            canvas.style.removeProperty("height");
          }
        } else {
          if (canvas.width  != wNative) canvas.width  = wNative;
          if (canvas.height != hNative) canvas.height = hNative;
          if (typeof canvas.style != 'undefined') {
            if (w != wNative || h != hNative) {
              canvas.style.setProperty( "width", w + "px", "important");
              canvas.style.setProperty("height", h + "px", "important");
            } else {
              canvas.style.removeProperty( "width");
              canvas.style.removeProperty("height");
            }
          }
        }
      }};

  function _sbrk(bytes) {
      // Implement a Linux-like 'memory area' for our 'process'.
      // Changes the size of the memory area by |bytes|; returns the
      // address of the previous top ('break') of the memory area
      // We control the "dynamic" memory - DYNAMIC_BASE to DYNAMICTOP
      var self = _sbrk;
      if (!self.called) {
        DYNAMICTOP = alignMemoryPage(DYNAMICTOP); // make sure we start out aligned
        self.called = true;
        assert(Runtime.dynamicAlloc);
        self.alloc = Runtime.dynamicAlloc;
        Runtime.dynamicAlloc = function() { abort('cannot dynamically allocate, sbrk now has control') };
      }
      var ret = DYNAMICTOP;
      if (bytes != 0) self.alloc(bytes);
      return ret;  // Previous break location.
    }

  function ___assert_fail(condition, filename, line, func) {
      ABORT = true;
      throw 'Assertion failed: ' + Pointer_stringify(condition) + ', at: ' + [filename ? Pointer_stringify(filename) : 'unknown filename', line, func ? Pointer_stringify(func) : 'unknown function'] + ' at ' + stackTrace();
    }

  function _time(ptr) {
      var ret = Math.floor(Date.now()/1000);
      if (ptr) {
        HEAP32[((ptr)>>2)]=ret;
      }
      return ret;
    }

  function _llvm_bswap_i32(x) {
      return ((x&0xff)<<24) | (((x>>8)&0xff)<<16) | (((x>>16)&0xff)<<8) | (x>>>24);
    }



  function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.set(HEAPU8.subarray(src, src+num), dest);
      return dest;
    }
  Module["_memcpy"] = _memcpy;
FS.staticInit();__ATINIT__.unshift({ func: function() { if (!Module["noFSInit"] && !FS.init.initialized) FS.init() } });__ATMAIN__.push({ func: function() { FS.ignorePermissions = false } });__ATEXIT__.push({ func: function() { FS.quit() } });Module["FS_createFolder"] = FS.createFolder;Module["FS_createPath"] = FS.createPath;Module["FS_createDataFile"] = FS.createDataFile;Module["FS_createPreloadedFile"] = FS.createPreloadedFile;Module["FS_createLazyFile"] = FS.createLazyFile;Module["FS_createLink"] = FS.createLink;Module["FS_createDevice"] = FS.createDevice;
___errno_state = Runtime.staticAlloc(4); HEAP32[((___errno_state)>>2)]=0;
__ATINIT__.unshift({ func: function() { TTY.init() } });__ATEXIT__.push({ func: function() { TTY.shutdown() } });TTY.utf8 = new Runtime.UTF8Processor();
if (ENVIRONMENT_IS_NODE) { var fs = require("fs"); NODEFS.staticInit(); }
__ATINIT__.push({ func: function() { SOCKFS.root = FS.mount(SOCKFS, {}, null); } });
_fputc.ret = allocate([0], "i8", ALLOC_STATIC);
Module["requestFullScreen"] = function Module_requestFullScreen(lockPointer, resizeCanvas) { Browser.requestFullScreen(lockPointer, resizeCanvas) };
  Module["requestAnimationFrame"] = function Module_requestAnimationFrame(func) { Browser.requestAnimationFrame(func) };
  Module["setCanvasSize"] = function Module_setCanvasSize(width, height, noUpdates) { Browser.setCanvasSize(width, height, noUpdates) };
  Module["pauseMainLoop"] = function Module_pauseMainLoop() { Browser.mainLoop.pause() };
  Module["resumeMainLoop"] = function Module_resumeMainLoop() { Browser.mainLoop.resume() };
  Module["getUserMedia"] = function Module_getUserMedia() { Browser.getUserMedia() }
STACK_BASE = STACKTOP = Runtime.alignMemory(STATICTOP);

staticSealed = true; // seal the static portion of memory

STACK_MAX = STACK_BASE + 5242880;

DYNAMIC_BASE = DYNAMICTOP = Runtime.alignMemory(STACK_MAX);

assert(DYNAMIC_BASE < TOTAL_MEMORY, "TOTAL_MEMORY not big enough for stack");


var Math_min = Math.min;
function invoke_iiii(index,a1,a2,a3) {
  try {
    return Module["dynCall_iiii"](index,a1,a2,a3);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_vii(index,a1,a2) {
  try {
    Module["dynCall_vii"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function invoke_iii(index,a1,a2) {
  try {
    return Module["dynCall_iii"](index,a1,a2);
  } catch(e) {
    if (typeof e !== 'number' && e !== 'longjmp') throw e;
    asm["setThrew"](1, 0);
  }
}

function asmPrintInt(x, y) {
  Module.print('int ' + x + ',' + y);// + ' ' + new Error().stack);
}
function asmPrintFloat(x, y) {
  Module.print('float ' + x + ',' + y);// + ' ' + new Error().stack);
}
// EMSCRIPTEN_START_ASM
var ModuleFunc;
var asm = (ModuleFunc = function(global, env, buffer) {
  'use asm';
  var HEAP8 = new global.Int8Array(buffer);
  var HEAP16 = new global.Int16Array(buffer);
  var HEAP32 = new global.Int32Array(buffer);
  var HEAPU8 = new global.Uint8Array(buffer);
  var HEAPU16 = new global.Uint16Array(buffer);
  var HEAPU32 = new global.Uint32Array(buffer);
  var HEAPF32 = new global.Float32Array(buffer);
  var HEAPF64 = new global.Float64Array(buffer);

  var STACKTOP=env.STACKTOP|0;
  var STACK_MAX=env.STACK_MAX|0;
  var tempDoublePtr=env.tempDoublePtr|0;
  var ABORT=env.ABORT|0;

  var __THREW__ = 0;
  var threwValue = 0;
  var setjmpId = 0;
  var undef = 0;
  var nan = +env.NaN, inf = +env.Infinity;
  var tempInt = 0, tempBigInt = 0, tempBigIntP = 0, tempBigIntS = 0, tempBigIntR = 0.0, tempBigIntI = 0, tempBigIntD = 0, tempValue = 0, tempDouble = 0.0;

  var tempRet0 = 0;
  var tempRet1 = 0;
  var tempRet2 = 0;
  var tempRet3 = 0;
  var tempRet4 = 0;
  var tempRet5 = 0;
  var tempRet6 = 0;
  var tempRet7 = 0;
  var tempRet8 = 0;
  var tempRet9 = 0;
  var Math_floor=global.Math.floor;
  var Math_abs=global.Math.abs;
  var Math_sqrt=global.Math.sqrt;
  var Math_pow=global.Math.pow;
  var Math_cos=global.Math.cos;
  var Math_sin=global.Math.sin;
  var Math_tan=global.Math.tan;
  var Math_acos=global.Math.acos;
  var Math_asin=global.Math.asin;
  var Math_atan=global.Math.atan;
  var Math_atan2=global.Math.atan2;
  var Math_exp=global.Math.exp;
  var Math_log=global.Math.log;
  var Math_ceil=global.Math.ceil;
  var Math_imul=global.Math.imul;
  var abort=env.abort;
  var assert=env.assert;
  var asmPrintInt=env.asmPrintInt;
  var asmPrintFloat=env.asmPrintFloat;
  var Math_min=env.min;
  var invoke_iiii=env.invoke_iiii;
  var invoke_vii=env.invoke_vii;
  var invoke_iii=env.invoke_iii;
  var _send=env._send;
  var ___setErrNo=env.___setErrNo;
  var ___assert_fail=env.___assert_fail;
  var _fflush=env._fflush;
  var _pwrite=env._pwrite;
  var __reallyNegative=env.__reallyNegative;
  var _sbrk=env._sbrk;
  var ___errno_location=env.___errno_location;
  var _emscripten_memcpy_big=env._emscripten_memcpy_big;
  var _fileno=env._fileno;
  var _sysconf=env._sysconf;
  var _puts=env._puts;
  var _mkport=env._mkport;
  var _write=env._write;
  var _llvm_bswap_i32=env._llvm_bswap_i32;
  var _fputc=env._fputc;
  var _abort=env._abort;
  var _fwrite=env._fwrite;
  var _time=env._time;
  var _fprintf=env._fprintf;
  var __formatString=env.__formatString;
  var _fputs=env._fputs;
  var _printf=env._printf;
  var tempFloat = 0.0;

// EMSCRIPTEN_START_FUNCS
function _inflate(i2, i3) {
 i2 = i2 | 0;
 i3 = i3 | 0;
 var i1 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0, i38 = 0, i39 = 0, i40 = 0, i41 = 0, i42 = 0, i43 = 0, i44 = 0, i45 = 0, i46 = 0, i47 = 0, i48 = 0, i49 = 0, i50 = 0, i51 = 0, i52 = 0, i53 = 0, i54 = 0, i55 = 0, i56 = 0, i57 = 0, i58 = 0, i59 = 0, i60 = 0, i61 = 0, i62 = 0, i63 = 0, i64 = 0, i65 = 0, i66 = 0, i67 = 0, i68 = 0, i69 = 0, i70 = 0, i71 = 0, i72 = 0;
 i1 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i25 = i1;
 if ((i2 | 0) == 0) {
  i72 = -2;
  STACKTOP = i1;
  return i72 | 0;
 }
 i4 = HEAP32[i2 + 28 >> 2] | 0;
 if ((i4 | 0) == 0) {
  i72 = -2;
  STACKTOP = i1;
  return i72 | 0;
 }
 i8 = i2 + 12 | 0;
 i19 = HEAP32[i8 >> 2] | 0;
 if ((i19 | 0) == 0) {
  i72 = -2;
  STACKTOP = i1;
  return i72 | 0;
 }
 i62 = HEAP32[i2 >> 2] | 0;
 if ((i62 | 0) == 0 ? (HEAP32[i2 + 4 >> 2] | 0) != 0 : 0) {
  i72 = -2;
  STACKTOP = i1;
  return i72 | 0;
 }
 i68 = HEAP32[i4 >> 2] | 0;
 if ((i68 | 0) == 11) {
  HEAP32[i4 >> 2] = 12;
  i68 = 12;
  i62 = HEAP32[i2 >> 2] | 0;
  i19 = HEAP32[i8 >> 2] | 0;
 }
 i15 = i2 + 16 | 0;
 i59 = HEAP32[i15 >> 2] | 0;
 i16 = i2 + 4 | 0;
 i5 = HEAP32[i16 >> 2] | 0;
 i17 = i4 + 56 | 0;
 i6 = i4 + 60 | 0;
 i12 = i4 + 8 | 0;
 i10 = i4 + 24 | 0;
 i39 = i25 + 1 | 0;
 i11 = i4 + 16 | 0;
 i38 = i4 + 32 | 0;
 i35 = i2 + 24 | 0;
 i40 = i4 + 36 | 0;
 i41 = i4 + 20 | 0;
 i9 = i2 + 48 | 0;
 i42 = i4 + 64 | 0;
 i46 = i4 + 12 | 0;
 i47 = (i3 + -5 | 0) >>> 0 < 2;
 i7 = i4 + 4 | 0;
 i48 = i4 + 76 | 0;
 i49 = i4 + 84 | 0;
 i50 = i4 + 80 | 0;
 i51 = i4 + 88 | 0;
 i43 = (i3 | 0) == 6;
 i57 = i4 + 7108 | 0;
 i37 = i4 + 72 | 0;
 i58 = i4 + 7112 | 0;
 i54 = i4 + 68 | 0;
 i28 = i4 + 44 | 0;
 i29 = i4 + 7104 | 0;
 i30 = i4 + 48 | 0;
 i31 = i4 + 52 | 0;
 i18 = i4 + 40 | 0;
 i13 = i2 + 20 | 0;
 i14 = i4 + 28 | 0;
 i32 = i4 + 96 | 0;
 i33 = i4 + 100 | 0;
 i34 = i4 + 92 | 0;
 i36 = i4 + 104 | 0;
 i52 = i4 + 1328 | 0;
 i53 = i4 + 108 | 0;
 i27 = i4 + 112 | 0;
 i55 = i4 + 752 | 0;
 i56 = i4 + 624 | 0;
 i44 = i25 + 2 | 0;
 i45 = i25 + 3 | 0;
 i67 = HEAP32[i6 >> 2] | 0;
 i65 = i5;
 i64 = HEAP32[i17 >> 2] | 0;
 i26 = i59;
 i61 = 0;
 L17 : while (1) {
  L19 : do {
   switch (i68 | 0) {
   case 16:
    {
     if (i67 >>> 0 < 14) {
      i63 = i67;
      while (1) {
       if ((i65 | 0) == 0) {
        i65 = 0;
        break L17;
       }
       i65 = i65 + -1 | 0;
       i66 = i62 + 1 | 0;
       i64 = (HEAPU8[i62] << i63) + i64 | 0;
       i63 = i63 + 8 | 0;
       if (i63 >>> 0 < 14) {
        i62 = i66;
       } else {
        i62 = i66;
        break;
       }
      }
     } else {
      i63 = i67;
     }
     i71 = (i64 & 31) + 257 | 0;
     HEAP32[i32 >> 2] = i71;
     i72 = (i64 >>> 5 & 31) + 1 | 0;
     HEAP32[i33 >> 2] = i72;
     HEAP32[i34 >> 2] = (i64 >>> 10 & 15) + 4;
     i64 = i64 >>> 14;
     i63 = i63 + -14 | 0;
     if (i71 >>> 0 > 286 | i72 >>> 0 > 30) {
      HEAP32[i35 >> 2] = 11616;
      HEAP32[i4 >> 2] = 29;
      i66 = i26;
      break L19;
     } else {
      HEAP32[i36 >> 2] = 0;
      HEAP32[i4 >> 2] = 17;
      i66 = 0;
      i60 = 154;
      break L19;
     }
    }
   case 2:
    {
     if (i67 >>> 0 < 32) {
      i63 = i67;
      i60 = 47;
     } else {
      i60 = 49;
     }
     break;
    }
   case 23:
    {
     i66 = HEAP32[i37 >> 2] | 0;
     i63 = i67;
     i60 = 240;
     break;
    }
   case 18:
    {
     i63 = HEAP32[i36 >> 2] | 0;
     i69 = i65;
     i60 = 164;
     break;
    }
   case 1:
    {
     if (i67 >>> 0 < 16) {
      i63 = i67;
      while (1) {
       if ((i65 | 0) == 0) {
        i65 = 0;
        break L17;
       }
       i65 = i65 + -1 | 0;
       i66 = i62 + 1 | 0;
       i64 = (HEAPU8[i62] << i63) + i64 | 0;
       i63 = i63 + 8 | 0;
       if (i63 >>> 0 < 16) {
        i62 = i66;
       } else {
        i62 = i66;
        break;
       }
      }
     } else {
      i63 = i67;
     }
     HEAP32[i11 >> 2] = i64;
     if ((i64 & 255 | 0) != 8) {
      HEAP32[i35 >> 2] = 11448;
      HEAP32[i4 >> 2] = 29;
      i66 = i26;
      break L19;
     }
     if ((i64 & 57344 | 0) != 0) {
      HEAP32[i35 >> 2] = 11504;
      HEAP32[i4 >> 2] = 29;
      i66 = i26;
      break L19;
     }
     i60 = HEAP32[i38 >> 2] | 0;
     if ((i60 | 0) == 0) {
      i60 = i64;
     } else {
      HEAP32[i60 >> 2] = i64 >>> 8 & 1;
      i60 = HEAP32[i11 >> 2] | 0;
     }
     if ((i60 & 512 | 0) != 0) {
      HEAP8[i25] = i64;
      HEAP8[i39] = i64 >>> 8;
      HEAP32[i10 >> 2] = _crc32(HEAP32[i10 >> 2] | 0, i25, 2) | 0;
     }
     HEAP32[i4 >> 2] = 2;
     i63 = 0;
     i64 = 0;
     i60 = 47;
     break;
    }
   case 8:
    {
     i63 = i67;
     i60 = 109;
     break;
    }
   case 22:
    {
     i63 = i67;
     i60 = 228;
     break;
    }
   case 24:
    {
     i63 = i67;
     i60 = 246;
     break;
    }
   case 19:
    {
     i63 = i67;
     i60 = 201;
     break;
    }
   case 20:
    {
     i63 = i67;
     i60 = 202;
     break;
    }
   case 21:
    {
     i66 = HEAP32[i37 >> 2] | 0;
     i63 = i67;
     i60 = 221;
     break;
    }
   case 10:
    {
     i63 = i67;
     i60 = 121;
     break;
    }
   case 11:
    {
     i63 = i67;
     i60 = 124;
     break;
    }
   case 12:
    {
     i63 = i67;
     i60 = 125;
     break;
    }
   case 5:
    {
     i63 = i67;
     i60 = 73;
     break;
    }
   case 4:
    {
     i63 = i67;
     i60 = 62;
     break;
    }
   case 0:
    {
     i66 = HEAP32[i12 >> 2] | 0;
     if ((i66 | 0) == 0) {
      HEAP32[i4 >> 2] = 12;
      i63 = i67;
      i66 = i26;
      break L19;
     }
     if (i67 >>> 0 < 16) {
      i63 = i67;
      while (1) {
       if ((i65 | 0) == 0) {
        i65 = 0;
        break L17;
       }
       i65 = i65 + -1 | 0;
       i67 = i62 + 1 | 0;
       i64 = (HEAPU8[i62] << i63) + i64 | 0;
       i63 = i63 + 8 | 0;
       if (i63 >>> 0 < 16) {
        i62 = i67;
       } else {
        i62 = i67;
        break;
       }
      }
     } else {
      i63 = i67;
     }
     if ((i66 & 2 | 0) != 0 & (i64 | 0) == 35615) {
      HEAP32[i10 >> 2] = _crc32(0, 0, 0) | 0;
      HEAP8[i25] = 31;
      HEAP8[i39] = -117;
      HEAP32[i10 >> 2] = _crc32(HEAP32[i10 >> 2] | 0, i25, 2) | 0;
      HEAP32[i4 >> 2] = 1;
      i63 = 0;
      i64 = 0;
      i66 = i26;
      break L19;
     }
     HEAP32[i11 >> 2] = 0;
     i67 = HEAP32[i38 >> 2] | 0;
     if ((i67 | 0) != 0) {
      HEAP32[i67 + 48 >> 2] = -1;
      i66 = HEAP32[i12 >> 2] | 0;
     }
     if ((i66 & 1 | 0) != 0 ? ((((i64 << 8 & 65280) + (i64 >>> 8) | 0) >>> 0) % 31 | 0 | 0) == 0 : 0) {
      if ((i64 & 15 | 0) != 8) {
       HEAP32[i35 >> 2] = 11448;
       HEAP32[i4 >> 2] = 29;
       i66 = i26;
       break L19;
      }
      i66 = i64 >>> 4;
      i63 = i63 + -4 | 0;
      i68 = (i66 & 15) + 8 | 0;
      i67 = HEAP32[i40 >> 2] | 0;
      if ((i67 | 0) != 0) {
       if (i68 >>> 0 > i67 >>> 0) {
        HEAP32[i35 >> 2] = 11480;
        HEAP32[i4 >> 2] = 29;
        i64 = i66;
        i66 = i26;
        break L19;
       }
      } else {
       HEAP32[i40 >> 2] = i68;
      }
      HEAP32[i41 >> 2] = 1 << i68;
      i63 = _adler32(0, 0, 0) | 0;
      HEAP32[i10 >> 2] = i63;
      HEAP32[i9 >> 2] = i63;
      HEAP32[i4 >> 2] = i64 >>> 12 & 2 ^ 11;
      i63 = 0;
      i64 = 0;
      i66 = i26;
      break L19;
     }
     HEAP32[i35 >> 2] = 11424;
     HEAP32[i4 >> 2] = 29;
     i66 = i26;
     break;
    }
   case 26:
    {
     if ((HEAP32[i12 >> 2] | 0) != 0) {
      if (i67 >>> 0 < 32) {
       i63 = i67;
       while (1) {
        if ((i65 | 0) == 0) {
         i65 = 0;
         break L17;
        }
        i65 = i65 + -1 | 0;
        i66 = i62 + 1 | 0;
        i64 = (HEAPU8[i62] << i63) + i64 | 0;
        i63 = i63 + 8 | 0;
        if (i63 >>> 0 < 32) {
         i62 = i66;
        } else {
         i62 = i66;
         break;
        }
       }
      } else {
       i63 = i67;
      }
      i66 = i59 - i26 | 0;
      HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + i66;
      HEAP32[i14 >> 2] = (HEAP32[i14 >> 2] | 0) + i66;
      if ((i59 | 0) != (i26 | 0)) {
       i59 = HEAP32[i10 >> 2] | 0;
       i67 = i19 + (0 - i66) | 0;
       if ((HEAP32[i11 >> 2] | 0) == 0) {
        i59 = _adler32(i59, i67, i66) | 0;
       } else {
        i59 = _crc32(i59, i67, i66) | 0;
       }
       HEAP32[i10 >> 2] = i59;
       HEAP32[i9 >> 2] = i59;
      }
      if ((HEAP32[i11 >> 2] | 0) == 0) {
       i59 = _llvm_bswap_i32(i64 | 0) | 0;
      } else {
       i59 = i64;
      }
      if ((i59 | 0) == (HEAP32[i10 >> 2] | 0)) {
       i63 = 0;
       i64 = 0;
       i59 = i26;
      } else {
       HEAP32[i35 >> 2] = 11904;
       HEAP32[i4 >> 2] = 29;
       i66 = i26;
       i59 = i26;
       break L19;
      }
     } else {
      i63 = i67;
     }
     HEAP32[i4 >> 2] = 27;
     i60 = 277;
     break;
    }
   case 27:
    {
     i63 = i67;
     i60 = 277;
     break;
    }
   case 28:
    {
     i63 = i67;
     i61 = 1;
     i60 = 285;
     break L17;
    }
   case 29:
    {
     i63 = i67;
     i61 = -3;
     break L17;
    }
   case 25:
    {
     if ((i26 | 0) == 0) {
      i63 = i67;
      i26 = 0;
      i60 = 285;
      break L17;
     }
     HEAP8[i19] = HEAP32[i42 >> 2];
     HEAP32[i4 >> 2] = 20;
     i63 = i67;
     i66 = i26 + -1 | 0;
     i19 = i19 + 1 | 0;
     break;
    }
   case 17:
    {
     i66 = HEAP32[i36 >> 2] | 0;
     if (i66 >>> 0 < (HEAP32[i34 >> 2] | 0) >>> 0) {
      i63 = i67;
      i60 = 154;
     } else {
      i60 = 158;
     }
     break;
    }
   case 13:
    {
     i63 = i67 & 7;
     i64 = i64 >>> i63;
     i63 = i67 - i63 | 0;
     if (i63 >>> 0 < 32) {
      while (1) {
       if ((i65 | 0) == 0) {
        i65 = 0;
        break L17;
       }
       i65 = i65 + -1 | 0;
       i66 = i62 + 1 | 0;
       i64 = (HEAPU8[i62] << i63) + i64 | 0;
       i63 = i63 + 8 | 0;
       if (i63 >>> 0 < 32) {
        i62 = i66;
       } else {
        i62 = i66;
        break;
       }
      }
     }
     i66 = i64 & 65535;
     if ((i66 | 0) == (i64 >>> 16 ^ 65535 | 0)) {
      HEAP32[i42 >> 2] = i66;
      HEAP32[i4 >> 2] = 14;
      if (i43) {
       i63 = 0;
       i64 = 0;
       i60 = 285;
       break L17;
      } else {
       i63 = 0;
       i64 = 0;
       i60 = 143;
       break L19;
      }
     } else {
      HEAP32[i35 >> 2] = 11584;
      HEAP32[i4 >> 2] = 29;
      i66 = i26;
      break L19;
     }
    }
   case 7:
    {
     i63 = i67;
     i60 = 96;
     break;
    }
   case 14:
    {
     i63 = i67;
     i60 = 143;
     break;
    }
   case 15:
    {
     i63 = i67;
     i60 = 144;
     break;
    }
   case 9:
    {
     if (i67 >>> 0 < 32) {
      i63 = i67;
      while (1) {
       if ((i65 | 0) == 0) {
        i65 = 0;
        break L17;
       }
       i65 = i65 + -1 | 0;
       i66 = i62 + 1 | 0;
       i64 = (HEAPU8[i62] << i63) + i64 | 0;
       i63 = i63 + 8 | 0;
       if (i63 >>> 0 < 32) {
        i62 = i66;
       } else {
        i62 = i66;
        break;
       }
      }
     }
     i63 = _llvm_bswap_i32(i64 | 0) | 0;
     HEAP32[i10 >> 2] = i63;
     HEAP32[i9 >> 2] = i63;
     HEAP32[i4 >> 2] = 10;
     i63 = 0;
     i64 = 0;
     i60 = 121;
     break;
    }
   case 30:
    {
     i60 = 299;
     break L17;
    }
   case 6:
    {
     i63 = i67;
     i60 = 83;
     break;
    }
   case 3:
    {
     if (i67 >>> 0 < 16) {
      i63 = i67;
      i66 = i62;
      i60 = 55;
     } else {
      i60 = 57;
     }
     break;
    }
   default:
    {
     i2 = -2;
     i60 = 300;
     break L17;
    }
   }
  } while (0);
  if ((i60 | 0) == 47) {
   while (1) {
    i60 = 0;
    if ((i65 | 0) == 0) {
     i65 = 0;
     break L17;
    }
    i65 = i65 + -1 | 0;
    i60 = i62 + 1 | 0;
    i64 = (HEAPU8[i62] << i63) + i64 | 0;
    i63 = i63 + 8 | 0;
    if (i63 >>> 0 < 32) {
     i62 = i60;
     i60 = 47;
    } else {
     i62 = i60;
     i60 = 49;
     break;
    }
   }
  } else if ((i60 | 0) == 121) {
   if ((HEAP32[i46 >> 2] | 0) == 0) {
    i60 = 122;
    break;
   }
   i60 = _adler32(0, 0, 0) | 0;
   HEAP32[i10 >> 2] = i60;
   HEAP32[i9 >> 2] = i60;
   HEAP32[i4 >> 2] = 11;
   i60 = 124;
  } else if ((i60 | 0) == 143) {
   HEAP32[i4 >> 2] = 15;
   i60 = 144;
  } else if ((i60 | 0) == 154) {
   while (1) {
    i60 = 0;
    if (i63 >>> 0 < 3) {
     while (1) {
      if ((i65 | 0) == 0) {
       i65 = 0;
       break L17;
      }
      i65 = i65 + -1 | 0;
      i67 = i62 + 1 | 0;
      i64 = (HEAPU8[i62] << i63) + i64 | 0;
      i63 = i63 + 8 | 0;
      if (i63 >>> 0 < 3) {
       i62 = i67;
      } else {
       i62 = i67;
       break;
      }
     }
    }
    HEAP32[i36 >> 2] = i66 + 1;
    HEAP16[i4 + (HEAPU16[11384 + (i66 << 1) >> 1] << 1) + 112 >> 1] = i64 & 7;
    i64 = i64 >>> 3;
    i63 = i63 + -3 | 0;
    i66 = HEAP32[i36 >> 2] | 0;
    if (i66 >>> 0 < (HEAP32[i34 >> 2] | 0) >>> 0) {
     i60 = 154;
    } else {
     i67 = i63;
     i60 = 158;
     break;
    }
   }
  } else if ((i60 | 0) == 277) {
   i60 = 0;
   if ((HEAP32[i12 >> 2] | 0) == 0) {
    i60 = 284;
    break;
   }
   if ((HEAP32[i11 >> 2] | 0) == 0) {
    i60 = 284;
    break;
   }
   if (i63 >>> 0 < 32) {
    i66 = i62;
    while (1) {
     if ((i65 | 0) == 0) {
      i65 = 0;
      i62 = i66;
      break L17;
     }
     i65 = i65 + -1 | 0;
     i62 = i66 + 1 | 0;
     i64 = (HEAPU8[i66] << i63) + i64 | 0;
     i63 = i63 + 8 | 0;
     if (i63 >>> 0 < 32) {
      i66 = i62;
     } else {
      break;
     }
    }
   }
   if ((i64 | 0) == (HEAP32[i14 >> 2] | 0)) {
    i63 = 0;
    i64 = 0;
    i60 = 284;
    break;
   }
   HEAP32[i35 >> 2] = 11928;
   HEAP32[i4 >> 2] = 29;
   i66 = i26;
  }
  do {
   if ((i60 | 0) == 49) {
    i60 = HEAP32[i38 >> 2] | 0;
    if ((i60 | 0) != 0) {
     HEAP32[i60 + 4 >> 2] = i64;
    }
    if ((HEAP32[i11 >> 2] & 512 | 0) != 0) {
     HEAP8[i25] = i64;
     HEAP8[i39] = i64 >>> 8;
     HEAP8[i44] = i64 >>> 16;
     HEAP8[i45] = i64 >>> 24;
     HEAP32[i10 >> 2] = _crc32(HEAP32[i10 >> 2] | 0, i25, 4) | 0;
    }
    HEAP32[i4 >> 2] = 3;
    i63 = 0;
    i64 = 0;
    i66 = i62;
    i60 = 55;
   } else if ((i60 | 0) == 124) {
    if (i47) {
     i60 = 285;
     break L17;
    } else {
     i60 = 125;
    }
   } else if ((i60 | 0) == 144) {
    i60 = 0;
    i66 = HEAP32[i42 >> 2] | 0;
    if ((i66 | 0) == 0) {
     HEAP32[i4 >> 2] = 11;
     i66 = i26;
     break;
    }
    i66 = i66 >>> 0 > i65 >>> 0 ? i65 : i66;
    i67 = i66 >>> 0 > i26 >>> 0 ? i26 : i66;
    if ((i67 | 0) == 0) {
     i60 = 285;
     break L17;
    }
    _memcpy(i19 | 0, i62 | 0, i67 | 0) | 0;
    HEAP32[i42 >> 2] = (HEAP32[i42 >> 2] | 0) - i67;
    i65 = i65 - i67 | 0;
    i66 = i26 - i67 | 0;
    i62 = i62 + i67 | 0;
    i19 = i19 + i67 | 0;
   } else if ((i60 | 0) == 158) {
    i60 = 0;
    if (i66 >>> 0 < 19) {
     while (1) {
      i61 = i66 + 1 | 0;
      HEAP16[i4 + (HEAPU16[11384 + (i66 << 1) >> 1] << 1) + 112 >> 1] = 0;
      if ((i61 | 0) == 19) {
       break;
      } else {
       i66 = i61;
      }
     }
     HEAP32[i36 >> 2] = 19;
    }
    HEAP32[i53 >> 2] = i52;
    HEAP32[i48 >> 2] = i52;
    HEAP32[i49 >> 2] = 7;
    i61 = _inflate_table(0, i27, 19, i53, i49, i55) | 0;
    if ((i61 | 0) == 0) {
     HEAP32[i36 >> 2] = 0;
     HEAP32[i4 >> 2] = 18;
     i63 = 0;
     i69 = i65;
     i61 = 0;
     i60 = 164;
     break;
    } else {
     HEAP32[i35 >> 2] = 11656;
     HEAP32[i4 >> 2] = 29;
     i63 = i67;
     i66 = i26;
     break;
    }
   }
  } while (0);
  L163 : do {
   if ((i60 | 0) == 55) {
    while (1) {
     i60 = 0;
     if ((i65 | 0) == 0) {
      i65 = 0;
      i62 = i66;
      break L17;
     }
     i65 = i65 + -1 | 0;
     i62 = i66 + 1 | 0;
     i64 = (HEAPU8[i66] << i63) + i64 | 0;
     i63 = i63 + 8 | 0;
     if (i63 >>> 0 < 16) {
      i66 = i62;
      i60 = 55;
     } else {
      i60 = 57;
      break;
     }
    }
   } else if ((i60 | 0) == 125) {
    i60 = 0;
    if ((HEAP32[i7 >> 2] | 0) != 0) {
     i66 = i63 & 7;
     HEAP32[i4 >> 2] = 26;
     i63 = i63 - i66 | 0;
     i64 = i64 >>> i66;
     i66 = i26;
     break;
    }
    if (i63 >>> 0 < 3) {
     while (1) {
      if ((i65 | 0) == 0) {
       i65 = 0;
       break L17;
      }
      i65 = i65 + -1 | 0;
      i66 = i62 + 1 | 0;
      i64 = (HEAPU8[i62] << i63) + i64 | 0;
      i63 = i63 + 8 | 0;
      if (i63 >>> 0 < 3) {
       i62 = i66;
      } else {
       i62 = i66;
       break;
      }
     }
    }
    HEAP32[i7 >> 2] = i64 & 1;
    i66 = i64 >>> 1 & 3;
    if ((i66 | 0) == 0) {
     HEAP32[i4 >> 2] = 13;
    } else if ((i66 | 0) == 1) {
     HEAP32[i48 >> 2] = 11952;
     HEAP32[i49 >> 2] = 9;
     HEAP32[i50 >> 2] = 14e3;
     HEAP32[i51 >> 2] = 5;
     HEAP32[i4 >> 2] = 19;
     if (i43) {
      i60 = 133;
      break L17;
     }
    } else if ((i66 | 0) == 2) {
     HEAP32[i4 >> 2] = 16;
    } else if ((i66 | 0) == 3) {
     HEAP32[i35 >> 2] = 11560;
     HEAP32[i4 >> 2] = 29;
    }
    i63 = i63 + -3 | 0;
    i64 = i64 >>> 3;
    i66 = i26;
   } else if ((i60 | 0) == 164) {
    i60 = 0;
    i65 = HEAP32[i32 >> 2] | 0;
    i66 = HEAP32[i33 >> 2] | 0;
    do {
     if (i63 >>> 0 < (i66 + i65 | 0) >>> 0) {
      i71 = i67;
      L181 : while (1) {
       i70 = (1 << HEAP32[i49 >> 2]) + -1 | 0;
       i72 = i70 & i64;
       i68 = HEAP32[i48 >> 2] | 0;
       i67 = HEAPU8[i68 + (i72 << 2) + 1 | 0] | 0;
       if (i67 >>> 0 > i71 >>> 0) {
        i67 = i71;
        while (1) {
         if ((i69 | 0) == 0) {
          i63 = i67;
          i65 = 0;
          break L17;
         }
         i69 = i69 + -1 | 0;
         i71 = i62 + 1 | 0;
         i64 = (HEAPU8[i62] << i67) + i64 | 0;
         i62 = i67 + 8 | 0;
         i72 = i70 & i64;
         i67 = HEAPU8[i68 + (i72 << 2) + 1 | 0] | 0;
         if (i67 >>> 0 > i62 >>> 0) {
          i67 = i62;
          i62 = i71;
         } else {
          i70 = i62;
          i62 = i71;
          break;
         }
        }
       } else {
        i70 = i71;
       }
       i68 = HEAP16[i68 + (i72 << 2) + 2 >> 1] | 0;
       L188 : do {
        if ((i68 & 65535) < 16) {
         if (i70 >>> 0 < i67 >>> 0) {
          while (1) {
           if ((i69 | 0) == 0) {
            i63 = i70;
            i65 = 0;
            break L17;
           }
           i69 = i69 + -1 | 0;
           i65 = i62 + 1 | 0;
           i64 = (HEAPU8[i62] << i70) + i64 | 0;
           i70 = i70 + 8 | 0;
           if (i70 >>> 0 < i67 >>> 0) {
            i62 = i65;
           } else {
            i62 = i65;
            break;
           }
          }
         }
         HEAP32[i36 >> 2] = i63 + 1;
         HEAP16[i4 + (i63 << 1) + 112 >> 1] = i68;
         i71 = i70 - i67 | 0;
         i64 = i64 >>> i67;
        } else {
         if (i68 << 16 >> 16 == 16) {
          i68 = i67 + 2 | 0;
          if (i70 >>> 0 < i68 >>> 0) {
           i71 = i62;
           while (1) {
            if ((i69 | 0) == 0) {
             i63 = i70;
             i65 = 0;
             i62 = i71;
             break L17;
            }
            i69 = i69 + -1 | 0;
            i62 = i71 + 1 | 0;
            i64 = (HEAPU8[i71] << i70) + i64 | 0;
            i70 = i70 + 8 | 0;
            if (i70 >>> 0 < i68 >>> 0) {
             i71 = i62;
            } else {
             break;
            }
           }
          }
          i64 = i64 >>> i67;
          i67 = i70 - i67 | 0;
          if ((i63 | 0) == 0) {
           i60 = 181;
           break L181;
          }
          i67 = i67 + -2 | 0;
          i68 = (i64 & 3) + 3 | 0;
          i64 = i64 >>> 2;
          i70 = HEAP16[i4 + (i63 + -1 << 1) + 112 >> 1] | 0;
         } else if (i68 << 16 >> 16 == 17) {
          i68 = i67 + 3 | 0;
          if (i70 >>> 0 < i68 >>> 0) {
           i71 = i62;
           while (1) {
            if ((i69 | 0) == 0) {
             i63 = i70;
             i65 = 0;
             i62 = i71;
             break L17;
            }
            i69 = i69 + -1 | 0;
            i62 = i71 + 1 | 0;
            i64 = (HEAPU8[i71] << i70) + i64 | 0;
            i70 = i70 + 8 | 0;
            if (i70 >>> 0 < i68 >>> 0) {
             i71 = i62;
            } else {
             break;
            }
           }
          }
          i64 = i64 >>> i67;
          i67 = -3 - i67 + i70 | 0;
          i68 = (i64 & 7) + 3 | 0;
          i64 = i64 >>> 3;
          i70 = 0;
         } else {
          i68 = i67 + 7 | 0;
          if (i70 >>> 0 < i68 >>> 0) {
           i71 = i62;
           while (1) {
            if ((i69 | 0) == 0) {
             i63 = i70;
             i65 = 0;
             i62 = i71;
             break L17;
            }
            i69 = i69 + -1 | 0;
            i62 = i71 + 1 | 0;
            i64 = (HEAPU8[i71] << i70) + i64 | 0;
            i70 = i70 + 8 | 0;
            if (i70 >>> 0 < i68 >>> 0) {
             i71 = i62;
            } else {
             break;
            }
           }
          }
          i64 = i64 >>> i67;
          i67 = -7 - i67 + i70 | 0;
          i68 = (i64 & 127) + 11 | 0;
          i64 = i64 >>> 7;
          i70 = 0;
         }
         if ((i63 + i68 | 0) >>> 0 > (i66 + i65 | 0) >>> 0) {
          i60 = 190;
          break L181;
         }
         while (1) {
          i68 = i68 + -1 | 0;
          HEAP32[i36 >> 2] = i63 + 1;
          HEAP16[i4 + (i63 << 1) + 112 >> 1] = i70;
          if ((i68 | 0) == 0) {
           i71 = i67;
           break L188;
          }
          i63 = HEAP32[i36 >> 2] | 0;
         }
        }
       } while (0);
       i63 = HEAP32[i36 >> 2] | 0;
       i65 = HEAP32[i32 >> 2] | 0;
       i66 = HEAP32[i33 >> 2] | 0;
       if (!(i63 >>> 0 < (i66 + i65 | 0) >>> 0)) {
        i60 = 193;
        break;
       }
      }
      if ((i60 | 0) == 181) {
       i60 = 0;
       HEAP32[i35 >> 2] = 11688;
       HEAP32[i4 >> 2] = 29;
       i63 = i67;
       i65 = i69;
       i66 = i26;
       break L163;
      } else if ((i60 | 0) == 190) {
       i60 = 0;
       HEAP32[i35 >> 2] = 11688;
       HEAP32[i4 >> 2] = 29;
       i63 = i67;
       i65 = i69;
       i66 = i26;
       break L163;
      } else if ((i60 | 0) == 193) {
       i60 = 0;
       if ((HEAP32[i4 >> 2] | 0) == 29) {
        i63 = i71;
        i65 = i69;
        i66 = i26;
        break L163;
       } else {
        i63 = i71;
        break;
       }
      }
     } else {
      i63 = i67;
     }
    } while (0);
    if ((HEAP16[i56 >> 1] | 0) == 0) {
     HEAP32[i35 >> 2] = 11720;
     HEAP32[i4 >> 2] = 29;
     i65 = i69;
     i66 = i26;
     break;
    }
    HEAP32[i53 >> 2] = i52;
    HEAP32[i48 >> 2] = i52;
    HEAP32[i49 >> 2] = 9;
    i61 = _inflate_table(1, i27, i65, i53, i49, i55) | 0;
    if ((i61 | 0) != 0) {
     HEAP32[i35 >> 2] = 11760;
     HEAP32[i4 >> 2] = 29;
     i65 = i69;
     i66 = i26;
     break;
    }
    HEAP32[i50 >> 2] = HEAP32[i53 >> 2];
    HEAP32[i51 >> 2] = 6;
    i61 = _inflate_table(2, i4 + (HEAP32[i32 >> 2] << 1) + 112 | 0, HEAP32[i33 >> 2] | 0, i53, i51, i55) | 0;
    if ((i61 | 0) == 0) {
     HEAP32[i4 >> 2] = 19;
     if (i43) {
      i65 = i69;
      i61 = 0;
      i60 = 285;
      break L17;
     } else {
      i65 = i69;
      i61 = 0;
      i60 = 201;
      break;
     }
    } else {
     HEAP32[i35 >> 2] = 11792;
     HEAP32[i4 >> 2] = 29;
     i65 = i69;
     i66 = i26;
     break;
    }
   }
  } while (0);
  if ((i60 | 0) == 57) {
   i60 = HEAP32[i38 >> 2] | 0;
   if ((i60 | 0) != 0) {
    HEAP32[i60 + 8 >> 2] = i64 & 255;
    HEAP32[i60 + 12 >> 2] = i64 >>> 8;
   }
   if ((HEAP32[i11 >> 2] & 512 | 0) != 0) {
    HEAP8[i25] = i64;
    HEAP8[i39] = i64 >>> 8;
    HEAP32[i10 >> 2] = _crc32(HEAP32[i10 >> 2] | 0, i25, 2) | 0;
   }
   HEAP32[i4 >> 2] = 4;
   i63 = 0;
   i64 = 0;
   i60 = 62;
  } else if ((i60 | 0) == 201) {
   HEAP32[i4 >> 2] = 20;
   i60 = 202;
  }
  do {
   if ((i60 | 0) == 62) {
    i60 = 0;
    i66 = HEAP32[i11 >> 2] | 0;
    if ((i66 & 1024 | 0) == 0) {
     i60 = HEAP32[i38 >> 2] | 0;
     if ((i60 | 0) != 0) {
      HEAP32[i60 + 16 >> 2] = 0;
     }
    } else {
     if (i63 >>> 0 < 16) {
      while (1) {
       if ((i65 | 0) == 0) {
        i65 = 0;
        break L17;
       }
       i65 = i65 + -1 | 0;
       i67 = i62 + 1 | 0;
       i64 = (HEAPU8[i62] << i63) + i64 | 0;
       i63 = i63 + 8 | 0;
       if (i63 >>> 0 < 16) {
        i62 = i67;
       } else {
        i62 = i67;
        break;
       }
      }
     }
     HEAP32[i42 >> 2] = i64;
     i60 = HEAP32[i38 >> 2] | 0;
     if ((i60 | 0) != 0) {
      HEAP32[i60 + 20 >> 2] = i64;
      i66 = HEAP32[i11 >> 2] | 0;
     }
     if ((i66 & 512 | 0) == 0) {
      i63 = 0;
      i64 = 0;
     } else {
      HEAP8[i25] = i64;
      HEAP8[i39] = i64 >>> 8;
      HEAP32[i10 >> 2] = _crc32(HEAP32[i10 >> 2] | 0, i25, 2) | 0;
      i63 = 0;
      i64 = 0;
     }
    }
    HEAP32[i4 >> 2] = 5;
    i60 = 73;
   } else if ((i60 | 0) == 202) {
    i60 = 0;
    if (i65 >>> 0 > 5 & i26 >>> 0 > 257) {
     HEAP32[i8 >> 2] = i19;
     HEAP32[i15 >> 2] = i26;
     HEAP32[i2 >> 2] = i62;
     HEAP32[i16 >> 2] = i65;
     HEAP32[i17 >> 2] = i64;
     HEAP32[i6 >> 2] = i63;
     _inflate_fast(i2, i59);
     i19 = HEAP32[i8 >> 2] | 0;
     i66 = HEAP32[i15 >> 2] | 0;
     i62 = HEAP32[i2 >> 2] | 0;
     i65 = HEAP32[i16 >> 2] | 0;
     i64 = HEAP32[i17 >> 2] | 0;
     i63 = HEAP32[i6 >> 2] | 0;
     if ((HEAP32[i4 >> 2] | 0) != 11) {
      break;
     }
     HEAP32[i57 >> 2] = -1;
     break;
    }
    HEAP32[i57 >> 2] = 0;
    i69 = (1 << HEAP32[i49 >> 2]) + -1 | 0;
    i71 = i69 & i64;
    i66 = HEAP32[i48 >> 2] | 0;
    i68 = HEAP8[i66 + (i71 << 2) + 1 | 0] | 0;
    i67 = i68 & 255;
    if (i67 >>> 0 > i63 >>> 0) {
     while (1) {
      if ((i65 | 0) == 0) {
       i65 = 0;
       break L17;
      }
      i65 = i65 + -1 | 0;
      i70 = i62 + 1 | 0;
      i64 = (HEAPU8[i62] << i63) + i64 | 0;
      i63 = i63 + 8 | 0;
      i71 = i69 & i64;
      i68 = HEAP8[i66 + (i71 << 2) + 1 | 0] | 0;
      i67 = i68 & 255;
      if (i67 >>> 0 > i63 >>> 0) {
       i62 = i70;
      } else {
       i62 = i70;
       break;
      }
     }
    }
    i69 = HEAP8[i66 + (i71 << 2) | 0] | 0;
    i70 = HEAP16[i66 + (i71 << 2) + 2 >> 1] | 0;
    i71 = i69 & 255;
    if (!(i69 << 24 >> 24 == 0)) {
     if ((i71 & 240 | 0) == 0) {
      i69 = i70 & 65535;
      i70 = (1 << i67 + i71) + -1 | 0;
      i71 = ((i64 & i70) >>> i67) + i69 | 0;
      i68 = HEAP8[i66 + (i71 << 2) + 1 | 0] | 0;
      if (((i68 & 255) + i67 | 0) >>> 0 > i63 >>> 0) {
       while (1) {
        if ((i65 | 0) == 0) {
         i65 = 0;
         break L17;
        }
        i65 = i65 + -1 | 0;
        i71 = i62 + 1 | 0;
        i64 = (HEAPU8[i62] << i63) + i64 | 0;
        i63 = i63 + 8 | 0;
        i62 = ((i64 & i70) >>> i67) + i69 | 0;
        i68 = HEAP8[i66 + (i62 << 2) + 1 | 0] | 0;
        if (((i68 & 255) + i67 | 0) >>> 0 > i63 >>> 0) {
         i62 = i71;
        } else {
         i69 = i62;
         i62 = i71;
         break;
        }
       }
      } else {
       i69 = i71;
      }
      i70 = HEAP16[i66 + (i69 << 2) + 2 >> 1] | 0;
      i69 = HEAP8[i66 + (i69 << 2) | 0] | 0;
      HEAP32[i57 >> 2] = i67;
      i66 = i67;
      i63 = i63 - i67 | 0;
      i64 = i64 >>> i67;
     } else {
      i66 = 0;
     }
    } else {
     i66 = 0;
     i69 = 0;
    }
    i72 = i68 & 255;
    i64 = i64 >>> i72;
    i63 = i63 - i72 | 0;
    HEAP32[i57 >> 2] = i66 + i72;
    HEAP32[i42 >> 2] = i70 & 65535;
    i66 = i69 & 255;
    if (i69 << 24 >> 24 == 0) {
     HEAP32[i4 >> 2] = 25;
     i66 = i26;
     break;
    }
    if ((i66 & 32 | 0) != 0) {
     HEAP32[i57 >> 2] = -1;
     HEAP32[i4 >> 2] = 11;
     i66 = i26;
     break;
    }
    if ((i66 & 64 | 0) == 0) {
     i66 = i66 & 15;
     HEAP32[i37 >> 2] = i66;
     HEAP32[i4 >> 2] = 21;
     i60 = 221;
     break;
    } else {
     HEAP32[i35 >> 2] = 11816;
     HEAP32[i4 >> 2] = 29;
     i66 = i26;
     break;
    }
   }
  } while (0);
  if ((i60 | 0) == 73) {
   i68 = HEAP32[i11 >> 2] | 0;
   if ((i68 & 1024 | 0) != 0) {
    i67 = HEAP32[i42 >> 2] | 0;
    i60 = i67 >>> 0 > i65 >>> 0 ? i65 : i67;
    if ((i60 | 0) != 0) {
     i66 = HEAP32[i38 >> 2] | 0;
     if ((i66 | 0) != 0 ? (i20 = HEAP32[i66 + 16 >> 2] | 0, (i20 | 0) != 0) : 0) {
      i67 = (HEAP32[i66 + 20 >> 2] | 0) - i67 | 0;
      i66 = HEAP32[i66 + 24 >> 2] | 0;
      _memcpy(i20 + i67 | 0, i62 | 0, ((i67 + i60 | 0) >>> 0 > i66 >>> 0 ? i66 - i67 | 0 : i60) | 0) | 0;
      i68 = HEAP32[i11 >> 2] | 0;
     }
     if ((i68 & 512 | 0) != 0) {
      HEAP32[i10 >> 2] = _crc32(HEAP32[i10 >> 2] | 0, i62, i60) | 0;
     }
     i67 = (HEAP32[i42 >> 2] | 0) - i60 | 0;
     HEAP32[i42 >> 2] = i67;
     i65 = i65 - i60 | 0;
     i62 = i62 + i60 | 0;
    }
    if ((i67 | 0) != 0) {
     i60 = 285;
     break;
    }
   }
   HEAP32[i42 >> 2] = 0;
   HEAP32[i4 >> 2] = 6;
   i60 = 83;
  } else if ((i60 | 0) == 221) {
   i60 = 0;
   if ((i66 | 0) == 0) {
    i60 = HEAP32[i42 >> 2] | 0;
   } else {
    if (i63 >>> 0 < i66 >>> 0) {
     while (1) {
      if ((i65 | 0) == 0) {
       i65 = 0;
       break L17;
      }
      i65 = i65 + -1 | 0;
      i67 = i62 + 1 | 0;
      i64 = (HEAPU8[i62] << i63) + i64 | 0;
      i63 = i63 + 8 | 0;
      if (i63 >>> 0 < i66 >>> 0) {
       i62 = i67;
      } else {
       i62 = i67;
       break;
      }
     }
    }
    i60 = (HEAP32[i42 >> 2] | 0) + ((1 << i66) + -1 & i64) | 0;
    HEAP32[i42 >> 2] = i60;
    HEAP32[i57 >> 2] = (HEAP32[i57 >> 2] | 0) + i66;
    i63 = i63 - i66 | 0;
    i64 = i64 >>> i66;
   }
   HEAP32[i58 >> 2] = i60;
   HEAP32[i4 >> 2] = 22;
   i60 = 228;
  }
  do {
   if ((i60 | 0) == 83) {
    if ((HEAP32[i11 >> 2] & 2048 | 0) == 0) {
     i60 = HEAP32[i38 >> 2] | 0;
     if ((i60 | 0) != 0) {
      HEAP32[i60 + 28 >> 2] = 0;
     }
    } else {
     if ((i65 | 0) == 0) {
      i65 = 0;
      i60 = 285;
      break L17;
     } else {
      i66 = 0;
     }
     while (1) {
      i60 = i66 + 1 | 0;
      i67 = HEAP8[i62 + i66 | 0] | 0;
      i66 = HEAP32[i38 >> 2] | 0;
      if (((i66 | 0) != 0 ? (i23 = HEAP32[i66 + 28 >> 2] | 0, (i23 | 0) != 0) : 0) ? (i21 = HEAP32[i42 >> 2] | 0, i21 >>> 0 < (HEAP32[i66 + 32 >> 2] | 0) >>> 0) : 0) {
       HEAP32[i42 >> 2] = i21 + 1;
       HEAP8[i23 + i21 | 0] = i67;
      }
      i66 = i67 << 24 >> 24 != 0;
      if (i66 & i60 >>> 0 < i65 >>> 0) {
       i66 = i60;
      } else {
       break;
      }
     }
     if ((HEAP32[i11 >> 2] & 512 | 0) != 0) {
      HEAP32[i10 >> 2] = _crc32(HEAP32[i10 >> 2] | 0, i62, i60) | 0;
     }
     i65 = i65 - i60 | 0;
     i62 = i62 + i60 | 0;
     if (i66) {
      i60 = 285;
      break L17;
     }
    }
    HEAP32[i42 >> 2] = 0;
    HEAP32[i4 >> 2] = 7;
    i60 = 96;
   } else if ((i60 | 0) == 228) {
    i60 = 0;
    i69 = (1 << HEAP32[i51 >> 2]) + -1 | 0;
    i71 = i69 & i64;
    i66 = HEAP32[i50 >> 2] | 0;
    i68 = HEAP8[i66 + (i71 << 2) + 1 | 0] | 0;
    i67 = i68 & 255;
    if (i67 >>> 0 > i63 >>> 0) {
     while (1) {
      if ((i65 | 0) == 0) {
       i65 = 0;
       break L17;
      }
      i65 = i65 + -1 | 0;
      i70 = i62 + 1 | 0;
      i64 = (HEAPU8[i62] << i63) + i64 | 0;
      i63 = i63 + 8 | 0;
      i71 = i69 & i64;
      i68 = HEAP8[i66 + (i71 << 2) + 1 | 0] | 0;
      i67 = i68 & 255;
      if (i67 >>> 0 > i63 >>> 0) {
       i62 = i70;
      } else {
       i62 = i70;
       break;
      }
     }
    }
    i69 = HEAP8[i66 + (i71 << 2) | 0] | 0;
    i70 = HEAP16[i66 + (i71 << 2) + 2 >> 1] | 0;
    i71 = i69 & 255;
    if ((i71 & 240 | 0) == 0) {
     i69 = i70 & 65535;
     i70 = (1 << i67 + i71) + -1 | 0;
     i71 = ((i64 & i70) >>> i67) + i69 | 0;
     i68 = HEAP8[i66 + (i71 << 2) + 1 | 0] | 0;
     if (((i68 & 255) + i67 | 0) >>> 0 > i63 >>> 0) {
      while (1) {
       if ((i65 | 0) == 0) {
        i65 = 0;
        break L17;
       }
       i65 = i65 + -1 | 0;
       i71 = i62 + 1 | 0;
       i64 = (HEAPU8[i62] << i63) + i64 | 0;
       i63 = i63 + 8 | 0;
       i62 = ((i64 & i70) >>> i67) + i69 | 0;
       i68 = HEAP8[i66 + (i62 << 2) + 1 | 0] | 0;
       if (((i68 & 255) + i67 | 0) >>> 0 > i63 >>> 0) {
        i62 = i71;
       } else {
        i69 = i62;
        i62 = i71;
        break;
       }
      }
     } else {
      i69 = i71;
     }
     i70 = HEAP16[i66 + (i69 << 2) + 2 >> 1] | 0;
     i69 = HEAP8[i66 + (i69 << 2) | 0] | 0;
     i66 = (HEAP32[i57 >> 2] | 0) + i67 | 0;
     HEAP32[i57 >> 2] = i66;
     i63 = i63 - i67 | 0;
     i64 = i64 >>> i67;
    } else {
     i66 = HEAP32[i57 >> 2] | 0;
    }
    i72 = i68 & 255;
    i64 = i64 >>> i72;
    i63 = i63 - i72 | 0;
    HEAP32[i57 >> 2] = i66 + i72;
    i66 = i69 & 255;
    if ((i66 & 64 | 0) == 0) {
     HEAP32[i54 >> 2] = i70 & 65535;
     i66 = i66 & 15;
     HEAP32[i37 >> 2] = i66;
     HEAP32[i4 >> 2] = 23;
     i60 = 240;
     break;
    } else {
     HEAP32[i35 >> 2] = 11848;
     HEAP32[i4 >> 2] = 29;
     i66 = i26;
     break;
    }
   }
  } while (0);
  if ((i60 | 0) == 96) {
   if ((HEAP32[i11 >> 2] & 4096 | 0) == 0) {
    i60 = HEAP32[i38 >> 2] | 0;
    if ((i60 | 0) != 0) {
     HEAP32[i60 + 36 >> 2] = 0;
    }
   } else {
    if ((i65 | 0) == 0) {
     i65 = 0;
     i60 = 285;
     break;
    } else {
     i66 = 0;
    }
    while (1) {
     i60 = i66 + 1 | 0;
     i66 = HEAP8[i62 + i66 | 0] | 0;
     i67 = HEAP32[i38 >> 2] | 0;
     if (((i67 | 0) != 0 ? (i24 = HEAP32[i67 + 36 >> 2] | 0, (i24 | 0) != 0) : 0) ? (i22 = HEAP32[i42 >> 2] | 0, i22 >>> 0 < (HEAP32[i67 + 40 >> 2] | 0) >>> 0) : 0) {
      HEAP32[i42 >> 2] = i22 + 1;
      HEAP8[i24 + i22 | 0] = i66;
     }
     i66 = i66 << 24 >> 24 != 0;
     if (i66 & i60 >>> 0 < i65 >>> 0) {
      i66 = i60;
     } else {
      break;
     }
    }
    if ((HEAP32[i11 >> 2] & 512 | 0) != 0) {
     HEAP32[i10 >> 2] = _crc32(HEAP32[i10 >> 2] | 0, i62, i60) | 0;
    }
    i65 = i65 - i60 | 0;
    i62 = i62 + i60 | 0;
    if (i66) {
     i60 = 285;
     break;
    }
   }
   HEAP32[i4 >> 2] = 8;
   i60 = 109;
  } else if ((i60 | 0) == 240) {
   i60 = 0;
   if ((i66 | 0) != 0) {
    if (i63 >>> 0 < i66 >>> 0) {
     i67 = i62;
     while (1) {
      if ((i65 | 0) == 0) {
       i65 = 0;
       i62 = i67;
       break L17;
      }
      i65 = i65 + -1 | 0;
      i62 = i67 + 1 | 0;
      i64 = (HEAPU8[i67] << i63) + i64 | 0;
      i63 = i63 + 8 | 0;
      if (i63 >>> 0 < i66 >>> 0) {
       i67 = i62;
      } else {
       break;
      }
     }
    }
    HEAP32[i54 >> 2] = (HEAP32[i54 >> 2] | 0) + ((1 << i66) + -1 & i64);
    HEAP32[i57 >> 2] = (HEAP32[i57 >> 2] | 0) + i66;
    i63 = i63 - i66 | 0;
    i64 = i64 >>> i66;
   }
   HEAP32[i4 >> 2] = 24;
   i60 = 246;
  }
  do {
   if ((i60 | 0) == 109) {
    i60 = 0;
    i66 = HEAP32[i11 >> 2] | 0;
    if ((i66 & 512 | 0) != 0) {
     if (i63 >>> 0 < 16) {
      i67 = i62;
      while (1) {
       if ((i65 | 0) == 0) {
        i65 = 0;
        i62 = i67;
        break L17;
       }
       i65 = i65 + -1 | 0;
       i62 = i67 + 1 | 0;
       i64 = (HEAPU8[i67] << i63) + i64 | 0;
       i63 = i63 + 8 | 0;
       if (i63 >>> 0 < 16) {
        i67 = i62;
       } else {
        break;
       }
      }
     }
     if ((i64 | 0) == (HEAP32[i10 >> 2] & 65535 | 0)) {
      i63 = 0;
      i64 = 0;
     } else {
      HEAP32[i35 >> 2] = 11536;
      HEAP32[i4 >> 2] = 29;
      i66 = i26;
      break;
     }
    }
    i67 = HEAP32[i38 >> 2] | 0;
    if ((i67 | 0) != 0) {
     HEAP32[i67 + 44 >> 2] = i66 >>> 9 & 1;
     HEAP32[i67 + 48 >> 2] = 1;
    }
    i66 = _crc32(0, 0, 0) | 0;
    HEAP32[i10 >> 2] = i66;
    HEAP32[i9 >> 2] = i66;
    HEAP32[i4 >> 2] = 11;
    i66 = i26;
   } else if ((i60 | 0) == 246) {
    i60 = 0;
    if ((i26 | 0) == 0) {
     i26 = 0;
     i60 = 285;
     break L17;
    }
    i67 = i59 - i26 | 0;
    i66 = HEAP32[i54 >> 2] | 0;
    if (i66 >>> 0 > i67 >>> 0) {
     i67 = i66 - i67 | 0;
     if (i67 >>> 0 > (HEAP32[i28 >> 2] | 0) >>> 0 ? (HEAP32[i29 >> 2] | 0) != 0 : 0) {
      HEAP32[i35 >> 2] = 11872;
      HEAP32[i4 >> 2] = 29;
      i66 = i26;
      break;
     }
     i68 = HEAP32[i30 >> 2] | 0;
     if (i67 >>> 0 > i68 >>> 0) {
      i68 = i67 - i68 | 0;
      i66 = i68;
      i68 = (HEAP32[i31 >> 2] | 0) + ((HEAP32[i18 >> 2] | 0) - i68) | 0;
     } else {
      i66 = i67;
      i68 = (HEAP32[i31 >> 2] | 0) + (i68 - i67) | 0;
     }
     i69 = HEAP32[i42 >> 2] | 0;
     i67 = i69;
     i69 = i66 >>> 0 > i69 >>> 0 ? i69 : i66;
    } else {
     i69 = HEAP32[i42 >> 2] | 0;
     i67 = i69;
     i68 = i19 + (0 - i66) | 0;
    }
    i66 = i69 >>> 0 > i26 >>> 0 ? i26 : i69;
    HEAP32[i42 >> 2] = i67 - i66;
    i67 = ~i26;
    i69 = ~i69;
    i67 = i67 >>> 0 > i69 >>> 0 ? i67 : i69;
    i69 = i66;
    i70 = i19;
    while (1) {
     HEAP8[i70] = HEAP8[i68] | 0;
     i69 = i69 + -1 | 0;
     if ((i69 | 0) == 0) {
      break;
     } else {
      i68 = i68 + 1 | 0;
      i70 = i70 + 1 | 0;
     }
    }
    i66 = i26 - i66 | 0;
    i19 = i19 + ~i67 | 0;
    if ((HEAP32[i42 >> 2] | 0) == 0) {
     HEAP32[i4 >> 2] = 20;
    }
   }
  } while (0);
  i68 = HEAP32[i4 >> 2] | 0;
  i67 = i63;
  i26 = i66;
 }
 if ((i60 | 0) == 122) {
  HEAP32[i8 >> 2] = i19;
  HEAP32[i15 >> 2] = i26;
  HEAP32[i2 >> 2] = i62;
  HEAP32[i16 >> 2] = i65;
  HEAP32[i17 >> 2] = i64;
  HEAP32[i6 >> 2] = i63;
  i72 = 2;
  STACKTOP = i1;
  return i72 | 0;
 } else if ((i60 | 0) == 133) {
  i63 = i63 + -3 | 0;
  i64 = i64 >>> 3;
 } else if ((i60 | 0) == 284) {
  HEAP32[i4 >> 2] = 28;
  i61 = 1;
 } else if ((i60 | 0) != 285) if ((i60 | 0) == 299) {
  i72 = -4;
  STACKTOP = i1;
  return i72 | 0;
 } else if ((i60 | 0) == 300) {
  STACKTOP = i1;
  return i2 | 0;
 }
 HEAP32[i8 >> 2] = i19;
 HEAP32[i15 >> 2] = i26;
 HEAP32[i2 >> 2] = i62;
 HEAP32[i16 >> 2] = i65;
 HEAP32[i17 >> 2] = i64;
 HEAP32[i6 >> 2] = i63;
 if ((HEAP32[i18 >> 2] | 0) == 0) {
  if ((HEAP32[i4 >> 2] | 0) >>> 0 < 26 ? (i59 | 0) != (HEAP32[i15 >> 2] | 0) : 0) {
   i60 = 289;
  }
 } else {
  i60 = 289;
 }
 if ((i60 | 0) == 289 ? (_updatewindow(i2, i59) | 0) != 0 : 0) {
  HEAP32[i4 >> 2] = 30;
  i72 = -4;
  STACKTOP = i1;
  return i72 | 0;
 }
 i16 = HEAP32[i16 >> 2] | 0;
 i72 = HEAP32[i15 >> 2] | 0;
 i15 = i59 - i72 | 0;
 i71 = i2 + 8 | 0;
 HEAP32[i71 >> 2] = i5 - i16 + (HEAP32[i71 >> 2] | 0);
 HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + i15;
 HEAP32[i14 >> 2] = (HEAP32[i14 >> 2] | 0) + i15;
 i13 = (i59 | 0) == (i72 | 0);
 if (!((HEAP32[i12 >> 2] | 0) == 0 | i13)) {
  i12 = HEAP32[i10 >> 2] | 0;
  i8 = (HEAP32[i8 >> 2] | 0) + (0 - i15) | 0;
  if ((HEAP32[i11 >> 2] | 0) == 0) {
   i8 = _adler32(i12, i8, i15) | 0;
  } else {
   i8 = _crc32(i12, i8, i15) | 0;
  }
  HEAP32[i10 >> 2] = i8;
  HEAP32[i9 >> 2] = i8;
 }
 i4 = HEAP32[i4 >> 2] | 0;
 if ((i4 | 0) == 19) {
  i8 = 256;
 } else {
  i8 = (i4 | 0) == 14 ? 256 : 0;
 }
 HEAP32[i2 + 44 >> 2] = ((HEAP32[i7 >> 2] | 0) != 0 ? 64 : 0) + (HEAP32[i6 >> 2] | 0) + ((i4 | 0) == 11 ? 128 : 0) + i8;
 i72 = ((i5 | 0) == (i16 | 0) & i13 | (i3 | 0) == 4) & (i61 | 0) == 0 ? -5 : i61;
 STACKTOP = i1;
 return i72 | 0;
}
function _malloc(i12) {
 i12 = i12 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0;
 i1 = STACKTOP;
 do {
  if (i12 >>> 0 < 245) {
   if (i12 >>> 0 < 11) {
    i12 = 16;
   } else {
    i12 = i12 + 11 & -8;
   }
   i20 = i12 >>> 3;
   i18 = HEAP32[3618] | 0;
   i21 = i18 >>> i20;
   if ((i21 & 3 | 0) != 0) {
    i6 = (i21 & 1 ^ 1) + i20 | 0;
    i5 = i6 << 1;
    i3 = 14512 + (i5 << 2) | 0;
    i5 = 14512 + (i5 + 2 << 2) | 0;
    i7 = HEAP32[i5 >> 2] | 0;
    i2 = i7 + 8 | 0;
    i4 = HEAP32[i2 >> 2] | 0;
    do {
     if ((i3 | 0) != (i4 | 0)) {
      if (i4 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
       _abort();
      }
      i8 = i4 + 12 | 0;
      if ((HEAP32[i8 >> 2] | 0) == (i7 | 0)) {
       HEAP32[i8 >> 2] = i3;
       HEAP32[i5 >> 2] = i4;
       break;
      } else {
       _abort();
      }
     } else {
      HEAP32[3618] = i18 & ~(1 << i6);
     }
    } while (0);
    i32 = i6 << 3;
    HEAP32[i7 + 4 >> 2] = i32 | 3;
    i32 = i7 + (i32 | 4) | 0;
    HEAP32[i32 >> 2] = HEAP32[i32 >> 2] | 1;
    i32 = i2;
    STACKTOP = i1;
    return i32 | 0;
   }
   if (i12 >>> 0 > (HEAP32[14480 >> 2] | 0) >>> 0) {
    if ((i21 | 0) != 0) {
     i7 = 2 << i20;
     i7 = i21 << i20 & (i7 | 0 - i7);
     i7 = (i7 & 0 - i7) + -1 | 0;
     i2 = i7 >>> 12 & 16;
     i7 = i7 >>> i2;
     i6 = i7 >>> 5 & 8;
     i7 = i7 >>> i6;
     i5 = i7 >>> 2 & 4;
     i7 = i7 >>> i5;
     i4 = i7 >>> 1 & 2;
     i7 = i7 >>> i4;
     i3 = i7 >>> 1 & 1;
     i3 = (i6 | i2 | i5 | i4 | i3) + (i7 >>> i3) | 0;
     i7 = i3 << 1;
     i4 = 14512 + (i7 << 2) | 0;
     i7 = 14512 + (i7 + 2 << 2) | 0;
     i5 = HEAP32[i7 >> 2] | 0;
     i2 = i5 + 8 | 0;
     i6 = HEAP32[i2 >> 2] | 0;
     do {
      if ((i4 | 0) != (i6 | 0)) {
       if (i6 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
        _abort();
       }
       i8 = i6 + 12 | 0;
       if ((HEAP32[i8 >> 2] | 0) == (i5 | 0)) {
        HEAP32[i8 >> 2] = i4;
        HEAP32[i7 >> 2] = i6;
        break;
       } else {
        _abort();
       }
      } else {
       HEAP32[3618] = i18 & ~(1 << i3);
      }
     } while (0);
     i6 = i3 << 3;
     i4 = i6 - i12 | 0;
     HEAP32[i5 + 4 >> 2] = i12 | 3;
     i3 = i5 + i12 | 0;
     HEAP32[i5 + (i12 | 4) >> 2] = i4 | 1;
     HEAP32[i5 + i6 >> 2] = i4;
     i6 = HEAP32[14480 >> 2] | 0;
     if ((i6 | 0) != 0) {
      i5 = HEAP32[14492 >> 2] | 0;
      i8 = i6 >>> 3;
      i9 = i8 << 1;
      i6 = 14512 + (i9 << 2) | 0;
      i7 = HEAP32[3618] | 0;
      i8 = 1 << i8;
      if ((i7 & i8 | 0) != 0) {
       i7 = 14512 + (i9 + 2 << 2) | 0;
       i8 = HEAP32[i7 >> 2] | 0;
       if (i8 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
        _abort();
       } else {
        i28 = i7;
        i27 = i8;
       }
      } else {
       HEAP32[3618] = i7 | i8;
       i28 = 14512 + (i9 + 2 << 2) | 0;
       i27 = i6;
      }
      HEAP32[i28 >> 2] = i5;
      HEAP32[i27 + 12 >> 2] = i5;
      HEAP32[i5 + 8 >> 2] = i27;
      HEAP32[i5 + 12 >> 2] = i6;
     }
     HEAP32[14480 >> 2] = i4;
     HEAP32[14492 >> 2] = i3;
     i32 = i2;
     STACKTOP = i1;
     return i32 | 0;
    }
    i18 = HEAP32[14476 >> 2] | 0;
    if ((i18 | 0) != 0) {
     i2 = (i18 & 0 - i18) + -1 | 0;
     i31 = i2 >>> 12 & 16;
     i2 = i2 >>> i31;
     i30 = i2 >>> 5 & 8;
     i2 = i2 >>> i30;
     i32 = i2 >>> 2 & 4;
     i2 = i2 >>> i32;
     i6 = i2 >>> 1 & 2;
     i2 = i2 >>> i6;
     i3 = i2 >>> 1 & 1;
     i3 = HEAP32[14776 + ((i30 | i31 | i32 | i6 | i3) + (i2 >>> i3) << 2) >> 2] | 0;
     i2 = (HEAP32[i3 + 4 >> 2] & -8) - i12 | 0;
     i6 = i3;
     while (1) {
      i5 = HEAP32[i6 + 16 >> 2] | 0;
      if ((i5 | 0) == 0) {
       i5 = HEAP32[i6 + 20 >> 2] | 0;
       if ((i5 | 0) == 0) {
        break;
       }
      }
      i6 = (HEAP32[i5 + 4 >> 2] & -8) - i12 | 0;
      i4 = i6 >>> 0 < i2 >>> 0;
      i2 = i4 ? i6 : i2;
      i6 = i5;
      i3 = i4 ? i5 : i3;
     }
     i6 = HEAP32[14488 >> 2] | 0;
     if (i3 >>> 0 < i6 >>> 0) {
      _abort();
     }
     i4 = i3 + i12 | 0;
     if (!(i3 >>> 0 < i4 >>> 0)) {
      _abort();
     }
     i5 = HEAP32[i3 + 24 >> 2] | 0;
     i7 = HEAP32[i3 + 12 >> 2] | 0;
     do {
      if ((i7 | 0) == (i3 | 0)) {
       i8 = i3 + 20 | 0;
       i7 = HEAP32[i8 >> 2] | 0;
       if ((i7 | 0) == 0) {
        i8 = i3 + 16 | 0;
        i7 = HEAP32[i8 >> 2] | 0;
        if ((i7 | 0) == 0) {
         i26 = 0;
         break;
        }
       }
       while (1) {
        i10 = i7 + 20 | 0;
        i9 = HEAP32[i10 >> 2] | 0;
        if ((i9 | 0) != 0) {
         i7 = i9;
         i8 = i10;
         continue;
        }
        i10 = i7 + 16 | 0;
        i9 = HEAP32[i10 >> 2] | 0;
        if ((i9 | 0) == 0) {
         break;
        } else {
         i7 = i9;
         i8 = i10;
        }
       }
       if (i8 >>> 0 < i6 >>> 0) {
        _abort();
       } else {
        HEAP32[i8 >> 2] = 0;
        i26 = i7;
        break;
       }
      } else {
       i8 = HEAP32[i3 + 8 >> 2] | 0;
       if (i8 >>> 0 < i6 >>> 0) {
        _abort();
       }
       i6 = i8 + 12 | 0;
       if ((HEAP32[i6 >> 2] | 0) != (i3 | 0)) {
        _abort();
       }
       i9 = i7 + 8 | 0;
       if ((HEAP32[i9 >> 2] | 0) == (i3 | 0)) {
        HEAP32[i6 >> 2] = i7;
        HEAP32[i9 >> 2] = i8;
        i26 = i7;
        break;
       } else {
        _abort();
       }
      }
     } while (0);
     do {
      if ((i5 | 0) != 0) {
       i7 = HEAP32[i3 + 28 >> 2] | 0;
       i6 = 14776 + (i7 << 2) | 0;
       if ((i3 | 0) == (HEAP32[i6 >> 2] | 0)) {
        HEAP32[i6 >> 2] = i26;
        if ((i26 | 0) == 0) {
         HEAP32[14476 >> 2] = HEAP32[14476 >> 2] & ~(1 << i7);
         break;
        }
       } else {
        if (i5 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
         _abort();
        }
        i6 = i5 + 16 | 0;
        if ((HEAP32[i6 >> 2] | 0) == (i3 | 0)) {
         HEAP32[i6 >> 2] = i26;
        } else {
         HEAP32[i5 + 20 >> 2] = i26;
        }
        if ((i26 | 0) == 0) {
         break;
        }
       }
       if (i26 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
        _abort();
       }
       HEAP32[i26 + 24 >> 2] = i5;
       i5 = HEAP32[i3 + 16 >> 2] | 0;
       do {
        if ((i5 | 0) != 0) {
         if (i5 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
          _abort();
         } else {
          HEAP32[i26 + 16 >> 2] = i5;
          HEAP32[i5 + 24 >> 2] = i26;
          break;
         }
        }
       } while (0);
       i5 = HEAP32[i3 + 20 >> 2] | 0;
       if ((i5 | 0) != 0) {
        if (i5 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
         _abort();
        } else {
         HEAP32[i26 + 20 >> 2] = i5;
         HEAP32[i5 + 24 >> 2] = i26;
         break;
        }
       }
      }
     } while (0);
     if (i2 >>> 0 < 16) {
      i32 = i2 + i12 | 0;
      HEAP32[i3 + 4 >> 2] = i32 | 3;
      i32 = i3 + (i32 + 4) | 0;
      HEAP32[i32 >> 2] = HEAP32[i32 >> 2] | 1;
     } else {
      HEAP32[i3 + 4 >> 2] = i12 | 3;
      HEAP32[i3 + (i12 | 4) >> 2] = i2 | 1;
      HEAP32[i3 + (i2 + i12) >> 2] = i2;
      i6 = HEAP32[14480 >> 2] | 0;
      if ((i6 | 0) != 0) {
       i5 = HEAP32[14492 >> 2] | 0;
       i8 = i6 >>> 3;
       i9 = i8 << 1;
       i6 = 14512 + (i9 << 2) | 0;
       i7 = HEAP32[3618] | 0;
       i8 = 1 << i8;
       if ((i7 & i8 | 0) != 0) {
        i7 = 14512 + (i9 + 2 << 2) | 0;
        i8 = HEAP32[i7 >> 2] | 0;
        if (i8 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
         _abort();
        } else {
         i25 = i7;
         i24 = i8;
        }
       } else {
        HEAP32[3618] = i7 | i8;
        i25 = 14512 + (i9 + 2 << 2) | 0;
        i24 = i6;
       }
       HEAP32[i25 >> 2] = i5;
       HEAP32[i24 + 12 >> 2] = i5;
       HEAP32[i5 + 8 >> 2] = i24;
       HEAP32[i5 + 12 >> 2] = i6;
      }
      HEAP32[14480 >> 2] = i2;
      HEAP32[14492 >> 2] = i4;
     }
     i32 = i3 + 8 | 0;
     STACKTOP = i1;
     return i32 | 0;
    }
   }
  } else {
   if (!(i12 >>> 0 > 4294967231)) {
    i24 = i12 + 11 | 0;
    i12 = i24 & -8;
    i26 = HEAP32[14476 >> 2] | 0;
    if ((i26 | 0) != 0) {
     i25 = 0 - i12 | 0;
     i24 = i24 >>> 8;
     if ((i24 | 0) != 0) {
      if (i12 >>> 0 > 16777215) {
       i27 = 31;
      } else {
       i31 = (i24 + 1048320 | 0) >>> 16 & 8;
       i32 = i24 << i31;
       i30 = (i32 + 520192 | 0) >>> 16 & 4;
       i32 = i32 << i30;
       i27 = (i32 + 245760 | 0) >>> 16 & 2;
       i27 = 14 - (i30 | i31 | i27) + (i32 << i27 >>> 15) | 0;
       i27 = i12 >>> (i27 + 7 | 0) & 1 | i27 << 1;
      }
     } else {
      i27 = 0;
     }
     i30 = HEAP32[14776 + (i27 << 2) >> 2] | 0;
     L126 : do {
      if ((i30 | 0) == 0) {
       i29 = 0;
       i24 = 0;
      } else {
       if ((i27 | 0) == 31) {
        i24 = 0;
       } else {
        i24 = 25 - (i27 >>> 1) | 0;
       }
       i29 = 0;
       i28 = i12 << i24;
       i24 = 0;
       while (1) {
        i32 = HEAP32[i30 + 4 >> 2] & -8;
        i31 = i32 - i12 | 0;
        if (i31 >>> 0 < i25 >>> 0) {
         if ((i32 | 0) == (i12 | 0)) {
          i25 = i31;
          i29 = i30;
          i24 = i30;
          break L126;
         } else {
          i25 = i31;
          i24 = i30;
         }
        }
        i31 = HEAP32[i30 + 20 >> 2] | 0;
        i30 = HEAP32[i30 + (i28 >>> 31 << 2) + 16 >> 2] | 0;
        i29 = (i31 | 0) == 0 | (i31 | 0) == (i30 | 0) ? i29 : i31;
        if ((i30 | 0) == 0) {
         break;
        } else {
         i28 = i28 << 1;
        }
       }
      }
     } while (0);
     if ((i29 | 0) == 0 & (i24 | 0) == 0) {
      i32 = 2 << i27;
      i26 = i26 & (i32 | 0 - i32);
      if ((i26 | 0) == 0) {
       break;
      }
      i32 = (i26 & 0 - i26) + -1 | 0;
      i28 = i32 >>> 12 & 16;
      i32 = i32 >>> i28;
      i27 = i32 >>> 5 & 8;
      i32 = i32 >>> i27;
      i30 = i32 >>> 2 & 4;
      i32 = i32 >>> i30;
      i31 = i32 >>> 1 & 2;
      i32 = i32 >>> i31;
      i29 = i32 >>> 1 & 1;
      i29 = HEAP32[14776 + ((i27 | i28 | i30 | i31 | i29) + (i32 >>> i29) << 2) >> 2] | 0;
     }
     if ((i29 | 0) != 0) {
      while (1) {
       i27 = (HEAP32[i29 + 4 >> 2] & -8) - i12 | 0;
       i26 = i27 >>> 0 < i25 >>> 0;
       i25 = i26 ? i27 : i25;
       i24 = i26 ? i29 : i24;
       i26 = HEAP32[i29 + 16 >> 2] | 0;
       if ((i26 | 0) != 0) {
        i29 = i26;
        continue;
       }
       i29 = HEAP32[i29 + 20 >> 2] | 0;
       if ((i29 | 0) == 0) {
        break;
       }
      }
     }
     if ((i24 | 0) != 0 ? i25 >>> 0 < ((HEAP32[14480 >> 2] | 0) - i12 | 0) >>> 0 : 0) {
      i4 = HEAP32[14488 >> 2] | 0;
      if (i24 >>> 0 < i4 >>> 0) {
       _abort();
      }
      i2 = i24 + i12 | 0;
      if (!(i24 >>> 0 < i2 >>> 0)) {
       _abort();
      }
      i3 = HEAP32[i24 + 24 >> 2] | 0;
      i6 = HEAP32[i24 + 12 >> 2] | 0;
      do {
       if ((i6 | 0) == (i24 | 0)) {
        i6 = i24 + 20 | 0;
        i5 = HEAP32[i6 >> 2] | 0;
        if ((i5 | 0) == 0) {
         i6 = i24 + 16 | 0;
         i5 = HEAP32[i6 >> 2] | 0;
         if ((i5 | 0) == 0) {
          i22 = 0;
          break;
         }
        }
        while (1) {
         i8 = i5 + 20 | 0;
         i7 = HEAP32[i8 >> 2] | 0;
         if ((i7 | 0) != 0) {
          i5 = i7;
          i6 = i8;
          continue;
         }
         i7 = i5 + 16 | 0;
         i8 = HEAP32[i7 >> 2] | 0;
         if ((i8 | 0) == 0) {
          break;
         } else {
          i5 = i8;
          i6 = i7;
         }
        }
        if (i6 >>> 0 < i4 >>> 0) {
         _abort();
        } else {
         HEAP32[i6 >> 2] = 0;
         i22 = i5;
         break;
        }
       } else {
        i5 = HEAP32[i24 + 8 >> 2] | 0;
        if (i5 >>> 0 < i4 >>> 0) {
         _abort();
        }
        i7 = i5 + 12 | 0;
        if ((HEAP32[i7 >> 2] | 0) != (i24 | 0)) {
         _abort();
        }
        i4 = i6 + 8 | 0;
        if ((HEAP32[i4 >> 2] | 0) == (i24 | 0)) {
         HEAP32[i7 >> 2] = i6;
         HEAP32[i4 >> 2] = i5;
         i22 = i6;
         break;
        } else {
         _abort();
        }
       }
      } while (0);
      do {
       if ((i3 | 0) != 0) {
        i4 = HEAP32[i24 + 28 >> 2] | 0;
        i5 = 14776 + (i4 << 2) | 0;
        if ((i24 | 0) == (HEAP32[i5 >> 2] | 0)) {
         HEAP32[i5 >> 2] = i22;
         if ((i22 | 0) == 0) {
          HEAP32[14476 >> 2] = HEAP32[14476 >> 2] & ~(1 << i4);
          break;
         }
        } else {
         if (i3 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
          _abort();
         }
         i4 = i3 + 16 | 0;
         if ((HEAP32[i4 >> 2] | 0) == (i24 | 0)) {
          HEAP32[i4 >> 2] = i22;
         } else {
          HEAP32[i3 + 20 >> 2] = i22;
         }
         if ((i22 | 0) == 0) {
          break;
         }
        }
        if (i22 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
         _abort();
        }
        HEAP32[i22 + 24 >> 2] = i3;
        i3 = HEAP32[i24 + 16 >> 2] | 0;
        do {
         if ((i3 | 0) != 0) {
          if (i3 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
           _abort();
          } else {
           HEAP32[i22 + 16 >> 2] = i3;
           HEAP32[i3 + 24 >> 2] = i22;
           break;
          }
         }
        } while (0);
        i3 = HEAP32[i24 + 20 >> 2] | 0;
        if ((i3 | 0) != 0) {
         if (i3 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
          _abort();
         } else {
          HEAP32[i22 + 20 >> 2] = i3;
          HEAP32[i3 + 24 >> 2] = i22;
          break;
         }
        }
       }
      } while (0);
      L204 : do {
       if (!(i25 >>> 0 < 16)) {
        HEAP32[i24 + 4 >> 2] = i12 | 3;
        HEAP32[i24 + (i12 | 4) >> 2] = i25 | 1;
        HEAP32[i24 + (i25 + i12) >> 2] = i25;
        i4 = i25 >>> 3;
        if (i25 >>> 0 < 256) {
         i6 = i4 << 1;
         i3 = 14512 + (i6 << 2) | 0;
         i5 = HEAP32[3618] | 0;
         i4 = 1 << i4;
         if ((i5 & i4 | 0) != 0) {
          i5 = 14512 + (i6 + 2 << 2) | 0;
          i4 = HEAP32[i5 >> 2] | 0;
          if (i4 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
           _abort();
          } else {
           i21 = i5;
           i20 = i4;
          }
         } else {
          HEAP32[3618] = i5 | i4;
          i21 = 14512 + (i6 + 2 << 2) | 0;
          i20 = i3;
         }
         HEAP32[i21 >> 2] = i2;
         HEAP32[i20 + 12 >> 2] = i2;
         HEAP32[i24 + (i12 + 8) >> 2] = i20;
         HEAP32[i24 + (i12 + 12) >> 2] = i3;
         break;
        }
        i3 = i25 >>> 8;
        if ((i3 | 0) != 0) {
         if (i25 >>> 0 > 16777215) {
          i3 = 31;
         } else {
          i31 = (i3 + 1048320 | 0) >>> 16 & 8;
          i32 = i3 << i31;
          i30 = (i32 + 520192 | 0) >>> 16 & 4;
          i32 = i32 << i30;
          i3 = (i32 + 245760 | 0) >>> 16 & 2;
          i3 = 14 - (i30 | i31 | i3) + (i32 << i3 >>> 15) | 0;
          i3 = i25 >>> (i3 + 7 | 0) & 1 | i3 << 1;
         }
        } else {
         i3 = 0;
        }
        i6 = 14776 + (i3 << 2) | 0;
        HEAP32[i24 + (i12 + 28) >> 2] = i3;
        HEAP32[i24 + (i12 + 20) >> 2] = 0;
        HEAP32[i24 + (i12 + 16) >> 2] = 0;
        i4 = HEAP32[14476 >> 2] | 0;
        i5 = 1 << i3;
        if ((i4 & i5 | 0) == 0) {
         HEAP32[14476 >> 2] = i4 | i5;
         HEAP32[i6 >> 2] = i2;
         HEAP32[i24 + (i12 + 24) >> 2] = i6;
         HEAP32[i24 + (i12 + 12) >> 2] = i2;
         HEAP32[i24 + (i12 + 8) >> 2] = i2;
         break;
        }
        i4 = HEAP32[i6 >> 2] | 0;
        if ((i3 | 0) == 31) {
         i3 = 0;
        } else {
         i3 = 25 - (i3 >>> 1) | 0;
        }
        L225 : do {
         if ((HEAP32[i4 + 4 >> 2] & -8 | 0) != (i25 | 0)) {
          i3 = i25 << i3;
          while (1) {
           i6 = i4 + (i3 >>> 31 << 2) + 16 | 0;
           i5 = HEAP32[i6 >> 2] | 0;
           if ((i5 | 0) == 0) {
            break;
           }
           if ((HEAP32[i5 + 4 >> 2] & -8 | 0) == (i25 | 0)) {
            i18 = i5;
            break L225;
           } else {
            i3 = i3 << 1;
            i4 = i5;
           }
          }
          if (i6 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
           _abort();
          } else {
           HEAP32[i6 >> 2] = i2;
           HEAP32[i24 + (i12 + 24) >> 2] = i4;
           HEAP32[i24 + (i12 + 12) >> 2] = i2;
           HEAP32[i24 + (i12 + 8) >> 2] = i2;
           break L204;
          }
         } else {
          i18 = i4;
         }
        } while (0);
        i4 = i18 + 8 | 0;
        i3 = HEAP32[i4 >> 2] | 0;
        i5 = HEAP32[14488 >> 2] | 0;
        if (i18 >>> 0 < i5 >>> 0) {
         _abort();
        }
        if (i3 >>> 0 < i5 >>> 0) {
         _abort();
        } else {
         HEAP32[i3 + 12 >> 2] = i2;
         HEAP32[i4 >> 2] = i2;
         HEAP32[i24 + (i12 + 8) >> 2] = i3;
         HEAP32[i24 + (i12 + 12) >> 2] = i18;
         HEAP32[i24 + (i12 + 24) >> 2] = 0;
         break;
        }
       } else {
        i32 = i25 + i12 | 0;
        HEAP32[i24 + 4 >> 2] = i32 | 3;
        i32 = i24 + (i32 + 4) | 0;
        HEAP32[i32 >> 2] = HEAP32[i32 >> 2] | 1;
       }
      } while (0);
      i32 = i24 + 8 | 0;
      STACKTOP = i1;
      return i32 | 0;
     }
    }
   } else {
    i12 = -1;
   }
  }
 } while (0);
 i18 = HEAP32[14480 >> 2] | 0;
 if (!(i12 >>> 0 > i18 >>> 0)) {
  i3 = i18 - i12 | 0;
  i2 = HEAP32[14492 >> 2] | 0;
  if (i3 >>> 0 > 15) {
   HEAP32[14492 >> 2] = i2 + i12;
   HEAP32[14480 >> 2] = i3;
   HEAP32[i2 + (i12 + 4) >> 2] = i3 | 1;
   HEAP32[i2 + i18 >> 2] = i3;
   HEAP32[i2 + 4 >> 2] = i12 | 3;
  } else {
   HEAP32[14480 >> 2] = 0;
   HEAP32[14492 >> 2] = 0;
   HEAP32[i2 + 4 >> 2] = i18 | 3;
   i32 = i2 + (i18 + 4) | 0;
   HEAP32[i32 >> 2] = HEAP32[i32 >> 2] | 1;
  }
  i32 = i2 + 8 | 0;
  STACKTOP = i1;
  return i32 | 0;
 }
 i18 = HEAP32[14484 >> 2] | 0;
 if (i12 >>> 0 < i18 >>> 0) {
  i31 = i18 - i12 | 0;
  HEAP32[14484 >> 2] = i31;
  i32 = HEAP32[14496 >> 2] | 0;
  HEAP32[14496 >> 2] = i32 + i12;
  HEAP32[i32 + (i12 + 4) >> 2] = i31 | 1;
  HEAP32[i32 + 4 >> 2] = i12 | 3;
  i32 = i32 + 8 | 0;
  STACKTOP = i1;
  return i32 | 0;
 }
 do {
  if ((HEAP32[3736] | 0) == 0) {
   i18 = _sysconf(30) | 0;
   if ((i18 + -1 & i18 | 0) == 0) {
    HEAP32[14952 >> 2] = i18;
    HEAP32[14948 >> 2] = i18;
    HEAP32[14956 >> 2] = -1;
    HEAP32[14960 >> 2] = -1;
    HEAP32[14964 >> 2] = 0;
    HEAP32[14916 >> 2] = 0;
    HEAP32[3736] = (_time(0) | 0) & -16 ^ 1431655768;
    break;
   } else {
    _abort();
   }
  }
 } while (0);
 i20 = i12 + 48 | 0;
 i25 = HEAP32[14952 >> 2] | 0;
 i21 = i12 + 47 | 0;
 i22 = i25 + i21 | 0;
 i25 = 0 - i25 | 0;
 i18 = i22 & i25;
 if (!(i18 >>> 0 > i12 >>> 0)) {
  i32 = 0;
  STACKTOP = i1;
  return i32 | 0;
 }
 i24 = HEAP32[14912 >> 2] | 0;
 if ((i24 | 0) != 0 ? (i31 = HEAP32[14904 >> 2] | 0, i32 = i31 + i18 | 0, i32 >>> 0 <= i31 >>> 0 | i32 >>> 0 > i24 >>> 0) : 0) {
  i32 = 0;
  STACKTOP = i1;
  return i32 | 0;
 }
 L269 : do {
  if ((HEAP32[14916 >> 2] & 4 | 0) == 0) {
   i26 = HEAP32[14496 >> 2] | 0;
   L271 : do {
    if ((i26 | 0) != 0) {
     i24 = 14920 | 0;
     while (1) {
      i27 = HEAP32[i24 >> 2] | 0;
      if (!(i27 >>> 0 > i26 >>> 0) ? (i23 = i24 + 4 | 0, (i27 + (HEAP32[i23 >> 2] | 0) | 0) >>> 0 > i26 >>> 0) : 0) {
       break;
      }
      i24 = HEAP32[i24 + 8 >> 2] | 0;
      if ((i24 | 0) == 0) {
       i13 = 182;
       break L271;
      }
     }
     if ((i24 | 0) != 0) {
      i25 = i22 - (HEAP32[14484 >> 2] | 0) & i25;
      if (i25 >>> 0 < 2147483647) {
       i13 = _sbrk(i25 | 0) | 0;
       i26 = (i13 | 0) == ((HEAP32[i24 >> 2] | 0) + (HEAP32[i23 >> 2] | 0) | 0);
       i22 = i13;
       i24 = i25;
       i23 = i26 ? i13 : -1;
       i25 = i26 ? i25 : 0;
       i13 = 191;
      } else {
       i25 = 0;
      }
     } else {
      i13 = 182;
     }
    } else {
     i13 = 182;
    }
   } while (0);
   do {
    if ((i13 | 0) == 182) {
     i23 = _sbrk(0) | 0;
     if ((i23 | 0) != (-1 | 0)) {
      i24 = i23;
      i22 = HEAP32[14948 >> 2] | 0;
      i25 = i22 + -1 | 0;
      if ((i25 & i24 | 0) == 0) {
       i25 = i18;
      } else {
       i25 = i18 - i24 + (i25 + i24 & 0 - i22) | 0;
      }
      i24 = HEAP32[14904 >> 2] | 0;
      i26 = i24 + i25 | 0;
      if (i25 >>> 0 > i12 >>> 0 & i25 >>> 0 < 2147483647) {
       i22 = HEAP32[14912 >> 2] | 0;
       if ((i22 | 0) != 0 ? i26 >>> 0 <= i24 >>> 0 | i26 >>> 0 > i22 >>> 0 : 0) {
        i25 = 0;
        break;
       }
       i22 = _sbrk(i25 | 0) | 0;
       i13 = (i22 | 0) == (i23 | 0);
       i24 = i25;
       i23 = i13 ? i23 : -1;
       i25 = i13 ? i25 : 0;
       i13 = 191;
      } else {
       i25 = 0;
      }
     } else {
      i25 = 0;
     }
    }
   } while (0);
   L291 : do {
    if ((i13 | 0) == 191) {
     i13 = 0 - i24 | 0;
     if ((i23 | 0) != (-1 | 0)) {
      i17 = i23;
      i14 = i25;
      i13 = 202;
      break L269;
     }
     do {
      if ((i22 | 0) != (-1 | 0) & i24 >>> 0 < 2147483647 & i24 >>> 0 < i20 >>> 0 ? (i19 = HEAP32[14952 >> 2] | 0, i19 = i21 - i24 + i19 & 0 - i19, i19 >>> 0 < 2147483647) : 0) {
       if ((_sbrk(i19 | 0) | 0) == (-1 | 0)) {
        _sbrk(i13 | 0) | 0;
        break L291;
       } else {
        i24 = i19 + i24 | 0;
        break;
       }
      }
     } while (0);
     if ((i22 | 0) != (-1 | 0)) {
      i17 = i22;
      i14 = i24;
      i13 = 202;
      break L269;
     }
    }
   } while (0);
   HEAP32[14916 >> 2] = HEAP32[14916 >> 2] | 4;
   i13 = 199;
  } else {
   i25 = 0;
   i13 = 199;
  }
 } while (0);
 if ((((i13 | 0) == 199 ? i18 >>> 0 < 2147483647 : 0) ? (i17 = _sbrk(i18 | 0) | 0, i16 = _sbrk(0) | 0, (i16 | 0) != (-1 | 0) & (i17 | 0) != (-1 | 0) & i17 >>> 0 < i16 >>> 0) : 0) ? (i15 = i16 - i17 | 0, i14 = i15 >>> 0 > (i12 + 40 | 0) >>> 0, i14) : 0) {
  i14 = i14 ? i15 : i25;
  i13 = 202;
 }
 if ((i13 | 0) == 202) {
  i15 = (HEAP32[14904 >> 2] | 0) + i14 | 0;
  HEAP32[14904 >> 2] = i15;
  if (i15 >>> 0 > (HEAP32[14908 >> 2] | 0) >>> 0) {
   HEAP32[14908 >> 2] = i15;
  }
  i15 = HEAP32[14496 >> 2] | 0;
  L311 : do {
   if ((i15 | 0) != 0) {
    i21 = 14920 | 0;
    while (1) {
     i16 = HEAP32[i21 >> 2] | 0;
     i19 = i21 + 4 | 0;
     i20 = HEAP32[i19 >> 2] | 0;
     if ((i17 | 0) == (i16 + i20 | 0)) {
      i13 = 214;
      break;
     }
     i18 = HEAP32[i21 + 8 >> 2] | 0;
     if ((i18 | 0) == 0) {
      break;
     } else {
      i21 = i18;
     }
    }
    if (((i13 | 0) == 214 ? (HEAP32[i21 + 12 >> 2] & 8 | 0) == 0 : 0) ? i15 >>> 0 >= i16 >>> 0 & i15 >>> 0 < i17 >>> 0 : 0) {
     HEAP32[i19 >> 2] = i20 + i14;
     i2 = (HEAP32[14484 >> 2] | 0) + i14 | 0;
     i3 = i15 + 8 | 0;
     if ((i3 & 7 | 0) == 0) {
      i3 = 0;
     } else {
      i3 = 0 - i3 & 7;
     }
     i32 = i2 - i3 | 0;
     HEAP32[14496 >> 2] = i15 + i3;
     HEAP32[14484 >> 2] = i32;
     HEAP32[i15 + (i3 + 4) >> 2] = i32 | 1;
     HEAP32[i15 + (i2 + 4) >> 2] = 40;
     HEAP32[14500 >> 2] = HEAP32[14960 >> 2];
     break;
    }
    if (i17 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
     HEAP32[14488 >> 2] = i17;
    }
    i19 = i17 + i14 | 0;
    i16 = 14920 | 0;
    while (1) {
     if ((HEAP32[i16 >> 2] | 0) == (i19 | 0)) {
      i13 = 224;
      break;
     }
     i18 = HEAP32[i16 + 8 >> 2] | 0;
     if ((i18 | 0) == 0) {
      break;
     } else {
      i16 = i18;
     }
    }
    if ((i13 | 0) == 224 ? (HEAP32[i16 + 12 >> 2] & 8 | 0) == 0 : 0) {
     HEAP32[i16 >> 2] = i17;
     i6 = i16 + 4 | 0;
     HEAP32[i6 >> 2] = (HEAP32[i6 >> 2] | 0) + i14;
     i6 = i17 + 8 | 0;
     if ((i6 & 7 | 0) == 0) {
      i6 = 0;
     } else {
      i6 = 0 - i6 & 7;
     }
     i7 = i17 + (i14 + 8) | 0;
     if ((i7 & 7 | 0) == 0) {
      i13 = 0;
     } else {
      i13 = 0 - i7 & 7;
     }
     i15 = i17 + (i13 + i14) | 0;
     i8 = i6 + i12 | 0;
     i7 = i17 + i8 | 0;
     i10 = i15 - (i17 + i6) - i12 | 0;
     HEAP32[i17 + (i6 + 4) >> 2] = i12 | 3;
     L348 : do {
      if ((i15 | 0) != (HEAP32[14496 >> 2] | 0)) {
       if ((i15 | 0) == (HEAP32[14492 >> 2] | 0)) {
        i32 = (HEAP32[14480 >> 2] | 0) + i10 | 0;
        HEAP32[14480 >> 2] = i32;
        HEAP32[14492 >> 2] = i7;
        HEAP32[i17 + (i8 + 4) >> 2] = i32 | 1;
        HEAP32[i17 + (i32 + i8) >> 2] = i32;
        break;
       }
       i12 = i14 + 4 | 0;
       i18 = HEAP32[i17 + (i12 + i13) >> 2] | 0;
       if ((i18 & 3 | 0) == 1) {
        i11 = i18 & -8;
        i16 = i18 >>> 3;
        do {
         if (!(i18 >>> 0 < 256)) {
          i9 = HEAP32[i17 + ((i13 | 24) + i14) >> 2] | 0;
          i19 = HEAP32[i17 + (i14 + 12 + i13) >> 2] | 0;
          do {
           if ((i19 | 0) == (i15 | 0)) {
            i19 = i13 | 16;
            i18 = i17 + (i12 + i19) | 0;
            i16 = HEAP32[i18 >> 2] | 0;
            if ((i16 | 0) == 0) {
             i18 = i17 + (i19 + i14) | 0;
             i16 = HEAP32[i18 >> 2] | 0;
             if ((i16 | 0) == 0) {
              i5 = 0;
              break;
             }
            }
            while (1) {
             i20 = i16 + 20 | 0;
             i19 = HEAP32[i20 >> 2] | 0;
             if ((i19 | 0) != 0) {
              i16 = i19;
              i18 = i20;
              continue;
             }
             i19 = i16 + 16 | 0;
             i20 = HEAP32[i19 >> 2] | 0;
             if ((i20 | 0) == 0) {
              break;
             } else {
              i16 = i20;
              i18 = i19;
             }
            }
            if (i18 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
             _abort();
            } else {
             HEAP32[i18 >> 2] = 0;
             i5 = i16;
             break;
            }
           } else {
            i18 = HEAP32[i17 + ((i13 | 8) + i14) >> 2] | 0;
            if (i18 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
             _abort();
            }
            i16 = i18 + 12 | 0;
            if ((HEAP32[i16 >> 2] | 0) != (i15 | 0)) {
             _abort();
            }
            i20 = i19 + 8 | 0;
            if ((HEAP32[i20 >> 2] | 0) == (i15 | 0)) {
             HEAP32[i16 >> 2] = i19;
             HEAP32[i20 >> 2] = i18;
             i5 = i19;
             break;
            } else {
             _abort();
            }
           }
          } while (0);
          if ((i9 | 0) != 0) {
           i16 = HEAP32[i17 + (i14 + 28 + i13) >> 2] | 0;
           i18 = 14776 + (i16 << 2) | 0;
           if ((i15 | 0) == (HEAP32[i18 >> 2] | 0)) {
            HEAP32[i18 >> 2] = i5;
            if ((i5 | 0) == 0) {
             HEAP32[14476 >> 2] = HEAP32[14476 >> 2] & ~(1 << i16);
             break;
            }
           } else {
            if (i9 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
             _abort();
            }
            i16 = i9 + 16 | 0;
            if ((HEAP32[i16 >> 2] | 0) == (i15 | 0)) {
             HEAP32[i16 >> 2] = i5;
            } else {
             HEAP32[i9 + 20 >> 2] = i5;
            }
            if ((i5 | 0) == 0) {
             break;
            }
           }
           if (i5 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
            _abort();
           }
           HEAP32[i5 + 24 >> 2] = i9;
           i15 = i13 | 16;
           i9 = HEAP32[i17 + (i15 + i14) >> 2] | 0;
           do {
            if ((i9 | 0) != 0) {
             if (i9 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
              _abort();
             } else {
              HEAP32[i5 + 16 >> 2] = i9;
              HEAP32[i9 + 24 >> 2] = i5;
              break;
             }
            }
           } while (0);
           i9 = HEAP32[i17 + (i12 + i15) >> 2] | 0;
           if ((i9 | 0) != 0) {
            if (i9 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
             _abort();
            } else {
             HEAP32[i5 + 20 >> 2] = i9;
             HEAP32[i9 + 24 >> 2] = i5;
             break;
            }
           }
          }
         } else {
          i5 = HEAP32[i17 + ((i13 | 8) + i14) >> 2] | 0;
          i12 = HEAP32[i17 + (i14 + 12 + i13) >> 2] | 0;
          i18 = 14512 + (i16 << 1 << 2) | 0;
          if ((i5 | 0) != (i18 | 0)) {
           if (i5 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
            _abort();
           }
           if ((HEAP32[i5 + 12 >> 2] | 0) != (i15 | 0)) {
            _abort();
           }
          }
          if ((i12 | 0) == (i5 | 0)) {
           HEAP32[3618] = HEAP32[3618] & ~(1 << i16);
           break;
          }
          if ((i12 | 0) != (i18 | 0)) {
           if (i12 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
            _abort();
           }
           i16 = i12 + 8 | 0;
           if ((HEAP32[i16 >> 2] | 0) == (i15 | 0)) {
            i9 = i16;
           } else {
            _abort();
           }
          } else {
           i9 = i12 + 8 | 0;
          }
          HEAP32[i5 + 12 >> 2] = i12;
          HEAP32[i9 >> 2] = i5;
         }
        } while (0);
        i15 = i17 + ((i11 | i13) + i14) | 0;
        i10 = i11 + i10 | 0;
       }
       i5 = i15 + 4 | 0;
       HEAP32[i5 >> 2] = HEAP32[i5 >> 2] & -2;
       HEAP32[i17 + (i8 + 4) >> 2] = i10 | 1;
       HEAP32[i17 + (i10 + i8) >> 2] = i10;
       i5 = i10 >>> 3;
       if (i10 >>> 0 < 256) {
        i10 = i5 << 1;
        i2 = 14512 + (i10 << 2) | 0;
        i9 = HEAP32[3618] | 0;
        i5 = 1 << i5;
        if ((i9 & i5 | 0) != 0) {
         i9 = 14512 + (i10 + 2 << 2) | 0;
         i5 = HEAP32[i9 >> 2] | 0;
         if (i5 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
          _abort();
         } else {
          i3 = i9;
          i4 = i5;
         }
        } else {
         HEAP32[3618] = i9 | i5;
         i3 = 14512 + (i10 + 2 << 2) | 0;
         i4 = i2;
        }
        HEAP32[i3 >> 2] = i7;
        HEAP32[i4 + 12 >> 2] = i7;
        HEAP32[i17 + (i8 + 8) >> 2] = i4;
        HEAP32[i17 + (i8 + 12) >> 2] = i2;
        break;
       }
       i3 = i10 >>> 8;
       if ((i3 | 0) != 0) {
        if (i10 >>> 0 > 16777215) {
         i3 = 31;
        } else {
         i31 = (i3 + 1048320 | 0) >>> 16 & 8;
         i32 = i3 << i31;
         i30 = (i32 + 520192 | 0) >>> 16 & 4;
         i32 = i32 << i30;
         i3 = (i32 + 245760 | 0) >>> 16 & 2;
         i3 = 14 - (i30 | i31 | i3) + (i32 << i3 >>> 15) | 0;
         i3 = i10 >>> (i3 + 7 | 0) & 1 | i3 << 1;
        }
       } else {
        i3 = 0;
       }
       i4 = 14776 + (i3 << 2) | 0;
       HEAP32[i17 + (i8 + 28) >> 2] = i3;
       HEAP32[i17 + (i8 + 20) >> 2] = 0;
       HEAP32[i17 + (i8 + 16) >> 2] = 0;
       i9 = HEAP32[14476 >> 2] | 0;
       i5 = 1 << i3;
       if ((i9 & i5 | 0) == 0) {
        HEAP32[14476 >> 2] = i9 | i5;
        HEAP32[i4 >> 2] = i7;
        HEAP32[i17 + (i8 + 24) >> 2] = i4;
        HEAP32[i17 + (i8 + 12) >> 2] = i7;
        HEAP32[i17 + (i8 + 8) >> 2] = i7;
        break;
       }
       i4 = HEAP32[i4 >> 2] | 0;
       if ((i3 | 0) == 31) {
        i3 = 0;
       } else {
        i3 = 25 - (i3 >>> 1) | 0;
       }
       L444 : do {
        if ((HEAP32[i4 + 4 >> 2] & -8 | 0) != (i10 | 0)) {
         i3 = i10 << i3;
         while (1) {
          i5 = i4 + (i3 >>> 31 << 2) + 16 | 0;
          i9 = HEAP32[i5 >> 2] | 0;
          if ((i9 | 0) == 0) {
           break;
          }
          if ((HEAP32[i9 + 4 >> 2] & -8 | 0) == (i10 | 0)) {
           i2 = i9;
           break L444;
          } else {
           i3 = i3 << 1;
           i4 = i9;
          }
         }
         if (i5 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
          _abort();
         } else {
          HEAP32[i5 >> 2] = i7;
          HEAP32[i17 + (i8 + 24) >> 2] = i4;
          HEAP32[i17 + (i8 + 12) >> 2] = i7;
          HEAP32[i17 + (i8 + 8) >> 2] = i7;
          break L348;
         }
        } else {
         i2 = i4;
        }
       } while (0);
       i4 = i2 + 8 | 0;
       i3 = HEAP32[i4 >> 2] | 0;
       i5 = HEAP32[14488 >> 2] | 0;
       if (i2 >>> 0 < i5 >>> 0) {
        _abort();
       }
       if (i3 >>> 0 < i5 >>> 0) {
        _abort();
       } else {
        HEAP32[i3 + 12 >> 2] = i7;
        HEAP32[i4 >> 2] = i7;
        HEAP32[i17 + (i8 + 8) >> 2] = i3;
        HEAP32[i17 + (i8 + 12) >> 2] = i2;
        HEAP32[i17 + (i8 + 24) >> 2] = 0;
        break;
       }
      } else {
       i32 = (HEAP32[14484 >> 2] | 0) + i10 | 0;
       HEAP32[14484 >> 2] = i32;
       HEAP32[14496 >> 2] = i7;
       HEAP32[i17 + (i8 + 4) >> 2] = i32 | 1;
      }
     } while (0);
     i32 = i17 + (i6 | 8) | 0;
     STACKTOP = i1;
     return i32 | 0;
    }
    i3 = 14920 | 0;
    while (1) {
     i2 = HEAP32[i3 >> 2] | 0;
     if (!(i2 >>> 0 > i15 >>> 0) ? (i11 = HEAP32[i3 + 4 >> 2] | 0, i10 = i2 + i11 | 0, i10 >>> 0 > i15 >>> 0) : 0) {
      break;
     }
     i3 = HEAP32[i3 + 8 >> 2] | 0;
    }
    i3 = i2 + (i11 + -39) | 0;
    if ((i3 & 7 | 0) == 0) {
     i3 = 0;
    } else {
     i3 = 0 - i3 & 7;
    }
    i2 = i2 + (i11 + -47 + i3) | 0;
    i2 = i2 >>> 0 < (i15 + 16 | 0) >>> 0 ? i15 : i2;
    i3 = i2 + 8 | 0;
    i4 = i17 + 8 | 0;
    if ((i4 & 7 | 0) == 0) {
     i4 = 0;
    } else {
     i4 = 0 - i4 & 7;
    }
    i32 = i14 + -40 - i4 | 0;
    HEAP32[14496 >> 2] = i17 + i4;
    HEAP32[14484 >> 2] = i32;
    HEAP32[i17 + (i4 + 4) >> 2] = i32 | 1;
    HEAP32[i17 + (i14 + -36) >> 2] = 40;
    HEAP32[14500 >> 2] = HEAP32[14960 >> 2];
    HEAP32[i2 + 4 >> 2] = 27;
    HEAP32[i3 + 0 >> 2] = HEAP32[14920 >> 2];
    HEAP32[i3 + 4 >> 2] = HEAP32[14924 >> 2];
    HEAP32[i3 + 8 >> 2] = HEAP32[14928 >> 2];
    HEAP32[i3 + 12 >> 2] = HEAP32[14932 >> 2];
    HEAP32[14920 >> 2] = i17;
    HEAP32[14924 >> 2] = i14;
    HEAP32[14932 >> 2] = 0;
    HEAP32[14928 >> 2] = i3;
    i4 = i2 + 28 | 0;
    HEAP32[i4 >> 2] = 7;
    if ((i2 + 32 | 0) >>> 0 < i10 >>> 0) {
     while (1) {
      i3 = i4 + 4 | 0;
      HEAP32[i3 >> 2] = 7;
      if ((i4 + 8 | 0) >>> 0 < i10 >>> 0) {
       i4 = i3;
      } else {
       break;
      }
     }
    }
    if ((i2 | 0) != (i15 | 0)) {
     i2 = i2 - i15 | 0;
     i3 = i15 + (i2 + 4) | 0;
     HEAP32[i3 >> 2] = HEAP32[i3 >> 2] & -2;
     HEAP32[i15 + 4 >> 2] = i2 | 1;
     HEAP32[i15 + i2 >> 2] = i2;
     i3 = i2 >>> 3;
     if (i2 >>> 0 < 256) {
      i4 = i3 << 1;
      i2 = 14512 + (i4 << 2) | 0;
      i5 = HEAP32[3618] | 0;
      i3 = 1 << i3;
      if ((i5 & i3 | 0) != 0) {
       i4 = 14512 + (i4 + 2 << 2) | 0;
       i3 = HEAP32[i4 >> 2] | 0;
       if (i3 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
        _abort();
       } else {
        i7 = i4;
        i8 = i3;
       }
      } else {
       HEAP32[3618] = i5 | i3;
       i7 = 14512 + (i4 + 2 << 2) | 0;
       i8 = i2;
      }
      HEAP32[i7 >> 2] = i15;
      HEAP32[i8 + 12 >> 2] = i15;
      HEAP32[i15 + 8 >> 2] = i8;
      HEAP32[i15 + 12 >> 2] = i2;
      break;
     }
     i3 = i2 >>> 8;
     if ((i3 | 0) != 0) {
      if (i2 >>> 0 > 16777215) {
       i3 = 31;
      } else {
       i31 = (i3 + 1048320 | 0) >>> 16 & 8;
       i32 = i3 << i31;
       i30 = (i32 + 520192 | 0) >>> 16 & 4;
       i32 = i32 << i30;
       i3 = (i32 + 245760 | 0) >>> 16 & 2;
       i3 = 14 - (i30 | i31 | i3) + (i32 << i3 >>> 15) | 0;
       i3 = i2 >>> (i3 + 7 | 0) & 1 | i3 << 1;
      }
     } else {
      i3 = 0;
     }
     i7 = 14776 + (i3 << 2) | 0;
     HEAP32[i15 + 28 >> 2] = i3;
     HEAP32[i15 + 20 >> 2] = 0;
     HEAP32[i15 + 16 >> 2] = 0;
     i4 = HEAP32[14476 >> 2] | 0;
     i5 = 1 << i3;
     if ((i4 & i5 | 0) == 0) {
      HEAP32[14476 >> 2] = i4 | i5;
      HEAP32[i7 >> 2] = i15;
      HEAP32[i15 + 24 >> 2] = i7;
      HEAP32[i15 + 12 >> 2] = i15;
      HEAP32[i15 + 8 >> 2] = i15;
      break;
     }
     i4 = HEAP32[i7 >> 2] | 0;
     if ((i3 | 0) == 31) {
      i3 = 0;
     } else {
      i3 = 25 - (i3 >>> 1) | 0;
     }
     L499 : do {
      if ((HEAP32[i4 + 4 >> 2] & -8 | 0) != (i2 | 0)) {
       i3 = i2 << i3;
       while (1) {
        i7 = i4 + (i3 >>> 31 << 2) + 16 | 0;
        i5 = HEAP32[i7 >> 2] | 0;
        if ((i5 | 0) == 0) {
         break;
        }
        if ((HEAP32[i5 + 4 >> 2] & -8 | 0) == (i2 | 0)) {
         i6 = i5;
         break L499;
        } else {
         i3 = i3 << 1;
         i4 = i5;
        }
       }
       if (i7 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
        _abort();
       } else {
        HEAP32[i7 >> 2] = i15;
        HEAP32[i15 + 24 >> 2] = i4;
        HEAP32[i15 + 12 >> 2] = i15;
        HEAP32[i15 + 8 >> 2] = i15;
        break L311;
       }
      } else {
       i6 = i4;
      }
     } while (0);
     i4 = i6 + 8 | 0;
     i3 = HEAP32[i4 >> 2] | 0;
     i2 = HEAP32[14488 >> 2] | 0;
     if (i6 >>> 0 < i2 >>> 0) {
      _abort();
     }
     if (i3 >>> 0 < i2 >>> 0) {
      _abort();
     } else {
      HEAP32[i3 + 12 >> 2] = i15;
      HEAP32[i4 >> 2] = i15;
      HEAP32[i15 + 8 >> 2] = i3;
      HEAP32[i15 + 12 >> 2] = i6;
      HEAP32[i15 + 24 >> 2] = 0;
      break;
     }
    }
   } else {
    i32 = HEAP32[14488 >> 2] | 0;
    if ((i32 | 0) == 0 | i17 >>> 0 < i32 >>> 0) {
     HEAP32[14488 >> 2] = i17;
    }
    HEAP32[14920 >> 2] = i17;
    HEAP32[14924 >> 2] = i14;
    HEAP32[14932 >> 2] = 0;
    HEAP32[14508 >> 2] = HEAP32[3736];
    HEAP32[14504 >> 2] = -1;
    i2 = 0;
    do {
     i32 = i2 << 1;
     i31 = 14512 + (i32 << 2) | 0;
     HEAP32[14512 + (i32 + 3 << 2) >> 2] = i31;
     HEAP32[14512 + (i32 + 2 << 2) >> 2] = i31;
     i2 = i2 + 1 | 0;
    } while ((i2 | 0) != 32);
    i2 = i17 + 8 | 0;
    if ((i2 & 7 | 0) == 0) {
     i2 = 0;
    } else {
     i2 = 0 - i2 & 7;
    }
    i32 = i14 + -40 - i2 | 0;
    HEAP32[14496 >> 2] = i17 + i2;
    HEAP32[14484 >> 2] = i32;
    HEAP32[i17 + (i2 + 4) >> 2] = i32 | 1;
    HEAP32[i17 + (i14 + -36) >> 2] = 40;
    HEAP32[14500 >> 2] = HEAP32[14960 >> 2];
   }
  } while (0);
  i2 = HEAP32[14484 >> 2] | 0;
  if (i2 >>> 0 > i12 >>> 0) {
   i31 = i2 - i12 | 0;
   HEAP32[14484 >> 2] = i31;
   i32 = HEAP32[14496 >> 2] | 0;
   HEAP32[14496 >> 2] = i32 + i12;
   HEAP32[i32 + (i12 + 4) >> 2] = i31 | 1;
   HEAP32[i32 + 4 >> 2] = i12 | 3;
   i32 = i32 + 8 | 0;
   STACKTOP = i1;
   return i32 | 0;
  }
 }
 HEAP32[(___errno_location() | 0) >> 2] = 12;
 i32 = 0;
 STACKTOP = i1;
 return i32 | 0;
}
function _deflate(i2, i10) {
 i2 = i2 | 0;
 i10 = i10 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0;
 i1 = STACKTOP;
 if ((i2 | 0) == 0) {
  i37 = -2;
  STACKTOP = i1;
  return i37 | 0;
 }
 i5 = i2 + 28 | 0;
 i7 = HEAP32[i5 >> 2] | 0;
 if ((i7 | 0) == 0 | i10 >>> 0 > 5) {
  i37 = -2;
  STACKTOP = i1;
  return i37 | 0;
 }
 i4 = i2 + 12 | 0;
 do {
  if ((HEAP32[i4 >> 2] | 0) != 0) {
   if ((HEAP32[i2 >> 2] | 0) == 0 ? (HEAP32[i2 + 4 >> 2] | 0) != 0 : 0) {
    break;
   }
   i11 = i7 + 4 | 0;
   i29 = HEAP32[i11 >> 2] | 0;
   i9 = (i10 | 0) == 4;
   if ((i29 | 0) != 666 | i9) {
    i3 = i2 + 16 | 0;
    if ((HEAP32[i3 >> 2] | 0) == 0) {
     HEAP32[i2 + 24 >> 2] = HEAP32[3180 >> 2];
     i37 = -5;
     STACKTOP = i1;
     return i37 | 0;
    }
    HEAP32[i7 >> 2] = i2;
    i8 = i7 + 40 | 0;
    i18 = HEAP32[i8 >> 2] | 0;
    HEAP32[i8 >> 2] = i10;
    do {
     if ((i29 | 0) == 42) {
      if ((HEAP32[i7 + 24 >> 2] | 0) != 2) {
       i17 = (HEAP32[i7 + 48 >> 2] << 12) + -30720 | 0;
       if ((HEAP32[i7 + 136 >> 2] | 0) <= 1 ? (i28 = HEAP32[i7 + 132 >> 2] | 0, (i28 | 0) >= 2) : 0) {
        if ((i28 | 0) < 6) {
         i28 = 64;
        } else {
         i28 = (i28 | 0) == 6 ? 128 : 192;
        }
       } else {
        i28 = 0;
       }
       i28 = i28 | i17;
       i17 = i7 + 108 | 0;
       i37 = (HEAP32[i17 >> 2] | 0) == 0 ? i28 : i28 | 32;
       HEAP32[i11 >> 2] = 113;
       i29 = i7 + 20 | 0;
       i30 = HEAP32[i29 >> 2] | 0;
       HEAP32[i29 >> 2] = i30 + 1;
       i28 = i7 + 8 | 0;
       HEAP8[(HEAP32[i28 >> 2] | 0) + i30 | 0] = i37 >>> 8;
       i30 = HEAP32[i29 >> 2] | 0;
       HEAP32[i29 >> 2] = i30 + 1;
       HEAP8[(HEAP32[i28 >> 2] | 0) + i30 | 0] = (i37 | ((i37 >>> 0) % 31 | 0)) ^ 31;
       i30 = i2 + 48 | 0;
       if ((HEAP32[i17 >> 2] | 0) != 0) {
        i37 = HEAP32[i30 >> 2] | 0;
        i36 = HEAP32[i29 >> 2] | 0;
        HEAP32[i29 >> 2] = i36 + 1;
        HEAP8[(HEAP32[i28 >> 2] | 0) + i36 | 0] = i37 >>> 24;
        i36 = HEAP32[i29 >> 2] | 0;
        HEAP32[i29 >> 2] = i36 + 1;
        HEAP8[(HEAP32[i28 >> 2] | 0) + i36 | 0] = i37 >>> 16;
        i36 = HEAP32[i30 >> 2] | 0;
        i37 = HEAP32[i29 >> 2] | 0;
        HEAP32[i29 >> 2] = i37 + 1;
        HEAP8[(HEAP32[i28 >> 2] | 0) + i37 | 0] = i36 >>> 8;
        i37 = HEAP32[i29 >> 2] | 0;
        HEAP32[i29 >> 2] = i37 + 1;
        HEAP8[(HEAP32[i28 >> 2] | 0) + i37 | 0] = i36;
       }
       HEAP32[i30 >> 2] = _adler32(0, 0, 0) | 0;
       i31 = HEAP32[i11 >> 2] | 0;
       i17 = 32;
       break;
      }
      i32 = i2 + 48 | 0;
      HEAP32[i32 >> 2] = _crc32(0, 0, 0) | 0;
      i30 = i7 + 20 | 0;
      i28 = HEAP32[i30 >> 2] | 0;
      HEAP32[i30 >> 2] = i28 + 1;
      i29 = i7 + 8 | 0;
      HEAP8[(HEAP32[i29 >> 2] | 0) + i28 | 0] = 31;
      i28 = HEAP32[i30 >> 2] | 0;
      HEAP32[i30 >> 2] = i28 + 1;
      HEAP8[(HEAP32[i29 >> 2] | 0) + i28 | 0] = -117;
      i28 = HEAP32[i30 >> 2] | 0;
      HEAP32[i30 >> 2] = i28 + 1;
      HEAP8[(HEAP32[i29 >> 2] | 0) + i28 | 0] = 8;
      i28 = i7 + 28 | 0;
      i33 = HEAP32[i28 >> 2] | 0;
      if ((i33 | 0) == 0) {
       i22 = HEAP32[i30 >> 2] | 0;
       HEAP32[i30 >> 2] = i22 + 1;
       HEAP8[(HEAP32[i29 >> 2] | 0) + i22 | 0] = 0;
       i22 = HEAP32[i30 >> 2] | 0;
       HEAP32[i30 >> 2] = i22 + 1;
       HEAP8[(HEAP32[i29 >> 2] | 0) + i22 | 0] = 0;
       i22 = HEAP32[i30 >> 2] | 0;
       HEAP32[i30 >> 2] = i22 + 1;
       HEAP8[(HEAP32[i29 >> 2] | 0) + i22 | 0] = 0;
       i22 = HEAP32[i30 >> 2] | 0;
       HEAP32[i30 >> 2] = i22 + 1;
       HEAP8[(HEAP32[i29 >> 2] | 0) + i22 | 0] = 0;
       i22 = HEAP32[i30 >> 2] | 0;
       HEAP32[i30 >> 2] = i22 + 1;
       HEAP8[(HEAP32[i29 >> 2] | 0) + i22 | 0] = 0;
       i22 = HEAP32[i7 + 132 >> 2] | 0;
       if ((i22 | 0) != 9) {
        if ((HEAP32[i7 + 136 >> 2] | 0) > 1) {
         i22 = 4;
        } else {
         i22 = (i22 | 0) < 2 ? 4 : 0;
        }
       } else {
        i22 = 2;
       }
       i37 = HEAP32[i30 >> 2] | 0;
       HEAP32[i30 >> 2] = i37 + 1;
       HEAP8[(HEAP32[i29 >> 2] | 0) + i37 | 0] = i22;
       i37 = HEAP32[i30 >> 2] | 0;
       HEAP32[i30 >> 2] = i37 + 1;
       HEAP8[(HEAP32[i29 >> 2] | 0) + i37 | 0] = 3;
       HEAP32[i11 >> 2] = 113;
       break;
      }
      i37 = (((HEAP32[i33 + 44 >> 2] | 0) != 0 ? 2 : 0) | (HEAP32[i33 >> 2] | 0) != 0 | ((HEAP32[i33 + 16 >> 2] | 0) == 0 ? 0 : 4) | ((HEAP32[i33 + 28 >> 2] | 0) == 0 ? 0 : 8) | ((HEAP32[i33 + 36 >> 2] | 0) == 0 ? 0 : 16)) & 255;
      i17 = HEAP32[i30 >> 2] | 0;
      HEAP32[i30 >> 2] = i17 + 1;
      HEAP8[(HEAP32[i29 >> 2] | 0) + i17 | 0] = i37;
      i17 = HEAP32[(HEAP32[i28 >> 2] | 0) + 4 >> 2] & 255;
      i37 = HEAP32[i30 >> 2] | 0;
      HEAP32[i30 >> 2] = i37 + 1;
      HEAP8[(HEAP32[i29 >> 2] | 0) + i37 | 0] = i17;
      i37 = (HEAP32[(HEAP32[i28 >> 2] | 0) + 4 >> 2] | 0) >>> 8 & 255;
      i17 = HEAP32[i30 >> 2] | 0;
      HEAP32[i30 >> 2] = i17 + 1;
      HEAP8[(HEAP32[i29 >> 2] | 0) + i17 | 0] = i37;
      i17 = (HEAP32[(HEAP32[i28 >> 2] | 0) + 4 >> 2] | 0) >>> 16 & 255;
      i37 = HEAP32[i30 >> 2] | 0;
      HEAP32[i30 >> 2] = i37 + 1;
      HEAP8[(HEAP32[i29 >> 2] | 0) + i37 | 0] = i17;
      i37 = (HEAP32[(HEAP32[i28 >> 2] | 0) + 4 >> 2] | 0) >>> 24 & 255;
      i17 = HEAP32[i30 >> 2] | 0;
      HEAP32[i30 >> 2] = i17 + 1;
      HEAP8[(HEAP32[i29 >> 2] | 0) + i17 | 0] = i37;
      i17 = HEAP32[i7 + 132 >> 2] | 0;
      if ((i17 | 0) != 9) {
       if ((HEAP32[i7 + 136 >> 2] | 0) > 1) {
        i17 = 4;
       } else {
        i17 = (i17 | 0) < 2 ? 4 : 0;
       }
      } else {
       i17 = 2;
      }
      i37 = HEAP32[i30 >> 2] | 0;
      HEAP32[i30 >> 2] = i37 + 1;
      HEAP8[(HEAP32[i29 >> 2] | 0) + i37 | 0] = i17;
      i37 = HEAP32[(HEAP32[i28 >> 2] | 0) + 12 >> 2] & 255;
      i17 = HEAP32[i30 >> 2] | 0;
      HEAP32[i30 >> 2] = i17 + 1;
      HEAP8[(HEAP32[i29 >> 2] | 0) + i17 | 0] = i37;
      i17 = HEAP32[i28 >> 2] | 0;
      if ((HEAP32[i17 + 16 >> 2] | 0) != 0) {
       i17 = HEAP32[i17 + 20 >> 2] & 255;
       i37 = HEAP32[i30 >> 2] | 0;
       HEAP32[i30 >> 2] = i37 + 1;
       HEAP8[(HEAP32[i29 >> 2] | 0) + i37 | 0] = i17;
       i37 = (HEAP32[(HEAP32[i28 >> 2] | 0) + 20 >> 2] | 0) >>> 8 & 255;
       i17 = HEAP32[i30 >> 2] | 0;
       HEAP32[i30 >> 2] = i17 + 1;
       HEAP8[(HEAP32[i29 >> 2] | 0) + i17 | 0] = i37;
       i17 = HEAP32[i28 >> 2] | 0;
      }
      if ((HEAP32[i17 + 44 >> 2] | 0) != 0) {
       HEAP32[i32 >> 2] = _crc32(HEAP32[i32 >> 2] | 0, HEAP32[i29 >> 2] | 0, HEAP32[i30 >> 2] | 0) | 0;
      }
      HEAP32[i7 + 32 >> 2] = 0;
      HEAP32[i11 >> 2] = 69;
      i17 = 34;
     } else {
      i31 = i29;
      i17 = 32;
     }
    } while (0);
    if ((i17 | 0) == 32) {
     if ((i31 | 0) == 69) {
      i28 = i7 + 28 | 0;
      i17 = 34;
     } else {
      i17 = 55;
     }
    }
    do {
     if ((i17 | 0) == 34) {
      i37 = HEAP32[i28 >> 2] | 0;
      if ((HEAP32[i37 + 16 >> 2] | 0) == 0) {
       HEAP32[i11 >> 2] = 73;
       i17 = 57;
       break;
      }
      i29 = i7 + 20 | 0;
      i34 = HEAP32[i29 >> 2] | 0;
      i17 = i7 + 32 | 0;
      i36 = HEAP32[i17 >> 2] | 0;
      L55 : do {
       if (i36 >>> 0 < (HEAP32[i37 + 20 >> 2] & 65535) >>> 0) {
        i30 = i7 + 12 | 0;
        i32 = i2 + 48 | 0;
        i31 = i7 + 8 | 0;
        i33 = i2 + 20 | 0;
        i35 = i34;
        while (1) {
         if ((i35 | 0) == (HEAP32[i30 >> 2] | 0)) {
          if ((HEAP32[i37 + 44 >> 2] | 0) != 0 & i35 >>> 0 > i34 >>> 0) {
           HEAP32[i32 >> 2] = _crc32(HEAP32[i32 >> 2] | 0, (HEAP32[i31 >> 2] | 0) + i34 | 0, i35 - i34 | 0) | 0;
          }
          i34 = HEAP32[i5 >> 2] | 0;
          i35 = HEAP32[i34 + 20 >> 2] | 0;
          i36 = HEAP32[i3 >> 2] | 0;
          i35 = i35 >>> 0 > i36 >>> 0 ? i36 : i35;
          if ((i35 | 0) != 0 ? (_memcpy(HEAP32[i4 >> 2] | 0, HEAP32[i34 + 16 >> 2] | 0, i35 | 0) | 0, HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i35, i27 = (HEAP32[i5 >> 2] | 0) + 16 | 0, HEAP32[i27 >> 2] = (HEAP32[i27 >> 2] | 0) + i35, HEAP32[i33 >> 2] = (HEAP32[i33 >> 2] | 0) + i35, HEAP32[i3 >> 2] = (HEAP32[i3 >> 2] | 0) - i35, i27 = HEAP32[i5 >> 2] | 0, i36 = i27 + 20 | 0, i37 = HEAP32[i36 >> 2] | 0, HEAP32[i36 >> 2] = i37 - i35, (i37 | 0) == (i35 | 0)) : 0) {
           HEAP32[i27 + 16 >> 2] = HEAP32[i27 + 8 >> 2];
          }
          i34 = HEAP32[i29 >> 2] | 0;
          if ((i34 | 0) == (HEAP32[i30 >> 2] | 0)) {
           break;
          }
          i37 = HEAP32[i28 >> 2] | 0;
          i36 = HEAP32[i17 >> 2] | 0;
          i35 = i34;
         }
         i36 = HEAP8[(HEAP32[i37 + 16 >> 2] | 0) + i36 | 0] | 0;
         HEAP32[i29 >> 2] = i35 + 1;
         HEAP8[(HEAP32[i31 >> 2] | 0) + i35 | 0] = i36;
         i36 = (HEAP32[i17 >> 2] | 0) + 1 | 0;
         HEAP32[i17 >> 2] = i36;
         i37 = HEAP32[i28 >> 2] | 0;
         if (!(i36 >>> 0 < (HEAP32[i37 + 20 >> 2] & 65535) >>> 0)) {
          break L55;
         }
         i35 = HEAP32[i29 >> 2] | 0;
        }
        i37 = HEAP32[i28 >> 2] | 0;
       }
      } while (0);
      if ((HEAP32[i37 + 44 >> 2] | 0) != 0 ? (i26 = HEAP32[i29 >> 2] | 0, i26 >>> 0 > i34 >>> 0) : 0) {
       i37 = i2 + 48 | 0;
       HEAP32[i37 >> 2] = _crc32(HEAP32[i37 >> 2] | 0, (HEAP32[i7 + 8 >> 2] | 0) + i34 | 0, i26 - i34 | 0) | 0;
       i37 = HEAP32[i28 >> 2] | 0;
      }
      if ((HEAP32[i17 >> 2] | 0) == (HEAP32[i37 + 20 >> 2] | 0)) {
       HEAP32[i17 >> 2] = 0;
       HEAP32[i11 >> 2] = 73;
       i17 = 57;
       break;
      } else {
       i31 = HEAP32[i11 >> 2] | 0;
       i17 = 55;
       break;
      }
     }
    } while (0);
    if ((i17 | 0) == 55) {
     if ((i31 | 0) == 73) {
      i37 = HEAP32[i7 + 28 >> 2] | 0;
      i17 = 57;
     } else {
      i17 = 76;
     }
    }
    do {
     if ((i17 | 0) == 57) {
      i26 = i7 + 28 | 0;
      if ((HEAP32[i37 + 28 >> 2] | 0) == 0) {
       HEAP32[i11 >> 2] = 91;
       i17 = 78;
       break;
      }
      i27 = i7 + 20 | 0;
      i35 = HEAP32[i27 >> 2] | 0;
      i32 = i7 + 12 | 0;
      i29 = i2 + 48 | 0;
      i28 = i7 + 8 | 0;
      i31 = i2 + 20 | 0;
      i30 = i7 + 32 | 0;
      i33 = i35;
      while (1) {
       if ((i33 | 0) == (HEAP32[i32 >> 2] | 0)) {
        if ((HEAP32[(HEAP32[i26 >> 2] | 0) + 44 >> 2] | 0) != 0 & i33 >>> 0 > i35 >>> 0) {
         HEAP32[i29 >> 2] = _crc32(HEAP32[i29 >> 2] | 0, (HEAP32[i28 >> 2] | 0) + i35 | 0, i33 - i35 | 0) | 0;
        }
        i33 = HEAP32[i5 >> 2] | 0;
        i34 = HEAP32[i33 + 20 >> 2] | 0;
        i35 = HEAP32[i3 >> 2] | 0;
        i34 = i34 >>> 0 > i35 >>> 0 ? i35 : i34;
        if ((i34 | 0) != 0 ? (_memcpy(HEAP32[i4 >> 2] | 0, HEAP32[i33 + 16 >> 2] | 0, i34 | 0) | 0, HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i34, i25 = (HEAP32[i5 >> 2] | 0) + 16 | 0, HEAP32[i25 >> 2] = (HEAP32[i25 >> 2] | 0) + i34, HEAP32[i31 >> 2] = (HEAP32[i31 >> 2] | 0) + i34, HEAP32[i3 >> 2] = (HEAP32[i3 >> 2] | 0) - i34, i25 = HEAP32[i5 >> 2] | 0, i36 = i25 + 20 | 0, i37 = HEAP32[i36 >> 2] | 0, HEAP32[i36 >> 2] = i37 - i34, (i37 | 0) == (i34 | 0)) : 0) {
         HEAP32[i25 + 16 >> 2] = HEAP32[i25 + 8 >> 2];
        }
        i35 = HEAP32[i27 >> 2] | 0;
        if ((i35 | 0) == (HEAP32[i32 >> 2] | 0)) {
         i25 = 1;
         break;
        } else {
         i33 = i35;
        }
       }
       i34 = HEAP32[i30 >> 2] | 0;
       HEAP32[i30 >> 2] = i34 + 1;
       i34 = HEAP8[(HEAP32[(HEAP32[i26 >> 2] | 0) + 28 >> 2] | 0) + i34 | 0] | 0;
       HEAP32[i27 >> 2] = i33 + 1;
       HEAP8[(HEAP32[i28 >> 2] | 0) + i33 | 0] = i34;
       if (i34 << 24 >> 24 == 0) {
        i17 = 68;
        break;
       }
       i33 = HEAP32[i27 >> 2] | 0;
      }
      if ((i17 | 0) == 68) {
       i25 = i34 & 255;
      }
      if ((HEAP32[(HEAP32[i26 >> 2] | 0) + 44 >> 2] | 0) != 0 ? (i24 = HEAP32[i27 >> 2] | 0, i24 >>> 0 > i35 >>> 0) : 0) {
       HEAP32[i29 >> 2] = _crc32(HEAP32[i29 >> 2] | 0, (HEAP32[i28 >> 2] | 0) + i35 | 0, i24 - i35 | 0) | 0;
      }
      if ((i25 | 0) == 0) {
       HEAP32[i30 >> 2] = 0;
       HEAP32[i11 >> 2] = 91;
       i17 = 78;
       break;
      } else {
       i31 = HEAP32[i11 >> 2] | 0;
       i17 = 76;
       break;
      }
     }
    } while (0);
    if ((i17 | 0) == 76) {
     if ((i31 | 0) == 91) {
      i26 = i7 + 28 | 0;
      i17 = 78;
     } else {
      i17 = 97;
     }
    }
    do {
     if ((i17 | 0) == 78) {
      if ((HEAP32[(HEAP32[i26 >> 2] | 0) + 36 >> 2] | 0) == 0) {
       HEAP32[i11 >> 2] = 103;
       i17 = 99;
       break;
      }
      i24 = i7 + 20 | 0;
      i32 = HEAP32[i24 >> 2] | 0;
      i29 = i7 + 12 | 0;
      i27 = i2 + 48 | 0;
      i25 = i7 + 8 | 0;
      i28 = i2 + 20 | 0;
      i30 = i7 + 32 | 0;
      i31 = i32;
      while (1) {
       if ((i31 | 0) == (HEAP32[i29 >> 2] | 0)) {
        if ((HEAP32[(HEAP32[i26 >> 2] | 0) + 44 >> 2] | 0) != 0 & i31 >>> 0 > i32 >>> 0) {
         HEAP32[i27 >> 2] = _crc32(HEAP32[i27 >> 2] | 0, (HEAP32[i25 >> 2] | 0) + i32 | 0, i31 - i32 | 0) | 0;
        }
        i31 = HEAP32[i5 >> 2] | 0;
        i33 = HEAP32[i31 + 20 >> 2] | 0;
        i32 = HEAP32[i3 >> 2] | 0;
        i32 = i33 >>> 0 > i32 >>> 0 ? i32 : i33;
        if ((i32 | 0) != 0 ? (_memcpy(HEAP32[i4 >> 2] | 0, HEAP32[i31 + 16 >> 2] | 0, i32 | 0) | 0, HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i32, i23 = (HEAP32[i5 >> 2] | 0) + 16 | 0, HEAP32[i23 >> 2] = (HEAP32[i23 >> 2] | 0) + i32, HEAP32[i28 >> 2] = (HEAP32[i28 >> 2] | 0) + i32, HEAP32[i3 >> 2] = (HEAP32[i3 >> 2] | 0) - i32, i23 = HEAP32[i5 >> 2] | 0, i36 = i23 + 20 | 0, i37 = HEAP32[i36 >> 2] | 0, HEAP32[i36 >> 2] = i37 - i32, (i37 | 0) == (i32 | 0)) : 0) {
         HEAP32[i23 + 16 >> 2] = HEAP32[i23 + 8 >> 2];
        }
        i32 = HEAP32[i24 >> 2] | 0;
        if ((i32 | 0) == (HEAP32[i29 >> 2] | 0)) {
         i23 = 1;
         break;
        } else {
         i31 = i32;
        }
       }
       i33 = HEAP32[i30 >> 2] | 0;
       HEAP32[i30 >> 2] = i33 + 1;
       i33 = HEAP8[(HEAP32[(HEAP32[i26 >> 2] | 0) + 36 >> 2] | 0) + i33 | 0] | 0;
       HEAP32[i24 >> 2] = i31 + 1;
       HEAP8[(HEAP32[i25 >> 2] | 0) + i31 | 0] = i33;
       if (i33 << 24 >> 24 == 0) {
        i17 = 89;
        break;
       }
       i31 = HEAP32[i24 >> 2] | 0;
      }
      if ((i17 | 0) == 89) {
       i23 = i33 & 255;
      }
      if ((HEAP32[(HEAP32[i26 >> 2] | 0) + 44 >> 2] | 0) != 0 ? (i22 = HEAP32[i24 >> 2] | 0, i22 >>> 0 > i32 >>> 0) : 0) {
       HEAP32[i27 >> 2] = _crc32(HEAP32[i27 >> 2] | 0, (HEAP32[i25 >> 2] | 0) + i32 | 0, i22 - i32 | 0) | 0;
      }
      if ((i23 | 0) == 0) {
       HEAP32[i11 >> 2] = 103;
       i17 = 99;
       break;
      } else {
       i31 = HEAP32[i11 >> 2] | 0;
       i17 = 97;
       break;
      }
     }
    } while (0);
    if ((i17 | 0) == 97 ? (i31 | 0) == 103 : 0) {
     i26 = i7 + 28 | 0;
     i17 = 99;
    }
    do {
     if ((i17 | 0) == 99) {
      if ((HEAP32[(HEAP32[i26 >> 2] | 0) + 44 >> 2] | 0) == 0) {
       HEAP32[i11 >> 2] = 113;
       break;
      }
      i17 = i7 + 20 | 0;
      i22 = i7 + 12 | 0;
      if ((((HEAP32[i17 >> 2] | 0) + 2 | 0) >>> 0 > (HEAP32[i22 >> 2] | 0) >>> 0 ? (i20 = HEAP32[i5 >> 2] | 0, i21 = HEAP32[i20 + 20 >> 2] | 0, i23 = HEAP32[i3 >> 2] | 0, i21 = i21 >>> 0 > i23 >>> 0 ? i23 : i21, (i21 | 0) != 0) : 0) ? (_memcpy(HEAP32[i4 >> 2] | 0, HEAP32[i20 + 16 >> 2] | 0, i21 | 0) | 0, HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i21, i19 = (HEAP32[i5 >> 2] | 0) + 16 | 0, HEAP32[i19 >> 2] = (HEAP32[i19 >> 2] | 0) + i21, i19 = i2 + 20 | 0, HEAP32[i19 >> 2] = (HEAP32[i19 >> 2] | 0) + i21, HEAP32[i3 >> 2] = (HEAP32[i3 >> 2] | 0) - i21, i19 = HEAP32[i5 >> 2] | 0, i36 = i19 + 20 | 0, i37 = HEAP32[i36 >> 2] | 0, HEAP32[i36 >> 2] = i37 - i21, (i37 | 0) == (i21 | 0)) : 0) {
       HEAP32[i19 + 16 >> 2] = HEAP32[i19 + 8 >> 2];
      }
      i19 = HEAP32[i17 >> 2] | 0;
      if (!((i19 + 2 | 0) >>> 0 > (HEAP32[i22 >> 2] | 0) >>> 0)) {
       i37 = i2 + 48 | 0;
       i34 = HEAP32[i37 >> 2] & 255;
       HEAP32[i17 >> 2] = i19 + 1;
       i35 = i7 + 8 | 0;
       HEAP8[(HEAP32[i35 >> 2] | 0) + i19 | 0] = i34;
       i34 = (HEAP32[i37 >> 2] | 0) >>> 8 & 255;
       i36 = HEAP32[i17 >> 2] | 0;
       HEAP32[i17 >> 2] = i36 + 1;
       HEAP8[(HEAP32[i35 >> 2] | 0) + i36 | 0] = i34;
       HEAP32[i37 >> 2] = _crc32(0, 0, 0) | 0;
       HEAP32[i11 >> 2] = 113;
      }
     }
    } while (0);
    i19 = i7 + 20 | 0;
    if ((HEAP32[i19 >> 2] | 0) == 0) {
     if ((HEAP32[i2 + 4 >> 2] | 0) == 0 ? (i18 | 0) >= (i10 | 0) & (i10 | 0) != 4 : 0) {
      HEAP32[i2 + 24 >> 2] = HEAP32[3180 >> 2];
      i37 = -5;
      STACKTOP = i1;
      return i37 | 0;
     }
    } else {
     i17 = HEAP32[i5 >> 2] | 0;
     i20 = HEAP32[i17 + 20 >> 2] | 0;
     i18 = HEAP32[i3 >> 2] | 0;
     i20 = i20 >>> 0 > i18 >>> 0 ? i18 : i20;
     if ((i20 | 0) != 0) {
      _memcpy(HEAP32[i4 >> 2] | 0, HEAP32[i17 + 16 >> 2] | 0, i20 | 0) | 0;
      HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i20;
      i17 = (HEAP32[i5 >> 2] | 0) + 16 | 0;
      HEAP32[i17 >> 2] = (HEAP32[i17 >> 2] | 0) + i20;
      i17 = i2 + 20 | 0;
      HEAP32[i17 >> 2] = (HEAP32[i17 >> 2] | 0) + i20;
      HEAP32[i3 >> 2] = (HEAP32[i3 >> 2] | 0) - i20;
      i17 = HEAP32[i5 >> 2] | 0;
      i36 = i17 + 20 | 0;
      i37 = HEAP32[i36 >> 2] | 0;
      HEAP32[i36 >> 2] = i37 - i20;
      if ((i37 | 0) == (i20 | 0)) {
       HEAP32[i17 + 16 >> 2] = HEAP32[i17 + 8 >> 2];
      }
      i18 = HEAP32[i3 >> 2] | 0;
     }
     if ((i18 | 0) == 0) {
      HEAP32[i8 >> 2] = -1;
      i37 = 0;
      STACKTOP = i1;
      return i37 | 0;
     }
    }
    i18 = (HEAP32[i11 >> 2] | 0) == 666;
    i17 = (HEAP32[i2 + 4 >> 2] | 0) == 0;
    if (i18) {
     if (i17) {
      i17 = 121;
     } else {
      HEAP32[i2 + 24 >> 2] = HEAP32[3180 >> 2];
      i37 = -5;
      STACKTOP = i1;
      return i37 | 0;
     }
    } else {
     if (i17) {
      i17 = 121;
     } else {
      i17 = 124;
     }
    }
    do {
     if ((i17 | 0) == 121) {
      if ((HEAP32[i7 + 116 >> 2] | 0) == 0) {
       if ((i10 | 0) != 0) {
        if (i18) {
         break;
        } else {
         i17 = 124;
         break;
        }
       } else {
        i37 = 0;
        STACKTOP = i1;
        return i37 | 0;
       }
      } else {
       i17 = 124;
      }
     }
    } while (0);
    do {
     if ((i17 | 0) == 124) {
      i18 = HEAP32[i7 + 136 >> 2] | 0;
      L185 : do {
       if ((i18 | 0) == 2) {
        i22 = i7 + 116 | 0;
        i18 = i7 + 96 | 0;
        i13 = i7 + 108 | 0;
        i14 = i7 + 56 | 0;
        i21 = i7 + 5792 | 0;
        i20 = i7 + 5796 | 0;
        i24 = i7 + 5784 | 0;
        i23 = i7 + 5788 | 0;
        i12 = i7 + 92 | 0;
        while (1) {
         if ((HEAP32[i22 >> 2] | 0) == 0 ? (_fill_window(i7), (HEAP32[i22 >> 2] | 0) == 0) : 0) {
          break;
         }
         HEAP32[i18 >> 2] = 0;
         i37 = HEAP8[(HEAP32[i14 >> 2] | 0) + (HEAP32[i13 >> 2] | 0) | 0] | 0;
         i26 = HEAP32[i21 >> 2] | 0;
         HEAP16[(HEAP32[i20 >> 2] | 0) + (i26 << 1) >> 1] = 0;
         HEAP32[i21 >> 2] = i26 + 1;
         HEAP8[(HEAP32[i24 >> 2] | 0) + i26 | 0] = i37;
         i37 = i7 + ((i37 & 255) << 2) + 148 | 0;
         HEAP16[i37 >> 1] = (HEAP16[i37 >> 1] | 0) + 1 << 16 >> 16;
         i37 = (HEAP32[i21 >> 2] | 0) == ((HEAP32[i23 >> 2] | 0) + -1 | 0);
         HEAP32[i22 >> 2] = (HEAP32[i22 >> 2] | 0) + -1;
         i26 = (HEAP32[i13 >> 2] | 0) + 1 | 0;
         HEAP32[i13 >> 2] = i26;
         if (!i37) {
          continue;
         }
         i25 = HEAP32[i12 >> 2] | 0;
         if ((i25 | 0) > -1) {
          i27 = (HEAP32[i14 >> 2] | 0) + i25 | 0;
         } else {
          i27 = 0;
         }
         __tr_flush_block(i7, i27, i26 - i25 | 0, 0);
         HEAP32[i12 >> 2] = HEAP32[i13 >> 2];
         i26 = HEAP32[i7 >> 2] | 0;
         i25 = i26 + 28 | 0;
         i27 = HEAP32[i25 >> 2] | 0;
         i30 = HEAP32[i27 + 20 >> 2] | 0;
         i28 = i26 + 16 | 0;
         i29 = HEAP32[i28 >> 2] | 0;
         i29 = i30 >>> 0 > i29 >>> 0 ? i29 : i30;
         if ((i29 | 0) != 0 ? (i16 = i26 + 12 | 0, _memcpy(HEAP32[i16 >> 2] | 0, HEAP32[i27 + 16 >> 2] | 0, i29 | 0) | 0, HEAP32[i16 >> 2] = (HEAP32[i16 >> 2] | 0) + i29, i16 = (HEAP32[i25 >> 2] | 0) + 16 | 0, HEAP32[i16 >> 2] = (HEAP32[i16 >> 2] | 0) + i29, i16 = i26 + 20 | 0, HEAP32[i16 >> 2] = (HEAP32[i16 >> 2] | 0) + i29, HEAP32[i28 >> 2] = (HEAP32[i28 >> 2] | 0) - i29, i16 = HEAP32[i25 >> 2] | 0, i36 = i16 + 20 | 0, i37 = HEAP32[i36 >> 2] | 0, HEAP32[i36 >> 2] = i37 - i29, (i37 | 0) == (i29 | 0)) : 0) {
          HEAP32[i16 + 16 >> 2] = HEAP32[i16 + 8 >> 2];
         }
         if ((HEAP32[(HEAP32[i7 >> 2] | 0) + 16 >> 2] | 0) == 0) {
          break L185;
         }
        }
        if ((i10 | 0) != 0) {
         i16 = HEAP32[i12 >> 2] | 0;
         if ((i16 | 0) > -1) {
          i14 = (HEAP32[i14 >> 2] | 0) + i16 | 0;
         } else {
          i14 = 0;
         }
         __tr_flush_block(i7, i14, (HEAP32[i13 >> 2] | 0) - i16 | 0, i9 & 1);
         HEAP32[i12 >> 2] = HEAP32[i13 >> 2];
         i14 = HEAP32[i7 >> 2] | 0;
         i13 = i14 + 28 | 0;
         i12 = HEAP32[i13 >> 2] | 0;
         i17 = HEAP32[i12 + 20 >> 2] | 0;
         i16 = i14 + 16 | 0;
         i18 = HEAP32[i16 >> 2] | 0;
         i17 = i17 >>> 0 > i18 >>> 0 ? i18 : i17;
         if ((i17 | 0) != 0 ? (i15 = i14 + 12 | 0, _memcpy(HEAP32[i15 >> 2] | 0, HEAP32[i12 + 16 >> 2] | 0, i17 | 0) | 0, HEAP32[i15 >> 2] = (HEAP32[i15 >> 2] | 0) + i17, i15 = (HEAP32[i13 >> 2] | 0) + 16 | 0, HEAP32[i15 >> 2] = (HEAP32[i15 >> 2] | 0) + i17, i15 = i14 + 20 | 0, HEAP32[i15 >> 2] = (HEAP32[i15 >> 2] | 0) + i17, HEAP32[i16 >> 2] = (HEAP32[i16 >> 2] | 0) - i17, i15 = HEAP32[i13 >> 2] | 0, i36 = i15 + 20 | 0, i37 = HEAP32[i36 >> 2] | 0, HEAP32[i36 >> 2] = i37 - i17, (i37 | 0) == (i17 | 0)) : 0) {
          HEAP32[i15 + 16 >> 2] = HEAP32[i15 + 8 >> 2];
         }
         if ((HEAP32[(HEAP32[i7 >> 2] | 0) + 16 >> 2] | 0) == 0) {
          i12 = i9 ? 2 : 0;
          i17 = 183;
          break;
         } else {
          i12 = i9 ? 3 : 1;
          i17 = 183;
          break;
         }
        }
       } else if ((i18 | 0) == 3) {
        i27 = i7 + 116 | 0;
        i26 = (i10 | 0) == 0;
        i22 = i7 + 96 | 0;
        i15 = i7 + 108 | 0;
        i20 = i7 + 5792 | 0;
        i24 = i7 + 5796 | 0;
        i23 = i7 + 5784 | 0;
        i21 = i7 + (HEAPU8[296] << 2) + 2440 | 0;
        i25 = i7 + 5788 | 0;
        i18 = i7 + 56 | 0;
        i16 = i7 + 92 | 0;
        while (1) {
         i29 = HEAP32[i27 >> 2] | 0;
         if (i29 >>> 0 < 258) {
          _fill_window(i7);
          i29 = HEAP32[i27 >> 2] | 0;
          if (i29 >>> 0 < 258 & i26) {
           break L185;
          }
          if ((i29 | 0) == 0) {
           break;
          }
          HEAP32[i22 >> 2] = 0;
          if (i29 >>> 0 > 2) {
           i17 = 151;
          } else {
           i28 = HEAP32[i15 >> 2] | 0;
           i17 = 166;
          }
         } else {
          HEAP32[i22 >> 2] = 0;
          i17 = 151;
         }
         if ((i17 | 0) == 151) {
          i17 = 0;
          i28 = HEAP32[i15 >> 2] | 0;
          if ((i28 | 0) != 0) {
           i31 = HEAP32[i18 >> 2] | 0;
           i30 = HEAP8[i31 + (i28 + -1) | 0] | 0;
           if ((i30 << 24 >> 24 == (HEAP8[i31 + i28 | 0] | 0) ? i30 << 24 >> 24 == (HEAP8[i31 + (i28 + 1) | 0] | 0) : 0) ? (i14 = i31 + (i28 + 2) | 0, i30 << 24 >> 24 == (HEAP8[i14] | 0)) : 0) {
            i31 = i31 + (i28 + 258) | 0;
            i32 = i14;
            do {
             i33 = i32 + 1 | 0;
             if (!(i30 << 24 >> 24 == (HEAP8[i33] | 0))) {
              i32 = i33;
              break;
             }
             i33 = i32 + 2 | 0;
             if (!(i30 << 24 >> 24 == (HEAP8[i33] | 0))) {
              i32 = i33;
              break;
             }
             i33 = i32 + 3 | 0;
             if (!(i30 << 24 >> 24 == (HEAP8[i33] | 0))) {
              i32 = i33;
              break;
             }
             i33 = i32 + 4 | 0;
             if (!(i30 << 24 >> 24 == (HEAP8[i33] | 0))) {
              i32 = i33;
              break;
             }
             i33 = i32 + 5 | 0;
             if (!(i30 << 24 >> 24 == (HEAP8[i33] | 0))) {
              i32 = i33;
              break;
             }
             i33 = i32 + 6 | 0;
             if (!(i30 << 24 >> 24 == (HEAP8[i33] | 0))) {
              i32 = i33;
              break;
             }
             i33 = i32 + 7 | 0;
             if (!(i30 << 24 >> 24 == (HEAP8[i33] | 0))) {
              i32 = i33;
              break;
             }
             i32 = i32 + 8 | 0;
            } while (i30 << 24 >> 24 == (HEAP8[i32] | 0) & i32 >>> 0 < i31 >>> 0);
            i30 = i32 - i31 + 258 | 0;
            i29 = i30 >>> 0 > i29 >>> 0 ? i29 : i30;
            HEAP32[i22 >> 2] = i29;
            if (i29 >>> 0 > 2) {
             i29 = i29 + 253 | 0;
             i28 = HEAP32[i20 >> 2] | 0;
             HEAP16[(HEAP32[i24 >> 2] | 0) + (i28 << 1) >> 1] = 1;
             HEAP32[i20 >> 2] = i28 + 1;
             HEAP8[(HEAP32[i23 >> 2] | 0) + i28 | 0] = i29;
             i29 = i7 + ((HEAPU8[808 + (i29 & 255) | 0] | 256) + 1 << 2) + 148 | 0;
             HEAP16[i29 >> 1] = (HEAP16[i29 >> 1] | 0) + 1 << 16 >> 16;
             HEAP16[i21 >> 1] = (HEAP16[i21 >> 1] | 0) + 1 << 16 >> 16;
             i29 = (HEAP32[i20 >> 2] | 0) == ((HEAP32[i25 >> 2] | 0) + -1 | 0) | 0;
             i28 = HEAP32[i22 >> 2] | 0;
             HEAP32[i27 >> 2] = (HEAP32[i27 >> 2] | 0) - i28;
             i28 = (HEAP32[i15 >> 2] | 0) + i28 | 0;
             HEAP32[i15 >> 2] = i28;
             HEAP32[i22 >> 2] = 0;
            } else {
             i17 = 166;
            }
           } else {
            i17 = 166;
           }
          } else {
           i28 = 0;
           i17 = 166;
          }
         }
         if ((i17 | 0) == 166) {
          i17 = 0;
          i29 = HEAP8[(HEAP32[i18 >> 2] | 0) + i28 | 0] | 0;
          i28 = HEAP32[i20 >> 2] | 0;
          HEAP16[(HEAP32[i24 >> 2] | 0) + (i28 << 1) >> 1] = 0;
          HEAP32[i20 >> 2] = i28 + 1;
          HEAP8[(HEAP32[i23 >> 2] | 0) + i28 | 0] = i29;
          i29 = i7 + ((i29 & 255) << 2) + 148 | 0;
          HEAP16[i29 >> 1] = (HEAP16[i29 >> 1] | 0) + 1 << 16 >> 16;
          i29 = (HEAP32[i20 >> 2] | 0) == ((HEAP32[i25 >> 2] | 0) + -1 | 0) | 0;
          HEAP32[i27 >> 2] = (HEAP32[i27 >> 2] | 0) + -1;
          i28 = (HEAP32[i15 >> 2] | 0) + 1 | 0;
          HEAP32[i15 >> 2] = i28;
         }
         if ((i29 | 0) == 0) {
          continue;
         }
         i29 = HEAP32[i16 >> 2] | 0;
         if ((i29 | 0) > -1) {
          i30 = (HEAP32[i18 >> 2] | 0) + i29 | 0;
         } else {
          i30 = 0;
         }
         __tr_flush_block(i7, i30, i28 - i29 | 0, 0);
         HEAP32[i16 >> 2] = HEAP32[i15 >> 2];
         i30 = HEAP32[i7 >> 2] | 0;
         i28 = i30 + 28 | 0;
         i29 = HEAP32[i28 >> 2] | 0;
         i33 = HEAP32[i29 + 20 >> 2] | 0;
         i31 = i30 + 16 | 0;
         i32 = HEAP32[i31 >> 2] | 0;
         i32 = i33 >>> 0 > i32 >>> 0 ? i32 : i33;
         if ((i32 | 0) != 0 ? (i13 = i30 + 12 | 0, _memcpy(HEAP32[i13 >> 2] | 0, HEAP32[i29 + 16 >> 2] | 0, i32 | 0) | 0, HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + i32, i13 = (HEAP32[i28 >> 2] | 0) + 16 | 0, HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + i32, i13 = i30 + 20 | 0, HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) + i32, HEAP32[i31 >> 2] = (HEAP32[i31 >> 2] | 0) - i32, i13 = HEAP32[i28 >> 2] | 0, i36 = i13 + 20 | 0, i37 = HEAP32[i36 >> 2] | 0, HEAP32[i36 >> 2] = i37 - i32, (i37 | 0) == (i32 | 0)) : 0) {
          HEAP32[i13 + 16 >> 2] = HEAP32[i13 + 8 >> 2];
         }
         if ((HEAP32[(HEAP32[i7 >> 2] | 0) + 16 >> 2] | 0) == 0) {
          break L185;
         }
        }
        i13 = HEAP32[i16 >> 2] | 0;
        if ((i13 | 0) > -1) {
         i14 = (HEAP32[i18 >> 2] | 0) + i13 | 0;
        } else {
         i14 = 0;
        }
        __tr_flush_block(i7, i14, (HEAP32[i15 >> 2] | 0) - i13 | 0, i9 & 1);
        HEAP32[i16 >> 2] = HEAP32[i15 >> 2];
        i14 = HEAP32[i7 >> 2] | 0;
        i16 = i14 + 28 | 0;
        i15 = HEAP32[i16 >> 2] | 0;
        i18 = HEAP32[i15 + 20 >> 2] | 0;
        i13 = i14 + 16 | 0;
        i17 = HEAP32[i13 >> 2] | 0;
        i17 = i18 >>> 0 > i17 >>> 0 ? i17 : i18;
        if ((i17 | 0) != 0 ? (i12 = i14 + 12 | 0, _memcpy(HEAP32[i12 >> 2] | 0, HEAP32[i15 + 16 >> 2] | 0, i17 | 0) | 0, HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + i17, i12 = (HEAP32[i16 >> 2] | 0) + 16 | 0, HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + i17, i12 = i14 + 20 | 0, HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) + i17, HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) - i17, i12 = HEAP32[i16 >> 2] | 0, i36 = i12 + 20 | 0, i37 = HEAP32[i36 >> 2] | 0, HEAP32[i36 >> 2] = i37 - i17, (i37 | 0) == (i17 | 0)) : 0) {
         HEAP32[i12 + 16 >> 2] = HEAP32[i12 + 8 >> 2];
        }
        if ((HEAP32[(HEAP32[i7 >> 2] | 0) + 16 >> 2] | 0) == 0) {
         i12 = i9 ? 2 : 0;
         i17 = 183;
         break;
        } else {
         i12 = i9 ? 3 : 1;
         i17 = 183;
         break;
        }
       } else {
        i12 = FUNCTION_TABLE_iii[HEAP32[184 + ((HEAP32[i7 + 132 >> 2] | 0) * 12 | 0) >> 2] & 3](i7, i10) | 0;
        i17 = 183;
       }
      } while (0);
      if ((i17 | 0) == 183) {
       if ((i12 & -2 | 0) == 2) {
        HEAP32[i11 >> 2] = 666;
       }
       if ((i12 & -3 | 0) != 0) {
        if ((i12 | 0) != 1) {
         break;
        }
        if ((i10 | 0) == 1) {
         __tr_align(i7);
        } else if (((i10 | 0) != 5 ? (__tr_stored_block(i7, 0, 0, 0), (i10 | 0) == 3) : 0) ? (i37 = HEAP32[i7 + 76 >> 2] | 0, i36 = HEAP32[i7 + 68 >> 2] | 0, HEAP16[i36 + (i37 + -1 << 1) >> 1] = 0, _memset(i36 | 0, 0, (i37 << 1) + -2 | 0) | 0, (HEAP32[i7 + 116 >> 2] | 0) == 0) : 0) {
         HEAP32[i7 + 108 >> 2] = 0;
         HEAP32[i7 + 92 >> 2] = 0;
        }
        i11 = HEAP32[i5 >> 2] | 0;
        i12 = HEAP32[i11 + 20 >> 2] | 0;
        i10 = HEAP32[i3 >> 2] | 0;
        i12 = i12 >>> 0 > i10 >>> 0 ? i10 : i12;
        if ((i12 | 0) != 0) {
         _memcpy(HEAP32[i4 >> 2] | 0, HEAP32[i11 + 16 >> 2] | 0, i12 | 0) | 0;
         HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i12;
         i10 = (HEAP32[i5 >> 2] | 0) + 16 | 0;
         HEAP32[i10 >> 2] = (HEAP32[i10 >> 2] | 0) + i12;
         i10 = i2 + 20 | 0;
         HEAP32[i10 >> 2] = (HEAP32[i10 >> 2] | 0) + i12;
         HEAP32[i3 >> 2] = (HEAP32[i3 >> 2] | 0) - i12;
         i10 = HEAP32[i5 >> 2] | 0;
         i36 = i10 + 20 | 0;
         i37 = HEAP32[i36 >> 2] | 0;
         HEAP32[i36 >> 2] = i37 - i12;
         if ((i37 | 0) == (i12 | 0)) {
          HEAP32[i10 + 16 >> 2] = HEAP32[i10 + 8 >> 2];
         }
         i10 = HEAP32[i3 >> 2] | 0;
        }
        if ((i10 | 0) != 0) {
         break;
        }
        HEAP32[i8 >> 2] = -1;
        i37 = 0;
        STACKTOP = i1;
        return i37 | 0;
       }
      }
      if ((HEAP32[i3 >> 2] | 0) != 0) {
       i37 = 0;
       STACKTOP = i1;
       return i37 | 0;
      }
      HEAP32[i8 >> 2] = -1;
      i37 = 0;
      STACKTOP = i1;
      return i37 | 0;
     }
    } while (0);
    if (!i9) {
     i37 = 0;
     STACKTOP = i1;
     return i37 | 0;
    }
    i8 = i7 + 24 | 0;
    i10 = HEAP32[i8 >> 2] | 0;
    if ((i10 | 0) < 1) {
     i37 = 1;
     STACKTOP = i1;
     return i37 | 0;
    }
    i11 = i2 + 48 | 0;
    i9 = HEAP32[i11 >> 2] | 0;
    if ((i10 | 0) == 2) {
     i34 = HEAP32[i19 >> 2] | 0;
     HEAP32[i19 >> 2] = i34 + 1;
     i36 = i7 + 8 | 0;
     HEAP8[(HEAP32[i36 >> 2] | 0) + i34 | 0] = i9;
     i34 = (HEAP32[i11 >> 2] | 0) >>> 8 & 255;
     i35 = HEAP32[i19 >> 2] | 0;
     HEAP32[i19 >> 2] = i35 + 1;
     HEAP8[(HEAP32[i36 >> 2] | 0) + i35 | 0] = i34;
     i35 = (HEAP32[i11 >> 2] | 0) >>> 16 & 255;
     i34 = HEAP32[i19 >> 2] | 0;
     HEAP32[i19 >> 2] = i34 + 1;
     HEAP8[(HEAP32[i36 >> 2] | 0) + i34 | 0] = i35;
     i34 = (HEAP32[i11 >> 2] | 0) >>> 24 & 255;
     i35 = HEAP32[i19 >> 2] | 0;
     HEAP32[i19 >> 2] = i35 + 1;
     HEAP8[(HEAP32[i36 >> 2] | 0) + i35 | 0] = i34;
     i35 = i2 + 8 | 0;
     i34 = HEAP32[i35 >> 2] & 255;
     i37 = HEAP32[i19 >> 2] | 0;
     HEAP32[i19 >> 2] = i37 + 1;
     HEAP8[(HEAP32[i36 >> 2] | 0) + i37 | 0] = i34;
     i37 = (HEAP32[i35 >> 2] | 0) >>> 8 & 255;
     i34 = HEAP32[i19 >> 2] | 0;
     HEAP32[i19 >> 2] = i34 + 1;
     HEAP8[(HEAP32[i36 >> 2] | 0) + i34 | 0] = i37;
     i34 = (HEAP32[i35 >> 2] | 0) >>> 16 & 255;
     i37 = HEAP32[i19 >> 2] | 0;
     HEAP32[i19 >> 2] = i37 + 1;
     HEAP8[(HEAP32[i36 >> 2] | 0) + i37 | 0] = i34;
     i35 = (HEAP32[i35 >> 2] | 0) >>> 24 & 255;
     i37 = HEAP32[i19 >> 2] | 0;
     HEAP32[i19 >> 2] = i37 + 1;
     HEAP8[(HEAP32[i36 >> 2] | 0) + i37 | 0] = i35;
    } else {
     i35 = HEAP32[i19 >> 2] | 0;
     HEAP32[i19 >> 2] = i35 + 1;
     i36 = i7 + 8 | 0;
     HEAP8[(HEAP32[i36 >> 2] | 0) + i35 | 0] = i9 >>> 24;
     i35 = HEAP32[i19 >> 2] | 0;
     HEAP32[i19 >> 2] = i35 + 1;
     HEAP8[(HEAP32[i36 >> 2] | 0) + i35 | 0] = i9 >>> 16;
     i35 = HEAP32[i11 >> 2] | 0;
     i37 = HEAP32[i19 >> 2] | 0;
     HEAP32[i19 >> 2] = i37 + 1;
     HEAP8[(HEAP32[i36 >> 2] | 0) + i37 | 0] = i35 >>> 8;
     i37 = HEAP32[i19 >> 2] | 0;
     HEAP32[i19 >> 2] = i37 + 1;
     HEAP8[(HEAP32[i36 >> 2] | 0) + i37 | 0] = i35;
    }
    i7 = HEAP32[i5 >> 2] | 0;
    i10 = HEAP32[i7 + 20 >> 2] | 0;
    i9 = HEAP32[i3 >> 2] | 0;
    i9 = i10 >>> 0 > i9 >>> 0 ? i9 : i10;
    if ((i9 | 0) != 0 ? (_memcpy(HEAP32[i4 >> 2] | 0, HEAP32[i7 + 16 >> 2] | 0, i9 | 0) | 0, HEAP32[i4 >> 2] = (HEAP32[i4 >> 2] | 0) + i9, i6 = (HEAP32[i5 >> 2] | 0) + 16 | 0, HEAP32[i6 >> 2] = (HEAP32[i6 >> 2] | 0) + i9, i6 = i2 + 20 | 0, HEAP32[i6 >> 2] = (HEAP32[i6 >> 2] | 0) + i9, HEAP32[i3 >> 2] = (HEAP32[i3 >> 2] | 0) - i9, i6 = HEAP32[i5 >> 2] | 0, i36 = i6 + 20 | 0, i37 = HEAP32[i36 >> 2] | 0, HEAP32[i36 >> 2] = i37 - i9, (i37 | 0) == (i9 | 0)) : 0) {
     HEAP32[i6 + 16 >> 2] = HEAP32[i6 + 8 >> 2];
    }
    i2 = HEAP32[i8 >> 2] | 0;
    if ((i2 | 0) > 0) {
     HEAP32[i8 >> 2] = 0 - i2;
    }
    i37 = (HEAP32[i19 >> 2] | 0) == 0 | 0;
    STACKTOP = i1;
    return i37 | 0;
   }
  }
 } while (0);
 HEAP32[i2 + 24 >> 2] = HEAP32[3168 >> 2];
 i37 = -2;
 STACKTOP = i1;
 return i37 | 0;
}
function _free(i7) {
 i7 = i7 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0;
 i1 = STACKTOP;
 if ((i7 | 0) == 0) {
  STACKTOP = i1;
  return;
 }
 i15 = i7 + -8 | 0;
 i16 = HEAP32[14488 >> 2] | 0;
 if (i15 >>> 0 < i16 >>> 0) {
  _abort();
 }
 i13 = HEAP32[i7 + -4 >> 2] | 0;
 i12 = i13 & 3;
 if ((i12 | 0) == 1) {
  _abort();
 }
 i8 = i13 & -8;
 i6 = i7 + (i8 + -8) | 0;
 do {
  if ((i13 & 1 | 0) == 0) {
   i19 = HEAP32[i15 >> 2] | 0;
   if ((i12 | 0) == 0) {
    STACKTOP = i1;
    return;
   }
   i15 = -8 - i19 | 0;
   i13 = i7 + i15 | 0;
   i12 = i19 + i8 | 0;
   if (i13 >>> 0 < i16 >>> 0) {
    _abort();
   }
   if ((i13 | 0) == (HEAP32[14492 >> 2] | 0)) {
    i2 = i7 + (i8 + -4) | 0;
    if ((HEAP32[i2 >> 2] & 3 | 0) != 3) {
     i2 = i13;
     i11 = i12;
     break;
    }
    HEAP32[14480 >> 2] = i12;
    HEAP32[i2 >> 2] = HEAP32[i2 >> 2] & -2;
    HEAP32[i7 + (i15 + 4) >> 2] = i12 | 1;
    HEAP32[i6 >> 2] = i12;
    STACKTOP = i1;
    return;
   }
   i18 = i19 >>> 3;
   if (i19 >>> 0 < 256) {
    i2 = HEAP32[i7 + (i15 + 8) >> 2] | 0;
    i11 = HEAP32[i7 + (i15 + 12) >> 2] | 0;
    i14 = 14512 + (i18 << 1 << 2) | 0;
    if ((i2 | 0) != (i14 | 0)) {
     if (i2 >>> 0 < i16 >>> 0) {
      _abort();
     }
     if ((HEAP32[i2 + 12 >> 2] | 0) != (i13 | 0)) {
      _abort();
     }
    }
    if ((i11 | 0) == (i2 | 0)) {
     HEAP32[3618] = HEAP32[3618] & ~(1 << i18);
     i2 = i13;
     i11 = i12;
     break;
    }
    if ((i11 | 0) != (i14 | 0)) {
     if (i11 >>> 0 < i16 >>> 0) {
      _abort();
     }
     i14 = i11 + 8 | 0;
     if ((HEAP32[i14 >> 2] | 0) == (i13 | 0)) {
      i17 = i14;
     } else {
      _abort();
     }
    } else {
     i17 = i11 + 8 | 0;
    }
    HEAP32[i2 + 12 >> 2] = i11;
    HEAP32[i17 >> 2] = i2;
    i2 = i13;
    i11 = i12;
    break;
   }
   i17 = HEAP32[i7 + (i15 + 24) >> 2] | 0;
   i18 = HEAP32[i7 + (i15 + 12) >> 2] | 0;
   do {
    if ((i18 | 0) == (i13 | 0)) {
     i19 = i7 + (i15 + 20) | 0;
     i18 = HEAP32[i19 >> 2] | 0;
     if ((i18 | 0) == 0) {
      i19 = i7 + (i15 + 16) | 0;
      i18 = HEAP32[i19 >> 2] | 0;
      if ((i18 | 0) == 0) {
       i14 = 0;
       break;
      }
     }
     while (1) {
      i21 = i18 + 20 | 0;
      i20 = HEAP32[i21 >> 2] | 0;
      if ((i20 | 0) != 0) {
       i18 = i20;
       i19 = i21;
       continue;
      }
      i20 = i18 + 16 | 0;
      i21 = HEAP32[i20 >> 2] | 0;
      if ((i21 | 0) == 0) {
       break;
      } else {
       i18 = i21;
       i19 = i20;
      }
     }
     if (i19 >>> 0 < i16 >>> 0) {
      _abort();
     } else {
      HEAP32[i19 >> 2] = 0;
      i14 = i18;
      break;
     }
    } else {
     i19 = HEAP32[i7 + (i15 + 8) >> 2] | 0;
     if (i19 >>> 0 < i16 >>> 0) {
      _abort();
     }
     i16 = i19 + 12 | 0;
     if ((HEAP32[i16 >> 2] | 0) != (i13 | 0)) {
      _abort();
     }
     i20 = i18 + 8 | 0;
     if ((HEAP32[i20 >> 2] | 0) == (i13 | 0)) {
      HEAP32[i16 >> 2] = i18;
      HEAP32[i20 >> 2] = i19;
      i14 = i18;
      break;
     } else {
      _abort();
     }
    }
   } while (0);
   if ((i17 | 0) != 0) {
    i18 = HEAP32[i7 + (i15 + 28) >> 2] | 0;
    i16 = 14776 + (i18 << 2) | 0;
    if ((i13 | 0) == (HEAP32[i16 >> 2] | 0)) {
     HEAP32[i16 >> 2] = i14;
     if ((i14 | 0) == 0) {
      HEAP32[14476 >> 2] = HEAP32[14476 >> 2] & ~(1 << i18);
      i2 = i13;
      i11 = i12;
      break;
     }
    } else {
     if (i17 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
      _abort();
     }
     i16 = i17 + 16 | 0;
     if ((HEAP32[i16 >> 2] | 0) == (i13 | 0)) {
      HEAP32[i16 >> 2] = i14;
     } else {
      HEAP32[i17 + 20 >> 2] = i14;
     }
     if ((i14 | 0) == 0) {
      i2 = i13;
      i11 = i12;
      break;
     }
    }
    if (i14 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
     _abort();
    }
    HEAP32[i14 + 24 >> 2] = i17;
    i16 = HEAP32[i7 + (i15 + 16) >> 2] | 0;
    do {
     if ((i16 | 0) != 0) {
      if (i16 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
       _abort();
      } else {
       HEAP32[i14 + 16 >> 2] = i16;
       HEAP32[i16 + 24 >> 2] = i14;
       break;
      }
     }
    } while (0);
    i15 = HEAP32[i7 + (i15 + 20) >> 2] | 0;
    if ((i15 | 0) != 0) {
     if (i15 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
      _abort();
     } else {
      HEAP32[i14 + 20 >> 2] = i15;
      HEAP32[i15 + 24 >> 2] = i14;
      i2 = i13;
      i11 = i12;
      break;
     }
    } else {
     i2 = i13;
     i11 = i12;
    }
   } else {
    i2 = i13;
    i11 = i12;
   }
  } else {
   i2 = i15;
   i11 = i8;
  }
 } while (0);
 if (!(i2 >>> 0 < i6 >>> 0)) {
  _abort();
 }
 i12 = i7 + (i8 + -4) | 0;
 i13 = HEAP32[i12 >> 2] | 0;
 if ((i13 & 1 | 0) == 0) {
  _abort();
 }
 if ((i13 & 2 | 0) == 0) {
  if ((i6 | 0) == (HEAP32[14496 >> 2] | 0)) {
   i21 = (HEAP32[14484 >> 2] | 0) + i11 | 0;
   HEAP32[14484 >> 2] = i21;
   HEAP32[14496 >> 2] = i2;
   HEAP32[i2 + 4 >> 2] = i21 | 1;
   if ((i2 | 0) != (HEAP32[14492 >> 2] | 0)) {
    STACKTOP = i1;
    return;
   }
   HEAP32[14492 >> 2] = 0;
   HEAP32[14480 >> 2] = 0;
   STACKTOP = i1;
   return;
  }
  if ((i6 | 0) == (HEAP32[14492 >> 2] | 0)) {
   i21 = (HEAP32[14480 >> 2] | 0) + i11 | 0;
   HEAP32[14480 >> 2] = i21;
   HEAP32[14492 >> 2] = i2;
   HEAP32[i2 + 4 >> 2] = i21 | 1;
   HEAP32[i2 + i21 >> 2] = i21;
   STACKTOP = i1;
   return;
  }
  i11 = (i13 & -8) + i11 | 0;
  i12 = i13 >>> 3;
  do {
   if (!(i13 >>> 0 < 256)) {
    i10 = HEAP32[i7 + (i8 + 16) >> 2] | 0;
    i15 = HEAP32[i7 + (i8 | 4) >> 2] | 0;
    do {
     if ((i15 | 0) == (i6 | 0)) {
      i13 = i7 + (i8 + 12) | 0;
      i12 = HEAP32[i13 >> 2] | 0;
      if ((i12 | 0) == 0) {
       i13 = i7 + (i8 + 8) | 0;
       i12 = HEAP32[i13 >> 2] | 0;
       if ((i12 | 0) == 0) {
        i9 = 0;
        break;
       }
      }
      while (1) {
       i14 = i12 + 20 | 0;
       i15 = HEAP32[i14 >> 2] | 0;
       if ((i15 | 0) != 0) {
        i12 = i15;
        i13 = i14;
        continue;
       }
       i14 = i12 + 16 | 0;
       i15 = HEAP32[i14 >> 2] | 0;
       if ((i15 | 0) == 0) {
        break;
       } else {
        i12 = i15;
        i13 = i14;
       }
      }
      if (i13 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
       _abort();
      } else {
       HEAP32[i13 >> 2] = 0;
       i9 = i12;
       break;
      }
     } else {
      i13 = HEAP32[i7 + i8 >> 2] | 0;
      if (i13 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
       _abort();
      }
      i14 = i13 + 12 | 0;
      if ((HEAP32[i14 >> 2] | 0) != (i6 | 0)) {
       _abort();
      }
      i12 = i15 + 8 | 0;
      if ((HEAP32[i12 >> 2] | 0) == (i6 | 0)) {
       HEAP32[i14 >> 2] = i15;
       HEAP32[i12 >> 2] = i13;
       i9 = i15;
       break;
      } else {
       _abort();
      }
     }
    } while (0);
    if ((i10 | 0) != 0) {
     i12 = HEAP32[i7 + (i8 + 20) >> 2] | 0;
     i13 = 14776 + (i12 << 2) | 0;
     if ((i6 | 0) == (HEAP32[i13 >> 2] | 0)) {
      HEAP32[i13 >> 2] = i9;
      if ((i9 | 0) == 0) {
       HEAP32[14476 >> 2] = HEAP32[14476 >> 2] & ~(1 << i12);
       break;
      }
     } else {
      if (i10 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
       _abort();
      }
      i12 = i10 + 16 | 0;
      if ((HEAP32[i12 >> 2] | 0) == (i6 | 0)) {
       HEAP32[i12 >> 2] = i9;
      } else {
       HEAP32[i10 + 20 >> 2] = i9;
      }
      if ((i9 | 0) == 0) {
       break;
      }
     }
     if (i9 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
      _abort();
     }
     HEAP32[i9 + 24 >> 2] = i10;
     i6 = HEAP32[i7 + (i8 + 8) >> 2] | 0;
     do {
      if ((i6 | 0) != 0) {
       if (i6 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
        _abort();
       } else {
        HEAP32[i9 + 16 >> 2] = i6;
        HEAP32[i6 + 24 >> 2] = i9;
        break;
       }
      }
     } while (0);
     i6 = HEAP32[i7 + (i8 + 12) >> 2] | 0;
     if ((i6 | 0) != 0) {
      if (i6 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
       _abort();
      } else {
       HEAP32[i9 + 20 >> 2] = i6;
       HEAP32[i6 + 24 >> 2] = i9;
       break;
      }
     }
    }
   } else {
    i9 = HEAP32[i7 + i8 >> 2] | 0;
    i7 = HEAP32[i7 + (i8 | 4) >> 2] | 0;
    i8 = 14512 + (i12 << 1 << 2) | 0;
    if ((i9 | 0) != (i8 | 0)) {
     if (i9 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
      _abort();
     }
     if ((HEAP32[i9 + 12 >> 2] | 0) != (i6 | 0)) {
      _abort();
     }
    }
    if ((i7 | 0) == (i9 | 0)) {
     HEAP32[3618] = HEAP32[3618] & ~(1 << i12);
     break;
    }
    if ((i7 | 0) != (i8 | 0)) {
     if (i7 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
      _abort();
     }
     i8 = i7 + 8 | 0;
     if ((HEAP32[i8 >> 2] | 0) == (i6 | 0)) {
      i10 = i8;
     } else {
      _abort();
     }
    } else {
     i10 = i7 + 8 | 0;
    }
    HEAP32[i9 + 12 >> 2] = i7;
    HEAP32[i10 >> 2] = i9;
   }
  } while (0);
  HEAP32[i2 + 4 >> 2] = i11 | 1;
  HEAP32[i2 + i11 >> 2] = i11;
  if ((i2 | 0) == (HEAP32[14492 >> 2] | 0)) {
   HEAP32[14480 >> 2] = i11;
   STACKTOP = i1;
   return;
  }
 } else {
  HEAP32[i12 >> 2] = i13 & -2;
  HEAP32[i2 + 4 >> 2] = i11 | 1;
  HEAP32[i2 + i11 >> 2] = i11;
 }
 i6 = i11 >>> 3;
 if (i11 >>> 0 < 256) {
  i7 = i6 << 1;
  i3 = 14512 + (i7 << 2) | 0;
  i8 = HEAP32[3618] | 0;
  i6 = 1 << i6;
  if ((i8 & i6 | 0) != 0) {
   i6 = 14512 + (i7 + 2 << 2) | 0;
   i7 = HEAP32[i6 >> 2] | 0;
   if (i7 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
    _abort();
   } else {
    i4 = i6;
    i5 = i7;
   }
  } else {
   HEAP32[3618] = i8 | i6;
   i4 = 14512 + (i7 + 2 << 2) | 0;
   i5 = i3;
  }
  HEAP32[i4 >> 2] = i2;
  HEAP32[i5 + 12 >> 2] = i2;
  HEAP32[i2 + 8 >> 2] = i5;
  HEAP32[i2 + 12 >> 2] = i3;
  STACKTOP = i1;
  return;
 }
 i4 = i11 >>> 8;
 if ((i4 | 0) != 0) {
  if (i11 >>> 0 > 16777215) {
   i4 = 31;
  } else {
   i20 = (i4 + 1048320 | 0) >>> 16 & 8;
   i21 = i4 << i20;
   i19 = (i21 + 520192 | 0) >>> 16 & 4;
   i21 = i21 << i19;
   i4 = (i21 + 245760 | 0) >>> 16 & 2;
   i4 = 14 - (i19 | i20 | i4) + (i21 << i4 >>> 15) | 0;
   i4 = i11 >>> (i4 + 7 | 0) & 1 | i4 << 1;
  }
 } else {
  i4 = 0;
 }
 i5 = 14776 + (i4 << 2) | 0;
 HEAP32[i2 + 28 >> 2] = i4;
 HEAP32[i2 + 20 >> 2] = 0;
 HEAP32[i2 + 16 >> 2] = 0;
 i7 = HEAP32[14476 >> 2] | 0;
 i6 = 1 << i4;
 L199 : do {
  if ((i7 & i6 | 0) != 0) {
   i5 = HEAP32[i5 >> 2] | 0;
   if ((i4 | 0) == 31) {
    i4 = 0;
   } else {
    i4 = 25 - (i4 >>> 1) | 0;
   }
   L204 : do {
    if ((HEAP32[i5 + 4 >> 2] & -8 | 0) != (i11 | 0)) {
     i4 = i11 << i4;
     i7 = i5;
     while (1) {
      i6 = i7 + (i4 >>> 31 << 2) + 16 | 0;
      i5 = HEAP32[i6 >> 2] | 0;
      if ((i5 | 0) == 0) {
       break;
      }
      if ((HEAP32[i5 + 4 >> 2] & -8 | 0) == (i11 | 0)) {
       i3 = i5;
       break L204;
      } else {
       i4 = i4 << 1;
       i7 = i5;
      }
     }
     if (i6 >>> 0 < (HEAP32[14488 >> 2] | 0) >>> 0) {
      _abort();
     } else {
      HEAP32[i6 >> 2] = i2;
      HEAP32[i2 + 24 >> 2] = i7;
      HEAP32[i2 + 12 >> 2] = i2;
      HEAP32[i2 + 8 >> 2] = i2;
      break L199;
     }
    } else {
     i3 = i5;
    }
   } while (0);
   i5 = i3 + 8 | 0;
   i4 = HEAP32[i5 >> 2] | 0;
   i6 = HEAP32[14488 >> 2] | 0;
   if (i3 >>> 0 < i6 >>> 0) {
    _abort();
   }
   if (i4 >>> 0 < i6 >>> 0) {
    _abort();
   } else {
    HEAP32[i4 + 12 >> 2] = i2;
    HEAP32[i5 >> 2] = i2;
    HEAP32[i2 + 8 >> 2] = i4;
    HEAP32[i2 + 12 >> 2] = i3;
    HEAP32[i2 + 24 >> 2] = 0;
    break;
   }
  } else {
   HEAP32[14476 >> 2] = i7 | i6;
   HEAP32[i5 >> 2] = i2;
   HEAP32[i2 + 24 >> 2] = i5;
   HEAP32[i2 + 12 >> 2] = i2;
   HEAP32[i2 + 8 >> 2] = i2;
  }
 } while (0);
 i21 = (HEAP32[14504 >> 2] | 0) + -1 | 0;
 HEAP32[14504 >> 2] = i21;
 if ((i21 | 0) == 0) {
  i2 = 14928 | 0;
 } else {
  STACKTOP = i1;
  return;
 }
 while (1) {
  i2 = HEAP32[i2 >> 2] | 0;
  if ((i2 | 0) == 0) {
   break;
  } else {
   i2 = i2 + 8 | 0;
  }
 }
 HEAP32[14504 >> 2] = -1;
 STACKTOP = i1;
 return;
}
function _build_tree(i4, i9) {
 i4 = i4 | 0;
 i9 = i9 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0;
 i2 = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 i1 = i2;
 i3 = HEAP32[i9 >> 2] | 0;
 i7 = i9 + 8 | 0;
 i11 = HEAP32[i7 >> 2] | 0;
 i12 = HEAP32[i11 >> 2] | 0;
 i11 = HEAP32[i11 + 12 >> 2] | 0;
 i8 = i4 + 5200 | 0;
 HEAP32[i8 >> 2] = 0;
 i6 = i4 + 5204 | 0;
 HEAP32[i6 >> 2] = 573;
 if ((i11 | 0) > 0) {
  i5 = -1;
  i13 = 0;
  do {
   if ((HEAP16[i3 + (i13 << 2) >> 1] | 0) == 0) {
    HEAP16[i3 + (i13 << 2) + 2 >> 1] = 0;
   } else {
    i5 = (HEAP32[i8 >> 2] | 0) + 1 | 0;
    HEAP32[i8 >> 2] = i5;
    HEAP32[i4 + (i5 << 2) + 2908 >> 2] = i13;
    HEAP8[i4 + i13 + 5208 | 0] = 0;
    i5 = i13;
   }
   i13 = i13 + 1 | 0;
  } while ((i13 | 0) != (i11 | 0));
  i14 = HEAP32[i8 >> 2] | 0;
  if ((i14 | 0) < 2) {
   i10 = 3;
  }
 } else {
  i14 = 0;
  i5 = -1;
  i10 = 3;
 }
 if ((i10 | 0) == 3) {
  i10 = i4 + 5800 | 0;
  i13 = i4 + 5804 | 0;
  if ((i12 | 0) == 0) {
   do {
    i12 = (i5 | 0) < 2;
    i13 = i5 + 1 | 0;
    i5 = i12 ? i13 : i5;
    i23 = i12 ? i13 : 0;
    i14 = i14 + 1 | 0;
    HEAP32[i8 >> 2] = i14;
    HEAP32[i4 + (i14 << 2) + 2908 >> 2] = i23;
    HEAP16[i3 + (i23 << 2) >> 1] = 1;
    HEAP8[i4 + i23 + 5208 | 0] = 0;
    HEAP32[i10 >> 2] = (HEAP32[i10 >> 2] | 0) + -1;
    i14 = HEAP32[i8 >> 2] | 0;
   } while ((i14 | 0) < 2);
  } else {
   do {
    i15 = (i5 | 0) < 2;
    i16 = i5 + 1 | 0;
    i5 = i15 ? i16 : i5;
    i23 = i15 ? i16 : 0;
    i14 = i14 + 1 | 0;
    HEAP32[i8 >> 2] = i14;
    HEAP32[i4 + (i14 << 2) + 2908 >> 2] = i23;
    HEAP16[i3 + (i23 << 2) >> 1] = 1;
    HEAP8[i4 + i23 + 5208 | 0] = 0;
    HEAP32[i10 >> 2] = (HEAP32[i10 >> 2] | 0) + -1;
    HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) - (HEAPU16[i12 + (i23 << 2) + 2 >> 1] | 0);
    i14 = HEAP32[i8 >> 2] | 0;
   } while ((i14 | 0) < 2);
  }
 }
 i10 = i9 + 4 | 0;
 HEAP32[i10 >> 2] = i5;
 i12 = HEAP32[i8 >> 2] | 0;
 if ((i12 | 0) > 1) {
  i18 = i12;
  i13 = (i12 | 0) / 2 | 0;
  do {
   i12 = HEAP32[i4 + (i13 << 2) + 2908 >> 2] | 0;
   i14 = i4 + i12 + 5208 | 0;
   i17 = i13 << 1;
   L21 : do {
    if ((i17 | 0) > (i18 | 0)) {
     i15 = i13;
    } else {
     i16 = i3 + (i12 << 2) | 0;
     i15 = i13;
     while (1) {
      do {
       if ((i17 | 0) < (i18 | 0)) {
        i18 = i17 | 1;
        i19 = HEAP32[i4 + (i18 << 2) + 2908 >> 2] | 0;
        i22 = HEAP16[i3 + (i19 << 2) >> 1] | 0;
        i20 = HEAP32[i4 + (i17 << 2) + 2908 >> 2] | 0;
        i21 = HEAP16[i3 + (i20 << 2) >> 1] | 0;
        if (!((i22 & 65535) < (i21 & 65535))) {
         if (!(i22 << 16 >> 16 == i21 << 16 >> 16)) {
          break;
         }
         if ((HEAPU8[i4 + i19 + 5208 | 0] | 0) > (HEAPU8[i4 + i20 + 5208 | 0] | 0)) {
          break;
         }
        }
        i17 = i18;
       }
      } while (0);
      i19 = HEAP16[i16 >> 1] | 0;
      i18 = HEAP32[i4 + (i17 << 2) + 2908 >> 2] | 0;
      i20 = HEAP16[i3 + (i18 << 2) >> 1] | 0;
      if ((i19 & 65535) < (i20 & 65535)) {
       break L21;
      }
      if (i19 << 16 >> 16 == i20 << 16 >> 16 ? (HEAPU8[i14] | 0) <= (HEAPU8[i4 + i18 + 5208 | 0] | 0) : 0) {
       break L21;
      }
      HEAP32[i4 + (i15 << 2) + 2908 >> 2] = i18;
      i19 = i17 << 1;
      i18 = HEAP32[i8 >> 2] | 0;
      if ((i19 | 0) > (i18 | 0)) {
       i15 = i17;
       break;
      } else {
       i15 = i17;
       i17 = i19;
      }
     }
    }
   } while (0);
   HEAP32[i4 + (i15 << 2) + 2908 >> 2] = i12;
   i13 = i13 + -1 | 0;
   i18 = HEAP32[i8 >> 2] | 0;
  } while ((i13 | 0) > 0);
 } else {
  i18 = i12;
 }
 i12 = i4 + 2912 | 0;
 while (1) {
  i13 = HEAP32[i12 >> 2] | 0;
  i20 = i18 + -1 | 0;
  HEAP32[i8 >> 2] = i20;
  i14 = HEAP32[i4 + (i18 << 2) + 2908 >> 2] | 0;
  HEAP32[i12 >> 2] = i14;
  i15 = i4 + i14 + 5208 | 0;
  L40 : do {
   if ((i18 | 0) < 3) {
    i17 = 1;
   } else {
    i16 = i3 + (i14 << 2) | 0;
    i17 = 1;
    i18 = 2;
    while (1) {
     do {
      if ((i18 | 0) < (i20 | 0)) {
       i22 = i18 | 1;
       i21 = HEAP32[i4 + (i22 << 2) + 2908 >> 2] | 0;
       i23 = HEAP16[i3 + (i21 << 2) >> 1] | 0;
       i20 = HEAP32[i4 + (i18 << 2) + 2908 >> 2] | 0;
       i19 = HEAP16[i3 + (i20 << 2) >> 1] | 0;
       if (!((i23 & 65535) < (i19 & 65535))) {
        if (!(i23 << 16 >> 16 == i19 << 16 >> 16)) {
         break;
        }
        if ((HEAPU8[i4 + i21 + 5208 | 0] | 0) > (HEAPU8[i4 + i20 + 5208 | 0] | 0)) {
         break;
        }
       }
       i18 = i22;
      }
     } while (0);
     i21 = HEAP16[i16 >> 1] | 0;
     i20 = HEAP32[i4 + (i18 << 2) + 2908 >> 2] | 0;
     i19 = HEAP16[i3 + (i20 << 2) >> 1] | 0;
     if ((i21 & 65535) < (i19 & 65535)) {
      break L40;
     }
     if (i21 << 16 >> 16 == i19 << 16 >> 16 ? (HEAPU8[i15] | 0) <= (HEAPU8[i4 + i20 + 5208 | 0] | 0) : 0) {
      break L40;
     }
     HEAP32[i4 + (i17 << 2) + 2908 >> 2] = i20;
     i19 = i18 << 1;
     i20 = HEAP32[i8 >> 2] | 0;
     if ((i19 | 0) > (i20 | 0)) {
      i17 = i18;
      break;
     } else {
      i17 = i18;
      i18 = i19;
     }
    }
   }
  } while (0);
  HEAP32[i4 + (i17 << 2) + 2908 >> 2] = i14;
  i17 = HEAP32[i12 >> 2] | 0;
  i14 = (HEAP32[i6 >> 2] | 0) + -1 | 0;
  HEAP32[i6 >> 2] = i14;
  HEAP32[i4 + (i14 << 2) + 2908 >> 2] = i13;
  i14 = (HEAP32[i6 >> 2] | 0) + -1 | 0;
  HEAP32[i6 >> 2] = i14;
  HEAP32[i4 + (i14 << 2) + 2908 >> 2] = i17;
  i14 = i3 + (i11 << 2) | 0;
  HEAP16[i14 >> 1] = (HEAPU16[i3 + (i17 << 2) >> 1] | 0) + (HEAPU16[i3 + (i13 << 2) >> 1] | 0);
  i18 = HEAP8[i4 + i13 + 5208 | 0] | 0;
  i16 = HEAP8[i4 + i17 + 5208 | 0] | 0;
  i15 = i4 + i11 + 5208 | 0;
  HEAP8[i15] = (((i18 & 255) < (i16 & 255) ? i16 : i18) & 255) + 1;
  i19 = i11 & 65535;
  HEAP16[i3 + (i17 << 2) + 2 >> 1] = i19;
  HEAP16[i3 + (i13 << 2) + 2 >> 1] = i19;
  i13 = i11 + 1 | 0;
  HEAP32[i12 >> 2] = i11;
  i19 = HEAP32[i8 >> 2] | 0;
  L56 : do {
   if ((i19 | 0) < 2) {
    i16 = 1;
   } else {
    i16 = 1;
    i17 = 2;
    while (1) {
     do {
      if ((i17 | 0) < (i19 | 0)) {
       i21 = i17 | 1;
       i22 = HEAP32[i4 + (i21 << 2) + 2908 >> 2] | 0;
       i19 = HEAP16[i3 + (i22 << 2) >> 1] | 0;
       i18 = HEAP32[i4 + (i17 << 2) + 2908 >> 2] | 0;
       i20 = HEAP16[i3 + (i18 << 2) >> 1] | 0;
       if (!((i19 & 65535) < (i20 & 65535))) {
        if (!(i19 << 16 >> 16 == i20 << 16 >> 16)) {
         break;
        }
        if ((HEAPU8[i4 + i22 + 5208 | 0] | 0) > (HEAPU8[i4 + i18 + 5208 | 0] | 0)) {
         break;
        }
       }
       i17 = i21;
      }
     } while (0);
     i19 = HEAP16[i14 >> 1] | 0;
     i20 = HEAP32[i4 + (i17 << 2) + 2908 >> 2] | 0;
     i18 = HEAP16[i3 + (i20 << 2) >> 1] | 0;
     if ((i19 & 65535) < (i18 & 65535)) {
      break L56;
     }
     if (i19 << 16 >> 16 == i18 << 16 >> 16 ? (HEAPU8[i15] | 0) <= (HEAPU8[i4 + i20 + 5208 | 0] | 0) : 0) {
      break L56;
     }
     HEAP32[i4 + (i16 << 2) + 2908 >> 2] = i20;
     i18 = i17 << 1;
     i19 = HEAP32[i8 >> 2] | 0;
     if ((i18 | 0) > (i19 | 0)) {
      i16 = i17;
      break;
     } else {
      i16 = i17;
      i17 = i18;
     }
    }
   }
  } while (0);
  HEAP32[i4 + (i16 << 2) + 2908 >> 2] = i11;
  i18 = HEAP32[i8 >> 2] | 0;
  if ((i18 | 0) > 1) {
   i11 = i13;
  } else {
   break;
  }
 }
 i12 = HEAP32[i12 >> 2] | 0;
 i8 = (HEAP32[i6 >> 2] | 0) + -1 | 0;
 HEAP32[i6 >> 2] = i8;
 HEAP32[i4 + (i8 << 2) + 2908 >> 2] = i12;
 i8 = HEAP32[i9 >> 2] | 0;
 i9 = HEAP32[i10 >> 2] | 0;
 i7 = HEAP32[i7 >> 2] | 0;
 i12 = HEAP32[i7 >> 2] | 0;
 i11 = HEAP32[i7 + 4 >> 2] | 0;
 i10 = HEAP32[i7 + 8 >> 2] | 0;
 i7 = HEAP32[i7 + 16 >> 2] | 0;
 i13 = i4 + 2876 | 0;
 i14 = i13 + 32 | 0;
 do {
  HEAP16[i13 >> 1] = 0;
  i13 = i13 + 2 | 0;
 } while ((i13 | 0) < (i14 | 0));
 i14 = HEAP32[i6 >> 2] | 0;
 HEAP16[i8 + (HEAP32[i4 + (i14 << 2) + 2908 >> 2] << 2) + 2 >> 1] = 0;
 i14 = i14 + 1 | 0;
 L72 : do {
  if ((i14 | 0) < 573) {
   i6 = i4 + 5800 | 0;
   i13 = i4 + 5804 | 0;
   if ((i12 | 0) == 0) {
    i18 = 0;
    do {
     i12 = HEAP32[i4 + (i14 << 2) + 2908 >> 2] | 0;
     i13 = i8 + (i12 << 2) + 2 | 0;
     i15 = HEAPU16[i8 + (HEAPU16[i13 >> 1] << 2) + 2 >> 1] | 0;
     i16 = (i15 | 0) < (i7 | 0);
     i15 = i16 ? i15 + 1 | 0 : i7;
     i18 = (i16 & 1 ^ 1) + i18 | 0;
     HEAP16[i13 >> 1] = i15;
     if ((i12 | 0) <= (i9 | 0)) {
      i23 = i4 + (i15 << 1) + 2876 | 0;
      HEAP16[i23 >> 1] = (HEAP16[i23 >> 1] | 0) + 1 << 16 >> 16;
      if ((i12 | 0) < (i10 | 0)) {
       i13 = 0;
      } else {
       i13 = HEAP32[i11 + (i12 - i10 << 2) >> 2] | 0;
      }
      i23 = Math_imul(HEAPU16[i8 + (i12 << 2) >> 1] | 0, i13 + i15 | 0) | 0;
      HEAP32[i6 >> 2] = i23 + (HEAP32[i6 >> 2] | 0);
     }
     i14 = i14 + 1 | 0;
    } while ((i14 | 0) != 573);
   } else {
    i18 = 0;
    do {
     i15 = HEAP32[i4 + (i14 << 2) + 2908 >> 2] | 0;
     i16 = i8 + (i15 << 2) + 2 | 0;
     i17 = HEAPU16[i8 + (HEAPU16[i16 >> 1] << 2) + 2 >> 1] | 0;
     i19 = (i17 | 0) < (i7 | 0);
     i17 = i19 ? i17 + 1 | 0 : i7;
     i18 = (i19 & 1 ^ 1) + i18 | 0;
     HEAP16[i16 >> 1] = i17;
     if ((i15 | 0) <= (i9 | 0)) {
      i23 = i4 + (i17 << 1) + 2876 | 0;
      HEAP16[i23 >> 1] = (HEAP16[i23 >> 1] | 0) + 1 << 16 >> 16;
      if ((i15 | 0) < (i10 | 0)) {
       i16 = 0;
      } else {
       i16 = HEAP32[i11 + (i15 - i10 << 2) >> 2] | 0;
      }
      i23 = HEAPU16[i8 + (i15 << 2) >> 1] | 0;
      i22 = Math_imul(i23, i16 + i17 | 0) | 0;
      HEAP32[i6 >> 2] = i22 + (HEAP32[i6 >> 2] | 0);
      i23 = Math_imul((HEAPU16[i12 + (i15 << 2) + 2 >> 1] | 0) + i16 | 0, i23) | 0;
      HEAP32[i13 >> 2] = i23 + (HEAP32[i13 >> 2] | 0);
     }
     i14 = i14 + 1 | 0;
    } while ((i14 | 0) != 573);
   }
   if ((i18 | 0) != 0) {
    i10 = i4 + (i7 << 1) + 2876 | 0;
    do {
     i12 = i7;
     while (1) {
      i11 = i12 + -1 | 0;
      i13 = i4 + (i11 << 1) + 2876 | 0;
      i14 = HEAP16[i13 >> 1] | 0;
      if (i14 << 16 >> 16 == 0) {
       i12 = i11;
      } else {
       break;
      }
     }
     HEAP16[i13 >> 1] = i14 + -1 << 16 >> 16;
     i11 = i4 + (i12 << 1) + 2876 | 0;
     HEAP16[i11 >> 1] = (HEAPU16[i11 >> 1] | 0) + 2;
     i11 = (HEAP16[i10 >> 1] | 0) + -1 << 16 >> 16;
     HEAP16[i10 >> 1] = i11;
     i18 = i18 + -2 | 0;
    } while ((i18 | 0) > 0);
    if ((i7 | 0) != 0) {
     i12 = 573;
     while (1) {
      i10 = i7 & 65535;
      if (!(i11 << 16 >> 16 == 0)) {
       i11 = i11 & 65535;
       do {
        do {
         i12 = i12 + -1 | 0;
         i15 = HEAP32[i4 + (i12 << 2) + 2908 >> 2] | 0;
        } while ((i15 | 0) > (i9 | 0));
        i13 = i8 + (i15 << 2) + 2 | 0;
        i14 = HEAPU16[i13 >> 1] | 0;
        if ((i14 | 0) != (i7 | 0)) {
         i23 = Math_imul(HEAPU16[i8 + (i15 << 2) >> 1] | 0, i7 - i14 | 0) | 0;
         HEAP32[i6 >> 2] = i23 + (HEAP32[i6 >> 2] | 0);
         HEAP16[i13 >> 1] = i10;
        }
        i11 = i11 + -1 | 0;
       } while ((i11 | 0) != 0);
      }
      i7 = i7 + -1 | 0;
      if ((i7 | 0) == 0) {
       break L72;
      }
      i11 = HEAP16[i4 + (i7 << 1) + 2876 >> 1] | 0;
     }
    }
   }
  }
 } while (0);
 i7 = 1;
 i6 = 0;
 do {
  i6 = (HEAPU16[i4 + (i7 + -1 << 1) + 2876 >> 1] | 0) + (i6 & 65534) << 1;
  HEAP16[i1 + (i7 << 1) >> 1] = i6;
  i7 = i7 + 1 | 0;
 } while ((i7 | 0) != 16);
 if ((i5 | 0) < 0) {
  STACKTOP = i2;
  return;
 } else {
  i4 = 0;
 }
 while (1) {
  i23 = HEAP16[i3 + (i4 << 2) + 2 >> 1] | 0;
  i7 = i23 & 65535;
  if (!(i23 << 16 >> 16 == 0)) {
   i8 = i1 + (i7 << 1) | 0;
   i6 = HEAP16[i8 >> 1] | 0;
   HEAP16[i8 >> 1] = i6 + 1 << 16 >> 16;
   i6 = i6 & 65535;
   i8 = 0;
   while (1) {
    i8 = i8 | i6 & 1;
    i7 = i7 + -1 | 0;
    if ((i7 | 0) <= 0) {
     break;
    } else {
     i6 = i6 >>> 1;
     i8 = i8 << 1;
    }
   }
   HEAP16[i3 + (i4 << 2) >> 1] = i8;
  }
  if ((i4 | 0) == (i5 | 0)) {
   break;
  } else {
   i4 = i4 + 1 | 0;
  }
 }
 STACKTOP = i2;
 return;
}
function _deflate_slow(i2, i6) {
 i2 = i2 | 0;
 i6 = i6 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i5 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0;
 i1 = STACKTOP;
 i15 = i2 + 116 | 0;
 i16 = (i6 | 0) == 0;
 i17 = i2 + 72 | 0;
 i18 = i2 + 88 | 0;
 i5 = i2 + 108 | 0;
 i7 = i2 + 56 | 0;
 i19 = i2 + 84 | 0;
 i20 = i2 + 68 | 0;
 i22 = i2 + 52 | 0;
 i21 = i2 + 64 | 0;
 i9 = i2 + 96 | 0;
 i10 = i2 + 120 | 0;
 i11 = i2 + 112 | 0;
 i12 = i2 + 100 | 0;
 i26 = i2 + 5792 | 0;
 i27 = i2 + 5796 | 0;
 i29 = i2 + 5784 | 0;
 i23 = i2 + 5788 | 0;
 i8 = i2 + 104 | 0;
 i4 = i2 + 92 | 0;
 i24 = i2 + 128 | 0;
 i14 = i2 + 44 | 0;
 i13 = i2 + 136 | 0;
 L1 : while (1) {
  i30 = HEAP32[i15 >> 2] | 0;
  while (1) {
   if (i30 >>> 0 < 262) {
    _fill_window(i2);
    i30 = HEAP32[i15 >> 2] | 0;
    if (i30 >>> 0 < 262 & i16) {
     i2 = 0;
     i30 = 50;
     break L1;
    }
    if ((i30 | 0) == 0) {
     i30 = 40;
     break L1;
    }
    if (!(i30 >>> 0 > 2)) {
     HEAP32[i10 >> 2] = HEAP32[i9 >> 2];
     HEAP32[i12 >> 2] = HEAP32[i11 >> 2];
     HEAP32[i9 >> 2] = 2;
     i32 = 2;
     i30 = 16;
    } else {
     i30 = 8;
    }
   } else {
    i30 = 8;
   }
   do {
    if ((i30 | 0) == 8) {
     i30 = 0;
     i34 = HEAP32[i5 >> 2] | 0;
     i31 = ((HEAPU8[(HEAP32[i7 >> 2] | 0) + (i34 + 2) | 0] | 0) ^ HEAP32[i17 >> 2] << HEAP32[i18 >> 2]) & HEAP32[i19 >> 2];
     HEAP32[i17 >> 2] = i31;
     i31 = (HEAP32[i20 >> 2] | 0) + (i31 << 1) | 0;
     i35 = HEAP16[i31 >> 1] | 0;
     HEAP16[(HEAP32[i21 >> 2] | 0) + ((HEAP32[i22 >> 2] & i34) << 1) >> 1] = i35;
     i32 = i35 & 65535;
     HEAP16[i31 >> 1] = i34;
     i31 = HEAP32[i9 >> 2] | 0;
     HEAP32[i10 >> 2] = i31;
     HEAP32[i12 >> 2] = HEAP32[i11 >> 2];
     HEAP32[i9 >> 2] = 2;
     if (!(i35 << 16 >> 16 == 0)) {
      if (i31 >>> 0 < (HEAP32[i24 >> 2] | 0) >>> 0) {
       if (!(((HEAP32[i5 >> 2] | 0) - i32 | 0) >>> 0 > ((HEAP32[i14 >> 2] | 0) + -262 | 0) >>> 0)) {
        i32 = _longest_match(i2, i32) | 0;
        HEAP32[i9 >> 2] = i32;
        if (i32 >>> 0 < 6) {
         if ((HEAP32[i13 >> 2] | 0) != 1) {
          if ((i32 | 0) != 3) {
           i30 = 16;
           break;
          }
          if (!(((HEAP32[i5 >> 2] | 0) - (HEAP32[i11 >> 2] | 0) | 0) >>> 0 > 4096)) {
           i32 = 3;
           i30 = 16;
           break;
          }
         }
         HEAP32[i9 >> 2] = 2;
         i32 = 2;
         i30 = 16;
        } else {
         i30 = 16;
        }
       } else {
        i32 = 2;
        i30 = 16;
       }
      } else {
       i32 = 2;
      }
     } else {
      i32 = 2;
      i30 = 16;
     }
    }
   } while (0);
   if ((i30 | 0) == 16) {
    i31 = HEAP32[i10 >> 2] | 0;
   }
   if (!(i31 >>> 0 < 3 | i32 >>> 0 > i31 >>> 0)) {
    break;
   }
   if ((HEAP32[i8 >> 2] | 0) == 0) {
    HEAP32[i8 >> 2] = 1;
    HEAP32[i5 >> 2] = (HEAP32[i5 >> 2] | 0) + 1;
    i30 = (HEAP32[i15 >> 2] | 0) + -1 | 0;
    HEAP32[i15 >> 2] = i30;
    continue;
   }
   i35 = HEAP8[(HEAP32[i7 >> 2] | 0) + ((HEAP32[i5 >> 2] | 0) + -1) | 0] | 0;
   i34 = HEAP32[i26 >> 2] | 0;
   HEAP16[(HEAP32[i27 >> 2] | 0) + (i34 << 1) >> 1] = 0;
   HEAP32[i26 >> 2] = i34 + 1;
   HEAP8[(HEAP32[i29 >> 2] | 0) + i34 | 0] = i35;
   i35 = i2 + ((i35 & 255) << 2) + 148 | 0;
   HEAP16[i35 >> 1] = (HEAP16[i35 >> 1] | 0) + 1 << 16 >> 16;
   if ((HEAP32[i26 >> 2] | 0) == ((HEAP32[i23 >> 2] | 0) + -1 | 0)) {
    i30 = HEAP32[i4 >> 2] | 0;
    if ((i30 | 0) > -1) {
     i31 = (HEAP32[i7 >> 2] | 0) + i30 | 0;
    } else {
     i31 = 0;
    }
    __tr_flush_block(i2, i31, (HEAP32[i5 >> 2] | 0) - i30 | 0, 0);
    HEAP32[i4 >> 2] = HEAP32[i5 >> 2];
    i33 = HEAP32[i2 >> 2] | 0;
    i32 = i33 + 28 | 0;
    i30 = HEAP32[i32 >> 2] | 0;
    i35 = HEAP32[i30 + 20 >> 2] | 0;
    i31 = i33 + 16 | 0;
    i34 = HEAP32[i31 >> 2] | 0;
    i34 = i35 >>> 0 > i34 >>> 0 ? i34 : i35;
    if ((i34 | 0) != 0 ? (i28 = i33 + 12 | 0, _memcpy(HEAP32[i28 >> 2] | 0, HEAP32[i30 + 16 >> 2] | 0, i34 | 0) | 0, HEAP32[i28 >> 2] = (HEAP32[i28 >> 2] | 0) + i34, i28 = (HEAP32[i32 >> 2] | 0) + 16 | 0, HEAP32[i28 >> 2] = (HEAP32[i28 >> 2] | 0) + i34, i28 = i33 + 20 | 0, HEAP32[i28 >> 2] = (HEAP32[i28 >> 2] | 0) + i34, HEAP32[i31 >> 2] = (HEAP32[i31 >> 2] | 0) - i34, i28 = HEAP32[i32 >> 2] | 0, i33 = i28 + 20 | 0, i35 = HEAP32[i33 >> 2] | 0, HEAP32[i33 >> 2] = i35 - i34, (i35 | 0) == (i34 | 0)) : 0) {
     HEAP32[i28 + 16 >> 2] = HEAP32[i28 + 8 >> 2];
    }
   }
   HEAP32[i5 >> 2] = (HEAP32[i5 >> 2] | 0) + 1;
   i30 = (HEAP32[i15 >> 2] | 0) + -1 | 0;
   HEAP32[i15 >> 2] = i30;
   if ((HEAP32[(HEAP32[i2 >> 2] | 0) + 16 >> 2] | 0) == 0) {
    i2 = 0;
    i30 = 50;
    break L1;
   }
  }
  i34 = HEAP32[i5 >> 2] | 0;
  i30 = i34 + -3 + (HEAP32[i15 >> 2] | 0) | 0;
  i35 = i31 + 253 | 0;
  i31 = i34 + 65535 - (HEAP32[i12 >> 2] | 0) | 0;
  i34 = HEAP32[i26 >> 2] | 0;
  HEAP16[(HEAP32[i27 >> 2] | 0) + (i34 << 1) >> 1] = i31;
  HEAP32[i26 >> 2] = i34 + 1;
  HEAP8[(HEAP32[i29 >> 2] | 0) + i34 | 0] = i35;
  i35 = i2 + ((HEAPU8[808 + (i35 & 255) | 0] | 0 | 256) + 1 << 2) + 148 | 0;
  HEAP16[i35 >> 1] = (HEAP16[i35 >> 1] | 0) + 1 << 16 >> 16;
  i31 = i31 + 65535 & 65535;
  if (!(i31 >>> 0 < 256)) {
   i31 = (i31 >>> 7) + 256 | 0;
  }
  i32 = i2 + ((HEAPU8[296 + i31 | 0] | 0) << 2) + 2440 | 0;
  HEAP16[i32 >> 1] = (HEAP16[i32 >> 1] | 0) + 1 << 16 >> 16;
  i32 = HEAP32[i26 >> 2] | 0;
  i31 = (HEAP32[i23 >> 2] | 0) + -1 | 0;
  i34 = HEAP32[i10 >> 2] | 0;
  HEAP32[i15 >> 2] = 1 - i34 + (HEAP32[i15 >> 2] | 0);
  i34 = i34 + -2 | 0;
  HEAP32[i10 >> 2] = i34;
  i33 = HEAP32[i5 >> 2] | 0;
  while (1) {
   i35 = i33 + 1 | 0;
   HEAP32[i5 >> 2] = i35;
   if (!(i35 >>> 0 > i30 >>> 0)) {
    i36 = ((HEAPU8[(HEAP32[i7 >> 2] | 0) + (i33 + 3) | 0] | 0) ^ HEAP32[i17 >> 2] << HEAP32[i18 >> 2]) & HEAP32[i19 >> 2];
    HEAP32[i17 >> 2] = i36;
    i36 = (HEAP32[i20 >> 2] | 0) + (i36 << 1) | 0;
    HEAP16[(HEAP32[i21 >> 2] | 0) + ((HEAP32[i22 >> 2] & i35) << 1) >> 1] = HEAP16[i36 >> 1] | 0;
    HEAP16[i36 >> 1] = i35;
   }
   i34 = i34 + -1 | 0;
   HEAP32[i10 >> 2] = i34;
   if ((i34 | 0) == 0) {
    break;
   } else {
    i33 = i35;
   }
  }
  HEAP32[i8 >> 2] = 0;
  HEAP32[i9 >> 2] = 2;
  i30 = i33 + 2 | 0;
  HEAP32[i5 >> 2] = i30;
  if ((i32 | 0) != (i31 | 0)) {
   continue;
  }
  i32 = HEAP32[i4 >> 2] | 0;
  if ((i32 | 0) > -1) {
   i31 = (HEAP32[i7 >> 2] | 0) + i32 | 0;
  } else {
   i31 = 0;
  }
  __tr_flush_block(i2, i31, i30 - i32 | 0, 0);
  HEAP32[i4 >> 2] = HEAP32[i5 >> 2];
  i33 = HEAP32[i2 >> 2] | 0;
  i31 = i33 + 28 | 0;
  i32 = HEAP32[i31 >> 2] | 0;
  i35 = HEAP32[i32 + 20 >> 2] | 0;
  i30 = i33 + 16 | 0;
  i34 = HEAP32[i30 >> 2] | 0;
  i34 = i35 >>> 0 > i34 >>> 0 ? i34 : i35;
  if ((i34 | 0) != 0 ? (i25 = i33 + 12 | 0, _memcpy(HEAP32[i25 >> 2] | 0, HEAP32[i32 + 16 >> 2] | 0, i34 | 0) | 0, HEAP32[i25 >> 2] = (HEAP32[i25 >> 2] | 0) + i34, i25 = (HEAP32[i31 >> 2] | 0) + 16 | 0, HEAP32[i25 >> 2] = (HEAP32[i25 >> 2] | 0) + i34, i25 = i33 + 20 | 0, HEAP32[i25 >> 2] = (HEAP32[i25 >> 2] | 0) + i34, HEAP32[i30 >> 2] = (HEAP32[i30 >> 2] | 0) - i34, i25 = HEAP32[i31 >> 2] | 0, i35 = i25 + 20 | 0, i36 = HEAP32[i35 >> 2] | 0, HEAP32[i35 >> 2] = i36 - i34, (i36 | 0) == (i34 | 0)) : 0) {
   HEAP32[i25 + 16 >> 2] = HEAP32[i25 + 8 >> 2];
  }
  if ((HEAP32[(HEAP32[i2 >> 2] | 0) + 16 >> 2] | 0) == 0) {
   i2 = 0;
   i30 = 50;
   break;
  }
 }
 if ((i30 | 0) == 40) {
  if ((HEAP32[i8 >> 2] | 0) != 0) {
   i36 = HEAP8[(HEAP32[i7 >> 2] | 0) + ((HEAP32[i5 >> 2] | 0) + -1) | 0] | 0;
   i35 = HEAP32[i26 >> 2] | 0;
   HEAP16[(HEAP32[i27 >> 2] | 0) + (i35 << 1) >> 1] = 0;
   HEAP32[i26 >> 2] = i35 + 1;
   HEAP8[(HEAP32[i29 >> 2] | 0) + i35 | 0] = i36;
   i36 = i2 + ((i36 & 255) << 2) + 148 | 0;
   HEAP16[i36 >> 1] = (HEAP16[i36 >> 1] | 0) + 1 << 16 >> 16;
   HEAP32[i8 >> 2] = 0;
  }
  i8 = HEAP32[i4 >> 2] | 0;
  if ((i8 | 0) > -1) {
   i7 = (HEAP32[i7 >> 2] | 0) + i8 | 0;
  } else {
   i7 = 0;
  }
  i6 = (i6 | 0) == 4;
  __tr_flush_block(i2, i7, (HEAP32[i5 >> 2] | 0) - i8 | 0, i6 & 1);
  HEAP32[i4 >> 2] = HEAP32[i5 >> 2];
  i4 = HEAP32[i2 >> 2] | 0;
  i7 = i4 + 28 | 0;
  i5 = HEAP32[i7 >> 2] | 0;
  i10 = HEAP32[i5 + 20 >> 2] | 0;
  i8 = i4 + 16 | 0;
  i9 = HEAP32[i8 >> 2] | 0;
  i9 = i10 >>> 0 > i9 >>> 0 ? i9 : i10;
  if ((i9 | 0) != 0 ? (i3 = i4 + 12 | 0, _memcpy(HEAP32[i3 >> 2] | 0, HEAP32[i5 + 16 >> 2] | 0, i9 | 0) | 0, HEAP32[i3 >> 2] = (HEAP32[i3 >> 2] | 0) + i9, i3 = (HEAP32[i7 >> 2] | 0) + 16 | 0, HEAP32[i3 >> 2] = (HEAP32[i3 >> 2] | 0) + i9, i3 = i4 + 20 | 0, HEAP32[i3 >> 2] = (HEAP32[i3 >> 2] | 0) + i9, HEAP32[i8 >> 2] = (HEAP32[i8 >> 2] | 0) - i9, i3 = HEAP32[i7 >> 2] | 0, i35 = i3 + 20 | 0, i36 = HEAP32[i35 >> 2] | 0, HEAP32[i35 >> 2] = i36 - i9, (i36 | 0) == (i9 | 0)) : 0) {
   HEAP32[i3 + 16 >> 2] = HEAP32[i3 + 8 >> 2];
  }
  if ((HEAP32[(HEAP32[i2 >> 2] | 0) + 16 >> 2] | 0) == 0) {
   i36 = i6 ? 2 : 0;
   STACKTOP = i1;
   return i36 | 0;
  } else {
   i36 = i6 ? 3 : 1;
   STACKTOP = i1;
   return i36 | 0;
  }
 } else if ((i30 | 0) == 50) {
  STACKTOP = i1;
  return i2 | 0;
 }
 return 0;
}
function _inflate_fast(i7, i19) {
 i7 = i7 | 0;
 i19 = i19 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0, i37 = 0;
 i1 = STACKTOP;
 i11 = HEAP32[i7 + 28 >> 2] | 0;
 i29 = HEAP32[i7 >> 2] | 0;
 i5 = i7 + 4 | 0;
 i8 = i29 + ((HEAP32[i5 >> 2] | 0) + -6) | 0;
 i9 = i7 + 12 | 0;
 i28 = HEAP32[i9 >> 2] | 0;
 i4 = i7 + 16 | 0;
 i25 = HEAP32[i4 >> 2] | 0;
 i6 = i28 + (i25 + -258) | 0;
 i17 = HEAP32[i11 + 44 >> 2] | 0;
 i12 = HEAP32[i11 + 48 >> 2] | 0;
 i18 = HEAP32[i11 + 52 >> 2] | 0;
 i3 = i11 + 56 | 0;
 i2 = i11 + 60 | 0;
 i16 = HEAP32[i11 + 76 >> 2] | 0;
 i13 = HEAP32[i11 + 80 >> 2] | 0;
 i14 = (1 << HEAP32[i11 + 84 >> 2]) + -1 | 0;
 i15 = (1 << HEAP32[i11 + 88 >> 2]) + -1 | 0;
 i19 = i28 + (i25 + ~i19) | 0;
 i25 = i11 + 7104 | 0;
 i20 = i18 + -1 | 0;
 i27 = (i12 | 0) == 0;
 i24 = (HEAP32[i11 + 40 >> 2] | 0) + -1 | 0;
 i21 = i24 + i12 | 0;
 i22 = i12 + -1 | 0;
 i23 = i19 + -1 | 0;
 i26 = i19 - i12 | 0;
 i31 = HEAP32[i2 >> 2] | 0;
 i30 = HEAP32[i3 >> 2] | 0;
 i29 = i29 + -1 | 0;
 i28 = i28 + -1 | 0;
 L1 : do {
  if (i31 >>> 0 < 15) {
   i37 = i29 + 2 | 0;
   i33 = i31 + 16 | 0;
   i30 = ((HEAPU8[i29 + 1 | 0] | 0) << i31) + i30 + ((HEAPU8[i37] | 0) << i31 + 8) | 0;
   i29 = i37;
  } else {
   i33 = i31;
  }
  i31 = i30 & i14;
  i34 = HEAP8[i16 + (i31 << 2) | 0] | 0;
  i32 = HEAP16[i16 + (i31 << 2) + 2 >> 1] | 0;
  i31 = HEAPU8[i16 + (i31 << 2) + 1 | 0] | 0;
  i30 = i30 >>> i31;
  i31 = i33 - i31 | 0;
  do {
   if (!(i34 << 24 >> 24 == 0)) {
    i33 = i34 & 255;
    while (1) {
     if ((i33 & 16 | 0) != 0) {
      break;
     }
     if ((i33 & 64 | 0) != 0) {
      i10 = 55;
      break L1;
     }
     i37 = (i30 & (1 << i33) + -1) + (i32 & 65535) | 0;
     i33 = HEAP8[i16 + (i37 << 2) | 0] | 0;
     i32 = HEAP16[i16 + (i37 << 2) + 2 >> 1] | 0;
     i37 = HEAPU8[i16 + (i37 << 2) + 1 | 0] | 0;
     i30 = i30 >>> i37;
     i31 = i31 - i37 | 0;
     if (i33 << 24 >> 24 == 0) {
      i10 = 6;
      break;
     } else {
      i33 = i33 & 255;
     }
    }
    if ((i10 | 0) == 6) {
     i32 = i32 & 255;
     i10 = 7;
     break;
    }
    i32 = i32 & 65535;
    i33 = i33 & 15;
    if ((i33 | 0) != 0) {
     if (i31 >>> 0 < i33 >>> 0) {
      i29 = i29 + 1 | 0;
      i35 = i31 + 8 | 0;
      i34 = ((HEAPU8[i29] | 0) << i31) + i30 | 0;
     } else {
      i35 = i31;
      i34 = i30;
     }
     i31 = i35 - i33 | 0;
     i30 = i34 >>> i33;
     i32 = (i34 & (1 << i33) + -1) + i32 | 0;
    }
    if (i31 >>> 0 < 15) {
     i37 = i29 + 2 | 0;
     i34 = i31 + 16 | 0;
     i30 = ((HEAPU8[i29 + 1 | 0] | 0) << i31) + i30 + ((HEAPU8[i37] | 0) << i31 + 8) | 0;
     i29 = i37;
    } else {
     i34 = i31;
    }
    i37 = i30 & i15;
    i33 = HEAP16[i13 + (i37 << 2) + 2 >> 1] | 0;
    i31 = HEAPU8[i13 + (i37 << 2) + 1 | 0] | 0;
    i30 = i30 >>> i31;
    i31 = i34 - i31 | 0;
    i34 = HEAPU8[i13 + (i37 << 2) | 0] | 0;
    if ((i34 & 16 | 0) == 0) {
     do {
      if ((i34 & 64 | 0) != 0) {
       i10 = 52;
       break L1;
      }
      i34 = (i30 & (1 << i34) + -1) + (i33 & 65535) | 0;
      i33 = HEAP16[i13 + (i34 << 2) + 2 >> 1] | 0;
      i37 = HEAPU8[i13 + (i34 << 2) + 1 | 0] | 0;
      i30 = i30 >>> i37;
      i31 = i31 - i37 | 0;
      i34 = HEAPU8[i13 + (i34 << 2) | 0] | 0;
     } while ((i34 & 16 | 0) == 0);
    }
    i33 = i33 & 65535;
    i34 = i34 & 15;
    if (i31 >>> 0 < i34 >>> 0) {
     i35 = i29 + 1 | 0;
     i30 = ((HEAPU8[i35] | 0) << i31) + i30 | 0;
     i36 = i31 + 8 | 0;
     if (i36 >>> 0 < i34 >>> 0) {
      i29 = i29 + 2 | 0;
      i31 = i31 + 16 | 0;
      i30 = ((HEAPU8[i29] | 0) << i36) + i30 | 0;
     } else {
      i31 = i36;
      i29 = i35;
     }
    }
    i33 = (i30 & (1 << i34) + -1) + i33 | 0;
    i30 = i30 >>> i34;
    i31 = i31 - i34 | 0;
    i35 = i28;
    i34 = i35 - i19 | 0;
    if (!(i33 >>> 0 > i34 >>> 0)) {
     i34 = i28 + (0 - i33) | 0;
     while (1) {
      HEAP8[i28 + 1 | 0] = HEAP8[i34 + 1 | 0] | 0;
      HEAP8[i28 + 2 | 0] = HEAP8[i34 + 2 | 0] | 0;
      i35 = i34 + 3 | 0;
      i33 = i28 + 3 | 0;
      HEAP8[i33] = HEAP8[i35] | 0;
      i32 = i32 + -3 | 0;
      if (!(i32 >>> 0 > 2)) {
       break;
      } else {
       i34 = i35;
       i28 = i33;
      }
     }
     if ((i32 | 0) == 0) {
      i28 = i33;
      break;
     }
     i33 = i28 + 4 | 0;
     HEAP8[i33] = HEAP8[i34 + 4 | 0] | 0;
     if (!(i32 >>> 0 > 1)) {
      i28 = i33;
      break;
     }
     i28 = i28 + 5 | 0;
     HEAP8[i28] = HEAP8[i34 + 5 | 0] | 0;
     break;
    }
    i34 = i33 - i34 | 0;
    if (i34 >>> 0 > i17 >>> 0 ? (HEAP32[i25 >> 2] | 0) != 0 : 0) {
     i10 = 22;
     break L1;
    }
    do {
     if (i27) {
      i36 = i18 + (i24 - i34) | 0;
      if (i34 >>> 0 < i32 >>> 0) {
       i32 = i32 - i34 | 0;
       i35 = i33 - i35 | 0;
       i37 = i28;
       do {
        i36 = i36 + 1 | 0;
        i37 = i37 + 1 | 0;
        HEAP8[i37] = HEAP8[i36] | 0;
        i34 = i34 + -1 | 0;
       } while ((i34 | 0) != 0);
       i33 = i28 + (i23 + i35 + (1 - i33)) | 0;
       i28 = i28 + (i19 + i35) | 0;
      } else {
       i33 = i36;
      }
     } else {
      if (!(i12 >>> 0 < i34 >>> 0)) {
       i36 = i18 + (i22 - i34) | 0;
       if (!(i34 >>> 0 < i32 >>> 0)) {
        i33 = i36;
        break;
       }
       i32 = i32 - i34 | 0;
       i35 = i33 - i35 | 0;
       i37 = i28;
       do {
        i36 = i36 + 1 | 0;
        i37 = i37 + 1 | 0;
        HEAP8[i37] = HEAP8[i36] | 0;
        i34 = i34 + -1 | 0;
       } while ((i34 | 0) != 0);
       i33 = i28 + (i23 + i35 + (1 - i33)) | 0;
       i28 = i28 + (i19 + i35) | 0;
       break;
      }
      i37 = i18 + (i21 - i34) | 0;
      i36 = i34 - i12 | 0;
      if (i36 >>> 0 < i32 >>> 0) {
       i32 = i32 - i36 | 0;
       i34 = i33 - i35 | 0;
       i35 = i28;
       do {
        i37 = i37 + 1 | 0;
        i35 = i35 + 1 | 0;
        HEAP8[i35] = HEAP8[i37] | 0;
        i36 = i36 + -1 | 0;
       } while ((i36 | 0) != 0);
       i35 = i28 + (i26 + i34) | 0;
       if (i12 >>> 0 < i32 >>> 0) {
        i32 = i32 - i12 | 0;
        i37 = i20;
        i36 = i12;
        do {
         i37 = i37 + 1 | 0;
         i35 = i35 + 1 | 0;
         HEAP8[i35] = HEAP8[i37] | 0;
         i36 = i36 + -1 | 0;
        } while ((i36 | 0) != 0);
        i33 = i28 + (i23 + i34 + (1 - i33)) | 0;
        i28 = i28 + (i19 + i34) | 0;
       } else {
        i33 = i20;
        i28 = i35;
       }
      } else {
       i33 = i37;
      }
     }
    } while (0);
    if (i32 >>> 0 > 2) {
     do {
      HEAP8[i28 + 1 | 0] = HEAP8[i33 + 1 | 0] | 0;
      HEAP8[i28 + 2 | 0] = HEAP8[i33 + 2 | 0] | 0;
      i33 = i33 + 3 | 0;
      i28 = i28 + 3 | 0;
      HEAP8[i28] = HEAP8[i33] | 0;
      i32 = i32 + -3 | 0;
     } while (i32 >>> 0 > 2);
    }
    if ((i32 | 0) != 0) {
     i34 = i28 + 1 | 0;
     HEAP8[i34] = HEAP8[i33 + 1 | 0] | 0;
     if (i32 >>> 0 > 1) {
      i28 = i28 + 2 | 0;
      HEAP8[i28] = HEAP8[i33 + 2 | 0] | 0;
     } else {
      i28 = i34;
     }
    }
   } else {
    i32 = i32 & 255;
    i10 = 7;
   }
  } while (0);
  if ((i10 | 0) == 7) {
   i10 = 0;
   i28 = i28 + 1 | 0;
   HEAP8[i28] = i32;
  }
 } while (i29 >>> 0 < i8 >>> 0 & i28 >>> 0 < i6 >>> 0);
 do {
  if ((i10 | 0) == 22) {
   HEAP32[i7 + 24 >> 2] = 14384;
   HEAP32[i11 >> 2] = 29;
  } else if ((i10 | 0) == 52) {
   HEAP32[i7 + 24 >> 2] = 14416;
   HEAP32[i11 >> 2] = 29;
  } else if ((i10 | 0) == 55) {
   if ((i33 & 32 | 0) == 0) {
    HEAP32[i7 + 24 >> 2] = 14440;
    HEAP32[i11 >> 2] = 29;
    break;
   } else {
    HEAP32[i11 >> 2] = 11;
    break;
   }
  }
 } while (0);
 i37 = i31 >>> 3;
 i11 = i29 + (0 - i37) | 0;
 i10 = i31 - (i37 << 3) | 0;
 i12 = (1 << i10) + -1 & i30;
 HEAP32[i7 >> 2] = i29 + (1 - i37);
 HEAP32[i9 >> 2] = i28 + 1;
 if (i11 >>> 0 < i8 >>> 0) {
  i7 = i8 - i11 | 0;
 } else {
  i7 = i8 - i11 | 0;
 }
 HEAP32[i5 >> 2] = i7 + 5;
 if (i28 >>> 0 < i6 >>> 0) {
  i37 = i6 - i28 | 0;
  i37 = i37 + 257 | 0;
  HEAP32[i4 >> 2] = i37;
  HEAP32[i3 >> 2] = i12;
  HEAP32[i2 >> 2] = i10;
  STACKTOP = i1;
  return;
 } else {
  i37 = i6 - i28 | 0;
  i37 = i37 + 257 | 0;
  HEAP32[i4 >> 2] = i37;
  HEAP32[i3 >> 2] = i12;
  HEAP32[i2 >> 2] = i10;
  STACKTOP = i1;
  return;
 }
}
function _send_tree(i2, i13, i12) {
 i2 = i2 | 0;
 i13 = i13 | 0;
 i12 = i12 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0;
 i11 = STACKTOP;
 i15 = HEAP16[i13 + 2 >> 1] | 0;
 i16 = i15 << 16 >> 16 == 0;
 i7 = i2 + 2754 | 0;
 i4 = i2 + 5820 | 0;
 i8 = i2 + 2752 | 0;
 i3 = i2 + 5816 | 0;
 i14 = i2 + 20 | 0;
 i10 = i2 + 8 | 0;
 i9 = i2 + 2758 | 0;
 i1 = i2 + 2756 | 0;
 i5 = i2 + 2750 | 0;
 i6 = i2 + 2748 | 0;
 i21 = i16 ? 138 : 7;
 i23 = i16 ? 3 : 4;
 i18 = 0;
 i15 = i15 & 65535;
 i24 = -1;
 L1 : while (1) {
  i20 = 0;
  while (1) {
   if ((i18 | 0) > (i12 | 0)) {
    break L1;
   }
   i18 = i18 + 1 | 0;
   i19 = HEAP16[i13 + (i18 << 2) + 2 >> 1] | 0;
   i16 = i19 & 65535;
   i22 = i20 + 1 | 0;
   i17 = (i15 | 0) == (i16 | 0);
   if (!((i22 | 0) < (i21 | 0) & i17)) {
    break;
   } else {
    i20 = i22;
   }
  }
  do {
   if ((i22 | 0) >= (i23 | 0)) {
    if ((i15 | 0) != 0) {
     if ((i15 | 0) == (i24 | 0)) {
      i23 = HEAP16[i3 >> 1] | 0;
      i21 = HEAP32[i4 >> 2] | 0;
      i20 = i22;
     } else {
      i22 = HEAPU16[i2 + (i15 << 2) + 2686 >> 1] | 0;
      i21 = HEAP32[i4 >> 2] | 0;
      i24 = HEAPU16[i2 + (i15 << 2) + 2684 >> 1] | 0;
      i25 = HEAPU16[i3 >> 1] | 0 | i24 << i21;
      i23 = i25 & 65535;
      HEAP16[i3 >> 1] = i23;
      if ((i21 | 0) > (16 - i22 | 0)) {
       i23 = HEAP32[i14 >> 2] | 0;
       HEAP32[i14 >> 2] = i23 + 1;
       HEAP8[(HEAP32[i10 >> 2] | 0) + i23 | 0] = i25;
       i23 = (HEAPU16[i3 >> 1] | 0) >>> 8 & 255;
       i21 = HEAP32[i14 >> 2] | 0;
       HEAP32[i14 >> 2] = i21 + 1;
       HEAP8[(HEAP32[i10 >> 2] | 0) + i21 | 0] = i23;
       i21 = HEAP32[i4 >> 2] | 0;
       i23 = i24 >>> (16 - i21 | 0) & 65535;
       HEAP16[i3 >> 1] = i23;
       i21 = i22 + -16 + i21 | 0;
      } else {
       i21 = i21 + i22 | 0;
      }
      HEAP32[i4 >> 2] = i21;
     }
     i22 = HEAPU16[i5 >> 1] | 0;
     i24 = HEAPU16[i6 >> 1] | 0;
     i23 = i23 & 65535 | i24 << i21;
     HEAP16[i3 >> 1] = i23;
     if ((i21 | 0) > (16 - i22 | 0)) {
      i21 = HEAP32[i14 >> 2] | 0;
      HEAP32[i14 >> 2] = i21 + 1;
      HEAP8[(HEAP32[i10 >> 2] | 0) + i21 | 0] = i23;
      i23 = (HEAPU16[i3 >> 1] | 0) >>> 8 & 255;
      i21 = HEAP32[i14 >> 2] | 0;
      HEAP32[i14 >> 2] = i21 + 1;
      HEAP8[(HEAP32[i10 >> 2] | 0) + i21 | 0] = i23;
      i21 = HEAP32[i4 >> 2] | 0;
      i23 = i24 >>> (16 - i21 | 0);
      HEAP16[i3 >> 1] = i23;
      i21 = i22 + -16 + i21 | 0;
     } else {
      i21 = i21 + i22 | 0;
     }
     HEAP32[i4 >> 2] = i21;
     i20 = i20 + 65533 & 65535;
     i22 = i23 & 65535 | i20 << i21;
     HEAP16[i3 >> 1] = i22;
     if ((i21 | 0) > 14) {
      i26 = HEAP32[i14 >> 2] | 0;
      HEAP32[i14 >> 2] = i26 + 1;
      HEAP8[(HEAP32[i10 >> 2] | 0) + i26 | 0] = i22;
      i26 = (HEAPU16[i3 >> 1] | 0) >>> 8 & 255;
      i27 = HEAP32[i14 >> 2] | 0;
      HEAP32[i14 >> 2] = i27 + 1;
      HEAP8[(HEAP32[i10 >> 2] | 0) + i27 | 0] = i26;
      i27 = HEAP32[i4 >> 2] | 0;
      HEAP16[i3 >> 1] = i20 >>> (16 - i27 | 0);
      HEAP32[i4 >> 2] = i27 + -14;
      break;
     } else {
      HEAP32[i4 >> 2] = i21 + 2;
      break;
     }
    }
    if ((i22 | 0) < 11) {
     i24 = HEAPU16[i7 >> 1] | 0;
     i23 = HEAP32[i4 >> 2] | 0;
     i21 = HEAPU16[i8 >> 1] | 0;
     i22 = HEAPU16[i3 >> 1] | 0 | i21 << i23;
     HEAP16[i3 >> 1] = i22;
     if ((i23 | 0) > (16 - i24 | 0)) {
      i27 = HEAP32[i14 >> 2] | 0;
      HEAP32[i14 >> 2] = i27 + 1;
      HEAP8[(HEAP32[i10 >> 2] | 0) + i27 | 0] = i22;
      i22 = (HEAPU16[i3 >> 1] | 0) >>> 8 & 255;
      i27 = HEAP32[i14 >> 2] | 0;
      HEAP32[i14 >> 2] = i27 + 1;
      HEAP8[(HEAP32[i10 >> 2] | 0) + i27 | 0] = i22;
      i27 = HEAP32[i4 >> 2] | 0;
      i22 = i21 >>> (16 - i27 | 0);
      HEAP16[i3 >> 1] = i22;
      i21 = i24 + -16 + i27 | 0;
     } else {
      i21 = i23 + i24 | 0;
     }
     HEAP32[i4 >> 2] = i21;
     i20 = i20 + 65534 & 65535;
     i22 = i22 & 65535 | i20 << i21;
     HEAP16[i3 >> 1] = i22;
     if ((i21 | 0) > 13) {
      i26 = HEAP32[i14 >> 2] | 0;
      HEAP32[i14 >> 2] = i26 + 1;
      HEAP8[(HEAP32[i10 >> 2] | 0) + i26 | 0] = i22;
      i26 = (HEAPU16[i3 >> 1] | 0) >>> 8 & 255;
      i27 = HEAP32[i14 >> 2] | 0;
      HEAP32[i14 >> 2] = i27 + 1;
      HEAP8[(HEAP32[i10 >> 2] | 0) + i27 | 0] = i26;
      i27 = HEAP32[i4 >> 2] | 0;
      HEAP16[i3 >> 1] = i20 >>> (16 - i27 | 0);
      HEAP32[i4 >> 2] = i27 + -13;
      break;
     } else {
      HEAP32[i4 >> 2] = i21 + 3;
      break;
     }
    } else {
     i21 = HEAPU16[i9 >> 1] | 0;
     i24 = HEAP32[i4 >> 2] | 0;
     i23 = HEAPU16[i1 >> 1] | 0;
     i22 = HEAPU16[i3 >> 1] | 0 | i23 << i24;
     HEAP16[i3 >> 1] = i22;
     if ((i24 | 0) > (16 - i21 | 0)) {
      i27 = HEAP32[i14 >> 2] | 0;
      HEAP32[i14 >> 2] = i27 + 1;
      HEAP8[(HEAP32[i10 >> 2] | 0) + i27 | 0] = i22;
      i22 = (HEAPU16[i3 >> 1] | 0) >>> 8 & 255;
      i27 = HEAP32[i14 >> 2] | 0;
      HEAP32[i14 >> 2] = i27 + 1;
      HEAP8[(HEAP32[i10 >> 2] | 0) + i27 | 0] = i22;
      i27 = HEAP32[i4 >> 2] | 0;
      i22 = i23 >>> (16 - i27 | 0);
      HEAP16[i3 >> 1] = i22;
      i21 = i21 + -16 + i27 | 0;
     } else {
      i21 = i24 + i21 | 0;
     }
     HEAP32[i4 >> 2] = i21;
     i20 = i20 + 65526 & 65535;
     i22 = i22 & 65535 | i20 << i21;
     HEAP16[i3 >> 1] = i22;
     if ((i21 | 0) > 9) {
      i26 = HEAP32[i14 >> 2] | 0;
      HEAP32[i14 >> 2] = i26 + 1;
      HEAP8[(HEAP32[i10 >> 2] | 0) + i26 | 0] = i22;
      i26 = (HEAPU16[i3 >> 1] | 0) >>> 8 & 255;
      i27 = HEAP32[i14 >> 2] | 0;
      HEAP32[i14 >> 2] = i27 + 1;
      HEAP8[(HEAP32[i10 >> 2] | 0) + i27 | 0] = i26;
      i27 = HEAP32[i4 >> 2] | 0;
      HEAP16[i3 >> 1] = i20 >>> (16 - i27 | 0);
      HEAP32[i4 >> 2] = i27 + -9;
      break;
     } else {
      HEAP32[i4 >> 2] = i21 + 7;
      break;
     }
    }
   } else {
    i20 = i2 + (i15 << 2) + 2686 | 0;
    i21 = i2 + (i15 << 2) + 2684 | 0;
    i23 = HEAP32[i4 >> 2] | 0;
    i26 = HEAP16[i3 >> 1] | 0;
    do {
     i24 = HEAPU16[i20 >> 1] | 0;
     i25 = HEAPU16[i21 >> 1] | 0;
     i27 = i26 & 65535 | i25 << i23;
     i26 = i27 & 65535;
     HEAP16[i3 >> 1] = i26;
     if ((i23 | 0) > (16 - i24 | 0)) {
      i26 = HEAP32[i14 >> 2] | 0;
      HEAP32[i14 >> 2] = i26 + 1;
      HEAP8[(HEAP32[i10 >> 2] | 0) + i26 | 0] = i27;
      i26 = (HEAPU16[i3 >> 1] | 0) >>> 8 & 255;
      i23 = HEAP32[i14 >> 2] | 0;
      HEAP32[i14 >> 2] = i23 + 1;
      HEAP8[(HEAP32[i10 >> 2] | 0) + i23 | 0] = i26;
      i23 = HEAP32[i4 >> 2] | 0;
      i26 = i25 >>> (16 - i23 | 0) & 65535;
      HEAP16[i3 >> 1] = i26;
      i23 = i24 + -16 + i23 | 0;
     } else {
      i23 = i23 + i24 | 0;
     }
     HEAP32[i4 >> 2] = i23;
     i22 = i22 + -1 | 0;
    } while ((i22 | 0) != 0);
   }
  } while (0);
  if (i19 << 16 >> 16 == 0) {
   i24 = i15;
   i21 = 138;
   i23 = 3;
   i15 = i16;
   continue;
  }
  i24 = i15;
  i21 = i17 ? 6 : 7;
  i23 = i17 ? 3 : 4;
  i15 = i16;
 }
 STACKTOP = i11;
 return;
}
function __tr_flush_block(i2, i4, i6, i3) {
 i2 = i2 | 0;
 i4 = i4 | 0;
 i6 = i6 | 0;
 i3 = i3 | 0;
 var i1 = 0, i5 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0;
 i1 = STACKTOP;
 if ((HEAP32[i2 + 132 >> 2] | 0) > 0) {
  i5 = (HEAP32[i2 >> 2] | 0) + 44 | 0;
  if ((HEAP32[i5 >> 2] | 0) == 2) {
   i8 = -201342849;
   i9 = 0;
   while (1) {
    if ((i8 & 1 | 0) != 0 ? (HEAP16[i2 + (i9 << 2) + 148 >> 1] | 0) != 0 : 0) {
     i8 = 0;
     break;
    }
    i9 = i9 + 1 | 0;
    if ((i9 | 0) < 32) {
     i8 = i8 >>> 1;
    } else {
     i7 = 6;
     break;
    }
   }
   L9 : do {
    if ((i7 | 0) == 6) {
     if (((HEAP16[i2 + 184 >> 1] | 0) == 0 ? (HEAP16[i2 + 188 >> 1] | 0) == 0 : 0) ? (HEAP16[i2 + 200 >> 1] | 0) == 0 : 0) {
      i8 = 32;
      while (1) {
       i7 = i8 + 1 | 0;
       if ((HEAP16[i2 + (i8 << 2) + 148 >> 1] | 0) != 0) {
        i8 = 1;
        break L9;
       }
       if ((i7 | 0) < 256) {
        i8 = i7;
       } else {
        i8 = 0;
        break;
       }
      }
     } else {
      i8 = 1;
     }
    }
   } while (0);
   HEAP32[i5 >> 2] = i8;
  }
  _build_tree(i2, i2 + 2840 | 0);
  _build_tree(i2, i2 + 2852 | 0);
  _scan_tree(i2, i2 + 148 | 0, HEAP32[i2 + 2844 >> 2] | 0);
  _scan_tree(i2, i2 + 2440 | 0, HEAP32[i2 + 2856 >> 2] | 0);
  _build_tree(i2, i2 + 2864 | 0);
  i5 = 18;
  while (1) {
   i7 = i5 + -1 | 0;
   if ((HEAP16[i2 + (HEAPU8[2888 + i5 | 0] << 2) + 2686 >> 1] | 0) != 0) {
    break;
   }
   if ((i7 | 0) > 2) {
    i5 = i7;
   } else {
    i5 = i7;
    break;
   }
  }
  i10 = i2 + 5800 | 0;
  i7 = (i5 * 3 | 0) + 17 + (HEAP32[i10 >> 2] | 0) | 0;
  HEAP32[i10 >> 2] = i7;
  i7 = (i7 + 10 | 0) >>> 3;
  i10 = ((HEAP32[i2 + 5804 >> 2] | 0) + 10 | 0) >>> 3;
  i9 = i10 >>> 0 > i7 >>> 0 ? i7 : i10;
 } else {
  i10 = i6 + 5 | 0;
  i5 = 0;
  i9 = i10;
 }
 do {
  if ((i6 + 4 | 0) >>> 0 > i9 >>> 0 | (i4 | 0) == 0) {
   i4 = i2 + 5820 | 0;
   i7 = HEAP32[i4 >> 2] | 0;
   i8 = (i7 | 0) > 13;
   if ((HEAP32[i2 + 136 >> 2] | 0) == 4 | (i10 | 0) == (i9 | 0)) {
    i9 = i3 + 2 & 65535;
    i6 = i2 + 5816 | 0;
    i5 = HEAPU16[i6 >> 1] | i9 << i7;
    HEAP16[i6 >> 1] = i5;
    if (i8) {
     i12 = i2 + 20 | 0;
     i13 = HEAP32[i12 >> 2] | 0;
     HEAP32[i12 >> 2] = i13 + 1;
     i14 = i2 + 8 | 0;
     HEAP8[(HEAP32[i14 >> 2] | 0) + i13 | 0] = i5;
     i13 = (HEAPU16[i6 >> 1] | 0) >>> 8 & 255;
     i5 = HEAP32[i12 >> 2] | 0;
     HEAP32[i12 >> 2] = i5 + 1;
     HEAP8[(HEAP32[i14 >> 2] | 0) + i5 | 0] = i13;
     i5 = HEAP32[i4 >> 2] | 0;
     HEAP16[i6 >> 1] = i9 >>> (16 - i5 | 0);
     i5 = i5 + -13 | 0;
    } else {
     i5 = i7 + 3 | 0;
    }
    HEAP32[i4 >> 2] = i5;
    _compress_block(i2, 1136, 2288);
    break;
   }
   i10 = i3 + 4 & 65535;
   i6 = i2 + 5816 | 0;
   i9 = HEAPU16[i6 >> 1] | i10 << i7;
   HEAP16[i6 >> 1] = i9;
   if (i8) {
    i13 = i2 + 20 | 0;
    i12 = HEAP32[i13 >> 2] | 0;
    HEAP32[i13 >> 2] = i12 + 1;
    i14 = i2 + 8 | 0;
    HEAP8[(HEAP32[i14 >> 2] | 0) + i12 | 0] = i9;
    i9 = (HEAPU16[i6 >> 1] | 0) >>> 8 & 255;
    i12 = HEAP32[i13 >> 2] | 0;
    HEAP32[i13 >> 2] = i12 + 1;
    HEAP8[(HEAP32[i14 >> 2] | 0) + i12 | 0] = i9;
    i12 = HEAP32[i4 >> 2] | 0;
    i9 = i10 >>> (16 - i12 | 0);
    HEAP16[i6 >> 1] = i9;
    i12 = i12 + -13 | 0;
   } else {
    i12 = i7 + 3 | 0;
   }
   HEAP32[i4 >> 2] = i12;
   i7 = HEAP32[i2 + 2844 >> 2] | 0;
   i8 = HEAP32[i2 + 2856 >> 2] | 0;
   i10 = i7 + 65280 & 65535;
   i11 = i9 & 65535 | i10 << i12;
   HEAP16[i6 >> 1] = i11;
   if ((i12 | 0) > 11) {
    i13 = i2 + 20 | 0;
    i9 = HEAP32[i13 >> 2] | 0;
    HEAP32[i13 >> 2] = i9 + 1;
    i14 = i2 + 8 | 0;
    HEAP8[(HEAP32[i14 >> 2] | 0) + i9 | 0] = i11;
    i11 = (HEAPU16[i6 >> 1] | 0) >>> 8 & 255;
    i9 = HEAP32[i13 >> 2] | 0;
    HEAP32[i13 >> 2] = i9 + 1;
    HEAP8[(HEAP32[i14 >> 2] | 0) + i9 | 0] = i11;
    i9 = HEAP32[i4 >> 2] | 0;
    i11 = i10 >>> (16 - i9 | 0);
    HEAP16[i6 >> 1] = i11;
    i9 = i9 + -11 | 0;
   } else {
    i9 = i12 + 5 | 0;
   }
   HEAP32[i4 >> 2] = i9;
   i10 = i8 & 65535;
   i11 = i10 << i9 | i11 & 65535;
   HEAP16[i6 >> 1] = i11;
   if ((i9 | 0) > 11) {
    i13 = i2 + 20 | 0;
    i9 = HEAP32[i13 >> 2] | 0;
    HEAP32[i13 >> 2] = i9 + 1;
    i14 = i2 + 8 | 0;
    HEAP8[(HEAP32[i14 >> 2] | 0) + i9 | 0] = i11;
    i11 = (HEAPU16[i6 >> 1] | 0) >>> 8 & 255;
    i9 = HEAP32[i13 >> 2] | 0;
    HEAP32[i13 >> 2] = i9 + 1;
    HEAP8[(HEAP32[i14 >> 2] | 0) + i9 | 0] = i11;
    i9 = HEAP32[i4 >> 2] | 0;
    i11 = i10 >>> (16 - i9 | 0);
    HEAP16[i6 >> 1] = i11;
    i9 = i9 + -11 | 0;
   } else {
    i9 = i9 + 5 | 0;
   }
   HEAP32[i4 >> 2] = i9;
   i10 = i5 + 65533 & 65535;
   i14 = i10 << i9 | i11 & 65535;
   HEAP16[i6 >> 1] = i14;
   if ((i9 | 0) > 12) {
    i12 = i2 + 20 | 0;
    i11 = HEAP32[i12 >> 2] | 0;
    HEAP32[i12 >> 2] = i11 + 1;
    i13 = i2 + 8 | 0;
    HEAP8[(HEAP32[i13 >> 2] | 0) + i11 | 0] = i14;
    i14 = (HEAPU16[i6 >> 1] | 0) >>> 8 & 255;
    i11 = HEAP32[i12 >> 2] | 0;
    HEAP32[i12 >> 2] = i11 + 1;
    HEAP8[(HEAP32[i13 >> 2] | 0) + i11 | 0] = i14;
    i11 = HEAP32[i4 >> 2] | 0;
    i14 = i10 >>> (16 - i11 | 0);
    HEAP16[i6 >> 1] = i14;
    i11 = i11 + -12 | 0;
   } else {
    i11 = i9 + 4 | 0;
   }
   HEAP32[i4 >> 2] = i11;
   if ((i5 | 0) > -1) {
    i10 = i2 + 20 | 0;
    i9 = i2 + 8 | 0;
    i12 = 0;
    while (1) {
     i13 = HEAPU16[i2 + (HEAPU8[2888 + i12 | 0] << 2) + 2686 >> 1] | 0;
     i14 = i13 << i11 | i14 & 65535;
     HEAP16[i6 >> 1] = i14;
     if ((i11 | 0) > 13) {
      i11 = HEAP32[i10 >> 2] | 0;
      HEAP32[i10 >> 2] = i11 + 1;
      HEAP8[(HEAP32[i9 >> 2] | 0) + i11 | 0] = i14;
      i14 = (HEAPU16[i6 >> 1] | 0) >>> 8 & 255;
      i11 = HEAP32[i10 >> 2] | 0;
      HEAP32[i10 >> 2] = i11 + 1;
      HEAP8[(HEAP32[i9 >> 2] | 0) + i11 | 0] = i14;
      i11 = HEAP32[i4 >> 2] | 0;
      i14 = i13 >>> (16 - i11 | 0);
      HEAP16[i6 >> 1] = i14;
      i11 = i11 + -13 | 0;
     } else {
      i11 = i11 + 3 | 0;
     }
     HEAP32[i4 >> 2] = i11;
     if ((i12 | 0) == (i5 | 0)) {
      break;
     } else {
      i12 = i12 + 1 | 0;
     }
    }
   }
   i13 = i2 + 148 | 0;
   _send_tree(i2, i13, i7);
   i14 = i2 + 2440 | 0;
   _send_tree(i2, i14, i8);
   _compress_block(i2, i13, i14);
  } else {
   __tr_stored_block(i2, i4, i6, i3);
  }
 } while (0);
 _init_block(i2);
 if ((i3 | 0) == 0) {
  STACKTOP = i1;
  return;
 }
 i3 = i2 + 5820 | 0;
 i4 = HEAP32[i3 >> 2] | 0;
 if ((i4 | 0) <= 8) {
  i5 = i2 + 5816 | 0;
  if ((i4 | 0) > 0) {
   i13 = HEAP16[i5 >> 1] & 255;
   i12 = i2 + 20 | 0;
   i14 = HEAP32[i12 >> 2] | 0;
   HEAP32[i12 >> 2] = i14 + 1;
   HEAP8[(HEAP32[i2 + 8 >> 2] | 0) + i14 | 0] = i13;
  }
 } else {
  i5 = i2 + 5816 | 0;
  i14 = HEAP16[i5 >> 1] & 255;
  i11 = i2 + 20 | 0;
  i12 = HEAP32[i11 >> 2] | 0;
  HEAP32[i11 >> 2] = i12 + 1;
  i13 = i2 + 8 | 0;
  HEAP8[(HEAP32[i13 >> 2] | 0) + i12 | 0] = i14;
  i12 = (HEAPU16[i5 >> 1] | 0) >>> 8 & 255;
  i14 = HEAP32[i11 >> 2] | 0;
  HEAP32[i11 >> 2] = i14 + 1;
  HEAP8[(HEAP32[i13 >> 2] | 0) + i14 | 0] = i12;
 }
 HEAP16[i5 >> 1] = 0;
 HEAP32[i3 >> 2] = 0;
 STACKTOP = i1;
 return;
}
function _deflate_fast(i3, i6) {
 i3 = i3 | 0;
 i6 = i6 | 0;
 var i1 = 0, i2 = 0, i4 = 0, i5 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0, i34 = 0, i35 = 0, i36 = 0;
 i1 = STACKTOP;
 i20 = i3 + 116 | 0;
 i22 = (i6 | 0) == 0;
 i23 = i3 + 72 | 0;
 i24 = i3 + 88 | 0;
 i5 = i3 + 108 | 0;
 i7 = i3 + 56 | 0;
 i9 = i3 + 84 | 0;
 i10 = i3 + 68 | 0;
 i11 = i3 + 52 | 0;
 i12 = i3 + 64 | 0;
 i19 = i3 + 44 | 0;
 i21 = i3 + 96 | 0;
 i16 = i3 + 112 | 0;
 i13 = i3 + 5792 | 0;
 i17 = i3 + 5796 | 0;
 i18 = i3 + 5784 | 0;
 i14 = i3 + 5788 | 0;
 i15 = i3 + 128 | 0;
 i4 = i3 + 92 | 0;
 while (1) {
  if ((HEAP32[i20 >> 2] | 0) >>> 0 < 262) {
   _fill_window(i3);
   i25 = HEAP32[i20 >> 2] | 0;
   if (i25 >>> 0 < 262 & i22) {
    i2 = 0;
    i25 = 34;
    break;
   }
   if ((i25 | 0) == 0) {
    i25 = 26;
    break;
   }
   if (!(i25 >>> 0 > 2)) {
    i25 = 9;
   } else {
    i25 = 6;
   }
  } else {
   i25 = 6;
  }
  if ((i25 | 0) == 6) {
   i25 = 0;
   i26 = HEAP32[i5 >> 2] | 0;
   i34 = ((HEAPU8[(HEAP32[i7 >> 2] | 0) + (i26 + 2) | 0] | 0) ^ HEAP32[i23 >> 2] << HEAP32[i24 >> 2]) & HEAP32[i9 >> 2];
   HEAP32[i23 >> 2] = i34;
   i34 = (HEAP32[i10 >> 2] | 0) + (i34 << 1) | 0;
   i35 = HEAP16[i34 >> 1] | 0;
   HEAP16[(HEAP32[i12 >> 2] | 0) + ((HEAP32[i11 >> 2] & i26) << 1) >> 1] = i35;
   i27 = i35 & 65535;
   HEAP16[i34 >> 1] = i26;
   if (!(i35 << 16 >> 16 == 0) ? !((i26 - i27 | 0) >>> 0 > ((HEAP32[i19 >> 2] | 0) + -262 | 0) >>> 0) : 0) {
    i26 = _longest_match(i3, i27) | 0;
    HEAP32[i21 >> 2] = i26;
   } else {
    i25 = 9;
   }
  }
  if ((i25 | 0) == 9) {
   i26 = HEAP32[i21 >> 2] | 0;
  }
  do {
   if (i26 >>> 0 > 2) {
    i35 = i26 + 253 | 0;
    i25 = (HEAP32[i5 >> 2] | 0) - (HEAP32[i16 >> 2] | 0) | 0;
    i34 = HEAP32[i13 >> 2] | 0;
    HEAP16[(HEAP32[i17 >> 2] | 0) + (i34 << 1) >> 1] = i25;
    HEAP32[i13 >> 2] = i34 + 1;
    HEAP8[(HEAP32[i18 >> 2] | 0) + i34 | 0] = i35;
    i35 = i3 + ((HEAPU8[808 + (i35 & 255) | 0] | 0 | 256) + 1 << 2) + 148 | 0;
    HEAP16[i35 >> 1] = (HEAP16[i35 >> 1] | 0) + 1 << 16 >> 16;
    i25 = i25 + 65535 & 65535;
    if (!(i25 >>> 0 < 256)) {
     i25 = (i25 >>> 7) + 256 | 0;
    }
    i25 = i3 + ((HEAPU8[296 + i25 | 0] | 0) << 2) + 2440 | 0;
    HEAP16[i25 >> 1] = (HEAP16[i25 >> 1] | 0) + 1 << 16 >> 16;
    i25 = (HEAP32[i13 >> 2] | 0) == ((HEAP32[i14 >> 2] | 0) + -1 | 0) | 0;
    i26 = HEAP32[i21 >> 2] | 0;
    i35 = (HEAP32[i20 >> 2] | 0) - i26 | 0;
    HEAP32[i20 >> 2] = i35;
    if (!(i26 >>> 0 <= (HEAP32[i15 >> 2] | 0) >>> 0 & i35 >>> 0 > 2)) {
     i26 = (HEAP32[i5 >> 2] | 0) + i26 | 0;
     HEAP32[i5 >> 2] = i26;
     HEAP32[i21 >> 2] = 0;
     i34 = HEAP32[i7 >> 2] | 0;
     i35 = HEAPU8[i34 + i26 | 0] | 0;
     HEAP32[i23 >> 2] = i35;
     HEAP32[i23 >> 2] = ((HEAPU8[i34 + (i26 + 1) | 0] | 0) ^ i35 << HEAP32[i24 >> 2]) & HEAP32[i9 >> 2];
     break;
    }
    i30 = i26 + -1 | 0;
    HEAP32[i21 >> 2] = i30;
    i34 = HEAP32[i24 >> 2] | 0;
    i33 = HEAP32[i7 >> 2] | 0;
    i35 = HEAP32[i9 >> 2] | 0;
    i32 = HEAP32[i10 >> 2] | 0;
    i27 = HEAP32[i11 >> 2] | 0;
    i29 = HEAP32[i12 >> 2] | 0;
    i26 = HEAP32[i5 >> 2] | 0;
    i31 = HEAP32[i23 >> 2] | 0;
    while (1) {
     i28 = i26 + 1 | 0;
     HEAP32[i5 >> 2] = i28;
     i31 = ((HEAPU8[i33 + (i26 + 3) | 0] | 0) ^ i31 << i34) & i35;
     HEAP32[i23 >> 2] = i31;
     i36 = i32 + (i31 << 1) | 0;
     HEAP16[i29 + ((i27 & i28) << 1) >> 1] = HEAP16[i36 >> 1] | 0;
     HEAP16[i36 >> 1] = i28;
     i30 = i30 + -1 | 0;
     HEAP32[i21 >> 2] = i30;
     if ((i30 | 0) == 0) {
      break;
     } else {
      i26 = i28;
     }
    }
    i26 = i26 + 2 | 0;
    HEAP32[i5 >> 2] = i26;
   } else {
    i25 = HEAP8[(HEAP32[i7 >> 2] | 0) + (HEAP32[i5 >> 2] | 0) | 0] | 0;
    i26 = HEAP32[i13 >> 2] | 0;
    HEAP16[(HEAP32[i17 >> 2] | 0) + (i26 << 1) >> 1] = 0;
    HEAP32[i13 >> 2] = i26 + 1;
    HEAP8[(HEAP32[i18 >> 2] | 0) + i26 | 0] = i25;
    i25 = i3 + ((i25 & 255) << 2) + 148 | 0;
    HEAP16[i25 >> 1] = (HEAP16[i25 >> 1] | 0) + 1 << 16 >> 16;
    i25 = (HEAP32[i13 >> 2] | 0) == ((HEAP32[i14 >> 2] | 0) + -1 | 0) | 0;
    HEAP32[i20 >> 2] = (HEAP32[i20 >> 2] | 0) + -1;
    i26 = (HEAP32[i5 >> 2] | 0) + 1 | 0;
    HEAP32[i5 >> 2] = i26;
   }
  } while (0);
  if ((i25 | 0) == 0) {
   continue;
  }
  i25 = HEAP32[i4 >> 2] | 0;
  if ((i25 | 0) > -1) {
   i27 = (HEAP32[i7 >> 2] | 0) + i25 | 0;
  } else {
   i27 = 0;
  }
  __tr_flush_block(i3, i27, i26 - i25 | 0, 0);
  HEAP32[i4 >> 2] = HEAP32[i5 >> 2];
  i27 = HEAP32[i3 >> 2] | 0;
  i28 = i27 + 28 | 0;
  i25 = HEAP32[i28 >> 2] | 0;
  i30 = HEAP32[i25 + 20 >> 2] | 0;
  i26 = i27 + 16 | 0;
  i29 = HEAP32[i26 >> 2] | 0;
  i29 = i30 >>> 0 > i29 >>> 0 ? i29 : i30;
  if ((i29 | 0) != 0 ? (i8 = i27 + 12 | 0, _memcpy(HEAP32[i8 >> 2] | 0, HEAP32[i25 + 16 >> 2] | 0, i29 | 0) | 0, HEAP32[i8 >> 2] = (HEAP32[i8 >> 2] | 0) + i29, i8 = (HEAP32[i28 >> 2] | 0) + 16 | 0, HEAP32[i8 >> 2] = (HEAP32[i8 >> 2] | 0) + i29, i8 = i27 + 20 | 0, HEAP32[i8 >> 2] = (HEAP32[i8 >> 2] | 0) + i29, HEAP32[i26 >> 2] = (HEAP32[i26 >> 2] | 0) - i29, i8 = HEAP32[i28 >> 2] | 0, i35 = i8 + 20 | 0, i36 = HEAP32[i35 >> 2] | 0, HEAP32[i35 >> 2] = i36 - i29, (i36 | 0) == (i29 | 0)) : 0) {
   HEAP32[i8 + 16 >> 2] = HEAP32[i8 + 8 >> 2];
  }
  if ((HEAP32[(HEAP32[i3 >> 2] | 0) + 16 >> 2] | 0) == 0) {
   i2 = 0;
   i25 = 34;
   break;
  }
 }
 if ((i25 | 0) == 26) {
  i8 = HEAP32[i4 >> 2] | 0;
  if ((i8 | 0) > -1) {
   i7 = (HEAP32[i7 >> 2] | 0) + i8 | 0;
  } else {
   i7 = 0;
  }
  i6 = (i6 | 0) == 4;
  __tr_flush_block(i3, i7, (HEAP32[i5 >> 2] | 0) - i8 | 0, i6 & 1);
  HEAP32[i4 >> 2] = HEAP32[i5 >> 2];
  i5 = HEAP32[i3 >> 2] | 0;
  i7 = i5 + 28 | 0;
  i4 = HEAP32[i7 >> 2] | 0;
  i10 = HEAP32[i4 + 20 >> 2] | 0;
  i8 = i5 + 16 | 0;
  i9 = HEAP32[i8 >> 2] | 0;
  i9 = i10 >>> 0 > i9 >>> 0 ? i9 : i10;
  if ((i9 | 0) != 0 ? (i2 = i5 + 12 | 0, _memcpy(HEAP32[i2 >> 2] | 0, HEAP32[i4 + 16 >> 2] | 0, i9 | 0) | 0, HEAP32[i2 >> 2] = (HEAP32[i2 >> 2] | 0) + i9, i2 = (HEAP32[i7 >> 2] | 0) + 16 | 0, HEAP32[i2 >> 2] = (HEAP32[i2 >> 2] | 0) + i9, i2 = i5 + 20 | 0, HEAP32[i2 >> 2] = (HEAP32[i2 >> 2] | 0) + i9, HEAP32[i8 >> 2] = (HEAP32[i8 >> 2] | 0) - i9, i2 = HEAP32[i7 >> 2] | 0, i35 = i2 + 20 | 0, i36 = HEAP32[i35 >> 2] | 0, HEAP32[i35 >> 2] = i36 - i9, (i36 | 0) == (i9 | 0)) : 0) {
   HEAP32[i2 + 16 >> 2] = HEAP32[i2 + 8 >> 2];
  }
  if ((HEAP32[(HEAP32[i3 >> 2] | 0) + 16 >> 2] | 0) == 0) {
   i36 = i6 ? 2 : 0;
   STACKTOP = i1;
   return i36 | 0;
  } else {
   i36 = i6 ? 3 : 1;
   STACKTOP = i1;
   return i36 | 0;
  }
 } else if ((i25 | 0) == 34) {
  STACKTOP = i1;
  return i2 | 0;
 }
 return 0;
}
function _inflate_table(i11, i5, i13, i2, i1, i10) {
 i11 = i11 | 0;
 i5 = i5 | 0;
 i13 = i13 | 0;
 i2 = i2 | 0;
 i1 = i1 | 0;
 i10 = i10 | 0;
 var i3 = 0, i4 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i12 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0, i25 = 0, i26 = 0, i27 = 0, i28 = 0, i29 = 0, i30 = 0, i31 = 0, i32 = 0, i33 = 0;
 i3 = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 i7 = i3 + 32 | 0;
 i12 = i3;
 i4 = i7 + 0 | 0;
 i9 = i4 + 32 | 0;
 do {
  HEAP16[i4 >> 1] = 0;
  i4 = i4 + 2 | 0;
 } while ((i4 | 0) < (i9 | 0));
 i14 = (i13 | 0) == 0;
 if (!i14) {
  i4 = 0;
  do {
   i32 = i7 + (HEAPU16[i5 + (i4 << 1) >> 1] << 1) | 0;
   HEAP16[i32 >> 1] = (HEAP16[i32 >> 1] | 0) + 1 << 16 >> 16;
   i4 = i4 + 1 | 0;
  } while ((i4 | 0) != (i13 | 0));
 }
 i4 = HEAP32[i1 >> 2] | 0;
 i9 = 15;
 while (1) {
  i15 = i9 + -1 | 0;
  if ((HEAP16[i7 + (i9 << 1) >> 1] | 0) != 0) {
   break;
  }
  if ((i15 | 0) == 0) {
   i6 = 7;
   break;
  } else {
   i9 = i15;
  }
 }
 if ((i6 | 0) == 7) {
  i32 = HEAP32[i2 >> 2] | 0;
  HEAP32[i2 >> 2] = i32 + 4;
  HEAP8[i32] = 64;
  HEAP8[i32 + 1 | 0] = 1;
  HEAP16[i32 + 2 >> 1] = 0;
  i32 = HEAP32[i2 >> 2] | 0;
  HEAP32[i2 >> 2] = i32 + 4;
  HEAP8[i32] = 64;
  HEAP8[i32 + 1 | 0] = 1;
  HEAP16[i32 + 2 >> 1] = 0;
  HEAP32[i1 >> 2] = 1;
  i32 = 0;
  STACKTOP = i3;
  return i32 | 0;
 }
 i4 = i4 >>> 0 > i9 >>> 0 ? i9 : i4;
 L12 : do {
  if (i9 >>> 0 > 1) {
   i27 = 1;
   while (1) {
    i15 = i27 + 1 | 0;
    if ((HEAP16[i7 + (i27 << 1) >> 1] | 0) != 0) {
     break L12;
    }
    if (i15 >>> 0 < i9 >>> 0) {
     i27 = i15;
    } else {
     i27 = i15;
     break;
    }
   }
  } else {
   i27 = 1;
  }
 } while (0);
 i4 = i4 >>> 0 < i27 >>> 0 ? i27 : i4;
 i16 = 1;
 i15 = 1;
 do {
  i16 = (i16 << 1) - (HEAPU16[i7 + (i15 << 1) >> 1] | 0) | 0;
  i15 = i15 + 1 | 0;
  if ((i16 | 0) < 0) {
   i8 = -1;
   i6 = 56;
   break;
  }
 } while (i15 >>> 0 < 16);
 if ((i6 | 0) == 56) {
  STACKTOP = i3;
  return i8 | 0;
 }
 if ((i16 | 0) > 0 ? !((i11 | 0) != 0 & (i9 | 0) == 1) : 0) {
  i32 = -1;
  STACKTOP = i3;
  return i32 | 0;
 }
 HEAP16[i12 + 2 >> 1] = 0;
 i16 = 0;
 i15 = 1;
 do {
  i16 = (HEAPU16[i7 + (i15 << 1) >> 1] | 0) + (i16 & 65535) | 0;
  i15 = i15 + 1 | 0;
  HEAP16[i12 + (i15 << 1) >> 1] = i16;
 } while ((i15 | 0) != 15);
 if (!i14) {
  i15 = 0;
  do {
   i14 = HEAP16[i5 + (i15 << 1) >> 1] | 0;
   if (!(i14 << 16 >> 16 == 0)) {
    i31 = i12 + ((i14 & 65535) << 1) | 0;
    i32 = HEAP16[i31 >> 1] | 0;
    HEAP16[i31 >> 1] = i32 + 1 << 16 >> 16;
    HEAP16[i10 + ((i32 & 65535) << 1) >> 1] = i15;
   }
   i15 = i15 + 1 | 0;
  } while ((i15 | 0) != (i13 | 0));
 }
 if ((i11 | 0) == 1) {
  i14 = 1 << i4;
  if (i14 >>> 0 > 851) {
   i32 = 1;
   STACKTOP = i3;
   return i32 | 0;
  } else {
   i16 = 0;
   i20 = 1;
   i17 = 14128 + -514 | 0;
   i19 = 256;
   i18 = 14192 + -514 | 0;
  }
 } else if ((i11 | 0) != 0) {
  i14 = 1 << i4;
  i16 = (i11 | 0) == 2;
  if (i16 & i14 >>> 0 > 591) {
   i32 = 1;
   STACKTOP = i3;
   return i32 | 0;
  } else {
   i20 = 0;
   i17 = 14256;
   i19 = -1;
   i18 = 14320;
  }
 } else {
  i16 = 0;
  i14 = 1 << i4;
  i20 = 0;
  i17 = i10;
  i19 = 19;
  i18 = i10;
 }
 i11 = i14 + -1 | 0;
 i12 = i4 & 255;
 i22 = i4;
 i21 = 0;
 i25 = 0;
 i13 = -1;
 i15 = HEAP32[i2 >> 2] | 0;
 i24 = 0;
 L44 : while (1) {
  i23 = 1 << i22;
  while (1) {
   i29 = i27 - i21 | 0;
   i22 = i29 & 255;
   i28 = HEAP16[i10 + (i24 << 1) >> 1] | 0;
   i30 = i28 & 65535;
   if ((i30 | 0) >= (i19 | 0)) {
    if ((i30 | 0) > (i19 | 0)) {
     i26 = HEAP16[i18 + (i30 << 1) >> 1] & 255;
     i28 = HEAP16[i17 + (i30 << 1) >> 1] | 0;
    } else {
     i26 = 96;
     i28 = 0;
    }
   } else {
    i26 = 0;
   }
   i31 = 1 << i29;
   i30 = i25 >>> i21;
   i32 = i23;
   while (1) {
    i29 = i32 - i31 | 0;
    i33 = i29 + i30 | 0;
    HEAP8[i15 + (i33 << 2) | 0] = i26;
    HEAP8[i15 + (i33 << 2) + 1 | 0] = i22;
    HEAP16[i15 + (i33 << 2) + 2 >> 1] = i28;
    if ((i32 | 0) == (i31 | 0)) {
     break;
    } else {
     i32 = i29;
    }
   }
   i26 = 1 << i27 + -1;
   while (1) {
    if ((i26 & i25 | 0) == 0) {
     break;
    } else {
     i26 = i26 >>> 1;
    }
   }
   if ((i26 | 0) == 0) {
    i25 = 0;
   } else {
    i25 = (i26 + -1 & i25) + i26 | 0;
   }
   i24 = i24 + 1 | 0;
   i32 = i7 + (i27 << 1) | 0;
   i33 = (HEAP16[i32 >> 1] | 0) + -1 << 16 >> 16;
   HEAP16[i32 >> 1] = i33;
   if (i33 << 16 >> 16 == 0) {
    if ((i27 | 0) == (i9 | 0)) {
     break L44;
    }
    i27 = HEAPU16[i5 + (HEAPU16[i10 + (i24 << 1) >> 1] << 1) >> 1] | 0;
   }
   if (!(i27 >>> 0 > i4 >>> 0)) {
    continue;
   }
   i26 = i25 & i11;
   if ((i26 | 0) != (i13 | 0)) {
    break;
   }
  }
  i28 = (i21 | 0) == 0 ? i4 : i21;
  i23 = i15 + (i23 << 2) | 0;
  i31 = i27 - i28 | 0;
  L67 : do {
   if (i27 >>> 0 < i9 >>> 0) {
    i29 = i27;
    i30 = i31;
    i31 = 1 << i31;
    while (1) {
     i31 = i31 - (HEAPU16[i7 + (i29 << 1) >> 1] | 0) | 0;
     if ((i31 | 0) < 1) {
      break L67;
     }
     i30 = i30 + 1 | 0;
     i29 = i30 + i28 | 0;
     if (i29 >>> 0 < i9 >>> 0) {
      i31 = i31 << 1;
     } else {
      break;
     }
    }
   } else {
    i30 = i31;
   }
  } while (0);
  i29 = (1 << i30) + i14 | 0;
  if (i20 & i29 >>> 0 > 851 | i16 & i29 >>> 0 > 591) {
   i8 = 1;
   i6 = 56;
   break;
  }
  HEAP8[(HEAP32[i2 >> 2] | 0) + (i26 << 2) | 0] = i30;
  HEAP8[(HEAP32[i2 >> 2] | 0) + (i26 << 2) + 1 | 0] = i12;
  i22 = HEAP32[i2 >> 2] | 0;
  HEAP16[i22 + (i26 << 2) + 2 >> 1] = (i23 - i22 | 0) >>> 2;
  i22 = i30;
  i21 = i28;
  i13 = i26;
  i15 = i23;
  i14 = i29;
 }
 if ((i6 | 0) == 56) {
  STACKTOP = i3;
  return i8 | 0;
 }
 L77 : do {
  if ((i25 | 0) != 0) {
   do {
    if ((i21 | 0) != 0) {
     if ((i25 & i11 | 0) != (i13 | 0)) {
      i21 = 0;
      i22 = i12;
      i9 = i4;
      i15 = HEAP32[i2 >> 2] | 0;
     }
    } else {
     i21 = 0;
    }
    i5 = i25 >>> i21;
    HEAP8[i15 + (i5 << 2) | 0] = 64;
    HEAP8[i15 + (i5 << 2) + 1 | 0] = i22;
    HEAP16[i15 + (i5 << 2) + 2 >> 1] = 0;
    i5 = 1 << i9 + -1;
    while (1) {
     if ((i5 & i25 | 0) == 0) {
      break;
     } else {
      i5 = i5 >>> 1;
     }
    }
    if ((i5 | 0) == 0) {
     break L77;
    }
    i25 = (i5 + -1 & i25) + i5 | 0;
   } while ((i25 | 0) != 0);
  }
 } while (0);
 HEAP32[i2 >> 2] = (HEAP32[i2 >> 2] | 0) + (i14 << 2);
 HEAP32[i1 >> 2] = i4;
 i33 = 0;
 STACKTOP = i3;
 return i33 | 0;
}
function _compress_block(i1, i3, i7) {
 i1 = i1 | 0;
 i3 = i3 | 0;
 i7 = i7 | 0;
 var i2 = 0, i4 = 0, i5 = 0, i6 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0;
 i2 = STACKTOP;
 i11 = i1 + 5792 | 0;
 if ((HEAP32[i11 >> 2] | 0) == 0) {
  i14 = HEAP32[i1 + 5820 >> 2] | 0;
  i17 = HEAP16[i1 + 5816 >> 1] | 0;
 } else {
  i9 = i1 + 5796 | 0;
  i10 = i1 + 5784 | 0;
  i8 = i1 + 5820 | 0;
  i12 = i1 + 5816 | 0;
  i5 = i1 + 20 | 0;
  i6 = i1 + 8 | 0;
  i14 = 0;
  while (1) {
   i20 = HEAP16[(HEAP32[i9 >> 2] | 0) + (i14 << 1) >> 1] | 0;
   i13 = i20 & 65535;
   i4 = i14 + 1 | 0;
   i14 = HEAPU8[(HEAP32[i10 >> 2] | 0) + i14 | 0] | 0;
   do {
    if (i20 << 16 >> 16 == 0) {
     i15 = HEAPU16[i3 + (i14 << 2) + 2 >> 1] | 0;
     i13 = HEAP32[i8 >> 2] | 0;
     i14 = HEAPU16[i3 + (i14 << 2) >> 1] | 0;
     i16 = HEAPU16[i12 >> 1] | 0 | i14 << i13;
     i17 = i16 & 65535;
     HEAP16[i12 >> 1] = i17;
     if ((i13 | 0) > (16 - i15 | 0)) {
      i17 = HEAP32[i5 >> 2] | 0;
      HEAP32[i5 >> 2] = i17 + 1;
      HEAP8[(HEAP32[i6 >> 2] | 0) + i17 | 0] = i16;
      i17 = (HEAPU16[i12 >> 1] | 0) >>> 8 & 255;
      i20 = HEAP32[i5 >> 2] | 0;
      HEAP32[i5 >> 2] = i20 + 1;
      HEAP8[(HEAP32[i6 >> 2] | 0) + i20 | 0] = i17;
      i20 = HEAP32[i8 >> 2] | 0;
      i17 = i14 >>> (16 - i20 | 0) & 65535;
      HEAP16[i12 >> 1] = i17;
      i14 = i15 + -16 + i20 | 0;
      HEAP32[i8 >> 2] = i14;
      break;
     } else {
      i14 = i13 + i15 | 0;
      HEAP32[i8 >> 2] = i14;
      break;
     }
    } else {
     i15 = HEAPU8[808 + i14 | 0] | 0;
     i19 = (i15 | 256) + 1 | 0;
     i18 = HEAPU16[i3 + (i19 << 2) + 2 >> 1] | 0;
     i17 = HEAP32[i8 >> 2] | 0;
     i19 = HEAPU16[i3 + (i19 << 2) >> 1] | 0;
     i20 = HEAPU16[i12 >> 1] | 0 | i19 << i17;
     i16 = i20 & 65535;
     HEAP16[i12 >> 1] = i16;
     if ((i17 | 0) > (16 - i18 | 0)) {
      i16 = HEAP32[i5 >> 2] | 0;
      HEAP32[i5 >> 2] = i16 + 1;
      HEAP8[(HEAP32[i6 >> 2] | 0) + i16 | 0] = i20;
      i16 = (HEAPU16[i12 >> 1] | 0) >>> 8 & 255;
      i20 = HEAP32[i5 >> 2] | 0;
      HEAP32[i5 >> 2] = i20 + 1;
      HEAP8[(HEAP32[i6 >> 2] | 0) + i20 | 0] = i16;
      i20 = HEAP32[i8 >> 2] | 0;
      i16 = i19 >>> (16 - i20 | 0) & 65535;
      HEAP16[i12 >> 1] = i16;
      i18 = i18 + -16 + i20 | 0;
     } else {
      i18 = i17 + i18 | 0;
     }
     HEAP32[i8 >> 2] = i18;
     i17 = HEAP32[2408 + (i15 << 2) >> 2] | 0;
     do {
      if ((i15 + -8 | 0) >>> 0 < 20) {
       i14 = i14 - (HEAP32[2528 + (i15 << 2) >> 2] | 0) & 65535;
       i15 = i14 << i18 | i16 & 65535;
       i16 = i15 & 65535;
       HEAP16[i12 >> 1] = i16;
       if ((i18 | 0) > (16 - i17 | 0)) {
        i16 = HEAP32[i5 >> 2] | 0;
        HEAP32[i5 >> 2] = i16 + 1;
        HEAP8[(HEAP32[i6 >> 2] | 0) + i16 | 0] = i15;
        i16 = (HEAPU16[i12 >> 1] | 0) >>> 8 & 255;
        i20 = HEAP32[i5 >> 2] | 0;
        HEAP32[i5 >> 2] = i20 + 1;
        HEAP8[(HEAP32[i6 >> 2] | 0) + i20 | 0] = i16;
        i20 = HEAP32[i8 >> 2] | 0;
        i16 = i14 >>> (16 - i20 | 0) & 65535;
        HEAP16[i12 >> 1] = i16;
        i14 = i17 + -16 + i20 | 0;
        HEAP32[i8 >> 2] = i14;
        break;
       } else {
        i14 = i18 + i17 | 0;
        HEAP32[i8 >> 2] = i14;
        break;
       }
      } else {
       i14 = i18;
      }
     } while (0);
     i13 = i13 + -1 | 0;
     if (i13 >>> 0 < 256) {
      i15 = i13;
     } else {
      i15 = (i13 >>> 7) + 256 | 0;
     }
     i15 = HEAPU8[296 + i15 | 0] | 0;
     i17 = HEAPU16[i7 + (i15 << 2) + 2 >> 1] | 0;
     i18 = HEAPU16[i7 + (i15 << 2) >> 1] | 0;
     i19 = i16 & 65535 | i18 << i14;
     i16 = i19 & 65535;
     HEAP16[i12 >> 1] = i16;
     if ((i14 | 0) > (16 - i17 | 0)) {
      i20 = HEAP32[i5 >> 2] | 0;
      HEAP32[i5 >> 2] = i20 + 1;
      HEAP8[(HEAP32[i6 >> 2] | 0) + i20 | 0] = i19;
      i20 = (HEAPU16[i12 >> 1] | 0) >>> 8 & 255;
      i14 = HEAP32[i5 >> 2] | 0;
      HEAP32[i5 >> 2] = i14 + 1;
      HEAP8[(HEAP32[i6 >> 2] | 0) + i14 | 0] = i20;
      i14 = HEAP32[i8 >> 2] | 0;
      i20 = i18 >>> (16 - i14 | 0) & 65535;
      HEAP16[i12 >> 1] = i20;
      i14 = i17 + -16 + i14 | 0;
      i17 = i20;
     } else {
      i14 = i14 + i17 | 0;
      i17 = i16;
     }
     HEAP32[i8 >> 2] = i14;
     i16 = HEAP32[2648 + (i15 << 2) >> 2] | 0;
     if ((i15 + -4 | 0) >>> 0 < 26) {
      i13 = i13 - (HEAP32[2768 + (i15 << 2) >> 2] | 0) & 65535;
      i15 = i13 << i14 | i17 & 65535;
      i17 = i15 & 65535;
      HEAP16[i12 >> 1] = i17;
      if ((i14 | 0) > (16 - i16 | 0)) {
       i17 = HEAP32[i5 >> 2] | 0;
       HEAP32[i5 >> 2] = i17 + 1;
       HEAP8[(HEAP32[i6 >> 2] | 0) + i17 | 0] = i15;
       i17 = (HEAPU16[i12 >> 1] | 0) >>> 8 & 255;
       i14 = HEAP32[i5 >> 2] | 0;
       HEAP32[i5 >> 2] = i14 + 1;
       HEAP8[(HEAP32[i6 >> 2] | 0) + i14 | 0] = i17;
       i14 = HEAP32[i8 >> 2] | 0;
       i17 = i13 >>> (16 - i14 | 0) & 65535;
       HEAP16[i12 >> 1] = i17;
       i14 = i16 + -16 + i14 | 0;
       HEAP32[i8 >> 2] = i14;
       break;
      } else {
       i14 = i14 + i16 | 0;
       HEAP32[i8 >> 2] = i14;
       break;
      }
     }
    }
   } while (0);
   if (i4 >>> 0 < (HEAP32[i11 >> 2] | 0) >>> 0) {
    i14 = i4;
   } else {
    break;
   }
  }
 }
 i5 = i3 + 1026 | 0;
 i6 = HEAPU16[i5 >> 1] | 0;
 i4 = i1 + 5820 | 0;
 i3 = HEAPU16[i3 + 1024 >> 1] | 0;
 i7 = i1 + 5816 | 0;
 i8 = i17 & 65535 | i3 << i14;
 HEAP16[i7 >> 1] = i8;
 if ((i14 | 0) > (16 - i6 | 0)) {
  i17 = i1 + 20 | 0;
  i18 = HEAP32[i17 >> 2] | 0;
  HEAP32[i17 >> 2] = i18 + 1;
  i20 = i1 + 8 | 0;
  HEAP8[(HEAP32[i20 >> 2] | 0) + i18 | 0] = i8;
  i18 = (HEAPU16[i7 >> 1] | 0) >>> 8 & 255;
  i19 = HEAP32[i17 >> 2] | 0;
  HEAP32[i17 >> 2] = i19 + 1;
  HEAP8[(HEAP32[i20 >> 2] | 0) + i19 | 0] = i18;
  i19 = HEAP32[i4 >> 2] | 0;
  HEAP16[i7 >> 1] = i3 >>> (16 - i19 | 0);
  i19 = i6 + -16 + i19 | 0;
  HEAP32[i4 >> 2] = i19;
  i19 = HEAP16[i5 >> 1] | 0;
  i19 = i19 & 65535;
  i20 = i1 + 5812 | 0;
  HEAP32[i20 >> 2] = i19;
  STACKTOP = i2;
  return;
 } else {
  i19 = i14 + i6 | 0;
  HEAP32[i4 >> 2] = i19;
  i19 = HEAP16[i5 >> 1] | 0;
  i19 = i19 & 65535;
  i20 = i1 + 5812 | 0;
  HEAP32[i20 >> 2] = i19;
  STACKTOP = i2;
  return;
 }
}
function _deflate_stored(i2, i5) {
 i2 = i2 | 0;
 i5 = i5 | 0;
 var i1 = 0, i3 = 0, i4 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0;
 i1 = STACKTOP;
 i4 = (HEAP32[i2 + 12 >> 2] | 0) + -5 | 0;
 i11 = i4 >>> 0 < 65535 ? i4 : 65535;
 i12 = i2 + 116 | 0;
 i4 = i2 + 108 | 0;
 i6 = i2 + 92 | 0;
 i10 = i2 + 44 | 0;
 i7 = i2 + 56 | 0;
 while (1) {
  i13 = HEAP32[i12 >> 2] | 0;
  if (i13 >>> 0 < 2) {
   _fill_window(i2);
   i13 = HEAP32[i12 >> 2] | 0;
   if ((i13 | i5 | 0) == 0) {
    i2 = 0;
    i8 = 28;
    break;
   }
   if ((i13 | 0) == 0) {
    i8 = 20;
    break;
   }
  }
  i13 = (HEAP32[i4 >> 2] | 0) + i13 | 0;
  HEAP32[i4 >> 2] = i13;
  HEAP32[i12 >> 2] = 0;
  i14 = HEAP32[i6 >> 2] | 0;
  i15 = i14 + i11 | 0;
  if (!((i13 | 0) != 0 & i13 >>> 0 < i15 >>> 0)) {
   HEAP32[i12 >> 2] = i13 - i15;
   HEAP32[i4 >> 2] = i15;
   if ((i14 | 0) > -1) {
    i13 = (HEAP32[i7 >> 2] | 0) + i14 | 0;
   } else {
    i13 = 0;
   }
   __tr_flush_block(i2, i13, i11, 0);
   HEAP32[i6 >> 2] = HEAP32[i4 >> 2];
   i16 = HEAP32[i2 >> 2] | 0;
   i14 = i16 + 28 | 0;
   i15 = HEAP32[i14 >> 2] | 0;
   i17 = HEAP32[i15 + 20 >> 2] | 0;
   i13 = i16 + 16 | 0;
   i18 = HEAP32[i13 >> 2] | 0;
   i17 = i17 >>> 0 > i18 >>> 0 ? i18 : i17;
   if ((i17 | 0) != 0 ? (i8 = i16 + 12 | 0, _memcpy(HEAP32[i8 >> 2] | 0, HEAP32[i15 + 16 >> 2] | 0, i17 | 0) | 0, HEAP32[i8 >> 2] = (HEAP32[i8 >> 2] | 0) + i17, i8 = (HEAP32[i14 >> 2] | 0) + 16 | 0, HEAP32[i8 >> 2] = (HEAP32[i8 >> 2] | 0) + i17, i8 = i16 + 20 | 0, HEAP32[i8 >> 2] = (HEAP32[i8 >> 2] | 0) + i17, HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) - i17, i8 = HEAP32[i14 >> 2] | 0, i16 = i8 + 20 | 0, i18 = HEAP32[i16 >> 2] | 0, HEAP32[i16 >> 2] = i18 - i17, (i18 | 0) == (i17 | 0)) : 0) {
    HEAP32[i8 + 16 >> 2] = HEAP32[i8 + 8 >> 2];
   }
   if ((HEAP32[(HEAP32[i2 >> 2] | 0) + 16 >> 2] | 0) == 0) {
    i2 = 0;
    i8 = 28;
    break;
   }
   i14 = HEAP32[i6 >> 2] | 0;
   i13 = HEAP32[i4 >> 2] | 0;
  }
  i13 = i13 - i14 | 0;
  if (i13 >>> 0 < ((HEAP32[i10 >> 2] | 0) + -262 | 0) >>> 0) {
   continue;
  }
  if ((i14 | 0) > -1) {
   i14 = (HEAP32[i7 >> 2] | 0) + i14 | 0;
  } else {
   i14 = 0;
  }
  __tr_flush_block(i2, i14, i13, 0);
  HEAP32[i6 >> 2] = HEAP32[i4 >> 2];
  i16 = HEAP32[i2 >> 2] | 0;
  i14 = i16 + 28 | 0;
  i15 = HEAP32[i14 >> 2] | 0;
  i17 = HEAP32[i15 + 20 >> 2] | 0;
  i13 = i16 + 16 | 0;
  i18 = HEAP32[i13 >> 2] | 0;
  i17 = i17 >>> 0 > i18 >>> 0 ? i18 : i17;
  if ((i17 | 0) != 0 ? (i9 = i16 + 12 | 0, _memcpy(HEAP32[i9 >> 2] | 0, HEAP32[i15 + 16 >> 2] | 0, i17 | 0) | 0, HEAP32[i9 >> 2] = (HEAP32[i9 >> 2] | 0) + i17, i9 = (HEAP32[i14 >> 2] | 0) + 16 | 0, HEAP32[i9 >> 2] = (HEAP32[i9 >> 2] | 0) + i17, i9 = i16 + 20 | 0, HEAP32[i9 >> 2] = (HEAP32[i9 >> 2] | 0) + i17, HEAP32[i13 >> 2] = (HEAP32[i13 >> 2] | 0) - i17, i9 = HEAP32[i14 >> 2] | 0, i16 = i9 + 20 | 0, i18 = HEAP32[i16 >> 2] | 0, HEAP32[i16 >> 2] = i18 - i17, (i18 | 0) == (i17 | 0)) : 0) {
   HEAP32[i9 + 16 >> 2] = HEAP32[i9 + 8 >> 2];
  }
  if ((HEAP32[(HEAP32[i2 >> 2] | 0) + 16 >> 2] | 0) == 0) {
   i2 = 0;
   i8 = 28;
   break;
  }
 }
 if ((i8 | 0) == 20) {
  i8 = HEAP32[i6 >> 2] | 0;
  if ((i8 | 0) > -1) {
   i7 = (HEAP32[i7 >> 2] | 0) + i8 | 0;
  } else {
   i7 = 0;
  }
  i5 = (i5 | 0) == 4;
  __tr_flush_block(i2, i7, (HEAP32[i4 >> 2] | 0) - i8 | 0, i5 & 1);
  HEAP32[i6 >> 2] = HEAP32[i4 >> 2];
  i4 = HEAP32[i2 >> 2] | 0;
  i7 = i4 + 28 | 0;
  i6 = HEAP32[i7 >> 2] | 0;
  i9 = HEAP32[i6 + 20 >> 2] | 0;
  i8 = i4 + 16 | 0;
  i10 = HEAP32[i8 >> 2] | 0;
  i9 = i9 >>> 0 > i10 >>> 0 ? i10 : i9;
  if ((i9 | 0) != 0 ? (i3 = i4 + 12 | 0, _memcpy(HEAP32[i3 >> 2] | 0, HEAP32[i6 + 16 >> 2] | 0, i9 | 0) | 0, HEAP32[i3 >> 2] = (HEAP32[i3 >> 2] | 0) + i9, i3 = (HEAP32[i7 >> 2] | 0) + 16 | 0, HEAP32[i3 >> 2] = (HEAP32[i3 >> 2] | 0) + i9, i3 = i4 + 20 | 0, HEAP32[i3 >> 2] = (HEAP32[i3 >> 2] | 0) + i9, HEAP32[i8 >> 2] = (HEAP32[i8 >> 2] | 0) - i9, i3 = HEAP32[i7 >> 2] | 0, i17 = i3 + 20 | 0, i18 = HEAP32[i17 >> 2] | 0, HEAP32[i17 >> 2] = i18 - i9, (i18 | 0) == (i9 | 0)) : 0) {
   HEAP32[i3 + 16 >> 2] = HEAP32[i3 + 8 >> 2];
  }
  if ((HEAP32[(HEAP32[i2 >> 2] | 0) + 16 >> 2] | 0) == 0) {
   i18 = i5 ? 2 : 0;
   STACKTOP = i1;
   return i18 | 0;
  } else {
   i18 = i5 ? 3 : 1;
   STACKTOP = i1;
   return i18 | 0;
  }
 } else if ((i8 | 0) == 28) {
  STACKTOP = i1;
  return i2 | 0;
 }
 return 0;
}
function _fill_window(i15) {
 i15 = i15 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0, i24 = 0;
 i2 = STACKTOP;
 i16 = i15 + 44 | 0;
 i9 = HEAP32[i16 >> 2] | 0;
 i4 = i15 + 60 | 0;
 i8 = i15 + 116 | 0;
 i3 = i15 + 108 | 0;
 i5 = i9 + -262 | 0;
 i1 = i15 + 56 | 0;
 i17 = i15 + 72 | 0;
 i6 = i15 + 88 | 0;
 i7 = i15 + 84 | 0;
 i11 = i15 + 112 | 0;
 i12 = i15 + 92 | 0;
 i13 = i15 + 76 | 0;
 i14 = i15 + 68 | 0;
 i10 = i15 + 64 | 0;
 i19 = HEAP32[i8 >> 2] | 0;
 i21 = i9;
 while (1) {
  i20 = HEAP32[i3 >> 2] | 0;
  i19 = (HEAP32[i4 >> 2] | 0) - i19 - i20 | 0;
  if (!(i20 >>> 0 < (i5 + i21 | 0) >>> 0)) {
   i20 = HEAP32[i1 >> 2] | 0;
   _memcpy(i20 | 0, i20 + i9 | 0, i9 | 0) | 0;
   HEAP32[i11 >> 2] = (HEAP32[i11 >> 2] | 0) - i9;
   i20 = (HEAP32[i3 >> 2] | 0) - i9 | 0;
   HEAP32[i3 >> 2] = i20;
   HEAP32[i12 >> 2] = (HEAP32[i12 >> 2] | 0) - i9;
   i22 = HEAP32[i13 >> 2] | 0;
   i21 = i22;
   i22 = (HEAP32[i14 >> 2] | 0) + (i22 << 1) | 0;
   do {
    i22 = i22 + -2 | 0;
    i23 = HEAPU16[i22 >> 1] | 0;
    if (i23 >>> 0 < i9 >>> 0) {
     i23 = 0;
    } else {
     i23 = i23 - i9 & 65535;
    }
    HEAP16[i22 >> 1] = i23;
    i21 = i21 + -1 | 0;
   } while ((i21 | 0) != 0);
   i22 = i9;
   i21 = (HEAP32[i10 >> 2] | 0) + (i9 << 1) | 0;
   do {
    i21 = i21 + -2 | 0;
    i23 = HEAPU16[i21 >> 1] | 0;
    if (i23 >>> 0 < i9 >>> 0) {
     i23 = 0;
    } else {
     i23 = i23 - i9 & 65535;
    }
    HEAP16[i21 >> 1] = i23;
    i22 = i22 + -1 | 0;
   } while ((i22 | 0) != 0);
   i19 = i19 + i9 | 0;
  }
  i21 = HEAP32[i15 >> 2] | 0;
  i24 = i21 + 4 | 0;
  i23 = HEAP32[i24 >> 2] | 0;
  if ((i23 | 0) == 0) {
   i18 = 28;
   break;
  }
  i22 = HEAP32[i8 >> 2] | 0;
  i20 = (HEAP32[i1 >> 2] | 0) + (i22 + i20) | 0;
  i19 = i23 >>> 0 > i19 >>> 0 ? i19 : i23;
  if ((i19 | 0) == 0) {
   i19 = 0;
  } else {
   HEAP32[i24 >> 2] = i23 - i19;
   i22 = HEAP32[(HEAP32[i21 + 28 >> 2] | 0) + 24 >> 2] | 0;
   if ((i22 | 0) == 1) {
    i22 = i21 + 48 | 0;
    HEAP32[i22 >> 2] = _adler32(HEAP32[i22 >> 2] | 0, HEAP32[i21 >> 2] | 0, i19) | 0;
    i22 = i21;
   } else if ((i22 | 0) == 2) {
    i22 = i21 + 48 | 0;
    HEAP32[i22 >> 2] = _crc32(HEAP32[i22 >> 2] | 0, HEAP32[i21 >> 2] | 0, i19) | 0;
    i22 = i21;
   } else {
    i22 = i21;
   }
   _memcpy(i20 | 0, HEAP32[i22 >> 2] | 0, i19 | 0) | 0;
   HEAP32[i22 >> 2] = (HEAP32[i22 >> 2] | 0) + i19;
   i22 = i21 + 8 | 0;
   HEAP32[i22 >> 2] = (HEAP32[i22 >> 2] | 0) + i19;
   i22 = HEAP32[i8 >> 2] | 0;
  }
  i19 = i22 + i19 | 0;
  HEAP32[i8 >> 2] = i19;
  if (i19 >>> 0 > 2 ? (i23 = HEAP32[i3 >> 2] | 0, i22 = HEAP32[i1 >> 2] | 0, i24 = HEAPU8[i22 + i23 | 0] | 0, HEAP32[i17 >> 2] = i24, HEAP32[i17 >> 2] = ((HEAPU8[i22 + (i23 + 1) | 0] | 0) ^ i24 << HEAP32[i6 >> 2]) & HEAP32[i7 >> 2], !(i19 >>> 0 < 262)) : 0) {
   break;
  }
  if ((HEAP32[(HEAP32[i15 >> 2] | 0) + 4 >> 2] | 0) == 0) {
   break;
  }
  i21 = HEAP32[i16 >> 2] | 0;
 }
 if ((i18 | 0) == 28) {
  STACKTOP = i2;
  return;
 }
 i5 = i15 + 5824 | 0;
 i6 = HEAP32[i5 >> 2] | 0;
 i4 = HEAP32[i4 >> 2] | 0;
 if (!(i6 >>> 0 < i4 >>> 0)) {
  STACKTOP = i2;
  return;
 }
 i3 = i19 + (HEAP32[i3 >> 2] | 0) | 0;
 if (i6 >>> 0 < i3 >>> 0) {
  i4 = i4 - i3 | 0;
  i24 = i4 >>> 0 > 258 ? 258 : i4;
  _memset((HEAP32[i1 >> 2] | 0) + i3 | 0, 0, i24 | 0) | 0;
  HEAP32[i5 >> 2] = i24 + i3;
  STACKTOP = i2;
  return;
 }
 i3 = i3 + 258 | 0;
 if (!(i6 >>> 0 < i3 >>> 0)) {
  STACKTOP = i2;
  return;
 }
 i3 = i3 - i6 | 0;
 i4 = i4 - i6 | 0;
 i24 = i3 >>> 0 > i4 >>> 0 ? i4 : i3;
 _memset((HEAP32[i1 >> 2] | 0) + i6 | 0, 0, i24 | 0) | 0;
 HEAP32[i5 >> 2] = (HEAP32[i5 >> 2] | 0) + i24;
 STACKTOP = i2;
 return;
}
function __tr_align(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0;
 i2 = STACKTOP;
 i3 = i1 + 5820 | 0;
 i6 = HEAP32[i3 >> 2] | 0;
 i4 = i1 + 5816 | 0;
 i7 = HEAPU16[i4 >> 1] | 0 | 2 << i6;
 i5 = i7 & 65535;
 HEAP16[i4 >> 1] = i5;
 if ((i6 | 0) > 13) {
  i8 = i1 + 20 | 0;
  i6 = HEAP32[i8 >> 2] | 0;
  HEAP32[i8 >> 2] = i6 + 1;
  i5 = i1 + 8 | 0;
  HEAP8[(HEAP32[i5 >> 2] | 0) + i6 | 0] = i7;
  i7 = (HEAPU16[i4 >> 1] | 0) >>> 8 & 255;
  i6 = HEAP32[i8 >> 2] | 0;
  HEAP32[i8 >> 2] = i6 + 1;
  HEAP8[(HEAP32[i5 >> 2] | 0) + i6 | 0] = i7;
  i6 = HEAP32[i3 >> 2] | 0;
  i5 = 2 >>> (16 - i6 | 0) & 65535;
  HEAP16[i4 >> 1] = i5;
  i6 = i6 + -13 | 0;
 } else {
  i6 = i6 + 3 | 0;
 }
 HEAP32[i3 >> 2] = i6;
 if ((i6 | 0) > 9) {
  i7 = i1 + 20 | 0;
  i6 = HEAP32[i7 >> 2] | 0;
  HEAP32[i7 >> 2] = i6 + 1;
  i8 = i1 + 8 | 0;
  HEAP8[(HEAP32[i8 >> 2] | 0) + i6 | 0] = i5;
  i5 = (HEAPU16[i4 >> 1] | 0) >>> 8 & 255;
  i6 = HEAP32[i7 >> 2] | 0;
  HEAP32[i7 >> 2] = i6 + 1;
  HEAP8[(HEAP32[i8 >> 2] | 0) + i6 | 0] = i5;
  HEAP16[i4 >> 1] = 0;
  i6 = (HEAP32[i3 >> 2] | 0) + -9 | 0;
  i5 = 0;
 } else {
  i6 = i6 + 7 | 0;
 }
 HEAP32[i3 >> 2] = i6;
 if ((i6 | 0) != 16) {
  if ((i6 | 0) > 7) {
   i6 = i1 + 20 | 0;
   i7 = HEAP32[i6 >> 2] | 0;
   HEAP32[i6 >> 2] = i7 + 1;
   HEAP8[(HEAP32[i1 + 8 >> 2] | 0) + i7 | 0] = i5;
   i7 = (HEAPU16[i4 >> 1] | 0) >>> 8;
   HEAP16[i4 >> 1] = i7;
   i6 = (HEAP32[i3 >> 2] | 0) + -8 | 0;
   HEAP32[i3 >> 2] = i6;
  } else {
   i7 = i5;
  }
 } else {
  i9 = i1 + 20 | 0;
  i8 = HEAP32[i9 >> 2] | 0;
  HEAP32[i9 >> 2] = i8 + 1;
  i7 = i1 + 8 | 0;
  HEAP8[(HEAP32[i7 >> 2] | 0) + i8 | 0] = i5;
  i8 = (HEAPU16[i4 >> 1] | 0) >>> 8 & 255;
  i6 = HEAP32[i9 >> 2] | 0;
  HEAP32[i9 >> 2] = i6 + 1;
  HEAP8[(HEAP32[i7 >> 2] | 0) + i6 | 0] = i8;
  HEAP16[i4 >> 1] = 0;
  HEAP32[i3 >> 2] = 0;
  i6 = 0;
  i7 = 0;
 }
 i5 = i1 + 5812 | 0;
 if ((11 - i6 + (HEAP32[i5 >> 2] | 0) | 0) >= 9) {
  HEAP32[i5 >> 2] = 7;
  STACKTOP = i2;
  return;
 }
 i7 = i7 & 65535 | 2 << i6;
 HEAP16[i4 >> 1] = i7;
 if ((i6 | 0) > 13) {
  i8 = i1 + 20 | 0;
  i6 = HEAP32[i8 >> 2] | 0;
  HEAP32[i8 >> 2] = i6 + 1;
  i9 = i1 + 8 | 0;
  HEAP8[(HEAP32[i9 >> 2] | 0) + i6 | 0] = i7;
  i7 = (HEAPU16[i4 >> 1] | 0) >>> 8 & 255;
  i6 = HEAP32[i8 >> 2] | 0;
  HEAP32[i8 >> 2] = i6 + 1;
  HEAP8[(HEAP32[i9 >> 2] | 0) + i6 | 0] = i7;
  i6 = HEAP32[i3 >> 2] | 0;
  i7 = 2 >>> (16 - i6 | 0);
  HEAP16[i4 >> 1] = i7;
  i6 = i6 + -13 | 0;
 } else {
  i6 = i6 + 3 | 0;
 }
 i7 = i7 & 255;
 HEAP32[i3 >> 2] = i6;
 if ((i6 | 0) > 9) {
  i8 = i1 + 20 | 0;
  i9 = HEAP32[i8 >> 2] | 0;
  HEAP32[i8 >> 2] = i9 + 1;
  i6 = i1 + 8 | 0;
  HEAP8[(HEAP32[i6 >> 2] | 0) + i9 | 0] = i7;
  i9 = (HEAPU16[i4 >> 1] | 0) >>> 8 & 255;
  i7 = HEAP32[i8 >> 2] | 0;
  HEAP32[i8 >> 2] = i7 + 1;
  HEAP8[(HEAP32[i6 >> 2] | 0) + i7 | 0] = i9;
  HEAP16[i4 >> 1] = 0;
  i7 = 0;
  i6 = (HEAP32[i3 >> 2] | 0) + -9 | 0;
 } else {
  i6 = i6 + 7 | 0;
 }
 HEAP32[i3 >> 2] = i6;
 if ((i6 | 0) == 16) {
  i6 = i1 + 20 | 0;
  i9 = HEAP32[i6 >> 2] | 0;
  HEAP32[i6 >> 2] = i9 + 1;
  i8 = i1 + 8 | 0;
  HEAP8[(HEAP32[i8 >> 2] | 0) + i9 | 0] = i7;
  i7 = (HEAPU16[i4 >> 1] | 0) >>> 8 & 255;
  i9 = HEAP32[i6 >> 2] | 0;
  HEAP32[i6 >> 2] = i9 + 1;
  HEAP8[(HEAP32[i8 >> 2] | 0) + i9 | 0] = i7;
  HEAP16[i4 >> 1] = 0;
  HEAP32[i3 >> 2] = 0;
  HEAP32[i5 >> 2] = 7;
  STACKTOP = i2;
  return;
 }
 if ((i6 | 0) <= 7) {
  HEAP32[i5 >> 2] = 7;
  STACKTOP = i2;
  return;
 }
 i8 = i1 + 20 | 0;
 i9 = HEAP32[i8 >> 2] | 0;
 HEAP32[i8 >> 2] = i9 + 1;
 HEAP8[(HEAP32[i1 + 8 >> 2] | 0) + i9 | 0] = i7;
 HEAP16[i4 >> 1] = (HEAPU16[i4 >> 1] | 0) >>> 8;
 HEAP32[i3 >> 2] = (HEAP32[i3 >> 2] | 0) + -8;
 HEAP32[i5 >> 2] = 7;
 STACKTOP = i2;
 return;
}
function _adler32(i6, i4, i5) {
 i6 = i6 | 0;
 i4 = i4 | 0;
 i5 = i5 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0, i17 = 0, i18 = 0, i19 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0;
 i1 = STACKTOP;
 i3 = i6 >>> 16;
 i6 = i6 & 65535;
 if ((i5 | 0) == 1) {
  i2 = (HEAPU8[i4] | 0) + i6 | 0;
  i2 = i2 >>> 0 > 65520 ? i2 + -65521 | 0 : i2;
  i3 = i2 + i3 | 0;
  i8 = (i3 >>> 0 > 65520 ? i3 + 15 | 0 : i3) << 16 | i2;
  STACKTOP = i1;
  return i8 | 0;
 }
 if ((i4 | 0) == 0) {
  i8 = 1;
  STACKTOP = i1;
  return i8 | 0;
 }
 if (i5 >>> 0 < 16) {
  if ((i5 | 0) != 0) {
   while (1) {
    i5 = i5 + -1 | 0;
    i6 = (HEAPU8[i4] | 0) + i6 | 0;
    i3 = i6 + i3 | 0;
    if ((i5 | 0) == 0) {
     break;
    } else {
     i4 = i4 + 1 | 0;
    }
   }
  }
  i8 = ((i3 >>> 0) % 65521 | 0) << 16 | (i6 >>> 0 > 65520 ? i6 + -65521 | 0 : i6);
  STACKTOP = i1;
  return i8 | 0;
 }
 if (i5 >>> 0 > 5551) {
  do {
   i5 = i5 + -5552 | 0;
   i7 = i4;
   i8 = 347;
   while (1) {
    i23 = (HEAPU8[i7] | 0) + i6 | 0;
    i22 = i23 + (HEAPU8[i7 + 1 | 0] | 0) | 0;
    i21 = i22 + (HEAPU8[i7 + 2 | 0] | 0) | 0;
    i20 = i21 + (HEAPU8[i7 + 3 | 0] | 0) | 0;
    i19 = i20 + (HEAPU8[i7 + 4 | 0] | 0) | 0;
    i18 = i19 + (HEAPU8[i7 + 5 | 0] | 0) | 0;
    i17 = i18 + (HEAPU8[i7 + 6 | 0] | 0) | 0;
    i16 = i17 + (HEAPU8[i7 + 7 | 0] | 0) | 0;
    i15 = i16 + (HEAPU8[i7 + 8 | 0] | 0) | 0;
    i14 = i15 + (HEAPU8[i7 + 9 | 0] | 0) | 0;
    i13 = i14 + (HEAPU8[i7 + 10 | 0] | 0) | 0;
    i12 = i13 + (HEAPU8[i7 + 11 | 0] | 0) | 0;
    i11 = i12 + (HEAPU8[i7 + 12 | 0] | 0) | 0;
    i10 = i11 + (HEAPU8[i7 + 13 | 0] | 0) | 0;
    i9 = i10 + (HEAPU8[i7 + 14 | 0] | 0) | 0;
    i6 = i9 + (HEAPU8[i7 + 15 | 0] | 0) | 0;
    i3 = i23 + i3 + i22 + i21 + i20 + i19 + i18 + i17 + i16 + i15 + i14 + i13 + i12 + i11 + i10 + i9 + i6 | 0;
    i8 = i8 + -1 | 0;
    if ((i8 | 0) == 0) {
     break;
    } else {
     i7 = i7 + 16 | 0;
    }
   }
   i4 = i4 + 5552 | 0;
   i6 = (i6 >>> 0) % 65521 | 0;
   i3 = (i3 >>> 0) % 65521 | 0;
  } while (i5 >>> 0 > 5551);
  if ((i5 | 0) != 0) {
   if (i5 >>> 0 > 15) {
    i2 = 15;
   } else {
    i2 = 16;
   }
  }
 } else {
  i2 = 15;
 }
 if ((i2 | 0) == 15) {
  while (1) {
   i5 = i5 + -16 | 0;
   i9 = (HEAPU8[i4] | 0) + i6 | 0;
   i10 = i9 + (HEAPU8[i4 + 1 | 0] | 0) | 0;
   i11 = i10 + (HEAPU8[i4 + 2 | 0] | 0) | 0;
   i12 = i11 + (HEAPU8[i4 + 3 | 0] | 0) | 0;
   i13 = i12 + (HEAPU8[i4 + 4 | 0] | 0) | 0;
   i14 = i13 + (HEAPU8[i4 + 5 | 0] | 0) | 0;
   i15 = i14 + (HEAPU8[i4 + 6 | 0] | 0) | 0;
   i16 = i15 + (HEAPU8[i4 + 7 | 0] | 0) | 0;
   i17 = i16 + (HEAPU8[i4 + 8 | 0] | 0) | 0;
   i18 = i17 + (HEAPU8[i4 + 9 | 0] | 0) | 0;
   i19 = i18 + (HEAPU8[i4 + 10 | 0] | 0) | 0;
   i20 = i19 + (HEAPU8[i4 + 11 | 0] | 0) | 0;
   i21 = i20 + (HEAPU8[i4 + 12 | 0] | 0) | 0;
   i22 = i21 + (HEAPU8[i4 + 13 | 0] | 0) | 0;
   i23 = i22 + (HEAPU8[i4 + 14 | 0] | 0) | 0;
   i6 = i23 + (HEAPU8[i4 + 15 | 0] | 0) | 0;
   i3 = i9 + i3 + i10 + i11 + i12 + i13 + i14 + i15 + i16 + i17 + i18 + i19 + i20 + i21 + i22 + i23 + i6 | 0;
   i4 = i4 + 16 | 0;
   if (!(i5 >>> 0 > 15)) {
    break;
   } else {
    i2 = 15;
   }
  }
  if ((i5 | 0) == 0) {
   i2 = 17;
  } else {
   i2 = 16;
  }
 }
 if ((i2 | 0) == 16) {
  while (1) {
   i5 = i5 + -1 | 0;
   i6 = (HEAPU8[i4] | 0) + i6 | 0;
   i3 = i6 + i3 | 0;
   if ((i5 | 0) == 0) {
    i2 = 17;
    break;
   } else {
    i4 = i4 + 1 | 0;
    i2 = 16;
   }
  }
 }
 if ((i2 | 0) == 17) {
  i6 = (i6 >>> 0) % 65521 | 0;
  i3 = (i3 >>> 0) % 65521 | 0;
 }
 i23 = i3 << 16 | i6;
 STACKTOP = i1;
 return i23 | 0;
}
function _crc32(i4, i2, i3) {
 i4 = i4 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 var i1 = 0, i5 = 0;
 i1 = STACKTOP;
 if ((i2 | 0) == 0) {
  i5 = 0;
  STACKTOP = i1;
  return i5 | 0;
 }
 i4 = ~i4;
 L4 : do {
  if ((i3 | 0) != 0) {
   while (1) {
    if ((i2 & 3 | 0) == 0) {
     break;
    }
    i4 = HEAP32[3192 + (((HEAPU8[i2] | 0) ^ i4 & 255) << 2) >> 2] ^ i4 >>> 8;
    i3 = i3 + -1 | 0;
    if ((i3 | 0) == 0) {
     break L4;
    } else {
     i2 = i2 + 1 | 0;
    }
   }
   if (i3 >>> 0 > 31) {
    while (1) {
     i4 = HEAP32[i2 >> 2] ^ i4;
     i4 = HEAP32[5240 + ((i4 >>> 8 & 255) << 2) >> 2] ^ HEAP32[6264 + ((i4 & 255) << 2) >> 2] ^ HEAP32[4216 + ((i4 >>> 16 & 255) << 2) >> 2] ^ HEAP32[3192 + (i4 >>> 24 << 2) >> 2] ^ HEAP32[i2 + 4 >> 2];
     i4 = HEAP32[5240 + ((i4 >>> 8 & 255) << 2) >> 2] ^ HEAP32[6264 + ((i4 & 255) << 2) >> 2] ^ HEAP32[4216 + ((i4 >>> 16 & 255) << 2) >> 2] ^ HEAP32[3192 + (i4 >>> 24 << 2) >> 2] ^ HEAP32[i2 + 8 >> 2];
     i4 = HEAP32[5240 + ((i4 >>> 8 & 255) << 2) >> 2] ^ HEAP32[6264 + ((i4 & 255) << 2) >> 2] ^ HEAP32[4216 + ((i4 >>> 16 & 255) << 2) >> 2] ^ HEAP32[3192 + (i4 >>> 24 << 2) >> 2] ^ HEAP32[i2 + 12 >> 2];
     i4 = HEAP32[5240 + ((i4 >>> 8 & 255) << 2) >> 2] ^ HEAP32[6264 + ((i4 & 255) << 2) >> 2] ^ HEAP32[4216 + ((i4 >>> 16 & 255) << 2) >> 2] ^ HEAP32[3192 + (i4 >>> 24 << 2) >> 2] ^ HEAP32[i2 + 16 >> 2];
     i4 = HEAP32[5240 + ((i4 >>> 8 & 255) << 2) >> 2] ^ HEAP32[6264 + ((i4 & 255) << 2) >> 2] ^ HEAP32[4216 + ((i4 >>> 16 & 255) << 2) >> 2] ^ HEAP32[3192 + (i4 >>> 24 << 2) >> 2] ^ HEAP32[i2 + 20 >> 2];
     i4 = HEAP32[5240 + ((i4 >>> 8 & 255) << 2) >> 2] ^ HEAP32[6264 + ((i4 & 255) << 2) >> 2] ^ HEAP32[4216 + ((i4 >>> 16 & 255) << 2) >> 2] ^ HEAP32[3192 + (i4 >>> 24 << 2) >> 2] ^ HEAP32[i2 + 24 >> 2];
     i5 = i2 + 32 | 0;
     i4 = HEAP32[5240 + ((i4 >>> 8 & 255) << 2) >> 2] ^ HEAP32[6264 + ((i4 & 255) << 2) >> 2] ^ HEAP32[4216 + ((i4 >>> 16 & 255) << 2) >> 2] ^ HEAP32[3192 + (i4 >>> 24 << 2) >> 2] ^ HEAP32[i2 + 28 >> 2];
     i4 = HEAP32[5240 + ((i4 >>> 8 & 255) << 2) >> 2] ^ HEAP32[6264 + ((i4 & 255) << 2) >> 2] ^ HEAP32[4216 + ((i4 >>> 16 & 255) << 2) >> 2] ^ HEAP32[3192 + (i4 >>> 24 << 2) >> 2];
     i3 = i3 + -32 | 0;
     if (i3 >>> 0 > 31) {
      i2 = i5;
     } else {
      i2 = i5;
      break;
     }
    }
   }
   if (i3 >>> 0 > 3) {
    while (1) {
     i5 = i2 + 4 | 0;
     i4 = HEAP32[i2 >> 2] ^ i4;
     i4 = HEAP32[5240 + ((i4 >>> 8 & 255) << 2) >> 2] ^ HEAP32[6264 + ((i4 & 255) << 2) >> 2] ^ HEAP32[4216 + ((i4 >>> 16 & 255) << 2) >> 2] ^ HEAP32[3192 + (i4 >>> 24 << 2) >> 2];
     i3 = i3 + -4 | 0;
     if (i3 >>> 0 > 3) {
      i2 = i5;
     } else {
      i2 = i5;
      break;
     }
    }
   }
   if ((i3 | 0) != 0) {
    while (1) {
     i4 = HEAP32[3192 + (((HEAPU8[i2] | 0) ^ i4 & 255) << 2) >> 2] ^ i4 >>> 8;
     i3 = i3 + -1 | 0;
     if ((i3 | 0) == 0) {
      break;
     } else {
      i2 = i2 + 1 | 0;
     }
    }
   }
  }
 } while (0);
 i5 = ~i4;
 STACKTOP = i1;
 return i5 | 0;
}
function _deflateInit2_(i3, i7, i8, i10, i4, i1, i5, i6) {
 i3 = i3 | 0;
 i7 = i7 | 0;
 i8 = i8 | 0;
 i10 = i10 | 0;
 i4 = i4 | 0;
 i1 = i1 | 0;
 i5 = i5 | 0;
 i6 = i6 | 0;
 var i2 = 0, i9 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0;
 i2 = STACKTOP;
 if ((i5 | 0) == 0) {
  i12 = -6;
  STACKTOP = i2;
  return i12 | 0;
 }
 if (!((HEAP8[i5] | 0) == 49 & (i6 | 0) == 56)) {
  i12 = -6;
  STACKTOP = i2;
  return i12 | 0;
 }
 if ((i3 | 0) == 0) {
  i12 = -2;
  STACKTOP = i2;
  return i12 | 0;
 }
 i5 = i3 + 24 | 0;
 HEAP32[i5 >> 2] = 0;
 i6 = i3 + 32 | 0;
 i9 = HEAP32[i6 >> 2] | 0;
 if ((i9 | 0) == 0) {
  HEAP32[i6 >> 2] = 1;
  HEAP32[i3 + 40 >> 2] = 0;
  i9 = 1;
 }
 i11 = i3 + 36 | 0;
 if ((HEAP32[i11 >> 2] | 0) == 0) {
  HEAP32[i11 >> 2] = 1;
 }
 i7 = (i7 | 0) == -1 ? 6 : i7;
 if ((i10 | 0) < 0) {
  i10 = 0 - i10 | 0;
  i11 = 0;
 } else {
  i11 = (i10 | 0) > 15;
  i10 = i11 ? i10 + -16 | 0 : i10;
  i11 = i11 ? 2 : 1;
 }
 if (!((i4 + -1 | 0) >>> 0 < 9 & (i8 | 0) == 8)) {
  i12 = -2;
  STACKTOP = i2;
  return i12 | 0;
 }
 if ((i10 + -8 | 0) >>> 0 > 7 | i7 >>> 0 > 9 | i1 >>> 0 > 4) {
  i12 = -2;
  STACKTOP = i2;
  return i12 | 0;
 }
 i12 = (i10 | 0) == 8 ? 9 : i10;
 i10 = i3 + 40 | 0;
 i8 = FUNCTION_TABLE_iiii[i9 & 1](HEAP32[i10 >> 2] | 0, 1, 5828) | 0;
 if ((i8 | 0) == 0) {
  i12 = -4;
  STACKTOP = i2;
  return i12 | 0;
 }
 HEAP32[i3 + 28 >> 2] = i8;
 HEAP32[i8 >> 2] = i3;
 HEAP32[i8 + 24 >> 2] = i11;
 HEAP32[i8 + 28 >> 2] = 0;
 HEAP32[i8 + 48 >> 2] = i12;
 i14 = 1 << i12;
 i11 = i8 + 44 | 0;
 HEAP32[i11 >> 2] = i14;
 HEAP32[i8 + 52 >> 2] = i14 + -1;
 i12 = i4 + 7 | 0;
 HEAP32[i8 + 80 >> 2] = i12;
 i12 = 1 << i12;
 i13 = i8 + 76 | 0;
 HEAP32[i13 >> 2] = i12;
 HEAP32[i8 + 84 >> 2] = i12 + -1;
 HEAP32[i8 + 88 >> 2] = ((i4 + 9 | 0) >>> 0) / 3 | 0;
 i12 = i8 + 56 | 0;
 HEAP32[i12 >> 2] = FUNCTION_TABLE_iiii[HEAP32[i6 >> 2] & 1](HEAP32[i10 >> 2] | 0, i14, 2) | 0;
 i14 = FUNCTION_TABLE_iiii[HEAP32[i6 >> 2] & 1](HEAP32[i10 >> 2] | 0, HEAP32[i11 >> 2] | 0, 2) | 0;
 i9 = i8 + 64 | 0;
 HEAP32[i9 >> 2] = i14;
 _memset(i14 | 0, 0, HEAP32[i11 >> 2] << 1 | 0) | 0;
 i11 = i8 + 68 | 0;
 HEAP32[i11 >> 2] = FUNCTION_TABLE_iiii[HEAP32[i6 >> 2] & 1](HEAP32[i10 >> 2] | 0, HEAP32[i13 >> 2] | 0, 2) | 0;
 HEAP32[i8 + 5824 >> 2] = 0;
 i4 = 1 << i4 + 6;
 i13 = i8 + 5788 | 0;
 HEAP32[i13 >> 2] = i4;
 i4 = FUNCTION_TABLE_iiii[HEAP32[i6 >> 2] & 1](HEAP32[i10 >> 2] | 0, i4, 4) | 0;
 HEAP32[i8 + 8 >> 2] = i4;
 i6 = HEAP32[i13 >> 2] | 0;
 HEAP32[i8 + 12 >> 2] = i6 << 2;
 if (((HEAP32[i12 >> 2] | 0) != 0 ? (HEAP32[i9 >> 2] | 0) != 0 : 0) ? !((HEAP32[i11 >> 2] | 0) == 0 | (i4 | 0) == 0) : 0) {
  HEAP32[i8 + 5796 >> 2] = i4 + (i6 >>> 1 << 1);
  HEAP32[i8 + 5784 >> 2] = i4 + (i6 * 3 | 0);
  HEAP32[i8 + 132 >> 2] = i7;
  HEAP32[i8 + 136 >> 2] = i1;
  HEAP8[i8 + 36 | 0] = 8;
  i14 = _deflateReset(i3) | 0;
  STACKTOP = i2;
  return i14 | 0;
 }
 HEAP32[i8 + 4 >> 2] = 666;
 HEAP32[i5 >> 2] = HEAP32[3176 >> 2];
 _deflateEnd(i3) | 0;
 i14 = -4;
 STACKTOP = i2;
 return i14 | 0;
}
function _longest_match(i19, i16) {
 i19 = i19 | 0;
 i16 = i16 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i4 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i17 = 0, i18 = 0, i20 = 0, i21 = 0, i22 = 0, i23 = 0;
 i1 = STACKTOP;
 i18 = HEAP32[i19 + 124 >> 2] | 0;
 i3 = HEAP32[i19 + 56 >> 2] | 0;
 i5 = HEAP32[i19 + 108 >> 2] | 0;
 i4 = i3 + i5 | 0;
 i20 = HEAP32[i19 + 120 >> 2] | 0;
 i10 = HEAP32[i19 + 144 >> 2] | 0;
 i2 = (HEAP32[i19 + 44 >> 2] | 0) + -262 | 0;
 i8 = i5 >>> 0 > i2 >>> 0 ? i5 - i2 | 0 : 0;
 i6 = HEAP32[i19 + 64 >> 2] | 0;
 i7 = HEAP32[i19 + 52 >> 2] | 0;
 i9 = i3 + (i5 + 258) | 0;
 i2 = HEAP32[i19 + 116 >> 2] | 0;
 i12 = i10 >>> 0 > i2 >>> 0 ? i2 : i10;
 i11 = i19 + 112 | 0;
 i15 = i3 + (i5 + 1) | 0;
 i14 = i3 + (i5 + 2) | 0;
 i13 = i9;
 i10 = i5 + 257 | 0;
 i17 = i20;
 i18 = i20 >>> 0 < (HEAP32[i19 + 140 >> 2] | 0) >>> 0 ? i18 : i18 >>> 2;
 i19 = HEAP8[i3 + (i20 + i5) | 0] | 0;
 i20 = HEAP8[i3 + (i5 + -1 + i20) | 0] | 0;
 while (1) {
  i21 = i3 + i16 | 0;
  if ((((HEAP8[i3 + (i16 + i17) | 0] | 0) == i19 << 24 >> 24 ? (HEAP8[i3 + (i17 + -1 + i16) | 0] | 0) == i20 << 24 >> 24 : 0) ? (HEAP8[i21] | 0) == (HEAP8[i4] | 0) : 0) ? (HEAP8[i3 + (i16 + 1) | 0] | 0) == (HEAP8[i15] | 0) : 0) {
   i21 = i3 + (i16 + 2) | 0;
   i22 = i14;
   do {
    i23 = i22 + 1 | 0;
    if ((HEAP8[i23] | 0) != (HEAP8[i21 + 1 | 0] | 0)) {
     i22 = i23;
     break;
    }
    i23 = i22 + 2 | 0;
    if ((HEAP8[i23] | 0) != (HEAP8[i21 + 2 | 0] | 0)) {
     i22 = i23;
     break;
    }
    i23 = i22 + 3 | 0;
    if ((HEAP8[i23] | 0) != (HEAP8[i21 + 3 | 0] | 0)) {
     i22 = i23;
     break;
    }
    i23 = i22 + 4 | 0;
    if ((HEAP8[i23] | 0) != (HEAP8[i21 + 4 | 0] | 0)) {
     i22 = i23;
     break;
    }
    i23 = i22 + 5 | 0;
    if ((HEAP8[i23] | 0) != (HEAP8[i21 + 5 | 0] | 0)) {
     i22 = i23;
     break;
    }
    i23 = i22 + 6 | 0;
    if ((HEAP8[i23] | 0) != (HEAP8[i21 + 6 | 0] | 0)) {
     i22 = i23;
     break;
    }
    i23 = i22 + 7 | 0;
    if ((HEAP8[i23] | 0) != (HEAP8[i21 + 7 | 0] | 0)) {
     i22 = i23;
     break;
    }
    i22 = i22 + 8 | 0;
    i21 = i21 + 8 | 0;
   } while ((HEAP8[i22] | 0) == (HEAP8[i21] | 0) & i22 >>> 0 < i9 >>> 0);
   i21 = i22 - i13 | 0;
   i22 = i21 + 258 | 0;
   if ((i22 | 0) > (i17 | 0)) {
    HEAP32[i11 >> 2] = i16;
    if ((i22 | 0) >= (i12 | 0)) {
     i17 = i22;
     i3 = 20;
     break;
    }
    i17 = i22;
    i19 = HEAP8[i3 + (i22 + i5) | 0] | 0;
    i20 = HEAP8[i3 + (i10 + i21) | 0] | 0;
   }
  }
  i16 = HEAPU16[i6 + ((i16 & i7) << 1) >> 1] | 0;
  if (!(i16 >>> 0 > i8 >>> 0)) {
   i3 = 20;
   break;
  }
  i18 = i18 + -1 | 0;
  if ((i18 | 0) == 0) {
   i3 = 20;
   break;
  }
 }
 if ((i3 | 0) == 20) {
  STACKTOP = i1;
  return (i17 >>> 0 > i2 >>> 0 ? i2 : i17) | 0;
 }
 return 0;
}
function __tr_stored_block(i3, i2, i5, i6) {
 i3 = i3 | 0;
 i2 = i2 | 0;
 i5 = i5 | 0;
 i6 = i6 | 0;
 var i1 = 0, i4 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0;
 i1 = STACKTOP;
 i4 = i3 + 5820 | 0;
 i7 = HEAP32[i4 >> 2] | 0;
 i9 = i6 & 65535;
 i6 = i3 + 5816 | 0;
 i8 = HEAPU16[i6 >> 1] | 0 | i9 << i7;
 HEAP16[i6 >> 1] = i8;
 if ((i7 | 0) > 13) {
  i11 = i3 + 20 | 0;
  i7 = HEAP32[i11 >> 2] | 0;
  HEAP32[i11 >> 2] = i7 + 1;
  i10 = i3 + 8 | 0;
  HEAP8[(HEAP32[i10 >> 2] | 0) + i7 | 0] = i8;
  i8 = (HEAPU16[i6 >> 1] | 0) >>> 8 & 255;
  i7 = HEAP32[i11 >> 2] | 0;
  HEAP32[i11 >> 2] = i7 + 1;
  HEAP8[(HEAP32[i10 >> 2] | 0) + i7 | 0] = i8;
  i7 = HEAP32[i4 >> 2] | 0;
  i8 = i9 >>> (16 - i7 | 0);
  HEAP16[i6 >> 1] = i8;
  i7 = i7 + -13 | 0;
 } else {
  i7 = i7 + 3 | 0;
 }
 i8 = i8 & 255;
 HEAP32[i4 >> 2] = i7;
 do {
  if ((i7 | 0) <= 8) {
   i9 = i3 + 20 | 0;
   if ((i7 | 0) > 0) {
    i7 = HEAP32[i9 >> 2] | 0;
    HEAP32[i9 >> 2] = i7 + 1;
    i11 = i3 + 8 | 0;
    HEAP8[(HEAP32[i11 >> 2] | 0) + i7 | 0] = i8;
    i7 = i9;
    i8 = i11;
    break;
   } else {
    i7 = i9;
    i8 = i3 + 8 | 0;
    break;
   }
  } else {
   i7 = i3 + 20 | 0;
   i10 = HEAP32[i7 >> 2] | 0;
   HEAP32[i7 >> 2] = i10 + 1;
   i11 = i3 + 8 | 0;
   HEAP8[(HEAP32[i11 >> 2] | 0) + i10 | 0] = i8;
   i10 = (HEAPU16[i6 >> 1] | 0) >>> 8 & 255;
   i8 = HEAP32[i7 >> 2] | 0;
   HEAP32[i7 >> 2] = i8 + 1;
   HEAP8[(HEAP32[i11 >> 2] | 0) + i8 | 0] = i10;
   i8 = i11;
  }
 } while (0);
 HEAP16[i6 >> 1] = 0;
 HEAP32[i4 >> 2] = 0;
 HEAP32[i3 + 5812 >> 2] = 8;
 i10 = HEAP32[i7 >> 2] | 0;
 HEAP32[i7 >> 2] = i10 + 1;
 HEAP8[(HEAP32[i8 >> 2] | 0) + i10 | 0] = i5;
 i10 = HEAP32[i7 >> 2] | 0;
 HEAP32[i7 >> 2] = i10 + 1;
 HEAP8[(HEAP32[i8 >> 2] | 0) + i10 | 0] = i5 >>> 8;
 i10 = i5 & 65535 ^ 65535;
 i11 = HEAP32[i7 >> 2] | 0;
 HEAP32[i7 >> 2] = i11 + 1;
 HEAP8[(HEAP32[i8 >> 2] | 0) + i11 | 0] = i10;
 i11 = HEAP32[i7 >> 2] | 0;
 HEAP32[i7 >> 2] = i11 + 1;
 HEAP8[(HEAP32[i8 >> 2] | 0) + i11 | 0] = i10 >>> 8;
 if ((i5 | 0) == 0) {
  STACKTOP = i1;
  return;
 }
 while (1) {
  i5 = i5 + -1 | 0;
  i10 = HEAP8[i2] | 0;
  i11 = HEAP32[i7 >> 2] | 0;
  HEAP32[i7 >> 2] = i11 + 1;
  HEAP8[(HEAP32[i8 >> 2] | 0) + i11 | 0] = i10;
  if ((i5 | 0) == 0) {
   break;
  } else {
   i2 = i2 + 1 | 0;
  }
 }
 STACKTOP = i1;
 return;
}
function _inflateInit_(i1, i3, i4) {
 i1 = i1 | 0;
 i3 = i3 | 0;
 i4 = i4 | 0;
 var i2 = 0, i5 = 0, i6 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0;
 i2 = STACKTOP;
 if ((i3 | 0) == 0) {
  i11 = -6;
  STACKTOP = i2;
  return i11 | 0;
 }
 if (!((HEAP8[i3] | 0) == 49 & (i4 | 0) == 56)) {
  i11 = -6;
  STACKTOP = i2;
  return i11 | 0;
 }
 if ((i1 | 0) == 0) {
  i11 = -2;
  STACKTOP = i2;
  return i11 | 0;
 }
 i3 = i1 + 24 | 0;
 HEAP32[i3 >> 2] = 0;
 i4 = i1 + 32 | 0;
 i6 = HEAP32[i4 >> 2] | 0;
 if ((i6 | 0) == 0) {
  HEAP32[i4 >> 2] = 1;
  HEAP32[i1 + 40 >> 2] = 0;
  i6 = 1;
 }
 i4 = i1 + 36 | 0;
 if ((HEAP32[i4 >> 2] | 0) == 0) {
  HEAP32[i4 >> 2] = 1;
 }
 i5 = i1 + 40 | 0;
 i8 = FUNCTION_TABLE_iiii[i6 & 1](HEAP32[i5 >> 2] | 0, 1, 7116) | 0;
 if ((i8 | 0) == 0) {
  i11 = -4;
  STACKTOP = i2;
  return i11 | 0;
 }
 i6 = i1 + 28 | 0;
 HEAP32[i6 >> 2] = i8;
 HEAP32[i8 + 52 >> 2] = 0;
 i9 = HEAP32[i6 >> 2] | 0;
 do {
  if ((i9 | 0) != 0) {
   i10 = i9 + 52 | 0;
   i11 = HEAP32[i10 >> 2] | 0;
   i7 = i9 + 36 | 0;
   if ((i11 | 0) != 0) {
    if ((HEAP32[i7 >> 2] | 0) == 15) {
     i10 = i9;
    } else {
     FUNCTION_TABLE_vii[HEAP32[i4 >> 2] & 1](HEAP32[i5 >> 2] | 0, i11);
     HEAP32[i10 >> 2] = 0;
     i10 = HEAP32[i6 >> 2] | 0;
    }
    HEAP32[i9 + 8 >> 2] = 1;
    HEAP32[i7 >> 2] = 15;
    if ((i10 | 0) == 0) {
     break;
    } else {
     i9 = i10;
    }
   } else {
    HEAP32[i9 + 8 >> 2] = 1;
    HEAP32[i7 >> 2] = 15;
   }
   HEAP32[i9 + 28 >> 2] = 0;
   HEAP32[i1 + 20 >> 2] = 0;
   HEAP32[i1 + 8 >> 2] = 0;
   HEAP32[i3 >> 2] = 0;
   HEAP32[i1 + 48 >> 2] = 1;
   HEAP32[i9 >> 2] = 0;
   HEAP32[i9 + 4 >> 2] = 0;
   HEAP32[i9 + 12 >> 2] = 0;
   HEAP32[i9 + 20 >> 2] = 32768;
   HEAP32[i9 + 32 >> 2] = 0;
   HEAP32[i9 + 40 >> 2] = 0;
   HEAP32[i9 + 44 >> 2] = 0;
   HEAP32[i9 + 48 >> 2] = 0;
   HEAP32[i9 + 56 >> 2] = 0;
   HEAP32[i9 + 60 >> 2] = 0;
   i11 = i9 + 1328 | 0;
   HEAP32[i9 + 108 >> 2] = i11;
   HEAP32[i9 + 80 >> 2] = i11;
   HEAP32[i9 + 76 >> 2] = i11;
   HEAP32[i9 + 7104 >> 2] = 1;
   HEAP32[i9 + 7108 >> 2] = -1;
   i11 = 0;
   STACKTOP = i2;
   return i11 | 0;
  }
 } while (0);
 FUNCTION_TABLE_vii[HEAP32[i4 >> 2] & 1](HEAP32[i5 >> 2] | 0, i8);
 HEAP32[i6 >> 2] = 0;
 i11 = -2;
 STACKTOP = i2;
 return i11 | 0;
}
function _init_block(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0;
 i2 = STACKTOP;
 i3 = 0;
 do {
  HEAP16[i1 + (i3 << 2) + 148 >> 1] = 0;
  i3 = i3 + 1 | 0;
 } while ((i3 | 0) != 286);
 HEAP16[i1 + 2440 >> 1] = 0;
 HEAP16[i1 + 2444 >> 1] = 0;
 HEAP16[i1 + 2448 >> 1] = 0;
 HEAP16[i1 + 2452 >> 1] = 0;
 HEAP16[i1 + 2456 >> 1] = 0;
 HEAP16[i1 + 2460 >> 1] = 0;
 HEAP16[i1 + 2464 >> 1] = 0;
 HEAP16[i1 + 2468 >> 1] = 0;
 HEAP16[i1 + 2472 >> 1] = 0;
 HEAP16[i1 + 2476 >> 1] = 0;
 HEAP16[i1 + 2480 >> 1] = 0;
 HEAP16[i1 + 2484 >> 1] = 0;
 HEAP16[i1 + 2488 >> 1] = 0;
 HEAP16[i1 + 2492 >> 1] = 0;
 HEAP16[i1 + 2496 >> 1] = 0;
 HEAP16[i1 + 2500 >> 1] = 0;
 HEAP16[i1 + 2504 >> 1] = 0;
 HEAP16[i1 + 2508 >> 1] = 0;
 HEAP16[i1 + 2512 >> 1] = 0;
 HEAP16[i1 + 2516 >> 1] = 0;
 HEAP16[i1 + 2520 >> 1] = 0;
 HEAP16[i1 + 2524 >> 1] = 0;
 HEAP16[i1 + 2528 >> 1] = 0;
 HEAP16[i1 + 2532 >> 1] = 0;
 HEAP16[i1 + 2536 >> 1] = 0;
 HEAP16[i1 + 2540 >> 1] = 0;
 HEAP16[i1 + 2544 >> 1] = 0;
 HEAP16[i1 + 2548 >> 1] = 0;
 HEAP16[i1 + 2552 >> 1] = 0;
 HEAP16[i1 + 2556 >> 1] = 0;
 HEAP16[i1 + 2684 >> 1] = 0;
 HEAP16[i1 + 2688 >> 1] = 0;
 HEAP16[i1 + 2692 >> 1] = 0;
 HEAP16[i1 + 2696 >> 1] = 0;
 HEAP16[i1 + 2700 >> 1] = 0;
 HEAP16[i1 + 2704 >> 1] = 0;
 HEAP16[i1 + 2708 >> 1] = 0;
 HEAP16[i1 + 2712 >> 1] = 0;
 HEAP16[i1 + 2716 >> 1] = 0;
 HEAP16[i1 + 2720 >> 1] = 0;
 HEAP16[i1 + 2724 >> 1] = 0;
 HEAP16[i1 + 2728 >> 1] = 0;
 HEAP16[i1 + 2732 >> 1] = 0;
 HEAP16[i1 + 2736 >> 1] = 0;
 HEAP16[i1 + 2740 >> 1] = 0;
 HEAP16[i1 + 2744 >> 1] = 0;
 HEAP16[i1 + 2748 >> 1] = 0;
 HEAP16[i1 + 2752 >> 1] = 0;
 HEAP16[i1 + 2756 >> 1] = 0;
 HEAP16[i1 + 1172 >> 1] = 1;
 HEAP32[i1 + 5804 >> 2] = 0;
 HEAP32[i1 + 5800 >> 2] = 0;
 HEAP32[i1 + 5808 >> 2] = 0;
 HEAP32[i1 + 5792 >> 2] = 0;
 STACKTOP = i2;
 return;
}
function _deflateReset(i1) {
 i1 = i1 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0;
 i2 = STACKTOP;
 if ((i1 | 0) == 0) {
  i5 = -2;
  STACKTOP = i2;
  return i5 | 0;
 }
 i3 = HEAP32[i1 + 28 >> 2] | 0;
 if ((i3 | 0) == 0) {
  i5 = -2;
  STACKTOP = i2;
  return i5 | 0;
 }
 if ((HEAP32[i1 + 32 >> 2] | 0) == 0) {
  i5 = -2;
  STACKTOP = i2;
  return i5 | 0;
 }
 if ((HEAP32[i1 + 36 >> 2] | 0) == 0) {
  i5 = -2;
  STACKTOP = i2;
  return i5 | 0;
 }
 HEAP32[i1 + 20 >> 2] = 0;
 HEAP32[i1 + 8 >> 2] = 0;
 HEAP32[i1 + 24 >> 2] = 0;
 HEAP32[i1 + 44 >> 2] = 2;
 HEAP32[i3 + 20 >> 2] = 0;
 HEAP32[i3 + 16 >> 2] = HEAP32[i3 + 8 >> 2];
 i4 = i3 + 24 | 0;
 i5 = HEAP32[i4 >> 2] | 0;
 if ((i5 | 0) < 0) {
  i5 = 0 - i5 | 0;
  HEAP32[i4 >> 2] = i5;
 }
 HEAP32[i3 + 4 >> 2] = (i5 | 0) != 0 ? 42 : 113;
 if ((i5 | 0) == 2) {
  i4 = _crc32(0, 0, 0) | 0;
 } else {
  i4 = _adler32(0, 0, 0) | 0;
 }
 HEAP32[i1 + 48 >> 2] = i4;
 HEAP32[i3 + 40 >> 2] = 0;
 __tr_init(i3);
 HEAP32[i3 + 60 >> 2] = HEAP32[i3 + 44 >> 2] << 1;
 i5 = HEAP32[i3 + 76 >> 2] | 0;
 i4 = HEAP32[i3 + 68 >> 2] | 0;
 HEAP16[i4 + (i5 + -1 << 1) >> 1] = 0;
 _memset(i4 | 0, 0, (i5 << 1) + -2 | 0) | 0;
 i5 = HEAP32[i3 + 132 >> 2] | 0;
 HEAP32[i3 + 128 >> 2] = HEAPU16[178 + (i5 * 12 | 0) >> 1] | 0;
 HEAP32[i3 + 140 >> 2] = HEAPU16[176 + (i5 * 12 | 0) >> 1] | 0;
 HEAP32[i3 + 144 >> 2] = HEAPU16[180 + (i5 * 12 | 0) >> 1] | 0;
 HEAP32[i3 + 124 >> 2] = HEAPU16[182 + (i5 * 12 | 0) >> 1] | 0;
 HEAP32[i3 + 108 >> 2] = 0;
 HEAP32[i3 + 92 >> 2] = 0;
 HEAP32[i3 + 116 >> 2] = 0;
 HEAP32[i3 + 120 >> 2] = 2;
 HEAP32[i3 + 96 >> 2] = 2;
 HEAP32[i3 + 112 >> 2] = 0;
 HEAP32[i3 + 104 >> 2] = 0;
 HEAP32[i3 + 72 >> 2] = 0;
 i5 = 0;
 STACKTOP = i2;
 return i5 | 0;
}
function _updatewindow(i6, i4) {
 i6 = i6 | 0;
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i5 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0;
 i1 = STACKTOP;
 i2 = HEAP32[i6 + 28 >> 2] | 0;
 i3 = i2 + 52 | 0;
 i8 = HEAP32[i3 >> 2] | 0;
 if ((i8 | 0) == 0) {
  i8 = FUNCTION_TABLE_iiii[HEAP32[i6 + 32 >> 2] & 1](HEAP32[i6 + 40 >> 2] | 0, 1 << HEAP32[i2 + 36 >> 2], 1) | 0;
  HEAP32[i3 >> 2] = i8;
  if ((i8 | 0) == 0) {
   i10 = 1;
   STACKTOP = i1;
   return i10 | 0;
  }
 }
 i5 = i2 + 40 | 0;
 i10 = HEAP32[i5 >> 2] | 0;
 if ((i10 | 0) == 0) {
  i10 = 1 << HEAP32[i2 + 36 >> 2];
  HEAP32[i5 >> 2] = i10;
  HEAP32[i2 + 48 >> 2] = 0;
  HEAP32[i2 + 44 >> 2] = 0;
 }
 i4 = i4 - (HEAP32[i6 + 16 >> 2] | 0) | 0;
 if (!(i4 >>> 0 < i10 >>> 0)) {
  _memcpy(i8 | 0, (HEAP32[i6 + 12 >> 2] | 0) + (0 - i10) | 0, i10 | 0) | 0;
  HEAP32[i2 + 48 >> 2] = 0;
  HEAP32[i2 + 44 >> 2] = HEAP32[i5 >> 2];
  i10 = 0;
  STACKTOP = i1;
  return i10 | 0;
 }
 i7 = i2 + 48 | 0;
 i9 = HEAP32[i7 >> 2] | 0;
 i10 = i10 - i9 | 0;
 i10 = i10 >>> 0 > i4 >>> 0 ? i4 : i10;
 i6 = i6 + 12 | 0;
 _memcpy(i8 + i9 | 0, (HEAP32[i6 >> 2] | 0) + (0 - i4) | 0, i10 | 0) | 0;
 i8 = i4 - i10 | 0;
 if ((i4 | 0) != (i10 | 0)) {
  _memcpy(HEAP32[i3 >> 2] | 0, (HEAP32[i6 >> 2] | 0) + (0 - i8) | 0, i8 | 0) | 0;
  HEAP32[i7 >> 2] = i8;
  HEAP32[i2 + 44 >> 2] = HEAP32[i5 >> 2];
  i10 = 0;
  STACKTOP = i1;
  return i10 | 0;
 }
 i6 = (HEAP32[i7 >> 2] | 0) + i4 | 0;
 i3 = HEAP32[i5 >> 2] | 0;
 HEAP32[i7 >> 2] = (i6 | 0) == (i3 | 0) ? 0 : i6;
 i5 = i2 + 44 | 0;
 i2 = HEAP32[i5 >> 2] | 0;
 if (!(i2 >>> 0 < i3 >>> 0)) {
  i10 = 0;
  STACKTOP = i1;
  return i10 | 0;
 }
 HEAP32[i5 >> 2] = i2 + i4;
 i10 = 0;
 STACKTOP = i1;
 return i10 | 0;
}
function _scan_tree(i1, i5, i6) {
 i1 = i1 | 0;
 i5 = i5 | 0;
 i6 = i6 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i7 = 0, i8 = 0, i9 = 0, i10 = 0, i11 = 0, i12 = 0, i13 = 0, i14 = 0, i15 = 0, i16 = 0;
 i8 = STACKTOP;
 i10 = HEAP16[i5 + 2 >> 1] | 0;
 i9 = i10 << 16 >> 16 == 0;
 HEAP16[i5 + (i6 + 1 << 2) + 2 >> 1] = -1;
 i2 = i1 + 2752 | 0;
 i3 = i1 + 2756 | 0;
 i4 = i1 + 2748 | 0;
 i7 = i9 ? 138 : 7;
 i9 = i9 ? 3 : 4;
 i13 = 0;
 i11 = i10 & 65535;
 i12 = -1;
 L1 : while (1) {
  i14 = 0;
  do {
   if ((i13 | 0) > (i6 | 0)) {
    break L1;
   }
   i13 = i13 + 1 | 0;
   i16 = HEAP16[i5 + (i13 << 2) + 2 >> 1] | 0;
   i10 = i16 & 65535;
   i14 = i14 + 1 | 0;
   i15 = (i11 | 0) == (i10 | 0);
  } while ((i14 | 0) < (i7 | 0) & i15);
  do {
   if ((i14 | 0) >= (i9 | 0)) {
    if ((i11 | 0) == 0) {
     if ((i14 | 0) < 11) {
      HEAP16[i2 >> 1] = (HEAP16[i2 >> 1] | 0) + 1 << 16 >> 16;
      break;
     } else {
      HEAP16[i3 >> 1] = (HEAP16[i3 >> 1] | 0) + 1 << 16 >> 16;
      break;
     }
    } else {
     if ((i11 | 0) != (i12 | 0)) {
      i14 = i1 + (i11 << 2) + 2684 | 0;
      HEAP16[i14 >> 1] = (HEAP16[i14 >> 1] | 0) + 1 << 16 >> 16;
     }
     HEAP16[i4 >> 1] = (HEAP16[i4 >> 1] | 0) + 1 << 16 >> 16;
     break;
    }
   } else {
    i12 = i1 + (i11 << 2) + 2684 | 0;
    HEAP16[i12 >> 1] = (HEAPU16[i12 >> 1] | 0) + i14;
   }
  } while (0);
  if (i16 << 16 >> 16 == 0) {
   i12 = i11;
   i7 = 138;
   i9 = 3;
   i11 = i10;
   continue;
  }
  i12 = i11;
  i7 = i15 ? 6 : 7;
  i9 = i15 ? 3 : 4;
  i11 = i10;
 }
 STACKTOP = i8;
 return;
}
function _deflateEnd(i4) {
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i5 = 0, i6 = 0, i7 = 0;
 i3 = STACKTOP;
 if ((i4 | 0) == 0) {
  i7 = -2;
  STACKTOP = i3;
  return i7 | 0;
 }
 i1 = i4 + 28 | 0;
 i6 = HEAP32[i1 >> 2] | 0;
 if ((i6 | 0) == 0) {
  i7 = -2;
  STACKTOP = i3;
  return i7 | 0;
 }
 i2 = HEAP32[i6 + 4 >> 2] | 0;
 switch (i2 | 0) {
 case 42:
 case 69:
 case 73:
 case 91:
 case 103:
 case 113:
 case 666:
  {
   break;
  }
 default:
  {
   i7 = -2;
   STACKTOP = i3;
   return i7 | 0;
  }
 }
 i5 = HEAP32[i6 + 8 >> 2] | 0;
 if ((i5 | 0) != 0) {
  FUNCTION_TABLE_vii[HEAP32[i4 + 36 >> 2] & 1](HEAP32[i4 + 40 >> 2] | 0, i5);
  i6 = HEAP32[i1 >> 2] | 0;
 }
 i5 = HEAP32[i6 + 68 >> 2] | 0;
 if ((i5 | 0) != 0) {
  FUNCTION_TABLE_vii[HEAP32[i4 + 36 >> 2] & 1](HEAP32[i4 + 40 >> 2] | 0, i5);
  i6 = HEAP32[i1 >> 2] | 0;
 }
 i5 = HEAP32[i6 + 64 >> 2] | 0;
 if ((i5 | 0) != 0) {
  FUNCTION_TABLE_vii[HEAP32[i4 + 36 >> 2] & 1](HEAP32[i4 + 40 >> 2] | 0, i5);
  i6 = HEAP32[i1 >> 2] | 0;
 }
 i7 = HEAP32[i6 + 56 >> 2] | 0;
 i5 = i4 + 36 | 0;
 if ((i7 | 0) == 0) {
  i4 = i4 + 40 | 0;
 } else {
  i4 = i4 + 40 | 0;
  FUNCTION_TABLE_vii[HEAP32[i5 >> 2] & 1](HEAP32[i4 >> 2] | 0, i7);
  i6 = HEAP32[i1 >> 2] | 0;
 }
 FUNCTION_TABLE_vii[HEAP32[i5 >> 2] & 1](HEAP32[i4 >> 2] | 0, i6);
 HEAP32[i1 >> 2] = 0;
 i7 = (i2 | 0) == 113 ? -3 : 0;
 STACKTOP = i3;
 return i7 | 0;
}
function _main(i4, i5) {
 i4 = i4 | 0;
 i5 = i5 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i6 = 0;
 i1 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i2 = i1;
 L1 : do {
  if ((i4 | 0) > 1) {
   i4 = HEAP8[HEAP32[i5 + 4 >> 2] | 0] | 0;
   switch (i4 | 0) {
   case 50:
    {
     i2 = 250;
     break L1;
    }
   case 51:
    {
     i3 = 4;
     break L1;
    }
   case 52:
    {
     i2 = 2500;
     break L1;
    }
   case 53:
    {
     i2 = 5e3;
     break L1;
    }
   case 48:
    {
     i6 = 0;
     STACKTOP = i1;
     return i6 | 0;
    }
   case 49:
    {
     i2 = 60;
     break L1;
    }
   default:
    {
     HEAP32[i2 >> 2] = i4 + -48;
     _printf(144, i2 | 0) | 0;
     i6 = -1;
     STACKTOP = i1;
     return i6 | 0;
    }
   }
  } else {
   i3 = 4;
  }
 } while (0);
 if ((i3 | 0) == 4) {
  i2 = 500;
 }
 i3 = _malloc(1e5) | 0;
 i4 = 0;
 i6 = 0;
 i5 = 17;
 while (1) {
  do {
   if ((i6 | 0) <= 0) {
    if ((i4 & 7 | 0) == 0) {
     i6 = i4 & 31;
     i5 = 0;
     break;
    } else {
     i5 = (((Math_imul(i4, i4) | 0) >>> 0) % 6714 | 0) & 255;
     break;
    }
   } else {
    i6 = i6 + -1 | 0;
   }
  } while (0);
  HEAP8[i3 + i4 | 0] = i5;
  i4 = i4 + 1 | 0;
  if ((i4 | 0) == 1e5) {
   i4 = 0;
   break;
  }
 }
 do {
  _doit(i3, 1e5, i4);
  i4 = i4 + 1 | 0;
 } while ((i4 | 0) < (i2 | 0));
 _puts(160) | 0;
 i6 = 0;
 STACKTOP = i1;
 return i6 | 0;
}
function _doit(i6, i1, i7) {
 i6 = i6 | 0;
 i1 = i1 | 0;
 i7 = i7 | 0;
 var i2 = 0, i3 = 0, i4 = 0, i5 = 0, i8 = 0, i9 = 0;
 i5 = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 i4 = i5;
 i3 = i5 + 12 | 0;
 i2 = i5 + 8 | 0;
 i8 = _compressBound(i1) | 0;
 i9 = HEAP32[2] | 0;
 if ((i9 | 0) == 0) {
  i9 = _malloc(i8) | 0;
  HEAP32[2] = i9;
 }
 if ((HEAP32[4] | 0) == 0) {
  HEAP32[4] = _malloc(i1) | 0;
 }
 HEAP32[i3 >> 2] = i8;
 _compress(i9, i3, i6, i1) | 0;
 i7 = (i7 | 0) == 0;
 if (i7) {
  i9 = HEAP32[i3 >> 2] | 0;
  HEAP32[i4 >> 2] = i1;
  HEAP32[i4 + 4 >> 2] = i9;
  _printf(24, i4 | 0) | 0;
 }
 HEAP32[i2 >> 2] = i1;
 _uncompress(HEAP32[4] | 0, i2, HEAP32[2] | 0, HEAP32[i3 >> 2] | 0) | 0;
 if ((HEAP32[i2 >> 2] | 0) != (i1 | 0)) {
  ___assert_fail(40, 72, 24, 104);
 }
 if (!i7) {
  STACKTOP = i5;
  return;
 }
 if ((_strcmp(i6, HEAP32[4] | 0) | 0) == 0) {
  STACKTOP = i5;
  return;
 } else {
  ___assert_fail(112, 72, 25, 104);
 }
}
function _uncompress(i6, i1, i5, i7) {
 i6 = i6 | 0;
 i1 = i1 | 0;
 i5 = i5 | 0;
 i7 = i7 | 0;
 var i2 = 0, i3 = 0, i4 = 0;
 i2 = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 i3 = i2;
 HEAP32[i3 >> 2] = i5;
 i5 = i3 + 4 | 0;
 HEAP32[i5 >> 2] = i7;
 HEAP32[i3 + 12 >> 2] = i6;
 HEAP32[i3 + 16 >> 2] = HEAP32[i1 >> 2];
 HEAP32[i3 + 32 >> 2] = 0;
 HEAP32[i3 + 36 >> 2] = 0;
 i6 = _inflateInit_(i3, 2992, 56) | 0;
 if ((i6 | 0) != 0) {
  i7 = i6;
  STACKTOP = i2;
  return i7 | 0;
 }
 i6 = _inflate(i3, 4) | 0;
 if ((i6 | 0) == 1) {
  HEAP32[i1 >> 2] = HEAP32[i3 + 20 >> 2];
  i7 = _inflateEnd(i3) | 0;
  STACKTOP = i2;
  return i7 | 0;
 }
 _inflateEnd(i3) | 0;
 if ((i6 | 0) == 2) {
  i7 = -3;
  STACKTOP = i2;
  return i7 | 0;
 } else if ((i6 | 0) == -5) {
  i4 = 4;
 }
 if ((i4 | 0) == 4 ? (HEAP32[i5 >> 2] | 0) == 0 : 0) {
  i7 = -3;
  STACKTOP = i2;
  return i7 | 0;
 }
 i7 = i6;
 STACKTOP = i2;
 return i7 | 0;
}
function _compress(i4, i1, i6, i5) {
 i4 = i4 | 0;
 i1 = i1 | 0;
 i6 = i6 | 0;
 i5 = i5 | 0;
 var i2 = 0, i3 = 0;
 i2 = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 i3 = i2;
 HEAP32[i3 >> 2] = i6;
 HEAP32[i3 + 4 >> 2] = i5;
 HEAP32[i3 + 12 >> 2] = i4;
 HEAP32[i3 + 16 >> 2] = HEAP32[i1 >> 2];
 HEAP32[i3 + 32 >> 2] = 0;
 HEAP32[i3 + 36 >> 2] = 0;
 HEAP32[i3 + 40 >> 2] = 0;
 i4 = _deflateInit_(i3, -1, 168, 56) | 0;
 if ((i4 | 0) != 0) {
  i6 = i4;
  STACKTOP = i2;
  return i6 | 0;
 }
 i4 = _deflate(i3, 4) | 0;
 if ((i4 | 0) == 1) {
  HEAP32[i1 >> 2] = HEAP32[i3 + 20 >> 2];
  i6 = _deflateEnd(i3) | 0;
  STACKTOP = i2;
  return i6 | 0;
 } else {
  _deflateEnd(i3) | 0;
  i6 = (i4 | 0) == 0 ? -5 : i4;
  STACKTOP = i2;
  return i6 | 0;
 }
 return 0;
}
function _inflateEnd(i4) {
 i4 = i4 | 0;
 var i1 = 0, i2 = 0, i3 = 0, i5 = 0, i6 = 0, i7 = 0;
 i1 = STACKTOP;
 if ((i4 | 0) == 0) {
  i7 = -2;
  STACKTOP = i1;
  return i7 | 0;
 }
 i2 = i4 + 28 | 0;
 i3 = HEAP32[i2 >> 2] | 0;
 if ((i3 | 0) == 0) {
  i7 = -2;
  STACKTOP = i1;
  return i7 | 0;
 }
 i6 = i4 + 36 | 0;
 i5 = HEAP32[i6 >> 2] | 0;
 if ((i5 | 0) == 0) {
  i7 = -2;
  STACKTOP = i1;
  return i7 | 0;
 }
 i7 = HEAP32[i3 + 52 >> 2] | 0;
 i4 = i4 + 40 | 0;
 if ((i7 | 0) != 0) {
  FUNCTION_TABLE_vii[i5 & 1](HEAP32[i4 >> 2] | 0, i7);
  i5 = HEAP32[i6 >> 2] | 0;
  i3 = HEAP32[i2 >> 2] | 0;
 }
 FUNCTION_TABLE_vii[i5 & 1](HEAP32[i4 >> 2] | 0, i3);
 HEAP32[i2 >> 2] = 0;
 i7 = 0;
 STACKTOP = i1;
 return i7 | 0;
}
function _memcpy(i3, i2, i1) {
 i3 = i3 | 0;
 i2 = i2 | 0;
 i1 = i1 | 0;
 var i4 = 0;
 if ((i1 | 0) >= 4096) return _emscripten_memcpy_big(i3 | 0, i2 | 0, i1 | 0) | 0;
 i4 = i3 | 0;
 if ((i3 & 3) == (i2 & 3)) {
  while (i3 & 3) {
   if ((i1 | 0) == 0) return i4 | 0;
   HEAP8[i3] = HEAP8[i2] | 0;
   i3 = i3 + 1 | 0;
   i2 = i2 + 1 | 0;
   i1 = i1 - 1 | 0;
  }
  while ((i1 | 0) >= 4) {
   HEAP32[i3 >> 2] = HEAP32[i2 >> 2];
   i3 = i3 + 4 | 0;
   i2 = i2 + 4 | 0;
   i1 = i1 - 4 | 0;
  }
 }
 while ((i1 | 0) > 0) {
  HEAP8[i3] = HEAP8[i2] | 0;
  i3 = i3 + 1 | 0;
  i2 = i2 + 1 | 0;
  i1 = i1 - 1 | 0;
 }
 return i4 | 0;
}
function _strcmp(i4, i2) {
 i4 = i4 | 0;
 i2 = i2 | 0;
 var i1 = 0, i3 = 0, i5 = 0;
 i1 = STACKTOP;
 i5 = HEAP8[i4] | 0;
 i3 = HEAP8[i2] | 0;
 if (i5 << 24 >> 24 != i3 << 24 >> 24 | i5 << 24 >> 24 == 0 | i3 << 24 >> 24 == 0) {
  i4 = i5;
  i5 = i3;
  i4 = i4 & 255;
  i5 = i5 & 255;
  i5 = i4 - i5 | 0;
  STACKTOP = i1;
  return i5 | 0;
 }
 do {
  i4 = i4 + 1 | 0;
  i2 = i2 + 1 | 0;
  i5 = HEAP8[i4] | 0;
  i3 = HEAP8[i2] | 0;
 } while (!(i5 << 24 >> 24 != i3 << 24 >> 24 | i5 << 24 >> 24 == 0 | i3 << 24 >> 24 == 0));
 i4 = i5 & 255;
 i5 = i3 & 255;
 i5 = i4 - i5 | 0;
 STACKTOP = i1;
 return i5 | 0;
}
function _memset(i1, i4, i3) {
 i1 = i1 | 0;
 i4 = i4 | 0;
 i3 = i3 | 0;
 var i2 = 0, i5 = 0, i6 = 0, i7 = 0;
 i2 = i1 + i3 | 0;
 if ((i3 | 0) >= 20) {
  i4 = i4 & 255;
  i7 = i1 & 3;
  i6 = i4 | i4 << 8 | i4 << 16 | i4 << 24;
  i5 = i2 & ~3;
  if (i7) {
   i7 = i1 + 4 - i7 | 0;
   while ((i1 | 0) < (i7 | 0)) {
    HEAP8[i1] = i4;
    i1 = i1 + 1 | 0;
   }
  }
  while ((i1 | 0) < (i5 | 0)) {
   HEAP32[i1 >> 2] = i6;
   i1 = i1 + 4 | 0;
  }
 }
 while ((i1 | 0) < (i2 | 0)) {
  HEAP8[i1] = i4;
  i1 = i1 + 1 | 0;
 }
 return i1 - i3 | 0;
}
function copyTempDouble(i1) {
 i1 = i1 | 0;
 HEAP8[tempDoublePtr] = HEAP8[i1];
 HEAP8[tempDoublePtr + 1 | 0] = HEAP8[i1 + 1 | 0];
 HEAP8[tempDoublePtr + 2 | 0] = HEAP8[i1 + 2 | 0];
 HEAP8[tempDoublePtr + 3 | 0] = HEAP8[i1 + 3 | 0];
 HEAP8[tempDoublePtr + 4 | 0] = HEAP8[i1 + 4 | 0];
 HEAP8[tempDoublePtr + 5 | 0] = HEAP8[i1 + 5 | 0];
 HEAP8[tempDoublePtr + 6 | 0] = HEAP8[i1 + 6 | 0];
 HEAP8[tempDoublePtr + 7 | 0] = HEAP8[i1 + 7 | 0];
}
function __tr_init(i1) {
 i1 = i1 | 0;
 var i2 = 0;
 i2 = STACKTOP;
 HEAP32[i1 + 2840 >> 2] = i1 + 148;
 HEAP32[i1 + 2848 >> 2] = 1064;
 HEAP32[i1 + 2852 >> 2] = i1 + 2440;
 HEAP32[i1 + 2860 >> 2] = 1088;
 HEAP32[i1 + 2864 >> 2] = i1 + 2684;
 HEAP32[i1 + 2872 >> 2] = 1112;
 HEAP16[i1 + 5816 >> 1] = 0;
 HEAP32[i1 + 5820 >> 2] = 0;
 HEAP32[i1 + 5812 >> 2] = 8;
 _init_block(i1);
 STACKTOP = i2;
 return;
}
function copyTempFloat(i1) {
 i1 = i1 | 0;
 HEAP8[tempDoublePtr] = HEAP8[i1];
 HEAP8[tempDoublePtr + 1 | 0] = HEAP8[i1 + 1 | 0];
 HEAP8[tempDoublePtr + 2 | 0] = HEAP8[i1 + 2 | 0];
 HEAP8[tempDoublePtr + 3 | 0] = HEAP8[i1 + 3 | 0];
}
function _deflateInit_(i4, i3, i2, i1) {
 i4 = i4 | 0;
 i3 = i3 | 0;
 i2 = i2 | 0;
 i1 = i1 | 0;
 var i5 = 0;
 i5 = STACKTOP;
 i4 = _deflateInit2_(i4, i3, 8, 15, 8, 0, i2, i1) | 0;
 STACKTOP = i5;
 return i4 | 0;
}
function _zcalloc(i3, i1, i2) {
 i3 = i3 | 0;
 i1 = i1 | 0;
 i2 = i2 | 0;
 var i4 = 0;
 i4 = STACKTOP;
 i3 = _malloc(Math_imul(i2, i1) | 0) | 0;
 STACKTOP = i4;
 return i3 | 0;
}
function dynCall_iiii(i4, i3, i2, i1) {
 i4 = i4 | 0;
 i3 = i3 | 0;
 i2 = i2 | 0;
 i1 = i1 | 0;
 return FUNCTION_TABLE_iiii[i4 & 1](i3 | 0, i2 | 0, i1 | 0) | 0;
}
function runPostSets() {}
function _strlen(i1) {
 i1 = i1 | 0;
 var i2 = 0;
 i2 = i1;
 while (HEAP8[i2] | 0) {
  i2 = i2 + 1 | 0;
 }
 return i2 - i1 | 0;
}
function stackAlloc(i1) {
 i1 = i1 | 0;
 var i2 = 0;
 i2 = STACKTOP;
 STACKTOP = STACKTOP + i1 | 0;
 STACKTOP = STACKTOP + 7 & -8;
 return i2 | 0;
}
function dynCall_iii(i3, i2, i1) {
 i3 = i3 | 0;
 i2 = i2 | 0;
 i1 = i1 | 0;
 return FUNCTION_TABLE_iii[i3 & 3](i2 | 0, i1 | 0) | 0;
}
function setThrew(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 if ((__THREW__ | 0) == 0) {
  __THREW__ = i1;
  threwValue = i2;
 }
}
function dynCall_vii(i3, i2, i1) {
 i3 = i3 | 0;
 i2 = i2 | 0;
 i1 = i1 | 0;
 FUNCTION_TABLE_vii[i3 & 1](i2 | 0, i1 | 0);
}
function _zcfree(i2, i1) {
 i2 = i2 | 0;
 i1 = i1 | 0;
 i2 = STACKTOP;
 _free(i1);
 STACKTOP = i2;
 return;
}
function _compressBound(i1) {
 i1 = i1 | 0;
 return i1 + 13 + (i1 >>> 12) + (i1 >>> 14) + (i1 >>> 25) | 0;
}
function b0(i1, i2, i3) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 i3 = i3 | 0;
 abort(0);
 return 0;
}
function b2(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 abort(2);
 return 0;
}
function b1(i1, i2) {
 i1 = i1 | 0;
 i2 = i2 | 0;
 abort(1);
}
function stackRestore(i1) {
 i1 = i1 | 0;
 STACKTOP = i1;
}
function setTempRet9(i1) {
 i1 = i1 | 0;
 tempRet9 = i1;
}
function setTempRet8(i1) {
 i1 = i1 | 0;
 tempRet8 = i1;
}
function setTempRet7(i1) {
 i1 = i1 | 0;
 tempRet7 = i1;
}
function setTempRet6(i1) {
 i1 = i1 | 0;
 tempRet6 = i1;
}
function setTempRet5(i1) {
 i1 = i1 | 0;
 tempRet5 = i1;
}
function setTempRet4(i1) {
 i1 = i1 | 0;
 tempRet4 = i1;
}
function setTempRet3(i1) {
 i1 = i1 | 0;
 tempRet3 = i1;
}
function setTempRet2(i1) {
 i1 = i1 | 0;
 tempRet2 = i1;
}
function setTempRet1(i1) {
 i1 = i1 | 0;
 tempRet1 = i1;
}
function setTempRet0(i1) {
 i1 = i1 | 0;
 tempRet0 = i1;
}
function stackSave() {
 return STACKTOP | 0;
}

// EMSCRIPTEN_END_FUNCS
  var FUNCTION_TABLE_iiii = [b0,_zcalloc];
  var FUNCTION_TABLE_vii = [b1,_zcfree];
  var FUNCTION_TABLE_iii = [b2,_deflate_stored,_deflate_fast,_deflate_slow];

  return { _strlen: _strlen, _free: _free, _main: _main, _memset: _memset, _malloc: _malloc, _memcpy: _memcpy, runPostSets: runPostSets, stackAlloc: stackAlloc, stackSave: stackSave, stackRestore: stackRestore, setThrew: setThrew, setTempRet0: setTempRet0, setTempRet1: setTempRet1, setTempRet2: setTempRet2, setTempRet3: setTempRet3, setTempRet4: setTempRet4, setTempRet5: setTempRet5, setTempRet6: setTempRet6, setTempRet7: setTempRet7, setTempRet8: setTempRet8, setTempRet9: setTempRet9, dynCall_iiii: dynCall_iiii, dynCall_vii: dynCall_vii, dynCall_iii: dynCall_iii };
})
// EMSCRIPTEN_END_ASM
({ "Math": Math, "Int8Array": Int8Array, "Int16Array": Int16Array, "Int32Array": Int32Array, "Uint8Array": Uint8Array, "Uint16Array": Uint16Array, "Uint32Array": Uint32Array, "Float32Array": Float32Array, "Float64Array": Float64Array }, { "abort": abort, "assert": assert, "asmPrintInt": asmPrintInt, "asmPrintFloat": asmPrintFloat, "min": Math_min, "invoke_iiii": invoke_iiii, "invoke_vii": invoke_vii, "invoke_iii": invoke_iii, "_send": _send, "___setErrNo": ___setErrNo, "___assert_fail": ___assert_fail, "_fflush": _fflush, "_pwrite": _pwrite, "__reallyNegative": __reallyNegative, "_sbrk": _sbrk, "___errno_location": ___errno_location, "_emscripten_memcpy_big": _emscripten_memcpy_big, "_fileno": _fileno, "_sysconf": _sysconf, "_puts": _puts, "_mkport": _mkport, "_write": _write, "_llvm_bswap_i32": _llvm_bswap_i32, "_fputc": _fputc, "_abort": _abort, "_fwrite": _fwrite, "_time": _time, "_fprintf": _fprintf, "__formatString": __formatString, "_fputs": _fputs, "_printf": _printf, "STACKTOP": STACKTOP, "STACK_MAX": STACK_MAX, "tempDoublePtr": tempDoublePtr, "ABORT": ABORT, "NaN": NaN, "Infinity": Infinity }, buffer);
assertTrue(%IsAsmWasmCode(ModuleFunc));
var _strlen = Module["_strlen"] = asm["_strlen"];
var _free = Module["_free"] = asm["_free"];
var _main = Module["_main"] = asm["_main"];
var _memset = Module["_memset"] = asm["_memset"];
var _malloc = Module["_malloc"] = asm["_malloc"];
var _memcpy = Module["_memcpy"] = asm["_memcpy"];
var runPostSets = Module["runPostSets"] = asm["runPostSets"];
var dynCall_iiii = Module["dynCall_iiii"] = asm["dynCall_iiii"];
var dynCall_vii = Module["dynCall_vii"] = asm["dynCall_vii"];
var dynCall_iii = Module["dynCall_iii"] = asm["dynCall_iii"];

Runtime.stackAlloc = function(size) { return asm['stackAlloc'](size) };
Runtime.stackSave = function() { return asm['stackSave']() };
Runtime.stackRestore = function(top) { asm['stackRestore'](top) };


// Warning: printing of i64 values may be slightly rounded! No deep i64 math used, so precise i64 code not included
var i64Math = null;

// === Auto-generated postamble setup entry stuff ===

if (memoryInitializer) {
  if (ENVIRONMENT_IS_NODE || ENVIRONMENT_IS_SHELL) {
    var data = Module['readBinary'](memoryInitializer);
    HEAPU8.set(data, STATIC_BASE);
  } else {
    addRunDependency('memory initializer');
    Browser.asyncLoad(memoryInitializer, function(data) {
      HEAPU8.set(data, STATIC_BASE);
      removeRunDependency('memory initializer');
    }, function(data) {
      throw 'could not load memory initializer ' + memoryInitializer;
    });
  }
}

function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
};
ExitStatus.prototype = new Error();
ExitStatus.prototype.constructor = ExitStatus;

var initialStackTop;
var preloadStartTime = null;
var calledMain = false;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!Module['calledRun'] && shouldRunNow) run([].concat(Module["arguments"]));
  if (!Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
}

Module['callMain'] = Module.callMain = function callMain(args) {
  assert(runDependencies == 0, 'cannot call main when async dependencies remain! (listen on __ATMAIN__)');
  assert(__ATPRERUN__.length == 0, 'cannot call main when preRun functions remain to be called');

  args = args || [];

  ensureInitRuntime();

  var argc = args.length+1;
  function pad() {
    for (var i = 0; i < 4-1; i++) {
      argv.push(0);
    }
  }
  var argv = [allocate(intArrayFromString("/bin/this.program"), 'i8', ALLOC_NORMAL) ];
  pad();
  for (var i = 0; i < argc-1; i = i + 1) {
    argv.push(allocate(intArrayFromString(args[i]), 'i8', ALLOC_NORMAL));
    pad();
  }
  argv.push(0);
  argv = allocate(argv, 'i32', ALLOC_NORMAL);

  initialStackTop = STACKTOP;

  try {

    var ret = Module['_main'](argc, argv, 0);


    // if we're not running an evented main loop, it's time to exit
    if (!Module['noExitRuntime']) {
      exit(ret);
    }
  }
  catch(e) {
    if (e instanceof ExitStatus) {
      // exit() throws this once it's done to make sure execution
      // has been stopped completely
      return;
    } else if (e == 'SimulateInfiniteLoop') {
      // running an evented main loop, don't immediately exit
      Module['noExitRuntime'] = true;
      return;
    } else {
      if (e && typeof e === 'object' && e.stack) Module.printErr('exception thrown: ' + [e, e.stack]);
      throw e;
    }
  } finally {
    calledMain = true;
  }
}




function run(args) {
  args = args || Module['arguments'];

  if (preloadStartTime === null) preloadStartTime = Date.now();

  if (runDependencies > 0) {
    Module.printErr('run() called, but dependencies remain, so not running');
    return;
  }

  preRun();

  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later
  if (Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame

  function doRun() {
    if (Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening
    Module['calledRun'] = true;

    ensureInitRuntime();

    preMain();

    if (ENVIRONMENT_IS_WEB && preloadStartTime !== null) {
      Module.printErr('pre-main prep time: ' + (Date.now() - preloadStartTime) + ' ms');
    }

    if (Module['_main'] && shouldRunNow) {
      Module['callMain'](args);
    }

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      if (!ABORT) doRun();
    }, 1);
  } else {
    doRun();
  }
}
Module['run'] = Module.run = run;

function exit(status) {
  ABORT = true;
  EXITSTATUS = status;
  STACKTOP = initialStackTop;

  // exit the runtime
  exitRuntime();

  // TODO We should handle this differently based on environment.
  // In the browser, the best we can do is throw an exception
  // to halt execution, but in node we could process.exit and
  // I'd imagine SM shell would have something equivalent.
  // This would let us set a proper exit status (which
  // would be great for checking test exit statuses).
  // https://github.com/kripken/emscripten/issues/1371

  // throw an exception to halt the current execution
  throw new ExitStatus(status);
}
Module['exit'] = Module.exit = exit;

function abort(text) {
  if (text) {
    Module.print(text);
    Module.printErr(text);
  }

  ABORT = true;
  EXITSTATUS = 1;

  var extra = '\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.';

  throw 'abort() at ' + stackTrace() + extra;
}
Module['abort'] = Module.abort = abort;

// {{PRE_RUN_ADDITIONS}}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

// shouldRunNow refers to calling main(), not run().
var shouldRunNow = true;
if (Module['noInitialRun']) {
  shouldRunNow = false;
}


run([].concat(Module["arguments"]));
                                                                                                            node-23.7.0/deps/v8/test/mjsunit/wasm/empirical_max_memory.js                                       0000664 0000000 0000000 00000004726 14746647661 0024235 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

let k1GiB = 1 * 1024 * 1024 * 1024;
let k4GiB = 4 * k1GiB;
// TODO(4153): Raise this to 4GiB, but only on 64-bit platforms.
let kMaxMemory = 2 * k1GiB - kPageSize;

(function Test() {
  var memory;

  function BuildAccessors(type, load_opcode, store_opcode) {
    builder = new WasmModuleBuilder();
    builder.addImportedMemory("i", "mem");
    builder.addFunction("load", makeSig([kWasmI32], [type]))
      .addBody([           // --
        kExprLocalGet, 0,  // --
        load_opcode, 0, 0, // --
      ])                   // --
      .exportFunc();
    builder.addFunction("store", makeSig([kWasmI32, type], []))
      .addBody([             // --
        kExprLocalGet, 0,    // --
        kExprLocalGet, 1,    // --
        store_opcode, 0, 0,  // --
      ])                     // --
      .exportFunc();
    let i = builder.instantiate({i: {mem: memory}});
    return {load: i.exports.load, store: i.exports.store};
  }

  function probe(a, f) {
    print("------------------------");
    let stride = kPageSize * 32;  // Don't check every page to save time.
    let max = kMaxMemory;
    for (let i = 0; i < max; i += stride) {
      a.store(i, f(i));
    }
    for (let i = 0; i < max; i += stride) {
      assertEquals(f(i), a.load(i));
    }
  }

  try {
    let kPages = kMaxMemory / kPageSize;
    memory = new WebAssembly.Memory({ initial: kPages, maximum: kPages });
  } catch (e) {
    print("OOM: sorry, best effort max memory size test.");
    return;
  }

  assertEquals(kMaxMemory, memory.buffer.byteLength);

  {
    let a = BuildAccessors(kWasmI32, kExprI32LoadMem, kExprI32StoreMem);
    probe(a, i => (0xaabbccee ^ ((i >> 11) * 0x110005)) | 0);
  }

  {
    let a = BuildAccessors(kWasmI32, kExprI32LoadMem16U, kExprI32StoreMem16);
    probe(a, i => (0xccee ^ ((i >> 11) * 0x110005)) & 0xFFFF);
  }

  {
    let a = BuildAccessors(kWasmI32, kExprI32LoadMem8U, kExprI32StoreMem8);
    probe(a, i => (0xee ^ ((i >> 11) * 0x05)) & 0xFF);
  }

  {
    let a = BuildAccessors(kWasmF64, kExprF64LoadMem, kExprF64StoreMem);
    probe(a, i => 0xaabbccee ^ ((i >> 11) * 0x110005));
  }

  {
    let a = BuildAccessors(kWasmF32, kExprF32LoadMem, kExprF32StoreMem);
    probe(a, i => Math.fround(0xaabbccee ^ ((i >> 11) * 0x110005)));
  }
})();
                                          node-23.7.0/deps/v8/test/mjsunit/wasm/ensure-wasm-binaries-up-to-date.js                            0000664 0000000 0000000 00000002130 14746647661 0026033 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

// Ensure checked in wasm binaries used by integration tests from v8 hosts
// (such as chromium) are up to date.

(function print_incrementer() {
  if (true) return; // remove to regenerate the module

  d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

  var module = new WasmModuleBuilder();
  module.addFunction(undefined, kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprI32Const, 1, kExprI32Add])
    .exportAs("increment");

  var buffer = module.toBuffer(true);
  var view = new Uint8Array(buffer);

  print("const unsigned char module[] = {");
  for (var i = 0; i < buffer.byteLength; i++) {
    print("  " + view[i] + ",");
  }
  print("};");
})();

(function ensure_incrementer() {
  var buff = readbuffer("test/mjsunit/wasm/incrementer.wasm");
  var mod = new WebAssembly.Module(buff);
  var inst = new WebAssembly.Instance(mod);
  var inc = inst.exports.increment;
  assertEquals(3, inc(2));
}())
                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/wasm/enter-and-leave-debug-state.js                                0000664 0000000 0000000 00000001537 14746647661 0025201 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function enterAndLeaveDebugging() {
  const builder = new WasmModuleBuilder();
  builder.addFunction("main", kSig_i_v).exportFunc().addBody(wasmI32Const(42));
  let main = builder.instantiate().exports.main;
  assertEquals(42, main());
  assertTrue(%IsLiftoffFunction(main));
  %WasmTierUpFunction(main);
  assertEquals(42, main());
  assertTrue(%IsTurboFanFunction(main));
  %WasmEnterDebugging();
  assertEquals(42, main());
  assertTrue(%IsWasmDebugFunction(main));
  %WasmLeaveDebugging();
  %WasmTierUpFunction(main);
  assertEquals(42, main());
  assertTrue(%IsTurboFanFunction(main));
})();
                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/wasm/enter-debug-state.js                                          0000664 0000000 0000000 00000002670 14746647661 0023346 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

const num_functions = 200;

function create_builder(delta = 0) {
  const builder = new WasmModuleBuilder();
  for (let i = 0; i < num_functions; ++i) {
    builder.addFunction('f' + i, kSig_i_v)
        .addBody(wasmI32Const(i + delta))
        .exportFunc();
  }
  return builder;
}

function checkForDebugCode(instance) {
  for (let i = 0; i < num_functions; ++i) {
    // Call the function once because of lazy compilation.
    instance.exports['f' + i]();
    assertTrue(%IsWasmDebugFunction(instance.exports['f' + i]));
  }
}

function check(instance) {
  %WasmEnterDebugging();
  checkForDebugCode(instance);

  for (let i = 0; i < num_functions; ++i) {
    %WasmTierUpFunction(instance.exports['f' + i]);
  }
  checkForDebugCode(instance);
}

(function testTierDownToLiftoff() {
  print(arguments.callee.name);
  const instance = create_builder().instantiate();
  check(instance);
})();

// Use slightly different module for this test to avoid sharing native module.
async function testTierDownToLiftoffAsync() {
  print(arguments.callee.name);
  const instance = await create_builder(num_functions).asyncInstantiate();
  check(instance);
}

assertPromiseResult(testTierDownToLiftoffAsync());
                                                                        node-23.7.0/deps/v8/test/mjsunit/wasm/errors.js                                                     0000664 0000000 0000000 00000015274 14746647661 0021347 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --allow-natives-syntax

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function builder() {
  return new WasmModuleBuilder;
}

function assertCompileError(bytes, msg) {
  assertThrows(
      () => new WebAssembly.Module(bytes), WebAssembly.CompileError,
      'WebAssembly.Module(): ' + msg);
  assertThrowsAsync(
      WebAssembly.compile(bytes), WebAssembly.CompileError,
      'WebAssembly.compile(): ' + msg);
}

function assertInstantiateError(error, bytes, imports = {}, msg) {
  assertThrows(
      () => new WebAssembly.Instance(new WebAssembly.Module(bytes), imports),
      error, 'WebAssembly.Instance(): ' + msg);
  assertThrowsAsync(
      WebAssembly.instantiate(bytes, imports), error,
      'WebAssembly.instantiate(): ' + msg);
}

// default imports to {} so we get LinkError by default, thus allowing us to
// distinguish the TypeError we want to catch
function assertTypeError(bytes, imports = {}, msg) {
  assertInstantiateError(TypeError, bytes, imports, msg);
}

function assertLinkError(bytes, imports, msg) {
  assertInstantiateError(WebAssembly.LinkError, bytes, imports, msg);
}

function assertConversionError(bytes, imports, msg) {
  let instance =
      new WebAssembly.Instance(new WebAssembly.Module(bytes), imports);
  assertThrows(() => instance.exports.run(), TypeError, msg);
}

(function TestDecodingError() {
  print(arguments.callee.name);
  assertCompileError(bytes(), 'BufferSource argument is empty');
  assertCompileError(bytes('X'), 'expected 4 bytes, fell off end @+0');
  assertCompileError(
      bytes('\0x00asm'),
      'expected magic word 00 61 73 6d, found 00 78 30 30 @+0');
})();

(function TestValidationError() {
  print(arguments.callee.name);
  let error = msg => 'Compiling function #0 failed: ' + msg;
  let f_error = msg => 'Compiling function #0:"f" failed: ' + msg;
  assertCompileError(
      (function build() {
        let b = builder();
        b.addType(kSig_v_v);
        // Use explicit section because the builder would automatically emit
        // e.g. locals declarations.
        // 1 function with type 0.
        b.addExplicitSection([kFunctionSectionCode, 2, 1, 0]);
        // 1 function body with length 0.
        b.addExplicitSection([kCodeSectionCode, 2, 1, 0]);
        return b.toBuffer();
      })(),
      error('reached end while decoding local decls count @+22'));
  assertCompileError(
      builder().addFunction('f', kSig_i_v).end().toBuffer(),
      f_error('function body must end with "end" opcode @+24'));
  assertCompileError(
      builder().addFunction('f', kSig_i_v).addBody([kExprReturn])
          .end().toBuffer(),
      f_error('expected 1 elements on the stack for return, found 0 @+24'));
  assertCompileError(builder().addFunction('f', kSig_v_v).addBody([
    kExprLocalGet, 0
  ]).end().toBuffer(), f_error('invalid local index: 0 @+24'));
  assertCompileError(
      builder().addStart(0).toBuffer(),
      'function index 0 out of bounds (0 entries) @+10');
})();

function import_error(index, module, func, msg) {
  let full_msg = 'Import #' + index + ' \"' + module + '\"';
  if (func !== undefined) full_msg += ' \"' + func + '\"';
  return full_msg + ': ' + msg;
}

(function TestTypeError() {
  print(arguments.callee.name);
  let b = builder();
  b.addImport('foo', 'bar', kSig_v_v);
  let msg =
      import_error(0, 'foo', undefined, 'module is not an object or function');
  assertTypeError(b.toBuffer(), {}, msg);

  b = builder();
  b.addImportedGlobal('foo', 'bar', kWasmI32);
  assertTypeError(b.toBuffer(), {}, msg);

  b = builder();
  b.addImportedMemory('foo', 'bar');
  assertTypeError(b.toBuffer(), {}, msg);
})();

(function TestLinkingError() {
  print(arguments.callee.name);
  let b;
  let msg;

  b = builder();
  msg = import_error(0, 'foo', 'bar', 'function import requires a callable');
  b.addImport('foo', 'bar', kSig_v_v);
  assertLinkError(b.toBuffer(), {foo: {}}, msg);
  b = builder();
  b.addImport('foo', 'bar', kSig_v_v);
  assertLinkError(b.toBuffer(), {foo: {bar: 9}}, msg);

  b = builder();
  msg = import_error(
      0, 'foo', 'bar',
      'global import must be a number, valid Wasm reference, '
        + 'or WebAssembly.Global object');
  b.addImportedGlobal('foo', 'bar', kWasmI32);
  assertLinkError(b.toBuffer(), {foo: {}}, msg);
  b = builder();
  b.addImportedGlobal('foo', 'bar', kWasmI32);
  assertLinkError(b.toBuffer(), {foo: {bar: ''}}, msg);
  b = builder();
  b.addImportedGlobal('foo', 'bar', kWasmI32);
  assertLinkError(b.toBuffer(), {foo: {bar: () => 9}}, msg);

  b = builder();
  msg = import_error(
      0, 'foo', 'bar', 'memory import must be a WebAssembly.Memory object');
  b.addImportedMemory('foo', 'bar');
  assertLinkError(b.toBuffer(), {foo: {}}, msg);
  b = builder();
  b.addImportedMemory('foo', 'bar', 1);
  assertLinkError(
      b.toBuffer(), {foo: {bar: () => new WebAssembly.Memory({initial: 0})}},
      msg);
})();

(function TestTrapUnreachable() {
  print(arguments.callee.name);
  let instance = builder().addFunction('run', kSig_v_v)
    .addBody([kExprUnreachable]).exportFunc().end().instantiate();
  assertTraps(kTrapUnreachable, instance.exports.run);
})();

(function TestTrapDivByZero() {
  print(arguments.callee.name);
  let instance = builder().addFunction('run', kSig_v_v).addBody(
     [kExprI32Const, 1, kExprI32Const, 0, kExprI32DivS, kExprDrop])
    .exportFunc().end().instantiate();
  assertTraps(kTrapDivByZero, instance.exports.run);
})();

(function TestUnreachableInStart() {
  print(arguments.callee.name);

  let b = builder().addFunction("start", kSig_v_v).addBody(
     [kExprUnreachable]).end().addStart(0);
  assertTraps(kTrapUnreachable, () => b.instantiate());
})();

(function InternalDebugTrace() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  var sig = builder.addType(kSig_i_dd);
  builder.addImport("mod", "func", sig);
  builder.addFunction("main", sig)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprCallFunction, 0])
    .exportAs("main");
  var main = builder.instantiate({
    mod: {
      func: ()=>{%DebugTrace();}
    }
  }).exports.main;
  main();
})();

(function TestMultipleCorruptFunctions() {
  print(arguments.callee.name);
  // Generate a module with multiple corrupt functions. The error message must
  // be deterministic.
  var builder = new WasmModuleBuilder();
  var sig = builder.addType(kSig_v_v);
  for (let i = 0; i < 10; ++i) {
    builder.addFunction('f' + i, sig).addBody([kExprEnd]);
  }
  assertCompileError(
      builder.toBuffer(),
      'Compiling function #0:"f0" failed: ' +
          'trailing code after function end @+33');
})();
                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/test/mjsunit/wasm/exceptions-api.js                                             0000664 0000000 0000000 00000027373 14746647661 0022766 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestImport() {
  print(arguments.callee.name);

  assertThrows(() => new WebAssembly.Tag(), TypeError,
      /Argument 0 must be a tag type/);
  assertThrows(() => new WebAssembly.Tag({}), TypeError,
      /Argument 0 must be a tag type with 'parameters'/);
  assertThrows(() => new WebAssembly.Tag({parameters: ['foo']}), TypeError,
      /Argument 0 parameter type at index #0 must be a value type/);
  assertThrows(() => new WebAssembly.Tag({parameters: {}}), TypeError,
      /Argument 0 contains parameters without 'length'/);

  let js_except_i32 = new WebAssembly.Tag({parameters: ['i32']});
  let js_except_v = new WebAssembly.Tag({parameters: []});
  let builder = new WasmModuleBuilder();
  builder.addImportedTag("m", "ex", kSig_v_i);

  assertDoesNotThrow(() => builder.instantiate({ m: { ex: js_except_i32 }}));
  assertThrows(
      () => builder.instantiate({ m: { ex: js_except_v }}), WebAssembly.LinkError,
      /imported tag does not match the expected type/);
  assertThrows(
      () => builder.instantiate({ m: { ex: js_except_v }}), WebAssembly.LinkError,
      /imported tag does not match the expected type/);
  assertTrue(js_except_i32.toString() == "[object WebAssembly.Tag]");
})();

(function TestExport() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  builder.addExportOfKind("ex", kExternalTag, except);
  let instance = builder.instantiate();

  assertTrue(Object.prototype.hasOwnProperty.call(instance.exports, 'ex'));
  assertEquals("object", typeof instance.exports.ex);
  assertInstanceof(instance.exports.ex, WebAssembly.Tag);
  assertSame(instance.exports.ex.constructor, WebAssembly.Tag);
})();

(function TestImportExport() {
  print(arguments.callee.name);

  let js_ex_i32 = new WebAssembly.Tag({parameters: ['i32']});
  let builder = new WasmModuleBuilder();
  let index = builder.addImportedTag("m", "ex", kSig_v_i);
  builder.addExportOfKind("ex", kExternalTag, index);

  let instance = builder.instantiate({ m: { ex: js_ex_i32 }});
  let res = instance.exports.ex;
  assertEquals(res, js_ex_i32);
})();


(function TestExceptionConstructor() {
  print(arguments.callee.name);
  // Check errors.
  let js_tag = new WebAssembly.Tag({parameters: []});
  assertThrows(() => new WebAssembly.Exception(0), TypeError,
      /Argument 0 must be a WebAssembly tag/);
  assertThrows(() => new WebAssembly.Exception({}), TypeError,
      /Argument 0 must be a WebAssembly tag/);
  assertThrows(() => WebAssembly.Exception(js_tag), TypeError,
      /WebAssembly.Exception must be invoked with 'new'/);
  let js_exception = new WebAssembly.Exception(js_tag, []);

  // Check prototype.
  assertSame(WebAssembly.Exception.prototype, js_exception.__proto__);
  assertTrue(js_exception instanceof WebAssembly.Exception);
  assertFalse(js_exception instanceof Error);

  // Check prototype of a thrown exception.
  let builder = new WasmModuleBuilder();
  let wasm_tag = builder.addTag(kSig_v_v);
  builder.addFunction("throw", kSig_v_v)
      .addBody([kExprThrow, wasm_tag]).exportFunc();
  let instance = builder.instantiate();
  try {
    instance.exports.throw();
  } catch (e) {
    assertTrue(e instanceof WebAssembly.Exception);
  }
})();

(function TestExceptionConstructorWithPayload() {
  print(arguments.callee.name);
  let tag = new WebAssembly.Tag(
      {parameters: ['i32', 'f32', 'i64', 'f64', 'externref']});
  assertThrows(() => new WebAssembly.Exception(
      tag, [1n, 2, 3n, 4, {}]), TypeError);
  assertThrows(() => new WebAssembly.Exception(
      tag, {}), TypeError, /Exception values argument has no length/);
  assertThrows(() => new WebAssembly.Exception(
      tag, []), TypeError,
      /Number of exception values does not match signature length/);
  assertDoesNotThrow(() => new WebAssembly.Exception(tag, [3, 4, 5n, 6, {}]));
})();

(function TestExceptionStackTrace() {
  print(arguments.callee.name);
  let tag = new WebAssembly.Tag({parameters: []});
  let exn = new WebAssembly.Exception(tag, []);
  assertEquals(undefined, exn.stack);
  exn = new WebAssembly.Exception(tag, [], {traceStack: false});
  assertEquals(undefined, exn.stack);
  exn = new WebAssembly.Exception(tag, [], {traceStack: true});
  assertTrue(exn.stack.indexOf(arguments.callee.name) > 0);
  assertThrows(() => new WebAssembly.Exception(tag, [], 0), TypeError,
               /Argument 2 is not an object/);
})();

(function TestCatchJSException() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let js_tag = new WebAssembly.Tag({parameters: []});
  let js_func_index = builder.addImport('m', 'js_func', kSig_v_v);
  let js_tag_index = builder.addImportedTag("m", "js_tag", kSig_v_v);
  let tag_index = builder.addTag(kSig_v_v);
  builder.addExportOfKind("wasm_tag", kExternalTag, tag_index);
  builder.addFunction("catch", kSig_i_v)
      .addBody([
        kExprTry, kWasmI32,
        kExprCallFunction, js_func_index,
        kExprI32Const, 0,
        kExprCatch, js_tag_index,
        kExprI32Const, 1,
        kExprCatch, tag_index,
        kExprI32Const, 2,
        kExprEnd
      ]).exportFunc();
  let tag;
  function js_func() {
    throw new WebAssembly.Exception(tag, []);
  }
  let instance = builder.instantiate({m: {js_func, js_tag}});
  tag = js_tag;
  assertEquals(1, instance.exports.catch());
  tag = instance.exports.wasm_tag;
  assertEquals(2, instance.exports.catch());
})();

function TestCatchJS(types_str, types, values) {
  // Create a JS exception, catch it in wasm and check the unpacked value(s).
  let builder = new WasmModuleBuilder();
  let js_tag = new WebAssembly.Tag({parameters: types_str});
  let js_func_index = builder.addImport('m', 'js_func', kSig_v_v);
  let sig1 = makeSig(types, []);
  let sig2 = makeSig([], types);
  let js_tag_index = builder.addImportedTag("m", "js_tag", sig1);
  let tag_index = builder.addTag(sig1);
  let return_type = builder.addType(sig2);
  builder.addExportOfKind("wasm_tag", kExternalTag, tag_index);
  builder.addFunction("catch", sig2)
      .addBody([
        kExprTry, return_type,
        kExprCallFunction, js_func_index,
        kExprUnreachable,
        kExprCatch, js_tag_index,
        kExprCatch, tag_index,
        kExprEnd
      ]).exportFunc();
  let exception;
  function js_func() {
    throw exception;
  }
  let expected = values.length == 1 ? values[0] : values;
  let instance = builder.instantiate({m: {js_func, js_tag}});
  exception = new WebAssembly.Exception(js_tag, values);
  assertEquals(expected, instance.exports.catch());
  exception = new WebAssembly.Exception(instance.exports.wasm_tag, values);
  assertEquals(expected, instance.exports.catch());
}

(function TestCatchJSExceptionWithPayload() {
  print(arguments.callee.name);
  TestCatchJS(['i32'], [kWasmI32], [1]);
  TestCatchJS(['i64'], [kWasmI64], [2n]);
  TestCatchJS(['f32'], [kWasmF32], [3]);
  TestCatchJS(['f64'], [kWasmF64], [4]);
  TestCatchJS(['externref'], [kWasmExternRef], [{value: 5}]);
  TestCatchJS(['i32', 'i64', 'f32', 'f64', 'externref'],
              [kWasmI32, kWasmI64, kWasmF32, kWasmF64, kWasmExternRef],
              [6, 7n, 8, 9, {value: 10}]);
})();

function TestGetArgHelper(types_str, types, values) {
  let tag = new WebAssembly.Tag({parameters: types_str});
  let exception = new WebAssembly.Exception(tag, values);
  for (i = 0; i < types.length; ++i) {
    assertEquals(exception.getArg(tag, i), values[i]);
  }

  let builder = new WasmModuleBuilder();
  let sig = makeSig(types, []);
  let tag_index = builder.addImportedTag("m", "t", sig);
  let body = [];
  for (i = 0; i < types.length; ++i) {
    body.push(kExprLocalGet, i);
  }
  body.push(kExprThrow, tag_index);
  builder.addFunction("throw", sig)
      .addBody(body).exportFunc();
  let instance = builder.instantiate({'m': {'t': tag}});
  try {
    instance.exports.throw(...values);
  } catch (e) {
    for (i = 0; i < types.length; ++i) {
      assertEquals(e.getArg(tag, i), values[i]);
    }
  }
}

(function TestGetArg() {
  print(arguments.callee.name);
  // Check errors.
  let tag = new WebAssembly.Tag({parameters: ['i32']});
  let exception = new WebAssembly.Exception(tag, [0]);
  assertThrows(() => exception.getArg(0, 0), TypeError,
      /Argument 0 must be a WebAssembly.Tag/);
  assertThrows(() => exception.getArg({}, 0), TypeError,
      /Argument 0 must be a WebAssembly.Tag/);
  assertThrows(() => exception.getArg(tag, undefined), TypeError,
      /Index must be convertible to a valid number/);
  assertThrows(() => exception.getArg(tag, 0xFFFFFFFF), RangeError,
      /Index out of range/);
  let wrong_tag = new WebAssembly.Tag({parameters: ['i32']});
  assertThrows(() => exception.getArg(wrong_tag, 0), TypeError,
      /First argument does not match the exception tag/);

  // Check decoding.
  TestGetArgHelper(['i32'], [kWasmI32], [1]);
  TestGetArgHelper(['i64'], [kWasmI64], [2n]);
  TestGetArgHelper(['f32'], [kWasmF32], [3]);
  TestGetArgHelper(['f64'], [kWasmF64], [4]);
  TestGetArgHelper(['externref'], [kWasmExternRef], [{val: 5}]);
  TestGetArgHelper(['i32', 'i64', 'f32', 'f64', 'externref'], [kWasmI32, kWasmI64, kWasmF32, kWasmF64, kWasmExternRef], [5, 6n, 7, 8, {val: 9}]);
})();

(function TestExceptionIs() {
  print(arguments.callee.name);
  let tag1 = new WebAssembly.Tag({parameters: []});
  let tag2 = new WebAssembly.Tag({parameters: []});
  assertThrows(() => new WebAssembly.Exception({}, []), TypeError,
      /Argument 0 must be a WebAssembly tag/);

  let exception = new WebAssembly.Exception(tag1, []);
  assertTrue(exception.is(tag1));
  assertFalse(exception.is(tag2));

  assertThrows(() => exception.is.apply({}, tag1), TypeError,
      /Receiver is not a WebAssembly.Exception/);
})();

(function TestJSTag() {
  print(arguments.callee.name);
  assertTrue(WebAssembly.JSTag instanceof WebAssembly.Tag);
  let desc = Object.getOwnPropertyDescriptor(WebAssembly, 'JSTag');
  assertEquals(typeof desc.value, 'object');
  assertFalse(desc.writable);
  assertFalse(desc.enumerable);
  assertTrue(desc.configurable);
})();

(function TestCatchJSTag() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let js_tag = builder.addImportedTag("", "tag", kSig_v_r);

  // Throw a JS object and check that we can catch it and unpack it using
  // WebAssembly.JSTag.
  function throw_ref(x) {
    throw x;
  }
  let kJSThrowRef = builder.addImport("", "throw_ref", kSig_r_r);
  try_sig_index = builder.addType(kSig_r_v);
  builder.addFunction("test", kSig_r_r)
    .addBody([
      kExprTry, try_sig_index,
        kExprLocalGet, 0,
        kExprCallFunction, kJSThrowRef,
      kExprCatch, js_tag,
      kExprEnd,
    ])
    .exportFunc();

  let instance = builder.instantiate({"": {
      throw_ref: throw_ref,
      tag: WebAssembly.JSTag,
  }});

  let obj = {};
  // Creating a WA.Exception with the JSTag explicitly is not allowed.
  assertThrows(() => new WebAssembly.Exception(WebAssembly.JSTag, [obj]), TypeError);

  // Catch with implicit wrapping.
  assertSame(obj, instance.exports.test(obj));
  // Don't catch with explicit wrapping.
  let not_js_tag = new WebAssembly.Tag({parameters:['externref']});
  let exn = new WebAssembly.Exception(not_js_tag, [obj]);
  assertThrowsEquals(() => instance.exports.test(exn), exn);


  // There is a separate code path for tags with externref type, so also check
  // that everything still works when the tag is *not* the JSTag.

  instance = builder.instantiate({"": {
      throw_ref: throw_ref,
      tag: not_js_tag
  }});

  // Catch with explicit wrapping.
  assertSame(obj, instance.exports.test(new WebAssembly.Exception(not_js_tag, [obj])));
  // Don't catch with implicit wrapping.
  assertThrowsEquals(() => instance.exports.test(obj), obj);
})();
                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/wasm/exceptions-export.js                                          0000664 0000000 0000000 00000004232 14746647661 0023523 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestExportMultiple() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except1 = builder.addTag(kSig_v_v);
  let except2 = builder.addTag(kSig_v_i);
  builder.addExportOfKind("ex1a", kExternalTag, except1);
  builder.addExportOfKind("ex1b", kExternalTag, except1);
  builder.addExportOfKind("ex2", kExternalTag, except2);
  let instance = builder.instantiate();

  assertTrue(Object.prototype.hasOwnProperty.call(instance.exports, 'ex1a'));
  assertTrue(Object.prototype.hasOwnProperty.call(instance.exports, 'ex1b'));
  assertTrue(Object.prototype.hasOwnProperty.call(instance.exports, 'ex2'));
  assertSame(instance.exports.ex1a, instance.exports.ex1b);
  assertNotSame(instance.exports.ex1a, instance.exports.ex2);
})();

(function TestExportOutOfBounds() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  builder.addExportOfKind("ex_oob", kExternalTag, except + 1);
  assertThrows(
      () => builder.instantiate(), WebAssembly.CompileError,
      'WebAssembly.Module(): tag index 1 out of bounds (1 entry) @+30');
})();

(function TestExportSameNameTwice() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  builder.addExportOfKind("ex", kExternalTag, except);
  builder.addExportOfKind("ex", kExternalTag, except);
  assertThrows(
      () => builder.instantiate(), WebAssembly.CompileError,
      'WebAssembly.Module(): Duplicate export name \'ex\' ' +
          'for tag 0 and tag 0 @+28');
})();

(function TestExportModuleGetExports() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  builder.addExportOfKind("ex", kExternalTag, except);
  let module = new WebAssembly.Module(builder.toBuffer());

  let exports = WebAssembly.Module.exports(module);
  assertArrayEquals([{ name: "ex", kind: "tag" }], exports);
})();
                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/wasm/exceptions-externref.js                                       0000664 0000000 0000000 00000006446 14746647661 0024215 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
d8.file.execute("test/mjsunit/wasm/exceptions-utils.js");

// Test the encoding of a thrown exception with a null-ref value.
(function TestThrowRefNull() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_r);
  builder.addFunction("throw_null", kSig_v_v)
      .addBody([
        kExprRefNull, kExternRefCode,
        kExprThrow, except,
      ]).exportFunc();
  let instance = builder.instantiate();

  assertWasmThrows(instance, except, [null],
                   () => instance.exports.throw_null());
})();

// Test throwing/catching the null-ref value.
(function TestThrowCatchRefNull() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_r);
  builder.addFunction("throw_catch_null", kSig_i_i)
      .addBody([
        kExprTry, kWasmI32,
          kExprLocalGet, 0,
          kExprI32Eqz,
          kExprIf, kWasmI32,
            kExprRefNull, kExternRefCode,
            kExprThrow, except,
          kExprElse,
            kExprI32Const, 42,
          kExprEnd,
        kExprCatch, except,
          kExprRefIsNull,
          kExprIf, kWasmI32,
            kExprI32Const, 23,
          kExprElse,
            kExprUnreachable,
          kExprEnd,
        kExprEnd,
      ]).exportFunc();
  let instance = builder.instantiate();

  assertEquals(23, instance.exports.throw_catch_null(0));
  assertEquals(42, instance.exports.throw_catch_null(1));
})();

// Test the encoding of a thrown exception with a reference type value.
(function TestThrowRefParam() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_r);
  builder.addFunction("throw_param", kSig_v_r)
      .addBody([
        kExprLocalGet, 0,
        kExprThrow, except,
      ]).exportFunc();
  let instance = builder.instantiate();
  let o = new Object();

  assertWasmThrows(instance, except, [o],
                   () => instance.exports.throw_param(o));
  assertWasmThrows(instance, except, [1],
                   () => instance.exports.throw_param(1));
  assertWasmThrows(instance, except, [2.3],
                   () => instance.exports.throw_param(2.3));
  assertWasmThrows(instance, except, ["str"],
                   () => instance.exports.throw_param("str"));
})();

// Test throwing/catching the reference type value.
(function TestThrowCatchRefParam() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_r);
  builder.addFunction("throw_catch_param", kSig_r_r)
      .addBody([
        kExprTry, kExternRefCode,
          kExprLocalGet, 0,
          kExprThrow, except,
        kExprCatch, except,
          // fall-through
        kExprEnd,
      ]).exportFunc();
  let instance = builder.instantiate();
  let o = new Object();

  assertEquals(o, instance.exports.throw_catch_param(o));
  assertEquals(1, instance.exports.throw_catch_param(1));
  assertEquals(2.3, instance.exports.throw_catch_param(2.3));
  assertEquals("str", instance.exports.throw_catch_param("str"));
})();
                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/wasm/exceptions-gc.js                                              0000664 0000000 0000000 00000016775 14746647661 0022612 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
d8.file.execute("test/mjsunit/wasm/exceptions-utils.js");

// Test throwing/catching the reference type value.
(function TestThrowCatchRefParam() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let sig = builder.addType(kSig_i_i);
  let struct = builder.addStruct([makeField(kWasmI32, true)]);

  builder.addFunction("doubler", sig)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 0, kExprI32Add])
    .exportFunc();

  builder.addFunction("struct_producer",
                      makeSig([kWasmI32], [wasmRefType(struct)]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprStructNew, struct])
    .exportFunc();

  for (let [name, code] of
      [["extern", kWasmExternRef],
       ["sig", sig],
       ["struct", struct]]) {
    let type = wasmRefNullType(code);
    let except = builder.addTag(makeSig([type], []));
    builder.addFunction("throw_catch_param_" + name, makeSig([type],[type]))
      .addBody([
        kExprTry, kWasmRefNull, code & kLeb128Mask,
          kExprLocalGet, 0,
          kExprThrow, except,
        kExprCatch, except,
          // fall-through
        kExprEnd,
      ]).exportFunc();
  }

  let instance = builder.instantiate();
  let wasm = instance.exports;

  let o = new Object();
  assertEquals(o, wasm.throw_catch_param_extern(o));
  assertEquals(1, wasm.throw_catch_param_extern(1));
  assertEquals(2.3, wasm.throw_catch_param_extern(2.3));
  assertEquals("str", wasm.throw_catch_param_extern("str"));

  let struct_obj = wasm.struct_producer(42);

  assertEquals(struct_obj, wasm.throw_catch_param_struct(struct_obj));

  let doubler_obj = wasm.doubler;
  assertEquals(doubler_obj, wasm.throw_catch_param_sig(doubler_obj));
  assertEquals(20, wasm.throw_catch_param_sig(doubler_obj)(10));
})();

// Test the encoding of a thrown exception with a null-ref value.
(function TestThrowRefNull() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct = builder.addStruct([makeField(kWasmI32, true)]);
  let except = builder.addTag(makeSig([wasmRefNullType(struct)], []));
  builder.addFunction("throw_null", kSig_v_v)
    .addBody([kExprRefNull, kNullRefCode, kExprThrow, except])
    .exportFunc();
  let instance = builder.instantiate();

  assertWasmThrows(instance, except, [null],
                   () => instance.exports.throw_null());
})();

(function TestJSToWasm() {
  print(arguments.callee.name);

  let producer = (function() {
    let builder = new WasmModuleBuilder();

    let struct = builder.addStruct([makeField(kWasmI64, true)]);
    let array = builder.addArray(wasmRefNullType(struct), true);
    let sig = builder.addType(kSig_i_ii);

    let struct_builder =
      builder.addFunction("struct_builder",
                          makeSig([kWasmI64], [wasmRefType(struct)]))
        .addBody([kExprLocalGet, 0, kGCPrefix, kExprStructNew, struct])
        .exportFunc();
    let array_builder =
      builder.addFunction("array_builder",
                          makeSig([kWasmI32], [wasmRefType(array)]))
        .addBody([kExprLocalGet, 0, kGCPrefix, kExprArrayNewDefault, array])
        .exportFunc();
    let adder = builder.addFunction("adder", sig)
      .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
      .exportFunc();

    return builder.instantiate().exports;
  })();

  let struct_obj = producer.struct_builder(42n);
  let array_obj = producer.array_builder(10);
  let function_obj = producer.adder;
  let external_obj = {};

  let tag = new WebAssembly.Tag({
    parameters: ["externref", "anyfunc", "anyref", "eqref", "i31ref",
                 "structref", "arrayref"]});
  let values_mistyped = [external_obj, 123, function_obj, struct_obj, -33,
                         struct_obj, array_obj];
  assertThrows(() => new WebAssembly.Exception(tag, values_mistyped), TypeError,
               /.* must be null \(if nullable\) or a Wasm function object/);
  let values = [external_obj, function_obj, 123, struct_obj, -33,
                struct_obj, array_obj];
  let exn = new WebAssembly.Exception(tag, values);
  // Make sure we roundtrip corretly through wasm using
  // the Exception constructor/getArg.
  for (i = 0 ; i < values.length; i++) {
    assertEquals(exn.getArg(tag, i), values[i]);
  }

  let t = () => { throw exn; }

  // Make sure objects in a JS exception object are correctly encoded as wasm
  // objects.
  let consumer = (function () {
    let builder = new WasmModuleBuilder();
    let struct = builder.addStruct([makeField(kWasmI64, true)]);
    builder.addArray(wasmRefNullType(struct), true);
    let sig = builder.addType(kSig_i_ii);
    let tag_sig = builder.addType(makeSig([
      kWasmExternRef, kWasmFuncRef, kWasmAnyRef, kWasmEqRef, kWasmI31Ref,
      kWasmStructRef, kWasmArrayRef], []));
    let throwing = builder.addImport("m", "t", kSig_i_v);
    let tag_index = builder.addImportedTag("m", "tag", tag_sig);
    builder.addFunction("catching", kSig_i_v)
      .addLocals(kWasmExternRef, 1)
      .addLocals(kWasmFuncRef, 1)
      .addLocals(kWasmAnyRef, 1)
      .addLocals(kWasmEqRef, 1)
      .addLocals(kWasmI31Ref, 1)
      .addLocals(kWasmStructRef, 1)
      .addLocals(kWasmArrayRef, 1)
      .addBody([
        kExprTry, kWasmI32,
          kExprCallFunction, throwing,
        kExprCatch, tag_index,
          kExprLocalSet, 6,
          kExprLocalSet, 5,
          kExprLocalSet, 4,
          kExprLocalSet, 3,
          kExprLocalSet, 2,
          kExprLocalSet, 1,
          kExprLocalSet, 0,

          // adder(10, 20)
          kExprI32Const, 10, kExprI32Const, 20,
          kExprLocalGet, 1, kGCPrefix, kExprRefCast, sig, kExprCallRef, sig,

          // 123
          kExprLocalGet, 2, kGCPrefix, kExprRefCast, kI31RefCode,
          kGCPrefix, kExprI31GetS,

          // (i32) struct(42l).get_0
          kExprLocalGet, 3, kGCPrefix, kExprRefCast, struct,
          kGCPrefix, kExprStructGet, struct, 0, kExprI32ConvertI64,

          // -33
          kExprLocalGet, 4, kGCPrefix, kExprI31GetS,

          // (i32) struct(42l).get_0
          kExprLocalGet, 5, kGCPrefix, kExprRefCast, struct,
          kGCPrefix, kExprStructGet, struct, 0, kExprI32ConvertI64,

          // array.length
          kExprLocalGet, 6, kGCPrefix, kExprArrayLen,

          // Now add them all up.
          kExprI32Add, kExprI32Add, kExprI32Add, kExprI32Add, kExprI32Add,
        kExprEnd])
      .exportFunc()

    return builder.instantiate({m: {t: t, tag: tag}}).exports
  })();

  assertEquals(30 + 123 + 42 + (-33) + 42 + 10, consumer.catching());
})();

(function TestWasmToJS() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();

  let sig = builder.addType(kSig_i_ii);

  let adder = builder.addFunction("adder", sig)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
    .exportFunc();

  let tag = builder.addTag(makeSig([kWasmFuncRef, kWasmFuncRef], []));
  builder.addExportOfKind("tag", kExternalTag, tag);

  builder.addFunction("thrower", kSig_v_v)
    .addBody([kExprRefNull, kFuncRefCode, kExprRefFunc, adder.index,
              kExprThrow, tag])
    .exportFunc();

  let wasm = builder.instantiate().exports;

  // Make sure objects thrown from Wasm and retrieved with getArg are correctly
  // decoded as JS objects.
  try { wasm.thrower() }
  catch (e) {
    assertEquals(null, e.getArg(wasm.tag, 0));
    assertEquals(99, e.getArg(wasm.tag, 1)(44, 55));
  }
})();
   node-23.7.0/deps/v8/test/mjsunit/wasm/exceptions-import.js                                          0000664 0000000 0000000 00000006605 14746647661 0023522 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// Helper function to return a new exported exception with the {kSig_v_v} type
// signature from an anonymous module. The underlying module is thrown away.
// This allows tests to reason solely about importing exceptions.
function NewExportedTag() {
  let builder = new WasmModuleBuilder();
  let tag = builder.addTag(kSig_v_v);
  builder.addExportOfKind("t", kExternalTag, tag);
  let instance = builder.instantiate();
  return instance.exports.t;
}

(function TestImportSimple() {
  print(arguments.callee.name);
  let exported = NewExportedTag();
  let builder = new WasmModuleBuilder();
  let except = builder.addImportedTag("m", "ex", kSig_v_v);

  assertDoesNotThrow(() => builder.instantiate({ m: { ex: exported }}));
})();

(function TestImportMultiple() {
  print(arguments.callee.name);
  let exported = NewExportedTag();
  let builder = new WasmModuleBuilder();
  let except1 = builder.addImportedTag("m", "ex1", kSig_v_v);
  let except2 = builder.addImportedTag("m", "ex2", kSig_v_v);
  let except3 = builder.addTag(kSig_v_v);
  builder.addExportOfKind("ex2", kExternalTag, except2);
  builder.addExportOfKind("ex3", kExternalTag, except3);
  let instance = builder.instantiate({ m: { ex1: exported, ex2: exported }});

  assertTrue(except1 < except3 && except2 < except3);
  assertEquals(undefined, instance.exports.ex1);
  assertSame(exported, instance.exports.ex2);
  assertNotSame(exported, instance.exports.ex3);
})();

(function TestImportMissing() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addImportedTag("m", "ex", kSig_v_v);

  assertThrows(
      () => builder.instantiate({}), TypeError,
      /module is not an object or function/);
  assertThrows(
      () => builder.instantiate({ m: {}}), WebAssembly.LinkError,
      /tag import requires a WebAssembly.Tag/);
})();

(function TestImportValueMismatch() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addImportedTag("m", "ex", kSig_v_v);

  assertThrows(
      () => builder.instantiate({ m: { ex: 23 }}), WebAssembly.LinkError,
      /tag import requires a WebAssembly.Tag/);
  assertThrows(
      () => builder.instantiate({ m: { ex: {} }}), WebAssembly.LinkError,
      /tag import requires a WebAssembly.Tag/);
  var monkey = Object.create(NewExportedTag());
  assertThrows(
      () => builder.instantiate({ m: { ex: monkey }}), WebAssembly.LinkError,
      /tag import requires a WebAssembly.Tag/);
})();

(function TestImportSignatureMismatch() {
  print(arguments.callee.name);
  let exported = NewExportedTag();
  let builder = new WasmModuleBuilder();
  let except = builder.addImportedTag("m", "ex", kSig_v_i);

  assertThrows(
      () => builder.instantiate({ m: { ex: exported }}), WebAssembly.LinkError,
      /imported tag does not match the expected type/);
})();

(function TestImportModuleGetImports() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addImportedTag("m", "ex", kSig_v_v);
  let module = new WebAssembly.Module(builder.toBuffer());

  let imports = WebAssembly.Module.imports(module);
  assertArrayEquals([{ module: "m", name: "ex", kind: "tag" }], imports);
})();
                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/wasm/exceptions-rethrow.js                                         0000664 0000000 0000000 00000010707 14746647661 0023700 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
d8.file.execute("test/mjsunit/wasm/exceptions-utils.js");

// Test that rethrow expressions can target catch blocks.
(function TestRethrowInCatch() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  builder.addFunction("rethrow0", kSig_v_v)
      .addBody([
        kExprTry, kWasmVoid,
          kExprThrow, except,
        kExprCatch, except,
          kExprRethrow, 0,
        kExprEnd,
  ]).exportFunc();
  builder.addFunction("rethrow1", kSig_i_i)
      .addBody([
        kExprTry, kWasmI32,
          kExprThrow, except,
        kExprCatch, except,
          kExprLocalGet, 0,
          kExprI32Eqz,
          kExprIf, kWasmVoid,
            kExprRethrow, 1,
          kExprEnd,
          kExprI32Const, 23,
        kExprEnd
  ]).exportFunc();
  let instance = builder.instantiate();

  assertWasmThrows(instance, except, [], () => instance.exports.rethrow0());
  assertWasmThrows(instance, except, [], () => instance.exports.rethrow1(0));
  assertEquals(23, instance.exports.rethrow1(1));
})();

// Test that rethrow expressions can target catch-all blocks.
(function TestRethrowInCatchAll() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  builder.addFunction("rethrow0", kSig_v_v)
      .addBody([
        kExprTry, kWasmVoid,
          kExprThrow, except,
        kExprCatchAll,
          kExprRethrow, 0,
        kExprEnd,
  ]).exportFunc();
  builder.addFunction("rethrow1", kSig_i_i)
      .addBody([
        kExprTry, kWasmI32,
          kExprThrow, except,
        kExprCatchAll,
          kExprLocalGet, 0,
          kExprI32Eqz,
          kExprIf, kWasmVoid,
            kExprRethrow, 1,
          kExprEnd,
          kExprI32Const, 23,
        kExprEnd
  ]).exportFunc();
  let instance = builder.instantiate();

  assertWasmThrows(instance, except, [], () => instance.exports.rethrow0());
  assertWasmThrows(instance, except, [], () => instance.exports.rethrow1(0));
  assertEquals(23, instance.exports.rethrow1(1));
})();

// Test that rethrow expression properly target the correct surrounding try
// block even in the presence of multiple handlers being involved.
(function TestRethrowNested() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except1 = builder.addTag(kSig_v_v);
  let except2 = builder.addTag(kSig_v_v);
  builder.addFunction("rethrow_nested", kSig_i_i)
      .addBody([
        kExprTry, kWasmI32,
          kExprThrow, except2,
        kExprCatch, except2,
          kExprTry, kWasmI32,
            kExprThrow, except1,
          kExprCatch, except1,
            kExprLocalGet, 0,
            kExprI32Const, 0,
            kExprI32Eq,
            kExprIf, kWasmVoid,
              kExprRethrow, 1,
            kExprEnd,
            kExprLocalGet, 0,
            kExprI32Const, 1,
            kExprI32Eq,
            kExprIf, kWasmVoid,
              kExprRethrow, 2,
            kExprEnd,
            kExprI32Const, 23,
          kExprEnd,
        kExprEnd,
  ]).exportFunc();
  let instance = builder.instantiate();

  assertWasmThrows(instance, except1, [], () => instance.exports.rethrow_nested(0));
  assertWasmThrows(instance, except2, [], () => instance.exports.rethrow_nested(1));
  assertEquals(23, instance.exports.rethrow_nested(2));
})();

// Test that an exception being rethrow can be caught by another local catch
// block in the same function without ever unwinding the activation.
(function TestRethrowRecatch() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  builder.addFunction("rethrow_recatch", kSig_i_i)
      .addBody([
        kExprTry, kWasmI32,
          kExprThrow, except,
        kExprCatch, except,
          kExprTry, kWasmI32,
            kExprLocalGet, 0,
            kExprI32Eqz,
            kExprIf, kWasmVoid,
              kExprRethrow, 2,
            kExprEnd,
            kExprI32Const, 42,
          kExprCatch, except,
            kExprI32Const, 23,
          kExprEnd,
        kExprEnd,
  ]).exportFunc();
  let instance = builder.instantiate();

  assertEquals(23, instance.exports.rethrow_recatch(0));
  assertEquals(42, instance.exports.rethrow_recatch(1));
})();
                                                         node-23.7.0/deps/v8/test/mjsunit/wasm/exceptions-shared.js                                          0000664 0000000 0000000 00000013141 14746647661 0023447 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// Helper function to return a new exported exception with the {kSig_v_v} type
// signature from an anonymous module. The underlying module is thrown away.
function NewExportedException() {
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  builder.addExportOfKind("ex", kExternalTag, except);
  let instance = builder.instantiate();
  return instance.exports.ex;
}

// Check that an instance matches an exception thrown by itself, even when the
// exception is re-thrown by a regular JavaScript function.
(function TestSingleInstance() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_v_v);
  let fun = builder.addImport("m", "f", sig_index);
  let except = builder.addTag(kSig_v_v);
  builder.addFunction("throw", kSig_v_v)
      .addBody([
        kExprThrow, except
      ]).exportFunc();
  builder.addFunction("catch", kSig_v_v)
      .addBody([
        kExprTry, kWasmVoid,
          kExprCallFunction, fun,
        kExprCatch, except,
        kExprEnd,
      ]).exportFunc();
  let ex_obj = new Error("my exception");
  let instance = builder.instantiate({ m: { f: function() { throw ex_obj }}});

  assertThrows(() => instance.exports.throw(), WebAssembly.Exception);
  assertThrowsEquals(() => instance.exports.catch(), ex_obj);
  try {
    instance.exports.throw();
  } catch (e) {
    ex_obj = e;
  }
  assertDoesNotThrow(() => instance.exports.catch());
})();

// Check that two instances distinguish their individual exceptions if they are
// not shared, even when declared by the same underlying module.
(function TestMultiInstanceNonShared() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_v_v);
  let fun = builder.addImport("m", "f", sig_index);
  let except = builder.addTag(kSig_v_v);
  builder.addFunction("throw", kSig_v_v)
      .addBody([
        kExprThrow, except
      ]).exportFunc();
  builder.addFunction("catch", kSig_v_v)
      .addBody([
        kExprTry, kWasmVoid,
          kExprCallFunction, fun,
        kExprCatch, except,
        kExprEnd,
      ]).exportFunc();
  let ex_obj = new Error("my exception");
  let instance1 = builder.instantiate({ m: { f: assertUnreachable }});
  let instance2 = builder.instantiate({ m: { f: function() { throw ex_obj }}});

  assertThrows(() => instance1.exports.throw(), WebAssembly.Exception);
  assertThrowsEquals(() => instance2.exports.catch(), ex_obj);
  try {
    instance1.exports.throw();
  } catch (e) {
    ex_obj = e;
  }
  assertThrowsEquals(() => instance2.exports.catch(), ex_obj);
})();

// Check that two instances match their exceptions if they are shared properly,
// even if the local exception index of export and import is different.
(function TestMultiInstanceShared() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_v_v);
  let fun = builder.addImport("m", "f", sig_index);
  let except1 = builder.addImportedTag("m", "ex1", kSig_v_v);
  let except2 = builder.addTag(kSig_v_v);
  builder.addExportOfKind("ex2", kExternalTag, except2);
  builder.addFunction("throw", kSig_v_v)
      .addBody([
        kExprThrow, except2
      ]).exportFunc();
  builder.addFunction("catch", kSig_v_v)
      .addBody([
        kExprTry, kWasmVoid,
          kExprCallFunction, fun,
        kExprCatch, except1,
        kExprEnd,
      ]).exportFunc();
  let ex_obj = new Error("my exception");
  let instance1 = builder.instantiate({ m: { f: assertUnreachable,
                                             ex1: NewExportedException() }});
  let instance2 = builder.instantiate({ m: { f: function() { throw ex_obj },
                                             ex1: instance1.exports.ex2 }});

  assertThrows(() => instance1.exports.throw(), WebAssembly.Exception);
  assertThrowsEquals(() => instance2.exports.catch(), ex_obj);
  try {
    instance1.exports.throw();
  } catch (e) {
    ex_obj = e;
  }
  assertDoesNotThrow(() => instance2.exports.catch());
})();

// Check that two instances based on different modules match their exceptions if
// they are shared properly, even if the local exception index is different.
(function TestMultiModuleShared() {
  print(arguments.callee.name);
  let builder1 = new WasmModuleBuilder();
  let except1 = builder1.addTag(kSig_v_v);
  let except2 = builder1.addTag(kSig_v_v);
  builder1.addExportOfKind("ex", kExternalTag, except2);
  builder1.addFunction("throw", kSig_v_v)
      .addBody([
        kExprThrow, except2
      ]).exportFunc();
  let builder2 = new WasmModuleBuilder();
  let sig_index = builder2.addType(kSig_v_v);
  let fun = builder2.addImport("m", "f", sig_index);
  let except = builder2.addImportedTag("m", "ex", kSig_v_v);
  builder2.addFunction("catch", kSig_v_v)
      .addBody([
        kExprTry, kWasmVoid,
          kExprCallFunction, fun,
        kExprCatch, except,
        kExprEnd,
      ]).exportFunc();
  let ex_obj = new Error("my exception");
  let instance1 = builder1.instantiate();
  let instance2 = builder2.instantiate({ m: { f: function() { throw ex_obj },
                                              ex: instance1.exports.ex }});

  assertThrows(() => instance1.exports.throw(), WebAssembly.Exception);
  assertThrowsEquals(() => instance2.exports.catch(), ex_obj);
  try {
    instance1.exports.throw();
  } catch (e) {
    ex_obj = e;
  }
  assertDoesNotThrow(() => instance2.exports.catch());
})();
                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/wasm/exceptions-simd.js                                            0000664 0000000 0000000 00000005164 14746647661 0023143 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
d8.file.execute("test/mjsunit/wasm/exceptions-utils.js");

(function TestThrowS128Default() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  var kSig_v_s = makeSig([kWasmS128], []);
  var except = builder.addTag(kSig_v_s);
  builder.addFunction("throw_simd", kSig_v_v)
      .addLocals(kWasmS128, 1)
      .addBody([
        kExprLocalGet, 0,
        kExprThrow, 0,
      ])
      .exportFunc();
  var instance = builder.instantiate();

  assertWasmThrows(instance, except, [0, 0, 0, 0, 0, 0, 0, 0],
                   () => instance.exports.throw_simd());
})();

(function TestThrowCatchS128Default() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  var kSig_v_s = makeSig([kWasmS128], []);
  var except = builder.addTag(kSig_v_s);
  builder.addFunction("throw_catch_simd", kSig_i_v)
      .addLocals(kWasmS128, 1)
      .addBody([
        kExprTry, kWasmS128,
          kExprLocalGet, 0,
          kExprThrow, 0,
        kExprCatch, except,
        kExprEnd,
        kExprLocalGet, 0,
        kSimdPrefix, kExprI32x4Eq,
        kSimdPrefix, kExprI8x16AllTrue,
      ])
      .exportFunc();
  var instance = builder.instantiate();

  assertEquals(1, instance.exports.throw_catch_simd());
})();

(function TestThrowCatchS128WithValue() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  var kSig_v_s = makeSig([kWasmS128], []);
  var except = builder.addTag(kSig_v_s);
  const in_idx = 0x10;   // Input index in memory.
  const out_idx = 0x20;  // Output index in memory.
  builder.addImportedMemory("env", "memory");
  builder.addFunction("throw_catch_simd", kSig_v_v)
      .addBody([
        kExprI32Const, out_idx,
        kExprTry, kWasmS128,
          kExprI32Const, in_idx,
          kSimdPrefix, kExprS128LoadMem, 0, 0,
          kExprThrow, 0,
        kExprCatch, except,
        kExprEnd,
        kSimdPrefix, kExprS128StoreMem, 0, 0,
      ])
      .exportFunc();
  var memory = new WebAssembly.Memory({initial: 1});
  var instance = builder.instantiate({env: {memory:memory}});

  var ref = [0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x67, 0x78,
             0x89, 0x9a, 0xab, 0xbc, 0xcd, 0xde, 0xef, 0xf0];
  var array = new Uint8Array(memory.buffer);
  array.set(ref, in_idx);  // Store reference value in memory.
  instance.exports.throw_catch_simd();
  assertArrayEquals(ref, array.slice(out_idx, out_idx + 0x10));
})();
                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/wasm/exceptions-type-reflection.js                                 0000664 0000000 0000000 00000003171 14746647661 0025314 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-type-reflection

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

let testcases = [
{types: {parameters:[]}, sig: kSig_v_v},
{types: {parameters:["i32"]}, sig: kSig_v_i},
{types: {parameters:["i64"]}, sig: kSig_v_l},
{types: {parameters:["f64", "f64", "i32"]}, sig: kSig_v_ddi},
{types: {parameters:["f32"]}, sig: kSig_v_f},
];

(function TestExport() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  testcases.forEach(function(expected, i) {
    let except = builder.addTag(expected.sig);
    builder.addExportOfKind("ex" + i, kExternalTag, except);
  });

  let instance = builder.instantiate();
  testcases.forEach(function(expected, i) {
    assertEquals(instance.exports["ex" + i].type(), expected.types);
  });
})();

(function TestImportExport() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();
  let imports = {m: {}};

  testcases.forEach(function(expected, i) {
    let t = new WebAssembly.Tag(expected.types);
    let index = builder.addImportedTag("m", "ex" + i, expected.sig);
    builder.addExportOfKind("ex" + i, kExternalTag, index);
    imports.m["ex" + i] = t;
  });

  let instance = builder.instantiate(imports);
  testcases.forEach(function(expected, i) {
    assertEquals(instance.exports["ex" + i].type(), expected.types);
  })
})();

(function TestJSTag() {
  print(arguments.callee.name);
  assertEquals(WebAssembly.JSTag.type(), {parameters:['externref']});
})();
                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/wasm/exceptions-utils.js                                           0000664 0000000 0000000 00000001742 14746647661 0023345 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

// This file is intended to be loaded by other tests to provide utility methods
// requiring natives syntax (and hence not suited for the mjsunit.js file).

function assertWasmThrows(instance, runtime_id, values, code) {
  try {
    if (typeof code === 'function') {
      code();
    } else {
      eval(code);
    }
  } catch (e) {
    assertInstanceof(e, WebAssembly.Exception);
    var e_runtime_id = %GetWasmExceptionTagId(e, instance);
    assertTrue(Number.isInteger(e_runtime_id));
    assertEquals(e_runtime_id, runtime_id);
    var e_values = %GetWasmExceptionValues(e);
    assertArrayEquals(values, e_values);
    return;  // Success.
  }
  throw new MjsUnitAssertionError('Did not throw expected <' + runtime_id +
                                  '> with values: ' + values);
}
                              node-23.7.0/deps/v8/test/mjsunit/wasm/exceptions.js                                                 0000664 0000000 0000000 00000104433 14746647661 0022210 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
d8.file.execute("test/mjsunit/wasm/exceptions-utils.js");

// The following method doesn't attempt to catch an raised exception.
(function TestThrowSimple() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  builder.addFunction("throw_if_param_not_zero", kSig_i_i)
      .addBody([
        kExprLocalGet, 0,
        kExprI32Const, 0,
        kExprI32Ne,
        kExprIf, kWasmVoid,
          kExprThrow, except,
        kExprEnd,
        kExprI32Const, 1
      ]).exportFunc();
  let instance = builder.instantiate();

  assertEquals(1, instance.exports.throw_if_param_not_zero(0));
  assertWasmThrows(instance, except, [],
                   () => instance.exports.throw_if_param_not_zero(10));
  assertWasmThrows(instance, except, [],
                   () => instance.exports.throw_if_param_not_zero(-1));
})();

// Test that empty try/catch blocks work.
(function TestCatchEmptyBlocks() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  builder.addFunction("catch_empty_try", kSig_v_v)
      .addBody([
        kExprTry, kWasmVoid,
        kExprCatch, except,
        kExprEnd,
      ]).exportFunc();
  let instance = builder.instantiate();

  assertDoesNotThrow(instance.exports.catch_empty_try);
})();

// Now that we know throwing works, we test catching the exceptions we raise.
(function TestCatchSimple() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  builder.addFunction("simple_throw_catch_to_0_1", kSig_i_i)
      .addBody([
        kExprTry, kWasmI32,
          kExprLocalGet, 0,
          kExprI32Eqz,
          kExprIf, kWasmVoid,
            kExprThrow, except,
          kExprEnd,
          kExprI32Const, 42,
        kExprCatch, except,
          kExprI32Const, 23,
        kExprEnd
      ]).exportFunc();
  let instance = builder.instantiate();

  assertEquals(23, instance.exports.simple_throw_catch_to_0_1(0));
  assertEquals(42, instance.exports.simple_throw_catch_to_0_1(1));
})();

(function TestTrapNotCaught() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction('unreachable_in_try', kSig_v_v)
      .addBody([
        kExprTry, kWasmVoid,
          kExprUnreachable,
        kExprCatchAll,
        kExprEnd
      ]).exportFunc();
  let instance = builder.instantiate();

  assertTraps(kTrapUnreachable, () => instance.exports.unreachable_in_try());
})();

(function TestTrapInCalleeNotCaught() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let func_div = builder.addFunction('div', kSig_i_ii).addBody([
    kExprLocalGet, 0,
    kExprLocalGet, 1,
    kExprI32DivU
  ]);
  builder.addFunction('trap_in_callee', kSig_i_ii)
      .addBody([
        kExprTry, kWasmI32,
          kExprLocalGet, 0,
          kExprLocalGet, 1,
          kExprCallFunction, func_div.index,
        kExprCatchAll,
          kExprI32Const, 11,
        kExprEnd
      ]).exportFunc();
  let instance = builder.instantiate();

  assertEquals(3, instance.exports.trap_in_callee(7, 2));
  assertTraps(kTrapDivByZero, () => instance.exports.trap_in_callee(1, 0));
})();

(function TestTrapViaJSNotCaught() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let imp = builder.addImport('imp', 'ort', kSig_i_v);
  builder.addFunction('div', kSig_i_ii)
      .addBody([
        kExprLocalGet, 0,
        kExprLocalGet, 1,
        kExprI32DivU
      ]).exportFunc();
  builder.addFunction('call_import', kSig_i_v)
      .addBody([
        kExprTry, kWasmI32,
          kExprCallFunction, imp,
        kExprCatchAll,
          kExprI32Const, 11,
        kExprEnd
      ]).exportFunc();
  let exception = undefined;
  let instance;
  function js_import() {
    try {
      instance.exports.div(1, 0);
    } catch (e) {
      exception = e;
    }
    throw exception;
  }
  instance = builder.instantiate({imp: {ort: js_import}});

  let caught = undefined;
  try {
    let res = instance.exports.call_import();
    assertUnreachable('call_import should trap, but returned with ' + res);
  } catch (e) {
    caught = e;
  }
  assertSame(exception, caught);
  assertInstanceof(exception, WebAssembly.RuntimeError);
  assertEquals(exception.message, kTrapMsgs[kTrapDivByZero]);
})();

(function TestManuallyThrownRuntimeErrorCaught() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let imp = builder.addImport('imp', 'ort', kSig_i_v);
  builder.addFunction('call_import', kSig_i_v)
      .addBody([
        kExprTry, kWasmI32,
          kExprCallFunction, imp,
        kExprCatchAll,
          kExprI32Const, 11,
        kExprEnd
      ]).exportFunc();
  function throw_exc() {
    throw new WebAssembly.RuntimeError('My user text');
  }
  let instance = builder.instantiate({imp: {ort: throw_exc}});

  assertEquals(11, instance.exports.call_import());
})();

(function TestExnWithWasmProtoNotCaught() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  let imp = builder.addImport('imp', 'ort', kSig_v_v);
  let throw_fn = builder.addFunction('throw', kSig_v_v)
                     .addBody([kExprThrow, except])
                     .exportFunc();
  builder.addFunction('test', kSig_v_v)
      .addBody([
        // Calling "throw" directly should produce the expected exception.
        kExprTry, kWasmVoid,
          kExprCallFunction, throw_fn.index,
        kExprCatch, except,
        kExprEnd,
        // Calling through JS produces a wrapped exceptions which does not match
        // the catch.
        kExprTry, kWasmVoid,
          kExprCallFunction, imp,
        kExprCatch, except,
        kExprEnd
      ]).exportFunc();
  let instance;
  let wrapped_exn;
  function js_import() {
    try {
      instance.exports.throw();
    } catch (e) {
      wrapped_exn = new Error();
      wrapped_exn.__proto__ = e;
      throw wrapped_exn;
    }
  }
  instance = builder.instantiate({imp: {ort: js_import}});
  let caught = undefined;
  try {
    instance.exports.test();
  } catch (e) {
    caught = e;
  }
  assertTrue(!!caught, 'should have trapped');
  assertEquals(caught, wrapped_exn);
  assertInstanceof(caught.__proto__, WebAssembly.Exception);
})();

(function TestStackOverflowNotCaught() {
  print(arguments.callee.name);
  function stack_overflow() {
    %ThrowStackOverflow();
  }
  let builder = new WasmModuleBuilder();
  let sig_v_v = builder.addType(kSig_v_v);
  let kStackOverflow = builder.addImport('', 'stack_overflow', sig_v_v);
  builder.addFunction('try_stack_overflow', kSig_v_v)
      .addBody([
        kExprTry, kWasmVoid,
          kExprCallFunction, 0,
        kExprCatchAll,
        kExprEnd
      ]).exportFunc();
  let instance = builder.instantiate({'': {'stack_overflow': stack_overflow}});

  assertThrows(() => instance.exports.try_stack_overflow(),
      RangeError, 'Maximum call stack size exceeded');
})();

// Test that we can distinguish which exception was thrown by using a cascaded
// sequence of nested try blocks with a single catch block each.
(function TestCatchComplex1() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except1 = builder.addTag(kSig_v_v);
  let except2 = builder.addTag(kSig_v_v);
  let except3 = builder.addTag(kSig_v_v);
  builder.addFunction("catch_complex", kSig_i_i)
      .addBody([
        kExprTry, kWasmI32,
          kExprTry, kWasmI32,
            kExprLocalGet, 0,
            kExprI32Eqz,
            kExprIf, kWasmVoid,
              kExprThrow, except1,
            kExprElse,
              kExprLocalGet, 0,
              kExprI32Const, 1,
              kExprI32Eq,
              kExprIf, kWasmVoid,
                kExprThrow, except2,
              kExprElse,
                kExprThrow, except3,
              kExprEnd,
            kExprEnd,
            kExprI32Const, 2,
          kExprCatch, except1,
            kExprI32Const, 3,
          kExprEnd,
        kExprCatch, except2,
          kExprI32Const, 4,
        kExprEnd,
      ]).exportFunc();
  let instance = builder.instantiate();

  assertEquals(3, instance.exports.catch_complex(0));
  assertEquals(4, instance.exports.catch_complex(1));
  assertWasmThrows(instance, except3, [],
                   () => instance.exports.catch_complex(2));
})();

// Test that we can distinguish which exception was thrown by using a single
// try block with multiple associated catch blocks in sequence.
(function TestCatchComplex2() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except1 = builder.addTag(kSig_v_v);
  let except2 = builder.addTag(kSig_v_v);
  let except3 = builder.addTag(kSig_v_v);
  builder.addFunction("catch_complex", kSig_i_i)
      .addBody([
        kExprTry, kWasmI32,
          kExprLocalGet, 0,
          kExprI32Eqz,
          kExprIf, kWasmVoid,
            kExprThrow, except1,
          kExprElse,
            kExprLocalGet, 0,
            kExprI32Const, 1,
            kExprI32Eq,
            kExprIf, kWasmVoid,
              kExprThrow, except2,
            kExprElse,
              kExprThrow, except3,
            kExprEnd,
          kExprEnd,
          kExprI32Const, 2,
        kExprCatch, except1,
          kExprI32Const, 3,
        kExprCatch, except2,
          kExprI32Const, 4,
        kExprEnd,
      ]).exportFunc();
  let instance = builder.instantiate();

  assertEquals(3, instance.exports.catch_complex(0));
  assertEquals(4, instance.exports.catch_complex(1));
  assertWasmThrows(instance, except3, [],
                   () => instance.exports.catch_complex(2));
})();

// Test throwing an exception with multiple values.
(function TestThrowMultipleValues() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_ii);
  builder.addFunction("throw_1_2", kSig_v_v)
      .addBody([
        kExprI32Const, 1,
        kExprI32Const, 2,
        kExprThrow, except,
      ]).exportFunc();
  let instance = builder.instantiate();

  assertWasmThrows(instance, except, [0, 1, 0, 2],
                   () => instance.exports.throw_1_2());
})();

// Test throwing/catching the i32 parameter value.
(function TestThrowCatchParamI() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_i);
  builder.addFunction("throw_catch_param", kSig_i_i)
      .addBody([
        kExprTry, kWasmI32,
          kExprLocalGet, 0,
          kExprThrow, except,
          kExprI32Const, 2,
        kExprCatch, except,
          kExprReturn,
        kExprEnd,
      ]).exportFunc();
  let instance = builder.instantiate();

  assertEquals(0, instance.exports.throw_catch_param(0));
  assertEquals(1, instance.exports.throw_catch_param(1));
  assertEquals(10, instance.exports.throw_catch_param(10));
})();

// Test the encoding of a thrown exception with an integer exception.
(function TestThrowParamI() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_i);
  builder.addFunction("throw_param", kSig_v_i)
      .addBody([
        kExprLocalGet, 0,
        kExprThrow, except,
      ]).exportFunc();
  let instance = builder.instantiate();

  assertWasmThrows(instance, except, [0, 5],
                   () => instance.exports.throw_param(5));
  assertWasmThrows(instance, except, [6, 31026],
                   () => instance.exports.throw_param(424242));
})();

// Test throwing/catching the f32 parameter value.
(function TestThrowCatchParamF() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_f);
  builder.addFunction("throw_catch_param", kSig_f_f)
      .addBody([
        kExprTry, kWasmF32,
          kExprLocalGet, 0,
          kExprThrow, except,
          kExprF32Const, 0, 0, 0, 0,
        kExprCatch, except,
          kExprReturn,
        kExprEnd,
      ]).exportFunc();
  let instance = builder.instantiate();

  assertEquals(5.0, instance.exports.throw_catch_param(5.0));
  assertEquals(10.5, instance.exports.throw_catch_param(10.5));
})();

// Test the encoding of a thrown exception with a float value.
(function TestThrowParamF() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_f);
  builder.addFunction("throw_param", kSig_v_f)
      .addBody([
        kExprLocalGet, 0,
        kExprThrow, except,
      ]).exportFunc();
  let instance = builder.instantiate();

  assertWasmThrows(instance, except, [16544, 0],
                   () => instance.exports.throw_param(5.0));
  assertWasmThrows(instance, except, [16680, 0],
                   () => instance.exports.throw_param(10.5));
})();

// Test throwing/catching an I64 value
(function TestThrowCatchParamL() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_l);
  builder.addFunction("throw_catch_param", kSig_i_i)
      .addLocals(kWasmI64, 1)
      .addBody([
        kExprLocalGet, 0,
        kExprI64UConvertI32,
        kExprLocalSet, 1,
        kExprTry, kWasmI32,
          kExprLocalGet, 1,
          kExprThrow, except,
          kExprI32Const, 2,
        kExprCatch, except,
          kExprLocalGet, 1,
          kExprI64Eq,
          kExprIf, kWasmI32,
            kExprI32Const, 1,
          kExprElse,
            kExprI32Const, 0,
          kExprEnd,
        kExprEnd,
      ]).exportFunc();
  let instance = builder.instantiate();

  assertEquals(1, instance.exports.throw_catch_param(5));
  assertEquals(1, instance.exports.throw_catch_param(0));
  assertEquals(1, instance.exports.throw_catch_param(-1));
})();

// Test the encoding of a thrown exception with an I64 value.
(function TestThrowParamL() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_l);
  builder.addFunction("throw_param", kSig_v_ii)
      .addBody([
        kExprLocalGet, 0,
        kExprI64UConvertI32,
        kExprI64Const, 32,
        kExprI64Shl,
        kExprLocalGet, 1,
        kExprI64UConvertI32,
        kExprI64Ior,
        kExprThrow, except,
      ]).exportFunc();
  let instance = builder.instantiate();

  assertWasmThrows(instance, except, [0, 10, 0, 5],
                   () => instance.exports.throw_param(10, 5));
  assertWasmThrows(instance, except, [65535, 65535, 0, 13],
                   () => instance.exports.throw_param(-1, 13));
})();

// Test throwing/catching the F64 parameter value
(function TestThrowCatchParamD() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_d);
  builder.addFunction("throw_catch_param", kSig_d_d)
      .addBody([
        kExprTry, kWasmF64,
          kExprLocalGet, 0,
          kExprThrow, except,
          kExprF64Const, 0, 0, 0, 0, 0, 0, 0, 0,
        kExprCatch, except,
          kExprReturn,
        kExprEnd,
      ]).exportFunc();
  let instance = builder.instantiate();

  assertEquals(5.0, instance.exports.throw_catch_param(5.0));
  assertEquals(10.5, instance.exports.throw_catch_param(10.5));
})();

// Test the encoding of a thrown exception with an f64 value.
(function TestThrowParamD() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_d);
  builder.addFunction("throw_param", kSig_v_f)
      .addBody([
        kExprLocalGet, 0,
        kExprF64ConvertF32,
        kExprThrow, except,
      ]).exportFunc();
  let instance = builder.instantiate();

  assertWasmThrows(instance, except, [16404, 0, 0, 0],
                   () => instance.exports.throw_param(5.0));
  assertWasmThrows(instance, except, [16739, 4816, 0, 0],
                   () => instance.exports.throw_param(10000000.5));
})();

// Test the encoding of a computed parameter value.
(function TestThrowParamComputed() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_i);
  builder.addFunction("throw_expr_with_params", kSig_v_ddi)
      .addBody([
        // p2 * (p0 + min(p0, p1))|0 - 20
        kExprLocalGet, 2,
        kExprLocalGet, 0,
        kExprLocalGet, 0,
        kExprLocalGet, 1,
        kExprF64Min,
        kExprF64Add,
        kExprI32SConvertF64,
        kExprI32Mul,
        kExprI32Const, 20,
        kExprI32Sub,
        kExprThrow, except,
      ]).exportFunc()
  let instance = builder.instantiate();

  assertWasmThrows(instance, except, [65535, 65536-8],
                   () => instance.exports.throw_expr_with_params(1.5, 2.5, 4));
  assertWasmThrows(instance, except, [0, 12],
                   () => instance.exports.throw_expr_with_params(5.7, 2.5, 4));
})();

// Now that we know catching works locally, we test catching exceptions that
// cross function boundaries and/or raised by JavaScript.
(function TestCatchCrossFunctions() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_i);

  // Helper function for throwing from JS. It is imported by the Wasm module
  // as throw_i.
  function throw_value(value) {
    throw value;
  }
  let sig_index = builder.addType(kSig_v_i);
  let kJSThrowI = builder.addImport("", "throw_i", sig_index);

  // Helper function that throws a string. Wasm should not catch it.
  function throw_string() {
    throw "use wasm";
  }
  sig_index = builder.addType(kSig_v_v);
  let kJSThrowString = builder.addImport("", "throw_string", sig_index);

  // Helper function that throws undefined. Wasm should not catch it.
  function throw_undefined() {
    throw undefined;
  }
  let kJSThrowUndefined = builder.addImport("", "throw_undefined", sig_index);

  // Helper function that throws an fp. Wasm should not catch it.
  function throw_fp() {
    throw 10.5;
  }
  let kJSThrowFP = builder.addImport("", "throw_fp", sig_index);

  // Helper function that throws a large number. Wasm should not catch it.
  function throw_large() {
    throw 1e+28;
  }
  let kJSThrowLarge = builder.addImport("", "throw_large", sig_index);

  // Helper function for throwing from WebAssembly.
  let kWasmThrowFunction =
    builder.addFunction("throw", kSig_v_i)
      .addBody([
        kExprLocalGet, 0,
        kExprThrow, except,
      ])
      .index;

  // Scenario 1: Throw and catch appear on the same function. This should
  // happen in case of inlining, for example.
  builder.addFunction("same_scope", kSig_i_i)
    .addBody([
      kExprTry, kWasmI32,
        kExprLocalGet, 0,
        kExprI32Const, 0,
        kExprI32Ne,
        kExprIf, kWasmVoid,
          kExprLocalGet, 0,
          kExprThrow, except,
          kExprUnreachable,
        kExprEnd,
        kExprI32Const, 63,
      kExprCatch, except,
      kExprEnd
    ])
    .exportFunc();

  builder.addFunction("same_scope_ignore", kSig_i_i)
    .addBody([
        kExprTry, kWasmI32,
          kExprLocalGet, 0,
          kExprThrow, except,
          kExprUnreachable,
        kExprCatch, except,
        kExprEnd,
    ])
    .exportFunc();

  builder.addFunction("same_scope_multiple", kSig_i_i)
    // path = 0;
    //
    // try {
    //   try {
    //     try {
    //       if (p == 1)
    //         throw 1;
    //       path |= 2
    //     } catch (v) {
    //       path |= v | 4;
    //       throw path;
    //     }
    //     if (p == 2)
    //       throw path|8;
    //     path |= 16;
    //   } catch (v) {
    //     path |= v | 32;
    //     throw path;
    //   }
    //   if (p == 3)
    //     throw path|64;
    //   path |= 128
    // } catch (v) {
    //   path |= v | 256;
    // }
    //
    // return path;
    //
    // p == 1 -> path == 293
    // p == 2 -> path == 298
    // p == 3 -> path == 338
    // else   -> path == 146
    .addLocals(kWasmI32, 1)
    .addBody([
        kExprTry, kWasmI32,
          kExprTry, kWasmI32,
            kExprTry, kWasmI32,
              kExprLocalGet, 0,
              kExprI32Const, 1,
              kExprI32Eq,
              kExprIf, kWasmVoid,
                kExprI32Const, 1,
                kExprThrow, except,
                kExprUnreachable,
              kExprEnd,
              kExprI32Const, 2,
            kExprCatch, except,
              kExprI32Const, 4,
              kExprI32Ior,
              kExprThrow, except,
              kExprUnreachable,
            kExprEnd,
            kExprLocalTee, 1,
            kExprLocalGet, 0,
            kExprI32Const, 2,
            kExprI32Eq,
            kExprIf, kWasmVoid,
              kExprLocalGet, 1,
              kExprI32Const, 8,
              kExprI32Ior,
              kExprThrow, except,
              kExprUnreachable,
            kExprEnd,
            kExprI32Const, 16,
            kExprI32Ior,
          kExprCatch, except,
            kExprI32Const, 32,
            kExprI32Ior,
            kExprThrow, except,
            kExprUnreachable,
          kExprEnd,
          kExprLocalTee, 1,
          kExprLocalGet, 0,
          kExprI32Const, 3,
          kExprI32Eq,
          kExprIf, kWasmVoid,
            kExprLocalGet, 1,
            kExprI32Const, /*64=*/ 192, 0,
            kExprI32Ior,
            kExprThrow, except,
            kExprUnreachable,
          kExprEnd,
          kExprI32Const, /*128=*/ 128, 1,
          kExprI32Ior,
        kExprCatch, except,
          kExprI32Const, /*256=*/ 128, 2,
          kExprI32Ior,
        kExprEnd,
    ])
    .exportFunc();

  // Scenario 2: Catches an exception raised from the direct callee.
  builder.addFunction("from_direct_callee", kSig_i_i)
    .addBody([
      kExprTry, kWasmI32,
        kExprLocalGet, 0,
        kExprCallFunction, kWasmThrowFunction,
        kExprUnreachable,
      kExprCatch, except,
      kExprEnd,
    ])
    .exportFunc();

  // Scenario 3: Catches an exception raised from an indirect callee.
  let sig_v_i = builder.addType(kSig_v_i);
  builder.appendToTable([kWasmThrowFunction, kWasmThrowFunction]);
  builder.addFunction("from_indirect_callee", kSig_i_ii)
    .addBody([
      kExprTry, kWasmI32,
        kExprLocalGet, 0,
        kExprLocalGet, 1,
        kExprCallIndirect, sig_v_i, kTableZero,
        kExprUnreachable,
      kExprCatch, except,
      kExprEnd
    ])
    .exportFunc();

  // Scenario 4: Does not catch an exception raised in JS, even if primitive
  // values are being used as exceptions.
  builder.addFunction("i_from_js", kSig_i_i)
    .addBody([
      kExprTry, kWasmI32,
        kExprLocalGet, 0,
        kExprCallFunction, kJSThrowI,
        kExprUnreachable,
      kExprCatch, except,
        kExprUnreachable,
      kExprEnd,
    ])
    .exportFunc();

  builder.addFunction("string_from_js", kSig_v_v)
    .addBody([
      kExprTry, kWasmVoid,
        kExprCallFunction, kJSThrowString,
      kExprCatch, except,
        kExprUnreachable,
      kExprEnd,
    ])
    .exportFunc();

  builder.addFunction("fp_from_js", kSig_v_v)
    .addBody([
      kExprTry, kWasmVoid,
        kExprCallFunction, kJSThrowFP,
      kExprCatch, except,
        kExprUnreachable,
      kExprEnd,
    ])
    .exportFunc();

  builder.addFunction("large_from_js", kSig_v_v)
    .addBody([
      kExprTry, kWasmVoid,
        kExprCallFunction, kJSThrowLarge,
      kExprCatch, except,
        kExprUnreachable,
      kExprEnd,
    ])
    .exportFunc();

  builder.addFunction("undefined_from_js", kSig_v_v)
    .addBody([
      kExprTry, kWasmVoid,
        kExprCallFunction, kJSThrowUndefined,
      kExprCatch, except,
        kExprUnreachable,
      kExprEnd,
    ])
    .exportFunc();

  let instance = builder.instantiate({"": {
      throw_i: throw_value,
      throw_string: throw_string,
      throw_fp: throw_fp,
      throw_large, throw_large,
      throw_undefined: throw_undefined
  }});

  assertEquals(63, instance.exports.same_scope(0));
  assertEquals(1024, instance.exports.same_scope(1024));
  assertEquals(-3, instance.exports.same_scope(-3));
  assertEquals(-1, instance.exports.same_scope_ignore(-1));
  assertEquals(1, instance.exports.same_scope_ignore(1));
  assertEquals(0x7FFFFFFF, instance.exports.same_scope_ignore(0x7FFFFFFF));
  assertEquals(1024, instance.exports.same_scope_ignore(1024));
  assertEquals(-1, instance.exports.same_scope_ignore(-1));
  assertEquals(293, instance.exports.same_scope_multiple(1));
  assertEquals(298, instance.exports.same_scope_multiple(2));
  assertEquals(338, instance.exports.same_scope_multiple(3));
  assertEquals(146, instance.exports.same_scope_multiple(0));
  assertEquals(-10024, instance.exports.from_direct_callee(-10024));
  assertEquals(3334333, instance.exports.from_direct_callee(3334333));
  assertEquals(-1, instance.exports.from_direct_callee(0xFFFFFFFF));
  assertEquals(0x7FFFFFFF, instance.exports.from_direct_callee(0x7FFFFFFF));
  assertEquals(10, instance.exports.from_indirect_callee(10, 0));
  assertEquals(77, instance.exports.from_indirect_callee(77, 1));

  assertThrowsEquals(() => instance.exports.i_from_js(10), 10);
  assertThrowsEquals(() => instance.exports.i_from_js(-10), -10);
  assertThrowsEquals(instance.exports.string_from_js, "use wasm");
  assertThrowsEquals(instance.exports.fp_from_js, 10.5);
  assertThrowsEquals(instance.exports.large_from_js, 1e+28);
  assertThrowsEquals(instance.exports.undefined_from_js, undefined);
})();

// Delegate with a try block that never throws.
(function TestDelegateNoThrow() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except1 = builder.addTag(kSig_v_v);
  builder.addFunction('test', kSig_i_v)
      .addBody([
        kExprTry, kWasmI32,
          kExprTry, kWasmI32,
            kExprI32Const, 1,
          kExprDelegate, 0,
        kExprCatch, except1,
          kExprI32Const, 2,
        kExprEnd,
      ]).exportFunc();
  instance = builder.instantiate();
  assertEquals(1, instance.exports.test());
})();

// Delegate exception handling to outer try/catch block.
(function TestDelegateThrow() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  let throw_if = builder.addFunction('throw', kSig_v_i)
      .addBody([
          kExprLocalGet, 0,
          kExprIf, kWasmVoid,
            kExprThrow, except,
          kExprEnd]).exportFunc();
  builder.addFunction('test', kSig_i_i)
      .addBody([
        kExprTry, kWasmI32,
          kExprTry, kWasmI32,
            kExprLocalGet, 0,
            kExprCallFunction, throw_if.index,
            kExprI32Const, 1,
          kExprDelegate, 0,
        kExprCatch, except,
          kExprI32Const, 2,
        kExprEnd,
      ]).exportFunc();
  instance = builder.instantiate();
  assertEquals(1, instance.exports.test(0));
  assertEquals(2, instance.exports.test(1));
})();

// No catch block matching the exception in the delegate target.
(function TestDelegateThrowNoCatch() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except1 = builder.addTag(kSig_v_v);
  let except2 = builder.addTag(kSig_v_v);
  let throw_fn = builder.addFunction('throw', kSig_v_v)
                     .addBody([kExprThrow, except1])
                     .exportFunc();
  let throw_fn_2 = builder.addFunction('throw_2', kSig_v_v)
                     .addBody([kExprThrow, except2])
                     .exportFunc();
  builder.addFunction('test', kSig_i_v)
      .addBody([
        kExprTry, kWasmI32,
          kExprTry, kWasmI32,
            kExprCallFunction, throw_fn.index,
            kExprI32Const, 1,
          kExprDelegate, 0,
        kExprCatch, except2,
          kExprI32Const, 2,
        kExprEnd,
      ]).exportFunc();
  instance = builder.instantiate();
  assertThrows(instance.exports.test, WebAssembly.Exception);
})();

// Check that the exception is merged properly when both scopes can throw.
(function TestDelegateMerge() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except1 = builder.addTag(kSig_v_v);
  let except2 = builder.addTag(kSig_v_v);
  // throw_fn: 0 -> returns
  //           1 -> throw except1
  //           2 -> throw except2
  let throw_fn = builder.addFunction('throw', kSig_v_i)
      .addBody([
          kExprBlock, kWasmVoid,
            kExprBlock, kWasmVoid,
              kExprBlock, kWasmVoid,
                kExprLocalGet, 0,
                kExprBrTable, 2, 0, 1, 2,
              kExprEnd,
              kExprReturn,
            kExprEnd,
            kExprThrow, except1,
          kExprEnd,
          kExprThrow, except2])
      .exportFunc();
  builder.addFunction('test', kSig_i_ii)
      .addBody([
        kExprTry, kWasmI32,
          kExprLocalGet, 0,
          kExprCallFunction, throw_fn.index,
          kExprTry, kWasmI32,
            kExprLocalGet, 1,
            kExprCallFunction, throw_fn.index,
            kExprI32Const, 1,
          kExprDelegate, 0,
        kExprCatch, except1,
          kExprI32Const, 2,
        kExprEnd,
      ]).exportFunc();
  instance = builder.instantiate();
  assertEquals(2, instance.exports.test(1, 0));
  assertThrows(() => instance.exports.test(2, 0), WebAssembly.Exception);
  assertEquals(2, instance.exports.test(0, 1));
  assertThrows(() => instance.exports.test(0, 2), WebAssembly.Exception);
  assertEquals(1, instance.exports.test(0, 0));
})();

// Delegate to second enclosing try scope.
(function TestDelegate1() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  let throw_fn = builder.addFunction('throw', kSig_v_v)
                     .addBody([kExprThrow, except])
                     .exportFunc();
  builder.addFunction('test', kSig_i_v)
      .addBody([
        kExprTry, kWasmI32,
          kExprTry, kWasmI32,
            kExprTry, kWasmI32,
              kExprCallFunction, throw_fn.index,
              kExprI32Const, 1,
            kExprDelegate, 1,
          kExprCatch, except,
            kExprI32Const, 2,
          kExprEnd,
        kExprCatch, except,
          kExprI32Const, 3,
        kExprEnd,
      ]).exportFunc();
  instance = builder.instantiate();
  assertEquals(3, instance.exports.test());
})();

(function TestDelegateUnreachable() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except1 = builder.addTag(kSig_v_v);
  let except2 = builder.addTag(kSig_v_v);
  builder.addFunction('test', kSig_i_v)
      .addBody([
        kExprTry, kWasmI32,
          kExprTry, kWasmVoid,
            kExprThrow, except1,
          kExprDelegate, 0,
          kExprI32Const, 1,
        kExprCatch, except1,
          kExprI32Const, 2,
        kExprCatch, except2,
          kExprI32Const, 3,
        kExprEnd,
      ]).exportFunc();
  instance = builder.instantiate();
  assertEquals(2, instance.exports.test());
})();

(function TestDelegateToCaller() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  builder.addFunction('test', kSig_v_v)
      .addBody([
        kExprTry, kWasmVoid,
          kExprTry, kWasmVoid,
            kExprThrow, except,
          kExprDelegate, 1,
        kExprCatchAll,
        kExprEnd
      ]).exportFunc();
  instance = builder.instantiate();
  assertThrows(() => instance.exports.test(), WebAssembly.Exception);
})();

(function TestThrowBeforeUnreachable() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  builder.addFunction('throw_before_unreachable', kSig_i_v)
      .addBody([
        kExprTry, kWasmI32,
          kExprThrow, except,
          kExprUnreachable,
        kExprCatchAll,
          kExprI32Const, 42,
        kExprEnd,
      ]).exportFunc();

  let instance = builder.instantiate();
  assertEquals(42, instance.exports.throw_before_unreachable());
})();

(function TestUnreachableInCatchAll() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  builder.addFunction('throw_before_unreachable', kSig_i_v)
      .addBody([
        kExprTry, kWasmI32,
          kExprThrow, except,
        kExprCatchAll,
          kExprUnreachable,
          kExprI32Const, 42,
        kExprEnd,
      ]).exportFunc();

  let instance = builder.instantiate();
})();

(function TestThrowWithLocal() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  builder.addFunction('throw_with_local', kSig_i_v)
    .addLocals(kWasmI32, 4)
    .addBody([
        kExprI32Const, 42,
        kExprF64Const, 0, 0, 0, 0, 0, 0, 0, 0,
        kExprTry, kWasmF32,
          kExprThrow, except,
        kExprCatchAll,
          kExprF32Const, 0, 0, 0, 0,
        kExprEnd,
        kExprDrop,  // Drop the f32.
        kExprDrop,  // Drop the f64.
        // Leave the '42' on the stack.
    ]).exportFunc();

  let instance = builder.instantiate();
  assertEquals(42, instance.exports.throw_with_local());
})();

(function TestCatchlessTry() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  builder.addFunction('catchless_try', kSig_v_i)
    .addBody([
        kExprTry, kWasmVoid,
          kExprLocalGet, 0,
          kExprIf, kWasmVoid,
            kExprThrow, except,
          kExprEnd,
        kExprEnd,
    ]).exportFunc();

  let instance = builder.instantiate();
  assertDoesNotThrow(() => instance.exports.catchless_try(0));
  assertWasmThrows(instance, except, [],
                   () => instance.exports.catchless_try(1));
})();

// Delegate to a regular block inside a try block.
(function TestDelegateToBlock() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  builder.addFunction('test', kSig_i_v)
      .addBody([
        kExprTry, kWasmI32,
          kExprBlock, kWasmI32,
            kExprTry, kWasmI32,
              kExprThrow, except,
            kExprDelegate, 0,
          kExprEnd,
        kExprCatch, except,
          kExprI32Const, 2,
        kExprEnd,
      ]).exportFunc();
  instance = builder.instantiate();
  assertEquals(2, instance.exports.test());
})();

// Delegate to a regular block with no outer try (delegate to caller).
(function TestDelegateToCallerWithBlock() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  builder.addFunction('test', kSig_v_v)
      .addBody([
        kExprBlock, kWasmVoid,
          kExprTry, kWasmVoid,
            kExprThrow, except,
          kExprDelegate, 0,
        kExprEnd
      ]).exportFunc();
  instance = builder.instantiate();
  assertThrows(() => instance.exports.test(), WebAssembly.Exception);
})();
                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/wasm/exnref-api.js                                                 0000664 0000000 0000000 00000015002 14746647661 0022056 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Flags: --allow-natives-syntax --experimental-wasm-exnref --turboshaft-wasm

// This file is for the most parts a direct port of
// test/mjsunit/wasm/exceptions-api.js using the new exception handling
// proposal.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
d8.file.execute("test/mjsunit/wasm/exceptions-utils.js");

(function TestCatchJSTag() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let js_tag = builder.addImportedTag("", "tag", kSig_v_r);

  // Throw a JS object and check that we can catch it and unpack it using
  // WebAssembly.JSTag in try_table.
  function throw_ref(x) {
    throw x;
  }
  let kJSThrowRef = builder.addImport("", "throw_ref", kSig_r_r);
  let try_sig_index = builder.addType(kSig_r_v);
  builder.addFunction("test", kSig_r_r)
    .addBody([
      kExprBlock, try_sig_index,
        kExprTryTable, try_sig_index, 1,
          kCatchNoRef, js_tag, 0,
          kExprLocalGet, 0,
          kExprCallFunction, kJSThrowRef,
        kExprEnd,
      kExprEnd,
    ])
    .exportFunc();

  let instance = builder.instantiate({"": {
      throw_ref: throw_ref,
      tag: WebAssembly.JSTag,
  }});

  let obj = {};
  // Creating a WA.Exception with the JSTag explicitly is not allowed.
  assertThrows(() => new WebAssembly.Exception(WebAssembly.JSTag, [obj]), TypeError);

  // Catch with implicit wrapping.
  assertSame(obj, instance.exports.test(obj));
  // Don't catch with explicit wrapping.
  let not_js_tag = new WebAssembly.Tag({parameters:['externref']});
  let exn = new WebAssembly.Exception(not_js_tag, [obj]);
  assertThrowsEquals(() => instance.exports.test(exn), exn);


  // There is a separate code path for tags with externref type, so also check
  // that everything still works when the tag is *not* the JSTag.

  instance = builder.instantiate({"": {
      throw_ref: throw_ref,
      tag: not_js_tag
  }});

  // Catch with explicit wrapping.
  assertSame(obj, instance.exports.test(new WebAssembly.Exception(not_js_tag, [obj])));
  // Don't catch with explicit wrapping.
  // Don't catch with implicit wrapping.
  assertThrowsEquals(() => instance.exports.test(obj), obj);
})();

(function TestCatchRefJSTag() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let js_tag = builder.addImportedTag("", "tag", kSig_v_r);

  // Throw a JS object and check that we can catch it and unpack it using
  // WebAssembly.JSTag in try_table.
  function throw_ref(x) {
    throw x;
  }
  let kJSThrowRef = builder.addImport("", "throw_ref", kSig_r_r);
  let try_sig_index = builder.addType(kSig_r_v);
  let catch_sig_index = builder.addType(makeSig([], [kWasmExternRef, kWasmExnRef]));
  builder.addFunction("test", kSig_r_r)
    .addBody([
      kExprBlock, catch_sig_index,
        kExprTryTable, try_sig_index, 1,
          kCatchRef, js_tag, 0,
          kExprLocalGet, 0,
          kExprCallFunction, kJSThrowRef,
        kExprEnd,
        kExprReturn,
      kExprEnd,
      kExprDrop,
    ])
    .exportFunc();

  let instance = builder.instantiate({"": {
      throw_ref: throw_ref,
      tag: WebAssembly.JSTag,
  }});

  let obj = {};

  // Catch with implicit wrapping.
  assertSame(obj, instance.exports.test(obj));
  // Don't catch with explicit wrapping.
  let not_js_tag = new WebAssembly.Tag({parameters:['externref']});
  let exn = new WebAssembly.Exception(not_js_tag, [obj]);
  assertThrowsEquals(() => instance.exports.test(exn), exn);


  // There is a separate code path for tags with externref type, so also check
  // that everything still works when the tag is *not* the JSTag.

  instance = builder.instantiate({"": {
      throw_ref: throw_ref,
      tag: not_js_tag
  }});

  // Catch with explicit wrapping.
  assertSame(obj, instance.exports.test(new WebAssembly.Exception(not_js_tag, [obj])));
  // Don't catch with implicit wrapping.
  assertThrowsEquals(() => instance.exports.test(obj), obj);
})();

(function TestCatchRefThrowRefJSTag() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let js_tag = builder.addImportedTag("", "tag", kSig_v_r);

  // Throw a JS object and check that we can catch it and unpack it using
  // WebAssembly.JSTag in try_table, then rethrow it as a JS object with
  // throw_ref.
  function throw_ref(x) {
    throw x;
  }
  let kJSThrowRef = builder.addImport("", "throw_ref", kSig_r_r);
  let try_sig_index = builder.addType(kSig_r_v);
  let catch_sig_index = builder.addType(makeSig([], [kWasmExternRef, kWasmExnRef]));
  builder.addFunction("test", kSig_r_r)
    .addBody([
      kExprBlock, catch_sig_index,
        kExprTryTable, try_sig_index, 1,
          kCatchRef, js_tag, 0,
          kExprLocalGet, 0,
          kExprCallFunction, kJSThrowRef,
        kExprEnd,
        kExprReturn,
      kExprEnd,
      kExprThrowRef,
    ])
    .exportFunc();

  let instance = builder.instantiate({"": {
      throw_ref: throw_ref,
      tag: WebAssembly.JSTag,
  }});

  let obj = {};

  // Catch and rethrown with implicit wrapping.
  assertThrowsEquals(() => instance.exports.test(obj), obj);
  // Don't catch with explicit wrapping.
  let not_js_tag = new WebAssembly.Tag({parameters:['externref']});
  exn = new WebAssembly.Exception(not_js_tag, [obj]);
  assertThrowsEquals(() => instance.exports.test(exn), exn);


  // There is a separate code path for tags with externref type, so also check
  // that everything still works when the tag is *not* the JSTag.

  instance = builder.instantiate({"": {
      throw_ref: throw_ref,
      tag: not_js_tag
  }});

  // Catch and rethrow with explicit wrapping -> not unwrapped in this case.
  exn = new WebAssembly.Exception(not_js_tag, [obj]);
  assertThrowsEquals(() => instance.exports.test(exn), exn);
  // Don't catch with implicit wrapping.
  assertThrowsEquals(() => instance.exports.test(obj), obj);
})();

(function TestThrowJSTag() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let js_tag = builder.addImportedTag("", "tag", kSig_v_r);

  // Throw a JS object with WebAssembly.JSTag and check that we can catch
  // it as-is from JavaScript.
  builder.addFunction("test", kSig_v_r)
    .addBody([
      kExprLocalGet, 0,
      kExprThrow, js_tag,
    ])
    .exportFunc();

  let instance = builder.instantiate({"": {
      tag: WebAssembly.JSTag,
  }});

  let obj = {};
  assertThrowsEquals(() => instance.exports.test(obj), obj);
  assertThrowsEquals(() => instance.exports.test(5), 5);
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/wasm/exnref-global.js                                              0000664 0000000 0000000 00000004357 14746647661 0022560 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-exnref

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

let kSig_e_v = makeSig([], [kWasmExnRef]);

// First we just test that "exnref" global variables are allowed.
(function TestGlobalExnRefSupported() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let g = builder.addGlobal(kWasmExnRef, false, false);
  builder.addFunction("push_and_drop_exnref", kSig_v_v)
      .addBody([
        kExprGlobalGet, g.index,
        kExprDrop,
      ]).exportFunc();
  let instance = builder.instantiate();

  assertDoesNotThrow(instance.exports.push_and_drop_exnref);
})();

// Test default value that global "exnref" variables are initialized with.
(function TestGlobalExnRefDefaultValue() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let g = builder.addGlobal(kWasmExnRef, false, false);
  builder.addFunction('push_and_check_exnref', kSig_i_v)
      .addBody([
          kExprGlobalGet, g.index,
          kExprRefIsNull, kExnRefCode,
      ])
      .exportFunc();
  let instance = builder.instantiate();

  assertEquals(1, instance.exports.push_and_check_exnref());
})();

// Test custom initialization index for a global "exnref" variable.
(function TestGlobalExnRefInitIndex() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let g_index = builder.addImportedGlobal("m", "exn", kWasmExnRef);
  builder.addFunction('push_and_return_exnref', kSig_e_v)
      .addBody([kExprGlobalGet, g_index])
      .exportFunc();
  assertThrows(() => builder.instantiate({ "m": { "exn": {} }}), WebAssembly.LinkError);
  assertThrows(() => builder.instantiate({ "m": { "exn": null }}), WebAssembly.LinkError);
})();

(function TestGlobalExnRefJsApi() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();
  let g_index = builder.addGlobal(kWasmExnRef, true, false).exportAs('g');
  let instance = builder.instantiate();
  assertThrows(() => new WebAssembly.Global({value: "exnref", mutable: true}, null), TypeError);
  assertThrows(() => { instance.exports.g.value; }, TypeError);
})();
                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/wasm/exnref-rethrow.js                                             0000664 0000000 0000000 00000006707 14746647661 0023013 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Flags: --allow-natives-syntax --experimental-wasm-exnref --turboshaft-wasm

// This file is for the most parts a direct port of
// test/mjsunit/wasm/exceptions-rethrow.js using the new exception handling
// proposal.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
d8.file.execute("test/mjsunit/wasm/exceptions-utils.js");

// Test that rethrow expressions can target catch blocks.
(function TestRethrowInCatch() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  let if_sig = builder.addType(makeSig([kWasmExnRef], []));
  builder.addFunction("rethrow0", kSig_v_v)
      .addBody([
        kExprBlock, kExnRefCode,
          kExprTryTable, kWasmVoid, 1,
          kCatchRef, except, 0,
            kExprThrow, except,
          kExprEnd,
          kExprBr, 1,
        kExprEnd,
        kExprThrowRef,
  ]).exportFunc();
  builder.addFunction("rethrow1", kSig_i_i)
      .addBody([
        kExprBlock, kExnRefCode,
          kExprTryTable, kWasmI32, 1,
          kCatchRef, except, 0,
            kExprThrow, except,
          kExprEnd,
          kExprUnreachable,
        kExprEnd,
        kExprLocalGet, 0,
        kExprI32Eqz,
        kExprIf, if_sig,
          kExprThrowRef,
        kExprElse,
          kExprDrop,
        kExprEnd,
        kExprI32Const, 23,
  ]).exportFunc();
  let instance = builder.instantiate();

  assertWasmThrows(instance, except, [], () => instance.exports.rethrow0());
  assertWasmThrows(instance, except, [], () => instance.exports.rethrow1(0));
  assertEquals(23, instance.exports.rethrow1(1));
})();

// Test that an exception being rethrown can be caught by another local catch
// block in the same function without ever unwinding the activation.
(function TestRethrowRecatch() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  let sig_v_e = builder.addType(makeSig([kWasmExnRef], []));
  builder.addFunction("rethrow_recatch", kSig_i_i)
      .addBody([
        kExprBlock, kExnRefCode,
          kExprTryTable, kWasmVoid, 1,
          kCatchRef, except, 0,
            kExprThrow, except,
          kExprEnd,
          kExprUnreachable,
        kExprEnd,
        kExprBlock, sig_v_e,
          kExprTryTable, sig_v_e, 1,
          kCatchNoRef, except, 0,
            kExprLocalGet, 0,
            kExprI32Eqz,
            kExprIf, sig_v_e,
              kExprThrowRef,
            kExprElse,
              kExprDrop,
            kExprEnd,
            kExprI32Const, 42,
            kExprReturn,
          kExprEnd,
        kExprEnd,
        kExprI32Const, 23,
  ]).exportFunc();
  let instance = builder.instantiate();

  assertEquals(23, instance.exports.rethrow_recatch(0));
  assertEquals(42, instance.exports.rethrow_recatch(1));
})();

// Test that throw-ref traps if the exception is null.
(function TestRethrowNullTraps() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  let if_sig = builder.addType(makeSig([kWasmExnRef], []));
  builder.addFunction("rethrow_null", kSig_v_v)
      .addBody([
        kExprRefNull, kExnRefCode,
        kExprThrowRef,
  ]).exportFunc();
  let instance = builder.instantiate();

  assertTraps(kTrapRethrowNull, () => instance.exports.rethrow_null());
})();
                                                         node-23.7.0/deps/v8/test/mjsunit/wasm/exnref.js                                                     0000664 0000000 0000000 00000047004 14746647661 0021316 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --experimental-wasm-exnref --turboshaft-wasm

// This file is for the most parts a direct port of
// test/mjsunit/wasm/exceptions.js using the new exception handling proposal.
// Tests that are independent of the version of the proposal are not included
// (e.g. tests that only use the `throw` instruction), and some exnref-specific
// tests are added.
// See also exnref-rethrow.js, exnref-global.js and exnref-api.js.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
d8.file.execute("test/mjsunit/wasm/exceptions-utils.js");

// Test that "exnref" local variables are allowed.
(function TestLocalExnRef() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("push_and_drop_exnref", kSig_v_v)
      .addLocals(kWasmExnRef, 1)
      .addBody([
        kExprLocalGet, 0,
        kExprDrop,
      ]).exportFunc();
  let instance = builder.instantiate();

  assertDoesNotThrow(instance.exports.push_and_drop_exnref);
})();

(function TestCatchEmptyBlocks() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  builder.addFunction("catch_empty_try", kSig_v_v)
      .addBody([
        kExprTryTable, kWasmVoid, 1,
        kCatchNoRef, except, 0,
        kExprEnd,
      ]).exportFunc();
  builder.addFunction("catch_ref_empty_try", kSig_v_v)
      .addBody([
        kExprBlock, kExnRefCode,
          kExprTryTable, kWasmVoid, 1,
          kCatchRef, except, 0,
          kExprEnd,
          kExprReturn,
        kExprEnd,
        kExprDrop,
      ]).exportFunc();
  builder.addFunction("catch_all_empty_try", kSig_v_v)
      .addBody([
        kExprTryTable, kWasmVoid, 1,
        kCatchAllNoRef, 0,
        kExprEnd,
      ]).exportFunc();
  builder.addFunction("catch_all_ref_empty_try", kSig_v_v)
      .addBody([
        kExprBlock, kExnRefCode,
          kExprTryTable, kWasmVoid, 1,
          kCatchAllRef, 0,
          kExprEnd,
          kExprReturn,
        kExprEnd,
        kExprDrop,
      ]).exportFunc();
  let instance = builder.instantiate();

  assertDoesNotThrow(instance.exports.catch_empty_try);
  assertDoesNotThrow(instance.exports.catch_ref_empty_try);
  assertDoesNotThrow(instance.exports.catch_all_empty_try);
  assertDoesNotThrow(instance.exports.catch_all_ref_empty_try);
})();

(function TestCatchSimple() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  builder.addFunction("simple_throw_catch_to_0_1", kSig_i_i)
      .addBody([
        kExprBlock, kWasmVoid,
          kExprTryTable, kWasmI32, 1,
          kCatchNoRef, except, 0,
            kExprLocalGet, 0,
            kExprI32Eqz,
            kExprIf, kWasmVoid,
              kExprThrow, except,
            kExprEnd,
            kExprI32Const, 42,
          kExprEnd,
          kExprBr, 1,
        kExprEnd,
        kExprI32Const, 23
      ]).exportFunc();
  let instance = builder.instantiate();

  assertEquals(23, instance.exports.simple_throw_catch_to_0_1(0));
  assertEquals(42, instance.exports.simple_throw_catch_to_0_1(1));
})();

(function TestTrapNotCaught() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction('unreachable_in_try', kSig_v_v)
      .addBody([
        kExprTryTable, kWasmVoid, 1,
        kCatchAllNoRef, 0,
          kExprUnreachable,
        kExprEnd
      ]).exportFunc();
  let instance = builder.instantiate();

  assertTraps(kTrapUnreachable, () => instance.exports.unreachable_in_try());
})();

(function TestTrapInCalleeNotCaught() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let func_div = builder.addFunction('div', kSig_i_ii).addBody([
    kExprLocalGet, 0,
    kExprLocalGet, 1,
    kExprI32DivU
  ]);
  builder.addFunction('trap_in_callee', kSig_i_ii)
      .addBody([
        kExprBlock, kWasmVoid,
          kExprTryTable, kWasmI32, 1,
          kCatchAllNoRef, 0,
            kExprLocalGet, 0,
            kExprLocalGet, 1,
            kExprCallFunction, func_div.index,
          kExprEnd,
          kExprBr, 1,
        kExprEnd,
        kExprI32Const, 11,
      ]).exportFunc();
  let instance = builder.instantiate();

  assertEquals(3, instance.exports.trap_in_callee(7, 2));
  assertTraps(kTrapDivByZero, () => instance.exports.trap_in_callee(1, 0));
})();

(function TestTrapViaJSNotCaught() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let imp = builder.addImport('imp', 'ort', kSig_i_v);
  builder.addFunction('div', kSig_i_ii)
      .addBody([
        kExprLocalGet, 0,
        kExprLocalGet, 1,
        kExprI32DivU
      ]).exportFunc();
  builder.addFunction('call_import', kSig_i_v)
      .addBody([
        kExprBlock, kWasmVoid,
          kExprTryTable, kWasmI32, 1,
          kCatchAllNoRef, 0,
            kExprCallFunction, imp,
          kExprEnd,
          kExprBr, 1,
        kExprEnd,
        kExprI32Const, 11,
      ]).exportFunc();
  let exception = undefined;
  let instance;
  function js_import() {
    try {
      instance.exports.div(1, 0);
    } catch (e) {
      exception = e;
    }
    throw exception;
  }
  instance = builder.instantiate({imp: {ort: js_import}});

  let caught = undefined;
  try {
    let res = instance.exports.call_import();
    assertUnreachable('call_import should trap, but returned with ' + res);
  } catch (e) {
    caught = e;
  }
  assertSame(exception, caught);
  assertInstanceof(exception, WebAssembly.RuntimeError);
  assertEquals(exception.message, kTrapMsgs[kTrapDivByZero]);
})();

(function TestManuallyThrownRuntimeErrorCaught() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let imp = builder.addImport('imp', 'ort', kSig_i_v);
  builder.addFunction('call_import', kSig_i_v)
      .addBody([
        kExprBlock, kWasmVoid,
          kExprTryTable, kWasmI32, 1,
          kCatchAllNoRef, 0,
            kExprCallFunction, imp,
          kExprEnd,
          kExprBr, 1,
        kExprEnd,
        kExprI32Const, 11,
      ]).exportFunc();
  function throw_exc() {
    throw new WebAssembly.RuntimeError('My user text');
  }
  let instance = builder.instantiate({imp: {ort: throw_exc}});

  assertEquals(11, instance.exports.call_import());
})();

(function TestExnWithWasmProtoNotCaught() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  let imp = builder.addImport('imp', 'ort', kSig_v_v);
  let throw_fn = builder.addFunction('throw', kSig_v_v)
                     .addBody([kExprThrow, except])
                     .exportFunc();
  builder.addFunction('test', kSig_v_v)
      .addBody([
        // Calling "throw" directly should produce the expected exception.
        kExprBlock, kWasmVoid,
          kExprTryTable, kWasmVoid, 1,
          kCatchNoRef, except, 0,
            kExprCallFunction, throw_fn.index,
          kExprEnd,
          kExprBr, 1,
        kExprEnd,
        // Calling through JS produces a wrapped exceptions which does not match
        // the catch.
        kExprBlock, kWasmVoid,
          kExprTryTable, kWasmVoid, 1,
          kCatchNoRef, except, 0,
            kExprCallFunction, imp,
          kExprEnd,
          kExprBr, 1,
        kExprEnd
      ]).exportFunc();
  let instance;
  let wrapped_exn;
  function js_import() {
    try {
      instance.exports.throw();
    } catch (e) {
      wrapped_exn = new Error();
      wrapped_exn.__proto__ = e;
      throw wrapped_exn;
    }
  }
  instance = builder.instantiate({imp: {ort: js_import}});
  let caught = undefined;
  try {
    instance.exports.test();
  } catch (e) {
    caught = e;
  }
  assertTrue(!!caught, 'should have trapped');
  assertEquals(caught, wrapped_exn);
  assertInstanceof(caught.__proto__, WebAssembly.Exception);
})();

(function TestStackOverflowNotCaught() {
  print(arguments.callee.name);
  function stack_overflow() {
    %ThrowStackOverflow();
  }
  let builder = new WasmModuleBuilder();
  let sig_v_v = builder.addType(kSig_v_v);
  let kStackOverflow = builder.addImport('', 'stack_overflow', sig_v_v);
  builder.addFunction('try_stack_overflow', kSig_v_v)
      .addBody([
        kExprTryTable, kWasmVoid, 1,
        kCatchAllNoRef, 0,
          kExprCallFunction, 0,
        kExprEnd
      ]).exportFunc();
  let instance = builder.instantiate({'': {'stack_overflow': stack_overflow}});

  assertThrows(() => instance.exports.try_stack_overflow(),
      RangeError, 'Maximum call stack size exceeded');
})();

// Test that we can distinguish which exception was thrown by using a cascaded
// sequence of nested try blocks with a single catch block each.
(function TestCatchComplex1() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except1 = builder.addTag(kSig_v_v);
  let except2 = builder.addTag(kSig_v_v);
  let except3 = builder.addTag(kSig_v_v);
  builder.addFunction("catch_complex", kSig_i_i)
      .addBody([
        kExprBlock, kWasmVoid,
          kExprTryTable, kWasmI32, 1,
          kCatchNoRef, except2, 0,
            kExprBlock, kWasmVoid,
              kExprTryTable, kWasmI32, 1,
              kCatchNoRef, except1, 0,
                kExprLocalGet, 0,
                kExprI32Eqz,
                kExprIf, kWasmVoid,
                  kExprThrow, except1,
                kExprElse,
                  kExprLocalGet, 0,
                  kExprI32Const, 1,
                  kExprI32Eq,
                  kExprIf, kWasmVoid,
                    kExprThrow, except2,
                  kExprElse,
                    kExprThrow, except3,
                  kExprEnd,
                kExprEnd,
                kExprI32Const, 2,
              kExprEnd,
              kExprBr, 1,
            kExprEnd,
            kExprI32Const, 3,
          kExprEnd,
          kExprBr, 1,
        kExprEnd,
        kExprI32Const, 4,
      ]).exportFunc();
  let instance = builder.instantiate();

  assertEquals(3, instance.exports.catch_complex(0));
  assertEquals(4, instance.exports.catch_complex(1));
  assertWasmThrows(instance, except3, [],
                   () => instance.exports.catch_complex(2));
})();

// Test that we can distinguish which exception was thrown by using a single
// try block with multiple associated catch blocks in sequence.
(function TestCatchComplex2() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except1 = builder.addTag(kSig_v_v);
  let except2 = builder.addTag(kSig_v_v);
  let except3 = builder.addTag(kSig_v_v);
  builder.addFunction("catch_complex", kSig_i_i)
      .addBody([
        kExprBlock, kWasmVoid,
          kExprBlock, kWasmVoid,
            kExprTryTable, kWasmI32, 2,
            kCatchNoRef, except1, 0,
            kCatchNoRef, except2, 1,
              kExprLocalGet, 0,
              kExprI32Eqz,
              kExprIf, kWasmVoid,
                kExprThrow, except1,
              kExprElse,
                kExprLocalGet, 0,
                kExprI32Const, 1,
                kExprI32Eq,
                kExprIf, kWasmVoid,
                  kExprThrow, except2,
                kExprElse,
                  kExprThrow, except3,
                kExprEnd,
              kExprEnd,
              kExprI32Const, 2,
            kExprEnd,
            kExprBr, 2,
          kExprEnd,
          kExprI32Const, 3,
          kExprBr, 1,
        kExprEnd,
        kExprI32Const, 4,
      ]).exportFunc();
  let instance = builder.instantiate();

  assertEquals(3, instance.exports.catch_complex(0));
  assertEquals(4, instance.exports.catch_complex(1));
  assertWasmThrows(instance, except3, [],
                   () => instance.exports.catch_complex(2));
})();

// Test throwing/catching the i32 parameter value.
(function TestThrowCatchParamI() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_i);
  builder.addFunction("throw_catch_param", kSig_i_i)
      .addBody([
        kExprBlock, kWasmI32,
          kExprTryTable, kWasmI32, 1,
          kCatchNoRef, except, 0,
            kExprLocalGet, 0,
            kExprThrow, except,
            kExprI32Const, 2,
          kExprEnd,
          kExprReturn,
        kExprEnd,
        kExprReturn,
      ]).exportFunc();
  let instance = builder.instantiate();

  assertEquals(0, instance.exports.throw_catch_param(0));
  assertEquals(1, instance.exports.throw_catch_param(1));
  assertEquals(10, instance.exports.throw_catch_param(10));
})();

// Test throwing/catching the f32 parameter value.
(function TestThrowCatchParamF() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_f);
  builder.addFunction("throw_catch_param", kSig_f_f)
      .addBody([
        kExprBlock, kWasmF32,
          kExprTryTable, kWasmF32, 1,
          kCatchNoRef, except, 0,
            kExprLocalGet, 0,
            kExprThrow, except,
            kExprF32Const, 0, 0, 0, 0,
          kExprEnd,
          kExprReturn,
        kExprEnd,
        kExprReturn,
      ]).exportFunc();
  let instance = builder.instantiate();

  assertEquals(5.0, instance.exports.throw_catch_param(5.0));
  assertEquals(10.5, instance.exports.throw_catch_param(10.5));
})();

(function TestThrowCatchParamL() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_l);
  builder.addFunction("throw_catch_param", kSig_i_i)
      .addLocals(kWasmI64, 1)
      .addBody([
        kExprLocalGet, 0,
        kExprI64UConvertI32,
        kExprLocalSet, 1,
        kExprBlock, kWasmI64,
          kExprTryTable, kWasmI32, 1,
          kCatchNoRef, except, 0,
            kExprLocalGet, 1,
            kExprThrow, except,
            kExprI32Const, 2,
          kExprEnd,
          kExprBr, 1,
        kExprEnd,
        kExprLocalGet, 1,
        kExprI64Eq,
        kExprIf, kWasmI32,
          kExprI32Const, 1,
        kExprElse,
          kExprI32Const, 0,
        kExprEnd,
      ]).exportFunc();
  let instance = builder.instantiate();

  assertEquals(1, instance.exports.throw_catch_param(5));
  assertEquals(1, instance.exports.throw_catch_param(0));
  assertEquals(1, instance.exports.throw_catch_param(-1));
})();

// Test throwing/catching the F64 parameter value
(function TestThrowCatchParamD() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_d);
  builder.addFunction("throw_catch_param", kSig_d_d)
      .addBody([
        kExprTryTable, kWasmF64, 1,
        kCatchNoRef, except, 0,
          kExprLocalGet, 0,
          kExprThrow, except,
          kExprF64Const, 0, 0, 0, 0, 0, 0, 0, 0,
          kExprReturn,
        kExprEnd,
      ]).exportFunc();
  let instance = builder.instantiate();

  assertEquals(5.0, instance.exports.throw_catch_param(5.0));
  assertEquals(10.5, instance.exports.throw_catch_param(10.5));
})();

(function TestThrowBeforeUnreachable() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  builder.addFunction('throw_before_unreachable', kSig_i_v)
      .addBody([
        kExprBlock, kWasmVoid,
          kExprTryTable, kWasmVoid, 1,
          kCatchAllNoRef, 0,
            kExprThrow, except,
            kExprUnreachable,
          kExprEnd,
          kExprI32Const, 0,
          kExprReturn,
        kExprEnd,
        kExprI32Const, 42,
      ]).exportFunc();

  let instance = builder.instantiate();
  assertEquals(42, instance.exports.throw_before_unreachable());
})();

(function TestUnreachableInCatchAll() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  builder.addFunction('throw_before_unreachable', kSig_i_v)
      .addBody([
        kExprBlock, kWasmVoid,
          kExprTryTable, kWasmVoid, 1,
          kCatchAllNoRef, 0,
            kExprThrow, except,
          kExprEnd,
          kExprI32Const, 0,
          kExprReturn,
        kExprEnd,
        kExprI32Const, 42,
        kExprUnreachable,
      ]).exportFunc();

  let instance = builder.instantiate();
})();

(function TestThrowWithLocal() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  builder.addFunction('throw_with_local', kSig_i_v)
    .addLocals(kWasmI32, 4)
    .addBody([
        kExprI32Const, 42,
        kExprF64Const, 0, 0, 0, 0, 0, 0, 0, 0,
        kExprBlock, kWasmF32,
          kExprBlock, kWasmVoid,
            kExprTryTable, kWasmF32, 1,
            kCatchAllNoRef, 0,
              kExprThrow, except,
            kExprEnd,
            kExprBr, 1,
          kExprEnd,
          kExprF32Const, 0, 0, 0, 0,
        kExprEnd,
        // Leave the '42' on the stack.
        kExprDrop,  // Drop the f32.
        kExprDrop,  // Drop the f64.
    ]).exportFunc();

  let instance = builder.instantiate();
  assertEquals(42, instance.exports.throw_with_local());
})();

(function TestCatchlessTry() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  builder.addFunction('catchless_try', kSig_v_i)
    .addBody([
        kExprTryTable, kWasmVoid, 0,
          kExprLocalGet, 0,
          kExprIf, kWasmVoid,
            kExprThrow, except,
          kExprEnd,
        kExprEnd,
    ]).exportFunc();

  let instance = builder.instantiate();
  assertDoesNotThrow(() => instance.exports.catchless_try(0));
  assertWasmThrows(instance, except, [],
                   () => instance.exports.catchless_try(1));
})();

// Test catch-ref + unpacking.
(function TestCatchRef() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_i);
  let sig = builder.addType(makeSig([], [kWasmI32, kWasmExnRef]));
  builder.addFunction("catch_ref_i32", kSig_i_v)
      .addBody([
        kExprBlock, sig,
          kExprTryTable, kWasmVoid, 1,
          kCatchRef, except, 0,
            kExprI32Const, 1,
            kExprThrow, except,
          kExprEnd,
          kExprI32Const, 2,
          kExprReturn,
        kExprEnd,
        kExprDrop,
  ]).exportFunc();
  let instance = builder.instantiate();

  assertEquals(1, instance.exports.catch_ref_i32());
})();

// Test catch-all-ref.
(function TestCatchAllRef() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  let sig = builder.addType(makeSig([], [kWasmExnRef]));
  let g = builder.addGlobal(kWasmExnRef, true, false);
  builder.addExportOfKind("g", kExternalGlobal, g.index);
  builder.addFunction("catch_all_ref", kSig_v_v)
      .addBody([
        kExprBlock, sig,
          kExprTryTable, kWasmVoid, 1,
          kCatchAllRef, 0,
            kExprThrow, except,
          kExprEnd,
          kExprReturn,
        kExprEnd,
        kExprThrowRef
  ]).exportFunc();
  let instance = builder.instantiate();

  assertThrows(instance.exports.catch_all_ref, WebAssembly.Exception);
})();

(function TestCatchRefTwoParams() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_ii);
  let sig = builder.addType(makeSig([], [kWasmI32, kWasmI32, kWasmExnRef]));
  builder.addFunction("catch_ref_two_params", kSig_ii_v)
      .addBody([
        kExprBlock, sig,
          kExprTryTable, kWasmVoid, 1,
          kCatchRef, except, 0,
            kExprI32Const, 1, kExprI32Const, 2,
            kExprThrow, except,
          kExprEnd,
          kExprI32Const, 3, kExprI32Const, 4,
          kExprReturn,
        kExprEnd,
        kExprDrop,
  ]).exportFunc();
  let instance = builder.instantiate();

  assertEquals([1, 2], instance.exports.catch_ref_two_params());
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/wasm/export-global.js                                              0000664 0000000 0000000 00000004421 14746647661 0022602 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function duplicateGlobalExportName() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  builder.addGlobal(kWasmI64, false).exportAs('g');
  builder.addGlobal(kWasmI64, false).exportAs('g');
  assertThrows(
      () => builder.instantiate(), WebAssembly.CompileError,
      /Duplicate export name 'g' for global 0 and global 1/);
})();

(function exportNameClashWithFunction() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  builder.addGlobal(kWasmI64, false).exportAs('foo');
  builder.addFunction('f', kSig_v_v).addBody([]).exportAs('foo');
  assertThrows(
      () => builder.instantiate(), WebAssembly.CompileError,
      /Duplicate export name 'foo' for global 0 and function 0/);
})();

(function veryLongExportName() {
  print(arguments.callee.name);
  // Regression test for crbug.com/740023.
  var export_name = 'abc';
  while (export_name.length < 8192) {
    export_name = export_name.concat(export_name);
  }
  var builder = new WasmModuleBuilder();
  var global = builder.addGlobal(kWasmI64, false, false);
  global.exportAs(export_name);
  global.exportAs(export_name);
  var error_msg =
      'Duplicate export name \'(abc){10,20}ab?c?\.\.\.\' for global 0 and global 0';
  assertThrows(
      () => builder.instantiate(), WebAssembly.CompileError,
      new RegExp(error_msg));
})();

(function exportAsElement() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const global = builder.addGlobal(kWasmI64, false);
  const max_array_index = Math.pow(2, 32) - 1;
  const func_idx = builder.addFunction('f', kSig_v_v).addBody([]);
  const export_names =
      [0, 3, max_array_index - 1, max_array_index + 1, 2 * max_array_index];
  for (const name of export_names) {
    global.exportAs(name);
  }
  const instance = builder.instantiate();
  const exports = instance.exports;
  for (const name of export_names) {
    assertTrue(name in exports);
    assertFalse((name - 1) in exports);
    assertFalse((name + 1) in exports);
    assertInstanceof(exports[name], WebAssembly.Global);
  }
})();
                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/wasm/export-identity.js                                            0000664 0000000 0000000 00000003172 14746647661 0023175 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function createExport(fun) {
  let builder = new WasmModuleBuilder();
  let fun_index = builder.addImport("m", "fun", kSig_i_v)
  builder.addExport("fun", fun_index);
  let instance = builder.instantiate({ m: { fun: fun }});
  return instance.exports.fun;
}

// Test that re-exporting a generic JavaScript function changes identity, as
// the resulting export is an instance of {WebAssembly.Function} instead.
(function TestReExportOfJS() {
  print(arguments.callee.name);
  function fun() { return 7 }
  let exported = createExport(fun);
  assertNotSame(exported, fun);
  assertEquals(7, exported());
  assertEquals(7, fun());
})();

// Test that re-exporting and existing {WebAssembly.Function} that represents
// regular WebAssembly functions preserves identity.
(function TestReReExportOfWasm() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction('fun', kSig_i_v).addBody([kExprI32Const, 9]).exportFunc();
  let fun = builder.instantiate().exports.fun;
  let exported = createExport(fun);
  assertSame(exported, fun);
  assertEquals(9, fun());
})();

// Test that re-exporting and existing {WebAssembly.Function} that represents
// generic JavaScript functions preserves identity.
(function TestReReExportOfJS() {
  print(arguments.callee.name);
  let fun = createExport(() => 11)
  let exported = createExport(fun);
  assertSame(exported, fun);
  assertEquals(11, fun());
})();
                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/wasm/export-mutable-global.js                                      0000664 0000000 0000000 00000006000 14746647661 0024224 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function exportImmutableGlobal() {
  var builder = new WasmModuleBuilder();
  let globals = [
    [kWasmI32, 'i32', 4711, wasmI32Const(4711)],
    [kWasmF32, 'f32', Math.fround(3.14), wasmF32Const(Math.fround(3.14))],
    [kWasmF64, 'f64', 1/7, wasmF64Const(1 / 7)]
  ];
  for (let [type, name, value, bytes] of globals) {
    builder.addGlobal(type, false, false, bytes).exportAs(name);
  }
  var instance = builder.instantiate();

  for (let [type, name, value, bytes] of globals) {
    let obj = instance.exports[name];
    assertEquals("object", typeof obj, name);
    assertTrue(obj instanceof WebAssembly.Global, name);
    assertEquals(value || 0, obj.value, name);
    assertThrows(() => obj.value = 0);
  }
})();

(function canExportI64Global() {
  var builder = new WasmModuleBuilder();
  builder.addGlobal(kWasmI64, false, false).exportAs('g');
  builder.instantiate();
})();

(function canExportAndImportI64() {
  var builder = new WasmModuleBuilder();
  builder.addGlobal(kWasmI64, false, false).exportAs('g');
  let g = builder.instantiate().exports.g;

  builder = new WasmModuleBuilder();
  builder.addImportedGlobal("mod", "g", kWasmI64);
  builder.instantiate({mod: {g: g}});
})();

(function exportMutableGlobal() {
  var builder = new WasmModuleBuilder();
  let globals = [
    [kWasmI32, 'i32', 4711, wasmI32Const(4711)],
    [kWasmF32, 'f32', Math.fround(3.14), wasmF32Const(Math.fround(3.14))],
    [kWasmF64, 'f64', 1/7, wasmF64Const(1 / 7)]
  ];
  for (let [index, [type, name, value, bytes]] of globals.entries()) {
    builder.addGlobal(type, true, false, bytes).exportAs(name);
    builder.addFunction("get " + name, makeSig([], [type]))
      .addBody([kExprGlobalGet, index])
      .exportFunc();
    builder.addFunction("set " + name, makeSig([type], []))
      .addBody([kExprLocalGet, 0, kExprGlobalSet, index])
      .exportFunc();
  }
  var instance = builder.instantiate();

  for (let [type, name, value, bytes] of globals) {
    let obj = instance.exports[name];

    assertEquals(value || 0, obj.value, name);

    // Changing the exported global should change the instance's global.
    obj.value = 1001;
    assertEquals(1001, instance.exports['get ' + name](), name);

    // Changing the instance's global should change the exported global.
    instance.exports['set ' + name](112358);
    assertEquals(112358, obj.value, name);
  }
})();

(function exportImportedMutableGlobal() {
  let builder = new WasmModuleBuilder();
  builder.addGlobal(kWasmI32, true, false).exportAs('g1');
  let g1 = builder.instantiate().exports.g1;

  builder = new WasmModuleBuilder();
  builder.addImportedGlobal("mod", "g1", kWasmI32, true);
  builder.addExportOfKind('g2', kExternalGlobal, 0);
  let g2 = builder.instantiate({mod: {g1: g1}}).exports.g2;

  g1.value = 123;

  assertEquals(g1.value, g2.value);
})();
node-23.7.0/deps/v8/test/mjsunit/wasm/export-table.js                                               0000664 0000000 0000000 00000010510 14746647661 0022425 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function testExportedMain() {
  print("TestExportedMain...");
  var kReturnValue = 44;
  var builder = new WasmModuleBuilder();

  builder.addFunction("main", kSig_i_v)
    .addBody([
      kExprI32Const,
      kReturnValue,
      kExprReturn
    ])
    .exportFunc();

  var module = builder.instantiate();

  assertEquals("object", typeof module.exports);
  assertEquals("function", typeof module.exports.main);

  assertEquals(kReturnValue, module.exports.main());
})();

(function testExportedTwice() {
  print("TestExportedTwice...");
  var kReturnValue = 45;

  var builder = new WasmModuleBuilder();

  builder.addFunction("main", kSig_i_v)
    .addBody([
      kExprI32Const,
      kReturnValue,
      kExprReturn
    ])
    .exportAs("blah")
    .exportAs("foo");

  var module = builder.instantiate();

  assertEquals("object", typeof module.exports);
  assertEquals("function", typeof module.exports.blah);
  assertEquals("function", typeof module.exports.foo);

  assertEquals(kReturnValue, module.exports.foo());
  assertEquals(kReturnValue, module.exports.blah());
  assertSame(module.exports.blah, module.exports.foo);
})();

(function testEmptyName() {
  print("TestEmptyName...");
  var kReturnValue = 46;

  var builder = new WasmModuleBuilder();

  builder.addFunction("main", kSig_i_v)
    .addBody([
      kExprI32Const,
      kReturnValue,
      kExprReturn
    ])
    .exportAs("");

  var module = builder.instantiate();

  assertEquals("object", typeof module.exports);
  assertEquals("function", typeof module.exports[""]);

  assertEquals(kReturnValue, module.exports[""]());
})();

(function testNumericName() {
  print("TestNumericName...");
  var kReturnValue = 47;

  var builder = new WasmModuleBuilder();

  builder.addFunction("main", kSig_i_v)
    .addBody([
      kExprI32Const,
      kReturnValue,
      kExprReturn
    ])
    .exportAs("0");

  var module = builder.instantiate();

  assertEquals("object", typeof module.exports);
  assertEquals("function", typeof module.exports["0"]);

  assertEquals(kReturnValue, module.exports["0"]());
})();

(function testExportNameClash() {
  print("TestExportNameClash...");
  var builder = new WasmModuleBuilder();

  builder.addFunction("one",   kSig_v_v).addBody([kExprNop]).exportAs("main");
  builder.addFunction("two",   kSig_v_v).addBody([kExprNop]).exportAs("other");
  builder.addFunction("three", kSig_v_v).addBody([kExprNop]).exportAs("main");

  assertThrows(() => builder.instantiate(), WebAssembly.CompileError,
    /Duplicate export name 'main' for function 0 and function 2/);
})();


(function testExportMultipleIdentity() {
  print("TestExportMultipleIdentity...");
  var builder = new WasmModuleBuilder();

  var f = builder.addFunction("one", kSig_v_v).addBody([kExprNop])
    .exportAs("a")
    .exportAs("b")
    .exportAs("c");

  let instance = builder.instantiate();
  let e = instance.exports;
  assertEquals("function", typeof e.a);
  assertEquals("function", typeof e.b);
  assertEquals("function", typeof e.c);
  assertSame(e.a, e.b);
  assertSame(e.a, e.c);
  assertEquals(String(f.index), e.a.name);
})();


(function testReexportJSMultipleIdentity() {
  print("TestReexportMultipleIdentity...");
  var builder = new WasmModuleBuilder();

  function js() {}

  var a = builder.addImport("m", "a", kSig_v_v);
  builder.addExport("f", a);
  builder.addExport("g", a);

  let instance = builder.instantiate({m: {a: js}});
  let e = instance.exports;
  assertEquals("function", typeof e.f);
  assertEquals("function", typeof e.g);
  assertFalse(e.f == js);
  assertFalse(e.g == js);
  assertTrue(e.f == e.g);
})();


(function testReexportJSMultiple() {
  print("TestReexportMultiple...");
  var builder = new WasmModuleBuilder();

  function js() {}

  var a = builder.addImport("q", "a", kSig_v_v);
  var b = builder.addImport("q", "b", kSig_v_v);
  builder.addExport("f", a);
  builder.addExport("g", b);

  let instance = builder.instantiate({q: {a: js, b: js}});
  let e = instance.exports;
  assertEquals("function", typeof e.f);
  assertEquals("function", typeof e.g);
  assertFalse(e.f == js);
  assertFalse(e.g == js);
  assertFalse(e.f == e.g);
})();
                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/wasm/expose-wasm.js                                                0000664 0000000 0000000 00000000371 14746647661 0022273 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --noexpose-wasm

assertThrows(() => { let x = WebAssembly.compile; });
                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/wasm/extended-constants.js                                         0000664 0000000 0000000 00000004525 14746647661 0023642 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function ExtendedConstantsTestI32() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();

  let imported_global_0 = builder.addImportedGlobal("m", "g0", kWasmI32, false);
  let imported_global_1 = builder.addImportedGlobal("m", "g1", kWasmI32, false);

  let defined_global = builder.addGlobal(
    kWasmI32, false, false,
    [kExprGlobalGet, imported_global_0, kExprGlobalGet, imported_global_1,
     kExprGlobalGet, imported_global_0, ...wasmI32Const(1),
     kExprI32Sub, kExprI32Mul, kExprI32Add]);

  builder.addExportOfKind("global", kExternalGlobal, defined_global.index);

  let value0 = 123;
  let value1 = -450;

  let global_obj0 = new WebAssembly.Global({value: "i32", mutable: false},
                                           value0);
  let global_obj1 = new WebAssembly.Global({value: "i32", mutable: false},
                                           value1);

  let instance = builder.instantiate({m : {g0: global_obj0, g1: global_obj1}});

  assertEquals(value0 + (value1 * (value0 - 1)), instance.exports.global.value);
})();

(function ExtendedConstantsTestI64() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();

  let imported_global_0 = builder.addImportedGlobal("m", "g0", kWasmI64, false);
  let imported_global_1 = builder.addImportedGlobal("m", "g1", kWasmI64, false);

  let defined_global = builder.addGlobal(
    kWasmI64, false, false,
    [kExprGlobalGet, imported_global_0, kExprI64Const, 1, kExprI64Sub,
     kExprGlobalGet, imported_global_1, kExprI64Mul,
     kExprGlobalGet, imported_global_0, kExprI64Add]);

  builder.addExportOfKind("global", kExternalGlobal, defined_global.index);

  let value0 = 123n;
  let value1 = -450n;

  let global_obj0 = new WebAssembly.Global({value: "i64", mutable: false},
                                           value0);
  let global_obj1 = new WebAssembly.Global({value: "i64", mutable: false},
                                           value1);

  let instance = builder.instantiate({m : {g0: global_obj0, g1: global_obj1}});

  assertEquals(value0 + (value1 * (value0 - 1n)),
               instance.exports.global.value);
})();
                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/wasm/externref-globals.js                                          0000664 0000000 0000000 00000051455 14746647661 0023457 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-gc

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestDefaultValue() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  const g_null = builder.addGlobal(kWasmExternRef, true, false).index;
  const g_nullfunc = builder.addGlobal(kWasmAnyFunc, true, false).index;
  builder.addFunction("get_externref_global", kSig_r_v)
    .addBody([kExprGlobalGet, g_null])
    .exportAs("get_externref_global");
  builder.addFunction("get_anyfunc_global", kSig_a_v)
    .addBody([kExprGlobalGet, g_nullfunc])
    .exportAs("get_anyfunc_global");

  const instance = builder.instantiate();
  assertEquals(null, instance.exports.get_externref_global());
  assertEquals(null, instance.exports.get_anyfunc_global());
})();

(function TestDefaultValueSecondGlobal() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  const g_setref = builder.addGlobal(kWasmExternRef, true, false);
  const g_setfunc = builder.addGlobal(kWasmAnyFunc, true, false);
  const g_null = builder.addGlobal(kWasmExternRef, true, false);
  const g_nullfunc = builder.addGlobal(kWasmAnyFunc, true, false);
  builder.addFunction("get_externref_global", kSig_r_r)
    .addBody([
      kExprLocalGet, 0,
      kExprGlobalSet, g_setref.index,
      kExprGlobalGet, g_null.index
    ])
    .exportAs("get_externref_global");
  builder.addFunction("get_anyfunc_global", kSig_a_a)
    .addBody([
      kExprLocalGet, 0,
      kExprGlobalSet, g_setfunc.index,
      kExprGlobalGet, g_nullfunc.index
    ])
    .exportAs("get_anyfunc_global");

  const instance = builder.instantiate();
  assertEquals(null, instance.exports.get_externref_global({}));
  assertEquals(null, instance.exports.get_anyfunc_global(
    instance.exports.get_externref_global));
})();

(function TestExternRefGlobalChangeValue() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  // Dummy global for offset.
  builder.addGlobal(kWasmExternRef, true, false);
  const g = builder.addGlobal(kWasmExternRef, true, false);
  builder.addFunction("main", kSig_r_r)
    .addBody([
      kExprLocalGet, 0,
      kExprGlobalSet, g.index,
      kExprGlobalGet, g.index
    ])
    .exportAs("main");

  const instance = builder.instantiate();

  const test_value = { hello: 'world' };
  assertSame(test_value, instance.exports.main(test_value));
})();

(function TestAnyFuncGlobalChangeValue() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  // Dummy global for offset.
  builder.addGlobal(kWasmAnyFunc, true, false);
  const g = builder.addGlobal(kWasmAnyFunc, true, false);
  builder.addFunction("main", kSig_a_a)
    .addBody([
      kExprLocalGet, 0,
      kExprGlobalSet, g.index,
      kExprGlobalGet, g.index
    ])
    .exportAs("main");

  const instance = builder.instantiate();

  const test_value = instance.exports.main;
  assertSame(test_value, instance.exports.main(test_value));
})();

(function TestGlobalChangeValueWithGC() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  const gc_index = builder.addImport("q", "gc", kSig_v_v);
  // Dummy global for offset.
  builder.addGlobal(kWasmExternRef, true, false);
  const g = builder.addGlobal(kWasmExternRef, true, false);
  builder.addFunction("main", kSig_r_r)
    .addBody([
      kExprLocalGet, 0,
      kExprGlobalSet, g.index,
      kExprCallFunction, gc_index,  // call gc
      kExprGlobalGet, g.index
    ])
    .exportAs("main");

  const instance = builder.instantiate({ q: { gc: gc } });

  const test_value = { hello: 'world' };
  assertSame(test_value, instance.exports.main(test_value));
  assertSame(5, instance.exports.main(5));
  assertSame("Hello", instance.exports.main("Hello"));
})();

(function TestGlobalAsRoot() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  const g = builder.addGlobal(kWasmExternRef, true, false);
  builder.addFunction("get_global", kSig_r_v)
    .addBody([
      kExprGlobalGet, g.index
    ])
    .exportAs("get_global");

  builder.addFunction("set_global", kSig_v_r)
    .addBody([
      kExprLocalGet, 0,
      kExprGlobalSet, g.index
    ])
    .exportAs("set_global");

  const instance = builder.instantiate();

  let test_value = { hello: 'world' };
  instance.exports.set_global(test_value);
  test_value = null;
  gc();

  const result = instance.exports.get_global();

  assertEquals('world', result.hello);
})();

(function TestImportedExternRef() {
  print(arguments.callee.name);
  function Test(obj) {
    let builder = new WasmModuleBuilder();
    const g = builder.addImportedGlobal('m', 'val', kWasmExternRef);
    builder.addFunction('main', kSig_r_v)
      .addBody([kExprGlobalGet, g])
      .exportAs('main');

    const instance = builder.instantiate({ m: { val: obj } });
    assertSame(obj, instance.exports.main());
  }
  Test(null);
  Test(undefined);
  Test(1653);
  Test("mystring");
  Test({ q: 14 });
  Test(print);
})();

function dummy_func() {
  let builder = new WasmModuleBuilder();
  builder.addFunction("dummy", kSig_i_v)
    .addBody([kExprI32Const, 12])
    .exportAs("dummy");
  return builder.instantiate().exports.dummy;
}

(function TestImportedAnyFunc() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();
  const g = builder.addImportedGlobal('m', 'val', kWasmAnyFunc);
  builder.addFunction('main', kSig_a_v)
    .addBody([kExprGlobalGet, g])
    .exportAs('main');

  const module = builder.toModule();
  const instance = new WebAssembly.Instance(module, { m: { val: null } });
  assertSame(null, instance.exports.main());

  const instance2 = new WebAssembly.Instance(
    module, { m: { val: instance.exports.main } });
  assertSame(instance.exports.main, instance2.exports.main());

  assertThrows(() => new WebAssembly.Instance(module, { m: { val: {} } }),
    WebAssembly.LinkError);
})();

(function TestExternRefGlobalObjectDefaultValue() {
  print(arguments.callee.name);
  let default_init = new WebAssembly.Global({ value: 'externref', mutable: true });
  assertSame(undefined, default_init.value);
  assertSame(undefined, default_init.valueOf());
})();

(function TestAnyFuncGlobalObjectDefaultValue() {
  print(arguments.callee.name);
  let default_init = new WebAssembly.Global({ value: 'anyfunc', mutable: true });
  assertSame(null, default_init.value);
  assertSame(null, default_init.valueOf());
})();

(function TestExternRefGlobalObject() {
  print(arguments.callee.name);
  function TestGlobal(obj) {
    const global = new WebAssembly.Global({ value: 'externref' }, obj);
    assertSame(obj, global.value);
    assertSame(obj, global.valueOf());
  }

  TestGlobal(null);
  TestGlobal(undefined);
  TestGlobal(1663);
  TestGlobal("testmyglobal");
  TestGlobal({ a: 11 });
  TestGlobal(print);
})();

(function TestAnyFuncGlobalObject() {
  print(arguments.callee.name);

  const dummy = dummy_func();
  const global = new WebAssembly.Global({ value: 'anyfunc' }, dummy);
  assertSame(dummy, global.value);
  assertSame(dummy, global.valueOf());

  const global_null = new WebAssembly.Global({ value: 'anyfunc' }, null);
  assertSame(null, global_null.value);
  assertSame(null, global_null.valueOf());

  assertThrows(() => new WebAssembly.Global({ value: 'anyfunc' }, {}),
               TypeError);
})();

(function TestExternRefGlobalObjectSetValue() {
  print(arguments.callee.name);
  let global = new WebAssembly.Global({ value: 'externref', mutable: true });

  function TestGlobal(obj) {
    global.value = obj;
    assertSame(obj, global.value);
    assertSame(obj, global.valueOf());
  }

  TestGlobal(null);
  TestGlobal(undefined);
  TestGlobal(1663);
  TestGlobal("testmyglobal");
  TestGlobal({ a: 11 });
  TestGlobal(print);
})();


(function TestAnyFuncGlobalObjectSetValue() {
  print(arguments.callee.name);
  let global = new WebAssembly.Global({ value: 'anyfunc', mutable: true });

  const dummy = dummy_func();
  global.value = dummy;
  assertSame(dummy, global.value);
  assertSame(dummy, global.valueOf());

  global.value = null;
  assertSame(null, global.value);
  assertSame(null, global.valueOf());

  assertThrows(() => global.value = {}, TypeError);
})();

(function TestExportMutableRefGlobal() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  const g1 = builder.addGlobal(kWasmExternRef, true, false).exportAs("global1");
  const g2 = builder.addGlobal(kWasmAnyFunc, true, false).exportAs("global2");
  builder.addGlobal(kWasmI32, true, false); // Dummy.
  builder.addGlobal(kWasmExternRef, true, false); // Dummy.
  const g3 = builder.addGlobal(kWasmExternRef, true, false).exportAs("global3");
  const g4 = builder.addGlobal(kWasmAnyFunc, true, false).exportAs("global4");
  builder.addFunction("main",
    makeSig([kWasmExternRef, kWasmAnyFunc, kWasmExternRef, kWasmAnyFunc], []))
    .addBody([
      kExprLocalGet, 0,
      kExprGlobalSet, g1.index,
      kExprLocalGet, 1,
      kExprGlobalSet, g2.index,
      kExprLocalGet, 2,
      kExprGlobalSet, g3.index,
      kExprLocalGet, 3,
      kExprGlobalSet, g4.index
    ])
    .exportAs("main");

  const instance = builder.instantiate();
  const obj1 = { x: 221 };
  const func2 = instance.exports.main;
  const obj3 = print;
  const func4 = dummy_func();
  instance.exports.main(obj1, func2, obj3, func4);
  assertSame(obj1, instance.exports.global1.value);
  assertSame(func2, instance.exports.global2.value);
  assertSame(obj3, instance.exports.global3.value);
  assertSame(func4, instance.exports.global4.value);
})();

(function TestImportMutableExternRefGlobal() {
  print(arguments.callee.name);
  function Test(obj) {
    let builder = new WasmModuleBuilder();
    const g = builder.addImportedGlobal('m', 'val', kWasmExternRef, true);
    builder.addFunction('main', kSig_r_v)
      .addBody([kExprGlobalGet, g])
      .exportAs('main');

    const global = new WebAssembly.Global({ value: 'externref', mutable: 'true' }, obj);
    const instance = builder.instantiate({ m: { val: global } });
    assertSame(obj, instance.exports.main());
  }
  Test(null);
  Test(undefined);
  Test(1653);
  Test("mystring");
  Test({ q: 14 });
  Test(print);
})();

(function TestImportMutableAnyFuncGlobal() {
  print(arguments.callee.name);
  function Test(obj) {
    let builder = new WasmModuleBuilder();
    const g = builder.addImportedGlobal('m', 'val', kWasmAnyFunc, true);
    builder.addFunction('main', kSig_a_v)
      .addBody([kExprGlobalGet, g])
      .exportAs('main');

    const global = new WebAssembly.Global({ value: 'anyfunc', mutable: 'true' }, obj);
    const instance = builder.instantiate({ m: { val: global } });
    assertSame(obj, instance.exports.main());
  }
  Test(dummy_func());
  Test(null);
})();

(function TestImportMutableExternRefGlobalFromOtherInstance() {
  print(arguments.callee.name);

  // Create an instance which exports globals.
  let builder1 = new WasmModuleBuilder();
  const g3 = builder1.addGlobal(kWasmExternRef, true, false).exportAs("e3");
  builder1.addGlobal(kWasmI32, true, false).exportAs("e1"); // Dummy.
  builder1.addGlobal(kWasmExternRef, true, false).exportAs("e4"); // Dummy.
  const g2 = builder1.addGlobal(kWasmExternRef, true, false).exportAs("e2");

  builder1.addFunction("set_globals", kSig_v_rr)
    .addBody([
      kExprLocalGet, 0,
      kExprGlobalSet, g2.index,
      kExprLocalGet, 1,
      kExprGlobalSet, g3.index,
    ])
    .exportAs("set_globals");

  builder1.addFunction('get_global2', kSig_r_v)
    .addBody([kExprGlobalGet, g2.index])
    .exportAs('get_global2');

  builder1.addFunction('get_global3', kSig_r_v)
    .addBody([kExprGlobalGet, g3.index])
    .exportAs('get_global3');

  const instance1 = builder1.instantiate();
  const obj2 = { x: 221 };
  const obj3 = print;
  instance1.exports.set_globals(obj2, obj3);

  // Create an instance which imports the globals of the other instance.
  let builder2 = new WasmModuleBuilder();
  const i1 = builder2.addImportedGlobal('exports', 'e1', kWasmI32, true);
  const i2 = builder2.addImportedGlobal('exports', 'e2', kWasmExternRef, true);
  const i3 = builder2.addImportedGlobal('exports', 'e3', kWasmExternRef, true);
  const i4 = builder2.addImportedGlobal('exports', 'e4', kWasmExternRef, true);

  builder2.addExportOfKind("reexport1", kExternalGlobal, i1);
  builder2.addExportOfKind("reexport2", kExternalGlobal, i2);
  builder2.addExportOfKind("reexport3", kExternalGlobal, i3);
  builder2.addExportOfKind("reexport4", kExternalGlobal, i4);

  builder2.addFunction("set_globals", kSig_v_rr)
    .addBody([
      kExprLocalGet, 0,
      kExprGlobalSet, i2,
      kExprLocalGet, 1,
      kExprGlobalSet, i3,
    ])
    .exportAs("set_globals");

  builder2.addFunction('get_global2', kSig_r_v)
    .addBody([kExprGlobalGet, i2])
    .exportAs('get_global2');

  builder2.addFunction('get_global3', kSig_r_v)
    .addBody([kExprGlobalGet, i3])
    .exportAs('get_global3');

  const instance2 = builder2.instantiate(instance1);
  // Check if the globals were imported correctly.
  assertSame(obj2, instance2.exports.get_global2());
  assertSame(obj3, instance2.exports.get_global3());

  assertSame(obj2, instance2.exports.reexport2.value);
  assertSame(obj3, instance2.exports.reexport3.value);

  // Check if instance2 can make changes visible for instance1.
  instance2.exports.set_globals(null, undefined);
  assertEquals(null, instance1.exports.get_global2());
  assertEquals(undefined, instance1.exports.get_global3());

  assertEquals(null, instance2.exports.reexport2.value);
  assertEquals(undefined, instance2.exports.reexport3.value);

  // Check if instance1 can make changes visible for instance2.
  instance1.exports.set_globals("foo", 66343);
  assertEquals("foo", instance2.exports.get_global2());
  assertEquals(66343, instance2.exports.get_global3());

  assertEquals("foo", instance2.exports.reexport2.value);
  assertEquals(66343, instance2.exports.reexport3.value);

  const bar2 = { f: "oo" };
  const bar3 = { b: "ar" };
  instance2.exports.reexport2.value = bar2;
  instance2.exports.reexport3.value = bar3;

  assertSame(bar2, instance1.exports.get_global2());
  assertSame(bar3, instance1.exports.get_global3());
  assertSame(bar2, instance2.exports.get_global2());
  assertSame(bar3, instance2.exports.get_global3());
})();

(function TestImportMutableAnyFuncGlobalFromOtherInstance() {
  print(arguments.callee.name);

  // Create an instance which exports globals.
  let builder1 = new WasmModuleBuilder();
  const g3 = builder1.addGlobal(kWasmAnyFunc, true, false).exportAs("e3");
  builder1.addGlobal(kWasmI32, true, false).exportAs("e1"); // Dummy.
  builder1.addGlobal(kWasmAnyFunc, true, false).exportAs("e4"); // Dummy.
  const g2 = builder1.addGlobal(kWasmAnyFunc, true, false).exportAs("e2");

  builder1.addFunction("set_globals", kSig_v_aa)
    .addBody([
      kExprLocalGet, 0,
      kExprGlobalSet, g2.index,
      kExprLocalGet, 1,
      kExprGlobalSet, g3.index,
    ])
    .exportAs("set_globals");

  builder1.addFunction('get_global2', kSig_a_v)
    .addBody([kExprGlobalGet, g2.index])
    .exportAs('get_global2');

  builder1.addFunction('get_global3', kSig_a_v)
    .addBody([kExprGlobalGet, g3.index])
    .exportAs('get_global3');

  const instance1 = builder1.instantiate();
  const obj2 = dummy_func();
  const obj3 = instance1.exports.set_globals;
  const obj4 = instance1.exports.get_global3;
  instance1.exports.set_globals(obj2, obj3);

  // Create an instance which imports the globals of the other instance.
  let builder2 = new WasmModuleBuilder();
  const i1 = builder2.addImportedGlobal('exports', 'e1', kWasmI32, true);
  const i2 = builder2.addImportedGlobal('exports', 'e2', kWasmAnyFunc, true);
  const i3 = builder2.addImportedGlobal('exports', 'e3', kWasmAnyFunc, true);
  const i4 = builder2.addImportedGlobal('exports', 'e4', kWasmAnyFunc, true);

  builder2.addExportOfKind("reexport1", kExternalGlobal, i1);
  builder2.addExportOfKind("reexport2", kExternalGlobal, i2);
  builder2.addExportOfKind("reexport3", kExternalGlobal, i3);
  builder2.addExportOfKind("reexport4", kExternalGlobal, i4);

  builder2.addFunction("set_globals", kSig_v_aa)
    .addBody([
      kExprLocalGet, 0,
      kExprGlobalSet, i2,
      kExprLocalGet, 1,
      kExprGlobalSet, i3,
    ])
    .exportAs("set_globals");

  builder2.addFunction('get_global2', kSig_a_v)
    .addBody([kExprGlobalGet, i2])
    .exportAs('get_global2');

  builder2.addFunction('get_global3', kSig_a_v)
    .addBody([kExprGlobalGet, i3])
    .exportAs('get_global3');

  const instance2 = builder2.instantiate(instance1);
  // Check if the globals were imported correctly.
  assertSame(obj2, instance2.exports.get_global2());
  assertSame(obj3, instance2.exports.get_global3());

  assertSame(obj2, instance2.exports.reexport2.value);
  assertSame(obj3, instance2.exports.reexport3.value);

  // Check if instance2 can make changes visible for instance1.
  instance2.exports.set_globals(null, obj4);
  assertEquals(null, instance1.exports.get_global2());
  assertEquals(obj4, instance1.exports.get_global3());

  assertEquals(null, instance2.exports.reexport2.value);
  assertEquals(obj4, instance2.exports.reexport3.value);

  // Check if instance1 can make changes visible for instance2.
  instance1.exports.set_globals(obj2, obj3);
  assertEquals(obj2, instance2.exports.get_global2());
  assertEquals(obj3, instance2.exports.get_global3());

  assertEquals(obj2, instance2.exports.reexport2.value);
  assertEquals(obj3, instance2.exports.reexport3.value);
})();

(function TestImportMutableAnyFuncGlobalAsExternRefFails() {
  print(arguments.callee.name);
  let builder1 = new WasmModuleBuilder();
  const g3 = builder1.addGlobal(kWasmAnyFunc, true, false).exportAs("e3");
  builder1.addGlobal(kWasmExternRef, true, false).exportAs("e1"); // Dummy.
  builder1.addGlobal(kWasmAnyFunc, true, false).exportAs("e2"); // Dummy.
  const instance1 = builder1.instantiate();

  let builder2 = new WasmModuleBuilder();
  const i1 = builder2.addImportedGlobal('exports', 'e1', kWasmExternRef, true);
  const i2 = builder2.addImportedGlobal('exports', 'e2', kWasmExternRef, true);
  assertThrows(() => builder2.instantiate(instance1), WebAssembly.LinkError);
})();

(function TestRefFuncGlobalInit() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  const f_func = builder.addFunction('get_anyfunc_global', kSig_a_v)
  builder.addDeclarativeElementSegment([f_func.index]);
  const g_func = builder.addGlobal(kWasmAnyFunc, true, false,
    [kExprRefFunc, f_func.index]);
  // Doing this here to break the cyclic dependency with g_func.
  f_func.addBody([kExprGlobalGet, g_func.index])
    .exportAs('get_anyfunc_global');

  const instance = builder.instantiate();
  assertEquals(
      instance.exports.get_anyfunc_global,
      instance.exports.get_anyfunc_global());
})();

(function TestRefFuncGlobalInitWithImport() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  const sig_index = builder.addType(kSig_i_v);
  const import_wasm = builder.addImport('m', 'wasm', sig_index);
  const import_js = builder.addImport('m', 'js', sig_index);
  const g_wasm = builder.addGlobal(kWasmAnyFunc, true, false,
                                   [kExprRefFunc, import_wasm]);
  const g_js = builder.addGlobal(kWasmAnyFunc, true, false,
                                 [kExprRefFunc, import_js]);
  builder.addDeclarativeElementSegment([import_wasm, import_js]);
  builder.addFunction('get_global_wasm', kSig_a_v)
      .addBody([kExprGlobalGet, g_wasm.index])
      .exportFunc();
  builder.addFunction('get_global_js', kSig_a_v)
      .addBody([kExprGlobalGet, g_js.index])
      .exportFunc();

  const expected_wasm = dummy_func();
  const expected_val = 27;
  // I want to test here that imported JS functions get wrapped by wasm-to-js
  // and js-to-wasm wrappers. That's why {expected_js} does not return an
  // integer directly but an object with a {valueOf} function.
  function expected_js() {
    const result = {};
    result.valueOf = () => expected_val;
    return result;
  };

  const instance =
      builder.instantiate({m: {wasm: expected_wasm, js: expected_js}});

  assertSame(expected_wasm, instance.exports.get_global_wasm());
  assertSame(expected_val, instance.exports.get_global_js()());
})();

(function TestSetGlobalWriteBarrier() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  const global = builder.addGlobal(kWasmExternRef, true, false).index;
  builder.addFunction("set_global", kSig_v_r)
    .addBody([kExprLocalGet, 0, kExprGlobalSet, global])
    .exportFunc();
  builder.addFunction("get_global", kSig_r_v)
    .addBody([kExprGlobalGet, global])
    .exportFunc();

  const instance = builder.instantiate();
  // Trigger GC twice to make sure the instance is moved to mature space.
  gc();
  gc();
  const test_value = { hello: 'world' };
  instance.exports.set_global(test_value);
  // Run another GC to test if the writebarrier existed.
  gc();
  assertSame(test_value, instance.exports.get_global());
})();
                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/wasm/externref-table.js                                            0000664 0000000 0000000 00000020026 14746647661 0023111 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-type-reflection

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestExternRefTableSetWithMultipleTypes() {
  print(arguments.callee.name);
  let table = new WebAssembly.Table({element: "externref", initial: 10});

  // Table should be initialized with undefined.
  assertEquals(undefined, table.get(1));
  let obj = {'hello' : 'world'};
  table.set(2, obj);
  assertSame(obj, table.get(2));
  table.set(3, 1234);
  assertEquals(1234, table.get(3));
  table.set(4, 123.5);
  assertEquals(123.5, table.get(4));
  table.set(5, undefined);
  assertEquals(undefined, table.get(5));
  // Overwrite entry 4, because null would otherwise be the default value.
  table.set(4, null);
  assertEquals(null, table.get(4));
  table.set(7, print);
  assertEquals(print, table.get(7));

  assertThrows(() => table.set(12), RangeError);
})();

(function TestImportExternRefTable() {
  print(arguments.callee.name);

  const builder = new WasmModuleBuilder();
  const table_index = builder.addImportedTable(
      "imp", "table", 3, 10, kWasmExternRef);
  builder.addFunction('get', kSig_r_v)
  .addBody([kExprI32Const, 0, kExprTableGet, table_index]);

  let table_ref = new WebAssembly.Table(
      { element: "externref", initial: 3, maximum: 10 });
  builder.instantiate({imp:{table: table_ref}});

  let table_func = new WebAssembly.Table(
      { element: "anyfunc", initial: 3, maximum: 10 });
  assertThrows(() => builder.instantiate({ imp: { table: table_func } }),
    WebAssembly.LinkError, /imported table does not match the expected type/);
})();

(function TestExternRefDropDeclarativeElementSegment() {
  print(arguments.callee.name);

  const builder = new WasmModuleBuilder();
  builder.addDeclarativeElementSegment([[kExprRefNull, kFuncRefCode]],
                                        kWasmFuncRef);
  builder.addFunction('drop', kSig_v_v)
      .addBody([kNumericPrefix, kExprElemDrop, 0])
      .exportFunc();
  const instance = builder.instantiate();

  // Counts as double-drop because declarative segments are dropped on
  // initialization and is therefore not expected to throw.
  instance.exports.drop();
})();

(function TestExternRefTableInitFromDeclarativeElementSegment() {
  print(arguments.callee.name);

  const builder = new WasmModuleBuilder();
  const table = builder.addTable(kWasmAnyFunc, 10);
  builder.addDeclarativeElementSegment([[kExprRefNull, kFuncRefCode]],
                                       kWasmFuncRef);
  builder.addFunction('init', kSig_v_v)
      .addBody([
        kExprI32Const, 0, kExprI32Const, 0, kExprI32Const, 1, kNumericPrefix,
        kExprTableInit, table.index, 0
      ])
      .exportFunc();
  const instance = builder.instantiate();

  assertTraps(kTrapElementSegmentOutOfBounds, () => instance.exports.init());
})();

(function TestTableInitializer() {
  print(arguments.callee.name);

  let test = function(is_nullable) {
    const builder = new WasmModuleBuilder();
    const sig = builder.addType(kSig_i_i);
    const func = builder.addFunction("func", kSig_i_i)
      .addBody([kExprLocalGet, 0]);
    builder.addTable(is_nullable ? wasmRefNullType(sig) : wasmRefType(sig),
                     10, 10, [kExprRefFunc, func.index]);
    builder.addFunction("main", kSig_i_ii)
      .addBody([kExprLocalGet, 1, kExprLocalGet, 0, kExprTableGet, 0,
                kExprCallRef, sig])
      .exportFunc();

    const instance = builder.instantiate();

    assertEquals(1, instance.exports.main(0, 1));
    assertEquals(33, instance.exports.main(5, 33));
  }

  test(true);
  test(false);
})();

(function TestExternRefTableConstructorWithDefaultValue() {
  print(arguments.callee.name);
  const testObject = {};
  const argument = { "element": "externref", "initial": 3 };
  const table = new WebAssembly.Table(argument, testObject);
  assertEquals(table.length, 3);
  assertEquals(table.get(0), testObject);
  assertEquals(table.get(1), testObject);
  assertEquals(table.get(2), testObject);
})();

function getDummy(val) {
  let builder = new WasmModuleBuilder();
  builder.addFunction('dummy', kSig_i_v)
      .addBody([kExprI32Const, val])
      .exportAs('dummy');
  return builder.instantiate().exports.dummy;
}

(function TestFuncRefTableConstructorWithDefaultValue() {
  print(arguments.callee.name);

  const expected = 6;
  let dummy = getDummy(expected);

  const argument = { "element": "anyfunc", "initial": 3 };
  const table = new WebAssembly.Table(argument, dummy);
  assertEquals(table.length, 3);
  assertEquals(table.get(0)(), expected);
  assertEquals(table.get(1)(), expected);
  assertEquals(table.get(2)(), expected);
})();

(function TestExternFuncTableSetWithoutValue() {
  print(arguments.callee.name);

  const expected = 6;
  const dummy = getDummy(expected);
  const argument = { "element": "anyfunc", "initial": 3 };
  const table = new WebAssembly.Table(argument, dummy);
  assertEquals(table.get(1)(), expected);
  table.set(1);
  assertEquals(table.get(1), null);
})();

(function TestExternRefTableSetWithoutValue() {
  print(arguments.callee.name);

  const testObject = {};
  const argument = { "element": "externref", "initial": 3 };
  const table = new WebAssembly.Table(argument, testObject);
  assertEquals(table.get(1), testObject);
  table.set(1);
  assertEquals(table.get(1), undefined);
})();

(function TestFunctionExternRefTableRoundtrip() {
  // Test that
  // - initialization, setting, and growing an externref table, and
  // - (imported) externref globals
  // preserve function references.
  print(arguments.callee.name);

  const js_function = function (i) { return i + 1; };
  const wasm_js_function = new WebAssembly.Function(
    {parameters:['i32', 'i32'], results: ['i32']},
    function(a, b) { return a * b; })

  let extern_type = wasmRefType(kWasmExternRef);

  let builder = new WasmModuleBuilder();
  let imported_global = builder.addImportedGlobal('m', 'n', extern_type, false);
  let global =
    builder.addGlobal(kWasmExternRef, true, false).exportAs('global');
  let table = builder.addTable(extern_type, 2, 10,
                               [kExprGlobalGet, imported_global])
  builder.addFunction(
      'setup', makeSig([extern_type, extern_type], []))
    .addBody([
      kExprLocalGet, 0, kExprGlobalSet, global.index,
      kExprI32Const, 1, kExprLocalGet, 0, kExprTableSet, table.index,
      kExprLocalGet, 1, kExprI32Const, 1, kNumericPrefix,
      kExprTableGrow, table.index, kExprDrop])
    .exportFunc();
  builder.addFunction('get', makeSig([kWasmI32], [kWasmExternRef]))
    .addBody([kExprLocalGet, 0, kExprTableGet, table.index])
    .exportFunc();
  let instance = builder.instantiate({m : {n : js_function}});

  instance.exports.setup(wasm_js_function, instance.exports.setup);

  assertEquals(instance.exports.global.value, wasm_js_function);
  assertEquals(instance.exports.get(0), js_function);
  assertEquals(instance.exports.get(1), wasm_js_function);
  assertEquals(instance.exports.get(2), instance.exports.setup);
})();

(function TestFunctionExternRefTableRoundtrip2() {
  // Test that initialization, setting, and growing an externref table in the JS
  // API preserves function references.
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();
  builder.addFunction('dummy', kSig_i_v)
      .addBody([kExprI32Const, 0])
      .exportAs('dummy');
  let instance = builder.instantiate();
  const js_function = function (i) { return i + 1; };
  const wasm_js_function = new WebAssembly.Function(
    {parameters:['i32', 'i32'], results: ['i32']},
    function(a, b) { return a * b; })

  const argument = { "element": "externref", "initial": 3 };
  const table = new WebAssembly.Table(argument, js_function);
  table.set(1, wasm_js_function);
  table.set(2, instance.exports.dummy);
  table.grow(1, wasm_js_function);
  assertEquals(table.get(0), js_function);
  assertEquals(table.get(1), wasm_js_function);
  assertEquals(table.get(2), instance.exports.dummy);
  assertEquals(table.get(3), wasm_js_function);
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/wasm/externref.js                                                  0000664 0000000 0000000 00000027500 14746647661 0022030 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --expose-gc --allow-natives-syntax

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function testExternRefIdentityFunction() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.addFunction('main', kSig_r_r)
      .addBody([kExprLocalGet, 0])
      .exportFunc();

  const instance = builder.instantiate();

  let obj = {'hello' : 'world'};
  assertEquals(obj, instance.exports.main(obj));
  assertEquals(1234, instance.exports.main(1234));
  assertEquals(123.4, instance.exports.main(123.4));
  assertEquals(undefined, instance.exports.main(undefined));
  assertEquals(null, instance.exports.main(null));
  assertEquals(print, instance.exports.main(print));
})();

(function testPassExternRefToImportedFunction() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const sig_index = builder.addType(kSig_v_r);
  const imp_index = builder.addImport("q", "func", sig_index);
  builder.addFunction('main', sig_index)
      .addBody([kExprLocalGet, 0,
      kExprCallFunction, imp_index])
      .exportFunc();

  function checkFunction(value) {
    assertEquals('world', value.hello);
  }

  const instance = builder.instantiate({q: {func: checkFunction}});

  instance.exports.main({hello: 'world'});
})();

(function testPassExternRefWithGCWithLocals() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const ref_sig = builder.addType(kSig_v_r);
  const void_sig = builder.addType(kSig_v_v);
  const imp_index = builder.addImport("q", "func", ref_sig);
  const gc_index = builder.addImport("q", "gc", void_sig);
  // First call the gc, then check if the object still exists.
  builder.addFunction('main', ref_sig)
      .addLocals(kWasmExternRef, 10)
      .addBody([
        kExprLocalGet, 0, kExprLocalSet, 1,             // Set local
        kExprLocalGet, 0, kExprLocalSet, 2,             // Set local
        kExprLocalGet, 0, kExprLocalSet, 3,             // Set local
        kExprLocalGet, 0, kExprLocalSet, 4,             // Set local
        kExprLocalGet, 0, kExprLocalSet, 5,             // Set local
        kExprLocalGet, 0, kExprLocalSet, 6,             // Set local
        kExprLocalGet, 0, kExprLocalSet, 7,             // Set local
        kExprLocalGet, 0, kExprLocalSet, 8,             // Set local
        kExprLocalGet, 0, kExprLocalSet, 9,             // Set local
        kExprLocalGet, 0, kExprLocalSet, 10,            // Set local
        kExprCallFunction, gc_index,                    // call gc
        kExprLocalGet, 9, kExprCallFunction, imp_index  // call import
      ])
      .exportFunc();

  function checkFunction(value) {
    assertEquals('world', value.hello);
  }

  const instance = builder.instantiate({q: {func: checkFunction, gc: gc}});

  instance.exports.main({hello: 'world'});
})();

(function testPassExternRefWithGC() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const ref_sig = builder.addType(kSig_v_r);
  const void_sig = builder.addType(kSig_v_v);
  const imp_index = builder.addImport("q", "func", ref_sig);
  const gc_index = builder.addImport("q", "gc", void_sig);
  // First call the gc, then check if the object still exists.
  builder.addFunction('main', ref_sig)
      .addBody([
        kExprCallFunction, gc_index,                    // call gc
        kExprLocalGet, 0, kExprCallFunction, imp_index  // call import
      ])
      .exportFunc();

  function checkFunction(value) {
    assertEquals('world', value.hello);
  }

  const instance = builder.instantiate({q: {func: checkFunction, gc: gc}});

  instance.exports.main({hello: 'world'});
})();

(function testPassExternRefWithGCWithStackParameters() {
  print(arguments.callee.name);
  const num_params = 15;
  for (let index = 0; index < num_params; index++) {
    const builder = new WasmModuleBuilder();
    // Make a signature with {num_params} many externref parameters.
    const mysig = makeSig(Array(num_params).fill(kWasmExternRef), []);
    const main_sig = builder.addType(mysig);
    const ref_sig = builder.addType(kSig_v_r);
    const void_sig = builder.addType(kSig_v_v);
    const imp_index = builder.addImport('q', 'func', ref_sig);
    const gc_index = builder.addImport('q', 'gc', void_sig);
    // First call the gc, then check if the object still exists.
    builder.addFunction('main', main_sig)
        .addBody([
          kExprCallFunction, gc_index,                        // call gc
          kExprLocalGet, index, kExprCallFunction, imp_index  // call import
        ])
        .exportFunc();

    function checkFunction(value) {
      assertEquals(index, value.hello);
    }

    const instance = builder.instantiate({q: {func: checkFunction, gc: gc}});

    // Pass {num_params} many parameters to main. Note that it is important
    // that no other references to these objects exist. They are kept alive
    // only through references stored in the parameters slots of a stack frame.
    instance.exports.main(
        {hello: 0}, {hello: 1}, {hello: 2}, {hello: 3}, {hello: 4}, {hello: 5},
        {hello: 6}, {hello: 7}, {hello: 8}, {hello: 9}, {hello: 10},
        {hello: 11}, {hello: 12}, {hello: 13}, {hello: 14});
  }
})();

(function testPassExternRefWithGCInWrapper() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const kSig_r_iri = makeSig([kWasmI32, kWasmExternRef, kWasmI32], [kWasmExternRef]);
  const sig_index = builder.addType(kSig_r_iri);
  builder.addFunction('main', sig_index)
      .addBody([kExprLocalGet, 1])
      .exportFunc();

  const instance = builder.instantiate();

  const triggerGCParam = {
    valueOf: () => {
      gc();
      return 17;
    }
  };

  const result = instance.exports.main(triggerGCParam, {hello: 'world'}, triggerGCParam);
  assertEquals('world', result.hello);
})();

(function testExternRefNull() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.addFunction('main', kSig_r_v)
      .addBody([kExprRefNull, kExternRefCode])
      .exportFunc();

  const instance = builder.instantiate();

  assertEquals(null, instance.exports.main());
})();

(function testExternRefIsNull() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.addFunction('main', kSig_i_r)
      .addBody([kExprLocalGet, 0, kExprRefIsNull])
      .exportFunc();

  const instance = builder.instantiate();

  assertEquals(0, instance.exports.main({'hello' : 'world'}));
  assertEquals(0, instance.exports.main(1234));
  assertEquals(0, instance.exports.main(0));
  assertEquals(0, instance.exports.main(123.4));
  assertEquals(0, instance.exports.main(undefined));
  assertEquals(1, instance.exports.main(null));
  assertEquals(0, instance.exports.main(print));
})();

(function testExternRefNullIsNull() {
  print(arguments.callee.name);

  const builder = new WasmModuleBuilder();
  builder.addFunction('main', kSig_i_v)
      .addBody([kExprRefNull, kExternRefCode, kExprRefIsNull])
      .exportFunc();

  const instance = builder.instantiate();

  assertEquals(1, instance.exports.main());
})();

(function testExternRefLocalDefaultValue() {
  print(arguments.callee.name);
  const numLocals = 3;
  for (let i = 0; i < numLocals; ++i) {
    const builder = new WasmModuleBuilder();
    builder.addFunction('main', kSig_r_v)
        .addBody([kExprLocalGet, i])
        .addLocals(kWasmExternRef, numLocals)
        .exportFunc();

    const instance = builder.instantiate();

    assertEquals(null, instance.exports.main());
  }
})();

(function testImplicitReturnNullAsExternRef() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const sig_index = builder.addType(kSig_r_v);
  builder.addFunction('main', sig_index)
      .addBody([kExprRefNull, kExternRefCode])
      .exportFunc();

  const main = builder.instantiate().exports.main;
  assertEquals(null, main());
})();

(function testExplicitReturnNullAsExternRef() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const sig_index = builder.addType(kSig_r_v);
  builder.addFunction('main', sig_index)
      .addBody([kExprRefNull, kExternRefCode, kExprReturn])
      .exportFunc();

  const main = builder.instantiate().exports.main;
  assertEquals(null, main());
})();

(function testGCInStackCheck() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();

  const gc_sig = builder.addType(kSig_v_v);
  const mysig = makeSig(
      [
        kWasmExternRef, kWasmI32, kWasmExternRef, kWasmExternRef, kWasmExternRef
      ],
      []);
  const func_sig = builder.addType(mysig);
  const triggerGC_index = builder.addImport('q', 'triggerGC', gc_sig);
  const func_index = builder.addImport('q', 'func', func_sig);

  const foo = builder.addFunction('foo', func_sig).addBody([
    kExprLocalGet, 0, // --
    kExprLocalGet, 1, // --
    kExprLocalGet, 2, // --
    kExprLocalGet, 3, // --
    kExprLocalGet, 4, // --
    kExprCallFunction, func_index
  ]);

  builder.addFunction('main', func_sig)
      .addBody([
        kExprCallFunction, triggerGC_index,  // --
        kExprLocalGet, 0,                    // --
        kExprLocalGet, 1,                    // --
        kExprLocalGet, 2,                    // --
        kExprLocalGet, 3,                    // --
        kExprLocalGet, 4,                    // --
        kExprCallFunction, foo.index
      ])
      .exportFunc();

  const instance = builder.instantiate({
    q: {
      triggerGC: () => %ScheduleGCInStackCheck(),
      func: (ref) => assertEquals(ref.hello, 4)
    }
  });

  instance.exports.main({hello: 4}, 5, {world: 6}, null, {bar: 7});
})();

(function testGCInStackCheckUnalignedFrameSize() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();

  const gc_sig = builder.addType(kSig_v_v);
  const mysig = makeSig(
      [
        kWasmExternRef, kWasmI32, kWasmExternRef, kWasmExternRef, kWasmExternRef
      ],
      []);
  const func_sig = builder.addType(mysig);
  const triggerGC_index = builder.addImport('q', 'triggerGC', gc_sig);
  const func_index = builder.addImport('q', 'func', func_sig);

  const foo = builder.addFunction('foo', func_sig).addBody([
    kExprLocalGet, 0, // --
    kExprLocalGet, 1, // --
    kExprLocalGet, 2, // --
    kExprLocalGet, 3, // --
    kExprLocalGet, 4, // --
    kExprCallFunction, func_index
  ]).addLocals(kWasmI32, 1);

  builder.addFunction('main', func_sig)
      .addBody([
        kExprCallFunction, triggerGC_index,  // --
        kExprLocalGet, 0,                    // --
        kExprLocalGet, 1,                    // --
        kExprLocalGet, 2,                    // --
        kExprLocalGet, 3,                    // --
        kExprLocalGet, 4,                    // --
        kExprCallFunction, foo.index
      ])
      .exportFunc();

  const instance = builder.instantiate({
    q: {
      triggerGC: () => %ScheduleGCInStackCheck(),
      func: (ref) => assertEquals(ref.hello, 4)
    }
  });

  instance.exports.main({hello: 4}, 5, {world: 6}, null, {bar: 7});
})();

(function MultiReturnRefTest() {
  print("MultiReturnTest");
  let builder = new WasmModuleBuilder();
  let gc_sig = builder.addType(kSig_v_v);
  let sig = makeSig([kWasmExternRef],
      [kWasmExternRef, kWasmExternRef, kWasmExternRef, kWasmExternRef]);

  let gc_index = builder.addImport('q', 'gc', gc_sig);
  let callee = builder.addFunction("callee", sig)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 0,
      kExprLocalGet, 0,
      kExprLocalGet, 0,
    ]);
  builder.addFunction("main", sig)
    .addBody([
      kExprLocalGet, 0,
      kExprCallFunction, callee.index,
      kExprCallFunction, gc_index,
    ])
    .exportAs("main");

  let instance = builder.instantiate({
    q: { gc: () => gc() }
  });
  assertEquals(instance.exports.main(null), [null, null, null, null]);
})();
                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/wasm/fast-api-calls-with-wellknown-imports-conflict.js             0000664 0000000 0000000 00000005200 14746647661 0031100 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --turbo-fast-api-calls --expose-fast-api --no-liftoff --wasm-fast-api
// Flags: --turboshaft-wasm --wasm-lazy-compilation
// Flags: --no-wasm-native-module-cache-enabled
// Flags: --fast-api-allow-float-in-sim

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function TestI64AsNumber() {
  const fast_c_api = new d8.test.FastCAPI();

  const builder = new WasmModuleBuilder();
  const sig = makeSig(
      [kWasmExternRef, kWasmF64, kWasmF64],
      [kWasmF64],
  );
  const imp_index = builder.addImport('mod', 'foo', sig);
  builder.addFunction('main', sig)
      .addBody([
        kExprLocalGet, 0, // receiver
        kExprLocalGet, 1, // param
        kExprLocalGet, 2, // param
        kExprCallFunction, imp_index
      ])
      .exportFunc();

  const wasmModule = builder.toModule();

  const boundImport1 =
      Function.prototype.call.bind(fast_c_api.sum_int64_as_number);
  const instance1 =
      new WebAssembly.Instance(wasmModule, {'mod': {'foo': boundImport1}});

  fast_c_api.reset_counts();
  assertEquals(5, instance1.exports.main(fast_c_api, 2.5, 3.5));
  // With just one instantiation, the well-known imports optimization is valid,
  // and fast API calls should be used.
  assertEquals(1, fast_c_api.fast_call_count());

  const boundImport2 =
      Function.prototype.call.bind(fast_c_api.sum_uint64_as_number);
  const instance2 =
      new WebAssembly.Instance(wasmModule, {'mod': {'foo': boundImport2}});

  fast_c_api.reset_counts();
  assertEquals(5, instance2.exports.main(fast_c_api, 2.5, 3.5));
  // With a second instantiation that imports an API function with a different
  // signature, the well-known imports optimization is not valid anymore, and
  // regular API calls should be used.
  assertEquals(1, fast_c_api.slow_call_count());

  assertEquals(5, instance1.exports.main(fast_c_api, 2.5, 3.5));
  // Make sure that also the code of the first instance got flushed, and also
  // the first instance now uses regular calls.
  assertEquals(2, fast_c_api.slow_call_count());
  assertEquals(0, fast_c_api.fast_call_count());

  const instance3 =
      new WebAssembly.Instance(wasmModule, {'mod': {'foo': boundImport1}});

  fast_c_api.reset_counts();
  assertEquals(5, instance3.exports.main(fast_c_api, 2.5, 3.5));
  // Even when there is another instantiation with the same imports as the first
  // one, we still don't use fast API calls anymore.
  assertEquals(1, fast_c_api.slow_call_count());
  assertEquals(0, fast_c_api.fast_call_count());
})();
                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/wasm/fast-api-calls-with-wellknown-imports-floats.js               0000664 0000000 0000000 00000006015 14746647661 0030574 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --turbo-fast-api-calls --expose-fast-api --no-liftoff --wasm-fast-api
// Flags: --turboshaft-wasm --wasm-lazy-compilation
// Flags: --fast-api-allow-float-in-sim

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function TestFastApiCallFromWasm() {
  const fast_c_api = new d8.test.FastCAPI();
  const boundImport = Function.prototype.call.bind(fast_c_api.add_all_no_options);

  const builder = new WasmModuleBuilder();
  const sig = makeSig(
      [
        kWasmExternRef, kWasmI32, kWasmI32, kWasmI64, kWasmI64,
        kWasmF32, kWasmF64
      ],
      [kWasmF64],
  );
  const imp_index = builder.addImport('mod', 'foo', sig);
  builder.addFunction('main', sig)
      .addBody([
        kExprLocalGet, 0, // receiver
        kExprLocalGet, 1, // param int32
        kExprLocalGet, 2, // param uint32
        kExprLocalGet, 3, // param int64
        kExprLocalGet, 4, // param uint64
        kExprLocalGet, 5, // param float32
        kExprLocalGet, 6, // param float64
        kExprCallFunction, imp_index
      ])
      .exportFunc();

  const instance = builder.instantiate({'mod': {'foo': boundImport}});

  const fallback = true;
  fast_c_api.reset_counts();
  instance.exports.main(fast_c_api, 1, 2, 3n, 4n, 5, 6);
  assertEquals(1, fast_c_api.fast_call_count());
  instance.exports.main(fast_c_api, 1, 2, 3n, 4n, 5, 6);
  assertEquals(2, fast_c_api.fast_call_count());
  assertThrows(
      _ => instance.exports.main(12, 1, 2, 3n, 4n, 5, 6), TypeError);
  assertThrows(
      _ => instance.exports.main({}, 1, 2, 3n, 4n, 5, 6), TypeError);
})();

(function TestFastApiCallWithOverloadFromWasm() {
  const fast_c_api = new d8.test.FastCAPI();
  const boundImport = Function.prototype.call.bind(fast_c_api.add_all_overload);

  const builder = new WasmModuleBuilder();
  const sig = makeSig(
      [
        kWasmExternRef, kWasmI32, kWasmI32, kWasmI64, kWasmI64,
        kWasmF32, kWasmF64
      ],
      [kWasmF64],
  );
  const imp_index = builder.addImport('mod', 'foo', sig);
  builder.addFunction('main', sig)
      .addBody([
        kExprLocalGet, 0, // receiver
        kExprLocalGet, 1, // param int32
        kExprLocalGet, 2, // param uint32
        kExprLocalGet, 3, // param int64
        kExprLocalGet, 4, // param uint64
        kExprLocalGet, 5, // param float32
        kExprLocalGet, 6, // param float64
        kExprCallFunction, imp_index
      ])
      .exportFunc();

  const instance = builder.instantiate({'mod': {'foo': boundImport}});

  fast_c_api.reset_counts();
  instance.exports.main(fast_c_api, 1, 2, 3n, 4n, 5, 6);
  assertEquals(1, fast_c_api.fast_call_count());
  instance.exports.main(fast_c_api, 1, 2, 3n, 4n, 5, 6);
  assertEquals(2, fast_c_api.fast_call_count());
  assertThrows(
      _ => instance.exports.main(12, 1, 2, 3n, 4n, 5, 6), TypeError);
  assertThrows(
      _ => instance.exports.main({}, 1, 2, 3n, 4n, 5, 6), TypeError);
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/wasm/fast-api-calls-with-wellknown-imports-i64.js                  0000664 0000000 0000000 00000015711 14746647661 0027711 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --turbo-fast-api-calls --expose-fast-api --no-liftoff --wasm-fast-api
// Flags: --turboshaft-wasm --wasm-lazy-compilation
// Flags: --no-wasm-native-module-cache-enabled
// Flags: --fast-api-allow-float-in-sim

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

function TestI64AsNumber(type1, v1, type2, v2, typeE, expected) {
  const fast_c_api = new d8.test.FastCAPI();
  const boundImport =
      Function.prototype.call.bind(fast_c_api.sum_int64_as_number);

  const builder = new WasmModuleBuilder();
  const sig = makeSig(
      [kWasmExternRef, type1, type2],
      [typeE],
  );
  const imp_index = builder.addImport('mod', 'foo', sig);
  builder.addFunction('main', sig)
      .addBody([
        kExprLocalGet, 0, // receiver
        kExprLocalGet, 1, // param
        kExprLocalGet, 2, // param
        kExprCallFunction, imp_index
      ])
      .exportFunc();

  const instance = builder.instantiate({'mod': {'foo': boundImport}});

  fast_c_api.reset_counts();
  assertEquals(expected, instance.exports.main(fast_c_api, v1, v2));
  assertEquals(1, fast_c_api.fast_call_count());
}

TestI64AsNumber(kWasmF64, 2.5, kWasmF64, 3.5, kWasmF64, 5);
TestI64AsNumber(kWasmF32, 2.5, kWasmF32, 3.5, kWasmF32, 5);
TestI64AsNumber(kWasmI32, 2, kWasmI32, 3, kWasmI32, 5);

TestI64AsNumber(kWasmF64, 2.5, kWasmF32, 3.5, kWasmI32, 5);
TestI64AsNumber(kWasmF32, 2.5, kWasmF64, 3.5, kWasmF32, 5);
TestI64AsNumber(kWasmI32, 2, kWasmF64, 3.5, kWasmF32, 5);
TestI64AsNumber(kWasmF32, 2.5, kWasmI32, 3, kWasmF64, 5);

assertThrows(
    () => TestI64AsNumber(kWasmF64, 2 ** 66, kWasmI32, 0, kWasmF64), Error,
    `First number is out of int64_t range.`);
assertThrows(
    () => TestI64AsNumber(kWasmF32, 2 ** 66, kWasmI32, 0, kWasmF64), Error,
    `First number is out of int64_t range.`);

function TestI64AsBigInt(type1, v1, type2, v2, typeE, expected, errorMessage) {
  const fast_c_api = new d8.test.FastCAPI();
  const boundImport =
      Function.prototype.call.bind(fast_c_api.sum_int64_as_bigint);

  const builder = new WasmModuleBuilder();
  const sig = makeSig(
      [kWasmExternRef, type1, type2],
      [typeE],
  );
  const imp_index = builder.addImport('mod', 'foo', sig);
  builder.addFunction('main', sig)
      .addBody([
        kExprLocalGet, 0, // receiver
        kExprLocalGet, 1, // param
        kExprLocalGet, 2, // param
        kExprCallFunction, imp_index
      ])
      .exportFunc();

  const instance = builder.instantiate({'mod': {'foo': boundImport}});

  fast_c_api.reset_counts();

  if (typeof expected === "bigint") {
    assertEquals(expected, instance.exports.main(fast_c_api, v1, v2));
    assertEquals(0, fast_c_api.slow_call_count());
    assertEquals(1, fast_c_api.fast_call_count());
  } else {
    assertThrows(
        () => instance.exports.main(fast_c_api, v1, v2), Error, expected);
  }
}

TestI64AsBigInt(kWasmI64, 2n, kWasmI64, 3n, kWasmI64, 5n);
TestI64AsBigInt(kWasmI64, 2n, kWasmI64, 3n, kWasmF64, "Cannot convert a BigInt value to a number");
TestI64AsBigInt(kWasmF32, 2.5, kWasmI64, 3n, kWasmI64,"Did not get a BigInt as first parameter.");
TestI64AsBigInt(kWasmI64, 2n, kWasmI64, 3n, kWasmI32, "Cannot convert a BigInt value to a number");

TestI64AsBigInt(kWasmF64, 2.5, kWasmF32, 3.5, kWasmI32, "Did not get a BigInt as first parameter.");
TestI64AsBigInt(kWasmF32, 2.5, kWasmF64, 3.5, kWasmF32, "Did not get a BigInt as first parameter.");
TestI64AsBigInt(kWasmI32, 2, kWasmF64, 3.5, kWasmF32, "Did not get a BigInt as first parameter.");
TestI64AsBigInt(kWasmF32, 2.5, kWasmI32, 3, kWasmF64, "Did not get a BigInt as first parameter.");

function TestU64AsNumber(type1, v1, type2, v2, typeE, expected) {
  const fast_c_api = new d8.test.FastCAPI();
  const boundImport =
      Function.prototype.call.bind(fast_c_api.sum_int64_as_number);

  const builder = new WasmModuleBuilder();
  const sig = makeSig(
      [kWasmExternRef, type1, type2],
      [typeE],
  );
  const imp_index = builder.addImport('mod', 'foo', sig);
  builder.addFunction('main', sig)
      .addBody([
        kExprLocalGet, 0, // receiver
        kExprLocalGet, 1, // param
        kExprLocalGet, 2, // param
        kExprCallFunction, imp_index
      ])
      .exportFunc();

  const instance = builder.instantiate({'mod': {'foo': boundImport}});

  fast_c_api.reset_counts();
  assertEquals(expected, instance.exports.main(fast_c_api, v1, v2));
  assertEquals(1, fast_c_api.fast_call_count());
}

TestU64AsNumber(kWasmF64, 2.5, kWasmF64, 3.5, kWasmF64, 5);
TestU64AsNumber(kWasmF32, 2.5, kWasmF32, 3.5, kWasmF32, 5);
TestU64AsNumber(kWasmI32, 2, kWasmI32, 3, kWasmI32, 5);

TestU64AsNumber(kWasmF64, 2.5, kWasmF32, 3.5, kWasmI32, 5);
TestU64AsNumber(kWasmF32, 2.5, kWasmF64, 3.5, kWasmF32, 5);
TestU64AsNumber(kWasmI32, 2, kWasmF64, 3.5, kWasmF32, 5);
TestU64AsNumber(kWasmF32, 2.5, kWasmI32, 3, kWasmF64, 5);

assertThrows(
    () => TestU64AsNumber(kWasmF64, 2 ** 66, kWasmI32, 0, kWasmF64), Error,
    `First number is out of int64_t range.`);
assertThrows(
    () => TestU64AsNumber(kWasmF32, 2 ** 66, kWasmI32, 0, kWasmF64), Error,
    `First number is out of int64_t range.`);

function TestU64AsBigInt(type1, v1, type2, v2, typeE, expected, errorMessage) {
  const fast_c_api = new d8.test.FastCAPI();
  const boundImport =
      Function.prototype.call.bind(fast_c_api.sum_uint64_as_bigint);

  const builder = new WasmModuleBuilder();
  const sig = makeSig(
      [kWasmExternRef, type1, type2],
      [typeE],
  );
  const imp_index = builder.addImport('mod', 'foo', sig);
  builder.addFunction('main', sig)
      .addBody([
        kExprLocalGet, 0, // receiver
        kExprLocalGet, 1, // param
        kExprLocalGet, 2, // param
        kExprCallFunction, imp_index
      ])
      .exportFunc();

  const instance = builder.instantiate({'mod': {'foo': boundImport}});

  fast_c_api.reset_counts();

  if (typeof expected === "bigint") {
    assertEquals(expected, instance.exports.main(fast_c_api, v1, v2));
    assertEquals(0, fast_c_api.slow_call_count());
    assertEquals(1, fast_c_api.fast_call_count());
  } else {
    assertThrows(
        () => instance.exports.main(fast_c_api, v1, v2), Error, expected);
  }
}

TestU64AsBigInt(kWasmI64, 2n, kWasmI64, 3n, kWasmI64, 5n);
TestU64AsBigInt(kWasmI64, 2n, kWasmI64, 3n, kWasmF64, "Cannot convert a BigInt value to a number");
TestU64AsBigInt(kWasmF32, 2.5, kWasmI64, 3n, kWasmI64,"Did not get a BigInt as first parameter.");
TestU64AsBigInt(kWasmI64, 2n, kWasmI64, 3n, kWasmI32, "Cannot convert a BigInt value to a number");

TestU64AsBigInt(kWasmF64, 2.5, kWasmF32, 3.5, kWasmI32, "Did not get a BigInt as first parameter.");
TestU64AsBigInt(kWasmF32, 2.5, kWasmF64, 3.5, kWasmF32, "Did not get a BigInt as first parameter.");
TestU64AsBigInt(kWasmI32, 2, kWasmF64, 3.5, kWasmF32, "Did not get a BigInt as first parameter.");
TestU64AsBigInt(kWasmF32, 2.5, kWasmI32, 3, kWasmF64, "Did not get a BigInt as first parameter.");
                                                       node-23.7.0/deps/v8/test/mjsunit/wasm/fast-api-calls-with-wellknown-imports-tagged.js               0000664 0000000 0000000 00000002340 14746647661 0030534 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --turbo-fast-api-calls --expose-fast-api --no-liftoff --wasm-fast-api
// Flags: --turboshaft-wasm --wasm-lazy-compilation

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function TestTaggedParam() {
  const fast_c_api = new d8.test.FastCAPI();
  const boundImport =
      Function.prototype.call.bind(fast_c_api.is_fast_c_api_object);

  const builder = new WasmModuleBuilder();
  const sig = makeSig(
      [kWasmExternRef, kWasmExternRef],
      [kWasmI32],
  );
  const imp_index = builder.addImport('mod', 'foo', sig);
  builder.addFunction('main', sig)
      .addBody([
        kExprLocalGet, 0, // receiver
        kExprLocalGet, 1, // param
        kExprCallFunction, imp_index
      ])
      .exportFunc();

  const instance = builder.instantiate({'mod': {'foo': boundImport}});

  fast_c_api.reset_counts();
  assertEquals(1, instance.exports.main(fast_c_api, fast_c_api));
  assertEquals(0, instance.exports.main(fast_c_api, {}));
  assertEquals(0, instance.exports.main(fast_c_api, 16));
  assertEquals(3, fast_c_api.fast_call_count());
})();
                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/wasm/ffi-error.js                                                  0000664 0000000 0000000 00000015367 14746647661 0021731 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

function CreateDefaultBuilder() {
  const builder = new WasmModuleBuilder();

  const sig_index = kSig_i_dd;
  builder.addImport('mod', 'fun', sig_index);
  builder.addFunction('main', sig_index)
      .addBody([
        kExprLocalGet, 0,      // --
        kExprLocalGet, 1,      // --
        kExprCallFunction, 0,  // --
      ])                       // --
      .exportFunc();
  return builder;
}

function checkSuccessfulInstantiation(builder, ffi, handler) {
  // Test synchronous instantiation.
  const instance = builder.instantiate(ffi);
  if (handler) handler(instance);

  // Test asynchronous instantiation.
  assertPromiseResult(builder.asyncInstantiate(ffi), handler);
}

function checkFailingInstantiation(
    builder, ffi, error, message, prepend_context = true) {
  // Test synchronous instantiation.
  assertThrows(
      _ => builder.instantiate(ffi), error,
      (prepend_context ? 'WebAssembly.Instance(): ' : '') + message);

  // Test asynchronous instantiation.
  assertThrowsAsync(
      builder.asyncInstantiate(ffi), error,
      (prepend_context ? 'WebAssembly.instantiate(): ' : '') + message);
}

(function testValidFFI() {
  print(arguments.callee.name);
  let ffi = {'mod': {fun: print}};
  checkSuccessfulInstantiation(CreateDefaultBuilder(), ffi, undefined);
})();

(function testInvalidFFIs() {
  print(arguments.callee.name);
  checkFailingInstantiation(
      CreateDefaultBuilder(), 17, TypeError,
      'Argument 1 must be an object');
  checkFailingInstantiation(
      CreateDefaultBuilder(), {}, TypeError,
      'Import #0 "mod": module is not an object or function');
  checkFailingInstantiation(
      CreateDefaultBuilder(), {mod: {}}, WebAssembly.LinkError,
      'Import #0 "mod" "fun": function import requires a callable');
  checkFailingInstantiation(
      CreateDefaultBuilder(), {mod: {fun: {}}}, WebAssembly.LinkError,
      'Import #0 "mod" "fun": function import requires a callable');
  checkFailingInstantiation(
      CreateDefaultBuilder(), {mod: {fun: 0}}, WebAssembly.LinkError,
      'Import #0 "mod" "fun": function import requires a callable');
})();

(function testImportWithInvalidSignature() {
  print(arguments.callee.name);
  // "fun" should have signature "i_dd"
  let builder = new WasmModuleBuilder();

  let sig_index = kSig_i_dd;
  builder.addFunction('exp', kSig_i_i)
      .addBody([
        kExprLocalGet,
        0,
      ])  // --
      .exportFunc();

  let exported = builder.instantiate().exports.exp;
  checkFailingInstantiation(
      CreateDefaultBuilder(), {mod: {fun: exported}}, WebAssembly.LinkError,
      'Import #0 "mod" "fun": imported function does not match ' +
          'the expected type');
})();

(function regression870646() {
  print(arguments.callee.name);
  const ffi = {mod: {fun: function() {}}};
  Object.defineProperty(ffi, 'mod', {
    get: function() {
      throw new Error('my_exception');
    }
  });

  checkFailingInstantiation(
      CreateDefaultBuilder(), ffi, Error, 'my_exception', false);
})();

// "fun" matches signature "i_dd"
(function testImportWithValidSignature() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  builder.addFunction('exp', kSig_i_dd)
      .addBody([
        kExprI32Const,
        33,
      ])  // --
      .exportFunc();

  let exported = builder.instantiate().exports.exp;

  checkSuccessfulInstantiation(
      CreateDefaultBuilder(), {mod: {fun: exported}},
      instance => assertEquals(33, instance.exports.main()));
})();

(function I64InSignature() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  builder.addMemory(1, 1);
  builder.addFunction('function_with_invalid_signature', kSig_l_ll)
    .addBody([           // --
      kExprLocalGet, 0,  // --
      kExprLocalGet, 1,  // --
      kExprI64Sub])      // --
    .exportFunc()

  checkSuccessfulInstantiation(
      builder, undefined,
      instance => assertEquals(
        instance.exports.function_with_invalid_signature(33n, 88n), -55n));
})();

(function I64ParamsInSignature() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  builder.addMemory(1, 1);
  builder.addFunction('function_with_invalid_signature', kSig_i_l)
      .addBody([kExprLocalGet, 0, kExprI32ConvertI64])
      .exportFunc();

  checkSuccessfulInstantiation(
      builder, undefined,
      instance => assertEquals(12,
          instance.exports.function_with_invalid_signature(12n)));

})();

(function I64JSImport() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_i_i);
  let sig_i64_index = builder.addType(kSig_i_l);
  let index = builder.addImport('', 'func', sig_i64_index);
  builder.addFunction('main', sig_index)
      .addBody([
        kExprLocalGet, 0, kExprI64SConvertI32, kExprCallFunction, index  // --
      ])                                                                 // --
      .exportFunc();

  checkSuccessfulInstantiation(
      builder, {'': {func: _ => {}}},
      instance => assertEquals(0, instance.exports.main(1)));

})();

(function ImportI64ParamWithF64Return() {
  print(arguments.callee.name);
  // This tests that we generate correct code by using the correct return
  // register. See bug 6096.
  let builder = new WasmModuleBuilder();
  builder.addImport('', 'f', makeSig([kWasmI64], [kWasmF64]));
  builder.addFunction('main', kSig_v_v)
      .addBody([kExprI64Const, 0, kExprCallFunction, 0, kExprDrop])
      .exportFunc();

  checkSuccessfulInstantiation(
      builder, {'': {f: i => Number(i)}},
      instance => assertDoesNotThrow(instance.exports.main));
})();

(function ImportI64Return() {
  print(arguments.callee.name);
  // This tests that we generate correct code by using the correct return
  // register(s). See bug 6104.
  let builder = new WasmModuleBuilder();
  builder.addImport('', 'f', makeSig([], [kWasmI64]));
  builder.addFunction('main', kSig_v_v)
      .addBody([kExprCallFunction, 0, kExprDrop])
      .exportFunc();

  checkSuccessfulInstantiation(
      builder, {'': {f: _ => 1n}},
      instance => assertDoesNotThrow(instance.exports.main));
})();

(function ImportSymbolToNumberThrows() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let index = builder.addImport('', 'f', kSig_i_v);
  builder.addFunction('main', kSig_i_v)
      .addBody([kExprCallFunction, 0])
      .exportFunc();

  checkSuccessfulInstantiation(
      builder, {'': {f: _ => Symbol()}},
      instance => assertThrows(
          instance.exports.main, TypeError,
          'Cannot convert a Symbol value to a number'));
})();
                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/wasm/ffi.js                                                        0000664 0000000 0000000 00000026337 14746647661 0020601 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --allow-natives-syntax

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function testCallFFI(func, check) {
  var builder = new WasmModuleBuilder();

  var sig_index = builder.addType(kSig_i_dd);
  builder.addImport("", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,            // --
      kExprLocalGet, 1,            // --
      kExprCallFunction, 0  // --
    ])        // --
    .exportFunc();

  var main = builder.instantiate({"": {func: func}}).exports.main;

  for (var i = 0; i < 100000; i += 10003) {
    var a = 22.5 + i, b = 10.5 + i;
    var r = main(a, b);
    if (check) {
      check(r, a, b);
    }
  }
}

var global = (function() { return this; })();
var params = [-99, -99, -99, -99, -99];
var was_called = false;
var length = -1;

function FOREIGN_SUB(a, b) {
//  print("FOREIGN_SUB(" + a + ", " + b + ")");
  was_called = true;
  params[0] = this;
  params[1] = a;
  params[2] = b;
  return (a - b) | 0;
}

function check_FOREIGN_SUB(r, a, b) {
    assertEquals(a - b | 0, r);
    assertTrue(was_called);
//    assertEquals(global, params[0]);  // sloppy mode
    assertEquals(a, params[1]);
    assertEquals(b, params[2]);
    was_called = false;
}

// Test calling a normal JSFunction.
print("JSFunction");
testCallFFI(FOREIGN_SUB, check_FOREIGN_SUB);

// Test calling a proxy.
print("Proxy");
var proxy_sub = new Proxy(FOREIGN_SUB, {});
testCallFFI(proxy_sub, check_FOREIGN_SUB);

// Test calling a bind function.
print("Bind function");
var bind_sub = FOREIGN_SUB.bind();
testCallFFI(bind_sub, check_FOREIGN_SUB);

(function testCallConstructor() {
  print(arguments.callee.name);
  class C {}
  var builder = new WasmModuleBuilder();

  var sig_index = builder.addType(kSig_i_dd);
  builder.addImport("", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,            // --
      kExprLocalGet, 1,            // --
      kExprCallFunction, 0  // --
    ])        // --
    .exportFunc();

  let main_for_constructor_test = builder.instantiate({"": {func: C}}).exports.main;

  assertThrows(_ => main_for_constructor_test(12, 43), TypeError);
}) ();

(function testCallConstructorWithSuperClass() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_v_v);
  let func_index = builder.addImport('', 'func', sig_index);
  builder.addExport('exp', func_index);

  class B {}
  class C extends B {
    constructor() {
      super();
    }
  };
  let exports = builder.instantiate({'': {func: C}}).exports;
  assertThrows(_ => exports.exp(), TypeError);
})();

(function test_ffi_call_to_native() {
  print(arguments.callee.name);

  var builder = new WasmModuleBuilder();

  var sig_index = builder.addType(kSig_d_v);
  builder.addImport("", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprCallFunction, 0  // --
    ])        // --
    .exportFunc();

  var main = builder.instantiate({"": {func: Object.prototype.toString}}).exports.main;
  // The result of the call to Object.prototype.toString should be
  // [object Undefined]. However, we cannot test for this result because wasm
  // cannot return objects but converts them to float64 in this test.
  assertEquals(NaN, main());
})();

print("Callable JSObject");
function callable_target(a, b) { return a - b; }
let callable_obj = %GetCallable("callable_target");
testCallFFI(callable_obj, function check(r, a, b) {assertEquals(a - b, r);});

function FOREIGN_ABCD(a, b, c, d) {
//  print("FOREIGN_ABCD(" + a + ", " + b + ", " + c + ", " + d + ")");
  was_called = true;
  params[0] = this;
  params[1] = a;
  params[2] = b;
  params[3] = c;
  params[4] = d;
  return (a * b * 6) | 0;
}

function check_FOREIGN_ABCD(r, a, b) {
    assertEquals((a * b * 6) | 0, r);
    assertTrue(was_called);
//    assertEquals(global, params[0]);  // sloppy mode.
    assertEquals(a, params[1]);
    assertEquals(b, params[2]);
    assertEquals(undefined, params[3]);
    assertEquals(undefined, params[4]);
    was_called = false;
}

testCallFFI(FOREIGN_ABCD, check_FOREIGN_ABCD);

function FOREIGN_ARGUMENTS0() {
  print("FOREIGN_ARGUMENTS0");
  was_called = true;
  length = arguments.length;
  for (var i = 0; i < arguments.length; i++) {
    params[i] = arguments[i];
  }
  return (arguments[0] * arguments[1] * 7) | 0;
}

function FOREIGN_ARGUMENTS1(a) {
  print("FOREIGN_ARGUMENTS1", a);
  was_called = true;
  length = arguments.length;
  for (var i = 0; i < arguments.length; i++) {
    params[i] = arguments[i];
  }
  return (arguments[0] * arguments[1] * 7) | 0;
}

function FOREIGN_ARGUMENTS2(a, b) {
  print("FOREIGN_ARGUMENTS2", a, b);
  was_called = true;
  length = arguments.length;
  for (var i = 0; i < arguments.length; i++) {
    params[i] = arguments[i];
  }
  return (a * b * 7) | 0;
}

function FOREIGN_ARGUMENTS3(a, b, c) {
  print("FOREIGN_ARGUMENTS3", a, b, c);
  was_called = true;
  length = arguments.length;
  for (var i = 0; i < arguments.length; i++) {
    params[i] = arguments[i];
  }
  return (a * b * 7) | 0;
}

function FOREIGN_ARGUMENTS4(a, b, c, d) {
  print("FOREIGN_ARGUMENTS4", a, b, c, d);
  was_called = true;
  length = arguments.length;
  for (var i = 0; i < arguments.length; i++) {
    params[i] = arguments[i];
  }
  return (a * b * 7) | 0;
}

function check_FOREIGN_ARGUMENTS(r, a, b) {
  assertEquals((a * b * 7) | 0, r);
  assertTrue(was_called);
  assertEquals(2, length);
  assertEquals(a, params[0]);
  assertEquals(b, params[1]);
  was_called = false;
}

// Check a bunch of uses of the arguments object.
testCallFFI(FOREIGN_ARGUMENTS0, check_FOREIGN_ARGUMENTS);
testCallFFI(FOREIGN_ARGUMENTS1, check_FOREIGN_ARGUMENTS);
testCallFFI(FOREIGN_ARGUMENTS2, check_FOREIGN_ARGUMENTS);
testCallFFI(FOREIGN_ARGUMENTS3, check_FOREIGN_ARGUMENTS);
testCallFFI(FOREIGN_ARGUMENTS4, check_FOREIGN_ARGUMENTS);

function returnValue(val) {
  return function(a, b) {
    print("RETURN_VALUE ", val);
    return val;
  }
}


function checkReturn(expected) {
  return function(r, a, b) { assertEquals(expected, r); }
}

// Check that returning weird values doesn't crash
testCallFFI(returnValue(undefined), checkReturn(0));
testCallFFI(returnValue(null), checkReturn(0));
testCallFFI(returnValue("0"), checkReturn(0));
testCallFFI(returnValue("-77"), checkReturn(-77));

var objWithValueOf = {valueOf: function() { return 198; }}

testCallFFI(returnValue(objWithValueOf), checkReturn(198));

function testCallBinopVoid(type, func, check) {
  var passed_length = -1;
  var passed_a = -1;
  var passed_b = -1;
  var args_a = -1;
  var args_b = -1;

  ffi = {"": {func: function(a, b) {
    passed_length = arguments.length;
    passed_a = a;
    passed_b = b;
    args_a = arguments[0];
    args_b = arguments[1];
  }}};

  var builder = new WasmModuleBuilder();

  builder.addImport("", "func", makeSig_v_xx(type));
  builder.addFunction("main", makeSig_r_xx(kWasmI32, type))
    .addBody([
      kExprLocalGet, 0,            // --
      kExprLocalGet, 1,            // --
      kExprCallFunction, 0,        // --
      kExprI32Const, 33            // --
    ])                             // --
    .exportFunc()

  var main = builder.instantiate(ffi).exports.main;

  print("testCallBinopVoid", type);

  for (var i = 0; i < 100000; i += 10003.1) {
    var a = 22.5 + i, b = 10.5 + i;
    var r = main(a, b);
    assertEquals(33, r);
    assertEquals(2, passed_length);
    var expected_a, expected_b;
    switch (type) {
      case kWasmI32: {
        expected_a = a | 0;
        expected_b = b | 0;
        break;
      }
      case kWasmF32: {
        expected_a = Math.fround(a);
        expected_b = Math.fround(b);
        break;
      }
      case kWasmF64: {
        expected_a = a;
        expected_b = b;
        break;
      }
    }

    assertEquals(expected_a, args_a);
    assertEquals(expected_b, args_b);
    assertEquals(expected_a, passed_a);
    assertEquals(expected_b, passed_b);
  }
}


testCallBinopVoid(kWasmI32);
// TODO testCallBinopVoid(kWasmI64);
testCallBinopVoid(kWasmF32);
testCallBinopVoid(kWasmF64);

(function testCallPrint() {
  var builder = new WasmModuleBuilder();

  builder.addImport("", "print", makeSig_v_x(kWasmI32));
  builder.addImport("", "print", makeSig_v_x(kWasmF64));
  builder.addFunction("main", makeSig_v_x(kWasmF64))
    .addBody([
      kExprI32Const, 37,     // --
      kExprCallFunction, 0,  // --
      kExprLocalGet, 0,      // --
      kExprCallFunction, 1   // --
    ])                       // --
    .exportFunc()

  var main = builder.instantiate({"": {print: print}}).exports.main;
  for (var i = -9; i < 900; i += 6.125) main(i);
})();


(function testImportNumbers() {
  print("TestImportNumbers...");
  var builder = new WasmModuleBuilder();

  builder.addImport("", '0', kSig_v_i);

  builder.instantiate({"": {0: print}});
})();

(function testImportNumbers2() {
  print("TestImportNumbers2...");
  var builder = new WasmModuleBuilder();

  builder.addImport('foo', '0', kSig_v_i);
  builder.addImport('0', 'foo', kSig_v_i);
  builder.addImport('0', '0', kSig_v_i);
  builder.addImport('18', '-3', kSig_v_i);
  builder.addImport('-3', '18', kSig_v_i);

  builder.instantiate({
    foo: {0: print},
    0: {0: print, foo: print},
    18: {'-3': print},
    '-3': {18: print}
  });
})();

(function ImportSymbolAsVoidDoesNotThrow() {
  print("ImportSymbolAsVoidDoesNotThrow...");
  var builder = new WasmModuleBuilder();
  // Return type is void, so there should be no ToNumber conversion.
  var index = builder.addImport("", "func", kSig_v_v);
  builder.addFunction("main", kSig_v_v)
      .addBody([kExprCallFunction, 0])
      .exportFunc();
  var func = () => Symbol();
  var main = builder.instantiate({"": {func: func}}).exports.main;
  main();
})();

(function ToNumberCalledOnImport() {
  var builder = new WasmModuleBuilder();
  // Return type is int, so there should be a ToNumber conversion.
  var index = builder.addImport("", "func", kSig_i_v);
  builder.addFunction("main", kSig_i_v)
      .addBody([kExprCallFunction, 0])
      .exportFunc();
  var num_valueOf = 0;
  function Foo() {}
  Foo.prototype.valueOf = () => ++num_valueOf;
  var func = () => new Foo();
  var main = builder.instantiate({"": {func: func}}).exports.main;
  main();
  assertEquals(1, num_valueOf);
  main();
  assertEquals(2, num_valueOf);
})();

(function ToNumberNotCalledOnVoidImport() {
  var builder = new WasmModuleBuilder();
  // Return type is void, so there should be no ToNumber conversion.
  var index = builder.addImport("", "func", kSig_v_v);
  builder.addFunction("main", kSig_v_v)
      .addBody([kExprCallFunction, 0])
      .exportFunc();
  var num_valueOf = 0;
  function Foo() {}
  Foo.prototype.valueOf = () => ++num_valueOf;
  var func = () => new Foo();
  var main = builder.instantiate({"": {func: func}}).exports.main;
  main();
  main();
  assertEquals(0, num_valueOf);
})();

(function ImportWithCustomGetter() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.addImport("import", "func", kSig_v_v);

  const ffi = {};
  Object.defineProperty(ffi, 'import', {
    get: _ => {
      return {func: () => null };
    }
  });

  builder.instantiate(ffi);
})();
                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/wasm/float-constant-folding.js                                     0000664 0000000 0000000 00000023033 14746647661 0024377 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function() {
  print("F32: sNaN - 0 = qNaN");
  var builder = new WasmModuleBuilder();
  builder.addFunction("F32Sub0", kSig_i_i).addBody(
      [ kExprLocalGet, 0, kExprF32ReinterpretI32, kExprF32Const, 0x00, 0x00,
          0x00, 0x00, // 0.0
          kExprF32Sub, kExprI32ReinterpretF32, ]).exportFunc();
  var module = builder.instantiate();
  // F32Sub0(signalling_NaN)
  assertEquals(0x7fe00000, module.exports.F32Sub0(0x7fa00000));
})();

(function() {
  print("F32: -0 sNaN = qNaN");
  var builder = new WasmModuleBuilder();
  builder.addFunction("F32Sub0", kSig_i_i).addBody(
      [ kExprF32Const, 0x00, 0x00, 0x00, 0x80, // 0.0
      kExprLocalGet, 0, kExprF32ReinterpretI32, kExprF32Sub,
          kExprI32ReinterpretF32, ]).exportFunc();
  var module = builder.instantiate();
  // F32Sub0(signalling_NaN)
  assertEquals(0x7fe00000, module.exports.F32Sub0(0x7fa00000));
})();

(function() {
  print("F32: sNaN - X = qNaN");
  var builder = new WasmModuleBuilder();
  builder.addFunction("F32NaNSubX", kSig_i_i).addBody(
      [ kExprF32Const, 0x00, 0x00, 0xa0, 0x7f, kExprF32Const, 0x12, 0x34, 0x56,
          0x78, kExprF32Sub, kExprI32ReinterpretF32, ]).exportFunc();
  var module = builder.instantiate();
  assertEquals(0x7fe00000, module.exports.F32NaNSubX());
})();

(function() {
  print("F32: X - sNaN = qNaN");
  var builder = new WasmModuleBuilder();
  builder.addFunction("F32XSubNaN", kSig_i_i).addBody(
      [ kExprF32Const, 0x12, 0x34, 0x56, 0x78, kExprF32Const, 0x00, 0x00, 0xa0,
          0x7f, kExprF32Sub, kExprI32ReinterpretF32, ]).exportFunc();
  var module = builder.instantiate();
  assertEquals(0x7fe00000, module.exports.F32XSubNaN());
})();

(function() {
  print("F64: X + sNaN = qNaN");
  var builder = new WasmModuleBuilder();
  builder.addFunction("F32XAddNaN", kSig_i_i).addBody(
      [ kExprF64Const, 0xde, 0xbc, 0x0a, 0x89, 0x67, 0x45, 0x23, 0x01,
          kExprF64Const, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf2, 0x7f,
          kExprF64Add, kExprI64ReinterpretF64, kExprI64Const, 32, kExprI64ShrU,
          kExprI32ConvertI64, ]).exportFunc();
  var module = builder.instantiate();
  assertEquals(0x7ffa0000, module.exports.F32XAddNaN());
})();

(function() {
  print("F64: sNaN - 0 = qNaN");
  var builder = new WasmModuleBuilder();
  builder.addFunction("F64Sub0", kSig_i_i).addBody(
      [ kExprI64Const, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xf9, 0xff,
          0x00, kExprF64ReinterpretI64, kExprF64Const, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, // 0.0
          kExprF64Sub, kExprI64ReinterpretF64, kExprI64Const, 32, kExprI64ShrU,
          kExprI32ConvertI64, ]).exportFunc();
  var module = builder.instantiate();
  assertEquals(0x7ffa0000, module.exports.F64Sub0());
})();

(function() {
  print("F64: -0 - sNaN = qNaN");
  var builder = new WasmModuleBuilder();
  builder.addFunction("F64Sub0", kSig_i_i).addBody(
      [ kExprF64Const, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, // 0.0
      kExprI64Const, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xf9, 0xff,
          0x00, kExprF64ReinterpretI64, kExprF64Sub, kExprI64ReinterpretF64,
          kExprI64Const, 32, kExprI64ShrU, kExprI32ConvertI64, ]).exportFunc();
  var module = builder.instantiate();
  assertEquals(0x7ffa0000, module.exports.F64Sub0());
})();

(function() {
  print("F64: sNaN - X = qNaN");
  var builder = new WasmModuleBuilder();
  builder.addFunction("F64NaNSubX", kSig_i_i).addBody(
      [ kExprF64Const, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf2, 0x7f,
          kExprF64Const, 0xde, 0xbc, 0x0a, 0x89, 0x67, 0x45, 0x23, 0x01,
          kExprF64Sub, kExprI64ReinterpretF64, kExprI64Const, 32, kExprI64ShrU,
          kExprI32ConvertI64, ]).exportFunc();
  var module = builder.instantiate();
  assertEquals(0x7ffa0000, module.exports.F64NaNSubX());
})();

(function() {
  print("F64: X - sNaN = qNaN");
  var builder = new WasmModuleBuilder();
  builder.addFunction("F64XSubNaN", kSig_i_i).addBody(
      [ kExprF64Const, 0xde, 0xbc, 0x0a, 0x89, 0x67, 0x45, 0x23, 0x01,
          kExprF64Const, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf2, 0x7f,
          kExprF64Sub, kExprI64ReinterpretF64, kExprI64Const, 32, kExprI64ShrU,
          kExprI32ConvertI64, ]).exportFunc();
  var module = builder.instantiate();
  assertEquals(0x7ffa0000, module.exports.F64XSubNaN());
})();

(function() {
  print("F64: sNaN * 1 = qNaN");
  var builder = new WasmModuleBuilder();
  builder.addFunction("F64Mul1", kSig_i_i).addBody(
      [ kExprI64Const, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xf9, 0xff,
          0x00, kExprF64ReinterpretI64, kExprF64Const, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0xf0, 0x3f, kExprF64Mul, kExprI64ReinterpretF64,
          kExprI64Const, 32, kExprI64ShrU, kExprI32ConvertI64, ]).exportFunc();
  var module = builder.instantiate();
  assertEquals(0x7ffa0000, module.exports.F64Mul1());
})();

(function() {
  print("F64: X * sNaN = qNaN");
  var builder = new WasmModuleBuilder();
  builder.addFunction("F64XMulNaN", kSig_i_i).addBody(
      [ kExprF64Const, 0xde, 0xbc, 0x0a, 0x89, 0x67, 0x45, 0x23, 0x01,
          kExprF64Const, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf2, 0x7f,
          kExprF64Mul, kExprI64ReinterpretF64, kExprI64Const, 32, kExprI64ShrU,
          kExprI32ConvertI64, ]).exportFunc();
  var module = builder.instantiate();
  assertEquals(0x7ffa0000, module.exports.F64XMulNaN());
})();

(function() {
  print("F64: sNaN / 1 = qNaN");
  var builder = new WasmModuleBuilder();
  builder.addFunction("F64Div1", kSig_i_i).addBody(
      [ kExprI64Const, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xf9, 0xff,
          0x00, kExprF64ReinterpretI64, kExprF64Const, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0xf0, 0x3f, kExprF64Div, kExprI64ReinterpretF64,
          kExprI64Const, 32, kExprI64ShrU, kExprI32ConvertI64, ]).exportFunc();
  var module = builder.instantiate();
  assertEquals(0x7ffa0000, module.exports.F64Div1());
})();

(function() {
  print("F64: sNaN / -1 = qNaN");
  var builder = new WasmModuleBuilder();
  builder.addFunction("F64Div1", kSig_i_i).addBody(
      [ kExprI64Const, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xf9, 0xff,
          0x00, kExprF64ReinterpretI64, kExprF64Const, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0xf0, 0xbf, kExprF64Div, kExprI64ReinterpretF64,
          kExprI64Const, 32, kExprI64ShrU, kExprI32ConvertI64, ]).exportFunc();
  var module = builder.instantiate();
  assertEquals(0x7ffa0000, module.exports.F64Div1());
})();

(function() {
  print("F64: sNaN / -1 = qNaN");
  var builder = new WasmModuleBuilder();
  builder.addFunction("F64Div1", kSig_i_i)
    .addBody([
      kExprI64Const, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xf9, 0xff, 0x00,
      kExprF64ReinterpretI64,
      kExprF64Const, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xbf,
      kExprF64Div,
      kExprI64ReinterpretF64,
      kExprI64Const, 32,
      kExprI64ShrU,
      kExprI32ConvertI64,
            ])
            .exportFunc();
  var module = builder.instantiate();
  assertEquals(0x7ffa0000, module.exports.F64Div1());
})();

(function() {
  print("F64: X / sNaN = qNaN");
  var builder = new WasmModuleBuilder();
  builder.addFunction("F64XDivNaN", kSig_i_i).addBody(
      [ kExprF64Const, 0xde, 0xbc, 0x0a, 0x89, 0x67, 0x45, 0x23, 0x01,
          kExprF64Const, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf2, 0x7f,
          kExprF64Div, kExprI64ReinterpretF64, kExprI64Const, 32, kExprI64ShrU,
          kExprI32ConvertI64, ]).exportFunc();
  var module = builder.instantiate();
  assertEquals(0x7ffa0000, module.exports.F64XDivNaN());
})();

(function() {
  print("F64: sNaN / X = qNaN");
  var builder = new WasmModuleBuilder();
  builder.addFunction("F64NaNDivX", kSig_i_i).addBody(
      [ kExprF64Const, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf2, 0x7f,
          kExprF64Const, 0xde, 0xbc, 0x0a, 0x89, 0x67, 0x45, 0x23, 0x01,
          kExprF64Div, kExprI64ReinterpretF64, kExprI64Const, 32, kExprI64ShrU,
          kExprI32ConvertI64, ]).exportFunc();
  var module = builder.instantiate();
  assertEquals(0x7ffa0000, module.exports.F64NaNDivX());
})();

(function() {
  print("F32ConvertF64(sNaN) = qNaN");
  var builder = new WasmModuleBuilder();
  builder.addFunction("F32ConvertF64X", kSig_i_i).addBody(
      [ kExprF64Const, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf2, 0x7f,
          kExprF32ConvertF64, kExprI32ReinterpretF32, ]).exportFunc();
  var module = builder.instantiate();
  assertEquals(0x7fd00000, module.exports.F32ConvertF64X());
})();

(function() {
  print("F64ConvertF32(sNaN) = qNaN");
  var builder = new WasmModuleBuilder();
  builder.addFunction("F64ConvertF32X", kSig_i_i).addBody(
      [ kExprF32Const, 0x00, 0x00, 0xa0, 0x7f, kExprF64ConvertF32,
          kExprI64ReinterpretF64, kExprI64Const, 32, kExprI64ShrU,
          kExprI32ConvertI64, ]).exportFunc();
  var module = builder.instantiate();
  assertEquals(0x7ffc0000, module.exports.F64ConvertF32X());
})();

(function() {
  print("F64ConvertF32(F32ConvertF64(sNaN)) = qNaN");
  var builder = new WasmModuleBuilder();
  builder.addFunction("F64toF32toF64", kSig_i_i).addBody(
      [ kExprI64Const, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xf9, 0xff,
          0x00, kExprF64ReinterpretI64, kExprF32ConvertF64, kExprF64ConvertF32,
          kExprI64ReinterpretF64, kExprI64Const, 32, kExprI64ShrU,
          kExprI32ConvertI64, ]).exportFunc();
  var module = builder.instantiate();
  assertEquals(0x7ffa0000, module.exports.F64toF32toF64());
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/wasm/function-names.js                                             0000664 0000000 0000000 00000004167 14746647661 0022760 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

var builder = new WasmModuleBuilder();

var last_func_index = builder.addFunction("exec_unreachable", kSig_v_v)
  .addBody([kExprUnreachable]).index

var illegal_func_name = [0xff];
var func_names = [ "☠", illegal_func_name, "some math: (½)² = ¼", "" ];
var expected_names = ["exec_unreachable", "☠", null,
                      "some math: (½)² = ¼", "", "main"];

for (var func_name of func_names) {
  last_func_index = builder.addFunction(func_name, kSig_v_v)
    .addBody([kExprCallFunction, last_func_index]).index;
}

builder.addFunction("main", kSig_v_v)
  .addBody([kExprCallFunction, last_func_index])
  .exportFunc();

var module = builder.instantiate();

(function testFunctionNamesAsString() {
  var names = expected_names.concat(["testFunctionNamesAsString", null]);
  try {
    module.exports.main();
    assertFalse("should throw");
  } catch (e) {
    var lines = e.stack.split(/\r?\n/);
    lines.shift();
    assertEquals(names.length, lines.length);
    for (var i = 0; i < names.length; ++i) {
      var line = lines[i].trim();
      if (names[i] === null) continue;
      var printed_name = names[i];
      var expected_start = "at " + printed_name + " (";
      assertTrue(line.startsWith(expected_start),
          "should start with '" + expected_start + "': '" + line + "'");
    }
  }
})();

// For the remaining tests, collect the Callsite objects instead of just a
// string:
Error.prepareStackTrace = function(error, frames) {
  return frames;
};

(function testFunctionNamesAsCallSites() {
  var names = expected_names.concat(['testFunctionNamesAsCallSites', null]);
  try {
    module.exports.main();
    assertFalse('should throw');
  } catch (e) {
    assertEquals(names.length, e.stack.length, 'stack length');
    for (var i = 0; i < names.length; ++i) {
      assertEquals(
          names[i], e.stack[i].getFunctionName(), 'function name at ' + i);
    }
  }
})();
                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/wasm/function-prototype.js                                         0000664 0000000 0000000 00000002062 14746647661 0023712 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestFunctionPrototype() {
  var builder = new WasmModuleBuilder();

  var f = builder.addFunction("nine", kSig_i_v)
    .addBody([kExprI32Const, 9])
    .exportFunc();

  var func = builder.instantiate().exports.nine;

  // Check type and existence of prototype
  assertEquals('function', typeof func);
  assertEquals('function', typeof func.apply);
  assertEquals('prototype' in func, false);
  assertEquals(String(f.index), func.name);
  assertEquals(undefined, func.displayName);

  // Check that .apply() works.
  assertEquals(9, func.apply([]));
  assertEquals(9, func.apply([1]));
  assertEquals(9, func.apply([2, 3]));
  assertEquals(9, func.apply([6, 7, 9, 9]));

  // TODO(titzer): assertEquals(1, func.length);

  // Check we don't crash when converting to a string.
  print(func.toString());
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/wasm/futex.js                                                      0000664 0000000 0000000 00000031563 14746647661 0021165 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

'use strict';

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function WasmAtomicNotify(memory, offset, index, num) {
  let builder = new WasmModuleBuilder();
  builder.addImportedMemory("m", "memory", 0, 20, "shared");
  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kAtomicPrefix,
      kExprAtomicNotify, /* alignment */ 2, offset])
    .exportAs("main");

  // Instantiate module, get function exports
  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module, {m: {memory}});
  return instance.exports.main(index, num);
}

function WasmI32AtomicWait(memory, offset, index, val, timeout) {
  let builder = new WasmModuleBuilder();
  builder.addImportedMemory("m", "memory", 0, 20, "shared");
  builder.addFunction("main",
    makeSig([kWasmI32, kWasmI32, kWasmF64], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprI64SConvertF64,
      kAtomicPrefix,
      kExprI32AtomicWait, /* alignment */ 2, offset])
      .exportAs("main");

  // Instantiate module, get function exports
  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module, {m: {memory}});
  return instance.exports.main(index, val, timeout);
}

function WasmI64AtomicWait(memory, offset, index, val_low,
                                   val_high, timeout) {
  let builder = new WasmModuleBuilder();
  builder.addImportedMemory("m", "memory", 0, 20, "shared");
  // Wrapper for I64AtomicWait that takes two I32 values and combines to into
  // I64 for the instruction parameter.
  builder.addFunction("main",
    makeSig([kWasmI32, kWasmI32, kWasmI32, kWasmF64], [kWasmI32]))
    .addLocals(kWasmI64, 1) // local that is passed as value param to wait
    .addBody([
      kExprLocalGet, 1,
      kExprI64UConvertI32,
      kExprI64Const, 32,
      kExprI64Shl,
      kExprLocalGet, 2,
      kExprI64UConvertI32,
      kExprI64Ior,
      kExprLocalSet, 4, // Store the created I64 value in local
      kExprLocalGet, 0,
      kExprLocalGet, 4,
      kExprLocalGet, 3,
      kExprI64SConvertF64,
      kAtomicPrefix,
      kExprI64AtomicWait, /* alignment */ 3, offset])
      .exportAs("main");

  // Instantiate module, get function exports
  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module, {m: {memory}});
  return instance.exports.main(index, val_high, val_low, timeout);
}

(function TestInvalidIndex() {
  if (!%IsAtomicsWaitAllowed()) return;
  let memory = new WebAssembly.Memory({initial: 1, maximum: 1, shared: true});

  // Valid indexes are 0-65535 (1 page).
  [-2, 65536, 0xffffffff].forEach(function(invalidIndex) {
    assertThrows(function() {
      WasmAtomicNotify(memory, 0, invalidIndex, -1);
    }, Error);
    assertThrows(function() {
      WasmI32AtomicWait(memory, 0, invalidIndex, 0, -1);
    }, Error);
    assertThrows(function() {
      WasmI64AtomicWait(memory, 0, invalidIndex, 0, 0, -1);
    }, Error);
    assertThrows(function() {
      WasmAtomicNotify(memory, invalidIndex, 0, -1);
    }, Error);
    assertThrows(function() {
      WasmI32AtomicWait(memory, invalidIndex, 0, 0, -1);
    }, Error);
    assertThrows(function() {
      WasmI64AtomicWait(memory, invalidIndex, 0, 0, 0, -1);
    }, Error);
    assertThrows(function() {
      WasmAtomicNotify(memory, invalidIndex/2, invalidIndex/2, -1);
    }, Error);
    assertThrows(function() {
      WasmI32AtomicWait(memory, invalidIndex/2, invalidIndex/2, 0, -1);
    }, Error);
    assertThrows(function() {
      WasmI64AtomicWait(memory, invalidIndex/2, invalidIndex/2, 0, 0, -1);
    }, Error);
  });
})();

(function TestInvalidAlignment() {
  if (!%IsAtomicsWaitAllowed()) return;
  let memory = new WebAssembly.Memory({initial: 1, maximum: 1, shared: true});

  // Wait and wake must be 4 byte aligned.
  [1, 2, 3].forEach(function(invalid) {
    assertThrows(function() {
      WasmAtomicNotify(memory, invalid, 0, -1)
    }, Error);
    assertThrows(function() {
      WasmAtomicNotify(memory, 0, invalid, -1)
    }, Error);
    assertThrows(function() {
      WasmI32AtomicWait(memory, invalid, 0, 0, -1)
    }, Error);
    assertThrows(function() {
      WasmI32AtomicWait(memory, 0, invalid, 0, -1)
    }, Error);
    assertThrows(function() {
      WasmI64AtomicWait(memory, invalid, 0, 0, 0, -1)
    }, Error);
    assertThrows(function() {
      WasmI64AtomicWait(memory, 0, invalid, 0, 0, -1)
    }, Error);
  });

  //WasmI64AtomicWait must be 8 byte aligned.
  [4, 5, 6, 7].forEach(function(invalid) {
    assertThrows(function() {
      WasmI64AtomicWait(memory, 0, invalid, 0, 0, -1)
    }, Error);
    assertThrows(function() {
      WasmI64AtomicWait(memory, invalid, 0, 0, 0, -1)
    }, Error);
  });
})();

(function TestI32WaitTimeout() {
  if (!%IsAtomicsWaitAllowed()) return;
  let memory = new WebAssembly.Memory({initial: 1, maximum: 1, shared: true});
  var waitMs = 100;
  var startTime = new Date();
  assertEquals(
      kAtomicWaitTimedOut,
      WasmI32AtomicWait(memory, 0, 0, 0, waitMs * 1000000));
  var endTime = new Date();
  assertTrue(endTime - startTime >= waitMs);
})();

(function TestI64WaitTimeout() {
  if (!%IsAtomicsWaitAllowed()) return;
  let memory = new WebAssembly.Memory({initial: 1, maximum: 1, shared: true});
  var waitMs = 100;
  var startTime = new Date();
  assertEquals(
      kAtomicWaitTimedOut,
      WasmI64AtomicWait(memory, 0, 0, 0, 0, waitMs * 1000000));
  var endTime = new Date();
  assertTrue(endTime - startTime >= waitMs);
})();

(function TestI32WaitNotEqual() {
  if (!%IsAtomicsWaitAllowed()) return;
  let memory = new WebAssembly.Memory({initial: 1, maximum: 1, shared: true});
  assertEquals(kAtomicWaitNotEqual, WasmI32AtomicWait(memory, 0, 0, 42, -1));

  assertEquals(kAtomicWaitTimedOut, WasmI32AtomicWait(memory, 0, 0, 0, 0));

  let i32a = new Int32Array(memory.buffer);
  i32a[0] = 1;
  assertEquals(kAtomicWaitNotEqual, WasmI32AtomicWait(memory, 0, 0, 0, -1));
  assertEquals(kAtomicWaitTimedOut, WasmI32AtomicWait(memory, 0, 0, 1, 0));
})();

(function TestI64WaitNotEqual() {
  if (!%IsAtomicsWaitAllowed()) return;
  let memory = new WebAssembly.Memory({initial: 1, maximum: 1, shared: true});
  assertEquals(kAtomicWaitNotEqual, WasmI64AtomicWait(memory, 0, 0, 42, 0, -1));

  assertEquals(kAtomicWaitTimedOut, WasmI64AtomicWait(memory, 0, 0, 0, 0, 0));

  let i32a = new Int32Array(memory.buffer);
  i32a[0] = 1;
  i32a[1] = 2;
  assertEquals(kAtomicWaitNotEqual, WasmI64AtomicWait(memory, 0, 0, 0, 0, -1));
  assertEquals(kAtomicWaitTimedOut, WasmI64AtomicWait(memory, 0, 0, 1, 2, 0));
})();

(function TestWakeCounts() {
  let memory = new WebAssembly.Memory({initial: 1, maximum: 1, shared: true});

  [-1, 0, 4, 100, 0xffffffff].forEach(function(count) {
    WasmAtomicNotify(memory, 0, 0, count);
  });
})();

//// WORKER ONLY TESTS

if (this.Worker) {

  // This test creates 4 workers that wait on consecutive (8 byte separated to
  // satisfy alignments for all kinds of wait) memory locations to test various
  // wait/wake combinations. For each combination, each thread waits 3 times
  // expecting all 4 threads to be woken with wake(4) in first iteration, all 4
  // to be woken with wake(5) in second iteration and, 3 and 1 to be woken in
  // third iteration.

  let memory = new WebAssembly.Memory({initial: 1, maximum: 1, shared: true});
  let i32a = new Int32Array(memory.buffer);
  const numWorkers = 4;

  let workerScript = `onmessage = function({data:msg}) {
    d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
    ${WasmI32AtomicWait.toString()}
    ${WasmI64AtomicWait.toString()}
    let id = msg.id;
    let memory = msg.memory;
    let i32a = new Int32Array(memory.buffer);
    // indices are right shifted by 2 for Atomics.wait to convert them to index
    // for Int32Array
    // for wasm-wake numWorkers threads
    let result = Atomics.wait(i32a, 0>>>2, 0);
    postMessage(result);
    // for wasm-wake numWorkers + 1 threads
    result = Atomics.wait(i32a, 8>>>2, 0);
    postMessage(result);
    // for wasm-wake numWorkers - 1 threads
    result = Atomics.wait(i32a, 16>>>2, 0);
    postMessage(result);
    // for js-wake numWorkers threads
    result = WasmI32AtomicWait(memory, 0, 24, 0, -1);
    postMessage(result);
    // for js-wake numWorkers + 1 threads
    result = WasmI32AtomicWait(memory, 0, 32, 0, -1);
    postMessage(result);
    // for js-wake numWorkers - 1 threads
    result = WasmI32AtomicWait(memory, 0, 40, 0, -1);
    postMessage(result);
    // for wasm-wake numWorkers threads
    result = WasmI32AtomicWait(memory, 0, 48, 0, -1);
    postMessage(result);
    // for wasm-wake numWorkers + 1 threads
    result = WasmI32AtomicWait(memory, 0, 56, 0, -1);
    postMessage(result);
    // for wasm-wake numWorkers - 1 threads
    result = WasmI32AtomicWait(memory, 0, 64, 0, -1);
    postMessage(result);
    // for js-wake numWorkers threads
    result = WasmI64AtomicWait(memory, 0, 72, 0, 0, -1);
    postMessage(result);
    // for js-wake numWorkers + 1 threads
    result = WasmI64AtomicWait(memory, 0, 80, 0, 0, -1);
    postMessage(result);
    // for js-wake numWorkers - 1 threads
    result = WasmI64AtomicWait(memory, 0, 88, 0, 0, -1);
    postMessage(result);
    // for wasm-wake numWorkers threads
    result = WasmI64AtomicWait(memory, 0, 96, 0, 0, -1);
    postMessage(result);
    // for wasm-wake numWorkers + 1 threads
    result = WasmI64AtomicWait(memory, 0, 104, 0, 0, -1);
    postMessage(result);
    // for wasm-wake numWorkers - 1 threads
    result = WasmI64AtomicWait(memory, 0, 112, 0, 0, -1);
    postMessage(result);
  };`;

  let waitForAllWorkers = function(index) {
    // index is right shifted by 2 to convert to index in Int32Array
    while (%AtomicsNumWaitersForTesting(i32a, index>>>2) != numWorkers) {}
  }

  let jsWakeCheck = function(index, num, workers, msg) {
    waitForAllWorkers(index);
    let indexJs = index>>>2; // convert to index in Int32Array
    if (num >= numWorkers) {
      // if numWorkers or more is passed to wake, numWorkers workers should be
      // woken.
      assertEquals(numWorkers, Atomics.notify(i32a, indexJs, num));
    } else {
      // if num < numWorkers is passed to wake, num workers should be woken.
      // Then the remaining workers are woken for the next part
      assertEquals(num, Atomics.notify(i32a, indexJs, num));
      assertEquals(numWorkers-num, Atomics.notify(i32a, indexJs, numWorkers));
    }
    for (let id = 0; id < numWorkers; id++) {
      assertEquals(msg, workers[id].getMessage());
    }
  };

  let wasmWakeCheck = function(index, num, workers, msg) {
    waitForAllWorkers(index);
    if (num >= numWorkers) {
      // if numWorkers or more is passed to wake, numWorkers workers should be
      // woken.
      assertEquals(numWorkers, WasmAtomicNotify(memory, 0, index, num));
    } else {
      // if num < numWorkers is passed to wake, num workers should be woken.
      // Then the remaining workers are woken for the next part
      assertEquals(num, WasmAtomicNotify(memory, 0, index, num));
      assertEquals(numWorkers-num,
                   WasmAtomicNotify(memory, 0, index, numWorkers));
    }
    for (let id = 0; id < numWorkers; id++) {
      assertEquals(msg, workers[id].getMessage());
    }
  };

  let workers = [];
  for (let id = 0; id < numWorkers; id++) {
    workers[id] = new Worker(workerScript, {type: 'string'});
    workers[id].postMessage({id, memory});
  }

  wasmWakeCheck(0, numWorkers, workers, "ok");
  wasmWakeCheck(8, numWorkers + 1, workers, "ok");
  wasmWakeCheck(16, numWorkers - 1, workers, "ok");

  jsWakeCheck(24, numWorkers, workers, kAtomicWaitOk);
  jsWakeCheck(32, numWorkers + 1, workers, kAtomicWaitOk);
  jsWakeCheck(40, numWorkers - 1, workers, kAtomicWaitOk);

  wasmWakeCheck(48, numWorkers, workers, kAtomicWaitOk);
  wasmWakeCheck(56, numWorkers + 1, workers, kAtomicWaitOk);
  wasmWakeCheck(64, numWorkers - 1, workers, kAtomicWaitOk);

  jsWakeCheck(72, numWorkers, workers, kAtomicWaitOk);
  jsWakeCheck(80, numWorkers + 1, workers, kAtomicWaitOk);
  jsWakeCheck(88, numWorkers - 1, workers, kAtomicWaitOk);

  wasmWakeCheck(96, numWorkers, workers, kAtomicWaitOk);
  wasmWakeCheck(104, numWorkers + 1, workers, kAtomicWaitOk);
  wasmWakeCheck(112, numWorkers - 1, workers, kAtomicWaitOk);

  for (let id = 0; id < numWorkers; id++) {
    workers[id].terminate();
  }
}

(function TestWaitTrapsOnDisallowedIsolate() {
  let memory = new WebAssembly.Memory({initial: 1, maximum: 1, shared: true});
  var waitMs = 100;
  %SetAllowAtomicsWait(false)
  assertThrows(function() {
    WasmI32AtomicWait(memory, 0, 0, 0, waitMs*1000000)}, WebAssembly.RuntimeError);
  assertThrows(function() {
    WasmI64AtomicWait(memory, 0, 0, 0, waitMs*1000000)}, WebAssembly.RuntimeError);
})();
                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/gc-buffer.js                                                  0000664 0000000 0000000 00000002345 14746647661 0021666 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --gc-interval=500 --stress-compaction --expose-gc

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function run(f) {
  // wrap the creation in a closure so that the only thing returned is
  // the module (i.e. the underlying array buffer of wasm wire bytes dies).
  var module = (() => {
    var builder = new WasmModuleBuilder();
    builder.addImport("mod", "the_name_of_my_import", kSig_i_i);
    builder.addFunction("main", kSig_i_i)
      .addBody([
        kExprLocalGet, 0,
        kExprCallFunction, 0])
      .exportAs("main");
    print("module");
    return new WebAssembly.Module(builder.toBuffer());
  })();

  gc();
  for (var i = 0; i < 10; i++) {
    print("  instance " + i);
    var instance = new WebAssembly.Instance(module, {"mod": {the_name_of_my_import: f}});
    var g = instance.exports.main;
    assertEquals("function", typeof g);
    for (var j = 0; j < 10; j++) {
      assertEquals(f(j), g(j));
    }
  }
}

(function test() {
  for (var i = 0; i < 3; i++) {
    run(x => (x + 19));
    run(x => (x - 18));
  }
})();
                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/wasm/gc-cast-type-inference.js                                     0000664 0000000 0000000 00000013657 14746647661 0024272 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function TestRefCastNullReturnsNullTypeForNonNullInput() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let consumeRefI31 =
    builder.addFunction(`consumeRefI31`,
                        makeSig([wasmRefType(kWasmI31Ref)], []))
    .addBody([]);

  builder.addFunction(`refCastRemovesNullability`,
                      makeSig([kWasmExternRef], []))
  .addBody([
    kExprLocalGet, 0,
    kGCPrefix, kExprAnyConvertExtern,
    kExprRefAsNonNull,
    kGCPrefix, kExprRefCastNull, kI31RefCode,
    // ref.cast null pushes a nullable value on the stack even though its input
    // was non-nullable, therefore this call is not spec-compliant.
    kExprCallFunction, consumeRefI31.index,
  ]).exportFunc();

  assertThrows(() => builder.instantiate(), WebAssembly.CompileError,
               /expected type \(ref i31\), found .* type i31ref/);
})();

(function TestRefCastRemovesNullability() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let i31ToI32 =
    builder.addFunction(`i31ToI32`,
                        makeSig([wasmRefType(kWasmI31Ref)], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprI31GetS
    ]);

  builder.addFunction(`refCastRemovesNullability`,
                      makeSig([kWasmExternRef], [kWasmI32]))
  .addBody([
    kExprLocalGet, 0,
    kGCPrefix, kExprAnyConvertExtern,
    kGCPrefix, kExprRefCast, kI31RefCode,
    // ref.cast pushes a non-nullable value on the stack even for a nullable
    // input value as the instruction traps on null.
    kExprCallFunction, i31ToI32.index,
  ]).exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(42, wasm.refCastRemovesNullability(42));
  assertEquals(-1, wasm.refCastRemovesNullability(-1));
  assertTraps(kTrapIllegalCast, () => wasm.refCastRemovesNullability(null));
})();

(function TestBrOnCastNullability() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let consumeNonNull =
    builder.addFunction(`consumeNonNull`,
                        makeSig([wasmRefType(kWasmAnyRef)], []))
    .addBody([]);
  let i31ToI32 =
    builder.addFunction(`i31ToI32`,
                        makeSig([wasmRefType(kWasmI31Ref)], [kWasmI32]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprI31GetS]);


  builder.addFunction(`brOnCastNullNonNullOnPassThrough`,
                      makeSig([kWasmExternRef], [kWasmI32]))
  .addBody([
    kExprBlock, kWasmRefNull, kI31RefCode,
      kExprLocalGet, 0,
      kGCPrefix, kExprAnyConvertExtern,
      kGCPrefix, kExprBrOnCast, 0b11, 0, kAnyRefCode, kI31RefCode,
      // As null branches, the type here is guaranteed to be non-null.
      kExprCallFunction, consumeNonNull.index,
      kExprI32Const, 0,
      kExprReturn,
    kExprEnd,
    kGCPrefix, kExprI31GetS,
    kExprReturn,
  ]).exportFunc();

  builder.addFunction(`brOnCastNonNullOnBranch`,
                      makeSig([kWasmExternRef], [kWasmI32]))
  .addBody([
    // The value is guaranteed to be non-null on branch.
    kExprBlock, kWasmRef, kI31RefCode,
      kExprLocalGet, 0,
      kGCPrefix, kExprAnyConvertExtern,
      kGCPrefix, kExprBrOnCast, 0b01, 0, kAnyRefCode, kI31RefCode,
      kExprDrop,
      kExprI32Const, 0,
      kExprReturn,
    kExprEnd,
    kExprCallFunction, i31ToI32.index,
    kExprReturn,
  ]).exportFunc();

  let instance = builder.instantiate();
  let wasm = instance.exports;
  assertTraps(kTrapNullDereference, () => wasm.brOnCastNullNonNullOnPassThrough(null));
  assertEquals(42, wasm.brOnCastNullNonNullOnPassThrough(42));
  assertEquals(0, wasm.brOnCastNullNonNullOnPassThrough("cast fails"));
  assertEquals(0, wasm.brOnCastNonNullOnBranch(null));
  assertEquals(42, wasm.brOnCastNonNullOnBranch(42));
  assertEquals(0, wasm.brOnCastNonNullOnBranch("cast fails"));
})();

(function TestBrOnCastFailNullability() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let consumeNonNull =
    builder.addFunction(`consumeNonNull`,
                        makeSig([wasmRefType(kWasmAnyRef)], []))
    .addBody([]);
  let i31ToI32 =
    builder.addFunction(`i31ToI32`,
                        makeSig([wasmRefType(kWasmI31Ref)], [kWasmI32]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprI31GetS]);

  builder.addFunction(`brOnCastFailNonNullOnPassThrough`,
                      makeSig([kWasmExternRef], [kWasmI32]))
  .addBody([
    kExprBlock, kWasmRefNull, kAnyRefCode,
      kExprLocalGet, 0,
      kGCPrefix, kExprAnyConvertExtern,
      kGCPrefix, kExprBrOnCastFail, 0b01, 0, kAnyRefCode, kI31RefCode,
      // As null branches, the type here is guaranteed to be non-null.
      kExprCallFunction, i31ToI32.index,
      kExprReturn,
    kExprEnd,
    kExprDrop,
    kExprI32Const, 1,
    kExprReturn,
  ]).exportFunc();

  builder.addFunction(`brOnCastFailNullNonNullOnBranch`,
                      makeSig([kWasmExternRef], [kWasmI32]))
  .addBody([
    // The value is guaranteed to be non-null on branch.
    kExprBlock, kWasmRef, kAnyRefCode,
      kExprLocalGet, 0,
      kGCPrefix, kExprAnyConvertExtern,
      kGCPrefix, kExprBrOnCastFail, 0b11, 0, kAnyRefCode, kI31RefCode,
      kGCPrefix, kExprI31GetS,
      kExprReturn,
    kExprEnd,
    kExprCallFunction, consumeNonNull.index,
    kExprI32Const, 1,
    kExprReturn,
  ]).exportFunc();

  let instance = builder.instantiate();
  let wasm = instance.exports;
  assertEquals(1, wasm.brOnCastFailNonNullOnPassThrough(null));
  assertEquals(42, wasm.brOnCastFailNonNullOnPassThrough(42));
  assertEquals(1, wasm.brOnCastFailNonNullOnPassThrough("cast fails"));
  assertTraps(kTrapNullDereference, () => wasm.brOnCastFailNullNonNullOnBranch(null));
  assertEquals(42, wasm.brOnCastFailNullNonNullOnBranch(42));
  assertEquals(1, wasm.brOnCastFailNullNonNullOnBranch("cast fails"));
})();
                                                                                 node-23.7.0/deps/v8/test/mjsunit/wasm/gc-casts-exnref.js                                            0000664 0000000 0000000 00000022127 14746647661 0023017 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-exnref --no-experimental-wasm-inlining

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

let getExnRef = function() {
  let tag = new WebAssembly.Tag({parameters: []});
  return new WebAssembly.Exception(tag, []);
}

// Helper module to produce an exnref or convert a JS value to an exnref.
let helper = (function () {
  let builder = new WasmModuleBuilder();
  let tag_index = builder.addTag(kSig_v_v);
  let throw_index = builder.addImport('m', 'import', kSig_v_r);
  builder.addFunction('get_exnref', makeSig([], [kWasmExnRef]))
      .addBody([
          kExprTryTable, kWasmVoid, 1,
          kCatchAllRef, 0,
          kExprThrow, tag_index,
          kExprEnd,
          kExprUnreachable,
      ]).exportFunc();
  builder.addFunction('to_exnref', makeSig([kWasmExternRef], [kWasmExnRef]))
      .addBody([
          kExprTryTable, kWasmVoid, 1,
          kCatchAllRef, 0,
          kExprLocalGet, 0,
          kExprCallFunction, throw_index,
          kExprEnd,
          kExprUnreachable,
      ]).exportFunc();
  function throw_js(r) { throw r; }
  let instance = builder.instantiate({m: {import: throw_js}});
  return instance;
})();

(function RefTestExnRef() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let get_exnref = builder.addImport('m', 'get_exnref', makeSig([], [kWasmExnRef]));
  builder.addFunction('testExnRef',
      makeSig([], [kWasmI32, kWasmI32, kWasmI32, kWasmI32]))
    .addLocals(kWasmExnRef, 1)
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprRefTest, kExnRefCode,
      kExprLocalGet, 0,
      kGCPrefix, kExprRefTest, kNullExnRefCode,
      kExprCallFunction, get_exnref,
      kGCPrefix, kExprRefTest, kExnRefCode,
      kExprCallFunction, get_exnref,
      kGCPrefix, kExprRefTest, kNullExnRefCode,
    ]).exportFunc();

  builder.addFunction('testNullExnRef',
      makeSig([], [kWasmI32, kWasmI32, kWasmI32, kWasmI32]))
    .addLocals(kWasmExnRef, 1)
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprRefTestNull, kExnRefCode,
      kExprLocalGet, 0,
      kGCPrefix, kExprRefTestNull, kNullExnRefCode,
      kExprCallFunction, get_exnref,
      kGCPrefix, kExprRefTestNull, kExnRefCode,
      kExprCallFunction, get_exnref,
      kGCPrefix, kExprRefTestNull, kNullExnRefCode,
    ]).exportFunc();


  let instance = builder.instantiate({m: {get_exnref: helper.exports.get_exnref}});
  let wasm = instance.exports;
  assertEquals([0, 0, 1, 0], wasm.testExnRef());
  assertEquals([1, 1, 1, 0], wasm.testNullExnRef());
})();

(function RefCastExnRef() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let to_exnref = builder.addImport('m', 'to_exnref', makeSig([kWasmExternRef], [kWasmExnRef]));

  builder.addFunction('castToExnRef',
      makeSig([kWasmExternRef], []))
    .addBody([
        kExprLocalGet, 0,
        kExprCallFunction, to_exnref,
        kGCPrefix, kExprRefCast, kExnRefCode,
        kExprThrowRef])
    .exportFunc();
  builder.addFunction('castToNullExnRef',
    makeSig([kWasmExternRef], []))
  .addBody([
      kExprLocalGet, 0,
      kExprCallFunction, to_exnref,
      kGCPrefix, kExprRefCast, kNullExnRefCode,
      kExprDrop])
  .exportFunc();
  builder.addFunction('castNullToExnRef',
    makeSig([kWasmExternRef], []))
  .addBody([
      kExprLocalGet, 0,
      kExprCallFunction, to_exnref,
      kGCPrefix, kExprRefCastNull, kExnRefCode,
      kExprThrowRef])
  .exportFunc();
  builder.addFunction('castNullToNullExnRef',
    makeSig([kWasmExternRef], []))
  .addBody([
      kExprLocalGet, 0,
      kExprCallFunction, to_exnref,
      kGCPrefix, kExprRefCastNull, kNullExnRefCode,
      kGCPrefix, kExprRefCastNull, kExnRefCode,
      kExprThrowRef])
  .exportFunc();

  let instance = builder.instantiate({m: {to_exnref: helper.exports.to_exnref}});
  let wasm = instance.exports;

  let exnRef = getExnRef();
  assertTraps(kTrapIllegalCast, () => wasm.castToExnRef(null));
  assertThrowsEquals(() => wasm.castToExnRef(exnRef), exnRef);
  assertTraps(kTrapIllegalCast, () => wasm.castToNullExnRef(null));
  assertTraps(kTrapIllegalCast, () => wasm.castToNullExnRef(exnRef));

  assertThrows(() => wasm.castNullToExnRef(null), Error, /rethrowing null value/);
  assertThrowsEquals(() => wasm.castNullToExnRef(exnRef), exnRef);
  assertThrows(() => wasm.castNullToNullExnRef(null), Error, /rethrowing null value/);
  assertTraps(kTrapIllegalCast, () => wasm.castNullToNullExnRef(exnRef));
})();

(function BrOnCastExnRef() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let to_exnref = builder.addImport('m', 'to_exnref', makeSig([kWasmExternRef], [kWasmExnRef]));

  builder.addFunction('castToExnRef',
    makeSig([kWasmExternRef], [kWasmI32]))
  .addBody([
    kExprBlock, kWasmRef, kExnRefCode,
      kExprLocalGet, 0,
      kExprCallFunction, to_exnref,
      ...wasmBrOnCast(
          0, wasmRefNullType(kWasmExnRef), wasmRefType(kWasmExnRef)),
      kExprI32Const, 0,
      kExprReturn,
    kExprEnd,
    kExprDrop,
    kExprI32Const, 1,
    kExprReturn,
  ])
  .exportFunc();
  builder.addFunction('castToNullExnRef',
    makeSig([kWasmExternRef], [kWasmI32]))
  .addBody([
    kExprBlock, kWasmRef, kNullExnRefCode,
      kExprLocalGet, 0,
      kExprCallFunction, to_exnref,
      ...wasmBrOnCast(
          0, wasmRefNullType(kWasmExnRef), wasmRefType(kWasmNullExnRef)),
      kExprI32Const, 0,
      kExprReturn,
    kExprEnd,
    kExprDrop,
    kExprI32Const, 1,
    kExprReturn,
  ])
  .exportFunc();

  builder.addFunction('castNullToExnRef',
    makeSig([kWasmExternRef], [kWasmI32]))
  .addBody([
    kExprBlock, kWasmRefNull, kExnRefCode,
      kExprLocalGet, 0,
      kExprCallFunction, to_exnref,
      ...wasmBrOnCast(0,
          wasmRefNullType(kWasmExnRef), wasmRefNullType(kWasmExnRef)),
      kExprI32Const, 0,
      kExprReturn,
    kExprEnd,
    kExprDrop,
    kExprI32Const, 1,
    kExprReturn,
  ])
  .exportFunc();
  builder.addFunction('castNullToNullExnRef',
    makeSig([kWasmExternRef], [kWasmI32]))
  .addBody([
    kExprBlock, kWasmRefNull, kNullExnRefCode,
      kExprLocalGet, 0,
      kExprCallFunction, to_exnref,
      ...wasmBrOnCast(0,
          wasmRefNullType(kWasmExnRef), wasmRefNullType(kWasmNullExnRef)),
      kExprI32Const, 0,
      kExprReturn,
    kExprEnd,
    kExprDrop,
    kExprI32Const, 1,
    kExprReturn,
  ])
  .exportFunc();

  builder.addFunction('castFailToExnRef',
    makeSig([kWasmExternRef], [kWasmI32]))
  .addBody([
    kExprBlock, kWasmRefNull, kExnRefCode,
      kExprLocalGet, 0,
      kExprCallFunction, to_exnref,
      ...wasmBrOnCastFail(0,
          wasmRefNullType(kWasmExnRef), wasmRefType(kWasmExnRef)),
      kExprI32Const, 0,
      kExprReturn,
    kExprEnd,
    kExprDrop,
    kExprI32Const, 1,
    kExprReturn,
  ])
  .exportFunc();
  builder.addFunction('castFailToNullExnRef',
    makeSig([kWasmExternRef], [kWasmI32]))
  .addBody([
    kExprBlock, kWasmRefNull, kExnRefCode,
      kExprLocalGet, 0,
      kExprCallFunction, to_exnref,
      ...wasmBrOnCastFail(0,
          wasmRefNullType(kWasmExnRef), wasmRefType(kWasmNullExnRef)),
      kExprI32Const, 0,
      kExprReturn,
    kExprEnd,
    kExprDrop,
    kExprI32Const, 1,
    kExprReturn,
  ])
  .exportFunc();

  builder.addFunction('castFailNullToExnRef',
    makeSig([kWasmExternRef], [kWasmI32]))
  .addBody([
    kExprBlock, kWasmRef, kExnRefCode,
      kExprLocalGet, 0,
      kExprCallFunction, to_exnref,
      ...wasmBrOnCastFail(0,
          wasmRefNullType(kWasmExnRef), wasmRefNullType(kWasmExnRef)),
      kExprI32Const, 0,
      kExprReturn,
    kExprEnd,
    kExprDrop,
    kExprI32Const, 1,
    kExprReturn,
  ])
  .exportFunc();
  builder.addFunction('castFailNullToNullExnRef',
    makeSig([kWasmExternRef], [kWasmI32]))
  .addBody([
    kExprBlock, kWasmRef, kExnRefCode,
      kExprLocalGet, 0,
      kExprCallFunction, to_exnref,
      ...wasmBrOnCastFail(0,
          wasmRefNullType(kWasmExnRef), wasmRefNullType(kWasmNullExnRef)),
      kExprI32Const, 0,
      kExprReturn,
    kExprEnd,
    kExprDrop,
    kExprI32Const, 1,
    kExprReturn,
  ])
  .exportFunc();

  let instance = builder.instantiate({m: {to_exnref: helper.exports.to_exnref}});
  let wasm = instance.exports;
  let exnRef = getExnRef();

  assertEquals(0, wasm.castToExnRef(null));
  assertEquals(1, wasm.castToExnRef(exnRef));

  assertEquals(0, wasm.castToNullExnRef(null));
  assertEquals(0, wasm.castToNullExnRef(exnRef));

  assertEquals(1, wasm.castNullToExnRef(null));
  assertEquals(1, wasm.castNullToExnRef(exnRef));

  assertEquals(1, wasm.castNullToNullExnRef(null));
  assertEquals(0, wasm.castNullToNullExnRef(exnRef));

  assertEquals(1, wasm.castFailToExnRef(null));
  assertEquals(0, wasm.castFailToExnRef(exnRef));

  assertEquals(1, wasm.castFailToNullExnRef(null));
  assertEquals(1, wasm.castFailToNullExnRef(exnRef));

  assertEquals(0, wasm.castFailNullToExnRef(null));
  assertEquals(0, wasm.castFailNullToExnRef(exnRef));

  assertEquals(0, wasm.castFailNullToNullExnRef(null));
  assertEquals(1, wasm.castFailNullToNullExnRef(exnRef));
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/wasm/gc-casts-from-any.js                                          0000664 0000000 0000000 00000121020 14746647661 0023250 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-stringref

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function TestRefTest() {
  var builder = new WasmModuleBuilder();
  builder.startRecGroup();
  let structSuper = builder.addStruct([makeField(kWasmI32, true)]);
  let structSub = builder.addStruct([makeField(kWasmI32, true)], structSuper);
  let array = builder.addArray(kWasmI32);
  builder.endRecGroup();

  let fct =
  builder.addFunction('createStructSuper',
                      makeSig([kWasmI32], [kWasmExternRef]))
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprStructNew, structSuper,
      kGCPrefix, kExprExternConvertAny,
    ]).exportFunc();
  builder.addFunction('createStructSub', makeSig([kWasmI32], [kWasmExternRef]))
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprStructNew, structSub,
      kGCPrefix, kExprExternConvertAny,
    ]).exportFunc();
  builder.addFunction('createArray', makeSig([kWasmI32], [kWasmExternRef]))
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprArrayNewFixed, array, 1,
      kGCPrefix, kExprExternConvertAny,
    ]).exportFunc();
  builder.addFunction('createFuncRef', makeSig([], [kWasmFuncRef]))
    .addBody([
      kExprRefFunc, fct.index,
    ]).exportFunc();

  [
    ["StructSuper", structSuper],
    ["StructSub", structSub],
    ["Array", array],
    ["I31", kI31RefCode],
    ["AnyArray", kArrayRefCode],
    ["Struct", kStructRefCode],
    ["Eq", kEqRefCode],
    ["String", kStringRefCode],
    // 'ref.test any' is semantically the same as '!ref.is_null' here.
    ["Any", kAnyRefCode],
    ["None", kNullRefCode]
  ].forEach(([typeName, typeCode]) => {
    builder.addFunction(`refTest${typeName}`,
                        makeSig([kWasmExternRef], [kWasmI32, kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprAnyConvertExtern,
      kGCPrefix, kExprRefTest, typeCode,
      kExprLocalGet, 0,
      kGCPrefix, kExprAnyConvertExtern,
      kGCPrefix, kExprRefTestNull, typeCode,
    ]).exportFunc();

    builder.addFunction(`refCast${typeName}`,
                        makeSig([kWasmExternRef], [kWasmExternRef]))
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprAnyConvertExtern,
      kGCPrefix, kExprRefCast, typeCode,
      kGCPrefix, kExprExternConvertAny,
    ]).exportFunc();

    builder.addFunction(`refCastNull${typeName}`,
                        makeSig([kWasmExternRef], [kWasmExternRef]))
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprAnyConvertExtern,
      kGCPrefix, kExprRefCastNull, typeCode,
      kGCPrefix, kExprExternConvertAny,
    ]).exportFunc();

    builder.addFunction(`brOnCast${typeName}`,
                        makeSig([kWasmExternRef], [kWasmI32]))
    .addBody([
      kExprBlock, kWasmRef, typeCode,
        kExprLocalGet, 0,
        kGCPrefix, kExprAnyConvertExtern,
        kGCPrefix, kExprBrOnCast, 0b01, 0, kAnyRefCode, typeCode,
        kExprI32Const, 0,
        kExprReturn,
      kExprEnd,
      kExprDrop,
      kExprI32Const, 1,
      kExprReturn,
    ]).exportFunc();
    builder.addFunction(`brOnCastNull${typeName}`,
                        makeSig([kWasmExternRef], [kWasmI32]))
    .addBody([
      kExprBlock, kWasmRefNull, typeCode,
        kExprLocalGet, 0,
        kGCPrefix, kExprAnyConvertExtern,
        kGCPrefix, kExprBrOnCast, 0b11, 0, kAnyRefCode, typeCode,
        kExprI32Const, 0,
        kExprReturn,
      kExprEnd,
      kExprDrop,
      kExprI32Const, 1,
      kExprReturn,
    ]).exportFunc();
    builder.addFunction(`brOnCastFail${typeName}`,
                        makeSig([kWasmExternRef], [kWasmI32]))
    .addBody([
      kExprBlock, kAnyRefCode,
        kExprLocalGet, 0,
        kGCPrefix, kExprAnyConvertExtern,
        kGCPrefix, kExprBrOnCastFail, 0b01, 0, kAnyRefCode, typeCode,
        kExprI32Const, 0,
        kExprReturn,
      kExprEnd,
      kExprDrop,
      kExprI32Const, 1,
      kExprReturn,
    ]).exportFunc();
    builder.addFunction(`brOnCastFailNull${typeName}`,
                        makeSig([kWasmExternRef], [kWasmI32]))
    .addBody([
      kExprBlock, kAnyRefCode,
        kExprLocalGet, 0,
        kGCPrefix, kExprAnyConvertExtern,
        kGCPrefix, kExprBrOnCastFail, 0b11, 0, kAnyRefCode, typeCode,
        kExprI32Const, 0,
        kExprReturn,
      kExprEnd,
      kExprDrop,
      kExprI32Const, 1,
      kExprReturn,
    ]).exportFunc();
  });

  var instance = builder.instantiate();
  let wasm = instance.exports;
  // result: [ref.test, ref.test null]
  assertEquals([0, 1], wasm.refTestStructSuper(null));
  assertEquals([0, 0], wasm.refTestStructSuper(undefined));
  assertEquals([1, 1], wasm.refTestStructSuper(wasm.createStructSuper()));
  assertEquals([1, 1], wasm.refTestStructSuper(wasm.createStructSub()));
  assertEquals([0, 0], wasm.refTestStructSuper(wasm.createArray()));
  assertEquals([0, 0], wasm.refTestStructSuper(wasm.createFuncRef()));
  assertEquals([0, 0], wasm.refTestStructSuper(1));
  assertEquals([0, 0], wasm.refTestStructSuper({'JavaScript': 'Object'}));
  assertEquals([0, 0], wasm.refTestStructSuper('string'));

  assertEquals([0, 1], wasm.refTestStructSub(null));
  assertEquals([0, 0], wasm.refTestStructSub(undefined));
  assertEquals([0, 0], wasm.refTestStructSub(wasm.createStructSuper()));
  assertEquals([1, 1], wasm.refTestStructSub(wasm.createStructSub()));
  assertEquals([0, 0], wasm.refTestStructSub(wasm.createArray()));
  assertEquals([0, 0], wasm.refTestStructSub(wasm.createFuncRef()));
  assertEquals([0, 0], wasm.refTestStructSub(1));
  assertEquals([0, 0], wasm.refTestStructSub({'JavaScript': 'Object'}));
  assertEquals([0, 0], wasm.refTestStructSub('string'));

  assertEquals([0, 1], wasm.refTestArray(null));
  assertEquals([0, 0], wasm.refTestArray(undefined));
  assertEquals([0, 0], wasm.refTestArray(wasm.createStructSuper()));
  assertEquals([0, 0], wasm.refTestArray(wasm.createStructSub()));
  assertEquals([1, 1], wasm.refTestArray(wasm.createArray()));
  assertEquals([0, 0], wasm.refTestArray(wasm.createFuncRef()));
  assertEquals([0, 0], wasm.refTestArray(1));
  assertEquals([0, 0], wasm.refTestArray({'JavaScript': 'Object'}));
  assertEquals([0, 0], wasm.refTestArray('string'));

  assertEquals([0, 1], wasm.refTestI31(null));
  assertEquals([0, 0], wasm.refTestI31(undefined));
  assertEquals([0, 0], wasm.refTestI31(wasm.createStructSuper()));
  assertEquals([0, 0], wasm.refTestI31(wasm.createStructSub()));
  assertEquals([0, 0], wasm.refTestI31(wasm.createArray()));
  assertEquals([0, 0], wasm.refTestI31(wasm.createFuncRef()));
  assertEquals([1, 1], wasm.refTestI31(1));
  assertEquals([0, 0], wasm.refTestI31({'JavaScript': 'Object'}));
  assertEquals([0, 0], wasm.refTestI31('string'));

  assertEquals([0, 1], wasm.refTestAnyArray(null));
  assertEquals([0, 0], wasm.refTestAnyArray(undefined));
  assertEquals([0, 0], wasm.refTestAnyArray(wasm.createStructSuper()));
  assertEquals([0, 0], wasm.refTestAnyArray(wasm.createStructSub()));
  assertEquals([1, 1], wasm.refTestAnyArray(wasm.createArray()));
  assertEquals([0, 0], wasm.refTestAnyArray(wasm.createFuncRef()));
  assertEquals([0, 0], wasm.refTestAnyArray(1));
  assertEquals([0, 0], wasm.refTestAnyArray({'JavaScript': 'Object'}));
  assertEquals([0, 0], wasm.refTestAnyArray('string'));

  assertEquals([0, 1], wasm.refTestStruct(null));
  assertEquals([0, 0], wasm.refTestStruct(undefined));
  assertEquals([1, 1], wasm.refTestStruct(wasm.createStructSuper()));
  assertEquals([1, 1], wasm.refTestStruct(wasm.createStructSub()));
  assertEquals([0, 0], wasm.refTestStruct(wasm.createArray()));
  assertEquals([0, 0], wasm.refTestStruct(wasm.createFuncRef()));
  assertEquals([0, 0], wasm.refTestStruct(1));
  assertEquals([0, 0], wasm.refTestStruct({'JavaScript': 'Object'}));
  assertEquals([0, 0], wasm.refTestStruct('string'));

  assertEquals([0, 1], wasm.refTestString(null));
  assertEquals([0, 0], wasm.refTestString(undefined));
  assertEquals([0, 0], wasm.refTestString(wasm.createStructSuper()));
  assertEquals([0, 0], wasm.refTestString(wasm.createStructSub()));
  assertEquals([0, 0], wasm.refTestString(wasm.createArray()));
  assertEquals([0, 0], wasm.refTestString(wasm.createFuncRef()));
  assertEquals([0, 0], wasm.refTestString(1));
  assertEquals([0, 0], wasm.refTestString({'JavaScript': 'Object'}));
  assertEquals([1, 1], wasm.refTestString('string'));

  assertEquals([0, 1], wasm.refTestEq(null));
  assertEquals([0, 0], wasm.refTestEq(undefined));
  assertEquals([1, 1], wasm.refTestEq(wasm.createStructSuper()));
  assertEquals([1, 1], wasm.refTestEq(wasm.createStructSub()));
  assertEquals([1, 1], wasm.refTestEq(wasm.createArray()));
  assertEquals([0, 0], wasm.refTestEq(wasm.createFuncRef()));
  assertEquals([1, 1], wasm.refTestEq(1)); // ref.i31
  assertEquals([0, 0], wasm.refTestEq({'JavaScript': 'Object'}));
  assertEquals([0, 0], wasm.refTestEq('string'));

  assertEquals([0, 1], wasm.refTestAny(null));
  assertEquals([1, 1], wasm.refTestAny(undefined));
  assertEquals([1, 1], wasm.refTestAny(wasm.createStructSuper()));
  assertEquals([1, 1], wasm.refTestAny(wasm.createStructSub()));
  assertEquals([1, 1], wasm.refTestAny(wasm.createArray()));
  assertEquals([1, 1], wasm.refTestAny(wasm.createFuncRef()));
  assertEquals([1, 1], wasm.refTestAny(1)); // ref.i31
  assertEquals([1, 1], wasm.refTestAny({'JavaScript': 'Object'}));
  assertEquals([1, 1], wasm.refTestAny('string'));

  assertEquals([0, 1], wasm.refTestNone(null));
  assertEquals([0, 0], wasm.refTestNone(undefined));
  assertEquals([0, 0], wasm.refTestNone(wasm.createStructSuper()));
  assertEquals([0, 0], wasm.refTestNone(wasm.createStructSub()));
  assertEquals([0, 0], wasm.refTestNone(wasm.createArray()));
  assertEquals([0, 0], wasm.refTestNone(wasm.createFuncRef()));
  assertEquals([0, 0], wasm.refTestNone(1)); // ref.i31
  assertEquals([0, 0], wasm.refTestNone({'JavaScript': 'Object'}));
  assertEquals([0, 0], wasm.refTestNone('string'));

  // ref.cast
  let structSuperObj = wasm.createStructSuper();
  let structSubObj = wasm.createStructSub();
  let arrayObj = wasm.createArray();
  let jsObj = {'JavaScript': 'Object'};
  let strObj = 'string';
  let funcObj = wasm.createFuncRef();

  assertTraps(kTrapIllegalCast, () => wasm.refCastStructSuper(null));
  assertTraps(kTrapIllegalCast, () => wasm.refCastStructSuper(undefined));
  assertSame(structSuperObj, wasm.refCastStructSuper(structSuperObj));
  assertSame(structSubObj, wasm.refCastStructSuper(structSubObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastStructSuper(arrayObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastStructSuper(funcObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastStructSuper(1));
  assertTraps(kTrapIllegalCast, () => wasm.refCastStructSuper(jsObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastStructSuper(strObj));

  assertTraps(kTrapIllegalCast, () => wasm.refCastStructSub(null));
  assertTraps(kTrapIllegalCast, () => wasm.refCastStructSub(undefined));
  assertTraps(kTrapIllegalCast, () => wasm.refCastStructSub(structSuperObj));
  assertSame(structSubObj, wasm.refCastStructSub(structSubObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastStructSub(arrayObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastStructSub(funcObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastStructSub(1));
  assertTraps(kTrapIllegalCast, () => wasm.refCastStructSub(jsObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastStructSub(strObj));

  assertTraps(kTrapIllegalCast, () => wasm.refCastArray(null));
  assertTraps(kTrapIllegalCast, () => wasm.refCastArray(undefined));
  assertTraps(kTrapIllegalCast, () => wasm.refCastArray(structSuperObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastArray(structSubObj));
  assertSame(arrayObj, wasm.refCastArray(arrayObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastArray(funcObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastArray(1));
  assertTraps(kTrapIllegalCast, () => wasm.refCastArray(jsObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastArray(strObj));

  assertTraps(kTrapIllegalCast, () => wasm.refCastI31(null));
  assertTraps(kTrapIllegalCast, () => wasm.refCastI31(undefined));
  assertTraps(kTrapIllegalCast, () => wasm.refCastI31(structSuperObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastI31(structSubObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastI31(arrayObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastI31(funcObj));
  assertEquals(1, wasm.refCastI31(1));
  assertTraps(kTrapIllegalCast, () => wasm.refCastI31(jsObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastI31(strObj));

  assertTraps(kTrapIllegalCast, () => wasm.refCastAnyArray(null));
  assertTraps(kTrapIllegalCast, () => wasm.refCastAnyArray(undefined));
  assertTraps(kTrapIllegalCast, () => wasm.refCastAnyArray(structSuperObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastAnyArray(structSubObj));
  assertSame(arrayObj, wasm.refCastAnyArray(arrayObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastAnyArray(funcObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastAnyArray(1));
  assertTraps(kTrapIllegalCast, () => wasm.refCastAnyArray(jsObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastAnyArray(strObj));

  assertTraps(kTrapIllegalCast, () => wasm.refCastStruct(null));
  assertTraps(kTrapIllegalCast, () => wasm.refCastStruct(undefined));
  assertSame(structSuperObj, wasm.refCastStruct(structSuperObj));
  assertSame(structSubObj, wasm.refCastStruct(structSubObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastStruct(arrayObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastStruct(funcObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastStruct(1));
  assertTraps(kTrapIllegalCast, () => wasm.refCastStruct(jsObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastStruct(strObj));

  assertTraps(kTrapIllegalCast, () => wasm.refCastString(null));
  assertTraps(kTrapIllegalCast, () => wasm.refCastString(undefined));
  assertTraps(kTrapIllegalCast, () => wasm.refCastString(structSuperObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastString(structSubObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastString(arrayObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastString(funcObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastString(1));
  assertTraps(kTrapIllegalCast, () => wasm.refCastString(jsObj));
  assertSame(strObj, wasm.refCastString(strObj));

  assertTraps(kTrapIllegalCast, () => wasm.refCastEq(null));
  assertTraps(kTrapIllegalCast, () => wasm.refCastEq(undefined));
  assertSame(structSuperObj, wasm.refCastEq(structSuperObj));
  assertSame(structSubObj, wasm.refCastEq(structSubObj));
  assertSame(arrayObj, wasm.refCastEq(arrayObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastEq(funcObj));
  assertEquals(1, wasm.refCastEq(1));
  assertTraps(kTrapIllegalCast, () => wasm.refCastEq(jsObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastEq(strObj));

  assertTraps(kTrapIllegalCast, () => wasm.refCastAny(null));
  assertSame(undefined, wasm.refCastAny(undefined));
  assertSame(structSuperObj, wasm.refCastAny(structSuperObj));
  assertSame(structSubObj, wasm.refCastAny(structSubObj));
  assertSame(arrayObj, wasm.refCastAny(arrayObj));
  assertSame(funcObj, wasm.refCastAny(funcObj));
  assertEquals(1, wasm.refCastAny(1));
  assertSame(jsObj, wasm.refCastAny(jsObj));
  assertSame(strObj, wasm.refCastAny(strObj));

  assertTraps(kTrapIllegalCast, () => wasm.refCastNone(null));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNone(undefined));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNone(structSuperObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNone(structSubObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNone(arrayObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNone(funcObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNone(1));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNone(jsObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNone(strObj));

  // ref.cast null
  assertSame(null, wasm.refCastNullStructSuper(null));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullStructSuper(undefined));
  assertSame(structSuperObj, wasm.refCastNullStructSuper(structSuperObj));
  assertSame(structSubObj, wasm.refCastNullStructSuper(structSubObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullStructSuper(arrayObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullStructSuper(funcObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullStructSuper(1));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullStructSuper(jsObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullStructSuper(strObj));

  assertSame(null, wasm.refCastNullStructSub(null));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullStructSub(undefined));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullStructSub(structSuperObj));
  assertSame(structSubObj, wasm.refCastNullStructSub(structSubObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullStructSub(arrayObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullStructSub(funcObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullStructSub(1));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullStructSub(jsObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullStructSub(strObj));

  assertSame(null, wasm.refCastNullArray(null));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullArray(undefined));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullArray(structSuperObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullArray(structSubObj));
  assertSame(arrayObj, wasm.refCastNullArray(arrayObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullArray(funcObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullArray(1));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullArray(jsObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullArray(strObj));

  assertSame(null, wasm.refCastNullI31(null));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullI31(undefined));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullI31(structSuperObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullI31(structSubObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullI31(arrayObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullI31(funcObj));
  assertEquals(1, wasm.refCastNullI31(1));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullI31(jsObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullI31(strObj));

  assertSame(null, wasm.refCastNullAnyArray(null));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullAnyArray(undefined));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullAnyArray(structSuperObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullAnyArray(structSubObj));
  assertSame(arrayObj, wasm.refCastNullAnyArray(arrayObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullAnyArray(funcObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullAnyArray(1));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullAnyArray(jsObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullAnyArray(strObj));

  assertSame(null, wasm.refCastNullStruct(null));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullStruct(undefined));
  assertSame(structSuperObj, wasm.refCastNullStruct(structSuperObj));
  assertSame(structSubObj, wasm.refCastNullStruct(structSubObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullStruct(arrayObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullStruct(funcObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullStruct(1));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullStruct(jsObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullStruct(strObj));

  assertSame(null, wasm.refCastNullString(null));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullString(undefined));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullString(structSuperObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullString(structSubObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullString(arrayObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullString(funcObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullString(1));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullString(jsObj));
  assertSame(strObj, wasm.refCastNullString(strObj));

  assertSame(null, wasm.refCastNullEq(null));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullEq(undefined));
  assertSame(structSuperObj, wasm.refCastNullEq(structSuperObj));
  assertSame(structSubObj, wasm.refCastNullEq(structSubObj));
  assertSame(arrayObj, wasm.refCastNullEq(arrayObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullEq(funcObj));
  assertEquals(1, wasm.refCastNullEq(1));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullEq(jsObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullEq(strObj));

  assertSame(null, wasm.refCastNullAny(null));
  assertSame(undefined, wasm.refCastNullAny(undefined));
  assertSame(structSuperObj, wasm.refCastNullAny(structSuperObj));
  assertSame(structSubObj, wasm.refCastNullAny(structSubObj));
  assertSame(arrayObj, wasm.refCastNullAny(arrayObj));
  assertSame(funcObj, wasm.refCastNullAny(funcObj));
  assertEquals(1, wasm.refCastNullAny(1));
  assertSame(jsObj, wasm.refCastNullAny(jsObj));
  assertSame(strObj, wasm.refCastNullAny(strObj));

  assertSame(null, wasm.refCastNullNone(null));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullNone(undefined));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullNone(structSuperObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullNone(structSubObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullNone(arrayObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullNone(funcObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullNone(1));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullNone(jsObj));
  assertTraps(kTrapIllegalCast, () => wasm.refCastNullNone(strObj));

  // br_on_cast
  assertEquals(0, wasm.brOnCastStructSuper(null));
  assertEquals(0, wasm.brOnCastStructSuper(undefined));
  assertEquals(1, wasm.brOnCastStructSuper(structSuperObj));
  assertEquals(1, wasm.brOnCastStructSuper(structSubObj));
  assertEquals(0, wasm.brOnCastStructSuper(arrayObj));
  assertEquals(0, wasm.brOnCastStructSuper(funcObj));
  assertEquals(0, wasm.brOnCastStructSuper(1));
  assertEquals(0, wasm.brOnCastStructSuper(jsObj));
  assertEquals(0, wasm.brOnCastStructSuper(strObj));

  assertEquals(0, wasm.brOnCastStructSub(null));
  assertEquals(0, wasm.brOnCastStructSub(undefined));
  assertEquals(0, wasm.brOnCastStructSub(structSuperObj));
  assertEquals(1, wasm.brOnCastStructSub(structSubObj));
  assertEquals(0, wasm.brOnCastStructSub(arrayObj));
  assertEquals(0, wasm.brOnCastStructSub(funcObj));
  assertEquals(0, wasm.brOnCastStructSub(1));
  assertEquals(0, wasm.brOnCastStructSub(jsObj));
  assertEquals(0, wasm.brOnCastStructSub(strObj));

  assertEquals(0, wasm.brOnCastArray(null));
  assertEquals(0, wasm.brOnCastArray(undefined));
  assertEquals(0, wasm.brOnCastArray(structSuperObj));
  assertEquals(0, wasm.brOnCastArray(structSubObj));
  assertEquals(1, wasm.brOnCastArray(arrayObj));
  assertEquals(0, wasm.brOnCastArray(funcObj));
  assertEquals(0, wasm.brOnCastArray(1));
  assertEquals(0, wasm.brOnCastArray(jsObj));
  assertEquals(0, wasm.brOnCastArray(strObj));

  assertEquals(0, wasm.brOnCastI31(null));
  assertEquals(0, wasm.brOnCastI31(undefined));
  assertEquals(0, wasm.brOnCastI31(structSuperObj));
  assertEquals(0, wasm.brOnCastI31(structSubObj));
  assertEquals(0, wasm.brOnCastI31(arrayObj));
  assertEquals(0, wasm.brOnCastI31(funcObj));
  assertEquals(1, wasm.brOnCastI31(1));
  assertEquals(0, wasm.brOnCastI31(jsObj));
  assertEquals(0, wasm.brOnCastI31(strObj));

  assertEquals(0, wasm.brOnCastAnyArray(null));
  assertEquals(0, wasm.brOnCastAnyArray(undefined));
  assertEquals(0, wasm.brOnCastAnyArray(structSuperObj));
  assertEquals(0, wasm.brOnCastAnyArray(structSubObj));
  assertEquals(1, wasm.brOnCastAnyArray(arrayObj));
  assertEquals(0, wasm.brOnCastAnyArray(funcObj));
  assertEquals(0, wasm.brOnCastAnyArray(1));
  assertEquals(0, wasm.brOnCastAnyArray(jsObj));
  assertEquals(0, wasm.brOnCastAnyArray(strObj));

  assertEquals(0, wasm.brOnCastStruct(null));
  assertEquals(0, wasm.brOnCastStruct(undefined));
  assertEquals(1, wasm.brOnCastStruct(structSuperObj));
  assertEquals(1, wasm.brOnCastStruct(structSubObj));
  assertEquals(0, wasm.brOnCastStruct(arrayObj));
  assertEquals(0, wasm.brOnCastStruct(funcObj));
  assertEquals(0, wasm.brOnCastStruct(1));
  assertEquals(0, wasm.brOnCastStruct(jsObj));
  assertEquals(0, wasm.brOnCastStruct(strObj));

  assertEquals(0, wasm.brOnCastEq(null));
  assertEquals(0, wasm.brOnCastEq(undefined));
  assertEquals(1, wasm.brOnCastEq(structSuperObj));
  assertEquals(1, wasm.brOnCastEq(structSubObj));
  assertEquals(1, wasm.brOnCastEq(arrayObj));
  assertEquals(0, wasm.brOnCastEq(funcObj));
  assertEquals(1, wasm.brOnCastEq(1));
  assertEquals(0, wasm.brOnCastEq(jsObj));
  assertEquals(0, wasm.brOnCastEq(strObj));

  assertEquals(0, wasm.brOnCastString(null));
  assertEquals(0, wasm.brOnCastString(undefined));
  assertEquals(0, wasm.brOnCastString(structSuperObj));
  assertEquals(0, wasm.brOnCastString(structSubObj));
  assertEquals(0, wasm.brOnCastString(arrayObj));
  assertEquals(0, wasm.brOnCastString(funcObj));
  assertEquals(0, wasm.brOnCastString(1));
  assertEquals(0, wasm.brOnCastString(jsObj));
  assertEquals(1, wasm.brOnCastString(strObj));

  assertEquals(0, wasm.brOnCastAny(null));
  assertEquals(1, wasm.brOnCastAny(undefined));
  assertEquals(1, wasm.brOnCastAny(structSuperObj));
  assertEquals(1, wasm.brOnCastAny(structSubObj));
  assertEquals(1, wasm.brOnCastAny(arrayObj));
  assertEquals(1, wasm.brOnCastAny(funcObj));
  assertEquals(1, wasm.brOnCastAny(1));
  assertEquals(1, wasm.brOnCastAny(jsObj));
  assertEquals(1, wasm.brOnCastAny(strObj));

  assertEquals(0, wasm.brOnCastNone(null));
  assertEquals(0, wasm.brOnCastNone(undefined));
  assertEquals(0, wasm.brOnCastNone(structSuperObj));
  assertEquals(0, wasm.brOnCastNone(structSubObj));
  assertEquals(0, wasm.brOnCastNone(arrayObj));
  assertEquals(0, wasm.brOnCastNone(funcObj));
  assertEquals(0, wasm.brOnCastNone(1));
  assertEquals(0, wasm.brOnCastNone(jsObj));
  assertEquals(0, wasm.brOnCastNone(strObj));

  // br_on_cast null
  assertEquals(1, wasm.brOnCastNullStructSuper(null));
  assertEquals(0, wasm.brOnCastNullStructSuper(undefined));
  assertEquals(1, wasm.brOnCastNullStructSuper(structSuperObj));
  assertEquals(1, wasm.brOnCastNullStructSuper(structSubObj));
  assertEquals(0, wasm.brOnCastNullStructSuper(arrayObj));
  assertEquals(0, wasm.brOnCastNullStructSuper(funcObj));
  assertEquals(0, wasm.brOnCastNullStructSuper(1));
  assertEquals(0, wasm.brOnCastNullStructSuper(jsObj));
  assertEquals(0, wasm.brOnCastNullStructSuper(strObj));

  assertEquals(1, wasm.brOnCastNullStructSub(null));
  assertEquals(0, wasm.brOnCastNullStructSub(undefined));
  assertEquals(0, wasm.brOnCastNullStructSub(structSuperObj));
  assertEquals(1, wasm.brOnCastNullStructSub(structSubObj));
  assertEquals(0, wasm.brOnCastNullStructSub(arrayObj));
  assertEquals(0, wasm.brOnCastNullStructSub(funcObj));
  assertEquals(0, wasm.brOnCastNullStructSub(1));
  assertEquals(0, wasm.brOnCastNullStructSub(jsObj));
  assertEquals(0, wasm.brOnCastNullStructSub(strObj));

  assertEquals(1, wasm.brOnCastNullArray(null));
  assertEquals(0, wasm.brOnCastNullArray(undefined));
  assertEquals(0, wasm.brOnCastNullArray(structSuperObj));
  assertEquals(0, wasm.brOnCastNullArray(structSubObj));
  assertEquals(1, wasm.brOnCastNullArray(arrayObj));
  assertEquals(0, wasm.brOnCastNullArray(funcObj));
  assertEquals(0, wasm.brOnCastNullArray(1));
  assertEquals(0, wasm.brOnCastNullArray(jsObj));
  assertEquals(0, wasm.brOnCastNullArray(strObj));

  assertEquals(1, wasm.brOnCastNullI31(null));
  assertEquals(0, wasm.brOnCastNullI31(undefined));
  assertEquals(0, wasm.brOnCastNullI31(structSuperObj));
  assertEquals(0, wasm.brOnCastNullI31(structSubObj));
  assertEquals(0, wasm.brOnCastNullI31(arrayObj));
  assertEquals(0, wasm.brOnCastNullI31(funcObj));
  assertEquals(1, wasm.brOnCastNullI31(1));
  assertEquals(0, wasm.brOnCastNullI31(jsObj));
  assertEquals(0, wasm.brOnCastNullI31(strObj));

  assertEquals(1, wasm.brOnCastNullAnyArray(null));
  assertEquals(0, wasm.brOnCastNullAnyArray(undefined));
  assertEquals(0, wasm.brOnCastNullAnyArray(structSuperObj));
  assertEquals(0, wasm.brOnCastNullAnyArray(structSubObj));
  assertEquals(1, wasm.brOnCastNullAnyArray(arrayObj));
  assertEquals(0, wasm.brOnCastNullAnyArray(funcObj));
  assertEquals(0, wasm.brOnCastNullAnyArray(1));
  assertEquals(0, wasm.brOnCastNullAnyArray(jsObj));
  assertEquals(0, wasm.brOnCastNullAnyArray(strObj));

  assertEquals(1, wasm.brOnCastNullStruct(null));
  assertEquals(0, wasm.brOnCastNullStruct(undefined));
  assertEquals(1, wasm.brOnCastNullStruct(structSuperObj));
  assertEquals(1, wasm.brOnCastNullStruct(structSubObj));
  assertEquals(0, wasm.brOnCastNullStruct(arrayObj));
  assertEquals(0, wasm.brOnCastNullStruct(funcObj));
  assertEquals(0, wasm.brOnCastNullStruct(1));
  assertEquals(0, wasm.brOnCastNullStruct(jsObj));
  assertEquals(0, wasm.brOnCastNullStruct(strObj));

  assertEquals(1, wasm.brOnCastNullEq(null));
  assertEquals(0, wasm.brOnCastNullEq(undefined));
  assertEquals(1, wasm.brOnCastNullEq(structSuperObj));
  assertEquals(1, wasm.brOnCastNullEq(structSubObj));
  assertEquals(1, wasm.brOnCastNullEq(arrayObj));
  assertEquals(0, wasm.brOnCastNullEq(funcObj));
  assertEquals(1, wasm.brOnCastNullEq(1));
  assertEquals(0, wasm.brOnCastNullEq(jsObj));
  assertEquals(0, wasm.brOnCastNullEq(strObj));

  assertEquals(1, wasm.brOnCastNullString(null));
  assertEquals(0, wasm.brOnCastNullString(undefined));
  assertEquals(0, wasm.brOnCastNullString(structSuperObj));
  assertEquals(0, wasm.brOnCastNullString(structSubObj));
  assertEquals(0, wasm.brOnCastNullString(arrayObj));
  assertEquals(0, wasm.brOnCastNullString(funcObj));
  assertEquals(0, wasm.brOnCastNullString(1));
  assertEquals(0, wasm.brOnCastNullString(jsObj));
  assertEquals(1, wasm.brOnCastNullString(strObj));

  assertEquals(1, wasm.brOnCastNullAny(null));
  assertEquals(1, wasm.brOnCastNullAny(undefined));
  assertEquals(1, wasm.brOnCastNullAny(structSuperObj));
  assertEquals(1, wasm.brOnCastNullAny(structSubObj));
  assertEquals(1, wasm.brOnCastNullAny(arrayObj));
  assertEquals(1, wasm.brOnCastNullAny(funcObj));
  assertEquals(1, wasm.brOnCastNullAny(1));
  assertEquals(1, wasm.brOnCastNullAny(jsObj));
  assertEquals(1, wasm.brOnCastNullAny(strObj));

  assertEquals(1, wasm.brOnCastNullNone(null));
  assertEquals(0, wasm.brOnCastNullNone(undefined));
  assertEquals(0, wasm.brOnCastNullNone(structSuperObj));
  assertEquals(0, wasm.brOnCastNullNone(structSubObj));
  assertEquals(0, wasm.brOnCastNullNone(arrayObj));
  assertEquals(0, wasm.brOnCastNullNone(funcObj));
  assertEquals(0, wasm.brOnCastNullNone(1));
  assertEquals(0, wasm.brOnCastNullNone(jsObj));
  assertEquals(0, wasm.brOnCastNullNone(strObj));

  // br_on_cast_fail
  assertEquals(1, wasm.brOnCastFailStructSuper(null));
  assertEquals(1, wasm.brOnCastFailStructSuper(undefined));
  assertEquals(0, wasm.brOnCastFailStructSuper(structSuperObj));
  assertEquals(0, wasm.brOnCastFailStructSuper(structSubObj));
  assertEquals(1, wasm.brOnCastFailStructSuper(arrayObj));
  assertEquals(1, wasm.brOnCastFailStructSuper(funcObj));
  assertEquals(1, wasm.brOnCastFailStructSuper(1));
  assertEquals(1, wasm.brOnCastFailStructSuper(jsObj));
  assertEquals(1, wasm.brOnCastFailStructSuper(strObj));

  assertEquals(1, wasm.brOnCastFailStructSub(null));
  assertEquals(1, wasm.brOnCastFailStructSub(undefined));
  assertEquals(1, wasm.brOnCastFailStructSub(structSuperObj));
  assertEquals(0, wasm.brOnCastFailStructSub(structSubObj));
  assertEquals(1, wasm.brOnCastFailStructSub(arrayObj));
  assertEquals(1, wasm.brOnCastFailStructSub(funcObj));
  assertEquals(1, wasm.brOnCastFailStructSub(1));
  assertEquals(1, wasm.brOnCastFailStructSub(jsObj));
  assertEquals(1, wasm.brOnCastFailStructSub(strObj));

  assertEquals(1, wasm.brOnCastFailArray(null));
  assertEquals(1, wasm.brOnCastFailArray(undefined));
  assertEquals(1, wasm.brOnCastFailArray(structSuperObj));
  assertEquals(1, wasm.brOnCastFailArray(structSubObj));
  assertEquals(0, wasm.brOnCastFailArray(arrayObj));
  assertEquals(1, wasm.brOnCastFailArray(funcObj));
  assertEquals(1, wasm.brOnCastFailArray(1));
  assertEquals(1, wasm.brOnCastFailArray(jsObj));
  assertEquals(1, wasm.brOnCastFailArray(strObj));

  assertEquals(1, wasm.brOnCastFailI31(null));
  assertEquals(1, wasm.brOnCastFailI31(undefined));
  assertEquals(1, wasm.brOnCastFailI31(structSuperObj));
  assertEquals(1, wasm.brOnCastFailI31(structSubObj));
  assertEquals(1, wasm.brOnCastFailI31(arrayObj));
  assertEquals(1, wasm.brOnCastFailI31(funcObj));
  assertEquals(0, wasm.brOnCastFailI31(1));
  assertEquals(1, wasm.brOnCastFailI31(jsObj));
  assertEquals(1, wasm.brOnCastFailI31(strObj));

  assertEquals(1, wasm.brOnCastFailAnyArray(null));
  assertEquals(1, wasm.brOnCastFailAnyArray(undefined));
  assertEquals(1, wasm.brOnCastFailAnyArray(structSuperObj));
  assertEquals(1, wasm.brOnCastFailAnyArray(structSubObj));
  assertEquals(0, wasm.brOnCastFailAnyArray(arrayObj));
  assertEquals(1, wasm.brOnCastFailAnyArray(funcObj));
  assertEquals(1, wasm.brOnCastFailAnyArray(1));
  assertEquals(1, wasm.brOnCastFailAnyArray(jsObj));
  assertEquals(1, wasm.brOnCastFailAnyArray(strObj));

  assertEquals(1, wasm.brOnCastFailStruct(null));
  assertEquals(1, wasm.brOnCastFailStruct(undefined));
  assertEquals(0, wasm.brOnCastFailStruct(structSuperObj));
  assertEquals(0, wasm.brOnCastFailStruct(structSubObj));
  assertEquals(1, wasm.brOnCastFailStruct(arrayObj));
  assertEquals(1, wasm.brOnCastFailStruct(funcObj));
  assertEquals(1, wasm.brOnCastFailStruct(1));
  assertEquals(1, wasm.brOnCastFailStruct(jsObj));
  assertEquals(1, wasm.brOnCastFailStruct(strObj));

  assertEquals(1, wasm.brOnCastFailEq(null));
  assertEquals(1, wasm.brOnCastFailEq(undefined));
  assertEquals(0, wasm.brOnCastFailEq(structSuperObj));
  assertEquals(0, wasm.brOnCastFailEq(structSubObj));
  assertEquals(0, wasm.brOnCastFailEq(arrayObj));
  assertEquals(1, wasm.brOnCastFailEq(funcObj));
  assertEquals(0, wasm.brOnCastFailEq(1));
  assertEquals(1, wasm.brOnCastFailEq(jsObj));
  assertEquals(1, wasm.brOnCastFailEq(strObj));

  assertEquals(1, wasm.brOnCastFailString(null));
  assertEquals(1, wasm.brOnCastFailString(undefined));
  assertEquals(1, wasm.brOnCastFailString(structSuperObj));
  assertEquals(1, wasm.brOnCastFailString(structSubObj));
  assertEquals(1, wasm.brOnCastFailString(arrayObj));
  assertEquals(1, wasm.brOnCastFailString(funcObj));
  assertEquals(1, wasm.brOnCastFailString(1));
  assertEquals(1, wasm.brOnCastFailString(jsObj));
  assertEquals(0, wasm.brOnCastFailString(strObj));

  assertEquals(1, wasm.brOnCastFailAny(null));
  assertEquals(0, wasm.brOnCastFailAny(undefined));
  assertEquals(0, wasm.brOnCastFailAny(structSuperObj));
  assertEquals(0, wasm.brOnCastFailAny(structSubObj));
  assertEquals(0, wasm.brOnCastFailAny(arrayObj));
  assertEquals(0, wasm.brOnCastFailAny(funcObj));
  assertEquals(0, wasm.brOnCastFailAny(1));
  assertEquals(0, wasm.brOnCastFailAny(jsObj));
  assertEquals(0, wasm.brOnCastFailAny(strObj));

  assertEquals(1, wasm.brOnCastFailNone(null));
  assertEquals(1, wasm.brOnCastFailNone(undefined));
  assertEquals(1, wasm.brOnCastFailNone(structSuperObj));
  assertEquals(1, wasm.brOnCastFailNone(structSubObj));
  assertEquals(1, wasm.brOnCastFailNone(arrayObj));
  assertEquals(1, wasm.brOnCastFailNone(funcObj));
  assertEquals(1, wasm.brOnCastFailNone(1));
  assertEquals(1, wasm.brOnCastFailNone(jsObj));
  assertEquals(1, wasm.brOnCastFailNone(strObj));

  // br_on_cast_fail null
  assertEquals(0, wasm.brOnCastFailNullStructSuper(null));
  assertEquals(1, wasm.brOnCastFailNullStructSuper(undefined));
  assertEquals(0, wasm.brOnCastFailNullStructSuper(structSuperObj));
  assertEquals(0, wasm.brOnCastFailNullStructSuper(structSubObj));
  assertEquals(1, wasm.brOnCastFailNullStructSuper(arrayObj));
  assertEquals(1, wasm.brOnCastFailNullStructSuper(funcObj));
  assertEquals(1, wasm.brOnCastFailNullStructSuper(1));
  assertEquals(1, wasm.brOnCastFailNullStructSuper(jsObj));
  assertEquals(1, wasm.brOnCastFailNullStructSuper(strObj));

  assertEquals(0, wasm.brOnCastFailNullStructSub(null));
  assertEquals(1, wasm.brOnCastFailNullStructSub(undefined));
  assertEquals(1, wasm.brOnCastFailNullStructSub(structSuperObj));
  assertEquals(0, wasm.brOnCastFailNullStructSub(structSubObj));
  assertEquals(1, wasm.brOnCastFailNullStructSub(arrayObj));
  assertEquals(1, wasm.brOnCastFailNullStructSub(funcObj));
  assertEquals(1, wasm.brOnCastFailNullStructSub(1));
  assertEquals(1, wasm.brOnCastFailNullStructSub(jsObj));
  assertEquals(1, wasm.brOnCastFailNullStructSub(strObj));

  assertEquals(0, wasm.brOnCastFailNullArray(null));
  assertEquals(1, wasm.brOnCastFailNullArray(undefined));
  assertEquals(1, wasm.brOnCastFailNullArray(structSuperObj));
  assertEquals(1, wasm.brOnCastFailNullArray(structSubObj));
  assertEquals(0, wasm.brOnCastFailNullArray(arrayObj));
  assertEquals(1, wasm.brOnCastFailNullArray(funcObj));
  assertEquals(1, wasm.brOnCastFailNullArray(1));
  assertEquals(1, wasm.brOnCastFailNullArray(jsObj));
  assertEquals(1, wasm.brOnCastFailNullArray(strObj));

  assertEquals(0, wasm.brOnCastFailNullI31(null));
  assertEquals(1, wasm.brOnCastFailNullI31(undefined));
  assertEquals(1, wasm.brOnCastFailNullI31(structSuperObj));
  assertEquals(1, wasm.brOnCastFailNullI31(structSubObj));
  assertEquals(1, wasm.brOnCastFailNullI31(arrayObj));
  assertEquals(1, wasm.brOnCastFailNullI31(funcObj));
  assertEquals(0, wasm.brOnCastFailNullI31(1));
  assertEquals(1, wasm.brOnCastFailNullI31(jsObj));
  assertEquals(1, wasm.brOnCastFailNullI31(strObj));

  assertEquals(0, wasm.brOnCastFailNullAnyArray(null));
  assertEquals(1, wasm.brOnCastFailNullAnyArray(undefined));
  assertEquals(1, wasm.brOnCastFailNullAnyArray(structSuperObj));
  assertEquals(1, wasm.brOnCastFailNullAnyArray(structSubObj));
  assertEquals(0, wasm.brOnCastFailNullAnyArray(arrayObj));
  assertEquals(1, wasm.brOnCastFailNullAnyArray(funcObj));
  assertEquals(1, wasm.brOnCastFailNullAnyArray(1));
  assertEquals(1, wasm.brOnCastFailNullAnyArray(jsObj));
  assertEquals(1, wasm.brOnCastFailNullAnyArray(strObj));

  assertEquals(0, wasm.brOnCastFailNullStruct(null));
  assertEquals(1, wasm.brOnCastFailNullStruct(undefined));
  assertEquals(0, wasm.brOnCastFailNullStruct(structSuperObj));
  assertEquals(0, wasm.brOnCastFailNullStruct(structSubObj));
  assertEquals(1, wasm.brOnCastFailNullStruct(arrayObj));
  assertEquals(1, wasm.brOnCastFailNullStruct(funcObj));
  assertEquals(1, wasm.brOnCastFailNullStruct(1));
  assertEquals(1, wasm.brOnCastFailNullStruct(jsObj));
  assertEquals(1, wasm.brOnCastFailNullStruct(strObj));

  assertEquals(0, wasm.brOnCastFailNullEq(null));
  assertEquals(1, wasm.brOnCastFailNullEq(undefined));
  assertEquals(0, wasm.brOnCastFailNullEq(structSuperObj));
  assertEquals(0, wasm.brOnCastFailNullEq(structSubObj));
  assertEquals(0, wasm.brOnCastFailNullEq(arrayObj));
  assertEquals(1, wasm.brOnCastFailNullEq(funcObj));
  assertEquals(0, wasm.brOnCastFailNullEq(1));
  assertEquals(1, wasm.brOnCastFailNullEq(jsObj));
  assertEquals(1, wasm.brOnCastFailNullEq(strObj));

  assertEquals(0, wasm.brOnCastFailNullString(null));
  assertEquals(1, wasm.brOnCastFailNullString(undefined));
  assertEquals(1, wasm.brOnCastFailNullString(structSuperObj));
  assertEquals(1, wasm.brOnCastFailNullString(structSubObj));
  assertEquals(1, wasm.brOnCastFailNullString(arrayObj));
  assertEquals(1, wasm.brOnCastFailNullString(funcObj));
  assertEquals(1, wasm.brOnCastFailNullString(1));
  assertEquals(1, wasm.brOnCastFailNullString(jsObj));
  assertEquals(0, wasm.brOnCastFailNullString(strObj));

  assertEquals(0, wasm.brOnCastFailNullAny(null));
  assertEquals(0, wasm.brOnCastFailNullAny(undefined));
  assertEquals(0, wasm.brOnCastFailNullAny(structSuperObj));
  assertEquals(0, wasm.brOnCastFailNullAny(structSubObj));
  assertEquals(0, wasm.brOnCastFailNullAny(arrayObj));
  assertEquals(0, wasm.brOnCastFailNullAny(funcObj));
  assertEquals(0, wasm.brOnCastFailNullAny(1));
  assertEquals(0, wasm.brOnCastFailNullAny(jsObj));
  assertEquals(0, wasm.brOnCastFailNullAny(strObj));

  assertEquals(0, wasm.brOnCastFailNullNone(null));
  assertEquals(1, wasm.brOnCastFailNullNone(undefined));
  assertEquals(1, wasm.brOnCastFailNullNone(structSuperObj));
  assertEquals(1, wasm.brOnCastFailNullNone(structSubObj));
  assertEquals(1, wasm.brOnCastFailNullNone(arrayObj));
  assertEquals(1, wasm.brOnCastFailNullNone(funcObj));
  assertEquals(1, wasm.brOnCastFailNullNone(1));
  assertEquals(1, wasm.brOnCastFailNullNone(jsObj));
  assertEquals(1, wasm.brOnCastFailNullNone(strObj));
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/wasm/gc-casts-invalid.js                                           0000664 0000000 0000000 00000016310 14746647661 0023153 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-exnref

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function TestRefTestInvalid() {
  print(arguments.callee.name);
  let struct = 0;
  let array = 1;
  let sig = 2;
  let types = [
    // source value type |target heap type
    [kWasmI32,            kAnyRefCode],
    [kWasmNullExternRef,  struct],
    [wasmRefType(struct), kNullFuncRefCode],
    [wasmRefType(array),  kFuncRefCode],
    [wasmRefType(struct), sig],
    [wasmRefType(sig),    struct],
    [wasmRefType(sig),    kExternRefCode],
    [kWasmAnyRef,         kExternRefCode],
    [kWasmAnyRef,         kFuncRefCode],
    [kWasmAnyRef,         kExnRefCode],
    [wasmRefType(sig),    kExnRefCode],
    [kWasmNullExternRef,  kExnRefCode],
    [wasmRefType(array),  kNullExnRefCode],
    [kWasmNullFuncRef,    kNullExnRefCode],
  ];
  let casts = [
    kExprRefTest,
    kExprRefTestNull,
    kExprRefCast,
    kExprRefCastNull,
  ];

  for (let [source_type, target_type_imm] of types) {
    for (let cast of casts) {
      let builder = new WasmModuleBuilder();
      assertEquals(struct, builder.addStruct([makeField(kWasmI32, true)]));
      assertEquals(array, builder.addArray(kWasmI32));
      assertEquals(sig, builder.addType(makeSig([kWasmI32], [])));
      builder.addFunction('refTest', makeSig([source_type], []))
      .addBody([
        kExprLocalGet, 0,
        kGCPrefix, cast, target_type_imm,
        kExprDrop,
      ]);

      assertThrows(() => builder.instantiate(),
                  WebAssembly.CompileError,
                  /has to be in the same reference type hierarchy/);
    }
  }
})();

(function TestBrOnCastExpectsNonNull() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct = builder.addStruct([makeField(kWasmI32, true)]);
  builder.addFunction('fct', makeSig([wasmRefNullType(struct)], []))
  .addBody([
    kExprBlock, kAnyRefCode,
      kExprLocalGet, 0,
      ...wasmBrOnCast(0, wasmRefType(struct), wasmRefType(struct)),
      kExprDrop,
      kExprReturn,
    kExprEnd,
    kExprDrop,
    kExprReturn,
  ]);

  assertThrows(() => builder.instantiate(),
    WebAssembly.CompileError,
    /br_on_cast\[0\] expected type \(ref 0\), found local.get of type \(ref null 0\)/);
})();

(function TestBrOnCastExpectsNull() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct = builder.addStruct([makeField(kWasmI32, true)]);
  builder.addFunction('fct', makeSig([wasmRefType(struct)], []))
  .addBody([
    kExprBlock, kAnyRefCode,
      kExprLocalGet, 0,
      ...wasmBrOnCast(0, wasmRefNullType(struct), wasmRefNullType(struct)),
      kExprDrop,
      kExprReturn,
    kExprEnd,
    kExprDrop,
    kExprReturn,
  ]);
  // Specifying a nullable source and providing a non-nullable value is not an
  // error (as non-nullable values can be cast implicitly to nullable).
  builder.instantiate();
})();

(function TestBrOnCastNonNullToNull() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct = builder.addStruct([makeField(kWasmI32, true)]);
  builder.addFunction('fct', makeSig([wasmRefType(struct)], []))
  .addBody([
    kExprBlock, kAnyRefCode,
      kExprLocalGet, 0,
      ...wasmBrOnCast(0, wasmRefType(struct), wasmRefNullType(struct)),
      kExprDrop,
      kExprReturn,
    kExprEnd,
    kExprDrop,
    kExprReturn,
  ]);
  // Even though the source is non-nullable, if the br_on_cast is set to produce
  // a nullable value on cast, the label target must be nullable as well.
  assertThrows(() => builder.instantiate(),
    WebAssembly.CompileError,
    /invalid types for br_on_cast: \(ref null 0\) is not a subtype of \(ref 0\)/);
})();

(function TestBrOnCastInvalidFlags() {
  print(arguments.callee.name);
  for (let value of [-1, 8, 127, 255, 256]) {
    let builder = new WasmModuleBuilder();
    let struct = builder.addStruct([makeField(kWasmI32, true)]);
    builder.addFunction('fct', makeSig([wasmRefType(struct)], []))
    .addBody([
      kExprBlock, kAnyRefCode,
        kExprLocalGet, 0,
        kGCPrefix, kExprBrOnCast,
          ...wasmUnsignedLeb(value), 0, kAnyRefCode, struct,
        kExprDrop,
        kExprReturn,
      kExprEnd,
      kExprDrop,
      kExprReturn,
    ]);
    assertThrows(() => builder.instantiate(),
      WebAssembly.CompileError,
      /invalid br_on_cast flags [0-9]+/);
  }
})();

(function TestBrOnCastSourceTypeUpcast() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct = builder.addStruct([makeField(kWasmI32, true)]);

  builder.addFunction('fct', makeSig([wasmRefType(struct)], []))
  .addBody([
    kExprBlock, kAnyRefCode,
      kExprLocalGet, 0,
      ...wasmBrOnCast(0, wasmRefType(kWasmAnyRef), wasmRefType(struct)),
      kGCPrefix, kExprStructGet, struct, 0,
      kExprDrop,
      kExprReturn,
    kExprEnd,
    kExprDrop,
    kExprReturn,
  ]);
  // While the value stack type is (ref struct), the source type in the
  // br_on_cast is specified as (ref any), so the fallthrough type becomes
  // the less specific (ref any).
  assertThrows(() => builder.instantiate(),
    WebAssembly.CompileError,
    /struct.get\[0\] expected type \(ref null 0\), found local.get of type \(ref any\)/);
})();

(function TestBrOnCastFailSourceTypeUpcast() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct = builder.addStruct([makeField(kWasmI32, true)]);
  let structRefSig =
      builder.addType(makeSig([], [wasmRefType(struct)]));

  builder.addFunction('fct', makeSig([wasmRefType(struct)], []))
  .addBody([
    kExprBlock, structRefSig,
      kExprLocalGet, 0,
      ...wasmBrOnCastFail(0, wasmRefNullType(kWasmAnyRef), wasmRefType(struct)),
      kExprDrop,
      kExprReturn,
    kExprEnd,
    kExprDrop,
    kExprReturn,
  ]);
  // While the value stack type is (ref struct), the source type in the
  // br_on_cast_fail is specified as (ref any), so the branch type becomes
  // the less specific (ref any).
  assertThrows(() => builder.instantiate(),
    WebAssembly.CompileError,
    /type error in branch\[0\] \(expected \(ref 0\), got anyref\)/);
})();

// Test that validation and code generation works fine in unreachable paths.
(function TestBrOnCastUnreachable() {
  print(arguments.callee.name);

  let casts = [
    wasmBrOnCastFail(
      0, wasmRefNullType(kWasmAnyRef), wasmRefNullType(kWasmI31Ref)),
    wasmBrOnCast(0, wasmRefNullType(kWasmAnyRef), wasmRefNullType(kWasmI31Ref)),
    wasmBrOnCastFail(0, wasmRefNullType(kWasmAnyRef), wasmRefType(kWasmI31Ref)),
    wasmBrOnCast(0, wasmRefNullType(kWasmAnyRef), wasmRefType(kWasmI31Ref)),
  ];

  for (let brOnCast of casts) {
    let builder = new WasmModuleBuilder();

    builder.addFunction(`brOnCastUnreachable`,
                        makeSig([kWasmExternRef], []))
    .addBody([
      kExprBlock, kAnyRefCode,
        kExprLocalGet, 0,
        kGCPrefix, kExprAnyConvertExtern,
        kExprUnreachable,
        ...brOnCast,
        kExprReturn,
      kExprEnd,
      kExprDrop,
    ]).exportFunc();

    let wasm = builder.instantiate().exports;
    assertTraps(kTrapUnreachable, () => wasm.brOnCastUnreachable());
  }
})();
                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/wasm/gc-casts-subtypes.js                                          0000664 0000000 0000000 00000107223 14746647661 0023407 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-type-reflection

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

// Test casting null from one type to another using ref.test & ref.cast.
(function RefCastFromNull() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.startRecGroup();
  let structSuper = builder.addStruct([makeField(kWasmI32, true)]);
  builder.endRecGroup();
  builder.startRecGroup();
  let structSub = builder.addStruct([makeField(kWasmI32, true)], structSuper);
  builder.endRecGroup();
  builder.startRecGroup();
  let array = builder.addArray(kWasmI32);
  builder.endRecGroup();

  // Note: Casting between unrelated types is allowed as long as the types
  // belong to the same type hierarchy (func / any / extern). In these cases the
  // check will always fail.
  // For br_on_cast, only downcasts are allowed!
  let tests = [
    [kWasmAnyRef, kWasmAnyRef, 'AnyToAny', true],
    [kWasmFuncRef, kWasmFuncRef, 'FuncToFunc', true],
    [kWasmExternRef, kWasmExternRef, 'ExternToExtern', true],
    [kWasmNullFuncRef, kWasmNullFuncRef, 'NullFuncToNullFunc', true],
    [kWasmNullExternRef, kWasmNullExternRef, 'NullExternToNullExtern', true],
    [structSub, array, 'StructToArray', false],
    [kWasmFuncRef, kWasmNullFuncRef, 'FuncToNullFunc', true],
    [kWasmNullFuncRef, kWasmFuncRef, 'NullFuncToFunc', false],
    [kWasmExternRef, kWasmNullExternRef, 'ExternToNullExtern', true],
    [kWasmNullExternRef, kWasmExternRef, 'NullExternToExtern', false],
    [kWasmNullRef, kWasmAnyRef, 'NullToAny', false],
    [kWasmI31Ref, structSub, 'I31ToStruct', false],
    [kWasmEqRef, kWasmI31Ref, 'EqToI31', true],
    [structSuper, structSub, 'StructSuperToStructSub', true],
    [structSub, structSuper, 'StructSubToStructSuper', false],
  ];

  for (let [sourceType, targetType, testName, isDowncast] of tests) {
    builder.addFunction('testNull' + testName, makeSig([], [kWasmI32]))
    .addLocals(wasmRefNullType(sourceType), 1)
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprRefTest, targetType & kLeb128Mask,
    ]).exportFunc();

    builder.addFunction('castNull' + testName, makeSig([], []))
    .addLocals(wasmRefNullType(sourceType), 1)
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprRefCast, targetType & kLeb128Mask,
      kExprDrop,
    ]).exportFunc();

    if (isDowncast) {
      builder.addFunction('branchNull' + testName, makeSig([], [kWasmI32]))
      .addLocals(wasmRefNullType(sourceType), 1)
      .addBody([
        kExprBlock, kWasmRef, targetType & kLeb128Mask,
          kExprLocalGet, 0,
          ...wasmBrOnCast(
              0, wasmRefNullType(sourceType), wasmRefType(targetType)),
          kExprI32Const, 0,
          kExprReturn,
        kExprEnd,
        kExprDrop,
        kExprI32Const, 1,
        kExprReturn,
      ]).exportFunc();

      builder.addFunction('branchFailNull' + testName, makeSig([], [kWasmI32]))
      .addLocals(wasmRefNullType(sourceType), 1)
      .addBody([
        kExprBlock, kWasmRef, sourceType & kLeb128Mask,
          kExprLocalGet, 0,
          ...wasmBrOnCastFail(
              0, wasmRefNullType(sourceType), wasmRefNullType(targetType)),
          kExprI32Const, 0,
          kExprReturn,
        kExprEnd,
        kExprDrop,
        kExprI32Const, 1,
        kExprReturn,
      ]).exportFunc();
    }
  }

  let instance = builder.instantiate();
  let wasm = instance.exports;

  for (let [sourceType, targetType, testName, isDowncast] of tests) {
    print(testName);
    assertEquals(0, wasm['testNull' + testName]());
    assertTraps(kTrapIllegalCast, wasm['castNull' + testName]);
    if (isDowncast) {
      assertEquals(0, wasm['branchNull' + testName]());
      assertEquals(0, wasm['branchFailNull' + testName]());
    }
  }
})();

(function RefTestFuncRef() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sigSuper = builder.addType(makeSig([kWasmI32], []), kNoSuperType, false);
  let sigSub = builder.addType(makeSig([kWasmI32], []), sigSuper);

  builder.addFunction('fctSuper', sigSuper).addBody([]).exportFunc();
  builder.addFunction('fctSub', sigSub).addBody([]).exportFunc();
  builder.addFunction('testFromFuncRef',
      makeSig([kWasmFuncRef], [kWasmI32, kWasmI32, kWasmI32, kWasmI32]))
    .addBody([
      kExprLocalGet, 0, kGCPrefix, kExprRefTest, kFuncRefCode,
      kExprLocalGet, 0, kGCPrefix, kExprRefTest, kNullFuncRefCode,
      kExprLocalGet, 0, kGCPrefix, kExprRefTest, sigSuper,
      kExprLocalGet, 0, kGCPrefix, kExprRefTest, sigSub,
    ]).exportFunc();
  builder.addFunction('testNullFromFuncRef',
      makeSig([kWasmFuncRef], [kWasmI32, kWasmI32, kWasmI32, kWasmI32]))
    .addBody([
      kExprLocalGet, 0, kGCPrefix, kExprRefTestNull, kFuncRefCode,
      kExprLocalGet, 0, kGCPrefix, kExprRefTestNull, kNullFuncRefCode,
      kExprLocalGet, 0, kGCPrefix, kExprRefTestNull, sigSuper,
      kExprLocalGet, 0, kGCPrefix, kExprRefTestNull, sigSub,
    ]).exportFunc();

  let instance = builder.instantiate();
  let wasm = instance.exports;
  let jsFct = new WebAssembly.Function(
      {parameters:['i32', 'i32'], results: ['i32']},
      function mul(a, b) { return a * b; });
  assertEquals([0, 0, 0, 0], wasm.testFromFuncRef(null));
  assertEquals([1, 0, 0, 0], wasm.testFromFuncRef(jsFct));
  assertEquals([1, 0, 1, 0], wasm.testFromFuncRef(wasm.fctSuper));
  assertEquals([1, 0, 1, 1], wasm.testFromFuncRef(wasm.fctSub));

  assertEquals([1, 1, 1, 1], wasm.testNullFromFuncRef(null));
  assertEquals([1, 0, 0, 0], wasm.testNullFromFuncRef(jsFct));
  assertEquals([1, 0, 1, 0], wasm.testNullFromFuncRef(wasm.fctSuper));
  assertEquals([1, 0, 1, 1], wasm.testNullFromFuncRef(wasm.fctSub));
})();

(function RefCastFuncRef() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sigSuper = builder.addType(makeSig([kWasmI32], []), kNoSuperType, false);
  let sigSub = builder.addType(makeSig([kWasmI32], []), sigSuper);

  builder.addFunction('fctSuper', sigSuper).addBody([]).exportFunc();
  builder.addFunction('fctSub', sigSub).addBody([]).exportFunc();
  builder.addFunction('castToFuncRef', makeSig([kWasmFuncRef], [kWasmFuncRef]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprRefCast, kFuncRefCode])
    .exportFunc();
  builder.addFunction('castToNullFuncRef',
                      makeSig([kWasmFuncRef], [kWasmFuncRef]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprRefCast, kNullFuncRefCode])
    .exportFunc();
  builder.addFunction('castToSuper', makeSig([kWasmFuncRef], [kWasmFuncRef]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprRefCast, sigSuper])
    .exportFunc();
  builder.addFunction('castToSub', makeSig([kWasmFuncRef], [kWasmFuncRef]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprRefCast, sigSub])
    .exportFunc();

  builder.addFunction('castNullToFuncRef',
                      makeSig([kWasmFuncRef], [kWasmFuncRef]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprRefCastNull, kFuncRefCode])
    .exportFunc();
  builder.addFunction('castNullToNullFuncRef',
                      makeSig([kWasmFuncRef], [kWasmFuncRef]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprRefCastNull, kNullFuncRefCode])
    .exportFunc();
  builder.addFunction('castNullToSuper',
                      makeSig([kWasmFuncRef], [kWasmFuncRef]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprRefCastNull, sigSuper])
    .exportFunc();
  builder.addFunction('castNullToSub', makeSig([kWasmFuncRef], [kWasmFuncRef]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprRefCastNull, sigSub])
    .exportFunc();

  let instance = builder.instantiate();
  let wasm = instance.exports;
  let jsFct = new WebAssembly.Function(
      {parameters:['i32', 'i32'], results: ['i32']},
      function mul(a, b) { return a * b; });

  assertTraps(kTrapIllegalCast, () => wasm.castToFuncRef(null));
  assertSame(jsFct, wasm.castToFuncRef(jsFct));
  assertSame(wasm.fctSuper, wasm.castToFuncRef(wasm.fctSuper));
  assertSame(wasm.fctSub, wasm.castToFuncRef(wasm.fctSub));

  assertSame(null, wasm.castNullToFuncRef(null));
  assertSame(jsFct, wasm.castNullToFuncRef(jsFct));
  assertSame(wasm.fctSuper, wasm.castNullToFuncRef(wasm.fctSuper));
  assertSame(wasm.fctSub, wasm.castNullToFuncRef(wasm.fctSub));

  assertSame(null, wasm.castNullToNullFuncRef(null));
  assertTraps(kTrapIllegalCast, () => wasm.castNullToNullFuncRef(jsFct));
  assertTraps(kTrapIllegalCast,
              () => wasm.castNullToNullFuncRef(wasm.fctSuper));
  assertTraps(kTrapIllegalCast, () => wasm.castNullToNullFuncRef(wasm.fctSub));

  assertTraps(kTrapIllegalCast, () => wasm.castToSuper(null));
  assertTraps(kTrapIllegalCast, () => wasm.castToSuper(jsFct));
  assertSame(wasm.fctSuper, wasm.castToSuper(wasm.fctSuper));
  assertSame(wasm.fctSub, wasm.castToSuper(wasm.fctSub));

  assertSame(null, wasm.castNullToSuper(null));
  assertTraps(kTrapIllegalCast, () => wasm.castNullToSuper(jsFct));
  assertSame(wasm.fctSuper, wasm.castNullToSuper(wasm.fctSuper));
  assertSame(wasm.fctSub, wasm.castNullToSuper(wasm.fctSub));

  assertTraps(kTrapIllegalCast, () => wasm.castToSub(null));
  assertTraps(kTrapIllegalCast, () => wasm.castToSub(jsFct));
  assertTraps(kTrapIllegalCast, () => wasm.castToSub(wasm.fctSuper));
  assertSame(wasm.fctSub, wasm.castToSub(wasm.fctSub));

  assertSame(null, wasm.castNullToSub(null));
  assertTraps(kTrapIllegalCast, () => wasm.castNullToSub(jsFct));
  assertTraps(kTrapIllegalCast, () => wasm.castNullToSub(wasm.fctSuper));
  assertSame(wasm.fctSub, wasm.castNullToSub(wasm.fctSub));
})();

(function BrOnCastFuncRef() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sigSuper = builder.addType(makeSig([kWasmI32], []), kNoSuperType, false);
  let sigSub = builder.addType(makeSig([kWasmI32], []), sigSuper);

  builder.addFunction('fctSuper', sigSuper).addBody([]).exportFunc();
  builder.addFunction('fctSub', sigSub).addBody([]).exportFunc();
  let targets = {
    "funcref": kWasmFuncRef,
    "nullfuncref": kWasmNullFuncRef,
    "super": sigSuper,
    "sub": sigSub
  };
  for (const [name, target_type] of Object.entries(targets)) {
    builder.addFunction(`brOnCast_${name}`,
      makeSig([kWasmFuncRef], [kWasmI32]))
    .addBody([
      kExprBlock, kWasmRef, target_type & kLeb128Mask,
        kExprLocalGet, 0,
        ...wasmBrOnCast(
            0, wasmRefNullType(kWasmFuncRef), wasmRefType(target_type)),
        kExprI32Const, 0,
        kExprReturn,
      kExprEnd,
      kExprDrop,
      kExprI32Const, 1,
      kExprReturn,
    ]).exportFunc();

    builder.addFunction(`brOnCastNull_${name}`,
      makeSig([kWasmFuncRef], [kWasmI32]))
    .addBody([
      kExprBlock, kWasmRefNull, target_type & kLeb128Mask,
        kExprLocalGet, 0,
        ...wasmBrOnCast(
            0, wasmRefNullType(kWasmFuncRef), wasmRefNullType(target_type)),
        kExprI32Const, 0,
        kExprReturn,
      kExprEnd,
      kExprDrop,
      kExprI32Const, 1,
      kExprReturn,
    ]).exportFunc();

    builder.addFunction(`brOnCastFail_${name}`,
      makeSig([kWasmFuncRef], [kWasmI32]))
    .addBody([
      kExprBlock, kFuncRefCode,
        kExprLocalGet, 0,
        ...wasmBrOnCastFail(
            0, wasmRefNullType(kWasmFuncRef), wasmRefType(target_type)),
        kExprI32Const, 0,
        kExprReturn,
      kExprEnd,
      kExprDrop,
      kExprI32Const, 1,
      kExprReturn,
    ]).exportFunc();

    builder.addFunction(`brOnCastFailNull_${name}`,
      makeSig([kWasmFuncRef], [kWasmI32]))
    .addBody([
      kExprBlock, kWasmRef, kFuncRefCode,
        kExprLocalGet, 0,
        ...wasmBrOnCastFail(
          0, wasmRefNullType(kWasmFuncRef), wasmRefNullType(target_type)),
        kExprI32Const, 0,
        kExprReturn,
      kExprEnd,
      kExprDrop,
      kExprI32Const, 1,
      kExprReturn,
    ]).exportFunc();
  }

  let instance = builder.instantiate();
  let wasm = instance.exports;
  let jsFct = new WebAssembly.Function(
      {parameters:['i32', 'i32'], results: ['i32']},
      function mul(a, b) { return a * b; });
  assertEquals(0, wasm.brOnCast_funcref(null));
  assertEquals(0, wasm.brOnCast_nullfuncref(null));
  assertEquals(0, wasm.brOnCast_super(null));
  assertEquals(0, wasm.brOnCast_sub(null));

  assertEquals(1, wasm.brOnCast_funcref(jsFct));
  assertEquals(0, wasm.brOnCast_nullfuncref(jsFct));
  assertEquals(0, wasm.brOnCast_super(jsFct));
  assertEquals(0, wasm.brOnCast_sub(jsFct));

  assertEquals(1, wasm.brOnCast_funcref(wasm.fctSuper));
  assertEquals(0, wasm.brOnCast_nullfuncref(wasm.fctSuper));
  assertEquals(1, wasm.brOnCast_super(wasm.fctSuper));
  assertEquals(0, wasm.brOnCast_sub(wasm.fctSuper));

  assertEquals(1, wasm.brOnCast_funcref(wasm.fctSub));
  assertEquals(0, wasm.brOnCast_nullfuncref(wasm.fctSub));
  assertEquals(1, wasm.brOnCast_super(wasm.fctSub));
  assertEquals(1, wasm.brOnCast_sub(wasm.fctSub));

  // br_on_cast null
  assertEquals(1, wasm.brOnCastNull_funcref(null));
  assertEquals(1, wasm.brOnCastNull_nullfuncref(null));
  assertEquals(1, wasm.brOnCastNull_super(null));
  assertEquals(1, wasm.brOnCastNull_sub(null));

  assertEquals(1, wasm.brOnCastNull_funcref(jsFct));
  assertEquals(0, wasm.brOnCastNull_nullfuncref(jsFct));
  assertEquals(0, wasm.brOnCastNull_super(jsFct));
  assertEquals(0, wasm.brOnCastNull_sub(jsFct));

  assertEquals(1, wasm.brOnCastNull_funcref(wasm.fctSuper));
  assertEquals(0, wasm.brOnCastNull_nullfuncref(wasm.fctSuper));
  assertEquals(1, wasm.brOnCastNull_super(wasm.fctSuper));
  assertEquals(0, wasm.brOnCastNull_sub(wasm.fctSuper));

  assertEquals(1, wasm.brOnCastNull_funcref(wasm.fctSub));
  assertEquals(0, wasm.brOnCastNull_nullfuncref(wasm.fctSub));
  assertEquals(1, wasm.brOnCastNull_super(wasm.fctSub));
  assertEquals(1, wasm.brOnCastNull_sub(wasm.fctSub));

  // br_on_cast_fail
  assertEquals(1, wasm.brOnCastFail_funcref(null));
  assertEquals(1, wasm.brOnCastFail_nullfuncref(null));
  assertEquals(1, wasm.brOnCastFail_super(null));
  assertEquals(1, wasm.brOnCastFail_sub(null));

  assertEquals(0, wasm.brOnCastFail_funcref(jsFct));
  assertEquals(1, wasm.brOnCastFail_nullfuncref(jsFct));
  assertEquals(1, wasm.brOnCastFail_super(jsFct));
  assertEquals(1, wasm.brOnCastFail_sub(jsFct));

  assertEquals(0, wasm.brOnCastFail_funcref(wasm.fctSuper));
  assertEquals(1, wasm.brOnCastFail_nullfuncref(wasm.fctSuper));
  assertEquals(0, wasm.brOnCastFail_super(wasm.fctSuper));
  assertEquals(1, wasm.brOnCastFail_sub(wasm.fctSuper));

  assertEquals(0, wasm.brOnCastFail_funcref(wasm.fctSub));
  assertEquals(1, wasm.brOnCastFail_nullfuncref(wasm.fctSub));
  assertEquals(0, wasm.brOnCastFail_super(wasm.fctSub));
  assertEquals(0, wasm.brOnCastFail_sub(wasm.fctSub));

  // br_on_cast_fail null
  assertEquals(0, wasm.brOnCastFailNull_funcref(null));
  assertEquals(0, wasm.brOnCastFailNull_nullfuncref(null));
  assertEquals(0, wasm.brOnCastFailNull_super(null));
  assertEquals(0, wasm.brOnCastFailNull_sub(null));

  assertEquals(0, wasm.brOnCastFailNull_funcref(jsFct));
  assertEquals(1, wasm.brOnCastFailNull_nullfuncref(jsFct));
  assertEquals(1, wasm.brOnCastFailNull_super(jsFct));
  assertEquals(1, wasm.brOnCastFailNull_sub(jsFct));

  assertEquals(0, wasm.brOnCastFailNull_funcref(wasm.fctSuper));
  assertEquals(1, wasm.brOnCastFailNull_nullfuncref(wasm.fctSuper));
  assertEquals(0, wasm.brOnCastFailNull_super(wasm.fctSuper));
  assertEquals(1, wasm.brOnCastFailNull_sub(wasm.fctSuper));

  assertEquals(0, wasm.brOnCastFailNull_funcref(wasm.fctSub));
  assertEquals(1, wasm.brOnCastFailNull_nullfuncref(wasm.fctSub));
  assertEquals(0, wasm.brOnCastFailNull_super(wasm.fctSub));
  assertEquals(0, wasm.brOnCastFailNull_sub(wasm.fctSub));
})();

(function RefTestExternRef() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  builder.addFunction('testExternRef',
      makeSig([kWasmExternRef], [kWasmI32, kWasmI32]))
    .addBody([
      kExprLocalGet, 0, kGCPrefix, kExprRefTest, kExternRefCode,
      kExprLocalGet, 0, kGCPrefix, kExprRefTest, kNullExternRefCode,
    ]).exportFunc();

  builder.addFunction('testNullExternRef',
      makeSig([kWasmExternRef], [kWasmI32, kWasmI32]))
    .addBody([
      kExprLocalGet, 0, kGCPrefix, kExprRefTestNull, kExternRefCode,
      kExprLocalGet, 0, kGCPrefix, kExprRefTestNull, kNullExternRefCode,
    ]).exportFunc();

  let instance = builder.instantiate();
  let wasm = instance.exports;
  assertEquals([0, 0], wasm.testExternRef(null));
  assertEquals([1, 0], wasm.testExternRef(undefined));
  assertEquals([1, 0], wasm.testExternRef(1));
  assertEquals([1, 0], wasm.testExternRef({}));
  assertEquals([1, 0], wasm.testExternRef(wasm.testExternRef));

  assertEquals([1, 1], wasm.testNullExternRef(null));
  assertEquals([1, 0], wasm.testNullExternRef(undefined));
  assertEquals([1, 0], wasm.testNullExternRef(1));
  assertEquals([1, 0], wasm.testNullExternRef({}));
  assertEquals([1, 0], wasm.testNullExternRef(wasm.testExternRef));
})();

(function RefCastExternRef() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  builder.addFunction('castToExternRef',
      makeSig([kWasmExternRef], [kWasmExternRef]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprRefCast, kExternRefCode])
    .exportFunc();
  builder.addFunction('castToNullExternRef',
    makeSig([kWasmExternRef], [kWasmExternRef]))
  .addBody([kExprLocalGet, 0, kGCPrefix, kExprRefCast, kNullExternRefCode])
  .exportFunc();
  builder.addFunction('castNullToExternRef',
    makeSig([kWasmExternRef], [kWasmExternRef]))
  .addBody([kExprLocalGet, 0, kGCPrefix, kExprRefCastNull, kExternRefCode])
  .exportFunc();
  builder.addFunction('castNullToNullExternRef',
    makeSig([kWasmExternRef], [kWasmExternRef]))
  .addBody([kExprLocalGet, 0, kGCPrefix, kExprRefCastNull, kNullExternRefCode])
  .exportFunc();

  let instance = builder.instantiate();
  let wasm = instance.exports;

  assertTraps(kTrapIllegalCast, () => wasm.castToExternRef(null));
  assertEquals(undefined, wasm.castToExternRef(undefined));
  assertEquals(1, wasm.castToExternRef(1));
  let obj = {};
  assertSame(obj, wasm.castToExternRef(obj));
  assertSame(wasm.castToExternRef, wasm.castToExternRef(wasm.castToExternRef));

  assertTraps(kTrapIllegalCast, () => wasm.castToNullExternRef(null));
  assertTraps(kTrapIllegalCast, () => wasm.castToNullExternRef(undefined));
  assertTraps(kTrapIllegalCast, () => wasm.castToNullExternRef(1));
  assertTraps(kTrapIllegalCast, () => wasm.castToNullExternRef(obj));
  assertTraps(kTrapIllegalCast,
              () => wasm.castToNullExternRef(wasm.castToExternRef));

  assertSame(null, wasm.castNullToExternRef(null));
  assertEquals(undefined, wasm.castNullToExternRef(undefined));
  assertEquals(1, wasm.castNullToExternRef(1));
  assertSame(obj, wasm.castNullToExternRef(obj));
  assertSame(wasm.castToExternRef,
             wasm.castNullToExternRef(wasm.castToExternRef));

  assertSame(null, wasm.castNullToNullExternRef(null));
  assertTraps(kTrapIllegalCast, () => wasm.castNullToNullExternRef(undefined));
  assertTraps(kTrapIllegalCast, () => wasm.castNullToNullExternRef(1));
  assertTraps(kTrapIllegalCast, () => wasm.castNullToNullExternRef(obj));
  assertTraps(kTrapIllegalCast,
              () => wasm.castNullToNullExternRef(wasm.castToExternRef));
})();

(function BrOnCastExternRef() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  builder.addFunction('castToExternRef',
    makeSig([kWasmExternRef], [kWasmI32]))
  .addBody([
    kExprBlock, kWasmRef, kExternRefCode,
      kExprLocalGet, 0,
      ...wasmBrOnCast(
          0, wasmRefNullType(kWasmExternRef), wasmRefType(kWasmExternRef)),
      kExprI32Const, 0,
      kExprReturn,
    kExprEnd,
    kExprDrop,
    kExprI32Const, 1,
    kExprReturn,
  ])
  .exportFunc();
  builder.addFunction('castToNullExternRef',
    makeSig([kWasmExternRef], [kWasmI32]))
  .addBody([
    kExprBlock, kWasmRef, kNullExternRefCode,
      kExprLocalGet, 0,
      ...wasmBrOnCast(
          0, wasmRefNullType(kWasmExternRef), wasmRefType(kWasmNullExternRef)),
      kExprI32Const, 0,
      kExprReturn,
    kExprEnd,
    kExprDrop,
    kExprI32Const, 1,
    kExprReturn,
  ])
  .exportFunc();

  builder.addFunction('castNullToExternRef',
    makeSig([kWasmExternRef], [kWasmI32]))
  .addBody([
    kExprBlock, kWasmRefNull, kExternRefCode,
      kExprLocalGet, 0,
      ...wasmBrOnCast(0,
          wasmRefNullType(kWasmExternRef), wasmRefNullType(kWasmExternRef)),
      kExprI32Const, 0,
      kExprReturn,
    kExprEnd,
    kExprDrop,
    kExprI32Const, 1,
    kExprReturn,
  ])
  .exportFunc();
  builder.addFunction('castNullToNullExternRef',
    makeSig([kWasmExternRef], [kWasmI32]))
  .addBody([
    kExprBlock, kWasmRefNull, kNullExternRefCode,
      kExprLocalGet, 0,
      ...wasmBrOnCast(0,
          wasmRefNullType(kWasmExternRef), wasmRefNullType(kWasmNullExternRef)),
      kExprI32Const, 0,
      kExprReturn,
    kExprEnd,
    kExprDrop,
    kExprI32Const, 1,
    kExprReturn,
  ])
  .exportFunc();

  builder.addFunction('castFailToExternRef',
    makeSig([kWasmExternRef], [kWasmI32]))
  .addBody([
    kExprBlock, kWasmRefNull, kExternRefCode,
      kExprLocalGet, 0,
      ...wasmBrOnCastFail(0,
          wasmRefNullType(kWasmExternRef), wasmRefType(kWasmExternRef)),
      kExprI32Const, 0,
      kExprReturn,
    kExprEnd,
    kExprDrop,
    kExprI32Const, 1,
    kExprReturn,
  ])
  .exportFunc();
  builder.addFunction('castFailToNullExternRef',
    makeSig([kWasmExternRef], [kWasmI32]))
  .addBody([
    kExprBlock, kWasmRefNull, kExternRefCode,
      kExprLocalGet, 0,
      ...wasmBrOnCastFail(0,
          wasmRefNullType(kWasmExternRef), wasmRefType(kWasmNullExternRef)),
      kExprI32Const, 0,
      kExprReturn,
    kExprEnd,
    kExprDrop,
    kExprI32Const, 1,
    kExprReturn,
  ])
  .exportFunc();

  builder.addFunction('castFailNullToExternRef',
    makeSig([kWasmExternRef], [kWasmI32]))
  .addBody([
    kExprBlock, kWasmRef, kExternRefCode,
      kExprLocalGet, 0,
      ...wasmBrOnCastFail(0,
          wasmRefNullType(kWasmExternRef), wasmRefNullType(kWasmExternRef)),
      kExprI32Const, 0,
      kExprReturn,
    kExprEnd,
    kExprDrop,
    kExprI32Const, 1,
    kExprReturn,
  ])
  .exportFunc();
  builder.addFunction('castFailNullToNullExternRef',
    makeSig([kWasmExternRef], [kWasmI32]))
  .addBody([
    kExprBlock, kWasmRef, kExternRefCode,
      kExprLocalGet, 0,
      ...wasmBrOnCastFail(0,
          wasmRefNullType(kWasmExternRef), wasmRefNullType(kWasmNullExternRef)),
      kExprI32Const, 0,
      kExprReturn,
    kExprEnd,
    kExprDrop,
    kExprI32Const, 1,
    kExprReturn,
  ])
  .exportFunc();

  let instance = builder.instantiate();
  let wasm = instance.exports;
  let obj = {};

  assertEquals(0, wasm.castToExternRef(null));
  assertEquals(1, wasm.castToExternRef(undefined));
  assertEquals(1, wasm.castToExternRef(1));
  assertEquals(1, wasm.castToExternRef(obj));
  assertEquals(1, wasm.castToExternRef(wasm.castToExternRef));

  assertEquals(0, wasm.castToNullExternRef(null));
  assertEquals(0, wasm.castToNullExternRef(undefined));
  assertEquals(0, wasm.castToNullExternRef(1));
  assertEquals(0, wasm.castToNullExternRef(obj));
  assertEquals(0, wasm.castToNullExternRef(wasm.castToExternRef));

  assertEquals(1, wasm.castNullToExternRef(null));
  assertEquals(1, wasm.castNullToExternRef(undefined));
  assertEquals(1, wasm.castNullToExternRef(1));
  assertEquals(1, wasm.castNullToExternRef(obj));
  assertEquals(1, wasm.castNullToExternRef(wasm.castToExternRef));

  assertEquals(1, wasm.castNullToNullExternRef(null));
  assertEquals(0, wasm.castNullToNullExternRef(undefined));
  assertEquals(0, wasm.castNullToNullExternRef(1));
  assertEquals(0, wasm.castNullToNullExternRef(obj));
  assertEquals(0, wasm.castNullToNullExternRef(wasm.castToExternRef));

  assertEquals(1, wasm.castFailToExternRef(null));
  assertEquals(0, wasm.castFailToExternRef(undefined));
  assertEquals(0, wasm.castFailToExternRef(1));
  assertEquals(0, wasm.castFailToExternRef(obj));
  assertEquals(0, wasm.castFailToExternRef(wasm.castToExternRef));

  assertEquals(1, wasm.castFailToNullExternRef(null));
  assertEquals(1, wasm.castFailToNullExternRef(undefined));
  assertEquals(1, wasm.castFailToNullExternRef(1));
  assertEquals(1, wasm.castFailToNullExternRef(obj));
  assertEquals(1, wasm.castFailToNullExternRef(wasm.castToExternRef));

  assertEquals(0, wasm.castFailNullToExternRef(null));
  assertEquals(0, wasm.castFailNullToExternRef(undefined));
  assertEquals(0, wasm.castFailNullToExternRef(1));
  assertEquals(0, wasm.castFailNullToExternRef(obj));
  assertEquals(0, wasm.castFailNullToExternRef(wasm.castToExternRef));

  assertEquals(0, wasm.castFailNullToNullExternRef(null));
  assertEquals(1, wasm.castFailNullToNullExternRef(undefined));
  assertEquals(1, wasm.castFailNullToNullExternRef(1));
  assertEquals(1, wasm.castFailNullToNullExternRef(obj));
  assertEquals(1, wasm.castFailNullToNullExternRef(wasm.castToExternRef));
})();

(function RefTestAnyRefHierarchy() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let structSuper = builder.addStruct([makeField(kWasmI32, true)]);
  let structSub = builder.addStruct([makeField(kWasmI32, true)], structSuper);
  let array = builder.addArray(kWasmI32);

  // Helpers to be able to instantiate a true externref value from wasm.
  let createExternSig = builder.addType(makeSig([], [kWasmExternRef]));
  let createExternIdx = builder.addImport('import', 'createExtern', createExternSig);
  let createExtern = () => undefined;

  let types = {
    any: kWasmAnyRef,
    eq: kWasmEqRef,
    struct: kWasmStructRef,
    anyArray: kWasmArrayRef,
    array: wasmRefNullType(array),
    structSuper: wasmRefNullType(structSuper),
    structSub: wasmRefNullType(structSub),
    nullref: kWasmNullRef,
  };

  let createBodies = {
    nullref: [kExprRefNull, kNullRefCode],
    i31ref: [kExprI32Const, 42, kGCPrefix, kExprRefI31],
    structSuper: [kExprI32Const, 42, kGCPrefix, kExprStructNew, structSuper],
    structSub: [kExprI32Const, 42, kGCPrefix, kExprStructNew, structSub],
    array: [kExprI32Const, 42, kGCPrefix, kExprArrayNewFixed, array, 1],
    any: [kExprCallFunction, createExternIdx, kGCPrefix, kExprAnyConvertExtern],
  };

  // Each Test lists the following:
  // source  => The static type of the source value.
  // values  => All actual values that are subtypes of the static types.
  // targets => A list of types for ref.test. For each type the values are
  //            listed for which ref.test should return 1 (i.e. the ref.test
  //            should succeed).
  // isUpcastOrUnrelated => A subset of the target types which are not legal
  //            targets for br_on_cast which only allows downcasts.)
  let tests = [
    {
      source: 'any',
      values: ['nullref', 'i31ref', 'structSuper', 'structSub', 'array', 'any'],
      targets: {
        any: ['i31ref', 'structSuper', 'structSub', 'array', 'any'],
        eq: ['i31ref', 'structSuper', 'structSub', 'array'],
        struct: ['structSuper', 'structSub'],
        anyArray: ['array'],
        array: ['array'],
        structSuper: ['structSuper', 'structSub'],
        structSub: ['structSub'],
        nullref: [],
      },
      isUpcastOrUnrelated: [],
    },
    {
      source: 'eq',
      values: ['nullref', 'i31ref', 'structSuper', 'structSub', 'array'],
      targets: {
        eq: ['i31ref', 'structSuper', 'structSub', 'array'],
        struct: ['structSuper', 'structSub'],
        anyArray: ['array'],
        array: ['array'],
        structSuper: ['structSuper', 'structSub'],
        structSub: ['structSub'],
        nullref: [],
      },
      isUpcastOrUnrelated: [],
    },
    {
      source: 'struct',
      values: ['nullref', 'structSuper', 'structSub'],
      targets: {
        eq: ['structSuper', 'structSub'],
        struct: ['structSuper', 'structSub'],
        anyArray: ['array'],
        array: ['array'],
        structSuper: ['structSuper', 'structSub'],
        structSub: ['structSub'],
        nullref: [],
      },
      isUpcastOrUnrelated: ['eq', 'anyArray', 'array'],
    },
    {
      source: 'anyArray',
      values: ['nullref', 'array'],
      targets: {
        eq: ['array'],
        struct: [],
        anyArray: ['array'],
        array: ['array'],
        structSuper: [],
        structSub: [],
        nullref: [],
      },
      isUpcastOrUnrelated: ['eq', 'struct', 'structSuper', 'structSub'],
    },
    {
      source: 'structSuper',
      values: ['nullref', 'structSuper', 'structSub'],
      targets: {
        eq: ['structSuper', 'structSub'],
        struct: ['structSuper', 'structSub'],
        anyArray: [],
        array: [],
        structSuper: ['structSuper', 'structSub'],
        structSub: ['structSub'],
        nullref: [],
      },
      isUpcastOrUnrelated: ['eq', 'struct', 'array', 'anyArray'],
    },
  ];

  for (let test of tests) {
    let sourceType = types[test.source];
    // Add creator functions.
    let creatorSig = makeSig([], [sourceType]);
    let creatorType = builder.addType(creatorSig);
    for (let value of test.values) {
      builder.addFunction(`create_${test.source}_${value}`, creatorType)
      .addBody(createBodies[value]).exportFunc();
    }
    // Add ref.test tester functions.
    // The functions take the creator functions as a callback to prevent the
    // compiler to derive the actual type of the value and can only use the
    // static source type.
    for (let target in test.targets) {
      // Get heap type for concrete types or apply Leb128 mask on the abstract
      // type.
      let targetHeapType = types[target].heap_type ?? types[target];
      let targetTypeCode = targetHeapType & kLeb128Mask;
      let sourceHeapType = sourceType.heapType ?? sourceType;
      let sourceTypeCode = sourceHeapType & kLeb128Mask;

      builder.addFunction(`test_${test.source}_to_${target}`,
                          makeSig([wasmRefType(creatorType)], [kWasmI32]))
      .addBody([
        kExprLocalGet, 0,
        kExprCallRef, ...wasmUnsignedLeb(creatorType),
        kGCPrefix, kExprRefTest, targetTypeCode,
      ]).exportFunc();
      builder.addFunction(`test_null_${test.source}_to_${target}`,
                          makeSig([wasmRefType(creatorType)], [kWasmI32]))
      .addBody([
        kExprLocalGet, 0,
        kExprCallRef, ...wasmUnsignedLeb(creatorType),
        kGCPrefix, kExprRefTestNull, targetTypeCode,
      ]).exportFunc();

      builder.addFunction(`cast_${test.source}_to_${target}`,
                          makeSig([wasmRefType(creatorType)], [kWasmI32]))
      .addBody([
        kExprLocalGet, 0,
        kExprCallRef, ...wasmUnsignedLeb(creatorType),
        kGCPrefix, kExprRefCast, targetTypeCode,
        kExprRefIsNull, // We can't expose the cast object to JS in most cases.
      ]).exportFunc();

      builder.addFunction(`cast_null_${test.source}_to_${target}`,
                          makeSig([wasmRefType(creatorType)], [kWasmI32]))
      .addBody([
        kExprLocalGet, 0,
        kExprCallRef, ...wasmUnsignedLeb(creatorType),
        kGCPrefix, kExprRefCastNull, targetTypeCode,
        kExprRefIsNull, // We can't expose the cast object to JS in most cases.
      ]).exportFunc();

      if (test.isUpcastOrUnrelated.includes(target)) {
        // br_on_cast only allows downcasts.
        continue;
      }

      builder.addFunction(`brOnCast_${test.source}_to_${target}`,
                          makeSig([wasmRefType(creatorType)], [kWasmI32]))
      .addBody([
        kExprBlock, kWasmRef, targetTypeCode,
          kExprLocalGet, 0,
          kExprCallRef, ...wasmUnsignedLeb(creatorType),
          ...wasmBrOnCast(0,
              wasmRefNullType(sourceHeapType), wasmRefType(targetHeapType)),
          kExprI32Const, 0,
          kExprReturn,
        kExprEnd,
        kExprDrop,
        kExprI32Const, 1,
        kExprReturn,
      ])
      .exportFunc();

      builder.addFunction(`brOnCastNull_${test.source}_to_${target}`,
                          makeSig([wasmRefType(creatorType)], [kWasmI32]))
      .addBody([
        kExprBlock, kWasmRefNull, targetTypeCode,
          kExprLocalGet, 0,
          kExprCallRef, ...wasmUnsignedLeb(creatorType),
          ...wasmBrOnCast(0,
              wasmRefNullType(sourceHeapType), wasmRefNullType(targetHeapType)),
          kExprI32Const, 0,
          kExprReturn,
        kExprEnd,
        kExprDrop,
        kExprI32Const, 1,
        kExprReturn,
      ])
      .exportFunc();

      builder.addFunction(`brOnCastFail_${test.source}_to_${target}`,
                          makeSig([wasmRefType(creatorType)], [kWasmI32]))
      .addBody([
        kExprBlock, kWasmRefNull, sourceTypeCode,
          kExprLocalGet, 0,
          kExprCallRef, ...wasmUnsignedLeb(creatorType),
          ...wasmBrOnCastFail(0,
              wasmRefNullType(sourceHeapType), wasmRefType(targetHeapType)),
          kExprI32Const, 0,
          kExprReturn,
        kExprEnd,
        kExprDrop,
        kExprI32Const, 1,
        kExprReturn,
      ])
      .exportFunc();

      builder.addFunction(`brOnCastFailNull_${test.source}_to_${target}`,
                          makeSig([wasmRefType(creatorType)], [kWasmI32]))
      .addBody([
        kExprBlock, kWasmRef, sourceTypeCode,
          kExprLocalGet, 0,
          kExprCallRef, ...wasmUnsignedLeb(creatorType),
          ...wasmBrOnCastFail(0,
              wasmRefNullType(sourceHeapType), wasmRefNullType(targetHeapType)),
          kExprI32Const, 0,
          kExprReturn,
        kExprEnd,
        kExprDrop,
        kExprI32Const, 1,
        kExprReturn,
      ])
      .exportFunc();
    }
  }

  let instance = builder.instantiate({import: {createExtern}});
  let wasm = instance.exports;

  for (let test of tests) {
    for (let [target, validValues] of Object.entries(test.targets)) {
      for (let value of test.values) {
        print(`Test ref.test: ${test.source}(${value}) -> ${target}`);
        let create_value = wasm[`create_${test.source}_${value}`];
        let res = wasm[`test_${test.source}_to_${target}`](create_value);
        assertEquals(validValues.includes(value) ? 1 : 0, res);
        print(`Test ref.test null: ${test.source}(${value}) -> ${target}`);
        res = wasm[`test_null_${test.source}_to_${target}`](create_value);
        assertEquals(
            (validValues.includes(value) || value == "nullref") ? 1 : 0, res);

        print(`Test ref.cast: ${test.source}(${value}) -> ${target}`);
        let cast = wasm[`cast_${test.source}_to_${target}`];
        if (validValues.includes(value)) {
          assertEquals(0, cast(create_value));
        } else {
          assertTraps(kTrapIllegalCast, () => cast(create_value));
        }
        let castNull = wasm[`cast_null_${test.source}_to_${target}`];
        if (validValues.includes(value) || value == "nullref") {
          let expected = value == "nullref" ? 1 : 0;
          assertEquals(expected, castNull(create_value));
        } else {
          assertTraps(kTrapIllegalCast, () => castNull(create_value));
        }

        if (test.isUpcastOrUnrelated.includes(target)) {
          // br_on_cast only allows downcasts.
          continue;
        }

        print(`Test br_on_cast: ${test.source}(${value}) -> ${target}`);
        res = wasm[`brOnCast_${test.source}_to_${target}`](create_value);
        assertEquals(validValues.includes(value) ? 1 : 0, res);
        print(`Test br_on_cast null: ${test.source}(${value}) -> ${target}`);
        res = wasm[`brOnCastNull_${test.source}_to_${target}`](create_value);
        assertEquals(
            validValues.includes(value) || value == "nullref" ? 1 : 0, res);

        print(`Test br_on_cast_fail: ${test.source}(${value}) -> ${target}`);
        res = wasm[`brOnCastFail_${test.source}_to_${target}`](create_value);
        assertEquals(!validValues.includes(value) || value == "nullref" ? 1 : 0, res);
        print(`Test br_on_cast_fail null: ${test.source}(${value}) -> ${target}`);
        res = wasm[`brOnCastFailNull_${test.source}_to_${target}`](create_value);
        assertEquals(!validValues.includes(value) && value != "nullref" ? 1 : 0, res);
      }
    }
  }
})();
                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/gc-experiments.js                                             0000664 0000000 0000000 00000001451 14746647661 0022755 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-ref-cast-nop

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestRefCastNop() {
  var builder = new WasmModuleBuilder();
  let struct = builder.addStruct([makeField(kWasmI32, true)]);

  builder.addFunction("main", kSig_i_i)
    .addLocals(kWasmStructRef, 1)
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprStructNew, struct,
      kExprLocalSet, 1,
      kExprLocalGet, 1,
      kGCPrefix, kExprRefCastNop, struct,
      kGCPrefix, kExprStructGet, struct, 0,
  ]).exportFunc();

  var instance = builder.instantiate();
  assertEquals(42, instance.exports.main(42));
})();
                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/wasm/gc-frame.js                                                   0000664 0000000 0000000 00000005655 14746647661 0021516 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --expose-gc

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function makeFFI(func, t) {
  var builder = new WasmModuleBuilder();

  var sig_index = builder.addType(makeSig([t,t,t,t,t,t,t,t,t,t], [t]));
  builder.addImport("m", "func", sig_index);
  // Try to create a frame with lots of spilled values and parameters
  // on the stack to try to catch GC bugs in the reference maps for
  // the different parts of the stack.
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,         // --
      kExprLocalGet, 1,         // --
      kExprLocalGet, 2,         // --
      kExprLocalGet, 3,         // --
      kExprLocalGet, 4,         // --
      kExprLocalGet, 5,         // --
      kExprLocalGet, 6,         // --
      kExprLocalGet, 7,         // --
      kExprLocalGet, 8,         // --
      kExprLocalGet, 9,         // --
      kExprCallFunction, 0,     // --
      kExprDrop,                // --
      kExprLocalGet, 0,         // --
      kExprLocalGet, 1,         // --
      kExprLocalGet, 2,         // --
      kExprLocalGet, 3,         // --
      kExprLocalGet, 4,         // --
      kExprLocalGet, 5,         // --
      kExprLocalGet, 6,         // --
      kExprLocalGet, 7,         // --
      kExprLocalGet, 8,         // --
      kExprLocalGet, 9,         // --
      kExprCallFunction, 0,    // --
    ])                          // --
    .exportFunc();

  return builder.instantiate({m: {func: func}}).exports.main;
}


function print10(a, b, c, d, e, f, g, h, i) {
  print(a + ",", b + ",", c + ",", d + ",", e + ",", f + ",", g + ",", h + ",", i);
  gc();
  print(a + ",", b + ",", c + ",", d + ",", e + ",", f + ",", g + ",", h + ",", i);
}

(function I32Test() {
  var main = makeFFI(print10, kWasmI32);
  for (var i = 1; i < 0xFFFFFFF; i <<= 2) {
    main(i - 1, i, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7, i + 8);
  }
})();

(function F32Test() {
  var main = makeFFI(print10, kWasmF32);
  for (var i = 1; i < 2e+30; i *= -157) {
    main(i - 1, i, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7, i + 8);
  }
})();

(function F64Test() {
  var main = makeFFI(print10, kWasmF64);
  for (var i = 1; i < 2e+80; i *= -1137) {
    main(i - 1, i, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7, i + 8);
  }
})();

(function GCInJSToWasmTest() {
  var builder = new WasmModuleBuilder();

  var sig_index = builder.addType(kSig_i_i);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,         // --
    ])                          // --
    .exportFunc();

  var main = builder.instantiate({}).exports.main;

  var gc_object = {
      valueOf: function() {
        // Call the GC in valueOf, which is called within the JSToWasm wrapper.
        gc();
        return {};
      }
  };

  main(gc_object);
})();
                                                                                   node-23.7.0/deps/v8/test/mjsunit/wasm/gc-js-interop-async-debugger.js                               0000664 0000000 0000000 00000001014 14746647661 0025374 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --turbofan --no-always-turbofan

// The implementation of Promises currently takes a different path (a C++
// runtime function instead of a Torque builtin) when the debugger is
// enabled, so exercise that path in this variant of the test.
d8.debugger.enable();
d8.file.execute('test/mjsunit/wasm/gc-js-interop-async.js');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/test/mjsunit/wasm/gc-js-interop-async.js                                        0000664 0000000 0000000 00000005724 14746647661 0023626 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --turbofan --no-always-turbofan --allow-natives-syntax

d8.file.execute('test/mjsunit/wasm/gc-js-interop-helpers.js');

let {struct, array} = CreateWasmObjects();
for (const wasm_obj of [struct, array]) {

  repeated(() => assertThrowsAsync(Promise.all(wasm_obj), TypeError));
  repeated(() => Promise.all([wasm_obj]));
  repeated(() => assertThrowsAsync(Promise.allSettled(wasm_obj), TypeError));
  repeated(
      () => Promise.allSettled([wasm_obj])
                .then((info) => assertEquals('fulfilled', info[0].status)));
  repeated(() => assertThrowsAsync(Promise.any(wasm_obj), TypeError));
  repeated(() => Promise.any([wasm_obj]));
  repeated(() => assertThrowsAsync(Promise.race(wasm_obj), TypeError));
  repeated(() => Promise.race([wasm_obj]));
  // Using wasm objects in Promise.resolve and Promise.reject should work as
  // for any other object.
  repeated(
      () => (new Promise((resolve, reject) => resolve(wasm_obj)))
                .then((v) => assertSame(wasm_obj, v)));
  repeated(
      () => (new Promise((resolve, reject) => reject(wasm_obj)))
                .then(() => assertUnreachable())
                .catch((v) => assertSame(wasm_obj, v)));
  // Wasm objects can also be passed as a result in a then chain.
  repeated(
      () => (new Promise((resolve) => resolve({})))
                .then(() => wasm_obj)
                .then((v) => assertSame(wasm_obj, v)));
  // If the `then` argument isn't a callback, it will simply be replaced with
  // an identity function (x) => x.
  repeated(
      () => (new Promise((resolve) => resolve({})))
                .then(wasm_obj)  // The value itself doesn't have any impact.
                .then((v) => assertEquals({}, v), () => assertUnreachable()));
  // If the `catch` argument isn't a callback, it will be replaced with a
  // thrower function (x) => { throw x; }.
  repeated(
      () => (new Promise((resolve, reject) => reject({})))
                .then(() => null)
                .catch(wasm_obj)  // The value itself doesn't have any impact.
                .then(() => assertUnreachable(), (v) => assertEquals({}, v)));
  // `finally(wasm_obj)` behaves just like `then(wasm_obj, wasm_obj)`
  repeated(
      () => (new Promise((resolve, reject) => resolve({})))
                .finally(wasm_obj)
                .then((v) => assertEquals({}, v), () => assertUnreachable()));
  repeated(
      () => (new Promise((resolve, reject) => reject({})))
                .finally(wasm_obj)
                .then(() => assertUnreachable(), (v) => assertEquals({}, v)));

  // Ensure no statement re-assigned wasm_obj by accident.
  assertTrue(wasm_obj == struct || wasm_obj == array);
}

repeated(async function testAsync() {
  for (let wasm_obj of [struct, array]) {
    let async_wasm_obj = await wasm_obj;
    assertSame(wasm_obj, async_wasm_obj);
  }
});
                                            node-23.7.0/deps/v8/test/mjsunit/wasm/gc-js-interop-collections.js                                  0000664 0000000 0000000 00000016453 14746647661 0025030 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --turbofan --no-always-turbofan --allow-natives-syntax

d8.file.execute('test/mjsunit/wasm/gc-js-interop-helpers.js');

let {struct, array} = CreateWasmObjects();
for (const wasm_obj of [struct, array]) {

  // Test Array.
  repeated(() => assertEquals([], Array.from(wasm_obj)));
  repeated(() => assertFalse(Array.isArray(wasm_obj)));
  repeated(() => assertEquals([wasm_obj], Array.of(wasm_obj)));
  testThrowsRepeated(() => [1, 2].at(wasm_obj), TypeError);
  repeated(() => assertEquals([1, wasm_obj], [1].concat(wasm_obj)));
  testThrowsRepeated(() => [1, 2].copyWithin(wasm_obj), TypeError);
  testThrowsRepeated(() => [1, 2].every(wasm_obj), TypeError);
  repeated(
      () => assertEquals([1, wasm_obj, 3], [1, 2, 3].fill(wasm_obj, 1, 2)));
  testThrowsRepeated(() => [1, 2].filter(wasm_obj), TypeError);
  repeated(
      () => assertEquals(
          [wasm_obj], [undefined, wasm_obj, null].filter(function(v) {
            return v == this;
          }, wasm_obj)));
  testThrowsRepeated(() => [1, 2].find(wasm_obj), TypeError);
  testThrowsRepeated(() => [1, 2].findIndex(wasm_obj), TypeError);
  testThrowsRepeated(() => [1, 2].findLast(wasm_obj), TypeError);
  testThrowsRepeated(() => [1, 2].findLastIndex(wasm_obj), TypeError);
  testThrowsRepeated(() => [1, 2].flat(wasm_obj), TypeError);
  testThrowsRepeated(() => [1, 2].flatMap(wasm_obj), TypeError);
  testThrowsRepeated(() => [1, 2].forEach(wasm_obj), TypeError);
  repeated(() => {
    let res = [];
    [1, 2].forEach(function(x) {
      res.push(this);
    }, wasm_obj);
    assertEquals([wasm_obj, wasm_obj], res);
  });
  repeated(() => assertTrue([wasm_obj].includes(wasm_obj)));
  repeated(() => assertFalse([1].includes(wasm_obj)));
  repeated(() => assertEquals(1, [0, wasm_obj, 2].indexOf(wasm_obj)));
  testThrowsRepeated(() => ['a', 'b'].join(wasm_obj), TypeError);
  repeated(() => assertEquals(1, [0, wasm_obj, 2].lastIndexOf(wasm_obj)));
  testThrowsRepeated(() => [1, 2].map(wasm_obj), TypeError);
  repeated(() => assertEquals([wasm_obj, wasm_obj], [1, 2].map(function() {
             return this;
           }, wasm_obj)));
  repeated(() => {
    let arr = [1];
    arr.push(wasm_obj, 3);
    assertEquals([1, wasm_obj, 3], arr);
  });
  testThrowsRepeated(() => [1, 2].reduce(wasm_obj), TypeError);
  repeated(() => assertSame(wasm_obj, [].reduce(() => null, wasm_obj)));
  testThrowsRepeated(() => [1, 2].reduceRight(wasm_obj), TypeError);
  testThrowsRepeated(() => [1, 2].slice(wasm_obj, 2), TypeError);
  testThrowsRepeated(() => [1, 2].some(wasm_obj), TypeError);
  testThrowsRepeated(() => [1, 2].sort(wasm_obj), TypeError);
  testThrowsRepeated(() => [1, 2].splice(1, wasm_obj), TypeError);
  repeated(() => {
    let arr = [1, 2];
    arr.unshift(wasm_obj);
    assertEquals([wasm_obj, 1, 2], arr);
  });
  repeated(() => assertEquals(Int8Array.from([]), Int8Array.from(wasm_obj)));
  testThrowsRepeated(() => Int8Array.of(wasm_obj), TypeError);
  for (let ArrayType
           of [Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array,
               Uint32Array]) {
    let array = ArrayType.of(1, 2, 3);
    testThrowsRepeated(() => array.at(wasm_obj), TypeError);
    testThrowsRepeated(() => array.copyWithin(wasm_obj), TypeError);
    testThrowsRepeated(() => array.fill(wasm_obj, 0, 1), TypeError);
    testThrowsRepeated(() => array.filter(wasm_obj), TypeError);
    testThrowsRepeated(() => array.find(wasm_obj), TypeError);
    testThrowsRepeated(() => array.findIndex(wasm_obj), TypeError);
    testThrowsRepeated(() => array.findLast(wasm_obj), TypeError);
    testThrowsRepeated(() => array.findLastIndex(wasm_obj), TypeError);
    testThrowsRepeated(() => array.forEach(wasm_obj), TypeError);
    repeated(() => assertFalse(array.includes(wasm_obj)));
    repeated(() => assertEquals(-1, array.indexOf(wasm_obj)));
    testThrowsRepeated(() => array.join(wasm_obj), TypeError);
    repeated(() => assertEquals(-1, array.lastIndexOf(wasm_obj)));
    testThrowsRepeated(() => array.map(wasm_obj), TypeError);
    testThrowsRepeated(() => array.map(() => wasm_obj), TypeError);
    testThrowsRepeated(() => array.reduce(wasm_obj), TypeError);
    testThrowsRepeated(() => array.reduceRight(wasm_obj), TypeError);
    repeated(() => array.set(wasm_obj));
    testThrowsRepeated(() => array.set([wasm_obj]), TypeError);
    testThrowsRepeated(() => array.slice(wasm_obj, 1), TypeError);
    testThrowsRepeated(() => array.some(wasm_obj), TypeError);
    testThrowsRepeated(() => array.sort(wasm_obj), TypeError);
    testThrowsRepeated(() => array.subarray(0, wasm_obj), TypeError);
  }

  // Test Map.
  for (let MapType of [Map, WeakMap]) {
    repeated(() => {
      let val = new String('a');
      let map = new MapType([[val, wasm_obj], [wasm_obj, val]]);
      assertSame(wasm_obj, map.get(val));
      assertEquals(val, map.get(wasm_obj));
      assertTrue(map.has(wasm_obj));
      map.delete(wasm_obj);
      assertFalse(map.has(wasm_obj));
      assertThrows(() => map.forEach(wasm_obj), TypeError);
      map.set(wasm_obj, wasm_obj);
      assertSame(wasm_obj, map.get(wasm_obj));
    });
  }

  // Test Set.
  for (let SetType of [Set, WeakSet]) {
    repeated(() => {
      let set = new SetType([new String('a'), wasm_obj]);
      set.add(wasm_obj);
      assertTrue(set.has(wasm_obj));
      set.delete(wasm_obj);
      assertFalse(set.has(wasm_obj));
    });
  }

  // Test ArrayBuffer.
  repeated(() => assertFalse(ArrayBuffer.isView(wasm_obj)));
  testThrowsRepeated(
      () => (new ArrayBuffer(32)).slice(wasm_obj, wasm_obj), TypeError);
  testThrowsRepeated(
      () => (new SharedArrayBuffer(32)).slice(wasm_obj, wasm_obj), TypeError);

  // Test Dataview.
  let arrayBuf = new ArrayBuffer(32);
  let dataView = new DataView(arrayBuf);
  testThrowsRepeated(() => dataView.getBigInt64(wasm_obj), TypeError);
  testThrowsRepeated(() => dataView.getBigUint64(wasm_obj), TypeError);
  testThrowsRepeated(() => dataView.getFloat32(wasm_obj), TypeError);
  testThrowsRepeated(() => dataView.getFloat64(wasm_obj), TypeError);
  testThrowsRepeated(() => dataView.getInt8(wasm_obj), TypeError);
  testThrowsRepeated(() => dataView.getInt16(wasm_obj), TypeError);
  testThrowsRepeated(() => dataView.getInt32(wasm_obj), TypeError);
  testThrowsRepeated(() => dataView.getUint8(wasm_obj), TypeError);
  testThrowsRepeated(() => dataView.getUint16(wasm_obj), TypeError);
  testThrowsRepeated(() => dataView.getUint32(wasm_obj), TypeError);
  testThrowsRepeated(() => dataView.setBigInt64(wasm_obj), TypeError);
  testThrowsRepeated(() => dataView.setBigUint64(wasm_obj), TypeError);
  testThrowsRepeated(() => dataView.setFloat32(wasm_obj), TypeError);
  testThrowsRepeated(() => dataView.setFloat64(0, wasm_obj), TypeError);
  testThrowsRepeated(() => dataView.setInt8(wasm_obj), TypeError);
  testThrowsRepeated(() => dataView.setInt16(0, wasm_obj), TypeError);
  testThrowsRepeated(() => dataView.setInt32(wasm_obj), TypeError);
  testThrowsRepeated(() => dataView.setUint8(0, wasm_obj), TypeError);
  testThrowsRepeated(() => dataView.setUint16(wasm_obj), TypeError);
  testThrowsRepeated(() => dataView.setUint32(0, wasm_obj), TypeError);

  // Ensure no statement re-assigned wasm_obj by accident.
  assertTrue(wasm_obj == struct || wasm_obj == array);
}
                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/wasm/gc-js-interop-export.mjs                                      0000664 0000000 0000000 00000000431 14746647661 0024175 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute('test/mjsunit/wasm/gc-js-interop-helpers.js');
export let {struct, array} = CreateWasmObjects();
                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/wasm/gc-js-interop-global-constructors.js                          0000664 0000000 0000000 00000014020 14746647661 0026504 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --turbofan --no-always-turbofan --allow-natives-syntax

d8.file.execute('test/mjsunit/wasm/gc-js-interop-helpers.js');

let {struct, array} = CreateWasmObjects();
for (const wasm_obj of [struct, array]) {

  // Test constructors of the global object as function.
  testThrowsRepeated(() => AggregateError(wasm_obj), TypeError);
  repeated(() => assertSame(wasm_obj, Array(wasm_obj)[0]));
  testThrowsRepeated(() => ArrayBuffer(wasm_obj), TypeError);
  testThrowsRepeated(() => BigInt(wasm_obj), TypeError);
  testThrowsRepeated(() => BigInt64Array(wasm_obj), TypeError);
  testThrowsRepeated(() => BigUint64Array(wasm_obj), TypeError);
  repeated(() => assertEquals(true, Boolean(wasm_obj)));
  testThrowsRepeated(() => DataView(wasm_obj), TypeError);
  repeated(() => {
    let date = Date(wasm_obj);
    assertEquals('string', typeof date);
  });
  testThrowsRepeated(() => Error(wasm_obj), TypeError);
  testThrowsRepeated(() => EvalError(wasm_obj), TypeError);
  testThrowsRepeated(() => Float64Array(wasm_obj), TypeError);
  testThrowsRepeated(() => Function(wasm_obj), TypeError);
  testThrowsRepeated(() => Int8Array(wasm_obj), TypeError);
  testThrowsRepeated(() => Int16Array(wasm_obj), TypeError);
  testThrowsRepeated(() => Int32Array(wasm_obj), TypeError);
  testThrowsRepeated(() => Map(wasm_obj), TypeError);
  testThrowsRepeated(() => Number(wasm_obj), TypeError);
  repeated(() => assertSame(wasm_obj, Object(wasm_obj)));
  testThrowsRepeated(() => Promise(wasm_obj), TypeError);
  testThrowsRepeated(() => Proxy(wasm_obj), TypeError);
  testThrowsRepeated(() => RangeError(wasm_obj), TypeError);
  testThrowsRepeated(() => ReferenceError(wasm_obj), TypeError);
  testThrowsRepeated(() => RegExp(wasm_obj), TypeError);
  testThrowsRepeated(() => Set(wasm_obj), TypeError);
  testThrowsRepeated(() => SharedArrayBuffer(wasm_obj), TypeError);
  testThrowsRepeated(() => String(wasm_obj), TypeError);
  testThrowsRepeated(() => Symbol(wasm_obj), TypeError);
  testThrowsRepeated(() => SyntaxError(wasm_obj), TypeError);
  testThrowsRepeated(() => TypeError(wasm_obj), TypeError);
  testThrowsRepeated(() => Uint8Array(wasm_obj), TypeError);
  testThrowsRepeated(() => Uint16Array(wasm_obj), TypeError);
  testThrowsRepeated(() => Uint32Array(wasm_obj), TypeError);
  testThrowsRepeated(() => URIError(wasm_obj), TypeError);
  testThrowsRepeated(() => WeakMap(wasm_obj), TypeError);
  testThrowsRepeated(() => WeakRef(wasm_obj), TypeError);
  testThrowsRepeated(() => WeakSet(wasm_obj), TypeError);

  // Test constructors of the global object with new.
  testThrowsRepeated(() => new AggregateError(wasm_obj), TypeError);
  repeated(() => assertSame(wasm_obj, new Array(wasm_obj)[0]));
  testThrowsRepeated(() => new ArrayBuffer(wasm_obj), TypeError);
  testThrowsRepeated(() => new BigInt(wasm_obj), TypeError);
  repeated(() => assertEquals(new BigInt64Array(),
                              new BigInt64Array(wasm_obj)));
  testThrowsRepeated(() => new BigInt64Array([wasm_obj]), TypeError);
  repeated(() => assertEquals(new BigUint64Array(),
                              new BigUint64Array(wasm_obj)));
  testThrowsRepeated(() => new BigUint64Array([wasm_obj]), TypeError);
  repeated(() => assertEquals(true, (new Boolean(wasm_obj)).valueOf()));
  testThrowsRepeated(() => new DataView(wasm_obj), TypeError);
  testThrowsRepeated(() => new Date(wasm_obj), TypeError);
  testThrowsRepeated(() => new Error(wasm_obj), TypeError);
  testThrowsRepeated(() => new EvalError(wasm_obj), TypeError);
  repeated(() => assertEquals(new Float64Array(),
                              new Float64Array(wasm_obj)));
  testThrowsRepeated(() => new Float64Array([wasm_obj]), TypeError);
  testThrowsRepeated(() => new Function(wasm_obj), TypeError);
  repeated(() => assertEquals(new Int8Array(),
                              new Int8Array(wasm_obj)));
  testThrowsRepeated(() => new Int8Array([wasm_obj]), TypeError);
  repeated(() => assertEquals(new Int16Array(),
                              new Int16Array(wasm_obj)));
  testThrowsRepeated(() => new Int16Array([wasm_obj]), TypeError);
  repeated(() => assertEquals(new Int32Array(),
                              new Int32Array(wasm_obj)));
  testThrowsRepeated(() => new Int32Array([wasm_obj]), TypeError);
  testThrowsRepeated(() => new Map(wasm_obj), TypeError);
  testThrowsRepeated(() => new Number(wasm_obj), TypeError);
  repeated(() => assertSame(wasm_obj, new Object(wasm_obj)));
  testThrowsRepeated(() => new Promise(wasm_obj), TypeError);
  testThrowsRepeated(() => new Proxy(wasm_obj), TypeError);
  testThrowsRepeated(() => new RangeError(wasm_obj), TypeError);
  testThrowsRepeated(() => new ReferenceError(wasm_obj), TypeError);
  testThrowsRepeated(() => new RegExp(wasm_obj), TypeError);
  testThrowsRepeated(() => new Set(wasm_obj), TypeError);
  testThrowsRepeated(() => new SharedArrayBuffer(wasm_obj), TypeError);
  testThrowsRepeated(() => new String(wasm_obj), TypeError);
  testThrowsRepeated(() => new Symbol(wasm_obj), TypeError);
  testThrowsRepeated(() => new SyntaxError(wasm_obj), TypeError);
  testThrowsRepeated(() => new TypeError(wasm_obj), TypeError);
  repeated(() => assertEquals(new Uint8Array(),
                              new Uint8Array(wasm_obj)));
  testThrowsRepeated(() => new Uint8Array([wasm_obj]), TypeError);
  repeated(() => assertEquals(new Uint16Array(),
                              new Uint16Array(wasm_obj)));
  testThrowsRepeated(() => new Uint16Array([wasm_obj]), TypeError);
  repeated(() => assertEquals(new Uint32Array(),
                              new Uint32Array(wasm_obj)));
  testThrowsRepeated(() => new URIError(wasm_obj), TypeError);
  testThrowsRepeated(() => new WeakMap(wasm_obj), TypeError);
  repeated(() => assertSame(wasm_obj, new WeakRef(wasm_obj).deref()));
  testThrowsRepeated(() => new WeakSet(wasm_obj), TypeError);

  // Ensure no statement re-assigned wasm_obj by accident.
  assertTrue(wasm_obj == struct || wasm_obj == array);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/wasm/gc-js-interop-helpers.js                                      0000664 0000000 0000000 00000004200 14746647661 0024137 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Helpers to test interoperability of Wasm objects in JavaScript.

// The following flags are required:
// Flags: --turbofan --no-always-turbofan --allow-natives-syntax

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

function CreateWasmObjects() {
  let builder = new WasmModuleBuilder();
  let struct_type = builder.addStruct([makeField(kWasmI32, true)]);
  let array_type = builder.addArray(kWasmI32, true);
  builder.addFunction('MakeStruct', makeSig([], [kWasmExternRef]))
      .exportFunc()
      .addBody([
        kExprI32Const, 42,                       // --
        kGCPrefix, kExprStructNew, struct_type,  // --
        kGCPrefix, kExprExternConvertAny        // --
      ]);
  builder.addFunction('MakeArray', makeSig([], [kWasmExternRef]))
      .exportFunc()
      .addBody([
        kExprI32Const, 2,                             // length
        kGCPrefix, kExprArrayNewDefault, array_type,  // --
        kGCPrefix, kExprExternConvertAny             // --
      ]);

  let instance = builder.instantiate();
  return {
    struct: instance.exports.MakeStruct(),
    array: instance.exports.MakeArray(),
  };
}

function testThrowsRepeated(fn, ErrorType) {
  const maxRuns = 3;
  for (let run = 0; run < maxRuns; ++run) {
    %PrepareFunctionForOptimization(fn);
    for (let i = 0; i < 5; i++) assertThrows(fn, ErrorType);
    %OptimizeFunctionOnNextCall(fn);
    assertThrows(fn, ErrorType);
    if (isOptimized(fn)) return;
  }
  assertOptimized(fn);
}

function repeated(fn) {
  const maxRuns = 3;
  for (let run = 0; run < maxRuns; ++run) {
    %PrepareFunctionForOptimization(fn);
    for (let i = 0; i < 5; i++) fn();
    %OptimizeFunctionOnNextCall(fn);
    fn();
    if (isOptimized(fn)) return;
  }
  assertOptimized(fn);
}

// Prevent optimization, so that the test functions can not be inlined which
// can cause issues in combination with `assertOptimized` and deopts in test
// code.
%NeverOptimizeFunction(testThrowsRepeated);
%NeverOptimizeFunction(repeated);
                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/wasm/gc-js-interop-import.mjs                                      0000664 0000000 0000000 00000002547 14746647661 0024200 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --turbofan --no-always-turbofan --allow-natives-syntax

import {struct, array} from 'gc-js-interop-export.mjs';

// Read struct and array with new wasm module.
let builder = new WasmModuleBuilder();
let struct_type = builder.addStruct([makeField(kWasmI32, true)]);
builder.addFunction('readStruct', makeSig([kWasmExternRef], [kWasmI32]))
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,                           // --
      kGCPrefix, kExprAnyConvertExtern,          // --
      kGCPrefix, kExprRefCast, struct_type,       // --
      kGCPrefix, kExprStructGet, struct_type, 0,  // --
    ]);
builder.addFunction('readArrayLength', makeSig([kWasmExternRef], [kWasmI32]))
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,                           // --
      kGCPrefix, kExprAnyConvertExtern,          // --
      kGCPrefix, kExprRefCast, kArrayRefCode,     // --
      kGCPrefix, kExprArrayLen,
    ]);

let instance = builder.instantiate();
let wasm = instance.exports;
assertEquals(42, wasm.readStruct(struct));
assertEquals(2, wasm.readArrayLength(array));
assertTraps(kTrapIllegalCast, () => wasm.readStruct(array));
assertTraps(kTrapIllegalCast, () => wasm.readArrayLength(struct));
                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/wasm/gc-js-interop-numeric.js                                      0000664 0000000 0000000 00000011567 14746647661 0024155 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --turbofan --no-always-turbofan --allow-natives-syntax

d8.file.execute('test/mjsunit/wasm/gc-js-interop-helpers.js');

let {struct, array} = CreateWasmObjects();
for (const wasm_obj of [struct, array]) {

  // Test numeric operators.
  testThrowsRepeated(() => ++wasm_obj, TypeError);
  testThrowsRepeated(() => wasm_obj--, TypeError);
  testThrowsRepeated(() => +wasm_obj, TypeError);
  testThrowsRepeated(() => -wasm_obj, TypeError);
  testThrowsRepeated(() => ~wasm_obj, TypeError);
  testThrowsRepeated(() => wasm_obj - 2, TypeError);
  testThrowsRepeated(() => wasm_obj * 2, TypeError);
  testThrowsRepeated(() => wasm_obj / 2, TypeError);
  testThrowsRepeated(() => wasm_obj ** 2, TypeError);
  testThrowsRepeated(() => wasm_obj << 2, TypeError);
  testThrowsRepeated(() => wasm_obj >> 2, TypeError);
  testThrowsRepeated(() => 2 >>> wasm_obj, TypeError);
  testThrowsRepeated(() => 2 % wasm_obj, TypeError);
  testThrowsRepeated(() => wasm_obj | 1, TypeError);
  testThrowsRepeated(() => 1 & wasm_obj, TypeError);
  testThrowsRepeated(() => wasm_obj ^ wasm_obj, TypeError);
  testThrowsRepeated(() => wasm_obj += 1, TypeError);
  let tmp = 1;
  testThrowsRepeated(() => tmp += wasm_obj, TypeError);
  testThrowsRepeated(() => tmp <<= wasm_obj, TypeError);
  testThrowsRepeated(() => tmp &= wasm_obj, TypeError);
  testThrowsRepeated(() => tmp **= wasm_obj, TypeError);

  // Test numeric functions of the global object.
  testThrowsRepeated(() => isFinite(wasm_obj), TypeError);
  testThrowsRepeated(() => isNaN(wasm_obj), TypeError);
  testThrowsRepeated(() => parseFloat(wasm_obj), TypeError);
  testThrowsRepeated(() => parseInt(wasm_obj), TypeError);

  // Test Number.
  repeated(() => assertFalse(Number.isFinite(wasm_obj)));
  repeated(() => assertFalse(Number.isInteger(wasm_obj)));
  repeated(() => assertFalse(Number.isNaN(wasm_obj)));
  repeated(() => assertFalse(Number.isSafeInteger(wasm_obj)));
  testThrowsRepeated(() => Number.parseFloat(wasm_obj), TypeError);
  testThrowsRepeated(() => Number.parseInt(wasm_obj), TypeError);

  // Test BigInt.
  testThrowsRepeated(() => BigInt.asIntN(2, wasm_obj), TypeError);
  testThrowsRepeated(
      () => BigInt.asUintN(wasm_obj, 123n), TypeError);

  // Test Math.
  testThrowsRepeated(() => Math.abs(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.acos(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.acosh(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.asin(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.asinh(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.atan(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.atanh(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.atan2(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.cbrt(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.ceil(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.clz32(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.cos(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.cosh(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.exp(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.expm1(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.floor(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.fround(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.hypot(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.imul(wasm_obj, wasm_obj), TypeError);
  testThrowsRepeated(() => Math.log(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.log1p(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.log10(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.log2(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.max(2, wasm_obj), TypeError);
  testThrowsRepeated(() => Math.min(2, wasm_obj), TypeError);
  testThrowsRepeated(() => Math.pow(2, wasm_obj), TypeError);
  testThrowsRepeated(() => Math.pow(wasm_obj, 2), TypeError);
  testThrowsRepeated(() => Math.round(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.sign(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.sin(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.sinh(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.sqrt(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.tan(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.tanh(wasm_obj), TypeError);
  testThrowsRepeated(() => Math.trunc(wasm_obj), TypeError);

  // Test boolean.
  repeated(() => assertFalse(!wasm_obj));
  repeated(() => assertTrue(wasm_obj ? true : false));
  tmp = true;
  repeated(() => assertSame(wasm_obj, tmp &&= wasm_obj));
  tmp = 0;
  repeated(() => assertSame(wasm_obj, tmp ||= wasm_obj));
  tmp = null;
  repeated(() => assertSame(wasm_obj, tmp ??= wasm_obj));

  // Ensure no statement re-assigned wasm_obj by accident.
  assertTrue(wasm_obj == struct || wasm_obj == array);
}
                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/wasm/gc-js-interop-objects.js                                      0000664 0000000 0000000 00000016517 14746647661 0024144 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --turbofan --no-always-turbofan --allow-natives-syntax

d8.file.execute('test/mjsunit/wasm/gc-js-interop-helpers.js');

let {struct, array} = CreateWasmObjects();
for (const wasm_obj of [struct, array]) {

  // Test Object.
  testThrowsRepeated(() => Object.freeze(wasm_obj), TypeError);
  testThrowsRepeated(() => Object.seal(wasm_obj), TypeError);
  repeated(() => assertSame(
      undefined, Object.prototype.__lookupGetter__.call(wasm_obj, 'foo')));
  repeated(() => assertSame(
      undefined, Object.prototype.__lookupSetter__.call(wasm_obj, 'foo')));
  testThrowsRepeated(
      () => Object.prototype.__defineGetter__.call(wasm_obj, 'foo', () => 42),
      TypeError);
  testThrowsRepeated(
      () => Object.prototype.__defineSetter__.call(wasm_obj, 'foo', () => {}),
      TypeError);
  testThrowsRepeated(
      () => Object.defineProperty(wasm_obj, 'foo', {value: 42}), TypeError);

  repeated(() => assertEquals([], Object.getOwnPropertyNames(wasm_obj)));
  repeated(() => assertEquals([], Object.getOwnPropertySymbols(wasm_obj)));
  repeated(() => assertEquals({}, Object.getOwnPropertyDescriptors(wasm_obj)));
  repeated(() => assertEquals([], Object.keys(wasm_obj)));
  repeated(() => assertEquals([], Object.entries(wasm_obj)));
  repeated(
      () => assertEquals(
          undefined, Object.getOwnPropertyDescriptor(wasm_obj, 'foo')));
  repeated(() => assertEquals(false, 'foo' in wasm_obj));
  repeated(
      () => assertEquals(
          false, Object.prototype.hasOwnProperty.call(wasm_obj, 'foo')));
  repeated(() => assertEquals(true, Object.isSealed(wasm_obj)));
  repeated(() => assertEquals(true, Object.isFrozen(wasm_obj)));
  repeated(() => assertEquals(false, Object.isExtensible(wasm_obj)));
  repeated(() => assertEquals('object', typeof wasm_obj));
  repeated(
      () => assertEquals(
          '[object Object]', Object.prototype.toString.call(wasm_obj)));

  repeated(() => {
    let tgt = {};
    Object.assign(tgt, wasm_obj);
    assertEquals({}, tgt);
  });
  repeated(() => Object.create(wasm_obj));
  repeated(() => ({}).__proto__ = wasm_obj);
  testThrowsRepeated(
      () => Object.defineProperties(wasm_obj, {prop: {value: 1}}), TypeError);
  testThrowsRepeated(
      () => Object.defineProperty(wasm_obj, 'prop', {value: 1}), TypeError);
  testThrowsRepeated(() => Object.fromEntries(wasm_obj), TypeError);
  repeated(() => assertSame(null, Object.getPrototypeOf(wasm_obj)));
  repeated(() => assertFalse(Object.hasOwn(wasm_obj, 'test')));
  testThrowsRepeated(() => Object.preventExtensions(wasm_obj), TypeError);
  testThrowsRepeated(() => Object.setPrototypeOf(wasm_obj, Object), TypeError);
  repeated(() => assertEquals([], Object.values(wasm_obj)));
  testThrowsRepeated(() => wasm_obj.toString(), TypeError);

  // Test prototype chain containing a wasm object.
  {
    let obj = Object.create(wasm_obj);
    repeated(() => assertSame(wasm_obj, Object.getPrototypeOf(obj)));
    repeated(() => assertSame(wasm_obj, Reflect.getPrototypeOf(obj)));
    repeated(() => assertSame(undefined, obj.__proto__));
    testThrowsRepeated(() => obj.__proto__ = wasm_obj, TypeError);
    // Property access fails.
    repeated(() => assertSame(undefined, obj[0]));
    repeated(() => assertSame(undefined, obj.prop));
    testThrowsRepeated(() => obj.toString(), TypeError);
    // Most conversions fail as it will use .toString(), .valueOf(), ...
    testThrowsRepeated(() => `${obj}`, TypeError);
    testThrowsRepeated(() => obj + 1, TypeError);
    repeated(() => assertTrue(!!obj));
  }
  repeated(() => {
    let obj = {};
    Object.setPrototypeOf(obj, wasm_obj);
    assertSame(wasm_obj, Object.getPrototypeOf(obj));
    Object.setPrototypeOf(obj, null);
    assertSame(null, Object.getPrototypeOf(obj));
    Reflect.setPrototypeOf(obj, wasm_obj);
    assertSame(wasm_obj, Reflect.getPrototypeOf(obj));
  })

  // Test Reflect.
  {
    let fct = function(x) {
      return [this, x]
    };
    repeated(
        () => assertEquals([wasm_obj, 1], Reflect.apply(fct, wasm_obj, [1])));
    repeated(
        () => assertEquals([{}, wasm_obj], Reflect.apply(fct, {}, [wasm_obj])));
    repeated(() => assertEquals([new Number(1), undefined], Reflect.apply(fct, 1, wasm_obj)));
    testThrowsRepeated(() => Reflect.apply(wasm_obj, null, []), TypeError);
  }
  testThrowsRepeated(() => Reflect.construct(wasm_obj, []), TypeError);
  repeated(() => assertEquals({}, Reflect.construct(Object, wasm_obj)));
  testThrowsRepeated(() => Reflect.construct(Object, [], wasm_obj), TypeError);
  testThrowsRepeated(
      () => Reflect.defineProperty(wasm_obj, 'prop', {value: 1}), TypeError);
  testThrowsRepeated(
      () => Reflect.defineProperty({}, wasm_obj, {value: 1}), TypeError);

  // Reflect.defineProperty performs ToPropertyDescriptor on the third
  // argument which checks whether {value} etc. exist before accessing them.
  // Therefore it does not throw but add the property with value undefined.
  repeated(() => {
    let obj = {};
    assertTrue(Reflect.defineProperty(obj, 'prop', wasm_obj));
    assertTrue(obj.hasOwnProperty('prop'));
    assertEquals(undefined, obj.prop);
  });
  repeated(() => {
    let obj = {};
    assertTrue(Reflect.defineProperty(obj, 'prop2', {value: wasm_obj}));
    assertSame(wasm_obj, obj.prop2);
  });
  testThrowsRepeated(() => Reflect.deleteProperty(wasm_obj, 'prop'), TypeError);
  testThrowsRepeated(() => Reflect.deleteProperty({}, wasm_obj), TypeError);
  repeated(() => assertSame(undefined, Reflect.get(wasm_obj, 'prop')));
  repeated(() => assertSame(null, Reflect.getPrototypeOf(wasm_obj)));
  repeated(() => assertFalse(Reflect.has(wasm_obj, 'prop')));
  repeated(() => assertTrue(Reflect.has({wasm_obj}, 'wasm_obj')));

  repeated(() => assertFalse(Reflect.isExtensible(wasm_obj)));
  repeated(() => assertEquals([], Reflect.ownKeys(wasm_obj)));
  testThrowsRepeated(() => Reflect.preventExtensions(wasm_obj), TypeError);
  testThrowsRepeated(() => Reflect.set(wasm_obj, 'prop', 123), TypeError);
  testThrowsRepeated(() => Reflect.set([], 0, 0, wasm_obj), TypeError);
  testThrowsRepeated(
      () => Reflect.setPrototypeOf(wasm_obj, Object.prototype), TypeError);
  repeated(() => Reflect.setPrototypeOf({}, wasm_obj));

  // Test Proxy.
  {
    const handler = {
      get(target, prop, receiver) {
        return 'proxied';
      }
    };
    let proxy = new Proxy(wasm_obj, handler);
    repeated(() => assertEquals('proxied', proxy.abc));
    testThrowsRepeated(() => proxy.abc = 123, TypeError);
  }
  {
    let underlyingObject = {};
    let proxy = new Proxy(underlyingObject, wasm_obj);
    repeated(() => assertSame(undefined, proxy.abc));
    underlyingObject.abc = 123;
    repeated(() => assertSame(123, proxy.abc));
  }
  {
    const handler = {
      get(target, prop, receiver) {
        return 'proxied';
      }
    };
    let {proxy, revoke} = Proxy.revocable(wasm_obj, handler);
    repeated(() => assertEquals('proxied', proxy.abc));
    testThrowsRepeated(() => proxy.abc = 123, TypeError);
    revoke();
    testThrowsRepeated(() => proxy.abc, TypeError);
  }
  {
    let proxy = Proxy.revocable({}, wasm_obj).proxy;
    repeated(() => assertSame(undefined, proxy.abc));
  }

  // Ensure no statement re-assigned wasm_obj by accident.
  assertTrue(wasm_obj == struct || wasm_obj == array);
}
                                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/wasm/gc-js-interop-wasm.js                                         0000664 0000000 0000000 00000007727 14746647661 0023465 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-test-streaming --turbofan --no-always-turbofan
// Flags: --allow-natives-syntax

d8.file.execute('test/mjsunit/wasm/gc-js-interop-helpers.js');

let {struct, array} = CreateWasmObjects();
for (const wasm_obj of [struct, array]) {
  testThrowsRepeated(() => new WebAssembly.Global(wasm_obj), TypeError);
  testThrowsRepeated(
      () => new WebAssembly.Global({value: wasm_obj}), TypeError);
  testThrowsRepeated(
      () => new WebAssembly.Global({value: 'i32'}, wasm_obj), TypeError);
  repeated(
      () => assertSame(
          wasm_obj,
          (new WebAssembly.Global({value: 'anyref'}, wasm_obj)).value));

  testThrowsRepeated(() => new WebAssembly.Module(wasm_obj), TypeError);
  let module = () => {
    let buffer = (new Uint8Array((new WasmModuleBuilder()).toArray())).buffer;
    return new WebAssembly.Module(buffer);
  };
  testThrowsRepeated(
      () => WebAssembly.Module.customSections(wasm_obj), TypeError);
  testThrowsRepeated(
      () => WebAssembly.Module.customSections(module, wasm_obj), TypeError);
  testThrowsRepeated(() => WebAssembly.Module.exports(wasm_obj), TypeError);
  testThrowsRepeated(() => WebAssembly.Module.imports(wasm_obj), TypeError);

  testThrowsRepeated(() => new WebAssembly.Instance(wasm_obj), TypeError);
  testThrowsRepeated(
      () => new WebAssembly.Instance(module, wasm_obj), TypeError);

  repeated(() => assertThrowsAsync(WebAssembly.compile(wasm_obj), TypeError));
  repeated(
      () =>
          assertThrowsAsync(WebAssembly.compileStreaming(wasm_obj), TypeError));
  repeated(
      () => assertThrowsAsync(WebAssembly.instantiate(wasm_obj), TypeError));
  repeated(
      () => assertThrowsAsync(
          WebAssembly.instantiateStreaming(wasm_obj), TypeError));
  testThrowsRepeated(() => WebAssembly.validate(wasm_obj), TypeError);

  testThrowsRepeated(() => new WebAssembly.Memory(wasm_obj), TypeError);
  testThrowsRepeated(
      () => new WebAssembly.Memory({initial: wasm_obj}), TypeError);
  testThrowsRepeated(
      () => new WebAssembly.Memory({initial: 1, shared: wasm_obj}), TypeError);
  let memory = new WebAssembly.Memory({initial: 1});
  testThrowsRepeated(() => memory.grow(wasm_obj), TypeError);

  testThrowsRepeated(() => new WebAssembly.Table(wasm_obj), TypeError);
  testThrowsRepeated(
      () => new WebAssembly.Table({element: wasm_obj, initial: wasm_obj}),
      TypeError);
  let table = new WebAssembly.Table({initial: 1, element: 'externref'});
  testThrowsRepeated(() => table.get(wasm_obj), TypeError);
  testThrowsRepeated(() => table.grow(wasm_obj), TypeError);
  testThrowsRepeated(() => table.set(wasm_obj, null), TypeError);
  repeated(() => table.set(0, wasm_obj));

  testThrowsRepeated(() => new WebAssembly.Tag(wasm_obj), TypeError);
  testThrowsRepeated(
      () => new WebAssembly.Tag({parameters: wasm_obj}), TypeError);
  testThrowsRepeated(
      () => new WebAssembly.Tag({parameters: [wasm_obj]}), TypeError);

  let tag = new WebAssembly.Tag({
    parameters: [wasm_obj == struct ? 'structref' : 'arrayref']});
  testThrowsRepeated(() => new WebAssembly.Exception(wasm_obj), TypeError);
  testThrowsRepeated(() => new WebAssembly.Exception(tag, wasm_obj), TypeError);
  repeated(() => new WebAssembly.Exception(tag, [wasm_obj]));
  let exception = new WebAssembly.Exception(tag, [wasm_obj]);
  testThrowsRepeated(() => exception.is(wasm_obj), TypeError);
  testThrowsRepeated(() => exception.getArg(wasm_obj), TypeError);
  testThrowsRepeated(() => exception.getArg(tag, wasm_obj), TypeError);
  testThrowsRepeated(() => new WebAssembly.CompileError(wasm_obj), TypeError);
  testThrowsRepeated(() => new WebAssembly.LinkError(wasm_obj), TypeError);
  testThrowsRepeated(() => new WebAssembly.RuntimeError(wasm_obj), TypeError);

  // Ensure no statement re-assigned wasm_obj by accident.
  assertTrue(wasm_obj == struct || wasm_obj == array);
}
                                         node-23.7.0/deps/v8/test/mjsunit/wasm/gc-js-interop.js                                              0000664 0000000 0000000 00000031145 14746647661 0022507 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --turbofan --no-always-turbofan --allow-natives-syntax

d8.file.execute('test/mjsunit/wasm/gc-js-interop-helpers.js');

let {struct, array} = CreateWasmObjects();
for (const wasm_obj of [struct, array]) {
  repeated(() => assertSame(undefined, wasm_obj.foo));
  testThrowsRepeated(() => wasm_obj.foo = 42, TypeError);
  repeated(() => assertSame(undefined, wasm_obj[0]));
  testThrowsRepeated(() => wasm_obj[0] = undefined, TypeError);
  repeated(() => assertSame(undefined, wasm_obj.__proto__));
  repeated(() => assertSame(
      null, Object.prototype.__lookupGetter__("__proto__").call(wasm_obj)));
  testThrowsRepeated(
      () => Object.prototype.__proto__.call(wasm_obj), TypeError);
  testThrowsRepeated(() => wasm_obj.__proto__ = null, TypeError);
  testThrowsRepeated(() => {
    for (let p in wasm_obj) {
    }
  }, TypeError);
  testThrowsRepeated(() => {
    for (let p of wasm_obj) {
    }
  }, TypeError);
  testThrowsRepeated(() => wasm_obj.toString(), TypeError);
  testThrowsRepeated(() => wasm_obj.valueOf(), TypeError);
  testThrowsRepeated(() => '' + wasm_obj, TypeError);
  testThrowsRepeated(() => 0 + wasm_obj, TypeError);
  testThrowsRepeated(() => { delete wasm_obj.foo; }, TypeError);

  {
    let js_obj = {};
    js_obj.foo = wasm_obj;
    repeated(() => assertSame(wasm_obj, js_obj.foo));
    js_obj[0] = wasm_obj;
    repeated(() => assertSame(wasm_obj, js_obj[0]));
  }

  repeated(() => assertEquals(42, wasm_obj ? 42 : 0));
  testThrowsRepeated(() => wasm_obj(), TypeError);

  testThrowsRepeated(() => [...wasm_obj], TypeError);
  repeated(() => assertEquals({}, {...wasm_obj}));
  repeated(() => ((...wasm_obj) => {})());
  repeated(() => assertSame(wasm_obj, ({wasm_obj}).wasm_obj));
  testThrowsRepeated(() => ({[wasm_obj]: null}), TypeError);
  testThrowsRepeated(() => `${wasm_obj}`, TypeError);
  testThrowsRepeated(() => wasm_obj`test`, TypeError);
  testThrowsRepeated(() => new wasm_obj, TypeError);
  repeated(() => assertSame(undefined, wasm_obj?.property));

  repeated(() => assertEquals(undefined, void wasm_obj));
  testThrowsRepeated(() => 2 == wasm_obj, TypeError);
  repeated(() => assertFalse(2 === wasm_obj));
  repeated(() => assertFalse({} === wasm_obj));
  repeated(() => assertTrue(wasm_obj == wasm_obj));
  repeated(() => assertTrue(wasm_obj === wasm_obj));
  repeated(() => assertFalse(wasm_obj != wasm_obj));
  repeated(() => assertFalse(wasm_obj !== wasm_obj));
  repeated(() => assertFalse(struct == array));
  repeated(() => assertTrue(struct != array));
  testThrowsRepeated(() => wasm_obj < wasm_obj, TypeError);
  testThrowsRepeated(() => wasm_obj <= wasm_obj, TypeError);
  testThrowsRepeated(() => wasm_obj >= wasm_obj, TypeError);

  testThrowsRepeated(() => { let [] = wasm_obj; }, TypeError);
  testThrowsRepeated(() => { let [a, b] = wasm_obj; }, TypeError);
  testThrowsRepeated(() => { let [...all] = wasm_obj; }, TypeError);
  repeated(() => { let {a} = wasm_obj; assertSame(undefined, a); });
  repeated(() => { let {} = wasm_obj; }, TypeError);
  repeated(() => {
    let {...rest} = wasm_obj;
    assertTrue(rest instanceof Object);
  });
  testThrowsRepeated(() => {
    with(wasm_obj) test;
  }, ReferenceError);
  repeated(() => {
    let tmp = 1;
    with(wasm_obj) var with_lookup = tmp;
    assertEquals(tmp, with_lookup);
  });
  repeated(() => {
    switch (wasm_obj) {
      case 0:
      default:
        throw 1;
      case wasm_obj:
        break;
    }
  });
  repeated(() => {
    try {
      throw wasm_obj;
    } catch (e) {
      assertEquals(e, wasm_obj);
    }
  });
  testThrowsRepeated(
      () => {class SubClass extends wasm_obj {}}, TypeError,
      'Class extends value [object Object] is not a constructor or null');
  repeated(() => {
    class TestMemberInit {
      x = wasm_obj;
    };
    assertSame(wasm_obj, new TestMemberInit().x);
  });
  repeated(() => assertSame(wasm_obj, eval('wasm_obj')));

  // Test functions of the global object.
  testThrowsRepeated(() => decodeURI(wasm_obj), TypeError);
  testThrowsRepeated(() => decodeURIComponent(wasm_obj), TypeError);
  testThrowsRepeated(() => encodeURI(wasm_obj), TypeError);
  testThrowsRepeated(() => encodeURIComponent(wasm_obj), TypeError);

  {
    let fct = function(x) {
      return [this, x]
    };
    repeated(() => assertEquals([wasm_obj, 1], fct.apply(wasm_obj, [1])));
    repeated(
        () =>
            assertEquals([new Number(1), wasm_obj], fct.apply(1, [wasm_obj])));
    repeated(
        () => assertEquals([new Number(1), undefined], fct.apply(1, wasm_obj)));
    repeated(() => assertEquals([wasm_obj, 1], fct.bind(wasm_obj)(1)));
    repeated(() => assertEquals([wasm_obj, 1], fct.call(wasm_obj, 1)));
  }

  testThrowsRepeated(() => Symbol.for(wasm_obj), TypeError);
  testThrowsRepeated(() => Symbol.keyFor(wasm_obj), TypeError);
  testThrowsRepeated(() => Date.parse(wasm_obj), TypeError);
  testThrowsRepeated(() => Date.UTC(wasm_obj), TypeError);
  testThrowsRepeated(() => (new Date()).setDate(wasm_obj), TypeError);
  testThrowsRepeated(() => (new Date()).setFullYear(wasm_obj), TypeError);
  testThrowsRepeated(() => (new Date()).setHours(wasm_obj), TypeError);
  testThrowsRepeated(() => (new Date()).setMilliseconds(wasm_obj), TypeError);
  testThrowsRepeated(() => (new Date()).setMinutes(wasm_obj), TypeError);
  testThrowsRepeated(() => (new Date()).setMonth(wasm_obj), TypeError);
  testThrowsRepeated(() => (new Date()).setSeconds(wasm_obj), TypeError);
  testThrowsRepeated(() => (new Date()).setTime(wasm_obj), TypeError);
  testThrowsRepeated(() => (new Date()).setUTCDate(wasm_obj), TypeError);
  testThrowsRepeated(() => (new Date()).setUTCFullYear(wasm_obj), TypeError);
  testThrowsRepeated(() => (new Date()).setUTCHours(wasm_obj), TypeError);
  testThrowsRepeated(
      () => (new Date()).setUTCMilliseconds(wasm_obj), TypeError);
  testThrowsRepeated(() => (new Date()).setUTCMinutes(wasm_obj), TypeError);
  testThrowsRepeated(() => (new Date()).setUTCMonth(wasm_obj), TypeError);
  testThrowsRepeated(() => (new Date()).setUTCSeconds(wasm_obj), TypeError);
  // Date.prototype.toJSON() parameter `key` is ignored.
  repeated(() => (new Date()).toJSON(wasm_obj));
  testThrowsRepeated(() => String.fromCharCode(wasm_obj), TypeError);
  testThrowsRepeated(() => String.fromCodePoint(wasm_obj), TypeError);
  testThrowsRepeated(() => String.raw(wasm_obj), TypeError);
  testThrowsRepeated(() => 'test'.at(wasm_obj), TypeError);
  testThrowsRepeated(() => 'test'.charAt(wasm_obj), TypeError);
  testThrowsRepeated(() => 'test'.charCodeAt(wasm_obj), TypeError);
  testThrowsRepeated(() => 'test'.codePointAt(wasm_obj), TypeError);
  testThrowsRepeated(() => 'test'.concat(wasm_obj), TypeError);
  testThrowsRepeated(() => 'test'.endsWith(wasm_obj), TypeError);
  testThrowsRepeated(() => 'test'.endsWith('t', wasm_obj), TypeError);
  testThrowsRepeated(() => 'test'.includes(wasm_obj), TypeError);
  testThrowsRepeated(() => 'test'.includes('t', wasm_obj), TypeError);
  testThrowsRepeated(() => 'test'.indexOf(wasm_obj), TypeError);
  testThrowsRepeated(() => 'test'.lastIndexOf(wasm_obj), TypeError);
  testThrowsRepeated(() => 'test'.localeCompare(wasm_obj), TypeError);
  testThrowsRepeated(() => 'test'.match(wasm_obj), TypeError);
  testThrowsRepeated(() => 'test'.matchAll(wasm_obj), TypeError);
  testThrowsRepeated(() => 'test'.normalize(wasm_obj), TypeError);
  testThrowsRepeated(() => 'test'.padEnd(wasm_obj), TypeError);
  testThrowsRepeated(() => 'test'.padStart(10, wasm_obj), TypeError);
  testThrowsRepeated(() => 'test'.repeat(wasm_obj), TypeError);
  testThrowsRepeated(() => 'test'.replace(wasm_obj, ''), TypeError);
  testThrowsRepeated(() => 'test'.replace('t', wasm_obj), TypeError);
  testThrowsRepeated(() => 'test'.replaceAll(wasm_obj, ''), TypeError);
  testThrowsRepeated(() => 'test'.search(wasm_obj), TypeError);
  testThrowsRepeated(() => 'test'.slice(wasm_obj, 2), TypeError);
  testThrowsRepeated(() => 'test'.split(wasm_obj), TypeError);
  testThrowsRepeated(() => 'test'.startsWith(wasm_obj), TypeError);
  testThrowsRepeated(() => 'test'.substring(wasm_obj), TypeError);

  let i8Array = new Int8Array(32);
  testThrowsRepeated(() => Atomics.add(wasm_obj, 1, 2), TypeError);
  testThrowsRepeated(() => Atomics.add(i8Array, wasm_obj, 2), TypeError);
  testThrowsRepeated(() => Atomics.add(i8Array, 1, wasm_obj), TypeError);
  testThrowsRepeated(() => Atomics.and(wasm_obj, 1, 2), TypeError);
  testThrowsRepeated(() => Atomics.and(i8Array, wasm_obj, 2), TypeError);
  testThrowsRepeated(() => Atomics.and(i8Array, 1, wasm_obj), TypeError);
  testThrowsRepeated(
      () => Atomics.compareExchange(wasm_obj, 1, 2, 3), TypeError);
  testThrowsRepeated(
      () => Atomics.compareExchange(i8Array, wasm_obj, 2, 3), TypeError);
  testThrowsRepeated(
      () => Atomics.compareExchange(i8Array, 1, wasm_obj, 3), TypeError);
  testThrowsRepeated(
      () => Atomics.compareExchange(i8Array, 1, 2, wasm_obj), TypeError);
  testThrowsRepeated(() => Atomics.exchange(wasm_obj, 1, 2), TypeError);
  testThrowsRepeated(() => Atomics.exchange(i8Array, wasm_obj, 2), TypeError);
  testThrowsRepeated(() => Atomics.exchange(i8Array, 1, wasm_obj), TypeError);
  testThrowsRepeated(() => Atomics.isLockFree(wasm_obj), TypeError);
  testThrowsRepeated(() => Atomics.load(wasm_obj, 1), TypeError);
  testThrowsRepeated(() => Atomics.load(i8Array, wasm_obj), TypeError);
  testThrowsRepeated(() => Atomics.or(wasm_obj, 1, 2), TypeError);
  testThrowsRepeated(() => Atomics.or(i8Array, wasm_obj, 2), TypeError);
  testThrowsRepeated(() => Atomics.or(i8Array, 1, wasm_obj), TypeError);
  testThrowsRepeated(() => Atomics.store(wasm_obj, 1, 2), TypeError);
  testThrowsRepeated(() => Atomics.store(i8Array, wasm_obj, 2), TypeError);
  testThrowsRepeated(() => Atomics.store(i8Array, 1, wasm_obj), TypeError);
  testThrowsRepeated(() => Atomics.sub(wasm_obj, 1, 2), TypeError);
  testThrowsRepeated(() => Atomics.sub(i8Array, wasm_obj, 2), TypeError);
  testThrowsRepeated(() => Atomics.sub(i8Array, 1, wasm_obj), TypeError);
  testThrowsRepeated(() => Atomics.wait(wasm_obj, 1, 2, 3), TypeError);
  testThrowsRepeated(() => Atomics.wait(i8Array, wasm_obj, 2, 3), TypeError);
  testThrowsRepeated(() => Atomics.wait(i8Array, 1, wasm_obj, 3), TypeError);
  testThrowsRepeated(() => Atomics.wait(i8Array, 1, 2, wasm_obj), TypeError);
  testThrowsRepeated(() => Atomics.notify(wasm_obj, 1, 2), TypeError);
  testThrowsRepeated(() => Atomics.notify(i8Array, wasm_obj, 2), TypeError);
  testThrowsRepeated(() => Atomics.notify(i8Array, 1, wasm_obj), TypeError);
  testThrowsRepeated(() => Atomics.xor(wasm_obj, 1, 2), TypeError);
  testThrowsRepeated(() => Atomics.xor(i8Array, wasm_obj, 2), TypeError);
  testThrowsRepeated(() => Atomics.xor(i8Array, 1, wasm_obj), TypeError);

  testThrowsRepeated(() => JSON.parse(wasm_obj), TypeError);
  repeated(() => assertEquals({x: 1}, JSON.parse('{"x": 1}', wasm_obj)));
  repeated(() => assertEquals(undefined, JSON.stringify(wasm_obj)));
  repeated(() => assertEquals('{"x":1}', JSON.stringify({x: 1}, wasm_obj)));
  repeated(
      () => assertEquals('{"x":1}', JSON.stringify({x: 1}, null, wasm_obj)));
  repeated(
      () => assertEquals("{}", JSON.stringify({wasm_obj})));

  // Yielding wasm objects from a generator function is valid.
  repeated(() => {
    let gen = (function*() {
      yield wasm_obj;
    })();
    assertSame(wasm_obj, gen.next().value);
  });
  // Test passing wasm objects via next() back to a generator function.
  repeated(() => {
    let gen = (function*() {
      assertSame(wasm_obj, yield 1);
    })();
    assertEquals(1, gen.next().value);
    assertTrue(gen.next(wasm_obj).done);  // triggers the assertEquals.
  });
  // Test passing wasm objects via return() to a generator function.
  repeated(() => {
    let gen = (function*() {
      yield 1;
      assertTrue(false);
    })();
    assertEquals({value: wasm_obj, done: true}, gen.return(wasm_obj));
  });
  // Test passing wasm objects via throw() to a generator function.
  repeated(() => {
    let gen = (function*() {
      try {
        yield 1;
        assertTrue(false);  // unreached
      } catch (e) {
        assertSame(wasm_obj, e);
        return 2;
      }
    })();
    assertEquals({value: 1, done: false}, gen.next());
    // wasm_obj is caught inside the generator
    assertEquals({value: 2, done: true}, gen.throw(wasm_obj));
  });
  // Treating wasm objects as generators is invalid.
  repeated(() => {
    let gen = function*() {
      yield* wasm_obj;
    };
    assertThrows(() => gen().next(), TypeError);
  });

  // Ensure no statement re-assigned wasm_obj by accident.
  assertTrue(wasm_obj == struct || wasm_obj == array);
}
                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/wasm/gc-memory.js                                                  0000664 0000000 0000000 00000001661 14746647661 0021725 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

let kPageSize = 65536;

function allocMems(count, initial, maximum) {
  print(`alloc ${count}`);
  let result = [];
  for (let i = 0; i < count; i++) {
    print(` memory #${i} (initial=${initial}, maximum=${maximum})...`);
    result.push(new WebAssembly.Memory({initial: initial, maximum: maximum}));
  }
  return result;
}

function check(mems, initial) {
  for (m of mems) {
    assertEquals(initial * kPageSize, m.buffer.byteLength);
  }
}

function test(count, initial, maximum) {
  let mems = allocMems(count, initial, maximum);
  check(mems, initial);
}

test(1, 1, 1);
test(1, 1, 2);
test(1, 1, 3);
test(1, 1, 4);

test(2, 1, 1);
test(2, 1, 2);
test(2, 1, 3);
test(2, 1, 4);

test(1, 1, undefined);
test(2, 1, undefined);
test(3, 1, undefined);
test(4, 1, undefined);
                                                                               node-23.7.0/deps/v8/test/mjsunit/wasm/gc-nominal.js                                                 0000664 0000000 0000000 00000003052 14746647661 0022046 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestNominalTypesBasic() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  let struct1 = builder.addStruct([makeField(kWasmI32, true)]);
  let struct2 = builder.addStruct(
      [makeField(kWasmI32, true), makeField(kWasmI32, true)], struct1);

  let array1 = builder.addArray(kWasmI32, true);
  let array2 = builder.addArray(kWasmI32, true, array1);

  builder.addFunction("main", kSig_v_v)
      .addLocals(wasmRefNullType(struct1), 1)
      .addLocals(wasmRefNullType(array1), 1)
      .addBody([
        // Check that we can create a struct with implicit RTT.
        kGCPrefix, kExprStructNewDefault, struct2,
        // ...and upcast it.
        kExprLocalSet, 0,
        // Check that we can create an array with implicit RTT.
        kExprI32Const, 10,  // length
        kGCPrefix, kExprArrayNewDefault, array2,
        // ...and upcast it.
        kExprLocalSet, 1])
      .exportFunc();

  // This test is only interested in type checking.
  builder.instantiate();
})();

(function TestSubtypingDepthTooLarge() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addStruct([]);
  for (let i = 0; i < 64; i++) builder.addStruct([], i);
  assertThrows(
      () => builder.instantiate(), WebAssembly.CompileError,
      /subtyping depth is greater than allowed/);
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/wasm/gc-null-traps.js                                              0000664 0000000 0000000 00000016502 14746647661 0022516 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function TestNullDereferences() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct = builder.addStruct([
      makeField(kWasmI32, true), makeField(kWasmI64, true),
      makeField(kWasmF64, true), makeField(kWasmF32, true)]);
  let struct_ref =
      builder.addStruct([makeField(wasmRefNullType(struct), true)]);
  let array = builder.addArray(kWasmI64, true);
  let array_ref = builder.addArray(wasmRefNullType(struct), true);
  let sig = builder.addType(kSig_i_i);

  for (let field_type of [[0, kWasmI32], [1, kWasmI64],
                          [2, kWasmF64], [3, kWasmF32]]) {
    builder.addFunction(
        "structGet" + field_type[0],
        makeSig([wasmRefNullType(struct)], [field_type[1]]))
      .addBody([
          kExprLocalGet, 0, kGCPrefix, kExprStructGet, struct, field_type[0]])
      .exportFunc();

    builder.addFunction(
        "structSet" + field_type[0],
        makeSig([wasmRefNullType(struct), field_type[1]], []))
      .addBody([kExprLocalGet, 0, kExprLocalGet, 1,
                kGCPrefix, kExprStructSet, struct, field_type[0]])
      .exportFunc();
  }

  builder.addFunction(
      "structRefGet", makeSig([wasmRefNullType(struct_ref)],
                              [wasmRefNullType(struct)]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprStructGet, struct_ref, 0])
    .exportFunc();

  builder.addFunction(
      "structRefSet", makeSig(
          [wasmRefNullType(struct_ref), wasmRefNullType(struct)], []))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1,
              kGCPrefix, kExprStructSet, struct_ref, 0])
    .exportFunc();

  builder.addFunction(
      "arrayGet", makeSig([wasmRefNullType(array), kWasmI32], [kWasmI64]))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1,
              kGCPrefix, kExprArrayGet, array])
    .exportFunc();

  builder.addFunction(
      "arraySet", makeSig([wasmRefNullType(array), kWasmI32, kWasmI64], []))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprLocalGet, 2,
              kGCPrefix, kExprArraySet, array])
    .exportFunc();

  builder.addFunction(
      "arrayRefGet", makeSig([wasmRefNullType(array_ref), kWasmI32],
                             [wasmRefNullType(struct)]))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1,
              kGCPrefix, kExprArrayGet, array_ref])
    .exportFunc();

  builder.addFunction(
      "arrayRefSet", makeSig(
          [wasmRefNullType(array_ref), kWasmI32, wasmRefNullType(struct)], []))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprLocalGet, 2,
              kGCPrefix, kExprArraySet, array_ref])
    .exportFunc();

  builder.addFunction(
      "arrayLen", makeSig([wasmRefNullType(array)], [kWasmI32]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprArrayLen])
    .exportFunc();

  builder.addFunction(
      "arrayCopy",
      makeSig([wasmRefNullType(array), wasmRefNullType(array)], []))
    .addBody([kExprLocalGet, 0, kExprI32Const, 10,
              kExprLocalGet, 1, kExprI32Const, 20,
              kExprI32Const, 30,
              kGCPrefix, kExprArrayCopy, array, array])
    .exportFunc();

  builder.addFunction(
      "arrayFill",
      makeSig([wasmRefNullType(array), kWasmI64], []))
    .addBody([kExprLocalGet, 0, kExprI32Const, 0, kExprLocalGet, 1,
              kExprI32Const, 10, kGCPrefix, kExprArrayFill, array])
    .exportFunc();

  builder.addFunction(
      "callFuncRef", makeSig([wasmRefNullType(sig), kWasmI32], [kWasmI32]))
    .addBody([kExprLocalGet, 1, kExprLocalGet, 0, kExprCallRef, sig])
    .exportFunc();

  builder.addFunction(
      "refAsNonNullStruct",
      makeSig([wasmRefNullType(struct)], [wasmRefType(struct)]))
    .addBody([kExprLocalGet, 0, kExprRefAsNonNull])
    .exportFunc();

  builder.addFunction(
      "refAsNonNullFunction",
      makeSig([wasmRefNullType(sig)], [wasmRefType(sig)]))
    .addBody([kExprLocalGet, 0, kExprRefAsNonNull])
    .exportFunc();

  builder.addFunction(
      "refAsNonNullAny",
      makeSig([kWasmAnyRef], [wasmRefType(kWasmAnyRef)]))
    .addBody([kExprLocalGet, 0, kExprRefAsNonNull])
    .exportFunc();

  builder.addFunction(
      "refAsNonNullI31",
      makeSig([kWasmI31Ref], [wasmRefType(kWasmI31Ref)]))
    .addBody([kExprLocalGet, 0, kExprRefAsNonNull])
    .exportFunc();

  builder.addFunction(
      "refAsNonNullExtern",
      makeSig([kWasmExternRef], [wasmRefType(kWasmExternRef)]))
    .addBody([kExprLocalGet, 0, kExprRefAsNonNull])
    .exportFunc();

  let instance = builder.instantiate();

  assertTraps(kTrapNullDereference, () => instance.exports.structGet0(null));
  assertTraps(kTrapNullDereference,
              () => instance.exports.structSet0(null, 15));
  assertTraps(kTrapNullDereference, () => instance.exports.structGet1(null));
  assertTraps(kTrapNullDereference,
              () => instance.exports.structSet1(null, 15n));
  assertTraps(kTrapNullDereference, () => instance.exports.structGet2(null));
  assertTraps(kTrapNullDereference,
              () => instance.exports.structSet2(null, 15.0));
  assertTraps(kTrapNullDereference, () => instance.exports.structGet3(null));
  assertTraps(kTrapNullDereference,
              () => instance.exports.structSet3(null, 15.0));
  assertTraps(kTrapNullDereference, () => instance.exports.structRefGet(null));
  assertTraps(kTrapNullDereference,
              () => instance.exports.structRefSet(null, null));

  assertTraps(kTrapNullDereference, () => instance.exports.arrayGet(null, 0));
  assertTraps(kTrapNullDereference,
              () => instance.exports.arrayGet(null, 2000000000));
  assertTraps(kTrapNullDereference,
              () => instance.exports.arraySet(null, 0, 42n));
  assertTraps(kTrapNullDereference,
              () => instance.exports.arraySet(null, 2000000000, 42n));
  assertTraps(kTrapNullDereference,
              () => instance.exports.arrayRefGet(null, 0));
  assertTraps(kTrapNullDereference,
              () => instance.exports.arrayRefGet(null, 2000000000));
  assertTraps(kTrapNullDereference,
              () => instance.exports.arrayRefSet(null, 0, null));
  assertTraps(kTrapNullDereference,
              () => instance.exports.arrayRefSet(null, 2000000000, null));
  assertTraps(kTrapNullDereference, () => instance.exports.arrayLen(null));
  assertTraps(kTrapNullDereference,
              () => instance.exports.arrayCopy(null, null));
  assertTraps(kTrapNullDereference,
              () => instance.exports.arrayFill(null, 42n));
  assertTraps(kTrapNullDereference,
              () => instance.exports.callFuncRef(null, 42));
  assertTraps(kTrapNullDereference,
              () => instance.exports.refAsNonNullStruct(null));
  assertTraps(kTrapNullDereference,
              () => instance.exports.refAsNonNullFunction(null));
  assertTraps(kTrapNullDereference,
              () => instance.exports.refAsNonNullAny(null));
  assertEquals(42, instance.exports.refAsNonNullAny(42));
  assertTraps(kTrapNullDereference,
              () => instance.exports.refAsNonNullI31(null));
  assertEquals(42, instance.exports.refAsNonNullI31(42));
  assertTraps(kTrapNullDereference,
              () => instance.exports.refAsNonNullExtern(null));
  let object = {};
  assertEquals(object, instance.exports.refAsNonNullExtern(object));
})();
                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/wasm/gc-optimization-array-get.js                                  0000664 0000000 0000000 00000003474 14746647661 0025040 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --no-liftoff --no-wasm-lazy-compilation
// Flags: --no-experimental-wasm-inlining --no-wasm-loop-unrolling
// Flags: --no-wasm-loop-peeling

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestArrayGetTypeInference() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();
  let struct = builder.addStruct([makeField(kWasmI32, true)]);
  let array = builder.addArray(wasmRefType(struct), true);

  builder.addFunction("arrayGetSameType",
    makeSig([kWasmI32, wasmRefNullType(array)], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kExprIf, kStructRefCode,
        kExprLocalGet, 1,
        kExprI32Const, 0,
        kGCPrefix, kExprArrayGet, array,
      kExprElse,
        kExprLocalGet, 1,
        kExprI32Const, 1,
        kGCPrefix, kExprArrayGet, array,
      kExprEnd,
      // This is always true.
      kGCPrefix, kExprRefTest, struct,
    ])
    .exportFunc();

  builder.addFunction("arrayGetDifferentType",
    makeSig([kWasmI32, wasmRefNullType(array)], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kExprIf, kStructRefCode,
        kExprRefNull, kStructRefCode,
      kExprElse,
        kExprLocalGet, 1,
        kExprI32Const, 1,
        kGCPrefix, kExprArrayGet, array,
      kExprEnd,
      // This cannot be optimized away.
      kGCPrefix, kExprRefTest, struct,
    ])
    .exportFunc();

  let instance = builder.instantiate({});
  assertTraps(kTrapNullDereference,
    () => instance.exports.arrayGetSameType(1, null));
  assertEquals(0, instance.exports.arrayGetDifferentType(1, null));
  assertTraps(kTrapNullDereference,
    () => instance.exports.arrayGetSameType(0, null));
})();
                                                                                                                                                                                                    node-23.7.0/deps/v8/test/mjsunit/wasm/gc-optimizations.js                                           0000664 0000000 0000000 00000113177 14746647661 0023334 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --no-liftoff --no-wasm-lazy-compilation
// Flags: --no-experimental-wasm-inlining --no-wasm-loop-unrolling
// Flags: --no-wasm-loop-peeling

// This tests are meant to examine if Turbofan CsaLoadElimination works
// correctly for wasm. The TurboFan graphs can be examined with --trace-turbo.
d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// Fresh objects, known offsets
(function LoadEliminationtFreshKnownTest() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();
  let struct = builder.addStruct([makeField(kWasmI32, true),
                                  makeField(kWasmI32, true)]);

  builder.addFunction("main", makeSig([kWasmI32], [kWasmI32]))
    .addLocals(wasmRefNullType(struct), 1)
    .addBody([
      kExprI32Const, 10,  // local1 = struct(10, 100);
      kExprI32Const, 100,
      kGCPrefix, kExprStructNew, struct,
      kExprLocalSet, 1,
      kExprLocalGet, 0,  // Split control based on an unknown value
      kExprIf, kWasmI32,
        kExprLocalGet, 1,  // local1.field1 = 42
        kExprI32Const, 42,
        kGCPrefix, kExprStructSet, struct, 1,
        kExprLocalGet, 1,  // local1.field1
        kGCPrefix, kExprStructGet, struct, 1,
      kExprElse,
        kExprLocalGet, 1,  // local1.field1 = 11
        kExprI32Const, 11,
        kGCPrefix, kExprStructSet, struct, 1,
        kExprLocalGet, 1,  // local1.field1 = 22
        kExprI32Const, 22,
        kGCPrefix, kExprStructSet, struct, 1,
        kExprLocalGet, 1,    // local1.field1 + local1.field1
        kGCPrefix, kExprStructGet, struct, 1,
        kExprLocalGet, 1,
        kGCPrefix, kExprStructGet, struct, 1,
        kExprI32Add,
      kExprEnd,
      kExprLocalGet, 1,  // return if-result * (local1.field1 + local1.field0)
      kGCPrefix, kExprStructGet, struct, 0,
      kExprLocalGet, 1,
      kGCPrefix, kExprStructGet, struct, 1,
      kExprI32Add,
      kExprI32Mul
    ])
    .exportFunc();

  let instance = builder.instantiate({});
  assertEquals(instance.exports.main(1), 42 * (42 + 10));
  assertEquals(instance.exports.main(0), (22 + 22) * (22 + 10));
})();

(function LoadEliminationtConstantKnownTest() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();
  let struct = builder.addStruct([makeField(kWasmI32, true)]);

  let replaced_value = 55
  let param_1_value = 42
  let init_value_1 = 5
  let init_value_2 = 17

  let tester = builder.addFunction("tester", makeSig(
      [wasmRefType(struct), wasmRefType(struct)], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprStructGet, struct, 0,

      kExprLocalGet, 0,
      kExprI32Const, replaced_value,
      kGCPrefix, kExprStructSet, struct, 0,

      // We should eliminate this load and replace it with replaced_value
      kExprLocalGet, 0,
      kGCPrefix, kExprStructGet, struct, 0,

      kExprLocalGet, 1,
      kExprI32Const, param_1_value,
      kGCPrefix, kExprStructSet, struct, 0,

      // Although we could eliminate this load before, we cannot anymore,
      // because the parameters may alias.
      kExprLocalGet, 0,
      kGCPrefix, kExprStructGet, struct, 0,

      kExprI32Add, kExprI32Add
    ]);

  function buildStruct(value) {
    return [kExprI32Const, value,
            kGCPrefix, kExprStructNew, struct];
  }

  builder.addFunction("main_non_aliasing", kSig_i_v)
    .addBody([
      ...buildStruct(init_value_1), ...buildStruct(init_value_2),
      kExprCallFunction, tester.index])
    .exportFunc();

  builder.addFunction("main_aliasing", kSig_i_v)
    .addLocals(wasmRefNullType(struct), 1)
    .addBody([
      ...buildStruct(init_value_1), kExprLocalSet, 0,
      kExprLocalGet, 0, kExprRefAsNonNull,
      kExprLocalGet, 0, kExprRefAsNonNull,
      kExprCallFunction, tester.index])
    .exportFunc();

  let instance = builder.instantiate({});
  assertEquals(init_value_1 + replaced_value + replaced_value,
               instance.exports.main_non_aliasing());
  assertEquals(init_value_1 + replaced_value + param_1_value,
               instance.exports.main_aliasing());
})();

(function LoadEliminationtArbitraryKnownTest() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();
  let struct = builder.addStruct([makeField(kWasmI32, true)]);

  let initial_value = 19;
  let replacing_value_1 = 55;
  let replacing_value_2 = 37;

  let id = builder.addFunction("id", makeSig([wasmRefNullType(struct)],
                                             [wasmRefNullType(struct)]))
      .addBody([kExprLocalGet, 0])

  builder.addFunction("main", kSig_i_v)
    .addLocals(wasmRefNullType(struct), 2)
    .addBody([
      // We store a fresh struct in local0
      kExprI32Const, initial_value,
      kGCPrefix, kExprStructNew, struct,
      kExprLocalSet, 0,

      // We pass it through a function and store it to local1. local1 may now
      // alias with anything.
      kExprLocalGet, 0, kExprCallFunction, id.index, kExprLocalSet, 1,

      kExprLocalGet, 0,
      kExprI32Const, replacing_value_1,
      kGCPrefix, kExprStructSet, struct, 0,

      // We should eliminate this load.
      kExprLocalGet, 0, kGCPrefix, kExprStructGet, struct, 0,

      kExprLocalGet, 1,
      kExprI32Const, replacing_value_2,
      kGCPrefix, kExprStructSet, struct, 0,

      // We should not eliminate this load.
      kExprLocalGet, 0, kGCPrefix, kExprStructGet, struct, 0,

      kExprI32Add])
    .exportFunc();

  let instance = builder.instantiate({});
  assertEquals(replacing_value_1 + replacing_value_2, instance.exports.main());
})();

(function LoadEliminationtFreshUnknownTest() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();
  let array = builder.addArray(kWasmI64, true);

  // parameter: unknown array index
  builder.addFunction("main", makeSig([kWasmI32], [kWasmI32]))
    .addLocals(wasmRefNullType(array), 1)
    .addBody([
      kExprI32Const, 5,
      kGCPrefix, kExprArrayNewDefault, array,
      kExprLocalSet, 1,

      kExprLocalGet, 1,  // a[i] = i for i = {0..4}
      kExprI32Const, 0,
      kExprI64Const, 0,
      kGCPrefix, kExprArraySet, array,

      kExprLocalGet, 1,
      kExprI32Const, 1,
      kExprI64Const, 1,
      kGCPrefix, kExprArraySet, array,

      kExprLocalGet, 1,
      kExprI32Const, 2,
      kExprI64Const, 2,
      kGCPrefix, kExprArraySet, array,

      kExprLocalGet, 1,
      kExprI32Const, 3,
      kExprI64Const, 3,
      kGCPrefix, kExprArraySet, array,

      kExprLocalGet, 1,
      kExprI32Const, 4,
      kExprI64Const, 4,
      kGCPrefix, kExprArraySet, array,

      // Get a constant index a[4] before setting unknown indices
      kExprLocalGet, 1,
      kExprI32Const, 4,
      kGCPrefix, kExprArrayGet, array,

      kExprLocalGet, 1,  // Set a[local0] = 33
      kExprLocalGet, 0,
      kExprI64Const, 33,
      kGCPrefix, kExprArraySet, array,

      kExprLocalGet, 1,  // Get a[local0]
      kExprLocalGet, 0,
      kGCPrefix, kExprArrayGet, array,

      kExprLocalGet, 1,  // Known index load cannot be eliminated anymore
      kExprI32Const, 3,
      kGCPrefix, kExprArrayGet, array,

      // A load from different unknown index a[local0 + 1] cannot be eliminated
      kExprLocalGet, 1,
      kExprLocalGet, 0,
      kExprI32Const, 1,
      kExprI32Add,
      kGCPrefix, kExprArrayGet, array,

      kExprI64Add, // return a[4] * (a[local0] - (a[3] + a[local0 + 1]))
      kExprI64Sub,
      kExprI64Mul,
      kExprI32ConvertI64  // To not have to worry about BigInts in JS world
    ])
    .exportFunc();

  let instance = builder.instantiate({});
  assertEquals(4 * (33 - (3 + 1)), instance.exports.main(0));
  assertEquals(4 * (33 - (3 + 2)), instance.exports.main(1));
  assertEquals(4 * (33 - (3 + 3)), instance.exports.main(2));
  assertEquals(4 * (33 - (33 + 4)), instance.exports.main(3));
})();

(function LoadEliminationtAllBetsAreOffTest() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();
  let struct = builder.addStruct([makeField(kWasmI32, true)]);
  let array = builder.addArray(kWasmI32, true);

  let value_0 = 19;
  let value_1 = 55;
  let value_2 = 2;

  let id = builder.addFunction("id", makeSig([wasmRefNullType(array)],
                                             [wasmRefNullType(array)]))
      .addBody([kExprLocalGet, 0])

  // parameters: array, index
  let tester = builder.addFunction("tester",
      makeSig([wasmRefType(array), kWasmI32], [kWasmI32]))
    .addLocals(wasmRefNullType(struct), 1)
    .addLocals(wasmRefNullType(array), 1)
    .addBody([
      // We store a fresh struct in local1
      kExprI32Const, 0,
      kGCPrefix, kExprStructNew, struct,
      kExprLocalSet, 2,

      // We pass the array parameter through a function and store it to local2.
      kExprLocalGet, 0, kExprCallFunction, id.index, kExprLocalSet, 3,

      // Set the parameter array, the fresh struct, then the arbitrary array to
      // an unknown offset.
      kExprLocalGet, 0,
      kExprI32Const, 5,
      kExprI32Const, value_0,
      kGCPrefix, kExprArraySet, array,

      kExprLocalGet, 2,
      kExprI32Const, value_1,
      kGCPrefix, kExprStructSet, struct, 0,

      kExprLocalGet, 3,
      kExprLocalGet, 1,
      kExprI32Const, value_2,
      kGCPrefix, kExprArraySet, array,

      // Neither load can be eliminated.
      kExprLocalGet, 0,
      kExprI32Const, 5,
      kGCPrefix, kExprArrayGet, array,

      kExprLocalGet, 2,
      kGCPrefix, kExprStructGet, struct, 0,

      kExprI32Add]);

  builder.addFunction("main", kSig_i_i)
    .addBody([
      kExprI32Const, 10,
      kGCPrefix, kExprArrayNewDefault, array,
      kExprI32Const, 7,
      kExprCallFunction, tester.index,
    ])
    .exportFunc();

  let instance = builder.instantiate({});
  assertEquals(value_0 + value_1, instance.exports.main());
})();

(function WasmLoadEliminationArrayLength() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();
  let array = builder.addArray(kWasmI32, true);
  builder.addFunction("producer", makeSig([kWasmI32], [wasmRefType(array)]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprArrayNewDefault, array])
    .exportFunc();
  let side_effect = builder.addFunction("side_effect", kSig_v_v).addBody([]);
  builder.addFunction("tester", makeSig([wasmRefType(array)], [kWasmI32]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprArrayLen,
              kExprI32Const, 1, kExprI32Add,
              kGCPrefix, kExprArrayNewDefault, array,
              kExprCallFunction, side_effect.index,  // unknown side-effect
              kGCPrefix, kExprArrayLen,
              kExprLocalGet, 0, kGCPrefix, kExprArrayLen,
              kExprI32Mul])
    .exportFunc();
  let instance = builder.instantiate();
  assertEquals(10 * 11,
               instance.exports.tester(instance.exports.producer(10)));
})();

(function WasmLoadEliminationUnrelatedTypes() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();
  let struct1 = builder.addStruct([makeField(kWasmI32, true)]);
  let struct2 = builder.addStruct([makeField(kWasmI32, true),
                                   makeField(kWasmI64, true)]);

  builder.addFunction("tester",
      makeSig([wasmRefType(struct1), wasmRefType(struct2)], [kWasmI32]))
    // f(x, y) { y.f = x.f + 10; return y.f * x.f }
    // x.f load in the state should survive y.f store.
    .addBody([kExprLocalGet, 1,
              kExprLocalGet, 0, kGCPrefix, kExprStructGet, struct1, 0,
              kExprI32Const, 10, kExprI32Add,
              kGCPrefix, kExprStructSet, struct2, 0,
              kExprLocalGet, 0, kGCPrefix, kExprStructGet, struct1, 0,
              kExprLocalGet, 1, kGCPrefix, kExprStructGet, struct2, 0,
              kExprI32Mul]);

  builder.instantiate()
})();

(function EscapeAnalysisWithLoadElimination() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();
  let struct1 = builder.addStruct([makeField(kWasmI32, true)]);
  let struct2 = builder.addStruct([makeField(wasmRefNullType(struct1), true)]);

  // TF should eliminate both allocations in this function.
  builder.addFunction("main", kSig_i_i)
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprStructNew, struct1,
      kGCPrefix, kExprStructNew, struct2,
      kGCPrefix, kExprStructGet, struct2, 0,
      kGCPrefix, kExprStructGet, struct1, 0])
    .exportFunc();

  let instance = builder.instantiate({});
  assertEquals(42, instance.exports.main(42));
})();

(function EscapeAnalysisWithInterveningEffect() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();
  let struct1 = builder.addStruct([makeField(kWasmI32, true)]);
  let struct2 = builder.addStruct([makeField(wasmRefNullType(struct1), true)]);

  let nop = builder.addFunction("nop", kSig_v_v).addBody([]);

  // TF should eliminate both allocations in this function, despite the
  // intervening effectful call.
  builder.addFunction("main", kSig_i_i)
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprStructNew, struct1,
      kExprCallFunction, nop.index,
      kGCPrefix, kExprStructNew, struct2,
      kExprLocalGet, 0,
      kExprReturn])
    .exportFunc();

  let instance = builder.instantiate({});
  assertEquals(42, instance.exports.main(42));
})();

(function AllocationFolding() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();

  let struct_index = builder.addStruct([makeField(kWasmI32, true)]);
  let struct_2 = builder.addStruct([
    makeField(wasmRefType(struct_index), false),
    makeField(wasmRefType(struct_index), false)
  ]);

  let global = builder.addGlobal(
      wasmRefNullType(struct_2), true, false, [kExprRefNull, struct_2]);

  // The three alocations should be folded.
  builder.addFunction("main", kSig_i_i)
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprStructNew, struct_index,
      kExprI32Const, 43,
      kGCPrefix, kExprStructNew, struct_index,
      kGCPrefix, kExprStructNew, struct_2,
      kExprGlobalSet, global.index,
      kExprLocalGet, 0,
    ])
    .exportFunc();

  let instance = builder.instantiate();
  assertEquals(10, instance.exports.main(10));
})();

(function PathBasedTypedOptimization() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();

  let super_struct = builder.addStruct([makeField(kWasmI32, true)]);
  let mid_struct = builder.addStruct(
    [makeField(kWasmI32, true), makeField(kWasmI32, true)], super_struct);
  let sub_struct = builder.addStruct(
    [makeField(kWasmI32, true), makeField(kWasmI32, true),
     makeField(kWasmI32, true)],
    mid_struct);

  let addToLocal = [kExprLocalGet, 1, kExprI32Add, kExprLocalSet, 1];

  builder.addFunction(
      "pathBasedTypes", makeSig([wasmRefNullType(super_struct)], [kWasmI32]))
    .addLocals(kWasmI32, 1)
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprRefTest, sub_struct,

      // These casts have to be preserved.
      kExprLocalGet, 0,
      kGCPrefix, kExprRefCast, mid_struct,
      kGCPrefix, kExprRefCast, sub_struct,
      kGCPrefix, kExprStructGet, sub_struct, 1,
      ...addToLocal,

      kExprIf, kWasmVoid,
        // Both these casts should be optimized away.
        kExprLocalGet, 0,
        kGCPrefix, kExprRefCast, mid_struct,
        kGCPrefix, kExprRefCast, sub_struct,
        kGCPrefix, kExprStructGet, sub_struct, 1,
        ...addToLocal,

        kExprBlock, kWasmRefNull, super_struct,
          kExprLocalGet, 0,
          // This should also get optimized away.
          kGCPrefix, kExprBrOnCastFail, 0b11, 0, super_struct,
              mid_struct,
          // So should this, despite being represented by a TypeGuard alias.
          kGCPrefix, kExprRefCast, sub_struct,
          kGCPrefix, kExprStructGet, sub_struct, 1,
          ...addToLocal,
          kExprLocalGet, 0,  // Due to the branch result type.
        kExprEnd,
        kExprDrop,
      kExprElse,
        // This (always trapping) cast should be optimized away.
        // (If the ref.test in the start block returns 0 the cast to sub_struct
        // in that block will already fail.)
        kExprLocalGet, 0,
        kGCPrefix, kExprRefCast, sub_struct,
        kGCPrefix, kExprStructGet, sub_struct, 1,
        ...addToLocal,
      kExprEnd,
      // This cast should be optimized away.
      kExprLocalGet, 0,
      kGCPrefix, kExprRefCast, sub_struct,
      kGCPrefix, kExprStructGet, sub_struct, 1,
      kExprLocalGet, 1, kExprI32Add
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertTraps(kTrapIllegalCast, () => wasm.pathBasedTypes(null));
})();

(function IndependentCastNullRefType() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct_super = builder.addStruct([makeField(kWasmI32, true)]);
  let struct_b = builder.addStruct([makeField(kWasmI32, true)], struct_super);
  let struct_a = builder.addStruct(
    [makeField(kWasmI32, true), makeField(kWasmI32, true)], struct_super);

  let callee_sig = makeSig([wasmRefNullType(struct_a)], [kWasmI32]);
  let callee = builder.addFunction("callee", callee_sig)
    .addBody([
      // Cast from struct_a to struct_b via common base type struct_super.
      kExprLocalGet, 0,
      kGCPrefix, kExprRefCastNull, struct_super,
      kGCPrefix, kExprRefCastNull, struct_b, // annotated as 'ref null none'
      kExprRefIsNull,
    ]);

  builder.addFunction("main", kSig_i_i)
    .addLocals(wasmRefNullType(struct_a), 1)
    .addBody([
      kExprLocalGet, 0,
      kExprIf, kWasmVoid,
      kExprI32Const, 10,
      kExprI32Const, 100,
      kGCPrefix, kExprStructNew, struct_a,
      kExprLocalSet, 1,
      kExprEnd,
      kExprLocalGet, 1,
      kExprCallFunction, callee.index
    ]).exportFunc();

  let instance = builder.instantiate({});
  // main calls 'callee(null)'
  // -> (ref.is_null (ref.cast struct_b (ref.cast struct_super (local.get 0))))
  //    returns true.
  assertEquals(1, instance.exports.main(0));
  // main calls 'callee(struct.new struct_a)'
  // -> (ref.cast struct_b) traps.
  assertTraps(kTrapIllegalCast, () => instance.exports.main(1));
})();

(function StaticCastOfKnownNull() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct_super = builder.addStruct([makeField(kWasmI32, true)]);
  let struct_b = builder.addStruct([makeField(kWasmI32, true)], struct_super);
  let struct_a = builder.addStruct(
    [makeField(kWasmI32, true), makeField(kWasmI32, true)], struct_super);

  let callee_sig = makeSig([wasmRefNullType(struct_super)], [kWasmI32]);
  let callee = builder.addFunction("callee", callee_sig)
    .addBody([
      kExprBlock, kWasmRefNull, struct_super,
      kExprLocalGet, 0,
      kExprBrOnNonNull, 0,
      // local.get 0 is known to be null until end of block.
      kExprLocalGet, 0,
      // This cast is a no-op and shold be optimized away.
      kGCPrefix, kExprRefCastNull, struct_b,
      kExprEnd,
      kExprRefIsNull,
    ]);

  builder.addFunction("main", kSig_i_v)
    .addBody([
      kExprRefNull, struct_a,
      kExprCallFunction, callee.index
    ]).exportFunc();

  let instance = builder.instantiate({});
  assertEquals(1, instance.exports.main());
})();

(function AssertNullAfterCastIncompatibleTypes() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct_super = builder.addStruct([makeField(kWasmI32, true)]);
  let struct_b = builder.addStruct([makeField(kWasmI32, true)], struct_super);
  let struct_a = builder.addStruct(
    [makeField(kWasmI32, true), makeField(kWasmI32, true)], struct_super);
  let callee_sig = makeSig([wasmRefNullType(struct_super)], [kWasmI32]);

  builder.addFunction("mkStruct", makeSig([], [kWasmExternRef]))
    .addBody([kGCPrefix, kExprStructNewDefault, struct_a,
              kGCPrefix, kExprExternConvertAny])
    .exportFunc();

  let callee = builder.addFunction("callee", callee_sig)
    .addBody([
       kExprLocalGet, 0, kGCPrefix, kExprRefCast, struct_b,
       kExprRefAsNonNull,
       kGCPrefix, kExprStructGet, struct_b, 0]);

  builder.addFunction("main", makeSig([kWasmExternRef], [kWasmI32]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprAnyConvertExtern,
              kGCPrefix, kExprRefCast, struct_a,
              kExprCallFunction, callee.index])
    .exportFunc();

  let instance = builder.instantiate({});
  assertTraps(kTrapIllegalCast,
              () => instance.exports.main(instance.exports.mkStruct()));
})();

(function StructGetMultipleNullChecks() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct = builder.addStruct([makeField(kWasmI32, true),
                                  makeField(kWasmI32, true)]);

  builder.addFunction("main",
                      makeSig([kWasmI32, wasmRefNullType(struct)], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kExprIf, kWasmI32,
        kExprLocalGet, 1,
        kGCPrefix, kExprStructGet, struct, 0,
        kExprLocalGet, 1,
        // The null check should be removed for this struct.
        kGCPrefix, kExprStructGet, struct, 1,
        kExprI32Add,
      kExprElse,
        kExprLocalGet, 1,
        kGCPrefix, kExprStructGet, struct, 0,
      kExprEnd,
      kExprLocalGet, 1,
      // The null check here could be removed if we compute type intersections.
      kGCPrefix, kExprStructGet, struct, 1,
      kExprI32Mul])
    .exportFunc();

  builder.instantiate({});
})();

(function StructSetMultipleNullChecks() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct = builder.addStruct([makeField(kWasmI32, true),
                                  makeField(kWasmI32, true)]);

  builder.addFunction("structSetMultiple",
                      makeSig([wasmRefNullType(struct)], []))
    .addBody([
      kExprLocalGet, 0,
      kExprI32Const, 42,
      kGCPrefix, kExprStructSet, struct, 0,
      kExprLocalGet, 0,
      kExprI32Const, 43,
      kGCPrefix, kExprStructSet, struct, 1,
    ])
    .exportFunc();

  let wasm = builder.instantiate({}).exports;
  assertTraps(kTrapNullDereference, () => wasm.structSetMultiple(null));
})();

(function ArrayLenMultipleNullChecks() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let array = builder.addArray(kWasmI32, true);

  builder.addFunction("arrayLenMultiple",
                      makeSig([wasmRefNullType(array)], [kWasmI32, kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprArrayLen,
      kExprLocalGet, 0,
      kGCPrefix, kExprArrayLen,
    ])
    .exportFunc();

  let wasm = builder.instantiate({}).exports;
  assertTraps(kTrapNullDereference, () => wasm.arrayLenMultiple(null));
})();

(function RedundantExternalizeInternalize() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let array = builder.addArray(kWasmI32, true);

  builder.addFunction('createArray',
      makeSig([kWasmI32], [kWasmExternRef]))
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprArrayNewFixed, array, 1,
      kGCPrefix, kExprExternConvertAny,
    ])
    .exportFunc();

  builder.addFunction('get', makeSig([kWasmExternRef, kWasmI32], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprAnyConvertExtern,
      // The following two operations are optimized away.
      kGCPrefix, kExprExternConvertAny,
      kGCPrefix, kExprAnyConvertExtern,
      //
      kGCPrefix, kExprRefCastNull, array,
      kExprLocalGet, 1,
      kGCPrefix, kExprArrayGet, array,
    ])
    .exportFunc();

  let instance = builder.instantiate({});
  let wasm = instance.exports;

  let wasmArray = wasm.createArray(10);
  assertEquals(10, wasm.get(wasmArray, 0));
})();

(function RedundantIsNull() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let array = builder.addArray(kWasmI32, true);

  builder.addFunction('checkIsNullAfterNonNullCast',
      makeSig([kWasmExternRef], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprRefCast, kExternRefCode,
      kExprDrop,
      kExprLocalGet, 0,
      kExprRefIsNull,
    ])
    .exportFunc();

  let instance = builder.instantiate({});
  let wasm = instance.exports;

  assertTraps(kTrapIllegalCast, () => wasm.checkIsNullAfterNonNullCast(null));
  assertEquals(0, wasm.checkIsNullAfterNonNullCast("not null"));
})();

(function RefTestUnrelated() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct = builder.addStruct([makeField(kWasmI32, true)]);
  let other = builder.addStruct([makeField(kWasmI64, true)]);

  builder.addFunction('refTestUnrelatedNull',
      makeSig([kWasmAnyRef], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprRefCastNull, other,
      kExprDrop,
      kExprLocalGet, 0,
      // This ref.test will only succeed if the input is null.
      kGCPrefix, kExprRefTestNull, struct,
    ])
    .exportFunc();

    builder.addFunction('refTestUnrelated',
    makeSig([kWasmAnyRef], [kWasmI32]))
  .addBody([
    kExprLocalGet, 0,
    kGCPrefix, kExprRefCastNull, other,
    kExprDrop,
    kExprLocalGet, 0,
    // This ref.test always returns 0.
    kGCPrefix, kExprRefTest, struct,
  ])
  .exportFunc();

  let instance = builder.instantiate({});
  let wasm = instance.exports;

  assertEquals(1, wasm.refTestUnrelatedNull(null));
  assertTraps(kTrapIllegalCast, () => wasm.refTestUnrelatedNull("not null"));
  assertEquals(0, wasm.refTestUnrelated(null));
  assertTraps(kTrapIllegalCast, () => wasm.refTestUnrelated("not null"));
})();

(function RefFuncIsNull() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let fct = builder.addFunction('dummy', makeSig([], []))
      .addBody([]).exportFunc();

  builder.addFunction('refFuncIsNull',
      makeSig([], [kWasmI32]))
    .addLocals(kWasmFuncRef, 1)
    .addBody([
      kExprRefFunc, fct.index,
      kExprLocalSet, 0,
      kExprLocalGet, 0,
      kExprRefIsNull,
    ])
    .exportFunc();

  let instance = builder.instantiate({});
  let wasm = instance.exports;

  assertEquals(0, wasm.refFuncIsNull());
})();


(function ArrayNewRefTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let array_base = builder.addArray(kWasmI32, true);
  let array_sub = builder.addArray(kWasmI32, true, array_base);
  let array_other = builder.addArray(kWasmI64, true);

  builder.addFunction('arrayNewRefTest',
      makeSig([], [kWasmI32, kWasmI32, kWasmI32]))
    .addLocals(kWasmAnyRef, 1)
    .addBody([
      kExprI32Const, 42,
      kGCPrefix, kExprArrayNewFixed, array_sub, 1,
      kExprLocalSet, 0,
      // All these checks can be statically inferred.
      kExprLocalGet, 0, kGCPrefix, kExprRefTest, array_base,
      kExprLocalGet, 0, kGCPrefix, kExprRefTest, array_sub,
      kExprLocalGet, 0, kGCPrefix, kExprRefTest, array_other,
    ])
    .exportFunc();

  let instance = builder.instantiate({});
  let wasm = instance.exports;

  assertEquals([1, 1, 0], wasm.arrayNewRefTest());
})();

(function TypePropagationPhi() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let array_base = builder.addArray(kWasmI32, true);
  let array_sub = builder.addArray(kWasmI32, true, array_base);

  builder.addFunction('typePhi',
      makeSig([kWasmI32], [kWasmI32]))
    .addLocals(kWasmArrayRef, 1)
    .addBody([
      kExprLocalGet, 0,
      kExprIf, kArrayRefCode,
        kExprLocalGet, 0,
        kGCPrefix, kExprArrayNewFixed, array_base, 1,
      kExprElse,
        kExprLocalGet, 0,
        kGCPrefix, kExprArrayNewFixed, array_sub, 1,
      kExprEnd,
      // While the two inputs to the phi have different types (ref $array_base)
      // and (ref $array_sub), they both share the information of being not
      // null, so the ref.is_null can be optimized away. Due to escape analysis,
      // the whole function can be simplified to just returning 0.
      kExprRefIsNull,
    ])
    .exportFunc();

  let instance = builder.instantiate({});
  let wasm = instance.exports;

  assertEquals(0, wasm.typePhi(0));
  assertEquals(0, wasm.typePhi(1));
})();

(function TypePropagationLoopPhiOptimizable() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let struct_base = builder.addStruct([makeField(kWasmI32, true)]);
  let struct_sub = builder.addStruct([makeField(kWasmI32, true)], struct_base);

  // This function counts all the structs stored in local[1] which are of type
  // struct_sub (which in this case are all the values).
  builder.addFunction('loopPhiOptimizable',
      makeSig([kWasmI32], [kWasmI32]))
    .addLocals(kWasmAnyRef, 1) // local with changing type
    .addLocals(kWasmI32, 1)    // result
    .addBody([
      kGCPrefix, kExprStructNewDefault, struct_sub,
      kExprLocalSet, 1,
      kExprLoop, kWasmVoid,
        // result += ref.test (local.get 1)
        kExprLocalGet, 1,
        kGCPrefix, kExprRefTest, struct_sub,
        kExprLocalGet, 2,
        kExprI32Add,
        kExprLocalSet, 2,
        // local[1] = new struct_sub
        kGCPrefix, kExprStructNewDefault, struct_sub,
        kExprLocalSet, 1, // This will cause a loop phi.
        // if (--(local.get 0)) continue;
        kExprLocalGet, 0,
        kExprI32Const, 1,
        kExprI32Sub,
        kExprLocalTee, 0,
        kExprBrIf, 0,
      kExprEnd,
      kExprLocalGet, 2,
    ])
    .exportFunc();

  let instance = builder.instantiate({});
  let wasm = instance.exports;

  assertEquals(1, wasm.loopPhiOptimizable(1));
  assertEquals(2, wasm.loopPhiOptimizable(2));
  assertEquals(20, wasm.loopPhiOptimizable(20));
})();

(function TypePropagationLoopPhiCheckRequired() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let struct_base = builder.addStruct([makeField(kWasmI32, true)]);
  let struct_sub = builder.addStruct([makeField(kWasmI32, true)], struct_base);

  // This function counts all the structs stored in local[1] which are of type
  // struct_sub (which in this case is only the first).
  builder.addFunction('loopPhiCheckRequired',
      makeSig([kWasmI32], [kWasmI32]))
    .addLocals(kWasmAnyRef, 1) // local with changing type
    .addLocals(kWasmI32, 1)    // result
    .addBody([
      kGCPrefix, kExprStructNewDefault, struct_sub,
      kExprLocalSet, 1,
      kExprLoop, kWasmVoid,
        // result += ref.test (local.get 1)
        kExprLocalGet, 1,
        kGCPrefix, kExprRefTest, struct_sub,
        kExprLocalGet, 2,
        kExprI32Add,
        kExprLocalSet, 2,
        // local[1] = new struct_base
        kGCPrefix, kExprStructNewDefault, struct_base,
        kExprLocalSet, 1, // This will cause a loop phi.
        // if (--(local.get 0)) continue;
        kExprLocalGet, 0,
        kExprI32Const, 1,
        kExprI32Sub,
        kExprLocalTee, 0,
        kExprBrIf, 0,
      kExprEnd,
      kExprLocalGet, 2,
    ])
    .exportFunc();

  let instance = builder.instantiate({});
  let wasm = instance.exports;

  assertEquals(1, wasm.loopPhiCheckRequired(1));
  assertEquals(1, wasm.loopPhiCheckRequired(2));
  assertEquals(1, wasm.loopPhiCheckRequired(20));
})();

(function TypePropagationLoopPhiCheckRequiredUnrelated() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  // Differently to the test above, here the two types merged in the loop phi
  // are not in a subtype hierarchy, meaning that the loop phi needs to merge
  // them to a more generic ref struct.
  let struct_a = builder.addStruct([makeField(kWasmI32, true)]);
  let struct_b = builder.addStruct([makeField(kWasmI64, true)]);

  // This function counts all the structs stored in local[1] which are of type
  // struct_a (which in this case is only the first).
  builder.addFunction('loopPhiCheckRequiredUnrelated',
      makeSig([kWasmI32], [kWasmI32]))
    .addLocals(kWasmAnyRef, 1) // local with changing type
    .addLocals(kWasmI32, 1)    // result
    .addBody([
      kGCPrefix, kExprStructNewDefault, struct_a,
      kExprLocalSet, 1,
      kExprLoop, kWasmVoid,
        // result += ref.test (local.get 1)
        kExprLocalGet, 1,
        kGCPrefix, kExprRefTest, struct_a,
        kExprLocalGet, 2,
        kExprI32Add,
        kExprLocalSet, 2,
        // local[1] = new struct_base
        kGCPrefix, kExprStructNewDefault, struct_b,
        kExprLocalSet, 1, // This will cause a loop phi.
        // if (--(local.get 0)) continue;
        kExprLocalGet, 0,
        kExprI32Const, 1,
        kExprI32Sub,
        kExprLocalTee, 0,
        kExprBrIf, 0,
      kExprEnd,
      kExprLocalGet, 2,
    ])
    .exportFunc();

  let instance = builder.instantiate({});
  let wasm = instance.exports;

  assertEquals(1, wasm.loopPhiCheckRequiredUnrelated(1));
  assertEquals(1, wasm.loopPhiCheckRequiredUnrelated(2));
  assertEquals(1, wasm.loopPhiCheckRequiredUnrelated(20));
})();

(function TypePropagationCallRef() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let struct = builder.addStruct([makeField(kWasmI32, true)]);
  let sig = builder.addType(makeSig([kWasmI32], [wasmRefNullType(struct)]));

  builder.addFunction('callee', sig)
  .addBody([
    // local.get[0] ? null : new struct();
    kExprLocalGet, 0,
    kExprIf, kWasmVoid,
      kExprRefNull, struct,
      kExprReturn,
    kExprEnd,
    kGCPrefix, kExprStructNewDefault, struct,
  ])
  .exportFunc();

  builder.addFunction('callTypedWasm',
      makeSig([kWasmI32, wasmRefType(sig)], []))
    .addLocals(kWasmAnyRef, 1)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprCallRef, sig,
      kExprLocalSet, 2,
      kExprLocalGet, 2,
      // Can be optimized away based on the signature of the callee.
      kGCPrefix, kExprRefCastNull, kStructRefCode,
      // Can be converted into a check for not null.
      kGCPrefix, kExprRefCast, struct,
      kExprDrop,
    ])
    .exportFunc();

  let instance = builder.instantiate({});
  let wasm = instance.exports;

  wasm.callTypedWasm(0, wasm.callee);
  assertTraps(kTrapIllegalCast, () => wasm.callTypedWasm(1, wasm.callee));
})();

(function TypePropagationDeadBranch() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let struct = builder.addStruct([makeField(kWasmI32, true)]);

  builder.addFunction('deadBranch',
      makeSig([kWasmI32, kWasmStructRef], [kWasmI32]))
    .addLocals(kWasmAnyRef, 1)
    .addBody([
      kExprLocalGet, 1,
      kExprLocalSet, 2,
      kExprLocalGet, 0,
      kExprIf, kWasmVoid,
        kExprLocalGet, 2,
        // This cast always traps -> dead branch.
        kGCPrefix, kExprRefCast, kArrayRefCode,
        kExprDrop,
      kExprElse,
        kExprLocalGet, 2,
        kGCPrefix, kExprRefCast, struct,
        kExprDrop,
      kExprEnd,
      kExprLocalGet, 2,
      // This is the same cast as in the else branch. As the end of the true
      // branch is unreachable, this cast can be safely eliminated.
      kGCPrefix, kExprRefCast, struct,
      kGCPrefix, kExprStructGet, struct, 0,
    ])
    .exportFunc();

  let instance = builder.instantiate({});
  let wasm = instance.exports;
  assertTraps(kTrapIllegalCast, () => wasm.deadBranch(0, null));
})();

(function TypePropagationDeadByRefTestTrue() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let struct = builder.addStruct([makeField(kWasmI32, true)]);

  builder.addFunction('deadBranchBasedOnRefTestTrue',
      makeSig([kWasmStructRef], [kWasmI32]))
    .addLocals(kWasmAnyRef, 1)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalSet, 1,
      kExprLocalGet, 1,
      // This test always succeeds, the true branch is always taken.
      kGCPrefix, kExprRefTestNull, kStructRefCode,
      kExprIf, kWasmVoid,
        kExprLocalGet, 1,
        kGCPrefix, kExprRefCast, struct,
        kExprDrop,
      kExprEnd,
      kExprLocalGet, 1,
      // This is the same cast as in the true branch. As the true branch is
      // guaranteed to be taken, the cast can be eliminated.
      kGCPrefix, kExprRefCast, struct,
      kGCPrefix, kExprStructGet, struct, 0,
    ])
    .exportFunc();

  let instance = builder.instantiate({});
  let wasm = instance.exports;
  assertTraps(kTrapIllegalCast, () => wasm.deadBranchBasedOnRefTestTrue(null));
})();

(function TypePropagationDeadByRefTestFalse() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let struct = builder.addStruct([makeField(kWasmI32, true)]);

  builder.addFunction('deadBranchBasedOnRefTestFalse',
      makeSig([kWasmStructRef], [kWasmI32]))
    .addLocals(kWasmAnyRef, 1)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalSet, 1,
      kExprLocalGet, 1,
      // This test is always false, the else branch is always taken.
      kGCPrefix, kExprRefTest, kArrayRefCode,
      kExprIf, kWasmVoid,
      kExprElse,
        kExprLocalGet, 1,
        kGCPrefix, kExprRefCast, struct,
        kExprDrop,
      kExprEnd,
      kExprLocalGet, 1,
      // This is the same cast as in the else branch. As the else branch is
      // guaranteed to be taken, the cast can be eliminated.
      kGCPrefix, kExprRefCast, struct,
      kGCPrefix, kExprStructGet, struct, 0,
    ])
    .exportFunc();

  let instance = builder.instantiate({});
  let wasm = instance.exports;
  assertTraps(kTrapIllegalCast, () => wasm.deadBranchBasedOnRefTestFalse(null));
})();

(function TypePropagationDeadByIsNull() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let struct = builder.addStruct([makeField(kWasmI32, true)]);

  builder.addFunction('deadBranchBasedOnIsNull',
      makeSig([wasmRefType(kWasmAnyRef)], [kWasmI32]))
    .addLocals(kWasmAnyRef, 1)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalSet, 1,
      kExprLocalGet, 1,
      // This is always false, the else branch is always taken.
      kExprRefIsNull,
      kExprIf, kWasmVoid,
      kExprElse,
        kExprLocalGet, 1,
        kGCPrefix, kExprRefCast, struct,
        kExprDrop,
      kExprEnd,
      kExprLocalGet, 1,
      // This is the same cast as in the else branch. As the true branch is
      // never taken, the cast can be eliminated.
      kGCPrefix, kExprRefCast, struct,
      kGCPrefix, kExprStructGet, struct, 0,
    ])
    .exportFunc();

  let instance = builder.instantiate({});
  let wasm = instance.exports;
  assertTraps(kTrapIllegalCast, () => wasm.deadBranchBasedOnIsNull({}));
})();
                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/wasm/gc-ref-eq.js                                                  0000664 0000000 0000000 00000001417 14746647661 0021573 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestRefEq() {
  let builder = new WasmModuleBuilder();
  let array = builder.addArray(wasmRefType(kWasmEqRef), true);

  builder.addFunction("equal", makeSig([], [kWasmI32]))
    .addBody([
      kExprI32Const, 0,
      kGCPrefix, kExprRefI31,
      kExprI32Const, 0,
      kGCPrefix, kExprRefI31,
      kGCPrefix, kExprArrayNewFixed, array, 1,
      kExprI32Const, 0,
      kGCPrefix, kExprArrayGet, array,
      kExprRefEq
    ])
    .exportFunc()

  let instance = builder.instantiate();

  assertEquals(1, instance.exports.equal());
})();
                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/wasm/gc-stress.js                                                  0000664 0000000 0000000 00000001702 14746647661 0021734 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --gc-interval=500 --stress-compaction

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function run(f) {
  var builder = new WasmModuleBuilder();
  builder.addImport("m", "f", kSig_i_i);
  builder.addFunction("main", kSig_i_i)
    .addBody([
      kExprLocalGet, 0,
      kExprCallFunction, 0])
    .exportAs("main");

  print("module");
  var module = new WebAssembly.Module(builder.toBuffer());

  for (var i = 0; i < 10; i++) {
    print("  instance " + i);
    var instance = new WebAssembly.Instance(module, {m: {f: f}});
    var g = instance.exports.main;
    for (var j = 0; j < 10; j++) {
      assertEquals(f(j), g(j));
    }
  }
}

(function test() {
  for (var i = 0; i < 10; i++) {
    run(x => (x + 19 + i));
    run(x => (x - 18));
  }
})();
                                                              node-23.7.0/deps/v8/test/mjsunit/wasm/gc-typecheck-reducer.js                                       0000664 0000000 0000000 00000003021 14746647661 0024013 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --no-liftoff

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

// Test inlining of a non-trivial type check (i.e. the decoder can't remove it
// directly) that becomes trivial after inlining.
// This covers a bug in the optimizing compiler treating null as a test failure
// for the "ref.test null" instruction.
(function TestRefTestNonTrivialTypeCheckInlinedTrivial() {
  var builder = new WasmModuleBuilder();
  let struct = builder.addStruct([makeField(kWasmI32, true)]);


  let refTestFromAny =  builder.addFunction(`refTestFromAny`,
                        makeSig([kWasmAnyRef], [kWasmI32, kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprRefTest, struct,
      kExprLocalGet, 0,
      kGCPrefix, kExprRefTestNull, struct,
    ]);

  builder.addFunction(`main`,
      makeSig([], [kWasmI32, kWasmI32, kWasmI32, kWasmI32]))
    .addBody([
      kExprI32Const, 1,
      kGCPrefix, kExprStructNew, struct,
      kExprCallFunction, refTestFromAny.index,
      kExprRefNull, kNullRefCode,
      kExprCallFunction, refTestFromAny.index,
    ]).exportFunc();

  var instance = builder.instantiate();
  let expected = [
    1,  // ref.test <struct> (struct)
    1,  // ref.test null <struct> (struct)
    0,  // ref.test <struct> (null)
    1   // ref.test null <struct> (null)
  ]
  assertEquals(expected, instance.exports.main());
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/wasm/gdbjit.js                                                     0000664 0000000 0000000 00000001273 14746647661 0021270 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --gdbjit

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

// A simple test to ensure that passing the --gdbjit flag doesn't crash.
(function testGdbJitFlag() {
  const builder = new WasmModuleBuilder();
  builder.addFunction('i32_add', kSig_i_ii)
      .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
      .exportFunc();

  const module = new WebAssembly.Module(builder.toBuffer());
  const instance = new WebAssembly.Instance(module);

  assertEquals(instance.exports.i32_add(1, 2), 3);
}());
                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/wasm/generate-random-module.js                                     0000664 0000000 0000000 00000001605 14746647661 0024357 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax
// Also enable all features that are used in the randomly generated module. This
// should stay in sync with `EnableExperimentalWasmFeatures` in
// `wasm-fuzzer-common.cc`.
// Flags: --wasm-staging

(function TestGenerateRandomModule() {
  print(arguments.callee.name);
  assertInstanceof(%WasmGenerateRandomModule(), WebAssembly.Module);
  assertInstanceof(%WasmGenerateRandomModule(4), WebAssembly.Module);
  assertInstanceof(%WasmGenerateRandomModule(4.2), WebAssembly.Module);
  assertInstanceof(
      %WasmGenerateRandomModule(new Uint8Array([11, 27])), WebAssembly.Module);
  assertInstanceof(
      %WasmGenerateRandomModule(new Uint8Array([11, 27]).buffer),
      WebAssembly.Module);
})();
                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/wasm/generic-wrapper.js                                            0000664 0000000 0000000 00000061312 14746647661 0023117 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-generic-wrapper --expose-gc --allow-natives-syntax
// Flags: --enable-wasm-arm64-generic-wrapper

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function testGenericWrapper0Param() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_v_v);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func() {
    gc();
    x = 20;
  }

  let instance = builder.instantiate({ mod: { func: import_func } });
  assertEquals(undefined, instance.exports.main());
  assertEquals(x, 20);
})();

(function testGenericWrapper0ParamTraps() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_v_v);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprUnreachable
    ])
    .exportFunc();

  let instance = builder.instantiate();
  assertTraps(kTrapUnreachable, instance.exports.main);
})();

(function testGenericWrapper1ParamTrap() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_v_i);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0, kExprUnreachable
    ])
    .exportFunc();

  let instance = builder.instantiate();
  assertTraps(kTrapUnreachable, () => instance.exports.main(1));
})();

(function testGenericWrapper1ParamGeneral() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_v_i);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0, kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func(param) {
    gc();
    x += param;
  }

  let instance = builder.instantiate({ mod: { func: import_func } });
  assertEquals(undefined, instance.exports.main(5));
  assertEquals(17, x);
})();

(function testGenericWrapper1ParamNotSmi() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_v_i);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0, kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func(param) {
    gc();
    x += param;
  }

  let y = { valueOf: () => { print("Hello!"); gc(); return 24; } };
  let instance = builder.instantiate({ mod: { func: import_func } });
  assertEquals(undefined, instance.exports.main(y));
  assertEquals(36, x);
})();

(function testGenericWrapper4Param() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_v_iiii);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func(param1, param2, param3, param4) {
    gc();
    x += 2 * param1 + 3 * param2 + 4 * param3 + 5 * param4;
  }

  let param2 = { valueOf: () => { gc(); return 6; } };
  let param3 = { valueOf: () => { gc(); return 3; } };
  let instance = builder.instantiate({ mod: { func: import_func } });
  assertEquals(undefined, instance.exports.main(9, param2, param3, 0));
  assertEquals(60, x);
  // Now we test if the evaluation order of the parameters is correct.
  x = 12;
  param3 = {
    valueOf: () => {
      Object.defineProperty(param2, 'valueOf', {
        value: () => 30
      })
      return 3;
    }
  };
  assertEquals(undefined, instance.exports.main(9, param2, param3, 0));
  assertEquals(60, x);
})();

let kSig_v_iiiiiiii = makeSig([kWasmI32, kWasmI32, kWasmI32, kWasmI32,
  kWasmI32, kWasmI32, kWasmI32, kWasmI32], []);

(function testGenericWrapper8Param() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_v_iiiiiiii);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      kExprLocalGet, 4,
      kExprLocalGet, 5,
      kExprLocalGet, 6,
      kExprLocalGet, 7,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func(param1, param2, param3, param4, param5, param6,
    param7, param8) {
    gc();
    x += param1 + 2 * param2 + 3 * param3 + 4 * param4 + 5 * param5
      + 6 * param6 + 7 * param7 + 8 * param8;
  }

  let param1 = { valueOf: () => { gc(); return 5; } };
  let param4 = { valueOf: () => { gc(); return 8; } };
  let param6 = { valueOf: () => { gc(); return 10; } };
  let param8 = { valueOf: () => { gc(); return 12; } };
  let instance = builder.instantiate({ mod: { func: import_func } });
  assertEquals(undefined, instance.exports.main(param1, 6, 7, param4, 9, param6, 11, param8));
  assertEquals(360, x);
})();

// Passing less parameters than expected.
(function testGenericWrapper4ParamWithLessParams() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_v_iiii);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func(param1, param2, param3, param4) {
    gc();
    x += param1 + param2 + param3 + param4;
  }

  let param2 = { valueOf: () => { gc(); return 3; } };
  let instance = builder.instantiate({ mod: { func: import_func } });
  assertEquals(undefined, instance.exports.main(5, param2));
  assertEquals(20, x);
})();

// Passing more parameters than expected.
(function testGenericWrapper4ParamWithMoreParams() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_v_iiii);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func(param1, param2, param3, param4) {
    gc();
    x += param1 + param2 + param3 + param4;
  }

  let param2 = { valueOf: () => { gc(); return 3; } };
  let param3 = { valueOf: () => { gc(); return 6; } };
  let instance = builder.instantiate({ mod: { func: import_func } });
  assertEquals(undefined, instance.exports.main(5, param2, param3, 7, 200, 300, 400));
  assertEquals(33, x);
})();

(function testGenericWrapper1I32ReturnSmi() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_i_i);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0, kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func(param) {
    gc();
    return x + param;
  }

  let instance = builder.instantiate({ mod: { func: import_func } });
  assertEquals(17, instance.exports.main(5));
})();

(function testGenericWrapper1I32ReturnHeapNumber() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_i_i);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0, kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 2147483640;
  function import_func(param) {
    let result = x + param;
    %SimulateNewspaceFull();
    return result;
  }

  let instance = builder.instantiate({ mod: { func: import_func } });
  assertEquals(2147483645, instance.exports.main(5));
})();

let kSig_i_lili = makeSig([kWasmI64, kWasmI32, kWasmI64, kWasmI32], [kWasmI32]);

(function testGenericWrapper4IParam1I32Ret() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_i_lili);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12n;
  function import_func(param1, param2, param3, param4) {
    x += 2n * param1 + BigInt(3 * param2) + 4n * param3 + BigInt(5 * param4);
    return Number(x);
  }

  let param2 = { valueOf: () => { gc(); return 6; } };
  let param3 = { valueOf: () => { gc(); return 3n; } };
  let instance = builder.instantiate({ mod: { func: import_func } });
  assertEquals(60, instance.exports.main(9n, param2, param3, 0));
})();

let kSig_v_iiili = makeSig([kWasmI32, kWasmI32, kWasmI32, kWasmI64,
  kWasmI32], []);

(function testGenericWrapper5IParam() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_v_iiili);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      kExprLocalGet, 4,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func(param1, param2, param3, param4, param5) {
    gc();
    x += 2 * param1 + 3 * param2 + 4 * param3 + 5 * Number(param4) + 6 * param5;
  }

  let param2 = { valueOf: () => { gc(); return 6; } };
  let param3 = { valueOf: () => { gc(); return 3; } };
  let instance = builder.instantiate({ mod: { func: import_func } });
  assertEquals(undefined, instance.exports.main(9, param2, param3, 0n, 2));
  assertEquals(72, x);
})();

let kSig_v_iiilii = makeSig([kWasmI32, kWasmI32, kWasmI32, kWasmI64,
  kWasmI32, kWasmI32], []);

(function testGenericWrapper6IParam() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_v_iiilii);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      kExprLocalGet, 4,
      kExprLocalGet, 5,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func(param1, param2, param3, param4, param5, param6) {
    gc();
    x += 2 * param1 + 3 * param2 + 4 * param3 + 5 * Number(param4) + 6 * param5 + 7 * param6;
  }

  let param2 = { valueOf: () => { gc(); return 6; } };
  let param3 = { valueOf: () => { gc(); return 3; } };
  let instance = builder.instantiate({ mod: { func: import_func } });
  assertEquals(undefined, instance.exports.main(9, param2, param3, 0n, 2, 3));
  assertEquals(93, x);
})();

let kSig_v_liilliiil = makeSig([kWasmI64, kWasmI32, kWasmI32, kWasmI64,
  kWasmI64, kWasmI32, kWasmI32, kWasmI32, kWasmI64], [kWasmI32]);

(function testGenericWrapper9IParam132Ret() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_v_liilliiil);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      kExprLocalGet, 4,
      kExprLocalGet, 5,
      kExprLocalGet, 6,
      kExprLocalGet, 7,
      kExprLocalGet, 8,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func(param1, param2, param3, param4, param5, param6,
    param7, param8, param9) {
    x += Number(param1) + 2 * param2 + 3 * param3 + Number(4n * param4) + Number(5n * param5)
      + 6 * param6 + 7 * param7 + 8 * param8 + Number(9n * param9);
    return x;
  }

  let param1 = { valueOf: () => { gc(); return 5n; } };
  let param4 = { valueOf: () => { gc(); return 8n; } };
  let param6 = { valueOf: () => { gc(); return 10; } };
  let param8 = { valueOf: () => { gc(); return 12; } };
  let instance = builder.instantiate({ mod: { func: import_func } });
  assertEquals(360, instance.exports.main(param1, 6, 7, param4, 9n, param6, 11, param8, 0n));
})();

// The function expects BigInt, but gets Number.
(function testGenericWrapperTypeError() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_v_l);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0, kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12n;
  function import_func(param1) {
    x += param1;
  }

  let instance = builder.instantiate({ mod: { func: import_func } });
  assertThrows(() => { instance.exports.main(17) }, TypeError);
})();

(function testGenericWrapper1I64Return() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_l_v);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprCallFunction, func_index
    ])
    .exportFunc();

  function import_func() {
    gc();
    return 10000000000n;
  }

  let instance = builder.instantiate({ mod: { func: import_func } });
  assertEquals(10000000000n, instance.exports.main());
})();

(function testGenericWrapper1F32Return() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_f_v);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprCallFunction, func_index
    ])
    .exportFunc();

  function import_func() {
    gc();
    return 0.5;
  }

  let instance = builder.instantiate({ mod: { func: import_func } });
  assertEquals(0.5, instance.exports.main());
})();

(function testGenericWrapper1F64Return() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_d_v);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprCallFunction, func_index
    ])
    .exportFunc();

  function import_func() {
    gc();
    return 0.25;
  }

  let instance = builder.instantiate({ mod: { func: import_func } });
  assertEquals(0.25, instance.exports.main());
})();

(function testGenericWrapper1Float32() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_v_f);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0, kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12.5;
  function import_func(param) {
    gc();
    x += param;
  }

  let instance = builder.instantiate({ mod: { func: import_func } });
  assertEquals(undefined, instance.exports.main(12.5));
  assertEquals(25, x);
})();

(function testGenericWrapper1Float64() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_v_d);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0, kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12.5;
  function import_func(param) {
    gc();
    x += param;
  }

  let instance = builder.instantiate({ mod: { func: import_func } });
  assertEquals(undefined, instance.exports.main(12.5));
  assertEquals(25, x);
})();

let kSig_v_ffddddff = makeSig([kWasmF32, kWasmF32, kWasmF64, kWasmF64,
  kWasmF64, kWasmF64, kWasmF32, kWasmF32], []);

(function testGenericWrapper8Floats() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_v_ffddddff);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      kExprLocalGet, 4,
      kExprLocalGet, 5,
      kExprLocalGet, 6,
      kExprLocalGet, 7,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func(param1, param2, param3, param4, param5, param6,
    param7, param8) {
    gc();
    x += param1 + 2 * param2 + 3 * param3 + 4 * param4 + 5 * param5
      + 6 * param6 + 7 * param7 + 8 * param8;
  }

  let param1 = { valueOf: () => { gc(); return 1.5; } };
  let param4 = { valueOf: () => { gc(); return 4.5; } };
  let param6 = { valueOf: () => { gc(); return 6.5; } };
  let param8 = { valueOf: () => { gc(); return 8.5; } };
  let instance = builder.instantiate({ mod: { func: import_func } });
  assertEquals(undefined, instance.exports.main(param1, 2.5, 3.5, param4,
    5.5, param6, 7.5, param8));
  assertEquals(234, x);
})();

let kSig_v_iiliffddlfdff = makeSig([kWasmI32, kWasmI32, kWasmI64,
  kWasmI32, kWasmF32, kWasmF32, kWasmF64, kWasmF64, kWasmI64, kWasmF32,
  kWasmF64, kWasmF32, kWasmF32], []);
// Floats don't fit into param registers.
(function testGenericWrapper13ParamMix() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_v_iiliffddlfdff);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      kExprLocalGet, 4,
      kExprLocalGet, 5,
      kExprLocalGet, 6,
      kExprLocalGet, 7,
      kExprLocalGet, 8,
      kExprLocalGet, 9,
      kExprLocalGet, 10,
      kExprLocalGet, 11,
      kExprLocalGet, 12,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  let y = 1.0;
  function import_func(parami1, parami2, paraml1, parami3, paramf1, paramf2,
    paramd1, paramd2, paraml2, paramf3, paramd3, paramf4, paramf5) {
    gc();
    x += parami1 + 2 * parami2 + 3 * Number(paraml1) + 4 * parami3
      + 5 * Number(paraml2);
    y += paramf1 + 2 * paramf2 + 3 * paramd1 + 4 * paramd2 + 5 * paramf3
      + 6 * paramd3 + 7 * paramf4 + 8 * paramf5;
  }

  let instance = builder.instantiate({ mod: { func: import_func } });
  assertEquals(undefined, instance.exports.main(5, 6, 7n, 8, 1.5, 2.5, 3.5,
    4.5, 11n, 5.5, 6.5, 7.5, 8.5));
  assertEquals(137, x);
  assertEquals(223, y);
})();

let kSig_v_iiliiiffddli = makeSig([kWasmI32, kWasmI32, kWasmI64, kWasmI32,
  kWasmI32, kWasmI32, kWasmF32, kWasmF32, kWasmF64, kWasmF64, kWasmI64,
  kWasmI32], []);
// Integers don't fit into param registers.
(function testGenericWrapper12ParamMix() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_v_iiliiiffddli);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      kExprLocalGet, 4,
      kExprLocalGet, 5,
      kExprLocalGet, 6,
      kExprLocalGet, 7,
      kExprLocalGet, 8,
      kExprLocalGet, 9,
      kExprLocalGet, 10,
      kExprLocalGet, 11,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  let y = 1.0;
  function import_func(param1, param2, param3, param4, param5, param6,
    paramf1, paramf2, paramd1, paramd2, param7, param8) {
    gc();
    x += param1 + 2 * param2 + 3 * Number(param3) + 4 * param4 + 5 * param5
      + 6 * param6 + 7 * Number(param7) + 8 * param8;
    y += paramf1 + paramf2 + paramd1 + paramd2;
  }

  let param1 = { valueOf: () => { gc(); return 5; } };
  let param4 = { valueOf: () => { gc(); return 8; } };
  let param6 = { valueOf: () => { gc(); return 10; } };
  let param8 = { valueOf: () => { gc(); return 12; } };
  let instance = builder.instantiate({ mod: { func: import_func } });
  assertEquals(undefined, instance.exports.main(param1, 6, 7n, param4, 9, param6,
    1.5, 2.5, 3.6, 4.4, 11n, param8));
  assertEquals(360, x);
  assertEquals(13, y);
})();

let kSig_f_iiliiiffddlifffdi = makeSig([kWasmI32, kWasmI32, kWasmI64, kWasmI32,
  kWasmI32, kWasmI32, kWasmF32, kWasmF32, kWasmF64, kWasmF64, kWasmI64,
  kWasmI32, kWasmF32, kWasmF32, kWasmF32, kWasmF64, kWasmI32], [kWasmF32]);
// Integers and floats don't fit into param registers.
(function testGenericWrapper17ParamMix() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_f_iiliiiffddlifffdi);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      kExprLocalGet, 4,
      kExprLocalGet, 5,
      kExprLocalGet, 6,
      kExprLocalGet, 7,
      kExprLocalGet, 8,
      kExprLocalGet, 9,
      kExprLocalGet, 10,
      kExprLocalGet, 11,
      kExprLocalGet, 12,
      kExprLocalGet, 13,
      kExprLocalGet, 14,
      kExprLocalGet, 15,
      kExprLocalGet, 16,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func(param1, param2, param3, param4, param5, param6,
    paramf1, paramf2, paramd1, paramd2, param7, param8, paramf3, paramf4,
    paramf5, paramd3, param9) {
    gc();
    x += param1 + 2 * param2 + 3 * Number(param3) + 4 * param4 + 5 * param5
      + 6 * param6 + 7 * Number(param7) + 8 * param8 + 9 * param9;
    let y = 1.0;
    y += paramf1 + 2 * paramf2 + 3 * paramd1 + 4 * paramd2 + 5 * paramf3
      + 6 * paramf4 + 7 * paramf5 + 8 * paramd3;
    return y;
  }

  let param1 = { valueOf: () => { gc(); return 5; } };
  let param4 = { valueOf: () => { gc(); return 8; } };
  let param6 = { valueOf: () => { gc(); return 10; } };
  let param8 = { valueOf: () => { gc(); return 12; } };
  let paramd1 = { valueOf: () => { gc(); return 3.5; } };
  let paramf3 = { valueOf: () => { gc(); return 5.5; } };
  let param9 = { valueOf: () => { gc(); return 0; } };
  let instance = builder.instantiate({ mod: { func: import_func } });
  assertEquals(223, instance.exports.main(param1, 6, 7n, param4, 9, param6,
    1.5, 2.5, paramd1, 4.5, 11n, param8, paramf3, 6.5, 7.5, 8.5, param9));
  assertEquals(360, x);
})();

(function testCallFromOptimizedFunction() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.addFunction('wasm_fn', kSig_v_v).addBody([
      kExprNop,
  ]).exportFunc();

  instance = builder.instantiate();
  function js_caller() {
    return instance.exports.wasm_fn();
  }
  %PrepareFunctionForOptimization(js_caller);
  js_caller();
  %OptimizeFunctionOnNextCall(js_caller);
  js_caller();
})();

(function Regression1130385() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_i_v);
  builder.addFunction("f0", sig_index)
    .addBody([kExprI32Const, 12])
    .exportFunc();

  builder.addFunction("f1", sig_index)
    .addBody([kExprI32Const, 15])
    .exportFunc();

  let instance = builder.instantiate();
  assertEquals(15, instance.exports.f1());
})();

(function testDeoptWithIncorrectNumberOfParams() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_v_ii);
  let imp = builder.addImport('q', 'func', sig_index);
  builder.addFunction('main', sig_index)
      .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprCallFunction, imp])
      .exportAs('main');

  function deopt() {
    %DeoptimizeFunction(caller);
  }

  let main = builder.instantiate({q: {func: deopt}}).exports.main;
  function caller() {
    main(1, 2, 3, 4, 5);
    main(1, 2, 3, 4);
    main(1, 2, 3);
    main(1, 2);
    main(1);
    main();
  }
  caller();
})();

(function testGenericWrapper6Ref7F64Param() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_r_ddrrrrrrddddd = builder.addType(makeSig(
      [kWasmF64, kWasmF64, kWasmExternRef, kWasmExternRef, kWasmExternRef,
       kWasmExternRef, kWasmExternRef, kWasmExternRef, kWasmF64, kWasmF64,
       kWasmF64, kWasmF64, kWasmF64],
       [kWasmExternRef]));


  builder.addFunction("func0", sig_r_ddrrrrrrddddd)
    .addBody([
      kExprLocalGet, 7,
      ])
    .exportAs("func0");

  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  let res = instance.exports.func0(1, 2, "3", "4", "5", "6", "7",
                                   "8", 9, 10, 11, 12, 13);
  assertEquals("8", res);
})();
                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/wasm/globals-import-export-identity.js                             0000664 0000000 0000000 00000002163 14746647661 0026125 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

const global1 = new WebAssembly.Global({value: 'i32', mutable: true}, 14);
const global2 = new WebAssembly.Global({value: 'i32', mutable: true}, 15);
const global3 = new WebAssembly.Global({value: 'i32', mutable: true}, 32);

const builder = new WasmModuleBuilder();

// Two additional globals, so that global-index != export-index.
builder.addImportedGlobal('module', 'global1', kWasmI32, true);
builder.addImportedGlobal('module', 'global2', kWasmI32, true);
const globalIndex =
    builder.addImportedGlobal('module', 'global3', kWasmI32, true);
builder.addExportOfKind('exportedGlobal', kExternalGlobal, globalIndex);

const buffer = builder.toBuffer();

const module = new WebAssembly.Module(buffer);
const instance = new WebAssembly.Instance(module, {
  'module': {
    'global1': global1,
    'global2': global2,
    'global3': global3,
  }
});

assertEquals(global3, instance.exports.exportedGlobal);
                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/globals.js                                                    0000664 0000000 0000000 00000015226 14746647661 0021453 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestMultipleInstances() {
  print("TestMultipleInstances");

  var builder = new WasmModuleBuilder();

  let g = builder.addGlobal(kWasmI32, true, false);
  let sig_index = builder.addType(kSig_i_v);
  builder.addFunction("get", sig_index)
    .addBody([
      kExprGlobalGet, g.index])
    .exportAs("get");
  builder.addFunction("set", kSig_v_i)
    .addBody([
      kExprLocalGet, 0,
      kExprGlobalSet, g.index])
    .exportAs("set");

  let module = new WebAssembly.Module(builder.toBuffer());

  let a = new WebAssembly.Instance(module);
  let b = new WebAssembly.Instance(module);

  assertEquals(0, a.exports.get());
  assertEquals(0, b.exports.get());

  a.exports.set(1);

  assertEquals(1, a.exports.get());
  assertEquals(0, b.exports.get());

  b.exports.set(6);

  assertEquals(1, a.exports.get());
  assertEquals(6, b.exports.get());

  a.exports.set(7);

  assertEquals(7, a.exports.get());
  assertEquals(6, b.exports.get());

})();

function TestImported(type, val, expected) {
  print("TestImported " + type + "(" + val +")" + " = " + expected);
  var builder = new WasmModuleBuilder();
  var sig = makeSig([], [type]);
  var g = builder.addImportedGlobal("uuu", "foo", type);
  builder.addFunction("main", sig)
    .addBody([kExprGlobalGet, g])
    .exportAs("main");
  builder.addGlobal(kWasmI32, false, false);  // pad

  var instance = builder.instantiate({uuu: {foo: val}});
  assertEquals(expected, instance.exports.main());
}

TestImported(kWasmI32, 300.1, 300);
TestImported(kWasmF32, 87234.87238, Math.fround(87234.87238));
TestImported(kWasmF64, 77777.88888, 77777.88888);


(function TestImportedMultipleInstances() {
  print("TestImportedMultipleInstances");

  var builder = new WasmModuleBuilder();

  let g = builder.addImportedGlobal("mod", "g", kWasmI32);
  let sig_index = builder.addType(kSig_i_v);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprGlobalGet, g])
    .exportAs("main");

  let module = new WebAssembly.Module(builder.toBuffer());

  print("  i 100...");
  let i100 = new WebAssembly.Instance(module, {mod: {g: 100}});
  assertEquals(100, i100.exports.main());

  print("  i 300...");
  let i300 = new WebAssembly.Instance(module, {mod: {g: 300}});
  assertEquals(300, i300.exports.main());
})();

function TestExported(type, val, expected) {
  print("TestExported " + type + "(" + val +")" + " = " + expected);
  var builder = new WasmModuleBuilder();
  builder.addGlobal(kWasmI32, false, false);  // pad
  builder.addGlobal(type, false, false, val).exportAs("foo");
  builder.addGlobal(kWasmI32, false, false);  // pad

  var instance = builder.instantiate();
  assertEquals(expected, instance.exports.foo.value);
}

TestExported(kWasmI32, wasmI32Const(455.5), 455);
TestExported(kWasmF32, wasmF32Const(-999.34343),
             Math.fround(-999.34343));
TestExported(kWasmF64, wasmF64Const(87347.66666), 87347.66666);

(function TestI64Exported() {
  var builder = new WasmModuleBuilder();
  builder.addGlobal(kWasmI32, false, false);  // pad
  builder.addGlobal(kWasmI64, false, false, wasmI64Const(1234)).exportAs("foo");
  builder.addGlobal(kWasmI32, false, false);  // pad

  var instance = builder.instantiate();
  assertTrue(instance.exports.foo instanceof WebAssembly.Global);
  assertEquals(instance.exports.foo.value, 1234n);
})();

function TestImportedExported(type, val, expected) {
  print("TestImportedExported " + type + "(" + val + ")" + " = " + expected);
  var builder = new WasmModuleBuilder();
  var i = builder.addImportedGlobal("ttt", "foo", type);
  builder.addGlobal(kWasmI32, false, false);  // pad
  builder.addGlobal(type, false, false, [kExprGlobalGet, i]).exportAs("bar");
  builder.addGlobal(kWasmI32, false, false);  // pad

  var instance = builder.instantiate({ttt: {foo: val}});
  assertEquals(expected, instance.exports.bar.value);
}

TestImportedExported(kWasmI32, 415.5, 415);
TestImportedExported(kWasmF32, -979.34343, Math.fround(-979.34343));
TestImportedExported(kWasmF64, 81347.66666, 81347.66666);

function TestGlobalIndexSpace(type, val) {
  print("TestGlobalIndexSpace(" + val + ") = " + val);
  var builder = new WasmModuleBuilder();
  var im = builder.addImportedGlobal("nnn", "foo", type);
  assertEquals(0, im);
  var def = builder.addGlobal(type, false, false, [kExprGlobalGet, im]);
  assertEquals(1, def.index);

  var sig = makeSig([], [type]);
  builder.addFunction("main", sig)
    .addBody([kExprGlobalGet, def.index])
    .exportAs("main");

  var instance = builder.instantiate({nnn: {foo: val}});
  assertEquals(val, instance.exports.main());
}

TestGlobalIndexSpace(kWasmI32, 123);
TestGlobalIndexSpace(kWasmF32, 54321.125);
TestGlobalIndexSpace(kWasmF64, 12345.678);

(function TestAccessesInBranch() {
  print("TestAccessesInBranches");

  var builder = new WasmModuleBuilder();

  let g = builder.addGlobal(kWasmI32, true, false);
  let h = builder.addGlobal(kWasmI32, true, false);
  let sig_index = builder.addType(kSig_i_i);
  builder.addFunction("get", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprIf, kWasmI32,
      kExprGlobalGet, g.index,
      kExprElse,
      kExprGlobalGet, h.index,
      kExprEnd])
    .exportAs("get");
  builder.addFunction("set", kSig_v_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprIf, kWasmVoid,
      kExprLocalGet, 1,
      kExprGlobalSet, g.index,
      kExprElse,
      kExprLocalGet, 1,
      kExprGlobalSet, h.index,
      kExprEnd])
    .exportAs("set");

  let module = new WebAssembly.Module(builder.toBuffer());

  let a = new WebAssembly.Instance(module);
  let get = a.exports.get;
  let set = a.exports.set;

  assertEquals(0, get(0));
  assertEquals(0, get(1));
  set(0, 1);
  assertEquals(1, get(0));
  assertEquals(0, get(1));

  set(0, 7);
  assertEquals(7, get(0));
  assertEquals(0, get(1));

  set(1, 9);
  assertEquals(7, get(0));
  assertEquals(9, get(1));

})();

(function testAssignUndefinedToGlobal() {
  print(arguments.callee.name);
  let i32_global = new WebAssembly.Global({mutable: true, value: 'i32'});
  i32_global.value = undefined;
  assertSame(0, i32_global.value);
  let i64_global = new WebAssembly.Global({mutable: true, value: 'i64'});
  assertThrows(() => {
    i64_global.value = undefined;
  }, TypeError);
  let f32_global = new WebAssembly.Global({mutable: true, value: 'f32'});
  f32_global.value = undefined;
  assertSame(NaN, f32_global.value);
  let f64_global = new WebAssembly.Global({mutable: true, value: 'f64'});
  f64_global.value = undefined;
  assertSame(NaN, f64_global.value);
})();
                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/wasm/graceful_shutdown.js                                          0000664 0000000 0000000 00000001655 14746647661 0023554 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --no-wait-for-background-tasks

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function CompileFunctionsTest() {
  // Create a big module.
  var builder = new WasmModuleBuilder();

  builder.addMemory(1, 1);
  for (i = 0; i < 100; i++) {
    builder.addFunction("sub" + i, kSig_i_i)
      .addBody([                // --
        kExprLocalGet, 0,       // --
        kExprI32Const, i % 61,  // --
        kExprI32Sub])           // --
      .exportFunc()
  }

  var buffer = builder.toBuffer();
  // Start the compilation but do not wait for the promise to resolve
  // with assertPromiseResult. This should not cause a crash.
  WebAssembly.compile(buffer).then(
    () => { print("success")},
    () => { print("failed"); });
})();
                                                                                   node-23.7.0/deps/v8/test/mjsunit/wasm/graceful_shutdown_during_tierup.js                            0000664 0000000 0000000 00000001526 14746647661 0026511 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --no-wait-for-background-tasks --wasm-tier-up

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function ShutdownDuringTierUp() {
  // Create a big module.
  var builder = new WasmModuleBuilder();

  builder.addMemory(1, 1);
  for (i = 0; i < 100; i++) {
    builder.addFunction("sub" + i, kSig_i_i)
      .addBody([                // --
        kExprLocalGet, 0,       // --
        kExprI32Const, i % 61,  // --
        kExprI32Sub])           // --
      .exportFunc()
  }

  var buffer = builder.toBuffer();
  // Wait for compilation to finish, but then shutdown while tier-up is still
  // running.
  assertPromiseResult(WebAssembly.compile(buffer));
})();
                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/wasm/grow-huge-memory.js                                           0000664 0000000 0000000 00000002345 14746647661 0023240 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Save some memory on Linux; other platforms ignore this flag.
// Flags: --multi-mapped-mock-allocator

// Test that we can grow memories to sizes beyond 2GB.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function GetMemoryPages(memory) {
  return memory.buffer.byteLength >>> 16;
}

(function TestGrowFromJS() {
  let mem = new WebAssembly.Memory({initial: 200});
  mem.grow(40000);
  assertEquals(40200, GetMemoryPages(mem));
})();

(function TestGrowFromWasm() {
  let builder = new WasmModuleBuilder();
  builder.addMemory(200, 50000);
  builder.exportMemoryAs("memory");
  builder.addFunction("grow", kSig_i_v)
    .addBody([
      ...wasmI32Const(40000),        // Number of pages to grow by.
      kExprMemoryGrow, kMemoryZero,  // Grow memory.
      kExprDrop,                     // Drop result of grow (old pages).
      kExprMemorySize, kMemoryZero   // Get the memory size.
      ]).exportFunc();
  let instance = builder.instantiate();
  assertEquals(40200, instance.exports.grow());
  assertEquals(40200, GetMemoryPages(instance.exports.memory));
})();
                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/wasm/grow-memory-detaching.js                                      0000664 0000000 0000000 00000003426 14746647661 0024237 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

let module = (() => {
  let builder = new WasmModuleBuilder();
  builder.addMemory(1, undefined);
  builder.addFunction("grow_memory", kSig_i_i)
              .addBody([kExprLocalGet, 0, kExprMemoryGrow, kMemoryZero])
    .exportFunc();
  builder.exportMemoryAs("memory");
  return builder.toModule();
})();

(function TestDetachingViaAPI() {
  print("TestDetachingViaAPI...");
  let memory = new WebAssembly.Memory({initial: 1, maximum: 100});
  let growMem = (pages) => memory.grow(pages);

  let b1 = memory.buffer;
  assertEquals(kPageSize, b1.byteLength);

  growMem(0);
  let b2 = memory.buffer;
  assertFalse(b1 === b2);
  assertEquals(0, b1.byteLength);
  assertEquals(kPageSize, b2.byteLength);

  growMem(1);
  let b3 = memory.buffer;
  assertFalse(b1 === b3);
  assertFalse(b2 === b3);
  assertEquals(0, b1.byteLength);
  assertEquals(0, b2.byteLength);
  assertEquals(2 * kPageSize, b3.byteLength);
})();

(function TestDetachingViaBytecode() {
  print("TestDetachingViaBytecode...");
  let instance = new WebAssembly.Instance(module);
  let growMem = instance.exports.grow_memory;
  let memory = instance.exports.memory;

  let b1 = memory.buffer;
  assertEquals(kPageSize, b1.byteLength);

  growMem(0);
  let b2 = memory.buffer;
  assertFalse(b1 === b2);
  assertEquals(0, b1.byteLength);
  assertEquals(kPageSize, b2.byteLength);

  growMem(1);
  let b3 = memory.buffer;
  assertFalse(b1 === b3);
  assertFalse(b2 === b3);
  assertEquals(0, b1.byteLength);
  assertEquals(0, b2.byteLength);
  assertEquals(2 * kPageSize, b3.byteLength);
})();
                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/wasm/grow-memory-in-branch.js                                      0000664 0000000 0000000 00000032267 14746647661 0024157 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --stress-compaction

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

var initialMemoryPages = 1;
var maximumMemoryPages = 5;

function generateBuilder() {
  let builder = new WasmModuleBuilder();
  builder.addMemory(initialMemoryPages, maximumMemoryPages);
  builder.addFunction('load', kSig_i_i)
      .addBody([kExprLocalGet, 0, kExprI32LoadMem, 0, 0])
      .exportFunc();
  builder.addFunction('store', kSig_i_ii)
      .addBody([
        kExprLocalGet, 0, kExprLocalGet, 1,
        kExprI32StoreMem, 0, 0, kExprLocalGet, 1
      ])
      .exportFunc();
  return builder;
}

// This test verifies that the effects of growing memory in an if branch
// affect the result of current_memory when the branch is merged.
(function TestMemoryGrowInIfBranchNoElse() {
  print('TestMemoryGrowInIfBranchNoElse ...');
  let deltaPages = 4;
  let builder = generateBuilder();
  builder.addFunction('main', kSig_i_i)
      .addBody([
        kExprLocalGet, 0,                       // get condition parameter
        kExprIf, kWasmVoid,                     // if it's 1 then enter if
          kExprI32Const, deltaPages,            // put deltaPages on stack
          kExprMemoryGrow, kMemoryZero,         // grow memory
          kExprDrop,                            // drop the result of grow
        kExprEnd,
        kExprMemorySize, kMemoryZero            // get the memory size
      ])
      .exportFunc();
  var instance = builder.instantiate();
  // Avoid the if branch (not growing memory).
  assertEquals(initialMemoryPages, instance.exports.main(0));
  // Enter the if branch (growing memory).
  assertEquals(initialMemoryPages + deltaPages, instance.exports.main(1));
})();

// This test verifies that the effects of growing memory in an if branch are
// retained when the branch is merged even when an else branch exists.
(function TestMemoryGrowInIfBranchWithElse() {
  print('TestMemoryGrowInIfBranchWithElse ...');
  let index = 0;
  let oldValue = 21;
  let newValue = 42;
  let deltaPages = 4;
  let builder = generateBuilder();
  builder.addFunction('main', kSig_i_i)
      .addBody([
        kExprLocalGet, 0,                       // get condition parameter
        kExprIf, kWasmVoid,                     // if it's 1 then enter if
          kExprI32Const, deltaPages,            // put deltaPages on stack
          kExprMemoryGrow, kMemoryZero,         // grow memory
          kExprDrop,                            // drop the result of grow
        kExprElse,
          kExprI32Const, index,                 // put index on stack
          kExprI32Const, newValue,              // put the value on stack
          kExprI32StoreMem, 0, 0,               // store
        kExprEnd,
        kExprMemorySize, kMemoryZero            // get the memory size
      ])
      .exportFunc();
  var instance = builder.instantiate();
  // Initialize the memory location with oldValue.
  instance.exports.store(index, oldValue);
  assertEquals(oldValue, instance.exports.load(index));
  // Verify that the else branch (not growing) is reachable.
  assertEquals(initialMemoryPages, instance.exports.main(0));
  assertEquals(newValue, instance.exports.load(index));
  // Enter the if branch (growing memory).
  assertEquals(initialMemoryPages + deltaPages, instance.exports.main(1));
})();

// This test verifies that the effects of growing memory in an else branch
// affect the result of current_memory when the branch is merged.
(function TestMemoryGrowInElseBranch() {
  print('TestMemoryGrowInElseBranch ...');
  let index = 0;
  let oldValue = 21;
  let newValue = 42;
  let deltaPages = 4;
  let builder = generateBuilder();
  builder.addFunction('main', kSig_i_i)
      .addBody([
        kExprLocalGet, 0,                       // get condition parameter
        kExprIf, kWasmVoid,                     // if it's 1 then enter if
          kExprI32Const, index,                 // put index on stack
          kExprI32Const, newValue,              // put the value on stack
          kExprI32StoreMem, 0, 0,               // store
        kExprElse,
          kExprI32Const, deltaPages,            // put deltaPages on stack
          kExprMemoryGrow, kMemoryZero,         // grow memory
          kExprDrop,                            // drop the result of grow
        kExprEnd,
        kExprMemorySize, kMemoryZero            // get the memory size
      ])
      .exportFunc();
  var instance = builder.instantiate();
  // Initialize the memory location with oldValue.
  instance.exports.store(index, oldValue);
  assertEquals(oldValue, instance.exports.load(index));
  // Verify that the if branch (not growing) is reachable.
  assertEquals(initialMemoryPages, instance.exports.main(1));
  assertEquals(newValue, instance.exports.load(index));
  // Enter the else branch (growing memory).
  assertEquals(initialMemoryPages + deltaPages, instance.exports.main(0));
})();

// This test verifies that the effects of growing memory in an if/else
// branch affect the result of current_memory when the branches are merged.
(function TestMemoryGrowInBothIfAndElse() {
  print('TestMemoryGrowInBothIfAndElse ...');
  let deltaPagesIf = 1;
  let deltaPagesElse = 2;
  let builder = generateBuilder();
  builder.addFunction('main', kSig_i_i)
      .addBody([
        kExprLocalGet, 0,                       // get condition parameter
        kExprIf, kWasmVoid,                     // if it's 1 then enter if
          kExprI32Const, deltaPagesIf,          // put deltaPagesIf on stack
          kExprMemoryGrow, kMemoryZero,         // grow memory
          kExprDrop,                            // drop the result of grow
        kExprElse,
          kExprI32Const, deltaPagesElse,        // put deltaPagesElse on stack
          kExprMemoryGrow, kMemoryZero,         // grow memory
          kExprDrop,                            // drop the result of grow
        kExprEnd,
        kExprMemorySize, kMemoryZero            // get the memory size
      ])
      .exportFunc();
  var instance = builder.instantiate();
  // Enter the if branch (growing memory by 1 page).
  assertEquals(initialMemoryPages + deltaPagesIf, instance.exports.main(1));
  // Create a new instance for the testing the else branch.
  var instance = builder.instantiate();
  // Enter the else branch (growing memory by 2 pages).
  assertEquals(initialMemoryPages + deltaPagesElse, instance.exports.main(0));
})();

// This test verifies that the effects of growing memory in an if branch are
// retained when the branch is merged.
(function TestMemoryGrowAndStoreInIfBranchNoElse() {
  print('TestMemoryGrowAndStoreInIfBranchNoElse ...');
  let index = 2 * kPageSize - 4;
  let value = 42;
  let deltaPages = 1;
  let builder = generateBuilder();
  builder.addFunction('main', kSig_i_ii)
      .addBody([
        kExprLocalGet, 0,                       // get condition parameter
        kExprIf, kWasmVoid,                     // if it's 1 then enter if
          kExprI32Const, deltaPages,            // put deltaPages on stack
          kExprMemoryGrow, kMemoryZero,         // grow memory
          kExprDrop,                            // drop the result of grow
          kExprLocalGet, 1,                     // get index parameter
          kExprI32Const, value,                 // put the value on stack
          kExprI32StoreMem, 0, 0,               // store
        kExprEnd,
        kExprLocalGet, 1,                       // get index parameter
        kExprI32LoadMem, 0, 0                   // load from grown memory
      ])
      .exportFunc();
  var instance = builder.instantiate();

  // Avoid the if branch (not growing memory). This should trap when executing
  // the kExprI32LoadMem instruction at the end of main.
  assertTraps(kTrapMemOutOfBounds, () => instance.exports.main(0, index));
  // Enter the if branch (growing memory).
  assertEquals(value, instance.exports.main(1, index));
})();

// This test verifies that the effects of growing memory in an if branch are
// retained when the branch is merged even when  an else branch exists.
(function TestMemoryGrowAndStoreInIfBranchWithElse() {
  print('TestMemoryGrowAndStoreInIfBranchWithElse ...');
  let index = 2 * kPageSize - 4;
  let value = 42;
  let deltaPages = 1;
  let builder = generateBuilder();
  builder.addFunction('main', kSig_i_ii)
      .addBody([
        kExprLocalGet, 0,                       // get condition parameter
        kExprIf, kWasmVoid,                     // if it's 1 then enter if
          kExprI32Const, deltaPages,            // put deltaPages on stack
          kExprMemoryGrow, kMemoryZero,         // grow memory
          kExprDrop,                            // drop the result of grow
          kExprLocalGet, 1,                     // get index parameter
          kExprI32Const, value,                 // put the value on stack
          kExprI32StoreMem, 0, 0,               // store
        kExprElse,
          kExprLocalGet, 1,                     // get index parameter
          kExprI32Const, value,                 // put the value on stack
          kExprI32StoreMem, 0, 0,               // store
        kExprEnd,
        kExprLocalGet, 1,                       // get index parameter
        kExprI32LoadMem, 0, 0                   // load from grown memory
      ])
      .exportFunc();
  var instance = builder.instantiate();
  // Avoid the if branch (not growing memory). This should trap when executing
  // the kExprI32StoreMem instruction in the if branch.
  assertTraps(kTrapMemOutOfBounds, () => instance.exports.main(0, index));
  // Enter the if branch (growing memory).
  assertEquals(value, instance.exports.main(1, index));
})();

// This test verifies that the effects of growing memory in an else branch are
// retained when the branch is merged.
(function TestMemoryGrowAndStoreInElseBranch() {
  print('TestMemoryGrowAndStoreInElseBranch ...');
  let index = 2 * kPageSize - 4;
  let value = 42;
  let deltaPages = 1;
  let builder = generateBuilder();
  builder.addFunction('main', kSig_i_ii)
      .addBody([
        kExprLocalGet, 0,                       // get condition parameter
        kExprIf, kWasmVoid,                     // if it's 1 then enter if
          kExprLocalGet, 1,                     // get index parameter
          kExprI32Const, value,                 // put the value on stack
          kExprI32StoreMem, 0, 0,               // store
        kExprElse,
          kExprI32Const, deltaPages,            // put deltaPages on stack
          kExprMemoryGrow, kMemoryZero,         // grow memory
          kExprDrop,                            // drop the result of grow
          kExprLocalGet, 1,                     // get index parameter
          kExprI32Const, value,                 // put the value on stack
          kExprI32StoreMem, 0, 0,               // store
        kExprEnd,
        kExprLocalGet, 1,                       // get index parameter
        kExprI32LoadMem, 0, 0                   // load from grown memory
      ])
      .exportFunc();
  var instance = builder.instantiate();
  // Avoid the else branch (not growing memory). This should trap when executing
  // the kExprI32StoreMem instruction in the else branch.
  assertTraps(kTrapMemOutOfBounds, () => instance.exports.main(1, index));
  // Enter the else branch (growing memory).
  assertEquals(value, instance.exports.main(0, index));
})();

// This test verifies that the effects of growing memory in an if/else branch
// are retained when the branch is merged.
(function TestMemoryGrowAndStoreInBothIfAndElse() {
  print('TestMemoryGrowAndStoreInBothIfAndElse ...');
  let index = 0;
  let valueIf = 21;
  let valueElse = 42;
  let deltaPagesIf = 1;
  let deltaPagesElse = 2;
  let builder = generateBuilder();
  builder.addFunction('main', kSig_i_ii)
      .addBody([
        kExprLocalGet, 0,                       // get condition parameter
        kExprIf, kWasmVoid,                     // if it's 1 then enter if
          kExprI32Const, deltaPagesIf,          // put deltaPagesIf on stack
          kExprMemoryGrow, kMemoryZero,         // grow memory
          kExprDrop,                            // drop the result of grow
          kExprLocalGet, 1,                     // get index parameter
          kExprI32Const, valueIf,               // put valueIf on stack
          kExprI32StoreMem, 0, 0,               // store
        kExprElse,
          kExprI32Const, deltaPagesElse,        // put deltaPagesElse on stack
          kExprMemoryGrow, kMemoryZero,         // grow memory
          kExprDrop,                            // drop the result of grow
          kExprLocalGet, 1,                     // get index parameter
          kExprI32Const, valueElse,             // put valueElse on stack
          kExprI32StoreMem, 0, 0,               // store
        kExprEnd,
        kExprLocalGet, 1,                       // get index parameter
        kExprI32LoadMem, 0, 0                   // load from grown memory
      ])
      .exportFunc();
  var instance = builder.instantiate();
  // Enter the if branch (growing memory by 1 page).
  assertEquals(valueIf, instance.exports.main(1, index));
  // Enter the else branch (growing memory by 2 pages).
  assertEquals(valueElse, instance.exports.main(0, index));
})();
                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/wasm/grow-memory-in-call.js                                        0000664 0000000 0000000 00000045600 14746647661 0023630 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --stress-compaction

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

var initialMemoryPages = 1;
var maximumMemoryPages = 5;

// Grow memory in directly called functions.
print('=== grow_memory in direct calls ===');

// This test verifies that the current_memory instruction returns the correct
// value after returning from a function (direct call) that grew memory.
(function TestMemoryGrowInFunction() {
  print('TestMemoryGrowInFunction ...');
  let builder = new WasmModuleBuilder();
  builder.addMemory(initialMemoryPages, maximumMemoryPages);
  let kGrowFunction =
      builder.addFunction('grow', kSig_i_i)
          .addBody([kExprLocalGet, 0, kExprMemoryGrow, kMemoryZero])
          .exportFunc()
          .index;
  builder.addFunction('main', kSig_i_i)
      .addBody([
        kExprLocalGet, 0,                  // get number of new pages
        kExprCallFunction, kGrowFunction,  // call the grow function
        kExprDrop,                         // drop the result of grow
        kExprMemorySize, kMemoryZero       // get the memory size
      ])
      .exportFunc();
  var instance = builder.instantiate();
  // The caller should be aware that the memory was grown by the callee.
  var deltaPages = 1;
  assertEquals(
      initialMemoryPages + deltaPages, instance.exports.main(deltaPages));
})();

// This test verifies that accessing a memory page that has been created inside
// a function (direct call) does not trap in the caller.
(function TestMemoryGrowAndAccessInFunction() {
  print('TestMemoryGrowAndAccessInFunction ...');
  let index = 2 * kPageSize - 4;
  let builder = new WasmModuleBuilder();
  builder.addMemory(initialMemoryPages, maximumMemoryPages);
  let kGrowFunction =
      builder.addFunction('grow', kSig_i_i)
          .addBody([kExprLocalGet, 0, kExprMemoryGrow, kMemoryZero])
          .exportFunc()
          .index;
  builder.addFunction('load', kSig_i_i)
      .addBody([kExprLocalGet, 0, kExprI32LoadMem, 0, 0])
      .exportFunc();
  builder.addFunction('main', kSig_v_iii)
      .addBody([
        kExprLocalGet, 0,                  // get number of new pages
        kExprCallFunction, kGrowFunction,  // call the grow function
        kExprDrop,                         // drop the result of grow
        kExprLocalGet, 1,                  // get index
        kExprLocalGet, 2,                  // get value
        kExprI32StoreMem, 0, 0             // store
      ])
      .exportFunc();
  var instance = builder.instantiate();
  assertTraps(kTrapMemOutOfBounds, () => instance.exports.load(index));
  var deltaPages = 1;
  instance.exports.main(deltaPages, index, 1234);
  // The caller should be able to access memory that was grown by the callee.
  assertEquals(1234, instance.exports.load(index));
})();

// This test verifies that when a function (direct call) grows and store
// something in the grown memory, the caller always reads from the grown
// memory. This checks that the memory start address gets updated in the caller.
(function TestMemoryGrowAndStoreInFunction() {
  print('TestMemoryGrowAndStoreInFunction ...');
  let index = 0;
  let oldValue = 21;
  let newValue = 42;
  let deltaPages = 1;
  let builder = new WasmModuleBuilder();
  builder.addMemory(initialMemoryPages, maximumMemoryPages);
  let kGrowFunction =
      builder.addFunction('grow', kSig_v_v)
          .addBody([
            kExprI32Const, deltaPages,     // always grow memory by deltaPages
            kExprMemoryGrow, kMemoryZero,  // grow memory
            kExprDrop,                     // drop the result of grow
            kExprI32Const, index,          // put index on stack
            kExprI32Const, newValue,       // put new value on stack
            kExprI32StoreMem, 0, 0         // store
          ])
          .exportFunc()
          .index;
  builder.addFunction('main', kSig_i_i)
      .addBody([
        kExprI32Const, index,              // put index on stack
        kExprI32Const, oldValue,           // put old value on stack
        kExprI32StoreMem, 0, 0,            // store
        kExprCallFunction, kGrowFunction,  // call grow_and_store
        kExprI32Const, index,              // put index on stack
        kExprI32LoadMem, 0, 0              // load from grown memory
      ])
      .exportFunc();
  var instance = builder.instantiate();
  // The caller should always read from grown memory.
  assertEquals(newValue, instance.exports.main());
})();

// This test verifies that the effects of growing memory in an directly
// called function inside a loop affect the result of current_memory when
// the loop is over.
(function TestMemoryGrowInFunctionInsideLoop() {
  print('TestMemoryGrowInFunctionInsideLoop ...');
  let builder = new WasmModuleBuilder();
  builder.addMemory(initialMemoryPages, maximumMemoryPages);
  let kGrowFunction =
      builder.addFunction('grow', kSig_i_i)
          .addBody([kExprLocalGet, 0, kExprMemoryGrow, kMemoryZero])
          .exportFunc()
          .index;
  builder.addFunction('main', kSig_i_ii)
      .addBody([
        // clang-format off
        kExprLoop, kWasmVoid,                   // while
          kExprLocalGet, 0,                     // -
          kExprIf, kWasmVoid,                   // if <param0> != 0
            // Grow memory.
            kExprLocalGet, 1,                   // get number of new pages
            kExprCallFunction, kGrowFunction,   // call the grow function
            kExprDrop,                          // drop the result of grow
            // Decrease loop variable.
            kExprLocalGet, 0,                   // -
            kExprI32Const, 1,                   // -
            kExprI32Sub,                        // -
            kExprLocalSet, 0,                   // decrease <param0>
            kExprBr, 1,                         // continue
          kExprEnd,                             // end if
        kExprEnd,                               // end loop
        // Return the memory size.
        kExprMemorySize, kMemoryZero            // put memory size on stack
        // clang-format on
      ])
      .exportFunc();
  // The caller should be aware that the memory was grown by the callee.
  let instance = builder.instantiate();
  let iterations = 4;
  let deltaPages = 1;
  assertEquals(
      initialMemoryPages + iterations * deltaPages,
      instance.exports.main(iterations, deltaPages));
})();

// This test verifies that the effects of writing to memory grown in an
// directly called function inside a loop are retained when the loop is over.
(function TestMemoryGrowAndStoreInFunctionInsideLoop() {
  print('TestMemoryGrowAndStoreInFunctionInsideLoop ...');
  let builder = new WasmModuleBuilder();
  builder.addMemory(initialMemoryPages, maximumMemoryPages);
  builder.addFunction('store', kSig_i_ii)
      .addBody([
        kExprLocalGet, 0, kExprLocalGet, 1, kExprI32StoreMem, 0, 0,
        kExprLocalGet, 1
      ])
      .exportFunc();
  let kGrowFunction =
      builder.addFunction('grow', kSig_i_i)
          .addBody([kExprLocalGet, 0, kExprMemoryGrow, kMemoryZero])
          .exportFunc()
          .index;
  // parameters:  iterations, deltaPages, index
  builder.addFunction('main', kSig_i_iii)
      .addBody([
        // clang-format off
        kExprLoop, kWasmVoid,                   // while
          kExprLocalGet, 0,                     // -
          kExprIf, kWasmVoid,                   // if <param0> != 0
            // Grow memory.
            kExprLocalGet, 1,                   // get number of new pages
            kExprCallFunction, kGrowFunction,   // call the grow function
            kExprDrop,                          // drop the result of grow
            // Increase counter in memory.
            kExprLocalGet, 2,                   // put index (for store)
                kExprLocalGet, 2,               // put index (for load)
                kExprI32LoadMem, 0, 0,          // load from grown memory
              kExprI32Const, 1,                 // -
              kExprI32Add,                      // increase counter
            kExprI32StoreMem, 0, 0,             // store counter in memory
            // Decrease loop variable.
            kExprLocalGet, 0,                   // -
            kExprI32Const, 1,                   // -
            kExprI32Sub,                        // -
            kExprLocalSet, 0,                   // decrease <param0>
            kExprBr, 1,                         // continue
          kExprEnd,                             // end if
        kExprEnd,                               // end loop
        // Return the value
        kExprLocalGet, 2,                       // -
        kExprI32LoadMem, 0, 0                   // load from grown memory
        // clang-format on
      ])
      .exportFunc();
  // The caller should always read the correct memory
  let instance = builder.instantiate();
  let iterations = 4;
  let deltaPages = 1;
  let index = 0;
  let initialValue = 1;
  let expectedValue = initialValue + iterations;
  instance.exports.store(index, initialValue);
  assertEquals(
      expectedValue, instance.exports.main(iterations, deltaPages, index));
})();

// Grow memory in indirectly called functions.
print('\n=== grow_memory in indirect calls ===');

// This test verifies that the current_memory instruction returns the correct
// value after returning from a function (indirect call) that grew memory.
(function TestMemoryGrowInIndirectCall() {
  print('TestMemoryGrowInIndirectCall ...');
  let builder = new WasmModuleBuilder();
  builder.addMemory(initialMemoryPages, maximumMemoryPages);
  let kGrowFunction =
      builder.addFunction('grow', kSig_i_i)
          .addBody([kExprLocalGet, 0, kExprMemoryGrow, kMemoryZero])
          .exportFunc()
          .index;
  builder.addFunction('main', kSig_i_ii)
      .addBody([
        kExprLocalGet, 1,                  // get number of new pages
        kExprLocalGet, 0,                  // get index of the function
        kExprCallIndirect, 0, kTableZero,  // call the function
        kExprDrop,                         // drop the result of grow
        kExprMemorySize, kMemoryZero       // get the memory size
      ])
      .exportFunc();
  builder.appendToTable([kGrowFunction]);
  var instance = builder.instantiate();
  // The caller should be aware that the memory was grown by the callee.
  var deltaPages = 1;
  assertEquals(
      initialMemoryPages + deltaPages,
      instance.exports.main(kGrowFunction, deltaPages));
})();

// This test verifies that accessing a memory page that has been created inside
// a function (indirect call) does not trap in the caller.
(function TestMemoryGrowAndAccessInIndirectCall() {
  print('TestMemoryGrowAndAccessInIndirectCall ...');
  let index = 2 * kPageSize - 4;
  let builder = new WasmModuleBuilder();
  builder.addMemory(initialMemoryPages, maximumMemoryPages);
  let kGrowFunction =
      builder.addFunction('grow', kSig_i_i)
          .addBody([kExprLocalGet, 0, kExprMemoryGrow, kMemoryZero])
          .exportFunc()
          .index;
  builder.addFunction('load', kSig_i_i)
      .addBody([kExprLocalGet, 0, kExprI32LoadMem, 0, 0])
      .exportFunc();
  let sig = makeSig([kWasmI32, kWasmI32, kWasmI32, kWasmI32], []);
  builder.addFunction('main', sig)
      .addBody([
        kExprLocalGet, 1,                  // get number of new pages
        kExprLocalGet, 0,                  // get index of the function
        kExprCallIndirect, 0, kTableZero,  // call the function
        kExprDrop,                         // drop the result of grow
        kExprLocalGet, 2,                  // get index
        kExprLocalGet, 3,                  // get value
        kExprI32StoreMem, 0, 0             // store
      ])
      .exportFunc();
  builder.appendToTable([kGrowFunction]);
  var instance = builder.instantiate();
  assertTraps(kTrapMemOutOfBounds, () => instance.exports.load(index));
  let deltaPages = 1;
  let value = 1234;
  instance.exports.main(kGrowFunction, deltaPages, index, value);
  // The caller should be able to access memory that was grown by the callee.
  assertEquals(value, instance.exports.load(index));
})();

// This test verifies that when a function (indirect call) grows and store
// something in the grown memory, the caller always reads from the grown
// memory. This checks that the memory start address gets updated in the caller.
(function TestMemoryGrowAndStoreInIndirectCall() {
  print('TestMemoryGrowAndStoreInIndirectCall ...');
  let index = 0;
  let oldValue = 21;
  let newValue = 42;
  let deltaPages = 1;
  let builder = new WasmModuleBuilder();
  builder.addMemory(initialMemoryPages, maximumMemoryPages);
  let kGrowFunction =
      builder.addFunction('grow', kSig_v_v)
          .addBody([
            kExprI32Const, deltaPages,     // always grow memory by deltaPages
            kExprMemoryGrow, kMemoryZero,  // grow memory
            kExprDrop,                     // drop the result of grow
            kExprI32Const, index,          // put index on stack
            kExprI32Const, newValue,       // put new value on stack
            kExprI32StoreMem, 0, 0         // store
          ])
          .exportFunc()
          .index;
  builder.addFunction('main', kSig_i_i)
      .addBody([
        kExprI32Const, index,              // put index on stack
        kExprI32Const, oldValue,           // put old value on stack
        kExprI32StoreMem, 0, 0,            // store
        kExprLocalGet, 0,                  // get index of the function
        kExprCallIndirect, 0, kTableZero,  // call the function
        kExprI32Const, index,              // put index on stack
        kExprI32LoadMem, 0, 0              // load from grown memory
      ])
      .exportFunc();
  builder.appendToTable([kGrowFunction]);
  var instance = builder.instantiate();
  // The caller should always read from grown memory.
  assertEquals(42, instance.exports.main(kGrowFunction));
})();

// This test verifies that the effects of growing memory in an indirectly
// called function inside a loop affect the result of current_memory when
// the loop is over.
(function TestMemoryGrowInIndirectCallInsideLoop() {
  print('TestMemoryGrowInIndirectCallInsideLoop ...');
  let builder = new WasmModuleBuilder();
  builder.addMemory(initialMemoryPages, maximumMemoryPages);
  let kGrowFunction =
      builder.addFunction('grow', kSig_i_i)
          .addBody([kExprLocalGet, 0, kExprMemoryGrow, kMemoryZero])
          .exportFunc()
          .index;
  builder.addFunction('main', kSig_i_iii)
      .addBody([
        // clang-format off
        kExprLoop, kWasmVoid,                   // while
          kExprLocalGet, 1,                     // -
          kExprIf, kWasmVoid,                   // if <param1> != 0
            // Grow memory.
            kExprLocalGet, 2,                   // get number of new pages
            kExprLocalGet, 0,                   // get index of the function
            kExprCallIndirect, 0, kTableZero,   // call the function
            kExprDrop,                          // drop the result of grow
            // Decrease loop variable.
            kExprLocalGet, 1,                   // -
            kExprI32Const, 1,                   // -
            kExprI32Sub,                        // -
            kExprLocalSet, 1,                   // decrease <param1>
            kExprBr, 1,                         // continue
          kExprEnd,                             // end if
        kExprEnd,                               // end loop
        // Return the memory size.
        kExprMemorySize, kMemoryZero            // put memory size on stack
        // clang-format on
      ])
      .exportFunc();
  builder.appendToTable([kGrowFunction]);
  // The caller should be aware that the memory was grown by the callee.
  let instance = builder.instantiate();
  let deltaPages = 1;
  let iterations = 4;
  assertEquals(
      initialMemoryPages + iterations * deltaPages,
      instance.exports.main(kGrowFunction, iterations, deltaPages));
})();

// This test verifies that the effects of writing to memory grown in an
// indirectly called function inside a loop are retained when the loop is over.
(function TestMemoryGrowAndStoreInIndirectCallInsideLoop() {
  print('TestMemoryGrowAndStoreInIndirectCallInsideLoop ...');
  let builder = new WasmModuleBuilder();
  let deltaPages = 1;
  builder.addMemory(initialMemoryPages, maximumMemoryPages);
  let kGrowFunction =
      builder.addFunction('grow', kSig_i_i)
          .addBody([kExprLocalGet, 0, kExprMemoryGrow, kMemoryZero])
          .exportFunc()
          .index;
  builder.addFunction('store', kSig_i_ii)
      .addBody([
        kExprLocalGet, 0, kExprLocalGet, 1, kExprI32StoreMem, 0, 0,
        kExprLocalGet, 1
      ])
      .exportFunc();
  builder
      .addFunction(
          // parameters:  function_index, iterations, deltaPages, index
          'main', makeSig([kWasmI32, kWasmI32, kWasmI32, kWasmI32], [kWasmI32]))
      .addBody([
        // clang-format off
        kExprLoop, kWasmVoid,                   // while
          kExprLocalGet, 1,                     // -
          kExprIf, kWasmVoid,                   // if <param1> != 0
            // Grow memory.
            kExprLocalGet, 2,                   // get number of new pages
            kExprLocalGet, 0,                   // get index of the function
            kExprCallIndirect, 0, kTableZero,   // call the function
            kExprDrop,                          // drop the result of grow
            // Increase counter in memory.
            kExprLocalGet, 3,                   // put index (for store)
                kExprLocalGet, 3,               // put index (for load)
                kExprI32LoadMem, 0, 0,          // load from grown memory
              kExprI32Const, 1,                 // -
              kExprI32Add,                      // increase counter
            kExprI32StoreMem, 0, 0,             // store counter in memory
            // Decrease loop variable.
            kExprLocalGet, 1,                   // -
            kExprI32Const, 1,                   // -
            kExprI32Sub,                        // -
            kExprLocalSet, 1,                   // decrease <param1>
            kExprBr, 1,                         // continue
          kExprEnd,                             // end if
        kExprEnd,                               // end loop
        // Return the value
        kExprLocalGet, 3,                       // -
        kExprI32LoadMem, 0, 0                   // load from grown memory
        // clang-format on
      ])
      .exportFunc();
  builder.appendToTable([kGrowFunction]);
  // The caller should be aware that the memory was grown by the callee.
  let instance = builder.instantiate();
  let iterations = 4;
  let index = 0;
  let initialValue = 1;
  let expectedValue = initialValue + iterations;
  instance.exports.store(index, initialValue);
  assertEquals(
      expectedValue,
      instance.exports.main(kGrowFunction, iterations, deltaPages, index));
})();
                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/wasm/grow-memory-in-loop.js                                        0000664 0000000 0000000 00000025112 14746647661 0023662 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --stress-compaction

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

let initialPages = 1;
let maximumPages = 6;

function generateBuilder() {
  let builder = new WasmModuleBuilder();
  builder.addMemory(initialPages, maximumPages);
  builder.addFunction('store', kSig_i_ii)
      .addBody([
        kExprLocalGet, 0, kExprLocalGet, 1, kExprI32StoreMem, 0, 0,
        kExprLocalGet, 1
      ])
      .exportFunc();
  return builder;
}

// This test verifies that the effects of growing memory inside a loop
// affect the result of current_memory when the loop is over.
(function TestMemoryGrowInsideLoop() {
  print('TestMemoryGrowInsideLoop ...');
  let deltaPages = 1;
  let builder = generateBuilder();
  builder.addFunction('main', kSig_i_i)
      .addBody([
        // clang-format off
        kExprLoop, kWasmVoid,                   // while
          kExprLocalGet, 0,                     // -
          kExprIf, kWasmVoid,                   // if <param0> != 0
            // Grow memory.
            kExprI32Const, deltaPages,          // -
            kExprMemoryGrow, kMemoryZero,       // grow memory
            kExprDrop,                          // drop the result of grow
            // Decrease loop variable.
            kExprLocalGet, 0,                   // -
            kExprI32Const, 1,                   // -
            kExprI32Sub,                        // -
            kExprLocalSet, 0,                   // decrease <param0>
            kExprBr, 1,                         // continue
          kExprEnd,                             // end if
        kExprEnd,                               // end loop
        // Return the memory size.
        kExprMemorySize, kMemoryZero            // put memory size on stack
        // clang-format on
      ])
      .exportFunc();
  {
    // Avoid the loop branch (not growing memory).
    let instance = builder.instantiate();
    let iterations = 0;
    let expectedPages = initialPages + iterations * deltaPages;
    assertTrue(expectedPages <= maximumPages);
    assertEquals(expectedPages, instance.exports.main(iterations));
  }
  {
    // Enter the loop branch (growing memory).
    let instance = builder.instantiate();
    let iterations = 2;
    let expectedPages = initialPages + iterations * deltaPages;
    assertTrue(expectedPages <= maximumPages);
    assertEquals(expectedPages, instance.exports.main(iterations));
  }
})();

// This test verifies that a loop does not affect the result of current_memory
// when the memory is grown both inside and outside the loop.
(function TestMemoryGrowInsideAndOutsideLoop() {
  print('TestMemoryGrowInsideAndOutsideLoop ...');
  let deltaPagesIn = 1;
  let deltaPagesOut = 2;
  let builder = generateBuilder();
  builder.addFunction('main', kSig_i_i)
      .addBody([
        // clang-format off
        // Grow memory.
        kExprI32Const, deltaPagesOut,           // -
        kExprMemoryGrow, kMemoryZero,           // grow memory
        kExprDrop,                              // drop the result of grow
        kExprLoop, kWasmVoid,                   // while
          kExprLocalGet, 0,                     // -
          kExprIf, kWasmVoid,                   // if <param0> != 0
            // Grow memory.
            kExprI32Const, deltaPagesIn,        // -
            kExprMemoryGrow, kMemoryZero,       // grow memory
            kExprDrop,                          // drop the result of grow
            // Decrease loop variable.
            kExprLocalGet, 0,                   // -
            kExprI32Const, 1,                   // -
            kExprI32Sub,                        // -
            kExprLocalSet, 0,                   // decrease <param0>
            kExprBr, 1,                         // continue
          kExprEnd,                             // end if
        kExprEnd,                               // end loop
        // Return memory size.
        kExprMemorySize, kMemoryZero            // put memory size on stack
        // clang-format on
      ])
      .exportFunc();
  {
    // Avoid the loop branch (grow memory by deltaPagesOut).
    let instance = builder.instantiate();
    let iterations = 0;
    let expectedPages = initialPages + deltaPagesOut;
    assertTrue(expectedPages <= maximumPages);
    assertEquals(expectedPages, instance.exports.main(iterations));
  }
  {
    // Avoid the loop branch (grow memory by deltaPagesOut
    // + iterations * deltaPagesIn).
    let instance = builder.instantiate();
    let iterations = 3;
    let expectedPages =
        initialPages + deltaPagesOut + (iterations * deltaPagesIn);
    assertTrue(expectedPages <= maximumPages);
    assertEquals(expectedPages, instance.exports.main(iterations));
  }
})();

// This test verifies that the effects of writing to memory grown inside a loop
// are retained when the loop is over.
(function TestMemoryGrowAndStoreInsideLoop() {
  print('TestMemoryGrowAndStoreInsideLoop ...');
  let deltaPages = 1;
  let builder = generateBuilder();
  builder.addFunction('main', kSig_i_ii)
      .addBody([
        // clang-format off
        kExprLoop, kWasmVoid,                   // while
          kExprLocalGet, 0,                     // -
          kExprIf, kWasmVoid,                   // if <param0> != 0
            // Grow memory.
            kExprI32Const, deltaPages,          // -
            kExprMemoryGrow, kMemoryZero,       // grow memory
            kExprDrop,                          // drop the result of grow
            // Increase counter in memory.
            kExprLocalGet, 1,                   // put index (for store)
                kExprLocalGet, 1,               // put index (for load)
                kExprI32LoadMem, 0, 0,          // load from grown memory
              kExprI32Const, 1,                 // -
              kExprI32Add,                      // increase counter
            kExprI32StoreMem, 0, 0,             // store counter in memory
            // Decrease loop variable.
            kExprLocalGet, 0,                   // -
            kExprI32Const, 1,                   // -
            kExprI32Sub,                        // -
            kExprLocalSet, 0,                   // decrease <param0>
            kExprBr, 1,                         // continue
          kExprEnd,                             // end if
        kExprEnd,                               // end loop
        // Increase counter in memory.
        kExprLocalGet, 1,                       // -
        kExprI32LoadMem, 0, 0                   // load from grown memory
        // clang-format on
      ])
      .exportFunc();

  let index = 0;
  let initialValue = 1;
  {
    // Avoid the loop (not growing memory).
    let instance = builder.instantiate();
    let iterations = 0;
    let expectedValue = initialValue + iterations;
    instance.exports.store(index, initialValue);
    assertEquals(expectedValue, instance.exports.main(iterations, index));
  }
  {
    // Enter the loop (growing memory + increasing counter in grown memory).
    let instance = builder.instantiate();
    let iterations = 2;
    let expectedValue = initialValue + iterations;
    instance.exports.store(index, initialValue);
    assertEquals(expectedValue, instance.exports.main(iterations, index));
  }
})();

// This test verifies that a loop does not affect the memory when the
// memory is grown both inside and outside the loop.
(function TestMemoryGrowAndStoreInsideAndOutsideLoop() {
  print('TestMemoryGrowAndStoreInsideAndOutsideLoop ...');
  let deltaPagesIn = 1;
  let deltaPagesOut = 2;
  let builder = generateBuilder();
  builder.addFunction('main', kSig_i_ii)
      .addBody([
        // clang-format off
        // Grow memory.
        kExprI32Const, deltaPagesOut,           // -
        kExprMemoryGrow, kMemoryZero,           // grow memory
        kExprDrop,                              // drop the result of grow
        // Increase counter in memory.
        kExprLocalGet, 1,                       // put index (for store)
            kExprLocalGet, 1,                   // put index (for load)
            kExprI32LoadMem, 0, 0,              // load from grown memory
          kExprI32Const, 1,                     // -
          kExprI32Add,                          // increase value on stack
        kExprI32StoreMem, 0, 0,                 // store new value
        // Start loop.
        kExprLoop, kWasmVoid,                   // while
          kExprLocalGet, 0,                     // -
          kExprIf, kWasmVoid,                   // if <param0> != 0
            // Grow memory.
            kExprI32Const, deltaPagesIn,        // -
            kExprMemoryGrow, kMemoryZero,       // grow memory
            kExprDrop,                          // drop the result of grow
            // Increase counter in memory.
            kExprLocalGet, 1,                   // put index (for store)
                kExprLocalGet, 1,               // put index (for load)
                kExprI32LoadMem, 0, 0,          // load from grown memory
              kExprI32Const, 1,                 // -
              kExprI32Add,                      // increase value on stack
            kExprI32StoreMem, 0, 0,             // store new value
            // Decrease loop variable.
            kExprLocalGet, 0,                   // -
            kExprI32Const, 1,                   // -
            kExprI32Sub,                        // -
            kExprLocalSet, 0,                   // decrease <param0>
            kExprBr, 1,                         // continue
          kExprEnd,                             // end if
        kExprEnd,                               // end loop
        // Return counter from memory.
        kExprLocalGet, 1,                       // put index on stack
        kExprI32LoadMem, 0, 0                   // load from grown memory
        // clang-format on
      ])
      .exportFunc();

  let index = 0;
  let initialValue = 1;
  {
    // Avoid the loop (grow memory and increment counter only outside the loop).
    let instance = builder.instantiate();
    let iterations = 0;
    let expectedValue = initialValue + 1;
    instance.exports.store(index, initialValue);
    assertEquals(expectedValue, instance.exports.main(iterations, index));
  }
  {
    // Enter the loop (grow memory and increment counter outside/inside loop).
    let instance = builder.instantiate();
    let iterations = 3;
    let expectedValue = initialValue + iterations + 1;
    instance.exports.store(index, initialValue);
    assertEquals(expectedValue, instance.exports.main(iterations, index));
  }
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/wasm/grow-memory.js                                                0000664 0000000 0000000 00000036323 14746647661 0022315 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --stress-compaction
// This test does not behave predictably, since growing memory is allowed to
// fail nondeterministically.
// Flags: --no-verify-predictable

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");


function genMemoryGrowBuilder() {
  var builder = new WasmModuleBuilder();
  builder.addFunction("grow_memory", kSig_i_i)
      .addBody([kExprLocalGet, 0, kExprMemoryGrow, kMemoryZero])
      .exportFunc();
  builder.addFunction("load", kSig_i_i)
      .addBody([kExprLocalGet, 0, kExprI32LoadMem, 0, 0])
      .exportFunc();
  builder.addFunction("store", kSig_i_ii)
      .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32StoreMem, 0, 0,
                kExprLocalGet, 1])
      .exportFunc();
  builder.addFunction("load16", kSig_i_i)
      .addBody([kExprLocalGet, 0, kExprI32LoadMem16U, 0, 0])
      .exportFunc();
  builder.addFunction("store16", kSig_i_ii)
      .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32StoreMem16, 0, 0,
                kExprLocalGet, 1])
      .exportFunc();
  builder.addFunction("load8", kSig_i_i)
      .addBody([kExprLocalGet, 0, kExprI32LoadMem8U, 0, 0])
      .exportFunc();
  builder.addFunction("store8", kSig_i_ii)
      .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32StoreMem8, 0, 0,
                kExprLocalGet, 1])
      .exportFunc();
  return builder;
}

// V8 internal memory size limit.
var kV8MaxPages = 65536;


function testMemoryGrowReadWriteBase(size, load_fn, store_fn) {
  // size is the number of bytes for load and stores.
  var builder = genMemoryGrowBuilder();
  builder.addMemory(1, undefined);
  var module = builder.instantiate();
  var offset;
  var load = module.exports[load_fn];
  var store = module.exports[store_fn];
  function peek() { return load(offset); }
  function poke(value) { return store(offset, value); }
  function growMem(pages) { return module.exports.grow_memory(pages); }

  // Instead of checking every n-th offset, check the first 5.
  for(offset = 0; offset <= (4*size); offset+=size) {
    poke(20);
    assertEquals(20, peek());
  }
  for (offset = kPageSize - (size - 1); offset < kPageSize + size; offset++) {
    assertTraps(kTrapMemOutOfBounds, poke);
    assertTraps(kTrapMemOutOfBounds, peek);
  }

  assertEquals(1, growMem(3));

  for (let n = 1; n <= 3; n++) {
    for (offset = n * kPageSize - 5 * size; offset <= n * kPageSize + 4 * size;
         offset += size) {
      // Check the 5 offsets to the before and after the n-th page.
      //    page n-1              page n          page n+1
      //    +---- ... ------------+---------- ... +------ ...
      //    | | | ... | | | | | | | | | | | | ... | | | | ...
      //      <+>       ^                 ^
      //       |        first offset      last offset
      //       +-> size bytes
      poke(20);
      assertEquals(20, peek());
    }
  }

  // Check the last 5 valid offsets of the last page.
  for (offset = 4*kPageSize-size-(4*size); offset <= 4*kPageSize -size; offset+=size) {
    poke(20);
    assertEquals(20, peek());
  }

  for (offset = 4*kPageSize - (size-1); offset < 4*kPageSize + size; offset++) {
    assertTraps(kTrapMemOutOfBounds, poke);
    assertTraps(kTrapMemOutOfBounds, peek);
  }

  assertEquals(4, growMem(15));

  for (offset = 4*kPageSize - (size-1); offset <= 4*kPageSize + size; offset+=size) {
    poke(20);
    assertEquals(20, peek());
  }
  for (offset = 19*kPageSize - 10; offset <= 19*kPageSize - size; offset+=size) {
    poke(20);
    assertEquals(20, peek());
  }
  for (offset = 19*kPageSize - (size-1); offset < 19*kPageSize + 5; offset++) {
    assertTraps(kTrapMemOutOfBounds, poke);
    assertTraps(kTrapMemOutOfBounds, peek);
  }
}

(function testMemoryGrowReadWrite32() {
  print(arguments.callee.name);
  testMemoryGrowReadWriteBase(4, "load", "store");
})();

(function testMemoryGrowReadWrite16() {
  print(arguments.callee.name);
  testMemoryGrowReadWriteBase(2, "load16", "store16");
})();

(function testMemoryGrowReadWrite8() {
  print(arguments.callee.name);
  testMemoryGrowReadWriteBase(1, "load8", "store8");
})();

(function testMemoryGrowZeroInitialSize() {
  print(arguments.callee.name);
  var builder = genMemoryGrowBuilder();
  builder.addMemory(0, undefined);
  var module = builder.instantiate();
  var offset;
  function peek() { return module.exports.load(offset); }
  function poke(value) { return module.exports.store(offset, value); }
  function growMem(pages) { return module.exports.grow_memory(pages); }

  assertTraps(kTrapMemOutOfBounds, peek);
  assertTraps(kTrapMemOutOfBounds, poke);

  assertEquals(0, growMem(1));

  // Check first 5 offsets.
  for(offset = 0; offset <= 5; offset++) {
    poke(20);
    assertEquals(20, peek());
  }

  // Check last 5 offsets.
  for(offset = kPageSize - 5*4; offset <= kPageSize - 4; offset++) {
    poke(20);
    assertEquals(20, peek());
  }

  for(offset = kPageSize - 3; offset <= kPageSize + 5; offset++) {
    assertTraps(kTrapMemOutOfBounds, peek);
  }

  offset = 3*kPageSize;
  for (var i = 1; i < 4; i++) {
    assertTraps(kTrapMemOutOfBounds, poke);
    assertEquals(i, growMem(1));
  }
  poke(20);
  assertEquals(20, peek());
})();

function testMemoryGrowZeroInitialSizeBase(size, load_fn, store_fn) {
  var builder = genMemoryGrowBuilder();
  builder.addMemory(0, undefined);
  var module = builder.instantiate();
  var offset;
  var load = module.exports[load_fn];
  var store = module.exports[store_fn];
  function peek() { return load(offset); }
  function poke(value) { return store(offset, value); }
  function growMem(pages) { return module.exports.grow_memory(pages); }

  assertTraps(kTrapMemOutOfBounds, peek);
  assertTraps(kTrapMemOutOfBounds, poke);

  assertEquals(0, growMem(1));

  // Instead of checking every offset, check the first 5.
  for(offset = 0; offset <= 4; offset++) {
    poke(20);
    assertEquals(20, peek());
  }

  // Check the last 5 valid ones.
  for(offset = kPageSize - (size * 4); offset <= kPageSize - size; offset++) {
    poke(20);
    assertEquals(20, peek());
  }

  for(offset = kPageSize - (size - 1); offset <= kPageSize + 5; offset++) {
    assertTraps(kTrapMemOutOfBounds, peek);
  }
}

(function testMemoryGrowZeroInitialSize32() {
  print(arguments.callee.name);
  testMemoryGrowZeroInitialSizeBase(4, "load", "store");
})();

(function testMemoryGrowZeroInitialSize16() {
  print(arguments.callee.name);
  testMemoryGrowZeroInitialSizeBase(2, "load16", "store16");
})();

(function testMemoryGrowZeroInitialSize8() {
  print(arguments.callee.name);
  testMemoryGrowZeroInitialSizeBase(1, "load8", "store8");
})();

(function testMemoryGrowTrapMaxPagesZeroInitialMemory() {
  print(arguments.callee.name);
  var builder = genMemoryGrowBuilder();
  builder.addMemory(0, undefined);
  var module = builder.instantiate();
  function growMem(pages) { return module.exports.grow_memory(pages); }
  assertEquals(-1, growMem(kV8MaxPages + 1));
})();

(function testMemoryGrowTrapMaxPages() {
  print(arguments.callee.name);
  var builder = genMemoryGrowBuilder();
  builder.addMemory(1, 1);
  var module = builder.instantiate();
  function growMem(pages) { return module.exports.grow_memory(pages); }
  assertEquals(-1, growMem(kV8MaxPages));
})();

(function testMemoryGrowTrapsWithNonSmiInput() {
  print(arguments.callee.name);
  var builder = genMemoryGrowBuilder();
  builder.addMemory(0, undefined);
  var module = builder.instantiate();
  function growMem(pages) { return module.exports.grow_memory(pages); }
  // The parameter of grow_memory is unsigned. Therefore -1 stands for
  // UINT32_MIN, which cannot be represented as SMI.
  assertEquals(-1, growMem(-1));
})();

(function testMemoryGrowCurrentMemory() {
  print(arguments.callee.name);
  var builder = genMemoryGrowBuilder();
  builder.addMemory(1, undefined);
  builder.addFunction("memory_size", kSig_i_v)
      .addBody([kExprMemorySize, kMemoryZero])
      .exportFunc();
  var module = builder.instantiate();
  function growMem(pages) { return module.exports.grow_memory(pages); }
  function MemSize() { return module.exports.memory_size(); }
  assertEquals(1, MemSize());
  assertEquals(1, growMem(1));
  assertEquals(2, MemSize());
})();

function testMemoryGrowPreservesDataMemOpBase(size, load_fn, store_fn) {
  var builder = genMemoryGrowBuilder();
  builder.addMemory(1, undefined);
  var module = builder.instantiate();
  var offset;
  var load = module.exports[load_fn];
  var store = module.exports[store_fn];
  function peek() { return load(offset); }
  function poke(value) { return store(offset, value); }
  function growMem(pages) { return module.exports.grow_memory(pages); }
  // Maximum unsigned integer of size bits.
  const max = Math.pow(2, (size * 8)) - 1;

  // Check the first 5 offsets.
  for(offset = 0; offset <= (4*size); offset+=size) {
    poke(offset % max);
    assertEquals(offset % max, peek());
  }

  // Check the last 5 valid offsets.
  for(offset = kPageSize - 5*size; offset <= (kPageSize - size); offset+=size) {
    poke(offset % max);
    assertEquals(offset % max, peek());
  }

  assertEquals(1, growMem(3));

  // Check the first 5 offsets are preserved by growMem.
  for(offset = 0; offset <= (4*size); offset+=size) {
    assertEquals(offset % max, peek());
  }

  // Check the last 5 valid offsets are preserved by growMem.
  for(offset = kPageSize - 5*size; offset <= (kPageSize - size); offset+=size) {
    assertEquals(offset % max, peek());
  }
}

(function testMemoryGrowPreservesDataMemOp32() {
  print(arguments.callee.name);
  testMemoryGrowPreservesDataMemOpBase(4, "load", "store");
})();

(function testMemoryGrowPreservesDataMemOp16() {
  print(arguments.callee.name);
  testMemoryGrowPreservesDataMemOpBase(2, "load16", "store16");
})();

(function testMemoryGrowPreservesDataMemOp8() {
  print(arguments.callee.name);
  testMemoryGrowPreservesDataMemOpBase(1, "load8", "store8");
})();

(function testMemoryGrowOutOfBoundsOffset() {
  print(arguments.callee.name);
  var builder = genMemoryGrowBuilder();
  builder.addMemory(1, undefined);
  var module = builder.instantiate();
  var offset, val;
  function peek() { return module.exports.load(offset); }
  function poke(value) { return module.exports.store(offset, value); }
  function growMem(pages) { return module.exports.grow_memory(pages); }

  offset = 3*kPageSize + 4;
  assertTraps(kTrapMemOutOfBounds, poke);

  assertEquals(1, growMem(1));
  assertTraps(kTrapMemOutOfBounds, poke);

  assertEquals(2, growMem(1));
  assertTraps(kTrapMemOutOfBounds, poke);

  assertEquals(3, growMem(1));

  for (offset = 3*kPageSize; offset <= 3*kPageSize + 4; offset++) {
    poke(0xaced);
    assertEquals(0xaced, peek());
  }

  for (offset = 4*kPageSize-8; offset <= 4*kPageSize - 4; offset++) {
    poke(0xaced);
    assertEquals(0xaced, peek());
  }

  for (offset = 4*kPageSize - 3; offset <= 4*kPageSize + 4; offset++) {
    assertTraps(kTrapMemOutOfBounds, poke);
  }
})();

(function testMemoryGrowOutOfBoundsOffset2() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  builder.addMemory(16, 128);
  builder.addFunction("main", kSig_v_v)
      .addBody([
          kExprI32Const, 20,
          kExprI32Const, 29,
          kExprMemoryGrow, kMemoryZero,
          kExprI32StoreMem, 0, 0xFF, 0xFF, 0xFF, 0x3a
          ])
      .exportAs("main");
  var module = builder.instantiate();
  assertTraps(kTrapMemOutOfBounds, module.exports.main);
})();

(function testMemoryGrowDeclaredMaxTraps() {
  print(arguments.callee.name);
  var builder = genMemoryGrowBuilder();
  builder.addMemory(1, 16);
  var module = builder.instantiate();
  function growMem(pages) { return module.exports.grow_memory(pages); }
  assertEquals(1, growMem(5));
  assertEquals(6, growMem(5));
  assertEquals(-1, growMem(6));
})();

(function testMemoryGrowInternalMaxTraps() {
  print(arguments.callee.name);
  // This test checks that grow_memory does not grow past the internally
  // defined maximum memory size.
  var builder = genMemoryGrowBuilder();
  builder.addMemory(1, kSpecMaxPages);
  var module = builder.instantiate();
  function growMem(pages) { return module.exports.grow_memory(pages); }
  assertEquals(1, growMem(20));
  assertEquals(-1, growMem(kV8MaxPages - 20));
})();

(function testMemoryGrow4Gb() {
  print(arguments.callee.name);
  var builder = genMemoryGrowBuilder();
  builder.addMemory(1, undefined);
  var module = builder.instantiate();
  var offset, val;
  function peek() { return module.exports.load(offset); }
  function poke(value) { return module.exports.store(offset, value); }
  function growMem(pages) { return module.exports.grow_memory(pages); }

  // Check first 5 offsets.
  for (offset = 0; offset <= 4 * 4; offset += 4) {
    poke(100000 - offset);
    assertEquals(100000 - offset, peek());
  }

  // Check last 5 offsets.
  for (offset = (kPageSize - 5 * 4); offset <= (kPageSize - 4); offset += 4) {
    poke(100000 - offset);
    assertEquals(100000 - offset, peek());
  }

  let result = growMem(kV8MaxPages - 1);
  if (result == 1) {
    // Check first 5 offsets.
    for (offset = 0; offset <= 4 * 4; offset += 4) {
      assertEquals(100000 - offset, peek());
    }

    // Check last 5 offsets.
    for (offset = (kPageSize - 5 * 4); offset <= (kPageSize - 4); offset += 4) {
      assertEquals(100000 - offset, peek());
    }

    // Bounds check for large mem size.
    let kMemSize = (kV8MaxPages * kPageSize);
    let kLastValidOffset = kMemSize - 4;  // Accommodate a 4-byte read/write.
    // Check first 5 offsets of last page.
    for (offset = kMemSize - kPageSize; offset <= kMemSize - kPageSize + 4 * 4;
         offset += 4) {
      poke(0xaced);
      assertEquals(0xaced, peek());
    }
    for (offset = kLastValidOffset - 5 * 4; offset <= kLastValidOffset;
         offset += 4) {
      poke(0xaced);
      assertEquals(0xaced, peek());
    }

    for (offset = kLastValidOffset + 1; offset < kMemSize; offset++) {
      assertTraps(kTrapMemOutOfBounds, poke);
    }
  } else {
    // Allocating big chunks of memory can fail on gc_stress, especially on 32
    // bit platforms. When grow_memory fails, expected result is -1.
    assertEquals(-1, result);
  }
})();

(function testGrowFromNearlyMaximum() {
  print(arguments.callee.name);
  // Regression test for https://crbug.com/1347668.
  const builder = genMemoryGrowBuilder();
  // The maximum needs to be >1GB, so we do not reserve everything upfront.
  const GB = 1024 * 1024 * 1024;
  const max_pages = 1 * GB / kPageSize + 10;

  builder.addMemory(0, max_pages);
  let module;
  const is_oom = e =>
      (e instanceof RangeError) && e.message.includes('Out of memory');
  // Allow instantiation to fail with OOM.
  try {
    module = builder.instantiate();
  } catch (e) {
    if (is_oom(e)) return;
    // Everything else is a bug.
    throw e;
  }
  const grow = module.exports.grow_memory;

  // First, grow close to the limit.
  // Growing can always fail if the system runs out of resources.
  let grow_result = grow(max_pages - 1);
  if (grow_result == -1) return;
  assertEquals(0, grow_result);

  // Then, grow by another page (this triggered the error in
  // https://crbug.com/1347668).
  grow_result = grow(1);
  if (grow_result == -1) return;
  assertEquals(max_pages - 1, grow_result);
  assertEquals(max_pages, grow(0));
  assertEquals(-1, grow(1));  // Fails.
})();
                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/grow-shared-memory.js                                         0000664 0000000 0000000 00000043504 14746647661 0023560 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function assertIsWasmSharedMemory(memory) {
 assertTrue(memory instanceof Object,
     "Memory is not an object");
 assertTrue(memory instanceof WebAssembly.Memory,
     "Object is not WebAssembly.Memory" );
 assertTrue(memory.buffer instanceof SharedArrayBuffer,
     "Memory.buffer is not a SharedArrayBuffer");
 assertTrue(Object.isFrozen(memory.buffer),
     "Memory.buffer not frozen");
}

function assertTrue(value, msg) {
  if (!value) {
    postMessage("Error: " + msg);
    throw new Error("Exit");  // To stop testing.
  }
}

let workerHelpers = assertTrue.toString() + assertIsWasmSharedMemory.toString();

(function TestGrowSharedMemoryWithoutPostMessage() {
  print(arguments.callee.name);
  let memory = new WebAssembly.Memory({initial: 1, maximum: 5, shared: true});
  assertEquals(memory.buffer.byteLength, kPageSize);
  assertEquals(1, memory.grow(1));
  assertEquals(memory.buffer.byteLength, 2 * kPageSize);
})();

(function TestPostMessageWithGrow() {
  print(arguments.callee.name);
  function workerCode(workerHelpers) {
    eval(workerHelpers);
    onmessage = function({data:obj}) {
      assertIsWasmSharedMemory(obj.memory);
      assertTrue(1 === obj.memory.grow(1));
      assertTrue(obj.memory.buffer.byteLength === obj.expected_size);
      assertIsWasmSharedMemory(obj.memory);
      postMessage("OK");
    }
  }
  let worker = new Worker(workerCode,
                          {type: 'function', arguments: [workerHelpers]});

  let memory = new WebAssembly.Memory({initial: 1, maximum: 5, shared: true});
  let obj = {memory: memory, expected_size: 2 * kPageSize};
  assertEquals(obj.memory.buffer.byteLength, kPageSize);
  worker.postMessage(obj);
  assertEquals("OK", worker.getMessage());
  assertEquals(obj.memory.buffer.byteLength, 2 * kPageSize);
  worker.terminate();
})();


// PostMessage from two different workers, and assert that the grow
// operations are performed on the same memory object.
(function TestWorkersWithGrowEarlyWorkerTerminate() {
  print(arguments.callee.name);
  function workerCode(workerHelpers) {
    eval(workerHelpers);
    onmessage = function({data:obj}) {
       assertIsWasmSharedMemory(obj.memory);
       obj.memory.grow(1);
       assertIsWasmSharedMemory(obj.memory);
       assertTrue(obj.memory.buffer.byteLength === obj.expected_size);
       postMessage("OK");
    };
  }

  let workers = [new Worker(workerCode,
                            {type: 'function', arguments: [workerHelpers]}),
                 new Worker(workerCode,
                            {type: 'function', arguments: [workerHelpers]})];
  let memory = new WebAssembly.Memory({initial: 1, maximum: 5, shared: true});
  let expected_pages = 1;
  for (let worker of workers) {
    assertEquals(memory.buffer.byteLength, expected_pages++ * kPageSize);
    let obj = {memory: memory, expected_size: expected_pages * kPageSize};
    worker.postMessage(obj);
    assertEquals("OK", worker.getMessage());
    assertEquals(memory.buffer.byteLength, expected_pages * kPageSize);
    worker.terminate();
  }
  assertEquals(memory.buffer.byteLength, expected_pages * kPageSize);
})();

// PostMessage of Multiple memories and grow
(function TestGrowSharedWithMultipleMemories() {
  print(arguments.callee.name);
  function workerCode(workerHelpers) {
    eval(workerHelpers);
    onmessage = function({data:obj}) {
      let expected_size = 0;
      let kPageSize = 0x10000;
      for (let memory of obj.memories) {
        assertIsWasmSharedMemory(memory);
        assertTrue(expected_size === memory.grow(2));
        expected_size+=2;
        assertIsWasmSharedMemory(memory);
        assertTrue(memory.buffer.byteLength === expected_size * kPageSize);
      }
      postMessage("OK");
    };
  }

  let worker = new Worker(workerCode,
                          {type: 'function', arguments: [workerHelpers]});
  let memories = [new WebAssembly.Memory({initial: 0, maximum: 2, shared: true}),
                  new WebAssembly.Memory({initial: 2, maximum: 10, shared: true}),
                  new WebAssembly.Memory({initial: 4, maximum: 12, shared: true})];
  let obj = {memories: memories};
  worker.postMessage(obj);
  assertEquals("OK", worker.getMessage());
  assertEquals(2 * kPageSize, memories[0].buffer.byteLength);
  assertEquals(4 * kPageSize, memories[1].buffer.byteLength);
  assertEquals(6 * kPageSize, memories[2].buffer.byteLength);
  worker.terminate();
})();

// SharedMemory Object shared between different instances
(function TestPostMessageJSAndWasmInterop() {
  print(arguments.callee.name);
  function workerCode(workerHelpers) {
    eval(workerHelpers);
    onmessage = function({data:obj}) {
      let kPageSize = 0x10000;
      assertIsWasmSharedMemory(obj.memory);
      let instance = new WebAssembly.Instance(
          obj.module, {m: {memory: obj.memory}});
      assertTrue(5 === obj.memory.grow(10));
      assertIsWasmSharedMemory(obj.memory);
      assertTrue(obj.memory.buffer.byteLength === 15 * kPageSize);
      assertTrue(15 === instance.exports.grow(5));
      assertIsWasmSharedMemory(obj.memory);
      assertTrue(obj.memory.buffer.byteLength === 20 * kPageSize);
      postMessage("OK");
    }
  }

  let worker = new Worker(workerCode,
                          {type: 'function', arguments: [workerHelpers]});
  let memory = new WebAssembly.Memory({initial: 5, maximum: 50, shared: true});
  var builder = new WasmModuleBuilder();
  builder.addImportedMemory("m", "memory", 5, 100, "shared");
  builder.addFunction("grow", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprMemoryGrow, kMemoryZero])
    .exportFunc();
  var module = new WebAssembly.Module(builder.toBuffer());
  let obj = {memory: memory, module: module};
  assertEquals(obj.memory.buffer.byteLength, 5 * kPageSize);
  worker.postMessage(obj);
  assertEquals("OK", worker.getMessage());
  worker.terminate();
  assertEquals(obj.memory.buffer.byteLength, 20 * kPageSize);
})();

(function TestConsecutiveJSAndWasmSharedGrow() {
  print(arguments.callee.name);
  function workerCode(workerHelpers) {
    eval(workerHelpers);
    onmessage = function({data:obj}) {
      let kPageSize = 0x10000;
      assertIsWasmSharedMemory(obj.memory);
      let instance = new WebAssembly.Instance(
          obj.module, {m: {memory: obj.memory}});
      assertTrue(5 === obj.memory.grow(10));
      assertIsWasmSharedMemory(obj.memory);
      assertTrue(obj.memory.buffer.byteLength === 15 * kPageSize);
      assertTrue(15 === instance.exports.grow(5));
      assertIsWasmSharedMemory(obj.memory);
      assertTrue(obj.memory.buffer.byteLength === 20 * kPageSize);
      postMessage("OK");
    }
  }

  let worker = new Worker(workerCode,
                          {type: 'function', arguments: [workerHelpers]});
  let memory = new WebAssembly.Memory({initial: 5, maximum: 50, shared: true});
  var builder = new WasmModuleBuilder();
  builder.addImportedMemory("m", "memory", 5, 100, "shared");
  builder.addFunction("grow", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprMemoryGrow, kMemoryZero])
    .exportFunc();
  var module = new WebAssembly.Module(builder.toBuffer());
  let obj = {memory: memory, module: module};
  assertEquals(obj.memory.buffer.byteLength, 5 * kPageSize);
  worker.postMessage(obj);
  assertEquals("OK", worker.getMessage());
  assertEquals(obj.memory.buffer.byteLength, 20 * kPageSize);
})();

(function TestConsecutiveWasmSharedGrow() {
  print(arguments.callee.name);
  function workerCode(workerHelpers) {
    eval(workerHelpers);
    onmessage = function({data:obj}) {
      let kPageSize = 0x10000;
      assertIsWasmSharedMemory(obj.memory);
      let instance = new WebAssembly.Instance(
          obj.module, {m: {memory: obj.memory}});
      assertTrue(5 === obj.memory.grow(10));
      assertIsWasmSharedMemory(obj.memory);
      assertTrue(obj.memory.buffer.byteLength === 15 * kPageSize);
      assertTrue(17 === instance.exports.grow_twice(2));
      assertIsWasmSharedMemory(obj.memory);
      assertTrue(obj.memory.buffer.byteLength === 19 * kPageSize);
      postMessage("OK");
    }
  }

  let worker = new Worker(workerCode,
                          {type: 'function', arguments: [workerHelpers]});
  let memory = new WebAssembly.Memory({initial: 5, maximum: 50, shared: true});
  var builder = new WasmModuleBuilder();
  builder.addImportedMemory("m", "memory", 5, 100, "shared");
  builder.addFunction("grow_twice", kSig_i_i)
    .addBody([kExprLocalGet, 0,
        kExprMemoryGrow, kMemoryZero,
        kExprDrop,
        kExprLocalGet, 0,
        kExprMemoryGrow, kMemoryZero])
    .exportFunc();
  var module = new WebAssembly.Module(builder.toBuffer());
  let obj = {memory: memory, module: module};
  assertEquals(obj.memory.buffer.byteLength, 5 * kPageSize);
  worker.postMessage(obj);
  assertEquals("OK", worker.getMessage());
  assertEquals(obj.memory.buffer.byteLength, 19 * kPageSize);
  let instance = new WebAssembly.Instance(module, {m: {memory: memory}});
  assertEquals(21, instance.exports.grow_twice(2));
  assertEquals(obj.memory.buffer.byteLength, 23 * kPageSize);
})();

(function TestConsecutiveSharedGrowAndMemorySize() {
  print(arguments.callee.name);
  function workerCode(workerHelpers) {
    eval(workerHelpers);
    onmessage = function({data:obj}) {
      let kPageSize = 0x10000;
      assertIsWasmSharedMemory(obj.memory);
      let instance = new WebAssembly.Instance(
          obj.module, {m: {memory: obj.memory}});
      assertTrue(5 === obj.memory.grow(10));
      assertTrue(15 === instance.exports.memory_size());
      assertIsWasmSharedMemory(obj.memory);
      assertTrue(obj.memory.buffer.byteLength === 15 * kPageSize);
      assertTrue(19 === instance.exports.grow_and_size(2));
      assertIsWasmSharedMemory(obj.memory);
      assertTrue(obj.memory.buffer.byteLength === 19 * kPageSize);
      postMessage("OK");
    }
  }

  let worker = new Worker(workerCode,
                          {type: 'function', arguments: [workerHelpers]});
  let memory = new WebAssembly.Memory({initial: 5, maximum: 50, shared: true});
  var builder = new WasmModuleBuilder();
  builder.addImportedMemory("m", "memory", 5, 100, "shared");
  builder.addFunction("grow_and_size", kSig_i_i)
    .addBody([kExprLocalGet, 0,
        kExprMemoryGrow, kMemoryZero,
        kExprDrop,
        kExprLocalGet, 0,
        kExprMemoryGrow, kMemoryZero,
        kExprDrop,
        kExprMemorySize, kMemoryZero])
    .exportFunc();
  builder.addFunction("memory_size", kSig_i_v)
    .addBody([kExprMemorySize, kMemoryZero])
    .exportFunc();
  var module = new WebAssembly.Module(builder.toBuffer());
  let obj = {memory: memory, module: module};
  assertEquals(obj.memory.buffer.byteLength, 5 * kPageSize);
  worker.postMessage(obj);
  assertEquals("OK", worker.getMessage());
  assertEquals(memory.buffer.byteLength, 19 * kPageSize);
  let instance = new WebAssembly.Instance(module, {m: {memory: memory}});
  assertEquals(23, instance.exports.grow_and_size(2));
  assertEquals(obj.memory.buffer.byteLength, 23 * kPageSize);
  assertEquals(23, memory.grow(2));
  assertEquals(25, instance.exports.memory_size());
})();

// Only spot checking here because currently the underlying buffer doesn't move.
// In the case that the underlying buffer does move, more comprehensive memory
// integrity checking and bounds checks testing are needed.
(function TestSpotCheckMemoryWithSharedGrow() {
  print(arguments.callee.name);
  function workerCode(workerHelpers) {
    eval(workerHelpers);
    onmessage = function({data:obj}) {
      let kPageSize = 0x10000;
      assertIsWasmSharedMemory(obj.memory);
      let instance = new WebAssembly.Instance(
          obj.module, {m: {memory: obj.memory}});
      assertTrue(5 === obj.memory.grow(10));
      assertIsWasmSharedMemory(obj.memory);
      assertTrue(obj.memory.buffer.byteLength === 15 * kPageSize);
      // Store again, and verify that the previous stores are still reflected.
      instance.exports.atomic_store(15 * kPageSize - 4, 0xACED);
      assertTrue(0xACED === instance.exports.atomic_load(0));
      assertTrue(0xACED === instance.exports.atomic_load(5 * kPageSize - 4));
      assertTrue(0xACED === instance.exports.atomic_load(15 * kPageSize - 4));
      assertTrue(15 === instance.exports.grow(2));
      assertIsWasmSharedMemory(obj.memory);
      assertTrue(obj.memory.buffer.byteLength === 17 * kPageSize);
      // Validate previous writes.
      instance.exports.atomic_store(17 * kPageSize - 4, 0xACED);
      assertTrue(0xACED === instance.exports.atomic_load(0));
      assertTrue(0xACED === instance.exports.atomic_load(5 * kPageSize - 4));
      assertTrue(0xACED === instance.exports.atomic_load(15 * kPageSize - 4));
      assertTrue(0xACED === instance.exports.atomic_load(17 * kPageSize - 4));
      postMessage("OK");
    }
  }

  let worker = new Worker(workerCode,
                          {type: 'function', arguments: [workerHelpers]});
  let memory = new WebAssembly.Memory({initial: 5, maximum: 50, shared: true});
  var builder = new WasmModuleBuilder();
  builder.addImportedMemory("m", "memory", 5, 100, "shared");
  builder.addFunction("grow", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprMemoryGrow, kMemoryZero])
    .exportFunc();
  builder.addFunction("atomic_load", kSig_i_i)
    .addBody([kExprLocalGet, 0, kAtomicPrefix, kExprI32AtomicLoad, 2, 0])
    .exportFunc();
  builder.addFunction("atomic_store", kSig_v_ii)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1,
      kAtomicPrefix, kExprI32AtomicStore, 2, 0])
    .exportFunc();
  var module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module, {m: {memory: memory}});
  // Store at first and last accessible 32 bit offset.
  instance.exports.atomic_store(0, 0xACED);
  instance.exports.atomic_store(5 * kPageSize - 4, 0xACED);
  // Verify that these were stored.
  assertEquals(0xACED, instance.exports.atomic_load(0));
  assertEquals(0xACED, instance.exports.atomic_load(5 * kPageSize - 4));
  // Verify bounds.
  // If an underlying platform uses traps for a bounds check,
  // kTrapUnalignedAccess will be thrown before kTrapMemOutOfBounds.
  // Otherwise, kTrapMemOutOfBounds will be first.
  assertTrapsOneOf([kTrapMemOutOfBounds, kTrapUnalignedAccess],
      () => instance.exports.atomic_load(5 * kPageSize - 3));
  let obj = {memory: memory, module: module};
  assertEquals(obj.memory.buffer.byteLength, 5 * kPageSize);
  // PostMessage
  worker.postMessage(obj);
  assertEquals("OK", worker.getMessage());
  assertEquals(memory.buffer.byteLength, 17 * kPageSize);
  assertEquals(17, instance.exports.grow(2));
  assertEquals(obj.memory.buffer.byteLength, 19 * kPageSize);
  // Validate previous writes, and check bounds.
  assertTrue(0xACED === instance.exports.atomic_load(0));
  assertTrue(0xACED === instance.exports.atomic_load(5 * kPageSize - 4));
  assertTrue(0xACED === instance.exports.atomic_load(15 * kPageSize - 4));
  assertTrue(0xACED === instance.exports.atomic_load(17 * kPageSize - 4));
  assertTrapsOneOf([kTrapMemOutOfBounds, kTrapUnalignedAccess],
      () => instance.exports.atomic_load(19 * kPageSize - 3));
  assertEquals(19, memory.grow(6));
  assertEquals(obj.memory.buffer.byteLength, 25 * kPageSize);
  assertTrapsOneOf([kTrapMemOutOfBounds, kTrapUnalignedAccess],
      () => instance.exports.atomic_load(25 * kPageSize - 3));
})();

(function TestMemoryBufferTypeAfterGrow() {
  const memory = new WebAssembly.Memory({
    "initial": 1, "maximum": 2, "shared": true });
  assertInstanceof(memory.buffer, SharedArrayBuffer);
  assertEquals(memory.grow(1), 1);
  assertInstanceof(memory.buffer, SharedArrayBuffer);
})();

(function TestSharedMemoryGrowByZero() {
  const memory = new WebAssembly.Memory({
    "initial": 1, "maximum": 2, "shared": true });
  assertEquals(memory.grow(0), 1);
})();

// Tests that a function receives the update of a shared memory's size if a
// loop's stack guard gets invoked. This is not strictly required by spec, but
// we implement it as an optimization.
(function TestStackGuardUpdatesMemorySize() {
  print(arguments.callee.name);

  let initial_size = 1;
  let final_size = 2;

  let memory = new WebAssembly.Memory({initial: 1, maximum: 5, shared: true});

  let sync_index = 64;
  let sync_value = 42;

  let builder = new WasmModuleBuilder();
  builder.addImportedMemory("mod", "mem", 1, 5, true);
  // int x;
  // while (true) {
  //   memory[sync_index] = sync_value;
  //   x = memory_size();
  //   if (x != 1) break;
  // }
  // return x;
  builder.addFunction("main", kSig_i_v)
    .addLocals(kWasmI32, 1)
    .addBody([
      kExprLoop, kWasmVoid,
        ...wasmI32Const(sync_index),
        ...wasmI32Const(sync_value),
        kAtomicPrefix, kExprI32AtomicStore, 2, 0,
        kExprMemorySize, 0, kExprLocalTee, 0,
        kExprI32Const, initial_size,
        kExprI32Eq,
        kExprBrIf, 0,
      kExprEnd,
      kExprLocalGet, 0])
    .exportFunc();

  builder.addFunction("setter", kSig_v_ii)
      .addBody([kExprLocalGet, 0, kExprLocalGet, 1,
                kAtomicPrefix, kExprI32AtomicStore, 2, 0])
      .exportFunc();

  builder.addFunction("getter", kSig_i_i)
      .addBody([kExprLocalGet, 0, kAtomicPrefix, kExprI32AtomicLoad, 2, 0])
      .exportFunc();

  let module = new WebAssembly.Module(builder.toBuffer());

  function workerCode() {
    onmessage = function({data:obj}) {
      let instance = new WebAssembly.Instance(
          obj.module, {mod: {mem: obj.memory}});
      let res = instance.exports.main();
      postMessage(res);
    }
  }

  let worker = new Worker(workerCode,
                          {type: 'function', arguments: []});
  worker.postMessage({module: module, memory: memory});

  let instance = new WebAssembly.Instance(module, {mod: {mem: memory}});

  // Make sure the worker thread has entered the loop.
  while (instance.exports.getter(sync_index) != sync_value) {}

  memory.grow(final_size - initial_size);

  assertEquals(final_size, worker.getMessage());
})();
                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/wasm/huge-memory.js                                                0000664 0000000 0000000 00000004262 14746647661 0022264 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-max-mem-pages=49152
// Save some memory on Linux; other platforms ignore this flag.
// Flags: --multi-mapped-mock-allocator

// This test makes sure things don't break once we support >2GB wasm memories.
d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function testHugeMemory() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();

  const num_pages = 49152;  // 3GB

  builder.addMemory(num_pages, num_pages);
  builder.addFunction("geti", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI32Mul,
      kExprI32LoadMem, 0, 0,
    ])
    .exportFunc();

  var module = builder.instantiate();
  const geti = module.exports.geti;

  print("In bounds");
  assertEquals(0, geti(2500, 1 << 20));
  print("Out of bounds");
  assertTraps(kTrapMemOutOfBounds, () => geti(3500, 1 << 20));
})();

(function testHugeMemoryConstInBounds() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();

  const num_pages = 49152;  // 3GB

  builder.addMemory(num_pages, num_pages);
  builder.addFunction("geti", kSig_i_v)
    .addBody([
      kExprI32Const, 0x80, 0x80, 0x80, 0x80, 0x7A, // 0xA0000000, 2.5GB
      kExprI32LoadMem, 0, 0,
    ])
    .exportFunc();

  var module = builder.instantiate();
  const geti = module.exports.geti;

  print("In bounds");
  assertEquals(0, geti());
})();

(function testHugeMemoryConstOutOfBounds() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();

  const num_pages = 49152;  // 3GB

  builder.addMemory(num_pages, num_pages);
  builder.addFunction("geti", kSig_i_v)
    .addBody([
      kExprI32Const, 0x80, 0x80, 0x80, 0x80, 0x7E, // 0xE0000000, 3.5GB
      kExprI32LoadMem, 0, 0,
    ])
    .exportFunc();

  var module = builder.instantiate();
  const geti = module.exports.geti;

  print("Out of bounds");
  assertTraps(kTrapMemOutOfBounds, geti);
})();

(function testGrowHugeMemory() {
  print(arguments.callee.name);

  let mem = new WebAssembly.Memory({initial: 1});
  mem.grow(49151);
})();
                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/wasm/huge-typedarray.js                                            0000664 0000000 0000000 00000001551 14746647661 0023136 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-max-mem-pages=65536

// Currently, the only way to create a huge TypedArray is via a
// WebAssembly Memory object.

const kNumPages = 65536;
const kWasmPageSize = 65536;
const kBytes = kNumPages * kWasmPageSize;
const kArrayLength = kBytes - 1;
assertEquals(2 ** 32, kBytes);
assertEquals(0xFFFFFFFF, kArrayLength);

var mem = new WebAssembly.Memory({ initial: kNumPages });
var buffer = mem.buffer;
var array = new Uint8Array(buffer, 0, kArrayLength);

assertEquals(kBytes, buffer.byteLength);
assertEquals(kArrayLength, array.length);
assertEquals(undefined, array[-1]);
assertEquals(0, array[0]);
assertEquals(0, array[kArrayLength - 1]);
assertEquals(undefined, array[kArrayLength]);
                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/wasm/i31ref.js                                                     0000664 0000000 0000000 00000013257 14746647661 0021123 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function I31RefBasic() {
  print(arguments.callee.name);

  var builder = new WasmModuleBuilder();
  builder.addFunction("signed", kSig_i_i)
    .addLocals(wasmRefType(kWasmI31Ref), 1)
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprRefI31, kExprLocalTee, 1,
              kGCPrefix, kExprI31GetS])
    .exportFunc();
  builder.addFunction("unsigned", kSig_i_i)
    .addLocals(wasmRefType(kWasmI31Ref), 1)
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprRefI31, kExprLocalTee, 1,
              kGCPrefix, kExprI31GetU])
    .exportFunc();

  let instance = builder.instantiate();

  assertEquals(123, instance.exports.signed(123));
  assertEquals(123, instance.exports.unsigned(123));
  // Truncation:
  assertEquals(0x1234, instance.exports.signed(0x80001234));
  assertEquals(0x1234, instance.exports.unsigned(0x80001234));
  // Sign/zero extention:
  assertEquals(-1, instance.exports.signed(0x7fffffff));
  assertEquals(0x7fffffff, instance.exports.unsigned(0x7fffffff));
})();

(function I31RefNullable() {
  print(arguments.callee.name);

  var builder = new WasmModuleBuilder();
  builder.addFunction("i31_null", kSig_i_i)
    .addLocals(wasmRefNullType(kWasmI31Ref), 1)
    .addBody([
        kExprLocalGet, 0,
        kExprIf, kWasmVoid,
          kExprRefNull, kI31RefCode, kExprLocalSet, 1,
        kExprElse,
          ...wasmI32Const(42), kGCPrefix, kExprRefI31, kExprLocalSet, 1,
        kExprEnd,
        kExprLocalGet, 1, kGCPrefix, kExprI31GetS])
    .exportFunc();

  let instance = builder.instantiate();

  assertEquals(42, instance.exports.i31_null(0));
  assertTraps(kTrapNullDereference, () => instance.exports.i31_null(1));
})();

(function I31RefJS() {
  print(arguments.callee.name);

  var builder = new WasmModuleBuilder();
  builder.addFunction("roundtrip", makeSig([kWasmExternRef], [kWasmExternRef]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprAnyConvertExtern,
              kGCPrefix, kExprExternConvertAny])
    .exportFunc();
  builder.addFunction("signed", makeSig([kWasmExternRef], [kWasmI32]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprAnyConvertExtern,
              kGCPrefix, kExprRefCast, kI31RefCode, kGCPrefix, kExprI31GetS])
    .exportFunc();
  builder.addFunction("unsigned", makeSig([kWasmExternRef], [kWasmI32]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprAnyConvertExtern,
              kGCPrefix, kExprRefCast, kI31RefCode, kGCPrefix, kExprI31GetU])
    .exportFunc();
  builder.addFunction("new", makeSig([kWasmI32], [kWasmExternRef]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprRefI31,
              kGCPrefix, kExprExternConvertAny])
    .exportFunc();

  let instance = builder.instantiate();

  assertEquals(0, instance.exports.roundtrip(0));
  assertEquals(0, instance.exports.signed(0));
  assertEquals(0, instance.exports.unsigned(0));
  assertEquals(0, instance.exports.new(0));

  assertEquals(123, instance.exports.roundtrip(123));
  assertEquals(123, instance.exports.signed(123));
  assertEquals(123, instance.exports.unsigned(123));
  assertEquals(123, instance.exports.new(123));

  // Max value.
  assertEquals(0x3fffffff, instance.exports.roundtrip(0x3fffffff));
  assertEquals(0x3fffffff, instance.exports.signed(0x3fffffff));
  assertEquals(0x3fffffff, instance.exports.unsigned(0x3fffffff));
  assertEquals(0x3fffffff, instance.exports.new(0x3fffffff));

  // Double number.
  assertEquals(1234.567, instance.exports.roundtrip(1234.567));
  assertTraps(kTrapIllegalCast, () => instance.exports.signed(1234.567));
  assertTraps(kTrapIllegalCast, () => instance.exports.unsigned(1234.567));

  // Out-of-bounds positive integer.
  assertEquals(0x40000000, instance.exports.roundtrip(0x40000000));
  assertTraps(kTrapIllegalCast, () => instance.exports.signed(0x40000000));
  assertTraps(kTrapIllegalCast, () => instance.exports.unsigned(0x40000000));
  assertEquals(-0x40000000, instance.exports.new(0x40000000));

  // Out-of-bounds negative integer.
  assertEquals(-0x40000001, instance.exports.roundtrip(-0x40000001));
  assertTraps(kTrapIllegalCast, () => instance.exports.signed(-0x40000001));
  assertTraps(kTrapIllegalCast, () => instance.exports.unsigned(-0x40000001));
  assertEquals(0x3fffffff, instance.exports.new(-0x40000001));

  // Sign/zero extention.
  assertEquals(-2, instance.exports.roundtrip(-2));
  assertEquals(-2, instance.exports.signed(-2));
  assertEquals(0x7ffffffe, instance.exports.unsigned(-2));
  assertEquals(-2, instance.exports.new(-2));

  // Min value.
  assertEquals(-0x40000000, instance.exports.roundtrip(-0x40000000));
  assertEquals(-0x40000000, instance.exports.signed(-0x40000000));
  assertEquals(0x40000000, instance.exports.unsigned(-0x40000000));
  assertEquals(-0x40000000, instance.exports.new(-0x40000000));

  assertEquals(NaN, instance.exports.roundtrip(NaN));
  assertTraps(kTrapIllegalCast, () => instance.exports.signed(NaN));
  assertTraps(kTrapIllegalCast, () => instance.exports.unsigned(NaN));

  assertEquals(-0, instance.exports.roundtrip(-0));
  assertTraps(kTrapIllegalCast, () => instance.exports.signed(-0));
  assertTraps(kTrapIllegalCast, () => instance.exports.unsigned(-0));

  assertEquals(Infinity, instance.exports.roundtrip(Infinity));
  assertTraps(kTrapIllegalCast, () => instance.exports.signed(Infinity));
  assertTraps(kTrapIllegalCast, () => instance.exports.unsigned(Infinity));

  assertEquals(-Infinity, instance.exports.roundtrip(-Infinity));
  assertTraps(kTrapIllegalCast, () => instance.exports.signed(-Infinity));
  assertTraps(kTrapIllegalCast, () => instance.exports.unsigned(-Infinity));
})();
                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/wasm/import-function.js                                            0000664 0000000 0000000 00000030502 14746647661 0023157 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function testCallImport(func, check) {
  var builder = new WasmModuleBuilder();

  var sig_index = builder.addType(kSig_i_dd);
  builder.addImport("q", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,            // --
      kExprLocalGet, 1,            // --
      kExprCallFunction, 0])         // --
    .exportAs("main");

  var main = builder.instantiate({q: {func: func}}).exports.main;

  for (var i = 0; i < 100000; i += 10003) {
    var a = 22.5 + i, b = 10.5 + i;
    var r = main(a, b);
    check(r, a, b);
  }
}

var global = (function() { return this; })();
var params = [-99, -99, -99, -99];
var was_called = false;
var length = -1;

function FOREIGN_SUB(a, b) {
  print("FOREIGN_SUB(" + a + ", " + b + ")");
  was_called = true;
  params[0] = this;
  params[1] = a;
  params[2] = b;
  return (a - b) | 0;
}

function check_FOREIGN_SUB(r, a, b) {
    assertEquals(a - b | 0, r);
    assertTrue(was_called);
    assertEquals(global, params[0]);  // sloppy mode
    assertEquals(a, params[1]);
    assertEquals(b, params[2]);
    was_called = false;
}

testCallImport(FOREIGN_SUB, check_FOREIGN_SUB);


function FOREIGN_ABCD(a, b, c, d) {
  print("FOREIGN_ABCD(" + a + ", " + b + ", " + c + ", " + d + ")");
  was_called = true;
  params[0] = this;
  params[1] = a;
  params[2] = b;
  params[3] = c;
  params[4] = d;
  return (a * b * 6) | 0;
}

function check_FOREIGN_ABCD(r, a, b) {
    assertEquals((a * b * 6) | 0, r);
    assertTrue(was_called);
    assertEquals(global, params[0]);  // sloppy mode.
    assertEquals(a, params[1]);
    assertEquals(b, params[2]);
    assertEquals(undefined, params[3]);
    assertEquals(undefined, params[4]);
    was_called = false;
}

testCallImport(FOREIGN_ABCD, check_FOREIGN_ABCD);

function FOREIGN_ARGUMENTS0() {
  print("FOREIGN_ARGUMENTS0");
  was_called = true;
  length = arguments.length;
  for (var i = 0; i < arguments.length; i++) {
    params[i] = arguments[i];
  }
  return (arguments[0] * arguments[1] * 7) | 0;
}

function FOREIGN_ARGUMENTS1(a) {
  print("FOREIGN_ARGUMENTS1", a);
  was_called = true;
  length = arguments.length;
  for (var i = 0; i < arguments.length; i++) {
    params[i] = arguments[i];
  }
  return (arguments[0] * arguments[1] * 7) | 0;
}

function FOREIGN_ARGUMENTS2(a, b) {
  print("FOREIGN_ARGUMENTS2", a, b);
  was_called = true;
  length = arguments.length;
  for (var i = 0; i < arguments.length; i++) {
    params[i] = arguments[i];
  }
  return (a * b * 7) | 0;
}

function FOREIGN_ARGUMENTS3(a, b, c) {
  print("FOREIGN_ARGUMENTS3", a, b, c);
  was_called = true;
  length = arguments.length;
  for (var i = 0; i < arguments.length; i++) {
    params[i] = arguments[i];
  }
  return (a * b * 7) | 0;
}

function FOREIGN_ARGUMENTS4(a, b, c, d) {
  print("FOREIGN_ARGUMENTS4", a, b, c, d);
  was_called = true;
  length = arguments.length;
  for (var i = 0; i < arguments.length; i++) {
    params[i] = arguments[i];
  }
  return (a * b * 7) | 0;
}

function check_FOREIGN_ARGUMENTS(r, a, b) {
  assertEquals((a * b * 7) | 0, r);
  assertTrue(was_called);
  assertEquals(2, length);
  assertEquals(a, params[0]);
  assertEquals(b, params[1]);
  was_called = false;
}

// Check a bunch of uses of the arguments object.
testCallImport(FOREIGN_ARGUMENTS0, check_FOREIGN_ARGUMENTS);
testCallImport(FOREIGN_ARGUMENTS1, check_FOREIGN_ARGUMENTS);
testCallImport(FOREIGN_ARGUMENTS2, check_FOREIGN_ARGUMENTS);
testCallImport(FOREIGN_ARGUMENTS3, check_FOREIGN_ARGUMENTS);
testCallImport(FOREIGN_ARGUMENTS4, check_FOREIGN_ARGUMENTS);

function returnValue(val) {
  return function(a, b) {
    print("RETURN_VALUE ", val);
    return val;
  }
}


function checkReturn(expected) {
  return function(r, a, b) { assertEquals(expected, r); }
}

// Check that returning weird values doesn't crash
testCallImport(returnValue(undefined), checkReturn(0));
testCallImport(returnValue(null), checkReturn(0));
testCallImport(returnValue("0"), checkReturn(0));
testCallImport(returnValue("-77"), checkReturn(-77));

var objWithValueOf = {valueOf: function() { return 198; }}

testCallImport(returnValue(objWithValueOf), checkReturn(198));


function testCallBinopVoid(type, func, check) {
  var passed_length = -1;
  var passed_a = -1;
  var passed_b = -1;
  var args_a = -1;
  var args_b = -1;

  var ffi = {q: {func: function(a, b) {
    passed_length = arguments.length;
    passed_a = a;
    passed_b = b;
    args_a = arguments[0];
    args_b = arguments[1];
  }}};

  var builder = new WasmModuleBuilder();

  builder.addImport("q", "func", makeSig_v_xx(type));
  builder.addFunction("main", makeSig_r_xx(kWasmI32, type))
    .addBody([
      kExprLocalGet, 0,           // --
      kExprLocalGet, 1,           // --
      kExprCallFunction, 0,       // --
      kExprI32Const, 39,          // --
    ])
    .exportFunc("main");

  var main = builder.instantiate(ffi).exports.main;

  print("testCallBinopVoid", type);

  for (var i = 0; i < 100000; i += 10003.1) {
    var a = 22.5 + i, b = 10.5 + i;
    var r = main(a, b);
    assertEquals(39, r);
    assertEquals(2, passed_length);
    var expected_a, expected_b;
    switch (type) {
      case kWasmI32: {
        expected_a = a | 0;
        expected_b = b | 0;
        break;
      }
      case kWasmF32: {
        expected_a = Math.fround(a);
        expected_b = Math.fround(b);
        break;
      }
      case kWasmF64: {
        expected_a = a;
        expected_b = b;
        break;
      }
    }

    assertEquals(expected_a, args_a);
    assertEquals(expected_b, args_b);
    assertEquals(expected_a, passed_a);
    assertEquals(expected_b, passed_b);
  }
}


testCallBinopVoid(kWasmI32);
// TODO testCallBinopVoid(kWasmI64);
testCallBinopVoid(kWasmF32);
testCallBinopVoid(kWasmF64);



function testCallPrint() {
  var builder = new WasmModuleBuilder();
  builder.addImport("q", "print", makeSig_v_x(kWasmI32));
  builder.addImport("q", "print", makeSig_r_x(kWasmF64, kWasmF64));
  builder.addFunction("main", makeSig_r_x(kWasmF64, kWasmF64))
    .addBody([
      kExprI32Const, 27,     // --
      kExprCallFunction, 0,  // --
      kExprLocalGet, 0,      // --
      kExprCallFunction, 1   // --
    ])
    .exportFunc();

  var main = builder.instantiate({q: {print: print}}).exports.main;

  for (var i = -9; i < 900; i += 16.125) {
    main(i);
  }
}

testCallPrint();
testCallPrint();


function testCallImport2(foo, bar, expected) {
  var builder = new WasmModuleBuilder();

  builder.addImport("q", "foo", kSig_i_v);
  builder.addImport("t", "bar", kSig_i_v);
  builder.addFunction("main", kSig_i_v)
    .addBody([
      kExprCallFunction, 0, // --
      kExprCallFunction, 1, // --
      kExprI32Add,                 // --
    ])                             // --
    .exportFunc();

  var main = builder.instantiate({q: {foo: foo}, t: {bar: bar}}).exports.main;
  assertEquals(expected, main());
}

testCallImport2(function() { return 33; }, function () { return 44; }, 77);


function testImportName(name) {
  var builder = new WasmModuleBuilder();
  builder.addImport("M", name, kSig_i_v);
  builder.addFunction("main", kSig_i_v)
    .addBody([
      kExprCallFunction, 0
    ])
    .exportFunc();

  let main = builder.instantiate({M: {[name]: () => 42}}).exports.main;
  assertEquals(42, main());
}

testImportName('bla');
testImportName('0');
testImportName('  a @#$2 324 ');
testImportName('');

(function testExportedImportsOnDifferentInstances() {
  print(arguments.callee.name);
  const exp = (function() {
    const builder = new WasmModuleBuilder();
    builder.addFunction('f11', kSig_i_v)
        .addBody([kExprI32Const, 11])
        .exportFunc();
    builder.addFunction('f17', kSig_i_v)
        .addBody([kExprI32Const, 17])
        .exportFunc();
    return builder.instantiate().exports;
  })();

  const builder = new WasmModuleBuilder();
  const imp_index = builder.addImport('q', 'imp', kSig_i_v);
  builder.addExport('exp', imp_index);

  const module = builder.toModule();
  const instance0 = new WebAssembly.Instance(module, {q: {imp: exp.f11}});
  const instance1 = new WebAssembly.Instance(module, {q: {imp: exp.f17}});
  const instance2 = new WebAssembly.Instance(module, {q: {imp: _ => 21}});
  const instance3 = new WebAssembly.Instance(module, {q: {imp: _ => 27}});

  assertEquals(11, instance0.exports.exp());
  assertEquals(17, instance1.exports.exp());
  assertEquals(21, instance2.exports.exp());
  assertEquals(27, instance3.exports.exp());
})();

(function testImportedStartFunctionOnDifferentInstances() {
  print(arguments.callee.name);
  var global = 0;
  const set_global = n => global = n;
  const exp = (function() {
    const builder = new WasmModuleBuilder();
    const imp_index = builder.addImport('q', 'imp', kSig_v_i);
    builder.addFunction('f11', kSig_v_v)
        .addBody([kExprI32Const, 11, kExprCallFunction, imp_index])
        .exportFunc();
    builder.addFunction('f17', kSig_v_v)
        .addBody([kExprI32Const, 17, kExprCallFunction, imp_index])
        .exportFunc();
    return builder.instantiate({q: {imp: set_global}}).exports;
  })();

  const builder = new WasmModuleBuilder();
  const imp_index = builder.addImport('q', 'imp', kSig_v_v);
  builder.addStart(imp_index);

  const module = builder.toModule();

  assertEquals(0, global);
  new WebAssembly.Instance(module, {q: {imp: exp.f11}});
  assertEquals(11, global);
  new WebAssembly.Instance(module, {q: {imp: exp.f17}});
  assertEquals(17, global);
  new WebAssembly.Instance(module, {q: {imp: _ => set_global(21)}});
  assertEquals(21, global);
  new WebAssembly.Instance(module, {q: {imp: _ => set_global(27)}});
  assertEquals(27, global);
})();

(function testImportedStartFunctionUsesRightInstance() {
  print(arguments.callee.name);
  var global = 0;
  const set_global = n => global = n;
  const exp = (function() {
    const builder = new WasmModuleBuilder();
    builder.addMemory(1, 1);
    builder.exportMemoryAs('mem');
    const imp_index = builder.addImport('q', 'imp', kSig_v_i);
    builder.addFunction('f', kSig_v_v)
        .addBody([kExprI32Const, 0, kExprI32Const, 11, kExprI32StoreMem8, 0, 0])
        .exportFunc();
    return builder.instantiate({q: {imp: set_global}}).exports;
  })();

  const builder = new WasmModuleBuilder();
  const imp_index = builder.addImport('q', 'imp', kSig_v_v);
  builder.addStart(imp_index);
  const module = builder.toModule();

  assertEquals(0, new Uint8Array(exp.mem.buffer)[0], 'memory initially 0');
  new WebAssembly.Instance(module, {q: {imp: exp.f}});
  assertEquals(11, new Uint8Array(exp.mem.buffer)[0], 'memory changed to 11');
})();

(function testImportWrapperWorksWithStrictAndSloppy() {
  function jsSloppyMatch(x) {
    assertSame(globalThis, this);
    return x - 4;
  }

  function jsStrictMatch(x) {
    "use strict";

    assertEquals(undefined, this);
    return x - 4;
  }

  function jsSloppyMismatch(x, y) {
    assertSame(globalThis, this);
    assertEquals(undefined, y);
    return x - 4;
  }

  function jsStrictMismatch(x, y) {
    "use strict";

    assertEquals(undefined, this);
    assertEquals(undefined, y);
    return x - 4;
  }

  const builder = new WasmModuleBuilder();
  const functionIndex = builder.addImport("imports", "jsFun", kSig_i_i);
  builder.addFunction('wasmFun', kSig_i_i)
    .addBody([
      kExprLocalGet, 0,
      kExprI32Const, 2,
      kExprI32Mul,
      kExprCallFunction, functionIndex
    ])
    .exportFunc();
  const module = builder.toModule();

  print("Running matching sloppy function");
  const instanceSloppyMatch = new WebAssembly.Instance(module, {imports: {jsFun: jsSloppyMatch}});
  assertEquals(42, instanceSloppyMatch.exports.wasmFun(23));

  print("Running matching strict function");
  const instanceStrictMatch = new WebAssembly.Instance(module, {imports: {jsFun: jsStrictMatch}});
  assertEquals(42, instanceStrictMatch.exports.wasmFun(23));

  print("Running mismatching sloppy function");
  const instanceSloppyMismatch = new WebAssembly.Instance(module, {imports: {jsFun: jsSloppyMismatch}});
  assertEquals(42, instanceSloppyMismatch.exports.wasmFun(23));

  print("Running mismatching strict function");
  const instanceStrictMismatch = new WebAssembly.Instance(module, {imports: {jsFun: jsStrictMismatch}});
  assertEquals(42, instanceStrictMismatch.exports.wasmFun(23));
})();
                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/wasm/import-memory.js                                              0000664 0000000 0000000 00000040412 14746647661 0022643 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// V8 internal memory size limit.
var kV8MaxPages = 65536;

(function TestOne() {
  print("TestOne");
  let memory = new WebAssembly.Memory({initial: 1});
  assertEquals(kPageSize, memory.buffer.byteLength);
  let i32 = new Int32Array(memory.buffer);
  let builder = new WasmModuleBuilder();
  builder.addImportedMemory("mod", "mine");
  builder.addFunction("main", kSig_i_v)
    .addBody([
      kExprI32Const, 0,
      kExprI32LoadMem, 0, 0])
    .exportAs("main");

  let main = builder.instantiate({mod: {mine: memory}}).exports.main;
  assertEquals(0, main());

  i32[0] = 993377;

  assertEquals(993377, main());
})();

(function TestIdentity() {
  print("TestIdentity");
  let memory = new WebAssembly.Memory({initial: 1});
  let i32 = new Int32Array(memory.buffer);
  let builder = new WasmModuleBuilder();
  builder.addImportedMemory("dad", "garg");
  builder.exportMemoryAs("daggle");

  let instance = builder.instantiate({dad: {garg: memory}});
  assertSame(memory, instance.exports.daggle);
})();

(function TestImportExport() {
  print("TestImportExport");
  var i1;
  {
    let builder = new WasmModuleBuilder();
    builder.addMemory(1, 1);
    builder.exportMemoryAs("exported_mem");
    builder.addFunction("foo", kSig_i_i)
      .addBody([
        kExprLocalGet, 0,
        kExprI32LoadMem, 0, 0])
      .exportAs("foo");
    i1 = builder.instantiate();
  }

  var i2;
  {
    let builder = new WasmModuleBuilder();
    builder.addImportedMemory("fil", "imported_mem");
    builder.addFunction("bar", kSig_i_i)
      .addBody([
        kExprLocalGet, 0,
        kExprI32LoadMem, 0, 0])
      .exportAs("bar");
    i2 = builder.instantiate({fil: {imported_mem: i1.exports.exported_mem}});
  }

  let i32 = new Int32Array(i1.exports.exported_mem.buffer);

  for (var i = 0; i < 1e11; i = i * 3 + 5) {
    for (var j = 0; j < 10; j++) {
      var val = i + 99077 + j;
      i32[j] = val;
      assertEquals(val | 0, i1.exports.foo(j * 4));
      assertEquals(val | 0, i2.exports.bar(j * 4));
    }
  }
})();

(function ValidateBoundsCheck() {
  print("ValidateBoundsCheck");
  let memory = new WebAssembly.Memory({initial: 1, maximum: 5});
  assertEquals(kPageSize, memory.buffer.byteLength);
  let i32 = new Int32Array(memory.buffer);
  let builder = new WasmModuleBuilder();
  builder.addImportedMemory("gaz", "mine");
  builder.addFunction("load", kSig_i_i)
      .addBody([kExprLocalGet, 0, kExprI32LoadMem, 0, 0])
      .exportFunc();
  builder.addFunction("store", kSig_i_ii)
      .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32StoreMem, 0, 0,
                kExprLocalGet, 1])
      .exportFunc();
  var offset;
  let instance = builder.instantiate({gaz: {mine: memory}});
  function load() { return instance.exports.load(offset); }
  function store(value) { return instance.exports.store(offset, value); }

  for (offset = 0; offset < kPageSize - 3; offset+=4) {
    store(offset);
  }
  for (offset = 0; offset < kPageSize - 3; offset+=4) {
    assertEquals(offset, load());
  }
  for (offset = kPageSize - 3; offset < kPageSize + 4; offset++) {
    assertTraps(kTrapMemOutOfBounds, load);
  }
})();

(function TestMemoryGrowMaxDesc() {
  print("MaximumDescriptor");
  let memory = new WebAssembly.Memory({initial: 1, maximum: 5});
  assertEquals(kPageSize, memory.buffer.byteLength);
  let i32 = new Int32Array(memory.buffer);
  let builder = new WasmModuleBuilder();
  builder.addImportedMemory("mine", "dog", 0, 20);
  builder.addFunction("load", kSig_i_i)
      .addBody([kExprLocalGet, 0, kExprI32LoadMem, 0, 0])
      .exportFunc();
  builder.addFunction("store", kSig_i_ii)
      .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32StoreMem, 0, 0,
                kExprLocalGet, 1])
      .exportFunc();
  var offset;
  let instance = builder.instantiate({mine: {dog: memory}});
  function load() { return instance.exports.load(offset); }
  function store(value) { return instance.exports.store(offset, value); }

  for (var i = 1; i < 5; i++) {
    for (offset = (i - 1) * kPageSize; offset < i * kPageSize - 3; offset+=4) {
      store(offset * 2);
    }
    assertEquals(i, memory.grow(1));
    assertEquals((i + 1) * kPageSize, memory.buffer.byteLength);
  }
  for (offset = 4 * kPageSize; offset < 5 * kPageSize - 3; offset+=4) {
    store(offset * 2);
  }
  for (offset = 0; offset < 5 * kPageSize - 3; offset+=4) {
    assertEquals(offset * 2, load());
  }
  for (offset = 5 * kPageSize; offset < 5 * kPageSize + 4; offset++) {
    assertThrows(load);
  }
  assertThrows(() => memory.grow(1));
})();

(function TestMemoryGrowZeroInitialMemory() {
  print("ZeroInitialMemory");
  let memory = new WebAssembly.Memory({initial: 0});
  assertEquals(0, memory.buffer.byteLength);
  let i32 = new Int32Array(memory.buffer);
  let builder = new WasmModuleBuilder();
  builder.addImportedMemory("mine", "fro");
  builder.addFunction("load", kSig_i_i)
      .addBody([kExprLocalGet, 0, kExprI32LoadMem, 0, 0])
      .exportFunc();
  builder.addFunction("store", kSig_i_ii)
      .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32StoreMem, 0, 0,
                kExprLocalGet, 1])
      .exportFunc();
  var offset;
  let instance = builder.instantiate({mine: {fro: memory}});
  function load() { return instance.exports.load(offset); }
  function store(value) { return instance.exports.store(offset, value); }

  for (var i = 1; i < 5; i++) {
    assertEquals(i - 1, memory.grow(1));
    assertEquals(i * kPageSize, memory.buffer.byteLength);
    for (offset = (i - 1) * kPageSize; offset < i * kPageSize - 3; offset++) {
      store(offset * 2);
    }
  }
  for (offset = 5 * kPageSize; offset < 5 * kPageSize + 4; offset++) {
    assertThrows(load);
  }
  assertThrows(() => memory.grow(kV8MaxPages - 3));
})();

(function ImportedMemoryBufferLength() {
  print("ImportedMemoryBufferLength");
  let memory = new WebAssembly.Memory({initial: 2, maximum: 10});
  assertEquals(2*kPageSize, memory.buffer.byteLength);
  let builder = new WasmModuleBuilder();
  builder.addFunction("grow", kSig_i_i)
      .addBody([kExprLocalGet, 0, kExprMemoryGrow, kMemoryZero])
      .exportFunc();
  builder.addImportedMemory("cat", "mine");
  let instance = builder.instantiate({cat: {mine: memory}});
  function grow(pages) { return instance.exports.grow(pages); }
  assertEquals(2, grow(3));
  assertEquals(5*kPageSize, memory.buffer.byteLength);
  assertEquals(5, grow(5));
  assertEquals(10*kPageSize, memory.buffer.byteLength);
  assertThrows(() => memory.grow(1));
})();

(function TestMemoryGrowExportedMaximum() {
  print("TestMemoryGrowExportedMaximum");
  let initial_size = 1, maximum_size = 10;
  var exp_instance;
  {
    let builder = new WasmModuleBuilder();
    builder.addMemory(initial_size, maximum_size);
    builder.exportMemoryAs("exported_mem");
    exp_instance = builder.instantiate();
  }
  var instance;
  {
    var builder = new WasmModuleBuilder();
    builder.addImportedMemory("fur", "imported_mem");
    builder.addFunction("mem_size", kSig_i_v)
      .addBody([kExprMemorySize, kMemoryZero])
      .exportFunc();
    builder.addFunction("grow", kSig_i_i)
      .addBody([kExprLocalGet, 0, kExprMemoryGrow, kMemoryZero])
      .exportFunc();
    instance = builder.instantiate({fur: {
      imported_mem: exp_instance.exports.exported_mem}});
  }
  for (var i = initial_size; i < maximum_size; i++) {
    assertEquals(i, instance.exports.grow(1));
    assertEquals((i+1), instance.exports.mem_size());
  }
  assertEquals(-1, instance.exports.grow(1));
})();

(function TestMemoryGrowWebAssemblyInstances() {
  print("TestMemoryGrowWebAssemblyInstances");
  let memory = new WebAssembly.Memory({initial: 1, maximum: 15});
  var builder = new WasmModuleBuilder();
  builder.addImportedMemory("lit", "imported_mem");
  builder.addFunction("mem_size", kSig_i_v)
    .addBody([kExprMemorySize, kMemoryZero])
    .exportAs("mem_size");
  builder.addFunction("grow", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprMemoryGrow, kMemoryZero])
    .exportFunc();
  var module = new WebAssembly.Module(builder.toBuffer());
  var instances = [];
  for (var i = 0; i < 6; i++) {
    instances.push(new WebAssembly.Instance(module, {lit: {imported_mem: memory}}));
  }
  function verify_mem_size(expected_pages) {
    assertEquals(expected_pages*kPageSize,
        memory.buffer.byteLength);
    for (var i = 0; i < 6; i++) {
      assertEquals(expected_pages, instances[i].exports.mem_size());
    }
  }

  // Verify initial memory size
  verify_mem_size(1);

  // Verify memory size with interleaving calls to Memory.grow,
  // MemoryGrow opcode.
  var current_mem_size = 1;
  for (var i = 0; i < 5; i++) {
    function grow(pages) { return instances[i].exports.grow(pages); }
    assertEquals(current_mem_size, memory.grow(1));
    verify_mem_size(++current_mem_size);
    assertEquals(current_mem_size, instances[i].exports.grow(1));
    verify_mem_size(++current_mem_size);
  }

  assertThrows(() => memory.grow(5));
})();

(function TestImportedMemoryGrowMultipleInstances() {
  print("TestImportMemoryMultipleInstances");
  let memory = new WebAssembly.Memory({initial: 5, maximum: 100});
  var builder = new WasmModuleBuilder();
  builder.addImportedMemory("nob", "imported_mem");
  builder.addFunction("mem_size", kSig_i_v)
    .addBody([kExprMemorySize, kMemoryZero])
    .exportFunc();
  builder.addFunction("grow", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprMemoryGrow, kMemoryZero])
    .exportFunc();
  var instances = [];
  for (var i = 0; i < 5; i++) {
    instances.push(builder.instantiate({nob: {imported_mem: memory}}));
  }
  function grow_instance_0(pages) { return instances[0].exports.grow(pages); }
  function grow_instance_1(pages) { return instances[1].exports.grow(pages); }
  function grow_instance_2(pages) { return instances[2].exports.grow(pages); }
  function grow_instance_3(pages) { return instances[3].exports.grow(pages); }
  function grow_instance_4(pages) { return instances[4].exports.grow(pages); }

  function verify_mem_size(expected_pages) {
    assertEquals(expected_pages*kPageSize, memory.buffer.byteLength);
    for (var i = 0; i < 5; i++) {
      assertEquals(expected_pages, instances[i].exports.mem_size());
    }
  }

  // Verify initial memory size
  verify_mem_size(5);

  // Grow instance memory and buffer memory out of order and verify memory is
  // updated correctly.
  assertEquals(5, grow_instance_0(7));
  verify_mem_size(12);

  assertEquals(12, memory.grow(4));
  verify_mem_size(16);

  assertEquals(16, grow_instance_4(1));
  verify_mem_size(17);

  assertEquals(17, grow_instance_1(6));
  verify_mem_size(23);

  assertEquals(23, grow_instance_3(2));
  verify_mem_size(25);

  assertEquals(25, memory.grow(10));
  verify_mem_size(35);

  assertEquals(35, grow_instance_2(15));
  verify_mem_size(50);
  assertThrows(() => memory.grow(51));
})();

(function TestExportImportedMemoryGrowMultipleInstances() {
  print("TestExportImportedMemoryGrowMultipleInstances");
  var instance;
  {
    let builder = new WasmModuleBuilder();
    builder.addMemory(1, 11);
    builder.exportMemoryAs("exported_mem");
    builder.addFunction("mem_size", kSig_i_v)
      .addBody([kExprMemorySize, kMemoryZero])
      .exportFunc();
    instance = builder.instantiate();
  }
  var builder = new WasmModuleBuilder();
  builder.addImportedMemory("doo", "imported_mem");
  builder.addFunction("mem_size", kSig_i_v)
    .addBody([kExprMemorySize, kMemoryZero])
    .exportFunc();
  builder.addFunction("grow", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprMemoryGrow, kMemoryZero])
    .exportFunc();
  var instances = [];
  for (var i = 0; i < 10; i++) {
    instances.push(builder.instantiate({
      doo: {imported_mem: instance.exports.exported_mem}}));
  }
  function verify_mem_size(expected_pages) {
    for (var i = 0; i < 10; i++) {
      assertEquals(expected_pages, instances[i].exports.mem_size());
    }
  }
  var current_mem_size = 1;
  for (var i = 0; i < 10; i++) {
    function grow(pages) { return instances[i].exports.grow(pages); }
    assertEquals(current_mem_size, instances[i].exports.grow(1));
    verify_mem_size(++current_mem_size);
  }
  for (var i = 0; i < 10; i++) {
    assertEquals(-1, instances[i].exports.grow(1));
    verify_mem_size(current_mem_size);
  }
})();

(function TestExportImportedMemoryGrowPastV8Maximum() {
  // The spec maximum is higher than the internal V8 maximum. This test only
  // checks that grow_memory does not grow past the internally defined maximum
  // to reflect the current implementation even when the memory is exported.
  print("TestExportImportedMemoryGrowPastV8Maximum");
  var instance_1, instance_2;
  {
    let builder = new WasmModuleBuilder();
    builder.addMemory(1, kSpecMaxPages);
    builder.exportMemoryAs("exported_mem");
    builder.addFunction("grow", kSig_i_i)
      .addBody([kExprLocalGet, 0, kExprMemoryGrow, kMemoryZero])
      .exportFunc();
    instance_1 = builder.instantiate();
  }
  {
    let builder = new WasmModuleBuilder();
    builder.addImportedMemory("doo", "imported_mem");
    builder.addFunction("grow", kSig_i_i)
      .addBody([kExprLocalGet, 0, kExprMemoryGrow, kMemoryZero])
      .exportFunc();
    instance_2 = builder.instantiate({
      doo: {imported_mem: instance_1.exports.exported_mem}});
  }
  assertEquals(1, instance_1.exports.grow(20));
  assertEquals(21, instance_2.exports.grow(20));
  assertEquals(-1, instance_1.exports.grow(kV8MaxPages - 40));
  assertEquals(-1, instance_2.exports.grow(kV8MaxPages - 40));
})();

(function TestExportGrow() {
  print("TestExportGrow");
  let builder = new WasmModuleBuilder();
  builder.addMemory(1, 5);
  builder.exportMemoryAs("exported_mem");
  builder.addFunction("mem_size", kSig_i_v)
    .addBody([kExprMemorySize, kMemoryZero])
    .exportFunc();
  builder.addFunction("grow", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprMemoryGrow, kMemoryZero])
    .exportFunc();
  instance = builder.instantiate();
  assertEquals(kPageSize, instance.exports.exported_mem.buffer.byteLength);
  assertEquals(1, instance.exports.grow(2));
  assertEquals(3, instance.exports.mem_size());
  assertEquals(3*kPageSize, instance.exports.exported_mem.buffer.byteLength);
})();

(function TestImportTooLarge() {
  print("TestImportTooLarge");
  let builder = new WasmModuleBuilder();
  builder.addImportedMemory("m", "m", 1, 2);

  // initial size is too large
  assertThrows(() => builder.instantiate({m: {m: new WebAssembly.Memory({initial: 3, maximum: 3})}}));

  // maximum size is too large
  assertThrows(() => builder.instantiate({m: {m: new WebAssembly.Memory({initial: 1, maximum: 4})}}));

  // no maximum
  assertThrows(() => builder.instantiate({m: {m: new WebAssembly.Memory({initial: 1})}}));
})();

(function TestMemoryGrowDetachBuffer() {
  print("TestMemoryGrowDetachBuffer");
  let memory = new WebAssembly.Memory({initial: 1, maximum: 5});
  var builder = new WasmModuleBuilder();
  builder.addImportedMemory("m", "imported_mem");
  let instance = builder.instantiate({m: {imported_mem: memory}});
  let buffer = memory.buffer;
  assertEquals(kPageSize, buffer.byteLength);
  assertEquals(1, memory.grow(2));
  assertTrue(buffer !== memory.buffer);
  assertEquals(0, buffer.byteLength);
  assertEquals(3*kPageSize, memory.buffer.byteLength);
})();

(function TestInitialMemorySharedModule() {
  print("TestInitialMemorySharedModule");
  var builder = new WasmModuleBuilder();
  builder.addImportedMemory("m", "imported_mem");
  builder.addFunction('f', kSig_i_v)
      .addBody([
        kExprI32Const, 0x1d,                       // --
        kExprI32Const, 0x20,                       // --
        kExprI32StoreMem, 0, 0,  // --
        kExprI32Const, 0x1d,                       // --
        kExprI32LoadMem, 0, 0,  // --
      ])
      .exportFunc();

  // First instance load/store success
  var module = new WebAssembly.Module(builder.toBuffer());
  let memory1= new WebAssembly.Memory({initial: 1, maximum: 20});
  let instance1  = new WebAssembly.Instance(module, {m: {imported_mem: memory1}});
  assertEquals(0x20, instance1.exports.f());

  // Second instance should trap as it has no initial memory
  let memory2= new WebAssembly.Memory({initial: 0, maximum: 2});
  let instance2  = new WebAssembly.Instance(module, {m: {imported_mem: memory2}});
  assertTraps(kTrapMemOutOfBounds, () => instance2.exports.f());
})();
                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/wasm/import-mutable-global.js                                      0000664 0000000 0000000 00000014665 14746647661 0024235 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-gc

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestBasic() {
  let global = new WebAssembly.Global({value: 'i32'}, 1);
  let builder = new WasmModuleBuilder();
  builder.addImportedGlobal("mod", "g", kWasmI32);
  builder.addFunction("main", kSig_i_v)
    .addBody([kExprGlobalGet, 0])
    .exportAs("main");

  let main = builder.instantiate({mod: {g: global}}).exports.main;
  assertEquals(1, main());
})();

(function TestTypeMismatch() {
  let global = new WebAssembly.Global({value: 'f32'}, 1);
  let builder = new WasmModuleBuilder();
  builder.addImportedGlobal("mod", "g", kWasmI32);

  assertThrows(() => builder.instantiate({mod: {g: global}}));
})();

(function TestMutableMismatch() {
  let global = new WebAssembly.Global({value: 'f64'}, 1);
  let builder = new WasmModuleBuilder();
  builder.addImportedGlobal("mod", "g", kWasmF64, true);

  assertThrows(() => builder.instantiate({mod: {g: global}}));

  global = new WebAssembly.Global({value: 'i32', mutable: true}, 1);
  builder = new WasmModuleBuilder();
  builder.addImportedGlobal("mod", "g", kWasmI32);

  assertThrows(() => builder.instantiate({mod: {g: global}}));
})();

(function TestImportMutableAsNumber() {
  let builder = new WasmModuleBuilder();
  builder.addImportedGlobal("mod", "g", kWasmF32, true);
  assertThrows(() => builder.instantiate({mod: {g: 1234}}));
})();

(function TestImportI64AsNumber() {
  let builder = new WasmModuleBuilder();
  builder.addImportedGlobal("mod", "g", kWasmI64);
  assertThrows(() => builder.instantiate({mod: {g: 1234}}));
})();

function addGlobalGetterAndSetter(builder, index, name, type) {
  builder.addFunction('get' + name, makeSig([], [type]))
      .addBody([kExprGlobalGet, index])
      .exportFunc();
  builder.addFunction('set' + name, makeSig([type], []))
      .addBody([kExprLocalGet, 0, kExprGlobalSet, index])
      .exportFunc();
}

(function TestImportMutableGlobal() {
  const globalDesc = [
    {name: 'i32', type: kWasmI32},
    {name: 'f32', type: kWasmF32},
    {name: 'f64', type: kWasmF64},
  ];

  let globals = {};
  let builder = new WasmModuleBuilder();

  for (let [index, {name, type}] of globalDesc.entries()) {
    globals[name] = new WebAssembly.Global({value: name, mutable: true});
    builder.addImportedGlobal("mod", name, type, true);
    addGlobalGetterAndSetter(builder, index, name, type);
  }

  let inst = builder.instantiate(
      {mod: {i32: globals.i32, f32: globals.f32, f64: globals.f64}});

  for (let type of ['i32', 'f32', 'f64']) {
    let global = globals[type];
    let get = inst.exports['get' + type];
    let set = inst.exports['set' + type];

    assertEquals(get(), global.value, type);
    set(1234567);
    assertEquals(1234567, global.value, type);
    global.value = 7654321;
    assertEquals(7654321, get(), type);
  }
})();

(function TestImportExportedMutableGlobal() {
  const globalDesc = [
    {name: 'i32', type: kWasmI32},
    {name: 'f32', type: kWasmF32},
    {name: 'f64', type: kWasmF64},
  ];

  let builder1 = new WasmModuleBuilder();
  let builder2 = new WasmModuleBuilder();
  for (let [index, {name, type}] of globalDesc.entries()) {
    builder1.addGlobal(type, true, false).exportAs(name);
    addGlobalGetterAndSetter(builder1, index, name, type);

    builder2.addImportedGlobal("mod", name, type, true);
    addGlobalGetterAndSetter(builder2, index, name, type);
  }
  let inst1 = builder1.instantiate();
  let inst2 = builder2.instantiate({
    mod: {
      i32: inst1.exports.i32,
      f32: inst1.exports.f32,
      f64: inst1.exports.f64
    }
  });

  for (let type of ['i32', 'f32', 'f64']) {
    let get1 = inst1.exports['get' + type];
    let get2 = inst2.exports['get' + type];
    let set1 = inst1.exports['set' + type];
    let set2 = inst2.exports['set' + type];

    assertEquals(get1(), get2(), type);
    set1(1234567);
    assertEquals(1234567, get2(), type);
    set2(7654321);
    assertEquals(7654321, get1(), type);
  }
})();

(function TestImportExportedMutableGlobalI64() {
  function addGettersAndSetters(builder) {
    const index = 0;
    builder.addFunction('geti64_hi', makeSig([], [kWasmI32]))
      .addBody([
        kExprGlobalGet, index,
        kExprI64Const, 32, kExprI64ShrU,
        kExprI32ConvertI64])
      .exportFunc();
    builder.addFunction('geti64_lo', makeSig([], [kWasmI32]))
      .addBody([kExprGlobalGet, index, kExprI32ConvertI64])
      .exportFunc();
    builder.addFunction("seti64", makeSig([kWasmI32, kWasmI32], []))
      .addBody([
        kExprLocalGet, 1, kExprI64UConvertI32,
        kExprLocalGet, 0, kExprI64UConvertI32,
        kExprI64Const, 32, kExprI64Shl,
        kExprI64Ior,
        kExprGlobalSet, index])
      .exportFunc();
  };

  let builder = new WasmModuleBuilder();
  builder.addGlobal(kWasmI64, true, false).exportAs('i64');
  addGettersAndSetters(builder);
  let inst1 = builder.instantiate();

  builder = new WasmModuleBuilder();
  builder.addImportedGlobal("mod", 'i64', kWasmI64, true);
  addGettersAndSetters(builder);
  let inst2 = builder.instantiate({ mod: { i64: inst1.exports.i64 } });

  assertEquals(inst1.exports.geti64_lo(), inst2.exports.geti64_lo());
  assertEquals(inst1.exports.geti64_hi(), inst2.exports.geti64_hi());
  inst1.exports.seti64(13579, 24680);
  assertEquals(13579, inst2.exports.geti64_hi());
  assertEquals(24680, inst2.exports.geti64_lo());
  inst2.exports.seti64(97531, 86420);
  assertEquals(97531, inst1.exports.geti64_hi());
  assertEquals(86420, inst1.exports.geti64_lo());
})();

(function TestImportMutableAcrossGc() {
  let builder = new WasmModuleBuilder();
  builder.addGlobal(kWasmI32, true, false).exportAs('i32');
  let inst1 = builder.instantiate();

  builder = new WasmModuleBuilder();
  builder.addImportedGlobal("mod", 'i32', kWasmI32, true);
  addGlobalGetterAndSetter(builder, 0, 'i32', kWasmI32);
  let inst2 = builder.instantiate({ mod: { i32: inst1.exports.i32 } });

  delete inst1;
  gc();

  inst2.exports.seti32(0x789abcde);
  assertEquals(0x789abcde, inst2.exports.geti32());
})();

(function TestImportedAndNonImportedMutableGlobal() {
  let global = new WebAssembly.Global({value: 'i32', mutable: true}, 1);
  let builder = new WasmModuleBuilder();
  builder.addImportedGlobal("mod", "g", kWasmI32, true);
  builder.addGlobal(kWasmI32, true, false).exportAs('i32');
  builder.instantiate({mod: {g: global}});
})();
                                                                           node-23.7.0/deps/v8/test/mjsunit/wasm/import-table.js                                               0000664 0000000 0000000 00000017620 14746647661 0022427 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function addConstFunc(builder, val) {
  return builder.addFunction("const" + val, kSig_i_v)
    .addBody(wasmI32Const(val)).index;
}

function addSigs(builder, pad) {
  for (let i = 0; i < pad; i++) {
    let params = [];
    for (let j = 0; j < i; j++) params.push(kWasmF32);
    builder.addType(makeSig(params, []));
  }

  return { i_v: builder.addType(kSig_i_v) };
}

let kTableSize = 50;

(function TestAliasedImportedTable() {
  print(arguments.callee.name);

  {
    let builder = new WasmModuleBuilder();
    let signums = addSigs(builder, 1);

    builder.addImportedTable("m", "table", kTableSize, kTableSize);
    let f15 = addConstFunc(builder, 15);
    let call = builder.addFunction("call", kSig_i_i)
        .addBody([
          kExprLocalGet, 0,
          kExprCallIndirect, signums.i_v, kTableZero
        ])
        .exportAs("call");
    let f17 = addConstFunc(builder, 17);
    builder.addExport("f15", f15);
    builder.addExport("f17", f17);
    builder.addActiveElementSegment(0, wasmI32Const(15), [f15]);
    builder.addActiveElementSegment(0, wasmI32Const(1), [call.index]);

    var mod1 = builder.toModule();
  }

  {
    let builder = new WasmModuleBuilder();
    let signums = addSigs(builder, 5);  // ensure different sigids

    builder.addImportedTable("m", "table", kTableSize, kTableSize);
    let f15 = builder.addImport("m", "f15", kSig_i_v);
    let f17 = builder.addImport("m", "f17", kSig_i_v);
    let f21 = addConstFunc(builder, 21);
    let call = builder.addFunction("call", kSig_i_i)
        .addBody([
          kExprLocalGet, 0,
          kExprCallIndirect, signums.i_v, kTableZero
        ])
        .exportAs("call");
    let f26 = addConstFunc(builder, 26);
    builder.addActiveElementSegment(0, wasmI32Const(17), [f17]);
    builder.addActiveElementSegment(0, wasmI32Const(21), [f21]);
    builder.addActiveElementSegment(0, wasmI32Const(26), [f26]);
    builder.addActiveElementSegment(0, wasmI32Const(5), [call.index]);

    var mod2 = builder.toModule();
  }

  var table = new WebAssembly.Table({initial: kTableSize,
                                     maximum: kTableSize, element: "anyfunc"});
  var i1 = new WebAssembly.Instance(mod1, {m: {table: table}});

  var i2 = new WebAssembly.Instance(mod2,
      {m: {table: table, f15: i1.exports.f15, f17: i1.exports.f17}});

  for (i of [15, 17, 21, 26]) {
    print(i);
    assertEquals(i, i1.exports.call(i));
    assertEquals(i, i2.exports.call(i));
  }
  for (i of [0, 1, 5, 16]) {
    assertThrows(() => i1.exports.call(i));
    assertThrows(() => i2.exports.call(i));
  }
})();

function addConstFuncUsingGlobal(builder, val) {
  let g = builder.addGlobal(kWasmI32, false, false, wasmI32Const(val));
  return builder.addFunction("global" + val, kSig_i_v)
    .addBody([kExprGlobalGet, g.index]).index;
}

(function TestAliasedImportedTableInstanceGlobals() {
  print(arguments.callee.name);

  {
    let builder = new WasmModuleBuilder();
    let signums = addSigs(builder, 1);

    builder.addImportedTable("m", "table", kTableSize, kTableSize);
    let f14 = addConstFuncUsingGlobal(builder, 14);
    let call = builder.addFunction("call", kSig_i_i)
        .addBody([
          kExprLocalGet, 0,
          kExprCallIndirect, signums.i_v, kTableZero
        ])
        .exportAs("call");
    let f18 = addConstFuncUsingGlobal(builder, 18);
    builder.addExport("f14", f14);
    builder.addExport("f18", f18);
    builder.addActiveElementSegment(0, wasmI32Const(14), [f14]);
    builder.addActiveElementSegment(0, wasmI32Const(1), [call.index]);

    var mod1 = builder.toModule();
  }

  {
    let builder = new WasmModuleBuilder();
    let signums = addSigs(builder, 3);  // ensure different sigids

    builder.addImportedTable("m", "table", kTableSize, kTableSize);
    let f14 = builder.addImport("m", "f14", kSig_i_v);
    let f18 = builder.addImport("m", "f18", kSig_i_v);
    let f22 = addConstFuncUsingGlobal(builder, 22);
    let call = builder.addFunction("call", kSig_i_i)
        .addBody([
          kExprLocalGet, 0,
          kExprCallIndirect, signums.i_v, kTableZero
        ])
        .exportAs("call");
    let f28 = addConstFuncUsingGlobal(builder, 28);
    builder.addActiveElementSegment(0, wasmI32Const(18), [f18]);
    builder.addActiveElementSegment(0, wasmI32Const(22), [f22]);
    builder.addActiveElementSegment(0, wasmI32Const(28), [f28]);
    builder.addActiveElementSegment(0, wasmI32Const(5), [call.index]);

    var mod2 = builder.toModule();
  }

  var table = new WebAssembly.Table({initial: kTableSize,
                                     maximum: kTableSize, element: "anyfunc"});
  var i1 = new WebAssembly.Instance(mod1, {m: {table: table}});

  var i2 = new WebAssembly.Instance(mod2,
      {m: {table: table, f14: i1.exports.f14, f18: i1.exports.f18}});

  for (i of [14, 18, 22, 28]) {
    print(i);
    assertEquals(i, i1.exports.call(i));
    assertEquals(i, i2.exports.call(i));
  }
  for (i of [0, 1, 5, 16]) {
    assertThrows(() => i1.exports.call(i));
    assertThrows(() => i2.exports.call(i));
  }
})();


function addConstFuncUsingMemory(builder, val) {
  var addr = builder.address;
  builder.address += 8;
  var bytes = [val & 0xff, (val>>8) & 0xff, (val>>16) & 0xff, (val>>24) & 0xff];
  builder.addActiveDataSegment(0, [kExprI32Const, addr], bytes);
  return builder.addFunction("mem" + val, kSig_i_v)
    .addBody([
      ...wasmI32Const(addr),
      kExprI32LoadMem, 0, 0
    ]).index;
}

(function TestAliasedImportedTableInstanceMemories() {
  print(arguments.callee.name);

  {
    let builder = new WasmModuleBuilder();
    builder.address = 8;
    let signums = addSigs(builder, 1);

    builder.addMemory(1, 1);
    builder.addImportedTable("m", "table", kTableSize, kTableSize);
    let f13 = addConstFuncUsingMemory(builder, 13);
    let call = builder.addFunction("call", kSig_i_i)
        .addBody([
          kExprLocalGet, 0,
          kExprCallIndirect, signums.i_v, kTableZero
        ])
        .exportAs("call");
    let f19 = addConstFuncUsingMemory(builder, 19);
    builder.addExport("f13", f13);
    builder.addExport("f19", f19);
    builder.addActiveElementSegment(0, wasmI32Const(13), [f13]);
    builder.addActiveElementSegment(0, wasmI32Const(1), [call.index]);

    var mod1 = builder.toModule();
  }

  {
    let builder = new WasmModuleBuilder();
    builder.address = 8;
    let signums = addSigs(builder, 4);  // ensure different sigids

    builder.addMemory(1, 1);
    builder.addImportedTable("m", "table", kTableSize, kTableSize);
    let f13 = builder.addImport("m", "f13", kSig_i_v);
    let f19 = builder.addImport("m", "f19", kSig_i_v);
    let f23 = addConstFuncUsingMemory(builder, 23);
    let call = builder.addFunction("call", kSig_i_i)
        .addBody([
          kExprLocalGet, 0,
          kExprCallIndirect, signums.i_v, kTableZero
        ])
        .exportAs("call");
    let f29 = addConstFuncUsingMemory(builder, 29);
    builder.addActiveElementSegment(0, wasmI32Const(19), [f19]);
    builder.addActiveElementSegment(0, wasmI32Const(23), [f23]);
    builder.addActiveElementSegment(0, wasmI32Const(29), [f29]);
    builder.addActiveElementSegment(0, wasmI32Const(5), [call.index]);

    var mod2 = builder.toModule();
  }

  var table = new WebAssembly.Table({initial: kTableSize,
                                     maximum: kTableSize, element: "anyfunc"});
  var i1 = new WebAssembly.Instance(mod1, {m: {table: table}});

  var i2 = new WebAssembly.Instance(mod2,
      {m: {table: table, f13: i1.exports.f13, f19: i1.exports.f19}});

  for (i of [13, 19, 23, 29]) {
    print(i);
    assertEquals(i, i1.exports.call(i));
    assertEquals(i, i2.exports.call(i));
  }
  for (i of [0, 1, 5, 16]) {
    assertThrows(() => i1.exports.call(i));
    assertThrows(() => i2.exports.call(i));
  }
})();
                                                                                                                node-23.7.0/deps/v8/test/mjsunit/wasm/imported-dataview-bytelength.js                               0000664 0000000 0000000 00000003000 14746647661 0025603 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --mock-arraybuffer-allocator

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

let kSig_d_r = makeSig([kWasmExternRef], [kWasmF64]);

let kImports = {
  DataView: {
    byteLengthImport: Function.prototype.call.bind(
        Object.getOwnPropertyDescriptor(DataView.prototype, 'byteLength').get)
  },
};

function MakeInstance() {
  let builder = new WasmModuleBuilder();

  let kDataViewByteLength =
      builder.addImport('DataView', 'byteLengthImport', kSig_d_r);
  builder.addFunction('byteLength', kSig_d_r).exportFunc().addBody([
    kExprLocalGet, 0,
    kExprCallFunction, kDataViewByteLength,
  ]);

  return builder.instantiate(kImports);
}

const kLength = 8 * 1024 * 1024 * 1024;

(function TestByteLengthLargeAlloc() {
  print(arguments.callee.name);
  let instance = MakeInstance()

  let big_array = new Int8Array(kLength);
  let big_dataview = new DataView(big_array.buffer);

  assertEquals(kLength, big_dataview.byteLength);
  assertEquals(kLength, instance.exports.byteLength(big_dataview));
})();

(function TestByteLengthLargeAllocLengthTrackingDataViewGSAB() {
  print(arguments.callee.name);
  let instance = MakeInstance();

  let buffer = new SharedArrayBuffer(kLength, {maxByteLength: 2 * kLength});
  let big_dataview = new DataView(buffer);

  assertEquals(kLength, instance.exports.byteLength(big_dataview));
})();
node-23.7.0/deps/v8/test/mjsunit/wasm/imported-dataview.js                                          0000664 0000000 0000000 00000065057 14746647661 0023464 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

// We use "r" for nullable "externref", and "e" for non-nullable "ref extern".
let kSig_d_r = makeSig([kWasmExternRef], [kWasmF64]);
let kSig_l_rii = makeSig([kWasmExternRef, kWasmI32, kWasmI32], [kWasmI64]);
let kSig_i_ri = makeSig([kWasmExternRef, kWasmI32], [kWasmI32]);
let kSig_i_rii = makeSig([kWasmExternRef, kWasmI32, kWasmI32], [kWasmI32]);
let kSig_f_rii = makeSig([kWasmExternRef, kWasmI32, kWasmI32], [kWasmF32]);
let kSig_d_rii = makeSig([kWasmExternRef, kWasmI32, kWasmI32], [kWasmF64]);
let kSig_v_rili = makeSig([kWasmExternRef, kWasmI32, kWasmI64, kWasmI32], []);
let kSig_v_rii = makeSig([kWasmExternRef, kWasmI32, kWasmI32], []);
let kSig_v_riii = makeSig([kWasmExternRef, kWasmI32, kWasmI32, kWasmI32], []);
let kSig_v_rifi = makeSig([kWasm