ExternRef, kWasmI32, kWasmF32, kWasmI32], []);
let kSig_v_ridi = makeSig([kWasmExternRef, kWasmI32, kWasmF64, kWasmI32], []);

let kImports = {
  DataView: {
    getBigInt64Import:
        Function.prototype.call.bind(DataView.prototype.getBigInt64),
    getBigUint64Import:
        Function.prototype.call.bind(DataView.prototype.getBigUint64),
    getFloat32Import:
        Function.prototype.call.bind(DataView.prototype.getFloat32),
    getFloat64Import:
        Function.prototype.call.bind(DataView.prototype.getFloat64),
    getInt8Import: Function.prototype.call.bind(DataView.prototype.getInt8),
    getInt16Import: Function.prototype.call.bind(DataView.prototype.getInt16),
    getInt32Import: Function.prototype.call.bind(DataView.prototype.getInt32),
    getUint8Import: Function.prototype.call.bind(DataView.prototype.getUint8),
    getUint16Import: Function.prototype.call.bind(DataView.prototype.getUint16),
    getUint32Import: Function.prototype.call.bind(DataView.prototype.getUint32),
    setBigInt64Import:
        Function.prototype.call.bind(DataView.prototype.setBigInt64),
    setBigUint64Import:
        Function.prototype.call.bind(DataView.prototype.setBigUint64),
    setFloat32Import:
        Function.prototype.call.bind(DataView.prototype.setFloat32),
    setFloat64Import:
        Function.prototype.call.bind(DataView.prototype.setFloat64),
    setInt8Import: Function.prototype.call.bind(DataView.prototype.setInt8),
    setInt16Import: Function.prototype.call.bind(DataView.prototype.setInt16),
    setInt32Import: Function.prototype.call.bind(DataView.prototype.setInt32),
    setUint8Import: Function.prototype.call.bind(DataView.prototype.setUint8),
    setUint16Import: Function.prototype.call.bind(DataView.prototype.setUint16),
    setUint32Import: Function.prototype.call.bind(DataView.prototype.setUint32),
    byteLengthImport: Function.prototype.call.bind(
        Object.getOwnPropertyDescriptor(DataView.prototype, 'byteLength').get)
  },
};

function ExportedDataViewGetterBody(dataview_op) {
  return [
    kExprLocalGet, 0,
    kExprLocalGet, 1,
    kExprLocalGet, 2,
    kExprCallFunction, dataview_op,
  ]
}

function ExportedDataViewSetterBody(dataview_op) {
  return [
    kExprLocalGet, 0,
    kExprLocalGet, 1,
    kExprLocalGet, 2,
    kExprLocalGet, 3,
    kExprCallFunction, dataview_op,
  ];
}

function MakeInstance() {
  let builder = new WasmModuleBuilder();

  let kDataViewGetBigInt64 =
      builder.addImport('DataView', 'getBigInt64Import', kSig_l_rii);
  let kDataViewGetBigUint64 =
      builder.addImport('DataView', 'getBigUint64Import', kSig_l_rii);
  let kDataViewGetFloat32 =
      builder.addImport('DataView', 'getFloat32Import', kSig_f_rii);
  let kDataViewGetFloat64 =
      builder.addImport('DataView', 'getFloat64Import', kSig_d_rii);
  let kDataViewGetInt8 =
      builder.addImport('DataView', 'getInt8Import', kSig_i_ri);
  let kDataViewGetInt16 =
      builder.addImport('DataView', 'getInt16Import', kSig_i_rii);
  let kDataViewGetInt32 =
      builder.addImport('DataView', 'getInt32Import', kSig_i_rii);
  let kDataViewGetUint8 =
      builder.addImport('DataView', 'getUint8Import', kSig_i_ri);
  let kDataViewGetUint16 =
      builder.addImport('DataView', 'getUint16Import', kSig_i_rii);
  let kDataViewGetUint32 =
      builder.addImport('DataView', 'getUint32Import', kSig_i_rii);
  let kDataViewSetBigInt64 =
      builder.addImport('DataView', 'setBigInt64Import', kSig_v_rili);
  let kDataViewSetBigUint64 =
      builder.addImport('DataView', 'setBigUint64Import', kSig_v_rili);
  let kDataViewSetFloat32 =
      builder.addImport('DataView', 'setFloat32Import', kSig_v_rifi);
  let kDataViewSetFloat64 =
      builder.addImport('DataView', 'setFloat64Import', kSig_v_ridi);
  let kDataViewSetInt8 =
      builder.addImport('DataView', 'setInt8Import', kSig_v_rii);
  let kDataViewSetInt16 =
      builder.addImport('DataView', 'setInt16Import', kSig_v_riii);
  let kDataViewSetInt32 =
      builder.addImport('DataView', 'setInt32Import', kSig_v_riii);
  let kDataViewSetUint8 =
      builder.addImport('DataView', 'setUint8Import', kSig_v_rii);
  let kDataViewSetUint16 =
      builder.addImport('DataView', 'setUint16Import', kSig_v_riii);
  let kDataViewSetUint32 =
      builder.addImport('DataView', 'setUint32Import', kSig_v_riii);
  let kDataViewByteLength =
      builder.addImport('DataView', 'byteLengthImport', kSig_d_r);

  builder.addFunction('getBigInt64', kSig_l_rii)
      .exportFunc()
      .addBody(ExportedDataViewGetterBody(kDataViewGetBigInt64));
  builder.addFunction('getBigUint64', kSig_l_rii)
      .exportFunc()
      .addBody(ExportedDataViewGetterBody(kDataViewGetBigUint64));
  builder.addFunction('getFloat32', kSig_f_rii)
      .exportFunc()
      .addBody(ExportedDataViewGetterBody(kDataViewGetFloat32));
  builder.addFunction('getFloat64', kSig_d_rii)
      .exportFunc()
      .addBody(ExportedDataViewGetterBody(kDataViewGetFloat64));
  builder.addFunction('getInt8', kSig_i_ri).exportFunc().addBody([
    kExprLocalGet, 0,
    kExprLocalGet, 1,
    kExprCallFunction, kDataViewGetInt8,
  ]);
  builder.addFunction('getInt16', kSig_i_rii)
      .exportFunc()
      .addBody(ExportedDataViewGetterBody(kDataViewGetInt16));
  builder.addFunction('getInt32', kSig_i_rii)
      .exportFunc()
      .addBody(ExportedDataViewGetterBody(kDataViewGetInt32));
  builder.addFunction('getUint8', kSig_i_ri).exportFunc().addBody([
    kExprLocalGet, 0,
    kExprLocalGet, 1,
    kExprCallFunction, kDataViewGetUint8,
  ]);
  builder.addFunction('getUint16', kSig_i_rii)
      .exportFunc()
      .addBody(ExportedDataViewGetterBody(kDataViewGetUint16));
  builder.addFunction('getUint32', kSig_i_rii)
      .exportFunc()
      .addBody(ExportedDataViewGetterBody(kDataViewGetUint32));
  builder.addFunction('setBigInt64', kSig_v_rili)
      .exportFunc()
      .addBody(ExportedDataViewSetterBody(kDataViewSetBigInt64));
  builder.addFunction('setBigUint64', kSig_v_rili)
      .exportFunc()
      .addBody(ExportedDataViewSetterBody(kDataViewSetBigUint64));
  builder.addFunction('setFloat32', kSig_v_rifi)
      .exportFunc()
      .addBody(ExportedDataViewSetterBody(kDataViewSetFloat32));
  builder.addFunction('setFloat64', kSig_v_ridi)
      .exportFunc()
      .addBody(ExportedDataViewSetterBody(kDataViewSetFloat64));
  builder.addFunction('setInt8', kSig_v_rii).exportFunc().addBody([
    kExprLocalGet, 0,
    kExprLocalGet, 1,
    kExprLocalGet, 2,
    kExprCallFunction, kDataViewSetInt8,
  ]);
  builder.addFunction('setInt16', kSig_v_riii)
      .exportFunc()
      .addBody(ExportedDataViewSetterBody(kDataViewSetInt16));
  builder.addFunction('setInt32', kSig_v_riii)
      .exportFunc()
      .addBody(ExportedDataViewSetterBody(kDataViewSetInt32));
  builder.addFunction('setUint8', kSig_v_rii).exportFunc().addBody([
    kExprLocalGet, 0,
    kExprLocalGet, 1,
    kExprLocalGet, 2,
    kExprCallFunction, kDataViewSetUint8,
  ]);
  builder.addFunction('setUint16', kSig_v_riii)
      .exportFunc()
      .addBody(ExportedDataViewSetterBody(kDataViewSetUint16));
  builder.addFunction('setUint32', kSig_v_riii)
      .exportFunc()
      .addBody(ExportedDataViewSetterBody(kDataViewSetUint32));
  builder.addFunction('byteLength', kSig_d_r).exportFunc().addBody([
    kExprLocalGet, 0,
    kExprCallFunction, kDataViewByteLength,
  ]);
  return builder.instantiate(kImports);
}

function CheckStackTrace(thrower, reference, topmost_wasm_func) {
  let reference_exception;
  let actual_exception;
  try {
    thrower();
    assertUnreachable();
  } catch (e) {
    actual_exception = e;
  }
  try {
    reference();
    assertUnreachable();
  } catch (e) {
    reference_exception = e;
  }
  assertInstanceof(actual_exception, reference_exception.constructor);
  let actual_stack = actual_exception.stack.split('\n');
  let reference_stack = reference_exception.stack.split('\n');
  assertEquals(reference_stack[0], actual_stack[0]);
  assertEquals(reference_stack[1], actual_stack[1]);

  let str_stack_msg = `    at ${topmost_wasm_func} (wasm://wasm/`;
  if (!actual_stack[2].startsWith(str_stack_msg)) {
    console.log(
        `expected starts with:\n${str_stack_msg}\nfound:\n${actual_stack[2]}`);
    assertUnreachable();
  }
}

function CheckDataViewErrorMessages(
    dataview_op, array, detach_check, set_to_value) {
  let dataview = new DataView(array.buffer);

  // Incompatible receiver (number).
  let params = [123, 0];
  if (set_to_value !== undefined) params.push(set_to_value);
  CheckStackTrace(
      () => instance.exports[dataview_op](...params),
      () => DataView.prototype[dataview_op].call(...params), dataview_op);

  // Incompatible receiver (string).
  params = ['test_string', 0];
  if (set_to_value !== undefined) params.push(set_to_value);
  CheckStackTrace(
      () => instance.exports[dataview_op](...params),
      () => DataView.prototype[dataview_op].call(...params), dataview_op);

  // Offset bounds check.
  params = [dataview, -1];
  if (set_to_value !== undefined) params.push(set_to_value);
  CheckStackTrace(
      () => instance.exports[dataview_op](...params),
      () => DataView.prototype[dataview_op].call(...params), dataview_op);

  // Dataview bounds check (expect the buffer index 100 is out of bounds).
  params = [dataview, 100];
  if (set_to_value !== undefined) params.push(set_to_value);
  CheckStackTrace(
      () => instance.exports[dataview_op](...params),
      () => DataView.prototype[dataview_op].call(...params), dataview_op);

  // Detached buffer.
  if (!detach_check) return;
  params = [dataview, 0];
  if (set_to_value !== undefined) params.push(set_to_value);
  %ArrayBufferDetach(array.buffer);
  CheckStackTrace(
      () => instance.exports[dataview_op](...params),
      () => DataView.prototype[dataview_op].call(...params), dataview_op);
}

let instance = MakeInstance();

(function TestDataViewOutOfBounds() {
  print(arguments.callee.name);
  let array = new BigInt64Array(2);
  array[0] = 0x7FFFFFFFFFFFFFFFn;
  array[1] = 0x12345678n;
  let dataview = new DataView(array.buffer);

  // Dataview bounds check:
  CheckStackTrace(
      () => instance.exports.getBigInt64(dataview, 15, 1),
      () => DataView.prototype.getBigInt64.call(dataview, 15, 1),
      'getBigInt64');
  // Offset with element size exactly out of bounds.
  CheckStackTrace(
      () => instance.exports.getBigInt64(dataview, 16, 1),
      () => DataView.prototype.getBigInt64.call(dataview, 16, 1),
      'getBigInt64');
  // Offset without element size already out of bounds.
  CheckStackTrace(
      () => instance.exports.getBigInt64(dataview, 17, 1),
      () => DataView.prototype.getBigInt64.call(dataview, 17, 1),
      'getBigInt64');
})();

(function TestDataViewSharedArrayBuffer() {
  print(arguments.callee.name);
  let buffer = new SharedArrayBuffer(16);
  let array = new Int32Array(buffer);
  let dataview = new DataView(buffer);

  instance.exports.setInt32(dataview, 0, 100, 1);
  assertEquals(100, array[0]);
  assertEquals(100, instance.exports.getInt32(dataview, 0, 1));

  CheckDataViewErrorMessages('setInt32', array, false, 42);
})();

(function TestGetBigInt64() {
  print(arguments.callee.name);
  let array = new BigInt64Array(2);
  array[0] = 0x7FFFFFFFFFFFFFFFn;
  array[1] = 0x12345678n;
  let dataview = new DataView(array.buffer);

  assertEquals(
      0x7FFFFFFFFFFFFFFFn, instance.exports.getBigInt64(dataview, 0, 1));
  assertEquals(0x12345678n, instance.exports.getBigInt64(dataview, 8, 1));
  assertEquals(
      0x7856341200000000n, instance.exports.getBigInt64(dataview, 8, 0));

  CheckDataViewErrorMessages('getBigInt64', array, true);
})();

(function TestGetBigUint64() {
  print(arguments.callee.name);
  let array = new BigUint64Array(2);
  array[0] = 0x7FFFFFFFFFFFFFFFn;
  array[1] = 0x12345678n;
  let dataview = new DataView(array.buffer);

  assertEquals(
      0x7FFFFFFFFFFFFFFFn, instance.exports.getBigUint64(dataview, 0, 1));
  assertEquals(
      0x7856341200000000n, instance.exports.getBigUint64(dataview, 8, 0));

  CheckDataViewErrorMessages('getBigUint64', array, true);
})();

(function TestGetFloat32() {
  print(arguments.callee.name);
  let array = new Float32Array(2);
  array[0] = 140.125;
  array[1] = -2048.015625;
  let dataview = new DataView(array.buffer);

  assertEquals(140.125, instance.exports.getFloat32(dataview, 0, 1));
  assertEquals(
      dataview.getFloat32(4, 0), instance.exports.getFloat32(dataview, 4, 0));

  CheckDataViewErrorMessages('getFloat32', array, true);
})();

(function TestGetFloat64() {
  print(arguments.callee.name);
  let array = new Float64Array(2);
  array[0] = 140.125;
  array[1] = -20480000.001953125;
  let dataview = new DataView(array.buffer);

  assertEquals(140.125, instance.exports.getFloat64(dataview, 0, 1));
  assertEquals(
      dataview.getFloat64(8, 0), instance.exports.getFloat64(dataview, 8, 0));

  CheckDataViewErrorMessages('getFloat64', array, true);
})();

(function TestGetInt8() {
  print(arguments.callee.name);
  let array = new Int8Array(2);
  array[0] = 127;
  array[1] = -64;
  let dataview = new DataView(array.buffer);

  assertEquals(127, instance.exports.getInt8(dataview, 0));
  assertEquals(-64, instance.exports.getInt8(dataview, 1));

  CheckDataViewErrorMessages('getInt8', array, true);
})();

(function TestGetInt16() {
  print(arguments.callee.name);
  let array = new Int16Array(2);
  array[0] = 32767;
  array[1] = 0x1234;
  let dataview = new DataView(array.buffer);

  assertEquals(32767, instance.exports.getInt16(dataview, 0, 1));
  assertEquals(0x3412, instance.exports.getInt16(dataview, 2, 0));

  CheckDataViewErrorMessages('getInt16', array, true);
})();

(function TestGetInt32() {
  print(arguments.callee.name);
  let array = new Int32Array(2);
  array[0] = 42;
  array[1] = 0x12345678;
  let dataview = new DataView(array.buffer);

  assertEquals(42, instance.exports.getInt32(dataview, 0, 1));
  assertEquals(0x12345678, instance.exports.getInt32(dataview, 4, 1));
  assertEquals(0x78563412, instance.exports.getInt32(dataview, 4, 0));

  CheckDataViewErrorMessages('getInt32', array, true);
})();

(function TestGetUint8() {
  print(arguments.callee.name);
  let array = new Uint8Array(1);
  array[0] = 255;
  let dataview = new DataView(array.buffer);

  assertEquals(255, instance.exports.getUint8(dataview, 0));

  CheckDataViewErrorMessages('getUint8', array, true);
})();

(function TestGetUint16() {
  print(arguments.callee.name);
  let array = new Uint16Array(2);
  array[0] = 0xFFFF;
  array[1] = 0x1234;
  let dataview = new DataView(array.buffer);

  assertEquals(0xFFFF, instance.exports.getUint16(dataview, 0, 1));
  assertEquals(0x3412, instance.exports.getUint16(dataview, 2, 0));

  CheckDataViewErrorMessages('getUint16', array, true);
})();

(function TestGetUint32() {
  print(arguments.callee.name);
  let array = new Uint32Array(2);
  array[0] = 0x7FFFFFFF;
  array[1] = 0x12345678;
  let dataview = new DataView(array.buffer);

  assertEquals(0x7FFFFFFF, instance.exports.getUint32(dataview, 0, 1));
  assertEquals(0x78563412, instance.exports.getUint32(dataview, 4, 0));

  CheckDataViewErrorMessages('getUint32', array, true);
})();

(function TestSetBigInt64() {
  print(arguments.callee.name);
  let array = new BigInt64Array(2);
  let dataview = new DataView(array.buffer);

  instance.exports.setBigInt64(dataview, 0, 0x7FFFFFFFFFFFFFFFn, 1);
  assertEquals(0x7FFFFFFFFFFFFFFFn, array[0]);
  instance.exports.setBigInt64(dataview, 0, -0x7FFFFFFFFFFFFFFFn, 1);
  assertEquals(-0x7FFFFFFFFFFFFFFFn, array[0]);
  instance.exports.setBigInt64(dataview, 8, 0x12345678n, 0);
  assertEquals(0x7856341200000000n, array[1]);

  CheckDataViewErrorMessages('setBigInt64', array, true, 50n);
})();

(function TestSetBigUint64() {
  print(arguments.callee.name);
  let array = new BigUint64Array(1);
  let dataview = new DataView(array.buffer);

  instance.exports.setBigUint64(dataview, 0, 0xFFFFFFFFFFFFFFFFn, 1);
  assertEquals(0xFFFFFFFFFFFFFFFFn, array[0]);
  instance.exports.setBigUint64(dataview, 0, 0x12345678n, 0);
  assertEquals(0x7856341200000000n, array[0]);

  CheckDataViewErrorMessages('setBigUint64', array, true, 50n);
})();

(function TestSetFloat32() {
  print(arguments.callee.name);
  let array = new Float32Array(2);
  let dataview = new DataView(array.buffer);

  instance.exports.setFloat32(dataview, 0, 50.5, 1);
  assertEquals(50.5, array[0]);
  instance.exports.setFloat32(dataview, 0, 0x1234, 0);
  dataview.setFloat32(4, 0x1234, 0);
  assertEquals(array[1], array[0]);

  CheckDataViewErrorMessages('setFloat32', array, true, 50.5);
})();

(function TestSetFloat64() {
  print(arguments.callee.name);
  let array = new Float64Array(2);
  let dataview = new DataView(array.buffer);

  instance.exports.setFloat64(dataview, 0, 42.5, 1);
  assertEquals(42.5, array[0]);
  instance.exports.setFloat64(dataview, 0, 0x1234, 0);
  dataview.setFloat64(8, 0x1234, 0);
  assertEquals(array[1], array[0]);

  CheckDataViewErrorMessages('setFloat64', array, true, 50.5);
})();

(function TestSetInt8() {
  print(arguments.callee.name);
  let array = new Int8Array(1);
  let dataview = new DataView(array.buffer);

  instance.exports.setInt8(dataview, 0, 127);
  assertEquals(127, array[0]);

  CheckDataViewErrorMessages('setInt8', array, true, 120);
})();

(function TestSetInt16() {
  print(arguments.callee.name);
  let array = new Int16Array(2);
  let dataview = new DataView(array.buffer);

  instance.exports.setInt16(dataview, 0, 0x1234, 1);
  assertEquals(0x1234, array[0]);
  instance.exports.setInt16(dataview, 2, 0x1234, 0);
  assertEquals(0x3412, array[1]);

  CheckDataViewErrorMessages('setInt16', array, true, 120);
})();

(function TestSetInt32() {
  print(arguments.callee.name);
  let array = new Int32Array(2);
  let dataview = new DataView(array.buffer);

  instance.exports.setInt32(dataview, 0, 50, 1);
  assertEquals(50, array[0]);
  instance.exports.setInt32(dataview, 4, 100, 1);
  assertEquals(100, array[1]);
  instance.exports.setInt32(dataview, 0, 0x12345678, 0);
  assertEquals(0x78563412, array[0]);

  CheckDataViewErrorMessages('setInt32', array, true, 100);
})();

(function TestSetUint8() {
  print(arguments.callee.name);
  let array = new Uint8Array(1);
  let dataview = new DataView(array.buffer);

  instance.exports.setUint8(dataview, 0, 255);
  assertEquals(255, array[0]);

  CheckDataViewErrorMessages('setUint8', array, true, 100);
})();

(function TestSetUint16() {
  print(arguments.callee.name);
  let array = new Uint16Array(2);
  let dataview = new DataView(array.buffer);

  instance.exports.setUint16(dataview, 0, 0x1234, 1);
  assertEquals(0x1234, array[0]);
  instance.exports.setUint16(dataview, 2, 0x1234, 0);
  assertEquals(0x3412, array[1]);

  CheckDataViewErrorMessages('setUint16', array, true, 100);
})();

(function TestSetUint32() {
  print(arguments.callee.name);
  let array = new Uint32Array(2);
  let dataview = new DataView(array.buffer);

  instance.exports.setUint32(dataview, 0, 50, 1);
  assertEquals(50, array[0]);
  instance.exports.setUint32(dataview, 4, 0x12345678, 0);
  assertEquals(0x78563412, array[1]);

  CheckDataViewErrorMessages('setUint32', array, true, 100);
})();

(function TestByteLength() {
  print(arguments.callee.name);
  let array = new Int32Array(2);
  let dataview = new DataView(array.buffer);

  assertEquals(8, instance.exports.byteLength(dataview));
  let dataview2 = new DataView(array.buffer, 4, 4);
  assertEquals(4, dataview2.byteLength);

  CheckStackTrace(
      () => instance.exports.byteLength('test_string'),
      () => Object.getOwnPropertyDescriptor(DataView.prototype, 'byteLength')
                .get.call('test_string'),
      'byteLength');

  CheckStackTrace(
      () => instance.exports.byteLength(1),
      () => Object.getOwnPropertyDescriptor(DataView.prototype, 'byteLength')
                .get.call(1),
      'byteLength');

  %ArrayBufferDetach(array.buffer);
  CheckStackTrace(
      () => instance.exports.byteLength(dataview),
      () => Object.getOwnPropertyDescriptor(DataView.prototype, 'byteLength')
                .get.call(dataview),
      'byteLength');
})();

// Abbreviations:
//  - LT: length-tracking;
//  - RAB: resizable ArrayBuffer;
//  - GSAB: growable SharedArrayBuffer.
(function TestLTDataViewRABNoByteOffset() {
  print(arguments.callee.name);
  let buffer = new ArrayBuffer(8, {maxByteLength: 128});
  let array = new Int32Array(buffer);
  let dataview = new DataView(buffer);

  array[0] = 123;
  assertEquals(123, instance.exports.getInt32(dataview, 0, 1));
  instance.exports.setInt32(dataview, 4, 100, 1);
  assertEquals(100, array[1]);
  assertEquals(8, instance.exports.byteLength(dataview));

  buffer.resize(24);
  assertEquals(24, instance.exports.byteLength(dataview));

  buffer.resize(0);
  assertEquals(0, instance.exports.byteLength(dataview));

  CheckDataViewErrorMessages('getInt32', array, true);
})();

(function TestLTDataViewRABWithByteOffset() {
  print(arguments.callee.name);
  let buffer = new ArrayBuffer(12, {maxByteLength: 80});
  let array = new Uint32Array(buffer);
  let dataview = new DataView(buffer, 8);

  array[2] = 123;
  assertEquals(123, instance.exports.getUint32(dataview, 0, 1));
  instance.exports.setUint32(dataview, 0, 100, 1);
  assertEquals(100, array[2]);
  assertEquals(4, instance.exports.byteLength(dataview));

  buffer.resize(24);
  assertEquals(16, instance.exports.byteLength(dataview));

  buffer.resize(8);
  assertEquals(0, instance.exports.byteLength(dataview));

  buffer.resize(7);
  CheckStackTrace(
      () => instance.exports.byteLength(dataview),
      () => Object.getOwnPropertyDescriptor(DataView.prototype, 'byteLength')
                .get.call(dataview),
      'byteLength');

  buffer.resize(0);
  CheckStackTrace(
      () => instance.exports.byteLength(dataview),
      () => Object.getOwnPropertyDescriptor(DataView.prototype, 'byteLength')
                .get.call(dataview),
      'byteLength');

  buffer.resize(80);
  assertEquals(72, instance.exports.byteLength(dataview));
  CheckDataViewErrorMessages('setUint32', array, true, 100);
})();

(function TestNonLTDataViewRAB() {
  print(arguments.callee.name);
  let buffer = new ArrayBuffer(56, {maxByteLength: 72});
  let array = new BigInt64Array(buffer);
  let dataview = new DataView(buffer, 24, 16);

  array[3] = 123n;
  assertEquals(123n, instance.exports.getBigInt64(dataview, 0, 1));
  instance.exports.setBigInt64(dataview, 8, 100n, 1);
  assertEquals(100n, array[4]);
  assertEquals(16, instance.exports.byteLength(dataview));

  buffer.resize(40);
  assertEquals(16, instance.exports.byteLength(dataview));

  buffer.resize(39);
  CheckStackTrace(
      () => instance.exports.byteLength(dataview),
      () => Object.getOwnPropertyDescriptor(DataView.prototype, 'byteLength')
                .get.call(dataview),
      'byteLength');

  buffer.resize(8);
  CheckStackTrace(
      () => instance.exports.byteLength(dataview),
      () => Object.getOwnPropertyDescriptor(DataView.prototype, 'byteLength')
                .get.call(dataview),
      'byteLength');

  buffer.resize(0);
  CheckStackTrace(
      () => instance.exports.byteLength(dataview),
      () => Object.getOwnPropertyDescriptor(DataView.prototype, 'byteLength')
                .get.call(dataview),
      'byteLength');

  buffer.resize(64);
  assertEquals(16, instance.exports.byteLength(dataview));
  CheckDataViewErrorMessages('setBigInt64', array, true, 200n);
})();

(function TestNonLTEmptyDataViewRAB() {
  print(arguments.callee.name);
  let buffer = new ArrayBuffer(24, {maxByteLength: 40});
  let empty_dataview = new DataView(buffer, 24, 0);

  assertEquals(0, instance.exports.byteLength(empty_dataview));

  buffer.resize(20);
  CheckStackTrace(
      () => instance.exports.byteLength(empty_dataview),
      () => Object.getOwnPropertyDescriptor(DataView.prototype, 'byteLength')
                .get.call(empty_dataview),
      'byteLength');
})();

(function TestLTDataViewGSABNoByteOffset() {
  print(arguments.callee.name);
  let buffer = new SharedArrayBuffer(24, {maxByteLength: 40});
  let array = new Float32Array(buffer);
  let dataview = new DataView(buffer);

  array[0] = 23.5;
  assertEquals(23.5, instance.exports.getFloat32(dataview, 0, 1));
  instance.exports.setFloat32(dataview, 4, 12.25, 1);
  assertEquals(12.25, array[1]);
  assertEquals(24, instance.exports.byteLength(dataview));

  buffer.grow(25);
  assertEquals(25, instance.exports.byteLength(dataview));

  CheckDataViewErrorMessages('getFloat32', array, false);
})();

(function TestLTDataViewGSABWithByteOffset() {
  print(arguments.callee.name);
  let buffer = new SharedArrayBuffer(24, {maxByteLength: 40});
  let array = new Int16Array(buffer);
  let dataview = new DataView(buffer, 24);

  assertEquals(0, instance.exports.byteLength(dataview));

  buffer.grow(36);
  array[12] = 123;
  assertEquals(123, instance.exports.getInt16(dataview, 0, 1));
  instance.exports.setInt16(dataview, 2, 100, 1);
  assertEquals(100, array[13]);
  assertEquals(12, instance.exports.byteLength(dataview));

  CheckDataViewErrorMessages('setInt16', array, false, 57);
})();

(function TestNonLTDataViewGSAB() {
  print(arguments.callee.name);
  let buffer = new SharedArrayBuffer(10, {maxByteLength: 23});
  let array = new Int8Array(buffer);
  let dataview = new DataView(buffer, 4, 3);

  array[4] = 123;
  assertEquals(123, instance.exports.getInt8(dataview, 0));
  instance.exports.setInt8(dataview, 1, 100);
  assertEquals(100, array[5]);
  assertEquals(3, instance.exports.byteLength(dataview));

  buffer.grow(23);
  assertEquals(3, instance.exports.byteLength(dataview));

  CheckDataViewErrorMessages('getInt8', array, false);
})();

(function TestNonLTEmptyDataViewGSAB() {
  print(arguments.callee.name);
  let buffer = new SharedArrayBuffer(12, {maxByteLength: 44});
  let array = new Int32Array(buffer);
  let dataview = new DataView(buffer, 12, 0);

  assertEquals(0, instance.exports.byteLength(dataview));

  buffer.grow(24);
  assertEquals(0, instance.exports.byteLength(dataview));
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/wasm/imported-function-types.js                                    0000664 0000000 0000000 00000002623 14746647661 0024635 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

var exporting_module = (function() {
  var builder = new WasmModuleBuilder();

  var binaryType = builder.addType(kSig_i_ii);
  var unaryType = builder.addType(kSig_i_i);

  builder.addFunction("func1", makeSig([wasmRefType(binaryType)], [kWasmI32]))
    .addBody([kExprI32Const, 42, kExprI32Const, 12, kExprLocalGet, 0,
              kExprCallRef, binaryType])
    .exportFunc();

  builder.addFunction("func2", makeSig([wasmRefType(unaryType)], [kWasmI32]))
    .addBody([kExprI32Const, 42, kExprLocalGet, 0, kExprCallRef, unaryType])
    .exportFunc();

  return builder.instantiate({});
})();

var importing_module = function(imported_function) {
  var builder = new WasmModuleBuilder();

  var unaryType = builder.addType(kSig_i_i);

  builder.addImport("other", "func",
    makeSig([wasmRefType(unaryType)], [kWasmI32]));

  return builder.instantiate({other: {func: imported_function}});
};

// Same form/different index should be fine.
importing_module(exporting_module.exports.func2);
// Same index/different form should throw.
assertThrows(
    () => importing_module(exporting_module.exports.func1),
    WebAssembly.LinkError,
    /imported function does not match the expected type/);
                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/imported-strings-constants.js                                 0000664 0000000 0000000 00000010337 14746647661 0025352 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-imported-strings

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

const kRefExtern = wasmRefType(kWasmExternRef);

(function InvalidCases() {
  // Cannot use function types in strings namespace.
  let invalid_builder = new WasmModuleBuilder();
  invalid_builder.addImport("'", "foo", kSig_v_v);
  assertThrows(
      () => invalid_builder.instantiate(
          {"'": {foo: () => {}}}, {importedStringConstants: "'"}),
      WebAssembly.LinkError,
      'WebAssembly.Module(): String constant import #0 "foo" must be ' +
          'an immutable global subtyping externref @+17');

  // Cannot use numeric types in strings namespace.
  let invalid_builder2 = new WasmModuleBuilder();
  invalid_builder2.addImportedGlobal("'", "bar", kWasmI32);
  assertThrows(
      () => invalid_builder2.instantiate(
          {"'": {bar: 42}}, {importedStringConstants: "'"}),
      WebAssembly.LinkError,
      'WebAssembly.Module(): String constant import #0 "bar" must be ' +
          'an immutable global subtyping externref @+11');

  // No implicit to-string conversion is performed.
  let invalid_builder3 = new WasmModuleBuilder();
  invalid_builder3.addImportedGlobal("'", "str", kRefExtern);
  assertThrows(
      () => invalid_builder3.instantiate(
          {}, {importedStringConstants: {toString: () => "'"}}),
      TypeError,
      'WebAssembly.Instance(): Import #0 "\'": module is not an object ' +
          'or function');
})();

(function EmptyModuleName() {
  let builder = new WasmModuleBuilder();
  let $foo = builder.addImportedGlobal("", "foo", kRefExtern, false);
  builder.addFunction("get_foo", kSig_r_v).exportFunc().addBody([
    kExprGlobalGet, $foo,
  ]);
  let instance = builder.instantiate({}, {importedStringConstants: ""});
  assertEquals("foo", instance.exports.get_foo());
})();

(function LongModuleName() {
  let builder = new WasmModuleBuilder();
  let $foo = builder.addImportedGlobal(
      "MyBeautifulMagicStringConstants", "foo", kRefExtern, false);
  builder.addFunction("get_foo", kSig_r_v).exportFunc().addBody([
    kExprGlobalGet, $foo,
  ]);
  let instance = builder.instantiate(
      {}, {importedStringConstants: "MyBeautifulMagicStringConstants"});
  assertEquals("foo", instance.exports.get_foo());
})();

(function NullableExternref() {
  let builder = new WasmModuleBuilder();
  let $foo = builder.addImportedGlobal("'", "foo", kWasmExternRef, false);
  builder.addFunction("get_foo", kSig_r_v).exportFunc().addBody([
    kExprGlobalGet, $foo,
  ]);
  let instance = builder.instantiate({}, {importedStringConstants: "'"});
  assertEquals("foo", instance.exports.get_foo());
})();

let builder = new WasmModuleBuilder();
let $log = builder.addImport("m", "log", kSig_v_r);
let hello_world = "Hello, world!";
let multi_byte = "\uD83D\uDE02";  // U+1F602
let $hello = builder.addImportedGlobal("'", hello_world, kRefExtern, false);
let $multi = builder.addImportedGlobal("'", multi_byte, kRefExtern, false);

builder.addFunction("main", kSig_v_v).exportFunc().addBody([
  kExprGlobalGet, $hello,
  kExprCallFunction, $log,
]);
builder.addFunction("multi", kSig_v_v).exportFunc().addBody([
  kExprGlobalGet, $multi,
  kExprCallFunction, $log,
]);


var callback_value = "the test has not yet run";
function log(x) {
  callback_value = x;
}
let kBuiltins = {importedStringConstants: "'"};
let kImports = {
  m: {log},
  "'": {
    [hello_world]: "This isn't the right string",
    [multi_byte]: "This also isn't the right string",
  },
};
let instance = builder.instantiate(kImports, kBuiltins);
instance.exports.main();
assertEquals(hello_world, callback_value);
instance.exports.multi();
assertEquals(multi_byte, callback_value);
// The magically satisfied string import isn't in the imports list.
let runtime_imports = WebAssembly.Module.imports(builder.toModule(kBuiltins));
assertArrayEquals(
    [{module: 'm', name: 'log', kind: 'function'}], runtime_imports);
// If we don't set the flag, we do get the plain old imports.
let instance2 = builder.instantiate(kImports);
instance2.exports.main();
assertEquals("This isn't the right string", callback_value);
                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/wasm/imported-strings-invalid.js                                   0000664 0000000 0000000 00000014667 14746647661 0024776 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-imported-strings

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

let kRefExtern = wasmRefType(kWasmExternRef);
let kSig_e_v = makeSig([], [kRefExtern]);

// Part I: Test that the String builtins throw when called
// with arguments of incorrect types.

let length = 3;
let instance = (() => {
  let builder = new WasmModuleBuilder();
  builder.startRecGroup();
  let good_array_i16 = builder.addArray(kWasmI16, true, kNoSuperType, true);
  builder.endRecGroup();
  builder.startRecGroup();
  let good_array_i8 = builder.addArray(kWasmI8, true, kNoSuperType, true);
  builder.endRecGroup();
  builder.startRecGroup();
  let bad_array_i16 = builder.addArray(kWasmI16, true, kNoSuperType, true);
  let bad_array_i8 = builder.addArray(kWasmI8, true, kNoSuperType, true);
  builder.endRecGroup();

  let wtf16_data = builder.addPassiveDataSegment([97, 0, 98, 0, 99, 0]);
  let wtf8_data = builder.addPassiveDataSegment([97, 98, 99]);

  let use_i16_array = builder.addImport(
      'wasm:js-string', 'fromCharCodeArray',
      makeSig([wasmRefType(good_array_i16), kWasmI32, kWasmI32], [kRefExtern]));
  let use_i8_array = builder.addImport(
      'wasm:text-decoder', 'decodeStringFromUTF8Array',
      makeSig([wasmRefType(good_array_i8), kWasmI32, kWasmI32], [kRefExtern]));

  builder.addExport('use_i16_array', use_i16_array);
  builder.addExport('use_i8_array', use_i8_array);

  builder.addFunction(
      "bad_i16_array", makeSig([], [wasmRefType(bad_array_i16)]))
    .exportFunc()
    .addBody([
      kExprI32Const, 0, kExprI32Const, length,
      kGCPrefix, kExprArrayNewData, bad_array_i16, wtf16_data
    ]);

  builder.addFunction(
      "good_i16_array", makeSig([], [wasmRefType(good_array_i16)]))
    .exportFunc()
    .addBody([
      kExprI32Const, 0, kExprI32Const, length,
      kGCPrefix, kExprArrayNewData, good_array_i16, wtf16_data
    ]);

  builder.addFunction(
      "bad_i8_array", makeSig([], [wasmRefType(bad_array_i8)]))
    .exportFunc()
    .addBody([
      kExprI32Const, 0, kExprI32Const, length,
      kGCPrefix, kExprArrayNewData, bad_array_i8, wtf8_data
    ]);

  builder.addFunction(
      "good_i8_array", makeSig([], [wasmRefType(good_array_i8)]))
    .exportFunc()
    .addBody([
      kExprI32Const, 0, kExprI32Const, length,
      kGCPrefix, kExprArrayNewData, good_array_i8, wtf8_data
    ]);

  return builder.instantiate({}, {builtins: ['js-string', 'text-decoder']});
})();

let good_a16 = instance.exports.good_i16_array();
let bad_a16 = instance.exports.bad_i16_array();
let good_a8 = instance.exports.good_i8_array();
let bad_a8 = instance.exports.bad_i8_array();

assertEquals("abc", instance.exports.use_i16_array(good_a16, 0, length));
assertEquals("abc", instance.exports.use_i8_array(good_a8, 0, length));

assertThrows(() => instance.exports.use_i16_array(bad_a16, 0, length),
             TypeError);
assertThrows(() => instance.exports.use_i8_array(bad_a8, 0, length),
             TypeError);

// Part II: Test that instantiating the module throws a LinkError when the
// string imports use incorrect types.

let array_i16;
let array_i8;
let good_array_i8;

function MakeInvalidImporterBuilder() {
  let builder = new WasmModuleBuilder();
  builder.startRecGroup();
  array_i16 = builder.addArray(kWasmI16, true, kNoSuperType, true);
  array_i8 = builder.addArray(kWasmI8, true, kNoSuperType, true);
  builder.endRecGroup();
  builder.startRecGroup();
  good_array_i8 = builder.addArray(kWasmI8, true, kNoSuperType, true);
  builder.endRecGroup();
  return builder;
}

let b1 = MakeInvalidImporterBuilder();
let b2 = MakeInvalidImporterBuilder();
let b3 = MakeInvalidImporterBuilder();
let b4 = MakeInvalidImporterBuilder();
let b5 = MakeInvalidImporterBuilder();
let b6 = MakeInvalidImporterBuilder();
let b99 = MakeInvalidImporterBuilder();

let array16ref = wasmRefNullType(array_i16);
let array8ref = wasmRefNullType(array_i8);

// These are invalid because they use array types with the right element
// type but violating the single-element-recgroup requirement.
b1.addImport('wasm:js-string', 'fromCharCodeArray',
             makeSig([array16ref, kWasmI32, kWasmI32], [kRefExtern]));
b2.addImport('wasm:text-decoder', 'decodeStringFromUTF8Array',
             makeSig([array8ref, kWasmI32, kWasmI32], [kRefExtern]));
b3.addImport('wasm:js-string', 'intoCharCodeArray',
             makeSig([kWasmExternRef, array16ref, kWasmI32], [kWasmI32]));
b4.addImport('wasm:text-encoder', 'encodeStringIntoUTF8Array',
             makeSig([kWasmExternRef, array8ref, kWasmI32], [kWasmI32]));
b5.addImport('wasm:text-encoder', 'encodeStringToUTF8Array',
             makeSig([kWasmExternRef], [wasmRefType(array_i8)]));
// This is invalid because the return type is nullable.
b6.addImport('wasm:text-encoder', 'encodeStringToUTF8Array',
             makeSig([kWasmExternRef], [wasmRefNullType(good_array_i8)]));
// One random example of a non-array-related incorrect type (incorrect result).
b99.addImport('wasm:js-string', 'charCodeAt',
             makeSig([kWasmExternRef, kWasmI32], [kWasmI64]));

let kBuiltins = { builtins: ['js-string', 'text-encoder', 'text-decoder'] };
assertThrows(() => b1.instantiate({}, kBuiltins), WebAssembly.LinkError);
assertThrows(() => b2.instantiate({}, kBuiltins), WebAssembly.LinkError);
assertThrows(() => b3.instantiate({}, kBuiltins), WebAssembly.LinkError);
assertThrows(() => b4.instantiate({}, kBuiltins), WebAssembly.LinkError);
assertThrows(() => b5.instantiate({}, kBuiltins), WebAssembly.LinkError);
assertThrows(() => b6.instantiate({}, kBuiltins), WebAssembly.LinkError);
assertThrows(() => b99.instantiate({}, kBuiltins), WebAssembly.LinkError);

(function () {
  let bytes = b99.toBuffer();
  assertTrue(WebAssembly.validate(bytes));
  // All ways to specify compile-time imports agree that one import has
  // an invalid signature.
  // (1) new WebAssembly.Module
  assertThrows(
    () => new WebAssembly.Module(bytes, kBuiltins), WebAssembly.LinkError);
  // (2) WebAssembly.validate
  assertFalse(WebAssembly.validate(bytes, kBuiltins));
  // (3) WebAssembly.compile
  assertThrowsAsync(
      WebAssembly.compile(bytes, kBuiltins), WebAssembly.LinkError);
  // (4) WebAssembly.instantiate
  assertThrowsAsync(
    WebAssembly.instantiate(bytes, {}, kBuiltins), WebAssembly.LinkError);

  // For compileStreaming/instantiateStreaming, see separate test.
})();
                                                                         node-23.7.0/deps/v8/test/mjsunit/wasm/imported-strings-streaming.js                                 0000664 0000000 0000000 00000004000 14746647661 0025315 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-imported-strings --wasm-test-streaming

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

let bad_builder = new WasmModuleBuilder();
let good_builder = new WasmModuleBuilder();
// This intentionally uses an incorrect return type to test LinkErrors.
bad_builder.addImport('wasm:js-string', 'charCodeAt',
                      makeSig([kWasmExternRef, kWasmI32], [kWasmI64]));
let charCodeAt = good_builder.addImport('wasm:js-string', 'charCodeAt',
                       makeSig([kWasmExternRef, kWasmI32], [kWasmI32]));
good_builder.addFunction('test', kSig_i_r).exportFunc().addBody([
  kExprLocalGet, 0, kExprI32Const, 0, kExprCallFunction, charCodeAt
]);

let bad = bad_builder.toBuffer();
let good = good_builder.toBuffer();
let kBuiltins = { builtins: ['js-string'] };

let message = new RegExp(
    'Imported builtin function "wasm:js-string" "charCodeAt" '+
    'has incorrect signature');

// WebAssembly.compileStreaming
assertPromiseResult(
    WebAssembly.compileStreaming(Promise.resolve(good), kBuiltins),
    // Demonstrate compilation success by showing that we can instantiate
    // the module without providing imports, and charCodeAt works.
    (module) => WebAssembly.instantiate(module).then(
        instance => assertEquals(97, instance.exports.test('abc'))),
    // Compilation failure doesn't happen.
    assertUnreachable);
assertThrowsAsync(
    WebAssembly.compileStreaming(Promise.resolve(bad), kBuiltins),
    WebAssembly.LinkError, message);

// WebAssembly.instantiateStreaming
assertPromiseResult(
    WebAssembly.instantiateStreaming(Promise.resolve(good), {}, kBuiltins),
    ({module, instance}) => assertEquals(97, instance.exports.test('abc')),
    assertUnreachable);
assertThrowsAsync(
    WebAssembly.instantiateStreaming(Promise.resolve(bad), {}, kBuiltins),
    WebAssembly.LinkError, message);
node-23.7.0/deps/v8/test/mjsunit/wasm/imported-strings.js                                           0000664 0000000 0000000 00000113311 14746647661 0023334 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-imported-strings
// For {isOneByteString}:
// Flags: --expose-externalize-string

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

let kRefExtern = wasmRefType(kWasmExternRef);

// We use "r" for nullable "externref", and "e" for non-nullable "ref extern".

let kSig_e_ii = makeSig([kWasmI32, kWasmI32], [kRefExtern]);
let kSig_e_v = makeSig([], [kRefExtern]);
let kSig_i_ri = makeSig([kWasmExternRef, kWasmI32], [kWasmI32]);
let kSig_i_rii = makeSig([kWasmExternRef, kWasmI32, kWasmI32], [kWasmI32]);
let kSig_i_rr = makeSig([kWasmExternRef, kWasmExternRef], [kWasmI32]);
let kSig_i_rri = makeSig([kWasmExternRef, kWasmExternRef, kWasmI32], [kWasmI32]);
let kSig_i_riii = makeSig([kWasmExternRef, kWasmI32, kWasmI32, kWasmI32],
                          [kWasmI32]);
let kSig_ii_riii = makeSig([kWasmExternRef, kWasmI32, kWasmI32, kWasmI32],
                           [kWasmI32, kWasmI32]);
let kSig_e_i = makeSig([kWasmI32], [kRefExtern]);
let kSig_e_rii = makeSig([kWasmExternRef, kWasmI32, kWasmI32],
                         [kRefExtern]);
let kSig_e_rr = makeSig([kWasmExternRef, kWasmExternRef], [kRefExtern]);
let kSig_e_r = makeSig([kWasmExternRef], [kRefExtern]);

let interestingStrings = [
  '',
  'ascii',
  'latin\xa91',        // Latin-1.
  '2 \ucccc b',        // Two-byte.
  'a \ud800\udc00 b',  // Proper surrogate pair.
  'a \ud800 b',        // Lone lead surrogate.
  'a \udc00 b',        // Lone trail surrogate.
  '\ud800 bc',         // Lone lead surrogate at the start.
  '\udc00 bc',         // Lone trail surrogate at the start.
  'ab \ud800',         // Lone lead surrogate at the end.
  'ab \udc00',         // Lone trail surrogate at the end.
  'a \udc00\ud800 b',  // Swapped surrogate pair.
];

function IsSurrogate(codepoint) {
  return 0xD800 <= codepoint && codepoint <= 0xDFFF
}

function HasIsolatedSurrogate(str) {
  for (let codepoint of str) {
    let value = codepoint.codePointAt(0);
    if (IsSurrogate(value)) return true;
  }
  return false;
}
function ReplaceIsolatedSurrogates(str, replacement='\ufffd') {
  let replaced = '';
  for (let codepoint of str) {
    replaced +=
      IsSurrogate(codepoint.codePointAt(0)) ? replacement : codepoint;
  }
  return replaced;
}

function encodeWtf16LE(str) {
  // String iterator coalesces surrogate pairs.
  let out = [];
  for (let i = 0; i < str.length; i++) {
    codeunit = str.charCodeAt(i);
    out.push(codeunit & 0xff)
    out.push(codeunit >> 8);
  }
  return out;
}

let kArrayI16;
let kArrayI8;
let kStringCast;
let kStringTest;
let kStringFromWtf16Array;
let kStringFromUtf8Array;
let kStringIntoUtf8Array;
let kStringToUtf8Array;
let kStringToWtf16Array;
let kStringMeasureUtf8;
let kStringFromCharCode;
let kStringFromCodePoint;
let kStringCharCodeAt;
let kStringCodePointAt;
let kStringLength;
let kStringConcat;
let kStringSubstring;
let kStringEquals;
let kStringCompare;
let kStringIndexOfImported;
let kStringToLowerCaseImported;

function MakeBuilder() {
  let builder = new WasmModuleBuilder();
  builder.startRecGroup();
  kArrayI16 = builder.addArray(kWasmI16, true, kNoSuperType, true);
  builder.endRecGroup();
  builder.startRecGroup();
  kArrayI8 = builder.addArray(kWasmI8, true, kNoSuperType, true);
  builder.endRecGroup();
  let arrayref = wasmRefNullType(kArrayI16);
  let array8ref = wasmRefNullType(kArrayI8);

  kStringCast = builder.addImport('wasm:js-string', 'cast', kSig_e_r);
  kStringTest = builder.addImport('wasm:js-string', 'test', kSig_i_r);
  kStringFromWtf16Array = builder.addImport(
      'wasm:js-string', 'fromCharCodeArray',
      makeSig([arrayref, kWasmI32, kWasmI32], [kRefExtern]));
  kStringFromUtf8Array = builder.addImport(
      'wasm:text-decoder', 'decodeStringFromUTF8Array',
      makeSig([array8ref, kWasmI32, kWasmI32], [kRefExtern]));
  kStringToWtf16Array = builder.addImport(
      'wasm:js-string', 'intoCharCodeArray',
      makeSig([kWasmExternRef, arrayref, kWasmI32], [kWasmI32]));
  kStringMeasureUtf8 =
      builder.addImport('wasm:text-encoder', 'measureStringAsUTF8', kSig_i_r);
  kStringIntoUtf8Array = builder.addImport(
      'wasm:text-encoder', 'encodeStringIntoUTF8Array',
      makeSig([kWasmExternRef, array8ref, kWasmI32], [kWasmI32]));
  kStringToUtf8Array = builder.addImport(
      'wasm:text-encoder', 'encodeStringToUTF8Array',
      makeSig([kWasmExternRef], [wasmRefType(kArrayI8)]));
  kStringFromCharCode =
      builder.addImport('wasm:js-string', 'fromCharCode', kSig_e_i);
  kStringFromCodePoint =
      builder.addImport('wasm:js-string', 'fromCodePoint', kSig_e_i);
  kStringCharCodeAt =
      builder.addImport('wasm:js-string', 'charCodeAt', kSig_i_ri);
  kStringCodePointAt =
      builder.addImport('wasm:js-string', 'codePointAt', kSig_i_ri);
  kStringLength = builder.addImport('wasm:js-string', 'length', kSig_i_r);
  kStringConcat = builder.addImport('wasm:js-string', 'concat', kSig_e_rr);
  kStringSubstring =
      builder.addImport('wasm:js-string', 'substring', kSig_e_rii);
  kStringEquals = builder.addImport('wasm:js-string', 'equals', kSig_i_rr);
  kStringCompare = builder.addImport('wasm:js-string', 'compare', kSig_i_rr);
  kStringIndexOfImported = builder.addImport('m', 'indexOf', kSig_i_rri);
  kStringToLowerCaseImported = builder.addImport('m', 'toLowerCase', kSig_r_r);

  return builder;
}

let kImports = {
  strings: interestingStrings,
  m: {
    indexOf: Function.prototype.call.bind(String.prototype.indexOf),
    toLowerCase: Function.prototype.call.bind(String.prototype.toLowerCase),
  },
};
let kBuiltins = { builtins: ["js-string", "text-decoder", "text-encoder"] };

(function TestStringCast() {
  print(arguments.callee.name);
  let builder = MakeBuilder();

  builder.addFunction("cast", kSig_e_r)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprCallFunction, kStringCast,
    ]);

  builder.addFunction("cast_null", kSig_e_v)
    .exportFunc()
    .addBody([
      kExprRefNull, kExternRefCode,
      kExprCallFunction, kStringCast,
    ]);

  let instance = builder.instantiate(kImports, kBuiltins);

  assertEquals('foo', instance.exports.cast('foo'));
  assertThrows(
      () => instance.exports.cast(123), WebAssembly.RuntimeError,
      'illegal cast');
  assertThrows(
      () => instance.exports.cast(undefined), WebAssembly.RuntimeError,
      'illegal cast');
  assertThrows(
      () => instance.exports.cast(true), WebAssembly.RuntimeError,
      'illegal cast');
  assertThrows(
      () => instance.exports.cast(null), WebAssembly.RuntimeError,
      'illegal cast');
  assertThrows(
      () => instance.exports.cast_null(), WebAssembly.RuntimeError,
      'illegal cast');
})();

(function TestStringTest() {
  print(arguments.callee.name);
  let builder = MakeBuilder();

  builder.addFunction("test", kSig_i_r)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprCallFunction, kStringTest,
    ]);

  builder.addFunction("test_null", kSig_i_v)
    .exportFunc()
    .addBody([
      kExprRefNull, kExternRefCode,
      kExprCallFunction, kStringTest,
    ]);

  let instance = builder.instantiate(kImports, kBuiltins);

  assertEquals(1, instance.exports.test("foo"));
  assertEquals(0, instance.exports.test(123));
  assertEquals(0, instance.exports.test(undefined));
  assertEquals(0, instance.exports.test(true));
  assertEquals(0, instance.exports.test(null));
  assertEquals(0, instance.exports.test_null());
})();

(function TestIndexOfImportedStrings() {
  print(arguments.callee.name);
  let builder = new MakeBuilder();

  builder.addFunction('indexOf', kSig_i_rri).exportFunc().addBody([
    kExprLocalGet, 0,
    kExprCallFunction, kStringCast,
    kExprLocalGet, 1,
    kExprCallFunction, kStringCast,
    kExprLocalGet, 2,
    kExprCallFunction, kStringIndexOfImported,
  ]);
  let instance = builder.instantiate(kImports, kBuiltins);

  assertEquals(2, instance.exports.indexOf('xxfooxx', 'foo', 0));
  assertEquals(2, instance.exports.indexOf('xxfooxx', 'foo', -2));
  assertEquals(-1, instance.exports.indexOf('xxfooxx', 'foo', 100));
  // Make sure we don't lose bits when Smi-tagging of the start position.
  assertEquals(-1, instance.exports.indexOf('xxfooxx', 'foo', 0x4000_0000));
  assertEquals(-1, instance.exports.indexOf('xxfooxx', 'foo', 0x2000_0000));
  assertEquals(
      2,
      instance.exports.indexOf(
          'xxfooxx', 'foo', 0x8000_0000));  // Negative i32.

  // Both first and second args should be non-null strings.
  assertThrows(
      () => instance.exports.indexOf('xxnullxx', null, 0),
      WebAssembly.RuntimeError, 'illegal cast');
  assertThrows(
      () => instance.exports.indexOf(12345, 234, 0), WebAssembly.RuntimeError,
      'illegal cast');
  assertThrows(
      () => instance.exports.indexOf(null, 'foo', 0), WebAssembly.RuntimeError,
      'illegal cast');
  assertThrows(
      () => instance.exports.indexOf(null, 'null', 0), WebAssembly.RuntimeError,
      'illegal cast');
})();

(function TestStringToLowerCaseImported() {
  print(arguments.callee.name);
  let builder = new MakeBuilder();

  builder.addFunction('toLowerCase', kSig_r_r).exportFunc().addBody([
    kExprLocalGet, 0,
    kExprCallFunction, kStringCast,
    kExprCallFunction, kStringToLowerCaseImported,
  ]);
  let instance = builder.instantiate(kImports, kBuiltins);

  assertEquals(
      'make this lowercase!',
      instance.exports.toLowerCase('MAKE THIS LOWERCASE!'));

  // The argument should be a non-null string.
  assertThrows(
      () => instance.exports.toLowerCase(null), WebAssembly.RuntimeError,
      'illegal cast');
  assertThrows(
      () => instance.exports.toLowerCase(123), WebAssembly.RuntimeError,
      'illegal cast');
})();

(function TestStringConst() {
  print(arguments.callee.name);
  let builder = MakeBuilder();
  for (let i = 0; i < interestingStrings.length; i++) {
    builder.addImportedGlobal('strings', i.toString(), kRefExtern, false);
    builder.addFunction("string_const" + i, kSig_e_v).exportFunc()
      .addBody([kExprGlobalGet, i]);
  }
  for (let i = 0; i < interestingStrings.length; i++) {
    builder.addGlobal(kRefExtern, false, false, [kExprGlobalGet, i])
      .exportAs("global" + i);
  }
  let instance = builder.instantiate(kImports, kBuiltins);
  for (let [i, str] of interestingStrings.entries()) {
    assertEquals(str, instance.exports["string_const" + i]());
    assertEquals(str, instance.exports["global" + i].value);
  }
})();

(function TestStringLength() {
  print(arguments.callee.name);
  let builder = MakeBuilder();

  builder.addFunction("string_length", kSig_i_r)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprCallFunction, kStringLength,
    ]);

  builder.addFunction("string_length_null", kSig_i_v)
    .exportFunc()
    .addBody([
      kExprRefNull, kExternRefCode,
      kExprCallFunction, kStringLength,
    ]);

  let instance = builder.instantiate(kImports, kBuiltins);
  for (let str of interestingStrings) {
    assertEquals(str.length, instance.exports.string_length(str));
  }

  assertThrows(() => instance.exports.string_length(null),
               WebAssembly.RuntimeError, "illegal cast");
  assertThrows(() => instance.exports.string_length_null(),
               WebAssembly.RuntimeError, "illegal cast");
})();

(function TestStringConcat() {
  print(arguments.callee.name);
  let builder = MakeBuilder();

  builder.addFunction("concat", kSig_e_rr)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprCallFunction, kStringConcat,
    ]);

  builder.addFunction("concat_null_head", kSig_e_r)
    .exportFunc()
    .addBody([
      kExprRefNull, kExternRefCode,
      kExprLocalGet, 0,
      kExprCallFunction, kStringConcat,
    ]);

  builder.addFunction("concat_null_tail", kSig_e_r)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprRefNull, kExternRefCode,
      kExprCallFunction, kStringConcat,
    ]);

  let instance = builder.instantiate(kImports, kBuiltins);

  for (let head of interestingStrings) {
    for (let tail of interestingStrings) {
      assertEquals(head + tail, instance.exports.concat(head, tail));
    }
  }

  assertThrows(() => instance.exports.concat(null, "hey"),
               WebAssembly.RuntimeError, "illegal cast");
  assertThrows(() => instance.exports.concat('hey', null),
               WebAssembly.RuntimeError, "illegal cast");
  assertThrows(() => instance.exports.concat_null_head("hey"),
               WebAssembly.RuntimeError, "illegal cast");
  assertThrows(() => instance.exports.concat_null_tail("hey"),
               WebAssembly.RuntimeError, "illegal cast");
})();

(function TestStringEq() {
  print(arguments.callee.name);
  let builder = MakeBuilder();

  builder.addFunction("eq", kSig_i_rr)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprCallFunction, kStringEquals,
    ]);

  builder.addFunction("eq_null_a", kSig_i_r)
    .exportFunc()
    .addBody([
      kExprRefNull, kExternRefCode,
      kExprLocalGet, 0,
      kExprCallFunction, kStringEquals,
    ]);

  builder.addFunction("eq_null_b", kSig_i_r)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprRefNull, kExternRefCode,
      kExprCallFunction, kStringEquals,
    ]);

  builder.addFunction("eq_both_null", kSig_i_v)
    .exportFunc()
    .addBody([
      kExprRefNull, kExternRefCode,
      kExprRefNull, kExternRefCode,
      kExprCallFunction, kStringEquals,
    ]);

  let instance = builder.instantiate(kImports, kBuiltins);

  for (let head of interestingStrings) {
    for (let tail of interestingStrings) {
      let result = (head == tail) | 0;
      assertEquals(result, instance.exports.eq(head, tail));
      assertEquals(result, instance.exports.eq(head + head, tail + tail));
    }
    assertEquals(0, instance.exports.eq_null_a(head))
    assertEquals(0, instance.exports.eq(null, head))
    assertEquals(0, instance.exports.eq(head, null))
  }

  assertEquals(1, instance.exports.eq_both_null());
  assertEquals(1, instance.exports.eq(null, null));
})();

(function TestStringViewWtf16() {
  print(arguments.callee.name);
  let builder = MakeBuilder();

  builder.addFunction("get_codeunit", kSig_i_ri)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprCallFunction, kStringCharCodeAt,
    ]);

  builder.addFunction("get_codeunit_null", kSig_i_v)
    .exportFunc()
    .addBody([
      kExprRefNull, kExternRefCode,
      kExprI32Const, 0,
      kExprCallFunction, kStringCharCodeAt,
    ]);

  builder.addFunction("get_codepoint", kSig_i_ri)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprCallFunction, kStringCodePointAt,
    ]);

  builder.addFunction("get_codepoint_null", kSig_i_v)
    .exportFunc()
    .addBody([
      kExprRefNull, kExternRefCode,
      kExprI32Const, 0,
      kExprCallFunction, kStringCodePointAt,
    ]);

  builder.addFunction("slice", kSig_e_rii)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprCallFunction, kStringSubstring,
    ]);

  builder.addFunction("slice_null", kSig_e_v)
    .exportFunc()
    .addBody([
      kExprRefNull, kExternRefCode,
      kExprI32Const, 0,
      kExprI32Const, 0,
      kExprCallFunction, kStringSubstring,
    ]);

  let instance = builder.instantiate(kImports, kBuiltins);
  for (let str of interestingStrings) {
    for (let i = 0; i < str.length; i++) {
      assertEquals(str.charCodeAt(i),
                   instance.exports.get_codeunit(str, i));
      assertEquals(str.codePointAt(i),
                   instance.exports.get_codepoint(str, i));
    }
    assertEquals(str, instance.exports.slice(str, 0, -1));
  }

  assertEquals("", instance.exports.slice("foo", 0, 0));
  assertEquals("f", instance.exports.slice("foo", 0, 1));
  assertEquals("fo", instance.exports.slice("foo", 0, 2));
  assertEquals("foo", instance.exports.slice("foo", 0, 3));
  assertEquals("foo", instance.exports.slice("foo", 0, 4));
  assertEquals("o", instance.exports.slice("foo", 1, 2));
  assertEquals("oo", instance.exports.slice("foo", 1, 3));
  assertEquals("oo", instance.exports.slice("foo", 1, 100));
  assertEquals("", instance.exports.slice("foo", 1, 0));
  assertEquals("", instance.exports.slice("foo", 3, 4));
  assertEquals("foo", instance.exports.slice("foo", 0, -1));
  assertEquals("", instance.exports.slice("foo", -1, 1));

  assertThrows(() => instance.exports.get_codeunit(null, 0),
               WebAssembly.RuntimeError, "illegal cast");
  assertThrows(() => instance.exports.get_codeunit_null(),
               WebAssembly.RuntimeError, "illegal cast");
  assertThrows(() => instance.exports.get_codeunit("", 0),
               WebAssembly.RuntimeError, "string offset out of bounds");
  assertThrows(() => instance.exports.get_codepoint(null, 0),
               WebAssembly.RuntimeError, "illegal cast");
  assertThrows(() => instance.exports.get_codepoint_null(),
               WebAssembly.RuntimeError, "illegal cast");
  assertThrows(() => instance.exports.get_codepoint("", 0),
               WebAssembly.RuntimeError, "string offset out of bounds");
  assertThrows(() => instance.exports.slice(null, 0, 0),
               WebAssembly.RuntimeError, "illegal cast");
  assertThrows(() => instance.exports.slice_null(),
               WebAssembly.RuntimeError, "illegal cast");

  // Cover runtime code path for long slices.
  const prefix = "a".repeat(10);
  const slice = "x".repeat(40);
  const suffix = "b".repeat(40);
  const input = prefix + slice + suffix;
  const start = prefix.length;
  const end = start + slice.length;
  assertEquals(slice, instance.exports.slice(input, start, end));

  // Check that we create one-byte substrings when possible.
  let onebyte = instance.exports.slice("\u1234abcABCDE", 1, 4);
  assertEquals("abc", onebyte);
  assertTrue(isOneByteString(onebyte));

  // Check that the CodeStubAssembler implementation also creates one-byte
  // substrings.
  onebyte = instance.exports.slice("\u1234abcA", 1, 4);
  assertEquals("abc", onebyte);
  assertTrue(isOneByteString(onebyte));
  // Cover the code path that checks 8 characters at a time.
  onebyte = instance.exports.slice("\u1234abcdefgh\u1234", 1, 9);
  assertEquals("abcdefgh", onebyte);  // Exactly 8 characters.
  assertTrue(isOneByteString(onebyte));
  onebyte = instance.exports.slice("\u1234abcdefghij\u1234", 1, 11);
  assertEquals("abcdefghij", onebyte);  // Longer than 8.
  assertTrue(isOneByteString(onebyte));

  // Check that the runtime code path also creates one-byte substrings.
  assertTrue(isOneByteString(
      instance.exports.slice(input + "\u1234", start, end)));
})();

(function TestStringCompare() {
  print(arguments.callee.name);
  let builder = MakeBuilder();

  builder.addFunction("compare", kSig_i_rr)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprCallFunction, kStringCompare,
    ]);

  builder.addFunction("compare_null_a", kSig_i_r)
    .exportFunc()
    .addBody([
      kExprRefNull, kExternRefCode,
      kExprLocalGet, 0,
      kExprCallFunction, kStringCompare,
    ]);

  builder.addFunction("compare_null_b", kSig_i_r)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprRefNull, kExternRefCode,
      kExprCallFunction, kStringCompare,
    ]);

  let instance = builder.instantiate(kImports, kBuiltins);
  for (let lhs of interestingStrings) {
    for (let rhs of interestingStrings) {
      const expected = lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
      assertEquals(expected, instance.exports.compare(lhs, rhs));
    }
  }

  assertThrows(() => instance.exports.compare(null, "abc"),
               WebAssembly.RuntimeError, "illegal cast");
  assertThrows(() => instance.exports.compare("abc", null),
               WebAssembly.RuntimeError, "illegal cast");
  assertThrows(() => instance.exports.compare_null_a("abc"),
               WebAssembly.RuntimeError, "illegal cast");
  assertThrows(() => instance.exports.compare_null_b("abc"),
               WebAssembly.RuntimeError, "illegal cast");
})();

(function TestStringCompareNullCheckStaticType() {
  print(arguments.callee.name);
  let builder = MakeBuilder();

  // Use a mix of nullable and non-nullable input types to the compare.
  builder.addFunction("compareLhsNullable",
                      makeSig([kWasmExternRef, kWasmExternRef], [kWasmI32]))
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprRefAsNonNull,
      kExprLocalGet, 1,
      kExprCallFunction, kStringCompare,
    ]);

  builder.addFunction("compareRhsNullable",
                      makeSig([kWasmExternRef, kWasmExternRef], [kWasmI32]))
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprRefAsNonNull,
      kExprCallFunction, kStringCompare,
    ]);

  let instance = builder.instantiate(kImports, kBuiltins);
  assertThrows(() => instance.exports.compareLhsNullable(null, "abc"),
               WebAssembly.RuntimeError, "dereferencing a null pointer");
  assertThrows(() => instance.exports.compareLhsNullable("abc", null),
               WebAssembly.RuntimeError, "illegal cast");
  assertThrows(() => instance.exports.compareRhsNullable(null, "abc"),
               WebAssembly.RuntimeError, "illegal cast");
  assertThrows(() => instance.exports.compareRhsNullable("abc", null),
               WebAssembly.RuntimeError, "dereferencing a null pointer");
})();

(function TestStringFromCodePoint() {
  print(arguments.callee.name);
  let builder = MakeBuilder();
  builder.addFunction("asString", kSig_e_i)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprCallFunction, kStringFromCodePoint,
    ]);

  let instance = builder.instantiate(kImports, kBuiltins);
  for (let char of "Az1#\n\ucccc\ud800\udc00") {
    assertEquals(char, instance.exports.asString(char.codePointAt(0)));
  }
  for (let codePoint of [0x110000, 0xFFFFFFFF, -1]) {
    assertThrows(() => instance.exports.asString(codePoint),
                 WebAssembly.RuntimeError, /Invalid code point -?[0-9]+/);
  }
})();

(function TestStringFromCharCode() {
  print(arguments.callee.name);
  let builder = MakeBuilder();
  builder.addFunction("asString", kSig_e_i)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprCallFunction, kStringFromCharCode,
    ]);

  let instance = builder.instantiate(kImports, kBuiltins);
  let inputs = "Az1#\n\ucccc\ud800\udc00";
  for (let i = 0; i < inputs.length; i++) {
    assertEquals(inputs.charAt(i),
                 instance.exports.asString(inputs.charCodeAt(i)));
  }
})();

function encodeWtf8(str) {
  // String iterator coalesces surrogate pairs.
  let out = [];
  for (let codepoint of str) {
    codepoint = codepoint.codePointAt(0);
    if (codepoint <= 0x7f) {
      out.push(codepoint);
    } else if (codepoint <= 0x7ff) {
      out.push(0xc0 | (codepoint >> 6));
      out.push(0x80 | (codepoint & 0x3f));
    } else if (codepoint <= 0xffff) {
      out.push(0xe0 | (codepoint >> 12));
      out.push(0x80 | ((codepoint >> 6) & 0x3f));
      out.push(0x80 | (codepoint & 0x3f));
    } else if (codepoint <= 0x10ffff) {
      out.push(0xf0 | (codepoint >> 18));
      out.push(0x80 | ((codepoint >> 12) & 0x3f));
      out.push(0x80 | ((codepoint >> 6) & 0x3f));
      out.push(0x80 | (codepoint & 0x3f));
    } else {
      throw new Error("bad codepoint " + codepoint);
    }
  }
  return out;
}

function makeWtf8TestDataSegment() {
  let data = []
  let valid = {};
  let invalid = {};

  for (let str of interestingStrings) {
    let bytes = encodeWtf8(str);
    valid[str] = { offset: data.length, length: bytes.length };
    for (let byte of bytes) {
      data.push(byte);
    }
  }
  let invalid_inputs = [
    'trailing high byte \xa9',
    'interstitial high \xa9 byte',
    'invalid \xc0 byte',
    'invalid three-byte \xed\xd0\x80',
    'surrogate \xed\xa0\x80\xed\xb0\x80 pair'
  ];
  let invalid_replaced = [
    'trailing high byte \uFFFD',
    'interstitial high \uFFFD byte',
    'invalid \uFFFD byte',
    'invalid three-byte \uFFFD\u0400',
    'surrogate \uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD pair'
  ];
  for (let i = 0; i < invalid_inputs.length; i++) {
    let bytes = invalid_inputs[i];
    invalid[bytes] = {
      offset: data.length,
      length: bytes.length,
      replaced: invalid_replaced[i]
    };
    for (let i = 0; i < bytes.length; i++) {
      data.push(bytes.charCodeAt(i));
    }
  }
  return { valid, invalid, data: Uint8Array.from(data) };
};

(function TestStringNewUtf8Array() {
  print(arguments.callee.name);
  let builder = MakeBuilder();
  let data = makeWtf8TestDataSegment();
  let data_index = builder.addPassiveDataSegment(data.data);

  let ascii_data_index =
      builder.addPassiveDataSegment(Uint8Array.from(encodeWtf8("ascii")));

  let make_i8_array = builder.addFunction(
      "make_i8_array", makeSig([], [wasmRefType(kArrayI8)]))
    .addBody([
      ...wasmI32Const(0),
      ...wasmI32Const(data.data.length),
      kGCPrefix, kExprArrayNewData, kArrayI8, data_index
    ]).index;

  builder.addFunction("new_utf8", kSig_e_ii)
    .exportFunc()
    .addBody([
      kExprCallFunction, make_i8_array,
      kExprLocalGet, 0, kExprLocalGet, 1,
      kExprCallFunction, kStringFromUtf8Array,
    ]);

  builder.addFunction("bounds_check", kSig_e_ii)
    .exportFunc()
    .addBody([
      ...wasmI32Const(0),
      ...wasmI32Const("ascii".length),
      kGCPrefix, kExprArrayNewData, kArrayI8, ascii_data_index,
      kExprLocalGet, 0, kExprLocalGet, 1,
      kExprCallFunction, kStringFromUtf8Array,
    ]);

  builder.addFunction("null_array", kSig_e_v).exportFunc()
    .addBody([
      kExprRefNull, kArrayI8,
      kExprI32Const, 0, kExprI32Const, 0,
      kExprCallFunction, kStringFromUtf8Array,
    ]);

  let instance = builder.instantiate(kImports, kBuiltins);
  for (let [str, {offset, length}] of Object.entries(data.valid)) {
    let start = offset;
    let end = offset + length;
    if (HasIsolatedSurrogate(str)) {
      // Isolated surrogates have the three-byte pattern ED [A0,BF] [80,BF].
      // When the sloppy decoder gets to the second byte, it will reject
      // the sequence, and then retry parsing at the second byte.
      // Seeing the second byte can't start a sequence, it replaces the
      // second byte and continues with the next, which also can't start
      // a sequence.  The result is that one isolated surrogate is replaced
      // by three U+FFFD codepoints.
      assertEquals(ReplaceIsolatedSurrogates(str, '\ufffd\ufffd\ufffd'),
                   instance.exports.new_utf8(start, end));
    } else {
      assertEquals(str, instance.exports.new_utf8(start, end));
    }
  }
  for (let [str, {offset, length, replaced}] of Object.entries(data.invalid)) {
    let start = offset;
    let end = offset + length;
    assertEquals(replaced, instance.exports.new_utf8(start, end));
  }

  assertEquals("ascii", instance.exports.bounds_check(0, "ascii".length));
  assertEquals("", instance.exports.bounds_check("ascii".length,
                                                 "ascii".length));
  assertEquals("i", instance.exports.bounds_check("ascii".length - 1,
                                                  "ascii".length));
  assertThrows(() => instance.exports.bounds_check(0, 100),
               WebAssembly.RuntimeError, "array element access out of bounds");
  assertThrows(() => instance.exports.bounds_check(0, -1),
               WebAssembly.RuntimeError, "array element access out of bounds");
  assertThrows(() => instance.exports.bounds_check(-1, 0),
               WebAssembly.RuntimeError, "array element access out of bounds");
  assertThrows(() => instance.exports.bounds_check("ascii".length,
                                                   "ascii".length + 1),
               WebAssembly.RuntimeError, "array element access out of bounds");
  assertThrows(() => instance.exports.null_array(),
               WebAssembly.RuntimeError, "dereferencing a null pointer");
})();

function encodeWtf16LE(str) {
  // String iterator coalesces surrogate pairs.
  let out = [];
  for (let i = 0; i < str.length; i++) {
    codeunit = str.charCodeAt(i);
    out.push(codeunit & 0xff)
    out.push(codeunit >> 8);
  }
  return out;
}

function makeWtf16TestDataSegment(strings) {
  let data = []
  let valid = {};

  for (let str of strings) {
    valid[str] = { offset: data.length, length: str.length };
    for (let byte of encodeWtf16LE(str)) {
      data.push(byte);
    }
  }

  return { valid, data: Uint8Array.from(data) };
};

(function TestStringNewWtf16Array() {
  print(arguments.callee.name);
  let builder = MakeBuilder();

  // string.new_wtf16_array switches to a different implementation (runtime
  // instead of Torque) for more than 32 characters, so provide some coverage
  // for that case.
  let strings = interestingStrings.concat([
    "String with more than 32 characters, all of which are ASCII",
    "Two-byte string with more than 32 characters \ucccc \ud800\udc00 \xa9?"
  ]);

  let data = makeWtf16TestDataSegment(strings);
  let data_index = builder.addPassiveDataSegment(data.data);
  let ascii_data_index =
      builder.addPassiveDataSegment(Uint8Array.from(encodeWtf16LE("ascii")));

  let make_i16_array = builder.addFunction(
      "make_i16_array", makeSig([], [wasmRefType(kArrayI16)]))
    .addBody([
      ...wasmI32Const(0),
      ...wasmI32Const(data.data.length / 2),
      kGCPrefix, kExprArrayNewData, kArrayI16, data_index
    ]).index;

  builder.addFunction("new_wtf16", kSig_e_ii)
    .exportFunc()
    .addBody([
      kExprCallFunction, make_i16_array,
      kExprLocalGet, 0, kExprLocalGet, 1,
      kExprCallFunction, kStringFromWtf16Array,
    ]);

  builder.addFunction("bounds_check", kSig_e_ii)
    .exportFunc()
    .addBody([
      ...wasmI32Const(0),
      ...wasmI32Const("ascii".length),
      kGCPrefix, kExprArrayNewData, kArrayI16, ascii_data_index,
      kExprLocalGet, 0, kExprLocalGet, 1,
      kExprCallFunction, kStringFromWtf16Array,
    ]);

  builder.addFunction("null_array", kSig_e_v).exportFunc()
    .addBody([
      kExprRefNull, kArrayI16,
      kExprI32Const, 0, kExprI32Const, 0,
      kExprCallFunction, kStringFromWtf16Array,
    ]);

  let instance = builder.instantiate(kImports, kBuiltins);
  for (let [str, {offset, length}] of Object.entries(data.valid)) {
    let start = offset / 2;
    let end = start + length;
    assertEquals(str, instance.exports.new_wtf16(start, end));
  }

  assertEquals("ascii", instance.exports.bounds_check(0, "ascii".length));
  assertEquals("", instance.exports.bounds_check("ascii".length,
                                                 "ascii".length));
  assertEquals("i", instance.exports.bounds_check("ascii".length - 1,
                                                  "ascii".length));
  assertThrows(() => instance.exports.bounds_check(0, 100),
               WebAssembly.RuntimeError, "array element access out of bounds");
  assertThrows(() => instance.exports.bounds_check("ascii".length,
                                                   "ascii".length + 1),
               WebAssembly.RuntimeError, "array element access out of bounds");
  assertThrows(() => instance.exports.null_array(),
               WebAssembly.RuntimeError, "dereferencing a null pointer");
})();

(function TestStringEncodeWtf16Array() {
  print(arguments.callee.name);
  let builder = MakeBuilder();

  // Allocate an array and encode into it.  Then decode it.
  // (str, length, offset) -> str
  builder.addFunction("encode", kSig_e_rii)
    .exportFunc()
    .addLocals(wasmRefNullType(kArrayI16), 1)
    .addLocals(kWasmI32, 1)
    .addBody([
      // Allocate buffer.
      kExprLocalGet, 1,
      kGCPrefix, kExprArrayNewDefault, kArrayI16,
      kExprLocalSet, 3,

      // Write buffer, store number of code units written.
      kExprLocalGet, 0,
      kExprLocalGet, 3,
      kExprLocalGet, 2,
      kExprCallFunction, kStringToWtf16Array,
      kExprLocalSet, 4,

      // Read buffer.
      kExprLocalGet, 3,
      kExprLocalGet, 2,
      kExprLocalGet, 2, kExprLocalGet, 4, kExprI32Add,
      kExprCallFunction, kStringFromWtf16Array,
    ]);

  builder.addFunction("encode_null_string", kSig_i_v)
    .exportFunc()
    .addBody([
      kExprRefNull, kExternRefCode,
      kExprI32Const, 0, kGCPrefix, kExprArrayNewDefault, kArrayI16,
      kExprI32Const, 0,
      kExprCallFunction, kStringToWtf16Array,
    ]);

  builder.addFunction("encode_null_array", kSig_i_v)
    .exportFunc()
    .addBody([
      kExprI32Const, 0, kGCPrefix, kExprArrayNewDefault, kArrayI16,
      kExprI32Const, 0, kExprI32Const, 0,
      kExprCallFunction, kStringFromWtf16Array,
      kExprRefNull, kArrayI16,
      kExprI32Const, 0,
      kExprCallFunction, kStringToWtf16Array,
    ]);

  let instance = builder.instantiate(kImports, kBuiltins);
  for (let str of interestingStrings) {
    assertEquals(str, instance.exports.encode(str, str.length, 0));
    assertEquals(str, instance.exports.encode(str, str.length + 20, 10));
  }

  assertThrows(() => instance.exports.encode(null, 0, 0),
               WebAssembly.RuntimeError, "illegal cast");
  assertThrows(() => instance.exports.encode_null_array(),
               WebAssembly.RuntimeError, "dereferencing a null pointer");
  assertThrows(() => instance.exports.encode_null_string(),
               WebAssembly.RuntimeError, "illegal cast");

  for (let str of interestingStrings) {
    let message = "array element access out of bounds";
    assertThrows(() => instance.exports.encode(str, str.length, 1),
                 WebAssembly.RuntimeError, message);
  }
})();

(function TestStringMeasureUtf8() {
  print(arguments.callee.name);
  let builder = MakeBuilder();

  builder.addFunction("string_measure_utf8", kSig_i_r)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprCallFunction, kStringMeasureUtf8,
    ]);

  builder.addFunction("string_measure_utf8_null", kSig_i_v)
    .exportFunc()
    .addBody([
      kExprRefNull, kExternRefCode,
      kExprCallFunction, kStringMeasureUtf8,
    ]);

  let instance = builder.instantiate(kImports, kBuiltins);
  for (let str of interestingStrings) {
    let wtf8 = encodeWtf8(str);
    assertEquals(wtf8.length, instance.exports.string_measure_utf8(str));
  }

  assertThrows(() => instance.exports.string_measure_utf8_null(),
               WebAssembly.RuntimeError, "illegal cast");
})();

(function TestStringEncodeUtf8Array() {
  print(arguments.callee.name);
  let builder = MakeBuilder();

  // Allocate an array that's exactly the expected size, and encode
  // into it.  Then decode it.
  // (str, length, offset=0) -> str
  builder.addFunction("encode_utf8", kSig_e_rii)
    .exportFunc()
    .addLocals(wasmRefNullType(kArrayI8), 1)
    .addLocals(kWasmI32, 1)
    .addBody([
      // Allocate buffer.
      kExprLocalGet, 1,
      kGCPrefix, kExprArrayNewDefault, kArrayI8,
      kExprLocalSet, 3,

      // Write buffer, store number of bytes written.
      kExprLocalGet, 0,
      kExprLocalGet, 3,
      kExprLocalGet, 2,
      kExprCallFunction, kStringIntoUtf8Array,
      kExprLocalSet, 4,

      // Read buffer.
      kExprLocalGet, 3,
      kExprLocalGet, 2,
      kExprLocalGet, 2, kExprLocalGet, 4, kExprI32Add,
      kExprCallFunction, kStringFromUtf8Array,
    ]);


  builder.addFunction("encode_null_string", kSig_i_v)
    .exportFunc()
    .addBody([
        kExprRefNull, kExternRefCode,
        kExprI32Const, 0, kGCPrefix, kExprArrayNewDefault, kArrayI8,
        kExprI32Const, 0,
        kExprCallFunction, kStringIntoUtf8Array,
      ]);
  builder.addFunction("encode_null_array", kSig_i_v)
    .exportFunc()
    .addBody([
        kExprI32Const, 0, kGCPrefix, kExprArrayNewDefault, kArrayI8,
        kExprI32Const, 0, kExprI32Const, 0,
        kExprCallFunction, kStringFromUtf8Array,
        kExprRefNull, kArrayI8,
        kExprI32Const, 0,
        kExprCallFunction, kStringIntoUtf8Array,
      ]);

  let instance = builder.instantiate(kImports, kBuiltins);

  for (let str of interestingStrings) {
    let replaced = ReplaceIsolatedSurrogates(str);
    if (!HasIsolatedSurrogate(str)) assertEquals(str, replaced);
    let wtf8 = encodeWtf8(replaced);
    assertEquals(replaced,
                 instance.exports.encode_utf8(str, wtf8.length, 0));
    assertEquals(replaced,
                 instance.exports.encode_utf8(str, wtf8.length + 20, 10));
  }

  assertThrows(() => instance.exports.encode_null_array(),
               WebAssembly.RuntimeError, "dereferencing a null pointer");
  assertThrows(() => instance.exports.encode_null_string(),
               WebAssembly.RuntimeError, "illegal cast");

  for (let str of interestingStrings) {
    let wtf8 = encodeWtf8(str);
    let message = "array element access out of bounds";
    assertThrows(() => instance.exports.encode_utf8(str, wtf8.length, 1),
                 WebAssembly.RuntimeError, message);
  }
})();

(function TestStringToUtf8Array() {
  print(arguments.callee.name);
  let builder = MakeBuilder();

  // Convert the string to an array, then decode it back.
  builder.addFunction("encode_utf8", kSig_e_r)
    .exportFunc()
    .addLocals(wasmRefNullType(kArrayI8), 1)
    .addBody([
      kExprLocalGet, 0,
      kExprCallFunction, kStringToUtf8Array,
      kExprLocalTee, 1,

      kExprI32Const, 0,  // start
      kExprLocalGet, 1, kGCPrefix, kExprArrayLen,  // end
      kExprCallFunction, kStringFromUtf8Array,
    ]);

  let sig_a8_v = makeSig([], [wasmRefType(kArrayI8)]);
  builder.addFunction("encode_null_string", sig_a8_v)
    .exportFunc()
    .addBody([
        kExprRefNull, kExternRefCode,
        kExprCallFunction, kStringToUtf8Array,
      ]);

  let instance = builder.instantiate(kImports, kBuiltins);

  for (let str of interestingStrings) {
    let replaced = ReplaceIsolatedSurrogates(str);
    if (!HasIsolatedSurrogate(str)) assertEquals(str, replaced);
    let wtf8 = encodeWtf8(replaced);
    assertEquals(replaced,
                 instance.exports.encode_utf8(str, wtf8.length, 0));
    assertEquals(replaced,
                 instance.exports.encode_utf8(str, wtf8.length + 20, 10));
  }

  assertThrows(() => instance.exports.encode_null_string(),
               WebAssembly.RuntimeError, "illegal cast");
})();
                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/wasm/incrementer.wasm                                              0000664 0000000 0000000 00000000056 14746647661 0022671 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                         asm   ` 	increment  
	   Aj                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/wasm/indirect-call-non-zero-table.js                               0000664 0000000 0000000 00000016104 14746647661 0025370 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function IndirectCallToNonZeroTable() {
  print(arguments.callee.name);

  const builder = new WasmModuleBuilder();
  const placeholder = builder.addTable(kWasmAnyFunc, 3).index;
  const table1 = builder.addTable(kWasmAnyFunc, 3).index;
  const table2 = builder.addTable(kWasmAnyFunc, 5).index;
  const sig_index = builder.addType(kSig_i_v);
  const other_sig = builder.addType(kSig_i_i);

  const v1 = 16;
  const v2 = 26;
  const v3 = 36;
  const v4 = 46;
  const v5 = 56;

  const f_unreachable = builder.addFunction('unreachable', sig_index)
    .addBody([kExprUnreachable]).index;
  const f1 = builder.addFunction('f1', sig_index)
    .addBody([kExprI32Const, v1])
    .index;
  const f2 = builder.addFunction('f2', sig_index)
    .addBody([kExprI32Const, v2])
    .index;
  const f3 = builder.addFunction('f3', sig_index)
    .addBody([kExprI32Const, v3])
    .index;
  const f4 = builder.addFunction('f4', sig_index)
    .addBody([kExprI32Const, v4])
    .index;
  const f5 = builder.addFunction('f5', sig_index)
    .addBody([kExprI32Const, v5])
    .index;

  builder.addFunction('call1', kSig_i_i)
    .addBody([kExprLocalGet, 0,   // function index
      kExprCallIndirect, sig_index, table1])
    .exportAs('call1');
  builder.addFunction('return_call1', kSig_i_i)
    .addBody([kExprLocalGet, 0,   // function index
      kExprReturnCallIndirect, sig_index, table1])
    .exportAs('return_call1');
  builder.addFunction('call2', kSig_i_i)
    .addBody([kExprLocalGet, 0,   // function index
      kExprCallIndirect, sig_index, table2])
    .exportAs('call2');
  builder.addFunction('return_call2', kSig_i_i)
    .addBody([kExprLocalGet, 0,   // function index
      kExprReturnCallIndirect, sig_index, table2])
    .exportAs('return_call2');

  builder.addFunction('call_invalid_sig', kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 0,   // function index + param
      kExprCallIndirect, other_sig, table2])
    .exportAs('call_invalid_sig');
  builder.addFunction('return_call_invalid_sig', kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 0,   // function index + param
      kExprReturnCallIndirect, other_sig, table2])
    .exportAs('return_call_invalid_sig');

  // We want to crash if we call through the table with index 0.
  builder.addActiveElementSegment(placeholder, wasmI32Const(0),
    [f_unreachable, f_unreachable, f_unreachable]);
  builder.addActiveElementSegment(table1, wasmI32Const(0),
                                  [f1, f2, f3]);
  // Keep one slot in table2 uninitialized. We should trap if we call it.
  builder.addActiveElementSegment(table2, wasmI32Const(1),
    [f_unreachable, f_unreachable, f4, f5]);

  const instance = builder.instantiate();

  assertEquals(v1, instance.exports.call1(0));
  assertEquals(v2, instance.exports.call1(1));
  assertEquals(v3, instance.exports.call1(2));
  assertTraps(kTrapTableOutOfBounds, () => instance.exports.call1(3));
  assertEquals(v1, instance.exports.return_call1(0));
  assertEquals(v2, instance.exports.return_call1(1));
  assertEquals(v3, instance.exports.return_call1(2));
  assertTraps(kTrapTableOutOfBounds, () => instance.exports.return_call1(3));

  // Try to call through the uninitialized table entry.
  assertTraps(kTrapFuncSigMismatch, () => instance.exports.call2(0));
  assertEquals(v4, instance.exports.call2(3));
  assertEquals(v5, instance.exports.call2(4));
  assertTraps(kTrapFuncSigMismatch,
    () => instance.exports.call_invalid_sig(4));
  assertTraps(kTrapFuncSigMismatch, () => instance.exports.return_call2(0));
  assertEquals(v4, instance.exports.return_call2(3));
  assertEquals(v5, instance.exports.return_call2(4));
  assertTraps(kTrapFuncSigMismatch,
    () => instance.exports.return_call_invalid_sig(4));
})();

(function IndirectCallToImportedNonZeroTable() {
  print(arguments.callee.name);

  const table_size = 10;
  const placeholder = new WebAssembly.Table(
    { initial: table_size, maximum: table_size, element: "anyfunc" });
  const table = new WebAssembly.Table(
    { initial: table_size, maximum: table_size, element: "anyfunc" });

  const builder = new WasmModuleBuilder();
  builder.addImportedTable("m", "placeholder", table_size, table_size);
  const t1 = builder.addImportedTable("m", "table", table_size, table_size);

  // We initialize the module twice and put the function f1 in the table at
  // the index defined by {g}. Thereby we can initialize the table at different
  // slots for different instances. The function f1 also returns {g} so that we
  // can see that actually different functions get called.
  const g = builder.addImportedGlobal("m", "base", kWasmI32);

  const sig_index = builder.addType(kSig_i_v);
  const f1 = builder.addFunction("foo", sig_index)
    .addBody([kExprGlobalGet, g, kExprI32Const, 12, kExprI32Add]);

  builder.addFunction('call', kSig_i_i)
    .addBody([kExprLocalGet, 0,   // function index
      kExprCallIndirect, sig_index, t1])
    .exportAs('call');

  builder.addActiveElementSegment(t1, [kExprGlobalGet, g], [f1.index]);
  const base1 = 3;
  const base2 = 5;

  const instance1 = builder.instantiate({
    m: {
      placeholder: placeholder,
      table: table,
      base: base1
    }
  });

  const instance2 = builder.instantiate({
    m: {
      placeholder: placeholder,
      table: table,
      base: base2
    }
  });

  assertEquals(base1 + 12, instance1.exports.call(base1));
  assertEquals(base2 + 12, instance1.exports.call(base2));
  assertEquals(base1 + 12, instance2.exports.call(base1));
  assertEquals(base2 + 12, instance2.exports.call(base2));
})();

function js_div(a, b) { return (a / b) | 0; }

(function CallImportedFunction() {
  let kTableSize = 10;
  print(arguments.callee.name);

  var builder = new WasmModuleBuilder();

  let div = builder.addImport("q", "js_div", kSig_i_ii);
  builder.addImportedTable("q", "placeholder", kTableSize, kTableSize);
  let table_index = builder.addImportedTable("q", "table", kTableSize,
                                             kTableSize);
  let g = builder.addImportedGlobal("q", "base", kWasmI32);

  let sig_index = builder.addType(kSig_i_ii);
  builder.addFunction("placeholder", sig_index)
    .addBody([kExprLocalGet, 0]);

  builder.addActiveElementSegment(table_index, [kExprGlobalGet, g], [div]);
  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprI32Const, 55,  // --
      kExprLocalGet, 0,   // --
      kExprLocalGet, 1,   // --
      kExprCallIndirect, 0, table_index])  // --
    .exportAs("main");

  let m = new WebAssembly.Module(builder.toBuffer());

  let table = new WebAssembly.Table({
    element: "anyfunc",
    initial: kTableSize,
    maximum: kTableSize
  });
  let placeholder = new WebAssembly.Table({
    element: "anyfunc",
    initial: kTableSize,
    maximum: kTableSize
  });

  let instance = new WebAssembly.Instance(m, {
    q: {
      base: 0, table: table, placeholder: placeholder,
      js_div: js_div
    }
  });

  assertEquals(13, instance.exports.main(4, 0));
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/wasm/indirect-calls.js                                             0000664 0000000 0000000 00000015661 14746647661 0022730 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function Test1() {
  print("Test1...");
  var module = (function () {
    var builder = new WasmModuleBuilder();

    var sig_index = builder.addType(kSig_i_ii);
    builder.addImport("q", "add", sig_index);
    var f = builder.addFunction("add", sig_index)
      .addBody([
        kExprLocalGet, 0, kExprLocalGet, 1, kExprCallFunction, 0
      ]);
    print("internal add index = " + f.index);
    builder.addFunction("sub", sig_index)
      .addBody([
        kExprLocalGet, 0,             // --
        kExprLocalGet, 1,             // --
        kExprI32Sub,                  // --
      ]);
    builder.addFunction("main", kSig_i_iii)
      .addBody([
        kExprLocalGet, 1,
        kExprLocalGet, 2,
        kExprLocalGet, 0,
        kExprCallIndirect, sig_index, kTableZero
      ])
      .exportFunc()
    builder.appendToTable([1, 2, 3]);

    return builder.instantiate({q: {add: function(a, b) {
      print("  --extadd");
      return a + b | 0;
    }}});
  })();

  // Check the module exists.
  assertFalse(module === undefined);
  assertFalse(module === null);
  assertFalse(module === 0);

  assertEquals("object", typeof module.exports);
  assertEquals("function", typeof module.exports.main);

  print(" --x1--");
  assertEquals(19, module.exports.main(0, 12, 7));
  print(" --y1--");
  assertEquals(5, module.exports.main(1, 12, 7));
  print(" --z1--");
  assertTraps(kTrapFuncSigMismatch, () => module.exports.main(2, 12, 33));
  print(" --w1--");
  assertTraps(kTrapTableOutOfBounds, () => module.exports.main(3, 12, 33));
})();

(function Test2() {
  print("Test2...");
  var module = (function () {
    var builder = new WasmModuleBuilder();

    var sig_i_ii = builder.addType(kSig_i_ii);
    var sig_i_i = builder.addType(kSig_i_i);
    var mul = builder.addImport("q", "mul", sig_i_ii);
    var add = builder.addFunction("add", sig_i_ii)
        .addBody([
          kExprLocalGet, 0,  // --
          kExprLocalGet, 1,  // --
          kExprI32Add        // --
        ]);
    var popcnt = builder.addFunction("popcnt", sig_i_i)
        .addBody([
          kExprLocalGet, 0,  // --
          kExprI32Popcnt     // --
        ]);
    var main = builder.addFunction("main", kSig_i_iii)
        .addBody([
          kExprLocalGet, 1,
          kExprLocalGet, 2,
          kExprLocalGet, 0,
          kExprCallIndirect, sig_i_ii, kTableZero
        ])
        .exportFunc();
    builder.appendToTable([mul, add.index, popcnt.index, main.index]);

    return builder.instantiate({q: {mul: function(a, b) { return a * b | 0; }}});
  })();

  print(" --x2--");
  assertEquals(-6, module.exports.main(0, -2, 3));
  print(" --y2--");
  assertEquals(99, module.exports.main(1, 22, 77));
  print(" --z2--");
  assertTraps(kTrapFuncSigMismatch, () => module.exports.main(2, 12, 33));
  print(" --q2--");
  assertTraps(kTrapFuncSigMismatch, () => module.exports.main(3, 12, 33));
  print(" --t2--");
  assertTraps(kTrapTableOutOfBounds, () => module.exports.main(4, 12, 33));
})();


function AddFunctions(builder) {
  var mul = builder.addFunction("mul", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,  // --
      kExprLocalGet, 1,  // --
      kExprI32Mul        // --
    ]);
  var add = builder.addFunction("add", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,  // --
      kExprLocalGet, 1,  // --
      kExprI32Add        // --
    ]);
  var sub = builder.addFunction("sub", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,  // --
      kExprLocalGet, 1,  // --
      kExprI32Sub        // --
    ]);
  return {mul: mul, add: add, sub: sub};
}


(function Test3() {
  print("Test3...");
  var module = (function () {
    var builder = new WasmModuleBuilder();

    var f = AddFunctions(builder);
    builder.addFunction("main", kSig_i_ii)
      .addBody([
        kExprI32Const, 33,  // --
        kExprLocalGet, 0,   // --
        kExprLocalGet, 1,   // --
        kExprCallIndirect, 0, kTableZero])  // --
      .exportAs("main");

    builder.appendToTable([f.mul.index, f.add.index, f.sub.index]);

    return builder.instantiate();
  })();

  assertEquals(33, module.exports.main(1, 0));
  assertEquals(66, module.exports.main(2, 0));
  assertEquals(34, module.exports.main(1, 1));
  assertEquals(35, module.exports.main(2, 1));
  assertEquals(32, module.exports.main(1, 2));
  assertEquals(31, module.exports.main(2, 2));
  assertTraps(kTrapTableOutOfBounds, () => module.exports.main(12, 3));
})();

(function ConstBaseTest() {
  print("ConstBaseTest...");
  function instanceWithTable(base, length) {
    var builder = new WasmModuleBuilder();

    var f = AddFunctions(builder);
    builder.addFunction("main", kSig_i_ii)
      .addBody([
        kExprI32Const, 33,  // --
        kExprLocalGet, 0,   // --
        kExprLocalGet, 1,   // --
        kExprCallIndirect, 0, kTableZero])  // --
      .exportAs("main");

    builder.setTableBounds(length, length);
    builder.addActiveElementSegment(0, wasmI32Const(base),
                                    [f.add.index, f.sub.index, f.mul.index]);

    return builder.instantiate();
  }

  for (var i = 0; i < 5; i++) {
    print(" base = " + i);
    var module = instanceWithTable(i, 10);
    main = module.exports.main;
    for (var j = 0; j < i; j++) {
      assertTraps(kTrapFuncSigMismatch, "main(12, " + j + ")");
    }
    assertEquals(34, main(1, i + 0));
    assertEquals(35, main(2, i + 0));
    assertEquals(32, main(1, i + 1));
    assertEquals(31, main(2, i + 1));
    assertEquals(33, main(1, i + 2));
    assertEquals(66, main(2, i + 2));
    assertTraps(kTrapTableOutOfBounds, () => main(12, 10));
  }
})();

(function GlobalBaseTest() {
  print("GlobalBaseTest...");

  var builder = new WasmModuleBuilder();

  var f = AddFunctions(builder);
  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprI32Const, 33,  // --
      kExprLocalGet, 0,   // --
      kExprLocalGet, 1,   // --
      kExprCallIndirect, 0, kTableZero])  // --
    .exportAs("main");

  builder.setTableBounds(10, 10);
  var g = builder.addImportedGlobal("fff", "base", kWasmI32);
  builder.addActiveElementSegment(0, [kExprGlobalGet, g],
                                  [f.mul.index, f.add.index, f.sub.index]);

  var module = new WebAssembly.Module(builder.toBuffer());

  for (var i = 0; i < 5; i++) {
    print(" base = " + i);
    var instance = new WebAssembly.Instance(module, {fff: {base: i}});
    main = instance.exports.main;
    for (var j = 0; j < i; j++) {
      assertTraps(kTrapFuncSigMismatch, "main(12, " + j + ")");
    }
    assertEquals(33, main(1, i + 0));
    assertEquals(66, main(2, i + 0));
    assertEquals(34, main(1, i + 1));
    assertEquals(35, main(2, i + 1));
    assertEquals(32, main(1, i + 2));
    assertEquals(31, main(2, i + 2));
    assertTraps(kTrapTableOutOfBounds, () => main(12, 10));
  }
})();
                                                                               node-23.7.0/deps/v8/test/mjsunit/wasm/indirect-sig-mismatch.js                                      0000664 0000000 0000000 00000007466 14746647661 0024223 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

const kTableSize = 3;

var m_i_v;
var m_i_i;
var m_i_ii;

(function BuildExportedMethods() {
  print("BuildingExportedMethods...");
  let builder = new WasmModuleBuilder();

  let sig_v_v = builder.addType(kSig_v_v);
  let sig_i_ii = builder.addType(kSig_i_ii);
  let sig_i_i = builder.addType(kSig_i_i);
  let sig_i_v = builder.addType(kSig_i_v);

  print("exported[i_v]  = " + sig_i_v);
  print("exported[i_i]  = " + sig_i_i);
  print("exported[i_ii] = " + sig_i_ii);

  builder.addFunction("", sig_i_v)
    .addBody([
      kExprI32Const, 41])  // --
    .exportAs("m_i_v");

  builder.addFunction("m_i_i", sig_i_i)
    .addBody([
      kExprI32Const, 42])  // --
    .exportAs("m_i_i");

  builder.addFunction("m_i_ii", sig_i_ii)
    .addBody([
      kExprI32Const, 43])  // --
    .exportAs("m_i_ii");

  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  m_i_v = instance.exports.m_i_v;
  m_i_i = instance.exports.m_i_i;
  m_i_ii = instance.exports.m_i_ii;

  m_i_v.sig = kSig_i_v;
  m_i_i.sig = kSig_i_i;
  m_i_ii.sig = kSig_i_ii;
})();

function caller_module() {
  let builder = new WasmModuleBuilder();

  let sig_i_v = builder.addType(kSig_i_v);
  let sig_i_ii = builder.addType(kSig_i_ii);
  let sig_i_i = builder.addType(kSig_i_i);

  print("imported[i_v]  = " + sig_i_v);
  print("imported[i_i]  = " + sig_i_i);
  print("imported[i_ii] = " + sig_i_ii);


  builder.addFunction("call1", sig_i_i)
    .addBody([
      kExprLocalGet, 0, // --
      kExprCallIndirect, sig_i_v, kTableZero])  // --
    .exportAs("call1");

  builder.addFunction("call2", sig_i_i)
    .addBody([
      kExprI32Const, 11, // --
      kExprLocalGet, 0,
      kExprCallIndirect, sig_i_i, kTableZero])  // --
    .exportAs("call2");

  builder.addFunction("call3", sig_i_i)
    .addBody([
      kExprI32Const, 21,
      kExprI32Const, 22,
      kExprLocalGet, 0,
      kExprCallIndirect, sig_i_ii, kTableZero])  // --
    .exportAs("call3");

  builder.addImportedTable("imp", "table", kTableSize, kTableSize);

  return builder.toModule();
}

function call(func, ...args) {
  try {
    return "" + func.apply(undefined, args);
  } catch (e) {
    return "!" + e;
  }
}

function DoCalls(table, calls) {
  for (func of calls) {
    print("func = " + func);
    for (var i = 0; i < 4; i++) {
      print("  i = " + i);
      var expectThrow = true;
      var exp = null;
      if (i < table.length) {
        exported = table.get(i);
        expectThrow = (exported.sig != func.sig);
        print("     exp=" + exported);
        print("     throw=" + expectThrow);
      } else {
        print("     exp=<oob>");
      }
      print("     result=" + call(func, i));
      if (expectThrow) {
        assertThrows(() => func(i), WebAssembly.RuntimeError);
      } else {
        assertEquals(exported(0), func(i));
      }
    }
  }
}

(function TestExecute() {
  print("TestExecute");
  let module = caller_module();
  let table = new WebAssembly.Table({element: "anyfunc",
    initial: kTableSize, maximum: kTableSize});
  let instance = new WebAssembly.Instance(module, {imp: {table: table}});
  instance.exports.call1.sig = kSig_i_v;
  instance.exports.call2.sig = kSig_i_i;
  instance.exports.call3.sig = kSig_i_ii;

  let exports = [m_i_v, m_i_i, m_i_ii];
  let calls = [instance.exports.call1,
               instance.exports.call2,
               instance.exports.call3];

  for (f0 of exports) {
    for (f1 of exports) {
      for (f2 of exports) {
        table.set(0, f0);
        table.set(1, f1);
        table.set(2, f2);

        DoCalls(table, calls);
      }
    }
  }
})();
                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/wasm/indirect-tables.js                                            0000664 0000000 0000000 00000071553 14746647661 0023106 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-gc

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function AddFunctions(builder) {
  let sig_index = builder.addType(kSig_i_ii);
  let mul = builder.addFunction("mul", sig_index)
    .addBody([
      kExprLocalGet, 0,  // --
      kExprLocalGet, 1,  // --
      kExprI32Mul        // --
    ]);
  let add = builder.addFunction("add", sig_index)
    .addBody([
      kExprLocalGet, 0,  // --
      kExprLocalGet, 1,  // --
      kExprI32Add        // --
    ]);
  let sub = builder.addFunction("sub", sig_index)
    .addBody([
      kExprLocalGet, 0,  // --
      kExprLocalGet, 1,  // --
      kExprI32Sub        // --
    ]);
  return {mul: mul, add: add, sub: sub};
}

function js_div(a, b) { return (a / b) | 0; }

(function ExportedTableTest() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();

  let d = builder.addImport("q", "js_div", kSig_i_ii);
  let f = AddFunctions(builder);
  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprI32Const, 33,  // --
      kExprLocalGet, 0,   // --
      kExprLocalGet, 1,   // --
      kExprCallIndirect, 0, kTableZero])  // --
    .exportAs("main");

  f.add.exportAs("blarg");

  builder.setTableBounds(10, 10);
  let g = builder.addImportedGlobal("q", "base", kWasmI32);
  builder.addActiveElementSegment(0, [kExprGlobalGet, g],
                                  [f.mul.index, f.add.index, f.sub.index, d]);
  builder.addExportOfKind("table", kExternalTable, 0);

  let module = new WebAssembly.Module(builder.toBuffer());

  for (let i = 0; i < 5; i++) {
    print(" base = " + i);
    let instance = new WebAssembly.Instance(module, {q: {base: i, js_div: js_div}});
    main = instance.exports.main;
    let table = instance.exports.table;
    assertTrue(table instanceof WebAssembly.Table);
    assertEquals(10, table.length);
    for (let j = 0; j < i; j++) {
      assertSame(null, table.get(j));
    }
    let mul = table.get(i+0);
    let add = table.get(i+1);
    let sub = table.get(i+2);

    print("  mul=" + mul);
    print("  add=" + add);
    print("  sub=" + sub);
    assertEquals("function", typeof mul);
    assertEquals("function", typeof add);
    assertEquals("function", typeof sub);
    assertEquals(2, mul.length);
    assertEquals(2, add.length);
    assertEquals(2, sub.length);
    assertEquals(String(f.add.index), add.name);

    let exp_div = table.get(i+3);
    assertEquals("function", typeof exp_div);
    print("  js_div=" + exp_div);
    // Should have a new, wrapped version of the import.
    assertFalse(js_div == exp_div);


    for (let j = i + 4; j < 10; j++) {
      assertSame(null, table.get(j));
    }

    assertEquals(-33, mul(-11, 3));
    assertEquals(4444444, add(3333333, 1111111));
    assertEquals(-9999, sub(1, 10000));
    assertEquals(-44, exp_div(-88.1, 2));
  }
})();


(function ImportedTableTest1() {
  let kTableSize = 10;
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();

  let d = builder.addImport("q", "js_div", kSig_i_ii);
  let f = AddFunctions(builder);
  builder.setTableBounds(kTableSize, kTableSize);
  let g = builder.addImportedGlobal("q", "base", kWasmI32);
  builder.addActiveElementSegment(0, [kExprGlobalGet, g],
                                  [f.mul.index, f.add.index, f.sub.index, d]);
  builder.addExportOfKind("table", kExternalTable, 0);

  let m1 = new WebAssembly.Module(builder.toBuffer());

  var builder = new WasmModuleBuilder();

  builder.addImportedTable("r", "table", kTableSize, kTableSize);
  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprI32Const, 33,  // --
      kExprLocalGet, 0,   // --
      kExprLocalGet, 1,   // --
      kExprCallIndirect, 0, kTableZero])  // --
    .exportAs("main");

  let m2 = new WebAssembly.Module(builder.toBuffer());

  // Run 5 trials at different table bases.
  for (let i = 0; i < 5; i++) {
    print(" base = " + i);
    let i1 = new WebAssembly.Instance(m1, {q: {base: i, js_div: js_div}});
    let table = i1.exports.table;
    assertEquals(10, table.length);
    let i2 = new WebAssembly.Instance(m2, {r: {table: table}});
    let main = i2.exports.main;

    for (var j = 0; j < i; j++) {
      assertTraps(kTrapFuncSigMismatch, () => main(0, j));
      assertSame(null, table.get(j));
    }

    // mul
    assertEquals("function", typeof table.get(i+0));
    assertEquals(0, main(0, i+0));
    assertEquals(66, main(2, i+0));

    // add
    assertEquals("function", typeof table.get(i+1));
    assertEquals(33, main(0, i+1));
    assertEquals(38, main(5, i+1));

    // sub
    assertEquals("function", typeof table.get(i+2));
    assertEquals(32, main(1, i+2));
    assertEquals(28, main(5, i+2));

    // div
    assertEquals("function", typeof table.get(i+3));
    assertEquals(8, main(4, i+3));
    assertEquals(3, main(11, i+3));

    for (var j = i + 4; j < (kTableSize + 5); j++) {
      assertThrows(x => main(0, j));
      if (j < kTableSize) assertSame(null, table.get(j));
    }
  }
})();

(function ImportedTableTest2() {
  let kTableSize = 10;
  print(arguments.callee.name);

  var builder = new WasmModuleBuilder();

  let d = builder.addImport("q", "js_div", kSig_i_ii);
  builder.addImportedTable("q", "table", kTableSize, kTableSize);
  let g = builder.addImportedGlobal("q", "base", kWasmI32);
  let f = AddFunctions(builder);
  builder.addActiveElementSegment(0, [kExprGlobalGet, g],
                                  [f.mul.index, f.add.index, f.sub.index, d]);
  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprI32Const, 55,  // --
      kExprLocalGet, 0,   // --
      kExprLocalGet, 1,   // --
      kExprCallIndirect, 0, kTableZero])  // --
    .exportAs("main");

  let m2 = new WebAssembly.Module(builder.toBuffer());

  // Run 5 trials at different table bases.
  for (let i = 0; i < 5; i++) {
    print(" base = " + i);
    let table = new WebAssembly.Table({element: "anyfunc",
                                       initial: kTableSize,
                                       maximum: kTableSize});
    assertEquals(10, table.length);
    let i2 = new WebAssembly.Instance(m2, {q: {base: i, table: table,
                                               js_div: js_div}});
    let main = i2.exports.main;

    for (var j = 0; j < i; j++) {
      assertTraps(kTrapFuncSigMismatch, () => main(0, j));
      assertSame(null, table.get(j));
    }

    // mul
    assertEquals("function", typeof table.get(i+0));
    assertEquals(0, main(0, i+0));
    assertEquals(110, main(2, i+0));

    // add
    assertEquals("function", typeof table.get(i+1));
    assertEquals(55, main(0, i+1));
    assertEquals(60, main(5, i+1));

    // sub
    assertEquals("function", typeof table.get(i+2));
    assertEquals(54, main(1, i+2));
    assertEquals(50, main(5, i+2));

    // div
    assertEquals("function", typeof table.get(i+3));
    assertEquals(13, main(4, i+3));
    assertEquals(5, main(11, i+3));

    for (var j = i + 4; j < (kTableSize + 5); j++) {
      assertThrows(x => main(0, j));
      if (j < kTableSize) assertSame(null, table.get(j));
    }
  }
})();


(function CumulativeTest() {
  print(arguments.callee.name);

  let kTableSize = 10;
  let table = new WebAssembly.Table(
    {element: "anyfunc", initial: kTableSize, maximum: kTableSize});

  var builder = new WasmModuleBuilder();

  builder.addImportedTable("x", "table", kTableSize, kTableSize);
  let g = builder.addImportedGlobal("x", "base", kWasmI32);
  let sig_index = builder.addType(kSig_i_v);
  let f = builder.addFunction("f", sig_index)
    .addBody([
      kExprGlobalGet, g
    ]);
  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprCallIndirect, sig_index, kTableZero])  // --
    .exportAs("main");
  builder.addActiveElementSegment(0, [kExprGlobalGet, g], [f.index]);

  let module = new WebAssembly.Module(builder.toBuffer());

  for (var i = 0; i < kTableSize; i++) {
    print(" base = " + i);
    let instance = new WebAssembly.Instance(module, {x: {base: i, table: table}});

    for (var j = 0; j < kTableSize; j++) {
      let func = table.get(j);
      if (j > i) {
        assertSame(null, func);
        assertTraps(kTrapFuncSigMismatch, () => instance.exports.main(j));
      } else {
        assertEquals("function", typeof func);
        assertEquals(j, func());
        assertEquals(j, instance.exports.main(j));
      }
    }
  }
})();

(function TwoWayTest() {
  print(arguments.callee.name);
  let kTableSize = 3;

  // Module {m1} defines the table and exports it.
  var builder = new WasmModuleBuilder();
  builder.addType(kSig_i_i);
  builder.addType(kSig_i_ii);
  var sig_index1 = builder.addType(kSig_i_v);
  var f1 = builder.addFunction("f1", sig_index1)
    .addBody([kExprI32Const, 11]);

  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,   // --
      kExprCallIndirect, sig_index1, kTableZero])  // --
    .exportAs("main");

  builder.setTableBounds(kTableSize, kTableSize);
  builder.addActiveElementSegment(0, wasmI32Const(0), [f1.index]);
  builder.addExportOfKind("table", kExternalTable, 0);

  var m1 = new WebAssembly.Module(builder.toBuffer());

  // Module {m2} imports the table and adds {f2}.
  var builder = new WasmModuleBuilder();
  builder.addType(kSig_i_ii);
  var sig_index2 = builder.addType(kSig_i_v);
  var f2 = builder.addFunction("f2", sig_index2)
    .addBody([kExprI32Const, 22]);

  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,   // --
      kExprCallIndirect, sig_index2, kTableZero])  // --
    .exportAs("main");

  builder.addImportedTable("z", "table", kTableSize, kTableSize);
  builder.addActiveElementSegment(0, wasmI32Const(1), [f2.index]);

  var m2 = new WebAssembly.Module(builder.toBuffer());

  assertFalse(sig_index1 == sig_index2);

  var i1 = new WebAssembly.Instance(m1);
  var i2 = new WebAssembly.Instance(m2, {z: {table: i1.exports.table}});

  assertEquals(11, i1.exports.main(0));
  assertEquals(11, i2.exports.main(0));

  assertEquals(22, i1.exports.main(1));
  assertEquals(22, i2.exports.main(1));

  assertTraps(kTrapFuncSigMismatch, () => i1.exports.main(2));
  assertTraps(kTrapFuncSigMismatch, () => i2.exports.main(2));
  assertTraps(kTrapTableOutOfBounds, () => i1.exports.main(3));
  assertTraps(kTrapTableOutOfBounds, () => i2.exports.main(3));
})();

(function MismatchedTableSize() {
  print(arguments.callee.name);
  let kTableSize = 5;

  for (var expsize = 1; expsize < 4; expsize++) {
    for (var impsize = 1; impsize < 4; impsize++) {
      print(" expsize = " + expsize + ", impsize = " + impsize);
      var builder = new WasmModuleBuilder();
      builder.setTableBounds(expsize, expsize);
      builder.addExportOfKind("expfoo", kExternalTable, 0);

      let m1 = new WebAssembly.Module(builder.toBuffer());

      var builder = new WasmModuleBuilder();
      builder.addImportedTable("y", "impfoo", impsize, impsize);

      let m2 = new WebAssembly.Module(builder.toBuffer());

      var i1 = new WebAssembly.Instance(m1);

      // TODO(titzer): v8 currently requires import table size to match
      // export table size.
      var ffi = {y: {impfoo: i1.exports.expfoo}};
      if (expsize == impsize) {
        var i2 = new WebAssembly.Instance(m2, ffi);
      } else {
        assertThrows(() => new WebAssembly.Instance(m2, ffi));
      }
    }
  }
})();

(function TableGrowBoundsCheck() {
  print(arguments.callee.name);
  var kMaxSize = 30, kInitSize = 5;
  let table = new WebAssembly.Table({element: "anyfunc",
    initial: kInitSize, maximum: kMaxSize});
  var builder = new WasmModuleBuilder();
  builder.addImportedTable("x", "table", kInitSize, kMaxSize);
  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module, {x: {base: 1, table: table}});

  for(var i = kInitSize; i < kMaxSize; i+=5) {
    assertEquals(i, table.length);
    for (var j = 0; j < i; j++) table.set(j, null);
    for (var j = 0; j < i; j++) assertEquals(null, table.get(j));
    assertThrows(() => table.set(i, null), RangeError);
    assertThrows(() => table.get(i), RangeError);
    assertEquals(i, table.grow(5));
  }
  assertEquals(30, table.length);
  assertThrows(() => table.grow(1), RangeError);
  assertThrows(() => table.set(kMaxSize, null), RangeError);
  assertThrows(() => table.get(kMaxSize), RangeError);
})();

(function CumulativeGrowTest() {
  print(arguments.callee.name);
  let table = new WebAssembly.Table({
    element: "anyfunc", initial: 10, maximum: 30});
  var builder = new WasmModuleBuilder();
  builder.addImportedTable("x", "table", 10, 30);

  let g = builder.addImportedGlobal("x", "base", kWasmI32);
  let sig_index = builder.addType(kSig_i_v);
  builder.addFunction("g", sig_index)
    .addBody([
      kExprGlobalGet, g
    ]);
  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprCallIndirect, sig_index, kTableZero])  // --
    .exportAs("main");
  builder.addActiveElementSegment(0, [kExprGlobalGet, g], [g]);
  let module = new WebAssembly.Module(builder.toBuffer());

  var instances = [];
  for (var i = 0; i < 10; i++) {
    print(" base = " + i);
    instances.push(new WebAssembly.Instance(
        module, {x: {base: i, table: table}}));
  }

  for (var j = 0; j < 10; j++) {
    let func = table.get(j);
    assertEquals("function", typeof func);
    assertEquals(j, func());
    assertEquals(j, instances[j].exports.main(j));
  }

  assertEquals(10, table.grow(10));

  // Verify that grow does not alter function behaviors
  for (var j = 0; j < 10; j++) {
    let func = table.get(j);
    assertEquals("function", typeof func);
    assertEquals(j, func());
    assertEquals(j, instances[j].exports.main(j));
  }

  let new_builder = new WasmModuleBuilder();
  new_builder.addExport("wasm", new_builder.addFunction("", kSig_v_v).addBody([]));
  new_builder.addImportedTable("x", "table", 20, 30);
  let new_module = new WebAssembly.Module(new_builder.toBuffer());
  let instance = new WebAssembly.Instance(new_module, {x: {table: table}});
  let new_func = instance.exports.wasm;

  for (var j = 10; j < 20; j++) {
    table.set(j, new_func);
    let func = table.get(j);
    assertEquals("function", typeof func);
    assertSame(new_func, table.get(j));
  }
  assertThrows(() => table.grow(11), RangeError);
})();


(function TestImportTooLarge() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addImportedTable("t", "t", 1, 2);

  // initial size is too large
  assertThrows(() => builder.instantiate({t: {t: new WebAssembly.Table(
    {element: "anyfunc", initial: 3, maximum: 3})}}), WebAssembly.LinkError);

  // maximum size is too large
  assertThrows(() => builder.instantiate({t: {t: new WebAssembly.Table(
    {element: "anyfunc", initial: 1, maximum: 4})}}), WebAssembly.LinkError);

  // no maximum
  assertThrows(() => builder.instantiate({t: {t: new WebAssembly.Table(
    {element: "anyfunc", initial: 1})}}), WebAssembly.LinkError);
})();

(function TableImportLargerThanCompiled() {
  print(arguments.callee.name);
  var kMaxSize = 30, kInitSize = 5;
  var builder = new WasmModuleBuilder();
  builder.addImportedTable("x", "table", 1, 35);
  let table = new WebAssembly.Table({element: "anyfunc",
    initial: kInitSize, maximum: kMaxSize});
  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module, {x: {base: 1, table: table}});
  for (var i = 0; i < kInitSize; ++i) table.set(i, null);
  for (var i = 0; i < kInitSize; ++i) assertEquals(null, table.get(i));
  assertThrows(() => table.set(kInitSize, null), RangeError);
})();

(function ModulesShareTableAndGrow() {
  print(arguments.callee.name);
  let module1 = (() => {
    let builder = new WasmModuleBuilder();
    builder.addImportedTable("x", "table", 1, 35);
    return new WebAssembly.Module(builder.toBuffer());
  })();
  let module2 = (() => {
    let builder = new WasmModuleBuilder();
    builder.addImportedTable("x", "table", 2, 40);
    return new WebAssembly.Module(builder.toBuffer());
  })();

  var kMaxSize = 30, kInitSize = 5;
  let table = new WebAssembly.Table({element: "anyfunc",
    initial: kInitSize, maximum: kMaxSize});
  let instance1 = new WebAssembly.Instance(
      module1, {x: {base: 1, table: table}});
  let instance2 = new WebAssembly.Instance(
      module2, {x: {base: 1, table: table}});

  for (var i = 0; i < kInitSize; ++i) table.set(i, null);
  for (var i = 0; i < kInitSize; ++i) assertEquals(null, table.get(i));
  assertThrows(() => table.set(kInitSize, null), RangeError);
  assertEquals(kInitSize, table.grow(5));
  for (var i = 0; i < 2*kInitSize; ++i) table.set(i, null);
  for (var i = 0; i < 2*kInitSize; ++i) assertEquals(null, table.get(i));
  assertThrows(() => table.set(2*kInitSize, null), RangeError);
  // Try to grow past imported maximum
  assertThrows(() => table.grow(21), RangeError);
})();

(function MultipleElementSegments() {
  let kTableSize = 10;
  print(arguments.callee.name);

  let mul = (a, b) => a * b;
  let add = (a, b) => a + b;
  let sub = (a, b) => a - b;

  // Test 1 to 3 segments in the elements section.
  // segment 1 sets [1, 2] to mul,
  // segment 2 sets [2, 3, 4] to add,
  // segment 3 sets [3, 4, 5, 6] to sub.
  for (let num_segments = 1; num_segments < 4; ++num_segments) {
    var builder = new WasmModuleBuilder();

    builder.setTableBounds(kTableSize, kTableSize);
    builder.addExportOfKind("table", kExternalTable, 0);
    let f = AddFunctions(builder);
    let indexes = [f.mul.index, f.add.index, f.sub.index];
    for (let i = 0; i < num_segments; ++i) {
      let offset = i + 1;
      let len = i + 2;
      let index = indexes[i];
      builder.addActiveElementSegment(0, wasmI32Const(offset),
                                      new Array(len).fill(index));
    }

    let instance = builder.instantiate();

    let table = instance.exports.table;
    assertEquals(kTableSize, table.length);

    for (let i = 0; i < num_segments; ++i) {
      let exp = i < 1 || i > 2 ? null : mul;
      if (num_segments > 1 && i >= 2 && i <= 4) exp = add;
      if (num_segments > 2 && i >= 3 && i <= 6) exp = sub;
      if (!exp) {
        assertSame(null, table.get(i));
      } else {
        assertEquals("function", typeof table.get(i));
    assertEquals(exp(6, 3), table.get(i)(6, 3));
      }
    }
  }
})();

(function InitImportedTableSignatureMismatch() {
  // instance0 exports a function table and a main function which indirectly
  // calls a function from the table.
  let builder0 = new WasmModuleBuilder();
  builder0.setName('module_0');
  let sig_index = builder0.addType(kSig_i_v);
  builder0.addFunction('main', kSig_i_i)
      .addBody([
        kExprLocalGet, 0,  // -
        kExprCallIndirect, sig_index, kTableZero
      ])
      .exportAs('main');
  builder0.setTableBounds(3, 3);
  builder0.addExportOfKind('table', kExternalTable);
  let module0 = new WebAssembly.Module(builder0.toBuffer());
  let instance0 = new WebAssembly.Instance(module0);

  // instance1 imports the table and adds a function to it.
  let builder1 = new WasmModuleBuilder();
  builder1.setName('module_1');
  builder1.addFunction('f', kSig_i_i).addBody([kExprLocalGet, 0]);
  builder1.addImportedTable('z', 'table');
  builder1.addActiveElementSegment(0, wasmI32Const(0), [0]);
  let module1 = new WebAssembly.Module(builder1.toBuffer());
  let instance1 =
      new WebAssembly.Instance(module1, {z: {table: instance0.exports.table}});

  // Calling the main method on instance0 should fail, because the signature of
  // the added function does not match.
  assertThrows(
      () => instance0.exports.main(0), WebAssembly.RuntimeError,
      /signature mismatch/);
})();

(function IndirectCallIntoOtherInstance() {
  print(arguments.callee.name);

  var mem_1 = new WebAssembly.Memory({initial: 1});
  var mem_2 = new WebAssembly.Memory({initial: 1});
  var view_1 = new Int32Array(mem_1.buffer);
  var view_2 = new Int32Array(mem_2.buffer);
  view_1[0] = 1;
  view_2[0] = 1000;

  let builder = new WasmModuleBuilder();
  let sig = builder.addType(kSig_i_v);
  builder.addFunction('main', kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprCallIndirect, sig, kTableZero])
    .exportAs('main');
  builder.addImportedMemory('', 'memory', 1);

  builder.setTableBounds(1, 1);
  builder.addExportOfKind('table', kExternalTable);

  let module1 = new WebAssembly.Module(builder.toBuffer());
  let instance1 = new WebAssembly.Instance(module1, {'':{memory:mem_1}});

  builder = new WasmModuleBuilder();
  builder.addFunction('main', kSig_i_v)
         .addBody([kExprI32Const, 0, kExprI32LoadMem, 0, 0]);
  builder.addImportedTable('', 'table');
  builder.addActiveElementSegment(0, wasmI32Const(0), [0]);
  builder.addImportedMemory('', 'memory', 1);


  let module2 = new WebAssembly.Module(builder.toBuffer());
  let instance2 = new WebAssembly.Instance(module2, {
    '': {
      table: instance1.exports.table,
      memory: mem_2
    }
  });

  assertEquals(instance1.exports.main(0), 1000);
})();


(function ImportedFreestandingTable() {
  print(arguments.callee.name);

  function forceGc() {
    gc();
    gc();
    gc();
  }

  function setup() {
    let builder = new WasmModuleBuilder();
    let sig = builder.addType(kSig_i_v);
    builder.addFunction('main', kSig_i_i)
      .addBody([kExprLocalGet, 0, kExprCallIndirect, sig, kTableZero])
      .exportAs('main');

    builder.addImportedTable('', 'table');

    let module1 = new WebAssembly.Module(builder.toBuffer());
    let table = new WebAssembly.Table({initial:2, element:'anyfunc'});
    let instance1 = new WebAssembly.Instance(module1, {'':{table: table}});

    builder = new WasmModuleBuilder();
    builder.addExport('theImport', builder.addImport('', 'callout', kSig_i_v));
    builder.addImportedMemory('', 'memory', 1);
    builder.addFunction('main', kSig_i_v)
      .addBody([
        kExprCallFunction, 0,
        kExprI32Const, 0, kExprI32LoadMem, 0, 0,
        kExprI32Add
      ]).exportAs('main');

    let mem = new WebAssembly.Memory({initial:1});
    let view = new Int32Array(mem.buffer);
    view[0] = 4;

    let module2 = new WebAssembly.Module(builder.toBuffer());
    let instance2 = new WebAssembly.Instance(module2, {
      '': {
        callout: () => {
          forceGc();
          return 3;
        },
        'memory': mem
      }
    });
    table.set(0, instance2.exports.main);
    table.set(1, instance2.exports.theImport);
    return instance1;
  }

  function test(variant, expectation) {
    var instance = setup();
    forceGc();
    assertEquals(expectation, instance.exports.main(variant));
  }

  // 0 indirectly calls the wasm function that calls the import,
  // 1 does the same but for the exported import.
  test(0, 7);
  test(1, 3);
})();


(function ImportedWasmFunctionPutIntoTable() {
  print(arguments.callee.name);

  let wasm_mul = (() => {
    let builder = new WasmModuleBuilder();
    builder.addFunction("mul", kSig_i_ii)
      .addBody(
        [kExprLocalGet, 0,
         kExprLocalGet, 1,
         kExprI32Mul])
      .exportFunc();
    return builder.instantiate().exports.mul;
  })();

  let builder = new WasmModuleBuilder();

  let j = builder.addImport("q", "js_div", kSig_i_ii);
  let w = builder.addImport("q", "wasm_mul", kSig_i_ii);
  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprI32Const, 33,  // --
      kExprLocalGet, 0,   // --
      kExprLocalGet, 1,   // --
      kExprCallIndirect, 0, kTableZero])  // --
    .exportAs("main");

  builder.setTableBounds(10, 10);
  let g = builder.addImportedGlobal("q", "base", kWasmI32);
  builder.addActiveElementSegment(0, [kExprGlobalGet, g], [j, w]);

  let module = new WebAssembly.Module(builder.toBuffer());
  for (var i = 0; i < 5; i++) {
    let instance = new WebAssembly.Instance(module, {q: {base: i, js_div: js_div, wasm_mul: wasm_mul}});
    let j = i + 1;

    assertThrows(() => {instance.exports.main(j, i-1)});
    assertEquals((33/j)|0, instance.exports.main(j, i+0));
    assertEquals((33*j)|0, instance.exports.main(j, i+1));
    assertThrows(() => {instance.exports.main(j, i+2)});
  }

})();

(function ImportedWasmFunctionPutIntoImportedTable() {
  print(arguments.callee.name);

  let kTableSize = 10;

  let wasm_mul = (() => {
    let builder = new WasmModuleBuilder();
    builder.addFunction("mul", kSig_i_ii)
      .addBody(
        [kExprLocalGet, 0,
         kExprLocalGet, 1,
         kExprI32Mul])
      .exportFunc();
    return builder.instantiate().exports.mul;
  })();

  let table = new WebAssembly.Table({element: "anyfunc",
                                     initial: kTableSize,
                                     maximum: kTableSize});

  let builder = new WasmModuleBuilder();

  let j = builder.addImport("q", "js_div", kSig_i_ii);
  let w = builder.addImport("q", "wasm_mul", kSig_i_ii);
  builder.addImportedTable("q", "table", kTableSize, kTableSize);
  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprI32Const, 44,  // --
      kExprLocalGet, 0,   // --
      kExprLocalGet, 1,   // --
      kExprCallIndirect, 0, kTableZero])  // --
    .exportAs("main");

  let g = builder.addImportedGlobal("q", "base", kWasmI32);
  builder.addActiveElementSegment(0, [kExprGlobalGet, g], [j, w]);

  let module = new WebAssembly.Module(builder.toBuffer());
  for (var i = 0; i < 5; i++) {
    let instance = new WebAssembly.Instance(
      module, {q: {base: i, js_div: js_div, wasm_mul: wasm_mul, table: table}});
    let j = i + 1;

    assertEquals((44/j)|0, instance.exports.main(j, i+0));
    assertEquals((44*j)|0, instance.exports.main(j, i+1));
    assertThrows(() => {instance.exports.main(j, i+2)});
  }
})();

(function ExportedFunctionsImportedOrder() {
  print(arguments.callee.name);

  let i1 = (() => {
    let builder = new WasmModuleBuilder();
    builder.addFunction("f1", kSig_i_v)
      .addBody(
        [kExprI32Const, 1])
      .exportFunc();
    builder.addFunction("f2", kSig_i_v)
      .addBody(
        [kExprI32Const, 2])
      .exportFunc();
    return builder.instantiate();
  })();

  let i2 = (() => {
    let builder = new WasmModuleBuilder();
    builder.addTable(kWasmAnyFunc, 4);
    builder.addImport("q", "f2", kSig_i_v);
    builder.addImport("q", "f1", kSig_i_v);
    builder.addFunction("main", kSig_i_i)
      .addBody([
        kExprLocalGet, 0,
        kExprCallIndirect, 0, kTableZero
      ])
      .exportFunc();
    builder.addActiveElementSegment(0, wasmI32Const(0), [0, 1, 1, 0]);

    return builder.instantiate({q: {f2: i1.exports.f2, f1: i1.exports.f1}});
  })();

  assertEquals(2, i2.exports.main(0));
  assertEquals(1, i2.exports.main(1));
  assertEquals(1, i2.exports.main(2));
  assertEquals(2, i2.exports.main(3));
})();

(function IndirectCallsToImportedFunctions() {
  print(arguments.callee.name);

  let module = (() => {
    let builder = new WasmModuleBuilder();
    builder.addMemory(1, 1);
    builder.addFunction("f", kSig_i_v)
      .addBody([
        kExprI32Const, 0,
        kExprI32LoadMem, 0, 4,
      ])
      .exportFunc();
    builder.exportMemoryAs("memory");
    return new WebAssembly.Module(builder.toBuffer());
  })();

  function setMemI32(instance, offset, val) {
    var array = new Int32Array(instance.exports.memory.buffer);
    array[offset/4] = val;
  }

  function makeFun(val) {
    let instance = new WebAssembly.Instance(module);
    setMemI32(instance, 0, 2000000);
    setMemI32(instance, 4, val);
    setMemI32(instance, 8, 3000000);
    return instance.exports.f;
  }

  let f300 = makeFun(300);
  let f100 = makeFun(100);
  let f200 = makeFun(200);

  let main = (() => {
    let builder = new WasmModuleBuilder();
    builder.addMemory(1, 1);
    builder.addTable(kWasmAnyFunc, 4);
    builder.addImport("q", "f1", kSig_i_v);
    builder.addImport("q", "f2", kSig_i_v);
    builder.addImport("q", "f3", kSig_i_v);
    builder.addFunction("f", kSig_i_v)
      .addBody([
        kExprI32Const, 8,
        kExprI32LoadMem, 0, 0,
      ]);
    builder.addFunction("main", kSig_i_i)
      .addBody([
        kExprLocalGet, 0,
        kExprCallIndirect, 0, kTableZero
      ])
      .exportFunc();
    builder.exportMemoryAs("memory");
    builder.addActiveElementSegment(0, wasmI32Const(0), [0, 1, 2, 3]);
    var instance = builder.instantiate({q: {f1: f100, f2: f200, f3: f300}});
    setMemI32(instance, 0, 5000000);
    setMemI32(instance, 4, 6000000);
    setMemI32(instance, 8, 400);
    return instance.exports.main;
  })();

  assertEquals(100, main(0));
  assertEquals(200, main(1));
  assertEquals(300, main(2));
  assertEquals(400, main(3));
})();

(function TestNonImportedGlobalInElementSegment() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let global = builder.addGlobal(kWasmFuncRef, true, false,
                                 [kExprRefNull, kFuncRefCode]);
  let table = builder.addTable(kWasmFuncRef, 10, 10);
  builder.addActiveElementSegment(
      table.index, wasmI32Const(0),
      [[kExprGlobalGet, global.index]], kWasmFuncRef);
  builder.addExportOfKind("table", kExternalTable, table.index);

  assertThrows(
    () => builder.instantiate(), WebAssembly.CompileError,
    /mutable globals cannot be used in constant expressions/);
})();
                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/wasm/inlining.js                                                   0000664 0000000 0000000 00000076576 14746647661 0021656 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-inlining --no-liftoff --allow-natives-syntax

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// TODO(12166): Consider running tests with --trace-wasm and inspecting their
// output, or implementing testing infrastructure with --allow-natives-syntax.

(function SimpleInliningTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  // f(x) = x - 1
  let callee = builder.addFunction("callee", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprI32Const, 1, kExprI32Sub]);
  // g(x) = f(5) + x
  builder.addFunction("main", kSig_i_i)
    .addBody([kExprI32Const, 5, kExprCallFunction, callee.index,
              kExprLocalGet, 0, kExprI32Add])
    .exportAs("main");

  let instance = builder.instantiate();
  assertEquals(14, instance.exports.main(10));
})();

(function MultiReturnTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  // f(x) = (x - 1, x + 1)
  let callee = builder.addFunction("callee", kSig_ii_i)
    .addBody([kExprLocalGet, 0, kExprI32Const, 1, kExprI32Sub,
              kExprLocalGet, 0, kExprI32Const, 1, kExprI32Add]);
  // g(x) = { let (a, b) = f(x); a * b }
  builder.addFunction("main", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprCallFunction, callee.index, kExprI32Mul])
    .exportAs("main");

  let instance = builder.instantiate();
  assertEquals(9 * 11, instance.exports.main(10));
})();

(function VoidReturnTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let global = builder.addGlobal(kWasmI32, true, false);

  let callee = builder.addFunction("callee", kSig_v_i)
    .addBody([kExprLocalGet, 0, kExprGlobalSet, global.index]);

  builder.addFunction("main", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprCallFunction, callee.index,
              kExprGlobalGet, global.index])
    .exportAs("main");

  let instance = builder.instantiate();
  assertEquals(10, instance.exports.main(10));
})();

(function NoReturnTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let tag = builder.addTag(kSig_v_i);

  let callee = builder.addFunction("callee", kSig_i_i)
    .addBody([kExprI32Const, 42, kExprThrow, tag]);

  builder.addFunction("main", kSig_i_i)
    .addBody([
      kExprTry, kWasmI32,
        kExprI32Const, 10, kExprCallFunction, callee.index,
        kExprI32Const, 10, kExprI32Add,
      kExprCatch, tag,
        kExprI32Const, 1, kExprI32Add,
      kExprEnd])
    .exportFunc();

  let instance = builder.instantiate();
  assertEquals(43, instance.exports.main(10));
})();

(function LoopInLoopTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let fact = builder.addFunction("fact", kSig_i_i)
    .addLocals(kWasmI32, 1)
    .addBody([// result = 1;
              kExprI32Const, 1, kExprLocalSet, 1,
              kExprLoop, kWasmVoid,
                kExprLocalGet, 1,
                // if input == 1 return result;
                kExprLocalGet, 0, kExprI32Const, 1, kExprI32Eq, kExprBrIf, 1,
                // result *= input;
                kExprLocalGet, 0, kExprI32Mul, kExprLocalSet, 1,
                // input -= 1;
                kExprLocalGet, 0, kExprI32Const, 1, kExprI32Sub,
                kExprLocalSet, 0,
                kExprBr, 0,
              kExprEnd,
              kExprUnreachable]);

  builder.addFunction("main", kSig_i_i)
    .addLocals(kWasmI32, 1)
    .addBody([
      kExprLoop, kWasmVoid,
        kExprLocalGet, 1,
        // if input == 0 return sum;
        kExprLocalGet, 0, kExprI32Const, 0, kExprI32Eq, kExprBrIf, 1,
        // sum += fact(input);
        kExprLocalGet, 0, kExprCallFunction, fact.index,
        kExprI32Add, kExprLocalSet, 1,
        // input -= 1;
        kExprLocalGet, 0, kExprI32Const, 1, kExprI32Sub,
        kExprLocalSet, 0,
        kExprBr, 0,
      kExprEnd,
      kExprUnreachable])
    .exportAs("main");

  let instance = builder.instantiate();
  assertEquals(33, instance.exports.main(4));
})();

(function InfiniteLoopTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let callee = builder.addFunction("callee", kSig_i_i)
    .addBody([kExprLoop, kWasmVoid,
                kExprLocalGet, 0, kExprI32Const, 1, kExprI32Add,
                kExprLocalSet, 0, kExprBr, 0,
              kExprEnd,
              kExprLocalGet, 0]);

  builder.addFunction("main", kSig_i_i)
    .addBody([kExprI32Const, 5, kExprCallFunction, callee.index,
              kExprLocalGet, 0, kExprI32Add])
    .exportAs("main");

  builder.instantiate();
})();

(function TailCallInCalleeTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  // f(x) = g(x - 1)
  let callee = builder.addFunction("callee", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprI32Const, 1, kExprI32Sub,
              kExprReturnCall, 1]);
  // g(x) = x * 2
  builder.addFunction("inner_callee", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprI32Const, 2, kExprI32Mul]);
  // h(x) = f(x) + 5
  builder.addFunction("main", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprCallFunction, callee.index,
              kExprI32Const, 5, kExprI32Add])
    .exportAs("main");

  let instance = builder.instantiate();
  assertEquals(23, instance.exports.main(10));
})();

(function MultipleCallAndReturnSitesTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  // f(x) = x >= 0 ? x - 1 : x + 1
  let callee = builder.addFunction("callee", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprI32Const, 0, kExprI32GeS,
              kExprIf, kWasmI32,
                kExprLocalGet, 0, kExprI32Const, 1, kExprI32Sub,
              kExprElse,
                kExprLocalGet, 0, kExprI32Const, 1, kExprI32Add,
              kExprEnd]);
  // g(x) = f(x) * f(-x)
  builder.addFunction("main", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprCallFunction, callee.index,
              kExprI32Const, 0, kExprLocalGet, 0, kExprI32Sub,
              kExprCallFunction, callee.index,
              kExprI32Mul])
    .exportAs("main");

  let instance = builder.instantiate();
  assertEquals(-81, instance.exports.main(10));
})();

(function TailCallInCallerTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  // f(x) = x > 0 ? g(x) + 1: g(x - 1);
  let callee = builder.addFunction("callee", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprI32Const, 0, kExprI32GeS,
              kExprIf, kWasmI32,
                kExprLocalGet, 0, kExprCallFunction, 1, kExprI32Const, 1,
                kExprI32Add,
              kExprElse,
                kExprLocalGet, 0, kExprI32Const, 1, kExprI32Sub,
                kExprReturnCall, 1,
              kExprEnd]);
  // g(x) = x * 2
  builder.addFunction("inner_callee", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprI32Const, 2, kExprI32Mul]);
  // h(x) = f(x + 5)
  builder.addFunction("main", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprI32Const, 5, kExprI32Add,
              kExprReturnCall, callee.index])
    .exportAs("main");

  let instance = builder.instantiate();
  assertEquals(31, instance.exports.main(10));
  assertEquals(-12, instance.exports.main(-10));
})();

(function HandledInHandledTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let tag = builder.addTag(kSig_v_i);

  let callee = builder.addFunction("callee", kSig_i_i)
    .addBody([kExprTry, kWasmI32,
                kExprI32Const, 42,
                kExprThrow, tag,
              kExprCatchAll,
                kExprLocalGet, 0,
              kExprEnd]);

  builder.addFunction("main", kSig_i_ii)
    .addBody([kExprTry, kWasmI32,
                kExprLocalGet, 0,
                kExprCallFunction, callee.index,
              kExprCatchAll,
                kExprLocalGet, 1,
              kExprEnd])
    .exportAs("main");

  let instance = builder.instantiate();
  assertEquals(10, instance.exports.main(10, 20));
})();

(function HandledInUnhandledTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let tag = builder.addTag(kSig_v_i);

  let callee = builder.addFunction("callee", kSig_i_i)
    .addBody([kExprTry, kWasmI32,
                kExprI32Const, 42,
                kExprThrow, tag,
              kExprCatchAll,
                kExprLocalGet, 0,
              kExprEnd]);

  builder.addFunction("main", kSig_i_ii)
    .addBody([kExprLocalGet, 0,
              kExprCallFunction, callee.index,])
    .exportAs("main");

  let instance = builder.instantiate();
  assertEquals(10, instance.exports.main(10, 20));
})();

(function UnhandledInUnhandledTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let tag = builder.addTag(kSig_v_i);

  let callee = builder.addFunction("callee", kSig_i_i)
    .addBody([kExprI32Const, 42, kExprThrow, tag]);

  builder.addFunction("main", kSig_i_ii)
    .addBody([kExprLocalGet, 0,
              kExprCallFunction, callee.index])
    .exportAs("main");

  let instance = builder.instantiate();
  assertThrows(() => instance.exports.main(10, 20), WebAssembly.Exception);
})();

// This is the most interesting of the exception tests, as it requires rewiring
// the unhandled calls in the callee (including the 'throw' builtin) to the
// handler in the caller.
(function UnhandledInHandledTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let tag = builder.addTag(kSig_v_i);

  let callee = builder.addFunction("callee", kSig_i_i)
    .addBody([
      kExprLocalGet, 0,
      kExprIf, kWasmI32,
        kExprLocalGet, 0, kExprThrow, tag,
      kExprElse,
        kExprCallFunction, 1,
      kExprEnd]);

  builder.addFunction("unreachable", kSig_i_v)
    .addBody([kExprUnreachable]);

  builder.addFunction("main", kSig_i_ii)
    .addBody([kExprTry, kWasmI32,
                kExprLocalGet, 0,
                kExprCallFunction, callee.index,
              kExprCatchAll,
                kExprLocalGet, 1,
              kExprEnd])
    .exportAs("main");

  let instance = builder.instantiate();
  assertEquals(20, instance.exports.main(10, 20));
})();

// Inlining should behave correctly when there are no throwing nodes in the
// callee.
(function NoThrowInHandledTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let tag = builder.addTag(kSig_v_i);

  let callee = builder.addFunction("callee", kSig_i_i)
    .addBody([
      kExprLocalGet, 0, kExprI32Const, 0, kExprI32GeS,
      kExprIf, kWasmI32,
        kExprLocalGet, 0, kExprI32Const, 1, kExprI32Add,
      kExprElse,
        kExprLocalGet, 0, kExprI32Const, 2, kExprI32Sub,
      kExprEnd]);

  builder.addFunction("main", kSig_i_ii)
    .addBody([kExprTry, kWasmI32,
                kExprLocalGet, 0,
                kExprCallFunction, callee.index,
              kExprCatchAll,
                kExprLocalGet, 1,
              kExprEnd])
    .exportAs("main");

  let instance = builder.instantiate();
  assertEquals(11, instance.exports.main(10, 20));
})();

// Things get more complex if we also need to reload the memory context.
(function UnhandledInHandledWithMemoryTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let sig = builder.addType(kSig_i_i);

  builder.addMemory(10, 100);

  let inner_callee = builder.addFunction("inner_callee", kSig_i_i)
    .addBody([kExprLocalGet, 0]).exportFunc();

  // f(x, y) = { do { y += 1; x -= 1; } while (x > 0); return y; }
  let callee = builder.addFunction("callee", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add,
      kExprRefFunc, inner_callee.index, kExprCallRef, sig]);
  // g(x) = f(5, x) + x
  builder.addFunction("main", kSig_i_i)
    .addBody([kExprTry, kWasmI32,
                kExprI32Const, 5, kExprLocalGet, 0,
                kExprCallFunction, callee.index,
              kExprCatchAll,
                kExprI32Const, 0,
              kExprEnd,
              kExprLocalGet, 0, kExprI32Add,
              kExprI32Const, 10, kExprI32LoadMem, 0, 0, kExprI32Add])
    .exportAs("main");

  let instance = builder.instantiate();
  assertEquals(25, instance.exports.main(10));
})();

(function TailCallInCatchBlock() {
  // A tail call frame replaces the caller frame, so an exception should not be
  // catchable in the caller frame.
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let tag = builder.addTag(kSig_v_i);

  let callee = builder.addFunction("callee", kSig_i_i)
    .addBody([kExprI32Const, 42, kExprThrow, tag])

  builder.addFunction("main", kSig_i_i)
    .addBody([
      kExprTry, kWasmI32,
        kExprLocalGet, 0, kExprReturnCall, callee.index,
      kExprCatch, tag,
      kExprEnd])
    .exportFunc();

  let instance = builder.instantiate();

  assertThrows(() => instance.exports.main(10), WebAssembly.Exception);
})();

(function TailCallInNestedCallInCatchBlock() {
  // In contrast to the previous test, if there is an intermediate frame, the
  // parent frame should be able to catch the exception.
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let tag = builder.addTag(kSig_v_i);

  let callee = builder.addFunction("callee", kSig_i_i)
    .addBody([kExprI32Const, 42, kExprThrow, tag]);

  let intermediate = builder.addFunction("intermediate", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprReturnCall, callee.index]);

  builder.addFunction("main", kSig_i_i)
    .addBody([
      kExprTry, kWasmI32,
        kExprLocalGet, 0, kExprCallFunction, intermediate.index,
      kExprCatch, tag,
      kExprEnd])
    .exportFunc();

  let instance = builder.instantiate();

  assertEquals(42, instance.exports.main(10));
})();

(function CallInTailCallInCatchBlock() {
  // A tail call removes the current frame, so an exception should not be
  // caught even from within a nested inlined call.
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let tag = builder.addTag(kSig_v_i);

  let callee = builder.addFunction("callee", kSig_i_i)
    .addBody([kExprI32Const, 42, kExprThrow, tag]);

  let intermediate = builder.addFunction("intermediate", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprI32Const, 1, kExprI32Add,
              kExprCallFunction, callee.index]);

  builder.addFunction("main", kSig_i_i)
    .addBody([
      kExprTry, kWasmI32,
        kExprLocalGet, 0, kExprReturnCall, intermediate.index,
      kExprCatch, tag,
      kExprEnd])
    .exportFunc();

  let instance = builder.instantiate();

  assertThrows(() => instance.exports.main(10), WebAssembly.Exception);
})();

(function LoopUnrollingTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  // f(x, y) = { do { y += 1; x -= 1; } while (x > 0); return y; }
  let callee = builder.addFunction("callee", kSig_i_ii)
    .addBody([
      kExprLoop, kWasmVoid,
        kExprLocalGet, 1, kExprI32Const, 1, kExprI32Add, kExprLocalSet, 1,
        kExprLocalGet, 0, kExprI32Const, 1, kExprI32Sub, kExprLocalSet, 0,
        kExprLocalGet, 0, kExprI32Const, 0, kExprI32GtS, kExprBrIf, 0,
      kExprEnd,
      kExprLocalGet, 1
    ]);
  // g(x) = f(5, x) + x
  builder.addFunction("main", kSig_i_i)
    .addBody([kExprI32Const, 5, kExprLocalGet, 0,
              kExprCallFunction, callee.index,
              kExprLocalGet, 0, kExprI32Add])
    .exportAs("main");

  let instance = builder.instantiate();
  assertEquals(25, instance.exports.main(10));
})();

(function ThrowInLoopTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let tag = builder.addTag(kSig_v_i);

  // f(x, y) {
  //   do {
  //     if (x < 0) throw x;
  //     y++; x--;
  //   } while (x > 0);
  //   return y;
  // }
  let callee = builder.addFunction("callee", kSig_i_ii)
    .addBody([
      kExprLoop, kWasmVoid,
        kExprLocalGet, 0, kExprI32Const, 0, kExprI32LtS,
        kExprIf, kWasmVoid,
          kExprLocalGet, 0, kExprThrow, tag,
        kExprEnd,
        kExprLocalGet, 1, kExprI32Const, 1, kExprI32Add, kExprLocalSet, 1,
        kExprLocalGet, 0, kExprI32Const, 1, kExprI32Sub, kExprLocalSet, 0,
        kExprLocalGet, 0, kExprI32Const, 0, kExprI32GtS, kExprBrIf, 0,
      kExprEnd,
      kExprLocalGet, 1
    ]);
  // g(x) = (try { f(x, 5) } catch(x) { x }) + x
  builder.addFunction("main", kSig_i_i)
    .addBody([kExprTry, kWasmI32,
              kExprLocalGet, 0, kExprI32Const, 5,
                kExprCallFunction, callee.index,
              kExprCatch, tag,
              kExprEnd,
              kExprLocalGet, 0, kExprI32Add])
    .exportAs("main");

  let instance = builder.instantiate();
  assertEquals(25, instance.exports.main(10));
  assertEquals(-20, instance.exports.main(-10));
})();

(function InlineSubtypeSignatureTest() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();
  let struct = builder.addStruct([makeField(kWasmI32, true)]);

  let callee = builder
    .addFunction("callee", makeSig([wasmRefNullType(struct)], [kWasmI32]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprStructGet, struct, 0]);

  // When inlining "callee", TF should pass the real parameter type (ref 0) and
  // thus eliminate the null check for struct.get.
  builder.addFunction("main", makeSig([wasmRefType(struct)], [kWasmI32]))
    .addBody([kExprLocalGet, 0, kExprCallFunction, callee.index])
    .exportFunc();

  builder.instantiate({});
})();

(function InliningAndEscapeAnalysisTest() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();
  let struct = builder.addStruct([makeField(kWasmI32, true)]);

  let callee = builder
    .addFunction("callee", makeSig([wasmRefNullType(struct)], [kWasmI32]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprStructGet, struct, 0]);

  // The allocation should be removed.
  builder.addFunction("main", kSig_i_i)
    .addBody([
      kExprLocalGet, 0, kExprI32Const, 1, kExprI32Add,
      kGCPrefix, kExprStructNew, struct,
      kExprCallFunction, callee.index])
    .exportFunc();

  let instance = builder.instantiate({});
  assertEquals(11, instance.exports.main(10));
})();

(function Int64Lowering() {
  print(arguments.callee.name);

  let kSig_l_li = makeSig([kWasmI64, kWasmI32], [kWasmI64]);

  let builder = new WasmModuleBuilder();

  let callee = builder.addFunction("callee", kSig_l_li)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1, kExprI64SConvertI32, kExprI64Add]);

  builder.addFunction("main", kSig_l_li)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1, kExprCallFunction, callee.index])
    .exportFunc();

  let instance = builder.instantiate({});
  assertEquals(BigInt(21), instance.exports.main(BigInt(10), 11));
})();

(function InliningRecursiveTest() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();

  let factorial = builder
    .addFunction("factorial", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprI32Const, 1, kExprI32LeS,
              kExprIf, kWasmVoid, kExprI32Const, 1, kExprReturn, kExprEnd,
              kExprLocalGet, 0, kExprI32Const, 1, kExprI32Sub,
              kExprCallFunction, 0,
              kExprLocalGet, 0, kExprI32Mul]);

  builder.addFunction("main", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprCallFunction, factorial.index])
    .exportFunc();

  let instance = builder.instantiate({});
  assertEquals(1, instance.exports.main(1));
  // {factorial} should not be fully inlined in the trace.
  assertEquals(120, instance.exports.main(5));
})();

// When inlining a function with a tail call into a regular call, the tail call
// has to be transformed into a call. That new call node (or its projections)
// has to be typed.
(function CallFromTailCallMustBeTyped() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();

  let tail_call = builder
    .addFunction("tail_call", makeSig([], [kWasmFuncRef]))
    .addBody([kExprReturnCall, 0]);

  let tail_call_multi = builder
    .addFunction("tail_call", makeSig([], [kWasmFuncRef, kWasmFuncRef]))
    .addBody([kExprReturnCall, 1]);

  builder
    .addFunction("main", makeSig([], [wasmRefType(kWasmFuncRef), kWasmFuncRef,
                                      wasmRefType(kWasmFuncRef)]))
    .addBody([
      kExprCallFunction, tail_call.index, kExprRefAsNonNull,
      kExprCallFunction, tail_call_multi.index, kExprRefAsNonNull])

  builder.instantiate({});
})();

(function InliningTrapFromCallee() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  // Add some types to have an index offset.
  for (let i = 0; i < 10; ++i) {
    builder.addFunction(null, makeSig([], [])).addBody([]);
  }

  let callee = builder.addFunction('callee', kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI32DivU,
    ]);

  let intermediate = builder.addFunction('intermediate', kSig_i_ii)
    .addBody([
      // Some nops, so that the call doesn't have the same offset as the div
      // in the callee.
      kExprNop, kExprNop,
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprCallFunction, callee.index,
    ])
    .exportFunc();

  let caller = builder.addFunction('main', kSig_ii_ii)
    .addBody([
      // Some nops, so that the call doesn't have the same offset as the div
      // in the callee.
      kExprNop, kExprNop, kExprNop, kExprNop, kExprNop,
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprCallFunction, intermediate.index,
      // If it didn't trap, call it again without intermediate function and with
      // swapped arguments.
      kExprLocalGet, 1,
      kExprLocalGet, 0,
      kExprCallFunction, callee.index,
    ])
    .exportFunc();

  let wire_bytes = builder.toBuffer();
  let module = new WebAssembly.Module(wire_bytes);
  let instance = new WebAssembly.Instance(module, {});
  TestStackTrace(instance.exports.main);
  // Serialize and deserialize the module to verify that the inlining positions
  // are properly "transformed" here.
  print("Repeat test with serialized module.")
  module = %DeserializeWasmModule(%SerializeWasmModule(module), wire_bytes);
  instance = new WebAssembly.Instance(module, {});
  TestStackTrace(instance.exports.main);

  function TestStackTrace(main) {
    assertEquals([7, 0], main(21, 3));
    assertTraps(kTrapDivByZero, () => main(1, 0));
    try {
      main(1, 0);
      assertUnreachable();
    } catch(e) {
      assertMatches(/RuntimeError: divide by zero/, e.stack);
      let expected_entries = [
        // [name, index, offset]
        ['callee', '' + callee.index, '0x8c'],
        ['intermediate', '' + intermediate.index, '0x96'],
        ['main', '' + caller.index, '0xa4'],
      ];
      CheckCallStack(e, expected_entries);
    }

    try {
      main(0, 1);
      assertUnreachable();
    } catch(e) {
      assertMatches(/RuntimeError: divide by zero/, e.stack);
      let expected_entries = [
        // [name, index, offset]
        ['callee', '' + callee.index, '0x8c'],
        ['main', '' + caller.index, '0xaa'],
      ];
      CheckCallStack(e, expected_entries);
    }
  }

  function CheckCallStack(error, expected_entries) {
    print(error.stack);
    let regex = /at ([^ ]+) \(wasm[^\[]+\[([0-9]+)\]:(0x[0-9a-f]+)\)/g;
    let entries = [...error.stack.matchAll(regex)];
    for (let i = 0; i < expected_entries.length; ++i) {
      let actual = entries[i];
      print(`match = ${actual[0]}`);
      let expected = expected_entries[i];
      assertEquals(expected[0], actual[1]);
      assertEquals(expected[1], actual[2]);
      assertEquals(expected[2], actual[3]);
    }
    assertEquals(expected_entries.length, entries.length);
  }
})();

(function InliningTrapFromCalleeWithNestedTailCall() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  // Add some types to have an index offset.
  for (let i = 0; i < 10; ++i) {
    builder.addFunction(null, makeSig([], [])).addBody([]);
  }

  let callee = builder.addFunction('callee', kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI32DivU,
    ]);

  let intermediate = builder.addFunction('intermediate', kSig_i_ii)
    .addBody([
      // Some nops, so that the call doesn't have the same offset as the div
      // in the callee.
      kExprNop, kExprNop,
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprReturnCall, callee.index,
    ])
    .exportFunc();

  let caller = builder.addFunction('main', kSig_ii_ii)
    .addBody([
      // Some nops, so that the call doesn't have the same offset as the div
      // in the callee.
      kExprNop, kExprNop, kExprNop, kExprNop, kExprNop,
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprCallFunction, intermediate.index,
      // If it didn't trap, call it again without intermediate function and with
      // swapped arguments.
      kExprLocalGet, 1,
      kExprLocalGet, 0,
      kExprCallFunction, callee.index,
    ])
    .exportFunc();

  let wire_bytes = builder.toBuffer();
  let module = new WebAssembly.Module(wire_bytes);
  let instance = new WebAssembly.Instance(module, {});
  TestStackTrace(instance.exports.main);
  // Serialize and deserialize the module to verify that the inlining positions
  // are properly "transformed" here.
  print("Repeat test with serialized module.")
  module = %DeserializeWasmModule(%SerializeWasmModule(module), wire_bytes);
  instance = new WebAssembly.Instance(module, {});
  TestStackTrace(instance.exports.main);

  function TestStackTrace(main) {
    assertEquals([7, 0], main(21, 3));
    assertTraps(kTrapDivByZero, () => main(1, 0));
    // Test stack trace for trap.
    try {
      main(1, 0);
      assertUnreachable();
    } catch(e) {
      assertMatches(/RuntimeError: divide by zero/, e.stack);
      let expected_entries = [
        // [name, index, offset]
        ['callee', '' + callee.index, '0x8c'],
        ['main', '' + caller.index, '0xa4'],
      ];
      CheckCallStack(e, expected_entries);
    }

    try {
      main(0, 1);
      assertUnreachable();
    } catch(e) {
      assertMatches(/RuntimeError: divide by zero/, e.stack);
      let expected_entries = [
        // [name, index, offset]
        ['callee', '' + callee.index, '0x8c'],
        ['main', '' + caller.index, '0xaa'],
      ];
      CheckCallStack(e, expected_entries);
    }
  }

  function CheckCallStack(error, expected_entries) {
    print(error.stack);
    let regex = /at ([^ ]+) \(wasm[^\[]+\[([0-9]+)\]:(0x[0-9a-f]+)\)/g;
    let entries = [...error.stack.matchAll(regex)];
    for (let i = 0; i < expected_entries.length; ++i) {
      let actual = entries[i];
      print(`match = ${actual[0]}`);
      let expected = expected_entries[i];
      assertEquals(expected[0], actual[1]);
      assertEquals(expected[1], actual[2]);
      assertEquals(expected[2], actual[3]);
    }
    assertEquals(expected_entries.length, entries.length);
  }
})();

(function InliningTrapFromCalleeWithSingleTailCall() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  // Add some types to have an index offset.
  for (let i = 0; i < 10; ++i) {
    builder.addFunction(null, makeSig([], [])).addBody([]);
  }

  let callee = builder.addFunction('callee', kSig_ii_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI32DivU,
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI32Mul,
    ]);

  let caller = builder.addFunction('main', kSig_ii_ii)
    .addBody([
      // Some nops, so that the call doesn't have the same offset as the div
      // in the callee.
      kExprNop, kExprNop,
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprReturnCall, callee.index,
    ])
    .exportFunc();

  let wire_bytes = builder.toBuffer();
  let module = new WebAssembly.Module(wire_bytes);
  let instance = new WebAssembly.Instance(module, {});
  TestStackTrace(instance.exports.main);
  // Serialize and deserialize the module to verify that the inlining positions
  // are properly "transformed" here.
  print("Repeat test with serialized module.")
  module = %DeserializeWasmModule(%SerializeWasmModule(module), wire_bytes);
  instance = new WebAssembly.Instance(module, {});
  TestStackTrace(instance.exports.main);

  function TestStackTrace(main) {
    assertEquals([7, 63], main(21, 3));
    try {
      main(1, 0);
      assertUnreachable();
    } catch(e) {
      assertMatches(/RuntimeError: divide by zero/, e.stack);
      let expected_entries = [
        // [name, index, offset]
        ['callee', '' + callee.index, '0x77'],
      ];
      CheckCallStack(e, expected_entries);
    }
  }

  function CheckCallStack(error, expected_entries) {
    print(error.stack);
    let regex = /at ([^ ]+) \(wasm[^\[]+\[([0-9]+)\]:(0x[0-9a-f]+)\)/g;
    let entries = [...error.stack.matchAll(regex)];
    for (let i = 0; i < expected_entries.length; ++i) {
      let actual = entries[i];
      print(`match = ${actual[0]}`);
      let expected = expected_entries[i];
      assertEquals(expected[0], actual[1]);
      assertEquals(expected[1], actual[2]);
      assertEquals(expected[2], actual[3]);
    }
    assertEquals(expected_entries.length, entries.length);
  }
})();

(function InliningTrapFromCalleeWithMultipleCalls() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  // Add some types to have an index offset.
  for (let i = 0; i < 10; ++i) {
    builder.addFunction(null, makeSig([], [])).addBody([]);
  }

  let callee0 = builder.addFunction('callee0', kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI32DivU
    ]);

  let callee1 = builder.addFunction('callee1', kSig_i_ii)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprCallFunction,
              callee0.index]);

  let callee2 = builder.addFunction('callee2', kSig_i_ii)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprReturnCall,
              callee1.index])

  let callee3 = builder.addFunction('callee3', kSig_i_ii)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprReturnCall,
              callee2.index])

  let callee4 = builder.addFunction('callee4', kSig_i_ii)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprCallFunction,
              callee3.index]);

  let main = builder.addFunction('main', kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprReturnCall, callee4.index,
    ])
    .exportFunc();

  let wire_bytes = builder.toBuffer();
  let module = new WebAssembly.Module(wire_bytes);
  let instance = new WebAssembly.Instance(module, {});
  TestStackTrace(instance.exports.main);
  // Serialize and deserialize the module to verify that the inlining positions
  // are properly "transformed" here.
  print("Repeat test with serialized module.")
  module = %DeserializeWasmModule(%SerializeWasmModule(module), wire_bytes);
  instance = new WebAssembly.Instance(module, {});
  TestStackTrace(instance.exports.main);

  function TestStackTrace(main) {
    assertEquals(7, main(21, 3));
    try {
      main(1, 0);
      assertUnreachable();
    } catch(e) {
      assertMatches(/RuntimeError: divide by zero/, e.stack);
      let expected_entries = [
        // [name, index, offset]
        ['callee0', '' + callee0.index, '0x91'],
        ['callee1', '' + callee1.index, '0x99'],
        ['callee4', '' + callee4.index, '0xb4'],
      ];
      CheckCallStack(e, expected_entries);
    }
  }

  function CheckCallStack(error, expected_entries) {
    print(error.stack);
    let regex = /at ([^ ]+) \(wasm[^\[]+\[([0-9]+)\]:(0x[0-9a-f]+)\)/g;
    let entries = [...error.stack.matchAll(regex)];
    for (let i = 0; i < expected_entries.length; ++i) {
      let actual = entries[i];
      print(`match = ${actual[0]}`);
      let expected = expected_entries[i];
      assertEquals(expected[0], actual[1]);
      assertEquals(expected[1], actual[2]);
      assertEquals(expected[2], actual[3]);
    }
    assertEquals(expected_entries.length, entries.length);
  }
})();
                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/wasm/instance-gc.js                                                0000664 0000000 0000000 00000006035 14746647661 0022221 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --expose-gc

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

let nogc = () => {};

function newModule() {
  let builder = new WasmModuleBuilder();
  builder.addMemory(1, 1);
  builder.exportMemoryAs("memory");
  builder.addFunction("main", kSig_i_v)
    .addBody([kExprI32Const, 0, kExprI32LoadMem, 0, 0])
    .exportFunc();

  return new WebAssembly.Module(builder.toBuffer());
}

function newInstance(module, val) {
  var instance = new WebAssembly.Instance(module);
  var view = new Int32Array(instance.exports.memory.buffer);
  view[0] = val;
  return instance;
}

function TestSingleLiveInstance(gc) {
  let module = newModule();

  print("TestSingleLiveInstance...");
  for (var i = 0; i < 5; i++) {
    (() => {  // don't leak references between iterations.
      print(" [" + i + "]...");
      gc();
      var instance = newInstance(module, i + 99);
      assertEquals(i + 99, instance.exports.main());
    })();
  }
}

TestSingleLiveInstance(nogc);
TestSingleLiveInstance(gc);

function TestMultiInstance(gc) {
  let module = newModule();

  print("TestMultiInstance...");
  // Note: compute the root instances in another function to be
  // sure that {roots} really is the only set of roots to the instances.
  let roots = (() => { return [
    newInstance(module, 33),
    newInstance(module, 4444),
    newInstance(module, 555555)
  ];})();

  (() => { // don't leak references!
    print(" [0]...");
    gc();
    assertEquals(33, roots[0].exports.main());
    roots[0] = null;
  })();

  (() => { // don't leak references!
    print(" [1]...");
    gc();
    assertEquals(4444, roots[1].exports.main());
    roots[1] = null;
  })();

  (() => { // don't leak references!
    print(" [2]...");
    gc();
    assertEquals(555555, roots[2].exports.main());
    roots[2] = null;
  })();
}

TestMultiInstance(nogc);
TestMultiInstance(gc);

function TestReclaimingCompiledModule() {
  let module = newModule();

  print("TestReclaimingCompiledModule...");
  let roots = (() => { return [
    newInstance(module, 7777),
    newInstance(module, 8888),
  ];})();

  (() => { // don't leak references!
    print(" [0]...");
    assertEquals(7777, roots[0].exports.main());
    assertEquals(8888, roots[1].exports.main());
    roots[1] = null;
  })();

  (() => { // don't leak references!
    print(" [1]...");
    gc();
    roots[1] = newInstance(module, 9999);
    assertEquals(7777, roots[0].exports.main());
    assertEquals(9999, roots[1].exports.main());
    roots[0] = null;
    roots[1] = null;
  })();

  (() => { // don't leak references!
    print(" [2]...");
    gc();
    roots[0] = newInstance(module, 11111);
    roots[1] = newInstance(module, 22222);
    assertEquals(11111, roots[0].exports.main());
    assertEquals(22222, roots[1].exports.main());
    roots[0] = null;
    roots[1] = null;
  })();
}

TestReclaimingCompiledModule(nogc);
TestReclaimingCompiledModule(gc);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/wasm/instance-memory-gc-stress.js                                  0000664 0000000 0000000 00000010346 14746647661 0025050 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --expose-gc

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// This test verifies that when instances are exported, Gc'ed, the other
// instances in the chain still maintain a consistent view of the memory.
(function InstanceMemoryGcStress() {
  print("InstanceMemoryGcStress");
  let memory = new WebAssembly.Memory({initial: 100, maximum: 1500});
  var builder = new WasmModuleBuilder();
  builder.addImportedMemory("mod", "imported_mem");
  builder.addFunction("mem_size", kSig_i_v)
    .addBody([kExprMemorySize, kMemoryZero])
    .exportFunc();
  builder.addFunction("grow", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprMemoryGrow, kMemoryZero])
    .exportFunc();
  var instances = [];
  for (var i = 0; i < 5; i++) {
    gc();
    instances.push(builder.instantiate({mod: {imported_mem: memory}}));
  }
  function grow_instance_0(pages) { return instances[0].exports.grow(pages); }
  function grow_instance_1(pages) { return instances[1].exports.grow(pages); }
  function grow_instance_2(pages) { return instances[2].exports.grow(pages); }
  function grow_instance_3(pages) { return instances[3].exports.grow(pages); }
  function grow_instance_4(pages) { return instances[4].exports.grow(pages); }

  var start_index = 0;
  var end_index = 5;
  function verify_mem_size(expected_pages) {
    assertEquals(expected_pages*kPageSize, memory.buffer.byteLength);
    for (var i = start_index; i < end_index; i++) {
      assertEquals(expected_pages, instances[i].exports.mem_size());
    }
  }

  // Verify initial memory size of all instances, grow and verify that all
  // instances are updated correctly.
  verify_mem_size(100);
  assertEquals(100, memory.grow(500));
  verify_mem_size(600);

  instances[1] = null;
  gc();
  gc();

  // i[0] - i[2] - i[3] - i[4]
  start_index = 2;
  verify_mem_size(600);
  assertEquals(600, instances[0].exports.mem_size());
  assertEquals(600, grow_instance_2(200));
  assertEquals(800*kPageSize, memory.buffer.byteLength);
  verify_mem_size(800);
  assertEquals(800, instances[0].exports.mem_size());

  // Instantiate a new instance and verify that it can be grown correctly.
  instances.push(builder.instantiate({mod: {imported_mem: memory}}));
  function grow_instance_5(pages) { return instances[5].exports.grow(pages); }
  gc();
  gc();

  // i[0] - i[2] - i[3] - i[4] - i[5]
  start_index = 2;
  end_index = 6;
  verify_mem_size(800);
  assertEquals(800, instances[0].exports.mem_size());
  assertEquals(800, grow_instance_2(100));
  assertEquals(900*kPageSize, memory.buffer.byteLength);
  verify_mem_size(900);
  assertEquals(900, instances[0].exports.mem_size());

  instances[4] = null;

  gc();
  gc();

  // i[0] - i[2] - i[3] - i[5]
  assertEquals(900, instances[0].exports.mem_size());
  assertEquals(900, instances[2].exports.mem_size());
  assertEquals(900, instances[3].exports.mem_size());
  assertEquals(900, instances[5].exports.mem_size());
  assertEquals(900, memory.grow(100));
  assertEquals(1000*kPageSize, memory.buffer.byteLength);
  assertEquals(1000, instances[0].exports.mem_size());
  assertEquals(1000, instances[2].exports.mem_size());
  assertEquals(1000, instances[3].exports.mem_size());
  assertEquals(1000, instances[5].exports.mem_size());

  gc();
  gc();

  instances[3] = null;

  // i[0] - i[2] - i[5]
  assertEquals(1000, instances[0].exports.mem_size());
  assertEquals(1000, instances[2].exports.mem_size());
  assertEquals(1000, instances[5].exports.mem_size());
  assertEquals(1000, memory.grow(100));
  assertEquals(1100*kPageSize, memory.buffer.byteLength);
  assertEquals(1100, instances[0].exports.mem_size());
  assertEquals(1100, instances[2].exports.mem_size());
  assertEquals(1100, instances[5].exports.mem_size());

  instances[0] = null;
  gc();
  gc();

  // i[2] - i[5]
  assertEquals(1100, instances[2].exports.mem_size());
  assertEquals(1100, instances[5].exports.mem_size());
  assertEquals(1100, grow_instance_5(1));
  gc();
  gc();

  assertEquals(1101*kPageSize, memory.buffer.byteLength);
  assertEquals(1101, instances[2].exports.mem_size());
  assertEquals(1101, instances[5].exports.mem_size());
})();
                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/wasm/instantiate-module-basic.js                                   0000664 0000000 0000000 00000020104 14746647661 0024704 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --allow-natives-syntax

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

let kReturnValue = 17;

let buffer = (() => {
  let builder = new WasmModuleBuilder();
  builder.addMemory(1, 1);
  builder.exportMemoryAs('memory');
  builder.addFunction('main', kSig_i_v)
      .addBody([kExprI32Const, kReturnValue])
      .exportFunc();

  return builder.toBuffer();
})();

function CheckInstance(instance) {
  assertFalse(instance === undefined);
  assertFalse(instance === null);
  assertFalse(instance === 0);
  assertEquals('object', typeof instance);

  // Check the exports object is frozen.
  assertFalse(Object.isExtensible(instance.exports));
  assertTrue(Object.isFrozen(instance.exports));

  // Check the memory is WebAssembly.Memory.
  var mem = instance.exports.memory;
  assertFalse(mem === undefined);
  assertFalse(mem === null);
  assertFalse(mem === 0);
  assertEquals('object', typeof mem);
  assertTrue(mem instanceof WebAssembly.Memory);
  var buf = mem.buffer;
  assertTrue(buf instanceof ArrayBuffer);
  assertEquals(65536, buf.byteLength);
  for (var i = 0; i < 4; i++) {
    instance.exports.memory = 0;  // should be ignored
    mem.buffer = 0;               // should be ignored
    assertSame(mem, instance.exports.memory);
    assertSame(buf, mem.buffer);
  }

  // Check the properties of the main function.
  let main = instance.exports.main;
  assertFalse(main === undefined);
  assertFalse(main === null);
  assertFalse(main === 0);
  assertEquals('function', typeof main);

  assertEquals(kReturnValue, main());
}

// Official API
(function BasicJSAPITest() {
  print('sync module compile...');
  let module = new WebAssembly.Module(buffer);
  print('sync module instantiate...');
  CheckInstance(new WebAssembly.Instance(module));

  print('async module compile...');
  let promise = WebAssembly.compile(buffer);
  assertPromiseResult(
      promise, module => CheckInstance(new WebAssembly.Instance(module)));

  print('async instantiate...');
  let instance_promise = WebAssembly.instantiate(buffer);
  assertPromiseResult(instance_promise, pair => CheckInstance(pair.instance));
})();

// Check that validate works correctly for a module.
assertTrue(WebAssembly.validate(buffer));
assertFalse(WebAssembly.validate(bytes(88, 88, 88, 88, 88, 88, 88, 88)));

// Negative tests.
(function InvalidModules() {
  print('InvalidModules...');
  let invalid_cases = [undefined, 1, '', 'a', {some: 1, obj: 'b'}];
  let len = invalid_cases.length;
  for (var i = 0; i < len; ++i) {
    try {
      let instance = new WebAssembly.Instance(invalid_cases[i]);
      assertUnreachable('should not be able to instantiate invalid modules.');
    } catch (e) {
      assertContains('Argument 0', e.toString());
    }
  }
})();

// Compile async an invalid blob.
(function InvalidBinaryAsyncCompilation() {
  print('InvalidBinaryAsyncCompilation...');
  let builder = new WasmModuleBuilder();
  builder.addFunction('f', kSig_i_i).addBody([kExprCallFunction, 0]);
  assertThrowsAsync(
      WebAssembly.compile(builder.toBuffer()), WebAssembly.CompileError);
})();

// Multiple instances tests.
(function ManyInstances() {
  print('ManyInstances...');
  let compiled_module = new WebAssembly.Module(buffer);
  let instance_1 = new WebAssembly.Instance(compiled_module);
  let instance_2 = new WebAssembly.Instance(compiled_module);
  assertTrue(instance_1 != instance_2);
})();

(function ManyInstancesAsync() {
  print('ManyInstancesAsync...');
  let promise = WebAssembly.compile(buffer);
  assertPromiseResult(promise, compiled_module => {
    let instance_1 = new WebAssembly.Instance(compiled_module);
    let instance_2 = new WebAssembly.Instance(compiled_module);
    assertTrue(instance_1 != instance_2);
  });
})();

(function InstancesAreIsolatedFromEachother() {
  print('InstancesAreIsolatedFromEachother...');
  var builder = new WasmModuleBuilder();
  builder.addImportedMemory('', 'memory', 1);
  var kSig_v_i = makeSig([kWasmI32], []);
  var signature = builder.addType(kSig_v_i);
  builder.addImport('m', 'some_value', kSig_i_v);
  builder.addImport('m', 'writer', signature);

  builder.addFunction('main', kSig_i_i)
      .addBody([
        kExprLocalGet, 0, kExprI32LoadMem, 0, 0, kExprI32Const, 1,
        kExprCallIndirect, signature, kTableZero, kExprLocalGet, 0,
        kExprI32LoadMem, 0, 0, kExprCallFunction, 0, kExprI32Add
      ])
      .exportFunc();

  // writer(mem[i]);
  // return mem[i] + some_value();
  builder.addFunction('_wrap_writer', signature).addBody([
    kExprLocalGet, 0, kExprCallFunction, 1
  ]);
  builder.appendToTable([2, 3]);

  var module = new WebAssembly.Module(builder.toBuffer());
  var mem_1 = new WebAssembly.Memory({initial: 1});
  var mem_2 = new WebAssembly.Memory({initial: 1});
  var view_1 = new Int32Array(mem_1.buffer);
  var view_2 = new Int32Array(mem_2.buffer);

  view_1[0] = 42;
  view_2[0] = 1000;

  var outval_1;
  var outval_2;
  var i1 = new WebAssembly.Instance(module, {
    m: {some_value: () => 1, writer: (x) => outval_1 = x},
    '': {memory: mem_1}
  });

  var i2 = new WebAssembly.Instance(module, {
    m: {some_value: () => 2, writer: (x) => outval_2 = x},
    '': {memory: mem_2}
  });

  assertEquals(43, i1.exports.main(0));
  assertEquals(1002, i2.exports.main(0));

  assertEquals(42, outval_1);
  assertEquals(1000, outval_2);
})();

(function GlobalsArePrivateToTheInstance() {
  print('GlobalsArePrivateToTheInstance...');
  var builder = new WasmModuleBuilder();
  builder.addGlobal(kWasmI32, true, false);
  builder.addFunction('read', kSig_i_v)
      .addBody([kExprGlobalGet, 0])
      .exportFunc();

  builder.addFunction('write', kSig_v_i)
      .addBody([kExprLocalGet, 0, kExprGlobalSet, 0])
      .exportFunc();

  var module = new WebAssembly.Module(builder.toBuffer());
  var i1 = new WebAssembly.Instance(module);
  var i2 = new WebAssembly.Instance(module);
  i1.exports.write(1);
  i2.exports.write(2);
  assertEquals(1, i1.exports.read());
  assertEquals(2, i2.exports.read());
})();

(function InstanceMemoryIsIsolated() {
  print('InstanceMemoryIsIsolated...');
  var builder = new WasmModuleBuilder();
  builder.addImportedMemory('', 'memory', 1);

  builder.addFunction('f', kSig_i_v)
      .addBody([kExprI32Const, 0, kExprI32LoadMem, 0, 0])
      .exportFunc();

  var mem_1 = new WebAssembly.Memory({initial: 1});
  var mem_2 = new WebAssembly.Memory({initial: 1});
  var view_1 = new Int32Array(mem_1.buffer);
  var view_2 = new Int32Array(mem_2.buffer);
  view_1[0] = 1;
  view_2[0] = 1000;

  var module = new WebAssembly.Module(builder.toBuffer());
  var i1 = new WebAssembly.Instance(module, {'': {memory: mem_1}});
  var i2 = new WebAssembly.Instance(module, {'': {memory: mem_2}});

  assertEquals(1, i1.exports.f());
  assertEquals(1000, i2.exports.f());
})();

(function MustBeMemory() {
  print('MustBeMemory...');
  var memory = new ArrayBuffer(65536);
  let builder = new WasmModuleBuilder();
  builder.addImportedMemory('', 'memory');

  let module = new WebAssembly.Module(builder.toBuffer());

  assertThrows(
      () => new WebAssembly.Instance(module, {'': {memory: memory}}),
      WebAssembly.LinkError);
})();

(function TestNoMemoryToExport() {
  let builder = new WasmModuleBuilder();
  builder.exportMemoryAs('memory', 0);
  assertThrows(() => builder.instantiate(), WebAssembly.CompileError);
})();

(function TestIterableExports() {
  print('TestIterableExports...');
  let builder = new WasmModuleBuilder;
  builder.addExport('a', builder.addFunction('', kSig_v_v).addBody([]));
  builder.addExport('b', builder.addFunction('', kSig_v_v).addBody([]));
  builder.addExport('c', builder.addFunction('', kSig_v_v).addBody([]));
  builder.addExport('d', builder.addFunction('', kSig_v_v).addBody([]));
  builder.addExport('e', builder.addGlobal(kWasmI32, false, false));

  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);

  let exports_count = 0;
  for (var e in instance.exports) ++exports_count;

  assertEquals(5, exports_count);
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/wasm/instantiate-run-basic.js                                      0000664 0000000 0000000 00000001642 14746647661 0024231 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

const kReturnValue = 15;

function getBuilder() {
  var builder = new WasmModuleBuilder();

  builder.addFunction("main", kSig_i_i)
    .addBody([kExprI32Const, kReturnValue])
    .exportFunc();
  return builder;
}

(function BasicTest() {
  var builder = getBuilder();
  var main = builder.instantiate().exports.main;
  assertEquals(kReturnValue, main());
})();

(function AsyncTest() {
  var builder = getBuilder();
  var buffer = builder.toBuffer();
  assertPromiseResult(
    WebAssembly.instantiate(buffer)
      .then(pair => pair.instance.exports.main(), assertUnreachable)
      .then(result => assertEquals(kReturnValue, result), assertUnreachable));
})();
                                                                                              node-23.7.0/deps/v8/test/mjsunit/wasm/interrupt-worker-with-perf.js                                 0000664 0000000 0000000 00000000413 14746647661 0025266 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --prof

d8.file.execute('test/mjsunit/wasm/worker-running-empty-loop-interruptible.js');
                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/wasm/js-api.js                                                     0000664 0000000 0000000 00000110735 14746647661 0021214 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

function assertEq(val, expected) {
  assertSame(expected, val);
}
function assertArrayBuffer(val, expected) {
  assertTrue(val instanceof ArrayBuffer);
  assertEq(expected.length, val.byteLength);
  var input = new Int8Array(val);
  for (var i = 0; i < expected.length; i++) {
    assertEq(expected[i], input[i]);
  }
}

function isConstructor(value) {
  var p = new Proxy(value, { construct: () => ({}) });
  try {
    return new p, true;
  } catch(e) {
    return false;
  }
}

let emptyModuleBinary = (() => {
  var builder = new WasmModuleBuilder();
  return new Int8Array(builder.toBuffer());
})();

let exportingModuleBinary = (() => {
  var builder = new WasmModuleBuilder();
  builder.addFunction('f', kSig_i_v).addBody([kExprI32Const, 42]).exportAs('f');
  return new Int8Array(builder.toBuffer());
})();

let importingModuleBinary = (() => {
  var builder = new WasmModuleBuilder();
  builder.addImport('', 'f', kSig_i_v);
  return new Int8Array(builder.toBuffer());
})();

let memoryImportingModuleBinary = (() => {
  var builder = new WasmModuleBuilder();
  builder.addImportedMemory('', 'my_memory');
  return new Int8Array(builder.toBuffer());
})();

let moduleBinaryImporting2Memories = (() => {
  var builder = new WasmModuleBuilder();
  builder.addImportedMemory('', 'memory1');
  builder.addImportedMemory('', 'memory2');
  return new Int8Array(builder.toBuffer());
})();

let moduleBinaryWithMemSectionAndMemImport = (() => {
  var builder = new WasmModuleBuilder();
  builder.addImportedMemory('', 'memory1');
  builder.addMemory(1, 1);
  return new Int8Array(builder.toBuffer());
})();

// 'WebAssembly' data property on global object
let wasmDesc = Object.getOwnPropertyDescriptor(this, 'WebAssembly');
assertEq(typeof wasmDesc.value, 'object');
assertTrue(wasmDesc.writable);
assertFalse(wasmDesc.enumerable);
assertTrue(wasmDesc.configurable);

// 'WebAssembly' object
assertEq(WebAssembly, wasmDesc.value);
assertEq(String(WebAssembly), '[object WebAssembly]');

// 'WebAssembly.CompileError'
let compileErrorDesc =
    Object.getOwnPropertyDescriptor(WebAssembly, 'CompileError');
assertEq(typeof compileErrorDesc.value, 'function');
assertTrue(compileErrorDesc.writable);
assertFalse(compileErrorDesc.enumerable);
assertTrue(compileErrorDesc.configurable);
let CompileError = WebAssembly.CompileError;
assertEq(CompileError, compileErrorDesc.value);
assertEq(CompileError.length, 1);
assertEq(CompileError.name, 'CompileError');
assertTrue(isConstructor(CompileError));
let compileError = new CompileError;
assertTrue(compileError instanceof CompileError);
assertTrue(compileError instanceof Error);
assertFalse(compileError instanceof TypeError);
assertEq(compileError.message, '');
assertEq(new CompileError('hi').message, 'hi');

// 'WebAssembly.RuntimeError'
let runtimeErrorDesc =
    Object.getOwnPropertyDescriptor(WebAssembly, 'RuntimeError');
assertEq(typeof runtimeErrorDesc.value, 'function');
assertTrue(runtimeErrorDesc.writable);
assertFalse(runtimeErrorDesc.enumerable);
assertTrue(runtimeErrorDesc.configurable);
let RuntimeError = WebAssembly.RuntimeError;
assertEq(RuntimeError, runtimeErrorDesc.value);
assertEq(RuntimeError.length, 1);
assertEq(RuntimeError.name, 'RuntimeError');
assertTrue(isConstructor(RuntimeError));
let runtimeError = new RuntimeError;
assertTrue(runtimeError instanceof RuntimeError);
assertTrue(runtimeError instanceof Error);
assertFalse(runtimeError instanceof TypeError);
assertEq(runtimeError.message, '');
assertEq(new RuntimeError('hi').message, 'hi');

// 'WebAssembly.LinkError'
let linkErrorDesc = Object.getOwnPropertyDescriptor(WebAssembly, 'LinkError');
assertEq(typeof linkErrorDesc.value, 'function');
assertTrue(linkErrorDesc.writable);
assertFalse(linkErrorDesc.enumerable);
assertTrue(linkErrorDesc.configurable);
let LinkError = WebAssembly.LinkError;
assertEq(LinkError, linkErrorDesc.value);
assertEq(LinkError.length, 1);
assertEq(LinkError.name, 'LinkError');
assertTrue(isConstructor(LinkError));
let linkError = new LinkError;
assertTrue(linkError instanceof LinkError);
assertTrue(linkError instanceof Error);
assertFalse(linkError instanceof TypeError);
assertEq(linkError.message, '');
assertEq(new LinkError('hi').message, 'hi');

// 'WebAssembly.Module' data property
let moduleDesc = Object.getOwnPropertyDescriptor(WebAssembly, 'Module');
assertEq(typeof moduleDesc.value, 'function');
assertTrue(moduleDesc.writable);
assertFalse(moduleDesc.enumerable);
assertTrue(moduleDesc.configurable);

// 'WebAssembly.Module' constructor function
let Module = WebAssembly.Module;
assertEq(Module, moduleDesc.value);
assertEq(Module.length, 1);
assertEq(Module.name, 'Module');
assertTrue(isConstructor(Module));
assertThrows(
    () => Module(), TypeError, /must be invoked with 'new'/);
assertThrows(
    () => new Module(), TypeError, /Argument 0 must be a buffer source/);
assertThrows(
    () => new Module(undefined), TypeError,
    'WebAssembly.Module(): Argument 0 must be a buffer source');
assertThrows(
    () => new Module(1), TypeError,
    'WebAssembly.Module(): Argument 0 must be a buffer source');
assertThrows(
    () => new Module({}), TypeError,
    'WebAssembly.Module(): Argument 0 must be a buffer source');
assertThrows(
    () => new Module(new Uint8Array()), CompileError,
    /BufferSource argument is empty/);
assertThrows(
    () => new Module(new ArrayBuffer()), CompileError,
    /BufferSource argument is empty/);
assertTrue(new Module(emptyModuleBinary) instanceof Module);
assertTrue(new Module(emptyModuleBinary.buffer) instanceof Module);

// 'WebAssembly.Module.prototype' data property
let moduleProtoDesc = Object.getOwnPropertyDescriptor(Module, 'prototype');
assertEq(typeof moduleProtoDesc.value, 'object');
assertFalse(moduleProtoDesc.writable);
assertFalse(moduleProtoDesc.enumerable);
assertFalse(moduleProtoDesc.configurable);

// 'WebAssembly.Module.prototype' object
let moduleProto = Module.prototype;
assertEq(moduleProto, moduleProtoDesc.value);
assertEq(String(moduleProto), '[object WebAssembly.Module]');
assertEq(Object.getPrototypeOf(moduleProto), Object.prototype);

// 'WebAssembly.Module' instance objects
let emptyModule = new Module(emptyModuleBinary);
let importingModule = new Module(importingModuleBinary);
let exportingModule = new Module(exportingModuleBinary);
assertEq(typeof emptyModule, 'object');
assertEq(String(emptyModule), '[object WebAssembly.Module]');
assertEq(Object.getPrototypeOf(emptyModule), moduleProto);

// 'WebAssembly.Module.imports' data property
let moduleImportsDesc = Object.getOwnPropertyDescriptor(Module, 'imports');
assertEq(typeof moduleImportsDesc.value, 'function');
assertTrue(moduleImportsDesc.writable);
assertTrue(moduleImportsDesc.enumerable);
assertTrue(moduleImportsDesc.configurable);

// 'WebAssembly.Module.imports' method
let moduleImports = moduleImportsDesc.value;
assertEq(moduleImports.length, 1);
assertFalse(isConstructor(moduleImports));
assertThrows(
    () => moduleImports(), TypeError, /Argument 0 must be a WebAssembly.Module/);
assertThrows(
    () => moduleImports(undefined), TypeError,
    /Argument 0 must be a WebAssembly.Module/);
assertThrows(
    () => moduleImports({}), TypeError,
    /Argument 0 must be a WebAssembly.Module/);
var arr = moduleImports(new Module(emptyModuleBinary));
assertTrue(arr instanceof Array);
assertEq(arr.length, 0);
let importingModuleBinary2 = (() => {
  var text =
      '(module (func (import "a" "b")) (memory (import "c" "d") 1) (table (import "e" "f") 1 anyfunc) (global (import "g" "⚡") i32))'
  let builder = new WasmModuleBuilder();
  builder.addImport('a', 'b', kSig_i_i);
  builder.addImportedMemory('c', 'd');
  builder.addImportedTable('e', 'f');
  builder.addImportedGlobal('g', 'x', kWasmI32);
  return new Int8Array(builder.toBuffer());
})();
var arr = moduleImports(new Module(importingModuleBinary2));
assertTrue(arr instanceof Array);
assertEq(arr.length, 4);
assertEq(arr[0].kind, 'function');
assertEq(arr[0].module, 'a');
assertEq(arr[0].name, 'b');
assertEq(arr[1].kind, 'memory');
assertEq(arr[1].module, 'c');
assertEq(arr[1].name, 'd');
assertEq(arr[2].kind, 'table');
assertEq(arr[2].module, 'e');
assertEq(arr[2].name, 'f');
assertEq(arr[3].kind, 'global');
assertEq(arr[3].module, 'g');
assertEq(arr[3].name, 'x');

// 'WebAssembly.Module.exports' data property
let moduleExportsDesc = Object.getOwnPropertyDescriptor(Module, 'exports');
assertEq(typeof moduleExportsDesc.value, 'function');
assertTrue(moduleExportsDesc.writable);
assertTrue(moduleExportsDesc.enumerable);
assertTrue(moduleExportsDesc.configurable);

// 'WebAssembly.Module.exports' method
let moduleExports = moduleExportsDesc.value;
assertEq(moduleExports.length, 1);
assertFalse(isConstructor(moduleExports));
assertThrows(
    () => moduleExports(), TypeError, /Argument 0 must be a WebAssembly.Module/);
assertThrows(
    () => moduleExports(undefined), TypeError,
    /Argument 0 must be a WebAssembly.Module/);
assertThrows(
    () => moduleExports({}), TypeError,
    /Argument 0 must be a WebAssembly.Module/);
var arr = moduleExports(emptyModule);
assertTrue(arr instanceof Array);
assertEq(arr.length, 0);
let exportingModuleBinary2 = (() => {
  var text =
      '(module (func (export "a")) (memory (export "b") 1) (table (export "c") 1 anyfunc) (global (export "⚡") i32 (i32.const 0)))';
  let builder = new WasmModuleBuilder();
  builder.addFunction('foo', kSig_v_v).addBody([]).exportAs('a');
  builder.addMemory(1, 1);
  builder.exportMemoryAs('b');
  builder.setTableBounds(1, 1);
  builder.addExportOfKind('c', kExternalTable, 0);
  var o = builder.addGlobal(kWasmI32, false, false).exportAs('x');
  return new Int8Array(builder.toBuffer());
})();
var arr = moduleExports(new Module(exportingModuleBinary2));
assertTrue(arr instanceof Array);
assertEq(arr.length, 4);
assertEq(arr[0].kind, 'function');
assertEq(arr[0].name, 'a');
assertEq(arr[1].kind, 'memory');
assertEq(arr[1].name, 'b');
assertEq(arr[2].kind, 'table');
assertEq(arr[2].name, 'c');
assertEq(arr[3].kind, 'global');
assertEq(arr[3].name, 'x');

// 'WebAssembly.Module.customSections' data property
let moduleCustomSectionsDesc =
    Object.getOwnPropertyDescriptor(Module, 'customSections');
assertEq(typeof moduleCustomSectionsDesc.value, 'function');
assertTrue(moduleCustomSectionsDesc.writable);
assertTrue(moduleCustomSectionsDesc.enumerable);
assertTrue(moduleCustomSectionsDesc.configurable);

// 'WebAssembly.Module.customSections' method
let moduleCustomSections = moduleCustomSectionsDesc.value;
assertEq(moduleCustomSections.length, 2);
assertFalse(isConstructor(moduleCustomSections));
assertThrows(
    () => moduleCustomSections(), TypeError, /Argument 0 must be a WebAssembly.Module/);
assertThrows(
    () => moduleCustomSections(undefined), TypeError,
    /Argument 0 must be a WebAssembly.Module/);
assertThrows(
    () => moduleCustomSections({}), TypeError,
    /Argument 0 must be a WebAssembly.Module/);
var arr = moduleCustomSections(emptyModule, 'x');
assertEq(arr instanceof Array, true);
assertEq(arr.length, 0);

assertThrows(
    () => moduleCustomSections(1), TypeError,
    'WebAssembly.Module.customSections(): Argument 0 must be a WebAssembly.Module');

let customSectionModuleBinary2 = (() => {
  let builder = new WasmModuleBuilder();
  builder.addCustomSection('x', [2]);
  builder.addCustomSection('foo', [66, 77]);
  builder.addCustomSection('foo', [91, 92, 93]);
  builder.addCustomSection('fox', [99, 99, 99]);
  return new Int8Array(builder.toBuffer());
})();
var arr = moduleCustomSections(new Module(customSectionModuleBinary2), 'x');
assertEq(arr instanceof Array, true);
assertEq(arr.length, 1);
assertArrayBuffer(arr[0], [2]);
var arr = moduleCustomSections(new Module(customSectionModuleBinary2), 'foo');
assertEq(arr instanceof Array, true);
assertEq(arr.length, 2);
assertArrayBuffer(arr[0], [66, 77]);
assertArrayBuffer(arr[1], [91, 92, 93]);
var arr = moduleCustomSections(new Module(customSectionModuleBinary2), 'bar');
assertEq(arr instanceof Array, true);
assertEq(arr.length, 0);
var o = {toString() { return "foo" }}
var arr = moduleCustomSections(new Module(customSectionModuleBinary2), o);
assertEq(arr instanceof Array, true);
assertEq(arr.length, 2);
assertArrayBuffer(arr[0], [66, 77]);
assertArrayBuffer(arr[1], [91, 92, 93]);
var o = {toString() { throw "boo!" }}
assertThrows(
  () => moduleCustomSections(new Module(customSectionModuleBinary2), o));

// 'WebAssembly.Instance' data property
let instanceDesc = Object.getOwnPropertyDescriptor(WebAssembly, 'Instance');
assertEq(typeof instanceDesc.value, 'function');
assertTrue(instanceDesc.writable);
assertFalse(instanceDesc.enumerable);
assertTrue(instanceDesc.configurable);

// 'WebAssembly.Instance' constructor function
let Instance = WebAssembly.Instance;
assertEq(Instance, instanceDesc.value);
assertEq(Instance.length, 1);
assertEq(Instance.name, 'Instance');
assertTrue(isConstructor(Instance));
assertThrows(
    () => Instance(), TypeError, /must be invoked with 'new'/);
assertThrows(
    () => new Instance(1), TypeError,
    'WebAssembly.Instance(): Argument 0 must be a WebAssembly.Module');
assertThrows(
    () => new Instance({}), TypeError,
    'WebAssembly.Instance(): Argument 0 must be a WebAssembly.Module');
assertThrows(
    () => new Instance(emptyModule, null), TypeError,
    'WebAssembly.Instance(): Argument 1 must be an object');
assertThrows(() => new Instance(importingModule, null), TypeError);
assertThrows(
    () => new Instance(importingModule, undefined), TypeError);
assertThrows(
    () => new Instance(importingModule, {'': {g: () => {}}}), LinkError);
assertThrows(
    () => new Instance(importingModule, {t: {f: () => {}}}), TypeError);

assertTrue(new Instance(emptyModule) instanceof Instance);
assertTrue(new Instance(emptyModule, {}) instanceof Instance);

// 'WebAssembly.Instance.prototype' data property
let instanceProtoDesc = Object.getOwnPropertyDescriptor(Instance, 'prototype');
assertEq(typeof instanceProtoDesc.value, 'object');
assertFalse(instanceProtoDesc.writable);
assertFalse(instanceProtoDesc.enumerable);
assertFalse(instanceProtoDesc.configurable);

// 'WebAssembly.Instance.prototype' object
let instanceProto = Instance.prototype;
assertEq(instanceProto, instanceProtoDesc.value);
assertEq(String(instanceProto), '[object WebAssembly.Instance]');
assertEq(Object.getPrototypeOf(instanceProto), Object.prototype);

// 'WebAssembly.Instance' instance objects
let exportingInstance = new Instance(exportingModule);
assertEq(typeof exportingInstance, 'object');
assertEq(String(exportingInstance), '[object WebAssembly.Instance]');
assertEq(Object.getPrototypeOf(exportingInstance), instanceProto);

// 'WebAssembly.Instance' 'exports' getter property
let instanceExportsDesc =
    Object.getOwnPropertyDescriptor(instanceProto, 'exports');
assertEq(typeof instanceExportsDesc.get, 'function');
assertEq(instanceExportsDesc.get.name, 'get exports');
assertEq(instanceExportsDesc.get.length, 0);
assertFalse(isConstructor(instanceExportsDesc.get));
assertFalse('prototype' in instanceExportsDesc.get);
assertEq(instanceExportsDesc.set, undefined);
assertTrue(instanceExportsDesc.enumerable);
assertTrue(instanceExportsDesc.configurable);

exportsObj = exportingInstance.exports;
assertEq(typeof exportsObj, 'object');
assertFalse(Object.isExtensible(exportsObj));
assertEq(Object.getPrototypeOf(exportsObj), null);
assertEq(Object.keys(exportsObj).join(), 'f');

// Exported WebAssembly functions
let f = exportingInstance.exports.f;
assertTrue(f instanceof Function);
assertEq(f.length, 0);
assertTrue('name' in f);
assertEq(Function.prototype.call.call(f), 42);
assertThrows(() => new f(), TypeError, /is not a constructor/);

// 'WebAssembly.Memory' data property
let memoryDesc = Object.getOwnPropertyDescriptor(WebAssembly, 'Memory');
assertEq(typeof memoryDesc.value, 'function');
assertTrue(memoryDesc.writable);
assertFalse(memoryDesc.enumerable);
assertTrue(memoryDesc.configurable);

// 'WebAssembly.Memory' constructor function
let Memory = WebAssembly.Memory;
assertEq(Memory, memoryDesc.value);
assertEq(Memory.length, 1);
assertEq(Memory.name, 'Memory');
assertTrue(isConstructor(Memory));
assertThrows(
    () => Memory(), TypeError, /must be invoked with 'new'/);
assertThrows(
    () => new Memory(1), TypeError,
    'WebAssembly.Memory(): Argument 0 must be a memory descriptor');
assertThrows(
    () => new Memory({initial: {valueOf() { throw new Error('here') }}}), Error,
    'here');
assertThrows(
    () => new Memory({initial: -1}), TypeError, /must be non-negative/);
assertThrows(
    () => new Memory({initial: Math.pow(2, 32)}), TypeError,
    /must be in the unsigned long range/);
assertThrows(
    () => new Memory({initial: 1, maximum: Math.pow(2, 32) / Math.pow(2, 14)}),
    RangeError, /is above the upper bound/);
assertThrows(
    () => new Memory({initial: 2, maximum: 1}), RangeError,
    /is below the lower bound/);
assertThrows(
    () => new Memory({maximum: -1}), TypeError, /'initial' is required/);
assertTrue(new Memory({initial: 1}) instanceof Memory);
assertEq(new Memory({initial: 1.5}).buffer.byteLength, kPageSize);

// 'WebAssembly.Memory.prototype' data property
let memoryProtoDesc = Object.getOwnPropertyDescriptor(Memory, 'prototype');
assertEq(typeof memoryProtoDesc.value, 'object');
assertFalse(memoryProtoDesc.writable);
assertFalse(memoryProtoDesc.enumerable);
assertFalse(memoryProtoDesc.configurable);

// 'WebAssembly.Memory.prototype' object
let memoryProto = Memory.prototype;
assertEq(memoryProto, memoryProtoDesc.value);
assertEq(String(memoryProto), '[object WebAssembly.Memory]');
assertEq(Object.getPrototypeOf(memoryProto), Object.prototype);

// 'WebAssembly.Memory' instance objects
let mem1 = new Memory({initial: 1});
assertEq(typeof mem1, 'object');
assertEq(String(mem1), '[object WebAssembly.Memory]');
assertEq(Object.getPrototypeOf(mem1), memoryProto);

// 'WebAssembly.Memory.prototype.buffer' accessor property
let bufferDesc = Object.getOwnPropertyDescriptor(memoryProto, 'buffer');
assertEq(typeof bufferDesc.get, 'function');
assertEq(bufferDesc.get.name, 'get buffer');
assertEq(bufferDesc.get.length, 0);
assertFalse(isConstructor(bufferDesc.get));
assertFalse('prototype' in bufferDesc.get);
assertEq(bufferDesc.set, undefined);
assertTrue(bufferDesc.enumerable);
assertTrue(bufferDesc.configurable);

// 'WebAssembly.Memory.prototype.buffer' getter
let bufferGetter = bufferDesc.get;
assertThrows(
    () => bufferGetter.call(), TypeError, /Receiver is not a WebAssembly.Memory/);
assertThrows(
    () => bufferGetter.call({}), TypeError, /Receiver is not a WebAssembly.Memory/);
assertTrue(bufferGetter.call(mem1) instanceof ArrayBuffer);
assertEq(bufferGetter.call(mem1).byteLength, kPageSize);

// 'WebAssembly.Memory.prototype.grow' data property
let memGrowDesc = Object.getOwnPropertyDescriptor(memoryProto, 'grow');
assertEq(typeof memGrowDesc.value, 'function');
assertTrue(memGrowDesc.enumerable);
assertTrue(memGrowDesc.configurable);

// 'WebAssembly.Memory.prototype.grow' method
let memGrow = memGrowDesc.value;
assertEq(memGrow.length, 1);
assertFalse(isConstructor(memGrow));
assertThrows(
    () => memGrow.call(), TypeError, /Receiver is not a WebAssembly.Memory/);
assertThrows(
    () => memGrow.call({}), TypeError, /Receiver is not a WebAssembly.Memory/);
assertThrows(
    () => memGrow.call(mem1, -1), TypeError, /must be non-negative/);
assertThrows(
    () => memGrow.call(mem1, Math.pow(2, 32)), TypeError,
    /must be in the unsigned long range/);
var mem = new Memory({initial: 1, maximum: 2});
var buf = mem.buffer;
assertEq(buf.byteLength, kPageSize);
assertEq(mem.grow(0), 1);
assertTrue(buf !== mem.buffer);
assertEq(buf.byteLength, 0);
buf = mem.buffer;
assertEq(buf.byteLength, kPageSize);
assertEq(mem.grow(1, 23), 1);
assertTrue(buf !== mem.buffer);
assertEq(buf.byteLength, 0);
buf = mem.buffer;
assertEq(buf.byteLength, 2 * kPageSize);
assertEq(mem.grow(0), 2);
assertTrue(buf !== mem.buffer);
assertEq(buf.byteLength, 0);
buf = mem.buffer;
assertEq(buf.byteLength, 2 * kPageSize);
assertThrows(() => mem.grow(1), Error, /Maximum memory size exceeded/);
assertThrows(() => mem.grow(Infinity), Error, /must be convertible to a valid number/);
assertThrows(() => mem.grow(-Infinity), Error, /must be convertible to a valid number/);
assertEq(buf, mem.buffer);
let throwOnValueOf = {
  valueOf: function() {
    throw Error('throwOnValueOf')
  }
};
assertThrows(() => mem.grow(throwOnValueOf), Error, /throwOnValueOf/);
assertEq(buf, mem.buffer);
let zero_wrapper = {
  valueOf: function() {
    ++this.call_counter;
    return 0;
  },
  call_counter: 0
};
assertEq(mem.grow(zero_wrapper), 2);
assertEq(zero_wrapper.call_counter, 1);
assertTrue(buf !== mem.buffer);
assertEq(buf.byteLength, 0);
buf = mem.buffer;
assertEq(buf.byteLength, 2 * kPageSize);

let empty_mem = new Memory({initial: 0, maximum: 5});
let empty_buf = empty_mem.buffer;
assertEq(empty_buf.byteLength, 0);
assertEq(empty_mem.grow(0), 0);
assertEq(empty_mem.buffer.byteLength, 0);
assertTrue(empty_buf !== empty_mem.buffer);

// 'WebAssembly.Table' data property
let tableDesc = Object.getOwnPropertyDescriptor(WebAssembly, 'Table');
assertEq(typeof tableDesc.value, 'function');
assertTrue(tableDesc.writable);
assertFalse(tableDesc.enumerable);
assertTrue(tableDesc.configurable);

// 'WebAssembly.Table' constructor function
let Table = WebAssembly.Table;
assertEq(Table, tableDesc.value);
assertEq(Table.length, 1);
assertEq(Table.name, 'Table');
assertTrue(isConstructor(Table));
assertThrows(
    () => Table(), TypeError, /must be invoked with 'new'/);
assertThrows(
    () => new Table(1), TypeError, 'WebAssembly.Table(): Argument 0 must be a table descriptor');
assertThrows(
    () => new Table({initial: 1, element: 1}), TypeError, /must be a WebAssembly reference type/);
assertThrows(
    () => new Table({initial: 1, element: 'any'}), TypeError,
    /must be a WebAssembly reference type/);
assertThrows(
    () => new Table({initial: 1, element: {valueOf() { return 'anyfunc' }}}),
    TypeError, /must be a WebAssembly reference type/);
assertThrows(
    () => new Table(
        {initial: {valueOf() { throw new Error('here') }}, element: 'anyfunc'}),
    Error, 'here');
assertThrows(
    () => new Table({initial: -1, element: 'anyfunc'}), TypeError,
    /must be non-negative/);
assertThrows(
    () => new Table({initial: Math.pow(2, 32), element: 'anyfunc'}), TypeError,
    /must be in the unsigned long range/);
assertThrows(
    () => new Table({initial: 2, maximum: 1, element: 'anyfunc'}), RangeError,
    /is below the lower bound/);
assertThrows(
    () => new Table({initial: 2, maximum: Math.pow(2, 32), element: 'anyfunc'}),
    TypeError, /must be in the unsigned long range/);
assertTrue(new Table({initial: 1, element: 'anyfunc'}) instanceof Table);
assertTrue(new Table({initial: 1.5, element: 'anyfunc'}) instanceof Table);
assertTrue(
    new Table({initial: 1, maximum: 1.5, element: 'anyfunc'}) instanceof Table);
assertTrue(
    new Table({initial: 1, maximum: Math.pow(2, 32) - 1, element: 'anyfunc'})
        instanceof Table);

// 'WebAssembly.Table.prototype' data property
let tableProtoDesc = Object.getOwnPropertyDescriptor(Table, 'prototype');
assertEq(typeof tableProtoDesc.value, 'object');
assertFalse(tableProtoDesc.writable);
assertFalse(tableProtoDesc.enumerable);
assertFalse(tableProtoDesc.configurable);

// 'WebAssembly.Table.prototype' object
let tableProto = Table.prototype;
assertEq(tableProto, tableProtoDesc.value);
assertEq(String(tableProto), '[object WebAssembly.Table]');
assertEq(Object.getPrototypeOf(tableProto), Object.prototype);

// 'WebAssembly.Table' instance objects
let tbl1 = new Table({initial: 2, element: 'anyfunc'});
assertEq(typeof tbl1, 'object');
assertEq(String(tbl1), '[object WebAssembly.Table]');
assertEq(Object.getPrototypeOf(tbl1), tableProto);

// 'WebAssembly.Table.prototype.length' accessor data property
let lengthDesc = Object.getOwnPropertyDescriptor(tableProto, 'length');
assertEq(typeof lengthDesc.get, 'function');
assertEq(lengthDesc.get.name, 'get length');
assertEq(lengthDesc.get.length, 0);
assertFalse(isConstructor(lengthDesc.get));
assertFalse('prototype' in lengthDesc.get);
assertEq(lengthDesc.set, undefined);
assertTrue(lengthDesc.enumerable);
assertTrue(lengthDesc.configurable);

// 'WebAssembly.Table.prototype.length' getter
let lengthGetter = lengthDesc.get;
assertEq(lengthGetter.length, 0);
assertThrows(
    () => lengthGetter.call(), TypeError, /Receiver is not a WebAssembly.Table/);
assertThrows(
    () => lengthGetter.call({}), TypeError, /Receiver is not a WebAssembly.Table/);
assertEq(typeof lengthGetter.call(tbl1), 'number');
assertEq(lengthGetter.call(tbl1), 2);

// 'WebAssembly.Table.prototype.get' data property
let getDesc = Object.getOwnPropertyDescriptor(tableProto, 'get');
assertEq(typeof getDesc.value, 'function');
assertTrue(getDesc.enumerable);
assertTrue(getDesc.configurable);

// 'WebAssembly.Table.prototype.get' method
let get = getDesc.value;
assertEq(get.length, 1);
assertFalse(isConstructor(get));
assertThrows(
    () => get.call(), TypeError, /Receiver is not a WebAssembly.Table/);
assertThrows(
    () => get.call({}), TypeError, /Receiver is not a WebAssembly.Table/);
assertThrows(
    () => get.call(tbl1), TypeError, /must be convertible to a valid number/);
assertEq(get.call(tbl1, 0), null);
assertEq(get.call(tbl1, 0, Infinity), null);
assertEq(get.call(tbl1, 1), null);
assertEq(get.call(tbl1, 1.5), null);
assertThrows(
    () => get.call(tbl1, 2), RangeError,
    /invalid index 2 into funcref table of size 2/);
assertThrows(
    () => get.call(tbl1, 2.5), RangeError,
    /invalid index 2 into funcref table of size 2/);
assertThrows(() => get.call(tbl1, -1), TypeError, /must be non-negative/);
assertThrows(
    () => get.call(tbl1, Math.pow(2, 33)), TypeError,
  /must be in the unsigned long range/);
assertThrows(
    () => get.call(tbl1, {valueOf() { throw new Error('hi') }}), Error, 'hi');

// 'WebAssembly.Table.prototype.set' data property
let setDesc = Object.getOwnPropertyDescriptor(tableProto, 'set');
assertEq(typeof setDesc.value, 'function');
assertTrue(setDesc.enumerable);
assertTrue(setDesc.configurable);

// 'WebAssembly.Table.prototype.set' method
let set = setDesc.value;
assertEq(set.length, 1);
assertFalse(isConstructor(set));
assertThrows(
    () => set.call(), TypeError, /Receiver is not a WebAssembly.Table/);
assertThrows(
    () => set.call({}), TypeError, /Receiver is not a WebAssembly.Table/);
assertThrows(
    () => set.call(tbl1, undefined), TypeError,
    /must be convertible to a valid number/);
assertThrows(
    () => set.call(tbl1, 2, null), RangeError,
    /invalid index 2 into funcref table of size 2/);
assertThrows(
    () => set.call(tbl1, -1, null), TypeError, /must be non-negative/);
assertThrows(
    () => set.call(tbl1, Math.pow(2, 33), null), TypeError,
    /must be in the unsigned long range/);
assertThrows(
    () => set.call(tbl1, Infinity, null), TypeError,
  /must be convertible to a valid number/);
assertThrows(
    () => set.call(tbl1, -Infinity, null), TypeError,
  /must be convertible to a valid number/);
assertThrows(
    () => set.call(tbl1, 0, undefined), TypeError,
    /Argument 1 is invalid for table: /);
assertThrows(
    () => set.call(tbl1, undefined, undefined), TypeError,
    /must be convertible to a valid number/);
assertThrows(
    () => set.call(tbl1, 0, {}), TypeError,
    /Argument 1 is invalid for table:.*null.*or a Wasm function object/);
assertThrows(
    () => set.call(tbl1, 0, function() {}), TypeError,
    /Argument 1 is invalid for table:.*null.*or a Wasm function object/);
assertThrows(
    () => set.call(tbl1, 0, Math.sin), TypeError,
    /Argument 1 is invalid for table:.*null.*or a Wasm function object/);
assertThrows(
    () => set.call(tbl1, {valueOf() { throw Error('hai') }}, null), Error,
    'hai');
assertEq(set.call(tbl1, 0, null), undefined);
assertEq(set.call(tbl1, 1, null), undefined);
assertThrows(
    () => set.call(tbl1, undefined, null), TypeError,
    /must be convertible to a valid number/);

// 'WebAssembly.Table.prototype.grow' data property
let tblGrowDesc = Object.getOwnPropertyDescriptor(tableProto, 'grow');
assertEq(typeof tblGrowDesc.value, 'function');
assertTrue(tblGrowDesc.enumerable);
assertTrue(tblGrowDesc.configurable);

// 'WebAssembly.Table.prototype.grow' method
let tblGrow = tblGrowDesc.value;
assertEq(tblGrow.length, 1);
assertFalse(isConstructor(tblGrow));
assertThrows(
    () => tblGrow.call(), TypeError, /Receiver is not a WebAssembly.Table/);
assertThrows(
    () => tblGrow.call({}), TypeError, /Receiver is not a WebAssembly.Table/);
assertThrows(
    () => tblGrow.call(tbl1, -1), TypeError, /must be non-negative/);
assertThrows(
    () => tblGrow.call(tbl1, Math.pow(2, 32)), TypeError,
    /must be in the unsigned long range/);
var tbl = new Table({element: 'anyfunc', initial: 1, maximum: 2});
assertEq(tbl.length, 1);
assertThrows(
    () => tbl.grow(Infinity), TypeError, /must be convertible to a valid number/);
assertThrows(
    () => tbl.grow(-Infinity), TypeError, /must be convertible to a valid number/);
assertEq(tbl.grow(0), 1);
assertEq(tbl.length, 1);
assertEq(tbl.grow(1, null, 4), 1);
assertEq(tbl.length, 2);
assertEq(tbl.length, 2);
assertThrows(() => tbl.grow(1), Error, /failed to grow table by \d+/);
assertThrows(
    () => tbl.grow(Infinity), TypeError, /must be convertible to a valid number/);
assertThrows(
    () => tbl.grow(-Infinity), TypeError, /must be convertible to a valid number/);

// 'WebAssembly.validate' function
assertThrows(() => WebAssembly.validate(), TypeError);
assertThrows(() => WebAssembly.validate('hi'), TypeError);
assertTrue(WebAssembly.validate(emptyModuleBinary));
assertTrue(WebAssembly.validate(moduleBinaryImporting2Memories));
assertTrue(WebAssembly.validate(moduleBinaryWithMemSectionAndMemImport));

// 'WebAssembly.compile' data property
let compileDesc = Object.getOwnPropertyDescriptor(WebAssembly, 'compile');
assertEq(typeof compileDesc.value, 'function');
assertTrue(compileDesc.writable);
assertTrue(compileDesc.enumerable);
assertTrue(compileDesc.configurable);

// 'WebAssembly.compile' function
let compile = WebAssembly.compile;
assertEq(compile, compileDesc.value);
assertEq(compile.length, 1);
assertEq(compile.name, 'compile');
assertFalse(isConstructor(compile));
function assertCompileError(args, err, msg) {
  assertThrowsAsync(compile(...args), err /* TODO , msg */);
}
assertCompileError([], TypeError, /requires more than 0 arguments/);
assertCompileError(
    [undefined], TypeError,
    /Argument 0 must be a buffer source/);
assertCompileError(
    [1], TypeError,
    /Argument 0 must be a buffer source/);
assertCompileError(
    [{}], TypeError,
    /Argument 0 must be a buffer source/);
assertCompileError(
    [new Uint8Array()], CompileError, /BufferSource argument is empty/);
assertCompileError(
    [new ArrayBuffer()], CompileError, /BufferSource argument is empty/);
assertCompileError(
    [new Uint8Array('hi!')], CompileError, /failed to match magic number/);
assertCompileError(
    [new ArrayBuffer('hi!')], CompileError, /failed to match magic number/);

function assertCompileSuccess(bytes) {
  var module = null;
  assertPromiseResult(compile(bytes), m => assertTrue(m instanceof Module));
}
assertCompileSuccess(emptyModuleBinary);
assertCompileSuccess(emptyModuleBinary.buffer);

// 'WebAssembly.instantiate' data property
let instantiateDesc =
    Object.getOwnPropertyDescriptor(WebAssembly, 'instantiate');
assertEq(typeof instantiateDesc.value, 'function');
assertTrue(instantiateDesc.writable);
assertTrue(instantiateDesc.enumerable);
assertTrue(instantiateDesc.configurable);

// 'WebAssembly.instantiate' function
let instantiate = WebAssembly.instantiate;
assertEq(instantiate, instantiateDesc.value);
assertEq(instantiate.length, 1);
assertEq(instantiate.name, 'instantiate');
assertFalse(isConstructor(instantiate));
function assertInstantiateError(args, err, msg) {
  assertThrowsAsync(instantiate(...args), err /* TODO , msg */);
}
var scratch_memory = new WebAssembly.Memory({ initial: 0 });
assertInstantiateError([], TypeError, /requires more than 0 arguments/);
assertInstantiateError(
    [undefined], TypeError, /first argument must be a BufferSource/);
assertInstantiateError([1], TypeError, /first argument must be a BufferSource/);
assertInstantiateError(
    [{}], TypeError, /first argument must be a BufferSource/);
assertInstantiateError(
    [new Uint8Array()], CompileError, /failed to match magic number/);
assertInstantiateError(
    [new ArrayBuffer()], CompileError, /failed to match magic number/);
assertInstantiateError(
    [new Uint8Array('hi!')], CompileError, /failed to match magic number/);
assertInstantiateError(
    [new ArrayBuffer('hi!')], CompileError, /failed to match magic number/);
assertInstantiateError(
    [importingModule], TypeError, /second argument must be an object/);
assertInstantiateError(
    [importingModule, null], TypeError, /second argument must be an object/);
assertInstantiateError(
    [importingModuleBinary, null], TypeError,
    /second argument must be an object/);
assertInstantiateError(
    [emptyModule, null], TypeError, /first argument must be a BufferSource/);
assertInstantiateError(
    [importingModuleBinary, null], TypeError, /TODO: error messages?/);
assertInstantiateError(
    [importingModuleBinary, undefined], TypeError, /TODO: error messages?/);
assertInstantiateError(
    [importingModuleBinary, {}], TypeError, /TODO: error messages?/);
assertInstantiateError(
    [importingModuleBinary, {'': {g: () => {}}}], LinkError,
    /TODO: error messages?/);
assertInstantiateError(
    [importingModuleBinary, {t: {f: () => {}}}], TypeError,
    /TODO: error messages?/);
assertInstantiateError(
    [memoryImportingModuleBinary, null], TypeError, /TODO: error messages?/);
assertInstantiateError(
    [memoryImportingModuleBinary, undefined], TypeError,
    /TODO: error messages?/);
assertInstantiateError(
    [memoryImportingModuleBinary, {}], TypeError, /TODO: error messages?/);
assertInstantiateError(
    [memoryImportingModuleBinary, {'mod': {'my_memory': scratch_memory}}],
    TypeError, /TODO: error messages?/);
assertInstantiateError(
    [memoryImportingModuleBinary, {'': {'memory': scratch_memory}}], LinkError,
    /TODO: error messages?/);

function assertInstantiateSuccess(module_or_bytes, imports) {
  var result = null;
  assertPromiseResult(instantiate(module_or_bytes, imports), result => {
    if (module_or_bytes instanceof Module) {
      assertTrue(result instanceof Instance);
    } else {
      assertTrue(result.module instanceof Module);
      assertTrue(result.instance instanceof Instance);
    }
  });
}
assertInstantiateSuccess(emptyModule);
assertInstantiateSuccess(emptyModuleBinary);
assertInstantiateSuccess(emptyModuleBinary.buffer);
assertInstantiateSuccess(importingModule, {'': {f: () => {}}});
assertInstantiateSuccess(importingModuleBinary, {'': {f: () => {}}});
assertInstantiateSuccess(importingModuleBinary.buffer, {'': {f: () => {}}});
assertInstantiateSuccess(
    memoryImportingModuleBinary, {'': {'my_memory': scratch_memory}});

(function TestSubclassing() {
  class M extends WebAssembly.Module { }
  assertThrows(() => new M());

  class I extends WebAssembly.Instance { }
  assertThrows(() => new I());

  class T extends WebAssembly.Table { }
  assertThrows(() => new T());

  class Y extends WebAssembly.Memory { }
  assertThrows(() => new Y());
})();

(function TestCallWithoutNew() {
  var bytes = Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x1, 0x00, 0x00, 0x00);
  assertThrows(() => WebAssembly.Module(bytes), TypeError);
  assertThrows(() => WebAssembly.Instance(new WebAssembly.Module(bytes)),
               TypeError);
  assertThrows(() => WebAssembly.Table({size: 10, element: 'anyfunc'}),
               TypeError);
  assertThrows(() => WebAssembly.Memory({size: 10}), TypeError);
})();

(function TestTinyModule() {
  var bytes = Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x1, 0x00, 0x00, 0x00);
  var module = new WebAssembly.Module(bytes);
  assertTrue(module instanceof Module);
  var instance = new WebAssembly.Instance(module);
  assertTrue(instance instanceof Instance);
})();

(function TestAccessorFunctions() {
  function testAccessorFunction(obj, prop, accessor) {
    var desc = Object.getOwnPropertyDescriptor(obj, prop);
    assertSame('function', typeof desc[accessor]);
    assertFalse(desc[accessor].hasOwnProperty('prototype'));
    assertFalse(isConstructor(desc[accessor]));
  }
  testAccessorFunction(WebAssembly.Global.prototype, "value", "get");
  testAccessorFunction(WebAssembly.Global.prototype, "value", "set");
  testAccessorFunction(WebAssembly.Instance.prototype, "exports", "get");
  testAccessorFunction(WebAssembly.Memory.prototype, "buffer", "get");
  testAccessorFunction(WebAssembly.Table.prototype, "length", "get");
})();
                                   node-23.7.0/deps/v8/test/mjsunit/wasm/js-to-js.js                                                   0000664 0000000 0000000 00000006422 14746647661 0021474 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
// Flags: --experimental-wasm-type-reflection

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

const dummyFunc =
    new WebAssembly.Function({parameters: [], results: []}, () => 15);

const tests = [
  {type: 'i32', input: 12.5, expected: 12},
  {type: 'i64', input: 0xffff_ffff_ffff_ffff_ffffn, expected: -1n},
  {
    type: 'f32',
    input: Number.MAX_SAFE_INTEGER,
    // F32 cannot represent MAX_SAFE_INTEGER, so it rounds to the next closest
    // representable number.
    expected: Number.MAX_SAFE_INTEGER + 1
  },
  {type: 'f64', input: {valueOf: () => 15}, expected: 15},
  {type: 'externref', input: 'Foo', expected: 'Foo'},
  {type: 'anyfunc', input: null, expected: null},
  {type: 'anyfunc', input: dummyFunc, expected: dummyFunc},
];

(function TestNoReturn() {
  print(arguments.callee.name);
  const jsFunc =
      new WebAssembly.Function({parameters: [], results: []}, () => 15);

  assertEquals(undefined, jsFunc());
})();

(function TestSingleReturn() {
  print(arguments.callee.name);
  for (const test of tests) {
    const jsFunc = new WebAssembly.Function(
        {parameters: [], results: [test.type]}, () => test.input);

    assertEquals(test.expected, jsFunc());
  }
})();

(function TestSingleParam() {
  print(arguments.callee.name);
  for (const test of tests) {
    const jsFunc = new WebAssembly.Function(
        {parameters: [test.type], results: []},
        (param) => assertEquals(test.expected, param));
    jsFunc(test.input);
  }
})();

(function TestMultiParamMultiReturn() {
  print(arguments.callee.name);
  for (const param of tests) {
    for (const ret of tests) {
      const jsFunc = new WebAssembly.Function(
          {parameters: ['i32', param.type], results: ['f32', ret.type]},
          (foo, p) => {
            assertEquals(param.expected, p);
            return [22, ret.input];
          });
      const result = jsFunc(12, param.input);
      assertEquals(ret.expected, result[1]);
    }
  }
})();

(function TestAnyfuncThrows() {
  print(arguments.callee.name);

  let jsFunc = new WebAssembly.Function(
      {parameters: [], results: ['anyfunc']}, () => 'no function');

  assertThrows(() => jsFunc(), TypeError);
  jsFunc = new WebAssembly.Function(
      {parameters: ['anyfunc'], results: []}, () => 'no function');

  assertThrows(() => jsFunc('no function'), TypeError);

  jsFunc = new WebAssembly.Function(
      {parameters: [], results: ['i32', 'anyfunc']}, () => [12, 'no function']);

  assertThrows(() => jsFunc(), TypeError);
  jsFunc = new WebAssembly.Function(
      {parameters: ['f32', 'anyfunc'], results: []}, () => 'no function');

  assertThrows(() => jsFunc(32, 'no function'), TypeError);
})();

(function TestParamPops() {
  print(arguments.callee.name);
  function add(i, j) {
    return i + j;
  }
  const jsFunc =
      new WebAssembly.Function({parameters: ['f64'], results: ['i32']}, add);
  jsFunc();
  jsFunc(1, 2, 3, 4);
}) ();

(function TestInvalidParam() {
  print(arguments.callee.name);
    const jsFunc = new WebAssembly.Function(
        {parameters: ['v128'], results: []},
        (param) => assertUnreachable());
    assertThrows(jsFunc, TypeError);
})();
                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/wasm/js-to-wasm-invalid-sig.js                                     0000664 0000000 0000000 00000000667 14746647661 0024240 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

const builder = new WasmModuleBuilder();
builder.addFunction('main', makeSig([kWasmS128], [])).addBody([]).exportFunc();
const instance = builder.instantiate();
assertThrows(instance.exports.main, TypeError);
                                                                         node-23.7.0/deps/v8/test/mjsunit/wasm/js-wrapper-typechecks.js                                      0000664 0000000 0000000 00000001641 14746647661 0024256 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-exnref

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function testNonNullRefWrapperNullCheck() {
  print(arguments.callee.name);
  for (let [name, type] of Object.entries({
    'extern': kWasmExternRef,
    'any': kWasmAnyRef,
    'func': kWasmFuncRef,
    'array': kWasmArrayRef,
    'exn': kWasmExnRef,
  })) {
    print(`- ${name}`);
    let builder = new WasmModuleBuilder();
    builder.addFunction('test', makeSig([wasmRefType(type)], []))
      .addBody([kExprUnreachable])
      .exportFunc();

    let instance = builder.instantiate({});
    let wasm = instance.exports;
    assertThrows(() => wasm.test(null), TypeError,
                 /type incompatibility when transforming from\/to JS/);
  }
})();
                                                                                               node-23.7.0/deps/v8/test/mjsunit/wasm/large-offset.js                                               0000664 0000000 0000000 00000001570 14746647661 0022403 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function testMemoryGrowOutOfBoundsOffset() {
  print("testMemoryGrowOutOfBoundsOffset2");
  var builder = new WasmModuleBuilder();
  builder.addMemory(16, 128);
  builder.addFunction("main", kSig_v_v)
      .addBody([
          kExprI32Const, 20,
          kExprI32Const, 29,
          kExprMemoryGrow, kMemoryZero,
          // Assembly equivalent Move <reg>,0xf5fffff
          // with wasm memory reference relocation information
          kExprI32StoreMem, 0, 0xFF, 0xFF, 0xFF, 0x7A
          ])
      .exportAs("main");
  var module = builder.instantiate();
  assertTraps(kTrapMemOutOfBounds, module.exports.main);
}

testMemoryGrowOutOfBoundsOffset();
                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/wasm/large-struct.js                                               0000664 0000000 0000000 00000010350 14746647661 0022435 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

// Keep in sync with wasm-limits.h.
let kWasmMaxStructFields = 10000;
// Keep in sync with wasm-constants.h.
let kMaxStructFieldIndexForImplicitNullCheck = 4000;

(function TestLargeStruct() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct_large = builder.addStruct(
      new Array(kWasmMaxStructFields).fill(makeField(kWasmS128, true)));

  let struct_large_indices = [
    0, kMaxStructFieldIndexForImplicitNullCheck,
    kMaxStructFieldIndexForImplicitNullCheck + 1,
    kWasmMaxStructFields - 1];

  for (let field_index of struct_large_indices) {
    builder.addFunction(
        "structLargeGet" + field_index,
        makeSig([wasmRefNullType(struct_large)], [kWasmI32]))
      .addBody([
        kExprLocalGet, 0,
        kGCPrefix, kExprStructGet, struct_large,
        ...wasmUnsignedLeb(field_index),
        kSimdPrefix, kExprI32x4ExtractLane, 0])
      .exportFunc();

    builder.addFunction(
        "structLargeSet" + field_index,
        makeSig([wasmRefNullType(struct_large)], []))
      .addBody([
        kExprLocalGet, 0,
        kSimdPrefix, kExprS128Const,
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
        kGCPrefix, kExprStructSet, struct_large,
        ...wasmUnsignedLeb(field_index)])
      .exportFunc();
  }

  builder.addFunction("structLargeMake",
                      makeSig([], [wasmRefType(struct_large)]))
      .addBody([kGCPrefix, kExprStructNewDefault, struct_large])
      .exportFunc();

  let instance = builder.instantiate();

  let struct_large_obj = instance.exports.structLargeMake();
  for (let field_index of struct_large_indices) {
    assertTraps(kTrapNullDereference,
      () => instance.exports[
          "structLargeGet" + field_index](null));
    assertTraps(kTrapNullDereference,
      () => instance.exports[
          "structLargeSet" + field_index](null));
    instance.exports["structLargeSet" + field_index](struct_large_obj);
    assertEquals(0x03020100,
                  instance.exports["structLargeGet" + field_index](
                    struct_large_obj));
  }
})();

(function TestLargeStructRef() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let element_type = builder.addStruct([makeField(kWasmI32, true)]);
  let struct_large = builder.addStruct(
      new Array(kWasmMaxStructFields).fill(
          makeField(wasmRefNullType(element_type), true)));

  let struct_large_indices = [
    0, kMaxStructFieldIndexForImplicitNullCheck,
    kMaxStructFieldIndexForImplicitNullCheck + 1,
    kWasmMaxStructFields - 1];

  for (let field_index of struct_large_indices) {
    builder.addFunction(
        "structLargeGet" + field_index,
        makeSig([wasmRefNullType(struct_large)], [kWasmI32]))
      .addBody([
        kExprLocalGet, 0,
        kGCPrefix, kExprStructGet, struct_large,
        ...wasmUnsignedLeb(field_index),
        kGCPrefix, kExprStructGet, element_type, 0])
      .exportFunc();

    builder.addFunction(
        "structLargeSet" + field_index,
        makeSig([wasmRefNullType(struct_large)], []))
      .addBody([
        kExprLocalGet, 0,
        kExprI32Const, 42, kGCPrefix, kExprStructNew, element_type,
        kGCPrefix, kExprStructSet, struct_large,
        ...wasmUnsignedLeb(field_index)])
      .exportFunc();
  }

  builder.addFunction("structLargeMake",
                      makeSig([], [wasmRefType(struct_large)]))
      .addBody([kGCPrefix, kExprStructNewDefault, struct_large])
      .exportFunc();

  let instance = builder.instantiate();

  let struct_large_obj = instance.exports.structLargeMake();
  for (let field_index of struct_large_indices) {
    assertTraps(kTrapNullDereference,
      () => instance.exports[
          "structLargeGet" + field_index](null));
    assertTraps(kTrapNullDereference,
      () => instance.exports[
          "structLargeSet" + field_index](null));
    instance.exports["structLargeSet" + field_index](struct_large_obj);
    assertEquals(42, instance.exports["structLargeGet" + field_index](
                         struct_large_obj));
  }
})();
                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/wasm/lazy-compilation.js                                           0000664 0000000 0000000 00000007121 14746647661 0023316 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-lazy-compilation --allow-natives-syntax

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function importFromOtherInstance() {
  print(arguments.callee.name);
  const builder1 = new WasmModuleBuilder();
  builder1.addFunction('func', kSig_v_v).addBody([]).exportFunc();
  const instance1 = builder1.instantiate();

  const builder2 = new WasmModuleBuilder();
  builder2.addImport('mod', 'fn', kSig_v_v);
  builder2.instantiate({mod: {fn: instance1.exports.func}});
})();

(function testWasmToWasmWithDifferentMemory() {
  print(arguments.callee.name);
  const builder1 = new WasmModuleBuilder();
  builder1.addMemory(1, 1);
  builder1.exportMemoryAs('memory');
  builder1.addFunction('store', kSig_v_i)
      .addBody([
        kExprI32Const, 0,        // i32.const 1
        kExprLocalGet, 0,        // get_local 0
        kExprI32StoreMem, 0, 0,  // i32.store offset=0 align=0
      ])
      .exportFunc();
  const instance1 = builder1.instantiate();
  const mem1 = new Int32Array(instance1.exports.memory.buffer);

  const builder2 = new WasmModuleBuilder();
  builder2.addMemory(1, 1);
  builder2.exportMemoryAs('memory');
  builder2.addImport('mod', 'store', kSig_v_i);
  builder2.addFunction('call_store', kSig_v_i)
      .addBody([kExprLocalGet, 0, kExprCallFunction, 0])
      .exportFunc();
  const instance2 = builder2.instantiate({mod: {store: instance1.exports.store}});
  const mem2 = new Int32Array(instance2.exports.memory.buffer);

  assertEquals(0, mem1[0]);
  assertEquals(0, mem2[0]);
  instance2.exports.call_store(3);
  assertEquals(3, mem1[0]);
  assertEquals(0, mem2[0]);
  %FreezeWasmLazyCompilation(instance1);
  %FreezeWasmLazyCompilation(instance2);
  instance2.exports.call_store(7);
  assertEquals(7, mem1[0]);
})();

(function exportImportedFunction() {
  print(arguments.callee.name);
  const builder1 = new WasmModuleBuilder();
  builder1.addFunction('foo', kSig_v_v).addBody([]).exportAs('foo');
  const instance1 = builder1.instantiate();

  const builder2 = new WasmModuleBuilder();
  const imp_idx = builder2.addImport('A', 'foo', kSig_v_v);
  builder2.addExport('foo', imp_idx);
  const instance2 = builder2.instantiate({A: instance1.exports});

  instance2.exports.foo();
  %FreezeWasmLazyCompilation(instance1);
  %FreezeWasmLazyCompilation(instance2);
  instance2.exports.foo();
})();

(function exportImportedFunctionWithDifferentMemory() {
  print(arguments.callee.name);
  const builder1 = new WasmModuleBuilder();
  builder1.addMemory(1, 1);
  builder1.exportMemoryAs('memory');
  builder1.addFunction('store', kSig_v_i)
      .addBody([
        kExprI32Const, 0,        // i32.const 1
        kExprLocalGet, 0,        // get_local 0
        kExprI32StoreMem, 0, 0,  // i32.store offset=0 align=0
      ])
      .exportFunc();
  const instance1 = builder1.instantiate();
  const mem1 = new Int32Array(instance1.exports.memory.buffer);

  const builder2 = new WasmModuleBuilder();
  builder2.addMemory(1, 1);
  builder2.exportMemoryAs('memory');
  const imp_idx = builder2.addImport('A', 'store', kSig_v_i);
  builder2.addExport('exp_store', imp_idx);
  const instance2 = builder2.instantiate({A: instance1.exports});
  const mem2 = new Int32Array(instance2.exports.memory.buffer);

  instance2.exports.exp_store(3);
  assertEquals(3, mem1[0]);
  assertEquals(0, mem2[0]);
  %FreezeWasmLazyCompilation(instance1);
  %FreezeWasmLazyCompilation(instance2);
  instance2.exports.exp_store(7);
  assertEquals(7, mem1[0]);
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/wasm/lazy-feedback-vector-allocation.js                            0000664 0000000 0000000 00000001243 14746647661 0026146 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-lazy-compilation --experimental-wasm-inlining

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

let builder = new WasmModuleBuilder();

let callee = builder.addFunction('callee', kSig_v_v).addBody([]);

builder.addFunction('main', kSig_v_v).exportFunc().addBody([
  kExprCallFunction, callee.index,
]);

let inst1 = builder.instantiate();
let inst2 = builder.instantiate();

inst1.exports.main();  // Triggers lazy compilation.
inst2.exports.main();  // Lacks feedback vector.
                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/liftoff-debug.js                                              0000664 0000000 0000000 00000003451 14746647661 0022542 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --expose-gc --liftoff-only
// Force all functions (the first 8, technically) to generate debug code.
// Flags: --wasm-debug-mask-for-testing=255

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function testGCInLoopStackCheck() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.addMemory(1, 1);

  const imp_index = builder.addImport('q', 'triggerStackCheck', kSig_v_v);

  const kIndex = 0;
  const kValue = 11;

  // This is a regression test for https://crbug.com/1222648:
  // Add a memory instruction before the loop, to get the memory start cached.
  // Then add a memory instruction inside the loop to make use of the cached
  // memory start.
  const main =
      builder.addFunction('main', kSig_i_v)
          .addBody([
            kExprCallFunction, imp_index,     // schedule stack check
            kExprI32Const,     kIndex,        // i32.const kIndex
            kExprI32Const,     kValue,        // i32.const kValue
            kExprI32StoreMem,  0,         0,  // i32.store align=0 offset=0
            kExprLoop,         kWasmVoid,     // loop
            kExprI32Const,     kIndex,        // i32.const kIndex
            kExprI32LoadMem,   0,         0,  // i32.load align=0 offset=0
            kExprReturn,                      // return
            kExprEnd,                         // end loop
            kExprUnreachable,                 // unreachable
          ])
          .exportFunc();

  const instance = builder.instantiate(
      {q: {triggerStackCheck: () => %ScheduleGCInStackCheck()}});

  assertEquals(kValue, instance.exports.main());
})();
                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/wasm/liftoff-simd-params.js                                        0000664 0000000 0000000 00000006412 14746647661 0023671 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

// This test case tries to exercise SIMD stack to stack movements by creating
// a function that has many parameters.
(function() {
const builder = new WasmModuleBuilder();
// At this point we have limited support for SIMD operations, but we can load
// and store s128 values. So this memory will be used for reading and writing
// s128 values and we will assert expected values from JS.
builder.addImportedMemory('m', 'imported_mem', 1, 2);
builder.addType(makeSig(new Array(18).fill(kWasmS128), []));

builder.addFunction(undefined, makeSig([], []))
    .addLocals(kWasmS128, 9)
    .addBodyWithEnd([
      // These will all be args to the callee.
      // Load first arg from memory, this was written with values from JS.
      kExprI32Const, 0,                     // i32.const
      kSimdPrefix, kExprS128LoadMem, 0, 0,  // s128.load
      kExprLocalGet, 0,                     // local.get
      kExprLocalGet, 1,                     // local.get
      kExprLocalGet, 2,                     // local.get
      kExprLocalGet, 3,                     // local.get
      kExprLocalGet, 4,                     // local.get
      kExprLocalGet, 5,                     // local.get
      kExprLocalGet, 6,                     // local.get
      kExprLocalGet, 7,                     // local.get
      kExprLocalGet, 8,                     // local.get
      kExprLocalGet, 0,                     // local.get
      kExprLocalGet, 1,                     // local.get
      kExprLocalGet, 2,                     // local.get
      kExprLocalGet, 3,                     // local.get
      kExprLocalGet, 4,                     // local.get
      kExprLocalGet, 5,                     // local.get
      kExprLocalGet, 6,                     // local.get
      // Load last s128 from memory, this was written with values from JS.
      kExprI32Const, 16,                    // i32.const
      kSimdPrefix, kExprS128LoadMem, 0, 0,  // s128.load
      kExprCallFunction, 0x01,              // call
      kExprEnd,                             // end
    ]);

builder.addFunction(undefined, 0 /* sig */).addBodyWithEnd([
  kExprI32Const, 32,                     // i32.const
  kExprLocalGet, 0,                      // local.get
  kSimdPrefix, kExprS128StoreMem, 0, 0,  // s128.store
  kExprI32Const, 48,                     // i32.const
  kExprLocalGet, 17,                     // local.get
  kSimdPrefix, kExprS128StoreMem, 0, 0,  // s128.store
  kExprEnd,                              // end
]);

builder.addExport('main', 0);
var memory = new WebAssembly.Memory({initial: 1, maximum: 2});
const instance = builder.instantiate({m: {imported_mem: memory}});

// We write sentinel values to two s128 values at the start of the memory.
// Function 1 will read these values from memory, and pass them as the first
// and last arg to function 2. Function 2 then write these values to memory
// after these two s128 values.
const arr = new Uint32Array(memory.buffer);
for (let i = 0; i < 8; i++) {
  arr[0] = i * 2;
}

instance.exports.main();

for (let i = 0; i < 8; i++) {
  assertEquals(arr[i], arr[i + 8]);
}
})();
                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/wasm/liftoff-trap-handler.js                                       0000664 0000000 0000000 00000001740 14746647661 0024034 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --liftoff --wasm-trap-handler

// A simple test to make sure Liftoff can compile memory operations with trap
// handlers enabled.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function testCompileLoadStore() {
  const builder = new WasmModuleBuilder();
  // These functions generate statically out of bounds accesses.
  builder.addFunction("load", kSig_i_i)
      .addBody([kExprLocalGet, 0, kExprI32LoadMem, 0, 0x80, 0x80, 0x80, 1])
      .exportFunc();
  builder.addFunction("store", kSig_i_ii)
      .addBody([kExprLocalGet, 0,
                kExprLocalGet, 1,
                kExprI32StoreMem, 0, 0x80, 0x80, 0x80, 1,
                kExprLocalGet, 1])
      .exportFunc();
  builder.addMemory(1, 1);
  const instance = builder.instantiate();
}
testCompileLoadStore();
                                node-23.7.0/deps/v8/test/mjsunit/wasm/liftoff.js                                                    0000664 0000000 0000000 00000003470 14746647661 0021457 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --liftoff --no-wasm-tier-up
// In this test we are interested in the generated code, so force code
// generation by disabling lazy compilation.
// Flags: --no-wasm-lazy-compilation

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function testLiftoffFlag() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.addFunction('i32_add', kSig_i_ii)
      .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
      .exportFunc();

  const module = new WebAssembly.Module(builder.toBuffer());
  const instance = new WebAssembly.Instance(module);
  const instance2 = new WebAssembly.Instance(module);

  assertEquals(%IsLiftoffFunction(instance.exports.i32_add),
               %IsLiftoffFunction(instance2.exports.i32_add));
})();


(function testLiftoffSync() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.addFunction('i32_add', kSig_i_ii)
      .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
      .exportFunc();

  const instance = builder.instantiate();

  assertTrue(%IsLiftoffFunction(instance.exports.i32_add));
})();

async function testLiftoffAsync() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.addFunction('i32_add', kSig_i_ii)
      .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
      .exportFunc();

  print('Compiling...');
  const module = await WebAssembly.compile(builder.toBuffer());
  print('Instantiating...');
  const instance = new WebAssembly.Instance(module);
  assertTrue(%IsLiftoffFunction(instance.exports.i32_add));
}

assertPromiseResult(testLiftoffAsync());
                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/wasm/load-immutable.js                                             0000664 0000000 0000000 00000007662 14746647661 0022731 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --no-liftoff

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// Test that comparisons with array length in a loop get optimized away.
(function ArrayLoopOptimizationTest() {
  var builder = new WasmModuleBuilder();
  var array_index = builder.addArray(kWasmI32, true);

  // Increase these parameters to measure performance.
  let array_size = 10; // 100000000;
  let iterations = 1; // 50;

  builder.addFunction("array_inc", kSig_v_v)
    .addLocals(wasmRefType(array_index), 1)
    .addLocals(kWasmI32, 2)
    // Locals: 0 -> array, 1 -> length, 2 -> index
    .addBody([
      ...wasmI32Const(array_size),
      kExprCallFunction, 1,
      kExprLocalSet, 0,

      // length = array.length
      kExprLocalGet, 0,
      kGCPrefix, kExprArrayLen,
      kExprLocalSet, 1,

      // while (true) {
      kExprLoop, kWasmVoid,
        // if (index < length) {
        kExprLocalGet, 2,
        kExprLocalGet, 1,
        kExprI32LtU,
        kExprIf, kWasmVoid,
          // array[index] = array[index] + 5;
          kExprLocalGet, 0,
          kExprLocalGet, 2,
          kExprLocalGet, 0,
          kExprLocalGet, 2,
          kGCPrefix, kExprArrayGet, array_index,
          kExprI32Const, 5,
          kExprI32Add,
          kGCPrefix, kExprArraySet, array_index,
          // index = index + 1;
          kExprLocalGet, 2,
          kExprI32Const, 1,
          kExprI32Add,
          kExprLocalSet, 2,
          // continue;
          kExprBr, 1,
        // }
        // break;
        kExprEnd,
      // }
      kExprEnd])
    .exportFunc();

  builder.addFunction("make_array",
                      makeSig([kWasmI32], [wasmRefType(array_index)]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprArrayNewDefault, array_index])

  var instance = builder.instantiate({});

  let before = Date.now();
  for (let i = 0; i < iterations; i++) {
    instance.exports.array_inc();
  }
  let after = Date.now();
  print(
    "Average of " + iterations + " runs: " +
    (after - before)/iterations + "ms");
})();

(function ImmutableLoadThroughEffect() {
  var builder = new WasmModuleBuilder();
  var struct = builder.addStruct([
    makeField(kWasmI32, false), makeField(kWasmI32, true)]);

  let effect = builder.addImport('m', 'f', kSig_v_v);

  builder.addFunction("main", kSig_i_i)
    .addLocals(wasmRefType(struct), 1)
    .addBody([
      // Initialize an object
      kExprLocalGet, 0,
      kExprLocalGet, 0, kExprI32Const, 1, kExprI32Add,
      kGCPrefix, kExprStructNew, struct,
      kExprLocalSet, 1,
      // Introduce unknown effect
      kExprCallFunction, effect,
      // TF should be able to eliminate this load...
      kExprLocalGet, 1,
      kGCPrefix, kExprStructGet, struct, 0,
      // ... but not this one.
      kExprLocalGet, 1,
      kGCPrefix, kExprStructGet, struct, 1,
      kExprI32Add
    ])
    .exportFunc();

  var instance = builder.instantiate({m : { f: function () {} }});

  assertEquals(85, instance.exports.main(42));
})();

(function FunctionTypeCheckThroughEffect() {
  var builder = new WasmModuleBuilder();
  var sig = builder.addType(kSig_i_i);

  let effect = builder.addImport('m', 'f', kSig_v_v);

  builder.addFunction("input", sig)
    .addBody([kExprLocalGet, 0])
    .exportFunc();

  builder.addFunction("main", makeSig([wasmRefType(kWasmFuncRef)], [kWasmI32]))
    .addBody([
      // Type check the function
      kExprLocalGet, 0, kGCPrefix, kExprRefCast, sig,
      kExprDrop,
      // Introduce unknown effect
      kExprCallFunction, effect,
      // TF should be able to eliminate the second type check, and return the
      // constant 1.
      kExprLocalGet, 0,
      kGCPrefix, kExprRefTest, sig])
    .exportFunc();

  var instance = builder.instantiate({m : { f: function () {} }});

  assertEquals(1, instance.exports.main(instance.exports.input));
})();
                                                                              node-23.7.0/deps/v8/test/mjsunit/wasm/log-code-after-post-message.js                                0000664 0000000 0000000 00000002743 14746647661 0025225 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function workerCode() {
  function WorkerOnProfileEnd(profile) {
    postMessage(profile.indexOf('foo'));
  }

  onmessage = ({data:wasm_module}) => {
    WebAssembly.instantiate(wasm_module, {q: {func: d8.profiler.triggerSample}})
        .then(instance => {
          instance.exports.foo();
          console.profileEnd();
        });
  };

  d8.profiler.setOnProfileEndListener(WorkerOnProfileEnd);
  // Code logging happens for all code objects when profiling gets started,
  // and when new code objects appear after profiling has started. We want to
  // test the second scenario here. As new code objects appear as the
  // parameter of {OnMessage}, we have to start profiling already here before
  // {onMessage} is called.
  console.profile();
  postMessage('Starting worker');
}

const worker = new Worker(workerCode, {type: 'function'});

assertEquals("Starting worker", worker.getMessage());

const builder = new WasmModuleBuilder();
const sig_index = builder.addType(kSig_v_v);
const imp_index = builder.addImport("q", "func", sig_index);
builder.addFunction('foo', kSig_v_v)
    .addBody([
      kExprCallFunction, imp_index,
    ])
    .exportFunc();
const wasm_module = builder.toModule();
worker.postMessage(wasm_module);
assertTrue(worker.getMessage() > 0);
                             node-23.7.0/deps/v8/test/mjsunit/wasm/log-wasm-to-js-wrapper-callref.js                             0000664 0000000 0000000 00000004225 14746647661 0025671 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Increase the profiler sampling interval to avoid a data race between
// interval-triggered samples and explicitly triggered samples. The goal of the
// big interval is to avoid any interval-triggered samples.
// Flags: --experimental-wasm-type-reflection --cpu-profiler-sampling-interval=1000000

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

let sampleCollected = false;
function OnProfilerSampleCallback(profile) {
  profile = profile.replaceAll('\\', '/');
  profile = JSON.parse(profile);
  let wasm_to_js_index = 0;
  let js_to_wasm_index = 0;
  let fib_index = 0;
  let imp_index = 0;
  let functionNames = profile.nodes.map(n => n.callFrame.functionName);
  for (let i = 0; i < functionNames.length; ++i) {
    if (functionNames[i].startsWith('js-to-wasm')) {
      assertTrue(functionNames[i + 1].startsWith('main'));
      assertTrue(functionNames[i + 2].startsWith('wasm-to-js'));
      assertTrue(functionNames[i + 3].startsWith('imp'));
      // {sampleCollected} is set at the end because the asserts above don't
      // show up in the test runner, probably because this function is called as
      // a callback from d8.
      sampleCollected = true;
      return;
    }
  }
  assertUnreachable();
}

const builder = new WasmModuleBuilder();
const sigId = builder.addType(kSig_i_i);
const g = builder.addImportedGlobal('m', 'val', kWasmAnyFunc);
builder.addFunction('main', sigId)
    .addBody([
      kExprLocalGet,
      0,
      kExprGlobalGet,
      g,
      kGCPrefix,
      kExprRefCast,
      sigId,
      kExprCallRef,
      sigId,
    ])
    .exportFunc();
const wasm_module = builder.toModule();

d8.profiler.setOnProfileEndListener(OnProfilerSampleCallback);
function imp(i) {
  d8.profiler.triggerSample();
  console.profileEnd();
}
const wrapped_imp =
    new WebAssembly.Function({parameters: ['i32'], results: ['i32']}, imp);
let instance = new WebAssembly.Instance(wasm_module, {m: {val: wrapped_imp}});
console.profile();
instance.exports.main(3);

assertTrue(sampleCollected);
                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/wasm/log-wasm-to-js-wrapper-indirect.js                            0000664 0000000 0000000 00000004132 14746647661 0026057 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Increase the profiler sampling interval to avoid a data race between
// interval-triggered samples and explicitly triggered samples. The goal of the
// big interval is to avoid any interval-triggered samples.
// Flags: --cpu-profiler-sampling-interval=1000000

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

let sampleCollected = false;
function OnProfilerSampleCallback(profile) {
  profile = profile.replaceAll('\\', '/');
  profile = JSON.parse(profile);
  let wasm_to_js_index = 0;
  let js_to_wasm_index = 0;
  let fib_index = 0;
  let imp_index = 0;
  let functionNames = profile.nodes.map(n => n.callFrame.functionName);
  for (let i = 0; i < functionNames.length; ++i) {
    if (functionNames[i].startsWith('js-to-wasm')) {
      assertTrue(functionNames[i + 1].startsWith('main'));
      assertTrue(functionNames[i + 2].startsWith('wasm-to-js'));
      assertTrue(functionNames[i + 3].startsWith('imp'));
      // {sampleCollected} is set at the end because the asserts above don't
      // show up in the test runner, probably because this function is called as
      // a callback from d8.
      sampleCollected = true;
      return;
    }
  }
  assertUnreachable();
}

const builder = new WasmModuleBuilder();
const sigId = builder.addType(kSig_i_i);
const imp_index = builder.addImport('q', 'f', sigId);
const table = builder.addTable(kWasmAnyFunc, 10).index;
builder.addActiveElementSegment(table, wasmI32Const(9), [imp_index]);
builder.addFunction('main', sigId)
    .addBody([
      kExprLocalGet,
      0,
      kExprI32Const,
      9,
      kExprCallIndirect,
      sigId,
      table,
    ])
    .exportFunc();
const wasm_module = builder.toModule();

d8.profiler.setOnProfileEndListener(OnProfilerSampleCallback);
function imp(i) {
  d8.profiler.triggerSample();
  console.profileEnd();
}
let instance = new WebAssembly.Instance(wasm_module, {q: {f: imp}});
console.profile();
instance.exports.main(3);
assertTrue(sampleCollected);
                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/wasm/loop-rotation.js                                              0000664 0000000 0000000 00000004111 14746647661 0022625 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --turbo-loop-rotation --noliftoff --nowasm-tier-up

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestTrivialLoop1() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  builder.addFunction("main", kSig_v_i)
    .addBody([
      kExprLoop, kWasmVoid,
        kExprLocalGet, 0,
        kExprI32Const, 1,
        kExprI32Sub,
        kExprLocalTee, 0,
        kExprBrIf, 0,
      kExprEnd,
    ])
    .exportFunc();
  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  instance.exports.main(1);
  instance.exports.main(10);
  instance.exports.main(100);
})();

(function TestTrivialLoop2() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  builder.addFunction("main", kSig_v_i)
    .addBody([
      kExprLoop, kWasmVoid,
        kExprLocalGet, 0,
        kExprI32Const, 1,
        kExprI32Sub,
        kExprLocalTee, 0,
        kExprBrIf, 1,
        kExprBr, 0,
      kExprEnd,
    ])
    .exportFunc();
  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  instance.exports.main(1);
  instance.exports.main(10);
  instance.exports.main(100);
})();

(function TestNonRotatedLoopWithStore() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  builder.addMemory(1, undefined);
  builder.addFunction("main", kSig_v_i)
    .addBody([
      kExprLoop, kWasmVoid,
        kExprLocalGet, 0,
        kExprI32Const, 1,
        kExprI32Sub,
        kExprLocalTee, 0,
      kExprBrIf, 1,
        kExprI32Const, 0,
        kExprI32Const, 0,
        kExprI32StoreMem, 0, 0,
        kExprBr, 0,
      kExprEnd,
    ])
    .exportFunc();
  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  instance.exports.main(1);
  instance.exports.main(10);
  instance.exports.main(100);
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/wasm/loop-unrolling.js                                             0000664 0000000 0000000 00000016105 14746647661 0023005 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --no-liftoff
// Needed for exceptions-utils.js.
// Flags: --allow-natives-syntax

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
d8.file.execute("test/mjsunit/wasm/exceptions-utils.js");

// Test that lowering a ror operator with int64-lowering does not produce
// floating control, which is incompatible with loop unrolling.
(function I64RorLoweringTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addMemory(1000, 1000);

  builder.addFunction("main", makeSig([kWasmI32, kWasmI64], []))
    .addBody([
      kExprLoop, kWasmVoid,
        kExprLocalGet, 0x00,
        kExprI32LoadMem, 0x00, 0x00,
        kExprI64UConvertI32,
        kExprLocalGet, 0x01,
        kExprI64Ror,
        kExprI32ConvertI64,
        kExprBrIf, 0x00,
      kExprEnd])
    .exportFunc();

  let module = new WebAssembly.Module(builder.toBuffer());
  new WebAssembly.Instance(module);
})();

// Test the interaction between multireturn and loop unrolling.
(function MultiBlockResultTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = builder.addType(kSig_ii_ii);

  // f(a, b) = a + b + b + b - a*b*b*b
  builder.addFunction("main", kSig_i_ii)
    .addLocals(kWasmI32, 2)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 0,
      kExprLoop, sig,
        kExprLocalSet, 2,  // Temporarily store the second value.
        kExprLocalGet, 1, kExprI32Add,
        // multiply the second value by 2
        kExprLocalGet, 2, kExprLocalGet, 1, kExprI32Mul,
        // Increment counter, then loop if <= 3.
        kExprLocalGet, 3, kExprI32Const, 1, kExprI32Add, kExprLocalSet, 3,
        kExprLocalGet, 3, kExprI32Const, 3, kExprI32LtS,
        kExprBrIf, 0,
      kExprEnd,
      kExprI32Sub])
    .exportFunc();

  let instance = builder.instantiate();
  assertEquals(10 + 5 + 5 + 5 - (10 * 5 * 5 * 5), instance.exports.main(10, 5))
})();

// Test the interaction between tail calls and loop unrolling.
(function TailCallTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let callee = builder.addFunction("callee", kSig_i_i)
    .addBody([kExprLocalGet, 0]);

  builder.addFunction("main", kSig_i_i)
    .addBody([
      kExprLoop, kWasmVoid,
        kExprLocalGet, 0,
        kExprIf, kWasmVoid,
          kExprLocalGet, 0,
          kExprReturnCall, callee.index,
        kExprElse,
          kExprBr, 1,
        kExprEnd,
      kExprEnd,
      kExprUnreachable
    ])
    .exportAs("main");

  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  assertEquals(instance.exports.main(1), 1);
})();

// Test the interaction between the eh proposal and loop unrolling.

(function TestRethrowNested() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except1 = builder.addTag(kSig_v_v);
  let except2 = builder.addTag(kSig_v_v);
  builder.addFunction("rethrow_nested", kSig_i_i)
    .addBody([
      kExprLoop, kWasmI32,
      kExprTry, kWasmI32,
        kExprLoop, kWasmI32,
          kExprThrow, except2,
        kExprEnd,
      kExprCatch, except2,
        kExprTry, kWasmI32,
          kExprThrow, except1,
        kExprCatch, except1,
          kExprLocalGet, 0,
          kExprI32Const, 0,
          kExprI32Eq,
          kExprIf, kWasmVoid,
            kExprLoop, kWasmVoid,
              kExprRethrow, 2,
            kExprEnd,
          kExprEnd,
          kExprLocalGet, 0,
          kExprI32Const, 1,
          kExprI32Eq,
          kExprIf, kWasmVoid,
            kExprLoop, kWasmVoid,
              kExprRethrow, 3,
            kExprEnd,
          kExprEnd,
          kExprI32Const, 23,
        kExprEnd,
      kExprEnd,
      kExprEnd])
    .exportFunc();
  let instance = builder.instantiate();

  assertWasmThrows(instance, except1, [],
                   () => instance.exports.rethrow_nested(0));
  assertWasmThrows(instance, except2, [],
                   () => instance.exports.rethrow_nested(1));
  assertEquals(23, instance.exports.rethrow_nested(2));
})();

(function TestThrow() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except1 = builder.addTag(kSig_v_v);
  builder.addFunction("throw", kSig_i_i)
    .addBody([
      kExprLoop, kWasmVoid,
        kExprLocalGet, 0,
        kExprI32Const, 10,
        kExprI32GtS,
        kExprIf, kWasmVoid,
          kExprThrow, except1,
        kExprElse,
          kExprLocalGet, 0,
          kExprI32Const, 1,
          kExprI32Add,
          kExprLocalSet, 0,
          kExprBr, 1,
        kExprEnd,
      kExprEnd,
      kExprLocalGet, 0
    ])
    .exportFunc();

  let instance = builder.instantiate();
  assertWasmThrows(instance, except1, [], ()=>instance.exports.throw(0));
})();

(function TestThrowCatch() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except1 = builder.addTag(kSig_v_v);
  builder.addFunction("throw_catch", kSig_i_i)
    .addBody([
      kExprLoop, kWasmI32,
        kExprTry, kWasmI32,
          kExprLocalGet, 0,
          kExprI32Const, 10,
          kExprI32GtS,
          kExprIf, kWasmVoid,
            kExprThrow, except1,
          kExprElse,
            kExprLocalGet, 0,
            kExprI32Const, 1,
            kExprI32Add,
            kExprLocalSet, 0,
            kExprBr, 2,
          kExprEnd,
          kExprLocalGet, 0,
        kExprCatch, except1,
          kExprLocalGet, 0,
        kExprEnd,
      kExprEnd])
    .exportFunc();

  let instance = builder.instantiate();
  assertEquals(11, instance.exports.throw_catch(0));
})();

// Test that loops are unrolled in the presence of builtins.
(function UnrollWithBuiltinsTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  builder.addTable(kWasmFuncRef, 10, 10);

  let callee = builder.addFunction("callee", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprI32Const, 1, kExprI32Add])
    .exportFunc();

  builder.addFunction("main", makeSig([kWasmI32], []))
    .addBody([
      kExprLoop, kWasmVoid,
        kExprLocalGet, 0, kExprI32Const, 0, kExprI32LtS, kExprBrIf, 1,
        kExprLocalGet, 0,
        kExprRefFunc, callee.index,
        kExprTableSet, 0,
        kExprBr, 0,
      kExprEnd])
    .exportFunc();

  builder.instantiate();
})();

// Test that loops are *not* unrolled in the presence of direct/indirect calls.
(function LoopWithCallsTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let callee = builder.addFunction("callee", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprI32Const, 1, kExprI32Add])
    .exportFunc();

  builder.addFunction("main", makeSig([kWasmI32], []))
    .addBody([
      kExprLoop, kWasmVoid,
        kExprLocalGet, 0,
        kExprRefFunc, callee.index,
        kExprCallRef, callee.type_index,
        kExprBrIf, 0,
      kExprEnd,
      kExprLoop, kWasmVoid,
        kExprLocalGet, 0,
        kExprCallFunction, callee.index,
        kExprBrIf, 0,
      kExprEnd])
    .exportFunc();

  builder.instantiate();
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/wasm/many-memories-no-trap-handler.js                              0000664 0000000 0000000 00000001201 14746647661 0025567 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --no-wasm-trap-handler

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

// Without trap handlers, we are able to allocate basically arbitrarily many
// memories, because we don't need to reserve a huge amount of virtual address
// space.

const num_memories = 10000;

const memories = [];
while (memories.length < num_memories) {
  print('Allocating memory #' + memories.length);
  memories.push(new WebAssembly.Memory({initial: 1, maximum: 1}));
}
                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/wasm/many-memories.js                                              0000664 0000000 0000000 00000001545 14746647661 0022611 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

// Test that we can generate at least 50 memories of small size.
// More memories are currently not possible if the trap handler is enabled,
// because we reserve 10GB then, and we have a virtual memory space limit of
// 512GB on MIPS64 and 1TB+4GB on other 64-bit systems.

// The number of memories should be increased in this test once we raise that
// limit or fix the allocation strategy to allow for more memories generally.

const num_memories = 50;

const memories = [];
while (memories.length < num_memories) {
  print('Allocating memory #' + memories.length);
  memories.push(new WebAssembly.Memory({initial: 1, maximum: 1}));
}
                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/wasm/many-modules.js                                               0000664 0000000 0000000 00000003657 14746647661 0022447 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

// We generate the module bytes once to make this test more efficient,
// especially on simulator builds. The bytes contain a sentinel which is later
// patched to different constants. This makes the modules distinct and forces
// the engine to create different code for them.

// This is the sentinel placed in the bytes. It's a 5 byte LEB-encoded integer.
const sentinel = wasmSignedLeb(0x12345678);
assertEquals(5, sentinel.length);

const builder = new WasmModuleBuilder();
builder.addFunction('f', kSig_i_i).addBody([kExprI32Const, ...sentinel]);
const module_bytes = builder.toBuffer();

// Checks whether {module_bytes[i .. i+sentinel.length]} matches {sentinel}.
const has_sentinel = (i, k = 0) => module_bytes[i + k] == sentinel[k] &&
    (k == sentinel.length - 1 || has_sentinel(i, k + 1));
// Now find the sentinel.
const find_sentinel = i =>
    module_bytes.slice(i).findIndex((e, i) => has_sentinel(i));
const sentinel_position = find_sentinel(0);
assertTrue(has_sentinel(sentinel_position), 'found sentinel');
assertEquals(-1, find_sentinel(sentinel_position + 1), 'exactly one sentinel');

// Generating {num_modules} modules should not run out of memory, since the code
// space needed per module is quite low.
const num_modules = 10000;
// Keep all generated modules alive.
const modules = [];
// Reset sentinel section to nops so that shorter LEBs will just be followed by
// nops. This resion will be patched in the loop with values of increasing size.
module_bytes.set(Array(sentinel.length).fill(_ => kExprNop), sentinel_position);
for (let i = 0; i < num_modules; ++i) {
  if (i % 50 == 0) print(i);
  module_bytes.set(wasmSignedLeb(i), sentinel_position);
  modules.push(new WebAssembly.Module(module_bytes));
}
                                                                                 node-23.7.0/deps/v8/test/mjsunit/wasm/many-parameters.js                                            0000664 0000000 0000000 00000004243 14746647661 0023132 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

let types = [kWasmI32, kWasmF32, kWasmF64];
let type_names = ["i32", "f32", "f64"];
let type_const = [wasmI32Const, wasmF32Const, wasmF64Const];

function f(values, shift, num_const_params, ...args) {
  assertEquals(
      values.length + num_const_params, args.length, 'number of arguments');
  const expected = idx =>
      idx < values.length ? values[(idx + shift) % values.length] : idx;
  const msg = 'shifted by ' + shift + ': ' +
      'expected [' + args.map((_, i) => expected(i)).join(', ') + '], got [' +
      args.join(', ') + ']';
  args.forEach((arg_val, idx) => {
    assertEquals(expected(idx), arg_val, 'arg #' + idx + ', ' + msg);
  });
}

types.forEach((type, type_idx) => {
  for (let num_params = 3; num_params < 32; num_params += 4) {
    print(
        'Testing ' + num_params + ' parameters of type ' +
        type_names[type_idx] + '...');
    for (let num_const_params = 0; num_const_params <= 3; ++num_const_params) {
      for (let shift = 2; shift <= 5; shift += 3) {
        let builder = new WasmModuleBuilder();

        let params_outer = new Array(num_params).fill(type);
        sig_outer = makeSig(params_outer, []);
        let params_inner = new Array(num_params + num_const_params).fill(type);
        sig_inner = makeSig(params_inner, []);

        let body = [];
        for (let i = 0; i < num_params; ++i)
          body.push(kExprLocalGet, (i + shift) % num_params);
        for (let i = 0; i < num_const_params; ++i)
          body.push(...type_const[type_idx](num_params + i));
        body.push(kExprCallFunction, 0);

        builder.addImport('', 'f', sig_inner);
        builder.addFunction(undefined, sig_outer)
            .addBody(body)
            .exportAs('main');
        let values = new Array(num_params).fill(0).map((_, i) => 123 - 3 * i);

        instance = builder.instantiate(
            {'': {'f': f.bind(null, values, shift, num_const_params)}});
        instance.exports.main(...values);
      }
    }
  }
});
                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/max-module-size-flag.js                                       0000664 0000000 0000000 00000003225 14746647661 0023753 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-max-module-size=128

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

let small_binary = (() => {
  let builder = new WasmModuleBuilder();
  builder.addFunction('f', kSig_v_v).addBody(new Array(32).fill(kExprNop));
  return builder.toBuffer();
})();

let big_binary = (() => {
  let builder = new WasmModuleBuilder();
  builder.addFunction('f', kSig_v_v).addBody(new Array(128).fill(kExprNop));
  return builder.toBuffer();
})();

// Check that the sizes of the generated modules are within the expected ranges.
assertTrue(small_binary.length > 64);
assertTrue(small_binary.length < 128);
assertTrue(big_binary.length > 128);
assertTrue(big_binary.length < 256);

let big_error_msg =
    'buffer source exceeds maximum size of 128 (is ' + big_binary.length + ')';

(function TestSyncSmallModule() {
  let sync_small_module = new WebAssembly.Module(small_binary);
  assertTrue(sync_small_module instanceof WebAssembly.Module);
})();

assertPromiseResult((async function TestAsyncSmallModule() {
  let async_small_module = await WebAssembly.compile(small_binary);
  assertTrue(async_small_module instanceof WebAssembly.Module);
})());

(function TestSyncBigModule() {
  assertThrows(
      () => new WebAssembly.Module(big_binary), WebAssembly.CompileError,
      'WebAssembly.Module(): ' + big_error_msg);
})();

(function TestAsyncBigModule() {
  assertThrowsAsync(
      WebAssembly.compile(big_binary), WebAssembly.CompileError,
      'WebAssembly.compile(): ' + big_error_msg);
})();
                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/wasm/max-wasm-functions.js                                         0000664 0000000 0000000 00000001030 14746647661 0023554 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --max-wasm-functions=1000100

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

const builder = new WasmModuleBuilder();
const sig_index = builder.addType(makeSig([kWasmI32], [kWasmI32]));

for (let j = 0; j < 1000010; ++j) {
  builder.addFunction(undefined, sig_index)
    .addBody([kExprLocalGet, 0]);
}
const instance = builder.instantiate();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/wasm/memory-external-call.js                                       0000664 0000000 0000000 00000030163 14746647661 0024066 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

let initialMemoryPages = 1;
let maximumMemoryPages = 5;
let other_fn_idx = 0;

// This builder can be used to generate a module with memory + load/store
// functions and/or an additional imported function.
function generateBuilder(add_memory, import_sig) {
  let builder = new WasmModuleBuilder();
  if (import_sig) {
    // Add the import if we expect a module builder with imported functions.
    let idx = builder.addImport('import_module', 'other_module_fn', import_sig);
    // The imported function should always have index 0. With this assertion we
    // verify that we can use other_fn_idx to refer to this function.
    assertEquals(idx, other_fn_idx)
  }
  if (add_memory) {
    // Add the memory if we expect a module builder with memory and load/store.
    builder.addMemory(initialMemoryPages, maximumMemoryPages);
    builder.addFunction('load', kSig_i_i)
        .addBody([kExprLocalGet, 0, kExprI32LoadMem, 0, 0])
        .exportFunc();
    builder.addFunction('store', kSig_i_ii)
        .addBody([
          kExprLocalGet, 0, kExprLocalGet, 1, kExprI32StoreMem, 0, 0,
          kExprLocalGet, 1
        ])
        .exportFunc();
  }
  return builder;
}

function assertMemoryIndependence(load_a, store_a, load_b, store_b) {

  assertEquals(0, load_a(0));
  assertEquals(0, load_b(0));
  assertEquals(0, load_a(4));
  assertEquals(0, load_b(4));

  store_a(0, 101);
  assertEquals(101, load_a(0));
  assertEquals(0,   load_b(0));
  assertEquals(0, load_a(4));
  assertEquals(0, load_b(4));

  store_a(4, 102);
  assertEquals(101, load_a(0));
  assertEquals(0,   load_b(0));
  assertEquals(102, load_a(4));
  assertEquals(0,   load_b(4));

  store_b(0, 103);
  assertEquals(101, load_a(0));
  assertEquals(103, load_b(0));
  assertEquals(102, load_a(4));
  assertEquals(0,   load_b(4));

  store_b(4, 107);
  assertEquals(101, load_a(0));
  assertEquals(103, load_b(0));
  assertEquals(102, load_a(4));
  assertEquals(107, load_b(4));

  store_a(0, 0);
  store_a(4, 0);
  store_b(0, 0);
  store_b(4, 0);
}

// A simple test for memory-independence between modules.
(function SimpleMemoryIndependenceTest() {
  print("SimpleMemoryIndependenceTest");
  let kPages = 1;
  let builder = new WasmModuleBuilder();

  builder.addMemory(kPages, kPages);
  builder.addFunction("store", kSig_v_ii)
    .addBody([
      kExprLocalGet, 0,     // --
      kExprLocalGet, 1,     // --
      kExprI32StoreMem, 0, 0, // --
    ])                      // --
    .exportFunc();
  builder.addFunction("load", kSig_i_i)
    .addBody([
      kExprLocalGet, 0,     // --
      kExprI32LoadMem, 0, 0, // --
    ])                      // --
    .exportFunc();

  var a = builder.instantiate();

  // The {b} instance forwards all {store} calls to the imported function.
  builder = new WasmModuleBuilder();
  builder.addImport("mod", "store", kSig_v_ii);
  builder.addMemory(kPages, kPages);
  builder.addFunction("store", kSig_v_ii)
    .addBody([
      kExprLocalGet, 0,     // --
      kExprLocalGet, 1,     // --
      kExprCallFunction, 0, // --
    ])                      // --
    .exportFunc();
  builder.addFunction("load", kSig_i_i)
    .addBody([
      kExprLocalGet, 0,     // --
      kExprI32LoadMem, 0, 0, // --
    ])                      // --
    .exportFunc();

  var b = builder.instantiate({mod: {store: a.exports.store}});

  assertEquals(0, a.exports.load(0));
  assertEquals(0, b.exports.load(0));
  assertEquals(0, a.exports.load(4));
  assertEquals(0, b.exports.load(4));

  a.exports.store(0, 101);
  assertEquals(101, a.exports.load(0));
  assertEquals(0,   b.exports.load(0));
  assertEquals(0, a.exports.load(4));
  assertEquals(0, b.exports.load(4));

  a.exports.store(4, 102);
  assertEquals(101, a.exports.load(0));
  assertEquals(0,   b.exports.load(0));
  assertEquals(102, a.exports.load(4));
  assertEquals(0,   b.exports.load(4));

  b.exports.store(4, 107);  // should forward to {a}.
  assertEquals(101, a.exports.load(0));
  assertEquals(0,   b.exports.load(0));
  assertEquals(107, a.exports.load(4));
  assertEquals(0,   b.exports.load(4));

})();

// This test verifies that when a Wasm module without memory invokes a function
// imported from another module that has memory, the second module reads its own
// memory and returns the expected value.
(function TestExternalCallBetweenTwoWasmModulesWithoutAndWithMemory() {
  print('TestExternalCallBetweenTwoWasmModulesWithoutAndWithMemory');

  let first_module = generateBuilder(add_memory = false, import_sig = kSig_i_i);
  // Function to invoke the imported function and add 1 to the result.
  first_module.addFunction('plus_one', kSig_i_i)
      .addBody([
        kExprLocalGet, 0,                   // -
        kExprCallFunction, other_fn_idx,    // call the imported function
        kExprI32Const, 1,                   // -
        kExprI32Add,                        // add 1 to the result
        kExprReturn                         // -
      ])
      .exportFunc();
  let second_module =
      generateBuilder(add_memory = true, import_sig = undefined);

  let index = kPageSize - 4;
  let second_value = 2222;
  // Instantiate the instances.
  let second_instance = second_module.instantiate();
  let first_instance = first_module.instantiate(
      {import_module: {other_module_fn: second_instance.exports.load}});
  // Write the values in the second instance.
  second_instance.exports.store(index, second_value);
  assertEquals(second_value, second_instance.exports.load(index));
  // Verify that the value is correct when passing from the imported function.
  assertEquals(second_value + 1, first_instance.exports.plus_one(index));
})();

// This test verifies that when a Wasm module with memory invokes a function
// imported from another module that also has memory, the second module reads
// its own memory and returns the expected value.
(function TestExternalCallBetweenTwoWasmModulesWithMemory() {
  print('TestExternalCallBetweenTwoWasmModulesWithMemory');

  let first_module = generateBuilder(add_memory = true, import_sig = kSig_i_i);
  // Function to invoke the imported function and add 1 to the result.
  first_module.addFunction('plus_one', kSig_i_i)
      .addBody([
        kExprLocalGet, 0,                   // -
        kExprCallFunction, other_fn_idx,    // call the imported function
        kExprI32Const, 1,                   // -
        kExprI32Add,                        // add 1 to the result
        kExprReturn                         // -
      ])
      .exportFunc();
  let second_module =
      generateBuilder(add_memory = true, import_sig = undefined);

  let index = kPageSize - 4;
  let first_value = 1111;
  let second_value = 2222;
  // Instantiate the instances.
  let second_instance = second_module.instantiate();
  let first_instance = first_module.instantiate(
      {import_module: {other_module_fn: second_instance.exports.load}});
  // Write the values in the two instances.
  first_instance.exports.store(index, first_value);
  second_instance.exports.store(index, second_value);
  // Verify that the values were stored to memory.
  assertEquals(first_value, first_instance.exports.load(index));
  assertEquals(second_value, second_instance.exports.load(index));
  // Verify that the value is correct when passing from the imported function.
  assertEquals(second_value + 1, first_instance.exports.plus_one(index));
})();

// This test verifies that the correct memory is accessed after returning
// from a function imported from another module that also has memory.
(function TestCorrectMemoryAccessedAfterReturningFromExternalCall() {
  print('TestCorrectMemoryAccessedAfterReturningFromExternalCall');

  let first_module = generateBuilder(add_memory = true, import_sig = kSig_i_ii);
  // Function to invoke the imported function and add 1 to the result.
  first_module.addFunction('sandwich', kSig_i_iii)
      .addBody([
        kExprLocalGet, 0,                   // param0 (index)
        kExprLocalGet, 1,                   // param1 (first_value)
        kExprI32StoreMem, 0, 0,             // store value in first_instance
        kExprLocalGet, 0,                   // param0 (index)
        kExprLocalGet, 2,                   // param2 (second_value)
        kExprCallFunction, other_fn_idx,    // call the imported function
        kExprDrop,                          // drop the return value
        kExprLocalGet, 0,                   // param0 (index)
        kExprI32LoadMem, 0, 0,              // load from first_instance
        kExprReturn                         // -
      ])
      .exportFunc();
  let second_module =
      generateBuilder(add_memory = true, import_sig = undefined);

  let index = kPageSize - 4;
  let first_value = 1111;
  let second_value = 2222;
  // Instantiate the instances.
  let second_instance = second_module.instantiate();
  let first_instance = first_module.instantiate(
      {import_module: {other_module_fn: second_instance.exports.store}});
  // Call the sandwich function and check that it returns the correct value.
  assertEquals(
      first_value,
      first_instance.exports.sandwich(index, first_value, second_value));
  // Verify that the values are correct in both memories.
  assertEquals(first_value, first_instance.exports.load(index));
  assertEquals(second_value, second_instance.exports.load(index));
})();

// A test for memory-independence between modules when calling through
// imported tables.
(function CallThroughTableMemoryIndependenceTest() {
  print("CallThroughTableIndependenceTest");
  let kTableSize = 2;
  let kPages = 1;
  let builder = new WasmModuleBuilder();

  builder.addMemory(kPages, kPages);
  builder.addFunction("store", kSig_v_ii)
    .addBody([
      kExprLocalGet, 0,     // --
      kExprLocalGet, 1,     // --
      kExprI32StoreMem, 0, 0, // --
    ])                      // --
    .exportFunc();
  builder.addFunction("load", kSig_i_i)
    .addBody([
      kExprLocalGet, 0,     // --
      kExprI32LoadMem, 0, 0, // --
    ])                      // --
    .exportFunc();

  {
    // Create two instances.
    let module = builder.toModule();
    var a = new WebAssembly.Instance(module);
    var b = new WebAssembly.Instance(module);
    // Check that the memories are initially independent.
    assertMemoryIndependence(a.exports.load, a.exports.store,
                             b.exports.load, b.exports.store);
  }

  let table = new WebAssembly.Table({element: "anyfunc",
                                     initial: kTableSize,
                                     maximum: kTableSize});

  table.set(0, a.exports.store);
  table.set(1, b.exports.store);
  // Check that calling (from JS) through the table maintains independence.
  assertMemoryIndependence(a.exports.load, table.get(0),
                           b.exports.load, table.get(1));

  table.set(1, a.exports.store);
  table.set(0, b.exports.store);
  // Check that calling (from JS) through the table maintains independence,
  // even after reorganizing the table.
  assertMemoryIndependence(a.exports.load, table.get(1),
                           b.exports.load, table.get(0));

  // Check that calling (from Wasm) through the table maintains independence.
  builder = new WasmModuleBuilder();
  builder.addImportedTable("m", "table", kTableSize, kTableSize);
  var sig_index = builder.addType(kSig_v_ii);
  builder.addFunction("store", kSig_v_iii)
    .addBody([
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 0,
      kExprCallIndirect, sig_index, kTableZero,
    ]).exportFunc();

  let c = builder.instantiate({m: {table: table}});

  let a_index = 1;
  let b_index = 0;
  let store_a = (index, val) => c.exports.store(a_index, index, val)
  let store_b = (index, val) => c.exports.store(b_index, index, val);

  assertMemoryIndependence(a.exports.load, store_a,
                           b.exports.load, store_b);

  // Flip the order in the table and do it again.
  table.set(0, a.exports.store);
  table.set(1, b.exports.store);

  a_index = 0;
  b_index = 1;

  assertMemoryIndependence(a.exports.load, store_a,
                           b.exports.load, store_b);

})();
                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/memory-instance-validation.js                                 0000664 0000000 0000000 00000005155 14746647661 0025272 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --expose-gc

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// This test verifies that when instances are exported, Gc'ed, the other
// instances in the chain still maintain a consistent view of the memory.
(function ValidateSharedInstanceMemory() {
  print("ValidateSharedInstanceMemory");
  let memory = new WebAssembly.Memory({initial: 5, maximum: 100});
  var builder = new WasmModuleBuilder();
  builder.addImportedMemory("mod", "imported_mem");
  builder.addFunction("mem_size", kSig_i_v)
    .addBody([kExprMemorySize, kMemoryZero])
    .exportFunc();
  builder.addFunction("grow", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprMemoryGrow, kMemoryZero])
    .exportFunc();
  var instances = [];
  for (var i = 0; i < 5; i++) {
    instances.push(builder.instantiate({mod: {imported_mem: memory}}));
  }
  function grow_instance(index, pages) {
    return instances[index].exports.grow(pages);
  }

  function verify_mem_size(expected_pages) {
    print("  checking size = " + expected_pages + " pages");
    assertEquals(expected_pages*kPageSize, memory.buffer.byteLength);
    for (let i = 0; i < instances.length; i++) {
      if (instances[i] == null) continue;
      assertEquals(expected_pages, instances[i].exports.mem_size());
    }
  }

  // Verify initial memory size of all instances, grow and verify that all
  // instances are updated correctly.
  verify_mem_size(5);
  assertEquals(5, memory.grow(6));
  verify_mem_size(11);

  print("  instances[1] = null, GC");
  instances[1] = null;
  gc();

  // i[0] - i[2] - i[3] - i[4]
  verify_mem_size(11);
  assertEquals(11, grow_instance(2, 10));
  verify_mem_size(21);

  print("  instances[4] = null, GC");
  instances[4] = null;
  gc();
  verify_mem_size(21);

  assertEquals(21, memory.grow(2));
  verify_mem_size(23);

  print("  instances[0] = null, GC");
  instances[0] = null;
  gc();
  gc();
  verify_mem_size(23);

  assertEquals(23, grow_instance(3, 5));
  verify_mem_size(28);

  print("  new instance, GC");
  // Instantiate a new instance and verify that it can be grown correctly.
  instances.push(builder.instantiate({mod: {imported_mem: memory}}));
  gc();
  gc();

  verify_mem_size(28);
  assertEquals(28, grow_instance(5, 2));
  verify_mem_size(30);
  assertEquals(30, memory.grow(5));
  verify_mem_size(35);

  for (let i = 0; i < instances.length; i++) {
    print("  instances[" + i + "] = null, GC");
    instances[i] = null;
    gc();
    verify_mem_size(35);
  }

})();
                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/wasm/memory-size.js                                                0000664 0000000 0000000 00000004507 14746647661 0022310 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

var kV8MaxWasmMemoryPages = 65536;  // 4 GiB
var kSpecMaxWasmMemoryPages = 65536;  // 4 GiB

(function testMemorySizeZero() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  builder.addMemory(0, 0);
  builder.addFunction("memory_size", kSig_i_v)
         .addBody([kExprMemorySize, kMemoryZero])
         .exportFunc();
  var module = builder.instantiate();
  assertEquals(0, module.exports.memory_size());
})();

(function testMemorySizeNonZero() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  var size = 11;
  builder.addMemory(size, size);
  builder.addFunction("memory_size", kSig_i_v)
         .addBody([kExprMemorySize, kMemoryZero])
         .exportFunc();
  var module = builder.instantiate();
  assertEquals(size, module.exports.memory_size());
})();

(function testMemorySizeSpecMaxOk() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  builder.addMemory(1, kSpecMaxWasmMemoryPages);
  builder.addFunction("memory_size", kSig_i_v)
         .addBody([kExprMemorySize, kMemoryZero])
         .exportFunc();
  var module = builder.instantiate();
  assertEquals(1, module.exports.memory_size());
})();

(function testMemorySizeV8MaxPlus1Throws() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  builder.addMemory(kV8MaxWasmMemoryPages + 1,
                    kV8MaxWasmMemoryPages + 1);
  builder.addFunction("memory_size", kSig_i_v)
         .addBody([kExprMemorySize, kMemoryZero])
         .exportFunc();
  assertThrows(() => builder.instantiate());
})();

(function testMemorySpecMaxOk() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  builder.addMemory(1, kSpecMaxWasmMemoryPages);
  builder.addFunction("memory_size", kSig_i_v)
         .addBody([kExprMemorySize, kMemoryZero])
    .exportFunc();
  var module = builder.instantiate();
  assertEquals(1, module.exports.memory_size());
})();

(function testMemoryInitialMaxPlus1Throws() {
  print(arguments.callee.name);
  assertThrows(() => new WebAssembly.Memory(
      {initial: kV8WasmMaxMemoryPages + 1}));
})();
                                                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/wasm/memory.js                                                     0000664 0000000 0000000 00000006536 14746647661 0021344 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// Basic tests.

var outOfUint32RangeValue = 1e12;

function assertMemoryIsValid(memory) {
  assertSame(WebAssembly.Memory.prototype, memory.__proto__);
  assertSame(WebAssembly.Memory, memory.constructor);
  assertTrue(memory instanceof Object);
  assertTrue(memory instanceof WebAssembly.Memory);
}

(function TestConstructor() {
  assertTrue(WebAssembly.Memory instanceof Function);
  assertSame(WebAssembly.Memory, WebAssembly.Memory.prototype.constructor);
  assertTrue(WebAssembly.Memory.prototype.grow instanceof Function);
  let desc = Object.getOwnPropertyDescriptor(WebAssembly.Memory.prototype, 'buffer');
  assertTrue(desc.get instanceof Function);
  assertSame(undefined, desc.set);

  assertThrows(() => new WebAssembly.Memory(), TypeError);
  assertThrows(() => new WebAssembly.Memory(1), TypeError);
  assertThrows(() => new WebAssembly.Memory(""), TypeError);

  assertThrows(() => new WebAssembly.Memory({initial: -1}), TypeError);
  assertThrows(() => new WebAssembly.Memory({initial: outOfUint32RangeValue}), TypeError);

  assertThrows(() => new WebAssembly.Memory({initial: 10, maximum: -1}), TypeError);
  assertThrows(() => new WebAssembly.Memory({initial: 10, maximum: outOfUint32RangeValue}), TypeError);
  assertThrows(() => new WebAssembly.Memory({initial: 10, maximum: 9}), RangeError);

  let memory = new WebAssembly.Memory({initial: 1});
  assertMemoryIsValid(memory);
})();

(function TestConstructorWithMaximum() {
  let memory = new WebAssembly.Memory({initial: 1, maximum: 10});
  assertMemoryIsValid(memory);
})();

(function TestMaximumIsUndefined() {
  // New memory with maximum = undefined, which means maximum = 0.
  let memory = new WebAssembly.Memory({initial: 0, maximum: undefined});
  assertMemoryIsValid(memory);
})();

(function TestMaximumIsReadOnce() {
  var a = true;
  var desc = {initial: 10};
  Object.defineProperty(desc, 'maximum', {get: function() {
    if (a) {
      a = false;
      return 16;
    }
    else {
      // Change the return value on the second call so it throws.
      return -1;
    }
  }});
  let memory = new WebAssembly.Memory(desc);
  assertMemoryIsValid(memory);
})();

(function TestMaximumDoesNotHasProperty() {
  var hasPropertyWasCalled = false;
  var desc = {initial: 10};
  var proxy = new Proxy({maximum: 16}, {
    has: function(target, name) { hasPropertyWasCalled = true; }
  });
  Object.setPrototypeOf(desc, proxy);
  let memory = new WebAssembly.Memory(desc);
  assertMemoryIsValid(memory);
  assertFalse(hasPropertyWasCalled);
})();

(function TestBuffer() {
  let memory = new WebAssembly.Memory({initial: 1});
  assertTrue(memory.buffer instanceof Object);
  assertTrue(memory.buffer instanceof ArrayBuffer);
  assertThrows(() => {'use strict'; memory.buffer = memory.buffer}, TypeError)
  assertThrows(() => ({__proto__: memory}).buffer, TypeError)
})();

(function TestMemoryGrow() {
  let memory = new WebAssembly.Memory({initial: 1, maximum:30});
  assertEquals(1, memory.grow(9));
  assertTrue(memory.buffer instanceof ArrayBuffer);
  assertTrue(10*kPageSize == memory.buffer.byteLength);
  assertMemoryIsValid(memory);
  assertThrows(() => memory.grow(21));
})();
                                                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/wasm/memory64.js                                                   0000664 0000000 0000000 00000061401 14746647661 0021506 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-memory64

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

// We use standard JavaScript doubles to represent bytes and offsets. They offer
// enough precision (53 bits) for every allowed memory size.

const GB = 1024 * 1024 * 1024;
// The current limit is 16GB. Adapt this test if this changes.
const max_num_pages = 16 * GB / kPageSize;

function BasicMemory64Tests(num_pages, use_atomic_ops) {
  const num_bytes = num_pages * kPageSize;
  print(`Testing ${num_bytes} bytes (${num_pages} pages) on ${
      use_atomic_ops ? '' : 'non-'}atomic memory`);

  let builder = new WasmModuleBuilder();
  builder.addMemory64(num_pages, num_pages);
  builder.exportMemoryAs('memory');

  // A memory operation with alignment (2) and offset (0).
  let op = (non_atomic, atomic) => use_atomic_ops ?
      [kAtomicPrefix, atomic, 2, 0] :
      [non_atomic, 2, 0];
  builder.addFunction('load', makeSig([kWasmF64], [kWasmI32]))
      .addBody([
        kExprLocalGet, 0,                           // local.get 0
        kExprI64UConvertF64,                        // i64.uconvert_sat.f64
        ...op(kExprI32LoadMem, kExprI32AtomicLoad)  // load
      ])
      .exportFunc();
  builder.addFunction('store', makeSig([kWasmF64, kWasmI32], []))
      .addBody([
        kExprLocalGet, 0,                             // local.get 0
        kExprI64UConvertF64,                          // i64.uconvert_sat.f64
        kExprLocalGet, 1,                             // local.get 1
        ...op(kExprI32StoreMem, kExprI32AtomicStore)  // store
      ])
      .exportFunc();

  let module = builder.instantiate();
  let memory = module.exports.memory;
  let load = module.exports.load;
  let store = module.exports.store;

  assertEquals(num_bytes, memory.buffer.byteLength);
  // Test that we can create a TypedArray from that large buffer.
  let array = new Int8Array(memory.buffer);
  assertEquals(num_bytes, array.length);

  const GB = Math.pow(2, 30);
  let unalignedAndOobTrap =
    use_atomic_ops ? kTrapUnalignedAccess : kTrapMemOutOfBounds;
  assertEquals(0, load(num_bytes - 4));
  assertTraps(kTrapMemOutOfBounds, () => load(num_bytes));
  assertTraps(unalignedAndOobTrap, () => load(num_bytes - 3));
  assertTraps(kTrapMemOutOfBounds, () => load(num_bytes - 4 + 4 * GB));
  assertTraps(kTrapMemOutOfBounds, () => store(num_bytes));
  assertTraps(unalignedAndOobTrap, () => store(num_bytes - 3));
  assertTraps(kTrapMemOutOfBounds, () => store(num_bytes - 4 + 4 * GB));
  if (use_atomic_ops) {
    assertTraps(kTrapUnalignedAccess, () => load(num_bytes - 7));
    assertTraps(kTrapUnalignedAccess, () => store(num_bytes - 7));
  }

  store(num_bytes - 4, 0x12345678);
  assertEquals(0x12345678, load(num_bytes - 4));

  let kStoreOffset = use_atomic_ops ? 40 : 27;
  store(kStoreOffset, 11);
  assertEquals(11, load(kStoreOffset));

  // Now check some interesting positions, plus 100 random positions.
  const positions = [
    // Nothing at the beginning.
    0, 1,
    // Check positions around the store offset.
    kStoreOffset - 1, kStoreOffset, kStoreOffset + 1,
    // Check the end.
    num_bytes - 5, num_bytes - 4, num_bytes - 3, num_bytes - 2, num_bytes - 1,
    // Check positions at the end, truncated to 32 bit (might be
    // redundant).
    (num_bytes - 5) >>> 0, (num_bytes - 4) >>> 0, (num_bytes - 3) >>> 0,
    (num_bytes - 2) >>> 0, (num_bytes - 1) >>> 0
  ];
  const random_positions =
      Array.from({length: 100}, () => Math.floor(Math.random() * num_bytes));
  for (let position of positions.concat(random_positions)) {
    let expected = 0;
    if (position == kStoreOffset) {
      expected = 11;
    } else if (num_bytes - position <= 4) {
      expected = [0x12, 0x34, 0x56, 0x78][num_bytes - position - 1];
    }
    let value = new Int8Array(memory.buffer, position, 1)[0];
    assertEquals(expected, value);
  }
}

function allowOOM(fn) {
  try {
    fn();
  } catch (e) {
    const is_oom =
        (e instanceof RangeError) && e.message.includes('Out of memory');
    if (!is_oom) throw e;
  }
}

(function TestSmallMemory() {
  print(arguments.callee.name);
  BasicMemory64Tests(4);
})();

(function Test3GBMemory() {
  print(arguments.callee.name);
  let num_pages = 3 * GB / kPageSize;
  // This test can fail if 3GB of memory cannot be allocated.
  allowOOM(() => BasicMemory64Tests(num_pages));
})();

(function Test5GBMemory() {
  print(arguments.callee.name);
  let num_pages = 5 * GB / kPageSize;
  // This test can fail if 5GB of memory cannot be allocated.
  allowOOM(() => BasicMemory64Tests(num_pages));
})();

(function TestMaxMem64Size() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addMemory64(max_num_pages);

  assertTrue(WebAssembly.validate(builder.toBuffer()));
  builder.toModule();

  // This test can fail if 16GB of memory cannot be allocated.
  allowOOM(() => BasicMemory64Tests(max_num_pages));
})();

(function TestTooBigDeclaredInitial() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addMemory64(max_num_pages + 1);

  assertFalse(WebAssembly.validate(builder.toBuffer()));
  assertThrows(
      () => builder.toModule(), WebAssembly.CompileError,
      'WebAssembly.Module(): initial memory size (262145 pages) is larger ' +
          'than implementation limit (262144 pages) @+12');
})();

(function TestTooBigDeclaredMaximum() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addMemory64(1, max_num_pages + 1);

  assertFalse(WebAssembly.validate(builder.toBuffer()));
  assertThrows(
      () => builder.toModule(), WebAssembly.CompileError,
      'WebAssembly.Module(): maximum memory size (262145 pages) is larger ' +
          'than implementation limit (262144 pages) @+13');
})();

(function TestGrow64() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addMemory64(1, 10, false);

  builder.addFunction('grow', makeSig([kWasmI64], [kWasmI64]))
      .addBody([
        kExprLocalGet, 0,    // local.get 0
        kExprMemoryGrow, 0,  // memory.grow 0
      ])
      .exportFunc();

  let instance = builder.instantiate();

  assertEquals(1n, instance.exports.grow(2n));
  assertEquals(3n, instance.exports.grow(1n));
  assertEquals(-1n, instance.exports.grow(-1n));
  assertEquals(-1n, instance.exports.grow(1n << 31n));
  assertEquals(-1n, instance.exports.grow(1n << 32n));
  assertEquals(-1n, instance.exports.grow(1n << 33n));
  assertEquals(-1n, instance.exports.grow(1n << 63n));
  assertEquals(-1n, instance.exports.grow(7n));  // Above the maximum of 10.
  assertEquals(4n, instance.exports.grow(6n));   // Just at the maximum of 10.
})();

(function TestGrow64_ToMemory() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addMemory64(1, 10);
  builder.exportMemoryAs('memory');

  // Grow memory and store the result in memory for inspection from JS.
  builder.addFunction('grow', makeSig([kWasmI64], []))
      .addBody([
        kExprI64Const, 0,       // i64.const (offset for result)
        kExprLocalGet, 0,       // local.get 0
        kExprMemoryGrow, 0,     // memory.grow 0
        kExprI64StoreMem, 3, 0  // store result to memory
      ])
      .exportFunc();

  let instance = builder.instantiate();
  function grow(arg) {
    instance.exports.grow(arg);
    let i64_arr = new BigInt64Array(instance.exports.memory.buffer, 0, 1);
    return i64_arr[0];
  }

  assertEquals(1n, grow(2n));
  assertEquals(3n, grow(1n));
  assertEquals(-1n, grow(-1n));
  assertEquals(-1n, grow(1n << 31n));
  assertEquals(-1n, grow(1n << 32n));
  assertEquals(-1n, grow(1n << 33n));
  assertEquals(-1n, grow(1n << 63n));
  assertEquals(-1n, grow(7n));  // Above the maximum of 10.
  assertEquals(4n, grow(6n));   // Just at the maximum of 10.
})();

(function TestGrow64_Above4GB() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let max_pages = 5 * GB / kPageSize;
  builder.addMemory64(1, max_pages);
  builder.exportMemoryAs('memory');

  builder.addFunction('grow', makeSig([kWasmI64], [kWasmI64]))
      .addBody([
        kExprLocalGet, 0,    // local.get 0
        kExprMemoryGrow, 0,  // memory.grow 0
      ])
      .exportFunc();

  let instance = builder.instantiate();

  // Grow from 1 to 3 pages.
  assertEquals(1n, instance.exports.grow(2n));
  // Grow from 3 to {max_pages - 1} pages.
  // This step can fail. We have to allow this, even though it weakens this test
  // (we do not know if we failed because of OOM or because of a wrong
  // engine-internal limit of 4GB).
  let grow_big_result = instance.exports.grow(BigInt(max_pages) - 4n);
  if (grow_big_result == -1) return;
  assertEquals(3n, grow_big_result);
  // Cannot grow by 2 pages.
  assertEquals(-1n, instance.exports.grow(2n));
  // Cannot grow by 2^32 pages.
  assertEquals(-1n, instance.exports.grow(1n << 32n));
  // Grow by one more page to the maximum.
  grow_big_result = instance.exports.grow(1n);
  if (grow_big_result == -1) return;
  assertEquals(BigInt(max_pages) - 1n, grow_big_result);
  // Cannot grow further.
  assertEquals(-1n, instance.exports.grow(1n));
})();

(function TestBulkMemoryOperations() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  const kMemSizeInPages = 10;
  const kMemSize = kMemSizeInPages * kPageSize;
  builder.addMemory64(kMemSizeInPages, kMemSizeInPages);
  const kSegmentSize = 1024;
  // Build a data segment with values [0, kSegmentSize-1].
  const segment = Array.from({length: kSegmentSize}, (_, idx) => idx)
  builder.addPassiveDataSegment(segment);
  builder.exportMemoryAs('memory');

  builder.addFunction('fill', makeSig([kWasmI64, kWasmI32, kWasmI64], []))
      .addBody([
        kExprLocalGet, 0,                   // local.get 0 (dst)
        kExprLocalGet, 1,                   // local.get 1 (value)
        kExprLocalGet, 2,                   // local.get 2 (size)
        kNumericPrefix, kExprMemoryFill, 0  // memory.fill mem=0
      ])
      .exportFunc();

  builder.addFunction('copy', makeSig([kWasmI64, kWasmI64, kWasmI64], []))
      .addBody([
        kExprLocalGet, 0,                      // local.get 0 (dst)
        kExprLocalGet, 1,                      // local.get 1 (src)
        kExprLocalGet, 2,                      // local.get 2 (size)
        kNumericPrefix, kExprMemoryCopy, 0, 0  // memory.copy srcmem=0 dstmem=0
      ])
      .exportFunc();

  builder.addFunction('init', makeSig([kWasmI64, kWasmI32, kWasmI32], []))
      .addBody([
        kExprLocalGet, 0,                      // local.get 0 (dst)
        kExprLocalGet, 1,                      // local.get 1 (offset)
        kExprLocalGet, 2,                      // local.get 2 (size)
        kNumericPrefix, kExprMemoryInit, 0, 0  // memory.init seg=0 mem=0
      ])
      .exportFunc();

  let instance = builder.instantiate();
  let fill = instance.exports.fill;
  let copy = instance.exports.copy;
  let init = instance.exports.init;
  // {memory(offset,size)} extracts the memory at [offset, offset+size)] into an
  // Array.
  let memory = (offset, size) => Array.from(new Uint8Array(
      instance.exports.memory.buffer.slice(offset, offset + size)));

  // Empty init (size=0).
  init(0n, 0, 0);
  assertEquals([0, 0], memory(0, 2));
  // Init memory[5..7] with [10..12].
  init(5n, 10, 3);
  assertEquals([0, 0, 10, 11, 12, 0, 0], memory(3, 7));
  // Init the end of memory ([kMemSize-2, kMemSize-1]) with [20, 21].
  init(BigInt(kMemSize-2), 20, 2);
  assertEquals([0, 0, 20, 21], memory(kMemSize - 4, 4));
  // Writing slightly OOB.
  assertTraps(kTrapMemOutOfBounds, () => init(BigInt(kMemSize-2), 20, 3));
  // Writing OOB, but the low 32-bit are in-bound.
  assertTraps(kTrapMemOutOfBounds, () => init(1n << 32n, 0, 0));
  // OOB even though size == 0.
  assertTraps(kTrapMemOutOfBounds, () => init(-1n, 0, 0));
  // More OOB.
  assertTraps(kTrapMemOutOfBounds, () => init(-1n, 0, 1));
  assertTraps(kTrapMemOutOfBounds, () => init(1n << 62n, 0, 1));
  assertTraps(kTrapMemOutOfBounds, () => init(1n << 63n, 0, 1));

  // Empty copy (size=0).
  copy(0n, 0n, 0n);
  // Copy memory[5..7] (containing [10..12]) to [3..5].
  copy(3n, 5n, 3n);
  assertEquals([0, 0, 0, 10, 11, 12, 11, 12, 0], memory(0, 9));
  // Copy to the end of memory ([kMemSize-2, kMemSize-1]).
  copy(BigInt(kMemSize-2), 3n, 2n);
  assertEquals([0, 0, 10, 11], memory(kMemSize - 4, 4));
  // Writing slightly OOB.
  assertTraps(kTrapMemOutOfBounds, () => copy(BigInt(kMemSize-2), 0n, 3n));
  // Writing OOB, but the low 32-bit are in-bound.
  assertTraps(kTrapMemOutOfBounds, () => copy(1n << 32n, 0n, 1n));
  assertTraps(kTrapMemOutOfBounds, () => copy(0n, 0n, 1n << 32n));
  // OOB even though size == 0.
  assertTraps(kTrapMemOutOfBounds, () => copy(-1n, 0n, 0n));
  // More OOB.
  assertTraps(kTrapMemOutOfBounds, () => copy(-1n, 0n, 1n));
  assertTraps(kTrapMemOutOfBounds, () => copy(1n << 62n, 0n, 1n));
  assertTraps(kTrapMemOutOfBounds, () => copy(1n << 63n, 0n, 1n));

  // Empty fill (size=0).
  fill(0n, 0, 0n);
  // Fill memory[15..17] with 3s.
  fill(15n, 3, 3n);
  assertEquals([0, 3, 3, 3, 0], memory(14, 5));
  // Fill the end of memory ([kMemSize-2, kMemSize-1]) with 7s.
  fill(BigInt(kMemSize-2), 7, 2n);
  assertEquals([0, 0, 7, 7], memory(kMemSize - 4, 4));
  // Writing slightly OOB.
  assertTraps(kTrapMemOutOfBounds, () => fill(BigInt(kMemSize-2), 0, 3n));
  // Writing OOB, but the low 32-bit are in-bound.
  assertTraps(kTrapMemOutOfBounds, () => fill(1n << 32n, 0, 1n));
  assertTraps(kTrapMemOutOfBounds, () => fill(0n, 0, 1n << 32n));
  // OOB even though size == 0.
  assertTraps(kTrapMemOutOfBounds, () => fill(-1n, 0, 0n));
  // More OOB.
  assertTraps(kTrapMemOutOfBounds, () => fill(-1n, 0, 1n));
  assertTraps(kTrapMemOutOfBounds, () => fill(1n << 62n, 0, 1n));
  assertTraps(kTrapMemOutOfBounds, () => fill(1n << 63n, 0, 1n));
})();

(function TestBulkMemoryConstOperations() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  const kMemSizeInPages = 10;
  builder.addMemory64(kMemSizeInPages, kMemSizeInPages);
  const kSegmentSize = 1024;
  // Build a data segment with values [0, kSegmentSize-1].
  const segment = Array.from({length: kSegmentSize}, (_, idx) => idx)
  builder.addPassiveDataSegment(segment);
  builder.exportMemoryAs('memory');

  builder.addFunction('fill', makeSig([kWasmI32, kWasmI64], []))
      .addBody([
        kExprI64Const, 15,                  // i64.const 15
        kExprLocalGet, 0,                   // local.get 0 (value)
        kExprLocalGet, 1,                   // local.get 1 (size)
        kNumericPrefix, kExprMemoryFill, 0  // memory.fill mem=0
      ])
      .exportFunc();

  builder.addFunction('init', makeSig([kWasmI32, kWasmI32], []))
      .addBody([
        kExprI64Const, 5,                      // i64.const 5
        kExprLocalGet, 0,                      // local.get 0 (offset)
        kExprLocalGet, 1,                      // local.get 1 (size)
        kNumericPrefix, kExprMemoryInit, 0, 0  // memory.init seg=0 mem=0
      ])
      .exportFunc();

  let instance = builder.instantiate();
  let fill = instance.exports.fill;
  let init = instance.exports.init;
  // {memory(offset,size)} extracts the memory at [offset, offset+size)] into an
  // Array.
  let memory = (offset, size) => Array.from(new Uint8Array(
      instance.exports.memory.buffer.slice(offset, offset + size)));

  // Init memory[5..7] with [10..12].
  init(10, 3);
  assertEquals([0, 0, 10, 11, 12, 0, 0], memory(3, 7));

  // Fill memory[15..17] with 3s.
  fill(3, 3n);
  assertEquals([0, 3, 3, 3, 0], memory(14, 5));
})();

(function TestMemory64SharedBasic() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addMemory64(1, 10, true);
  builder.exportMemoryAs('memory');
  builder.addFunction('load', makeSig([kWasmI64], [kWasmI32]))
      .addBody([
        kExprLocalGet, 0,       // local.get 0
        kExprI32LoadMem, 0, 0,  // i32.load_mem align=1 offset=0
      ])
      .exportFunc();
  let instance = builder.instantiate();

  assertTrue(instance.exports.memory instanceof WebAssembly.Memory);
  assertTrue(instance.exports.memory.buffer instanceof SharedArrayBuffer);
  assertEquals(0, instance.exports.load(0n));
})();

(function TestMemory64SharedBetweenWorkers() {
  print(arguments.callee.name);
  let shared_mem64 = new WebAssembly.Memory(
      {initial: 1, maximum: 10, shared: true, index: 'i64'});

  let builder = new WasmModuleBuilder();
  builder.addImportedMemory('imp', 'mem', 1, 10, true, true);

  builder.addFunction('grow', makeSig([kWasmI64], [kWasmI64]))
      .addBody([
        kExprLocalGet, 0,    // local.get 0
        kExprMemoryGrow, 0,  // memory.grow 0
      ])
      .exportFunc();
  builder.addFunction('load', makeSig([kWasmI64], [kWasmI32]))
      .addBody([
        kExprLocalGet, 0,       // local.get 0
        kExprI32LoadMem, 0, 0,  // i32.load_mem align=1 offset=0
      ])
      .exportFunc();
  builder.addFunction('store', makeSig([kWasmI64, kWasmI32], []))
      .addBody([
        kExprLocalGet, 0,        // local.get 0
        kExprLocalGet, 1,        // local.get 1
        kExprI32StoreMem, 0, 0,  // i32.store_mem align=1 offset=0
      ])
      .exportFunc();

  let module = builder.toModule();
  let instance = new WebAssembly.Instance(module, {imp: {mem: shared_mem64}});

  assertEquals(1n, instance.exports.grow(2n));
  assertEquals(3n, instance.exports.grow(1n));
  const kOffset1 = 47n;
  const kOffset2 = 128n;
  const kValue = 21;
  assertEquals(0, instance.exports.load(kOffset1));
  instance.exports.store(kOffset1, kValue);
  assertEquals(kValue, instance.exports.load(kOffset1));
  let worker = new Worker(function() {
    onmessage = function({data:[mem, module]}) {
      function workerAssert(condition, message) {
        if (!condition) postMessage(`Check failed: ${message}`);
      }

      function workerAssertEquals(expected, actual, message) {
        if (expected != actual) {
          postMessage(`Check failed (${message}): ${expected} != ${actual}`);
        }
      }

      const kOffset1 = 47n;
      const kOffset2 = 128n;
      const kValue = 21;
      workerAssert(mem instanceof WebAssembly.Memory, 'Wasm memory');
      workerAssert(mem.buffer instanceof SharedArrayBuffer);
      workerAssertEquals(4, mem.grow(1), 'grow');
      let instance = new WebAssembly.Instance(module, {imp: {mem: mem}});
      let exports = instance.exports;
      workerAssertEquals(kValue, exports.load(kOffset1), 'load 1');
      workerAssertEquals(0, exports.load(kOffset2), 'load 2');
      exports.store(kOffset2, kValue);
      workerAssertEquals(kValue, exports.load(kOffset2), 'load 3');
      postMessage('OK');
    }
  }, {type: 'function'});
  worker.postMessage([shared_mem64, module]);
  assertEquals('OK', worker.getMessage());
  assertEquals(kValue, instance.exports.load(kOffset2));
  assertEquals(5n, instance.exports.grow(1n));
})();

(function TestAtomics_SmallMemory() {
  print(arguments.callee.name);
  BasicMemory64Tests(4, true);
})();

(function TestAtomics_5GB() {
  print(arguments.callee.name);
  let num_pages = 5 * GB / kPageSize;
  // This test can fail if 5GB of memory cannot be allocated.
  allowOOM(() => BasicMemory64Tests(num_pages, true));
})();

(function Test64BitOffsetOn32BitMemory() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addMemory(1, 1);

  builder.addFunction('load', makeSig([kWasmI32], [kWasmI32]))
      .addBody([
        // local.get 0
        kExprLocalGet, 0,
        // i32.load align=0 offset=2^32+2
        kExprI32LoadMem, 0, ...wasmSignedLeb64(Math.pow(2, 32) + 2),
      ])
      .exportFunc();

  // An offset outside the 32-bit range should not validate.
  assertFalse(WebAssembly.validate(builder.toBuffer()));
})();

(function Test64BitOffsetOn64BitMemory() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addMemory64(1, 1);

  builder.addFunction('load', makeSig([kWasmI64], [kWasmI32]))
      .addBody([
        // local.get 0
        kExprLocalGet, 0,
        // i32.load align=0 offset=2^32+2
        kExprI32LoadMem, 0, ...wasmSignedLeb64(Math.pow(2, 32) + 2),
      ])
      .exportFunc();

  // Instantiation works, this should throw at runtime.
  let instance = builder.instantiate();
  let load = instance.exports.load;

  assertTraps(kTrapMemOutOfBounds, () => load(0n));
})();

(function TestImportMemory64() {
  print(arguments.callee.name);
  const builder1 = new WasmModuleBuilder();
  builder1.addMemory64(1, 1);
  builder1.exportMemoryAs('mem64');
  const instance1 = builder1.instantiate();
  const {mem64} = instance1.exports;

  let builder2 = new WasmModuleBuilder();
  builder2.addImportedMemory(
      'imp', 'mem', 1, 1, /* shared */ false, /* memory64 */ true);
  builder2.instantiate({imp: {mem: mem64}});
})();

(function TestImportMemory64AsMemory32() {
  print(arguments.callee.name);
  const builder1 = new WasmModuleBuilder();
  builder1.addMemory64(1, 1);
  builder1.exportMemoryAs('mem64');
  const instance1 = builder1.instantiate();
  const {mem64} = instance1.exports;

  let builder2 = new WasmModuleBuilder();
  builder2.addImportedMemory('imp', 'mem');
  assertThrows(
      () => builder2.instantiate({imp: {mem: mem64}}), WebAssembly.LinkError,
      'WebAssembly.Instance(): cannot import memory64 as memory32');
})();

(function TestImportMemory32AsMemory64() {
  print(arguments.callee.name);
  const builder1 = new WasmModuleBuilder();
  builder1.addMemory(1, 1);
  builder1.exportMemoryAs('mem32');
  const instance1 = builder1.instantiate();
  const {mem32} = instance1.exports;

  let builder2 = new WasmModuleBuilder();
  builder2.addImportedMemory(
      'imp', 'mem', 1, 1, /* shared */ false, /* memory64 */ true);
  assertThrows(
      () => builder2.instantiate({imp: {mem: mem32}}), WebAssembly.LinkError,
      'WebAssembly.Instance(): cannot import memory32 as memory64');
})();

function InstantiatingWorkerCode() {
  function workerAssert(condition, message) {
    if (!condition) postMessage(`Check failed: ${message}`);
  }

  onmessage = function({data:[mem, module]}) {
    workerAssert(mem instanceof WebAssembly.Memory, 'Wasm memory');
    workerAssert(mem.buffer instanceof SharedArrayBuffer, 'SAB');
    try {
      new WebAssembly.Instance(module, {imp: {mem: mem}});
      postMessage('Instantiation succeeded');
    } catch (e) {
      postMessage(`Exception: ${e}`);
    }
  };
}

(function TestImportMemory64AsMemory32InWorker() {
  print(arguments.callee.name);
  const builder1 = new WasmModuleBuilder();
  builder1.addMemory64(1, 1, /* shared */ true);
  builder1.exportMemoryAs('mem64');
  const instance1 = builder1.instantiate();
  const {mem64} = instance1.exports;

  let builder2 = new WasmModuleBuilder();
  builder2.addImportedMemory('imp', 'mem');
  let module2 = builder2.toModule();

  let worker = new Worker(InstantiatingWorkerCode, {type: 'function'});
  worker.postMessage([mem64, module2]);
  assertEquals(
      'Exception: LinkError: WebAssembly.Instance(): ' +
          'cannot import memory64 as memory32',
      worker.getMessage());
})();

(function TestImportMemory32AsMemory64InWorker() {
  print(arguments.callee.name);
  const builder1 = new WasmModuleBuilder();
  builder1.addMemory(1, 1, /* shared */ true);
  builder1.exportMemoryAs('mem32');
  const instance1 = builder1.instantiate();
  const {mem32} = instance1.exports;

  let builder2 = new WasmModuleBuilder();
  builder2.addImportedMemory(
      'imp', 'mem', 1, 1, /* shared */ false, /* memory64 */ true);
  let module2 = builder2.toModule();

  let worker = new Worker(InstantiatingWorkerCode, {type: 'function'});
  worker.postMessage([mem32, module2]);
  assertEquals(
      'Exception: LinkError: WebAssembly.Instance(): ' +
          'cannot import memory32 as memory64',
      worker.getMessage());
})();

(function TestMemory64EmbedLoadInFloatBinop() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addMemory64(1, 1, true);

  builder.addFunction('move_load_into_float_binop',
                      makeSig([kWasmF64], [kWasmF64]))
    .addBody([
      ...wasmF64Const(0),
      kExprLocalGet, 0,
      kExprF64Add,
      ...wasmI64Const(65536),
      kExprF64LoadMem, 0, 0,
      kExprF64Add,
    ])
    .exportFunc();

  builder.addFunction('dont_move_load_if_something_traps_in_between',
                      makeSig([], [kWasmF64]))
    .addBody([
      ...wasmI64Const(65536),
      kExprF64LoadMem, 0, 0,

      ...wasmI32Const(42),
      ...wasmI64Const(0),
      kExprI32LoadMem, 0, 0, // Loads zero as i32.
      kExprI32DivU, // Divide by zero trap.
      kExprF64UConvertI32,

      kExprF64Add,
    ])
    .exportFunc();

  // Instantiation works, this should throw at runtime.
  let instance = builder.instantiate();
  assertTraps(kTrapMemOutOfBounds, () =>
    instance.exports.move_load_into_float_binop(1.0));
  assertTraps(kTrapMemOutOfBounds, () =>
    instance.exports.dont_move_load_if_something_traps_in_between());
})();
                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/wasm/memory_1gb_oob.js                                             0000664 0000000 0000000 00000006146 14746647661 0022731 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-max-mem-pages=16384

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

const k1MiB = 1 * 1024 * 1024;
const k1GiB = 1 * 1024 * 1024 * 1024;
const k2GiB = 2 * k1GiB;
const k3GiB = 3 * k1GiB;
const k4GiB = 4 * k1GiB;
const kMaxMemory = k1GiB;

// Indexes (and offsets) used to systematically probe the memory.
const indexes = (() => {
  const a = k1GiB, b = k2GiB, c = k3GiB, d = k4GiB;
  return [
    0,   1,   2,   3,   4,   5,   7,   8,   9,            // near 0
  a-8, a-4, a+0, a+1, a+2, a+3, a+4, a+5, a+7, a+8, a+9,  // near 1GiB
  b-8, b-4, b+0, b+1, b+2, b+3, b+4, b+5, b+7, b+8, b+9,  // near 2GiB
  c-8, c-4, c+0, c+1, c+2, c+3, c+4, c+5, c+7, c+8, c+9,  // near 3GiB
  d-9, d-8, d-7, d-5, d-4, d-3, d-2, d-1                  // near 4GiB
];
})();

(function Test() {
  var memory;

  function BuildAccessors(type, load_opcode, store_opcode, offset) {
    builder = new WasmModuleBuilder();
    builder.addImportedMemory("i", "mem");
    builder.addFunction('load', makeSig([kWasmI32], [type]))
      .addBody([
        kExprLocalGet, 0,                            // --
        load_opcode, 0, ...wasmUnsignedLeb(offset),  // --
      ])                                             // --
      .exportFunc();
    builder.addFunction('store', makeSig([kWasmI32, type], []))
      .addBody([
        kExprLocalGet, 0,                             // --
        kExprLocalGet, 1,                             // --
        store_opcode, 0, ...wasmUnsignedLeb(offset),  // --
      ])                                              // --
      .exportFunc();
    let i = builder.instantiate({i: {mem: memory}});
    return {offset: offset, load: i.exports.load, store: i.exports.store};
  }

  function probe(a, size, offset, f) {
    print(`size=${size} offset=${offset}`);
    for (let i of indexes) {
      let oob = (i + size + offset) > kMaxMemory;
      if (oob) {
//        print(`  ${i} + ${offset} OOB`);
        assertThrows(() => a.store(i, f(i)));
        assertThrows(() => a.load(i));
      } else {
//        print(`  ${i} = ${f(i)}`);
        a.store(i, f(i));
        assertEquals(f(i), a.load(i));
      }
    }
  }

  try {
    const kPages = kMaxMemory / kPageSize;
    memory = new WebAssembly.Memory({initial: kPages, maximum: kPages});
  } catch (e) {
    print("OOM: sorry, best effort max memory size test.");
    return;
  }

  assertEquals(kMaxMemory, memory.buffer.byteLength);

  for (let offset of indexes) {
    let a = BuildAccessors(kWasmI32, kExprI32LoadMem, kExprI32StoreMem, offset);
    probe(a, 4, offset, i => (0xaabbccee ^ ((i >> 11) * 0x110005)) | 0);
  }

  for (let offset of indexes) {
    let a = BuildAccessors(kWasmI32, kExprI32LoadMem8U, kExprI32StoreMem8, offset);
    probe(a, 1, offset, i => (0xee ^ ((i >> 11) * 0x05)) & 0xFF);
  }

  for (let offset of indexes) {
    let a = BuildAccessors(kWasmF64, kExprF64LoadMem, kExprF64StoreMem, offset);
    probe(a, 8, offset, i => 0xaabbccee ^ ((i >> 11) * 0x110005));
  }
})();
                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/wasm/memory_2gb_oob.js                                             0000664 0000000 0000000 00000006144 14746647661 0022730 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-max-mem-pages=32768

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

const k1MiB = 1 * 1024 * 1024;
const k1GiB = 1 * 1024 * 1024 * 1024;
const k2GiB = 2 * k1GiB;
const k3GiB = 3 * k1GiB;
const k4GiB = 4 * k1GiB;
const kMaxMemory = k2GiB;

// Indexes (and offsets) used to systematically probe the memory.
const indexes = (() => {
  const a = k1GiB, b = k2GiB, c = k3GiB, d = k4GiB;
  return [
    0,   1,   2,   3,   4,   5,   7,   8,   9,            // near 0
  a-8, a-4, a+0, a+1, a+2, a+3, a+4, a+5, a+7, a+8, a+9,  // near 1GiB
  b-8, b-4, b+0, b+1, b+2, b+3, b+4, b+5, b+7, b+8, b+9,  // near 2GiB
  c-8, c-4, c+0, c+1, c+2, c+3, c+4, c+5, c+7, c+8, c+9,  // near 3GiB
  d-9, d-8, d-7, d-5, d-4, d-3, d-2, d-1                  // near 4GiB
];
})();

(function Test() {
  var memory;

  function BuildAccessors(type, load_opcode, store_opcode, offset) {
    builder = new WasmModuleBuilder();
    builder.addImportedMemory("i", "mem");
    builder.addFunction('load', makeSig([kWasmI32], [type]))
      .addBody([
        kExprLocalGet, 0,                            // --
        load_opcode, 0, ...wasmUnsignedLeb(offset),  // --
      ])                                             // --
      .exportFunc();
    builder.addFunction('store', makeSig([kWasmI32, type], []))
      .addBody([
        kExprLocalGet, 0,                             // --
        kExprLocalGet, 1,                             // --
        store_opcode, 0, ...wasmUnsignedLeb(offset),  // --
      ])                                              // --
      .exportFunc();
    let i = builder.instantiate({i: {mem: memory}});
    return {offset: offset, load: i.exports.load, store: i.exports.store};
  }

  function probe(a, size, offset, f) {
    print(`size=${size} offset=${offset}`);
    for (let i of indexes) {
      let oob = (i + size + offset) > kMaxMemory;
      if (oob) {
//        print(`  ${i} + ${offset} OOB`);
        assertThrows(() => a.store(i, f(i)));
        assertThrows(() => a.load(i));
      } else {
//        print(`  ${i} = ${f(i)}`);
        a.store(i, f(i));
        assertEquals(f(i), a.load(i));
      }
    }
  }

  try {
    let kPages = kMaxMemory / kPageSize;
    memory = new WebAssembly.Memory({initial: kPages, maximum: kPages});
  } catch (e) {
    print("OOM: sorry, best effort max memory size test.");
    return;
  }

  assertEquals(kMaxMemory, memory.buffer.byteLength);

  for (let offset of indexes) {
    let a = BuildAccessors(kWasmI32, kExprI32LoadMem, kExprI32StoreMem, offset);
    probe(a, 4, offset, i => (0xaabbccee ^ ((i >> 11) * 0x110005)) | 0);
  }

  for (let offset of indexes) {
    let a = BuildAccessors(kWasmI32, kExprI32LoadMem8U, kExprI32StoreMem8, offset);
    probe(a, 1, offset, i => (0xee ^ ((i >> 11) * 0x05)) & 0xFF);
  }

  for (let offset of indexes) {
    let a = BuildAccessors(kWasmF64, kExprF64LoadMem, kExprF64StoreMem, offset);
    probe(a, 8, offset, i => 0xaabbccee ^ ((i >> 11) * 0x110005));
  }
})();
                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/wasm/memory_4gb_oob.js                                             0000664 0000000 0000000 00000006076 14746647661 0022736 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

const k1MiB = 1 * 1024 * 1024;
const k1GiB = 1 * 1024 * 1024 * 1024;
const k2GiB = 2 * k1GiB;
const k3GiB = 3 * k1GiB;
const k4GiB = 4 * k1GiB;
const kMaxMemory = k4GiB;

// Indexes (and offsets) used to systematically probe the memory.
const indexes = (() => {
  const a = k1GiB, b = k2GiB, c = k3GiB, d = k4GiB;
  return [
    0,   1,   2,   3,   4,   5,   7,   8,   9,            // near 0
  a-8, a-4, a+0, a+1, a+2, a+3, a+4, a+5, a+7, a+8, a+9,  // near 1GiB
  b-8, b-4, b+0, b+1, b+2, b+3, b+4, b+5, b+7, b+8, b+9,  // near 2GiB
  c-8, c-4, c+0, c+1, c+2, c+3, c+4, c+5, c+7, c+8, c+9,  // near 3GiB
  d-9, d-8, d-7, d-5, d-4, d-3, d-2, d-1                  // near 4GiB
];
})();

(function Test() {
  var memory;

  function BuildAccessors(type, load_opcode, store_opcode, offset) {
    builder = new WasmModuleBuilder();
    builder.addImportedMemory("i", "mem");
    builder.addFunction('load', makeSig([kWasmI32], [type]))
      .addBody([
        kExprLocalGet, 0,                            // --
        load_opcode, 0, ...wasmUnsignedLeb(offset),  // --
      ])                                             // --
      .exportFunc();
    builder.addFunction('store', makeSig([kWasmI32, type], []))
      .addBody([
        kExprLocalGet, 0,                             // --
        kExprLocalGet, 1,                             // --
        store_opcode, 0, ...wasmUnsignedLeb(offset),  // --
      ])                                              // --
      .exportFunc();
    let i = builder.instantiate({i: {mem: memory}});
    return {offset: offset, load: i.exports.load, store: i.exports.store};
  }

  function probe(a, size, offset, f) {
    print(`size=${size} offset=${offset}`);
    for (let i of indexes) {
      let oob = (i + size + offset) > kMaxMemory;
      if (oob) {
//        print(`  ${i} + ${offset} OOB`);
        assertThrows(() => a.store(i, f(i)));
        assertThrows(() => a.load(i));
      } else {
//        print(`  ${i} = ${f(i)}`);
        a.store(i, f(i));
        assertEquals(f(i), a.load(i));
      }
    }
  }

  try {
    let kPages = kMaxMemory / kPageSize;
    memory = new WebAssembly.Memory({initial: kPages, maximum: kPages});
  } catch (e) {
    print("OOM: sorry, best effort max memory size test.");
    return;
  }

  assertEquals(kMaxMemory, memory.buffer.byteLength);

  for (let offset of indexes) {
    let a = BuildAccessors(kWasmI32, kExprI32LoadMem, kExprI32StoreMem, offset);
    probe(a, 4, offset, i => (0xaabbccee ^ ((i >> 11) * 0x110005)) | 0);
  }

  for (let offset of indexes) {
    let a = BuildAccessors(kWasmI32, kExprI32LoadMem8U, kExprI32StoreMem8, offset);
    probe(a, 1, offset, i => (0xee ^ ((i >> 11) * 0x05)) & 0xFF);
  }

  for (let offset of indexes) {
    let a = BuildAccessors(kWasmF64, kExprF64LoadMem, kExprF64StoreMem, offset);
    probe(a, 8, offset, i => 0xaabbccee ^ ((i >> 11) * 0x110005));
  }
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/wasm/module-memory.js                                              0000664 0000000 0000000 00000012211 14746647661 0022612 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --expose-gc --stress-compaction --allow-natives-syntax

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

var kMemSize = 65536;

function genModule(memory) {
  var builder = new WasmModuleBuilder();

  builder.addImportedMemory("", "memory", 1);
  builder.exportMemoryAs("memory");
  builder.addFunction("main", kSig_i_i)
    .addBody([
      // main body: while(i) { if(mem[i]) return -1; i -= 4; } return 0;
      // TODO(titzer): this manual bytecode has a copy of test-run-wasm.cc
      /**/ kExprLoop, kWasmVoid,           // --
      /*  */ kExprLocalGet, 0,             // --
      /*  */ kExprIf, kWasmVoid,           // --
      /*    */ kExprLocalGet, 0,           // --
      /*    */ kExprI32LoadMem, 0, 0,      // --
      /*    */ kExprIf, kWasmVoid,         // --
      /*      */ kExprI32Const, 127,       // --
      /*      */ kExprReturn,              // --
      /*      */ kExprEnd,                 // --
      /*    */ kExprLocalGet, 0,           // --
      /*    */ kExprI32Const, 4,           // --
      /*    */ kExprI32Sub,                // --
      /*    */ kExprLocalSet, 0,           // --
      /*    */ kExprBr, 1,                 // --
      /*    */ kExprEnd,                   // --
      /*  */ kExprEnd,                     // --
      /**/ kExprI32Const, 0                // --
    ])
    .exportFunc();
  var module = builder.instantiate({"": {memory:memory}});
  assertTrue(module.exports.memory instanceof WebAssembly.Memory);
  if (memory != null) assertEquals(memory.buffer, module.exports.memory.buffer);
  return module;
}

function testPokeMemory() {
  print("testPokeMemory");
  var module = genModule(new WebAssembly.Memory({initial: 1}));
  var buffer = module.exports.memory.buffer;
  var main = module.exports.main;
  assertEquals(kMemSize, buffer.byteLength);

  var array = new Int8Array(buffer);
  assertEquals(kMemSize, array.length);

  assertTrue(array.every((e => e === 0)));

  for (var i = 0; i < 10; i++) {
    assertEquals(0, main(kMemSize - 4));

    array[kMemSize/2 + i] = 1;
    assertEquals(0, main(kMemSize/2 - 4));
    assertEquals(-1, main(kMemSize - 4));

    array[kMemSize/2 + i] = 0;
    assertEquals(0, main(kMemSize - 4));
  }
}

testPokeMemory();

function genAndGetMain(buffer) {
  return genModule(buffer).exports.main;  // to prevent intermediates living
}

function testSurvivalAcrossGc() {
  var checker = genAndGetMain(new WebAssembly.Memory({initial: 1}));
  for (var i = 0; i < 3; i++) {
    print("gc run ", i);
    assertEquals(0, checker(kMemSize - 4));
    gc();
  }
}

testSurvivalAcrossGc();
testSurvivalAcrossGc();
testSurvivalAcrossGc();
testSurvivalAcrossGc();


function testPokeOuterMemory() {
  print("testPokeOuterMemory");
  var buffer = new WebAssembly.Memory({initial: kMemSize / kPageSize});
  var module = genModule(buffer);
  var main = module.exports.main;
  assertEquals(kMemSize, buffer.buffer.byteLength);

  var array = new Int8Array(buffer.buffer);
  assertEquals(kMemSize, array.length);

  assertTrue(array.every((e => e === 0)));

  for (var i = 0; i < 10; i++) {
    assertEquals(0, main(kMemSize - 4));

    array[kMemSize/2 + i] = 1;
    assertEquals(0, main(kMemSize/2 - 4));
    assertEquals(-1, main(kMemSize - 4));

    array[kMemSize/2 + i] = 0;
    assertEquals(0, main(kMemSize - 4));
  }
}

testPokeOuterMemory();

function testOuterMemorySurvivalAcrossGc() {
  var buffer = new WebAssembly.Memory({initial: kMemSize / kPageSize});
  var checker = genAndGetMain(buffer);
  for (var i = 0; i < 3; i++) {
    print("gc run ", i);
    assertEquals(0, checker(kMemSize - 4));
    gc();
  }
}

testOuterMemorySurvivalAcrossGc();
testOuterMemorySurvivalAcrossGc();
testOuterMemorySurvivalAcrossGc();
testOuterMemorySurvivalAcrossGc();


function testOOBThrows() {
  var builder = new WasmModuleBuilder();

  builder.addMemory(1, 1);
  builder.addFunction("geti", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI32LoadMem, 0, 0,
      kExprI32StoreMem, 0, 0,
      kExprLocalGet, 1,
      kExprI32LoadMem, 0, 0,
    ])
    .exportFunc();

  var module = builder.instantiate();

  let read = offset => module.exports.geti(0, offset);
  let write = offset =>  module.exports.geti(offset, 0);

  assertEquals(0, read(65532));
  assertEquals(0, write(65532));

  // Note that this test might be run concurrently in multiple Isolates, which
  // makes an exact comparison of the expected trap count unreliable. But is is
  // still possible to check the lower bound for the expected trap count.
  for (let offset = kMemSize - 3; offset <= kMemSize; offset++) {
    const trap_count = %GetWasmRecoveredTrapCount();
    assertTraps(kTrapMemOutOfBounds, () => read(offset));
    assertTraps(kTrapMemOutOfBounds, () => write(offset));
    if (%IsWasmTrapHandlerEnabled()) {
      if (%IsWasmPartialOOBWriteNoop()) {
        assertTrue(trap_count + 2 <= %GetWasmRecoveredTrapCount());
      } else {
        assertTrue(trap_count + 1 <= %GetWasmRecoveredTrapCount());
      }
    }
  }
}

testOOBThrows();
                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/wasm/module-prototype.js                                           0000664 0000000 0000000 00000001524 14746647661 0023354 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --no-js-source-phase-imports

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function makeBuilder() {
  var builder = new WasmModuleBuilder();

  builder.addFunction("f", kSig_v_v)
    .addBody([])
    .exportFunc();
  return builder;
}

assertEquals(
  Object.getPrototypeOf(WebAssembly.Module.prototype),
  Object.prototype);

var builder = makeBuilder();
var module = new WebAssembly.Module(builder.toBuffer());
var module_prototype = Object.getPrototypeOf(module);
assertEquals(module_prototype, WebAssembly.Module.prototype);
assertTrue(module instanceof WebAssembly.Module);
assertEquals(module[Symbol.toStringTag], "WebAssembly.Module");
                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/wasm/module-source.js                                              0000664 0000000 0000000 00000002216 14746647661 0022606 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --js-source-phase-imports --allow-natives-syntax

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function makeBuilder() {
  var builder = new WasmModuleBuilder();

  builder.addFunction("f", kSig_v_v)
    .addBody([])
    .exportFunc();
  return builder;
}

var AbstractModuleSource = %GetAbstractModuleSource();
assertEquals(
  Object.getPrototypeOf(WebAssembly.Module.prototype),
  AbstractModuleSource.prototype);
assertEquals(
  Object.getPrototypeOf(AbstractModuleSource.prototype),
  Object.prototype);

var ToStringTag = Object
  .getOwnPropertyDescriptor(
    AbstractModuleSource.prototype,
    Symbol.toStringTag,
  ).get;

var builder = makeBuilder();
var module = new WebAssembly.Module(builder.toBuffer());
assertEquals(Object.getPrototypeOf(module), WebAssembly.Module.prototype);
assertTrue(module instanceof WebAssembly.Module);
assertTrue(module instanceof AbstractModuleSource);
assertEquals(ToStringTag.call(module), "WebAssembly.Module");
                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/wasm/multi-memory.js                                               0000664 0000000 0000000 00000053235 14746647661 0022472 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-multi-memory

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

// Add a {loadN} and {storeN} function for memory N.
function addLoadAndStoreFunctions(builder, mem_index) {
  builder.addFunction(`load${mem_index}`, kSig_i_i)
      .addBody([kExprLocalGet, 0, kExprI32LoadMem, 0x40, mem_index, 0])
      .exportFunc();
  builder.addFunction(`store${mem_index}`, kSig_v_ii)
      .addBody([
        kExprLocalGet, 1, kExprLocalGet, 0, kExprI32StoreMem, 0x40, mem_index, 0
      ])
      .exportFunc();
}

// Add a {growN} and {sizeN} function for memory N.
function addGrowAndSizeFunctions(builder, mem_index) {
  builder.addFunction(`grow${mem_index}`, kSig_i_i)
      .addBody([kExprLocalGet, 0, kExprMemoryGrow, mem_index])
      .exportFunc();
  builder.addFunction(`size${mem_index}`, kSig_i_v)
      .addBody([kExprMemorySize, mem_index])
      .exportFunc();
}

// Add a {initN_M} function for memory N and data segment M.
function addMemoryInitFunction(builder, data_segment, mem_index) {
  builder.addFunction(`init${mem_index}_${data_segment}`, kSig_v_iii)
      .addBody([
        kExprLocalGet, 0,  // dst
        kExprLocalGet, 1,  // offset
        kExprLocalGet, 2,  // size
        kNumericPrefix, kExprMemoryInit, data_segment, mem_index
      ])
      .exportFunc();
}

// Add a {fillN} function for memory N.
function addMemoryFillFunction(builder, mem_index) {
  builder.addFunction(`fill${mem_index}`, kSig_v_iii)
      .addBody([
        kExprLocalGet, 0,  // dst
        kExprLocalGet, 1,  // value
        kExprLocalGet, 2,  // size
        kNumericPrefix, kExprMemoryFill, mem_index
      ])
      .exportFunc();
}

// Add a {copyN_M} function for copying from memory M to memory N.
function addMemoryCopyFunction(builder, mem_dst_index, mem_src_index) {
  builder.addFunction(`copy${mem_dst_index}_${mem_src_index}`, kSig_v_iii)
      .addBody([
        kExprLocalGet, 0,  // dst
        kExprLocalGet, 1,  // src
        kExprLocalGet, 2,  // size
        kNumericPrefix, kExprMemoryCopy, mem_dst_index, mem_src_index
      ])
      .exportFunc();
}

// Helper to test that two memories can be accessed independently.
function testTwoMemories(instance, mem0_size, mem1_size) {
  const {load0, load1, store0, store1} = instance.exports;

  assertEquals(0, load0(0));
  assertEquals(0, load1(0));

  store0(47, 0);
  assertEquals(47, load0(0));
  assertEquals(0, load1(0));

  store1(11, 0);
  assertEquals(47, load0(0));
  assertEquals(11, load1(0));

  store1(22, 1);
  assertEquals(47, load0(0));
  assertEquals(22, load1(1));
  // The 22 is in the second byte when loading from 0.
  assertEquals(22 * 256 + 11, load1(0));

  const mem0_bytes = mem0_size * kPageSize;
  load0(mem0_bytes - 4);  // should not trap.
  for (const offset of [-3, -1, mem0_bytes - 3, mem0_bytes - 1, mem0_bytes]) {
    assertTraps(kTrapMemOutOfBounds, () => load0(offset));
    assertTraps(kTrapMemOutOfBounds, () => store0(0, offset));
  }

  const mem1_bytes = mem1_size * kPageSize;
  load1(mem1_bytes - 4);  // should not trap.
  for (const offset of [-3, -1, mem1_bytes - 3, mem1_bytes - 1, mem1_bytes]) {
    assertTraps(kTrapMemOutOfBounds, () => load1(offset));
    assertTraps(kTrapMemOutOfBounds, () => store1(0, offset));
  }
}

function assertMemoryEquals(expected, memory) {
  assertInstanceof(memory, WebAssembly.Memory);
  assertInstanceof(expected, Uint8Array);
  const buf = new Uint8Array(memory.buffer);
  // For better output, check the first 50 bytes separately first.
  assertEquals(expected.slice(0, 50), buf.slice(0, 50));
  // Now also check the full memory content.
  assertEquals(expected, buf);
}

(function testBasicMultiMemory() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const mem0_idx = builder.addMemory(1, 1);
  const mem1_idx = builder.addMemory(1, 1);
  addLoadAndStoreFunctions(builder, mem0_idx);
  addLoadAndStoreFunctions(builder, mem1_idx);

  const instance = builder.instantiate();
  testTwoMemories(instance, 1, 1);
})();

(function testMemoryIndexDecodedAsU32() {
  print(arguments.callee.name);
  for (let leb_length = 1; leb_length <= 6; ++leb_length) {
    // Create the array [0x80, 0x80, ..., 0x0] of length `leb_length`. This
    // encodes `0` using `leb_length` bytes.
    const leb = new Array(leb_length).fill(0x80).with(leb_length - 1, 0);
    const builder = new WasmModuleBuilder();
    builder.addMemory(1, 1);
    builder.addFunction('load', kSig_i_i)
        .addBody([kExprLocalGet, 0, kExprI32LoadMem, 0x40, ...leb, 0])
        .exportFunc();
    builder.addFunction('store', kSig_v_ii)
        .addBody([
          kExprLocalGet, 0, kExprLocalGet, 1, kExprI32StoreMem, 0x40, ...leb, 0
        ])
        .exportFunc();
    builder.exportMemoryAs('mem');

    if (leb_length == 6) {
      assertThrows(
          () => builder.instantiate(), WebAssembly.CompileError,
          /length overflow while decoding memory index/);
      continue;
    }
    const instance = builder.instantiate();
    assertEquals(0, instance.exports.load(7));
    instance.exports.store(7, 11);
    assertEquals(11, instance.exports.load(7));
    assertEquals(0, instance.exports.load(11));

    const expected_memory = new Uint8Array(kPageSize);
    expected_memory[7] = 11;
    assertMemoryEquals(expected_memory, instance.exports.mem);
  }
})();

(function testImportedAndDeclaredMemories() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.addImportedMemory('imp', 'mem0');
  builder.addMemory(1, 1);
  addLoadAndStoreFunctions(builder, 0);
  addLoadAndStoreFunctions(builder, 1);

  const mem0 = new WebAssembly.Memory({initial: 3, maximum: 4});
  const instance = builder.instantiate({imp: {mem0: mem0}});
  testTwoMemories(instance, 3, 1);
})();

(function testTwoImportedMemories() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.addImportedMemory('imp', 'mem0');
  builder.addImportedMemory('imp', 'mem1');
  addLoadAndStoreFunctions(builder, 0);
  addLoadAndStoreFunctions(builder, 1);

  const mem0 = new WebAssembly.Memory({initial: 2, maximum: 3});
  const mem1 = new WebAssembly.Memory({initial: 3, maximum: 4});
  const instance = builder.instantiate({imp: {mem0: mem0, mem1: mem1}});
  testTwoMemories(instance, 2, 3);
})();

(function testTwoExportedMemories() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const mem0_idx = builder.addMemory(1, 1);
  const mem1_idx = builder.addMemory(1, 1);
  addLoadAndStoreFunctions(builder, mem0_idx);
  addLoadAndStoreFunctions(builder, mem1_idx);
  builder.exportMemoryAs('mem0', mem0_idx);
  builder.exportMemoryAs('mem1', mem1_idx);

  const instance = builder.instantiate();
  const mem0 = new Uint8Array(instance.exports.mem0.buffer);
  const mem1 = new Uint8Array(instance.exports.mem1.buffer);
  assertEquals(0, mem0[11]);
  assertEquals(0, mem1[11]);

  instance.exports.store0(47, 11);
  assertEquals(47, mem0[11]);
  assertEquals(0, mem1[11]);

  instance.exports.store1(49, 11);
  assertEquals(47, mem0[11]);
  assertEquals(49, mem1[11]);
})();

(function testMultiMemoryDataSegments() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  const mem0_idx = builder.addMemory(1, 1);
  const mem1_idx = builder.addMemory(1, 1);
  addLoadAndStoreFunctions(builder, mem0_idx);
  addLoadAndStoreFunctions(builder, mem1_idx);
  const mem0_offset = 11;
  const mem1_offset = 23;
  builder.addActiveDataSegment(1, [kExprI32Const, mem1_offset], [7, 7]);
  builder.addActiveDataSegment(0, [kExprI32Const, mem0_offset], [9, 9]);
  builder.exportMemoryAs('mem0', 0);
  builder.exportMemoryAs('mem1', 1);

  const instance = builder.instantiate();
  const expected_memory0 = new Uint8Array(kPageSize);
  expected_memory0.set([9, 9], mem0_offset);
  const expected_memory1 = new Uint8Array(kPageSize);
  expected_memory1.set([7, 7], mem1_offset);

  assertMemoryEquals(expected_memory0, instance.exports.mem0);
  assertMemoryEquals(expected_memory1, instance.exports.mem1);
})();

(function testMultiMemoryDataSegmentsOutOfBounds() {
  print(arguments.callee.name);
  // Check that we use the right memory size for the bounds check.
  for (let [mem0_size, mem1_size] of [[1, 2], [2, 1]]) {
    for (let [mem0_offset, mem1_offset] of [[0, 0], [1, 2], [0, 2], [1, 0]]) {
      var builder = new WasmModuleBuilder();
      const mem0_idx = builder.addMemory(mem0_size, mem0_size);
      const mem1_idx = builder.addMemory(mem1_size, mem1_size);
      builder.addActiveDataSegment(
          mem0_idx, wasmI32Const(mem0_offset * kPageSize), [0]);
      builder.addActiveDataSegment(
          mem1_idx, wasmI32Const(mem1_offset * kPageSize), [0]);

      if (mem0_offset < mem0_size && mem1_offset < mem1_size) {
        builder.instantiate();  // should not throw.
        continue;
      }
      const oob = mem0_offset >= mem0_size ? 0 : 1;
      const expected_offset = [mem0_offset, mem1_offset][oob] * kPageSize;
      const expected_mem_size = [mem0_size, mem1_size][oob] * kPageSize;
      const expected_msg =
          `WebAssembly.Instance(): data segment ${oob} is out of bounds ` +
          `(offset ${expected_offset}, length 1, ` +
          `memory size ${expected_mem_size})`;
      assertThrows(
          () => builder.instantiate(), WebAssembly.RuntimeError, expected_msg);
    }
  }
})();

(function testMultiMemoryInit() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  const mem0_idx = builder.addMemory(1, 1);
  const mem1_idx = builder.addMemory(1, 1);
  const mem0_offset = 11;
  const mem1_offset = 23;
  const seg0_init = [5, 4, 3];
  const seg0_id = builder.addPassiveDataSegment(seg0_init);
  const seg1_init = [11, 10, 9, 8, 7];
  const seg1_id = builder.addPassiveDataSegment(seg1_init);
  builder.exportMemoryAs('mem0', mem0_idx);
  builder.exportMemoryAs('mem1', mem1_idx);
  // Initialize memory 1 from data segment 0 and vice versa.
  addMemoryInitFunction(builder, mem0_idx, seg1_id);
  addMemoryInitFunction(builder, mem1_idx, seg0_id);

  const instance = builder.instantiate();
  const expected_memory0 = new Uint8Array(kPageSize);
  const expected_memory1 = new Uint8Array(kPageSize);

  assertMemoryEquals(expected_memory0, instance.exports.mem0);
  assertMemoryEquals(expected_memory1, instance.exports.mem1);

  instance.exports.init0_1(3, 1, 3);
  expected_memory0.set(seg1_init.slice(1, 4), 3);
  assertMemoryEquals(expected_memory0, instance.exports.mem0);
  assertMemoryEquals(expected_memory1, instance.exports.mem1);

  instance.exports.init1_0(17, 0, 2);
  expected_memory1.set(seg0_init.slice(0, 2), 17);
  assertMemoryEquals(expected_memory0, instance.exports.mem0);
  assertMemoryEquals(expected_memory1, instance.exports.mem1);

  assertTraps(kTrapMemOutOfBounds, () => instance.exports.init0_1(0, 5, 1));
  assertTraps(kTrapMemOutOfBounds, () => instance.exports.init1_0(0, 3, 1));
})();

(function testMultiMemoryFill() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  const mem0_idx = builder.addMemory(1, 1);
  const mem1_idx = builder.addMemory(2, 2);
  builder.exportMemoryAs('mem0', mem0_idx);
  builder.exportMemoryAs('mem1', mem1_idx);
  addMemoryFillFunction(builder, mem0_idx);
  addMemoryFillFunction(builder, mem1_idx);

  const instance = builder.instantiate();
  const expected_memory0 = new Uint8Array(kPageSize);
  const expected_memory1 = new Uint8Array(2 * kPageSize);

  assertMemoryEquals(expected_memory0, instance.exports.mem0);
  assertMemoryEquals(expected_memory1, instance.exports.mem1);

  // Fill [3..4] in mem0 with value 7.
  instance.exports.fill0(3, 7, 2);  // dst, value, size
  expected_memory0.fill(7, 3, 5);   // value, start, end
  assertMemoryEquals(expected_memory0, instance.exports.mem0);
  assertMemoryEquals(expected_memory1, instance.exports.mem1);

  // Fill [4..11] in mem0 with value 17.
  instance.exports.fill1(4, 17, 8);  // dst, value, size
  expected_memory1.fill(17, 4, 12);  // value, start, end
  assertMemoryEquals(expected_memory0, instance.exports.mem0);
  assertMemoryEquals(expected_memory1, instance.exports.mem1);

  // mem0 has size 1.
  instance.exports.fill0(kPageSize - 1, 1, 1);
  assertTraps(
      kTrapMemOutOfBounds, () => instance.exports.fill0(kPageSize - 1, 1, 2));
  assertTraps(
      kTrapMemOutOfBounds, () => instance.exports.fill0(kPageSize, 1, 1));

  // mem1 has size 2.
  instance.exports.fill1(2 * kPageSize - 1, 1, 1);
  assertTraps(
      kTrapMemOutOfBounds,
      () => instance.exports.fill1(2 * kPageSize - 1, 1, 2));
  assertTraps(
      kTrapMemOutOfBounds, () => instance.exports.fill1(2 * kPageSize, 1, 1));
})();

(function testMultiMemoryCopy() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  const mem0_id = 0;
  builder.addMemory(1, 1);
  const mem1_id = 1;
  builder.addMemory(2, 2);
  builder.exportMemoryAs('mem0', mem0_id);
  builder.exportMemoryAs('mem1', mem1_id);
  addMemoryCopyFunction(builder, mem0_id, mem0_id);
  addMemoryCopyFunction(builder, mem0_id, mem1_id);
  addMemoryCopyFunction(builder, mem1_id, mem0_id);
  addMemoryCopyFunction(builder, mem1_id, mem1_id);

  const instance = builder.instantiate();
  const expected_memory0 = new Uint8Array(kPageSize);
  const expected_memory1 = new Uint8Array(2 * kPageSize);

  // Set some initial bytes that we can then copy around.
  new Uint8Array(instance.exports.mem0.buffer).set([1, 2, 3, 4, 5]);
  expected_memory0.set([1, 2, 3, 4, 5], 0);
  assertMemoryEquals(expected_memory0, instance.exports.mem0);

  // Copy [3..5] to [7..9] in mem0.
  instance.exports.copy0_0(7, 3, 3);  // dst, src, size
  expected_memory0.set([1, 2, 3, 4, 5, 0, 0, 4, 5, 0]);
  assertMemoryEquals(expected_memory0, instance.exports.mem0);

  // Copy [3..7] from mem0 to [2..6] in mem1.
  instance.exports.copy1_0(2, 3, 5);  // dst, src, size
  expected_memory1.set([0, 0, 4, 5, 0, 0, 4]);
  assertMemoryEquals(expected_memory0, instance.exports.mem0);
  assertMemoryEquals(expected_memory1, instance.exports.mem1);

  // Copy [3..4] from mem1 to [1..3] in mem0.
  instance.exports.copy0_1(1, 3, 2);  // dst, src, size
  expected_memory0.set([5, 0], 1);
  assertMemoryEquals(expected_memory0, instance.exports.mem0);
  assertMemoryEquals(expected_memory1, instance.exports.mem1);

  // Copy [2..4] to [0..2] in mem1.
  instance.exports.copy1_1(0, 2, 3);  // dst, src, size
  expected_memory1.set([4, 5, 0]);
  assertMemoryEquals(expected_memory0, instance.exports.mem0);
  assertMemoryEquals(expected_memory1, instance.exports.mem1);

  const mem0_size = kPageSize;
  const mem1_size = 2 * kPageSize;
  for ([method, dst_size, src_size] of [
           [instance.exports.copy0_0, mem0_size, mem0_size],
           [instance.exports.copy0_1, mem0_size, mem1_size],
           [instance.exports.copy1_0, mem1_size, mem0_size],
           [instance.exports.copy1_1, mem1_size, mem1_size]]) {
    print(`- ${method}`);
    // Test at the boundary.
    method(dst_size - 1, src_size - 1, 1);
    // Then test one byte further.
    assertTraps(kTrapMemOutOfBounds, () => method(dst_size, src_size - 1, 1));
    assertTraps(kTrapMemOutOfBounds, () => method(dst_size - 1, src_size, 1));
    assertTraps(
        kTrapMemOutOfBounds, () => method(dst_size - 1, src_size - 2, 2));
    assertTraps(
        kTrapMemOutOfBounds, () => method(dst_size - 2, src_size - 1, 2));
  }
})();

(function testGrowMultipleMemories() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  const mem0_idx = builder.addMemory(1, 4);
  const mem1_idx = builder.addMemory(1, 5);
  addGrowAndSizeFunctions(builder, mem0_idx);
  addGrowAndSizeFunctions(builder, mem1_idx);
  builder.exportMemoryAs('mem0', mem0_idx);
  builder.exportMemoryAs('mem1', mem1_idx);
  const instance = builder.instantiate();

  assertEquals(1, instance.exports.grow0(2));
  assertEquals(3, instance.exports.grow0(1));
  assertEquals(4, instance.exports.size0());
  assertEquals(-1, instance.exports.grow0(1));
  assertEquals(4, instance.exports.size0());

  assertEquals(1, instance.exports.grow1(2));
  assertEquals(3, instance.exports.grow1(2));
  assertEquals(5, instance.exports.size1());
  assertEquals(-1, instance.exports.grow1(1));
  assertEquals(5, instance.exports.size1());
})();

(function testGrowDecodesMemoryIndexAsU32() {
  print(arguments.callee.name);
  for (let leb_length = 1; leb_length <= 6; ++leb_length) {
    // Create the array [0x80, 0x80, ..., 0x0] of length `leb_length`. This
    // encodes `0` using `leb_length` bytes.
    const leb = new Array(leb_length).fill(0x80).with(leb_length - 1, 0);
    var builder = new WasmModuleBuilder();
    builder.addMemory(1, 4);
    builder.addFunction('grow', kSig_i_i)
        .addBody([kExprLocalGet, 0, kExprMemoryGrow, ...leb])
        .exportFunc();
    builder.exportMemoryAs('mem', 0);

    if (leb_length == 6) {
      assertThrows(
          () => builder.instantiate(), WebAssembly.CompileError,
          /length overflow while decoding memory index/);
      continue;
    }
    const instance = builder.instantiate();

    assertEquals(1, instance.exports.grow(2));
    assertEquals(-1, instance.exports.grow(2));
    assertEquals(3, instance.exports.grow(1));
  }
})();

(function testMultipleMemoriesInOneFunction() {
  print(arguments.callee.name);
  // Some "interesting" access patterns.
  const mem_indexes_list =
      [[0, 1, 0, 1], [1, 0, 1, 0], [0, 0, 1, 1], [1, 1, 0, 0]];
  const builder = new WasmModuleBuilder();
  const mem0_idx = builder.addMemory(1, 1);
  const mem1_idx = builder.addMemory(1, 1);
  for (let [idx, mem_indexes] of mem_indexes_list.entries()) {
    let sig = makeSig(new Array(4).fill(kWasmI32), [kWasmI32]);
    builder.addFunction(`load${idx}`, sig)
        .addBody([
          kExprLocalGet, 0, kExprI32LoadMem, 0x40, mem_indexes[0], 0,  // load 1
          kExprLocalGet, 1, kExprI32LoadMem, 0x40, mem_indexes[1], 0,  // load 2
          kExprI32Add,                                                 // add
          kExprLocalGet, 2, kExprI32LoadMem, 0x40, mem_indexes[2], 0,  // load 3
          kExprI32Add,                                                 // add
          kExprLocalGet, 3, kExprI32LoadMem, 0x40, mem_indexes[3], 0,  // load 4
          kExprI32Add,                                                 // add
        ])
        .exportFunc();
  }
  builder.exportMemoryAs('mem0', mem0_idx);
  builder.exportMemoryAs('mem1', mem1_idx);

  const instance = builder.instantiate();

  // Create random memory contents.
  let buf0 = new DataView(instance.exports.mem0.buffer);
  let buf1 = new DataView(instance.exports.mem1.buffer);
  for (let i = 0; i < kPageSize; ++i) {
    buf0.setUint8(i, Math.floor(Math.random() * 0xff));
    buf1.setUint8(i, Math.floor(Math.random() * 0xff));
  }

  for (let run = 0; run < 10; ++run) {
    // Return a random index in [0, kPageSize - 3) such that we can read four
    // bytes from there.
    let get_random_offset = () => Math.floor(Math.random() * (kPageSize - 3));
    let inputs = new Array(4).fill(0).map(get_random_offset);
    for (let [func_idx, mem_indexes] of mem_indexes_list.entries()) {
      let expected = 0;
      for (let i = 0; i < 4; ++i) {
        let buf = mem_indexes[i] == 0 ? buf0 : buf1;
        expected += buf.getInt32(inputs[i], true);
      }
      expected >>= 0;  // Truncate to 32 bit.
      assertEquals(expected, instance.exports[`load${func_idx}`](...inputs));
    }
  }
})();

(function testAtomicsOnMultiMemory() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const mem0_idx = builder.addMemory(1, 1, true);
  const mem1_idx = builder.addMemory(2, 2, true);
  builder.exportMemoryAs('mem0', mem0_idx);
  builder.exportMemoryAs('mem1', mem1_idx);

  for (let mem_idx of [mem0_idx, mem1_idx]) {
    builder.addFunction(`load${mem_idx}`, kSig_i_i)
        .addBody([
          kExprLocalGet, 0,                                    // -
          kAtomicPrefix, kExprI32AtomicLoad, 0x42, mem_idx, 0  // -
        ])
        .exportFunc();
    builder.addFunction(`store${mem_idx}`, kSig_v_ii)
        .addBody([
          kExprLocalGet, 0,                                     // -
          kExprLocalGet, 1,                                     // -
          kAtomicPrefix, kExprI32AtomicStore, 0x42, mem_idx, 0  // -
        ])
        .exportFunc();
    builder.addFunction(`cmpxchg${mem_idx}`, kSig_i_iii)
        .addBody([
          kExprLocalGet, 0,                                               // -
          kExprLocalGet, 1,                                               // -
          kExprLocalGet, 2,                                               // -
          kAtomicPrefix, kExprI32AtomicCompareExchange, 0x42, mem_idx, 0  // -
        ])
        .exportFunc();
  }

  const instance = builder.instantiate();

  const {mem0, load0, store0, cmpxchg0, mem1, load1, store1, cmpxchg1} =
      instance.exports;

  const data0 = new DataView(mem0.buffer);
  const data1 = new DataView(mem1.buffer);

  const offset0 = 16;
  const value0 = 13;
  store0(offset0, value0);
  assertEquals(value0, load0(offset0));
  assertEquals(0, load1(offset0));

  const offset1 = 24;
  const value1 = 11;
  store1(offset1, value1);
  assertEquals(value1, load1(offset1));
  assertEquals(0, load0(offset1));

  assertEquals(value0, cmpxchg0(offset0, -1, -1));
  assertEquals(value0, cmpxchg0(offset0, value0, value1));
  assertEquals(value1, load0(offset0));

  assertEquals(value1, cmpxchg1(offset1, -1, -1));
  assertEquals(value1, cmpxchg1(offset1, value1, value0));
  assertEquals(value0, load1(offset1));

  assertEquals(0, load0(offset1));
  assertEquals(0, load1(offset0));

  // Test traps.
  assertEquals(0, load0(kPageSize - 4));
  assertEquals(0, load1(2 * kPageSize - 4));
  assertTraps(kTrapMemOutOfBounds, () => load0(kPageSize));
  assertTraps(kTrapMemOutOfBounds, () => load1(2 * kPageSize));
})();
                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/wasm/multi-memory64-memorysize.js                                  0000664 0000000 0000000 00000003126 14746647661 0025037 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-multi-memory --experimental-wasm-memory64

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function testMemorySizeMultimemory64Index0() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();

  const mem64 = builder.addMemory64(1, 1);
  const mem32 = builder.addMemory(4, 4);

  builder.addFunction('memorySize32Plus1', kSig_i_v)
    .addBody([kExprMemorySize, mem32, kExprI32Const, 1, kExprI32Add])
    .exportFunc();
  builder.addFunction('memorySize64Plus1', kSig_l_v)
    .addBody([kExprMemorySize, mem64, kExprI64Const, 1, kExprI64Add])
    .exportFunc();

  let {memorySize32Plus1, memorySize64Plus1} = builder.instantiate().exports;
  assertEquals(2n, memorySize64Plus1());
  assertEquals(5, memorySize32Plus1());
})();

(function testMemorySizeMultimemory64Index1() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();

  const mem32 = builder.addMemory(4, 4);
  const mem64 = builder.addMemory64(1, 1);

  builder.addFunction('memorySize32Plus1', kSig_i_v)
    .addBody([kExprMemorySize, mem32, kExprI32Const, 1, kExprI32Add])
    .exportFunc();
  builder.addFunction('memorySize64Plus1', kSig_l_v)
    .addBody([kExprMemorySize, mem64, kExprI64Const, 1, kExprI64Add])
    .exportFunc();

  let {memorySize32Plus1, memorySize64Plus1} = builder.instantiate().exports;
  assertEquals(2n, memorySize64Plus1());
  assertEquals(5, memorySize32Plus1());
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/wasm/multi-memory64-wrong-offset.js                                0000664 0000000 0000000 00000002171 14746647661 0025253 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-multi-memory --experimental-wasm-memory64

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function testLoadOOBOffset() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();

  builder.addMemory64(1, 1);
  let mem32_idx = builder.addMemory(1, 1);

  builder.addFunction('load32', kSig_i_i)
      .addBody([
        kExprLocalGet, 0,
        kExprI32LoadMem, 0x40, mem32_idx, ...wasmSignedLeb64(0x1n << 33n)
      ]).exportFunc();

  assertThrows(() => builder.instantiate(), WebAssembly.CompileError);
})();

(function testLoadInBoundsOffset() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();

  builder.addMemory(1, 1);
  let mem64_idx = builder.addMemory64(1, 1);

  builder.addFunction('load64', kSig_l_l)
      .addBody([
        kExprLocalGet, 0,
        kExprI64LoadMem, 0x40, mem64_idx, ...wasmSignedLeb64(0x1n << 33n)
      ]).exportFunc();

  builder.instantiate();
})();
                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/wasm/multi-memory64.js                                             0000664 0000000 0000000 00000023347 14746647661 0022645 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-multi-memory --experimental-wasm-memory64

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

function assertMemoryEquals(expected, memory) {
  assertInstanceof(memory, WebAssembly.Memory);
  assertInstanceof(expected, Uint8Array);
  const buf = new Uint8Array(memory.buffer);
  // For better output, check the first 50 bytes separately first.
  assertEquals(expected.slice(0, 50), buf.slice(0, 50));
  // Now also check the full memory content.
  assertEquals(expected, buf);
}

(function testBasicMultiMemory() {
  print(arguments.callee.name);
  // Test two memories: One 32-bit and one 64-bit, in both orders.
  for (let mem64_idx of [0, 1]) {
    const builder = new WasmModuleBuilder();
    const mem32_idx = 1 - mem64_idx;

    const mem32_pages = 1;
    const mem32_size = mem32_pages * kPageSize;
    const mem64_pages = 3;
    const mem64_size = mem64_pages * kPageSize;
    if (mem32_idx == 0) {
      builder.addMemory(mem32_pages, mem32_pages);
      builder.addMemory64(mem64_pages, mem64_pages);
    } else {
      builder.addMemory64(mem64_pages, mem64_pages);
      builder.addMemory(mem32_pages, mem32_pages);
    }
    builder.exportMemoryAs('mem32', mem32_idx);
    builder.exportMemoryAs('mem64', mem64_idx);

    builder.addFunction('load32', kSig_i_i)
        .addBody([kExprLocalGet, 0, kExprI32LoadMem, 0x40, mem32_idx, 0])
        .exportFunc();
    builder.addFunction('load64', kSig_i_l)
        .addBody([kExprLocalGet, 0, kExprI32LoadMem, 0x40, mem64_idx, 0])
        .exportFunc();

    const instance = builder.instantiate();
    const mem32_offset = 48;
    const mem64_offset = 16;
    const value = 13;
    const view32 = new DataView(instance.exports.mem32.buffer);
    const view64 = new DataView(instance.exports.mem64.buffer);
    view32.setInt32(mem32_offset, value, true);
    view64.setInt32(mem64_offset, value, true);

    const {load32, load64} = instance.exports;

    assertEquals(value, load32(mem32_offset));
    assertEquals(0, load32(mem64_offset));
    assertEquals(0, load64(BigInt(mem32_offset)));
    assertEquals(value, load64(BigInt(mem64_offset)));

    assertEquals(0, load32(mem32_size - 4));
    assertEquals(0, load64(BigInt(mem64_size - 4)));
    assertTraps(kTrapMemOutOfBounds, () => load32(mem32_size - 3));
    assertTraps(kTrapMemOutOfBounds, () => load64(BigInt(mem64_size - 3)));
  }
})();

(function testMultiMemoryInit() {
  print(arguments.callee.name);
  // Test two memories: One 32-bit and one 64-bit, in both orders.
  for (let mem64_idx of [0, 1]) {
    const builder = new WasmModuleBuilder();
    const mem32_idx = 1 - mem64_idx;

    const mem32_pages = 1;
    const mem32_size = mem32_pages * kPageSize;
    const mem64_pages = 3;
    const mem64_size = mem64_pages * kPageSize;
    if (mem32_idx == 0) {
      builder.addMemory(mem32_pages, mem32_pages);
      builder.addMemory64(mem64_pages, mem64_pages);
    } else {
      builder.addMemory64(mem64_pages, mem64_pages);
      builder.addMemory(mem32_pages, mem32_pages);
    }
    builder.exportMemoryAs('mem32', mem32_idx);
    builder.exportMemoryAs('mem64', mem64_idx);

    const data = [1, 2, 3, 4, 5];
    const seg_id = builder.addPassiveDataSegment(data);

    builder.addFunction('init32', kSig_v_iii)
        .addBody([
          kExprLocalGet, 0,  // dst
          kExprLocalGet, 1,  // offset
          kExprLocalGet, 2,  // size
          kNumericPrefix, kExprMemoryInit, seg_id, mem32_idx
        ])
        .exportFunc();
    builder.addFunction('init64', kSig_v_lii)
        .addBody([
          kExprLocalGet, 0,  // dst
          kExprLocalGet, 1,  // offset
          kExprLocalGet, 2,  // size
          kNumericPrefix, kExprMemoryInit, seg_id, mem64_idx
        ])
        .exportFunc();

    const instance = builder.instantiate();
    const {init32, init64} = instance.exports;
    const expected_mem32 = new Uint8Array(mem32_size);
    const expected_mem64 = new Uint8Array(mem64_size);

    assertMemoryEquals(expected_mem32, instance.exports.mem32);
    assertMemoryEquals(expected_mem64, instance.exports.mem64);

    init32(7, 1, 3);  // dst, (data) offset, size
    expected_mem32.set(data.slice(1, 4), 7);
    assertMemoryEquals(expected_mem32, instance.exports.mem32);
    assertMemoryEquals(expected_mem64, instance.exports.mem64);

    init64(11n, 3, 2);  // dst, (data) offset, size
    expected_mem64.set(data.slice(3, 5), 11);
    assertMemoryEquals(expected_mem32, instance.exports.mem32);
    assertMemoryEquals(expected_mem64, instance.exports.mem64);

    // Test bounds checks.
    init32(mem32_size - 1, 0, 1);  // dst, (data) offset, size
    assertTraps(kTrapMemOutOfBounds, () => init32(mem32_size - 1, 0, 2));
    init64(BigInt(mem64_size - 1), 0, 1);  // dst, (data) offset, size
    assertTraps(
        kTrapMemOutOfBounds, () => init64(BigInt(mem64_size - 1), 0, 2));
  }
})();

(function testTypingForCopyBetween32And64Bit() {
  print(arguments.callee.name);
  for (let [src, dst, src_type, dst_type, size_type, expect_valid] of [
    // Copy from 32 to 64 bit with correct types.
    [32, 64, kWasmI32, kWasmI64, kWasmI32, true],
    // Copy from 64 to 32 bit with correct types.
    [64, 32, kWasmI64, kWasmI32, kWasmI32, true],
    // Copy from 32 to 64 bit with always one type wrong.
    [32, 64, kWasmI64, kWasmI64, kWasmI32, false],
    [32, 64, kWasmI32, kWasmI32, kWasmI32, false],
    [32, 64, kWasmI32, kWasmI64, kWasmI64, false],
    // Copy from 64 to 32 bit with always one type wrong.
    [64, 32, kWasmI32, kWasmI32, kWasmI32, false],
    [64, 32, kWasmI64, kWasmI64, kWasmI32, false],
    [64, 32, kWasmI64, kWasmI32, kWasmI64, false],
  ]) {
    let type_str = type => type == kWasmI32 ? 'i32' : 'i64';
    print(`- copy from ${src} to ${dst} using types src=${
        type_str(src_type)}, dst=${type_str(dst_type)}, size=${
        type_str(size_type)}`);
    let builder = new WasmModuleBuilder();
    const kMemSizeInPages = 10;
    const kMemSize = kMemSizeInPages * kPageSize;
    let mem64_index = builder.addMemory64(kMemSizeInPages, kMemSizeInPages);
    let mem32_index = builder.addMemory(kMemSizeInPages, kMemSizeInPages);
    builder.exportMemoryAs('mem64', mem64_index);
    builder.exportMemoryAs('mem32', mem32_index);

    let src_index = src == 32 ? mem32_index : mem64_index;
    let dst_index = dst == 32 ? mem32_index : mem64_index;

    builder.addFunction('copy', makeSig([dst_type, src_type, size_type], []))
        .addBody([
          kExprLocalGet, 0,                                      // dst
          kExprLocalGet, 1,                                      // src
          kExprLocalGet, 2,                                      // size
          kNumericPrefix, kExprMemoryCopy, dst_index, src_index  // memcpy
        ])
        .exportFunc();

    if (expect_valid) {
      builder.toModule();
    } else {
      assertThrows(
          () => builder.toModule(), WebAssembly.CompileError,
          /expected type i(32|64), found local.get of type i(32|64)/);
    }
  }
})();

(function testCopyBetween32And64Bit() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  const kMemSizeInPages = 10;
  const kMemSize = kMemSizeInPages * kPageSize;
  let mem64_index = builder.addMemory64(kMemSizeInPages, kMemSizeInPages);
  let mem32_index = builder.addMemory(kMemSizeInPages, kMemSizeInPages);
  builder.exportMemoryAs('mem64', mem64_index);
  builder.exportMemoryAs('mem32', mem32_index);

  builder
      .addFunction('copy_32_to_64', makeSig([kWasmI64, kWasmI32, kWasmI32], []))
      .addBody([
        kExprLocalGet, 0,                                          // dst
        kExprLocalGet, 1,                                          // src
        kExprLocalGet, 2,                                          // size
        kNumericPrefix, kExprMemoryCopy, mem64_index, mem32_index  // memcpy
      ])
      .exportFunc();
  builder
      .addFunction('copy_64_to_32', makeSig([kWasmI32, kWasmI64, kWasmI32], []))
      .addBody([
        kExprLocalGet, 0,                                          // dst
        kExprLocalGet, 1,                                          // src
        kExprLocalGet, 2,                                          // size
        kNumericPrefix, kExprMemoryCopy, mem32_index, mem64_index  // memcpy
      ])
      .exportFunc();

  let instance = builder.instantiate();
  let {mem32, mem64, copy_32_to_64, copy_64_to_32} = instance.exports;

  // These helpers extract the memory at [offset, offset+size)] into an Array.
  let memory32 = (offset, size) =>
      Array.from(new Uint8Array(mem32.buffer.slice(offset, offset + size)));
  let memory64 = (offset, size) =>
      Array.from(new Uint8Array(mem64.buffer.slice(offset, offset + size)));

  // Init mem32[3] to 11.
  new Uint8Array(mem32.buffer)[3] = 11;
  // Copy mem32[2..4] to mem64[1..3].
  copy_32_to_64(1n, 2, 3);
  assertEquals([0, 0, 0, 11, 0], memory32(0, 5));
  assertEquals([0, 0, 11, 0, 0], memory64(0, 5));
  // Copy mem64[2..3] to mem32[1..2].
  copy_64_to_32(1, 2n, 2);
  assertEquals([0, 11, 0, 11, 0], memory32(0, 5));
  assertEquals([0, 0, 11, 0, 0], memory64(0, 5));

  // Just before OOB.
  copy_32_to_64(BigInt(kMemSize), 0, 0);
  copy_64_to_32(kMemSize, 0n, 0);
  copy_32_to_64(BigInt(kMemSize - 3), 0, 3);
  copy_64_to_32(kMemSize - 3, 0n, 3);
  assertEquals([0, 11, 0], memory64(kMemSize - 3, 3));
  // OOB.
  assertTraps(
      kTrapMemOutOfBounds, () => copy_32_to_64(BigInt(kMemSize + 1), 0, 0));
  assertTraps(
      kTrapMemOutOfBounds, () => copy_64_to_32(kMemSize + 1, 0n, 0));
  assertTraps(
      kTrapMemOutOfBounds, () => copy_32_to_64(BigInt(kMemSize - 2), 0, 3));
  assertTraps(
      kTrapMemOutOfBounds, () => copy_64_to_32(kMemSize - 2, 0n, 3));
})();
                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/wasm/multi-table-element-section.js                                0000664 0000000 0000000 00000006040 14746647661 0025332 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestInitMultipleTables() {
  print(arguments.callee.name);

  const value1 = 11;
  const value2 = 22;
  const value3 = 46;
  const value4 = 57;
  const value5 = 13;

  // The offsets for the initialization of tables. The segement for table2 should
  // overlap with the segment of table1, because table2 is actually the imported
  // table1.
  const offset1 = 2;
  const offset2 = offset1 + 1;
  const offset3 = 4;
  const offset4 = 1;

  const instance_for_import = (function () {
    const builder_for_import = new WasmModuleBuilder();
    const t1 = builder_for_import.addTable(kWasmAnyFunc, 15, 15)
      .exportAs("table").index;
    const f1 = builder_for_import.addFunction('f1', kSig_i_v)
      .addBody([kExprI32Const, value1]).index;
    const f2 = builder_for_import.addFunction('f2', kSig_i_v)
      .addBody([kExprI32Const, value2]).index;

    builder_for_import.addActiveElementSegment(t1, wasmI32Const(offset1),
                                         [f1, f2]);
    const instance_for_import = builder_for_import.instantiate();
    const table1 = instance_for_import.exports.table;
    assertEquals(value1, table1.get(offset1)());
    assertEquals(value2, table1.get(offset1 + 1)());
    return instance_for_import;
  })();

  const builder = new WasmModuleBuilder();

  const t2 = builder.addImportedTable("exports", "table", 15, 15);
  builder.addExportOfKind("table2", kExternalTable, t2);
  const t3 = builder.addTable(kWasmAnyFunc, 10).exportAs("table3").index;
  const t4 = builder.addTable(kWasmAnyFunc, 12).exportAs("table4").index;

  const f3 = builder.addFunction('f3', kSig_i_v)
    .addBody([kExprI32Const, value3]).index;
  const f4 = builder.addFunction('f4', kSig_i_v)
    .addBody([kExprI32Const, value4]).index;
  const f5 = builder.addFunction('f5', kSig_i_v)
    .addBody([kExprI32Const, value5]).index;


  builder.addActiveElementSegment(t2, wasmI32Const(offset2), [f3, f4]);
  builder.addActiveElementSegment(t3, wasmI32Const(offset3), [f5, f4]);
  builder.addActiveElementSegment(t4, wasmI32Const(offset4), [f3, f5]);
  // Add one more overlapping offset
  builder.addActiveElementSegment(t4, wasmI32Const(offset4 + 1),
                                  [f4, f3]);

  const instance = builder.instantiate(instance_for_import);
  // table2 == table1
  const table2 = instance.exports.table2;
  const table3 = instance.exports.table3;
  const table4 = instance.exports.table4;
  // table1 == table2
  assertEquals(value1, table2.get(offset1)());
  assertEquals(value3, table2.get(offset2)());
  assertEquals(value4, table2.get(offset2 + 1)());

  assertEquals(value5, table3.get(offset3)());
  assertEquals(value4, table3.get(offset3 + 1)());

  assertEquals(value3, table4.get(offset4)());
  assertEquals(value4, table4.get(offset4 + 1)());
  assertEquals(value3, table4.get(offset4 + 2)());
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/wasm/multi-value-simd.js                                           0000664 0000000 0000000 00000005475 14746647661 0023233 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function MultiReturnS128Test() {
  print("MultiReturnS128Test");
  // Most backends only support 2 fp return registers, so the third v128
  // onwards here will written to caller stack slot.
  let builder = new WasmModuleBuilder();
  let sig_v_sssss = builder.addType(
    makeSig([], [kWasmS128, kWasmS128, kWasmS128, kWasmS128, kWasmS128]));
  let sig_iiiiiiiiii_v = builder.addType(
    makeSig([], [kWasmI32, kWasmI32, kWasmI32, kWasmI32, kWasmI32, kWasmI32,
      kWasmI32, kWasmI32, kWasmI32, kWasmI32] ));

  let callee = builder.addFunction("callee", sig_v_sssss)
    .addBody([
      kExprI32Const, 0,
      kSimdPrefix, kExprI32x4Splat,
      kExprI32Const, 1,
      kSimdPrefix, kExprI32x4Splat,
      kExprI32Const, 2,
      kSimdPrefix, kExprI32x4Splat,
      kExprI32Const, 3,
      kSimdPrefix, kExprI32x4Splat,
      kExprI32Const, 4,
      kSimdPrefix, kExprI32x4Splat,
      kExprReturn]);
  // For each v128 on the stack, we return the first and last lane. This help
  // catch bugs with reading/writing the wrong stack slots.
  builder.addFunction("main", sig_iiiiiiiiii_v)
    .addLocals(kWasmI32, 10).addLocals(kWasmS128, 1)
    .addBody([
      kExprCallFunction, callee.index,

      kExprLocalTee, 10,
      kSimdPrefix, kExprI32x4ExtractLane, 0,
      kExprLocalSet, 0,
      kExprLocalGet, 10,
      kSimdPrefix, kExprI32x4ExtractLane, 3,
      kExprLocalSet, 1,

      kExprLocalTee, 10,
      kSimdPrefix, kExprI32x4ExtractLane, 0,
      kExprLocalSet, 2,
      kExprLocalGet, 10,
      kSimdPrefix, kExprI32x4ExtractLane, 3,
      kExprLocalSet, 3,

      kExprLocalTee, 10,
      kSimdPrefix, kExprI32x4ExtractLane, 0,
      kExprLocalSet, 4,
      kExprLocalGet, 10,
      kSimdPrefix, kExprI32x4ExtractLane, 3,
      kExprLocalSet, 5,

      kExprLocalTee, 10,
      kSimdPrefix, kExprI32x4ExtractLane, 0,
      kExprLocalSet, 6,
      kExprLocalGet, 10,
      kSimdPrefix, kExprI32x4ExtractLane, 3,
      kExprLocalSet, 7,

      kExprLocalTee, 10,
      kSimdPrefix, kExprI32x4ExtractLane, 0,
      kExprLocalSet, 8,
      kExprLocalGet, 10,
      kSimdPrefix, kExprI32x4ExtractLane, 3,
      kExprLocalSet, 9,

      // Return all the stored locals.
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      kExprLocalGet, 4,
      kExprLocalGet, 5,
      kExprLocalGet, 6,
      kExprLocalGet, 7,
      kExprLocalGet, 8,
      kExprLocalGet, 9,
    ])
    .exportAs("main");

  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  assertEquals(instance.exports.main(), [4, 4, 3, 3, 2, 2, 1, 1, 0, 0]);
})();
                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/wasm/multi-value.js                                                0000664 0000000 0000000 00000040162 14746647661 0022271 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function MultiBlockResultTest() {
  print("MultiBlockResultTest");
  let builder = new WasmModuleBuilder();
  let sig_ii_v = builder.addType(kSig_ii_v);

  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprBlock, sig_ii_v,
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprEnd,
      kExprI32Add])
    .exportAs("main");

  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  assertEquals(instance.exports.main(1, 4), 5);
})();

(function MultiBlockParamTest() {
  print("MultiBlockParamTest");
  let builder = new WasmModuleBuilder();
  let sig_i_ii = builder.addType(kSig_i_ii);

  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprBlock, sig_i_ii,
      kExprI32Add,
      kExprEnd])
    .exportAs("main");

  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  assertEquals(instance.exports.main(1, 4), 5);
})();

(function MultiBlockBrTest() {
  print("MultiBlockBrTest");
  let builder = new WasmModuleBuilder();
  let sig_i_ii = builder.addType(kSig_i_ii);
  let sig_ii_v = builder.addType(kSig_ii_v);

  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprBlock, sig_ii_v,
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprBr, 0,
      kExprEnd,
      kExprI32Add])
    .exportAs("main");

  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  assertEquals(instance.exports.main(1, 4), 5);
})();

(function MultiBlockUnreachableTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_il_v = builder.addType(makeSig([], [kWasmI32, kWasmI64]));

  builder.addFunction("main", kSig_i_v)
    .addBody([
      kExprBlock, sig_il_v,
      kExprI32Const, 1,
      kExprI64Const, 1,
      kExprBr, 0,
      kExprI32Const, 1,
      kExprI64Const, 1,
      kExprEnd,
      kExprDrop])
    .exportAs("main");

  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  assertEquals(instance.exports.main(1, 2), 1);
})();

(function MultiBlockUnreachableTypeErrorTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_il_v = builder.addType(makeSig([], [kWasmI32, kWasmI64]));

  builder.addFunction("main", kSig_i_v)
    .addBody([
      kExprBlock, sig_il_v,
      kExprI32Const, 1,
      kExprI64Const, 1,
      kExprBr, 0,
      kExprI64Const, 1,
      kExprI32Const, 1,
      // Wrong order: expect i32, i64.
      kExprEnd,
      kExprDrop])
    .exportAs("main");

  assertThrows(() => new WebAssembly.Module(builder.toBuffer()),
      WebAssembly.CompileError, /expected type i64, found i32.const/);
})();

(function MultiLoopResultTest() {
  print("MultiLoopResultTest");
  let builder = new WasmModuleBuilder();
  let sig_i_ii = builder.addType(kSig_i_ii);
  let sig_ii_v = builder.addType(kSig_ii_v);

  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprLoop, sig_ii_v,
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprEnd,
      kExprI32Add])
    .exportAs("main");

  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  assertEquals(instance.exports.main(1, 4), 5);
})();

(function MultiLoopParamTest() {
  print("MultiLoopParamTest");
  let builder = new WasmModuleBuilder();
  let sig_i_ii = builder.addType(kSig_i_ii);

  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLoop, sig_i_ii,
      kExprI32Add,
      kExprEnd])
    .exportAs("main");

  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  assertEquals(instance.exports.main(1, 4), 5);
})();

(function MultiLoopBrTest() {
  print("MultiLoopBrTest");
  let builder = new WasmModuleBuilder();
  let sig_i_ii = builder.addType(kSig_i_ii);
  let sig_ii_i = builder.addType(kSig_ii_i);
  let sig_ii_ii = builder.addType(kSig_ii_ii);

  builder.addFunction("dup", kSig_ii_i)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 0]);
  builder.addFunction("swap", kSig_ii_ii)
    .addBody([kExprLocalGet, 1, kExprLocalGet, 0]);
  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLoop, sig_ii_ii,
      kExprCallFunction, 1,  // swap
      kExprCallFunction, 0,  // dup
      kExprI32Add,
      kExprCallFunction, 0,  // dup
      kExprI32Const, 20,
      kExprI32LeU,
      kExprBrIf, 0,
      kExprEnd,
      kExprDrop])
    .exportAs("main");

  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  assertEquals(0, instance.exports.main(0, 1));
  assertEquals(16, instance.exports.main(1, 1));
  assertEquals(4, instance.exports.main(3, 1));
  assertEquals(4, instance.exports.main(4, 1));
  assertEquals(0, instance.exports.main(0, 2));
  assertEquals(16, instance.exports.main(1, 2));
  assertEquals(8, instance.exports.main(3, 2));
  assertEquals(8, instance.exports.main(4, 2));
  assertEquals(0, instance.exports.main(0, 3));
  assertEquals(8, instance.exports.main(1, 3));
  assertEquals(12, instance.exports.main(3, 3));
  assertEquals(12, instance.exports.main(4, 3));
  assertEquals(0, instance.exports.main(0, 4));
  assertEquals(8, instance.exports.main(1, 4));
  assertEquals(16, instance.exports.main(3, 4));
  assertEquals(16, instance.exports.main(4, 4));
  assertEquals(3, instance.exports.main(100, 3));
  assertEquals(6, instance.exports.main(3, 100));
})();


(function MultiIfResultTest() {
  print("MultiIfResultTest");
  let builder = new WasmModuleBuilder();
  let sig_i_ii = builder.addType(kSig_i_ii);
  let sig_ii_v = builder.addType(kSig_ii_v);

  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprIf, sig_ii_v,
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprElse,
      kExprLocalGet, 1,
      kExprLocalGet, 0,
      kExprEnd,
      kExprI32Sub])
    .exportAs("main");

  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  assertEquals(instance.exports.main(8, 3), 5);
  assertEquals(instance.exports.main(0, 3), 3);
})();

(function MultiIfParamTest() {
  print("MultiIfParamTest");
  let builder = new WasmModuleBuilder();
  let sig_i_ii = builder.addType(kSig_i_ii);

  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 0,
      kExprIf, sig_i_ii,
      kExprI32Add,
      kExprElse,
      kExprI32Sub,
      kExprEnd])
    .exportAs("main");

  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  assertEquals(instance.exports.main(1, 4), 5);
  assertEquals(instance.exports.main(0, 4), -4);
})();

(function MultiIfBrTest() {
  print("MultiIfBrTest");
  let builder = new WasmModuleBuilder();
  let sig_i_ii = builder.addType(kSig_i_ii);
  let sig_ii_v = builder.addType(kSig_ii_v);

  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprIf, sig_ii_v,
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprBr, 0,
      kExprElse,
      kExprLocalGet, 1,
      kExprLocalGet, 0,
      kExprBr, 0,
      kExprEnd,
      kExprI32Sub])
    .exportAs("main");

  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  assertEquals(instance.exports.main(8, 3), 5);
  assertEquals(instance.exports.main(0, 3), 3);
})();

(function MultiIfParamOneArmedTest() {
  print("MultiIfParamOneArmedTest");
  let builder = new WasmModuleBuilder();
  let sig_i_i = builder.addType(kSig_i_i);

  builder.addFunction("main", kSig_i_i)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 0,
      kExprIf, sig_i_i,
      kExprI32Const, 5,
      kExprI32Add,
      kExprEnd])
    .exportAs("main");

  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  assertEquals(instance.exports.main(0), 0);
  assertEquals(instance.exports.main(1), 6);
})();

(function MultiIfOneArmedNoTypeCheckTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_i_l = builder.addType(kSig_i_l);

  builder.addFunction("main", kSig_i_v)
    .addBody([
      kExprI64Const, 0,
      kExprI32Const, 0,
      kExprIf, sig_i_l,
      kExprDrop,
      kExprI32Const, 0,
      kExprEnd]);

  assertThrows(() => new WebAssembly.Module(builder.toBuffer()),
      WebAssembly.CompileError, /expected i32, got i64/);
})();

(function MultiResultTest() {
  print("MultiResultTest");
  let builder = new WasmModuleBuilder();
  let sig_i_ii = builder.addType(kSig_i_ii);
  let sig_iii_ii = builder.addType(kSig_iii_ii);

  builder.addFunction("callee", kSig_iii_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI32Sub]);
  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprCallFunction, 0,
      kExprI32Mul,
      kExprI32Add])
    .exportAs("main");

  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  assertEquals(instance.exports.main(0, 0), 0);
  assertEquals(instance.exports.main(1, 0), 1);
  assertEquals(instance.exports.main(2, 0), 2);
  assertEquals(instance.exports.main(0, 1), -1);
  assertEquals(instance.exports.main(0, 2), -4);
  assertEquals(instance.exports.main(3, 4), -1);
  assertEquals(instance.exports.main(4, 3), 7);
})();

(function MultiReturnTest() {
  print("MultiReturnTest");
  let builder = new WasmModuleBuilder();
  let sig_i_i = builder.addType(kSig_i_i);
  let sig_ii_i = builder.addType(kSig_ii_i);

  builder.addFunction("callee", kSig_ii_i)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 0,
      kExprLocalGet, 0,
      kExprI32Add,
      kExprReturn]);
  builder.addFunction("main", kSig_i_i)
    .addBody([
      kExprLocalGet, 0,
      kExprCallFunction, 0,
      kExprI32Mul])
    .exportAs("main");

  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  assertEquals(instance.exports.main(0), 0);
  assertEquals(instance.exports.main(1), 2);
  assertEquals(instance.exports.main(2), 8);
  assertEquals(instance.exports.main(10), 200);
})();

(function MultiBrReturnTest() {
  print("MultiBrReturnTest");
  let builder = new WasmModuleBuilder();
  let sig_i_i = builder.addType(kSig_i_i);
  let sig_ii_i = builder.addType(kSig_ii_i);

  builder.addFunction("callee", kSig_ii_i)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 0,
      kExprLocalGet, 0,
      kExprI32Add,
      kExprBr, 0]);
  builder.addFunction("main", kSig_i_i)
    .addBody([
      kExprLocalGet, 0,
      kExprCallFunction, 0,
      kExprI32Mul])
    .exportAs("main");

  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  assertEquals(instance.exports.main(0), 0);
  assertEquals(instance.exports.main(1), 2);
  assertEquals(instance.exports.main(2), 8);
  assertEquals(instance.exports.main(10), 200);
})();

(function MultiBrTableTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  builder.addFunction("main", kSig_ii_v)
    .addBody([
      kExprI32Const, 1, kExprI32Const, 2,
      kExprI32Const, 0,
      kExprBrTable, 1, 0, 0,
    ])
    .exportAs("main");

  let instance = builder.instantiate();
  assertEquals(instance.exports.main(), [1, 2]);
})();

(function MultiUnreachablePolymorphicTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_v_i = builder.addType(kSig_v_i);
  let sig_i_i = builder.addType(kSig_i_i);

  builder.addFunction("block", kSig_v_v)
    .addBody([
      kExprReturn,
      kExprBlock, sig_v_i,
      kExprDrop,
      kExprEnd
    ])
    .exportAs("block");
  builder.addFunction("if_else", kSig_v_v)
    .addBody([
      kExprReturn,
      kExprIf, sig_v_i,
      kExprDrop,
      kExprElse,
      kExprDrop,
      kExprEnd
    ])
    .exportAs("if_else");
  builder.addFunction("loop", kSig_v_v)
    .addBody([
      kExprReturn,
      kExprLoop, sig_i_i,
      kExprEnd,
      kExprDrop
    ])
    .exportAs("loop");
  // TODO(thibaudm): Create eh + mv mjsunit test and add try/catch case.
  let instance = builder.instantiate();
  instance.exports.block();
  instance.exports.if_else();
  instance.exports.loop();
})();

(function MultiWasmToJSReturnTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_fi_if = makeSig([kWasmI32, kWasmF32], [kWasmF32, kWasmI32]);

  builder.addFunction("swap", sig_fi_if)
    .addBody([
      kExprLocalGet, 1,
      kExprLocalGet, 0])
    .exportAs("swap");
  builder.addFunction("addsubmul", kSig_iii_i)
      .addBody([
        kExprLocalGet, 0,
        kExprLocalGet, 0,
        kExprI32Add,
        kExprLocalGet, 0,
        kExprLocalGet, 0,
        kExprI32Sub,
        kExprLocalGet, 0,
        kExprLocalGet, 0,
        kExprI32Mul])
    .exportAs("addsubmul");

  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  assertEquals(instance.exports.swap(0, 1.5), [1.5, 0]);
  assertEquals(instance.exports.swap(2, 3.75), [3.75, 2]);
  assertEquals(instance.exports.addsubmul(4), [8, 0, 16]);
  assertEquals(instance.exports.addsubmul(5), [10, 0, 25]);
})();

(function MultiJSToWasmReturnTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  function swap(x, y) { return [y, x]; }
  function swap_proxy(x, y) {
    return new Proxy([y, x], {
      get: function(obj, prop) { return Reflect.get(obj, prop); },
    });
  }
  function proxy_throw(x, y) {
    return new Proxy([y, x], {
      get: function(obj, prop) {
        if (prop == 1) {
          throw new Error("abc");
        }
        return Reflect.get(obj, prop); },
    });
  }
  function drop_first(x, y) {
    return [y];
  }
  function repeat(x, y) {
    return [x, y, x, y];
  }
  function not_receiver(x, y) {
    return 0;
  }
  function not_iterable(x, y) {
    a = [x, y];
    a[Symbol.iterator] = undefined;
    return a;
  }
  function* generator(x, y) {
    yield x;
    yield y;
  }
  function* generator_throw(x, y) {
    yield x;
    throw new Error("def");
  }

  builder.addImport('imports', 'f', kSig_ii_ii);
  builder.addFunction("main", kSig_ii_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprCallFunction, 0])
    .exportAs("main")

  let module = new WebAssembly.Module(builder.toBuffer());

  var instance = new WebAssembly.Instance(module, { 'imports' : { 'f' : swap } });
  assertEquals(instance.exports.main(1, 2), [2, 1]);
  instance = new WebAssembly.Instance(module, { 'imports' : { 'f' : swap_proxy } });
  assertEquals(instance.exports.main(1, 2), [2, 1]);
  instance = new WebAssembly.Instance(module, { 'imports' : { 'f' : generator } });
  assertEquals(instance.exports.main(1, 2), [1, 2]);

  instance = new WebAssembly.Instance(module, { 'imports' : { 'f' : drop_first } });
  assertThrows(() => instance.exports.main(1, 2), TypeError, "multi-return length mismatch");
  instance = new WebAssembly.Instance(module, { 'imports' : { 'f' : repeat } });
  assertThrows(() => instance.exports.main(1, 2), TypeError, "multi-return length mismatch");
  instance = new WebAssembly.Instance(module, { 'imports' : { 'f' : proxy_throw } });
  assertThrows(() => instance.exports.main(1, 2), Error, "abc");
  instance = new WebAssembly.Instance(module, { 'imports' : { 'f' : not_receiver } });
  assertThrows(() => instance.exports.main(1, 2), TypeError, /not iterable/);
  instance = new WebAssembly.Instance(module, { 'imports' : { 'f' : not_iterable } });
  assertThrows(() => instance.exports.main(1, 2), TypeError, /not iterable/);
  instance = new WebAssembly.Instance(module, { 'imports' : { 'f' : generator_throw } });
  assertThrows(() => instance.exports.main(1, 2), Error, "def");
})();
                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/wasm/multiple-code-spaces.js                                       0000664 0000000 0000000 00000005052 14746647661 0024043 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --randomize-all-allocations
// Flags: --wasm-max-initial-code-space-reservation=1
// Disable lazy compilation, because force easier code generation.
// Flags: --no-wasm-lazy-compilation

// Disable tier-up, to reduce execution time of this test (Liftoff generates
// much bigger code, thus reaches the four code spaces much faster).
// Flags: --no-wasm-tier-up

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

// Instantiate bigger modules, until at least four separate code spaces have
// been allocated.
// Each function calls through many of the previous functions to execute the
// jump table(s) sufficiently.

let num_functions = 50;
while (true) {
  print(`Trying ${num_functions} functions...`);
  if (num_functions > 1e6) {
    throw new Error('We should have hit four code spaces by now');
  }
  const builder = new WasmModuleBuilder();
  builder.addMemory(1, 1);
  builder.addFunction('f0', kSig_i_i).addBody([kExprLocalGet, 0]);
  // Generate some code per function to fill the code space.
  // Each function contains a number of loads that will not be executed
  // (inside an "if (i == 0)" block). They increase the code size a bit so we
  // do not need too many functions.
  // Each function f<n> with argument {i} then calls f<n/10> with argument
  // {i + 1} and returns whatever that function returns.
  const body_template = [
    kExprLocalGet, 0, kExprI32Eqz, kExprIf, kWasmVoid,  // if (i == 0)
    kExprLocalGet, 0                                    // get i
  ];
  for (let i = 0; i < 1000; ++i) body_template.push(kExprI32LoadMem, 0, 0);
  body_template.push(
      kExprDrop, kExprEnd,                              // end if
      kExprLocalGet, 0, kExprI32Const, 1, kExprI32Add,  // i + 1
      kExprCallFunction                                 // call f<?>
  );
  for (let i = 1; i < num_functions; ++i) {
    const body = body_template.slice();
    body.push(...wasmSignedLeb(Math.floor(i / 10)));
    builder.addFunction('f' + i, kSig_i_i).addBody(body);
  }
  builder.addExport('f', num_functions - 1);
  const instance = builder.instantiate();
  let expected = 17;
  for (let i = num_functions - 1; i > 0; i = Math.floor(i / 10)) ++expected;
  assertEquals(expected, instance.exports.f(17));
  const num_code_spaces = %WasmNumCodeSpaces(instance);
  print(`--> ${num_code_spaces} code spaces.`);
  if (num_code_spaces >= 4) break;
  num_functions *= 2;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/wasm/mutable-globals.js                                            0000664 0000000 0000000 00000017135 14746647661 0023103 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

function assertGlobalIsValid(global) {
  assertSame(WebAssembly.Global.prototype, global.__proto__);
  assertSame(WebAssembly.Global, global.constructor);
  assertTrue(global instanceof Object);
  assertTrue(global instanceof WebAssembly.Global);
}

(function TestConstructor() {

  assertTrue(WebAssembly.Global instanceof Function);
  assertSame(WebAssembly.Global, WebAssembly.Global.prototype.constructor);

  assertThrows(() => new WebAssembly.Global(), TypeError);
  assertThrows(() => new WebAssembly.Global(1), TypeError);
  assertThrows(() => new WebAssembly.Global(""), TypeError);

  assertThrows(() => new WebAssembly.Global({}), TypeError);
  assertThrows(() => new WebAssembly.Global({value: 'foo'}), TypeError);
  assertThrows(() => new WebAssembly.Global({value: 'i128'}), TypeError);

  for (let type of ['i32', 'f32', 'f64', 'i64', 'externref', 'anyfunc']) {
    assertGlobalIsValid(new WebAssembly.Global({value: type}));
  }
})();

// Copied from //src/v8/test/common/value-helper.h
const u32_values = [
  0x00000000, 0x00000001, 0xFFFFFFFF, 0x1B09788B, 0x04C5FCE8, 0xCC0DE5BF,
  // This row is useful for testing lea optimizations on intel.
  0x00000002, 0x00000003, 0x00000004, 0x00000005, 0x00000008, 0x00000009,
  0x273A798E, 0x187937A3, 0xECE3AF83, 0x5495A16B, 0x0B668ECC, 0x11223344,
  0x0000009E, 0x00000043, 0x0000AF73, 0x0000116B, 0x00658ECC, 0x002B3B4C,
  0x88776655, 0x70000000, 0x07200000, 0x7FFFFFFF, 0x56123761, 0x7FFFFF00,
  0x761C4761, 0x80000000, 0x88888888, 0xA0000000, 0xDDDDDDDD, 0xE0000000,
  0xEEEEEEEE, 0xFFFFFFFD, 0xF0000000, 0x007FFFFF, 0x003FFFFF, 0x001FFFFF,
  0x000FFFFF, 0x0007FFFF, 0x0003FFFF, 0x0001FFFF, 0x0000FFFF, 0x00007FFF,
  0x00003FFF, 0x00001FFF, 0x00000FFF, 0x000007FF, 0x000003FF, 0x000001FF,
  // Bit pattern of a quiet NaN and signaling NaN, with or without
  // additional payload.
  0x7FC00000, 0x7F800000, 0x7FFFFFFF, 0x7F876543
];

const f32_values = [
  -Infinity,
  -2.70497e+38,
  -1.4698e+37,
  -1.22813e+35,
  -1.20555e+35,
  -1.34584e+34,
  -1.0079e+32,
  -6.49364e+26,
  -3.06077e+25,
  -1.46821e+25,
  -1.17658e+23,
  -1.9617e+22,
  -2.7357e+20,
  -9223372036854775808.0,  // INT64_MIN
  -1.48708e+13,
  -1.89633e+12,
  -4.66622e+11,
  -2.22581e+11,
  -1.45381e+10,
  -2147483904.0,  // First float32 after INT32_MIN
  -2147483648.0,  // INT32_MIN
  -2147483520.0,  // Last float32 before INT32_MIN
  -1.3956e+09,
  -1.32951e+09,
  -1.30721e+09,
  -1.19756e+09,
  -9.26822e+08,
  -6.35647e+08,
  -4.00037e+08,
  -1.81227e+08,
  -5.09256e+07,
  -964300.0,
  -192446.0,
  -28455.0,
  -27194.0,
  -26401.0,
  -20575.0,
  -17069.0,
  -9167.0,
  -960.178,
  -113.0,
  -62.0,
  -15.0,
  -7.0,
  -1.0,
  -0.0256635,
  -4.60374e-07,
  -3.63759e-10,
  -4.30175e-14,
  -5.27385e-15,
  -1.5707963267948966,
  -1.48084e-15,
  -2.220446049250313e-16,
  -1.05755e-19,
  -3.2995e-21,
  -1.67354e-23,
  -1.11885e-23,
  -1.78506e-30,
  -5.07594e-31,
  -3.65799e-31,
  -1.43718e-34,
  -1.27126e-38,
  -0.0,
  0.0,
  1.17549e-38,
  1.56657e-37,
  4.08512e-29,
  3.31357e-28,
  6.25073e-22,
  4.1723e-13,
  1.44343e-09,
  1.5707963267948966,
  5.27004e-08,
  9.48298e-08,
  5.57888e-07,
  4.89988e-05,
  0.244326,
  1.0,
  12.4895,
  19.0,
  47.0,
  106.0,
  538.324,
  564.536,
  819.124,
  7048.0,
  12611.0,
  19878.0,
  20309.0,
  797056.0,
  1.77219e+09,
  2147483648.0,  // INT32_MAX + 1
  4294967296.0,  // UINT32_MAX + 1
  1.51116e+11,
  4.18193e+13,
  3.59167e+16,
  9223372036854775808.0,   // INT64_MAX + 1
  18446744073709551616.0,  // UINT64_MAX + 1
  3.38211e+19,
  2.67488e+20,
  1.78831e+21,
  9.20914e+21,
  8.35654e+23,
  1.4495e+24,
  5.94015e+25,
  4.43608e+30,
  2.44502e+33,
  2.61152e+33,
  1.38178e+37,
  1.71306e+37,
  3.31899e+38,
  3.40282e+38,
  Infinity,
  NaN
];

const f64_values = [
  -2e66,
  -2.220446049250313e-16,
  -9223373136366403584.0,
  -9223372036854775808.0,  // INT64_MIN
  -2147483649.5,
  -2147483648.25,
  -2147483648.0,
  -2147483647.875,
  -2147483647.125,
  -2147483647.0,
  -999.75,
  -2e66,
  -1.75,
  -1.5707963267948966,
  -1.0,
  -0.5,
  -0.0,
  0.0,
  3e-88,
  0.125,
  0.25,
  0.375,
  0.5,
  1.0,
  1.17549e-38,
  1.56657e-37,
  1.0000001,
  1.25,
  1.5707963267948966,
  2,
  3.1e7,
  5.125,
  6.25,
  888,
  982983.25,
  2147483647.0,
  2147483647.375,
  2147483647.75,
  2147483648.0,
  2147483648.25,
  2147483649.25,
  9223372036854775808.0,  // INT64_MAX + 1
  9223373136366403584.0,
  18446744073709551616.0,  // UINT64_MAX + 1
  2e66,
  Infinity,
  -Infinity,
  NaN
];

function GlobalI32(value, mutable = false) {
  return new WebAssembly.Global({value: 'i32', mutable}, value);
}

function GlobalI64(mutable = false) {
  let builder = new WasmModuleBuilder();
  builder.addGlobal(kWasm64, mutable, false).exportAs('i64');
  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  return instance.exports.i64;
}

function GlobalF32(value, mutable = false) {
  return new WebAssembly.Global({value: 'f32', mutable}, value);
}

function GlobalF64(value, mutable = false) {
  return new WebAssembly.Global({value: 'f64', mutable}, value);
}

(function TestDefaultValue() {
  assertSame(0, GlobalI32().value);
  assertSame(0, GlobalF32().value);
  assertSame(0, GlobalF64().value);
})();

(function TestValueOf() {
  assertTrue(WebAssembly.Global.prototype.valueOf instanceof Function);
  assertSame(0, WebAssembly.Global.prototype.valueOf.length);

  for (let u32_value of u32_values) {
    let i32_value = u32_value | 0;

    assertSame(i32_value, GlobalI32(u32_value).valueOf());
    assertSame(i32_value, GlobalI32(i32_value).valueOf());
  }

  assertThrows(() => GlobalI64().valueOf());

  for (let f32_value of f32_values) {
    assertSame(Math.fround(f32_value), GlobalF32(f32_value).valueOf());
  }

  for (let f64_value of f64_values) {
    assertSame(f64_value, GlobalF64(f64_value).valueOf());
  }
})();

(function TestGetValue() {
  let getter =
      Object.getOwnPropertyDescriptor(WebAssembly.Global.prototype, 'value')
          .get;
  assertTrue(getter instanceof Function);
  assertSame(0, getter.length);

  for (let u32_value of u32_values) {
    let i32_value = u32_value | 0;
    assertSame(i32_value, GlobalI32(u32_value).value);
    assertSame(i32_value, GlobalI32(i32_value).value);
  }

  assertThrows(() => GlobalI64().value);

  for (let f32_value of f32_values) {
    assertSame(Math.fround(f32_value), GlobalF32(f32_value).value);
  }

  for (let f64_value of f64_values) {
    assertSame(f64_value, GlobalF64(f64_value).value);
  }
})();

(function TestSetValueImmutable() {
  assertThrows(() => GlobalI32().value = 0);
  assertThrows(() => GlobalI64().value = 0);
  assertThrows(() => GlobalF32().value = 0);
  assertThrows(() => GlobalF64().value = 0);
})();

(function TestSetValue() {
  let setter =
      Object.getOwnPropertyDescriptor(WebAssembly.Global.prototype, 'value')
          .set;
  assertTrue(setter instanceof Function);
  assertSame(1, setter.length);

  for (let u32_value of u32_values) {
    let i32_value = u32_value | 0;

    let global = GlobalI32(0, true);
    global.value = u32_value;
    assertSame(i32_value, global.value);

    global.value = i32_value;
    assertSame(i32_value, global.value);
  }

  assertThrows(() => GlobalI64(true).value = 0);

  for (let f32_value of f32_values) {
    let global = GlobalF32(0, true);
    global.value = f32_value;
    assertSame(Math.fround(f32_value), global.value);
  }

  for (let f64_value of f64_values) {
    let global = GlobalF64(0, true);
    global.value = f64_value;
    assertSame(f64_value, global.value);
  }
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/wasm/names.js                                                      0000664 0000000 0000000 00000003004 14746647661 0021122 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

function toBytes(string) {
  var a = new Array(string.length + 1);
  a[0] = string.length;
  for (i = 0; i < string.length; i++) {
    a[i + 1] = string.charCodeAt(i);
  }
  return a;
}

(function TestEmptyNamesSection() {
  print('TestEmptyNamesSection...');
  var builder = new WasmModuleBuilder();

  builder.addExplicitSection([kUnknownSectionCode, 6, ...toBytes('name'), 0]);

  var buffer = builder.toBuffer();
  assertTrue(WebAssembly.validate(buffer));
  assertTrue((new WebAssembly.Module(buffer)) instanceof WebAssembly.Module);
})();

(function TestTruncatedNamesSection() {
  print('TestTruncatedNamesSection...');
  var builder = new WasmModuleBuilder();

  builder.addExplicitSection([kUnknownSectionCode, 6, ...toBytes('name'), 1]);

  var buffer = builder.toBuffer();
  assertTrue(WebAssembly.validate(buffer));
  assertTrue((new WebAssembly.Module(buffer)) instanceof WebAssembly.Module);
})();

(function TestBrokenNamesSection() {
  print('TestBrokenNamesSection...');
  var builder = new WasmModuleBuilder();

  builder.addExplicitSection(
      [kUnknownSectionCode, 7, ...toBytes('name'), 1, 100]);

  var buffer = builder.toBuffer();
  assertTrue(WebAssembly.validate(buffer));
  assertTrue((new WebAssembly.Module(buffer)) instanceof WebAssembly.Module);
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/wasm/nan-constant.js                                               0000664 0000000 0000000 00000003627 14746647661 0022435 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Note that we explicitly set the --turboshaft-wasm flag as the bug only
// reproduces on ia32 full debug builds which do not seem to execute the
// turboshaft variant.
// Flags: --allow-natives-syntax --turboshaft-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestInstructionSelectionSignalingNanFloat32Literal() {
  var builder = new WasmModuleBuilder();
  let funcRefT = builder.addType(makeSig([kWasmF32], [kWasmI32]));

  builder.addFunction("reinterpretF32", funcRefT)
    .addBody([kExprLocalGet, 0, kExprI32ReinterpretF32])
    .exportFunc();

  let mainSig =
    makeSig([wasmRefType(funcRefT)], [kWasmI32]);
  builder.addFunction("main", mainSig)
    .addBody([
      ...wasmF32ConstSignalingNaN(),
      kExprLocalGet, 0,
      kExprCallRef, funcRefT,
  ]).exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(0x7fa7a1b9, wasm.main(wasm.reinterpretF32));
  %WasmTierUpFunction(wasm.main);
  assertEquals(0x7fa7a1b9, wasm.main(wasm.reinterpretF32));
})();

(function TestInstructionSelectionSignalingNanFloat64Literal() {
  var builder = new WasmModuleBuilder();
  let funcRefT = builder.addType(makeSig([kWasmF64], [kWasmI64]));

  builder.addFunction("reinterpretF64", funcRefT)
    .addBody([kExprLocalGet, 0, kExprI64ReinterpretF64])
    .exportFunc();

  let mainSig =
    makeSig([wasmRefType(funcRefT)], [kWasmI64]);
  builder.addFunction("main", mainSig)
    .addBody([
      ...wasmF64ConstSignalingNaN(),
      kExprLocalGet, 0,
      kExprCallRef, funcRefT,
  ]).exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(0x7ff4000000000000n, wasm.main(wasm.reinterpretF64));
  %WasmTierUpFunction(wasm.main);
  assertEquals(0x7ff4000000000000n, wasm.main(wasm.reinterpretF64));
})();
                                                                                                         node-23.7.0/deps/v8/test/mjsunit/wasm/origin-trial-flags.js                                         0000664 0000000 0000000 00000002120 14746647661 0023507 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --no-experimental-wasm-stringref
// Flags: --allow-natives-syntax

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function instantiateModuleWithStringRef() {
  // Build a WebAssembly module which uses stringref features.
  const builder = new WasmModuleBuilder();
  builder.addFunction("main",
                      makeSig([kWasmStringRef], [kWasmStringRef]))
  .addBody([kExprLocalGet, 0])
  .exportFunc();
  return builder.instantiate();
}

// Due to --noexperimental-wasm-stringref stringrefs are not supported.
assertThrows(instantiateModuleWithStringRef, WebAssembly.CompileError);
// Disable imported strings explicitly.
%SetWasmImportedStringsEnabled(false);
assertThrows(instantiateModuleWithStringRef, WebAssembly.CompileError);
// Enable imported strings explicitly.
%SetWasmImportedStringsEnabled(true);
let str = "Hello World!";
assertSame(str, instantiateModuleWithStringRef().exports.main(str));
                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/wasm/parallel_compilation.js                                       0000664 0000000 0000000 00000006003 14746647661 0024213 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --wasm-num-compilation-tasks=10

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function assertModule(module, memsize) {
  // Check the module exists.
  assertFalse(module === undefined);
  assertFalse(module === null);
  assertFalse(module === 0);
  assertEquals("object", typeof module);

  // Check the memory is an ArrayBuffer.
  var mem = module.exports.memory;
  assertFalse(mem === undefined);
  assertFalse(mem === null);
  assertFalse(mem === 0);
  assertEquals("object", typeof mem);
  assertTrue(mem instanceof WebAssembly.Memory);
  var buf = mem.buffer;
  assertTrue(buf instanceof ArrayBuffer);
  assertEquals(memsize, buf.byteLength);
  for (var i = 0; i < 4; i++) {
    module.exports.memory = 0;  // should be ignored
    mem.buffer = 0; // should be ignored
    assertSame(mem, module.exports.memory);
    assertSame(buf, mem.buffer);
  }
}

function assertFunction(module, func) {
  assertEquals("object", typeof module.exports);

  var exp = module.exports[func];
  assertFalse(exp === undefined);
  assertFalse(exp === null);
  assertFalse(exp === 0);
  assertEquals("function", typeof exp);
  return exp;
}

(function CompileFunctionsTest() {

  var builder = new WasmModuleBuilder();

  builder.addMemory(1, 1);
  builder.exportMemoryAs("memory");
  for (i = 0; i < 1000; i++) {
    builder.addFunction("sub" + i, kSig_i_i)
      .addBody([                // --
        kExprLocalGet, 0,       // --
        kExprI32Const, i % 61,  // --
        kExprI32Sub])           // --
      .exportFunc()
  }

  var module = builder.instantiate();
  assertModule(module, kPageSize);

  // Check the properties of the functions.
  for (i = 0; i < 1000; i++) {
    var sub = assertFunction(module, "sub" + i);
    assertEquals(33 - (i % 61), sub(33));
  }
})();

(function CallFunctionsTest() {

  var builder = new WasmModuleBuilder();

  var f = []

  f[0] = builder.addFunction("add0", kSig_i_ii)
  .addBody([
            kExprLocalGet, 0,             // --
            kExprLocalGet, 1,             // --
            kExprI32Add,                  // --
          ])
          .exportFunc()

  builder.addMemory(1, 1);
  builder.exportMemoryAs("memory");
  for (i = 1; i < 256; i++) {
    f[i] = builder.addFunction("add" + i, kSig_i_ii)
      .addBody([                                            // --
        kExprLocalGet, 0,                                   // --
        kExprLocalGet, 1,                                   // --
        kExprCallFunction, f[i >>> 1].index])      // --
      .exportFunc()
  }
  var module = builder.instantiate();
  assertModule(module, kPageSize);

  // Check the properties of the functions.
  for (i = 0; i < 256; i++) {
    var add = assertFunction(module, "add" + i);
    assertEquals(88, add(33, 55));
    assertEquals(88888, add(33333, 55555));
    assertEquals(8888888, add(3333333, 5555555));
  }
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/params.js                                                     0000664 0000000 0000000 00000006335 14746647661 0021314 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function runSelect2(select, which, a, b) {
  assertEquals(which == 0 ? a : b, select(a, b));
}

function testSelect2(type) {
  for (var which = 0; which < 2; which++) {
    print("type = " + type + ", which = " + which);

    var builder = new WasmModuleBuilder();

    builder.addFunction("select", makeSig_r_xx(type, type))
      .addBody([kExprLocalGet, which])
      .exportFunc()

    var select = builder.instantiate().exports.select;

    runSelect2(select, which, 99, 97);
    runSelect2(select, which, -99, -97);

    if (type != kWasmF32) {
      runSelect2(select, which, 0x80000000 | 0, 0x7fffffff | 0);
      runSelect2(select, which, 0x80000001 | 0, 0x7ffffffe | 0);
      runSelect2(select, which, 0xffffffff | 0, 0xfffffffe | 0);
      runSelect2(select, which, -2147483647, 2147483646);
      runSelect2(select, which, -2147483646, 2147483645);
      runSelect2(select, which, -2147483648, 2147483647);
    }

    if (type != kWasmI32 && type != kWasmI64) {
      runSelect2(select, which, -1.25, 5.25);
      runSelect2(select, which, Infinity, -Infinity);
    }
  }
}


testSelect2(kWasmI32);
testSelect2(kWasmF32);
testSelect2(kWasmF64);


function runSelect10(select, which, a, b) {
  var x = -1;

  var result = [
    select(a, b, x, x, x, x, x, x, x, x),
    select(x, a, b, x, x, x, x, x, x, x),
    select(x, x, a, b, x, x, x, x, x, x),
    select(x, x, x, a, b, x, x, x, x, x),
    select(x, x, x, x, a, b, x, x, x, x),
    select(x, x, x, x, x, a, b, x, x, x),
    select(x, x, x, x, x, x, a, b, x, x),
    select(x, x, x, x, x, x, x, a, b, x),
    select(x, x, x, x, x, x, x, x, a, b),
    select(x, x, x, x, x, x, x, x, x, a)
  ];

  for (var i = 0; i < 10; i++) {
     if (which == i) assertEquals(a, result[i]);
     else if (which == i+1) assertEquals(b, result[i]);
     else assertEquals(x, result[i]);
  }
}

function testSelect10(t) {
  var kBodySize = 2;
  var kNameOffset = kHeaderSize + 29 + kBodySize + 1;

  for (var which = 0; which < 10; which++) {
    print("type = " + t + ", which = " + which);

    var builder = new WasmModuleBuilder();
    builder.addFunction("select", makeSig([t,t,t,t,t,t,t,t,t,t], [t]))
      .addBody([kExprLocalGet, which])
      .exportFunc();

    var select = builder.instantiate().exports.select;

    assertEquals("function", typeof select);
    runSelect10(select, which, 99, 97);
    runSelect10(select, which, -99, -97);

    if (t != kWasmF32) {
      runSelect10(select, which, 0x80000000 | 0, 0x7fffffff | 0);
      runSelect10(select, which, 0x80000001 | 0, 0x7ffffffe | 0);
      runSelect10(select, which, 0xffffffff | 0, 0xfffffffe | 0);
      runSelect10(select, which, -2147483647, 2147483646);
      runSelect10(select, which, -2147483646, 2147483645);
      runSelect10(select, which, -2147483648, 2147483647);
    }

    if (t != kWasmI32 && t != kWasmI64) {
      runSelect10(select, which, -1.25, 5.25);
      runSelect10(select, which, Infinity, -Infinity);
    }
  }
}


testSelect10(kWasmI32);
testSelect10(kWasmF32);
testSelect10(kWasmF64);
                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/wasm/print-code.js                                                 0000664 0000000 0000000 00000001764 14746647661 0022076 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Force TurboFan code for serialization.
// Flags: --allow-natives-syntax --print-wasm-code --no-liftoff
// Flags: --no-wasm-lazy-compilation

// Just test that printing the code of the following wasm modules does not
// crash.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function print_deserialized_code() {
  // https://crbug.com/849656
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();
  builder.addImport('', 'imp', kSig_i_v);

  builder.addFunction('main', kSig_i_v)
      .addBody([
        kExprCallFunction,
        0,
      ])
      .exportFunc();

  var wire_bytes = builder.toBuffer();
  var module = new WebAssembly.Module(wire_bytes);
  print('serializing');
  var buff = %SerializeWasmModule(module);
  print('deserializing');
  module = %DeserializeWasmModule(buff, wire_bytes);
})();
            node-23.7.0/deps/v8/test/mjsunit/wasm/prototype.js                                                  0000664 0000000 0000000 00000002634 14746647661 0022074 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

let emptyModuleBinary = new WasmModuleBuilder().toBuffer();

(function ModulePrototype() {
  class _Module extends WebAssembly.Module {}
  let module = new _Module(emptyModuleBinary);
  assertInstanceof(module, _Module);
  assertInstanceof(module, WebAssembly.Module);
})();

(function InstancePrototype() {
  class _Instance extends WebAssembly.Instance {}
  let instance = new _Instance(new WebAssembly.Module(emptyModuleBinary));
  assertInstanceof(instance, _Instance);
  assertInstanceof(instance, WebAssembly.Instance);
})();

(function TablePrototype() {
  class _Table extends WebAssembly.Table {}
  let table = new _Table({initial: 0, element: "anyfunc"});
  assertInstanceof(table, _Table);
  assertInstanceof(table, WebAssembly.Table);
})();

(function MemoryPrototype() {
  class _Memory extends WebAssembly.Memory {}
  let memory = new _Memory({initial: 0, maximum: 1});
  assertInstanceof(memory, _Memory);
  assertInstanceof(memory, WebAssembly.Memory);
})();

(function GlobalPrototype() {
  class _Global extends WebAssembly.Global {}
  let global = new _Global({value: 'i32', mutable: false}, 0);
  assertInstanceof(global, _Global);
  assertInstanceof(global, WebAssembly.Global);
})();
                                                                                                    node-23.7.0/deps/v8/test/mjsunit/wasm/receiver.js                                                   0000664 0000000 0000000 00000002223 14746647661 0021625 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function testCallImport(func, expected, a, b) {
  var builder = new WasmModuleBuilder();

  var sig_index = builder.addType(kSig_i_dd);
  builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,            // --
      kExprLocalGet, 1,            // --
      kExprCallFunction, 0])         // --
    .exportAs("main");

  var main = builder.instantiate({mod: {func: func}}).exports.main;

  assertEquals(expected, main(a, b));
}

var global = (function() { return this; })();

function sloppyReceiver(a, b) {
  assertEquals(global, this);
  assertEquals(33.3, a);
  assertEquals(44.4, b);
  return 11;
}

function strictReceiver(a, b) {
  'use strict';
  assertEquals(undefined, this);
  assertEquals(55.5, a);
  assertEquals(66.6, b);
  return 22;
}

testCallImport(sloppyReceiver, 11, 33.3, 44.4);
testCallImport(strictReceiver, 22, 55.5, 66.6);
                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/recognize-imports.js                                          0000664 0000000 0000000 00000024304 14746647661 0023505 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-stringref --allow-natives-syntax

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

function CheckStackTrace(thrower, reference, topmost_wasm_func) {
  let reference_exception;
  let actual_exception;
  try {
    thrower();
    assertUnreachable();
  } catch (e) {
    actual_exception = e;
  }
  try {
    reference();
    assertUnreachable();
  } catch (e) {
    reference_exception = e;
  }
  assertInstanceof(actual_exception, reference_exception.constructor);
  let actual_stack = actual_exception.stack.split('\n');
  let reference_stack = reference_exception.stack.split('\n');
  assertEquals(reference_stack[0], actual_stack[0]);
  assertEquals(reference_stack[1], actual_stack[1]);
  assertTrue(
      actual_stack[2].startsWith(`    at ${topmost_wasm_func} (wasm://wasm/`));
}

let builder = new WasmModuleBuilder();
let sig_w_w = makeSig([kWasmStringRef], [kWasmStringRef]);
let kRefString = wasmRefType(kWasmStringRef);
let toLowerCase = builder.addImport("m", "toLowerCase", sig_w_w);

builder.addFunction('call_tolower', sig_w_w).exportFunc().addBody([
  kExprLocalGet, 0,
  kExprCallFunction, toLowerCase,
]);

let module = builder.toModule();

let recognizable = Function.prototype.call.bind(String.prototype.toLowerCase);
let recognizable_imports = { m: { toLowerCase: recognizable } };

let instance1 = new WebAssembly.Instance(module, recognizable_imports);
let call_tolower = instance1.exports.call_tolower;
assertEquals("abc", call_tolower("ABC"));
%WasmTierUpFunction(call_tolower);
assertEquals("abc", call_tolower("ABC"));

// Null should be handled correctly (by throwing the same TypeError that
// JavaScript would throw).
CheckStackTrace(
    () => call_tolower(null), () => String.prototype.toLowerCase.call(null),
    'call_tolower');

// Creating a second instance with identical imports should not cause
// recompilation.
console.log("Second instance.");
let instance2 = new WebAssembly.Instance(module, recognizable_imports);
assertEquals("def", instance2.exports.call_tolower("DEF"));

// Creating a third instance with different imports must not reuse the
// existing optimized code.
console.log("Third instance.");
let other_imports = { m: { toLowerCase: () => "foo" } };
let instance3 = new WebAssembly.Instance(module, other_imports);
assertEquals("foo", instance3.exports.call_tolower("GHI"));
assertEquals("def", instance2.exports.call_tolower("DEF"));
assertEquals("abc", instance1.exports.call_tolower("ABC"));

(function TestStringToLowercaseStringRef() {
  console.log('Testing String.toLowerCase with stringRef');
  let builder = new WasmModuleBuilder();
  let toLowerCaseNullable =
      builder.addImport('m', 'toLowerCaseNullable', sig_w_w);
  builder.addFunction('tolower_nullable', sig_w_w).exportFunc().addBody([
    kExprLocalGet, 0,
    kExprCallFunction, toLowerCaseNullable,
  ]);
  let func = Function.prototype.call.bind(String.prototype.toLowerCase);
  toLowerCaseNullable = builder.instantiate({m: {toLowerCaseNullable: func}})
                            .exports.tolower_nullable;

  %WasmTierUpFunction(toLowerCaseNullable);
  assertEquals('abc', toLowerCaseNullable('ABC'));
  CheckStackTrace(
      () => toLowerCaseNullable(null),
      () => String.prototype.toLowerCase.call(null), 'tolower_nullable');
})();

(function TestStringToLowercaseRefString() {
  console.log('Testing String.toLowerCase with refString');
  let builder = new WasmModuleBuilder();
  let sig_refstr = makeSig([kRefString], [kRefString]);
  let toLowerCaseNonNullable =
      builder.addImport('m', 'toLowerCaseNonNullable', sig_refstr);
  builder.addFunction('tolower_non_nullable', sig_refstr).exportFunc().addBody([
    kExprLocalGet, 0,
    kExprCallFunction, toLowerCaseNonNullable,
  ]);
  let func = Function.prototype.call.bind(String.prototype.toLowerCase);
  toLowerCaseNonNullable =
      builder.instantiate({m: {toLowerCaseNonNullable: func}})
          .exports.tolower_non_nullable;

  %WasmTierUpFunction(toLowerCaseNonNullable);
  assertEquals('abc', toLowerCaseNonNullable('ABC'));
})();

(function TestIntToString() {
  console.log("Testing IntToString");
  let builder = new WasmModuleBuilder();
  let sig_w_ii = makeSig([kWasmI32, kWasmI32], [kWasmStringRef]);
  let intToString = builder.addImport("m", "intToString", sig_w_ii);
  builder.addFunction('call_inttostring', sig_w_ii).exportFunc().addBody([
    kExprLocalGet, 0,
    kExprLocalGet, 1,
    kExprCallFunction, intToString,
  ]);
  let func = Function.prototype.call.bind(Number.prototype.toString);
  let instance = builder.instantiate({ m: { intToString: func } });
  let call_inttostring = instance.exports.call_inttostring;
  %WasmTierUpFunction(call_inttostring);
  assertEquals("42", call_inttostring(42, 10));
  assertEquals("-123", call_inttostring(-123, 10));
  assertEquals("2a", call_inttostring(42, 16));
  assertEquals("2147483647", call_inttostring(2147483647, 10));
  assertEquals("-2147483648", call_inttostring(-2147483648, 10));
  CheckStackTrace(
      () => call_inttostring(1, 99), () => func(1, 99), 'call_inttostring');
})();

(function TestDoubleToString() {
  console.log("Testing DoubleToString");
  let builder = new WasmModuleBuilder();
  let sig_d_w = makeSig([kWasmStringRef], [kWasmF64]);
  let sig_d_refstr = makeSig([kRefString], [kWasmF64]);
  let sig_w_d = makeSig([kWasmF64], [kWasmStringRef]);
  let doubleToString = builder.addImport('m', 'doubleToString', sig_w_d);
  let stringToDoubleNullable =
      builder.addImport('m', 'stringToDoubleNullable', sig_d_w);
  let stringToDoubleNonNullable =
      builder.addImport('m', 'stringToDoubleNonNullable', sig_d_refstr);
  builder.addFunction('call_doubletostring', sig_w_d).exportFunc().addBody([
    kExprLocalGet, 0,
    kExprCallFunction, doubleToString,
  ]);
  builder.addFunction('call_stringtodouble_nullable', sig_d_w)
      .exportFunc()
      .addBody([
        kExprLocalGet, 0,
        kExprCallFunction, stringToDoubleNullable,
      ]);
  builder.addFunction('call_stringtodouble_non_nullable', sig_d_refstr)
      .exportFunc()
      .addBody([
        kExprLocalGet, 0,
        kExprCallFunction, stringToDoubleNonNullable,
      ]);
  let wasm = builder.instantiate({
    m: {
      doubleToString: Function.prototype.call.bind(Number.prototype.toString),
      stringToDoubleNullable: parseFloat,
      stringToDoubleNonNullable: parseFloat,
    }
  }).exports;
  let d2s = wasm.call_doubletostring;
  let s2d_nullable = wasm.call_stringtodouble_nullable;
  let s2d_non_nullable = wasm.call_stringtodouble_non_nullable;
  %WasmTierUpFunction(d2s);
  %WasmTierUpFunction(s2d_nullable);
  %WasmTierUpFunction(s2d_non_nullable);
  assertEquals("42", d2s(42));
  assertEquals("1234.5", d2s(1234.5));
  assertEquals("NaN", d2s(NaN));
  assertEquals(1234.5, s2d_nullable("1234.5"));
  assertEquals(1234.5, s2d_non_nullable("1234.5"));
  assertEquals(NaN, s2d_nullable(null));
})();

(function TestIndexOfWithStringRef() {
  console.log("Testing String.indexOf with stringRef");
  let builder = new WasmModuleBuilder();
  let sig_i_wwi =
      makeSig([kWasmStringRef, kWasmStringRef, kWasmI32], [kWasmI32]);
  let indexOf = builder.addImport("m", "indexOf", sig_i_wwi);
  builder.addFunction('call_indexof', sig_i_wwi).exportFunc().addBody([
    kExprLocalGet, 0,
    kExprLocalGet, 1,
    kExprLocalGet, 2,
    kExprCallFunction, indexOf,
  ]);
  indexOf = builder.instantiate({
      m: {indexOf: Function.prototype.call.bind(String.prototype.indexOf)}
  }).exports.call_indexof;
  %WasmTierUpFunction(indexOf);
  assertEquals(2, indexOf("xxfooxx", "foo", 0));
  assertEquals(2, indexOf("xxfooxx", "foo", -2));
  assertEquals(-1, indexOf("xxfooxx", "foo", 100));
  // Make sure we don't lose bits when Smi-tagging of the start position.
  assertEquals(-1, indexOf("xxfooxx", "foo", 0x4000_0000));
  assertEquals(-1, indexOf("xxfooxx", "foo", 0x2000_0000));
  assertEquals(2, indexOf("xxfooxx", "foo", 0x8000_0000));  // Negative i32.
  // When first arg is null, throw; when second arg is null, convert.
  assertEquals(2, indexOf("xxnullxx", null, 0));
  CheckStackTrace(
      () => indexOf(null, 'null', 0),
      () => String.prototype.indexOf.call(null, 'null', 0), 'call_indexof');
})();

(function TestIndexOfRefString() {
  console.log("Testing String.indexOf with refString");
  let builder = new WasmModuleBuilder();
  let sig_refstr = makeSig([kRefString, kRefString, kWasmI32], [kWasmI32]);
  let indexOf = builder.addImport("m", "indexOf", sig_refstr);
  builder.addFunction('call_indexof', sig_refstr).exportFunc().addBody([
    kExprLocalGet, 0,
    kExprLocalGet, 1,
    kExprLocalGet, 2,
    kExprCallFunction, indexOf,
  ]);
  indexOf = builder.instantiate({
      m: {indexOf: Function.prototype.call.bind(String.prototype.indexOf)}
  }).exports.call_indexof;
  %WasmTierUpFunction(indexOf);
  assertEquals(2, indexOf("xxfooxx", "foo", 0));
})();

(function TestToLocaleLower() {
  console.log("Testing String.toLocaleLowerCase");
  let builder = new WasmModuleBuilder();
  let sig_w_ww = makeSig([kWasmStringRef, kWasmStringRef], [kWasmStringRef]);
  let tolower = builder.addImport("m", "tolower", sig_w_ww);
  builder.addFunction('call_tolower', sig_w_ww).exportFunc().addBody([
    kExprLocalGet, 0,
    kExprLocalGet, 1,
    kExprCallFunction, tolower,
  ]);
  tolower = builder.instantiate({
    m: {
      tolower: Function.prototype.call.bind(String.prototype.toLocaleLowerCase)
    }
  }).exports.call_tolower;
  %WasmTierUpFunction(tolower);
  assertEquals("abc", tolower("ABC", "en"));
  let has_i18n = typeof Intl !== "undefined";
  if (has_i18n) {
    // Check that the locale isn't ignored.
    assertEquals("\u0131", tolower("I", "az"));
    CheckStackTrace(
        () => tolower('ABC', null),
        () => String.prototype.toLocaleLowerCase.call('ABC', null),
        'call_tolower');
  } else {
    // Non-i18n builds ignore the locale parameter.
    assertEquals("i", tolower("I", "az"));
    assertEquals('abc', tolower('ABC', null));
    assertEquals('abc', String.prototype.toLocaleLowerCase.call('ABC', null));
  }
  CheckStackTrace(
      () => tolower(null, 'en'),
      () => String.prototype.toLocaleLowerCase.call(null, 'en'),
      'call_tolower');
})();
                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/wasm/ref-cast-js-function.js                                       0000664 0000000 0000000 00000002102 14746647661 0023756 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-type-reflection

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function RefCastWasmJSFunction() {
  const paramsTypes = [kWasmI32];
  const retTypes = [];
  const sig = makeSig(paramsTypes, retTypes);

  const builder = new WasmModuleBuilder();
  const sigId = builder.addType(sig);
  const impIndex = builder.addImport('m', 'foo', sigId);

  const table = builder.addTable(kWasmAnyFunc, 10).index;
  builder.addActiveElementSegment(table, wasmI32Const(0), [impIndex]);

  builder.addFunction('main', sigId)
    .addBody([
      kExprLocalGet, 0, kExprI32Const, 0, kExprTableGet, table, kGCPrefix,
      kExprRefCast, sigId, kExprCallRef, sigId
    ])
    .exportFunc();
  const jsFunc = new WebAssembly.Function(
    { parameters: ['i32'], results: [] },
    () => 12 );
  const instance = builder.instantiate({ 'm': { 'foo': jsFunc } });
  instance.exports.main(15);
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/wasm/ref-eq-unreachable.js                                         0000664 0000000 0000000 00000000640 14746647661 0023450 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

const builder = new WasmModuleBuilder();
builder.addFunction("main", makeSig([], []))
  .addBody([
kExprReturn,
kExprRefEq,  // ref.eq
kExprDrop,
]).exportFunc();
builder.instantiate();
                                                                                                node-23.7.0/deps/v8/test/mjsunit/wasm/reference-globals-import.js                                   0000664 0000000 0000000 00000046456 14746647661 0024730 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-stringref

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// Test type checks when creating a global with a value imported from a global
// from another module.
(function TestReferenceGlobalsImportGlobal() {
  print(arguments.callee.name);

  let exporting_instance = (function() {
    let builder = new WasmModuleBuilder();
    let type_super = builder.addStruct([makeField(kWasmI32, false)]);
    let type_sub =
        builder.addStruct([makeField(kWasmI32, false)], type_super);
    let type_other = builder.addStruct([makeField(kWasmI64, false)]);

    builder.addGlobal(wasmRefType(type_super), false, false,
                      [kExprI32Const, 42,
                       kGCPrefix, kExprStructNew, type_super])
           .exportAs("super");
    builder.addGlobal(wasmRefType(type_sub), false, false,
                      [kExprI32Const, 42,
                       kGCPrefix, kExprStructNew, type_sub])
           .exportAs("sub");
    builder.addGlobal(wasmRefType(type_other), false, false,
            [kExprI64Const, 42,
             kGCPrefix, kExprStructNew, type_other])
           .exportAs("other");
    // null variants
    builder.addGlobal(wasmRefNullType(type_super), false, false,
                      [kExprI32Const, 42,
                       kGCPrefix, kExprStructNew, type_super])
           .exportAs("super_nullable");
    builder.addGlobal(wasmRefNullType(type_sub), false, false,
                      [kExprI32Const, 42,
                       kGCPrefix, kExprStructNew, type_sub])
           .exportAs("sub_nullable");
    builder.addGlobal(wasmRefNullType(type_other), false, false,
            [kExprI64Const, 42,
             kGCPrefix, kExprStructNew, type_other])
           .exportAs("other_nullable");
    return builder.instantiate({});
  })();

  let tests = [
    //valid |type             |imported_global
    [true,  "super",          "super"],
    [true,  "sub",            "sub"],
    [true,  "super",          "sub"], // would be invalid for immutable global!
    [false, "sub",            "super"],
    [false, "sub",            "other"],
    [false, "super",          "super_nullable"],
    [true,  "super_nullable", "super"],
    [true,  "super_nullable", "sub"],
    [true,  "super_nullable", "sub_nullable"],
    [false, "super_nullable", "other_nullable"],
    [false, "sub_nullable",   "super_nullable"],
  ];
  for (let[expected_valid, type, global] of tests) {
    print(`test ${type} imports ${global}`);
    let builder = new WasmModuleBuilder();
    let type_super = builder.addStruct([makeField(kWasmI32, false)]);
    let type_sub =
      builder.addStruct([makeField(kWasmI32, false)], type_super);

    let types = {
      super: wasmRefType(type_super),
      sub: wasmRefType(type_sub),
      super_nullable: wasmRefNullType(type_super),
      sub_nullable: wasmRefNullType(type_sub),
    };
    builder.addImportedGlobal("imports", "global", types[type], false);
    assertNotEquals(exporting_instance.exports[global], undefined);
    let imports = { global: exporting_instance.exports[global] };
    if (expected_valid) {
      builder.addFunction("read_global", makeSig([], [kWasmI32]))
      .addBody([
        kExprGlobalGet, 0,
        kGCPrefix, kExprStructGet, types[type].heap_type, 0,
      ])
      .exportFunc();

      let instance = builder.instantiate({imports});
      assertEquals(42, instance.exports.read_global());
    } else {
      assertThrows(
        () => builder.instantiate({imports}),
        WebAssembly.LinkError,
        /imported global does not match the expected type/
      );
    }
  }
})();

// Test type checks when creating a global initialized with wasm objects
// provided as externref.
(function TestReferenceGlobalsImportValue() {
  print(arguments.callee.name);

  let exporting_instance = (function() {
    let builder = new WasmModuleBuilder();
    let type_super = builder.addStruct([makeField(kWasmI32, false)]);
    let type_sub =
        builder.addStruct([makeField(kWasmI32, false)], type_super);
    let type_other = builder.addStruct([makeField(kWasmI64, false)]);

    builder.addFunction("create_super", makeSig([], [kWasmExternRef]))
    .addBody([
      kExprI32Const, 42,
      kGCPrefix, kExprStructNew, type_super,
      kGCPrefix, kExprExternConvertAny])
    .exportFunc();
    builder.addFunction("create_sub", makeSig([], [kWasmExternRef]))
    .addBody([
      kExprI32Const, 42,
      kGCPrefix, kExprStructNew, type_sub,
      kGCPrefix, kExprExternConvertAny])
    .exportFunc();
    builder.addFunction("create_other", makeSig([], [kWasmExternRef]))
    .addBody([
      kExprI64Const, 42,
      kGCPrefix, kExprStructNew, type_other,
      kGCPrefix, kExprExternConvertAny])
    .exportFunc();
    builder.addFunction("create_null", makeSig([], [kWasmExternRef]))
    .addBody([
      kExprRefNull, kNullRefCode,
      kGCPrefix, kExprExternConvertAny])
    .exportFunc();

    return builder.instantiate({});
  })();

  let tests = [
    //valid |type             |imported_value
    [true,  "super",          "super"],
    [true,  "sub",            "sub"],
    [true,  "super",          "sub"],
    [false, "sub",            "super"],
    [false, "sub",            "other"],
    [false, "super",          "null"],
    [true,  "super_nullable", "super"],
    [true,  "super_nullable", "sub"],
    [true,  "super_nullable", "sub"],
    [false, "super_nullable", "other"],
    [false, "sub_nullable",   "super"],
    [true,  "super_nullable", "null"],
  ];
  for (let[expected_valid, type, imported_value] of tests) {
    print(`test ${type} imports ${imported_value}`);
    let builder = new WasmModuleBuilder();
    let type_super = builder.addStruct([makeField(kWasmI32, false)]);
    let type_sub =
      builder.addStruct([makeField(kWasmI32, false)], type_super);
    let types = {
      super: wasmRefType(type_super),
      sub: wasmRefType(type_sub),
      super_nullable: wasmRefNullType(type_super),
      sub_nullable: wasmRefNullType(type_sub),
    };
    builder.addImportedGlobal("imports", "global", types[type], false);
    let init_value = exporting_instance.exports[`create_${imported_value}`]();
    let imports = {global: init_value};
    if (expected_valid) {
      builder.addFunction("read_global", makeSig([], [kWasmI32]))
      .addBody([
        kExprBlock, kWasmVoid,
          kExprGlobalGet, 0,
          kExprBrOnNull, 0,
          kGCPrefix, kExprStructGet, types[type].heap_type, 0,
          kExprReturn,
        kExprEnd,
        ...wasmI32Const(-1),
      ])
      .exportFunc();

      let instance = builder.instantiate({imports});
      assertEquals(imported_value == "null" ? -1 : 42,
                   instance.exports.read_global());
    } else {
      assertThrows(
        () => builder.instantiate({imports}),
        WebAssembly.LinkError
      );
    }
  }
})();

(function TestReferenceGlobalsImportInvalidJsValues() {
  print(arguments.callee.name);
  let invalid_values =
      [undefined, {}, [], 0, NaN, null, /regex/, true, false, ""];
  for (let value of invalid_values) {
    print(`test invalid value ${JSON.stringify(value)}`);
    let builder = new WasmModuleBuilder();
    let struct_type = builder.addStruct([makeField(kWasmI32, false)]);
    let ref_type = wasmRefType(struct_type);
    builder.addImportedGlobal("imports", "value", ref_type, false);
    assertThrows(
      () => builder.instantiate({imports: {value}}),
      WebAssembly.LinkError);
  }
})();

(function TestReferenceGlobalsAbstractTypes() {
  print(arguments.callee.name);
  let exporting_instance = (function() {
    let builder = new WasmModuleBuilder();
    let type_struct = builder.addStruct([makeField(kWasmI32, false)]);
    let type_array = builder.addArray(kWasmI32);

    builder.addFunction("create_struct", makeSig([], [kWasmExternRef]))
    .addBody([
      kExprI32Const, 42,
      kGCPrefix, kExprStructNew, type_struct,
      kGCPrefix, kExprExternConvertAny])
    .exportFunc();
    builder.addFunction("create_array", makeSig([], [kWasmExternRef]))
    .addBody([
      kExprI32Const, 42,
      kGCPrefix, kExprArrayNewFixed, type_array, 1,
      kGCPrefix, kExprExternConvertAny])
    .exportFunc();
    return builder.instantiate({});
  })();

  let builder = new WasmModuleBuilder();
  builder.addImportedGlobal("imports", "any1", kWasmAnyRef, false);
  builder.addImportedGlobal("imports", "any2", kWasmAnyRef, false);
  builder.addImportedGlobal("imports", "any3", kWasmAnyRef, false);
  builder.addImportedGlobal("imports", "any4", kWasmAnyRef, false);
  builder.addImportedGlobal("imports", "any4", kWasmAnyRef, false);
  builder.addImportedGlobal("imports", "any5", kWasmAnyRef, false);
  builder.addImportedGlobal("imports", "eq1", kWasmEqRef, false);
  builder.addImportedGlobal("imports", "eq2", kWasmEqRef, false);
  builder.addImportedGlobal("imports", "eq3", kWasmEqRef, false);
  builder.addImportedGlobal("imports", "array", kWasmArrayRef, false);
  builder.addImportedGlobal("imports", "i31ref", kWasmI31Ref, false);
  builder.instantiate({imports : {
    any1: exporting_instance.exports.create_struct(),
    any2: exporting_instance.exports.create_array(),
    any3: 12345, // i31
    any4: null,
    any5: "test string",
    eq1: 12345,
    eq2: exporting_instance.exports.create_array(),
    eq3: exporting_instance.exports.create_struct(),
    array: exporting_instance.exports.create_array(),
    i31ref: -123,
  }});
})();

(function TestReferenceGlobalsStrings() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addImportedGlobal("imports", "string1", kWasmStringRef, false);
  builder.addImportedGlobal("imports", "string2", kWasmStringRef, false);
  builder.addImportedGlobal("imports", "any", kWasmAnyRef, false);

  builder.addFunction("get_string1", makeSig([], [kWasmExternRef]))
  .addBody([kExprGlobalGet, 0, kGCPrefix, kExprExternConvertAny])
  .exportFunc();
  builder.addFunction("get_string2", makeSig([], [kWasmExternRef]))
  .addBody([kExprGlobalGet, 1, kGCPrefix, kExprExternConvertAny])
  .exportFunc();
  builder.addFunction("get_any", makeSig([], [kWasmExternRef]))
  .addBody([kExprGlobalGet, 2, kGCPrefix, kExprExternConvertAny])
  .exportFunc();

  let instance = builder.instantiate({imports : {
    string1: "Content of string1",
    string2: null,
    any: "Content of any",
  }});

  assertEquals("Content of string1", instance.exports.get_string1());
  assertEquals(null, instance.exports.get_string2());
  assertEquals("Content of any", instance.exports.get_any());
})();

(function TestAnyRefGlobalFromJS() {
  print(arguments.callee.name);
  let anyref_global = new WebAssembly.Global(
      { value: "anyref", mutable: true }, "initial value");
  assertEquals("initial value", anyref_global.value);

  let builder = new WasmModuleBuilder();
  builder.addImportedGlobal("imports", "anyref_global", kWasmAnyRef, true);
  let struct_type = builder.addStruct([makeField(kWasmI32, false)]);
  let array_type = builder.addArray(kWasmI32);

  builder.addFunction("get_extern", makeSig([], [kWasmExternRef]))
  .addBody([kExprGlobalGet, 0, kGCPrefix, kExprExternConvertAny])
  .exportFunc();
  builder.addFunction("get_struct_val", makeSig([], [kWasmI32]))
  .addBody([
    kExprGlobalGet, 0,
    kGCPrefix, kExprRefCast, struct_type,
    kGCPrefix, kExprStructGet, struct_type, 0,
  ])
  .exportFunc();
  builder.addFunction("get_array_val", makeSig([], [kWasmI32]))
  .addBody([
    kExprGlobalGet, 0,
    kGCPrefix, kExprRefCast, array_type,
    kExprI32Const, 0,
    kGCPrefix, kExprArrayGet, array_type,
  ])
  .exportFunc();
  builder.addFunction("create_struct", makeSig([kWasmI32], [kWasmExternRef]))
  .addBody([
    kExprLocalGet, 0,
    kGCPrefix, kExprStructNew, struct_type,
    kGCPrefix, kExprExternConvertAny])
  .exportFunc();
  builder.addFunction("create_array", makeSig([kWasmI32], [kWasmExternRef]))
  .addBody([
    kExprLocalGet, 0,
    kGCPrefix, kExprArrayNewFixed, array_type, 1,
    kGCPrefix, kExprExternConvertAny])
  .exportFunc();

  let instance = builder.instantiate({imports : {anyref_global}});
  let wasm = instance.exports;

  anyref_global.value = "Set anyref from string";
  assertEquals("Set anyref from string", anyref_global.value);
  assertEquals("Set anyref from string", wasm.get_extern());
  anyref_global.value = wasm.create_struct(42);
  assertEquals(42, wasm.get_struct_val());
  anyref_global.value = wasm.create_array(43);
  assertEquals(43, wasm.get_array_val());
  anyref_global.value = null;
  assertEquals(null, anyref_global.value);
  assertEquals(null, wasm.get_extern());
  anyref_global.value = 12345;
  assertEquals(12345, wasm.get_extern());

  let o = {};
  anyref_global.value = o;
  assertEquals(o, anyref_global.value);
  assertEquals(o, wasm.get_extern());
  anyref_global.value = undefined;
  assertEquals(undefined, anyref_global.value);
})();

(function TestEqRefGlobalFromJS() {
  print(arguments.callee.name);
  let eqref_global = new WebAssembly.Global(
      { value: "eqref", mutable: true }, null);
  assertEquals(null, eqref_global.value);

  let builder = new WasmModuleBuilder();
  builder.addImportedGlobal("imports", "eqref_global", kWasmEqRef, true);
  let struct_type = builder.addStruct([makeField(kWasmI32, false)]);
  let array_type = builder.addArray(kWasmI32);

  builder.addFunction("get_extern", makeSig([], [kWasmExternRef]))
  .addBody([kExprGlobalGet, 0, kGCPrefix, kExprExternConvertAny])
  .exportFunc();
  builder.addFunction("get_struct_val", makeSig([], [kWasmI32]))
  .addBody([
    kExprGlobalGet, 0,
    kGCPrefix, kExprRefCast, struct_type,
    kGCPrefix, kExprStructGet, struct_type, 0,
  ])
  .exportFunc();
  builder.addFunction("get_array_val", makeSig([], [kWasmI32]))
  .addBody([
    kExprGlobalGet, 0,
    kGCPrefix, kExprRefCast, array_type,
    kExprI32Const, 0,
    kGCPrefix, kExprArrayGet, array_type,
  ])
  .exportFunc();
  builder.addFunction("create_struct", makeSig([kWasmI32], [kWasmExternRef]))
  .addBody([
    kExprLocalGet, 0,
    kGCPrefix, kExprStructNew, struct_type,
    kGCPrefix, kExprExternConvertAny])
  .exportFunc();
  builder.addFunction("create_array", makeSig([kWasmI32], [kWasmExternRef]))
  .addBody([
    kExprLocalGet, 0,
    kGCPrefix, kExprArrayNewFixed, array_type, 1,
    kGCPrefix, kExprExternConvertAny])
  .exportFunc();

  let instance = builder.instantiate({imports : {eqref_global}});
  let wasm = instance.exports;

  eqref_global.value = wasm.create_struct(42);
  assertEquals(42, wasm.get_struct_val());
  eqref_global.value = wasm.create_array(43);
  assertEquals(43, wasm.get_array_val());
  eqref_global.value = null;
  assertEquals(null, eqref_global.value);
  assertEquals(null, wasm.get_extern());
  eqref_global.value = 12345;
  assertEquals(12345, wasm.get_extern());

  assertThrows(() => eqref_global.value = {}, TypeError);
  assertThrows(() => eqref_global.value = undefined, TypeError);
  assertThrows(() => eqref_global.value = "string", TypeError);
})();

(function TestStructRefGlobalFromJS() {
  print(arguments.callee.name);
  let structref_global = new WebAssembly.Global(
      { value: "structref", mutable: true }, null);
  assertNull(structref_global.value);

  let builder = new WasmModuleBuilder();
  builder.addImportedGlobal("imports", "structref_global", kWasmStructRef, true);
  let struct_type = builder.addStruct([makeField(kWasmI32, false)]);
  let array_type = builder.addArray(kWasmI32);

  builder.addFunction("get_struct_val", makeSig([], [kWasmI32]))
  .addBody([
    kExprGlobalGet, 0,
    kGCPrefix, kExprRefCast, struct_type,
    kGCPrefix, kExprStructGet, struct_type, 0,
  ])
  .exportFunc();
  builder.addFunction("create_struct", makeSig([kWasmI32], [kWasmExternRef]))
  .addBody([
    kExprLocalGet, 0,
    kGCPrefix, kExprStructNew, struct_type,
    kGCPrefix, kExprExternConvertAny])
  .exportFunc();
  builder.addFunction("create_array", makeSig([kWasmI32], [kWasmExternRef]))
  .addBody([
    kExprLocalGet, 0,
    kGCPrefix, kExprArrayNewFixed, array_type, 1,
    kGCPrefix, kExprExternConvertAny])
  .exportFunc();

  let instance = builder.instantiate({imports : {structref_global}});
  let wasm = instance.exports;

  structref_global.value = wasm.create_struct(42);
  assertEquals(42, wasm.get_struct_val());
  structref_global.value = null;
  assertEquals(null, structref_global.value);

  assertThrows(() => structref_global.value = undefined, TypeError);
  assertThrows(() => structref_global.value = "string", TypeError);
  assertThrows(() => structref_global.value = wasm.create_array(1), TypeError);
})();

(function TestArrayRefGlobalFromJS() {
  print(arguments.callee.name);
  let arrayref_global = new WebAssembly.Global(
      { value: "arrayref", mutable: true }, null);
  assertNull(arrayref_global.value);

  let builder = new WasmModuleBuilder();
  builder.addImportedGlobal("imports", "arrayref_global", kWasmArrayRef, true);
  let struct_type = builder.addStruct([makeField(kWasmI32, false)]);
  let array_type = builder.addArray(kWasmI32);

  builder.addFunction("get_array_val", makeSig([], [kWasmI32]))
  .addBody([
    kExprGlobalGet, 0,
    kGCPrefix, kExprRefCast, array_type,
    kExprI32Const, 0,
    kGCPrefix, kExprArrayGet, array_type,
  ])
  .exportFunc();
  builder.addFunction("create_struct", makeSig([kWasmI32], [kWasmExternRef]))
  .addBody([
    kExprLocalGet, 0,
    kGCPrefix, kExprStructNew, struct_type,
    kGCPrefix, kExprExternConvertAny])
  .exportFunc();
  builder.addFunction("create_array", makeSig([kWasmI32], [kWasmExternRef]))
  .addBody([
    kExprLocalGet, 0,
    kGCPrefix, kExprArrayNewFixed, array_type, 1,
    kGCPrefix, kExprExternConvertAny])
  .exportFunc();

  let instance = builder.instantiate({imports : {arrayref_global}});
  let wasm = instance.exports;

  arrayref_global.value = wasm.create_array(43);
  assertEquals(43, wasm.get_array_val());
  arrayref_global.value = null;
  assertEquals(null, arrayref_global.value);

  assertThrows(() => arrayref_global.value = undefined, TypeError);
  assertThrows(() => arrayref_global.value = "string", TypeError);
  assertThrows(() => arrayref_global.value = wasm.create_struct(1), TypeError);
})();

(function TestI31RefGlobalFromJS() {
  print(arguments.callee.name);
  let i31ref_global = new WebAssembly.Global(
      { value: "i31ref", mutable: true }, 123);
  assertEquals(123, i31ref_global.value);

  let builder = new WasmModuleBuilder();
  builder.addImportedGlobal("imports", "i31ref_global", kWasmI31Ref, true);
  let struct_type = builder.addStruct([makeField(kWasmI32, false)]);

  builder.addFunction("get_i31", makeSig([], [kWasmI32]))
  .addBody([
    kExprGlobalGet, 0,
    kGCPrefix, kExprI31GetS
  ])
  .exportFunc();
  builder.addFunction("create_struct",
                      makeSig([kWasmI32], [wasmRefType(struct_type)]))
  .addBody([
    kExprLocalGet, 0,
    kGCPrefix, kExprStructNew, struct_type,
  ])
  .exportFunc();

  let instance = builder.instantiate({imports : {i31ref_global}});
  let wasm = instance.exports;
  assertEquals(123, i31ref_global.value);

  i31ref_global.value = 42;
  assertEquals(42, i31ref_global.value);
  assertEquals(42, wasm.get_i31());
  i31ref_global.value = null;
  assertEquals(null, i31ref_global.value);

  assertThrows(() => i31ref_global.value = undefined, TypeError);
  assertThrows(() => i31ref_global.value = "string", TypeError);
  assertThrows(() => i31ref_global.value = wasm.create_struct(1), TypeError);
  assertThrows(() => i31ref_global.value = Math.pow(2, 33), TypeError);
})();
                                                                                                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/wasm/reference-globals.js                                          0000664 0000000 0000000 00000035736 14746647661 0023417 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestReferenceGlobals() {
  print(arguments.callee.name);

  var exporting_instance = (function() {
    var builder = new WasmModuleBuilder();

    builder.startRecGroup();
    var sig_index = builder.addType(kSig_i_ii);
    builder.endRecGroup();
    builder.startRecGroup();
    var wrong_sig_index = builder.addType(kSig_i_i);
    builder.endRecGroup();

    var addition_index = builder.addFunction("addition", sig_index)
      .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
      .exportFunc();

    builder.addGlobal(wasmRefType(sig_index), false, false,
                      [kExprRefFunc, addition_index.index])
           .exportAs("global");
    builder.addGlobal(wasmRefNullType(wrong_sig_index), false, false)
      .exportAs("mistyped_global");

    return builder.instantiate({});
  })();

  // Mistyped imported global.
  assertThrows(
    () => {
      var builder = new WasmModuleBuilder();
      var sig_index = builder.addType(kSig_i_ii);
      builder.addImportedGlobal("imports", "global", wasmRefNullType(sig_index),
                                false);
      builder.instantiate(
        {imports: { global: exporting_instance.exports.mistyped_global }})},
    WebAssembly.LinkError,
    /imported global does not match the expected type/
  );

  // Mistyped imported global due to cross-module typechecking.
  assertThrows(
    () => {
      var builder = new WasmModuleBuilder();
      var sig_index = builder.addType(kSig_i_i);
      builder.addImportedGlobal("imports", "global", wasmRefNullType(sig_index),
                                false);
      builder.instantiate(
        {imports: { global: exporting_instance.exports.global }})},
    WebAssembly.LinkError,
    /imported global does not match the expected type/
  );

  // Non-function imported into function-typed global.
  assertThrows(
    () => {
      var builder = new WasmModuleBuilder();
      var sig_index = builder.addType(kSig_i_ii);
      builder.addImportedGlobal("imports", "global", wasmRefNullType(sig_index),
                                false);
      builder.instantiate({imports: { global: 42 }})},
    WebAssembly.LinkError,
    /JS object does not match expected wasm type/
  );

  // Mistyped function import.
  assertThrows(
    () => {
      var builder = new WasmModuleBuilder();
      var sig_index = builder.addType(kSig_i_i);
      builder.addImportedGlobal("imports", "global", wasmRefType(sig_index),
                                false);
      builder.instantiate(
        {imports: { global: exporting_instance.exports.addition }})},
    WebAssembly.LinkError,
    /assigned exported function has to be a subtype of the expected type/
  );

  var instance = (function () {
    var builder = new WasmModuleBuilder();

    var sig_index = builder.addType(kSig_i_ii);

    builder.addImportedGlobal("imports", "global", wasmRefNullType(sig_index),
                              false);

    builder.addFunction("test_import", kSig_i_ii)
      .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprGlobalGet, 0,
                kExprCallRef, sig_index])
      .exportFunc();

    return builder.instantiate({imports: {
      global: exporting_instance.exports.global
    }});
  })();

  // This module is valid.
  assertFalse(instance === undefined);
  assertFalse(instance === null);
  assertFalse(instance === 0);

  // The correct function reference has been passed.
  assertEquals(66, instance.exports.test_import(42, 24));
})();

(function TestStructInitExpr() {
  print(arguments.callee.name);

  var builder = new WasmModuleBuilder();
  builder.startRecGroup();
  var struct_index = builder.addStruct([{type: kWasmI32, mutability: true}]);
  builder.endRecGroup();
  var composite_struct_index = builder.addStruct(
      [{type: kWasmI32, mutability: true},
       {type: wasmRefNullType(struct_index), mutability: true},
       {type: kWasmI8, mutability: true}]);

  let field1_value = 432;
  let field2_value = -123;
  let field3_value = -555;

  var global0 = builder.addGlobal(
      wasmRefType(struct_index), false, false,
      [...wasmI32Const(field2_value),
       kGCPrefix, kExprStructNew, struct_index]);

  var global = builder.addGlobal(
      wasmRefType(composite_struct_index), false, false,
      [...wasmI32Const(field1_value), kExprGlobalGet, global0.index,
       ...wasmI32Const(field3_value),
       kGCPrefix, kExprStructNew, composite_struct_index]);

  var global_default = builder.addGlobal(
    wasmRefType(composite_struct_index), false, false,
    [kGCPrefix, kExprStructNewDefault, composite_struct_index]);

  builder.addFunction("field_1", kSig_i_v)
    .addBody([
      kExprGlobalGet, global.index,
      kGCPrefix, kExprStructGet, composite_struct_index, 0
    ])
    .exportFunc();

  builder.addFunction("field_2", kSig_i_v)
    .addBody([
      kExprGlobalGet, global.index,
      kGCPrefix, kExprStructGet, composite_struct_index, 1,
      kGCPrefix, kExprStructGet, struct_index, 0
    ])
    .exportFunc();

  builder.addFunction("field_3", kSig_i_v)
    .addBody([
      kExprGlobalGet, global.index,
      kGCPrefix, kExprStructGetS, composite_struct_index, 2])
    .exportFunc();

  builder.addFunction("field_1_default", kSig_i_v)
    .addBody([
      kExprGlobalGet, global_default.index,
      kGCPrefix, kExprStructGet, composite_struct_index, 0])
    .exportFunc();

  builder.addFunction("field_2_default", makeSig([], [kWasmStructRef]))
    .addBody([
      kExprGlobalGet, global_default.index,
      kGCPrefix, kExprStructGet, composite_struct_index, 1])
    .exportFunc();

  builder.addFunction("field_3_default", kSig_i_v)
    .addBody([
      kExprGlobalGet, global_default.index,
      kGCPrefix, kExprStructGetS, composite_struct_index, 2])
    .exportFunc();

  var instance = builder.instantiate({});

  assertEquals(field1_value, instance.exports.field_1());
  assertEquals(field2_value, instance.exports.field_2());
  assertEquals((field3_value << 24) >> 24, instance.exports.field_3());
  assertEquals(0, instance.exports.field_1_default());
  assertEquals(null, instance.exports.field_2_default());
  assertEquals(0, instance.exports.field_3_default());
})();

(function TestArrayNewFixedExprNumeric() {
  print(arguments.callee.name);

  var builder = new WasmModuleBuilder();
  var array_index = builder.addArray(kWasmI16, true);

  let element0_value = -44;
  let element1_value = 55;

  var global0 = builder.addGlobal(
      kWasmI32, false, false,
      wasmI32Const(element0_value));

  var global = builder.addGlobal(
      wasmRefType(array_index), false, false,
      [kExprGlobalGet, global0.index, ...wasmI32Const(element1_value),
       kGCPrefix, kExprArrayNewFixed, array_index, 2]);

  builder.addFunction("get_element", kSig_i_i)
    .addBody([
      kExprGlobalGet, global.index,
      kExprLocalGet, 0,
      kGCPrefix, kExprArrayGetS, array_index])
    .exportFunc();

  var instance = builder.instantiate({});

  assertEquals(element0_value, instance.exports.get_element(0));
  assertEquals(element1_value, instance.exports.get_element(1));
})();

(function TestArrayNewFixedExprRef() {
  print(arguments.callee.name);

  var builder = new WasmModuleBuilder();
  var struct_index = builder.addStruct([{type: kWasmI32, mutability: false}]);
  var array_index = builder.addArray(wasmRefNullType(struct_index), true);

  let element0_value = 44;
  let element2_value = 55;

  var global0 = builder.addGlobal(
      wasmRefType(struct_index), false, false,
      [...wasmI32Const(element0_value),
       kGCPrefix, kExprStructNew, struct_index]);

  var global = builder.addGlobal(
      wasmRefType(array_index), false, false,
      [kExprGlobalGet, global0.index, kExprRefNull, struct_index,
       ...wasmI32Const(element2_value),
       kGCPrefix, kExprStructNew, struct_index,
       kGCPrefix, kExprArrayNewFixed, array_index, 3]);

  builder.addFunction("element0", kSig_i_v)
    .addBody([
      kExprGlobalGet, global.index,
      kExprI32Const, 0,
      kGCPrefix, kExprArrayGet, array_index,
      kGCPrefix, kExprStructGet, struct_index, 0])
    .exportFunc();

  builder.addFunction("element1", makeSig([], [kWasmStructRef]))
    .addBody([
      kExprGlobalGet, global.index,
      kExprI32Const, 1,
      kGCPrefix, kExprArrayGet, array_index])
    .exportFunc();

  builder.addFunction("element2", kSig_i_v)
    .addBody([
      kExprGlobalGet, global.index,
      kExprI32Const, 2,
      kGCPrefix, kExprArrayGet, array_index,
      kGCPrefix, kExprStructGet, struct_index, 0])
    .exportFunc();

  var instance = builder.instantiate({});

  assertEquals(element0_value, instance.exports.element0());
  assertEquals(null, instance.exports.element1());
  assertEquals(element2_value, instance.exports.element2());
})();

(function TestArrayNew() {
  print(arguments.callee.name);

  var builder = new WasmModuleBuilder();
  var struct_index = builder.addStruct([makeField(kWasmI64, true)]);
  var array_num_index = builder.addArray(kWasmI64, true);
  var array_ref_index = builder.addArray(wasmRefNullType(struct_index), true);

  let elem1 = -44;
  let elem2 = 15;
  let length = 20;

  let global_elem_1 =
    builder.addGlobal(kWasmI64, false, false, wasmI64Const(elem1));
  let global_elem_2 =
    builder.addGlobal(kWasmI64, false, false, wasmI64Const(elem2));
  let global_length =
    builder.addGlobal(kWasmI32, false, false, wasmI32Const(length));

  var global_array_1 = builder.addGlobal(
      wasmRefType(array_num_index), false, false,
      [kExprGlobalGet, global_elem_1.index,
       kExprGlobalGet, global_length.index,
       kGCPrefix, kExprArrayNew, array_num_index]);

  var global_array_2 = builder.addGlobal(
        wasmRefType(array_ref_index), false, false,
        [kExprGlobalGet, global_elem_2.index,
         kGCPrefix, kExprStructNew, struct_index,
         kExprGlobalGet, global_length.index,
         kGCPrefix, kExprArrayNew, array_ref_index]);

  builder.addFunction("get_elements", kSig_l_i)
    .addBody([
      kExprGlobalGet, global_array_1.index,
      kExprLocalGet, 0,
      kGCPrefix, kExprArrayGet, array_num_index,
      kExprGlobalGet, global_array_2.index,
      kExprLocalGet, 0,
      kGCPrefix, kExprArrayGet, array_ref_index,
      kGCPrefix, kExprStructGet, struct_index, 0,
      kExprI64Add])
    .exportFunc();

  var instance = builder.instantiate({});

  let result = BigInt(elem1 + elem2);

  assertEquals(result, instance.exports.get_elements(0));
  assertEquals(result, instance.exports.get_elements(length / 2));
  assertEquals(result, instance.exports.get_elements(length - 1));
  assertTraps(kTrapArrayOutOfBounds,
              () => instance.exports.get_elements(length));
})();

(function TestArrayNewArrayTooLarge() {
  print(arguments.callee.name);

  var builder = new WasmModuleBuilder();
  var array_num_index = builder.addArray(kWasmI64, true);

  builder.addGlobal(
      wasmRefType(array_num_index), false, false,
      [...wasmI32Const(0x8ffffff),
       kGCPrefix, kExprArrayNewDefault, array_num_index]);

  assertTraps(kTrapArrayTooLarge, () => builder.instantiate({}));
})();

(function TestI31RefConstantExpr() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let array_index = builder.addArray(kWasmI31Ref, false);

  let values = [0, 10, -22, 0x7fffffff, -1];

  let global = builder.addGlobal(
      wasmRefType(array_index), true, false,
      [...values.flatMap(
        value => [...wasmI32Const(value), kGCPrefix, kExprRefI31]),
       kGCPrefix, kExprArrayNewFixed, array_index, 5]);

  for (signed of [true, false]) {
    builder.addFunction(`get_${signed ? "s" : "u"}`, kSig_i_i)
        .addBody([kExprGlobalGet, global.index,
                  kExprLocalGet, 0, kGCPrefix, kExprArrayGet, array_index,
                  kGCPrefix, signed ? kExprI31GetS : kExprI31GetU])
        .exportFunc();
  }

  let instance = builder.instantiate();

  assertEquals(values[0], instance.exports.get_s(0));
  assertEquals(values[1], instance.exports.get_s(1));
  assertEquals(values[2], instance.exports.get_s(2));
  assertEquals(values[3] | 0x80000000, instance.exports.get_s(3));
  assertEquals(values[4], instance.exports.get_s(4));

  assertEquals(values[0], instance.exports.get_u(0));
  assertEquals(values[1], instance.exports.get_u(1));
  assertEquals(values[2] & 0x7fffffff, instance.exports.get_u(2));
  assertEquals(values[3], instance.exports.get_u(3));
  assertEquals(values[4] & 0x7fffffff, instance.exports.get_u(4));
})();

(function TestI31RefConstantExprTypeError() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  builder.addGlobal(kWasmI31Ref, false, false,
                    [...wasmI64Const(0), kGCPrefix, kExprRefI31]);

  assertThrows(() => builder.instantiate(), WebAssembly.CompileError,
               /ref.i31\[0\] expected type i32, found i64.const of type i64/);
})();

(function TestConstantExprFuncIndexOutOfBounds() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct_index = builder.addStruct([makeField(kWasmFuncRef, true)]);
  let func = builder.addFunction("element", kSig_i_i)
    .addBody([kExprLocalGet, 0])
    .exportFunc()

  builder.addGlobal(wasmRefType(struct_index), false, false,
                    [kExprRefFunc, func.index + 1, kExprStructNew,
                     struct_index]);

  assertThrows(() => builder.instantiate(), WebAssembly.CompileError,
               /function index #1 is out of bounds/);
})();

(function TestExternConstantExpr() {
  print(arguments.callee.name);

  let imported_struct = (function () {
    let builder = new WasmModuleBuilder();

    let struct = builder.addStruct([makeField(kWasmI32, true)]);

    let global = builder.addGlobal(
        wasmRefType(struct), false, false,
        [kExprI32Const, 42, kGCPrefix, kExprStructNew, struct])
      .exportAs("global");

    return builder.instantiate().exports.global.value;
  })();

  let builder = new WasmModuleBuilder();

  let struct = builder.addStruct([makeField(kWasmI32, true)]);

  let imported = builder.addImportedGlobal("m", "ext", kWasmExternRef, false)

  let internal = builder.addGlobal(
    kWasmAnyRef, false, false,
    [kExprGlobalGet, imported, kGCPrefix, kExprAnyConvertExtern]);

  builder.addGlobal(
      kWasmExternRef, false, false,
      [kExprGlobalGet, internal.index, kGCPrefix, kExprExternConvertAny])
    .exportAs("exported")

  builder.addFunction("getter", kSig_i_v)
    .addBody([kExprGlobalGet, internal.index,
              kGCPrefix, kExprRefCast, struct,
              kGCPrefix, kExprStructGet, struct, 0])
    .exportFunc();

  builder.addFunction("getter_fail", kSig_i_v)
    .addBody([kExprGlobalGet, internal.index,
              kGCPrefix, kExprRefCast, kI31RefCode,
              kGCPrefix, kExprI31GetS])
    .exportFunc();

  let instance = builder.instantiate({m: {ext: imported_struct}});

  assertSame(instance.exports.exported.value, imported_struct);
  assertEquals(42, instance.exports.getter());
  assertTraps(kTrapIllegalCast, () => instance.exports.getter_fail());
})();
                                  node-23.7.0/deps/v8/test/mjsunit/wasm/reference-table-js-interop.js                                 0000664 0000000 0000000 00000020104 14746647661 0025132 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-stringref

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

let tableTypes = {
  "anyref": kWasmAnyRef,
  "eqref": kWasmEqRef,
  "structref": kWasmStructRef,
  "arrayref": kWasmArrayRef,
  "i31ref": kWasmI31Ref,
};

// Test table consistency check.
for (let [typeName, type] of Object.entries(tableTypes)) {
  print("TestTableTypeCheck_" + typeName);
  let builder = new WasmModuleBuilder();
  const size = 10;
  builder.addImportedTable("imports", "table", size, size, type);

  for (let typeName2 in tableTypes) {
    let table = new WebAssembly.Table({
      initial: size, maximum: size, element: typeName2
    });
    if (typeName == typeName2) {
      builder.instantiate({ imports: { table } });
    } else {
      let err = 'WebAssembly.Instance(): Import #0 "imports" "table": ' +
                'imported table does not match the expected type';
      assertThrows(() => builder.instantiate({ imports: { table } }),
                   WebAssembly.LinkError,
                   err);
    }
  }
}

// Test table usage from JS and Wasm.
for (let [typeName, type] of Object.entries(tableTypes)) {
  print("TestImportedTable_" + typeName);
  let builder = new WasmModuleBuilder();

  const size = 10;
  const maxSize = 20;
  let table = new WebAssembly.Table({
    initial: size, maximum: maxSize, element: typeName
  });

  let creatorSig = builder.addType(makeSig([], [type]));
  let creatorAnySig = builder.addType(makeSig([], [kWasmAnyRef]));
  let struct = builder.addStruct([makeField(kWasmI32, false)]);
  let array = builder.addArray(kWasmI32, true);

  builder.addImportedTable("imports", "table", size, maxSize, type);
  builder.addFunction("tableSet",
                      makeSig([kWasmI32, wasmRefType(creatorSig)], []))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprCallRef, creatorSig,
      kExprTableSet, 0,
    ])
    .exportFunc();
  builder.addFunction("tableGet", makeSig([kWasmI32], [kWasmExternRef]))
    .addBody([
      kExprLocalGet, 0, kExprTableGet, 0,
      kGCPrefix, kExprExternConvertAny,
    ])
    .exportFunc();

  let getValSig = makeSig([kWasmI32], [kWasmI32]);
  builder.addFunction("tableGetStructVal", getValSig)
    .addBody([
      kExprLocalGet, 0, kExprTableGet, 0,
      kGCPrefix, kExprRefCast, struct,
      kGCPrefix, kExprStructGet, struct, 0,
    ])
    .exportFunc();
  builder.addFunction("tableGetArrayVal", getValSig)
    .addBody([
      kExprLocalGet, 0, kExprTableGet, 0,
      kGCPrefix, kExprRefCast, array,
      kExprI32Const, 0,
      kGCPrefix, kExprArrayGet, array,
    ])
    .exportFunc();

  builder.addFunction("exported",
                      makeSig([wasmRefType(creatorSig)], [kWasmExternRef]))
    .addBody([
      kExprLocalGet, 0,
      kExprCallRef, creatorSig,
      kGCPrefix, kExprExternConvertAny,
    ])
    .exportFunc();
  builder.addFunction("exportedAny",
                      makeSig([wasmRefType(creatorAnySig)], [kWasmExternRef]))
    .addBody([
      kExprLocalGet, 0,
      kExprCallRef, creatorAnySig,
      kGCPrefix, kExprExternConvertAny,
    ])
    .exportFunc();

  builder.addFunction("createNull", creatorSig)
    .addBody([kExprRefNull, kNullRefCode])
    .exportFunc();
  let i31Sig = typeName != "structref" && typeName != "arrayref"
               ? creatorSig : creatorAnySig;
  builder.addFunction("createI31", i31Sig)
    .addBody([kExprI32Const, 12, kGCPrefix, kExprRefI31])
    .exportFunc();
  let structSig = typeName != "arrayref" && typeName != "i31ref"
                  ? creatorSig : creatorAnySig;
  builder.addFunction("createStruct", structSig)
    .addBody([kExprI32Const, 12, kGCPrefix, kExprStructNew, struct])
    .exportFunc();
  let arraySig = typeName != "structref" && typeName != "i31ref"
                 ? creatorSig : creatorAnySig;
  builder.addFunction("createArray", arraySig)
    .addBody([
      kExprI32Const, 12,
      kGCPrefix, kExprArrayNewFixed, array, 1
    ])
    .exportFunc();

  if (typeName == "anyref") {
    builder.addFunction("tableSetFromExtern",
                      makeSig([kWasmI32, kWasmExternRef], []))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kGCPrefix, kExprAnyConvertExtern,
      kExprTableSet, 0,
    ])
    .exportFunc();
  }

  let instance = builder.instantiate({ imports: { table } });
  let wasm = instance.exports;

  // Set null.
  table.set(0, null);
  assertEquals(null, wasm.tableGet(0));
  assertEquals(null, table.get(0));
  wasm.tableSet(1, wasm.createNull);
  assertEquals(null, wasm.tableGet(1));
  assertEquals(null, table.get(1));
  // Set i31.
  if (typeName != "structref" && typeName != "arrayref") {
    table.set(2, wasm.exported(wasm.createI31));
    assertSame(table.get(2), wasm.tableGet(2));
    wasm.tableSet(3, wasm.createI31);
    assertSame(table.get(3), wasm.tableGet(3));
    assertSame(table.get(2), table.get(3)); // The same smi.
  }
  // Set struct.
  if (typeName != "arrayref" && typeName != "i31ref") {
    table.set(4, wasm.exported(wasm.createStruct));
    assertSame(table.get(4), wasm.tableGet(4));
    assertEquals(12, wasm.tableGetStructVal(4));
    wasm.tableSet(5, wasm.createStruct);
    assertSame(table.get(5), wasm.tableGet(5));
    assertEquals(12, wasm.tableGetStructVal(5));
    assertNotSame(table.get(4), table.get(5));
  }
  // Set array.
  if (typeName != "structref" && typeName != "i31ref") {
    table.set(6, wasm.exported(wasm.createArray));
    assertSame(table.get(6), wasm.tableGet(6));
    assertEquals(12, wasm.tableGetArrayVal(6));
    wasm.tableSet(7, wasm.createArray);
    assertSame(table.get(7), wasm.tableGet(7));
    assertEquals(12, wasm.tableGetArrayVal(7));
    assertNotSame(table.get(6), table.get(7));
  }

  // Set stringref.
  if (typeName == "anyref") {
    table.set(8, "TestString");
    assertEquals("TestString", wasm.tableGet(8));
    assertEquals("TestString", table.get(8));
    let largeString = "Another test string, this time larger to prevent"
                    + " any kind of short string optimization.";
    wasm.tableSetFromExtern(9, largeString);
    assertEquals(largeString, wasm.tableGet(9));
    assertEquals(largeString, table.get(9));
  }

  if (typeName != "arrayref" && typeName != "i31ref") {
    // Grow table with explicit value.
    table.grow(2, wasm.exported(wasm.createStruct));
    assertEquals(12, wasm.tableGetStructVal(size));
    assertEquals(12, wasm.tableGetStructVal(size + 1));
    assertTraps(kTrapTableOutOfBounds, () => wasm.tableGetStructVal(size + 2));
    // Grow by 1 without initial value.
    table.grow(1, null);
    if (typeName == "anyref") {
      // Undefined is fine for anyref.
      table.grow(1, undefined);
    } else {
      // But not for any other wasm internal type.
      assertThrows(() => table.grow(1, undefined), TypeError);
      // No-argument will use the default value.
      table.grow(1);
    }
  }
  if (typeName == "anyref") {
    table.grow(1, "Grow using a string");
    assertEquals("Grow using a string", wasm.tableGet(14));
    assertEquals("Grow using a string", table.get(14));
  }
  if (typeName == "i31ref" || typeName == "anyref") {
    table.set(0, 123);
    assertEquals(123, table.get(0));
    table.set(1, -123);
    assertEquals(-123, table.get(1));
    if (typeName == "i31ref") {
      assertThrows(() => table.set(0, 1 << 31), TypeError);
    } else {
      // anyref can reference boxed numbers as well.
      table.set(0, 1 << 31)
      assertEquals(1 << 31, table.get(0));
    }
  }

  // Set from JS with wrapped wasm value of incompatible type.
  let invalidValues = {
    "anyref": [],
    "eqref": [],
    "structref": ["I31", "Array"],
    "arrayref": ["I31", "Struct"],
    "i31ref": ["Struct", "Array"],
  };
  for (let invalidType of invalidValues[typeName]) {
    print(`Test invalid type ${invalidType} for ${typeName}`);
    let invalid_value = wasm.exportedAny(wasm[`create${invalidType}`]);
    assertThrows(() => table.grow(1, invalid_value), TypeError);
    assertThrows(() => table.set(1, invalid_value), TypeError);
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/wasm/reference-tables.js                                           0000664 0000000 0000000 00000054730 14746647661 0023241 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');
(function TestTables() {
  print(arguments.callee.name);
  var exporting_instance = (function() {
    var builder = new WasmModuleBuilder();
    var binary_type = builder.addType(kSig_i_ii);

    builder.addFunction('addition', kSig_i_ii)
        .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
        .exportFunc();

    builder.addFunction('succ', kSig_i_i)
        .addBody([kExprLocalGet, 0, kExprI32Const, 1, kExprI32Add])
        .exportFunc();

    builder.addTable(wasmRefNullType(binary_type), 1, 100).exportAs('table');

    return builder.instantiate({});
  })();

  // Wrong type for imported table.
  assertThrows(() => {
    var builder = new WasmModuleBuilder();
    var unary_type = builder.addType(kSig_i_i);
    builder.addImportedTable(
        'imports', 'table', 1, 100, wasmRefNullType(unary_type));
    builder.instantiate({imports: {table: exporting_instance.exports.table}})
  }, WebAssembly.LinkError, /imported table does not match the expected type/);

  // Type for imported table must match exactly.
  assertThrows(() => {
    var builder = new WasmModuleBuilder();
    builder.addImportedTable('imports', 'table', 1, 100, kWasmFuncRef);
    builder.instantiate({imports: {table: exporting_instance.exports.table}})
  }, WebAssembly.LinkError, /imported table does not match the expected type/);

  var instance = (function() {
    var builder = new WasmModuleBuilder();

    var unary_type = builder.addType(kSig_i_i);
    var binary_type = builder.addType(kSig_i_ii);

    builder.addImportedTable(
        'imports', 'table', 1, 100, wasmRefNullType(binary_type));

    var table =
        builder.addTable(wasmRefNullType(unary_type), 10).exportAs('table');
    builder.addTable(kWasmFuncRef, 1).exportAs('generic_table');

    builder
        .addFunction(
            'table_test', makeSig([wasmRefType(unary_type)], [kWasmI32]))
        // Set table[0] to input function, then retrieve it and call it.
        .addBody([
          kExprI32Const, 0, kExprLocalGet, 0, kExprTableSet, table.index,
          kExprI32Const, 42, kExprI32Const, 0, kExprTableGet, table.index,
          kExprCallRef, unary_type,
        ])
        .exportFunc();

    // Same, but with table[1] and call_indirect
    builder
        .addFunction(
            'table_indirect_test',
            makeSig([wasmRefType(unary_type)], [kWasmI32]))
        .addBody([
          kExprI32Const, 1, kExprLocalGet, 0, kExprTableSet, table.index,
          kExprI32Const, 42, kExprI32Const, 0, kExprCallIndirect, unary_type,
          table.index
        ])
        .exportFunc();

    // Instantiate with a table of the correct type.
    return builder.instantiate(
        {imports: {table: exporting_instance.exports.table}});
  })();

  // This module is valid.
  assertTrue(!!instance);

  // The correct function reference is preserved when setting it to and getting
  // it back from a table.
  assertEquals(
      43, instance.exports.table_test(exporting_instance.exports.succ));
  // Same for call indirect (the indirect call tables are also set correctly).
  assertEquals(
      43,
      instance.exports.table_indirect_test(exporting_instance.exports.succ));

  // Setting from JS API respects types.
  instance.exports.generic_table.set(0, exporting_instance.exports.succ);
  instance.exports.table.set(0, exporting_instance.exports.succ);
  assertThrows(
      () => instance.exports.table.set(0, exporting_instance.exports.addition),
      TypeError,
      /Argument 1 is invalid for table: assigned exported function has to be a subtype of the expected type/);
})();

(function TestNonNullableTables() {
  print(arguments.callee.name);
  var builder = new WasmModuleBuilder();

  var binary_type = builder.addType(kSig_i_ii);

  var addition = builder.addFunction('addition', binary_type).addBody([
    kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add
  ]);
  var subtraction =
      builder.addFunction('subtraction', binary_type)
          .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Sub])
          .exportFunc();

  var table = builder.addTable(wasmRefType(binary_type), 3, 3,
                               [kExprRefFunc, addition.index]);

  builder.addFunction('init', kSig_v_v)
      .addBody([
        kExprI32Const, 1, kExprRefFunc, subtraction.index, kExprTableSet,
        table.index
      ])
      .exportFunc();

  // (index, arg1, arg2) -> table[index](arg1, arg2)
  builder.addFunction('table_test', kSig_i_iii)
      .addBody([
        kExprLocalGet, 1, kExprLocalGet, 2, kExprLocalGet, 0, kExprCallIndirect,
        binary_type, table.index
      ])
      .exportFunc();

  var instance = builder.instantiate({});

  assertTrue(!!instance);

  instance.exports.init();
  assertEquals(44, instance.exports.table_test(0, 33, 11));
  assertEquals(22, instance.exports.table_test(1, 33, 11));
})();

(function TestAnyRefTable() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let array_type = builder.addArray(kWasmI32);
  let struct_type = builder.addStruct([makeField(kWasmI32, false)]);

  let table = builder.addTable(kWasmAnyRef, 4, 4);
  builder.addActiveElementSegment(
    table, wasmI32Const(0),
    [[...wasmI32Const(111), ...wasmI32Const(222),
      kGCPrefix, kExprArrayNewFixed, array_type, 2],
     [...wasmI32Const(-31), kGCPrefix, kExprRefI31],
     [...wasmI32Const(10), kGCPrefix, kExprStructNew, struct_type],
     [kExprRefNull, kEqRefCode]],
    kWasmAnyRef);

  // return ...static_cast<array_type>(table[0])
  builder.addFunction("array_getter", kSig_ii_v)
    .addLocals(wasmRefNullType(array_type), 1)
    .addBody([
      kExprI32Const, 0, kExprTableGet, 0,
      kGCPrefix, kExprRefCast, array_type,
      kExprLocalSet, 0,
      kExprLocalGet, 0,
      ...wasmI32Const(0), kGCPrefix, kExprArrayGet, array_type,
      kExprLocalGet, 0,
      ...wasmI32Const(1), kGCPrefix, kExprArrayGet, array_type])
    .exportFunc();

  // return static_cast<i31>(table[1])
  builder.addFunction("i31_getter", kSig_i_v)
   .addBody([
     kExprI32Const, 1, kExprTableGet, 0,
     kGCPrefix, kExprRefCast, kI31RefCode,
     kGCPrefix, kExprI31GetS])
   .exportFunc();

  // return static_cast<struct_type>(table[2]).field_0
  builder.addFunction("struct_getter", kSig_i_v)
    .addBody([
      kExprI32Const, 2, kExprTableGet, 0,
      kGCPrefix, kExprRefCast, struct_type,
      kGCPrefix, kExprStructGet, struct_type, 0])
    .exportFunc();

  // return table[3] == null
  builder.addFunction("null_getter", kSig_i_v)
    .addBody([kExprI32Const, 3, kExprTableGet, 0, kExprRefIsNull])
    .exportFunc();

  let instance = builder.instantiate({});

  assertTrue(!!instance);

  assertEquals([111, 222], instance.exports.array_getter());
  assertEquals(-31, instance.exports.i31_getter());
  assertEquals(10, instance.exports.struct_getter());
  assertEquals(1, instance.exports.null_getter());
})();

(function TestAnyRefTableNotNull() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let array_type = builder.addArray(kWasmI32);
  let struct_type = builder.addStruct([makeField(kWasmI32, false)]);

  let table = builder.addTable(wasmRefType(kWasmAnyRef), 3, 6,
      [...wasmI32Const(111), ...wasmI32Const(222),
       kGCPrefix, kExprArrayNewFixed, array_type, 2])
    .exportAs("table");
  builder.addActiveElementSegment(
    table, wasmI32Const(0),
    [[...wasmI32Const(111), ...wasmI32Const(222),
      kGCPrefix, kExprArrayNewFixed, array_type, 2],
     [...wasmI32Const(-31), kGCPrefix, kExprRefI31],
     [...wasmI32Const(10), kGCPrefix, kExprStructNew, struct_type]],
     wasmRefType(kWasmAnyRef));

  // return ...cast<array_type>(table.get(0))
  builder.addFunction("array_getter", kSig_ii_v)
    .addLocals(wasmRefNullType(array_type), 1)
    .addBody([
      kExprI32Const, 0, kExprTableGet, 0,
      kGCPrefix, kExprRefCast, array_type,
      kExprLocalSet, 0,
      kExprLocalGet, 0,
      ...wasmI32Const(0), kGCPrefix, kExprArrayGet, array_type,
      kExprLocalGet, 0,
      ...wasmI32Const(1), kGCPrefix, kExprArrayGet, array_type])
    .exportFunc();

  // return cast<i31>(table.get(1))
  builder.addFunction("i31_getter", kSig_i_v)
   .addBody([
     kExprI32Const, 1, kExprTableGet, 0,
     kGCPrefix, kExprRefCast, kI31RefCode,
     kGCPrefix, kExprI31GetS])
   .exportFunc();

  // return cast<struct_type>(table.get(param<0>))[0]
  builder.addFunction("struct_getter", kSig_i_i)
    .addBody([
      kExprLocalGet, 0, kExprTableGet, 0,
      kGCPrefix, kExprRefCast, struct_type,
      kGCPrefix, kExprStructGet, struct_type, 0])
    .exportFunc();

  builder.addFunction("grow_table", kSig_v_v)
    .addBody([
      ...wasmI32Const(20), kGCPrefix, kExprStructNew, struct_type,
      kExprI32Const, 1,
      kNumericPrefix, kExprTableGrow, 0,
      kExprDrop,
    ])
    .exportFunc();

  builder.addFunction("create_struct", makeSig([kWasmI32], [kWasmExternRef]))
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprStructNew, struct_type,
      kGCPrefix, kExprExternConvertAny,
    ])
    .exportFunc();

  let instance = builder.instantiate({});
  let wasmTable = instance.exports.table;

  assertEquals([111, 222], instance.exports.array_getter());
  assertEquals(-31, instance.exports.i31_getter());
  assertEquals(10, instance.exports.struct_getter(2));
  assertTraps(kTrapTableOutOfBounds, () => instance.exports.struct_getter(3));
  instance.exports.grow_table();
  assertEquals(20, instance.exports.struct_getter(3));
  assertThrows(() => wasmTable.grow(1), TypeError,
               /Argument 1 must be specified for non-nullable element type/);
  wasmTable.grow(1, instance.exports.create_struct(33));
  assertEquals(33, instance.exports.struct_getter(4));
  // undefined is ok for (ref any), but not null.
  wasmTable.set(4, undefined);
  assertThrows(() => wasmTable.set(4, null), TypeError,
               /Argument 1 is invalid/);
})();

(function TestStructRefTable() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let struct_type = builder.addStruct([makeField(kWasmI32, false)]);

  let table = builder.addTable(wasmRefNullType(struct_type), 4, 4);
  builder.addActiveElementSegment(
    table, wasmI32Const(0),
    [[...wasmI32Const(10), kGCPrefix, kExprStructNew, struct_type],
     [...wasmI32Const(11), kGCPrefix, kExprStructNew, struct_type],
     [kExprRefNull, struct_type]],
     wasmRefNullType(struct_type));

  builder.addFunction("struct_getter", kSig_i_i)
    .addBody([
      kExprLocalGet, 0, kExprTableGet, 0,
      kGCPrefix, kExprStructGet, struct_type, 0])
    .exportFunc();

  builder.addFunction("null_getter", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprTableGet, 0, kExprRefIsNull])
    .exportFunc();

  let instance = builder.instantiate({});
  assertTrue(!!instance);

  assertEquals(10, instance.exports.struct_getter(0));
  assertEquals(11, instance.exports.struct_getter(1));
  assertEquals(1, instance.exports.null_getter(2));
})();

(function TestI31RefTable() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let table = builder.addTable(kWasmI31Ref, 4, 4);
  builder.addActiveElementSegment(
    table, wasmI32Const(0),
    [[...wasmI32Const(10), kGCPrefix, kExprRefI31],
     [...wasmI32Const(-42), kGCPrefix, kExprRefI31],
     [kExprRefNull, kI31RefCode]],
     kWasmI31Ref);

  builder.addFunction("i31GetI32", kSig_i_i)
    .addBody([
      kExprLocalGet, 0, kExprTableGet, 0,
      kGCPrefix, kExprI31GetS])
    .exportFunc();

  builder.addFunction("i31GetNull", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprTableGet, 0, kExprRefIsNull])
    .exportFunc();

  let instance = builder.instantiate({});
  assertTrue(!!instance);

  assertEquals(0, instance.exports.i31GetNull(0));
  assertEquals(0, instance.exports.i31GetNull(1));
  assertEquals(1, instance.exports.i31GetNull(2));
  assertEquals(1, instance.exports.i31GetNull(3));
  assertEquals(10, instance.exports.i31GetI32(0));
  assertEquals(-42, instance.exports.i31GetI32(1));
  assertTraps(kTrapNullDereference, () => instance.exports.i31GetI32(2));
  assertTraps(kTrapNullDereference, () => instance.exports.i31GetI32(3));
})();

(function TestArrayRefTable() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let array_type = builder.addArray(kWasmI32);

  let table = builder.addTable(wasmRefNullType(array_type), 4, 4);
  builder.addActiveElementSegment(
    table, wasmI32Const(0),
    [[...wasmI32Const(10), ...wasmI32Const(11), ...wasmI32Const(12),
      kGCPrefix, kExprArrayNewFixed, array_type, 3],
     [kGCPrefix, kExprArrayNewFixed, array_type, 0],
     [kExprRefNull, array_type]],
     wasmRefNullType(array_type));

  builder.addFunction("array_getter", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0, kExprTableGet, 0,
      kExprLocalGet, 1,
      kGCPrefix, kExprArrayGet, array_type])
    .exportFunc();

  builder.addFunction("null_getter", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprTableGet, 0, kExprRefIsNull])
    .exportFunc();

  let instance = builder.instantiate({});
  assertTrue(!!instance);

  assertEquals(10, instance.exports.array_getter(0, 0));
  assertEquals(11, instance.exports.array_getter(0, 1));
  assertEquals(12, instance.exports.array_getter(0, 2));
  assertEquals(0, instance.exports.null_getter(1));
  assertTraps(kTrapArrayOutOfBounds,
              () => instance.exports.array_getter(1, 0));
  assertEquals(1, instance.exports.null_getter(2));
})();

(function TestRefTableInvalidSegmentType() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let struct_type_a = builder.addStruct([makeField(kWasmI32, false)]);
  let struct_type_b = builder.addStruct([makeField(kWasmI64, false)]);

  let table = builder.addTable(wasmRefNullType(struct_type_a), 4, 4);
  builder.addActiveElementSegment(
    table, wasmI32Const(0),
    [[...wasmI32Const(10), kGCPrefix, kExprStructNew, struct_type_b]],
     wasmRefNullType(struct_type_b)); // Mismatches table type.

  assertThrows(() => builder.instantiate({}),
               WebAssembly.CompileError,
               /Element segment .* is not a subtype of referenced table/);
})();

(function TestRefTableInvalidSegmentExpressionType() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let struct_type_a = builder.addStruct([makeField(kWasmI32, false)]);
  let struct_type_b = builder.addStruct([makeField(kWasmI64, false)]);

  let table = builder.addTable(wasmRefNullType(struct_type_a), 4, 4);
  builder.addActiveElementSegment(
    table, wasmI32Const(0),
    [[...wasmI64Const(10), kGCPrefix, kExprStructNew, struct_type_b]],
     wasmRefNullType(struct_type_a));

  assertThrows(() => builder.instantiate({}),
               WebAssembly.CompileError,
               /expected \(ref null 0\), got \(ref 1\)/);
})();

(function TestMultiModuleRefTableEquivalentTypes() {
  print(arguments.callee.name);
  let exporting_instance = (() => {
    let builder = new WasmModuleBuilder();
    let struct_type = builder.addStruct([makeField(kWasmI32, false)]);
    builder.addTable(wasmRefNullType(struct_type), 1, 100).exportAs('table');
    return builder.instantiate({});
  })();

  // Mismatching struct definition.
  assertThrows(() => {
    let builder = new WasmModuleBuilder();
    let struct_type = builder.addStruct([makeField(kWasmI64, false)]);
    builder.addImportedTable(
        'imports', 'table', 1, 100, wasmRefNullType(struct_type));
    builder.instantiate({imports: {table: exporting_instance.exports.table}})
  }, WebAssembly.LinkError, /imported table does not match the expected type/);

  // Mismatching nullability.
  assertThrows(() => {
    let builder = new WasmModuleBuilder();
    let struct_type = builder.addStruct([makeField(kWasmI32, false)]);
    builder.addImportedTable(
        'imports', 'table', 1, 100, wasmRefType(struct_type));
    builder.instantiate({imports: {table: exporting_instance.exports.table}})
  }, WebAssembly.LinkError, /imported table does not match the expected type/);

  // Equivalent struct type.
  let builder = new WasmModuleBuilder();
  let struct_type = builder.addStruct([makeField(kWasmI32, false)]);
  let struct_type_invalid = builder.addStruct([makeField(kWasmI64, false)]);
  let struct_type_sub = builder.addStruct(
      [makeField(kWasmI32, false), makeField(kWasmI32, false)], struct_type);
  builder.addImportedTable(
      'imports', 'table', 1, 100, wasmRefNullType(struct_type));

  builder.addFunction("invalid_struct", makeSig([], [kWasmExternRef]))
    .addBody([
      kExprI64Const, 44,
      kGCPrefix, kExprStructNew, struct_type_invalid,
      kGCPrefix, kExprExternConvertAny])
    .exportFunc();

  builder.addFunction("valid_struct", makeSig([], [kWasmExternRef]))
    .addBody([
      kExprI32Const, 44,
      kGCPrefix, kExprStructNew, struct_type,
      kGCPrefix, kExprExternConvertAny])
    .exportFunc();

    builder.addFunction("valid_struct_sub", makeSig([], [kWasmExternRef]))
    .addBody([
      kExprI32Const, 55,
      kExprI32Const, 66,
      kGCPrefix, kExprStructNew, struct_type_sub,
      kGCPrefix, kExprExternConvertAny])
    .exportFunc();

  let table = exporting_instance.exports.table;
  let instance = builder.instantiate({imports: {table}});

  assertThrows(() => table.grow(5, undefined), TypeError);
  table.grow(5);
  assertThrows(() => table.set(1, instance.exports.invalid_struct()),
               TypeError);
  table.set(1, instance.exports.valid_struct());
  table.set(2, instance.exports.valid_struct_sub());
  table.set(3, null);
  assertThrows(() => table.set(1, undefined), TypeError);
})();

(function TestMultiModuleRefTableSuperType() {
  print(arguments.callee.name);
  let exporting_instance = (() => {
    let builder = new WasmModuleBuilder();
    let struct_type_base = builder.addStruct([makeField(kWasmI32, false)]);
    let struct_type =
        builder.addStruct([makeField(kWasmI32, false)], struct_type_base);
    builder.addTable(wasmRefNullType(struct_type), 1, 100).exportAs('table');
    return builder.instantiate({});
  })();

  let builder = new WasmModuleBuilder();
  let struct_type_base = builder.addStruct([makeField(kWasmI32, false)]);
  let struct_type =
      builder.addStruct([makeField(kWasmI32, false)], struct_type_base);
  builder.addImportedTable(
      'imports', 'table', 1, 100, wasmRefNullType(struct_type));

  builder.addFunction("struct_base", makeSig([], [kWasmExternRef]))
    .addBody([
      kExprI32Const, 66,
      kGCPrefix, kExprStructNew, struct_type_base,
      kGCPrefix, kExprExternConvertAny])
    .exportFunc();

  let table = exporting_instance.exports.table;
  let instance = builder.instantiate({imports: {table}});
  assertThrows(() => table.set(0, instance.exports.struct_base()), TypeError);
  assertThrows(() => table.grow(1, instance.exports.struct_base()), TypeError);
})();

(function TestRefTableNotNull() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct_type = builder.addStruct([makeField(kWasmI32, false)]);
  let table = builder.addTable(wasmRefType(struct_type), 2, 6,
      [...wasmI32Const(111),
       kGCPrefix, kExprStructNew, struct_type])
    .exportAs("table");

  builder.addFunction("create_struct", makeSig([kWasmI32], [kWasmExternRef]))
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprStructNew, struct_type,
      kGCPrefix, kExprExternConvertAny,
    ])
    .exportFunc();

  builder.addFunction("struct_getter", kSig_i_i)
    .addBody([
      kExprLocalGet, 0, kExprTableGet, 0,
      kGCPrefix, kExprStructGet, struct_type, 0])
    .exportFunc();

  let instance = builder.instantiate({});
  let wasmTable = instance.exports.table;

  // Initial values.
  assertEquals(111, instance.exports.struct_getter(0));
  assertEquals(111, instance.exports.struct_getter(1));
  assertTraps(kTrapTableOutOfBounds, () => instance.exports.struct_getter(2));

  assertThrows(() => wasmTable.grow(1), TypeError,
               /Argument 1 must be specified for non-nullable element type/);
  wasmTable.grow(1, instance.exports.create_struct(222));
  assertEquals(222, instance.exports.struct_getter(2));
  assertThrows(() => wasmTable.set(2, undefined), TypeError,
               /Argument 1 is invalid/);
  assertThrows(() => wasmTable.set(2, null), TypeError,
               /Argument 1 is invalid/);
  wasmTable.set(2, instance.exports.create_struct(333));
  assertEquals(333, instance.exports.struct_getter(2));
})();

(function TestTypedTableCallIndirect() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();

  let super_struct = builder.addStruct([makeField(kWasmI32, false)]);
  let sub_struct = builder.addStruct(
    [makeField(kWasmI32, false), makeField(kWasmI32, false)], super_struct);
  let super_sig = builder.addType(
    makeSig([kWasmI32], [wasmRefType(super_struct)]), kNoSuperType, false);
  let sub_sig = builder.addType(
    makeSig([kWasmI32], [wasmRefType(sub_struct)]), super_sig);

  let super_func = builder.addFunction("super_func", super_sig)
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprStructNew, super_struct]);
  let sub_func = builder.addFunction("super_func", sub_sig)
    .addBody([kExprLocalGet, 0, kExprI32Const, 1, kExprI32Add,
              kExprLocalGet, 0, kExprI32Const, 2, kExprI32Add,
              kGCPrefix, kExprStructNew, sub_struct]);

  let table = builder.addTable(wasmRefNullType(super_sig), 10, 10);
  builder.addActiveElementSegment(
    table.index, wasmI32Const(0),
    [[kExprRefFunc, super_func.index], [kExprRefFunc, sub_func.index]],
    wasmRefType(super_sig));

  // Parameters: index, value.
  builder.addFunction("call_indirect_super", kSig_i_ii)
    .addBody([kExprLocalGet, 1, kExprLocalGet, 0,
              kExprCallIndirect, super_sig, table.index,
              kGCPrefix, kExprStructGet, super_struct, 0])
    .exportFunc();
  builder.addFunction("call_indirect_sub", kSig_i_ii)
    .addBody([kExprLocalGet, 1, kExprLocalGet, 0,
              kExprCallIndirect, sub_sig, table.index,
              kGCPrefix, kExprStructGet, sub_struct, 0])
    .exportFunc();

  let instance = builder.instantiate();

  // No type check needed, null check needed.
  assertEquals(10, instance.exports.call_indirect_super(0, 10));
  assertEquals(11, instance.exports.call_indirect_super(1, 10));
  assertTraps(kTrapFuncSigMismatch,
              () => instance.exports.call_indirect_super(2, 10));
  // Type check and null check needed.
  assertEquals(11, instance.exports.call_indirect_sub(1, 10));
  assertTraps(kTrapFuncSigMismatch,
              () => instance.exports.call_indirect_sub(0, 10));
  assertTraps(kTrapFuncSigMismatch,
              () => instance.exports.call_indirect_sub(2, 10));
})();
                                        node-23.7.0/deps/v8/test/mjsunit/wasm/regress-367818758.js                                          0000664 0000000 0000000 00000014762 14746647661 0022530 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// Flags: --allow-natives-syntax

var kWasmH0 = 0;
var kWasmH1 = 0x61;
var kWasmH2 = 0x73;
var kWasmH3 = 0x6d;
var kWasmV0 = 0x1;
var kWasmV1 = 0;
var kWasmV2 = 0;
var kWasmV3 = 0;
let kTypeSectionCode = 1;        // Function signature declarations
let kFunctionSectionCode = 3;    // Function declarations
let kExportSectionCode = 7;      // Exports
let kCodeSectionCode = 10;       // Function code
let kWasmFunctionTypeForm = 0x60;
let kWasmStructTypeForm = 0x5f;
let kNoSuperType = 0xFFFFFFFF;
let kWasmI32 = 0x7f;
let kWasmExternRef = -0x11;
let kLeb128Mask = 0x7f;
let kExternalFunction = 0;
function makeSig(params, results) {
  return {params: params, results: results};
}
const kWasmOpcodes = {
  'End': 0x0b,
  'I32Const': 0x41,
};
function defineWasmOpcode(name, value) {
  Object.defineProperty(globalThis, name, {value: value});
}
for (let name in kWasmOpcodes) {
  defineWasmOpcode(`kExpr${name}`, kWasmOpcodes[name]);
}
const kPrefixOpcodes = {
  'GC': 0xfb,
};
for (let prefix in kPrefixOpcodes) {
  defineWasmOpcode(`k${prefix}Prefix`, kPrefixOpcodes[prefix]);
}
let kExprStructNew = 0x00;
let kExprExternConvertAny = 0x1b;
class Binary {
  constructor() {
    this.length = 0;
    this.buffer = new Uint8Array(8192);
  }
  trunc_buffer() {
    return new Uint8Array(this.buffer.buffer, 0, this.length);
  }
  emit_u8(val) {
    this.buffer[this.length++] = val;
  }
  emit_leb_u(val) {
      let v = val & 0xff;
        this.buffer[this.length++] = v;
  }
  emit_u32v(val) {
    this.emit_leb_u(val);
  }
  emit_bytes(data) {
    this.buffer.set(data, this.length);
    this.length += data.length;
  }
  emit_string(string) {
    let string_utf8 = string;
    this.emit_u32v(string_utf8.length);
    for (let i = 0; i < string_utf8.length; i++) {
      this.emit_u8(string_utf8.charCodeAt(i));
    }
  }
  emit_type(type) {
      this.emit_u8(type >= 0 ? type : type & kLeb128Mask);
  }
  emit_header() {
    this.emit_bytes([
      kWasmH0, kWasmH1, kWasmH2, kWasmH3, kWasmV0, kWasmV1, kWasmV2, kWasmV3
    ]);
  }
  emit_section(section_code, content_generator) {
    this.emit_u8(section_code);
    const section = new Binary;
    content_generator(section);
    this.emit_u32v(section.length);
    this.emit_bytes(section.trunc_buffer());
  }
}
class WasmFunctionBuilder {
  constructor(module, name, type_index, arg_names) {
    this.module = module;
    this.name = name;
    this.type_index = type_index;
  }
  exportAs(name) {
    this.module.addExport(name, this.index);
  }
  exportFunc() {
    this.exportAs(this.name);
    return this;
  }
  addBody(body) {
    this.body = body.concat([kExprEnd]);
  }
}
function makeField(type, mutability) {
  return {type: type, mutability: mutability};
}
class WasmStruct {
  constructor(fields) {
    this.fields = fields;
  }
}
class WasmModuleBuilder {
  constructor() {
    this.types = [];
    this.exports = [];
    this.functions = [];
  }
  addType(type, supertype_idx = kNoSuperType, is_final = true,
      is_shared = false) {
    var type_copy = {params: type.params, results: type.results,
                     is_final: is_final, is_shared: is_shared,
                     supertype: supertype_idx};
    this.types.push(type_copy);
    return this.types.length - 1;
  }
  addStruct(fields = kNoSuperType = false, is_shared = false) {
    this.types.push(new WasmStruct(fields));
  }
  addFunction(name, type, arg_names) {
    let type_index =typeof type == 'number' ? type : this.addType(type);
    let func = new WasmFunctionBuilder(this, name, type_index);
    this.functions.push(func);
    return func;
  }
  addExport(name, index) {
    this.exports.push({name: name, kind: kExternalFunction, index: index});
  }
  toBuffer() {
    let binary = new Binary;
    let wasm = this;
    binary.emit_header();
      binary.emit_section(kTypeSectionCode, section => {
        let length_with_groups = wasm.types.length;
        section.emit_u32v(length_with_groups);
        for (let i = 0; i < wasm.types.length; i++) {
          let type = wasm.types[i];
          if (type instanceof WasmStruct) {
            section.emit_u8(kWasmStructTypeForm);
            section.emit_u32v(type.fields.length);
            for (let field of type.fields) {
              section.emit_type(field.type);
              section.emit_u8();
            }
          } else {
            section.emit_u8(kWasmFunctionTypeForm);
            section.emit_u32v();
            section.emit_u32v(type.results.length);
            for (let result of type.results) {
              section.emit_type(result);
            }
          }
        }
      });
      binary.emit_section(kFunctionSectionCode, section => {
        section.emit_u32v(wasm.functions.length);
        for (let func of wasm.functions) {
          section.emit_u32v(func.type_index);
        }
      });
    var exports_count = wasm.exports.length;
      binary.emit_section(kExportSectionCode, section => {
        section.emit_u32v(exports_count);
        for (let exp of wasm.exports) {
          section.emit_string(exp.name);
          section.emit_u8();
          section.emit_u32v();
        }
      });
      binary.emit_section(kCodeSectionCode, section => {
        section.emit_u32v(wasm.functions.length);
        for (let func of wasm.functions) {
            section.emit_u32v(func.body.length + 1);
            section.emit_u8();  // 0 locals.
          section.emit_bytes(func.body);
        }
      });
    return binary.trunc_buffer();
  }
  instantiate() {
    let module = this.toModule();
    let instance = new WebAssembly.Instance(module);
    return instance;
  }
  toModule() {
    return new WebAssembly.Module(this.toBuffer());
  }
}
let builder = new WasmModuleBuilder();
let struct_type = builder.addStruct([makeField(kWasmI32)]);
builder.addFunction('MakeStruct', makeSig([], [kWasmExternRef])).exportFunc()
       .addBody([kExprI32Const, 42, kGCPrefix, kExprStructNew, struct_type,
                 kGCPrefix, kExprExternConvertAny]);
let instance = builder.instantiate();
let evil_wasm_object = instance.exports.MakeStruct();
function evil_ctor(){
}
function evil_cast_jit(evil_o){
    global_collect_node_info = evil_o; // get nodeinfo from PropertyCellStore
    return evil_o instanceof evil_ctor;
}
evil_ctor.prototype = evil_wasm_object;
%PrepareFunctionForOptimization(evil_cast_jit);
evil_cast_jit(new evil_ctor());
evil_cast_jit(new evil_ctor());
%OptimizeFunctionOnNextCall(evil_cast_jit);
evil_cast_jit();
              node-23.7.0/deps/v8/test/mjsunit/wasm/resizablearraybuffer-growablesharedarraybuffer-wasm.js        0000664 0000000 0000000 00000000670 14746647661 0032423 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

(function TestMemoryBufferNotResizable() {
  const m = new WebAssembly.Memory({
    initial: 128
  });

  assertFalse(m.buffer.resizable);
  // For non-resizable buffers, maxByteLength returns byteLength.
  assertEquals(m.buffer.maxByteLength, m.buffer.byteLength);
})();
                                                                        node-23.7.0/deps/v8/test/mjsunit/wasm/return-calls-eh.js                                            0000664 0000000 0000000 00000010220 14746647661 0023022 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");
d8.file.execute("test/mjsunit/wasm/exceptions-utils.js");

// Check that exceptions thrown by a return_call cannot be caught inside the
// frame that does the call.
(function TryReturnCallCatch() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  let throw_ = builder.addFunction("throw", kSig_v_v)
      .addBody([kExprThrow, except]);
  builder.addFunction("try_return_call", kSig_v_v)
      .addBody([
        kExprTry, kWasmVoid,
          kExprReturnCall, throw_.index,
        kExprCatch, except,
        kExprEnd
      ]).exportFunc();
  let instance = builder.instantiate();
  assertWasmThrows(instance, except, [], () => instance.exports.try_return_call());
})();

// Check that exceptions thrown by a return_call_indirect cannot be caught
// inside the frame that does the call.
(function TryReturnCallIndirectCatch() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  let sig = builder.addType(kSig_v_v);
  let throw_ = builder.addFunction("throw", kSig_v_v)
      .addBody([kExprThrow, except]);
  let table = builder.addTable(kWasmAnyFunc, 1, 1);
  builder.addActiveElementSegment(table.index, wasmI32Const(0), [0]);
  builder.addFunction("try_return_call_indirect", kSig_v_v)
      .addBody([
        kExprTry, kWasmVoid,
          kExprI32Const, throw_.index,
          kExprReturnCallIndirect, sig, 0,
        kExprCatch, except,
        kExprEnd
      ]).exportFunc();
  let instance = builder.instantiate();
  assertWasmThrows(instance, except, [], () => instance.exports.try_return_call_indirect());
})();

// Check that exceptions thrown by a return_call cannot be delegated inside the
// frame that does the call.
(function TryReturnCallDelegate() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  let throw_ = builder.addFunction("throw", kSig_v_v)
      .addBody([kExprThrow, except]);
  builder.addFunction("try_return_call_delegate", kSig_v_v)
      .addBody([
        kExprTry, kWasmVoid,
          kExprTry, kWasmVoid,
            kExprReturnCall, throw_.index,
          kExprDelegate, 0,
        kExprCatch, except,
        kExprEnd
      ]).exportFunc();
  let instance = builder.instantiate();
  assertWasmThrows(instance, except, [], () => instance.exports.try_return_call_delegate());
})();

// Check that exceptions thrown by a return_call to a JS import cannot be caught
// inside the frame that does the call.
(function TryReturnCallImportJSCatch() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let throw_import = builder.addImport("m", "throw_", kSig_v_v);
  let except = builder.addTag(kSig_v_v);
  builder.addExportOfKind("ex", kExternalTag, except);
  builder.addFunction("return_call", kSig_v_v)
      .addBody([
          kExprTry, kWasmVoid,
            kExprReturnCall, throw_import,
          kExprCatchAll,
          kExprEnd
      ]).exportFunc();
  let throw_ = () => { throw new WebAssembly.Exception(instance.exports.ex, []); };
  let instance = builder.instantiate({m: {throw_}});
  assertWasmThrows(instance, except, [], () => instance.exports.return_call());
})();

// Check that the exception can be caught in the caller's caller.
(function TryReturnCallCatchInCaller() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let except = builder.addTag(kSig_v_v);
  let throw_ = builder.addFunction("throw", kSig_v_v)
      .addBody([kExprThrow, except]);
  builder.addFunction("caller", kSig_v_v)
      .addBody([
          kExprTry, kWasmVoid,
            kExprCallFunction, 2,
          kExprCatch, except,
          kExprEnd
      ]).exportFunc();
  builder.addFunction("return_call", kSig_v_v)
      .addBody([
          kExprReturnCall, throw_.index,
      ]);
  let instance = builder.instantiate();
  assertDoesNotThrow(() => instance.exports.caller());
})();
                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/wasm/return-calls.js                                               0000664 0000000 0000000 00000013343 14746647661 0022441 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Reduce the stack size to test that we are indeed doing return calls (instead
// of standard calls which consume stack space).
// Flags: --stack-size=128

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestFactorialReturnCall() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();

  const sig_i_iii = builder.addType(kSig_i_iii);

  // construct the code for the function
  // f_aux(N,X) where N=<1 => X
  // f_aux(N,X) => f_aux(N-1,X*N)
  let fact_aux = builder.addFunction("fact_aux",kSig_i_ii);
  fact_aux.addBody([
    kExprLocalGet, 0, kExprI32Const, 1, kExprI32LeS,
    kExprIf, kWasmI32,
      kExprLocalGet, 1,
    kExprElse,
      kExprLocalGet, 0,
      kExprI32Const, 1,
      kExprI32Sub,
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI32Mul,
      kExprReturnCall, fact_aux.index,
    kExprEnd
      ]);

  //main(N)=>fact_aux(N,1)
  let main = builder.addFunction("main", kSig_i_i)
        .addBody([
          kExprLocalGet, 0,
          kExprI32Const, 1,
          kExprReturnCall,0
    ]).exportFunc();

  let module = builder.instantiate();

  print(" --three--");
  assertEquals(6, module.exports.main(3));
  print(" --four--");
  assertEquals(24, module.exports.main(4));
})();

(function TestIndirectFactorialReturnCall() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();

  const sig_i_iii = builder.addType(kSig_i_iii);

  // construct the code for the function
  // fact(N) => f_ind(N,1,f).
  //
  // f_ind(N,X,_) where N=<1 => X
  // f_ind(N,X,F) => F(N-1,X*N,F).

  let f_ind = builder.addFunction("f_ind",kSig_i_iii).
      addBody([
    kExprLocalGet, 0, kExprI32Const, 1, kExprI32LeS,
    kExprIf, kWasmI32,
      kExprLocalGet, 1,
    kExprElse,
      kExprLocalGet, 0,
      kExprI32Const, 1,
      kExprI32Sub,
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI32Mul,
      kExprLocalGet, 2,
      kExprLocalGet, 2,
      kExprReturnCallIndirect, sig_i_iii, kTableZero,
    kExprEnd
      ]);

  //main(N)=>fact_aux(N,1)
  let main = builder.addFunction("main", kSig_i_i)
        .addBody([
      kExprLocalGet, 0,
      kExprI32Const, 1,
      kExprI32Const, f_ind.index,
      kExprReturnCall, f_ind.index
    ]).exportFunc();

  builder.appendToTable([f_ind.index, main.index]);

  let module = builder.instantiate();

  print(" --three--");
  assertEquals(6, module.exports.main(3));
  print(" --four--");
  assertEquals(24, module.exports.main(4));
})();

(function TestImportReturnCall() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();

  const sig_i_iii = builder.addType(kSig_i_iii);

  let pick = builder.addImport("q", "pick", sig_i_iii);

  let main = builder.addFunction("main", kSig_i_iii)
        .addBody([
          kExprLocalGet, 1,
          kExprLocalGet, 2,
          kExprLocalGet, 0,
          kExprReturnCall, pick
        ])
        .exportFunc();

  let module = builder.instantiate({q: {
    pick: function(a, b, c) { return c ? a : b; }}});

  print(" --left--");
  assertEquals(-2, module.exports.main(1, -2, 3));
  print(" --right--");
  assertEquals(3, module.exports.main(0, -2, 3));
})();

(function TestImportIndirectReturnCall() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();

  const sig_i_iii = builder.addType(kSig_i_iii);

  let pick = builder.addImport("q", "pick", sig_i_iii);
  builder.addTable(kWasmAnyFunc, 4);
  // Arbitrary location in the table.
  const tableIndex = 3;

  builder.addActiveElementSegment(0, wasmI32Const(tableIndex),[pick]);

  let main = builder.addFunction("main", kSig_i_iii)
        .addBody([
          kExprLocalGet, 1,
          kExprLocalGet, 2,
          kExprLocalGet, 0,
          kExprI32Const, tableIndex,
          kExprReturnCallIndirect, sig_i_iii, kTableZero
        ])
        .exportFunc();
  builder.appendToTable([pick, main.index]);

  let module = builder.instantiate({q: {
    pick: function(a, b, c) { return c ? a : b; }
  }});

  print(" --left--");
  assertEquals(-2, module.exports.main(1, -2, 3));
  print(" --right--");
  assertEquals(3, module.exports.main(0, -2, 3));
})();

(function TestMultiReturnCallWithLongSig() {
  print(arguments.callee.name);
  const callee_inputs = 10;
  // Tail call from a function with less, as many, or more parameters than the
  // callee.
  for (caller_inputs = 9; caller_inputs <= 11; ++caller_inputs) {
    let builder = new WasmModuleBuilder();

    // f just returns its arguments in reverse order.
    const f_params = new Array(callee_inputs).fill(kWasmI32);
    const f_returns = f_params;
    const f_sig = builder.addType(makeSig(f_params, f_returns));
    let f_body = [];
    for (i = 0; i < callee_inputs; ++i) {
      f_body.push(kExprLocalGet, callee_inputs - i - 1);
    }
    const f = builder.addFunction("f", f_sig).addBody(f_body);

    // Slice or pad the caller inputs to match the callee.
    const main_params = new Array(caller_inputs).fill(kWasmI32);
    const main_sig = builder.addType(makeSig(main_params, f_returns));
    let main_body = [];
    for (i = 0; i < callee_inputs; ++i) {
      main_body.push(kExprLocalGet, Math.min(caller_inputs - 1, i));
    }
    main_body.push(kExprReturnCall, f.index);
    builder.addFunction("main", main_sig).addBody(main_body).exportFunc();

    let module = builder.instantiate();

    inputs = [];
    for (i = 0; i < caller_inputs; ++i) {
      inputs.push(i);
    }
    let expect = inputs.slice(0, callee_inputs);
    while (expect.length < callee_inputs) {
      expect.push(inputs[inputs.length - 1]);
    }
    expect.reverse();
    assertEquals(expect, module.exports.main(...inputs));
  }
})();
                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/runtime-gc-objects.js                                         0000664 0000000 0000000 00000001655 14746647661 0023532 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestDeoptMinimalCallRef() {
  var builder = new WasmModuleBuilder();

  builder.addFunction("isArray", makeSig([kWasmAnyRef], [kWasmI32]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprRefTest, kArrayRefCode])
    .exportFunc();
  builder.addFunction("isStruct", makeSig([kWasmAnyRef], [kWasmI32]))
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprRefTest, kStructRefCode])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  let array = %WasmArray();
  let struct = %WasmStruct();
  assertEquals(1, wasm.isArray(array));
  assertEquals(0, wasm.isArray(struct));
  assertEquals(0, wasm.isStruct(array));
  assertEquals(1, wasm.isStruct(struct));
})();
                                                                                   node-23.7.0/deps/v8/test/mjsunit/wasm/runtime-type-canonicalization.js                              0000664 0000000 0000000 00000005235 14746647661 0026014 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-gc

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

let builder = new WasmModuleBuilder();

let struct_index = builder.addStruct([makeField(kWasmI32, true)]);
let identical_struct_index = builder.addStruct([makeField(kWasmI32, true)]);
let distinct_struct_index = builder.addStruct([makeField(kWasmI64, true)]);

let struct_init = builder.addFunction("struct_init",
                                      makeSig([], [kWasmStructRef]))
    .addBody([kGCPrefix, kExprStructNewDefault, struct_index])
    .exportFunc();
let test_pass = builder.addFunction("test_pass",
                                    makeSig([kWasmStructRef], [kWasmI32]))
    .addBody([kExprLocalGet, 0,
              kGCPrefix, kExprRefTest, identical_struct_index])
    .exportFunc();
let test_fail = builder.addFunction("test_fail",
                                    makeSig([kWasmStructRef], [kWasmI32]))
    .addBody([kExprLocalGet, 0,
              kGCPrefix, kExprRefTest, distinct_struct_index])
    .exportFunc();

(function TestCanonicalizationSameInstance() {
  print(arguments.callee.name);
  let instance = builder.instantiate({});
  assertEquals(1, instance.exports.test_pass(instance.exports.struct_init()));
  assertEquals(0, instance.exports.test_fail(instance.exports.struct_init()));
})();

(function TestCanonicalizationSameModuleDifferentInstances() {
  print(arguments.callee.name);
  let module = builder.toModule();
  let instance1 = new WebAssembly.Instance(module, {});
  let instance2 = new WebAssembly.Instance(module, {});
  assertEquals(1, instance2.exports.test_pass(instance1.exports.struct_init()));
  assertEquals(0, instance2.exports.test_fail(instance1.exports.struct_init()));
})();

// GC between tests so that the type registry is cleared.
gc();

(function TestCanonicalizationDifferentModules() {
  print(arguments.callee.name);
  let instance1 = builder.instantiate({});
  let instance2 = builder.instantiate({});
  assertEquals(1, instance2.exports.test_pass(instance1.exports.struct_init()));
  assertEquals(0, instance2.exports.test_fail(instance1.exports.struct_init()));
})();

(function TestCanonicalizationDifferentModulesAfterGC() {
  print(arguments.callee.name);
  let struct = (function make_struct() {
    return builder.instantiate({}).exports.struct_init();
  })();
  // A the live {struct} object keeps the instance alive.
  gc();
  let instance = builder.instantiate({});
  assertEquals(1, instance.exports.test_pass(struct));
  assertEquals(0, instance.exports.test_fail(struct));
})();
                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/wasm/serialization-with-compilation-hints.js                       0000664 0000000 0000000 00000003221 14746647661 0027305 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --wasm-dynamic-tiering --liftoff
// Flags: --no-wasm-native-module-cache-enabled
// Make the test faster:
// Flags: --wasm-tiering-budget=1000

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

const num_functions = 3;

function create_builder() {
  const builder = new WasmModuleBuilder();
  builder.addImport("foo", "bar", kSig_i_v);
  for (let i = 0; i < num_functions; ++i) {
    builder.addFunction('f' + i, kSig_i_v)
        .addBody(wasmI32Const(i))
        .exportFunc();
  }
  return builder;
}

const wire_bytes = create_builder().toBuffer();

function serializeModule() {
  const module = new WebAssembly.Module(wire_bytes);
  let instance = new WebAssembly.Instance(module, {foo: {bar: () => 1}});
  %WasmTierUpFunction(instance.exports.f1);
  // Execute {f2} once, so that the module knows that this is a used function.
  instance.exports.f2();
  const buff = %SerializeWasmModule(module);
  return buff;
};

const serialized_module = serializeModule();

(function testSerializedModule() {
  print(arguments.callee.name);
  const module = %DeserializeWasmModule(serialized_module, wire_bytes);

  const instance = new WebAssembly.Instance(module, {foo: {bar: () => 1}});

  assertTrue(%IsTurboFanFunction(instance.exports.f1));
  // Busy-wait for `f2` to be compiled with Liftoff.
  while (!%IsLiftoffFunction(instance.exports.f2)) {}
  assertTrue(
      !%IsLiftoffFunction(instance.exports.f0) &&
      !%IsTurboFanFunction(instance.exports.f0));
})();
                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/wasm/serialize-lazy-module.js                                      0000664 0000000 0000000 00000004363 14746647661 0024257 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// The test needs --no-liftoff because we can't serialize and deserialize
// Liftoff code.
// Flags: --wasm-lazy-compilation --allow-natives-syntax --expose-gc
// Flags: --no-liftoff

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function SerializeUncompiledModule() {
  print(arguments.callee.name);
  const [wire_bytes, i1, buff] = (function GenerateInstance() {
    const builder = new WasmModuleBuilder();

    // Add 20 functions.
    for (let i = 0; i < 20; ++i) {
      builder.addFunction('f' + i, kSig_i_i)
          .addBody([kExprI32Const, i])
          .exportFunc();
    }

    const wire_bytes = builder.toBuffer();
    const module = new WebAssembly.Module(wire_bytes);
    // Run one function so that serialization happens.
    let instance = new WebAssembly.Instance(module);
    instance.exports.f3();
    const buff = %SerializeWasmModule(module);
    return [wire_bytes, instance, buff];
  })();

  gc();
  const module = %DeserializeWasmModule(buff, wire_bytes);

  const i2 = new WebAssembly.Instance(module);

  assertEquals(13, i2.exports.f13());
  assertEquals(11, i1.exports.f11());
})();

(function SerializePartlyCompiledModule() {
  print(arguments.callee.name);
  const [wire_bytes, i1, buff] = (function GenerateInstance() {
    const builder = new WasmModuleBuilder();

    // Add 20 functions.
    for (let i = 0; i < 20; ++i) {
      builder.addFunction('f' + i, kSig_i_i)
          .addBody([kExprI32Const, i])
          .exportFunc();
    }

    const wire_bytes = builder.toBuffer();
    const module = new WebAssembly.Module(wire_bytes);
    const i1 = new WebAssembly.Instance(module);
    // Run one function so that serialization happens.
    i1.exports.f3();
    const buff = %SerializeWasmModule(module);

    assertEquals(2, i1.exports.f2());
    assertEquals(11, i1.exports.f11());

    return [wire_bytes, i1, buff];
  })();

  gc();
  const module = %DeserializeWasmModule(buff, wire_bytes);

  const i2 = new WebAssembly.Instance(module);

  assertEquals(13, i2.exports.f13());
  assertEquals(11, i1.exports.f11());
  assertEquals(9, i1.exports.f9());
})();
                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/shared-arraybuffer-worker-simple-gc.js                        0000664 0000000 0000000 00000004121 14746647661 0026761 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-gc

const kNumIterations = 10;

function NewWorker() {
  function workerCode() {
    onmessage = ({data:msg}) => {
      if (msg.memory) postMessage("ack");
      if (msg.quit) postMessage("bye");
      gc();
    }
  }
  return new Worker(workerCode, {type: 'function'});
}

function PingWorker(worker, memory) {
  worker.postMessage({memory: memory});
  assertEquals("ack", worker.getMessage());
  worker.postMessage({quit: true});
  assertEquals("bye", worker.getMessage());
}

function AllocMemory() {
  return new SharedArrayBuffer(1024);
}

function RunSingleWorkerSingleMemoryTest() {
  print(arguments.callee.name);
  let worker = NewWorker();
  let first = AllocMemory();
  for (let i = 0; i < kNumIterations; i++) {
    print(`iteration ${i}`);
    PingWorker(worker, first);
    gc();
  }
  worker.terminate();
}

function RunSingleWorkerTwoMemoryTest() {
  print(arguments.callee.name);
  let worker = NewWorker();
  let first = AllocMemory(), second = AllocMemory();
  for (let i = 0; i < kNumIterations; i++) {
    print(`iteration ${i}`);
    PingWorker(worker, first);
    PingWorker(worker, second);
    gc();
  }
  worker.terminate();
}

function RunSingleWorkerMultipleMemoryTest() {
  print(arguments.callee.name);
  let worker = NewWorker();
  let first = AllocMemory();
  for (let i = 0; i < kNumIterations; i++) {
    print(`iteration ${i}`);
    PingWorker(worker, first);
    PingWorker(worker, AllocMemory());
    gc();
  }
  worker.terminate();
}

function RunMultipleWorkerMultipleMemoryTest() {
  print(arguments.callee.name);
  let first = AllocMemory();
  for (let i = 0; i < kNumIterations; i++) {
    print(`iteration ${i}`);
    let worker = NewWorker();
    PingWorker(worker, first);
    PingWorker(worker, AllocMemory());
    worker.terminate();
    gc();
  }
}

RunSingleWorkerSingleMemoryTest();
RunSingleWorkerTwoMemoryTest();
RunSingleWorkerMultipleMemoryTest();
RunMultipleWorkerMultipleMemoryTest();
                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/wasm/shared-everything/                                            0000775 0000000 0000000 00000000000 14746647661 0023114 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/wasm/shared-everything/basic.js                                    0000664 0000000 0000000 00000047630 14746647661 0024545 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-shared --no-experimental-wasm-inlining

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function SharedGlobal() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let callee_sig = builder.addType(kSig_v_v, kNoSuperType, true, true);
  let sig = builder.addType(kSig_i_i, kNoSuperType, true, true);
  let global = builder.addGlobal(kWasmI32, true, true, [kExprI32Const, 0]);

  let side_effect = builder.addFunction("side_effect", callee_sig).addBody([]);

  builder.addFunction("roundtrip", sig)
    .addBody([kExprLocalGet, 0, kExprGlobalSet, global.index,
              // Adding intermediate side-effect to prevent load elimination.
              kExprCallFunction, side_effect.index,
              kExprGlobalGet, global.index])
    .exportFunc();

  let wasm = builder.instantiate().exports;

  assertEquals(10, wasm.roundtrip(10));
})();

(function SharedGlobalAbstractType() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = builder.addType(kSig_i_i, kNoSuperType, true, false);
  let struct = builder.addStruct(
    [makeField(kWasmI32, true)], kNoSuperType, false, true);
  let global = builder.addGlobal(
    wasmRefNullType(kWasmAnyRef, true), true, true,
    [kExprRefNull, kWasmSharedTypeForm, kAnyRefCode]);

  let side_effect = builder.addFunction("side_effect", kSig_v_v).addBody([]);

  builder.addFunction("roundtrip", sig)
    .addBody([kExprLocalGet, 0, kGCPrefix, kExprStructNew, struct,
              kExprGlobalSet, global.index,
              // Adding intermediate side-effect to prevent load elimination.
              kExprCallFunction, side_effect.index,
              kExprGlobalGet, global.index,
              kGCPrefix, kExprRefCast, struct,
              kGCPrefix, kExprStructGet, struct, 0])
    .exportFunc();

  let wasm = builder.instantiate().exports;

  assertEquals(10, wasm.roundtrip(10));
})();

(function SharedGlobalInNonSharedFunction() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = builder.addType(kSig_i_i, kNoSuperType, true, false);
  let global = builder.addGlobal(kWasmI32, true, true, [kExprI32Const, 0]);

  builder.addFunction("roundtrip", sig)
    .addBody([kExprLocalGet, 0, kExprGlobalSet, global.index,
              kExprGlobalGet, global.index])
    .exportFunc();

  let wasm = builder.instantiate().exports;

  assertEquals(10, wasm.roundtrip(10));
})();

(function SharedGlobalInNonSharedFunctionExported() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = builder.addType(kSig_i_i, kNoSuperType, true, false);
  let global = builder.addGlobal(kWasmI32, true, true, [kExprI32Const, 0])
                      .exportAs("g");

  builder.addFunction("roundtrip", sig)
    .addBody([kExprLocalGet, 0, kExprGlobalSet, global.index,
              kExprGlobalGet, global.index])
    .exportFunc();

  let wasm = builder.instantiate().exports;

  assertEquals(10, wasm.roundtrip(10));
  assertEquals(10, wasm.g.value);
  wasm.g.value = 20;
  assertEquals(20, wasm.g.value);
})();

(function InvalidGlobalInSharedFunction() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = builder.addType(kSig_v_i, kNoSuperType, true, true);
  let global = builder.addGlobal(kWasmI32, true, false, [kExprI32Const, 0]);

  builder.addFunction("setter", sig)
    .addBody([kExprLocalGet, 0, kExprGlobalSet, global.index]);

  assertThrows(() => builder.instantiate(), WebAssembly.CompileError,
               /Cannot access non-shared global 0 in a shared function/);
})();

(function InvalidGlobalInSharedConstantExpression() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let global_non_shared =
      builder.addGlobal(kWasmI32, true, false, [kExprI32Const, 0]);
  builder.addGlobal(
      kWasmI32, true, true, [kExprGlobalGet, global_non_shared.index]);

  assertThrows(
      () => builder.instantiate(), WebAssembly.CompileError,
      /Cannot access non-shared global 0 in a shared constant expression/);
})();

(function InvalidImportedGlobal() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = builder.addType(kSig_i_i);
  builder.addImportedGlobal("m", "g", wasmRefType(sig), true, true);

  assertThrows(
    () => builder.instantiate(), WebAssembly.CompileError,
    /shared imported global must have shared type/);
})();

(function SharedTypes() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = builder.addType(kSig_i_i, kNoSuperType, true, true);
  let struct =
    builder.addStruct([makeField(kWasmI32, true)], kNoSuperType, false, true);

  builder.addFunction("main", sig)
    .addLocals(wasmRefType(struct), 1)
    .addBody([
      kExprLocalGet, 0, kGCPrefix, kExprStructNew, struct,
      kExprLocalSet, 1,
      kExprLocalGet, 1, kGCPrefix, kExprStructGet, struct, 0])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(42, wasm.main(42));
})();

(function InvalidLocal() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = builder.addType(kSig_i_i, kNoSuperType, true, true);
  let struct =
    builder.addStruct([makeField(kWasmI32, true)], kNoSuperType, false, false);

  builder.addFunction("main", sig)
    .addLocals(wasmRefType(struct), 1)
    .addBody([kExprLocalGet, 0])
    .exportFunc();

  assertThrows(() => builder.instantiate(), WebAssembly.CompileError,
               /local must have shared type/)
})();

(function InvalidStack() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = builder.addType(kSig_i_v, kNoSuperType, true, true);
  let struct =
    builder.addStruct([makeField(kWasmI32, true)], kNoSuperType, false, false);

  builder.addFunction("main", sig)
    .addBody([
      kExprI32Const, 42, kGCPrefix, kExprStructNew, struct,
      kGCPrefix, kExprStructGet, struct, 0])
    .exportFunc();

  assertThrows(() => builder.instantiate(), WebAssembly.CompileError,
               /struct.new does not have a shared type/);
})();

(function InvalidFuncRefInConstantExpression() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = builder.addType(kSig_i_i);
  let adder = builder.addFunction("adder", sig)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
  let global = builder.addGlobal(wasmRefType(sig), true, true,
                                 [kExprRefFunc, adder.index]);

  assertThrows(() => builder.instantiate(), WebAssembly.CompileError,
               /ref.func does not have a shared type/);
})();

(function DataSegmentInFunction() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = builder.addType(kSig_v_v, kNoSuperType, false, true);
  let data = builder.addPassiveDataSegment([1, 2, 3], true);
  builder.addFunction("drop", sig)
    .addBody([kNumericPrefix, kExprDataDrop, data])
    .exportFunc();
  builder.instantiate().exports.drop();
})();

(function InvalidDataSegmentInFunction() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = builder.addType(kSig_v_v, kNoSuperType, false, true);
  let data = builder.addPassiveDataSegment([1, 2, 3], false);
  builder.addFunction("drop", sig)
    .addBody([kNumericPrefix, kExprDataDrop, data])

  assertThrows(() => builder.instantiate(), WebAssembly.CompileError,
               /cannot refer to non-shared segment/);
})();

(function ElementSegmentInFunction() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = builder.addType(kSig_v_v, kNoSuperType, false, true);
  let func = builder.addFunction("void", sig).addBody([]);
  let elem = builder.addPassiveElementSegment(
    [[kExprRefFunc, func.index]], wasmRefType(0), true);
  builder.addFunction("drop", sig)
    .addBody([kNumericPrefix, kExprElemDrop, elem])
  builder.instantiate();
})();

(function InvalidElementSegmentInFunction() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = builder.addType(kSig_v_v, kNoSuperType, false, true);
  let elem = builder.addPassiveElementSegment(
    [[kExprRefNull, kNullFuncRefCode]], kWasmFuncRef, false);
  builder.addFunction("drop", sig)
    .addBody([kNumericPrefix, kExprElemDrop, elem])

  assertThrows(() => builder.instantiate(), WebAssembly.CompileError,
               /cannot reference non-shared element segment/);
})();

(function TableInFunction() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct = builder.addStruct([makeField(kWasmI32, true)], kNoSuperType,
                                 true, true);
  let sig = builder.addType(makeSig([kWasmI32], [wasmRefNullType(struct)]),
                            kNoSuperType, false, true);
  let table = builder.addTable(wasmRefNullType(struct), 10, undefined,
                               [kExprRefNull, struct], true);
  builder.addFunction("get", sig)
    .addBody([kExprLocalGet, 0, kExprTableGet, table.index])
    .exportFunc();

  let instance = builder.instantiate();

  assertEquals(null, instance.exports.get(0));
})();

(function TableInNonSharedFunction() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct = builder.addStruct([makeField(kWasmI32, true)], kNoSuperType,
                                 true, true);
  let sig = builder.addType(makeSig([kWasmI32], [wasmRefNullType(struct)]),
                            kNoSuperType, false, false);
  let table = builder.addTable(wasmRefNullType(struct), 10, undefined,
                               [kExprRefNull, struct], true)
                      .exportAs("t");
  builder.addFunction("get", sig)
    .addBody([kExprLocalGet, 0, kExprTableGet, table.index])
    .exportFunc();

  builder.addFunction("allocate", sig)
    .addBody([kGCPrefix, kExprStructNewDefault, struct])
    .exportFunc();

  let wasm = builder.instantiate().exports;

  assertEquals(null, wasm.get(0));
  let o = wasm.allocate();
  wasm.t.set(1, o);
  assertEquals(o, wasm.t.get(1));
})();

(function FunctionTableInNonSharedFunction() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let table = builder.addTable(
    wasmRefNullType(kWasmFuncRef, true), 10, undefined,
    [kExprRefNull, kWasmSharedTypeForm, kFuncRefCode], true);
  let sig = builder.addType(kSig_i_ii, kNoSuperType, true, true);
  let add = builder.addFunction("add", sig)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add]);
  let mul = builder.addFunction("mul", sig)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Mul]);
  builder.addActiveElementSegment(
    table.index, [kExprI32Const, 0],
    [[kExprRefFunc, add.index], [kExprRefFunc, mul.index]],
    wasmRefNullType(kWasmFuncRef, true), true);
  let passive = builder.addPassiveElementSegment(
    [[kExprRefFunc, add.index], [kExprRefFunc, mul.index]],
    wasmRefNullType(kWasmFuncRef, true), true);

  builder.addFunction("call", kSig_i_iii)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1, kExprLocalGet, 2,
      kExprCallIndirect, sig, table.index])
    .exportFunc();

  builder.addFunction("call_through_get", kSig_i_iii)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1,
      kExprLocalGet, 2, kExprTableGet, table.index,
      kGCPrefix, kExprRefCast, sig,
      kExprCallRef, sig])
    .exportFunc()

  builder.addFunction("set", kSig_v_v)
    .addBody([
      kExprI32Const, 0, kExprRefFunc, mul.index, kExprTableSet, table.index])
    .exportFunc();

  builder.addFunction("grow", kSig_v_v)
    .addBody([kExprRefNull, kWasmSharedTypeForm, kFuncRefCode,
              kExprI32Const, 42, kNumericPrefix, kExprTableGrow, table.index,
              kExprDrop])
    .exportFunc();

  builder.addFunction("fill", kSig_v_v)
    .addBody([kExprI32Const, 10, kExprRefFunc, add.index, kExprI32Const, 42,
              kNumericPrefix, kExprTableFill, table.index])
    .exportFunc();

  builder.addFunction("init", kSig_v_v)
    .addBody([kExprI32Const, 20, kExprI32Const, 0, kExprI32Const, 2,
              kNumericPrefix, kExprTableInit, passive, table.index])
    .exportFunc();

  builder.addFunction("copy", kSig_v_v)
    .addBody([kExprI32Const, 30, kExprI32Const, 20, kExprI32Const, 2,
              kNumericPrefix, kExprTableCopy, table.index, table.index])
    .exportFunc();

  builder.addFunction("size", kSig_i_v)
    .addBody([kNumericPrefix, kExprTableSize, table.index])
    .exportFunc();

  let wasm = builder.instantiate().exports;

  assertEquals(30, wasm.call(10, 20, 0));
  assertEquals(200, wasm.call(10, 20, 1));
  assertEquals(30, wasm.call_through_get(10, 20, 0));
  assertEquals(200, wasm.call_through_get(10, 20, 1));
  wasm.set();
  assertEquals(200, wasm.call(10, 20, 0));
  wasm.grow();
  assertTraps(kTrapFuncSigMismatch, () => wasm.call(10, 20, 42));
  wasm.fill();
  assertEquals(30, wasm.call(10, 20, 42));
  wasm.init();
  assertEquals(200, wasm.call(10, 20, 21));
  wasm.copy();
  assertEquals(30, wasm.call(10, 20, 30));
  assertEquals(200, wasm.call(10, 20, 31));
  assertEquals(52, wasm.size());
})();

(function InvalidTableInFunction() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct = builder.addStruct([makeField(kWasmI32, true)], kNoSuperType,
                                 true, true);
  let sig = builder.addType(makeSig([kWasmI32], [wasmRefNullType(struct)]),
                            kNoSuperType, false, true);
  let table = builder.addTable(wasmRefNullType(struct), 10, undefined,
                               [kExprRefNull, struct], false);
  builder.addFunction("get", sig)
    .addBody([kExprLocalGet, 0, kExprTableGet, table.index])
    .exportFunc();

  assertThrows(() => builder.instantiate(), WebAssembly.CompileError,
               /cannot reference non-shared table/);
})();

(function InvalidTableInitializer() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_shared = builder.addType(kSig_v_v, kNoSuperType, false, true);
  let sig = builder.addType(kSig_v_v, kNoSuperType, false, false);
  builder.addTable(wasmRefNullType(sig_shared), 10, undefined,
                   [kExprRefNull, sig], true);

  assertThrows(() => builder.instantiate(), WebAssembly.CompileError,
               /type error in constant expression\[0\] \(expected \(ref null 0\), got \(ref null 1\)\)/);
})();

(function CallNonShared() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = builder.addType(kSig_i_i, kNoSuperType, true, true);

  let callee = builder.addFunction("callee", kSig_v_v).addBody([]);

  builder.addFunction("caller", sig)
    .addBody([kExprCallFunction, callee.index])
    .exportFunc();

  assertThrows(() => builder.instantiate(), WebAssembly.CompileError,
               /cannot call non-shared function/);
})();

(function CallIndirectSharedImported() {
  print(arguments.callee.name);
  let exported_function = (function() {
    let builder = new WasmModuleBuilder();
    let sig = builder.addType(kSig_i_ii, kNoSuperType, true, true);
    let global = builder.addGlobal(kWasmI32, true, true, wasmI32Const(42));
    builder.addFunction("f", sig)
      .addBody([kExprGlobalGet, global.index, kExprLocalGet, 0,
                kExprLocalGet, 1, kExprI32Add, kExprI32Add])
      .exportFunc();
    return builder.instantiate().exports.f;
  })();

  let builder = new WasmModuleBuilder();

  let sig = builder.addType(kSig_i_ii, kNoSuperType, true, true);
  let table = builder.addTable(wasmRefNullType(sig), 10, undefined, undefined,
              true);
  let imp0 = builder.addImport("m", "imp0", sig);
  let imp1 = builder.addImport("m", "imp1", sig);

  builder.addActiveElementSegment(
    table.index, wasmI32Const(0), [[kExprRefFunc, imp0], [kExprRefFunc, imp1]],
    wasmRefNullType(sig), true);

  let call = builder.addFunction("call", kSig_i_iii)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprLocalGet, 2,
              kExprCallIndirect, sig, table.index])
    .exportFunc();

  let wasm = builder.instantiate(
    {m : {imp0 : (x, y) => x * y, imp1: exported_function}}).exports;

  assertEquals(200, wasm.call(10, 20, 0));
  assertEquals(42 + 10 + 20, wasm.call(10, 20, 1));
})();

(function CallIndirectSharedImportedWrongNonSharedType() {
  print(arguments.callee.name);
  let exported_function = (function() {
    let builder = new WasmModuleBuilder();
    let sig = builder.addType(kSig_i_ii, kNoSuperType, true, false);
    builder.addFunction("f", sig)
      .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
      .exportFunc();
    return builder.instantiate().exports.f;
  })();

  let builder = new WasmModuleBuilder();

  let sig = builder.addType(kSig_i_ii, kNoSuperType, true, true);
  builder.addImport("m", "imp", sig);

  assertThrows(
    () => builder.instantiate({m : {imp : exported_function}}),
    WebAssembly.LinkError,
    /imported function does not match the expected type/);
})();

(function SharedRefFuncInNonSharedFunction() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();

  let callee_sig = builder.addType(kSig_i_ii, kNoSuperType, true, true);

  let add = builder.addFunction("add", callee_sig)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add]);

  let mul = builder.addFunction("mul", callee_sig)
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Mul]);

  builder.addDeclarativeElementSegment(
    [[kExprRefFunc, add.index], [kExprRefFunc, mul.index]],
    wasmRefNullType(callee_sig), true);

  let caller = builder.addFunction("caller", kSig_i_iii)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprIf, kWasmRef, callee_sig,
        kExprRefFunc, add.index,
      kExprElse,
        kExprRefFunc, mul.index,
      kExprEnd,
      kExprCallRef, callee_sig])
    .exportFunc()

  let wasm = builder.instantiate().exports;

  // The first two calls have to call into the builtin.
  assertEquals(30, wasm.caller(10, 20, 1));
  assertEquals(200, wasm.caller(10, 20, 0));
  assertEquals(30, wasm.caller(10, 20, 1));
  assertEquals(200, wasm.caller(10, 20, 0));
})();

(function SharedArrayNewAndInitInNonSharedFunction() {
  print(arguments.callee.name);

  let builder = new WasmModuleBuilder();

  let struct_type = builder.addStruct(
    [makeField(kWasmI32, true)], kNoSuperType, true, true);

  let array_type =
    builder.addArray(wasmRefType(struct_type), true, kNoSuperType, true,
                     true);

  let segment = builder.addPassiveElementSegment(
    [[kExprI32Const, 0, kGCPrefix, kExprStructNew, struct_type],
     [kExprI32Const, 1, kGCPrefix, kExprStructNew, struct_type],
     [kExprI32Const, 2, kGCPrefix, kExprStructNew, struct_type],
     [kExprI32Const, 3, kGCPrefix, kExprStructNew, struct_type]],
    wasmRefType(struct_type), true);

  builder.addFunction("new_segment", makeSig([], [wasmRefType(array_type)]))
    .addBody([kExprI32Const, 0, kExprI32Const, 4,
              kGCPrefix, kExprArrayNewElem, array_type, segment])
    .exportFunc();

  builder.addFunction("get", makeSig([wasmRefNullType(array_type), kWasmI32],
                                     [kWasmI32]))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1,
              kGCPrefix, kExprArrayGet, array_type,
              kGCPrefix, kExprStructGet, struct_type, 0])
    .exportFunc();

  builder.addFunction("init_segment",
                      makeSig([wasmRefNullType(array_type)], []))
    .addBody([kExprLocalGet, 0, kExprI32Const, 2, kExprI32Const, 0,
              kExprI32Const, 2,
              kGCPrefix, kExprArrayInitElem, array_type, segment])
    .exportFunc();

  let wasm = builder.instantiate().exports;

  let array = wasm.new_segment();

  assertEquals(0, wasm.get(array, 0));
  assertEquals(1, wasm.get(array, 1));
  assertEquals(2, wasm.get(array, 2));
  assertEquals(3, wasm.get(array, 3));

  wasm.init_segment(array);

  assertEquals(0, wasm.get(array, 0));
  assertEquals(1, wasm.get(array, 1));
  assertEquals(0, wasm.get(array, 2));
  assertEquals(1, wasm.get(array, 3));
})();
                                                                                                        node-23.7.0/deps/v8/test/mjsunit/wasm/shared-memory-gc-stress.js                                    0000664 0000000 0000000 00000002151 14746647661 0024505 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

function AllocMemory(pages, max = pages) {
  let m =
      new WebAssembly.Memory({initial : pages, maximum : max, shared : true});
  let v = new Int32Array(m.buffer);
  return {memory : m, view : v};
}

function RunSomeAllocs(total, retained, pages, max = pages) {
  print(`-------iterations = ${total}, retained = ${retained} -------`);
  var array = new Array(retained);
  for (var i = 0; i < total; i++) {
    if ((i % 25) == 0)
      print(`iteration ${i}`);
    let pair = AllocMemory(pages, max);
    // For some iterations, retain the memory, view, or both.
    switch (i % 3) {
    case 0:
      pair.memory = null;
      break;
    case 1:
      pair.view = null;
      break;
    case 2:
      break;
    }
    array[i % retained] = pair;
  }
}

RunSomeAllocs(10, 1, 1, 1);
RunSomeAllocs(100, 3, 1, 1);
RunSomeAllocs(1000, 10, 1, 1);
// TODO(12278): Make this faster (by collection memories earlier?) and reenable.
// RunSomeAllocs(10000, 20, 1, 1);
                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/wasm/shared-memory-worker-explicit-gc-stress.js                    0000664 0000000 0000000 00000001766 14746647661 0027646 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-gc

d8.file.execute("test/mjsunit/worker-ping-test.js");

let config = {
  numThings: 4,       // size of circular buffer
  numWorkers: 4,      // number of workers
  numMessages: 500,   // number of messages sent to each worker
  allocInterval: 11,  // interval for allocating new things per worker
  traceScript: false, // print the script
  traceAlloc: true,   // print each allocation attempt
  traceIteration: 10, // print diagnostics every so many iterations
  abortOnFail: true,  // kill worker if allocation fails

  AllocThing: function AllocThing(id) {
    let pages = 1, max = 1;
    return new WebAssembly.Memory({initial : pages, maximum : max, shared : true});
  },
  BeforeSend: function BeforeSend(msg) {
    gc();
  },
  BeforeReceive: function BeforeReceive(msg) {
    gc();
  }
}

RunWorkerPingTest(config);
          node-23.7.0/deps/v8/test/mjsunit/wasm/shared-memory-worker-gc-stress.js                             0000664 0000000 0000000 00000001673 14746647661 0026024 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/worker-ping-test.js");

let kDisabledAbort = false; // TODO(9380): enable abort for this test

let config = {
  numThings: 4,       // size of circular buffer
  numWorkers: 4,      // number of workers
  numMessages: 1000,  // number of messages sent to each worker
  allocInterval: 11,  // interval for allocating new things per worker
  traceScript: false, // print the script
  traceAlloc: true,   // print each allocation attempt
  traceIteration: 10, // print diagnostics every so many iterations
  abortOnFail: kDisabledAbort,  // kill worker if allocation fails

  AllocThing: function AllocThing(id) {
    let pages = 1, max = 1;
    return new WebAssembly.Memory({initial : pages, maximum : max, shared : true});
  },
}

RunWorkerPingTest(config);
                                                                     node-23.7.0/deps/v8/test/mjsunit/wasm/shared-memory-worker-gc.js                                    0000664 0000000 0000000 00000001730 14746647661 0024475 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-gc

const kNumMessages = 1000;

function AllocMemory(pages = 1, max = pages) {
  return new WebAssembly.Memory({initial : pages, maximum : max, shared : true});
}

(function RunTest() {
  function workerCode() {
    onmessage = function({data:msg}) {
      if (msg.memory) postMessage({memory : msg.memory});
      gc();
    }
  }

  let worker = new Worker(workerCode, {type: 'function'});

  let time = performance.now();

  for (let i = 0; i < kNumMessages; i++) {
    let now = performance.now();
    print(`iteration ${i}, Δ = ${(now - time).toFixed(3)} ms`);
    time = now;

    let memory = AllocMemory();
    worker.postMessage({memory : memory});
    let msg = worker.getMessage();
    if (msg.memory) {
      assertInstanceof(msg.memory, WebAssembly.Memory);
    }
    gc();
  }
})();
                                        node-23.7.0/deps/v8/test/mjsunit/wasm/shared-memory-worker-simple-gc.js                             0000664 0000000 0000000 00000004164 14746647661 0025770 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-gc

const kNumIterations = 10;

function NewWorker() {
  let script =
`onmessage = ({data:msg}) => {
   if (msg.memory) postMessage("ack");
   if (msg.quit) postMessage("bye");
   gc();
}`;
  return new Worker(script, {type: 'string'});
}

function PingWorker(worker, memory) {
  worker.postMessage({memory: memory});
  assertEquals("ack", worker.getMessage());
  worker.postMessage({quit: true});
  assertEquals("bye", worker.getMessage());
}

function AllocMemory() {
  let pages = 1, max = 1;
  return new WebAssembly.Memory({initial : pages, maximum : max, shared : true});
}

function RunSingleWorkerSingleMemoryTest() {
  print(arguments.callee.name);
  let worker = NewWorker();
  let first = AllocMemory();
  for (let i = 0; i < kNumIterations; i++) {
    print(`iteration ${i}`);
    PingWorker(worker, first);
    gc();
  }
  worker.terminate();
}

function RunSingleWorkerTwoMemoryTest() {
  print(arguments.callee.name);
  let worker = NewWorker();
  let first = AllocMemory(), second = AllocMemory();
  for (let i = 0; i < kNumIterations; i++) {
    print(`iteration ${i}`);
    PingWorker(worker, first);
    PingWorker(worker, second);
    gc();
  }
  worker.terminate();
}

function RunSingleWorkerMultipleMemoryTest() {
  print(arguments.callee.name);
  let worker = NewWorker();
  let first = AllocMemory();
  for (let i = 0; i < kNumIterations; i++) {
    print(`iteration ${i}`);
    PingWorker(worker, first);
    PingWorker(worker, AllocMemory());
    gc();
  }
  worker.terminate();
}

function RunMultipleWorkerMultipleMemoryTest() {
  print(arguments.callee.name);
  let first = AllocMemory();
  for (let i = 0; i < kNumIterations; i++) {
    print(`iteration ${i}`);
    let worker = NewWorker();
    PingWorker(worker, first);
    PingWorker(worker, AllocMemory());
    worker.terminate();
    gc();
  }
}

RunSingleWorkerSingleMemoryTest();
RunSingleWorkerTwoMemoryTest();
RunSingleWorkerMultipleMemoryTest();
RunMultipleWorkerMultipleMemoryTest();
                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/wasm/shared-memory-worker-stress.js                                0000664 0000000 0000000 00000001751 14746647661 0025432 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/worker-ping-test.js");

// TODO(v8:9380): increase {numThings} and {numWorkers} when stress-opt mode
// no longer leaks wasm memories.
let config = {
  numThings: 2,         // size of circular buffer
  numWorkers: 2,        // number of workers
  numMessages: 2000,    // number of messages sent to each worker
  allocInterval: 10001, // interval for allocating new things per worker
  traceScript: false,   // print the script
  traceAlloc: true,     // print each allocation attempt
  traceIteration: 10,   // print diagnostics every so many iterations
  abortOnFail: true,    // kill worker if allocation fails

  AllocThing: function AllocThing(id) {
    let pages = 1, max = 1;
    return new WebAssembly.Memory({initial : pages, maximum : max, shared : true});
  },
}

RunWorkerPingTest(config);
                       node-23.7.0/deps/v8/test/mjsunit/wasm/shared-memory.js                                              0000664 0000000 0000000 00000011130 14746647661 0022572 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function assertMemoryIsValid(memory, shared) {
  assertSame(WebAssembly.Memory.prototype, memory.__proto__);
  assertSame(WebAssembly.Memory, memory.constructor);
  assertTrue(memory instanceof Object);
  assertTrue(memory instanceof WebAssembly.Memory);
  if (shared) {
    assertTrue(memory.buffer instanceof SharedArrayBuffer);
    // Assert that the buffer is frozen when memory is shared.
    assertTrue(Object.isFrozen(memory.buffer));
  }
}

(function TestConstructorWithShared() {
  print("TestConstructorWithShared");
  let memory = new WebAssembly.Memory({
    initial: 0, maximum: 10, shared: true});
  assertMemoryIsValid(memory, true);
})();

(function TestConstructorWithUndefinedShared() {
  print("TestConstructorWithUndefinedShared");
  // Maximum = undefined, shared = undefined.
  let memory = new WebAssembly.Memory({
    initial: 0, maximum: undefined, shared: undefined});
  assertMemoryIsValid(memory);
})();

(function TestConstructorWithNumericShared() {
  print("TestConstructorWithNumericShared");
  // For numeric values, shared = true.
  let memory = new WebAssembly.Memory({
    initial: 0, maximum: 10, shared: 2098665});
  assertMemoryIsValid(memory, true);
})();

(function TestConstructorWithEmptyStringShared() {
  print("TestConstructorWithEmptyStringShared");
  // Maximum = undefined, shared = false.
  let memory = new WebAssembly.Memory({
    initial: 0, maximum: undefined, shared: ""});
  assertMemoryIsValid(memory);
})();

(function TestConstructorWithUndefinedMaxShared() {
  print("TestConstructorWithUndefinedMaxShared");
  // New memory with Maximum = undefined, shared = true => TypeError.
  assertThrows(() => new WebAssembly.Memory({initial: 0, shared: true}),
      TypeError);
})();

(function TestCompileWithUndefinedShared() {
  print("TestCompileWithUndefinedShared");
  let memory = new WebAssembly.Memory({
    initial: 0, maximum: 10, shared: true});
  let builder = new WasmModuleBuilder();
  builder.addImportedMemory("m", "imported_mem", 0, undefined, "shared");
  assertThrows(() => new WebAssembly.Module(builder.toBuffer()),
       WebAssembly.CompileError);
})();

(function TestInstantiateWithUndefinedShared() {
  print("TestInstantiateWithUndefinedShared");
  let memory = new WebAssembly.Memory({
    initial: 0, maximum: 10, shared: true});
  let builder = new WasmModuleBuilder();
  builder.addImportedMemory("m", "imported_mem");
  let module = new WebAssembly.Module(builder.toBuffer());
  assertThrows(() => new WebAssembly.Instance(module,
         {m: {imported_mem: memory}}), WebAssembly.LinkError);
})();

(function TestInstantiateWithImportNotSharedDefined() {
  print("TestInstantiateWithImportNotSharedDefined");
  let memory = new WebAssembly.Memory({
    initial: 0, maximum: 10, shared: false});
  let builder = new WasmModuleBuilder();
  builder.addImportedMemory("m", "imported_mem", 0, 10, "shared");
  let module = new WebAssembly.Module(builder.toBuffer());
  assertThrows(() => new WebAssembly.Instance(module,
         {m: {imported_mem: memory}}), WebAssembly.LinkError);
})();

(function TestInstantiateWithSharedDefined() {
  print("TestInstantiateWithSharedDefined");
  let builder = new WasmModuleBuilder();
  builder.addMemory(2, 10, "shared");
  builder.exportMemoryAs("memory");
  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  assertMemoryIsValid(instance.exports.memory, true);
})();

(function TestAtomicOpWithSharedMemoryDefined() {
  print("TestAtomicOpWithSharedMemoryDefined");
  let builder = new WasmModuleBuilder();
  builder.addMemory(2, 10, "shared");
  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kAtomicPrefix,
      kExprI32AtomicAdd, 2, 0])
    .exportFunc();
  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  assertEquals(0, instance.exports.main(0, 0x11111111));
  assertEquals(0x11111111, instance.exports.main(0, 0x11111111));
})();

(function TestMemoryConstructorShouldNotCallHasProperty() {
  print(arguments.callee.name);
  // from test/wasm-js/data/test/js-api/memory/constructor.any.js
  const proxy = new Proxy({}, {
    has(o, x) {
      throw new Error(`Should not call [[HasProperty]] with ${x}`);
    },
    get(o, x) {
      if (x === "index") {
        return "i32";
      }
      return 0;
    },
  });
  new WebAssembly.Memory(proxy);
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/wasm/simd-call.js                                                  0000664 0000000 0000000 00000004010 14746647661 0021662 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

// Tests function calls containing s128 parameters. It also checks that
// lowering of simd calls are correct, so we create 2 functions with s128
// arguments: function 2 has a single s128 parameter, function 3 has a i32 then
// s128, to ensure that the arguments in different indices are correctly lowered.
(function TestSimd128Params() {
  const builder = new WasmModuleBuilder();
  builder.addImportedMemory('m', 'imported_mem', 1, 2);

  builder
    .addFunction("main", makeSig([], []))
    .addBodyWithEnd([
      kExprI32Const, 0,
      kSimdPrefix, kExprS128LoadMem, 0, 0,
      kExprCallFunction, 0x01,
      kExprEnd,
    ]);

  // Writes s128 argument to memory starting byte 16.
  builder
    .addFunction("function2", makeSig([kWasmS128], []))
    .addBodyWithEnd([
      kExprI32Const, 16,
      kExprLocalGet, 0,
      kSimdPrefix, kExprS128StoreMem, 0, 0,
      kExprI32Const, 9, // This constant doesn't matter.
      kExprLocalGet, 0,
      kExprCallFunction, 0x02,
      kExprEnd,
    ]);

  // Writes s128 argument to memory starting byte 32.
  builder
    .addFunction("function3", makeSig([kWasmI32, kWasmS128], []))
    .addBodyWithEnd([
      kExprI32Const, 32,
      kExprLocalGet, 1,
      kSimdPrefix, kExprS128StoreMem, 0, 0,
      kExprEnd,
    ]);

  builder.addExport('main', 0);
  var memory = new WebAssembly.Memory({initial:1, maximum:2});
  const instance = builder.instantiate({m: {imported_mem: memory}});

  const arr = new Uint8Array(memory.buffer);
  // Fill the initial memory with some values, this is read by main and passed
  // as arguments to function2, and then to function3.
  for (let i = 0; i < 16; i++) {
    arr[i] = i * 2;
  }

  instance.exports.main();

  for (let i = 0; i < 16; i++) {
    assertEquals(arr[i], arr[i+16]);
    assertEquals(arr[i], arr[i+32]);
  }
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/wasm/simd-errors.js                                                0000664 0000000 0000000 00000004020 14746647661 0022264 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestS128InSignatureThrows() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction('foo', kSig_s_i)
    .addBody([
      kExprLocalGet, 0,
      kSimdPrefix,
      kExprI32x4Splat])
    .exportFunc()
  const instance = builder.instantiate();
  assertThrows(() => instance.exports.foo(33), TypeError);
})();

(function TestS128ParamInSignatureThrows() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction('foo', kSig_i_s)
      .addBody([
          kExprLocalGet, 0,
          kSimdPrefix,
          kExprI32x4ExtractLane, 1])
      .exportFunc();
  const instance = builder.instantiate();
  assertThrows(() => instance.exports.foo(10), TypeError);
})();

(function TestImportS128Return() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addImport('', 'f', makeSig([], [kWasmS128]));
  builder.addFunction('foo', kSig_v_v)
      .addBody([kExprCallFunction, 0, kExprDrop])
      .exportFunc();
  const instance = builder.instantiate({'': {f: _ => 1}});
  assertThrows(() => instance.exports.foo(), TypeError);
})();

(function TestS128ImportThrows() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_i_i);
  let sig_s128_index = builder.addType(kSig_i_s);
  let index = builder.addImport('', 'func', sig_s128_index);
  builder.addFunction('foo', sig_index)
    .addBody([
      kExprLocalGet, 0,
      kSimdPrefix,
      kExprI32x4Splat,
      kExprCallFunction, index])
    .exportFunc();
  const instance = builder.instantiate({'': {func: _ => {}}});
  assertThrows(() => instance.exports.foo(14), TypeError);
})();

(function TestS128GlobalConstructor() {
  assertThrows(() => new WebAssembly.Global({value: 'v128'}), TypeError);
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/wasm/simd-globals.js                                               0000664 0000000 0000000 00000003375 14746647661 0022407 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// Test for S128 global with initialization.
// This checks for a bug in copying the immediate values from the
// initialization expression into the globals area of the module.
(function TestS128GlobalInitialization() {
  var builder = new WasmModuleBuilder();
  var g = builder.addGlobal(
    kWasmS128, false, false,
    [kSimdPrefix, kExprS128Const,
     1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0]);

  // Check that all lanes have the right values by creating 4 functions that
  // extract each lane.
  function addGetFunction(i) {
    builder.addFunction(`get${i}`, kSig_i_v)
      .addBody([
        kExprGlobalGet, g.index,
        kSimdPrefix, kExprI32x4ExtractLane, i])
      .exportAs(`get${i}`);
  }

  for (let i = 0; i < 4; i++) {
    addGetFunction(i);
  }

  var instance = builder.instantiate();

  for (let i = 0; i < 4; i++) {
    // get0 will get lane0, which has value 1
    assertEquals(i+1, instance.exports[`get${i}`]());
  }
})();

(function TestS128GlobalImport() {
  // We want to test that a module with an imported V128 global does not crash.
  // But that is a bit tricky because:
  // 1. WebAssembly.Global({value: 'v128'}) is an error
  // 2. WebAssembly.Global of any other type is a type mismatch error
  // So here, we do 2. in order to get further along the code path, where
  // previously it would have crashed, it now checks for v128 and exits early.
  var builder = new WasmModuleBuilder();
  var g = builder.addImportedGlobal('m', 'foo', kWasmS128);
  assertThrows(() => builder.instantiate({m: {foo: 0}}));
})();
                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/mjsunit/wasm/simd-i64x2-mul.js                                             0000664 0000000 0000000 00000002563 14746647661 0022431 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --no-enable-avx

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

// Carefully hand-crafted test case to exercie a codegen bug in Liftoff.  In
// i64x2.mul, non-AVX case, we will overwrite rhs if dst == rhs. The intention
// is to do dst = lhs * rhs, but if dst == rhs && dst != lhs, we will overwrite
// dst (and hence rhs) with lhs, effectively doing lhs^2.
const builder = new WasmModuleBuilder();
builder.addMemory(16, 32);
builder.addFunction(undefined, kSig_l_v)
.addBody([
  kExprI64Const, 0,
  kSimdPrefix, kExprI64x2Splat,
  kExprI64Const, 1,
  kSimdPrefix, kExprI64x2Splat,
  kExprI64Const, 2,
  kSimdPrefix, kExprI64x2Splat,
  kExprCallFunction, 1,
]);

let sig = makeSig([kWasmS128, kWasmS128, kWasmS128], [kWasmI64]);
builder.addFunction(undefined, sig)
.addLocals(kWasmS128, 10)
.addBody([
  kExprLocalGet, 2,  // This is 2 (lhs).
  kExprI64Const, 4,  // This is 4 (rhs).
  kSimdPrefix, kExprI64x2Splat,
  kSimdPrefix, kExprI64x2Mul, 0x01,  // The bug will write 2 to rhs.
  kSimdPrefix, kExprI64x2ExtractLane, 0,
]);
builder.addExport('main', 0);
const module = builder.instantiate();
// Should be 2 * 4, the buggy codegen will give 2 * 2 instead.
assertEquals(8n, module.exports.main());
                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/simd-lane-memory64.js                                         0000664 0000000 0000000 00000006305 14746647661 0023357 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-memory64

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

const GB = 1024 * 1024 * 1024;
const SRC_OFFSET = 4294970000n; // 0x100000a90n
const SRC_OFFSET_LEB = [0x90, 0x95, 0x80, 0x80, 0x10];
const DST_OFFSET = 4294970160n;
const DST_OFFSET_LEB = [0xb0, 0x96, 0x80, 0x80, 0x10];

const builder = new WasmModuleBuilder();
builder.addMemory64(5 * GB / kPageSize);
builder.exportMemoryAs('memory');

// Here we make a global of type v128 to be the target
// for loading lanes and the source for storing lanes.
var g = builder.addGlobal(
  kWasmS128, true, false,
  [kSimdPrefix, kExprS128Const,
   1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0, 4, 0, 0, 0]);

for (let i = 0; i < 4; ++i) {
  builder.addFunction(`load_lane_${i}`, kSig_v_l)
      .addBody([kExprLocalGet, 0,
                kExprGlobalGet, g.index,
                kSimdPrefix, kExprS128Load32Lane, 0, 0, i,
                kExprGlobalSet, g.index])
      .exportFunc();

  builder.addFunction(`store_lane_${i}`, kSig_v_l)
      .addBody([kExprLocalGet, 0,
                kExprGlobalGet, g.index,
                kSimdPrefix, kExprS128Store32Lane, 0, 0, i])
      .exportFunc();

  builder.addFunction(`Load_Lane_${i}`, kSig_v_l)
      .addBody([kExprLocalGet, 0,
                kExprGlobalGet, g.index,
                kSimdPrefix, kExprS128Load32Lane, 0, ...SRC_OFFSET_LEB, i,
                kExprGlobalSet, g.index])
      .exportFunc();

  builder.addFunction(`Store_Lane_${i}`, kSig_v_l)
      .addBody([kExprLocalGet, 0,
                kExprGlobalGet, g.index,
                kSimdPrefix, kExprS128Store32Lane, 0, ...DST_OFFSET_LEB, i])
      .exportFunc();
}

(function TestLoadStoreLaneExternalOffset(){
  print(arguments.callee.name);

  var instance = builder.instantiate({});
  var buffer = instance.exports.memory.buffer;

  var src_view = new Uint32Array(buffer, Number(SRC_OFFSET), 4);
  var dst_view = new Uint32Array(buffer, Number(DST_OFFSET), 4);
  var values = [ 0x01234567, 0x89abcdef, 0x76543210, 0xfedcba98 ];
  var expected_values = [ 0, 0, 0, 0 ];
  src_view.set(values, 0);

  for (let i = 0n; i < 4n; ++i) {
    expected_values[i] = values[i];
    const offset = 4n * i;
    instance.exports[`load_lane_${i}`](SRC_OFFSET + offset);
    instance.exports[`store_lane_${i}`](DST_OFFSET + offset);
    assertEquals(expected_values, Array.from(dst_view.values()));
  }
})();

(function TestLoadStoreLaneInternalOffset(){
  print(arguments.callee.name);

  var instance = builder.instantiate({});
  var buffer = instance.exports.memory.buffer;

  var src_view = new Uint32Array(buffer, Number(SRC_OFFSET), 4);
  var dst_view = new Uint32Array(buffer, Number(DST_OFFSET), 4);
  var values = [ 0x01234567, 0x89abcdef, 0x76543210, 0xfedcba98 ];
  var expected_values = [ 0, 0, 0, 0 ];
  src_view.set(values, 0);

  for (let i = 0n; i < 4n; ++i) {
    expected_values[i] = values[i];
    const offset = 4n * i;
    instance.exports[`Load_Lane_${i}`](offset);
    instance.exports[`Store_Lane_${i}`](offset);
    assertEquals(expected_values, Array.from(dst_view.values()));
  }
})();
                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/wasm/simd-relaxed-lane-select.js                                   0000664 0000000 0000000 00000004102 14746647661 0024567 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

const builder = new WasmModuleBuilder();

function MakeBody(lane_width) {
  let select_instr = lane_width == 8 ? kExprI8x16RelaxedLaneSelect :
                     lane_width == 16 ? kExprI16x8RelaxedLaneSelect :
                     lane_width == 32 ? kExprI32x4RelaxedLaneSelect :
                     lane_width == 64 ? kExprI64x2RelaxedLaneSelect : null;
  assertNotNull(select_instr);
  return [
    // Value A: all 0-bits.
    kExprI32Const, 0x00,
    kSimdPrefix, kExprI8x16Splat,
    // Value B: all 1-bits.
    ...wasmI32Const(0xFF),
    kSimdPrefix, kExprI8x16Splat,
    // Mask: a wild mix of bit patterns.
    ...wasmS128Const([0x80, 0x7F, 0xC0, 0x3F, 0x40, 0x9F, 0x20, 0x1F,
                      0x70, 0xA0, 0xFF, 0x00, 0xFF, 0xFF, 0x10, 0x01]),
    // The main point of the test: use the mask to select lanes.
    kSimdPrefix, ...select_instr,
    // Let's see which lanes were selected for each byte.
    kSimdPrefix, kExprI8x16BitMask, 0x01,
  ];
}

builder.addFunction('test8', kSig_i_v).exportFunc().addBody(MakeBody(8));
builder.addFunction('test16', kSig_i_v).exportFunc().addBody(MakeBody(16));
builder.addFunction('test32', kSig_i_v).exportFunc().addBody(MakeBody(32));
builder.addFunction('test64', kSig_i_v).exportFunc().addBody(MakeBody(64));
const instance = builder.instantiate();

let test8 = instance.exports.test8;
let test16 = instance.exports.test16;
let test32 = instance.exports.test32;
let test64 = instance.exports.test64;

let test8_result = test8();
let test16_result = test16();
let test32_result = test32();
let test64_result = test64();

%WasmTierUpFunction(test8);
%WasmTierUpFunction(test16);
%WasmTierUpFunction(test32);
%WasmTierUpFunction(test64);

assertEquals(test8_result, test8());
assertEquals(test16_result, test16());
assertEquals(test32_result, test32());
assertEquals(test64_result, test64());
                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/wasm/simd-wasm-interpreter.js                                      0000664 0000000 0000000 00000003522 14746647661 0024266 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

// Tests that R2R/S2R mode is not supported for Simd types in the Wasm
// interpreter.
(function testSimdSelect() {
  print(arguments.callee.name);

  const builder = new WasmModuleBuilder();
  builder.addType(makeSig([], []));
  builder.addFunction('main', 0 /* sig */)
    .addLocals(kWasmS128, 2)
    .exportFunc()
    .addBody([
      ...wasmS128Const(new Array(16).fill(0)),  // s128.const
      ...wasmS128Const(new Array(16).fill(0)),  // s128.const
      kExprI32Const, 0,
      kExprSelect,                              // select
      kExprDrop,
    ]);
  var instance = builder.instantiate();
  instance.exports.main();
})();

// Tests R2S mode Select instruction for Simd types
(function testSimdSelectR2S() {
  print(arguments.callee.name);

  const builder = new WasmModuleBuilder();
  let globalint = builder.addImportedGlobal('o', 'g', kWasmI32, true);

  builder.addType(makeSig([], []));
  builder.addFunction('main', 0 /* sig */)
    .addLocals(kWasmS128, 2)
    .exportFunc()
    .addBody([
      ...wasmS128Const(new Array(16).fill(1)),  // s128.const
      ...wasmS128Const(new Array(16).fill(0)),  // s128.const
      kExprGlobalGet, globalint,
      kExprSelect,                              // select

      // The first s128 const should be selected.
      ...wasmS128Const(new Array(16).fill(1)),
      kSimdPrefix, kExprI8x16Ne,
      kSimdPrefix, kExprI8x16AllTrue,
      kExprIf, kWasmVoid,
        kExprUnreachable,
      kExprEnd,
    ]);
  let gint = new WebAssembly.Global({mutable: true, value: 'i32'});
  gint.value = 1;
  var instance = builder.instantiate({o: {g: gint}});
  instance.exports.main();
})();
                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/wasm/single-threaded-compilation.js                                0000664 0000000 0000000 00000001423 14746647661 0025375 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-num-compilation-tasks=0

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function testSyncCompilation() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.addFunction("main", kSig_d_d)
      .addBody([kExprLocalGet, 0])
      .exportFunc();

  const instance = builder.instantiate();
})();

(function testAsyncCompilation() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.addFunction("main", kSig_i_i)
      .addBody([kExprLocalGet, 0])
      .exportFunc();

  const instance = builder.asyncInstantiate();
})();
                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/speculative-inlining.js                                       0000664 0000000 0000000 00000027163 14746647661 0024164 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-inlining-call-indirect
// Flags: --experimental-wasm-type-reflection
// Flags: --no-wasm-tier-up --wasm-dynamic-tiering --allow-natives-syntax
// Flags: --turboshaft-wasm
// Explicitly set Turboshaft since speculative call_indirect inlining is only
// implemented there and TurboFan is on its way out anyway.

// These tests check if functions are speculatively inlined as expected. We do
// not check automatically which functions are inlined.
// To get more insight, run with --trace-wasm-inlining, --trace-turbo,
// --trace-wasm, and (for the last test only) --trace or consider the test in
// message/wasm-speculative-inlining.js.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function CallRefSpecSucceededTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  // f(x) = x - 1
  let callee = builder.addFunction("callee", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprI32Const, 1, kExprI32Sub]);

  let global = builder.addGlobal(wasmRefType(callee.type_index), false, false,
                                 [kExprRefFunc, callee.index]);

  // g(x) = f(5) + x
  let main = builder.addFunction("main", kSig_i_i)
    .addBody([kExprI32Const, 5, kExprGlobalGet, global.index,
              kExprCallRef, callee.type_index,
              kExprLocalGet, 0, kExprI32Add])
    .exportAs("main");

  let instance = builder.instantiate();
  for (let i = 0; i < 20; i++) assertEquals(14, instance.exports.main(10));
  %WasmTierUpFunction(instance.exports.main);
  // The tiered-up function should have {callee} speculatively inlined.
  assertEquals(14, instance.exports.main(10));
})();

(function CallRefSpecFailedTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let sig_index = builder.addType(kSig_i_i);

  // h(x) = x - 1
  let callee0 = builder.addFunction("callee0", sig_index)
    .addBody([kExprLocalGet, 0, kExprI32Const, 1, kExprI32Sub]);

  // f(x) = x - 2
  let callee1 = builder.addFunction("callee1", sig_index)
    .addBody([kExprLocalGet, 0, kExprI32Const, 2, kExprI32Sub]);

  let global0 = builder.addGlobal(wasmRefType(sig_index), false, false,
                                  [kExprRefFunc, callee0.index]);
  let global1 = builder.addGlobal(wasmRefType(sig_index), false, false,
                                  [kExprRefFunc, callee1.index]);

  // g(x, y) = if (y) { h(5) + x } else { f(7) + x }
  let main = builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprLocalGet, 1,
      kExprIf, kWasmI32,
        kExprI32Const, 5, kExprGlobalGet, global0.index,
        kExprCallRef, sig_index,
        kExprLocalGet, 0, kExprI32Add,
      kExprElse,
        kExprI32Const, 7, kExprGlobalGet, global1.index,
        kExprCallRef, sig_index,
        kExprLocalGet, 0, kExprI32Add,
      kExprEnd])
    .exportAs("main");

  let instance = builder.instantiate();

  for (let i = 0; i < 20; i++) assertEquals(14, instance.exports.main(10, 1));
  %WasmTierUpFunction(instance.exports.main);
  // Tier-up is done, and {callee0} should be inlined in the trace.
  assertEquals(14, instance.exports.main(10, 1));

  // Now, run main with {callee1} instead. The correct reference should still be
  // called after inlining.
  assertEquals(15, instance.exports.main(10, 0));
})();

(function CallReturnRefSpecSucceededTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  // f(x) = x - 1
  let callee = builder.addFunction("callee", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprI32Const, 1, kExprI32Sub]);

  let global = builder.addGlobal(wasmRefType(callee.type_index), false, false,
                                 [kExprRefFunc, callee.index]);

  // g(x) = f(5 + x)
  let main = builder.addFunction("main", kSig_i_i)
    .addBody([kExprI32Const, 5, kExprLocalGet, 0, kExprI32Add,
              kExprGlobalGet, global.index,
              kExprReturnCallRef, callee.type_index])
    .exportAs("main");

  let instance = builder.instantiate();

  for (let i = 0; i < 20; i++) assertEquals(14, instance.exports.main(10));
  %WasmTierUpFunction(instance.exports.main);
  // After tier-up, the tail call should be speculatively inlined.
  assertEquals(14, instance.exports.main(10));
})();

(function CallReturnRefSpecFailedTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let sig_index = builder.addType(kSig_i_i);

  // h(x) = x - 1
  let callee0 = builder.addFunction("callee0", sig_index)
    .addBody([kExprLocalGet, 0, kExprI32Const, 1, kExprI32Sub]);

  // f(x) = x - 2
  let callee1 = builder.addFunction("callee1", sig_index)
    .addBody([kExprLocalGet, 0, kExprI32Const, 2, kExprI32Sub]);

  let global0 = builder.addGlobal(wasmRefType(sig_index), false, false,
                                 [kExprRefFunc, callee0.index]);
  let global1 = builder.addGlobal(wasmRefType(sig_index), false, false,
                                 [kExprRefFunc, callee1.index]);

  // g(x, y) = if (y) { h(x) } else { f(x) }
  let main = builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprLocalGet, 1,
      kExprIf, kWasmI32,
        kExprLocalGet, 0, kExprGlobalGet, global0.index,
        kExprReturnCallRef, sig_index,
      kExprElse,
        kExprLocalGet, 0, kExprGlobalGet, global1.index,
        kExprReturnCallRef, sig_index,
      kExprEnd])
    .exportAs("main");

  let instance = builder.instantiate();

  assertEquals(9, instance.exports.main(10, 1));
  %WasmTierUpFunction(instance.exports.main);
  // After tier-up, {callee0} should be inlined in the trace.
  assertEquals(9, instance.exports.main(10, 1))

  // Now, run main with {callee1} instead. The correct reference should still be
  // called.
  assertEquals(8, instance.exports.main(10, 0));
})();

(function CallRefImportedFunction() {
  print(arguments.callee.name);

  let instance1 = function() {
    let builder = new WasmModuleBuilder();

    let f1 = builder.addImport("m", "i_f1", kSig_i_i);
    let f2 = builder.addImport("m", "i_f2", kSig_i_i);

    builder.addExport("f1", f1);
    builder.addExport("f2", f2);

    return builder.instantiate({m : { i_f1 : x => x + 1, i_f2 : x => x + 2}});
  }();

  let main = null;
  let instance2 = function() {
    let builder = new WasmModuleBuilder();

    let sig1 = builder.addType(kSig_i_i);
    let sig2 = builder.addType(kSig_i_ii);

    builder.addFunction("callee", sig2)
      .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
      .exportFunc();

    main = builder.addFunction("main",
        makeSig([kWasmI32, wasmRefType(sig1)], [kWasmI32]))
      .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprCallRef, sig1])
      .exportFunc();

    return builder.instantiate({});
  }();

  // Run 'main' until it is tiered-up.
  assertEquals(1, instance2.exports.main(0, instance1.exports.f1));
  %WasmTierUpFunction(instance2.exports.main);
  // The function f1 defined in another module should not be inlined.
  assertEquals(1, instance2.exports.main(0, instance1.exports.f1));
})();

// Check that we handle WasmJSFunctions properly and do not inline them, both
// in the monomorphic and polymorphic case.
(function CallRefWasmJsFunction() {
  print(arguments.callee.name);

  let f1 = new WebAssembly.Function({parameters: ["i32"], results: ["i32"]},
                                    x => x + 1);
  let f2 = new WebAssembly.Function({parameters: ["i32"], results: ["i32"]},
                                    x => x * 2);

  let main = null;
  let instance2 = function() {
    let builder = new WasmModuleBuilder();

    let sig = builder.addType(kSig_i_i);

    main = builder.addFunction("main", makeSig(
        [kWasmI32, wasmRefType(sig), wasmRefType(sig)], [kWasmI32]))
      .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprCallRef, sig,
                kExprLocalGet, 0, kExprLocalGet, 2, kExprCallRef, sig,
                kExprI32Add])
      .exportFunc();

    return builder.instantiate({});
  }();

  // Run 'main' until it is tiered-up. The first argument should try to be
  // spec-inlined monomorphically. We pass f2 to the second argument 80% of the
  // time, so it should try to be spec-inlined polymorphically.
  for (let i = 0; i < 20; i++) {
    if (i % 5 == 0) {
      assertEquals(12, instance2.exports.main(5, f1, f1));
    } else {
      assertEquals(16, instance2.exports.main(5, f1, f2));
    }
  }
  %WasmTierUpFunction(instance2.exports.main);
  // WebAssembly.Function objects should not be inlined.
  assertEquals(16, instance2.exports.main(5, f1, f2));
  assertEquals(12, instance2.exports.main(5, f1, f1));
})();

// For call_indirect, we only test the (not inlining of) imported JS/Wasm
// functions. The cases that can be successfully inlined are already covered
// by the test in message/wasm-speculative-inlining.
(function CallIndirectImportedFunction() {
  print(arguments.callee.name);

  let instance1 = function() {
    let builder = new WasmModuleBuilder();
    builder.addFunction("f", kSig_i_i)
      .addBody([kExprLocalGet, 0, kExprI32Const, 1, kExprI32Add])
      .exportFunc();
    return builder.instantiate();
  }();

  let instance2 = function() {
    let builder = new WasmModuleBuilder();

    let sig = builder.addType(kSig_i_i);

    let f = builder.addImport("m", "f", kSig_i_i);
    builder.appendToTable([f]);

    builder.addFunction("main", kSig_i_i)
      .addBody([
        kExprLocalGet, 0,
        kExprI32Const, /* index of `f` in the table */ 0,
        kExprCallIndirect, sig, kTableZero])
      .exportFunc();

    return builder.instantiate({ m: { f: instance1.exports.f }});
  }();

  // Run 'main' until it is tiered-up.
  assertEquals(1, instance2.exports.main(0));
  %WasmTierUpFunction(instance2.exports.main);
  // The function f1 defined in another module should not be inlined.
  assertEquals(1, instance2.exports.main(0));
})();

(function CallIndirectWasmJsFunction() {
  print(arguments.callee.name);

  let f_js = new WebAssembly.Function({parameters: ["i32"], results: ["i32"]},
                                      x => x + 1);

  let instance = function() {
    let builder = new WasmModuleBuilder();

    let sig = builder.addType(kSig_i_i);

    let f = builder.addImport("m", "f", kSig_i_i);
    builder.appendToTable([f]);

    builder.addFunction("main", kSig_i_i)
      .addBody([
        kExprLocalGet, 0,
        kExprI32Const, /* index of `f` in the table */ 0,
        kExprCallIndirect, sig, kTableZero])
      .exportFunc();

    return builder.instantiate({ m: { f: f_js }});
  }();

  // Run 'main' until it is tiered-up.
  assertEquals(1, instance.exports.main(0));
  %WasmTierUpFunction(instance.exports.main);
  // WebAssembly.Function objects should not be inlined.
  assertEquals(1, instance.exports.main(0));
})();

(function ReturnCallRefSpecSucceededTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  // f(x) = x - 1
  let callee = builder.addFunction("callee", kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprI32Const, 1, kExprI32Sub]);

  let global = builder.addGlobal(wasmRefType(callee.type_index), false, false,
                                 [kExprRefFunc, callee.index]);

  // g(x) = f(5 + x)
  let main = builder.addFunction("main", kSig_i_i)
    .addBody([kExprI32Const, 5, kExprLocalGet, 0, kExprI32Add,
              kExprGlobalGet, global.index,
              kExprReturnCallRef, callee.type_index])
    .exportAs("main");

  let instance = builder.instantiate();
  for (let i = 0; i < 20; i++) assertEquals(14, instance.exports.main(10));
  %WasmTierUpFunction(instance.exports.main);
  // The tiered-up function should have {callee} speculatively inlined.
  assertEquals(14, instance.exports.main(10));
})();
                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/stack-push-root.js                                            0000664 0000000 0000000 00000002026 14746647661 0023065 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Tests that code generator behaves correctly when pushing to the stack an
// operand that is an offset of the root register.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

let builder = new WasmModuleBuilder();

let sig = makeSig(
    [kWasmAnyRef, kWasmAnyRef, kWasmAnyRef, kWasmAnyRef, kWasmAnyRef,
     kWasmAnyRef],
    [kWasmAnyRef]);
let sig_index = builder.addType(sig);

let callee =
    builder.addFunction('callee', sig_index).addBody([kExprLocalGet, 5]);

builder.addFunction('main', kSig_r_v).exportFunc().addBody([
  kExprRefNull, kAnyRefCode,
  kExprRefNull, kAnyRefCode,
  kExprRefNull, kAnyRefCode,
  kExprRefNull, kAnyRefCode,
  kExprRefNull, kAnyRefCode,
  kExprRefNull, kAnyRefCode,
  kExprCallFunction, callee.index,
  kGCPrefix, kExprExternConvertAny
]);

let instance = builder.instantiate();
assertEquals(null, instance.exports.main());
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/wasm/stack-switching-conditional.js                                0000664 0000000 0000000 00000001237 14746647661 0025430 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// We pick a small stack size to run the stack overflow test quickly, but big
// enough to run all the tests.
//
// Flags: --allow-natives-syntax
// Flags: --expose-gc --wasm-stack-switching-stack-size=100


// Enable the JSPI flag conditionally (as in a Chrome Origin Trial),
// then run existing stack-switching tests.
d8.test.enableJSPI();
d8.file.execute("test/mjsunit/wasm/stack-switching.js");

// Test that nothing blows up if we call this multiple times.
d8.test.installConditionalFeatures();
                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/wasm/stack-switching-export.js                                     0000664 0000000 0000000 00000067400 14746647661 0024452 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-generic-wrapper --expose-gc --allow-natives-syntax
// Flags: --experimental-wasm-jspi

// This is a port of the generic-wrapper.js tests for the JS Promise Integration
// variant of the wrapper. We don't suspend the stacks in this test, we only
// test the wrapper's argument conversion logic.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function GC() {
  %CheckIsOnCentralStack();
  gc();
}

(function testGenericWrapper0Param() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_r_v);
  let func_index = builder.addImport("mod", "func", kSig_r_v);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func() {
    GC();
    x = 20;
  }

  let instance = builder.instantiate({ mod: { func: import_func } });
  let main = WebAssembly.promising(instance.exports.main);
  assertPromiseResult(main(), v => assertEquals(undefined, v));
  assertEquals(20, x);
})();

(function testGenericWrapper0ParamTraps() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_r_v);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprUnreachable
    ])
    .exportFunc();

  let instance = builder.instantiate();
  let main = WebAssembly.promising(instance.exports.main);
  assertThrowsAsync(main(), WebAssembly.RuntimeError);
})();

(function testGenericWrapper1ParamTrap() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = makeSig([kWasmI32], [kWasmExternRef]);
  let sig_index = builder.addType(sig);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0, kExprUnreachable
    ])
    .exportFunc();

  let instance = builder.instantiate();
  let main = WebAssembly.promising(instance.exports.main);
  assertThrowsAsync(main(), WebAssembly.RuntimeError);
})();

(function testGenericWrapper1ParamGeneral() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = makeSig([kWasmI32], [kWasmExternRef]);
  let sig_index = builder.addType(sig);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func(param) {
    GC();
    x += param;
  }

  let instance = builder.instantiate({ mod: { func: import_func } });
  let main = WebAssembly.promising(instance.exports.main);
  assertPromiseResult(main(5), v => { assertEquals(undefined, v); });
  assertEquals(17, x);
})();

(function testGenericWrapper1ParamNotSmi() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = makeSig([kWasmI32], [kWasmExternRef]);
  let sig_index = builder.addType(sig);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
        kExprLocalGet, 0,
        kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func(param) {
    GC();
    x += param;
  }

  let y = { valueOf: () => { print("Hello!"); GC(); return 24; } };
  let instance = builder.instantiate({ mod: { func: import_func } });
  let main = WebAssembly.promising(instance.exports.main);
  assertPromiseResult(main(y), v => { assertEquals(undefined, v); });
  assertEquals(36, x);
})();

(function testGenericWrapper4Param() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = makeSig([kWasmI32, kWasmI32, kWasmI32, kWasmI32],
      [kWasmExternRef]);
  let sig_index = builder.addType(sig);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func(param1, param2, param3, param4) {
    GC();
    x += 2 * param1 + 3 * param2 + 4 * param3 + 5 * param4;
  }

  let param2 = { valueOf: () => { GC(); return 6; } };
  let param3 = { valueOf: () => { GC(); return 3; } };
  let instance = builder.instantiate({ mod: { func: import_func } });
  let main = WebAssembly.promising(instance.exports.main);
  assertPromiseResult(
      main(9, param2, param3, 0),
      v => { assertEquals(undefined, v); });
  assertEquals(60, x);
  // Now we test if the evaluation order of the parameters is correct.
  x = 12;
  param3 = {
    valueOf: () => {
      Object.defineProperty(param2, 'valueOf', {
        value: () => 30
      })
      return 3;
    }
  };
  assertPromiseResult(main(9, param2, param3, 0), undefined);
  assertEquals(60, x);
})();

let kSig_r_iiiiiiii = makeSig([kWasmI32, kWasmI32, kWasmI32, kWasmI32,
    kWasmI32, kWasmI32, kWasmI32, kWasmI32], [kWasmExternRef]);

(function testGenericWrapper8Param() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_r_iiiiiiii);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      kExprLocalGet, 4,
      kExprLocalGet, 5,
      kExprLocalGet, 6,
      kExprLocalGet, 7,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func(param1, param2, param3, param4, param5,
      param6, param7, param8) {
    GC();
    x += param1 + 2 * param2 + 3 * param3 + 4 * param4 + 5 * param5
      + 6 * param6 + 7 * param7 + 8 * param8;
  }

  let param1 = { valueOf: () => { GC(); return 5; } };
  let param4 = { valueOf: () => { GC(); return 8; } };
  let param6 = { valueOf: () => { GC(); return 10; } };
  let param8 = { valueOf: () => { GC(); return 12; } };
  let instance = builder.instantiate({ mod: { func: import_func } });
  let main = WebAssembly.promising(instance.exports.main);
  assertPromiseResult(
      main(param1, 6, 7, param4, 9, param6, 11, param8),
      v => assertEquals(undefined, v));
  assertEquals(360, x);
})();

// Passing less parameters than expected.
(function testGenericWrapper4ParamWithLessParams() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = makeSig([kWasmI32, kWasmI32, kWasmI32, kWasmI32], [kWasmExternRef]);
  let sig_index = builder.addType(sig);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func(param1, param2, param3, param4) {
    GC();
    x += param1 + param2 + param3 + param4;
  }

  let param2 = { valueOf: () => { GC(); return 3; } };
  let instance = builder.instantiate({ mod: { func: import_func } });
  let main = WebAssembly.promising(instance.exports.main);
  assertPromiseResult(main(5, param2), v => assertEquals(undefined, v));
  assertEquals(20, x);
})();

// Passing more parameters than expected.
(function testGenericWrapper4ParamWithMoreParams() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = makeSig([kWasmI32, kWasmI32, kWasmI32, kWasmI32], [kWasmExternRef]);
  let sig_index = builder.addType(sig);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func(param1, param2, param3, param4) {
    GC();
    x += param1 + param2 + param3 + param4;
  }

  let param2 = { valueOf: () => { GC(); return 3; } };
  let param3 = { valueOf: () => { GC(); return 6; } };
  let instance = builder.instantiate({ mod: { func: import_func } });
  let main = WebAssembly.promising(instance.exports.main);
  assertPromiseResult(
      main(5, param2, param3, 7, 200, 300, 400),
      v => assertEquals(undefined, v));
  assertEquals(33, x);
})();

(function testGenericWrapper1I32ReturnSmi() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = makeSig([kWasmI32], [kWasmI32]);
  let sig_index = builder.addType(sig);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
        kExprLocalGet, 0,
        kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func(param) {
    GC();
    return x + param;
  }

  let instance = builder.instantiate({ mod: { func: import_func } });
  let main = WebAssembly.promising(instance.exports.main);
  assertPromiseResult(main(5), v => assertEquals(17, v));
})();

(function testGenericWrapper1I32ReturnHeapNumber() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = makeSig([kWasmI32], [kWasmI32]);
  let sig_index = builder.addType(sig);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 2147483640;
  function import_func(param) {
    let result = x + param;
    %SimulateNewspaceFull();
    return result;
  }

  let instance = builder.instantiate({ mod: { func: import_func } });
  let main = WebAssembly.promising(instance.exports.main);
  assertPromiseResult(main(5), v => assertEquals(2147483645, v));
})();

let kSig_i_lili = makeSig([kWasmI64, kWasmI32, kWasmI64, kWasmI32],
    [kWasmI32]);

(function testGenericWrapper4IParam1I32Ret() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_i_lili);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12n;
  function import_func(param1, param2, param3, param4) {
    x += 2n * param1 + BigInt(3 * param2) + 4n * param3 + BigInt(5 * param4);
    return Number(x);
  }

  let param2 = { valueOf: () => { GC(); return 6; } };
  let param3 = { valueOf: () => { GC(); return 3n; } };
  let instance = builder.instantiate({ mod: { func: import_func } });
  let main = WebAssembly.promising(instance.exports.main);
  assertPromiseResult(main(9n, param2, param3, 0), v => assertEquals(60, v));
})();

let kSig_r_iiili = makeSig([kWasmI32, kWasmI32, kWasmI32, kWasmI64, kWasmI32],
    [kWasmExternRef]);

(function testGenericWrapper5IParam() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_r_iiili);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      kExprLocalGet, 4,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func(param1, param2, param3, param4, param5) {
    GC();
    x += 2 * param1 + 3 * param2 + 4 * param3 + 5 * Number(param4) + 6 * param5;
  }

  let param2 = { valueOf: () => { GC(); return 6; } };
  let param3 = { valueOf: () => { GC(); return 3; } };
  let instance = builder.instantiate({ mod: { func: import_func } });
  let main = WebAssembly.promising(instance.exports.main);
  assertPromiseResult(
      main(9, param2, param3, 0n, 2),
      v => assertEquals(undefined, v));
  assertEquals(72, x);
})();

let kSig_r_iiilii = makeSig([kWasmI32, kWasmI32, kWasmI32, kWasmI64, kWasmI32,
    kWasmI32], [kWasmExternRef]);

(function testGenericWrapper6IParam() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_r_iiilii);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      kExprLocalGet, 4,
      kExprLocalGet, 5,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func(param1, param2, param3, param4, param5,
      param6) {
    gc();
    x += 2 * param1 + 3 * param2 + 4 * param3 + 5 * Number(param4) + 6 * param5 + 7 * param6;
  }

  let param2 = { valueOf: () => { GC(); return 6; } };
  let param3 = { valueOf: () => { GC(); return 3; } };
  let instance = builder.instantiate({ mod: { func: import_func } });
  let main = WebAssembly.promising(instance.exports.main);
  assertPromiseResult(
      main(9, param2, param3, 0n, 2, 3),
      v => assertEquals(undefined, v));
  assertEquals(93, x);
})();

let kSig_r_liilliiil = makeSig([kWasmI64, kWasmI32, kWasmI32, kWasmI64,
    kWasmI64, kWasmI32, kWasmI32, kWasmI32, kWasmI64], [kWasmI32]);

(function testGenericWrapper9IParam132Ret() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_r_liilliiil);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      kExprLocalGet, 4,
      kExprLocalGet, 5,
      kExprLocalGet, 6,
      kExprLocalGet, 7,
      kExprLocalGet, 8,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func(param1, param2, param3, param4, param5, param6, param7,
      param8, param9) {
    x += Number(param1) + 2 * param2 + 3 * param3 + Number(4n * param4) + Number(5n * param5)
      + 6 * param6 + 7 * param7 + 8 * param8 + Number(9n * param9);
    return x;
  }

  let param1 = { valueOf: () => { GC(); return 5n; } };
  let param4 = { valueOf: () => { GC(); return 8n; } };
  let param6 = { valueOf: () => { GC(); return 10; } };
  let param8 = { valueOf: () => { GC(); return 12; } };
  let instance = builder.instantiate({ mod: { func: import_func } });
  let main = WebAssembly.promising(instance.exports.main);
  assertPromiseResult(
      main(param1, 6, 7, param4, 9n, param6, 11, param8, 0n),
      v => assertEquals(360, v));
})();

// The function expects BigInt, but gets Number.
(function testGenericWrapperTypeError() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = makeSig([kWasmI64], [kWasmExternRef]);
  let sig_index = builder.addType(sig);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12n;
  function import_func(param1) {
    x += param1;
  }

  let instance = builder.instantiate({ mod: { func: import_func } });
  let main = WebAssembly.promising(instance.exports.main);
  assertThrows(() => main(17), TypeError);
})();

(function testGenericWrapper1I64Return() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_l_v);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
        kExprCallFunction, func_index
    ])
    .exportFunc();

  function import_func() {
    GC();
    return 10000000000n;
  }

  let instance = builder.instantiate({ mod: { func: import_func } });
  let main = WebAssembly.promising(instance.exports.main);
  assertPromiseResult(main(), v => assertEquals(10000000000n, v));
})();

(function testGenericWrapper1F32Return() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_f_v);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
        kExprCallFunction, func_index
    ])
    .exportFunc();

  function import_func() {
    GC();
    return 0.5;
  }

  let instance = builder.instantiate({ mod: { func: import_func } });
  let main = WebAssembly.promising(instance.exports.main);
  assertPromiseResult(main(), v => assertEquals(0.5, v));
})();

(function testGenericWrapper1F64Return() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_d_v);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
        kExprCallFunction, func_index
    ])
    .exportFunc();

  function import_func() {
    GC();
    return 0.25;
  }

  let instance = builder.instantiate({ mod: { func: import_func } });
  let main = WebAssembly.promising(instance.exports.main);
  assertPromiseResult(main(), v => assertEquals(0.25, v));
})();

(function testGenericWrapper1Float32() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = makeSig([kWasmF32], [kWasmExternRef]);
  let sig_index = builder.addType(sig);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
        kExprLocalGet, 0,
        kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12.5;
  function import_func(param) {
    GC();
    x += param;
  }

  let instance = builder.instantiate({ mod: { func: import_func } });
  let main = WebAssembly.promising(instance.exports.main);
  assertPromiseResult(main(12.5), v => assertEquals(undefined, v));
  assertEquals(25, x);
})();

(function testGenericWrapper1Float64() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig = makeSig([kWasmF64], [kWasmExternRef]);
  let sig_index = builder.addType(sig);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12.5;
  function import_func(param) {
    GC();
    x += param;
  }

  let instance = builder.instantiate({ mod: { func: import_func } });
  let main = WebAssembly.promising(instance.exports.main);
  assertPromiseResult(main(12.5), v => assertEquals(undefined, v));
  assertEquals(25, x);
})();

let kSig_r_ffddddff = makeSig([kWasmF32, kWasmF32, kWasmF64, kWasmF64,
    kWasmF64, kWasmF64, kWasmF32, kWasmF32], [kWasmExternRef]);

(function testGenericWrapper8Floats() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_r_ffddddff);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      kExprLocalGet, 4,
      kExprLocalGet, 5,
      kExprLocalGet, 6,
      kExprLocalGet, 7,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func(param1, param2, param3, param4, param5,
      param6, param7, param8) {
    GC();
    x += param1 + 2 * param2 + 3 * param3 + 4 * param4 + 5 * param5
      + 6 * param6 + 7 * param7 + 8 * param8;
  }

  let param1 = { valueOf: () => { GC(); return 1.5; } };
  let param4 = { valueOf: () => { GC(); return 4.5; } };
  let param6 = { valueOf: () => { GC(); return 6.5; } };
  let param8 = { valueOf: () => { GC(); return 8.5; } };
  let instance = builder.instantiate({ mod: { func: import_func } });
  let main = WebAssembly.promising(instance.exports.main);
  assertPromiseResult(
      main(param1, 2.5, 3.5, param4, 5.5, param6, 7.5, param8),
      v => assertEquals(undefined, v));
  assertEquals(234, x);
})();

let kSig_r_iiliffddlfdff = makeSig([kWasmI32, kWasmI32, kWasmI64, kWasmI32,
    kWasmF32, kWasmF32, kWasmF64, kWasmF64, kWasmI64, kWasmF32, kWasmF64,
    kWasmF32, kWasmF32], [kWasmExternRef]);
// Floats don't fit into param registers.
(function testGenericWrapper13ParamMix() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_r_iiliffddlfdff);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      kExprLocalGet, 4,
      kExprLocalGet, 5,
      kExprLocalGet, 6,
      kExprLocalGet, 7,
      kExprLocalGet, 8,
      kExprLocalGet, 9,
      kExprLocalGet, 10,
      kExprLocalGet, 11,
      kExprLocalGet, 12,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  let y = 1.0;
  function import_func(parami1, parami2, paraml1, parami3, paramf1,
      paramf2, paramd1, paramd2, paraml2, paramf3, paramd3, paramf4, paramf5) {
    GC();
    x += parami1 + 2 * parami2 + 3 * Number(paraml1) + 4 * parami3
      + 5 * Number(paraml2);
    y += paramf1 + 2 * paramf2 + 3 * paramd1 + 4 * paramd2 + 5 * paramf3
      + 6 * paramd3 + 7 * paramf4 + 8 * paramf5;
  }

  let instance = builder.instantiate({ mod: { func: import_func } });
  let main = WebAssembly.promising(instance.exports.main);
  assertPromiseResult(
      main(5, 6, 7n, 8, 1.5, 2.5, 3.5, 4.5, 11n, 5.5, 6.5, 7.5, 8.5),
      v => assertEquals(undefined, v));
  assertEquals(137, x);
  assertEquals(223, y);
})();

let kSig_r_iiliiiffddli = makeSig([kWasmI32, kWasmI32, kWasmI64, kWasmI32,
    kWasmI32, kWasmI32, kWasmF32, kWasmF32, kWasmF64, kWasmF64, kWasmI64,
    kWasmI32], [kWasmExternRef]);
// Integers don't fit into param registers.
(function testGenericWrapper12ParamMix() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_r_iiliiiffddli);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      kExprLocalGet, 4,
      kExprLocalGet, 5,
      kExprLocalGet, 6,
      kExprLocalGet, 7,
      kExprLocalGet, 8,
      kExprLocalGet, 9,
      kExprLocalGet, 10,
      kExprLocalGet, 11,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  let y = 1.0;
  function import_func(param1, param2, param3, param4, param5,
      param6, paramf1, paramf2, paramd1, paramd2, param7, param8) {
    GC();
    x += param1 + 2 * param2 + 3 * Number(param3) + 4 * param4 + 5 * param5
      + 6 * param6 + 7 * Number(param7) + 8 * param8;
    y += paramf1 + paramf2 + paramd1 + paramd2;
  }

  let param1 = { valueOf: () => { GC(); return 5; } };
  let param4 = { valueOf: () => { GC(); return 8; } };
  let param6 = { valueOf: () => { GC(); return 10; } };
  let param8 = { valueOf: () => { GC(); return 12; } };
  let instance = builder.instantiate({ mod: { func: import_func } });
  let main = WebAssembly.promising(instance.exports.main);
  assertPromiseResult(
      main(param1, 6, 7n, param4, 9, param6, 1.5, 2.5, 3.6, 4.4, 11n, param8),
      v => assertEquals(undefined, v));
  assertEquals(360, x);
  assertEquals(13, y);
})();

let kSig_f_iiliiiffddlifffdi = makeSig([kWasmI32, kWasmI32, kWasmI64,
    kWasmI32, kWasmI32, kWasmI32, kWasmF32, kWasmF32, kWasmF64, kWasmF64,
    kWasmI64, kWasmI32, kWasmF32, kWasmF32, kWasmF32, kWasmF64, kWasmI32],
    [kWasmF32]);
// Integers and floats don't fit into param registers.
(function testGenericWrapper17ParamMix() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_f_iiliiiffddlifffdi);
  let func_index = builder.addImport("mod", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      kExprLocalGet, 4,
      kExprLocalGet, 5,
      kExprLocalGet, 6,
      kExprLocalGet, 7,
      kExprLocalGet, 8,
      kExprLocalGet, 9,
      kExprLocalGet, 10,
      kExprLocalGet, 11,
      kExprLocalGet, 12,
      kExprLocalGet, 13,
      kExprLocalGet, 14,
      kExprLocalGet, 15,
      kExprLocalGet, 16,
      kExprCallFunction, func_index
    ])
    .exportFunc();

  let x = 12;
  function import_func(param1, param2, param3, param4, param5,
      param6, paramf1, paramf2, paramd1, paramd2, param7, param8, paramf3,
      paramf4, paramf5, paramd3, param9) {
    GC();
    x += param1 + 2 * param2 + 3 * Number(param3) + 4 * param4 + 5 * param5
      + 6 * param6 + 7 * Number(param7) + 8 * param8 + 9 * param9;
    let y = 1.0;
    y += paramf1 + 2 * paramf2 + 3 * paramd1 + 4 * paramd2 + 5 * paramf3
      + 6 * paramf4 + 7 * paramf5 + 8 * paramd3;
    return y;
  }

  let param1 = { valueOf: () => { gc(); return 5; } };
  let param4 = { valueOf: () => { gc(); return 8; } };
  let param6 = { valueOf: () => { gc(); return 10; } };
  let param8 = { valueOf: () => { gc(); return 12; } };
  let paramd1 = { valueOf: () => { gc(); return 3.5; } };
  let paramf3 = { valueOf: () => { gc(); return 5.5; } };
  let param9 = { valueOf: () => { gc(); return 0; } };
  let instance = builder.instantiate({ mod: { func: import_func } });
  let main = WebAssembly.promising(instance.exports.main);
  assertPromiseResult(
      main(param1, 6, 7n, param4, 9, param6, 1.5, 2.5, paramd1,
        4.5, 11n, param8, paramf3, 6.5, 7.5, 8.5, param9),
      v => assertEquals(223, v));
  assertEquals(360, x);
})();

(function testCallFromOptimizedFunction() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.addFunction('wasm_fn', kSig_r_r).addBody([
      kExprLocalGet, 0
  ]).exportFunc();

  instance = builder.instantiate();
  function js_caller() {
    return WebAssembly.promising(instance.exports.wasm_fn);
  }
  %PrepareFunctionForOptimization(js_caller);
  js_caller();
  %OptimizeFunctionOnNextCall(js_caller);
  js_caller();
})();

(function Regression1130385() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_index = builder.addType(kSig_i_r);
  builder.addFunction("f0", sig_index)
    .addBody([kExprI32Const, 12])
    .exportFunc();

  builder.addFunction("f1", sig_index)
    .addBody([kExprI32Const, 15])
    .exportFunc();

  let instance = builder.instantiate();
  let f1 = WebAssembly.promising(instance.exports.f1);
  assertPromiseResult(f1(), v => assertEquals(15, v));
})();

(function testDeoptWithIncorrectNumberOfParams() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  let sig = makeSig([kWasmI32, kWasmI32], [kWasmExternRef]);
  let sig_index = builder.addType(sig);
  let imp = builder.addImport('q', 'func', sig_index);
  builder.addFunction('main', sig_index)
      .addBody([
          kExprLocalGet, 0,
          kExprLocalGet, 1,
          kExprCallFunction, imp])
      .exportAs('main');

  function deopt() {
    %DeoptimizeFunction(caller);
  }

  let instance = builder.instantiate({q: {func: deopt}});
  let main = WebAssembly.promising(instance.exports.main);
  function caller() {
    main(1, 2, 3, 4, 5);
    main(1, 2, 3, 4);
    main(1, 2, 3);
    main(1, 2);
    main(1);
    main();
  }
  caller();
})();

(function testGenericWrapper6Ref7F64Param() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let sig_r_ddrrrrrrddddd = builder.addType(makeSig(
      [kWasmF64, kWasmF64, kWasmExternRef, kWasmExternRef, kWasmExternRef,
      kWasmExternRef, kWasmExternRef, kWasmExternRef, kWasmF64, kWasmF64,
      kWasmF64, kWasmF64, kWasmF64],
      [kWasmExternRef]));


  builder.addFunction("func0", sig_r_ddrrrrrrddddd)
    .addBody([
      kExprLocalGet, 7,
      ])
    .exportAs("func0");

  let module = new WebAssembly.Module(builder.toBuffer());
  let instance = new WebAssembly.Instance(module);
  let func0 = WebAssembly.promising(instance.exports.func0);
  let res = func0(1, 2, "3", "4", "5", "6", "7", "8", 9, 10, 11, 12, 13);
  assertPromiseResult(res, v => assertEquals("8", v));
})();
                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/wasm/stack-switching-generic-wrapper.js                            0000664 0000000 0000000 00000003124 14746647661 0026214 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-to-js-generic-wrapper --expose-gc --allow-natives-syntax
// Flags: --experimental-wasm-stack-switching

// Test the stack-switching export wrapper in combination with the generic
// import wrapper, in particular to test that the generic wrapper switches to
// the central stack.
d8.file.execute("test/mjsunit/wasm/stack-switching-export.js");

// Throw an exception from JS, catch it in wasm and then overflow the stack.
// This tests the implicit stack switch when the exception leaves JS (central
// stack) and re-enters wasm (secondary stack). If the stack limit is not
// updated during unwinding, the stack overflow is likely to crash.
(function testGenericWrapperException() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let func_index = builder.addImport("mod", "func", kSig_v_v);
  builder.addFunction("main", kSig_v_v)
    .addBody([
      kExprTry, kWasmVoid,
        kExprCallFunction, func_index,
      kExprCatchAll,
      kExprEnd,
      kExprCallFunction, 2
    ])
    .exportFunc();
  builder.addFunction("stackOverflow", kSig_v_v)
      .addBody([
          kExprCallFunction, 2
      ]);

  function import_func() {
    %CheckIsOnCentralStack();
    throw new Error();
  }

  let instance = builder.instantiate({ mod: { func: import_func } });
  let main = WebAssembly.promising(instance.exports.main);
  assertThrowsAsync(main(), RangeError, /Maximum call stack size exceeded/);
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/wasm/stack-switching.js                                            0000664 0000000 0000000 00000056427 14746647661 0023142 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --experimental-wasm-jspi
// Flags: --expose-gc --wasm-stack-switching-stack-size=100

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestInvalidWrappers() {
  print(arguments.callee.name);
  assertThrows(() => WebAssembly.promising({}), TypeError,
      /Argument 0 must be a function/);
  assertThrows(() => WebAssembly.promising(() => {}), TypeError,
      /Argument 0 must be a WebAssembly exported function/);
  assertThrows(() => WebAssembly.Suspending(() => {}), TypeError,
      /WebAssembly.Suspending must be invoked with 'new'/);
  assertThrows(() => new WebAssembly.Suspending({}), TypeError,
      /Argument 0 must be a function/);
  function asmModule() {
    "use asm";
    function x(v) {
      v = v | 0;
    }
    return x;
  }
  assertThrows(() => WebAssembly.promising(asmModule()), TypeError,
      /Argument 0 must be a WebAssembly exported function/);
})();

(function TestStackSwitchNoSuspend() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addGlobal(kWasmI32, true, false).exportAs('g');
  builder.addFunction("test", kSig_i_v)
      .addBody([
          kExprI32Const, 42,
          kExprGlobalSet, 0,
          kExprI32Const, 0]).exportFunc();
  let instance = builder.instantiate();
  let wrapper = WebAssembly.promising(instance.exports.test);
  wrapper();
  assertEquals(42, instance.exports.g.value);
})();

(function TestStackSwitchSuspend() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  import_index = builder.addImport('m', 'import', kSig_i_v);
  builder.addFunction("test", kSig_i_v)
      .addBody([
          kExprCallFunction, import_index, // suspend
      ]).exportFunc();
  let js_import = new WebAssembly.Suspending(() => Promise.resolve(42));
  let instance = builder.instantiate({m: {import: js_import}});
  let wrapped_export = WebAssembly.promising(instance.exports.test);
  let combined_promise = wrapped_export();
  assertPromiseResult(combined_promise, v => assertEquals(42, v));

  // Also try with a JS function with a mismatching arity.
  js_import = new WebAssembly.Suspending((unused) => Promise.resolve(42));
  instance = builder.instantiate({m: {import: js_import}});
  wrapped_export = WebAssembly.promising(instance.exports.test);
  combined_promise = wrapped_export();
  assertPromiseResult(combined_promise, v => assertEquals(42, v));

  // Also try with a proxy.
  js_import = new WebAssembly.Suspending(new Proxy(() => Promise.resolve(42), {}));
  instance = builder.instantiate({m: {import: js_import}});
  wrapped_export = WebAssembly.promising(instance.exports.test);
  combined_promise = wrapped_export();
  assertPromiseResult(combined_promise, v => assertEquals(42, v));
  %CheckIsOnCentralStack();
})();

// Check that we can suspend back out of a resumed computation.
(function TestStackSwitchSuspendLoop() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addGlobal(kWasmI32, true, false).exportAs('g');
  import_index = builder.addImport('m', 'import', kSig_i_v);
  // Pseudo-code for the wasm function:
  // for (i = 0; i < 5; ++i) {
  //   g = g + import();
  // }
  builder.addFunction("test", kSig_i_v)
      .addLocals(kWasmI32, 1)
      .addBody([
          kExprI32Const, 5,
          kExprLocalSet, 0,
          kExprLoop, kWasmVoid,
            kExprCallFunction, import_index, // suspend
            kExprGlobalGet, 0, // resume
            kExprI32Add,
            kExprGlobalSet, 0,
            kExprLocalGet, 0,
            kExprI32Const, 1,
            kExprI32Sub,
            kExprLocalTee, 0,
            kExprBrIf, 0,
          kExprEnd,
          kExprI32Const, 0,
      ]).exportFunc();
  let i = 0;
  // The n-th call to the import returns a promise that resolves to n.
  function js_import() {
    return Promise.resolve(++i);
  };
  let wasm_js_import = new WebAssembly.Suspending(js_import);
  let instance = builder.instantiate({m: {import: wasm_js_import}});
  let wrapped_export = WebAssembly.promising(instance.exports.test);
  let chained_promise = wrapped_export();
  assertEquals(0, instance.exports.g.value);
  assertPromiseResult(chained_promise, _ => assertEquals(15, instance.exports.g.value));
})();

// Call the GC in the import call.
(function TestStackSwitchGC() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let gc_index = builder.addImport('m', 'gc', kSig_v_v);
  builder.addFunction("test", kSig_i_v)
      .addBody([
          kExprCallFunction, gc_index,
          kExprI32Const, 0
      ]).exportFunc();
  let js_import = new WebAssembly.Suspending(gc);
  let instance = builder.instantiate({'m': {'gc': js_import}});
  let wrapper = WebAssembly.promising(instance.exports.test);
  wrapper();
})();

// Call the GC during param conversion.
(function TestStackSwitchGC2() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let import_index = builder.addImport('m', 'import', kSig_i_i);
  builder.addFunction("test", kSig_i_i)
      .addBody([
          kExprLocalGet, 0,
          kExprCallFunction, import_index,
      ]).exportFunc();
  let js_import = new WebAssembly.Suspending((v) => { return Promise.resolve(v) });
  let instance = builder.instantiate({'m': {'import': js_import}});
  let wrapper = WebAssembly.promising(instance.exports.test);
  let arg = { valueOf: () => { gc(); return 24; } };
  assertPromiseResult(wrapper(arg), v => assertEquals(arg.valueOf(), v));
})();

// Check that the suspender does not suspend if the import's
// return value is not a promise.
(function TestStackSwitchNoPromise() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addGlobal(kWasmI32, true, false).exportAs('g');
  import_index = builder.addImport('m', 'import', kSig_i_v);
  builder.addFunction("test", kSig_i_v)
      .addBody([
          kExprCallFunction, import_index, // suspend
          kExprGlobalSet, 0, // resume
          kExprGlobalGet, 0,
      ]).exportFunc();
  function js_import() {
    return 42
  };
  let wasm_js_import = new WebAssembly.Suspending(js_import);
  let instance = builder.instantiate({m: {import: wasm_js_import}});
  let wrapped_export = WebAssembly.promising(instance.exports.test);
  let result = wrapped_export();
  assertEquals(42, instance.exports.g.value);
})();

(function TestStackSwitchSuspendArgs() {
  print(arguments.callee.name);
  function reduce(array) {
    // a[0] + a[1] * 2 + a[2] * 3 + ...
    return array.reduce((prev, cur, i) => prev + cur * (i + 1));
  }
  let builder = new WasmModuleBuilder();
  // Number of param registers + 1 for both types.
  let params = [kWasmI32, kWasmI32, kWasmI32, kWasmI32, kWasmI32, kWasmI32,
      kWasmF32, kWasmF32, kWasmF32, kWasmF32, kWasmF32, kWasmF32, kWasmF32];
  let sig = makeSig(params, [kWasmI32]);
  import_index = builder.addImport('m', 'import', sig);
  builder.addFunction("test", sig)
      .addBody([
          kExprLocalGet, 0, kExprLocalGet, 1, kExprLocalGet, 2, kExprLocalGet, 3,
          kExprLocalGet, 4, kExprLocalGet, 5, kExprLocalGet, 6, kExprLocalGet, 7,
          kExprLocalGet, 8, kExprLocalGet, 9, kExprLocalGet, 10, kExprLocalGet, 11,
          kExprLocalGet, 12,
          kExprCallFunction, import_index, // suspend
      ]).exportFunc();
  function js_import(i1, i2, i3, i4, i5, i6, f1, f2, f3, f4, f5, f6, f7) {
    return Promise.resolve(reduce(Array.from(arguments)));
  };
  let wasm_js_import = new WebAssembly.Suspending(js_import);

  let instance = builder.instantiate({m: {import: wasm_js_import}});
  let wrapped_export = WebAssembly.promising(instance.exports.test);
  let args = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];
  let combined_promise =
      wrapped_export.apply(null, args);
  assertPromiseResult(combined_promise, v => assertEquals(reduce(args), v));
})();

(function TestStackSwitchReturnFloat() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  import_index = builder.addImport('m', 'import', kSig_f_v);
  builder.addFunction("test", kSig_f_v)
      .addBody([
          kExprCallFunction, import_index, // suspend
      ]).exportFunc();
  function js_import() {
    return Promise.resolve(0.5);
  };
  let wasm_js_import = new WebAssembly.Suspending(js_import);

  let instance = builder.instantiate({m: {import: wasm_js_import}});
  let wrapped_export = WebAssembly.promising(instance.exports.test);
  let combined_promise = wrapped_export();
  assertPromiseResult(combined_promise, v => assertEquals(0.5, v));
})();

// Throw an exception before suspending. The export wrapper should return a
// promise rejected with the exception.
(function TestStackSwitchException1() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let tag = builder.addTag(kSig_v_v);
  builder.addFunction("throw", kSig_i_v)
      .addBody([kExprThrow, tag]).exportFunc();
  let instance = builder.instantiate();
  let wrapper = WebAssembly.promising(instance.exports.throw);
  assertThrowsAsync(wrapper(), WebAssembly.Exception);
})();

// Throw an exception after the first resume event, which propagates to the
// promise wrapper.
(function TestStackSwitchException2() {
  print(arguments.callee.name);
  let tag = new WebAssembly.Tag({parameters: []});
  let builder = new WasmModuleBuilder();
  import_index = builder.addImport('m', 'import', kSig_i_v);
  tag_index = builder.addImportedTag('m', 'tag', kSig_v_v);
  builder.addFunction("test", kSig_i_v)
      .addBody([
          kExprCallFunction, import_index,
          kExprThrow, tag_index
      ]).exportFunc();
  function js_import() {
    return Promise.resolve(42);
  };
  let wasm_js_import = new WebAssembly.Suspending(js_import);

  let instance = builder.instantiate({m: {import: wasm_js_import, tag: tag}});
  let wrapped_export = WebAssembly.promising(instance.exports.test);
  let combined_promise = wrapped_export();
  assertThrowsAsync(combined_promise, WebAssembly.Exception);
})();

(function TestStackSwitchPromiseReject() {
  print(arguments.callee.name);
  let tag = new WebAssembly.Tag({parameters: ['i32']});
  let builder = new WasmModuleBuilder();
  import_index = builder.addImport('m', 'import', kSig_i_v);
  tag_index = builder.addImportedTag('m', 'tag', kSig_v_i);
  builder.addFunction("test", kSig_i_v)
      .addBody([
          kExprTry, kWasmI32,
          kExprCallFunction, import_index,
          kExprCatch, tag_index,
          kExprEnd,
      ]).exportFunc();
  function js_import() {
    return Promise.reject(new WebAssembly.Exception(tag, [42]));
  };
  let wasm_js_import = new WebAssembly.Suspending(js_import);

  let instance = builder.instantiate({m: {import: wasm_js_import, tag: tag}});
  let wrapped_export = WebAssembly.promising(instance.exports.test);
  let combined_promise = wrapped_export();
  assertPromiseResult(combined_promise, v => assertEquals(v, 42));
})();

function TestNestedSuspenders(suspend) {
  // Nest two suspenders. The call chain looks like:
  // outer (wasm) -> outer (js) -> inner (wasm) -> inner (js)
  // If 'suspend' is true, the inner JS function returns a Promise, which
  // suspends the inner wasm function, which returns a Promise, which suspends
  // the outer wasm function, which returns a Promise. The inner Promise
  // resolves first, which resumes the inner continuation. Then the outer
  // promise resolves which resumes the outer continuation.
  // If 'suspend' is false, the inner and outer JS functions return a regular
  // value and no computation is suspended.
  let builder = new WasmModuleBuilder();
  inner_index = builder.addImport('m', 'inner', kSig_i_v);
  outer_index = builder.addImport('m', 'outer', kSig_i_v);
  builder.addFunction("outer", kSig_i_v)
      .addBody([
          kExprCallFunction, outer_index
      ]).exportFunc();
  builder.addFunction("inner", kSig_i_v)
      .addBody([
          kExprCallFunction, inner_index
      ]).exportFunc();

  let inner = new WebAssembly.Suspending(() => suspend ? Promise.resolve(42) : 42);

  let export_inner;
  let outer = new WebAssembly.Suspending(() => suspend ? export_inner() : 42);

  let instance = builder.instantiate({m: {inner, outer}});
  export_inner = WebAssembly.promising(instance.exports.inner);
  let export_outer = WebAssembly.promising(instance.exports.outer);
  assertPromiseResult(export_outer(), v => assertEquals(42, v));
}

(function TestNestedSuspendersSuspend() {
  print(arguments.callee.name);
  TestNestedSuspenders(true);
})();

(function TestNestedSuspendersNoSuspend() {
  print(arguments.callee.name);
  TestNestedSuspenders(false);
})();

(function Regress13231() {
  print(arguments.callee.name);
  // Check that a promising function with no return is allowed.
  let builder = new WasmModuleBuilder();
  builder.addFunction("export", kSig_v_v).addBody([]).exportFunc();
  let instance = builder.instantiate();
  let export_wrapper = WebAssembly.promising(instance.exports.export);
  let export_sig = export_wrapper.type();
  assertEquals([], export_sig.parameters);
  assertEquals(['externref'], export_sig.results);
})();

(function TestStackOverflow() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("test", kSig_i_v)
      .addBody([
          kExprCallFunction, 0
          ]).exportFunc();
  let instance = builder.instantiate();
  let wrapper = WebAssembly.promising(instance.exports.test);
  assertThrowsAsync(wrapper(), RangeError, /Maximum call stack size exceeded/);
})();

(function SuspendCallRef() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let funcref_type = builder.addType(kSig_i_v);
  let table = builder.addTable(wasmRefNullType(funcref_type), 1)
                         .exportAs('table');
  builder.addFunction("test", kSig_i_v)
      .addBody([
          kExprI32Const, 0, kExprTableGet, table.index,
          kExprCallRef, funcref_type,
      ]).exportFunc();
  let instance = builder.instantiate();

  let funcref = new WebAssembly.Function(
      {parameters: [], results: ['i32']},
        new WebAssembly.Suspending(() => Promise.resolve(42)));
  instance.exports.table.set(0, funcref);

  let exp = WebAssembly.promising(instance.exports.test);
  assertPromiseResult(exp(), v => assertEquals(42, v));
})();

(function SuspendCallIndirect() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let functype = builder.addType(kSig_i_v);
  let table = builder.addTable(kWasmFuncRef, 10, 10);
  let callee = builder.addImport('m', 'f', kSig_i_v);
  builder.addActiveElementSegment(table, wasmI32Const(0), [callee]);
  builder.addFunction("test", kSig_i_v)
      .addBody([
          kExprI32Const, 0,
          kExprCallIndirect, functype, table.index,
      ]).exportFunc();

  let create_promise = new WebAssembly.Suspending(() => Promise.resolve(42));

  let instance = builder.instantiate({m: {f: create_promise}});

  let exp = WebAssembly.promising(instance.exports.test);
  assertPromiseResult(exp(), v => assertEquals(42, v));
})();

(function TestSuspendJSFramesTraps() {
  // The call stack of this test looks like:
  // export1 -> import1 -> export2 -> import2
  // Where export1 is "promising" and import2 is "suspending". Returning a
  // promise from import2 should trap because of the JS import in the middle.
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let import1_index = builder.addImport("m", "import1", kSig_i_v);
  let import2_index = builder.addImport("m", "import2", kSig_i_v);
  builder.addFunction("export1", kSig_i_v)
      .addBody([
          // export1 -> import1 (unwrapped)
          kExprCallFunction, import1_index,
      ]).exportFunc();
  builder.addFunction("export2", kSig_i_v)
      .addBody([
          // export2 -> import2 (suspending)
          kExprCallFunction, import2_index,
      ]).exportFunc();
  let instance;
  function import1() {
    // import1 -> export2 (unwrapped)
    instance.exports.export2();
  }
  function import2() {
    return Promise.resolve(0);
  }
  import2 = new WebAssembly.Suspending(import2);
  instance = builder.instantiate(
      {'m':
        {'import1': import1,
         'import2': import2
        }});
  // export1 (promising)
  let wrapper = WebAssembly.promising(instance.exports.export1);
  assertThrowsAsync(wrapper(), WebAssembly.RuntimeError,
      /trying to suspend JS frames/);
})();

(function TestSwitchingToTheCentralStackForRuntime() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let table = builder.addTable(kWasmExternRef, 1);
  let array_index = builder.addArray(kWasmI32, true);
  let new_space_full_index = builder.addImport('m', 'new_space_full', kSig_v_v);
  builder.addFunction("test", kSig_i_r)
      .addBody([
        kExprLocalGet, 0,
        kExprI32Const, 1,
        kNumericPrefix, kExprTableGrow, table.index]).exportFunc();
  builder.addFunction("test2", kSig_i_r)
      .addBody([
        kExprI32Const, 1]).exportFunc();
  builder.addFunction("test3", kSig_l_v)
      .addBody([
        kExprCallFunction, new_space_full_index,
        ...wasmI64Const(0)
        ]).exportFunc();
  builder.addFunction("test4", kSig_v_v)
      .addBody([
        kExprCallFunction, new_space_full_index,
        kExprI32Const, 1,
        kGCPrefix, kExprArrayNewDefault, array_index,
        kExprDrop]).exportFunc();
  function new_space_full() {
    %SimulateNewspaceFull();
  }
  let instance = builder.instantiate({m: {new_space_full}});
  let wrapper = WebAssembly.promising(instance.exports.test);
  let wrapper2 = WebAssembly.promising(instance.exports.test2);
  let wrapper3 = WebAssembly.promising(instance.exports.test3);
  let wrapper4 = WebAssembly.promising(instance.exports.test4);
  function switchesToCS(fn) {
    const beforeCall = %WasmSwitchToTheCentralStackCount();
    fn();
    return %WasmSwitchToTheCentralStackCount() - beforeCall;
  }

  // Calling exported functions from the central stack.
  assertEquals(0, switchesToCS(() => instance.exports.test({})));
  assertEquals(0, switchesToCS(() => instance.exports.test2({})));
  assertEquals(0, switchesToCS(() => instance.exports.test3({})));
  assertEquals(0, switchesToCS(() => instance.exports.test4({})));

  // Runtime call to table.grow.
  switchesToCS(wrapper);
  // No runtime calls.
  switchesToCS(wrapper2);
  // Runtime call to allocate the bigint.
  switchesToCS(wrapper3);
  // Runtime call for array.new.
  switchesToCS(wrapper4);
  %CheckIsOnCentralStack();
})();

(function TestSwitchingToTheCentralStackForJS() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  import_index = builder.addImport('m', 'import', kSig_i_v);
  builder.addFunction("test", kSig_i_v)
      .addBody([
          kExprCallFunction, import_index,
      ]).exportFunc();
  let js_import = new WebAssembly.Suspending(
      () => {
        %CheckIsOnCentralStack();
        return 123;
      });
  let instance = builder.instantiate({m: {import: js_import}});
  let wrapped_export = WebAssembly.promising(instance.exports.test);
  assertPromiseResult(wrapped_export(), v => assertEquals(123, v));
})();

// Test that the wasm-to-js stack params get scanned.
(function TestSwitchingToTheCentralStackManyParams() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  const num_params = 10;
  const sig = makeSig(Array(num_params).fill(kWasmExternRef), [kWasmExternRef]);
  const import_index = builder.addImport('m', 'import_', sig);
  let body = [];
  for (let i = 0; i < num_params; ++i) {
    body.push(kExprLocalGet, i);
  }
  body.push(kExprCallFunction, import_index);
  builder.addFunction("test", sig)
      .addBody(body).exportFunc();
  function import_js(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9) {
    gc();
    return [arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9];
  };
  import_js();
  let import_ = new WebAssembly.Suspending(import_js);
  let instance = builder.instantiate({m: {import_}});
  let wrapper = WebAssembly.promising(instance.exports.test);
  let args = Array(num_params).fill({});
  assertPromiseResult(wrapper(...args), results => { assertEquals(args, results); });
})();

// Similar to TestNestedSuspenders, but trigger an infinite recursion inside the
// outer wasm function after the import call. This is likely to crash if the
// stack limit is not properly restored when we return from the central stack.
// In particular in the nested case, we should preserve and restore the limit of
// each intermediate secondary stack.
(function TestCentralStackReentrency() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  inner_index = builder.addImport('m', 'inner', kSig_i_v);
  outer_index = builder.addImport('m', 'outer', kSig_i_v);
  let stack_overflow = builder.addFunction('stack_overflow', kSig_v_v)
      .addBody([kExprCallFunction, 2]);
  builder.addFunction("outer", kSig_i_v)
      .addBody([
          kExprCallFunction, outer_index,
          kExprCallFunction, stack_overflow.index,
      ]).exportFunc();
  builder.addFunction("inner", kSig_i_v)
      .addBody([
          kExprCallFunction, inner_index
      ]).exportFunc();

  let inner = new WebAssembly.Suspending(() => Promise.resolve(42));

  let export_inner;
  let outer = new WebAssembly.Suspending(() => export_inner());

  let instance = builder.instantiate({m: {inner, outer}});
  export_inner = WebAssembly.promising(instance.exports.inner);
  let export_outer = WebAssembly.promising(instance.exports.outer);
  assertThrowsAsync(export_outer(), RangeError,
      /Maximum call stack size exceeded/);
})();

(function TestStackSwitchRegressStackLimit() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  suspend_index = builder.addImport('m', 'suspend', kSig_v_r);
  let leaf_index = builder.addFunction("leaf", kSig_v_v)
      .addBody([
      ]).index;
  let stackcheck_index = builder.addFunction("stackcheck", kSig_v_v)
      .addBody([
          kExprCallFunction, leaf_index,
      ]).index;
  builder.addFunction("test", kSig_v_r)
      .addBody([
          kExprLocalGet, 0,
          kExprCallFunction, suspend_index,
          // This call should not throw a stack overflow.
          kExprCallFunction, stackcheck_index,
      ]).exportFunc();
  let suspend = new WebAssembly.Suspending(() => Promise.resolve());
  let instance = builder.instantiate({m: {suspend}});
  let wrapped_export = WebAssembly.promising(instance.exports.test);
  assertPromiseResult(wrapped_export(), v => assertEquals(undefined, v));
})();

(function TestSuspendTwoModules() {
  print(arguments.callee.name);
  let builder1 = new WasmModuleBuilder();
  import_index = builder1.addImport('m', 'import', kSig_i_v);
  builder1.addFunction("f", kSig_i_v)
      .addBody([
          kExprCallFunction, import_index, // suspend
          kExprI32Const, 1,
          kExprI32Add,
      ]).exportFunc();
  let js_import = new WebAssembly.Suspending(() => Promise.resolve(1));
  let instance1 = builder1.instantiate({m: {import: js_import}});
  let builder2 = new WasmModuleBuilder();
  import_index = builder2.addImport('m', 'import', kSig_i_v);
  builder2.addFunction("main", kSig_i_v)
      .addBody([
          kExprCallFunction, import_index,
          kExprI32Const, 1,
          kExprI32Add,
      ]).exportFunc();
  let instance2 = builder2.instantiate({m: {import: instance1.exports.f}});
  let wrapped_export = WebAssembly.promising(instance2.exports.main);
  let combined_promise = wrapped_export();
  assertPromiseResult(combined_promise, v => assertEquals(3, v));
})();
                                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/wasm/stack.js                                                      0000664 0000000 0000000 00000015150 14746647661 0021131 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --no-force-slow-path

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// The stack trace contains file path, only keep "stack.js".
function stripPath(s) {
  return s.replace(/[^ (]*stack\.js/g, "stack.js");
}

function verifyStack(frames, expected) {
  assertEquals(expected.length, frames.length, "number of frames mismatch");
  expected.forEach(function(exp, i) {
    assertEquals(exp[1], frames[i].getFunctionName(),
        "["+i+"].getFunctionName()");
    assertEquals(exp[2], frames[i].getLineNumber(), "["+i+"].getLineNumber()");
    if (exp[0])
      assertEquals(exp[3], frames[i].getPosition(),
          "["+i+"].getPosition()");
    assertContains(exp[4], frames[i].getFileName(), "["+i+"].getFileName()");
    var toString;
    if (exp[0]) {
      toString = exp[4] + ":wasm-function[" + exp[6] + "]:" + exp[5];
      if (exp[1] !== null) toString = exp[1] + " (" + toString + ")";
    } else {
      toString = exp[4] + ":" + exp[2] + ":";
    }
    assertContains(toString, frames[i].toString(), "["+i+"].toString()");
  });
}


var stack;
function STACK() {
  var e = new Error();
  stack = e.stack;
}

var builder = new WasmModuleBuilder();

builder.addMemory(0, 1);

builder.addImport("mod", "func", kSig_v_v);

builder.addFunction("main", kSig_v_v)
  .addBody([kExprCallFunction, 0])
  .exportAs("main");

builder.addFunction("exec_unreachable", kSig_v_v)
  .addBody([kExprUnreachable])
  .exportAs("exec_unreachable");

// Make this function unnamed, just to test also this case.
var mem_oob_func = builder.addFunction(undefined, kSig_i_v)
  // Access the memory at offset -1, to provoke a trap.
  .addBody([kExprI32Const, 0x7f, kExprI32LoadMem8S, 0, 0]);

// Call the mem_out_of_bounds function, in order to have two wasm stack frames.
builder.addFunction("call_mem_out_of_bounds", kSig_i_v)
  .addBody([kExprCallFunction, mem_oob_func.index])
  .exportAs("call_mem_out_of_bounds");

var module = builder.instantiate({mod: {func: STACK}});

(function testSimpleStack() {
  var expected_string = 'Error\n' +
      // The line numbers below will change as this test gains / loses lines..
      '    at STACK (stack.js:38:11)\n' +                            // --
      '    at main (wasm://wasm/862e1cf6:wasm-function[1]:0x72)\n' + // --
      '    at testSimpleStack (stack.js:76:18)\n' +                  // --
      '    at stack.js:78:3';                                        // --

  module.exports.main();
  assertEquals(expected_string, stripPath(stack));
})();

// For the remaining tests, collect the Callsite objects instead of just a
// string:
Error.prepareStackTrace = function(error, frames) {
  return frames;
};

(function testStackFrames() {
  module.exports.main();

  verifyStack(stack, [
      // isWasm           function   line   pos                    file  offset funcIndex
      [   false,           "STACK",    38,    0,             "stack.js"],
      [    true,            "main",     1, 0x72, "wasm://wasm/862e1cf6", '0x72',        1],
      [   false, "testStackFrames",    87,    0,             "stack.js"],
      [   false,              null,    96,    0,             "stack.js"]
  ]);
})();

(function testWasmUnreachable() {
  try {
    module.exports.exec_unreachable();
    fail("expected wasm exception");
  } catch (e) {
    assertContains("unreachable", e.message);
    verifyStack(e.stack, [
        // isWasm               function   line  pos                    file  offset funcIndex
        [    true,    "exec_unreachable",    1, 0x77, "wasm://wasm/862e1cf6", '0x77',        2],
        [   false, "testWasmUnreachable",  100,    0,             "stack.js"],
        [   false,                  null,  111,    0,             "stack.js"]
    ]);
  }
})();

(function testWasmMemOutOfBounds() {
  try {
    module.exports.call_mem_out_of_bounds();
    fail("expected wasm exception");
  } catch (e) {
    assertContains("out of bounds", e.message);
    verifyStack(e.stack, [
        // isWasm                  function   line   pos                    file  offset funcIndex
        [    true,                     null,     1, 0x7d, "wasm://wasm/862e1cf6", '0x7d',        3],
        [    true, "call_mem_out_of_bounds",     1, 0x83, "wasm://wasm/862e1cf6", '0x83',        4],
        [   false, "testWasmMemOutOfBounds",   115,    0,             "stack.js"],
        [   false,                     null,   127,    0,             "stack.js"]
    ]);
  }
})();

(function testStackOverflow() {
  print("testStackOverflow");
  var builder = new WasmModuleBuilder();

  var sig_index = builder.addType(kSig_v_v);
  builder.addFunction("recursion", sig_index)
    .addBody([
      kExprI32Const, 0,
      kExprCallIndirect, sig_index, kTableZero
    ])
    .exportFunc();
  builder.appendToTable([0]);

  try {
    builder.instantiate().exports.recursion();
    fail("expected wasm exception");
  } catch (e) {
    assertEquals("Maximum call stack size exceeded", e.message, "trap reason");
    assertTrue(e.stack.length >= 4, "expected at least 4 stack entries");
    verifyStack(e.stack.splice(0, 4), [
        // isWasm     function  line   pos                    file  offset funcIndex
        [    true, "recursion",    1, 0x34, "wasm://wasm/80a35e5a", '0x34',        0],
        [    true, "recursion",    1, 0x37, "wasm://wasm/80a35e5a", '0x37',        0],
        [    true, "recursion",    1, 0x37, "wasm://wasm/80a35e5a", '0x37',        0],
        [    true, "recursion",    1, 0x37, "wasm://wasm/80a35e5a", '0x37',        0]
    ]);
  }
})();

(function testBigOffset() {
  print('testBigOffset');
  var builder = new WasmModuleBuilder();

  let body = [kExprI32Const, 0, kExprI32Add];
  while (body.length <= 65536) body = body.concat(body);
  body.unshift(kExprI32Const, 0);
  body.push(kExprUnreachable);
  let unreachable_pos = body.length - 1;

  builder.addFunction('main', kSig_v_v).addBody(body).exportFunc();

  try {
    builder.instantiate().exports.main();
    fail('expected wasm exception');
  } catch (e) {
    assertEquals('unreachable', e.message, 'trap reason');
    let hexOffset = '0x' + (unreachable_pos + 0x25).toString(16);
    verifyStack(e.stack, [
      // isWasm         function line                     pos                    file     offset funcIndex
      [    true,          'main',   1, unreachable_pos + 0x25, 'wasm://wasm/000600e6', hexOffset,        0],
      [   false, 'testBigOffset', 171,                      0,             'stack.js'],
      [   false,            null, 183,                      0,             'stack.js']
    ]);
  }
})();
                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/wasm/stackwalk.js                                                  0000664 0000000 0000000 00000004134 14746647661 0022010 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm --expose-gc --allow-natives-syntax

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function makeFFI(func) {
  var builder = new WasmModuleBuilder();

  var sig_index = builder.addType(kSig_i_dd);
  builder.addImport("mom", "func", sig_index);
  builder.addFunction("main", sig_index)
    .addBody([
      kExprLocalGet, 0,            // --
      kExprLocalGet, 1,            // --
      kExprCallFunction, 0,        // --
    ])
    .exportFunc()

  return builder.instantiate({mom: {func: func}}).exports.main;
}


function makeReentrantFFI(func) {
  var main = makeFFI(reenter);

  function reenter(a, b) {
    print(" reenter " + a);
    if (a > 0) main(a - 1, b);
    else func();
  }
  return main;
}


function runTest(builder) {
  // ---- THROWING TEST -----------------------------------------------

  function throwadd(a, b) {
    print("-- trying throw --");
    throw a + b;
  }

  function throwa(a) {
    print("-- trying throw --");
    throw a;
  }

  function throwstr() {
    print("-- trying throw --");
    throw "string";
  }

  assertThrows(builder(throwadd));
  assertThrows(builder(throwa));
  assertThrows(builder(throwstr));

  try {
    builder(throwadd)(7.8, 9.9);
  } catch(e) {
    print(e);
  }

  try {
    builder(throwa)(11.8, 9.3);
  } catch(e) {
    print(e);
  }


  try {
    builder(throwstr)(3, 5);
  } catch(e) {
    print(e);
  }


  // ---- DEOPT TEST -----------------------------------------------

  function deopt() {
    print("-- trying deopt --");
    %DeoptimizeFunction(deopter);
  }

  var deopter = builder(deopt);

  deopter(5, 5);
  for (var i = 0; i < 9; i++) {
    deopter(6, 6);
  }


  // ---- GC TEST -----------------------------------------------
  function dogc(a, b) {
    print("-- trying gc --");
    gc();
    gc();
  }


  var gcer = builder(dogc);
  gcer(7, 7);

  for (var i = 0; i < 9; i++) {
    gcer(8, 8);
  }
}

runTest(makeReentrantFFI);
runTest(makeFFI);
                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/test/mjsunit/wasm/start-function.js                                             0000664 0000000 0000000 00000010752 14746647661 0023007 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function instantiate(sig, body) {
  var builder = new WasmModuleBuilder();

  var func = builder.addFunction("", sig)
    .addBody(body);

  builder.addStart(func.index);

  return builder.instantiate();
}

function assertVerifies(sig, body) {
  var module = instantiate(sig, body);
  assertFalse(module === undefined);
  assertFalse(module === null);
  assertFalse(module === 0);
  assertEquals("object", typeof module);
  return module;
}

assertVerifies(kSig_v_v, [kExprNop]);

// Arguments aren't allowed to start functions.
assertThrows(() => {instantiate(kSig_i_i, [kExprLocalGet, 0]);});
assertThrows(() => {instantiate(kSig_i_ii, [kExprLocalGet, 0]);});
assertThrows(() => {instantiate(kSig_i_dd, [kExprLocalGet, 0]);});
assertThrows(() => {instantiate(kSig_i_v, [kExprI32Const, 0]);});

(function testInvalidIndex() {
  print("testInvalidIndex");
  var builder = new WasmModuleBuilder();

  var func = builder.addFunction("", kSig_v_v)
    .addBody([kExprNop]);

  builder.addStart(func.index + 1);

  assertThrows(
      () => builder.instantiate(), WebAssembly.CompileError,
      'WebAssembly.Module(): ' +
          'function index 1 out of bounds (1 entry) @+20');
})();


(function testTwoStartFuncs() {
  print("testTwoStartFuncs");
  var builder = new WasmModuleBuilder();

  var func = builder.addFunction("", kSig_v_v)
    .addBody([kExprNop]);

  builder.addExplicitSection([kStartSectionCode, 0]);
  builder.addExplicitSection([kStartSectionCode, 0]);

  assertThrows(
      () => builder.instantiate(), WebAssembly.CompileError,
      'WebAssembly.Module(): unexpected section <Start> @+27');
})();


(function testRun1() {
  print("testRun1");
  var builder = new WasmModuleBuilder();

  builder.addMemory(12, 12);
  builder.exportMemoryAs("memory");

  var func = builder.addFunction("", kSig_v_v)
    .addBody([kExprI32Const, 0, kExprI32Const, 55, kExprI32StoreMem, 0, 0]);

  builder.addStart(func.index);

  var module = builder.instantiate();
  var memory = module.exports.memory.buffer;
  var view = new Int8Array(memory);
  assertEquals(55, view[0]);
})();

(function testRun2() {
  print("testRun2");
  var builder = new WasmModuleBuilder();

  builder.addMemory(12, 12);
  builder.exportMemoryAs("memory");

  var func = builder.addFunction("", kSig_v_v)
    .addBody([kExprI32Const, 0, kExprI32Const, 22, kExprI32Const, 55, kExprI32Add, kExprI32StoreMem, 0, 0]);

  builder.addStart(func.index);

  var module = builder.instantiate();
  var memory = module.exports.memory.buffer;
  var view = new Int8Array(memory);
  assertEquals(77, view[0]);
})();

(function testStartFFI() {
  print("testStartFFI");
  var ranned = false;
  var ffi = {gak: {foo : function() {
    print("we ranned at stert!");
    ranned = true;
  }}};

  var builder = new WasmModuleBuilder();
  var sig_index = builder.addType(kSig_v_v);

  builder.addImport("gak", "foo", sig_index);
  var func = builder.addFunction("", sig_index)
    .addBody([kExprCallFunction, 0]);

  builder.addStart(func.index);

  var module = builder.instantiate(ffi);
  assertTrue(ranned);
})();

(function testStartFunctionThrowsExplicitly() {
  print('testStartFunctionThrowsExplicitly');
  let error = new Error('my explicit error');
  var ffi = {
    foo: {
      throw_fn: function() {
        throw error;
      }
    }
  };
  let builder = new WasmModuleBuilder();
  builder.addImport('foo', 'throw_fn', kSig_v_v);
  let func = builder.addFunction('', kSig_v_v).addBody([kExprCallFunction, 0]);
  builder.addStart(func.index);

  assertThrowsEquals(() => builder.instantiate(ffi), error);
  assertPromiseResult(builder.asyncInstantiate(ffi), assertUnreachable,
    e => assertSame(e, error));
  assertPromiseResult(WebAssembly.instantiate(builder.toModule(), ffi),
    assertUnreachable, e => assertSame(e, error));
})();

(function testStartFunctionThrowsImplicitly() {
  print("testStartFunctionThrowsImplicitly");
  let builder = new WasmModuleBuilder();
  let func = builder.addFunction('', kSig_v_v).addBody([kExprUnreachable]);
  builder.addStart(func.index);

  assertThrows(
      () => builder.instantiate(), WebAssembly.RuntimeError, /unreachable/);
  assertThrowsAsync(builder.asyncInstantiate(), WebAssembly.RuntimeError);
  assertThrowsAsync(
      WebAssembly.instantiate(builder.toModule()), WebAssembly.RuntimeError);
})();
                      node-23.7.0/deps/v8/test/mjsunit/wasm/streaming-api.js                                              0000664 0000000 0000000 00000005206 14746647661 0022565 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-test-streaming

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestCompileStreaming() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("main", kSig_i_i)
         .addBody([kExprLocalGet, 0])
         .exportAs("main");
  let bytes = builder.toBuffer();
  assertPromiseResult(WebAssembly.compileStreaming(Promise.resolve(bytes)).then(
    module => WebAssembly.instantiate(module)).then(
      instance => assertEquals(5, instance.exports.main(5))));
})();

(function TestInstantiateStreaming() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("main", kSig_i_i)
         .addBody([kExprLocalGet, 0])
         .exportAs("main");
  let bytes = builder.toBuffer();
  assertPromiseResult(WebAssembly.instantiateStreaming(Promise.resolve(bytes)).then(
    ({module, instance}) => assertEquals(5, instance.exports.main(5))));
})();

(function TestCompileStreamingRejectedInputPromise() {
  print(arguments.callee.name);
  assertPromiseResult(WebAssembly.compileStreaming(Promise.reject("myError")),
    assertUnreachable,
    error => assertEquals(error, "myError"));
})();

(function TestInstantiateStreamingRejectedInputPromise() {
  print(arguments.callee.name);
  assertPromiseResult(WebAssembly.instantiateStreaming(Promise.reject("myError")),
    assertUnreachable,
    error => assertEquals(error, "myError"));
})();

(function TestStreamingErrorMessage() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("main", kSig_i_i)
         .addBody([kExprLocalGet, 0,
                   kExprLocalGet, 0,
                   kExprF32Mul])
         .exportAs("main");
  let bytes = builder.toBuffer();
  assertPromiseResult(WebAssembly.compileStreaming(Promise.resolve(bytes)),
    assertUnreachable,
    error => assertEquals("WebAssembly.compileStreaming(): Compiling " +
                          "function #0:\"main\" failed: f32.mul[0] expected " +
                          "type f32, found local.get of type i32 @+35",
                          error.message));
  assertPromiseResult(WebAssembly.instantiateStreaming(Promise.resolve(bytes)),
    assertUnreachable,
    error => assertEquals("WebAssembly.instantiateStreaming(): Compiling " +
                          "function #0:\"main\" failed: f32.mul[0] expected " +
                          "type f32, found local.get of type i32 @+35",
                          error.message));
})();
                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/wasm/streaming-compile.js                                          0000664 0000000 0000000 00000000445 14746647661 0023444 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-test-streaming --expose-wasm --allow-natives-syntax

d8.file.execute("test/mjsunit/wasm/async-compile.js");
                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/wasm/streaming-error-position.js                                   0000664 0000000 0000000 00000035163 14746647661 0025014 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-test-streaming --expose-wasm

'use strict';

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

function testErrorPosition(bytes, pos, message) {
  const buffer = bytes.trunc_buffer();
  // First check the non-streaming decoder as a reference.
  const regexp = new RegExp(message + '.*@\\+' + pos);
  assertThrows(
      () => new WebAssembly.Module(buffer), WebAssembly.CompileError, regexp);
  // Next test the actual streaming decoder.
  assertThrowsAsync(
      WebAssembly.compile(buffer), WebAssembly.CompileError, regexp);
}

(function testInvalidMagic() {
  let bytes = new Binary;
  bytes.emit_bytes([
    kWasmH0, kWasmH1 + 1, kWasmH2, kWasmH3, kWasmV0, kWasmV1, kWasmV2, kWasmV3
  ]);
  // Error at pos==0 because that's where the magic word is.
  testErrorPosition(bytes, 0, 'expected magic word');
})();

(function testInvalidVersion() {
  let bytes = new Binary;
  bytes.emit_bytes([
    kWasmH0, kWasmH1, kWasmH2, kWasmH3, kWasmV0, kWasmV1 + 1, kWasmV2, kWasmV3
  ]);
  // Error at pos==4 because that's where the version word is.
  testErrorPosition(bytes, 4, 'expected version');
})();

(function testSectionLengthInvalidVarint() {
  let bytes = new Binary;
  bytes.emit_header();
  bytes.emit_u8(kTypeSectionCode);
  bytes.emit_bytes([0x80, 0x80, 0x80, 0x80, 0x80, 0x00]);
  let pos = bytes.length - 1 - 1;
  testErrorPosition(bytes, pos, 'length overflow while decoding section length');
})();

(function testSectionLengthTooBig() {
  let bytes = new Binary;
  bytes.emit_header();
  let pos = bytes.length;
  bytes.emit_u8(kTypeSectionCode);
  bytes.emit_u32v(0xffffff23);
  testErrorPosition(
      bytes, pos,
      'section \\(code 1, "Type"\\) extends past end of the module ' +
          '\\(length 4294967075, remaining bytes 0\\)');
})();

(function testFunctionsCountInvalidVarint() {
  let bytes = new Binary;
  bytes.emit_header();
  bytes.emit_bytes([
      kTypeSectionCode,  // section id
      1,                 // section length
      0                  // number of types
  ]);
  bytes.emit_bytes([
      kFunctionSectionCode,  // section id
      1,                     // section length
      0                      // number of functions
  ]);
  let pos = bytes.length;
  bytes.emit_bytes([
      kCodeSectionCode,  // section id
      20,                // section length (arbitrary value > 6)
  ]);
  // Functions count
  bytes.emit_bytes([0x80, 0x80, 0x80, 0x80, 0x80, 0x00]);

  testErrorPosition(
      bytes, pos,
      'section \\(code 10, "Code"\\) extends past end of the module ' +
          '\\(length 20, remaining bytes 6\\)');
})();

(function testFunctionsCountTooBig() {
  let bytes = new Binary;
  bytes.emit_header();
  bytes.emit_bytes([
      kTypeSectionCode,  // section id
      1,                 // section length
      0                  // number of types
  ]);
  bytes.emit_bytes([
      kFunctionSectionCode,  // section id
      1,                     // section length
      0                      // number of functions
  ]);
  let pos = bytes.length;
  bytes.emit_bytes([
      kCodeSectionCode,  // section id
      20,                // section length (arbitrary value > 6)
  ]);
  // Functions count
  bytes.emit_u32v(0xffffff23);

  testErrorPosition(
      bytes, pos,
      'section \\(code 10, "Code"\\) extends past end of the module ' +
          '\\(length 20, remaining bytes 5\\)');
})();

(function testFunctionsCountDoesNotMatch() {
  let bytes = new Binary;
  bytes.emit_header();
  bytes.emit_bytes([
      kTypeSectionCode,  // section id
      1,                 // section length
      0                  // number of types
  ]);
  bytes.emit_bytes([
      kFunctionSectionCode,  // section id
      1,                     // section length
      0                      // number of functions
  ]);
  let pos = bytes.length;
  bytes.emit_bytes([
      kCodeSectionCode,  // section id
      20,                // section length (arbitrary value > 6)
  ]);
  // Functions count (different than the count in the functions section.
  bytes.emit_u32v(5);

  testErrorPosition(
      bytes, pos,
      'section \\(code 10, "Code"\\) extends past end of the module ' +
          '\\(length 20, remaining bytes 1\\)');
})();

(function testBodySizeInvalidVarint() {
  let bytes = new Binary;
  bytes.emit_header();
  bytes.emit_bytes([
      kTypeSectionCode,       // section id
      4,                      // section length
      1,                      // number of types
      kWasmFunctionTypeForm,  // type
      0,                      // number of parameter
      0                       // number of returns
  ]);
  bytes.emit_bytes([
      kFunctionSectionCode,  // section id
      2,                     // section length
      1,                     // number of functions
      0                      // signature index
  ]);
  let pos = bytes.length;
  bytes.emit_bytes([
      kCodeSectionCode,  // section id
      20,                // section length (arbitrary value > 6)
      1                  // functions count
  ]);
  // Invalid function body size.
  bytes.emit_bytes([0x80, 0x80, 0x80, 0x80, 0x80, 0x00]);

  testErrorPosition(
      bytes, pos,
      'section \\(code 10, "Code"\\) extends past end of the module ' +
          '\\(length 20, remaining bytes 7\\)');
})();

(function testBodySizeTooBig() {
  let bytes = new Binary;
  bytes.emit_header();
  bytes.emit_bytes([
      kTypeSectionCode,       // section id
      4,                      // section length
      1,                      // number of types
      kWasmFunctionTypeForm,  // type
      0,                      // number of parameter
      0                       // number of returns
  ]);
  bytes.emit_bytes([
      kFunctionSectionCode,  // section id
      2,                     // section length
      1,                     // number of functions
      0                      // signature index
  ]);
  let pos = bytes.length;
  bytes.emit_bytes([
      kCodeSectionCode,  // section id
      20,                // section length (arbitrary value > 6)
      1                  // functions count
  ]);
  // Invalid function body size.
  bytes.emit_u32v(0xffffff23);

  testErrorPosition(
      bytes, pos,
      'section \\(code 10, "Code"\\) extends past end of the module ' +
          '\\(length 20, remaining bytes 6\\)');
})();

(function testBodySizeDoesNotFit() {
  let bytes = new Binary;
  bytes.emit_header();
  bytes.emit_bytes([
      kTypeSectionCode,       // section id
      4,                      // section length
      1,                      // number of types
      kWasmFunctionTypeForm,  // type
      0,                      // number of parameter
      0                       // number of returns
  ]);
  bytes.emit_bytes([
      kFunctionSectionCode,  // section id
      2,                     // section length
      1,                     // number of functions
      0                      // signature index
  ]);
  let pos = bytes.length;
  bytes.emit_bytes([
      kCodeSectionCode,  // section id
      20,                // section length (arbitrary value > 6)
      1                  // functions count
  ]);
  // Invalid function body size (does not fit into the code section).
  bytes.emit_u32v(20);

  testErrorPosition(
      bytes, pos,
      'section \\(code 10, "Code"\\) extends past end of the module ' +
          '\\(length 20, remaining bytes 2\\)');
})();

(function testBodySizeIsZero() {
  let bytes = new Binary;
  bytes.emit_header();
  bytes.emit_bytes([
      kTypeSectionCode,       // section id
      4,                      // section length
      1,                      // number of types
      kWasmFunctionTypeForm,  // type
      0,                      // number of parameter
      0                       // number of returns
  ]);
  bytes.emit_bytes([
      kFunctionSectionCode,  // section id
      2,                     // section length
      1,                     // number of functions
      0                      // signature index
  ]);
  let pos = bytes.length;
  bytes.emit_bytes([
      kCodeSectionCode,  // section id
      20,                // section length (arbitrary value > 6)
      1                  // functions count
  ]);
  // Invalid function body size (body size of 0 is invalid).
  bytes.emit_u32v(0);

  testErrorPosition(
      bytes, pos,
      'section \\(code 10, "Code"\\) extends past end of the module ' +
          '\\(length 20, remaining bytes 2\\)');
})();

(function testStaleCodeSectionBytes() {
  let bytes = new Binary;
  bytes.emit_header();
  bytes.emit_bytes([
      kTypeSectionCode,       // section id
      4,                      // section length
      1,                      // number of types
      kWasmFunctionTypeForm,  // type
      0,                      // number of parameter
      0                       // number of returns
  ]);
  bytes.emit_bytes([
      kFunctionSectionCode,  // section id
      2,                     // section length
      1,                     // number of functions
      0                      // signature index
  ]);
  bytes.emit_bytes([
      kCodeSectionCode,  // section id
      10,                // section length (too big)
      1,                 // functions count
      2,                 // body size
      0,                 // locals count
      kExprEnd           // body
  ]);
  let pos = bytes.length;
  // Add some more bytes to avoid early error detection for too big section
  // length.
  bytes.emit_bytes([0, 0, 0, 0, 0, 0, 0, 0]);

  testErrorPosition(
      bytes, pos,
      'section was shorter than expected size ' +
          '\\(10 bytes expected, 4 decoded\\)');
})();

(function testInvalidCode() {
  let bytes = new Binary;
  bytes.emit_header();
  bytes.emit_bytes([
      kTypeSectionCode,       // section id
      4,                      // section length
      1,                      // number of types
      kWasmFunctionTypeForm,  // type
      0,                      // number of parameter
      0                       // number of returns
  ]);
  bytes.emit_bytes([
      kFunctionSectionCode,  // section id
      2,                     // section length
      1,                     // number of functions
      0                      // signature index
  ]);
  bytes.emit_bytes([
      kCodeSectionCode,  // section id
      6,                 // section length
      1,                 // functions count
      4,                 // body size
      0,                 // locals count
      kExprLocalGet, 0,  // Access a non-existing local
      kExprEnd           // --
  ]);

  // Find error at the index of kExprLocalGet.
  let pos = bytes.length - 1 - 1;
  testErrorPosition(bytes, pos, 'invalid local index');
})();

(function testCodeSectionRepeats() {
  let bytes = new Binary;
  bytes.emit_header();
  bytes.emit_bytes([
      kTypeSectionCode,       // section id
      4,                      // section length
      1,                      // number of types
      kWasmFunctionTypeForm,  // type
      0,                      // number of parameter
      0                       // number of returns
  ]);
  bytes.emit_bytes([
      kFunctionSectionCode,  // section id
      2,                     // section length
      1,                     // number of functions
      0                      // signature index
  ]);
  bytes.emit_bytes([
      kCodeSectionCode,  // section id
      4,                 // section length
      1,                 // functions count
      2,                 // body size
      0,                 // locals count
      kExprEnd           // body
  ]);
  // TODO(clemensb): Fix error reporting to point to the section start, not the
  // payload start.
  let pos = bytes.length + 2;
  bytes.emit_bytes([
      kCodeSectionCode,  // section id (repeating)
      4,                 // section length
      1,                 // functions count
      2,                 // body size
      0,                 // locals count
      kExprEnd           // body
  ]);

  // Find error at the second kCodeSectionCode.
  testErrorPosition(bytes, pos, 'unexpected section <Code>');
})();

(function testCodeSectionSizeZero() {
  let bytes = new Binary;
  bytes.emit_header();
  bytes.emit_bytes([
      kTypeSectionCode,       // section id
      4,                      // section length
      1,                      // number of types
      kWasmFunctionTypeForm,  // type
      0,                      // number of parameter
      0                       // number of returns
  ]);
  bytes.emit_bytes([
      kFunctionSectionCode,  // section id
      2,                     // section length
      1,                     // number of functions
      0                      // signature index
  ]);
  bytes.emit_bytes([
      kCodeSectionCode,  // section id
      0,                 // section length (empty)
  ]);

  // Find error at the code section length.
  let pos = bytes.length;
  testErrorPosition(bytes, pos, 'reached end while decoding functions count');
})();

(function testInvalidSection() {
  let bytes = new Binary;
  bytes.emit_header();
  bytes.emit_bytes([
      kTypeSectionCode,       // section id
      5,                      // section length
      1,                      // number of types
      kWasmFunctionTypeForm,  // type
      1,                      // number of parameter
      kWasmVoid,              // invalid type
      0                       // number of returns
  ]);

  let pos = bytes.length - 1 - 1;
  testErrorPosition(bytes, pos, 'invalid value type');
})();

(function testDataSegmentsMismatch() {
  let bytes = new Binary;
  bytes.emit_header();
  bytes.emit_bytes([
    kDataCountSectionCode,  // section id
    1,                      // section length
    1,                      // num data segments
    kDataSectionCode,       // section id
    1,                      // section length
    0                       // num data segments
  ]);

  let pos = bytes.length;
  testErrorPosition(
      bytes, pos, 'data segments count 0 mismatch \\(1 expected\\)');
})();

(function testMissingCodeSection() {
  let bytes = new Binary;
  bytes.emit_header();
  bytes.emit_bytes([
    kTypeSectionCode,       // section id
    4,                      // section length
    1,                      // number of types
    kWasmFunctionTypeForm,  // type
    0,                      // number of parameter
    0,                      // number of returns
    kFunctionSectionCode,   // section id
    2,                      // section length
    1,                      // number of functions
    0,                      // signature index
  ]);

  let pos = bytes.length;
  testErrorPosition(
      bytes, pos, 'function count is 1, but code section is absent');
})();
                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/streaming-trap-location.js                                    0000664 0000000 0000000 00000000416 14746647661 0024566 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-test-streaming --expose-wasm

d8.file.execute("test/mjsunit/wasm/trap-location.js");
                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/wasm/stringref-array-nonetype.js                                   0000664 0000000 0000000 00000001634 14746647661 0025004 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-stringref

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

let builder = new WasmModuleBuilder();

builder.addFunction("test", kSig_v_v).exportFunc().addBody([
  kExprRefNull, kNullRefCode,
  kExprI32Const, 0,
  kExprI32Const, 0,
  ...GCInstr(kExprStringNewWtf16Array),
  kExprDrop,
]);

builder.addFunction("test2", kSig_v_v).exportFunc().addBody([
  kExprRefNull, kNullRefCode,
  kExprRefAsNonNull,
  kExprI32Const, 0,
  kExprI32Const, 0,
  ...GCInstr(kExprStringNewWtf16Array),
  kExprDrop,
]);

assertTrue(WebAssembly.validate(builder.toBuffer()));
assertTraps(kTrapNullDereference, () => builder.instantiate().exports.test());
assertTraps(kTrapNullDereference, () => builder.instantiate().exports.test2());
                                                                                                    node-23.7.0/deps/v8/test/mjsunit/wasm/stringref-instance-type.js                                    0000664 0000000 0000000 00000003727 14746647661 0024617 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-stringref --expose-gc

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// This test case tests the loading an instance type for a string before a GC
// is triggered which (in the case of thin strings) changes the instance type.
// Afterwards, the instance type needs to be reloaded.
//
// In Turbofan map and instance type loads in wasm are marked as immutable.
// This is slightly imprecise. Still, due to the limited possibility of changing
// maps resulting in different behavior, this works fine.
// (StringPrepareForGetCodeunit is the only operation that could be affected by
// changing type info and it emits a loop which the instance type floats into
// with another value on the backedge preventing the load elimination.)
(function TestStringInstanceTypeLoad() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let gc_func = builder.addImport("a", "gc", makeSig([], []));

  builder.addFunction("test", makeSig([wasmRefType(kWasmAnyRef)], [kWasmI32]))
    .addLocals(wasmRefType(kWasmStringViewWtf16), 1,)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      // Cast to string. This will load the map and the instance type immutably.
      kGCPrefix, kExprRefCast, kStringRefCode,
      ...GCInstr(kExprStringAsWtf16),
      // Trigger gc.
      kExprCallFunction, gc_func,
      // Access some char on the string.
      kExprI32Const, 4,
      ...GCInstr(kExprStringViewWtf16GetCodeunit),
    ]);
  let instance = builder.instantiate({"a": {gc}});
  assertEquals(52, instance.exports.test(ThinString("a", "1234567")));
  assertEquals(52, instance.exports.test(ConsString("a", "1234567")));

  function ThinString(a, b) {
    var str = a + b;
    var o = {};
    o[str];
    return str;
  }
  function ConsString(a, b) {
    return a + b;
  }
})();
                                         node-23.7.0/deps/v8/test/mjsunit/wasm/stringref-memory64.js                                         0000664 0000000 0000000 00000004672 14746647661 0023516 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-stringref --experimental-wasm-memory64

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

let builder = new WasmModuleBuilder();
builder.addMemory(1, 1);  // Just to block memory index 0.
let $mem1 = builder.addMemory64(1, 1);

builder.addActiveDataSegment(
    1, [kExprI64Const, 0], [97, 98, 99, 0, 100, 0, 101]);

let kSig_w_li = makeSig([kWasmI64, kWasmI32], [kWasmStringRef]);
let kSig_i_wl = makeSig([kWasmStringRef, kWasmI64], [kWasmI32]);

builder.addFunction("new_wtf8", kSig_w_li).exportFunc().addBody([
  kExprLocalGet, 0,
  kExprLocalGet, 1,
  ...GCInstr(kExprStringNewUtf8), $mem1,
]);

builder.addFunction("new_wtf16", kSig_w_li).exportFunc().addBody([
  kExprLocalGet, 0,
  kExprLocalGet, 1,
  ...GCInstr(kExprStringNewWtf16), $mem1,
]);

builder.addFunction("encode_wtf8", kSig_i_wl).exportFunc().addBody([
  kExprLocalGet, 0,
  kExprLocalGet, 1,
  ...GCInstr(kExprStringEncodeWtf8), $mem1,
]);

builder.addFunction("encode_wtf8_view", kSig_i_wl).exportFunc().addBody([
  kExprLocalGet, 0,
  ...GCInstr(kExprStringAsWtf8),
  kExprLocalGet, 1,
  kExprI32Const, 0,  // start offset
  kExprI32Const, 2,  // number of bytes
  ...GCInstr(kExprStringViewWtf8EncodeWtf8), $mem1,
  kExprReturn,
]);

builder.addFunction("encode_wtf16", kSig_i_wl).exportFunc().addBody([
  kExprLocalGet, 0,
  kExprLocalGet, 1,
  ...GCInstr(kExprStringEncodeWtf16), $mem1,
]);

builder.addFunction("encode_wtf16_view", kSig_i_wl).exportFunc().addBody([
  kExprLocalGet, 0,
  ...GCInstr(kExprStringAsWtf16),
  kExprLocalGet, 1,
  kExprI32Const, 0,  // start offset
  kExprI32Const, 2,  // number of code units
  ...GCInstr(kExprStringViewWtf16Encode), $mem1,
]);

let instance = builder.instantiate();

assertEquals("ab", instance.exports.new_wtf8(0n, 2));

assertEquals("cd", instance.exports.new_wtf16(2n, 2));

assertEquals(2, instance.exports.encode_wtf8("ef", 100n));
assertEquals("ef", instance.exports.new_wtf8(100n, 2));

assertEquals(2, instance.exports.encode_wtf8_view("gh", 100n));
assertEquals("gh", instance.exports.new_wtf8(100n, 2));

assertEquals(2, instance.exports.encode_wtf16("ij", 102n));
assertEquals("ij", instance.exports.new_wtf16(102n, 2));

assertEquals(2, instance.exports.encode_wtf16_view("kl", 102n));
assertEquals("kl", instance.exports.new_wtf16(102n, 2));
                                                                      node-23.7.0/deps/v8/test/mjsunit/wasm/stringrefs-exec-gc.js                                         0000664 0000000 0000000 00000044132 14746647661 0023525 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-stringref --expose-externalize-string

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

let kSig_w_v = makeSig([], [kWasmStringRef]);
let kSig_w_ii = makeSig([kWasmI32, kWasmI32], [kWasmStringRef]);

function encodeWtf8(str) {
  // String iterator coalesces surrogate pairs.
  let out = [];
  for (let codepoint of str) {
    codepoint = codepoint.codePointAt(0);
    if (codepoint <= 0x7f) {
      out.push(codepoint);
    } else if (codepoint <= 0x7ff) {
      out.push(0xc0 | (codepoint >> 6));
      out.push(0x80 | (codepoint & 0x3f));
    } else if (codepoint <= 0xffff) {
      out.push(0xe0 | (codepoint >> 12));
      out.push(0x80 | ((codepoint >> 6) & 0x3f));
      out.push(0x80 | (codepoint & 0x3f));
    } else if (codepoint <= 0x10ffff) {
      out.push(0xf0 | (codepoint >> 18));
      out.push(0x80 | ((codepoint >> 12) & 0x3f));
      out.push(0x80 | ((codepoint >> 6) & 0x3f));
      out.push(0x80 | (codepoint & 0x3f));
    } else {
      throw new Error("bad codepoint " + codepoint);
    }
  }
  return out;
}

let externalString = "I'm an external string";
externalizeString(externalString);
let interestingStrings = [
  '',
  'ascii',
  'latin\xa91',        // Latin-1.
  '2 \ucccc b',        // Two-byte.
  'a \ud800\udc00 b',  // Proper surrogate pair.
  'a \ud800 b',        // Lone lead surrogate.
  'a \udc00 b',        // Lone trail surrogate.
  '\ud800 bc',         // Lone lead surrogate at the start.
  '\udc00 bc',         // Lone trail surrogate at the start.
  'ab \ud800',         // Lone lead surrogate at the end.
  'ab \udc00',         // Lone trail surrogate at the end.
  'a \udc00\ud800 b',  // Swapped surrogate pair.
  externalString,      // External string.
];

function IsSurrogate(codepoint) {
  return 0xD800 <= codepoint && codepoint <= 0xDFFF
}
function HasIsolatedSurrogate(str) {
  for (let codepoint of str) {
    let value = codepoint.codePointAt(0);
    if (IsSurrogate(value)) return true;
  }
  return false;
}
function ReplaceIsolatedSurrogates(str, replacement='\ufffd') {
  let replaced = '';
  for (let codepoint of str) {
    replaced +=
      IsSurrogate(codepoint.codePointAt(0)) ? replacement : codepoint;
  }
  return replaced;
}

function makeWtf8TestDataSegment() {
  let data = []
  let valid = {};
  let invalid = {};

  for (let str of interestingStrings) {
    let bytes = encodeWtf8(str);
    valid[str] = { offset: data.length, length: bytes.length };
    for (let byte of bytes) {
      data.push(byte);
    }
  }
  for (let bytes of ['trailing high byte \xa9',
                     'interstitial high \xa9 byte',
                     'invalid \xc0 byte',
                     'invalid three-byte \xed\xd0\x80',
                     'surrogate \xed\xa0\x80\xed\xb0\x80 pair']) {
    invalid[bytes] = { offset: data.length, length: bytes.length };
    for (let i = 0; i < bytes.length; i++) {
      data.push(bytes.charCodeAt(i));
    }
  }

  return { valid, invalid, data: Uint8Array.from(data) };
};

(function TestStringNewWtf8Array() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let data = makeWtf8TestDataSegment();
  let data_index = builder.addPassiveDataSegment(data.data);

  let ascii_data_index =
      builder.addPassiveDataSegment(Uint8Array.from(encodeWtf8("ascii")));

  let i8_array = builder.addArray(kWasmI8, true);

  let make_i8_array = builder.addFunction(
      "make_i8_array", makeSig([], [wasmRefType(i8_array)]))
    .addBody([
      ...wasmI32Const(0),
      ...wasmI32Const(data.data.length),
      kGCPrefix, kExprArrayNewData, i8_array, data_index
    ]).index;

  for (let [instr, name] of
       [[kExprStringNewWtf8Array, "new_wtf8"],
        [kExprStringNewUtf8Array, "new_utf8"],
        [kExprStringNewUtf8ArrayTry, "new_utf8_try"],
        [kExprStringNewLossyUtf8Array, "new_utf8_sloppy"]]) {
    builder.addFunction(name, kSig_w_ii)
      .exportFunc()
      .addBody([
        kExprCallFunction, make_i8_array,
        kExprLocalGet, 0, kExprLocalGet, 1,
        ...GCInstr(instr)
      ]);
  }

  builder.addFunction("bounds_check", kSig_w_ii)
    .exportFunc()
    .addBody([
      ...wasmI32Const(0),
      ...wasmI32Const("ascii".length),
      kGCPrefix, kExprArrayNewData, i8_array, ascii_data_index,
      kExprLocalGet, 0, kExprLocalGet, 1,
      ...GCInstr(kExprStringNewWtf8Array)
    ]);

  builder.addFunction("null_array", kSig_w_v).exportFunc()
    .addBody([
      kExprRefNull, i8_array,
      kExprI32Const, 0, kExprI32Const, 0,
      ...GCInstr(kExprStringNewWtf8Array)
    ])

  let instance = builder.instantiate();
  for (let [str, {offset, length}] of Object.entries(data.valid)) {
    let start = offset;
    let end = offset + length;
    assertEquals(str, instance.exports.new_wtf8(start, end));
    if (HasIsolatedSurrogate(str)) {
      assertThrows(() => instance.exports.new_utf8(start, end),
                   WebAssembly.RuntimeError, "invalid UTF-8 string");
      assertNull(instance.exports.new_utf8_try(start, end));

      // Isolated surrogates have the three-byte pattern ED [A0,BF]
      // [80,BF].  When the sloppy decoder gets to the second byte, it
      // will reject the sequence, and then retry parsing at the second
      // byte.  Seeing the second byte can't start a sequence, it
      // replaces the second byte and continues with the next, which
      // also can't start a sequence.  The result is that one isolated
      // surrogate is replaced by three U+FFFD codepoints.
      assertEquals(ReplaceIsolatedSurrogates(str, '\ufffd\ufffd\ufffd'),
                   instance.exports.new_utf8_sloppy(start, end));
    } else {
      assertEquals(str, instance.exports.new_utf8(start, end));
      assertEquals(str, instance.exports.new_utf8_sloppy(start, end));
      assertEquals(str, instance.exports.new_utf8_try(start, end));
    }
  }
  for (let [str, {offset, length}] of Object.entries(data.invalid)) {
    let start = offset;
    let end = offset + length;
    assertThrows(() => instance.exports.new_wtf8(start, end),
                 WebAssembly.RuntimeError, "invalid WTF-8 string");
    assertThrows(() => instance.exports.new_utf8(start, end),
                 WebAssembly.RuntimeError, "invalid UTF-8 string");
    assertNull(instance.exports.new_utf8_try(start, end));
  }

  assertEquals("ascii", instance.exports.bounds_check(0, "ascii".length));
  assertEquals("", instance.exports.bounds_check("ascii".length,
                                                 "ascii".length));
  assertEquals("i", instance.exports.bounds_check("ascii".length - 1,
                                                  "ascii".length));
  assertThrows(() => instance.exports.bounds_check(0, 100),
               WebAssembly.RuntimeError, "array element access out of bounds");
  assertThrows(() => instance.exports.bounds_check(0, -1),
               WebAssembly.RuntimeError, "array element access out of bounds");
  assertThrows(() => instance.exports.bounds_check(-1, 0),
               WebAssembly.RuntimeError, "array element access out of bounds");
  assertThrows(() => instance.exports.bounds_check("ascii".length,
                                                   "ascii".length + 1),
               WebAssembly.RuntimeError, "array element access out of bounds");
  assertThrows(() => instance.exports.null_array(),
               WebAssembly.RuntimeError, "dereferencing a null pointer");
})();

(function TestStringNewUtf8ArrayTryNullCheck() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let data = makeWtf8TestDataSegment();
  let data_index = builder.addPassiveDataSegment(data.data);
  let i8_array = builder.addArray(kWasmI8, true);

  let make_i8_array = builder.addFunction(
      "make_i8_array", makeSig([], [wasmRefType(i8_array)]))
    .addBody([
      ...wasmI32Const(0),
      ...wasmI32Const(data.data.length),
      kGCPrefix, kExprArrayNewData, i8_array, data_index
    ]).index;

  builder.addFunction("is_null_new_utf8_try", kSig_i_ii)
    .exportFunc()
    .addBody([
      kExprCallFunction, make_i8_array,
      kExprLocalGet, 0, kExprLocalGet, 1,
      ...GCInstr(kExprStringNewUtf8ArrayTry),
      kExprRefIsNull,
    ]);

  let instance = builder.instantiate();
  for (let [str, {offset, length}] of Object.entries(data.valid)) {
    assertEquals(
        +HasIsolatedSurrogate(str),
        instance.exports.is_null_new_utf8_try(offset, offset+length));
  }
  for (let [str, {offset, length}] of Object.entries(data.invalid)) {
    assertEquals(1, instance.exports.is_null_new_utf8_try(offset, offset+length));
  }
})();

function encodeWtf16LE(str) {
  // String iterator coalesces surrogate pairs.
  let out = [];
  for (let i = 0; i < str.length; i++) {
    codeunit = str.charCodeAt(i);
    out.push(codeunit & 0xff)
    out.push(codeunit >> 8);
  }
  return out;
}

function makeWtf16TestDataSegment(strings) {
  let data = []
  let valid = {};

  for (let str of strings) {
    valid[str] = { offset: data.length, length: str.length };
    for (let byte of encodeWtf16LE(str)) {
      data.push(byte);
    }
  }

  return { valid, data: Uint8Array.from(data) };
};

(function TestStringNewWtf16Array() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  // string.new_wtf16_array switches to a different implementation (runtime
  // instead of Torque) for more than 32 characters, so provide some coverage
  // for that case.
  let strings = interestingStrings.concat([
    "String with more than 32 characters, all of which are ASCII",
    "Two-byte string with more than 32 characters \ucccc \ud800\udc00 \xa9?"
  ]);

  let data = makeWtf16TestDataSegment(strings);
  let data_index = builder.addPassiveDataSegment(data.data);
  let ascii_data_index =
      builder.addPassiveDataSegment(Uint8Array.from(encodeWtf16LE("ascii")));

  let i16_array = builder.addArray(kWasmI16, true);

  let make_i16_array = builder.addFunction(
      "make_i16_array", makeSig([], [wasmRefType(i16_array)]))
    .addBody([
      ...wasmI32Const(0),
      ...wasmI32Const(data.data.length / 2),
      kGCPrefix, kExprArrayNewData, i16_array, data_index
    ]).index;

  builder.addFunction("new_wtf16", kSig_w_ii)
    .exportFunc()
    .addBody([
      kExprCallFunction, make_i16_array,
      kExprLocalGet, 0, kExprLocalGet, 1,
      ...GCInstr(kExprStringNewWtf16Array)
    ]);

  builder.addFunction("bounds_check", kSig_w_ii)
    .exportFunc()
    .addBody([
      ...wasmI32Const(0),
      ...wasmI32Const("ascii".length),
      kGCPrefix, kExprArrayNewData, i16_array, ascii_data_index,
      kExprLocalGet, 0, kExprLocalGet, 1,
      ...GCInstr(kExprStringNewWtf16Array)
    ]);

  builder.addFunction("null_array", kSig_w_v).exportFunc()
    .addBody([
      kExprRefNull, i16_array,
      kExprI32Const, 0,
      kExprI32Const, 0,
      ...GCInstr(kExprStringNewWtf16Array)
    ]);

  let instance = builder.instantiate();
  for (let [str, {offset, length}] of Object.entries(data.valid)) {
    let start = offset / 2;
    let end = start + length;
    assertEquals(str, instance.exports.new_wtf16(start, end));
  }

  assertEquals("ascii", instance.exports.bounds_check(0, "ascii".length));
  assertEquals("", instance.exports.bounds_check("ascii".length,
                                                 "ascii".length));
  assertEquals("i", instance.exports.bounds_check("ascii".length - 1,
                                                  "ascii".length));
  assertThrows(() => instance.exports.bounds_check(0, 100),
               WebAssembly.RuntimeError, "array element access out of bounds");
  assertThrows(() => instance.exports.bounds_check("ascii".length,
                                                   "ascii".length + 1),
               WebAssembly.RuntimeError, "array element access out of bounds");
  assertThrows(() => instance.exports.null_array(),
               WebAssembly.RuntimeError, "dereferencing a null pointer");
})();

(function TestStringEncodeWtf8Array() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let i8_array = builder.addArray(kWasmI8, true);

  let kSig_w_wii =
      makeSig([kWasmStringRef, kWasmI32, kWasmI32],
              [kWasmStringRef]);
  for (let [instr, name] of [[kExprStringEncodeUtf8Array, "utf8"],
                             [kExprStringEncodeWtf8Array, "wtf8"],
                             [kExprStringEncodeLossyUtf8Array, "replace"]]) {
    // Allocate an array that's exactly the expected size, and encode
    // into it.  Then decode it.
    // (str, length, offset=0) -> str
    builder.addFunction("encode_" + name, kSig_w_wii)
      .exportFunc()
      .addLocals(wasmRefNullType(i8_array), 1)
      .addLocals(kWasmI32, 1)
      .addBody([
        // Allocate buffer.
        kExprLocalGet, 1,
        kGCPrefix, kExprArrayNewDefault, i8_array,
        kExprLocalSet, 3,

        // Write buffer, store number of bytes written.
        kExprLocalGet, 0,
        kExprLocalGet, 3,
        kExprLocalGet, 2,
        ...GCInstr(instr),
        kExprLocalSet, 4,

        // Read buffer.
        kExprLocalGet, 3,
        kExprLocalGet, 2,
        kExprLocalGet, 2, kExprLocalGet, 4, kExprI32Add,
        ...GCInstr(kExprStringNewWtf8Array)
      ]);
  }

  builder.addFunction("encode_null_string", kSig_i_v)
    .exportFunc()
    .addBody([
        kExprRefNull, kStringRefCode,
        kExprI32Const, 0, kGCPrefix, kExprArrayNewDefault, i8_array,
        kExprI32Const, 0,
        ...GCInstr(kExprStringEncodeWtf8Array)
      ]);
  builder.addFunction("encode_null_array", kSig_i_v)
    .exportFunc()
    .addBody([
        kExprI32Const, 0, kGCPrefix, kExprArrayNewDefault, i8_array,
        kExprI32Const, 0, kExprI32Const, 0,
        ...GCInstr(kExprStringNewWtf8Array),
        kExprRefNull, i8_array,
        kExprI32Const, 0,
        ...GCInstr(kExprStringEncodeWtf8Array)
      ]);

  let instance = builder.instantiate();
  for (let str of interestingStrings) {
    let wtf8 = encodeWtf8(str);
    assertEquals(str, instance.exports.encode_wtf8(str, wtf8.length, 0));
    assertEquals(str, instance.exports.encode_wtf8(str, wtf8.length + 20,
                                                   10));
  }

  for (let str of interestingStrings) {
    let wtf8 = encodeWtf8(str);
    if (HasIsolatedSurrogate(str)) {
      assertThrows(() => instance.exports.encode_utf8(str, wtf8.length, 0),
          WebAssembly.RuntimeError,
          "Failed to encode string as UTF-8: contains unpaired surrogate");
    } else {
      assertEquals(str, instance.exports.encode_utf8(str, wtf8.length, 0));
      assertEquals(str,
                   instance.exports.encode_wtf8(str, wtf8.length + 20, 10));
    }
  }

  for (let str of interestingStrings) {
    let offset = 42;
    let replaced = ReplaceIsolatedSurrogates(str);
    if (!HasIsolatedSurrogate(str)) assertEquals(str, replaced);
    let wtf8 = encodeWtf8(replaced);
    assertEquals(replaced,
                 instance.exports.encode_replace(str, wtf8.length, 0));
    assertEquals(replaced,
                 instance.exports.encode_replace(str, wtf8.length + 20, 10));
  }

  assertThrows(() => instance.exports.encode_null_array(),
               WebAssembly.RuntimeError, "dereferencing a null pointer");
  assertThrows(() => instance.exports.encode_null_string(),
               WebAssembly.RuntimeError, "dereferencing a null pointer");

  for (let str of interestingStrings) {
    let wtf8 = encodeWtf8(str);
    let message = "array element access out of bounds";
    assertThrows(() => instance.exports.encode_wtf8(str, wtf8.length, 1),
                 WebAssembly.RuntimeError, message);
    assertThrows(() => instance.exports.encode_utf8(str, wtf8.length, 1),
                 WebAssembly.RuntimeError, message);
    assertThrows(() => instance.exports.encode_replace(str, wtf8.length, 1),
                 WebAssembly.RuntimeError, message);
  }
})();

(function TestStringEncodeWtf16Array() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let i16_array = builder.addArray(kWasmI16, true);

  let kSig_w_wii =
      makeSig([kWasmStringRef, kWasmI32, kWasmI32],
              [kWasmStringRef]);
  // Allocate an array and encode into it.  Then decode it.
  // (str, length, offset) -> str
  builder.addFunction("encode", kSig_w_wii)
    .exportFunc()
    .addLocals(wasmRefNullType(i16_array), 1)
    .addLocals(kWasmI32, 1)
    .addBody([
      // Allocate buffer.
      kExprLocalGet, 1,
      kGCPrefix, kExprArrayNewDefault, i16_array,
      kExprLocalSet, 3,

      // Write buffer, store number of code units written.
      kExprLocalGet, 0,
      kExprLocalGet, 3,
      kExprLocalGet, 2,
      ...GCInstr(kExprStringEncodeWtf16Array),
      kExprLocalSet, 4,

      // Read buffer.
      kExprLocalGet, 3,
      kExprLocalGet, 2,
      kExprLocalGet, 2, kExprLocalGet, 4, kExprI32Add,
      ...GCInstr(kExprStringNewWtf16Array),
    ]);

  builder.addFunction("encode_null_string", kSig_i_v)
    .exportFunc()
    .addBody([
        kExprRefNull, kStringRefCode,
        kExprI32Const, 0, kGCPrefix, kExprArrayNewDefault, i16_array,
        kExprI32Const, 0,
        ...GCInstr(kExprStringEncodeWtf16Array)
      ]);
  builder.addFunction("encode_null_array", kSig_i_v)
    .exportFunc()
    .addBody([
        kExprI32Const, 0, kGCPrefix, kExprArrayNewDefault, i16_array,
        kExprI32Const, 0, kExprI32Const, 0,
        ...GCInstr(kExprStringNewWtf16Array),
        kExprRefNull, i16_array,
        kExprI32Const, 0,
        ...GCInstr(kExprStringEncodeWtf16Array)
      ]);

  let instance = builder.instantiate();
  for (let str of interestingStrings) {
    assertEquals(str, instance.exports.encode(str, str.length, 0));
    assertEquals(str, instance.exports.encode(str, str.length + 20, 10));
  }

  assertThrows(() => instance.exports.encode_null_array(),
               WebAssembly.RuntimeError, "dereferencing a null pointer");
  assertThrows(() => instance.exports.encode_null_string(),
               WebAssembly.RuntimeError, "dereferencing a null pointer");

  for (let str of interestingStrings) {
    let message = "array element access out of bounds";
    assertThrows(() => instance.exports.encode(str, str.length, 1),
                 WebAssembly.RuntimeError, message);
  }
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/wasm/stringrefs-exec.js                                            0000664 0000000 0000000 00000124262 14746647661 0023141 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-stringref
// For {isOneByteString}:
// Flags: --expose-externalize-string

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

let kSig_w_ii = makeSig([kWasmI32, kWasmI32], [kWasmStringRef]);
let kSig_w_v = makeSig([], [kWasmStringRef]);
let kSig_i_w = makeSig([kWasmStringRef], [kWasmI32]);
let kSig_i_wi = makeSig([kWasmStringRef, kWasmI32], [kWasmI32]);
let kSig_i_wii = makeSig([kWasmStringRef, kWasmI32, kWasmI32], [kWasmI32]);
let kSig_i_ww = makeSig([kWasmStringRef, kWasmStringRef], [kWasmI32]);
let kSig_i_wiii = makeSig([kWasmStringRef, kWasmI32, kWasmI32, kWasmI32],
                          [kWasmI32]);
let kSig_ii_wiii = makeSig([kWasmStringRef, kWasmI32, kWasmI32, kWasmI32],
                           [kWasmI32, kWasmI32]);
let kSig_v_w = makeSig([kWasmStringRef], []);
let kSig_w_i = makeSig([kWasmI32], [kWasmStringRef]);
let kSig_w_wii = makeSig([kWasmStringRef, kWasmI32, kWasmI32],
                         [kWasmStringRef]);
let kSig_w_ww = makeSig([kWasmStringRef, kWasmStringRef], [kWasmStringRef]);
let kSig_w_w = makeSig([kWasmStringRef], [kWasmStringRef]);

function encodeWtf8(str) {
  // String iterator coalesces surrogate pairs.
  let out = [];
  for (let codepoint of str) {
    codepoint = codepoint.codePointAt(0);
    if (codepoint <= 0x7f) {
      out.push(codepoint);
    } else if (codepoint <= 0x7ff) {
      out.push(0xc0 | (codepoint >> 6));
      out.push(0x80 | (codepoint & 0x3f));
    } else if (codepoint <= 0xffff) {
      out.push(0xe0 | (codepoint >> 12));
      out.push(0x80 | ((codepoint >> 6) & 0x3f));
      out.push(0x80 | (codepoint & 0x3f));
    } else if (codepoint <= 0x10ffff) {
      out.push(0xf0 | (codepoint >> 18));
      out.push(0x80 | ((codepoint >> 12) & 0x3f));
      out.push(0x80 | ((codepoint >> 6) & 0x3f));
      out.push(0x80 | (codepoint & 0x3f));
    } else {
      throw new Error("bad codepoint " + codepoint);
    }
  }
  return out;
}

// Compute the string that corresponds to the valid WTF-8 bytes from
// start (inclusive) to end (exclusive).
function decodeWtf8(wtf8, start, end) {
  let result = ''
  while (start < end) {
    let cp;
    let b0 = wtf8[start];
    if ((b0 & 0xC0) == 0x80) {
      // The precondition is that we have valid WTF-8 bytes and that
      // start and end are codepoint boundaries.  Here we make a weak
      // assertion about that invariant, that we don't start decoding
      // with a continuation byte.
      throw new Error('invalid wtf8');
    }
    if (b0 <= 0x7F) {
      cp = b0;
      start += 1;
    } else if (b0 <= 0xDF) {
      cp = (b0 & 0x1f) << 6;
      cp |= (wtf8[start + 1] & 0x3f);
      start += 2;
    } else if (b0 <= 0xEF) {
      cp = (b0 & 0x0f) << 12;
      cp |= (wtf8[start + 1] & 0x3f) << 6;
      cp |= (wtf8[start + 2] & 0x3f);
      start += 3;
    } else {
      cp = (b0 & 0x07) << 18;
      cp |= (wtf8[start + 1] & 0x3f) << 12;
      cp |= (wtf8[start + 2] & 0x3f) << 6;
      cp |= (wtf8[start + 3] & 0x3f);
      start += 4;
    }
    result += String.fromCodePoint(cp);
  }
  assertEquals(start, end);
  return result;
}

// We iterate over every one of these strings and every substring of it,
// so to keep test execution times fast on slow platforms, keep both this
// list and the individual strings reasonably short.
let externalString = "I'm an external string";
externalizeString(externalString);
let interestingStrings = [
  '',
  'ascii',
  'latin\xa91',        // Latin-1.
  '2 \ucccc b',        // Two-byte.
  'a \ud800\udc00 b',  // Proper surrogate pair.
  'a \ud800 b',        // Lone lead surrogate.
  'a \udc00 b',        // Lone trail surrogate.
  '\ud800 bc',         // Lone lead surrogate at the start.
  '\udc00 bc',         // Lone trail surrogate at the start.
  'ab \ud800',         // Lone lead surrogate at the end.
  'ab \udc00',         // Lone trail surrogate at the end.
  'a \udc00\ud800 b',  // Swapped surrogate pair.
  externalString,      // External string.
];

function IsSurrogate(codepoint) {
  return 0xD800 <= codepoint && codepoint <= 0xDFFF
}
function HasIsolatedSurrogate(str) {
  for (let codepoint of str) {
    let value = codepoint.codePointAt(0);
    if (IsSurrogate(value)) return true;
  }
  return false;
}
function ReplaceIsolatedSurrogates(str, replacement='\ufffd') {
  let replaced = '';
  for (let codepoint of str) {
    replaced +=
      IsSurrogate(codepoint.codePointAt(0)) ? replacement : codepoint;
  }
  return replaced;
}

function makeWtf8TestDataSegment() {
  let data = []
  let valid = {};
  let invalid = {};

  for (let str of interestingStrings) {
    let bytes = encodeWtf8(str);
    valid[str] = { offset: data.length, length: bytes.length };
    for (let byte of bytes) {
      data.push(byte);
    }
  }
  for (let bytes of ['trailing high byte \xa9',
                     'interstitial high \xa9 byte',
                     'invalid \xc0 byte',
                     'invalid three-byte \xed\xd0\x80',
                     'surrogate \xed\xa0\x80\xed\xb0\x80 pair']) {
    invalid[bytes] = { offset: data.length, length: bytes.length };
    for (let i = 0; i < bytes.length; i++) {
      data.push(bytes.charCodeAt(i));
    }
  }

  return { valid, invalid, data: Uint8Array.from(data) };
};

(function TestStringNewWtf8() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  builder.addMemory(1, undefined);
  let data = makeWtf8TestDataSegment();
  builder.addActiveDataSegment(0, [kExprI32Const, 0], data.data);

  builder.addFunction("string_new_utf8", kSig_w_ii)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1,
      ...GCInstr(kExprStringNewUtf8), 0
    ]);

  builder.addFunction("string_new_utf8_try", kSig_w_ii)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1,
      ...GCInstr(kExprStringNewUtf8Try), 0
    ]);

  builder.addFunction("string_new_wtf8", kSig_w_ii)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1,
      ...GCInstr(kExprStringNewWtf8), 0
    ]);

  builder.addFunction("string_new_utf8_sloppy", kSig_w_ii)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1,
      ...GCInstr(kExprStringNewLossyUtf8), 0
    ]);

  let instance = builder.instantiate();
  for (let [str, {offset, length}] of Object.entries(data.valid)) {
    assertEquals(str, instance.exports.string_new_wtf8(offset, length));
    if (HasIsolatedSurrogate(str)) {
      assertThrows(() => instance.exports.string_new_utf8(offset, length),
                   WebAssembly.RuntimeError, "invalid UTF-8 string");
      assertEquals(null, instance.exports.string_new_utf8_try(offset, length));

      // Isolated surrogates have the three-byte pattern ED [A0,BF]
      // [80,BF].  When the sloppy decoder gets to the second byte, it
      // will reject the sequence, and then retry parsing at the second
      // byte.  Seeing the second byte can't start a sequence, it
      // replaces the second byte and continues with the next, which
      // also can't start a sequence.  The result is that one isolated
      // surrogate is replaced by three U+FFFD codepoints.
      assertEquals(ReplaceIsolatedSurrogates(str, '\ufffd\ufffd\ufffd'),
                   instance.exports.string_new_utf8_sloppy(offset, length));
    } else {
      assertEquals(str, instance.exports.string_new_utf8(offset, length));
      assertEquals(str, instance.exports.string_new_utf8_try(offset, length));
      assertEquals(str,
                   instance.exports.string_new_utf8_sloppy(offset, length));
    }
  }
  for (let [str, {offset, length}] of Object.entries(data.invalid)) {
    assertThrows(() => instance.exports.string_new_wtf8(offset, length),
                 WebAssembly.RuntimeError, "invalid WTF-8 string");
    assertThrows(() => instance.exports.string_new_utf8(offset, length),
                 WebAssembly.RuntimeError, "invalid UTF-8 string");
    assertEquals(null, instance.exports.string_new_utf8_try(offset, length));
  }
})();

(function TestStringNewUtf8TryNullCheck() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  builder.addMemory(1, undefined);
  let data = makeWtf8TestDataSegment();
  builder.addActiveDataSegment(0, [kExprI32Const, 0], data.data);

  builder.addFunction("is_null_new_utf8_try", kSig_i_ii)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1,
      ...GCInstr(kExprStringNewUtf8Try), 0,
      kExprRefIsNull,
    ]);

  let instance = builder.instantiate();
  for (let [str, {offset, length}] of Object.entries(data.valid)) {
    print(offset, length);
    assertEquals(
        +HasIsolatedSurrogate(str),
        instance.exports.is_null_new_utf8_try(offset, length));
  }
  for (let [str, {offset, length}] of Object.entries(data.invalid)) {
    assertEquals(1, instance.exports.is_null_new_utf8_try(offset, length));
  }
})();

function encodeWtf16LE(str) {
  // String iterator coalesces surrogate pairs.
  let out = [];
  for (let i = 0; i < str.length; i++) {
    codeunit = str.charCodeAt(i);
    out.push(codeunit & 0xff)
    out.push(codeunit >> 8);
  }
  return out;
}

function makeWtf16TestDataSegment() {
  let data = []
  let valid = {};

  for (let str of interestingStrings) {
    valid[str] = { offset: data.length, length: str.length };
    for (let byte of encodeWtf16LE(str)) {
      data.push(byte);
    }
  }

  return { valid, data: Uint8Array.from(data) };
};

(function TestStringNewWtf16() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  builder.addMemory(1, undefined);
  let data = makeWtf16TestDataSegment();
  builder.addActiveDataSegment(0, [kExprI32Const, 0], data.data);

  builder.addFunction("string_new_wtf16", kSig_w_ii)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1,
      ...GCInstr(kExprStringNewWtf16), 0
    ]);

  let instance = builder.instantiate();
  for (let [str, {offset, length}] of Object.entries(data.valid)) {
    assertEquals(str, instance.exports.string_new_wtf16(offset, length));
  }
})();

(function TestStringConst() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  for (let [index, str] of interestingStrings.entries()) {
    builder.addLiteralStringRef(encodeWtf8(str));

    builder.addFunction("string_const" + index, kSig_w_v)
      .exportFunc()
      .addBody([...GCInstr(kExprStringConst), index]);

    builder.addGlobal(kWasmStringRef, false, false,
                      [...GCInstr(kExprStringConst), index])
      .exportAs("global" + index);
  }

  let instance = builder.instantiate();
  for (let [index, str] of interestingStrings.entries()) {
    assertEquals(str, instance.exports["string_const" + index]());
    assertEquals(str, instance.exports["global" + index].value);
  }
})();

(function TestStringMeasureUtf8AndWtf8() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  builder.addFunction("string_measure_utf8", kSig_i_w)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringMeasureUtf8)
    ]);

  builder.addFunction("string_measure_wtf8", kSig_i_w)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringMeasureWtf8)
    ]);

  builder.addFunction("string_measure_utf8_null", kSig_i_v)
    .exportFunc()
    .addBody([
      kExprRefNull, kStringRefCode,
      ...GCInstr(kExprStringMeasureUtf8)
    ]);

  builder.addFunction("string_measure_wtf8_null", kSig_i_v)
    .exportFunc()
    .addBody([
      kExprRefNull, kStringRefCode,
      ...GCInstr(kExprStringMeasureWtf8)
    ]);

  let instance = builder.instantiate();
  for (let str of interestingStrings) {
    let wtf8 = encodeWtf8(str);
    assertEquals(wtf8.length, instance.exports.string_measure_wtf8(str));
    if (HasIsolatedSurrogate(str)) {
      assertEquals(-1, instance.exports.string_measure_utf8(str));
    } else {
      assertEquals(wtf8.length, instance.exports.string_measure_utf8(str));
    }
  }

  assertThrows(() => instance.exports.string_measure_utf8_null(),
               WebAssembly.RuntimeError, "dereferencing a null pointer");
  assertThrows(() => instance.exports.string_measure_wtf8_null(),
               WebAssembly.RuntimeError, "dereferencing a null pointer");
})();

(function TestStringMeasureWtf16() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  builder.addFunction("string_measure_wtf16", kSig_i_w)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringMeasureWtf16)
    ]);

  builder.addFunction("string_measure_wtf16_null", kSig_i_v)
    .exportFunc()
    .addBody([
      kExprRefNull, kStringRefCode,
      ...GCInstr(kExprStringMeasureWtf16)
    ]);

  let instance = builder.instantiate();
  for (let str of interestingStrings) {
    assertEquals(str.length, instance.exports.string_measure_wtf16(str));
  }

  assertThrows(() => instance.exports.string_measure_wtf16_null(),
               WebAssembly.RuntimeError, "dereferencing a null pointer");
})();

(function TestStringEncodeWtf8() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  builder.addMemory(1, undefined);
  builder.exportMemoryAs("memory");

  for (let [instr, name] of [[kExprStringEncodeUtf8, "utf8"],
                             [kExprStringEncodeWtf8, "wtf8"],
                             [kExprStringEncodeLossyUtf8, "replace"]]) {
    builder.addFunction("encode_" + name, kSig_i_wi)
      .exportFunc()
      .addBody([
        kExprLocalGet, 0,
        kExprLocalGet, 1,
        ...GCInstr(instr), 0,
      ]);
  }

  builder.addFunction("encode_null", kSig_i_v)
    .exportFunc()
    .addBody([
        kExprRefNull, kStringRefCode,
        kExprI32Const, 42,
        ...GCInstr(kExprStringEncodeWtf8), 0, 0,
      ]);

  let instance = builder.instantiate();
  let memory = new Uint8Array(instance.exports.memory.buffer);
  function clearMemory(low, high) {
    for (let i = low; i < high; i++) {
      memory[i] = 0;
    }
  }
  function assertMemoryBytesZero(low, high) {
    for (let i = low; i < high; i++) {
      assertEquals(0, memory[i]);
    }
  }
  function checkMemory(offset, bytes) {
    let slop = 64;
    assertMemoryBytesZero(Math.max(0, offset - slop), offset);
    for (let i = 0; i < bytes.length; i++) {
      assertEquals(bytes[i], memory[offset + i]);
    }
    assertMemoryBytesZero(offset + bytes.length,
                          Math.min(memory.length,
                                   offset + bytes.length + slop));
  }

  for (let str of interestingStrings) {
    let wtf8 = encodeWtf8(str);
    let offset = memory.length - wtf8.length;
    assertEquals(wtf8.length, instance.exports.encode_wtf8(str, offset));
    checkMemory(offset, wtf8);
    clearMemory(offset, offset + wtf8.length);
  }

  for (let str of interestingStrings) {
    let offset = 0;
    if (HasIsolatedSurrogate(str)) {
      assertThrows(() => instance.exports.encode_utf8(str, offset),
          WebAssembly.RuntimeError,
          "Failed to encode string as UTF-8: contains unpaired surrogate");
    } else {
      let wtf8 = encodeWtf8(str);
      assertEquals(wtf8.length, instance.exports.encode_utf8(str, offset));
      checkMemory(offset, wtf8);
      clearMemory(offset, offset + wtf8.length);
    }
  }

  for (let str of interestingStrings) {
    let offset = 42;
    let replaced = ReplaceIsolatedSurrogates(str);
    if (!HasIsolatedSurrogate(str)) assertEquals(str, replaced);
    let wtf8 = encodeWtf8(replaced);
    assertEquals(wtf8.length, instance.exports.encode_replace(str, offset));
    checkMemory(offset, wtf8);
    clearMemory(offset, offset + wtf8.length);
  }

  assertThrows(() => instance.exports.encode_null(),
               WebAssembly.RuntimeError, "dereferencing a null pointer");

  checkMemory(memory.length - 10, []);

  for (let str of interestingStrings) {
    let wtf8 = encodeWtf8(str);
    let offset = memory.length - wtf8.length + 1;
    assertThrows(() => instance.exports.encode_wtf8(str, offset),
                 WebAssembly.RuntimeError, "memory access out of bounds");
    assertThrows(() => instance.exports.encode_utf8(str, offset),
                 WebAssembly.RuntimeError, "memory access out of bounds");
    assertThrows(() => instance.exports.encode_replace(str, offset),
                 WebAssembly.RuntimeError, "memory access out of bounds");
    checkMemory(offset - 1, []);
  }
})();

(function TestStringEncodeWtf16() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  builder.addMemory(1, undefined);
  builder.exportMemoryAs("memory");

  builder.addFunction("encode_wtf16", kSig_i_wi)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      ...GCInstr(kExprStringEncodeWtf16), 0,
    ]);

  builder.addFunction("encode_null", kSig_i_v)
    .exportFunc()
    .addBody([
        kExprRefNull, kStringRefCode,
        kExprI32Const, 42,
        ...GCInstr(kExprStringEncodeWtf16), 0,
      ]);

  let instance = builder.instantiate();
  let memory = new Uint8Array(instance.exports.memory.buffer);
  function clearMemory(low, high) {
    for (let i = low; i < high; i++) {
      memory[i] = 0;
    }
  }
  function assertMemoryBytesZero(low, high) {
    for (let i = low; i < high; i++) {
      assertEquals(0, memory[i]);
    }
  }
  function checkMemory(offset, bytes) {
    let slop = 64;
    assertMemoryBytesZero(Math.max(0, offset - slop), offset);
    for (let i = 0; i < bytes.length; i++) {
      assertEquals(bytes[i], memory[offset + i]);
    }
    assertMemoryBytesZero(offset + bytes.length,
                          Math.min(memory.length,
                                   offset + bytes.length + slop));
  }

  for (let str of interestingStrings) {
    let wtf16 = encodeWtf16LE(str);
    let offset = memory.length - wtf16.length;
    assertEquals(str.length, instance.exports.encode_wtf16(str, offset));
    checkMemory(offset, wtf16);
    clearMemory(offset, offset + wtf16.length);
  }

  for (let str of interestingStrings) {
    let wtf16 = encodeWtf16LE(str);
    let offset = 0;
    assertEquals(str.length, instance.exports.encode_wtf16(str, offset));
    checkMemory(offset, wtf16);
    clearMemory(offset, offset + wtf16.length);
  }

  assertThrows(() => instance.exports.encode_null(),
               WebAssembly.RuntimeError, "dereferencing a null pointer");

  checkMemory(memory.length - 10, []);

  for (let str of interestingStrings) {
    let offset = 1;
    assertThrows(() => instance.exports.encode_wtf16(str, offset),
                 WebAssembly.RuntimeError,
                 "operation does not support unaligned accesses");
  }

  for (let str of interestingStrings) {
    let wtf16 = encodeWtf16LE(str);
    let offset = memory.length - wtf16.length + 2;
    assertThrows(() => instance.exports.encode_wtf16(str, offset),
                 WebAssembly.RuntimeError, "memory access out of bounds");
    checkMemory(offset - 2, []);
  }
})();

(function TestStringConcat() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  builder.addFunction("concat", kSig_w_ww)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      ...GCInstr(kExprStringConcat)
    ]);

  builder.addFunction("concat_null_head", kSig_w_w)
    .exportFunc()
    .addBody([
      kExprRefNull, kStringRefCode,
      kExprLocalGet, 0,
      ...GCInstr(kExprStringConcat)
    ]);
  builder.addFunction("concat_null_tail", kSig_w_w)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprRefNull, kStringRefCode,
      ...GCInstr(kExprStringConcat)
    ]);

  let instance = builder.instantiate();

  for (let head of interestingStrings) {
    for (let tail of interestingStrings) {
      assertEquals(head + tail, instance.exports.concat(head, tail));
    }
  }

  assertThrows(() => instance.exports.concat_null_head("hey"),
               WebAssembly.RuntimeError, "dereferencing a null pointer");
  assertThrows(() => instance.exports.concat_null_tail("hey"),
               WebAssembly.RuntimeError, "dereferencing a null pointer");
})();

(function TestStringEq() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  builder.addFunction("eq", kSig_i_ww)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      ...GCInstr(kExprStringEq)
    ]);

  builder.addFunction("eq_null_a", kSig_i_w)
    .exportFunc()
    .addBody([
      kExprRefNull, kStringRefCode,
      kExprLocalGet, 0,
      ...GCInstr(kExprStringEq)
    ]);
  builder.addFunction("eq_null_b", kSig_i_w)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprRefNull, kStringRefCode,
      ...GCInstr(kExprStringEq)
    ]);
  builder.addFunction("eq_both_null", kSig_i_v)
    .exportFunc()
    .addBody([
      kExprRefNull, kStringRefCode,
      kExprRefNull, kStringRefCode,
      ...GCInstr(kExprStringEq)
    ]);

  let instance = builder.instantiate();

  for (let head of interestingStrings) {
    for (let tail of interestingStrings) {
      let result = (head == tail)|0;
      assertEquals(result, instance.exports.eq(head, tail));
      assertEquals(result, instance.exports.eq(head + head, tail + tail));
    }
    assertEquals(0, instance.exports.eq_null_a(head))
    assertEquals(0, instance.exports.eq_null_b(head))
  }

  assertEquals(1, instance.exports.eq_both_null());
})();

(function TestStringIsUSVSequence() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  builder.addFunction("is_usv_sequence", kSig_i_w)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringIsUsvSequence)
    ]);

  builder.addFunction("is_usv_sequence_null", kSig_i_v)
    .exportFunc()
    .addBody([
      kExprRefNull, kStringRefCode,
      ...GCInstr(kExprStringIsUsvSequence)
    ]);

  let instance = builder.instantiate();

  for (let str of interestingStrings) {
    assertEquals(HasIsolatedSurrogate(str) ? 0 : 1,
                 instance.exports.is_usv_sequence(str));
  }

  assertThrows(() => instance.exports.is_usv_sequence_null(),
               WebAssembly.RuntimeError, "dereferencing a null pointer");
})();

(function TestStringViewWtf16() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  builder.addMemory(1, undefined);
  builder.exportMemoryAs("memory");

  builder.addFunction("view_from_null", kSig_v_v).exportFunc().addBody([
    kExprRefNull, kStringRefCode,
    ...GCInstr(kExprStringAsWtf16),
    kExprDrop,
  ]);

  builder.addFunction("length", kSig_i_w)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringAsWtf16),
      ...GCInstr(kExprStringViewWtf16Length)
    ]);

  builder.addFunction("get_codeunit", kSig_i_wi)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringAsWtf16),
      kExprLocalGet, 1,
      ...GCInstr(kExprStringViewWtf16GetCodeunit)
    ]);

  builder.addFunction("encode", kSig_i_wiii)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringAsWtf16),
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
      ...GCInstr(kExprStringViewWtf16Encode), 0
    ]);

  builder.addFunction("slice", kSig_w_wii)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringAsWtf16),
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      ...GCInstr(kExprStringViewWtf16Slice)
    ]);

  // Non-nullable stringview references are still encoded as regular
  // non-nullable references, so they Just Work with br_on_* instructions.
  builder.addFunction("br_on_null", kSig_i_w).exportFunc().addBody([
    kExprBlock, kWasmI32,
      kExprI32Const, 11,
      kExprLocalGet, 0,
      ...GCInstr(kExprStringAsWtf16),
      kExprBrOnNull, 0,  // Never taken.
      kExprDrop,  // Drop the string view.
      kExprDrop,  // Drop the "11".
      kExprI32Const, 42,
    kExprEnd,
  ]);

  builder.addFunction("br_on_non_null", kSig_i_w).exportFunc().addBody([
    kExprBlock, kWasmI32,
      kExprBlock, kStringViewWtf16Code,
        kExprLocalGet, 0,
        ...GCInstr(kExprStringAsWtf16),
        kExprBrOnNonNull, 0,  // Always taken.
        kExprI32Const, 11,
        kExprBr, 1,
      kExprEnd,
      kExprDrop,  // Drop the string view.
      kExprI32Const, 42,
    kExprEnd,
  ]);

  let instance = builder.instantiate();
  let memory = new Uint8Array(instance.exports.memory.buffer);
  for (let str of interestingStrings) {
    assertEquals(str.length, instance.exports.length(str));
    for (let i = 0; i < str.length; i++) {
      assertEquals(str.charCodeAt(i),
                   instance.exports.get_codeunit(str, i));
    }
    assertEquals(str, instance.exports.slice(str, 0, -1));
  }

  function checkEncoding(str, slice, start, length) {
    let bytes = encodeWtf16LE(slice);
    function clearMemory(low, high) {
      for (let i = low; i < high; i++) {
        memory[i] = 0;
      }
    }
    function assertMemoryBytesZero(low, high) {
      for (let i = low; i < high; i++) {
        assertEquals(0, memory[i]);
      }
    }
    function checkMemory(offset, bytes) {
      let slop = 64;
      assertMemoryBytesZero(Math.max(0, offset - slop), offset);
      for (let i = 0; i < bytes.length; i++) {
        assertEquals(bytes[i], memory[offset + i]);
      }
      assertMemoryBytesZero(offset + bytes.length,
                            Math.min(memory.length,
                                     offset + bytes.length + slop));
    }

    for (let offset of [0, 42, memory.length - bytes.length]) {
      assertEquals(slice.length,
                   instance.exports.encode(str, offset, start, length));
      checkMemory(offset, bytes);
      clearMemory(offset, offset + bytes.length);
    }

    assertThrows(() => instance.exports.encode(str, 1, start, length),
                 WebAssembly.RuntimeError,
                 "operation does not support unaligned accesses");
    assertThrows(
        () => instance.exports.encode(str, memory.length - bytes.length + 2,
                                      start, length),
        WebAssembly.RuntimeError, "memory access out of bounds");
    checkMemory(memory.length - bytes.length - 2, []);
  }
  checkEncoding("fox", "f", 0, 1);
  checkEncoding("fox", "fo", 0, 2);
  checkEncoding("fox", "fox", 0, 3);
  checkEncoding("fox", "fox", 0, 300);
  checkEncoding("fox", "", 1, 0);
  checkEncoding("fox", "o", 1, 1);
  checkEncoding("fox", "ox", 1, 2);
  checkEncoding("fox", "ox", 1, 200);
  checkEncoding("fox", "", 2, 0);
  checkEncoding("fox", "x", 2, 1);
  checkEncoding("fox", "x", 2, 2);
  checkEncoding("fox", "", 3, 0);
  checkEncoding("fox", "", 3, 1_000_000_000);
  checkEncoding("fox", "", 1_000_000_000, 1_000_000_000);
  checkEncoding("fox", "", 100, 100);
  // Bounds checks before alignment checks.
  assertThrows(() => instance.exports.encode("foo", memory.length - 1, 0, 3),
               WebAssembly.RuntimeError, "memory access out of bounds");

  assertEquals("", instance.exports.slice("foo", 0, 0));
  assertEquals("f", instance.exports.slice("foo", 0, 1));
  assertEquals("fo", instance.exports.slice("foo", 0, 2));
  assertEquals("foo", instance.exports.slice("foo", 0, 3));
  assertEquals("foo", instance.exports.slice("foo", 0, 4));
  assertEquals("o", instance.exports.slice("foo", 1, 2));
  assertEquals("oo", instance.exports.slice("foo", 1, 3));
  assertEquals("oo", instance.exports.slice("foo", 1, 100));
  assertEquals("", instance.exports.slice("foo", 1, 0));
  assertEquals("", instance.exports.slice("foo", 3, 4));
  assertEquals("foo", instance.exports.slice("foo", 0, -1));
  assertEquals("", instance.exports.slice("foo", -1, 1));

  assertEquals(42, instance.exports.br_on_null("foo"));
  assertEquals(42, instance.exports.br_on_non_null("foo"));

  assertThrows(() => instance.exports.view_from_null(),
               WebAssembly.RuntimeError, 'dereferencing a null pointer');
  assertThrows(() => instance.exports.get_codeunit("", 0),
               WebAssembly.RuntimeError, "string offset out of bounds");

  // Cover runtime code path for long slices.
  const prefix = "a".repeat(10);
  const slice = "x".repeat(40);
  const suffix = "b".repeat(40);
  const input = prefix + slice + suffix;
  const start = prefix.length;
  const end = start + slice.length;
  assertEquals(slice, instance.exports.slice(input, start, end));

  // Check that we create one-byte substrings when possible.
  let onebyte = instance.exports.slice("\u1234abcABCDE", 1, 4);
  assertEquals("abc", onebyte);
  assertTrue(isOneByteString(onebyte));

  // Check that the CodeStubAssembler implementation also creates one-byte
  // substrings.
  onebyte = instance.exports.slice("\u1234abcA", 1, 4);
  assertEquals("abc", onebyte);
  assertTrue(isOneByteString(onebyte));
  // Cover the code path that checks 8 characters at a time.
  onebyte = instance.exports.slice("\u1234abcdefgh\u1234", 1, 9);
  assertEquals("abcdefgh", onebyte);  // Exactly 8 characters.
  assertTrue(isOneByteString(onebyte));
  onebyte = instance.exports.slice("\u1234abcdefghijXYZ", 1, 11);
  assertEquals("abcdefghij", onebyte);  // Longer than 8.
  assertTrue(isOneByteString(onebyte));

  // Check that the runtime code path also creates one-byte substrings.
  assertTrue(isOneByteString(
      instance.exports.slice(input + "\u1234", start, end)));
})();

(function TestStringViewWtf8() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  builder.addMemory(1, undefined);
  builder.exportMemoryAs("memory");

  builder.addFunction("advance", kSig_i_wii)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringAsWtf8),
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      ...GCInstr(kExprStringViewWtf8Advance)
    ]);

  for (let [instr, name] of
       [[kExprStringViewWtf8EncodeUtf8, "utf8"],
        [kExprStringViewWtf8EncodeWtf8, "wtf8"],
        [kExprStringViewWtf8EncodeLossyUtf8, "replace"]]) {
    builder.addFunction(`encode_${name}`, kSig_ii_wiii)
      .exportFunc()
      .addBody([
        kExprLocalGet, 0,
        ...GCInstr(kExprStringAsWtf8),
        kExprLocalGet, 1,
        kExprLocalGet, 2,
        kExprLocalGet, 3,
        ...GCInstr(instr), 0
      ]);
  }

  builder.addFunction(`slice`, kSig_w_wii)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringAsWtf8),
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      ...GCInstr(kExprStringViewWtf8Slice)
    ]);

  function Wtf8StartsCodepoint(wtf8, offset) {
    return (wtf8[offset] & 0xc0) != 0x80;
  }
  function Wtf8PositionTreatment(wtf8, offset) {
    while (offset < wtf8.length) {
      if (Wtf8StartsCodepoint(wtf8, offset)) return offset;
      offset++;
    }
    return wtf8.length;
  }
  function CodepointStart(wtf8, offset) {
    if (offset >= wtf8.length) return wtf8.length;
    while (!Wtf8StartsCodepoint(wtf8, offset)) {
      offset--;
    }
    return offset;
  }

  let instance = builder.instantiate();
  let memory = new Uint8Array(instance.exports.memory.buffer);

  for (let pos = 0; pos < "ascii".length; pos++) {
    assertEquals(pos + 1, instance.exports.advance("ascii", pos, 1));
  }

  for (let str of interestingStrings) {
    let wtf8 = encodeWtf8(str);
    assertEquals(wtf8.length, instance.exports.advance(str, 0, -1));
    assertEquals(wtf8.length, instance.exports.advance(str, -1, 0));
    assertEquals(wtf8.length, instance.exports.advance(str, 0, wtf8.length));
    assertEquals(wtf8.length, instance.exports.advance(str, wtf8.length, 0));
    assertEquals(wtf8.length,
                 instance.exports.advance(str, 0, wtf8.length + 1));
    assertEquals(wtf8.length,
                 instance.exports.advance(str, wtf8.length + 1, 0));
    for (let pos = 0; pos <= wtf8.length; pos++) {
      for (let bytes = 0; bytes <= wtf8.length - pos; bytes++) {
        assertEquals(
            CodepointStart(wtf8, Wtf8PositionTreatment(wtf8, pos) + bytes),
            instance.exports.advance(str, pos, bytes));
      }
    }
  }

  function clearMemory(low, high) {
    for (let i = low; i < high; i++) {
      memory[i] = 0;
    }
  }
  function assertMemoryBytesZero(low, high) {
    for (let i = low; i < high; i++) {
      assertEquals(0, memory[i]);
    }
  }
  function checkMemory(offset, bytes) {
    let slop = 16;
    assertMemoryBytesZero(Math.max(0, offset - slop), offset);
    for (let i = 0; i < bytes.length; i++) {
      assertEquals(bytes[i], memory[offset + i]);
    }
    assertMemoryBytesZero(offset + bytes.length,
                          Math.min(memory.length,
                                   offset + bytes.length + slop));
  }
  function checkEncoding(variant, str, slice, start, length) {
    let all_bytes = encodeWtf8(str);
    let bytes = encodeWtf8(slice);

    let encode = instance.exports[`encode_${variant}`];
    let expected_start = Wtf8PositionTreatment(all_bytes, start);
    let expected_end = CodepointStart(all_bytes, expected_start + bytes.length);
    for (let offset of [0, 42, memory.length - bytes.length]) {
      assertArrayEquals([expected_end, expected_end - expected_start],
                        encode(str, offset, start, length));
      checkMemory(offset, bytes);
      clearMemory(offset, offset + bytes.length);
    }

    assertThrows(() => encode(str, memory.length - bytes.length + 2,
                              start, length),
                 WebAssembly.RuntimeError, "memory access out of bounds");
    checkMemory(memory.length - bytes.length - 2, []);
  }

  checkEncoding('utf8', "fox", "f", 0, 1);
  checkEncoding('utf8', "fox", "fo", 0, 2);
  checkEncoding('utf8', "fox", "fox", 0, 3);
  checkEncoding('utf8', "fox", "fox", 0, 300);
  checkEncoding('utf8', "fox", "", 1, 0);
  checkEncoding('utf8', "fox", "o", 1, 1);
  checkEncoding('utf8', "fox", "ox", 1, 2);
  checkEncoding('utf8', "fox", "ox", 1, 200);
  checkEncoding('utf8', "fox", "", 2, 0);
  checkEncoding('utf8', "fox", "x", 2, 1);
  checkEncoding('utf8', "fox", "x", 2, 2);
  checkEncoding('utf8', "fox", "", 3, 0);
  checkEncoding('utf8', "fox", "", 3, 1_000_000_000);
  checkEncoding('utf8', "fox", "", 1_000_000_000, 1_000_000_000);
  checkEncoding('utf8', "fox", "", 100, 100);

  for (let str of interestingStrings) {
    let wtf8 = encodeWtf8(str);
    for (let pos = 0; pos <= wtf8.length; pos++) {
      for (let bytes = 0; bytes <= wtf8.length - pos; bytes++) {
        let start = Wtf8PositionTreatment(wtf8, pos);
        let end = CodepointStart(wtf8, start + bytes);
        let expected = decodeWtf8(wtf8, start, end);
        checkEncoding('wtf8', str, expected, pos, bytes);
        if (HasIsolatedSurrogate(expected)) {
          assertThrows(() => instance.exports.encode_utf8(str, 0, pos, bytes),
                       WebAssembly.RuntimeError,
                       "Failed to encode string as UTF-8: " +
                       "contains unpaired surrogate");
          checkEncoding('replace', str,
                        ReplaceIsolatedSurrogates(expected), pos, bytes);
        } else {
          checkEncoding('utf8', str, expected, pos, bytes);
          checkEncoding('replace', str, expected, pos, bytes);
        }
      }
    }
  }

  for (let str of interestingStrings) {
    let wtf8 = encodeWtf8(str);
    for (let start = 0; start <= wtf8.length; start++) {
      for (let end = start; end <= wtf8.length; end++) {
        let expected_slice = decodeWtf8(wtf8,
                                        Wtf8PositionTreatment(wtf8, start),
                                        Wtf8PositionTreatment(wtf8, end));
        assertEquals(expected_slice, instance.exports.slice(str, start, end));
      }
    }
  }
})();

(function TestStringViewIter() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let wrapper = builder.addStruct([makeField(kWasmStringViewIter, true)]);

  let global = builder.addGlobal(wasmRefNullType(wrapper), true, false);

  builder.addFunction("iterate", kSig_v_w)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringAsIter),
      kGCPrefix, kExprStructNew, wrapper,
      kExprGlobalSet, global.index
    ]);

  builder.addFunction("next", kSig_i_v)
    .exportFunc()
    .addBody([
      kExprGlobalGet, global.index,
      kGCPrefix, kExprStructGet, wrapper, 0,
      ...GCInstr(kExprStringViewIterNext)
    ]);

  builder.addFunction("advance", kSig_i_i)
    .exportFunc()
    .addBody([
      kExprGlobalGet, global.index,
      kGCPrefix, kExprStructGet, wrapper, 0,
      kExprLocalGet, 0,
      ...GCInstr(kExprStringViewIterAdvance)
    ]);

  builder.addFunction("rewind", kSig_i_i)
    .exportFunc()
    .addBody([
      kExprGlobalGet, global.index,
      kGCPrefix, kExprStructGet, wrapper, 0,
      kExprLocalGet, 0,
      ...GCInstr(kExprStringViewIterRewind)
    ]);

  builder.addFunction("slice", kSig_w_i)
    .exportFunc()
    .addBody([
      kExprGlobalGet, global.index,
      kGCPrefix, kExprStructGet, wrapper, 0,
      kExprLocalGet, 0,
      ...GCInstr(kExprStringViewIterSlice)
    ]);

  let instance = builder.instantiate();

  for (let str of interestingStrings) {
    let codepoints = [];
    for (let codepoint of str) {
      codepoints.push(codepoint.codePointAt(0));
    }

    instance.exports.iterate(str);
    for (let codepoint of codepoints) {
      assertEquals(codepoint, instance.exports.next());
    }
    assertEquals(-1, instance.exports.next());
    assertEquals(-1, instance.exports.next());

    for (let i = 1; i <= codepoints.length; i++) {
      assertEquals(i, instance.exports.rewind(i));
      assertEquals(codepoints[codepoints.length - i], instance.exports.next());
      assertEquals(i - 1, instance.exports.advance(-1));
    }
    for (let i = 0; i < codepoints.length; i++) {
      instance.exports.rewind(-1);
      assertEquals(i, instance.exports.advance(i));
      assertEquals(codepoints[i], instance.exports.next());
    }

    assertEquals(codepoints.length, instance.exports.rewind(-1));
    assertEquals(0, instance.exports.rewind(-1));
    assertEquals(codepoints.length, instance.exports.advance(-1));
    assertEquals(0, instance.exports.advance(-1));

    for (let start = 0; start <= codepoints.length; start++) {
      for (let end = start; end <= codepoints.length; end++) {
        let expected_slice =
            String.fromCodePoint(...codepoints.slice(start, end));
        instance.exports.iterate(str);
        assertEquals(start, instance.exports.advance(start));
        assertEquals(expected_slice, instance.exports.slice(end - start));
      }
    }
    instance.exports.iterate(str);
    assertEquals(str, instance.exports.slice(codepoints.length));
    assertEquals(str, instance.exports.slice(-1));
    assertEquals("", instance.exports.slice(0));
    assertEquals(codepoints.length, instance.exports.advance(-1));
    assertEquals("", instance.exports.slice(-1));
  }
})();

(function TestStringCompare() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  builder.addFunction("compare",
                      makeSig([kWasmStringRef, kWasmStringRef], [kWasmI32]))
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      ...GCInstr(kExprStringCompare)
    ]);

  let instance = builder.instantiate();
  for (let lhs of interestingStrings) {
    for (let rhs of interestingStrings) {
      print(`"${lhs}" <=> "${rhs}"`);
      const expected = lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
      assertEquals(expected, instance.exports.compare(lhs, rhs));
    }
  }

  assertThrows(() => instance.exports.compare(null, "abc"),
               WebAssembly.RuntimeError, "dereferencing a null pointer");
  assertThrows(() => instance.exports.compare("abc", null),
               WebAssembly.RuntimeError, "dereferencing a null pointer");
})();

(function TestStringCompareNullCheckStaticType() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  // Use a mix of nullable and non-nullable input types to the compare.
  builder.addFunction("compareLhsNullable",
                      makeSig([kWasmStringRef, kWasmStringRef], [kWasmI32]))
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprRefAsNonNull,
      kExprLocalGet, 1,
      ...GCInstr(kExprStringCompare)
    ]);

  builder.addFunction("compareRhsNullable",
                      makeSig([kWasmStringRef, kWasmStringRef], [kWasmI32]))
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprRefAsNonNull,
      ...GCInstr(kExprStringCompare)
    ]);

  let instance = builder.instantiate();
  assertThrows(() => instance.exports.compareLhsNullable(null, "abc"),
               WebAssembly.RuntimeError, "dereferencing a null pointer");
  assertThrows(() => instance.exports.compareLhsNullable("abc", null),
               WebAssembly.RuntimeError, "dereferencing a null pointer");
  assertThrows(() => instance.exports.compareRhsNullable(null, "abc"),
               WebAssembly.RuntimeError, "dereferencing a null pointer");
  assertThrows(() => instance.exports.compareRhsNullable("abc", null),
               WebAssembly.RuntimeError, "dereferencing a null pointer");
})();

(function TestStringFromCodePoint() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("asString",
                      makeSig([kWasmI32], [wasmRefType(kWasmStringRef)]))
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringFromCodePoint),
    ]);

  let instance = builder.instantiate();
  for (let char of "Az1#\n\ucccc\ud800\udc00") {
    assertEquals(char, instance.exports.asString(char.codePointAt(0)));
  }
  for (let codePoint of [0x110000, 0xFFFFFFFF, -1]) {
    assertThrows(() => instance.exports.asString(codePoint),
                 WebAssembly.RuntimeError, /Invalid code point [0-9]+/);
  }
})();

(function TestStringHash() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("hash", kSig_i_w)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringHash),
    ]);

  let hash = builder.instantiate().exports.hash;
  assertEquals(hash(""), hash(""));
  assertEquals(hash("foo"), hash("foo"));
  assertEquals(hash("bar"), hash("bar"));
  assertEquals(hash("123"), hash("123"));
  // Assuming that hash collisions are very rare.
  assertNotEquals(hash("foo"), hash("bar"));
  // Test with cons strings.
  assertEquals(hash("f" + "o" + "o"), hash("foo"));
  assertEquals(hash("f" + 1), hash("f1"));

  assertEquals(hash(new String(" foo ").trim()), hash("foo"));
  assertEquals(hash(new String("xfoox").substring(1, 4)), hash("foo"));

  // Test integer index hash.
  let dummy_obj = {123: 456};
  let index_string = "123";
  assertEquals(456, dummy_obj[index_string]);
  assertEquals(hash("1" + "23"), hash(index_string));
})();
                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/wasm/stringrefs-invalid.js                                         0000664 0000000 0000000 00000003144 14746647661 0023636 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function assertInvalid(fn, message) {
  let builder = new WasmModuleBuilder();
  fn(builder);
  assertThrows(() => builder.toModule(), WebAssembly.CompileError, message);
}

assertInvalid(
  builder => builder.addLiteralStringRef("foo"),
  /unexpected section <StringRef> \(enable with --experimental-wasm-stringref\)/);

let enableMessage = 'enable with --experimental-wasm-stringref'

for (let [name, code] of [['string', kStringRefCode],
                          ['stringview_wtf8', kStringViewWtf8Code],
                          ['stringview_wtf16', kStringViewWtf16Code],
                          ['stringview_iter', kStringViewIterCode]]) {
  let message = new RegExp(`invalid value type '${name}ref', ${enableMessage}`);
  let default_init = [kExprRefNull, code];

  assertInvalid(b => b.addType(makeSig([code], [])), message);
  assertInvalid(b => b.addStruct([makeField(code, true)]), message);
  assertInvalid(b => b.addArray(code, true), message);
  assertInvalid(b => b.addType(makeSig([], [code])), message);
  assertInvalid(b => b.addGlobal(code, true, false, default_init), message);
  assertInvalid(b => b.addTable(code, 0), message);
  assertInvalid(b => b.addPassiveElementSegment([default_init], code), message);
  assertInvalid(b => b.addTag(makeSig([code], [])), message);
  assertInvalid(
    b => b.addFunction(undefined, kSig_v_v).addLocals(code, 1).addBody([]),
    message);
}
                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/wasm/stringrefs-js.js                                              0000664 0000000 0000000 00000022264 14746647661 0022630 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-stringref

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function assertInvalid(fn, message) {
  let builder = new WasmModuleBuilder();
  fn(builder);
  assertThrows(() => builder.toModule(), WebAssembly.CompileError,
               `WebAssembly.Module(): ${message}`);
}

(function TestPassthrough() {
  let kSig_w_w = makeSig([kWasmStringRef], [kWasmStringRef]);
  let builder = new WasmModuleBuilder();

  builder.addFunction("passthrough", kSig_w_w)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
    ]);

  let instance = builder.instantiate()

  assertEquals('foo', instance.exports.passthrough('foo'));
  assertEquals(null, instance.exports.passthrough(null));

  assertThrows(()=>instance.exports.passthrough(3),
               TypeError, "type incompatibility when transforming from/to JS");
  assertThrows(()=>instance.exports.passthrough({}),
               TypeError, "type incompatibility when transforming from/to JS");
  assertThrows(()=>instance.exports.passthrough({valueOf: ()=>'foo'}),
               TypeError, "type incompatibility when transforming from/to JS");
  assertThrows(()=>instance.exports.passthrough(undefined),
               TypeError, "type incompatibility when transforming from/to JS");
  assertThrows(()=>instance.exports.passthrough(),
               TypeError, "type incompatibility when transforming from/to JS");
})();

(function TestSwap() {
  let kSig_ww_ww = makeSig([kWasmStringRef, kWasmStringRef],
                           [kWasmStringRef, kWasmStringRef]);
  let builder = new WasmModuleBuilder();

  builder.addFunction("swap", kSig_ww_ww)
    .exportFunc()
    .addBody([
      kExprLocalGet, 1,
      kExprLocalGet, 0,
    ]);

  let instance = builder.instantiate()

  assertArrayEquals(['bar', 'foo'], instance.exports.swap('foo', 'bar'));
  assertArrayEquals(['bar', null], instance.exports.swap(null, 'bar'));
  assertArrayEquals([null, 'foo'], instance.exports.swap('foo', null));
})();

(function TestCallout() {
  let kSig_w_w = makeSig([kWasmStringRef], [kWasmStringRef]);
  let builder = new WasmModuleBuilder();

  builder.addImport("env", "transformer", kSig_w_w)
  builder.addFunction("transform", kSig_w_w)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprCallFunction, 0
    ]);

  let instance = builder.instantiate(
      { env: { transformer: x=>x.toUpperCase() } });

  assertEquals('FOO', instance.exports.transform('foo'));
})();

(function TestViewsUnsupported() {
  let kSig_x_w = makeSig([kWasmStringRef], [kWasmStringViewWtf8]);
  let kSig_y_w = makeSig([kWasmStringRef], [kWasmStringViewWtf16]);
  let kSig_z_w = makeSig([kWasmStringRef], [kWasmStringViewIter]);
  let builder = new WasmModuleBuilder();

  builder.addFunction("stringview_wtf8", kSig_x_w)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringAsWtf8),
    ]);
  builder.addFunction("stringview_wtf16", kSig_y_w)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringAsWtf16),
    ]);
  builder.addFunction("stringview_iter", kSig_z_w)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringAsIter),
    ]);

  let instance = builder.instantiate()

  assertThrows(()=>instance.exports.stringview_wtf8(),
               TypeError, "type incompatibility when transforming from/to JS");
  assertThrows(()=>instance.exports.stringview_wtf16(),
               TypeError, "type incompatibility when transforming from/to JS");
  assertThrows(()=>instance.exports.stringview_iter(),
               TypeError, "type incompatibility when transforming from/to JS");
})();

(function TestDefinedGlobals() {
  let kSig_w_v = makeSig([], [kWasmStringRef]);
  let kSig_v_w = makeSig([kWasmStringRef], []);
  let builder = new WasmModuleBuilder();

  builder.addGlobal(kWasmStringRef, true, false).exportAs('w');
  // String views being non-nullable makes them non-defaultable; combined
  // with view creation instructions not being constant that means there is
  // currently no way to have view-typed globals.

  builder.addFunction("get_stringref", kSig_w_v)
    .exportFunc()
    .addBody([
      kExprGlobalGet, 0,
    ]);
  builder.addFunction("set_stringref", kSig_v_w)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprGlobalSet, 0
    ]);

  let instance = builder.instantiate()

  assertEquals(null, instance.exports.get_stringref());
  instance.exports.set_stringref('foo');
  assertEquals('foo', instance.exports.get_stringref());

  assertEquals('foo', instance.exports.w.value);
  instance.exports.w.value = 'bar';
  assertEquals('bar', instance.exports.w.value);
  assertEquals('bar', instance.exports.get_stringref());
})();

(function TestImportedGlobals() {
  for (let type of ['stringview_wtf8', 'stringview_wtf16',
                    'stringview_iter']) {
    let msg = "WebAssembly.Global(): Descriptor property 'value' must be" +
        " a WebAssembly type";

    assertThrows(()=>new WebAssembly.Global({ mutable: true, value: type }),
                 TypeError, msg);
    assertThrows(()=>new WebAssembly.Global({ mutable: true, value: type },
                                            null),
                 TypeError, msg);
  }

  // String with default initializer.
  // TODO(12868): Is this the intended behavior?
  let null_str = new WebAssembly.Global({ value: 'stringref' });
  assertEquals(null, null_str.value);

  let kSig_w_v = makeSig([], [kWasmStringRef]);
  let kSig_v_w = makeSig([kWasmStringRef], []);
  let builder = new WasmModuleBuilder();
  builder.addImportedGlobal('env', 'w', kWasmStringRef, true)
  builder.addFunction("get_stringref", kSig_w_v)
    .exportFunc()
    .addBody([
      kExprGlobalGet, 0,
    ]);
  builder.addFunction("set_stringref", kSig_v_w)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      kExprGlobalSet, 0
    ]);

  let w = new WebAssembly.Global({ mutable: true, value: 'stringref' },
                                 null);
  let instance = builder.instantiate({env: {w: w}})

  assertEquals(null, instance.exports.get_stringref());
  instance.exports.set_stringref('foo');
  assertEquals('foo', instance.exports.get_stringref());

  assertEquals('foo', w.value);
  w.value = 'bar';
  assertEquals('bar', w.value);
  assertEquals('bar', instance.exports.get_stringref());
})();

(function TestDefinedTables() {
  let kSig_w_v = makeSig([], [kWasmStringRef]);
  let kSig_v_w = makeSig([kWasmStringRef], []);
  // String views being non-nullable makes them non-defaultable; combined
  // with view creation instructions not being constant that means there is
  // currently no way to have view-typed tables.
  let builder = new WasmModuleBuilder();

  builder.addTable(kWasmStringRef, 1).exportAs('w');

  builder.addFunction("get_stringref", kSig_w_v)
    .exportFunc()
    .addBody([
      kExprI32Const, 0,
      kExprTableGet, 0,
    ]);
  builder.addFunction("set_stringref", kSig_v_w)
    .exportFunc()
    .addBody([
      kExprI32Const, 0,
      kExprLocalGet, 0,
      kExprTableSet, 0,
    ]);

  let instance = builder.instantiate()

  assertEquals(null, instance.exports.get_stringref());
  instance.exports.set_stringref('foo');
  assertEquals('foo', instance.exports.get_stringref());

  assertEquals('foo', instance.exports.w.get(0));
  instance.exports.w.set(0, 'bar');
  assertEquals('bar', instance.exports.w.get(0));
  assertEquals('bar', instance.exports.get_stringref());

})();

(function TestImportedTables() {
  for (let type of ['stringview_wtf8', 'stringview_wtf16',
                    'stringview_iter']) {
    let msg = "WebAssembly.Table(): Descriptor property 'element' must be" +
        " a WebAssembly reference type";

    assertThrows(()=>new WebAssembly.Table({ element: type, initial: 1 }),
                 TypeError, msg);
    assertThrows(()=>new WebAssembly.Table({ element: type, initial: 1 },
                                            null),
                 TypeError, msg);
  }

  assertThrows(()=>new WebAssembly.Table({ element: 'stringref', initial: 1 }),
               TypeError,
               "WebAssembly.Table(): " +
               "Missing initial value when creating stringref table");

  let kSig_w_v = makeSig([], [kWasmStringRef]);
  let kSig_v_w = makeSig([kWasmStringRef], []);
  let builder = new WasmModuleBuilder();
  builder.addImportedTable('env', 't', 0, undefined, kWasmStringRef);
  builder.addFunction("get_stringref", kSig_w_v)
    .exportFunc()
    .addBody([
      kExprI32Const, 0,
      kExprTableGet, 0,
    ]);
  builder.addFunction("set_stringref", kSig_v_w)
    .exportFunc()
    .addBody([
      kExprI32Const, 0,
      kExprLocalGet, 0,
      kExprTableSet, 0,
    ]);

  let t = new WebAssembly.Table({ element: 'stringref', initial: 1 },
                                 null);
  let instance = builder.instantiate({env: {t: t}})

  assertEquals(null, instance.exports.get_stringref());
  instance.exports.set_stringref('foo');
  assertEquals('foo', instance.exports.get_stringref());

  assertEquals('foo', t.get(0));
  t.set(0, 'bar');
  assertEquals('bar', t.get(0));
  assertEquals('bar', instance.exports.get_stringref());
})();
                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/wasm/stringrefs-regressions.js                                     0000664 0000000 0000000 00000011223 14746647661 0024550 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-stringref --allow-natives-syntax
// We just want speculative inlining, but the "stress" variant doesn't like
// that flag for some reason, so use the GC flag which implies it.
d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

let kSig_w_v = makeSig([], [kWasmStringRef]);
let kSig_w_i = makeSig([kWasmI32], [kWasmStringRef]);
let kSig_v_w = makeSig([kWasmStringRef], []);

(function () {
  let huge_builder = new WasmModuleBuilder();
  huge_builder.addMemory(65001, undefined);

  huge_builder.addFunction("huge", kSig_w_v).exportFunc().addBody([
    kExprI32Const, 0,                  // address
    ...wasmI32Const(65000 * 65536),    // bytes
    ...GCInstr(kExprStringNewUtf8), 0  // memory index
  ]);

  let callee = huge_builder.addFunction("callee", kSig_w_i).addBody([
    kExprI32Const, 0,                  // address
    kExprLocalGet, 0,                  // bytes
    ...GCInstr(kExprStringNewUtf8), 0  // memory index
  ]);

  let caller = huge_builder.addFunction("caller", kSig_i_i).exportFunc()
    .addBody([
      kExprTry, kWasmI32,
      kExprLocalGet, 0,
      kExprCallFunction, callee.index,
      kExprDrop,
      kExprI32Const, 1,
      kExprCatchAll,
      kExprI32Const, 0,
      kExprEnd
    ]);

  let instance;
  try {
    instance = huge_builder.instantiate();
    // On 64-bit platforms, expect to see this message.
    console.log("Instantiation successful, proceeding.");
  } catch (e) {
    // 32-bit builds don't have enough virtual memory, that's OK.
    assertInstanceof(e, RangeError);
    assertMatches(/Cannot allocate Wasm memory for new instance/, e.message,
      'Error message');
    return;
  }

  // Bug 1: The Utf8Decoder can't handle more than kMaxInt bytes as input.
  assertThrows(() => instance.exports.huge(), RangeError);

  // Bug 2: Exceptions created by the JS-focused strings infrastructure must
  // be marked as uncatchable by Wasm.
  let f1 = instance.exports.caller;
  assertThrows(() => f1(2147483647), RangeError);

  // Bug 3: Builtin calls that have neither a kNoThrow annotation nor exception-
  // handling support make the Wasm inliner sad.
  for (let i = 0; i < 20; i++) f1(10);
  %WasmTierUpFunction(f1);
  f1(10);
})();

(function () {
  let builder = new WasmModuleBuilder();

  let concat_body = [];
  // This doubles the string 26 times, i.e. multiplies its length with a factor
  // of ~65 million.
  for (let i = 0; i < 26; i++) {
    concat_body.push(...[
      kExprLocalGet, 0, kExprLocalGet, 0,
      ...GCInstr(kExprStringConcat),
      kExprLocalSet, 0
    ]);
  }

  builder.addFunction('concat', kSig_v_w).exportFunc().addBody(concat_body);

  let instance = builder.instantiate();

  // Bug 4: Throwing in StringAdd must clear the "thread in wasm" bit.
  let f2 = instance.exports.concat;
  assertThrows(() => f2("1234567890"));  // 650M characters is too much.

  // Bug 5: Operations that can trap must not be marked as kEliminatable,
  // otherwise the trap may be eliminated.
  for (let i = 0; i < 3; i++) f2("a");   // 65M characters is okay.
  %WasmTierUpFunction(f2);
  assertThrows(() => f2("1234567890"));  // Optimized code still traps.
})();

(function TestThatOneCharacterStringsAreInternalized() {
  let builder = new WasmModuleBuilder();

  builder.addMemory(1, undefined);
  const kMemIndex = 0;
  builder.addActiveDataSegment(0, [kExprI32Const, 0], [65, 0]);

  let a8 = builder.addArray(kWasmI8, true);
  let a16 = builder.addArray(kWasmI16, true);

  builder.addFunction('makeString8A', kSig_w_v).exportFunc().addBody([
    ...wasmI32Const(65),
    kGCPrefix, kExprArrayNewFixed, a8, 1,
    kExprI32Const, 0,
    kExprI32Const, 1,
    ...GCInstr(kExprStringNewWtf8Array),
  ]);

  builder.addFunction('makeString16A', kSig_w_v).exportFunc().addBody([
    ...wasmI32Const(65),
    kGCPrefix, kExprArrayNewFixed, a16, 1,
    kExprI32Const, 0,
    kExprI32Const, 1,
    ...GCInstr(kExprStringNewWtf16Array),
  ]);

  builder.addFunction('makeString8M', kSig_w_v).exportFunc().addBody([
    kExprI32Const, 0,
    kExprI32Const, 1,
    ...GCInstr(kExprStringNewWtf8), kMemIndex,
  ]);

  builder.addFunction('makeString16M', kSig_w_v).exportFunc().addBody([
    kExprI32Const, 0,
    kExprI32Const, 1,
    ...GCInstr(kExprStringNewWtf16), kMemIndex,
  ]);

  let wasm = builder.instantiate().exports;

  assertTrue(%IsSameHeapObject("A", wasm.makeString8A()));
  assertTrue(%IsSameHeapObject("A", wasm.makeString16A()));
  assertTrue(%IsSameHeapObject("A", wasm.makeString8M()));
  assertTrue(%IsSameHeapObject("A", wasm.makeString16M()));
})();
                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/mjsunit/wasm/stringrefs-valid.js                                           0000664 0000000 0000000 00000035212 14746647661 0023310 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-stringref

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function assertValid(fn) {
  let builder = new WasmModuleBuilder();
  fn(builder);
  // If an assertValid() ever fails unexpectedly, uncomment this line to
  // get a more precise error:
  // builder.toModule();
  assertTrue(WebAssembly.validate(builder.toBuffer()));
}
function assertInvalid(fn, message) {
  let builder = new WasmModuleBuilder();
  fn(builder);
  assertThrows(() => builder.toModule(), WebAssembly.CompileError, message);
}

assertValid(builder => builder.addLiteralStringRef("foo"));

for (let [name, code] of [['string', kStringRefCode],
                          ['stringview_wtf8', kStringViewWtf8Code],
                          ['stringview_wtf16', kStringViewWtf16Code],
                          ['stringview_iter', kStringViewIterCode]]) {
  let default_init = [kExprRefNull, code];

  assertValid(b => b.addType(makeSig([code], [])));
  assertValid(b => b.addStruct([makeField(code, true)]));
  assertValid(b => b.addArray(code, true));
  assertValid(b => b.addType(makeSig([], [code])));
  assertValid(b => b.addTag(makeSig([code], [])));
  assertValid(
    b => b.addFunction(undefined, kSig_v_v).addLocals(code, 1).addBody([]));
  if (name.startsWith("stringview_")) {
    // String views aren't defaultable because they aren't nullable.
    assertInvalid(b => b.addGlobal(code, true, false, default_init));
    assertInvalid(b => b.addTable(code, 0));
    assertInvalid(b => b.addPassiveElementSegment([default_init], code));
    assertInvalid(
        b => b.addFunction(undefined, kSig_v_v).addLocals(code, 1).addBody([
          kExprLocalGet, 0,
          kExprDrop,
        ]));
    assertInvalid(
        b => b.addFunction(undefined, kSig_v_v).addBody([
          kExprRefNull, code,
          kExprDrop,
        ]));
    } else {
    assertValid(b => b.addGlobal(code, true, false, default_init));
    assertValid(b => b.addTable(code, 0));
    assertValid(b => b.addPassiveElementSegment([default_init], code));
  }
}

let kSig_w_i = makeSig([kWasmI32], [kWasmStringRef]);
let kSig_w_ii = makeSig([kWasmI32, kWasmI32], [kWasmStringRef]);
let kSig_w_v = makeSig([], [kWasmStringRef]);
let kSig_i_w = makeSig([kWasmStringRef], [kWasmI32]);
let kSig_i_wi = makeSig([kWasmStringRef, kWasmI32], [kWasmI32]);
let kSig_w_ww = makeSig([kWasmStringRef, kWasmStringRef], [kWasmStringRef]);
let kSig_i_ww = makeSig([kWasmStringRef, kWasmStringRef], [kWasmI32]);
let kSig_x_w = makeSig([kWasmStringRef], [kWasmStringViewWtf8]);
let kSig_i_xii = makeSig([kWasmStringViewWtf8, kWasmI32, kWasmI32],
                         [kWasmI32]);
let kSig_ii_xiii = makeSig([kWasmStringViewWtf8, kWasmI32, kWasmI32,
                            kWasmI32],
                           [kWasmI32, kWasmI32]);
let kSig_w_xii = makeSig([kWasmStringViewWtf8, kWasmI32, kWasmI32],
                         [kWasmStringRef]);
let kSig_y_w = makeSig([kWasmStringRef], [kWasmStringViewWtf16]);
let kSig_i_y = makeSig([kWasmStringViewWtf16], [kWasmI32]);
let kSig_i_yi = makeSig([kWasmStringViewWtf16, kWasmI32], [kWasmI32]);
let kSig_i_yiii = makeSig([kWasmStringViewWtf16, kWasmI32, kWasmI32,
                           kWasmI32], [kWasmI32]);
let kSig_w_yii = makeSig([kWasmStringViewWtf16, kWasmI32, kWasmI32],
                         [kWasmStringRef]);
let kSig_z_w = makeSig([kWasmStringRef], [kWasmStringViewIter]);
let kSig_i_z = makeSig([kWasmStringViewIter], [kWasmI32]);
let kSig_i_zi = makeSig([kWasmStringViewIter, kWasmI32], [kWasmI32]);
let kSig_w_zi = makeSig([kWasmStringViewIter, kWasmI32],
                        [kWasmStringRef]);

(function TestInstructions() {
  let builder = new WasmModuleBuilder();

  builder.addMemory(0, undefined);

  builder.addFunction("string.new_utf8", kSig_w_ii)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1,
      ...GCInstr(kExprStringNewUtf8), 0
    ]);
  builder.addFunction("string.new_utf8_try", kSig_w_ii)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1,
      ...GCInstr(kExprStringNewUtf8Try), 0
    ]);
  builder.addFunction("string.new_lossy_utf8", kSig_w_ii)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1,
      ...GCInstr(kExprStringNewLossyUtf8), 0
    ]);
  builder.addFunction("string.new_wtf8", kSig_w_ii)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1,
      ...GCInstr(kExprStringNewWtf8), 0
    ]);

  builder.addFunction("string.new_wtf16", kSig_w_ii)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1,
      ...GCInstr(kExprStringNewWtf16), 0
    ]);

  builder.addLiteralStringRef("foo");
  builder.addFunction("string.const", kSig_w_v)
    .addBody([
      ...GCInstr(kExprStringConst), 0
    ]);

  builder.addFunction("string.measure_utf8", kSig_i_w)
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringMeasureUtf8)
    ]);
  builder.addFunction("string.measure_wtf8", kSig_i_w)
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringMeasureWtf8)
    ]);

  builder.addFunction("string.measure_wtf16", kSig_i_w)
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringMeasureWtf16)
    ]);

  builder.addFunction("string.encode_utf8", kSig_i_wi)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1,
      ...GCInstr(kExprStringEncodeUtf8), 0
    ]);
  builder.addFunction("string.encode_lossy_utf8", kSig_i_wi)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1,
      ...GCInstr(kExprStringEncodeLossyUtf8), 0
    ]);
  builder.addFunction("string.encode_wtf8", kSig_i_wi)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1,
      ...GCInstr(kExprStringEncodeWtf8), 0
    ]);

  builder.addFunction("string.encode_wtf16", kSig_i_wi)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1,
      ...GCInstr(kExprStringEncodeWtf16), 0
    ]);

  builder.addFunction("string.concat", kSig_w_ww)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1,
      ...GCInstr(kExprStringConcat)
    ]);

  builder.addFunction("string.eq", kSig_i_ww)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1,
      ...GCInstr(kExprStringEq)
    ]);

  builder.addFunction("string.as_wtf8", kSig_x_w)
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringAsWtf8)
    ]);

  builder.addFunction("stringview_wtf8.advance", kSig_i_xii)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1, kExprLocalGet, 2,
      ...GCInstr(kExprStringViewWtf8Advance)
    ]);

  builder.addFunction("stringview_wtf8.encode_utf8", kSig_ii_xiii)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1, kExprLocalGet, 2, kExprLocalGet, 3,
      ...GCInstr(kExprStringViewWtf8EncodeUtf8), 0
    ]);
  builder.addFunction("stringview_wtf8.encode_lossy_utf8", kSig_ii_xiii)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1, kExprLocalGet, 2, kExprLocalGet, 3,
      ...GCInstr(kExprStringViewWtf8EncodeLossyUtf8), 0
    ]);
  builder.addFunction("stringview_wtf8.encode_wtf8", kSig_ii_xiii)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1, kExprLocalGet, 2, kExprLocalGet, 3,
      ...GCInstr(kExprStringViewWtf8EncodeWtf8), 0
    ]);

  builder.addFunction("stringview_wtf8.slice", kSig_w_xii)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1, kExprLocalGet, 2,
      ...GCInstr(kExprStringViewWtf8Slice)
    ]);

  builder.addFunction("string.as_wtf16", kSig_y_w)
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringAsWtf16)
    ]);

  builder.addFunction("stringview_wtf16.length", kSig_i_y)
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringViewWtf16Length)
    ]);

  builder.addFunction("stringview_wtf16.get_codeunit", kSig_i_yi)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1,
      ...GCInstr(kExprStringViewWtf16GetCodeunit)
    ]);

  builder.addFunction("stringview_wtf16.encode", kSig_i_yiii)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1, kExprLocalGet, 2, kExprLocalGet, 3,
      ...GCInstr(kExprStringViewWtf16Encode), 0
    ]);

  builder.addFunction("stringview_wtf16.slice", kSig_w_yii)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1, kExprLocalGet, 2,
      ...GCInstr(kExprStringViewWtf16Slice)
    ]);

  builder.addFunction("string.as_iter", kSig_z_w)
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringAsIter)
    ]);

  builder.addFunction("stringview_iter.next", kSig_i_z)
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringViewIterNext)
    ]);

  builder.addFunction("stringview_iter.advance", kSig_i_zi)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1,
      ...GCInstr(kExprStringViewIterAdvance)
    ]);

  builder.addFunction("stringview_iter.rewind", kSig_i_zi)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1,
      ...GCInstr(kExprStringViewIterRewind)
    ]);

  builder.addFunction("stringview_iter.slice", kSig_w_zi)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1,
      ...GCInstr(kExprStringViewIterSlice)
    ]);

  builder.addFunction("string.from_code_point", kSig_w_i)
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringFromCodePoint)
    ]);

  builder.addFunction("string.hash", kSig_i_w)
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringHash)
    ]);

  let i8_array = builder.addArray(kWasmI8, true);
  let i16_array = builder.addArray(kWasmI16, true);

  builder.addFunction("string.new_utf8_array", kSig_w_v)
    .addBody([
      kExprRefNull, i8_array,
      kExprI32Const, 0,
      kExprI32Const, 0,
      ...GCInstr(kExprStringNewUtf8Array)
    ]);
  builder.addFunction("string.new_utf8_array_try", kSig_w_v)
    .addBody([
      kExprRefNull, i8_array,
      kExprI32Const, 0,
      kExprI32Const, 0,
      ...GCInstr(kExprStringNewUtf8ArrayTry)
    ]);
  builder.addFunction("string.new_lossy_utf8_array", kSig_w_v)
    .addBody([
      kExprRefNull, i8_array,
      kExprI32Const, 0,
      kExprI32Const, 0,
      ...GCInstr(kExprStringNewLossyUtf8Array)
    ]);
  builder.addFunction("string.new_wtf8_array", kSig_w_v)
    .addBody([
      kExprRefNull, i8_array,
      kExprI32Const, 0,
      kExprI32Const, 0,
      ...GCInstr(kExprStringNewWtf8Array)
    ]);

  builder.addFunction("string.new_wtf16_array", kSig_w_v)
    .addBody([
      kExprRefNull, i16_array,
      kExprI32Const, 0,
      kExprI32Const, 0,
      ...GCInstr(kExprStringNewWtf16Array)
    ]);

  builder.addFunction("string.encode_utf8_array", kSig_i_v)
    .addBody([
      kExprRefNull, kStringRefCode,
      kExprRefNull, i8_array,
      kExprI32Const, 0,
      ...GCInstr(kExprStringEncodeUtf8Array)
    ]);
  builder.addFunction("string.encode_lossy_utf8_array", kSig_i_v)
    .addBody([
      kExprRefNull, kStringRefCode,
      kExprRefNull, i8_array,
      kExprI32Const, 0,
      ...GCInstr(kExprStringEncodeLossyUtf8Array)
    ]);
  builder.addFunction("string.encode_wtf8_array", kSig_i_v)
    .addBody([
      kExprRefNull, kStringRefCode,
      kExprRefNull, i8_array,
      kExprI32Const, 0,
      ...GCInstr(kExprStringEncodeWtf8Array)
    ]);

  builder.addFunction("string.encode_wtf16_array", kSig_i_v)
    .addBody([
      kExprRefNull, kStringRefCode,
      kExprRefNull, i16_array,
      kExprI32Const, 0,
      ...GCInstr(kExprStringEncodeWtf16Array)
    ]);

  assertTrue(WebAssembly.validate(builder.toBuffer()));
})();

assertInvalid(
  builder => {
    builder.addFunction("string.const/bad-index", kSig_w_v)
      .addBody([
        ...GCInstr(kExprStringConst), 0
      ]);
  },
  /Invalid string literal index: 0/);

assertInvalid(
  builder => {
    builder.addFunction("string.new_wtf8/no-mem", kSig_w_ii)
      .addBody([
        kExprLocalGet, 0, kExprLocalGet, 1,
        ...GCInstr(kExprStringNewWtf8), 0
      ]);
  },
  /memory index 0 exceeds number of declared memories \(0\)/);

assertInvalid(
  builder => {
    builder.addMemory(0, undefined);
    builder.addFunction("string.new_wtf8/bad-mem", kSig_w_ii)
      .addBody([
        kExprLocalGet, 0, kExprLocalGet, 1,
        ...GCInstr(kExprStringNewWtf8), 1
      ]);
  },
  /memory index 1 exceeds number of declared memories \(1\)/);

assertInvalid(
  builder => {
    builder.addFunction("string.encode_wtf8/no-mem", kSig_i_wi)
      .addBody([
        kExprLocalGet, 0, kExprLocalGet, 1,
        ...GCInstr(kExprStringEncodeWtf8), 0
      ]);
  },
  /memory index 0 exceeds number of declared memories \(0\)/);

assertInvalid(
  builder => {
    builder.addMemory(0, undefined);
    builder.addFunction("string.encode_wtf8/bad-mem", kSig_i_wi)
      .addBody([
        kExprLocalGet, 0, kExprLocalGet, 1,
        ...GCInstr(kExprStringEncodeWtf8), 1
      ]);
  },
  /memory index 1 exceeds number of declared memories \(1\)/);

assertInvalid(
  builder => {
    let i16_array = builder.addArray(kWasmI16, true);
    builder.addFunction("string.new_wtf8_array/bad-type", kSig_w_v)
      .addBody([
        kExprRefNull, i16_array,
        kExprI32Const, 0,
        kExprI32Const, 0,
        ...GCInstr(kExprStringNewWtf8Array)
      ]);
  },
  /string.new_wtf8_array\[0\] expected array of i8, found ref.null of type \(ref null 0\)/);

assertInvalid(
  builder => {
    let i8_array = builder.addArray(kWasmI8, true);
    builder.addFunction("string.new_wtf16_array/bad-type", kSig_w_v)
      .addBody([
        kExprRefNull, i8_array,
        kExprI32Const, 0,
        kExprI32Const, 0,
        ...GCInstr(kExprStringNewWtf16Array)
      ]);
  },
  /string.new_wtf16_array\[0\] expected array of i16, found ref.null of type \(ref null 0\)/);

assertInvalid(
  builder => {
    let immutable_i8_array = builder.addArray(kWasmI8, false);
    let sig = makeSig([kWasmStringRef,
                       wasmRefType(immutable_i8_array),
                       kWasmI32],
                      [kWasmI32]);
    builder.addFunction("string.encode_wtf8_array/bad-type", sig)
      .addBody([
        kExprLocalGet, 0,
        kExprLocalGet, 1,
        kExprLocalGet, 2,
        ...GCInstr(kExprStringEncodeWtf8Array)
      ]);
  },
  /string.encode_wtf8_array\[1\] expected array of mutable i8, found local.get of type \(ref 0\)/);

assertInvalid(
  builder => {
    let immutable_i16_array = builder.addArray(kWasmI16, false);
    let sig = makeSig([kWasmStringRef,
                       wasmRefType(immutable_i16_array),
                       kWasmI32],
                      [kWasmI32]);
    builder.addFunction("string.encode_wtf16_array/bad-type", sig)
      .addBody([
        kExprLocalGet, 0,
        kExprLocalGet, 1,
        kExprLocalGet, 2,
        ...GCInstr(kExprStringEncodeWtf16Array),
      ]);
  },
  /string.encode_wtf16_array\[1\] expected array of mutable i16, found local.get of type \(ref 0\)/);

assertInvalid(builder => {
  builder.addFunction(undefined, kSig_v_v).addBody([...GCInstr(0x790)]);
}, /invalid stringref opcode: fb790/);
                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/wasm/stringview-valuestack.js                                      0000664 0000000 0000000 00000004426 14746647661 0024371 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-stringref

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

let kSig_v_w = makeSig([kWasmStringRef], []);
let kSig_iw_i = makeSig([kWasmI32], [kWasmI32, kWasmStringRef]);

(function TestStringViewIterStack() {
  let builder = new WasmModuleBuilder();
  let wrapper = builder.addStruct([makeField(kWasmStringViewIter, true)]);

  let global = builder.addGlobal(wasmRefNullType(wrapper), true, false);

  builder.addFunction("iterate", kSig_v_w)
    .exportFunc()
    .addBody([
      kExprLocalGet, 0,
      ...GCInstr(kExprStringAsIter),
      kGCPrefix, kExprStructNew, wrapper,
      kExprGlobalSet, global.index
    ]);

  // The following functions perform a stringview operation and have the
  // value 42 on the stack to ensure that the value stack is preserved on each
  // of these operations.

  builder.addFunction("advance", kSig_ii_i)
    .exportFunc()
    .addBody([
      kExprI32Const, 42,
      kExprGlobalGet, global.index,
      kGCPrefix, kExprStructGet, wrapper, 0,
      kExprLocalGet, 0,
      ...GCInstr(kExprStringViewIterAdvance)
    ]);

  builder.addFunction("rewind", kSig_ii_i)
    .exportFunc()
    .addBody([
      kExprI32Const, 42,
      kExprGlobalGet, global.index,
      kGCPrefix, kExprStructGet, wrapper, 0,
      kExprLocalGet, 0,
      ...GCInstr(kExprStringViewIterRewind)
    ]);

  builder.addFunction("slice", kSig_iw_i)
    .exportFunc()
    .addBody([
      kExprI32Const, 42,
      kExprGlobalGet, global.index,
      kGCPrefix, kExprStructGet, wrapper, 0,
      kExprLocalGet, 0,
      ...GCInstr(kExprStringViewIterSlice)
    ]);

  let instance = builder.instantiate();

  let str = 'ascii string';
  instance.exports.iterate(str);
  for (let i = 0; i < str.length; i++) {
    assertEquals([42, 1], instance.exports.advance(1));
  }
  assertEquals([42, 0], instance.exports.advance(1));

  for (let i = 0; i < str.length; i++) {
    assertEquals([42, 1], instance.exports.rewind(1));
  }
  assertEquals([42, 0], instance.exports.rewind(1));

  for (let i = 0; i < str.length; i++) {
    assertEquals([42, str.substring(0, i)], instance.exports.slice(i));
  }
})();
                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/mjsunit/wasm/table-access.js                                               0000664 0000000 0000000 00000013745 14746647661 0022362 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TestGetAndSet() {
function addTableWithAccessors(builder, type, size, name) {
  const table = builder.addTable(type, size);
  const set_sig = makeSig([kWasmI32, type], []);
  builder.addFunction('set_' + name, set_sig)
      .addBody([kExprLocalGet, 0,
          kExprLocalGet, 1,
          kExprTableSet, table.index])
      .exportFunc();

  const get_sig = makeSig([kWasmI32], [type]);
  builder.addFunction('get_' + name, get_sig)
      .addBody([kExprLocalGet, 0, kExprTableGet, table.index])
      .exportFunc();
}

const builder = new WasmModuleBuilder();

addTableWithAccessors(builder, kWasmAnyFunc, 10, 'table_func1');
addTableWithAccessors(builder, kWasmExternRef, 20, 'table_ref1');
addTableWithAccessors(builder, kWasmExternRef, 9, 'table_ref2');
addTableWithAccessors(builder, kWasmAnyFunc, 12, 'table_func2');

let exports = builder.instantiate().exports;
const dummy_ref = {foo : 1, bar : 3};
const dummy_func = exports.set_table_func1;

(function testTableGetInitialValue() {
  print(arguments.callee.name);
  // Tables are initialized with `null`.
  assertSame(null, exports.get_table_func1(1));
  assertSame(null, exports.get_table_func2(2));
  assertSame(null, exports.get_table_ref1(3));
  assertSame(null, exports.get_table_ref2(4));
})();

(function testTableGetOOB() {
  print(arguments.callee.name);
  assertSame(null, exports.get_table_func2(11));
  assertTraps(kTrapTableOutOfBounds, () => exports.get_table_func1(11));
  assertTraps(kTrapTableOutOfBounds, () => exports.get_table_func2(21));
  assertTraps(kTrapTableOutOfBounds, () => exports.get_table_func1(-1));
  assertTraps(kTrapTableOutOfBounds, () => exports.get_table_func2(-2));
  assertSame(null, exports.get_table_ref1(14));
  assertTraps(kTrapTableOutOfBounds, () => exports.get_table_ref2(14));
  assertTraps(kTrapTableOutOfBounds, () => exports.get_table_ref1(44));
  assertTraps(kTrapTableOutOfBounds, () => exports.get_table_ref2(-1));
  assertTraps(kTrapTableOutOfBounds, () => exports.get_table_ref1(-4));
})();

(function testTableSetOOB() {
  print(arguments.callee.name);
  exports.set_table_func2(11, dummy_func);
  assertTraps(kTrapTableOutOfBounds, () => exports.set_table_func1(11, dummy_func));
  assertTraps(kTrapTableOutOfBounds, () => exports.set_table_func2(21, dummy_func));
  exports.set_table_ref1(14, dummy_ref);
  assertTraps(kTrapTableOutOfBounds, () => exports.set_table_ref2(14, dummy_ref));
  assertTraps(kTrapTableOutOfBounds, () => exports.set_table_ref1(44, dummy_ref));
})();

(function testTableSet() {
  print(arguments.callee.name);
  assertSame(null, exports.get_table_func1(3));
  exports.set_table_func1(3, dummy_func);
  assertSame(dummy_func, exports.get_table_func1(3));
  assertSame(null, exports.get_table_func2(3));

  assertSame(null, exports.get_table_func2(7));
  exports.set_table_func2(7, dummy_func);
  assertSame(dummy_func, exports.get_table_func2(7));
  assertSame(null, exports.get_table_func1(7));

  assertSame(null, exports.get_table_ref1(3));
  exports.set_table_ref1(3, dummy_ref);
  assertSame(dummy_ref, exports.get_table_ref1(3));
  assertSame(null, exports.get_table_ref2(3));

  assertSame(null, exports.get_table_ref2(7));
  exports.set_table_ref2(7, dummy_ref);
  assertSame(dummy_ref, exports.get_table_ref2(7));
  assertSame(null, exports.get_table_ref1(7));
})();

(function testSetFunctionTableInvalidType() {
  print(arguments.callee.name);
  assertThrows(() => exports.set_table_func2(7, dummy_ref), TypeError);
})();
})();

(function testGetFunctionFromInitializedTable() {
  print(arguments.callee.name);
  const value1 = 11;
  const value2 = 22;
  const value3 = 13;

  const builder = new WasmModuleBuilder();
  const t1 = builder.addTable(kWasmAnyFunc, 10).index;
  const t2 = builder.addTable(kWasmAnyFunc, 12).index;

  const f1 = builder.addFunction('f', kSig_i_v).addBody([kExprI32Const, value1]);
  const f2 = builder.addFunction('f', kSig_i_v).addBody([kExprI32Const, value2]);
  const f3 = builder.addFunction('f', kSig_i_v).addBody([kExprI32Const, value3]);
  builder.addFunction('get_t1', kSig_a_i)
      .addBody([kExprLocalGet, 0, kExprTableGet, t1])
      .exportFunc();
  builder.addFunction('get_t2', kSig_a_i)
      .addBody([kExprLocalGet, 0, kExprTableGet, t2])
      .exportFunc();

  const offset1 = 3;
  const offset2 = 9;
  builder.addActiveElementSegment(t1, wasmI32Const(offset1),
                                  [f1.index, f2.index]);
  builder.addActiveElementSegment(t2, wasmI32Const(offset2),
                                  [f3.index, f1.index]);

  const instance = builder.instantiate();

  assertEquals(value1, instance.exports.get_t1(offset1)());
  assertEquals(value2, instance.exports.get_t1(offset1 + 1)());
  assertEquals(value3, instance.exports.get_t2(offset2)());
  assertEquals(value1, instance.exports.get_t2(offset2 + 1)());
})();

(function testRefFuncInTableIsCallable() {
  print(arguments.callee.name);
  const expected = 54;
  const index = 3;
  const builder = new WasmModuleBuilder();
  const table_index = builder.addTable(kWasmAnyFunc, 15, 15).index;
  const sig_index = builder.addType(kSig_i_v);
  const function_index = builder.addFunction('hidden', sig_index)
                             .addBody([kExprI32Const, expected])
                             .index;
  builder.addDeclarativeElementSegment([function_index]);

  builder.addFunction('main', kSig_i_v)
      .addBody([
        kExprI32Const, index,                      // entry index
        kExprRefFunc, function_index,              // function reference
        kExprTableSet, table_index,                // --
        kExprI32Const, index,                      // entry index
        kExprCallIndirect, sig_index, table_index  // --
      ])
      .exportFunc();

  const instance = builder.instantiate();
  assertEquals(expected, instance.exports.main());
})();
                           node-23.7.0/deps/v8/test/mjsunit/wasm/table-copy-externref.js                                       0000664 0000000 0000000 00000004211 14746647661 0024057 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

let kTableSize = 5;

let table = new WebAssembly.Table(
    {element: 'externref', initial: kTableSize, maximum: kTableSize});

let builder = new WasmModuleBuilder();
builder.addImportedTable('m', 'table', kTableSize, kTableSize, kWasmExternRef);
builder.addTable(kWasmAnyFunc, 1000);

builder.addFunction('copy', kSig_v_iii)
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1, kExprLocalGet, 2, kNumericPrefix,
      kExprTableCopy, kTableZero, kTableZero
    ])
    .exportFunc();

const instance = builder.instantiate({m: {table: table}});

function resetTable() {
  table.set(0, 1000);
  table.set(1, 1001);
  table.set(2, 1002);
  table.set(3, 1003);
  table.set(4, 1004);
}

function assertTable(values) {
  for (let i = 0; i < kTableSize; ++i) {
    assertEquals(table.get(i), values[i]);
  }
}

resetTable();
instance.exports.copy(0, 1, 1);
assertTable([1001, 1001, 1002, 1003, 1004]);

resetTable();
instance.exports.copy(0, 1, 2);
assertTable([1001, 1002, 1002, 1003, 1004]);

resetTable();
instance.exports.copy(3, 0, 2);
assertTable([1000, 1001, 1002, 1000, 1001]);

// Non-overlapping, src < dst. Because of src < dst, we copy backwards.
// Therefore the first access already traps, and the table is not changed.
resetTable();
assertTraps(kTrapTableOutOfBounds, () => instance.exports.copy(3, 0, 3));
assertTable([1000, 1001, 1002, 1003, 1004]);

// Non-overlapping, dst < src.
resetTable();
assertTraps(kTrapTableOutOfBounds, () => instance.exports.copy(0, 4, 2));
assertTable([1000, 1001, 1002, 1003, 1004]);

// Overlapping, src < dst. This is required to copy backward, but the first
// access will be out-of-bounds, so nothing changes.
resetTable();
assertTraps(kTrapTableOutOfBounds, () => instance.exports.copy(3, 0, 99));
assertTable([1000, 1001, 1002, 1003, 1004]);

// Overlapping, dst < src.
resetTable();
assertTraps(kTrapTableOutOfBounds, () => instance.exports.copy(0, 1, 99));
assertTable([1000, 1001, 1002, 1003, 1004]);
                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/mjsunit/wasm/table-copy.js                                                 0000664 0000000 0000000 00000005702 14746647661 0022065 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function addFunction(builder, k) {
  let m = builder.addFunction("", kSig_i_v)
      .addBody([...wasmI32Const(k)]);
  return m;
}

function assertCall(call, ...elems) {
  for (var i = 0; i < elems.length; i++) {
    assertEquals(elems[i], call(i));
  }
}

(function TestTableCopyShared() {
  print(arguments.callee.name);
  let kTableSize = 5;

  let table = new WebAssembly.Table({element: "anyfunc",
                                     initial: kTableSize,
                                     maximum: kTableSize});

  let module = (() => {
    let builder = new WasmModuleBuilder();
    let sig_v_iii = builder.addType(kSig_v_iii);
    let sig_i_i = builder.addType(kSig_i_i);
    let sig_i_v = builder.addType(kSig_i_v);

    builder.addImportedTable("m", "table", kTableSize, kTableSize);
    var g = builder.addImportedGlobal("m", "g", kWasmI32);

    for (let i = 0; i < kTableSize; i++) {
      let f = builder.addFunction("", kSig_i_v)
          .addBody([
            kExprGlobalGet, g,
            ...wasmI32Const(i),
            kExprI32Add
          ]);
      f.exportAs(`f${i}`);
    }

    builder.addFunction("copy", sig_v_iii)
      .addBody([
        kExprLocalGet, 0,
        kExprLocalGet, 1,
        kExprLocalGet, 2,
        kNumericPrefix, kExprTableCopy, kTableZero, kTableZero])
      .exportAs("copy");

    builder.addFunction("call", sig_i_i)
      .addBody([
        kExprLocalGet, 0,
        kExprCallIndirect, sig_i_v, kTableZero])
      .exportAs("call");

    return builder.toModule();
  })();

  // Two different instances with different globals, to verify that
  // dispatch tables get updated with the right instance.
  let x = new WebAssembly.Instance(module, {m: {g: 1000, table: table}});
  let y = new WebAssembly.Instance(module, {m: {g: 2000, table: table}});

  let x_call = x.exports.call;
  let y_call = y.exports.call;

  assertNotEquals(x.exports.f3, y.exports.f3);

  table.set(0, x.exports.f0);
  table.set(1, x.exports.f1);
  table.set(2, x.exports.f2);
  table.set(3, y.exports.f3);
  table.set(4, y.exports.f4);

  assertEquals(2003, table.get(3)(3));
  assertEquals(2003, x_call(3));
  assertEquals(2003, y_call(3));

  // Check that calling copy on either of them updates the dispatch table
  // on both of them.
  assertCall(x_call, 1000, 1001, 1002, 2003, 2004);
  assertCall(y_call, 1000, 1001, 1002, 2003, 2004);

  x.exports.copy(0, 1, 1);

  assertCall(x_call, 1001, 1001, 1002, 2003, 2004);
  assertCall(y_call, 1001, 1001, 1002, 2003, 2004);

  y.exports.copy(0, 1, 2);

  assertCall(x_call, 1001, 1002, 1002, 2003, 2004);
  assertCall(y_call, 1001, 1002, 1002, 2003, 2004);

  x.exports.copy(3, 0, 2);

  assertCall(x_call, 1001, 1002, 1002, 1001, 1002);
  assertCall(y_call, 1001, 1002, 1002, 1001, 1002);
})();
                                                              node-23.7.0/deps/v8/test/mjsunit/wasm/table-fill.js                                                 0000664 0000000 0000000 00000015116 14746647661 0022041 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

function dummy_func(val) {
  let builder = new WasmModuleBuilder();
  builder.addFunction('dummy', kSig_i_v)
      .addBody([kExprI32Const, val])
      .exportAs('dummy');
  return builder.instantiate().exports.dummy;
}

let kSig_v_iri = makeSig([kWasmI32, kWasmExternRef, kWasmI32], []);
let kSig_v_iai = makeSig([kWasmI32, kWasmAnyFunc, kWasmI32], []);
let kSig_r_i = makeSig([kWasmI32], [kWasmExternRef]);

const builder = new WasmModuleBuilder();
const size = 10;
const maximum = size;
const import_ref =
    builder.addImportedTable('imp', 'table_ref', size, maximum, kWasmExternRef);
const import_func =
    builder.addImportedTable('imp', 'table_func', size, maximum, kWasmAnyFunc);
const internal_ref = builder.addTable(kWasmExternRef, size, maximum).index;
const internal_func = builder.addTable(kWasmAnyFunc, size, maximum).index;

// Add fill and get functions for the externref tables.
for (index of [import_ref, internal_ref]) {
  builder.addFunction(`fill${index}`, kSig_v_iri)
      .addBody([
        kExprLocalGet, 0, kExprLocalGet, 1, kExprLocalGet, 2, kNumericPrefix,
        kExprTableFill, index
      ])
      .exportFunc();

  builder.addFunction(`get${index}`, kSig_r_i)
      .addBody([kExprLocalGet, 0, kExprTableGet, index])
      .exportFunc();
}

// Add fill and call functions for the anyfunc tables.
const sig_index = builder.addType(kSig_i_v);
for (index of [import_func, internal_func]) {
  builder.addFunction(`fill${index}`, kSig_v_iai)
      .addBody([
        kExprLocalGet, 0, kExprLocalGet, 1, kExprLocalGet, 2, kNumericPrefix,
        kExprTableFill, index
      ])
      .exportFunc();

  builder.addFunction(`call${index}`, kSig_i_i)
      .addBody([kExprLocalGet, 0, kExprCallIndirect, sig_index, index])
      .exportFunc();
}

const table_ref =
    new WebAssembly.Table({element: 'externref', initial: size, maximum: maximum});
const table_func = new WebAssembly.Table(
    {element: 'anyfunc', initial: size, maximum: maximum});

const instance =
    builder.instantiate({imp: {table_ref: table_ref, table_func: table_func}});

function checkExternRefTable(getter, start, count, value) {
  for (i = 0; i < count; ++i) {
    assertEquals(value, getter(start + i));
  }
}

(function testExternRefTableIsUninitialized() {
  print(arguments.callee.name);

  checkExternRefTable(instance.exports[`get${import_ref}`], 0, size, undefined);
  checkExternRefTable(instance.exports[`get${internal_ref}`], 0, size, null);
})();

(function testExternRefTableFill() {
  print(arguments.callee.name);
  // Fill table and check the content.
  let start = 1;
  let value = {foo: 23};
  let count = 3;
  instance.exports[`fill${import_ref}`](start, value, count);
  checkExternRefTable(instance.exports[`get${import_ref}`], start, count, value);
  value = 'foo';
  instance.exports[`fill${internal_ref}`](start, value, count);
  checkExternRefTable(instance.exports[`get${internal_ref}`], start, count, value);
})();

(function testExternRefTableFillOOB() {
  print(arguments.callee.name);
  // Fill table out-of-bounds, check if the table wasn't altered.
  let start = 7;
  let value = {foo: 27};
  // {maximum + 4} elements definitely don't fit into the table.
  let count = maximum + 4;
  assertTraps(
      kTrapTableOutOfBounds,
      () => instance.exports[`fill${import_ref}`](start, value, count));
  checkExternRefTable(
      instance.exports[`get${import_ref}`], start, size - start, undefined);

  value = 45;
  assertTraps(
      kTrapTableOutOfBounds,
      () => instance.exports[`fill${internal_ref}`](start, value, count));
  checkExternRefTable(
      instance.exports[`get${internal_ref}`], start, size - start, null);
})();

(function testExternRefTableFillOOBCountZero() {
  print(arguments.callee.name);
  // Fill 0 elements at an oob position. This should trap.
  let start = size + 32;
  let value = 'bar';
  assertTraps(
      kTrapTableOutOfBounds,
      () => instance.exports[`fill${import_ref}`](start, value, 0));
  assertTraps(
      kTrapTableOutOfBounds,
      () => instance.exports[`fill${internal_ref}`](start, value, 0));
})();

function checkAnyFuncTable(call, start, count, value) {
  for (i = 0; i < count; ++i) {
    if (value) {
      assertEquals(value, call(start + i));
    } else {
      assertTraps(kTrapFuncSigMismatch, () => call(start + i));
    }
  }
}

(function testExternRefTableIsUninitialized() {
  print(arguments.callee.name);
  // Check that the table is uninitialized.
  checkAnyFuncTable(instance.exports[`call${import_func}`], 0, size);
  checkAnyFuncTable(instance.exports[`call${internal_func}`], 0, size);
})();

(function testAnyFuncTableFill() {
  print(arguments.callee.name);
  // Fill and check the result.
  let start = 1;
  let value = 44;
  let count = 3;
  instance.exports[`fill${import_func}`](start, dummy_func(value), count);
  checkAnyFuncTable(
      instance.exports[`call${import_func}`], start, count, value);
  value = 21;
  instance.exports[`fill${internal_func}`](start, dummy_func(value), count);
  checkAnyFuncTable(
      instance.exports[`call${internal_func}`], start, count, value);
})();

(function testAnyFuncTableFillOOB() {
  print(arguments.callee.name);
  // Fill table out-of-bounds, check if the table wasn't altered.
  let start = 7;
  let value = 38;
  // {maximum + 4} elements definitely don't fit into the table.
  let count = maximum + 4;
  assertTraps(
      kTrapTableOutOfBounds,
      () => instance.exports[`fill${import_func}`](
          start, dummy_func(value), count));
  checkAnyFuncTable(
      instance.exports[`call${import_func}`], start, size - start, null);

  value = 46;
  assertTraps(
      kTrapTableOutOfBounds,
      () => instance.exports[`fill${internal_func}`](
          start, dummy_func(value), count));
  checkAnyFuncTable(
      instance.exports[`call${internal_func}`], start, size - start, null);
})();

(function testAnyFuncTableFillOOBCountZero() {
  print(arguments.callee.name);
  // Fill 0 elements at an oob position. This should trap.
  let start = size + 32;
  let value = dummy_func(33);
  assertTraps(
      kTrapTableOutOfBounds,
      () => instance.exports[`fill${import_func}`](start, null, 0));
  assertTraps(
      kTrapTableOutOfBounds,
      () => instance.exports[`fill${internal_func}`](start, null, 0));

  // Check that table.fill at position `size` is still valid.
  instance.exports[`fill${import_func}`](size, null, 0);
  instance.exports[`fill${internal_func}`](size, null, 0);
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/test/mjsunit/wasm/table-get.js                                                  0000664 0000000 0000000 00000013362 14746647661 0021673 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function testTableGetNonExportedFunction() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const table = builder.addTable(kWasmAnyFunc, 20).exportAs("table");
  const f1 = builder.addFunction('f', kSig_i_v).addBody([kExprI32Const, 11]);
  const f2 = builder.addFunction('f', kSig_i_v).addBody([kExprI32Const, 22]);
  const offset = 3;
  builder.addActiveElementSegment(0, wasmI32Const(offset),
                                  [f1.index, f2.index]);

  const instance = builder.instantiate();

  const table_function2 = instance.exports.table.get(offset + 1);
  assertEquals(22, table_function2());
})();

(function testTableGetExportedFunction() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const table = builder.addTable(kWasmAnyFunc, 20).exportAs("table");
  const f1 = builder.addFunction('f', kSig_i_v).addBody([kExprI32Const, 11]);
  const f2 = builder.addFunction('f', kSig_i_v).addBody([kExprI32Const, 22])
                    .exportAs("f2");
  const offset = 3;
  builder.addActiveElementSegment(0, wasmI32Const(offset),
                                  [f1.index, f2.index]);

  const instance = builder.instantiate();

  const table_function2 = instance.exports.table.get(offset + 1);
  assertEquals(22, table_function2());
})();

(function testTableGetOverlappingSegments() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const table = builder.addTable(kWasmAnyFunc, 20).exportAs("table");
  const f1 = builder.addFunction('f', kSig_i_v).addBody([kExprI32Const, 11]);
  const f2 = builder.addFunction('f', kSig_i_v).addBody([kExprI32Const, 22]);
  const offset = 3;
  builder.addActiveElementSegment(0, wasmI32Const(offset),
                                  [f1.index, f2.index]);
  builder.addActiveElementSegment(0, wasmI32Const(offset + 1),
                                  [f1.index, f2.index]);

  const instance = builder.instantiate();

  const table_function1 = instance.exports.table.get(offset + 1);
  assertEquals(11, table_function1());
})();

(function testTableGetUniqueWrapperExportedFunction() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const table = builder.addTable(kWasmAnyFunc, 20).exportAs("table");
  const f1 = builder.addFunction('f', kSig_i_v)
                    .addBody([kExprI32Const, 11]).exportAs("f1");
  const f2 = builder.addFunction('f', kSig_i_v).addBody([kExprI32Const, 22]);
  const offset = 3;
  builder.addActiveElementSegment(0, wasmI32Const(offset),
                                  [f1.index, f1.index, f1.index]);

  const instance = builder.instantiate();

  assertEquals(undefined, instance.exports.f1.tag);
  const my_tag = { hello: 15 };
  instance.exports.f1.tag = my_tag;

  assertSame(my_tag, instance.exports.table.get(offset).tag);
  assertSame(my_tag, instance.exports.table.get(offset + 1).tag);
  assertSame(my_tag, instance.exports.table.get(offset + 2).tag);
})();

(function testTableGetUniqueWrapperNonExportedFunction() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const table = builder.addTable(kWasmAnyFunc, 20).exportAs("table");
  const f1 = builder.addFunction('f', kSig_i_v).addBody([kExprI32Const, 11]);
  const f2 = builder.addFunction('f', kSig_i_v).addBody([kExprI32Const, 22]);
  const offset = 3;
  builder.addActiveElementSegment(0, wasmI32Const(offset),
                                  [f1.index, f1.index, f1.index]);

  const instance = builder.instantiate();

  assertEquals(undefined, instance.exports.table.get(offset).tag);
  const my_tag = { hello: 15 };
  instance.exports.table.get(offset).tag = my_tag;

  assertSame(my_tag, instance.exports.table.get(offset + 1).tag);
  assertSame(my_tag, instance.exports.table.get(offset + 2).tag);
})();

(function testTableGetEmptyValue() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const table = builder.addTable(kWasmAnyFunc, 20).exportAs("table");
  const f1 = builder.addFunction('f', kSig_i_v).addBody([kExprI32Const, 11]);
  const f2 = builder.addFunction('f', kSig_i_v).addBody([kExprI32Const, 22]);
  const offset = 3;
  builder.addActiveElementSegment(0, wasmI32Const(offset),
                                  [f1.index, f1.index, f1.index]);

  const instance = builder.instantiate();
  assertEquals(null, instance.exports.table.get(offset - 1));
})();

(function testTableGetOOB() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const size = 20;
  const table = builder.addTable(kWasmAnyFunc, size).exportAs("table");
  const f1 = builder.addFunction('f', kSig_i_v).addBody([kExprI32Const, 11]);
  const f2 = builder.addFunction('f', kSig_i_v).addBody([kExprI32Const, 22]);
  const offset = 3;
  builder.addActiveElementSegment(0, wasmI32Const(offset),
                                  [f1.index, f1.index, f1.index]);

  const instance = builder.instantiate();
  assertThrows(() => instance.exports.table.get(size + 3), RangeError);
})();

(function testTableGetImportedFunction() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const size = 20;
  const table = builder.addTable(kWasmAnyFunc, size).exportAs("table");
  const import1 = builder.addImport("q", "fun", kSig_i_ii);
  const f1 = builder.addFunction('f', kSig_i_v).addBody([kExprI32Const, 11]);
  const offset = 3;
  builder.addActiveElementSegment(0, wasmI32Const(offset),
                                  [f1.index, import1]);

  const instance = builder.instantiate({q: {fun: () => 33}});
  assertEquals(33, instance.exports.table.get(offset + 1)());
})();
                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/wasm/table-grow-from-wasm.js                                       0000664 0000000 0000000 00000020262 14746647661 0023775 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

function dummy_func(val) {
  let builder = new WasmModuleBuilder();
  builder.addFunction("dummy", kSig_i_v)
    .addBody([kExprI32Const, val])
    .exportAs("dummy");
  return builder.instantiate().exports.dummy;
}

let kSig_i_ri = makeSig([kWasmExternRef, kWasmI32], [kWasmI32]);
let kSig_r_i = makeSig([kWasmI32], [kWasmExternRef]);
let kSig_i_ai = makeSig([kWasmAnyFunc, kWasmI32], [kWasmI32]);

function testGrowInternalExternRefTable(table_index) {
  print(arguments.callee.name, table_index);

  const builder = new WasmModuleBuilder();
  const initial_size = 5;
  // Add 10 tables, we only test one.
  for (let i = 0; i < 10; ++i) {
    builder.addTable(kWasmExternRef, initial_size);
  }
  builder.addFunction('grow', kSig_i_ri)
    .addBody([kExprLocalGet, 0,
      kExprLocalGet, 1,
      kNumericPrefix, kExprTableGrow, table_index])
    .exportFunc();

  builder.addFunction('size', kSig_i_v)
    .addBody([kNumericPrefix, kExprTableSize, table_index])
    .exportFunc();

  builder.addFunction('get', kSig_r_i)
    .addBody([kExprLocalGet, 0, kExprTableGet, table_index])
    .exportFunc();

  const instance = builder.instantiate();

  let size = initial_size;
  assertEquals(null, instance.exports.get(size - 2));

  function growAndCheck(element, grow_by) {
    assertEquals(size, instance.exports.size());
    assertTraps(kTrapTableOutOfBounds, () => instance.exports.get(size));
    assertEquals(size, instance.exports.grow(element, grow_by));
    for (let i = 0; i < grow_by; ++i) {
      assertEquals(element, instance.exports.get(size + i));
    }
    size += grow_by;
  }
  growAndCheck("Hello", 3);
  growAndCheck(undefined, 4);
  growAndCheck(4, 2);
  growAndCheck({Hello: "World"}, 3);
  growAndCheck(null, 2);
}

testGrowInternalExternRefTable(0);
testGrowInternalExternRefTable(7);
testGrowInternalExternRefTable(9);

function testGrowInternalAnyFuncTable(table_index) {
  print(arguments.callee.name, table_index);

  const builder = new WasmModuleBuilder();
  let size = 5;
  for (let i = 0; i < 10; ++i) {
    builder.addTable(kWasmAnyFunc, size).index;
  }
  builder.addFunction('grow', kSig_i_ai)
    .addBody([kExprLocalGet, 0,
      kExprLocalGet, 1,
      kNumericPrefix, kExprTableGrow, table_index])
    .exportFunc();

  builder.addFunction('size', kSig_i_v)
    .addBody([kNumericPrefix, kExprTableSize, table_index])
    .exportFunc();

  const sig_index = builder.addType(kSig_i_v);
  builder.addFunction('call', kSig_i_i)
    .addBody([kExprLocalGet, 0, kExprCallIndirect, sig_index, table_index])
    .exportFunc();

  const instance = builder.instantiate();
  assertTraps(kTrapFuncSigMismatch, () => instance.exports.call(size - 2));
  function growAndCheck(element, grow_by) {
    assertEquals(size, instance.exports.size());
    assertTraps(kTrapTableOutOfBounds, () => instance.exports.call(size));
    assertEquals(size, instance.exports.grow(dummy_func(element), grow_by));
    for (let i = 0; i < grow_by; ++i) {
      assertEquals(element, instance.exports.call(size + i));
    }
    size += grow_by;
  }
  growAndCheck(56, 3);
  growAndCheck(12, 4);

  assertEquals(size, instance.exports.grow(null, 1));
  assertTraps(kTrapFuncSigMismatch, () => instance.exports.call(size));
}

testGrowInternalAnyFuncTable(0);
testGrowInternalAnyFuncTable(7);
testGrowInternalAnyFuncTable(9);

(function testGrowImportedTable() {
  print(arguments.callee.name);

  let size = 3;
  const builder = new WasmModuleBuilder();
  const table_index = builder.addImportedTable("imp", "table", size, undefined, kWasmExternRef);
  builder.addFunction('grow', kSig_i_ri)
    .addBody([kExprLocalGet, 0,
      kExprLocalGet, 1,
      kNumericPrefix, kExprTableGrow, table_index])
    .exportFunc();

  builder.addFunction('size', kSig_i_v)
    .addBody([kNumericPrefix, kExprTableSize, table_index])
    .exportFunc();

  const table = new WebAssembly.Table({element: "externref", initial: size});

  const instance = builder.instantiate({imp: {table: table}});
  assertEquals(undefined, table.get(size - 2));

  function growAndCheck(element, grow_by) {
    assertEquals(size, instance.exports.size());
    assertEquals(size, instance.exports.grow(element, grow_by));
    for (let i = 0; i < grow_by; ++i) {
      assertEquals(element, table.get(size + i));
    }
    size += grow_by;
  }
  growAndCheck("Hello", 3);
  growAndCheck(undefined, 4);
  growAndCheck(4, 2);
  growAndCheck({ Hello: "World" }, 3);
  growAndCheck(null, 2);
})();

(function testGrowTableOutOfBounds() {
  print(arguments.callee.name);

  const initial = 3;
  const maximum = 10;
  const max_delta = maximum - initial;
  const invalid_delta = max_delta + 1;

  const builder = new WasmModuleBuilder();
  const import_ref = builder.addImportedTable(
    "imp", "table_ref", initial, maximum, kWasmExternRef);
  const import_func = builder.addImportedTable(
    "imp", "table_func", initial, maximum, kWasmAnyFunc);
  const internal_ref = builder.addTable(kWasmExternRef, initial, maximum).index;
  const internal_func = builder.addTable(kWasmAnyFunc, initial, maximum).index;

  builder.addFunction('grow_imported_ref', kSig_i_ri)
  .addBody([kExprLocalGet, 0,
    kExprLocalGet, 1,
    kNumericPrefix, kExprTableGrow, import_ref])
  .exportFunc();

  builder.addFunction('grow_imported_func', kSig_i_ai)
  .addBody([kExprLocalGet, 0,
    kExprLocalGet, 1,
    kNumericPrefix, kExprTableGrow, import_func])
  .exportFunc();

  builder.addFunction('grow_internal_ref', kSig_i_ri)
  .addBody([kExprLocalGet, 0,
    kExprLocalGet, 1,
    kNumericPrefix, kExprTableGrow, internal_ref])
  .exportFunc();

  builder.addFunction('grow_internal_func', kSig_i_ai)
  .addBody([kExprLocalGet, 0,
    kExprLocalGet, 1,
    kNumericPrefix, kExprTableGrow, internal_func])
  .exportFunc();

  builder.addFunction('size_imported_ref', kSig_i_v)
    .addBody([kNumericPrefix, kExprTableSize, import_ref])
    .exportFunc();

  builder.addFunction('size_imported_func', kSig_i_v)
    .addBody([kNumericPrefix, kExprTableSize, import_func])
    .exportFunc();

  builder.addFunction('size_internal_ref', kSig_i_v)
    .addBody([kNumericPrefix, kExprTableSize, internal_ref])
    .exportFunc();

  builder.addFunction('size_internal_func', kSig_i_v)
    .addBody([kNumericPrefix, kExprTableSize, internal_func])
    .exportFunc();

  const table_ref = new WebAssembly.Table(
    { element: "externref", initial: initial, maximum: maximum });
  const table_func = new WebAssembly.Table(
    {element: "anyfunc", initial: initial, maximum: maximum});

  const instance = builder.instantiate(
    {imp: {table_ref: table_ref, table_func: table_func}});

  const ref = { foo: "bar" };
  const func = dummy_func(17);

  // First check that growing out-of-bounds is not possible.
  assertEquals(-1, instance.exports.grow_imported_ref(ref, invalid_delta));
  assertEquals(initial, table_ref.length);
  assertEquals(initial, instance.exports.size_imported_ref());
  assertEquals(-1, instance.exports.grow_imported_func(func, invalid_delta));
  assertEquals(initial, table_func.length);
  assertEquals(initial, instance.exports.size_imported_func());
  assertEquals(-1, instance.exports.grow_internal_ref(ref, invalid_delta));
  assertEquals(initial, instance.exports.size_internal_ref());
  assertEquals(-1, instance.exports.grow_internal_func(func, invalid_delta));
  assertEquals(initial, instance.exports.size_internal_func());

  // Check that we can grow to the maximum size.
  assertEquals(initial, instance.exports.grow_imported_ref(ref, max_delta));
  assertEquals(maximum, table_ref.length);
  assertEquals(maximum, instance.exports.size_imported_ref());
  assertEquals(initial, instance.exports.grow_imported_func(func, max_delta));
  assertEquals(maximum, table_func.length);
  assertEquals(maximum, instance.exports.size_imported_func());
  assertEquals(initial, instance.exports.grow_internal_ref(ref, max_delta));
  assertEquals(maximum, instance.exports.size_internal_ref());
  assertEquals(initial, instance.exports.grow_internal_func(func, max_delta));
  assertEquals(maximum, instance.exports.size_internal_func());
})();
                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/wasm/table-grow.js                                                 0000664 0000000 0000000 00000023400 14746647661 0022064 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

let kMaxTableSize = 10000000;

function addFunctions(builder) {
  let sig_index = builder.addType(kSig_i_ii);
  let mul = builder.addFunction("mul", sig_index)
    .addBody([
      kExprLocalGet, 0,  // --
      kExprLocalGet, 1,  // --
      kExprI32Mul        // --
    ]);
  let add = builder.addFunction("add", sig_index)
    .addBody([
      kExprLocalGet, 0,  // --
      kExprLocalGet, 1,  // --
      kExprI32Add        // --
    ]);
  let sub = builder.addFunction("sub", sig_index)
    .addBody([
      kExprLocalGet, 0,  // --
      kExprLocalGet, 1,  // --
      kExprI32Sub        // --
    ]);
  return {mul: mul, add: add, sub: sub};
}

function testBounds(func, table) {
  for (let i = 0; i < table.length; i++) {
    assertEquals(0, func(i));
  }
  let l = table.length;
  let oob = [l, l + 1, l + 2, l * 2, l * 3, l + 10000];
  for (let i of oob) {
    assertThrows(() => func(i));
  }
}

function addMain(builder) {
  builder.addImportedTable("imp", "table", 0, kMaxTableSize);
  builder.addFunction("main", kSig_i_i)
    .addBody([
      kExprI32Const, 0,
      kExprLocalGet, 0,
      kExprCallIndirect, 0, kTableZero])
    .exportAs("main");
}

let id = (() => {  // identity exported function
  let builder = new WasmModuleBuilder();
  builder.addFunction("id", kSig_i_i)
    .addBody([kExprLocalGet, 0])
    .exportAs("id");
  let module = new WebAssembly.Module(builder.toBuffer());
  return (new WebAssembly.Instance(builder.toModule())).exports.id;
})();

(function TableGrowBoundsCheck() {
  print("TableGrowBoundsCheck");
  let builder = new WasmModuleBuilder();
  addMain(builder);
  let module = new WebAssembly.Module(builder.toBuffer());
  let table = new WebAssembly.Table({element: "anyfunc",
                                     initial: 1, maximum:kMaxTableSize});
  function fillTable() {
    for (let i = 0; i < table.length; i++) table.set(i, id);
    return table;
  }
  fillTable();
  let instance1 = new WebAssembly.Instance(module, {imp: {table:table}});
  testBounds(instance1.exports.main, table);

  for (let i = 0; i < 4; i++) {
    table.grow(1);
    fillTable(table);
    testBounds(instance1.exports.main, table);
  }
  let instance2 = new WebAssembly.Instance(module, {imp: {table:table}});
  testBounds(instance2.exports.main, table);

  for (let i = 0; i < 4; i++) {
    table.grow(1);
    fillTable(table);
    testBounds(instance1.exports.main, table);
    testBounds(instance2.exports.main, table);
  }
})();

(function TableGrowBoundsZeroInitial() {
  print("TableGrowBoundsZeroInitial");
  let builder = new WasmModuleBuilder();
  addMain(builder);
  let module = new WebAssembly.Module(builder.toBuffer());
  var table = new WebAssembly.Table({element: "anyfunc",
                                     initial: 0, maximum:kMaxTableSize});
  function growTableByOne() {
    table.grow(1);
    table.set(table.length - 1, id);
  }
  let instance1 = new WebAssembly.Instance(module, {imp: {table:table}});
  testBounds(instance1.exports.main, table);

  for (let i = 0; i < 4; i++) {
    growTableByOne();
    testBounds(instance1.exports.main, table);
  }
  let instance2 = new WebAssembly.Instance(module, {imp: {table:table}});
  testBounds(instance2.exports.main, table);

  for (let i = 0; i < 4; i++) {
    growTableByOne();
    testBounds(instance1.exports.main, table);
    testBounds(instance2.exports.main, table);
  }
})();

(function InstancesShareTableAndGrowTest() {
  print("InstancesShareTableAndGrowTest");
  let builder = new WasmModuleBuilder();
  let funcs = addFunctions(builder);
  builder.addFunction("main", kSig_i_ii)
    .addBody([
      kExprI32Const, 15,  // --
      kExprLocalGet, 0,   // --
      kExprLocalGet, 1,   // --
      kExprCallIndirect, 0, kTableZero])  // --
    .exportAs("main");

  builder.addImportedTable("q", "table", 5, 32);
  let g = builder.addImportedGlobal("q", "base", kWasmI32);
  builder.addActiveElementSegment(0, [kExprGlobalGet, g],
      [funcs.mul.index, funcs.add.index, funcs.sub.index]);
  builder.addExportOfKind("table", kExternalTable, 0);
  let module = new WebAssembly.Module(builder.toBuffer());
  let t1 = new WebAssembly.Table({element: "anyfunc",
    initial: 5, maximum: 30});

  for (let i = 0; i < 5; i++) {
    print("base = " + i);
    let instance = new WebAssembly.Instance(module, {q: {base: i, table: t1}});
    main = instance.exports.main;
    assertEquals(i * 5 + 5, t1.length);

    // mul
    assertEquals(15, main(1, i));
    assertEquals(30, main(2, i));
    // add
    assertEquals(20, main(5, i+1));
    assertEquals(25, main(10, i+1));
    //sub
    assertEquals(10, main(5, i+2));
    assertEquals(5, main(10, i+2));

    assertThrows(() => t1.set(t1.length, id), RangeError);
    assertThrows(() => t1.set(t1.length + 5, id), RangeError);
    assertEquals(i * 5 + 5, t1.grow(5));
  }

  t1.set(t1.length - 1, id);
  assertThrows(() => t1.set(t1.length, id), RangeError);
  assertThrows(() => t1.grow(2), RangeError);
})();

(function ModulesShareTableAndGrowTest() {
  print("ModulesShareTableAndGrowTest");
  let builder = new WasmModuleBuilder();
  let sig_i_ii = builder.addType(kSig_i_ii);
  let sig_i_i = builder.addType(kSig_i_i);
  let sig_i_v = builder.addType(kSig_i_v);

  let g1 = builder.addImportedGlobal("q", "base", kWasmI32);

  let a = builder.addImport("q", "exp_add", sig_i_ii);
  let i = builder.addImport("q", "exp_inc", sig_i_i);
  let t = builder.addImport("q", "exp_ten", sig_i_v);

  builder.setTableBounds(7, 35);
  builder.addActiveElementSegment(0, [kExprGlobalGet, g1], [a, i, t]);

  builder.addExportOfKind("table", kExternalTable, 0);
  let module = new WebAssembly.Module(builder.toBuffer());

  function exp_add(a, b) { return a + b; }
  function exp_inc(a) { return a + 1 | 0; }
  function exp_ten() { return 10; }

  let instance = new WebAssembly.Instance(module, {q: {base: 0,
    exp_add: exp_add, exp_inc: exp_inc, exp_ten: exp_ten}});

  let table = instance.exports.table;

  print("   initial check");

  function checkTableFunc(index, expected, ...args) {
    let f = table.get(index);
    print("  table[" + index + "] = " + f);
    result = f(...args);
    print("    -> expect " + expected + ", got " + result);
    assertEquals(expected, result);
  }

  checkTableFunc(0, 5, 1, 4);
  checkTableFunc(1, 9, 8);
  checkTableFunc(2, 10, 0);

  let builder1 = new WasmModuleBuilder();
  let g = builder1.addImportedGlobal("q", "base", kWasmI32);
  let funcs = addFunctions(builder1);

  builder1.addImportedTable("q", "table", 6, 36);
  builder1.addActiveElementSegment(
      0, [kExprGlobalGet, g],
      [funcs.mul.index, funcs.add.index, funcs.sub.index]);
  let module1 = new WebAssembly.Module(builder1.toBuffer());

  function verifyTableFuncs(base) {
    print("  base = " + base);
    checkTableFunc(0, 5, 1, 4);
    checkTableFunc(1, 9, 8);
    checkTableFunc(2, 10, 0);

    checkTableFunc(base+0, 20, 10, 2); // mul
    checkTableFunc(base+1, 12, 10, 2); // add
    checkTableFunc(base+2,  8, 10, 2); // sub
  }

  for (let i = 3; i < 10; i++) {
    new WebAssembly.Instance(module1, {q: {base: i, table: table}});
    verifyTableFuncs(i);
    var prev = table.length;
    assertEquals(prev,     table.grow(3));
    assertEquals(prev + 3, table.length);
    verifyTableFuncs(i);

    assertThrows(() => table.set(table.length, id), RangeError);
    assertThrows(() => table.set(table.length + 5, id), RangeError);
  }
})();

(function ModulesInstancesSharedTableBoundsCheck() {
  print("ModulesInstancesSharedTableBoundsCheck");
  let table = new WebAssembly.Table({element: "anyfunc",
    initial: 1, maximum: kMaxTableSize});

  function CallModuleBuilder() {
    var builder = new WasmModuleBuilder();
    builder.addType(kSig_i_v);
    builder.addType(kSig_v_v);
    let index_i_ii = builder.addType(kSig_i_ii);
    let index_i_i = builder.addType(kSig_i_i);
    builder.addImportedTable("x", "table", 1, kMaxTableSize);
    builder.addFunction("add", index_i_ii)
      .addBody([
        kExprLocalGet, 0,
        kExprLocalGet, 1,
        kExprI32Add]);
    builder.addFunction("main", index_i_i)
      .addBody([
        kExprI32Const, 5,
        kExprI32Const, 5,
        kExprLocalGet, 0,
        kExprCallIndirect, index_i_ii, kTableZero])
      .exportAs("main");
    builder.addActiveElementSegment(0, wasmI32Const(0), [0]);
    return new WebAssembly.Module(builder.toBuffer());
  }

  var instances = [], modules = [];
  modules[0] = CallModuleBuilder();
  modules[1] = CallModuleBuilder();

  // Modules[0] shared by instances[0..2], modules[1] shared by instances[3, 4]
  instances[0] = new WebAssembly.Instance(modules[0], {x: {table:table}});
  instances[1] = new WebAssembly.Instance(modules[0], {x: {table:table}});
  instances[2] = new WebAssembly.Instance(modules[0], {x: {table:table}});
  instances[3] = new WebAssembly.Instance(modules[1], {x: {table:table}});
  instances[4] = new WebAssembly.Instance(modules[1], {x: {table:table}});

  function VerifyTableBoundsCheck(size) {
    print("Verifying bounds for size = " + size);
    assertEquals(size, table.length);
    for (let i = 0; i < 5; i++) {
      // Validity check for indirect call
      assertEquals(10, instances[i].exports.main(0));
      // Bounds check at different out of bounds indices
      assertInvalidFunction = function(s) {
        assertThrows(
            () => instances[i].exports.main(s), WebAssembly.RuntimeError,
            kTrapMsgs[kTrapTableOutOfBounds]);
      }
      assertInvalidFunction(size);
      assertInvalidFunction(size + 1);
      assertInvalidFunction(size + 1000);
      assertInvalidFunction(2 * size);
    }
  }

  for (let i = 0; i < 4; i++) {
    VerifyTableBoundsCheck(99900 * i + 1);
    table.grow(99900);
  }
})();
                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/wasm/table-limits.js                                               0000664 0000000 0000000 00000002731 14746647661 0022413 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-max-table-size=10

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// With the flags we set the maximum table size to 10, so 11 is out-of-bounds.
const oob = 11;

(function TestJSTableInitialAboveTheLimit() {
  print(arguments.callee.name);
  assertThrows(
    () => new WebAssembly.Table({ initial: oob, element: "anyfunc" }),
    RangeError, /above the upper bound/);
})();

(function TestJSTableMaximumAboveTheLimit() {
  print(arguments.callee.name);
  let table =
      new WebAssembly.Table({initial: 1, maximum: oob, element: 'anyfunc'});
  assertThrows(() => table.grow(oob - 1), RangeError, /failed to grow table/);
})();

(function TestDecodeTableInitialAboveTheLimit() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.setTableBounds(oob);

  const err_msg = `WebAssembly.Module(): initial table size \
(11 elements) is larger than implementation limit (10 elements) @+13`;
  assertThrows(
    () => builder.instantiate(),
    WebAssembly.CompileError, err_msg);
})();

(function TestDecodeTableMaximumAboveTheLimit() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.setTableBounds(1, oob);
  // Should not throw, as the table does not exceed the limit at instantiation
  // time.
  builder.instantiate();
})();
                                       node-23.7.0/deps/v8/test/mjsunit/wasm/table-numeric-ops.js                                          0000664 0000000 0000000 00000013040 14746647661 0023346 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function TestTableNumericOps() {
  print(arguments.callee.name);
  let kTableNum = 10;
  for (let table_index of [0, 7, 9]) {
    let builder = new WasmModuleBuilder();
    let kTableSize = 5;

    for (let i = 0; i < kTableNum; i++) {
      builder.addTable(kWasmFuncRef, kTableSize);
    }

    let elements = [];

    let sig_i_v = builder.addType(kSig_i_v);

    for (let i = 0; i < kTableSize; i++) {
      builder.addFunction("f" + i, sig_i_v).addBody([kExprI32Const, i]);
      elements.push(i);
    }

    let passive = builder.addPassiveElementSegment(elements);

    let sig_i_i = builder.addType(kSig_i_i);

    builder.addFunction("call", sig_i_i)
      .addBody([kExprLocalGet, 0, kExprCallIndirect, sig_i_v, table_index])
      .exportFunc();
    builder.addFunction("table_init", kSig_v_iii)
      .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprLocalGet, 2,
                kNumericPrefix, kExprTableInit, passive, table_index])
      .exportFunc();
    builder.addFunction("drop", kSig_v_v)
      .addBody([kNumericPrefix, kExprElemDrop, passive])
      .exportFunc();

    let wasm = builder.instantiate().exports;

    // An out-of-bounds trapping initialization should not have an effect on the
    // table.
    assertTraps(kTrapTableOutOfBounds, () => wasm.table_init(3, 0, 3));
    assertTraps(kTrapFuncSigMismatch, () => wasm.call(0));
    assertTraps(kTrapFuncSigMismatch, () => wasm.call(1));
    assertTraps(kTrapFuncSigMismatch, () => wasm.call(2));
    assertTraps(kTrapFuncSigMismatch, () => wasm.call(3));
    assertTraps(kTrapFuncSigMismatch, () => wasm.call(4));

    assertTraps(kTrapElementSegmentOutOfBounds, () => wasm.table_init(0, 3, 3));
    assertTraps(kTrapFuncSigMismatch, () => wasm.call(0));
    assertTraps(kTrapFuncSigMismatch, () => wasm.call(1));
    assertTraps(kTrapFuncSigMismatch, () => wasm.call(2));
    assertTraps(kTrapFuncSigMismatch, () => wasm.call(3));
    assertTraps(kTrapFuncSigMismatch, () => wasm.call(4));

    // 0-count is still oob if target is invalid.
    assertTraps(kTrapTableOutOfBounds,
                () => wasm.table_init(kTableSize + 1, 0, 0));
    assertTraps(kTrapElementSegmentOutOfBounds,
                () => wasm.table_init(0, kTableSize + 1, 0));

    assertTraps(kTrapTableOutOfBounds, () => wasm.table_init(0, 0, 6));
    assertTraps(kTrapElementSegmentOutOfBounds, () => wasm.table_init(0, 1, 5));
    assertTraps(kTrapElementSegmentOutOfBounds, () => wasm.table_init(0, 2, 4));
    assertTraps(kTrapElementSegmentOutOfBounds, () => wasm.table_init(0, 3, 3));
    assertTraps(kTrapElementSegmentOutOfBounds, () => wasm.table_init(0, 4, 2));
    assertTraps(kTrapElementSegmentOutOfBounds, () => wasm.table_init(0, 5, 1));
    assertTraps(kTrapTableOutOfBounds, () => wasm.table_init(0, 0, 6));
    assertTraps(kTrapTableOutOfBounds, () => wasm.table_init(1, 0, 5));
    assertTraps(kTrapTableOutOfBounds, () => wasm.table_init(2, 0, 4));
    assertTraps(kTrapTableOutOfBounds, () => wasm.table_init(3, 0, 3));
    assertTraps(kTrapTableOutOfBounds, () => wasm.table_init(4, 0, 2));
    assertTraps(kTrapTableOutOfBounds, () => wasm.table_init(5, 0, 1));
    assertTraps(kTrapTableOutOfBounds, () => wasm.table_init(10, 0, 1));
    assertTraps(kTrapElementSegmentOutOfBounds,
                () => wasm.table_init(0, 10, 1));

    // Initializing 0 elements is ok, even at the end of the table/segment.
    wasm.table_init(0, 0, 0);
    wasm.table_init(kTableSize, 0, 0);
    wasm.table_init(0, kTableSize, 0);

    wasm.table_init(0, 0, 1);
    assertEquals(0, wasm.call(0));
    assertTraps(kTrapFuncSigMismatch, () => wasm.call(1));
    assertTraps(kTrapFuncSigMismatch, () => wasm.call(2));
    assertTraps(kTrapFuncSigMismatch, () => wasm.call(3));
    assertTraps(kTrapFuncSigMismatch, () => wasm.call(4));

    wasm.table_init(0, 0, 2);
    assertEquals(0, wasm.call(0));
    assertEquals(1, wasm.call(1));
    assertTraps(kTrapFuncSigMismatch, () => wasm.call(2));
    assertTraps(kTrapFuncSigMismatch, () => wasm.call(3));
    assertTraps(kTrapFuncSigMismatch, () => wasm.call(4));

    wasm.table_init(0, 0, 3);
    assertEquals(0, wasm.call(0));
    assertEquals(1, wasm.call(1));
    assertEquals(2, wasm.call(2));
    assertTraps(kTrapFuncSigMismatch, () => wasm.call(3));
    assertTraps(kTrapFuncSigMismatch, () => wasm.call(4));

    wasm.table_init(3, 0, 2);
    assertEquals(0, wasm.call(0));
    assertEquals(1, wasm.call(1));
    assertEquals(2, wasm.call(2));
    assertEquals(0, wasm.call(3));
    assertEquals(1, wasm.call(4));

    wasm.table_init(3, 1, 2);
    assertEquals(0, wasm.call(0));
    assertEquals(1, wasm.call(1));
    assertEquals(2, wasm.call(2));
    assertEquals(1, wasm.call(3));
    assertEquals(2, wasm.call(4));

    wasm.table_init(3, 2, 2);
    assertEquals(0, wasm.call(0));
    assertEquals(1, wasm.call(1));
    assertEquals(2, wasm.call(2));
    assertEquals(2, wasm.call(3));
    assertEquals(3, wasm.call(4));

    wasm.table_init(3, 3, 2);
    assertEquals(0, wasm.call(0));
    assertEquals(1, wasm.call(1));
    assertEquals(2, wasm.call(2));
    assertEquals(3, wasm.call(3));
    assertEquals(4, wasm.call(4));

    // Now drop the passive segment twice. This should work.
    wasm.drop();
    wasm.drop();

    // Subsequent accesses should trap for size > 0.
    wasm.table_init(0, 0, 0);
    assertTraps(kTrapElementSegmentOutOfBounds, () => wasm.table_init(0, 1, 0));
  }
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/wasm/table.js                                                      0000664 0000000 0000000 00000024172 14746647661 0021117 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

'use strict';

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// Basic tests.

const outOfUint32RangeValue = 1e12;
const kV8MaxWasmTableSize = 10000000;

function assertTableIsValid(table, length) {
  assertSame(WebAssembly.Table.prototype, table.__proto__);
  assertSame(WebAssembly.Table, table.constructor);
  assertTrue(table instanceof Object);
  assertTrue(table instanceof WebAssembly.Table);
  assertEquals(length, table.length);
}

(function TestConstructor() {
  assertTrue(WebAssembly.Table instanceof Function);
  assertSame(WebAssembly.Table, WebAssembly.Table.prototype.constructor);
  assertTrue(WebAssembly.Table.prototype.grow instanceof Function);
  assertTrue(WebAssembly.Table.prototype.get instanceof Function);
  assertTrue(WebAssembly.Table.prototype.set instanceof Function);
  let desc = Object.getOwnPropertyDescriptor(WebAssembly.Table.prototype, 'length');
  assertTrue(desc.get instanceof Function);
  assertSame(undefined, desc.set);

  assertThrows(() => new WebAssembly.Table(), TypeError);
  assertThrows(() => new WebAssembly.Table(1), TypeError);
  assertThrows(() => new WebAssembly.Table(""), TypeError);

  assertThrows(() => new WebAssembly.Table({}), TypeError);
  assertThrows(() => new WebAssembly.Table({initial: 10}), TypeError);

  assertThrows(() => new WebAssembly.Table({element: 0, initial: 10}), TypeError);
  assertThrows(() => new WebAssembly.Table({element: "any", initial: 10}), TypeError);

  assertThrows(() => new WebAssembly.Table(
    {element: "anyfunc", initial: -1}), TypeError);
  assertThrows(() => new WebAssembly.Table(
    {element: "anyfunc", initial: outOfUint32RangeValue}), TypeError);

  assertThrows(() => new WebAssembly.Table(
    {element: "anyfunc", initial: 10, maximum: -1}), TypeError);
  assertThrows(() => new WebAssembly.Table(
    {element: "anyfunc", initial: 10, maximum: outOfUint32RangeValue}), TypeError);
  assertThrows(() => new WebAssembly.Table(
    {element: "anyfunc", initial: 10, maximum: 9}), RangeError);

  let table;
  table = new WebAssembly.Table({element: "anyfunc", initial: 1});
  assertTableIsValid(table, 1);
  assertEquals(null, table.get(0));
  assertEquals(undefined, table[0]);

  table = new WebAssembly.Table({element: "anyfunc", initial: "2"});
  assertTableIsValid(table, 2);
  assertEquals(null, table.get(0));
  assertEquals(null, table.get(1));
  assertEquals(undefined, table[0]);
  assertEquals(undefined, table[1]);

  table = new WebAssembly.Table({element: "anyfunc", initial: {valueOf() { return "1" }}});
  assertTableIsValid(table, 1);
  assertEquals(null, table.get(0));
  assertEquals(undefined, table[0]);

  table = new WebAssembly.Table({element: "anyfunc", initial: 0, maximum: 10});
  assertTableIsValid(table, 0);

  table = new WebAssembly.Table({element: "anyfunc", initial: 0,  maximum: "10"});
  assertTableIsValid(table, 0);

  table = new WebAssembly.Table({element: "anyfunc", initial: 0, maximum: {valueOf() { return "10" }}});
  assertTableIsValid(table, 0);

  table = new WebAssembly.Table({element: "anyfunc", initial: 0, maximum: undefined});
  assertTableIsValid(table, 0);

  table = new WebAssembly.Table({element: "anyfunc", initial: 0, maximum: 1000000});
  assertTableIsValid(table, 0);

  table = new WebAssembly.Table({element: "anyfunc", initial: 0, maximum: kV8MaxWasmTableSize});
  assertTableIsValid(table, 0);

  table = new WebAssembly.Table({element: "anyfunc", initial: 0, maximum: kV8MaxWasmTableSize + 1});
  assertTableIsValid(table, 0);

  assertThrows(
    () => new WebAssembly.Table(
      {element: "anyfunc", initial: kV8MaxWasmTableSize + 1}),
    RangeError, /above the upper bound/);
})();

(function TestMaximumIsReadOnce() {
  var a = true;
  var desc = {element: "anyfunc", initial: 10};
  Object.defineProperty(desc, 'maximum', {get: function() {
    if (a) {
      a = false;
      return 16;
    }
    else {
      // Change the return value on the second call so it throws.
      return -1;
    }
  }});
  let table = new WebAssembly.Table(desc);
  assertTableIsValid(table, 10);
})();

(function TestMaximumDoesHasProperty() {
  var hasPropertyWasCalled = false;
  var desc = {element: "anyfunc", initial: 10};
  var proxy = new Proxy({maximum: 16}, {
    has: function(target, name) { hasPropertyWasCalled = true; }
  });
  Object.setPrototypeOf(desc, proxy);
  let table = new WebAssembly.Table(desc);
  assertTableIsValid(table, 10);
})();

(function TestLength() {
  for (let i = 0; i < 10; ++i) {
    let table = new WebAssembly.Table({element: "anyfunc", initial: i});
    assertEquals(i, table.length);
  }

  assertThrows(() => WebAssembly.Table.prototype.length.call([]), TypeError);
})();

(function TestGet() {
  let table = new WebAssembly.Table({element: "anyfunc", initial: 10});

  for (let i = 0; i < table.length; ++i) {
    assertEquals(null, table.get(i));
    assertEquals(null, table.get(String(i)));
  }
  for (let key of [0.4, "", []]) {
    assertEquals(null, table.get(key));
  }
  for (let key of [-1, NaN, {}, () => {}]) {
    assertThrows(() => table.get(key), TypeError);
  }
  for (let key of [table.length, table.length * 10]) {
    assertThrows(() => table.get(key), RangeError);
  }
  assertThrows(() => table.get(Symbol()), TypeError);
  assertThrows(() => WebAssembly.Table.prototype.get.call([], 0), TypeError);
})();

(function TestSet() {
  let builder = new WasmModuleBuilder;
  builder.addExport("host", builder.addImport("test", "f", kSig_v_v));
  builder.addExport("wasm", builder.addFunction("", kSig_v_v).addBody([]));
  let {wasm, host} = builder.instantiate({test: {f() {}}}).exports;

  let table = new WebAssembly.Table({element: "anyfunc", initial: 10});

  for (let f of [wasm, host]) {
    for (let i = 0; i < table.length; ++i) table.set(i, null);
    for (let i = 0; i < table.length; ++i) {
      assertSame(null, table.get(i));
      assertSame(undefined, table.set(i, f));
      assertSame(f, table.get(i));
      assertSame(undefined, table[i]);
    }

    for (let i = 0; i < table.length; ++i) table.set(i, null);
    for (let i = 0; i < table.length; ++i) {
      assertSame(null, table.get(i));
      assertSame(undefined, table.set(String(i), f));
      assertSame(f, table.get(i));
      assertSame(undefined, table[i]);
    }

    for (let key of [0.4, "", []]) {
      assertSame(undefined, table.set(0, null));
      assertSame(undefined, table.set(key, f));
      assertSame(f, table.get(0));
      assertSame(undefined, table[key]);
    }
    for (let key of [NaN, {}, () => {}]) {
      assertSame(undefined, table[key]);
      assertThrows(() => table.set(key, f), TypeError);
    }

    assertThrows(() => table.set(-1, f), TypeError);
    for (let key of [table.length, table.length * 10]) {
      assertThrows(() => table.set(key, f), RangeError);
    }

    for (let val of [undefined, 0, "", {}, [], () => {}]) {
      assertThrows(() => table.set(0, val), TypeError);
    }

    assertThrows(() => table.set(Symbol(), f), TypeError);
    assertThrows(() => WebAssembly.Table.prototype.set.call([], 0, f),
                 TypeError);
  }
})();


(function TestIndexing() {
  let builder = new WasmModuleBuilder;
  builder.addExport("host", builder.addImport("test", "f", kSig_v_v));
  builder.addExport("wasm", builder.addFunction("", kSig_v_v).addBody([]));
  let {wasm, host} = builder.instantiate({test: {f() {}}}).exports;

  let table = new WebAssembly.Table({element: "anyfunc", initial: 10});

  for (let f of [wasm, host, () => {}, 5, {}, ""]) {
    for (let i = 0; i < table.length; ++i) table[i] = f;
    for (let i = 0; i < table.length; ++i) {
      assertSame(null, table.get(i));
      assertSame(f, table[i]);
    }

    for (let key of [NaN, {}, () => {}]) {
      assertSame(f, table[key] = f);
      assertSame(f, table[key]);
      assertThrows(() => table.get(key), TypeError);
    }
    for (let key of [0.4, "", []]) {
      assertSame(f, table[key] = f);
      assertSame(f, table[key]);
      assertSame(null, table.get(key));
    }
  }
})();

(function TestGrow() {
  let builder = new WasmModuleBuilder;
  builder.addExport("host", builder.addImport("test", "f", kSig_v_v));
  builder.addExport("wasm", builder.addFunction("", kSig_v_v).addBody([]));
  let {wasm, host} = builder.instantiate({test: {f() {}}}).exports;

  function init(table) {
    for (let i = 0; i < 5; ++i) table.set(i, wasm);
    for (let i = 15; i < 20; ++i) table.set(i, host);
  }
  function check(table) {
    for (let i = 0; i < 5; ++i) assertSame(wasm, table.get(i));
    for (let i = 6; i < 15; ++i) assertSame(null, table.get(i));
    for (let i = 15; i < 20; ++i) assertSame(host, table.get(i));
    for (let i = 21; i < table.length; ++i) assertSame(null, table.get(i));
  }

  let table = new WebAssembly.Table({element: "anyfunc", initial: 20});
  init(table);
  check(table);
  table.grow(0);
  check(table);
  table.grow(10);
  check(table);
  assertThrows(() => table.grow(-10), TypeError);

  table = new WebAssembly.Table({element: "anyfunc", initial: 20, maximum: 25});
  init(table);
  check(table);
  table.grow(0);
  check(table);
  table.grow(5);
  check(table);
  table.grow(0);
  check(table);
  assertThrows(() => table.grow(1), RangeError);
  assertThrows(() => table.grow(-10), TypeError);

  assertThrows(() => WebAssembly.Table.prototype.grow.call([], 0), TypeError);

  table = new WebAssembly.Table(
    {element: "anyfunc", initial: 0, maximum: kV8MaxWasmTableSize});
  table.grow(kV8MaxWasmTableSize);
  assertThrows(() => table.grow(1), RangeError);

  table = new WebAssembly.Table({element: "anyfunc", initial: 0});
  table.grow({valueOf: () => {table.grow(2); return 1;}});
  assertEquals(3, table.length);
})();

(function TestGrowWithInit() {
  function getDummy(val) {
    let builder = new WasmModuleBuilder();
    builder.addFunction('dummy', kSig_i_v)
        .addBody([kExprI32Const, val])
        .exportAs('dummy');
    return builder.instantiate().exports.dummy;
  }
  let table = new WebAssembly.Table({element: "anyfunc", initial: 1});
  table.grow(5, getDummy(24));
  for (let i = 1; i <= 5; ++i) {
    assertEquals(24, table.get(i)());
  }
})();
                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/wasm/table64-callindirect.js                                       0000664 0000000 0000000 00000007300 14746647661 0023716 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-memory64

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

function exportTable64CallIndirect(builder, table, param_l, param_r, is_tail_call) {
  let sig = builder.addType(kSig_i_iii);
  builder.addFunction('table64_callindirect', kSig_i_i)
      .addBody([
        ...wasmI32Const(param_l),
        ...wasmI32Const(param_r),
        kExprLocalGet, 0,
        ...wasmI64Const(0),
        is_tail_call ? kExprReturnCallIndirect : kExprCallIndirect,
        sig, table.index
      ])
      .exportFunc();
}

let js_function = function(a, b, c) {
  return c ? a : b;
};

function test(is_tail_call) {
  const builder = new WasmModuleBuilder();

  let callee = builder.addImport('m', 'f', kSig_i_iii);
  let table = builder.addTable64(kWasmFuncRef, 10, 10);
  builder.addActiveElementSegment(table.index, wasmI64Const(0), [callee]);

  let left = -2;
  let right = 3;
  exportTable64CallIndirect(builder, table, left, right, is_tail_call);
  let instance = builder.instantiate({m: {f: js_function}});

  assertEquals(left, instance.exports.table64_callindirect(1));
  assertEquals(right, instance.exports.table64_callindirect(0));
}

(function TestTable64CallIndirect() {
  print(arguments.callee.name);
  test(false);
})();

(function TestTable64ReturnCallIndirect() {
  print(arguments.callee.name);
  test(true);
})();

function testOOB(is_tail_call, is_table_growable) {
  const builder = new WasmModuleBuilder();

  let callee = builder.addImport('m', 'f', kSig_i_iii);
  let table_size = 10
  let max_table_size = is_table_growable ? table_size + 1 : table_size;
  let table = builder.addTable64(kWasmFuncRef, table_size, max_table_size);
  builder.addActiveElementSegment(table.index, wasmI64Const(1), [callee]);

  let left = -2;
  let right = 3;
  let sig = builder.addType(kSig_i_iii);
  const kSig_i_il = makeSig([kWasmI32, kWasmI64], [kWasmI32]);
  builder.addFunction('table64_callindirect', kSig_i_il)
      .addBody([
        ...wasmI32Const(left),   // param 0 of js_function
        ...wasmI32Const(right),  // param 1 of js_function
        kExprLocalGet, 0,        // param 2 of js_function
        kExprLocalGet, 1,        // index into the table
        is_tail_call ? kExprReturnCallIndirect : kExprCallIndirect, sig,
        table.index
      ])
      .exportFunc();

  let instance = builder.instantiate({m: {f: js_function}});

  // Null entry.
  let table_index = 2n;
  assertTraps(
      kTrapFuncSigMismatch,
      () => instance.exports.table64_callindirect(1, table_index));
  table_index = BigInt(table_size - 1);
  assertTraps(
      kTrapFuncSigMismatch,
      () => instance.exports.table64_callindirect(1, table_index));
  // Table index is OOB.
  table_index = BigInt(table_size);
  assertTraps(
      kTrapTableOutOfBounds,
      () => instance.exports.table64_callindirect(1, table_index));
  table_index = -1n;
  assertTraps(
      kTrapTableOutOfBounds,
      () => instance.exports.table64_callindirect(1, table_index));
  table_index = 1n << 32n;
  assertTraps(
      kTrapTableOutOfBounds,
      () => instance.exports.table64_callindirect(1, table_index));
}

(function TestTable64CallIndirectOOBNonGrowable() {
  print(arguments.callee.name);
  testOOB(false, false);
})();

(function TestTable64CallIndirectOOBGrowable() {
  print(arguments.callee.name);
  testOOB(false, true);
})();

(function TestTable64ReturnCallIndirectOOBNonGrowable() {
  print(arguments.callee.name);
  testOOB(true, false);
})();

(function TestTable64ReturnCallIndirectOOBGrowable() {
  print(arguments.callee.name);
  testOOB(true, true);
})();
                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/wasm/table64-copy.js                                               0000664 0000000 0000000 00000017625 14746647661 0022246 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-memory64

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

function exportTable64Getter(builder, table, type) {
  const table64_get_sig = makeSig([kWasmI64], [type]);
  builder.addFunction('table64_get', table64_get_sig)
      .addBody([
        kExprLocalGet, 0,
        kExprTableGet, table.index])
      .exportFunc();
}

function exportTable64Copy(builder, table_dst, table_src) {
  const kSig_v_lll = makeSig([kWasmI64, kWasmI64, kWasmI64], []);
  builder.addFunction('table64_copy', kSig_v_lll)
      .addBody([
        kExprLocalGet, 0,
        kExprLocalGet, 1,
        kExprLocalGet, 2,
        kNumericPrefix, kExprTableCopy, table_dst.index, table_src.index
      ])
      .exportFunc();
}

function exportTable64FillExternRef(builder, table) {
    let kSig_v_lrl = makeSig([kWasmI64, kWasmExternRef, kWasmI64], []);
    builder.addFunction('table64_fill', kSig_v_lrl)
        .addBody([
          kExprLocalGet, 0,
          kExprLocalGet, 1,
          kExprLocalGet, 2,
          kNumericPrefix, kExprTableFill, table.index
        ])
        .exportFunc();
}

function exportTable64Size(builder, table) {
  builder.addFunction('table64_size', kSig_l_v)
  .addBody([kNumericPrefix, kExprTableSize, table.index])
  .exportFunc();
}

function checkExternRefTable(getter, size, start, count, value) {
  for (let i = 0; i < size; ++i) {
    if (i < start || i >= start + count) {
      assertEquals(null, getter(BigInt(i)))
    } else {
      assertEquals(value, getter(BigInt(i)));
    }
  }
}

(function TestTable64Copy() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const table_src =
      builder.addTable64(kWasmExternRef, 15, 20).exportAs('table_src');
  const table_dst =
      builder.addTable64(kWasmExternRef, 10).exportAs('table_dst');

  exportTable64Getter(builder, table_dst, kWasmExternRef);
  exportTable64Size(builder, table_dst);
  exportTable64Copy(builder, table_dst, table_src);
  exportTable64FillExternRef(builder, table_src)

  let exports = builder.instantiate().exports;

  let dummy_externref = {foo: 12, bar: 34};

  // Just in bounds.
  let start_dst = 3n;
  let start_src = 6n;
  let count = 7n;
  exports.table64_fill(start_src, dummy_externref, count);
  exports.table64_copy(start_dst, start_src, count);
  let size = exports.table64_size(builder, table_dst);
  checkExternRefTable(
      exports.table64_get, size, start_dst, count, dummy_externref);

  // start_dst is OOB.
  start_dst = 4n;
  assertTraps(
      kTrapTableOutOfBounds,
      () => exports.table64_copy(start_dst, start_src, count));
  start_dst = 1n << 32n;
  assertTraps(
      kTrapTableOutOfBounds,
      () => exports.table64_copy(start_dst, start_src, count));

  // start_src is OOB.
  start_dst = 1n;
  start_src = 9n;
  count = 7n;
  assertTraps(
      kTrapTableOutOfBounds,
      () => exports.table64_copy(start_dst, start_src, count));
  start_src = 1n << 32n;
  assertTraps(
      kTrapTableOutOfBounds,
      () => exports.table64_copy(start_dst, start_src, count));
  // count is OOB.
  start_dst = 3n;
  start_src = 6n;
  count = 1n << 32n;
  assertTraps(
      kTrapTableOutOfBounds,
      () => exports.table64_copy(start_dst, start_src, count));
})();

(function TestTypingForCopyBetween32And64Bit() {
  print(arguments.callee.name);
  for (let [src, dst, src_type, dst_type, size_type, expect_valid] of [
    // Copy from 32 to 64 bit with correct types.
    [32, 64, kWasmI32, kWasmI64, kWasmI32, true],
    // Copy from 64 to 32 bit with correct types.
    [64, 32, kWasmI64, kWasmI32, kWasmI32, true],
    // Copy from 32 to 64 bit with always one type wrong.
    [32, 64, kWasmI64, kWasmI64, kWasmI32, false],
    [32, 64, kWasmI32, kWasmI32, kWasmI32, false],
    [32, 64, kWasmI32, kWasmI64, kWasmI64, false],
    // Copy from 64 to 32 bit with always one type wrong.
    [64, 32, kWasmI32, kWasmI32, kWasmI32, false],
    [64, 32, kWasmI64, kWasmI64, kWasmI32, false],
    [64, 32, kWasmI64, kWasmI32, kWasmI64, false],
  ]) {
    let type_str = type => type == kWasmI32 ? 'i32' : 'i64';
    print(`- copy from ${src} to ${dst} using types src=${
        type_str(src_type)}, dst=${type_str(dst_type)}, size=${
        type_str(size_type)}`);
    let builder = new WasmModuleBuilder();
    const kTableSize = 10;
    let table64_index = builder.addTable64(kWasmExternRef, kTableSize)
                            .exportAs('table64')
                            .index;
    let table32_index =
        builder.addTable(kWasmExternRef, kTableSize).exportAs('table32').index;

    let src_index = src == 32 ? table32_index : table64_index;
    let dst_index = dst == 32 ? table32_index : table64_index;

    builder.addFunction('copy', makeSig([dst_type, src_type, size_type], []))
        .addBody([
          kExprLocalGet, 0,                                     // dst
          kExprLocalGet, 1,                                     // src
          kExprLocalGet, 2,                                     // size
          kNumericPrefix, kExprTableCopy, dst_index, src_index  // table.copy
        ])
        .exportFunc();

    if (expect_valid) {
      builder.toModule();
    } else {
      assertThrows(
          () => builder.toModule(), WebAssembly.CompileError,
          /expected type i(32|64), found local.get of type i(32|64)/);
    }
  }
})();

(function TestCopyBetweenTable32AndTable64() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const kTableSize = 10;
  let table64_index =
      builder.addTable64(kWasmExternRef, kTableSize).exportAs('table64').index;
  let table32_index =
      builder.addTable(kWasmExternRef, kTableSize).exportAs('table32').index;

  builder
      .addFunction('copy_32_to_64', makeSig([kWasmI64, kWasmI32, kWasmI32], []))
      .addBody([
        kExprLocalGet, 0,  // dst
        kExprLocalGet, 1,  // src
        kExprLocalGet, 2,  // size
        kNumericPrefix, kExprTableCopy, table64_index, table32_index
      ])
      .exportFunc();
  builder
      .addFunction('copy_64_to_32', makeSig([kWasmI32, kWasmI64, kWasmI32], []))
      .addBody([
        kExprLocalGet, 0,  // dst
        kExprLocalGet, 1,  // src
        kExprLocalGet, 2,  // size
        kNumericPrefix, kExprTableCopy, table32_index, table64_index
      ])
      .exportFunc();

  let instance = builder.instantiate();
  let {table32, table64, copy_32_to_64, copy_64_to_32} = instance.exports;

  let object = {foo: 12, bar: 34};

  // These helpers extract the table elements at [offset, offset+size)] into an
  // Array.
  let table32_elements = (offset, size) =>
      new Array(size).fill(0).map((e, i) => table32.get(i));
  let table64_elements = (offset, size) =>
      new Array(size).fill(0).map((e, i) => table64.get(i));

  // Init table32[2] to object.
  table32.set(2, object);
  // Copy table32[1..3] to table64[0..2].
  copy_32_to_64(0n, 1, 3);
  assertEquals([null, null, object, null], table32_elements(0, 4));
  assertEquals([null, object, null, null], table64_elements(0, 4));
  // Copy table64[1..2] to table32[0..1].
  copy_64_to_32(0, 1n, 2);
  assertEquals([object, null, object, null], table32_elements(0, 4));
  assertEquals([null, object, null, null], table64_elements(0, 4));

  // Just before OOB.
  copy_32_to_64(BigInt(kTableSize), 0, 0);
  copy_64_to_32(kTableSize, 0n, 0);
  copy_32_to_64(BigInt(kTableSize - 3), 0, 3);
  copy_64_to_32(kTableSize - 3, 0n, 3);
  assertEquals([null, object, null], table64_elements(kTableSize - 3, 3));
  // OOB.
  assertTraps(
      kTrapTableOutOfBounds, () => copy_32_to_64(BigInt(kTableSize + 1), 0, 0));
  assertTraps(
      kTrapTableOutOfBounds, () => copy_64_to_32(kTableSize + 1, 0n, 0));
  assertTraps(
      kTrapTableOutOfBounds, () => copy_32_to_64(BigInt(kTableSize - 2), 0, 3));
  assertTraps(
      kTrapTableOutOfBounds, () => copy_64_to_32(kTableSize - 2, 0n, 3));
})();
                                                                                                           node-23.7.0/deps/v8/test/mjsunit/wasm/table64-fill.js                                               0000664 0000000 0000000 00000005065 14746647661 0022215 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-memory64

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

function exportTable64Getter(builder, table, type) {
  const table64_get_sig = makeSig([kWasmI64], [type]);
  builder.addFunction('table64_get', table64_get_sig)
      .addBody([
        kExprLocalGet, 0,
        kExprTableGet, table.index])
      .exportFunc();
}

function exportTable64FillExternRef(builder, table) {
  let kSig_v_lrl = makeSig([kWasmI64, kWasmExternRef, kWasmI64], []);
  builder.addFunction('table64_fill', kSig_v_lrl)
      .addBody([
        kExprLocalGet, 0,
        kExprLocalGet, 1,
        kExprLocalGet, 2,
        kNumericPrefix, kExprTableFill, table.index
      ])
      .exportFunc();
}

function checkExternRefTable(getter, start, count, value) {
  for (let i = 0; i < count; ++i) {
    assertEquals(value, getter(start + BigInt(i)));
  }
}

(function TestTable64Fill() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const table = builder.addTable64(kWasmExternRef, 5, 20).exportAs('table');

  exportTable64Getter(builder, table, kWasmExternRef);
  exportTable64FillExternRef(builder, table)

  let exports = builder.instantiate().exports;

  let start = 1n;
  let value = {foo: 12, bar: 34};
  let count = 3n;

  exports.table64_fill(start, value, count);
  checkExternRefTable(exports.table64_get, start, count, value);
})();

(function TestTable64FillOOB() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const table = builder.addTable64(kWasmExternRef, 5, 20).exportAs('table');

  exportTable64Getter(builder, table, kWasmExternRef);
  exportTable64FillExternRef(builder, table)

  let exports = builder.instantiate().exports;

  let value = {foo: 12, bar: 34};
  // Just in bounds.
  let start = 1n;
  let count = 4n;
  exports.table64_fill(start, value, count);
  checkExternRefTable(exports.table64_get, start, count, value);
  // Start OOB.
  start = 5n;
  count = 1n;
  assertTraps(
      kTrapTableOutOfBounds, () => exports.table64_fill(start, value, count));
  start = 1n << 32n;
  assertTraps(
      kTrapTableOutOfBounds, () => exports.table64_fill(start, value, count));
  // Count OOB.
  start = 0n;
  count = 6n;
  assertTraps(
      kTrapTableOutOfBounds, () => exports.table64_fill(start, value, count));
  count = 1n << 32n;
  assertTraps(
      kTrapTableOutOfBounds, () => exports.table64_fill(start, value, count));
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/wasm/table64-get.js                                                0000664 0000000 0000000 00000011400 14746647661 0022034 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-memory64

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

function exportTable64Getter(builder, table, type) {
  const table64_get_sig = makeSig([kWasmI64], [type]);
  builder.addFunction('table64_get', table64_get_sig)
      .addBody(
        [kExprLocalGet, 0,
         kExprTableGet, table.index])
      .exportFunc();
}

(function TestTable64GetFuncRef() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const table = builder.addTable64(kWasmAnyFunc, 10).exportAs('table');
  const f1 = builder.addFunction('f', kSig_i_v).addBody([kExprI32Const, 11]);
  const offset = 3;
  builder.addActiveElementSegment(0, wasmI64Const(offset), [f1.index]);

  exportTable64Getter(builder, table, kWasmAnyFunc);

  let exports = builder.instantiate().exports;

  assertEquals(11, exports.table64_get(BigInt(offset))());
})();

(function TestTable64GetAnyRef() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const table = builder.addTable64(kWasmAnyRef, 10, 15).exportAs('table');
  const struct = builder.addStruct([makeField(kWasmI32, true)])
  const offset = 4;
  builder.addActiveElementSegment(
      0, wasmI64Const(offset),
      [[kExprI32Const, 23, kGCPrefix, kExprStructNew, struct]], kWasmAnyRef);

  builder.addFunction('getField', makeSig([kWasmAnyRef], [kWasmI32]))
      .addBody([
        kExprLocalGet, 0,
        kGCPrefix, kExprRefCast, struct,
        kGCPrefix, kExprStructGet, struct, 0
      ])
      .exportFunc();

  exportTable64Getter(builder, table, kWasmAnyRef);

  let exports = builder.instantiate().exports;

  assertEquals(23, exports.getField(exports.table64_get(BigInt(offset))));
})();

(function TestTable64GetExternRef() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const table = builder.addTable64(kWasmExternRef, 10).exportAs('table');

  exportTable64Getter(builder, table, kWasmExternRef);

  let exports = builder.instantiate().exports;

  assertEquals(null, exports.table64_get(8n));
})();

(function TestTable64GetWrongType() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const table = builder.addTable64(kWasmAnyFunc, 10).exportAs('table');
  const f1 = builder.addFunction('f', kSig_i_v).addBody([kExprI32Const, 11]);
  const offset = 3;
  builder.addActiveElementSegment(0, wasmI64Const(offset), [f1.index]);

  // Table64 expects kWasmI64 as the index to the table.
  const table32_get_sig = makeSig([kWasmI32], [kWasmAnyFunc]);
  builder.addFunction('table32_get', table32_get_sig)
      .addBody([kExprLocalGet, 0, kExprTableGet, table.index])
      .exportFunc();

  assertThrows(() => builder.toModule(), WebAssembly.CompileError);
})();

(function TestTable64GetFuncRefOOB() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const table_size = 5;
  const table = builder.addTable64(kWasmAnyFunc, table_size).exportAs('table');
  const f1 = builder.addFunction('f', kSig_i_v).addBody([kExprI32Const, 11]);
  const offset = 3;
  builder.addActiveElementSegment(0, wasmI64Const(offset), [f1.index]);

  exportTable64Getter(builder, table, kWasmAnyFunc);

  let exports = builder.instantiate().exports;

  assertEquals(11, exports.table64_get(BigInt(offset))());
  assertEquals(null, exports.table64_get(BigInt(table_size - 1)));
  assertTraps(kTrapTableOutOfBounds, () => exports.table64_get(BigInt(-1)));
  assertTraps(
      kTrapTableOutOfBounds, () => exports.table64_get(BigInt(table_size)));
  assertTraps(
      kTrapTableOutOfBounds,
      () => exports.table64_get(BigInt(table_size + 13)));
  assertTraps(kTrapTableOutOfBounds, () => exports.table64_get(1n << 32n));
  assertTraps(
      kTrapTableOutOfBounds, () => exports.table64_get(BigInt(offset) << 32n));
})();

(function TestTable64GetExternRefOOB() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const table_size = 12;
  const table = builder.addTable64(kWasmExternRef, table_size, table_size + 4)
                    .exportAs('table');

  exportTable64Getter(builder, table, kWasmExternRef);

  let exports = builder.instantiate().exports;

  assertEquals(null, exports.table64_get(BigInt(table_size - 1)));
  assertTraps(kTrapTableOutOfBounds, () => exports.table64_get(-1n));
  assertTraps(
      kTrapTableOutOfBounds, () => exports.table64_get(BigInt(table_size)));
  assertTraps(
      kTrapTableOutOfBounds, () => exports.table64_get(BigInt(table_size + 3)));
  assertTraps(
      kTrapTableOutOfBounds,
      () => exports.table64_get(BigInt(table_size + 23)));
  assertTraps(kTrapTableOutOfBounds, () => exports.table64_get(1n << 32n));
})();
                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/mjsunit/wasm/table64-grow.js                                               0000664 0000000 0000000 00000003017 14746647661 0022240 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-memory64

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

function exportTable64Grow(builder, table) {
let kSig_l_rl = makeSig([kWasmExternRef, kWasmI64], [kWasmI64]);
  builder.addFunction('table64_grow', kSig_l_rl)
      .addBody([
        kExprLocalGet, 0,
        kExprLocalGet, 1,
        kNumericPrefix, kExprTableGrow, table.index])
      .exportFunc();
}

function exportTable64Size(builder, table) {
    builder.addFunction('table64_size', kSig_l_v)
    .addBody([kNumericPrefix, kExprTableSize, table.index])
    .exportFunc();
}

(function TestTable64GrowExternRef() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const initial_size = 7;
  const max_size = 20;
  const table = builder.addTable64(kWasmExternRef, initial_size, max_size)
                    .exportAs('table');

  exportTable64Grow(builder, table);
  exportTable64Size(builder, table);
  let exports = builder.instantiate().exports;

  assertEquals(BigInt(initial_size), exports.table64_size());
  assertEquals(BigInt(initial_size), exports.table64_grow('externref', 3n));
  assertEquals(BigInt(initial_size) + 3n, exports.table64_size());
  const oob_size = 11n;
  assertEquals(-1n, exports.table64_grow('too big', oob_size));
  const oob64_size = 1n << 32n;
  assertEquals(-1n, exports.table64_grow('64 bit', oob64_size));
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/wasm/table64-import.js                                             0000664 0000000 0000000 00000004313 14746647661 0022574 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-memory64

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function TestImportTable64AsTable64() {
  print(arguments.callee.name);
  const builder1 = new WasmModuleBuilder();
  builder1.addTable64(kWasmAnyFunc, 10, 10).exportAs('table64');
  const {table64} = builder1.instantiate().exports;

  let builder2 = new WasmModuleBuilder();
  builder2.addImportedTable(
      'imports', 'table', 10, 10, kWasmAnyFunc, /* table64 */ true);
  builder2.instantiate({imports: {table: table64}});
})();

(function TestImportTable32AsTable32() {
  print(arguments.callee.name);
  const builder1 = new WasmModuleBuilder();
  builder1.addTable(kWasmAnyFunc, 10, 10).exportAs('table32');
  const {table32} = builder1.instantiate().exports;

  let builder2 = new WasmModuleBuilder();
  builder2.addImportedTable(
      'imports', 'table', 10, 10, kWasmAnyFunc, /* table64 */ false);
  builder2.instantiate({imports: {table: table32}});
})();

(function TestImportTable64AsTable32() {
  print(arguments.callee.name);
  const builder1 = new WasmModuleBuilder();
  builder1.addTable64(kWasmAnyFunc, 10, 10).exportAs('table64');
  const {table64} = builder1.instantiate().exports;

  let builder2 = new WasmModuleBuilder();
  builder2.addImportedTable(
      'imports', 'table', 10, 10, kWasmAnyFunc, /* table64 */ false);
  assertThrows(
      () => builder2.instantiate({imports: {table: table64}}),
      WebAssembly.LinkError,
      'WebAssembly.Instance(): cannot import table64 as table32');
})();

(function TestImportTable32AsTable64() {
  print(arguments.callee.name);
  const builder1 = new WasmModuleBuilder();
  builder1.addTable(kWasmAnyFunc, 10, 10).exportAs('table32');
  const {table32} = builder1.instantiate().exports;

  let builder2 = new WasmModuleBuilder();
  builder2.addImportedTable(
      'imports', 'table', 10, 10, kWasmAnyFunc, /* table64 */ true);
  assertThrows(
      () => builder2.instantiate({imports: {table: table32}}),
      WebAssembly.LinkError,
      'WebAssembly.Instance(): cannot import table32 as table64');
})();
                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/wasm/table64-init.js                                               0000664 0000000 0000000 00000007065 14746647661 0022234 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-memory64

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

function exportTable64Getter(builder, table, type) {
  const table64_get_sig = makeSig([kWasmI64], [type]);
  builder.addFunction('table64_get', table64_get_sig)
      .addBody([
        kExprLocalGet, 0,
        kExprTableGet, table.index])
      .exportFunc();
}

function exportTable64Size(builder, table) {
  builder.addFunction('table64_size', kSig_l_v)
      .addBody([kNumericPrefix, kExprTableSize, table.index])
      .exportFunc();
}

function exportTable64Init(builder, table, passive) {
  builder.addFunction('table64_init', kSig_v_lii)
      .addBody([
        kExprLocalGet, 0,
        kExprLocalGet, 1,
        kExprLocalGet, 2,
        kNumericPrefix, kExprTableInit, passive, table.index
      ])
      .exportFunc();
}

function addPassiveSegmentWithExportedFuncs(builder) {
  let sig = builder.addType(kSig_i_v, kNoSuperType, false);
  let f1 =
      builder.addFunction('f1', sig).addBody([kExprI32Const, 11]).exportFunc();
  let f2 =
      builder.addFunction('f2', sig).addBody([kExprI32Const, 22]).exportFunc();
  let f3 =
      builder.addFunction('f3', sig).addBody([kExprI32Const, 33]).exportFunc();
  let passive = builder.addPassiveElementSegment(
      [
        [kExprRefFunc, f1.index], [kExprRefFunc, f2.index],
        [kExprRefFunc, f3.index]
      ],
      wasmRefType(0));
  return passive;
}

(function TestTable64Init() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  let passive = addPassiveSegmentWithExportedFuncs(builder);
  const table = builder.addTable64(kWasmAnyFunc, 5, 5).exportAs('table');

  exportTable64Init(builder, table, passive);
  exportTable64Getter(builder, table, kWasmAnyFunc);
  exportTable64Size(builder, table);

  let exports = builder.instantiate().exports;

  const dst = 1n;
  const src = 0;
  const size = 3;
  exports.table64_init(dst, src, size);

  assertEquals(5n, exports.table64_size());
  assertEquals(null, exports.table64_get(0n));
  assertSame(exports.f1, exports.table64_get(dst));
  assertEquals(11, exports.table64_get(dst)());
  assertSame(exports.f2, exports.table64_get(dst + 1n));
  assertEquals(22, exports.table64_get(dst + 1n)());
  assertSame(exports.f3, exports.table64_get(dst + 2n));
  assertEquals(33, exports.table64_get(dst + 2n)());
  assertEquals(null, exports.table64_get(4n));
})();

(function TestTable64InitOOB() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  let passive = addPassiveSegmentWithExportedFuncs(builder);
  const table = builder.addTable64(kWasmAnyFunc, 5, 5).exportAs('table');

  exportTable64Init(builder, table, passive);
  exportTable64Getter(builder, table, kWasmAnyFunc);
  exportTable64Size(builder, table);

  let exports = builder.instantiate().exports;

  const src = 0;
  const size = 3;
  // Just in bouds.
  let dst = 2n;
  exports.table64_init(dst, src, size);
  assertEquals(5n, exports.table64_size());
  assertSame(null, exports.table64_get(0n));
  assertSame(null, exports.table64_get(1n));
  assertSame(exports.f1, exports.table64_get(2n));
  assertSame(exports.f2, exports.table64_get(3n));
  assertSame(exports.f3, exports.table64_get(4n));
  // OOB.
  dst = 3n;
  assertTraps(
      kTrapTableOutOfBounds, () => exports.table64_init(dst, src, size));
  dst = 1n << 32n;
  assertTraps(
      kTrapTableOutOfBounds, () => exports.table64_init(dst, src, size));
})();
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/mjsunit/wasm/table64-limits.js                                             0000664 0000000 0000000 00000004720 14746647661 0022565 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-memory64

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

const max_size = 10000000
const oob_size = max_size + 1;

(function TestTable64OOBInitialSize() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  builder.addTable64(kWasmAnyFunc, oob_size).exportAs('table').index;

  const err_msg = `WebAssembly.Module(): initial table size \
(${oob_size} elements) is larger than implementation limit \
(10000000 elements) @+13`;
  assertThrows(
      () => builder.instantiate().exports, WebAssembly.CompileError, err_msg);
})();

(function TestTable64OOBMaxSize() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  // We should not throw an error if the declared maximum size is oob.
  builder.addTable64(kWasmAnyFunc, 1, oob_size).exportAs('table').index;
  builder.instantiate().exports;
})();

(function TestJSTable64OOBInitialSize() {
  print(arguments.callee.name);
  assertThrows(
      () => new WebAssembly.Table(
          {element: 'anyfunc', initial: oob_size, index: 'i64'}),
      RangeError, /above the upper bound/);
})();

(function TestJSTable64OOBMaxSize() {
  print(arguments.callee.name);
  new WebAssembly.Table(
          {element: 'anyfunc', initial:1, maximum: oob_size, index: 'i64'});
})();

(function TestJSTable64OOBGrowSize() {
  print(arguments.callee.name);
  let table = new WebAssembly.Table(
      {initial: 1, maximum: oob_size + 10, element: 'anyfunc', index: 'i64'});
  assertThrows(
      () => table.grow(oob_size - 1), RangeError, /failed to grow table/);
})();

function exportTable64Grow(builder, table) {
  let kSig_l_rl = makeSig([kWasmExternRef, kWasmI64], [kWasmI64]);
    builder.addFunction('table64_grow', kSig_l_rl)
        .addBody([
          kExprLocalGet, 0,
          kExprLocalGet, 1,
          kNumericPrefix, kExprTableGrow, table.index])
        .exportFunc();
}

(function TestTable64OOBGrowSize() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const initial_size = 1;
  const table = builder.addTable64(kWasmExternRef, initial_size, oob_size + 10)
                    .exportAs('table');

  exportTable64Grow(builder, table);
  let exports = builder.instantiate().exports;

  assertEquals(-1n, exports.table64_grow('64 bit', BigInt(oob_size - 1)));
})();
                                                node-23.7.0/deps/v8/test/mjsunit/wasm/table64-set.js                                                0000664 0000000 0000000 00000010727 14746647661 0022063 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-memory64

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

function exportTable64Getter(builder, table, type) {
  const table64_get_sig = makeSig([kWasmI64], [type]);
  builder.addFunction('table64_get', table64_get_sig)
      .addBody(
        [kExprLocalGet, 0,
         kExprTableGet, table.index])
      .exportFunc();
}

function exportTable64Setter(builder, table, type) {
  const table64_set_sig = makeSig([kWasmI64, type], []);
  builder.addFunction('table64_set', table64_set_sig)
      .addBody(
        [kExprLocalGet, 0,
         kExprLocalGet, 1,
         kExprTableSet, table.index])
      .exportFunc();
}

(function TestTable64SetFuncRef() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const table = builder.addTable64(kWasmAnyFunc, 10).exportAs('table');
  builder.addFunction('f', kSig_i_v).addBody([kExprI32Const, 11]).exportFunc();

  exportTable64Getter(builder, table, kWasmAnyFunc);
  exportTable64Setter(builder, table, kWasmAnyFunc);

  let exports = builder.instantiate().exports;

  const offset = 5n;
  assertEquals(null, exports.table64_get(offset));
  exports.table64_set(offset, exports.f);
  assertSame(exports.f, exports.table64_get(offset));
})();

(function TestTable64SetExternRef() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const table = builder.addTable64(kWasmExternRef, 10, 20).exportAs('table');

  exportTable64Getter(builder, table, kWasmExternRef);
  exportTable64Setter(builder, table, kWasmExternRef);

  let exports = builder.instantiate().exports;

  const offset = 1n;
  const dummy_ref = {foo: 1, bar: 3};
  assertEquals(null, exports.table64_get(offset));
  exports.table64_set(offset, dummy_ref);
  assertSame(dummy_ref, exports.table64_get(offset));
})();

(function TestTable64SetFuncRefWrongType() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const table = builder.addTable64(kWasmAnyFunc, 10).exportAs('table');
  builder.addFunction('f', kSig_i_v).addBody([kExprI32Const, 11]).exportFunc();

  // Table64 expects kWasmI64 as the index to the table.
  const table64_set_sig = makeSig([kWasmI32, kWasmAnyFunc], []);
  builder.addFunction('table64_set', table64_set_sig)
      .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprTableSet, table.index])
      .exportFunc();

  assertThrows(() => builder.toModule(), WebAssembly.CompileError);
})();

(function TestTable64SetFuncRefOOB() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const table_size = 4;
  const table = builder.addTable64(kWasmAnyFunc, table_size).exportAs('table');
  builder.addFunction('f', kSig_i_v).addBody([kExprI32Const, 11]).exportFunc();

  exportTable64Getter(builder, table, kWasmAnyFunc);
  exportTable64Setter(builder, table, kWasmAnyFunc);

  let exports = builder.instantiate().exports;

  exports.table64_set(BigInt(table_size - 1), exports.f);
  assertSame(exports.f, exports.table64_get(BigInt(table_size - 1)));
  assertTraps(
      kTrapTableOutOfBounds,
      () => exports.table64_set(BigInt(table_size), exports.f));
  assertTraps(
      kTrapTableOutOfBounds,
      () => exports.table64_set(BigInt(table_size + 1), exports.f));
  assertTraps(kTrapTableOutOfBounds, () => exports.table64_set(-1n, exports.f));
  assertTraps(
      kTrapTableOutOfBounds, () => exports.table64_set(1n << 32n, exports.f));
})();

(function TestTable64SetExternRefOOB() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const table_size = 10;
  const table =
      builder.addTable64(kWasmExternRef, table_size, 20).exportAs('table');

  exportTable64Getter(builder, table, kWasmExternRef);
  exportTable64Setter(builder, table, kWasmExternRef);

  let exports = builder.instantiate().exports;

  const dummy_ref = {foo: 1, bar: 3};

  exports.table64_set(BigInt(table_size - 1), dummy_ref);
  assertSame(dummy_ref, exports.table64_get(BigInt(table_size - 1)));
  assertTraps(
      kTrapTableOutOfBounds,
      () => exports.table64_set(BigInt(table_size), dummy_ref));
  assertTraps(
      kTrapTableOutOfBounds,
      () => exports.table64_set(BigInt(table_size + 1), dummy_ref));
  assertTraps(kTrapTableOutOfBounds, () => exports.table64_set(-1n, dummy_ref));
  assertTraps(
      kTrapTableOutOfBounds, () => exports.table64_set(1n << 32n, dummy_ref));
})();
                                         node-23.7.0/deps/v8/test/mjsunit/wasm/table64-size.js                                               0000664 0000000 0000000 00000001274 14746647661 0022237 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --experimental-wasm-memory64

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function TestTable64Size() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  const table_index =
      builder.addTable64(kWasmAnyFunc, 15, 30).exportAs('table').index;
  builder.addFunction('table64_size', kSig_l_v)
      .addBody([kNumericPrefix, kExprTableSize, table_index])
      .exportFunc();

  let exports = builder.instantiate().exports;

  assertEquals(15n, exports.table64_size());
})();
                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/test/mjsunit/wasm/tagged-stack-parameters.js                                    0000664 0000000 0000000 00000003502 14746647661 0024521 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --expose-gc

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

var instance = (function () {
  let builder = new WasmModuleBuilder();

  let struct_index = builder.addStruct([makeField(kWasmI32, true)]);
  let struct_ref = wasmRefType(struct_index);

  let gc_function_index =
    builder.addImport("imports", "gc_func", kSig_v_v);

  let struct_consumer =
    builder.addFunction("struct_consumer", makeSig([
        struct_ref, struct_ref], [kWasmI32]))
      .addBody([
        kExprLocalGet, 0, kGCPrefix, kExprStructGet, struct_index, 0,
        kExprLocalGet, 1, kGCPrefix, kExprStructGet, struct_index, 0,
        kExprI32Add]);

  let many_params = builder.addFunction("many_params", makeSig([
      kWasmI32, kWasmI32, kWasmI32, kWasmI32, kWasmI32, kWasmI32, kWasmI32,
      struct_ref, struct_ref], [kWasmI32]))
    .addBody([
      kExprCallFunction, gc_function_index,
      kExprLocalGet, 7, kExprLocalGet, 8,
      kExprCallFunction, struct_consumer.index]);

  builder.addFunction("main", kSig_i_v)
    .addBody([
      // Seven i32 parameters that look like tagged pointers.
      ...wasmI32Const(1), ...wasmI32Const(3), ...wasmI32Const(5),
      ...wasmI32Const(7), ...wasmI32Const(9), ...wasmI32Const(11),
      ...wasmI32Const(13),
      // Two structs (i.e. actual tagged pointers).
      ...wasmI32Const(20),
      kGCPrefix, kExprStructNew, struct_index,
      ...wasmI32Const(22),
      kGCPrefix, kExprStructNew, struct_index,
      kExprCallFunction, many_params.index,
    ])
    .exportFunc();

  return builder.instantiate({imports: {
    gc_func: () => gc(),
  }});
})();

assertEquals(42, instance.exports.main());
                                                                                                                                                                                              node-23.7.0/deps/v8/test/mjsunit/wasm/test-partial-serialization.js                                 0000664 0000000 0000000 00000003204 14746647661 0025305 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --liftoff --no-wasm-tier-up --expose-gc
// Flags: --no-wasm-dynamic-tiering --no-wasm-lazy-compilation
// Compile functions 0 and 2 with Turbofan, the rest with Liftoff:
// Flags: --wasm-tier-mask-for-testing=5

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

const num_functions = 5;

function create_builder() {
  const builder = new WasmModuleBuilder();
  for (let i = 0; i < num_functions; ++i) {
    builder.addFunction('f' + i, kSig_i_v)
        .addBody(wasmI32Const(i))
        .exportFunc();
  }
  return builder;
}

function check(instance) {
  for (let i = 0; i < num_functions; ++i) {
    const expect_turbofan = i == 0 || i == 2;
    assertEquals(
        expect_turbofan, %IsTurboFanFunction(instance.exports['f' + i]),
        'function ' + i);
  }
}

const wire_bytes = create_builder().toBuffer();

function testTierTestingFlag() {
  print(arguments.callee.name);
  const module = new WebAssembly.Module(wire_bytes);
  const buff = %SerializeWasmModule(module);
  const instance = new WebAssembly.Instance(module);
  check(instance);
  return buff;
};

const serialized_module = testTierTestingFlag();
// Do some GCs to make sure the first module got collected and removed from the
// module cache.
gc();
gc();
gc();

(function testSerializedModule() {
  print(arguments.callee.name);
  const module = %DeserializeWasmModule(serialized_module, wire_bytes);

  const instance = new WebAssembly.Instance(module);
  check(instance);
})();
                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/wasm/test-serialization-with-lazy-compilation.js                   0000664 0000000 0000000 00000002666 14746647661 0030130 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// The test needs --no-liftoff because we can't serialize and deserialize
// Liftoff code.
// Flags: --allow-natives-syntax --wasm-lazy-compilation --expose-gc
// Flags: --no-liftoff --no-wasm-native-module-cache-enabled

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

const num_functions = 3;

function create_builder() {
  const builder = new WasmModuleBuilder();
  builder.addImport("foo", "bar", kSig_i_v);
  for (let i = 0; i < num_functions; ++i) {
    builder.addFunction('f' + i, kSig_i_v)
        .addBody(wasmI32Const(i))
        .exportFunc();
  }
  return builder;
}

const wire_bytes = create_builder().toBuffer();

function serializeModule() {
  const module = new WebAssembly.Module(wire_bytes);
  // Run one function so that serialization happens.
  let instance = new WebAssembly.Instance(module, {foo: {bar: () => 1}});
  instance.exports.f2();
  const buff = %SerializeWasmModule(module);
  return buff;
};

const serialized_module = serializeModule();

(function testSerializedModule() {
  print(arguments.callee.name);
  const module = %DeserializeWasmModule(serialized_module, wire_bytes);

  const instance = new WebAssembly.Instance(module, {foo: {bar: () => 1}});
  assertEquals(0, instance.exports.f0());
  assertEquals(1, instance.exports.f1());
})();
                                                                          node-23.7.0/deps/v8/test/mjsunit/wasm/test-wasm-module-builder.js                                   0000664 0000000 0000000 00000014706 14746647661 0024665 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

var debug = true;

function instantiate(buffer, ffi) {
  return new WebAssembly.Instance(new WebAssembly.Module(buffer), ffi);
}

(function BasicTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addMemory(1, 2);
  builder.addFunction('foo', kSig_i_v)
      .addBody([kExprI32Const, 11])
      .exportAs('blarg');

  var buffer = builder.toBuffer(debug);
  var instance = instantiate(buffer);
  assertEquals(11, instance.exports.blarg());
})();

(function ImportTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  var index = builder.addImport('', 'print', makeSig_v_x(kWasmI32));
  builder.addFunction('foo', kSig_v_v)
      .addBody([kExprI32Const, 13, kExprCallFunction, index])
      .exportAs('main');

  var buffer = builder.toBuffer(debug);
  var instance = instantiate(buffer, {'': {print: print}});
  print('should print 13! ');
  instance.exports.main();
})();

(function LocalsTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction(undefined, kSig_i_i)
      .addLocals(kWasmI32, 1)
      .addBody([kExprLocalGet, 0, kExprLocalSet, 1, kExprLocalGet, 1])
      .exportAs('main');

  var buffer = builder.toBuffer(debug);
  var instance = instantiate(buffer);
  assertEquals(19, instance.exports.main(19));
  assertEquals(27777, instance.exports.main(27777));
})();

(function LocalsTest2() {
  print(arguments.callee.name);
  // TODO(titzer): i64 only works on 64-bit platforms.
  var types = [
    {count: 1, type: kWasmI32},
    {count: 1, type: kWasmF32},
    {count: 1, type: kWasmF64},
  ];

  for (p of types) {
    let builder = new WasmModuleBuilder();
    builder.addFunction(undefined, makeSig_r_x(p.type, p.type))
        .addLocals(p.type, p.count)
        .addBody([kExprLocalGet, 0, kExprLocalSet, 1, kExprLocalGet, 1])
        .exportAs('main');

    var buffer = builder.toBuffer(debug);
    var instance = instantiate(buffer);
    assertEquals(19, instance.exports.main(19));
    assertEquals(27777, instance.exports.main(27777));
  }
})();

(function CallTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction('add', kSig_i_ii).addBody([
    kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add
  ]);
  builder.addFunction('main', kSig_i_ii)
      .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprCallFunction, 0])
      .exportAs('main');

  var instance = builder.instantiate();
  assertEquals(44, instance.exports.main(11, 33));
  assertEquals(7777, instance.exports.main(2222, 5555));
})();

(function IndirectCallTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction('add', kSig_i_ii).addBody([
    kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add
  ]);
  builder.addFunction('main', kSig_i_iii)
      .addBody([
        kExprLocalGet, 1, kExprLocalGet, 2, kExprLocalGet, 0, kExprCallIndirect,
        0, kTableZero
      ])
      .exportAs('main');
  builder.appendToTable([0]);

  var instance = builder.instantiate();
  assertEquals(44, instance.exports.main(0, 11, 33));
  assertEquals(7777, instance.exports.main(0, 2222, 5555));
  assertThrows(() => instance.exports.main(1, 1, 1));
})();

(function DataSegmentTest() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addMemory(1, 1);
  builder.addFunction('load', kSig_i_i)
      .addBody([kExprLocalGet, 0, kExprI32LoadMem, 0, 0])
      .exportAs('load');
  builder.addActiveDataSegment(0, [kExprI32Const, 0], [9, 9, 9, 9]);

  var buffer = builder.toBuffer(debug);
  var instance = instantiate(buffer);
  assertEquals(151587081, instance.exports.load(0));
})();

(function BasicTestWithUint8Array() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addMemory(1, 2);
  builder.addFunction('foo', kSig_i_v)
      .addBody([kExprI32Const, 17])
      .exportAs('blarg');

  var buffer = builder.toBuffer(debug);
  var array = new Uint8Array(buffer);
  var instance = instantiate(array);
  assertEquals(17, instance.exports.blarg());

  var kPad = 5;
  var buffer2 = new ArrayBuffer(kPad + buffer.byteLength + kPad);
  var whole = new Uint8Array(buffer2);
  for (var i = 0; i < whole.byteLength; i++) {
    whole[i] = 0xff;
  }
  var array2 = new Uint8Array(buffer2, kPad, buffer.byteLength);
  for (var i = 0; i < array2.byteLength; i++) {
    array2[i] = array[i];
  }
  var instance = instantiate(array2);
  assertEquals(17, instance.exports.blarg());
})();

(function ImportTestTwoLevel() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  var index = builder.addImport('mod', 'print', makeSig_v_x(kWasmI32));
  builder.addFunction('foo', kSig_v_v)
      .addBody([kExprI32Const, 19, kExprCallFunction, index])
      .exportAs('main');

  var buffer = builder.toBuffer(debug);
  var instance = instantiate(buffer, {mod: {print: print}});
  print('should print 19! ');
  instance.exports.main();
})();

(function TestI32Const() {
  print(arguments.callee.name);
  let ints = [
    // A few negative number of different length.
    -3 << 28, -20000, -400, -200, -100, -50, -10, -1,
    // And a few positive number of different length.
    0, 1, 2, 20, 120, 130, 260, 500, 5000000, 3 << 28
  ];
  for (let i of ints) {
    let builder = new WasmModuleBuilder();
    builder.addFunction('main', kSig_i_v)
        .addBody([...wasmI32Const(i)])
        .exportAs('main');
    let instance = builder.instantiate();
    assertEquals(i, instance.exports.main());
  }
})();

(function TestBigTypeIndices() {
  print(arguments.callee.name);
  // These are all positive type indices (e.g. kI31RefCode and not kWasmI31Ref)
  // and should be treated as such.
  let indices = [kI31RefCode, kStructRefCode, 200, 400];
  let kMaxIndex = 400;
  let builder = new WasmModuleBuilder();
  for (let i = 0; i <= kMaxIndex; i++) {
    builder.addType(kSig_i_i);
    builder.addFunction(undefined, i)
           .addBody([kExprLocalGet, 0]);
    builder.addGlobal(wasmRefType(i), false, false,
                      [kExprRefFunc, ...wasmSignedLeb(i)]);
  }
  for (let i of indices) {
    builder.addFunction('f_' + i, makeSig([], [wasmRefType(i)]))
      .addBody([kExprRefFunc, ...wasmSignedLeb(i, 5)])
      .exportFunc();
  }
  builder.instantiate();
})();
                                                          node-23.7.0/deps/v8/test/mjsunit/wasm/tier-up-testing-flag.js                                       0000664 0000000 0000000 00000002404 14746647661 0023771 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --allow-natives-syntax --liftoff --no-wasm-tier-up
// Flags: --no-wasm-lazy-compilation
// Compile functions 0 and 2 with Turbofan, the rest with Liftoff:
// Flags: --wasm-tier-mask-for-testing=5

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

const num_functions = 5;

function create_builder() {
  const builder = new WasmModuleBuilder();
  for (let i = 0; i < num_functions; ++i) {
    builder.addFunction('f' + i, kSig_i_v)
        .addBody(wasmI32Const(i))
        .exportFunc();
  }
  return builder;
}

function check(instance) {
  for (let i = 0; i < num_functions; ++i) {
    const expect_liftoff = i != 0 && i != 2;
    assertEquals(
        expect_liftoff, %IsLiftoffFunction(instance.exports['f' + i]),
        'function ' + i);
  }
}

(function testTierTestingFlag() {
  print(arguments.callee.name);
  const instance = create_builder().instantiate();
  check(instance);
})();


async function testTierTestingFlag() {
  print(arguments.callee.name);
  const instance = await create_builder().asyncInstantiate();
  check(instance);
}

assertPromiseResult(testTierTestingFlag());
                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/mjsunit/wasm/torque-wrapper.js                                             0000664 0000000 0000000 00000023664 14746647661 0023032 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-gc
//
d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

// This test randomly generates WebAssembly signatures, creates WebAssembly
// functions with the generated signature which randomly maps parameters to
// returns, and then calls the WebAssembly function from JavaScript with some
// inputs and checks the return values. `RunTest` is the core function, which
// runs the test case for a specific signature and value mapping. `RunTest can
// be used well for debugging a specific signature.
// `GenerateAndRunTest` additionally generates the inputs for `RunTest`, which
// is good for fuzzing the js-to-wasm wrappers.

// Some documentation if the test fails in the CQ.
console.log("This test is a fuzzer, it tests the generic js-to-wasm wrapper");
console.log("with random signatures. If this test fails, then it may not fail");
console.log("for the CL that actually introduced the issue, but for a");
console.log("later CL in the CQ. You may want to use flako to identify that");
console.log("actual culprit.");

const debug = false;

let kSig_r_i = makeSig([kWasmI32], [kWasmExternRef]);
const kPossibleTypes = [kWasmI32, kWasmI64, kWasmF32, kWasmF64, kWasmExternRef];

function getRandomInt(max) {
  return Math.floor(Math.random() * max);
}

function TypeString(type) {
  switch (type) {
    case kWasmI32:
      return 'kWasmI32';
    case kWasmI64:
      return 'kWasmI64';
    case kWasmF32:
      return 'kWasmF32';
    case kWasmF64:
      return 'kWasmF64';
    case kWasmExternRef:
      return 'kWasmExternRef';
  }
}

function ConvertFunctionName(to, from) {
  return TypeString(from) + 'To' + TypeString(to);
}

// The ConversionFunction mimics the value conversion done within the wasm
// function, in addition to the `ToPrimitive` conversion done in the js-to-wasm
// wrapper.
function ConversionFunction(to, from, val) {
  if (to == from) {
    // If {to} and {from} are the same type, then we only have to do the
    // conversion done in the js-to-wasm wrapper.
    if (to == kWasmI64) return BigInt.asIntN(64, val);
    if (to == kWasmExternRef) return val;

    // In all other cases convert {val} into a Number so that the `valueOf`
    // function of an object gets called.
    return Number(val);
  }
  if (from == kWasmExternRef) {
    if (val == null) {
      val = 0;
    } else {
      val = val.value;
    }
  }
  if (from == kWasmI64) {
    // Convert BigInt to BigInt64.
    val = BigInt.asIntN(64, val);
  }
  switch (to) {
    case kWasmI32:
      if (from == kWasmI64) return Number(BigInt.asIntN(32, val));
      // Imitate the saturating conversions in WebAssembly.
      if (val > 0x7fff_ffff) return 0x7fff_ffff;
      if (val < -0x8000_0000) return -0x8000_0000;
      return val | 0;
    case kWasmI64:
      // Imitate the saturating conversions in WebAssembly.
      // Compare with 0x8000..., because 0x7fff... is not representable as
      // float64.
      if (val >= 0x8000_0000_0000_0000) return 0x7fff_ffff_ffff_ffffn;
      if (val < -0x8000_0000_0000_0000) return -0x8000_0000_0000_0000n;
      return BigInt(Math.trunc(val));
    case kWasmF32:
      return Math.fround(Number(val));
    case kWasmF64:
      return Number(val);
    case kWasmExternRef:
      return itoo(ConversionFunction(kWasmI32, from, val));
  }
}

function ConvertOpcode(to, from, itooIndex, otoiIndex) {
  if (from == kWasmExternRef) {
    if (to == kWasmExternRef) {
      return [kExprNop];
    }
    return [
      kExprCallFunction, otoiIndex,
      ...ConvertOpcode(to, kWasmI32, itooIndex, otoiIndex)
    ];
  }
  switch (to) {
    case kWasmI32:
      switch (from) {
        case kWasmI32:
          return [kExprNop];
        case kWasmI64:
          return [kExprI32ConvertI64];
        case kWasmF32:
          return [kNumericPrefix, kExprI32SConvertSatF32];
        case kWasmF64:
          return [kNumericPrefix, kExprI32SConvertSatF64];
      }
    case kWasmI64:
      switch (from) {
        case kWasmI32:
          return [kExprI64SConvertI32];
        case kWasmI64:
          return [kExprNop];
        case kWasmF32:
          return [kNumericPrefix, kExprI64SConvertSatF32];
        case kWasmF64:
          return [kNumericPrefix, kExprI64SConvertSatF64];
      }
    case kWasmF32:
      switch (from) {
        case kWasmI32:
          return [kExprF32SConvertI32];
        case kWasmI64:
          return [kExprF32SConvertI64];
        case kWasmF32:
          return [kExprNop];
        case kWasmF64:
          return [kExprF32ConvertF64];
      }
    case kWasmF64:
      switch (from) {
        case kWasmI32:
          return [kExprF64SConvertI32];
        case kWasmI64:
          return [kExprF64SConvertI64];
        case kWasmF32:
          return [kExprF64ConvertF32];
        case kWasmF64:
          return [kExprNop];
      }
    case kWasmExternRef:
      return [
        ...ConvertOpcode(kWasmI32, from, itooIndex, otoiIndex),
        kExprCallFunction, itooIndex
      ];
  }
}

function itoo(val) {
  return {value: val};
}

function otoi(val) {
  return val.value;
}

// A set of interesting values that will be used as parameters.
let interestingParams = {};
interestingParams[kWasmI32] = [
  -0x8000_0000, -1500000000, -0x4000_0000, -0x3fff_ffff, -1, 0, 1, 2,
  0x3fff_ffff, 0x4000_0000, 1500000000, 0x7fff_ffff, {valueOf: () => 15}, {
    toString: () => {
      gc();
      return '17';
    }
  }
];

interestingParams[kWasmI64] = [
  -0xffffffffffffffffn,
  -0x8000_0000_0000_0000n,
  -0x7fff_ffff_ffff_ffffn,
  -0xffff_ffffn,
  -0x8000_0000n,
  -1500000000n,
  -0x4000_0000n,
  -0x3fff_ffffn,
  -1n,
  0n,
  1n,
  2n,
  0x3fff_ffffn,
  0x4000_0000n,
  1500000000n,
  0x7fff_ffffn,
  0x8000_0000n,
  0xffff_ffffn,
  0x7fff_ffff_ffff_ffffn,
  0x8000_0000_0000_0000n,
  0xffff_ffff_ffff_ffffn,
  {valueOf: () => 15n},
  {
    toString: () => {
      gc();
      return '17';
    }
  }
];

interestingParams[kWasmF32] = [
  -Infinity,
  -(2 ** 65),
  -(2 ** 64),
  -(2 ** 63),
  -(2 ** 62),
  -(2 ** 29),
  -(2 ** 33),
  -(2 ** 32),
  -(2 ** 31),
  -(2 ** 30),
  -(2 ** 29),
  -1.5,
  -1,
  0,
  -0,
  1,
  1.5,
  2,
  2 ** 29,
  2 ** 30,
  2 ** 31,
  2 ** 32,
  2 ** 33,
  2 ** 62,
  2 ** 63,
  2 ** 64,
  2 ** 65,
  {valueOf: () => 16},
  {
    toString: () => {
      gc();
      return '18';
    }
  },
  Infinity
];

interestingParams[kWasmF64] = [
  -Infinity,
  -(2 ** 65),
  -(2 ** 64),
  -(2 ** 63),
  -(2 ** 62),
  -(2 ** 29),
  -(2 ** 33),
  -(2 ** 32),
  -(2 ** 31),
  -(2 ** 30),
  -(2 ** 29),
  -1.5,
  -1,
  0,
  -0,
  1,
  1.5,
  2,
  // 28 set bits, too many for float32.
  0xfffffff,
  2 ** 29,
  2 ** 30,
  2 ** 31,
  2 ** 32,
  2 ** 33,
  2 ** 62,
  2 ** 63,
  2 ** 64,
  2 ** 65,
  {valueOf: () => 14},
  {
    toString: () => {
      gc();
      return '19';
    }
  },
  Infinity
];

function GetParam(type) {
  if (type == kWasmExternRef) {
    return itoo(interestingParams[kWasmI32][getRandomInt(
        interestingParams[kWasmI32].length)]);
  }
  return interestingParams[type][getRandomInt(interestingParams[type].length)];
}

function GenerateAndRunTest() {
  // Generate signature
  const kMaxParams = 20;
  const kMaxReturns = 10;
  const numParams = getRandomInt(kMaxParams) + 1;
  const numReturns = getRandomInt(kMaxReturns + 1);
  // The array of parameter types.
  const params = [];
  // The array of return types.
  const returns = [];
  // This array stores which parameters map to which returns. {map} has the same
  // length as {returns}. `map[i] == j` means that parameter {j} gets returned
  // by return {i}.
  const map = [];
  for (let i = 0; i < numParams; ++i) {
    params.push(kPossibleTypes[getRandomInt(kPossibleTypes.length)]);
  }
  for (let i = 0; i < numReturns; ++i) {
    returns.push(kPossibleTypes[getRandomInt(kPossibleTypes.length)]);
  }
  for (let i = 0; i < numReturns; ++i) {
    map.push(getRandomInt(numParams));
  }
  RunTest(params, returns, map);
}

function RunTest(params, returns, map) {
  if (debug) {
    for (let i = 0; i < map.length; ++i) {
      map[i] = map[i] % params.length;
    }
    while (map.length < returns.length) {
      map.push(0);
    }
    let testcase = 'RunTest([';
    for (let i = 0; i < params.length; ++i) {
      testcase += (i == 0 ? '' : ', ') + TypeString(params[i]);
    }
    testcase += '], [';
    if (returns.length > 0) {
      testcase += TypeString(returns[0]);
      for (let i = 1; i < returns.length; ++i) {
        testcase += ', ' + TypeString(returns[i]);
      }
    }
    testcase += '], [' + map + ']);';
    print(testcase);
  }
  const builder = new WasmModuleBuilder();

  const itooIndex = builder.addImport('imp', 'itoo', kSig_r_i);
  const otoiIndex = builder.addImport('imp', 'otoi', kSig_i_r);

  const sig = makeSig(params, returns);
  // Generate module
  const body = [];
  for (let i = 0; i < returns.length; ++i) {
    body.push(kExprLocalGet);
    body.push(map[i]);

    body.push(
        ...ConvertOpcode(returns[i], params[map[i]], itooIndex, otoiIndex));
  }
  builder.addFunction('main', sig).addBody(body).exportFunc();

  const instance = builder.instantiate({imp: {itoo: itoo, otoi: otoi}});

  // Generate call.
  const args = [];
  for (let i = 0; i < params.length; ++i) {
    args.push(GetParam(params[i]));
  }
  let result = instance.exports.main(...args);
  if (returns.length == 0) {
    assertEquals(result, undefined);
    return;
  }
  if (returns.length == 1) {
    // Turn result into an array, so that the code below can be used.
    result = [result];
  }

  // Check result
  for (let i = 0; i < returns.length; ++i) {
    let details = undefined;
    if (debug) {
      details = `${i}, converting ${args[map[i]]} \
                 from ${TypeString(params[map[i]])} \
                 to ${TypeString(returns[i])}`;
    }
    assertEquals(
        ConversionFunction(returns[i], params[map[i]], args[map[i]]),
        result[i], details);
  }
}

for (let i = 0; i < (debug ? 200 : 2); ++i) {
  GenerateAndRunTest();
}
                                                                            node-23.7.0/deps/v8/test/mjsunit/wasm/trap-location.js                                              0000664 0000000 0000000 00000005412 14746647661 0022600 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --expose-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// Collect the Callsite objects instead of just a string:
Error.prepareStackTrace = function(error, frames) {
  return frames;
};

function testTrapLocations(instance, expected_stack_length) {
  function testWasmTrap(value, reason, position) {
    let function_name = arguments.callee.name;
    try {
      instance.exports.main(value);
      fail('expected wasm exception');
    } catch (e) {
      assertEquals(kTrapMsgs[reason], e.message, 'trap reason');
      // Check that the trapping function is the one which was called from this
      // function.
      assertTrue(
          e.stack[1].toString().startsWith(function_name), 'stack depth');
      assertEquals(1, e.stack[0].getLineNumber(), 'wasmFunctionIndex');
      assertEquals(position, e.stack[0].getPosition(), 'position');
    }
  }

  // The actual tests:
  testWasmTrap(0, kTrapDivByZero, 73);
  testWasmTrap(1, kTrapMemOutOfBounds, 74);
  testWasmTrap(2, kTrapUnreachable, 87);
  testWasmTrap(3, kTrapTableOutOfBounds, 91);
}

var builder = new WasmModuleBuilder();
builder.addMemory(0, 1);
var sig_index = builder.addType(kSig_i_v)

// Build a function to resemble this code:
//   if (idx < 2) {
//     return load(-2 / idx);
//   } else if (idx == 2) {
//     unreachable;
//   } else {
//     return call_indirect(idx);
//   }
// There are four different traps which are triggered by different input values:
// (0) division by zero; (1) mem oob; (2) unreachable; (3) invalid call target
// Each of them also has a different location where it traps.
builder.addFunction("main", kSig_i_i)
  .addBody([
      // offset 1
        kExprBlock, kWasmI32,
            kExprLocalGet, 0,
            kExprI32Const, 2,
          kExprI32LtU,
        kExprIf, kWasmVoid,
        // offset 9
              kExprI32Const, 0x7e /* -2 */,
              kExprLocalGet, 0,
            kExprI32DivU,
          // offset 15
          kExprI32LoadMem, 0, 0,
          kExprBr, 1,
        kExprEnd,
        // offset 21
            kExprLocalGet, 0,
            kExprI32Const, 2,
          kExprI32Eq,
        kExprIf, kWasmVoid,
          kExprUnreachable,
        kExprEnd,
        // offset 30
        kExprLocalGet, 0,
        kExprCallIndirect, sig_index, kTableZero,
      kExprEnd,
  ])
  .exportAs("main");
builder.appendToTable([0]);

let buffer = builder.toBuffer();

// Test async compilation and instantiation.
assertPromiseResult(WebAssembly.instantiate(buffer), pair => {
  testTrapLocations(pair.instance, 5);
});

// Test sync compilation and instantiation.
testTrapLocations(builder.instantiate(), 4);
                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/mjsunit/wasm/turboshaft/                                                   0000775 0000000 0000000 00000000000 14746647661 0021645 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/test/mjsunit/wasm/turboshaft/array-new-unreachable.js                           0000664 0000000 0000000 00000003447 14746647661 0026367 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --wasm-staging

d8.file.execute('test/mjsunit/wasm/wasm-module-builder.js');

(function TestArrayNewS128Unreachable() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  let array = builder.addArray(kWasmS128, true);
  let empty_sig = builder.addType(makeSig([], []));
  builder.addFunction(undefined, empty_sig)
    .addBody([
      // The empty try will never jump to the catch making the catch block
      // unreachable already during graph construction time.
      kExprTry, kWasmVoid,
      kExprCatchAll,
        kExprI32Const, 0,
        kSimdPrefix, kExprI8x16Splat,
        kExprI32Const, 42,
        kGCPrefix, kExprArrayNew, array,  // array.new
        kExprDrop,
      kExprEnd,
  ]);
  builder.addExport('main', 0);
  const instance = builder.instantiate();
  instance.exports.main();
})();

(function TestArrayNewUnreachableNoDefault() {
  print(arguments.callee.name);
  const builder = new WasmModuleBuilder();
  let empty_sig = builder.addType(makeSig([], []));
  let array = builder.addArray(wasmRefType(empty_sig), true);
  let empty_func = builder.addFunction(undefined, empty_sig)
    .addBody([]).exportFunc();
  builder.addFunction("main", empty_sig)
    .addBody([
      // The empty try will never jump to the catch making the catch block
      // unreachable already during graph construction time.
      kExprTry, kWasmVoid,
      kExprCatchAll,
        kExprRefFunc, empty_func.index,
        kExprI32Const, 42,
        kGCPrefix, kExprArrayNew, array,  // array.new
        kExprDrop,
      kExprEnd,
  ]).exportFunc();
  const instance = builder.instantiate();
  instance.exports.main();
})();
                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/mjsunit/wasm/turboshaft/basic.js                                           0000664 0000000 0000000 00000016541 14746647661 0023273 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --no-liftoff --no-wasm-lazy-compilation
// Flags: --turboshaft-wasm --enable-testing-opcode-in-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// Make sure turboshaft bails out graciously for non-implemented features.
(function Bailout() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("bailout", makeSig([], []))
    .addBody([kExprNopForTestingUnsupportedInLiftoff])
    .exportFunc();

  builder.instantiate();
})();

(function I32Arithmetic() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("i32_arithmetic", kSig_i_v)
    .addBody([kExprI32Const, 32, kExprI32Const, 10, kExprI32Add])
    .exportFunc();

  let wasm = builder.instantiate().exports;

  assertEquals(42, wasm.i32_arithmetic());
})();

(function I32Locals() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("i32_locals", kSig_i_ii)
    .addLocals(kWasmI32, 1)
    .addBody([
      // i = i + 1;
      kExprLocalGet, 0, kExprI32Const, 1, kExprI32Add, kExprLocalSet, 0,
      // k = j + 2; temp1 = k;
      kExprLocalGet, 1, kExprI32Const, 2, kExprI32Add, kExprLocalTee, 2,
      // temp2 = temp1 + i;
      kExprLocalGet, 0, kExprI32Add,
      // return temp2 * k;
      kExprLocalGet, 2, kExprI32Mul])
    .exportFunc();

  let wasm = builder.instantiate().exports;

  assertEquals((22 + 11) * 22, wasm.i32_locals(10, 20));
})();

(function IfThenElse() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let if_sig_32 = builder.addType(kSig_ii_ii);

  builder.addFunction("if_then_else_32", kSig_i_iii)
    .addBody([
      // f(x, y, z) {
      //   [temp1, temp2] = z ? [x + y, x] : [x - y, y];
      //   return temp1 * temp2;
      // }
      kExprLocalGet, 0, kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprIf, if_sig_32,
        kExprI32Add, kExprLocalGet, 0,
      kExprElse,
        kExprI32Sub, kExprLocalGet, 1,
      kExprEnd,
      kExprI32Mul])
    .exportFunc();

  let if_sig_64 = builder.addType(
      makeSig([kWasmI64, kWasmI64], [kWasmI64, kWasmI64]));

  builder.addFunction(
      "if_then_else_64",
      makeSig([kWasmI64, kWasmI64, kWasmI32], [kWasmI64]))
    .addBody([
      // f(x, y, z) {
      //   [temp1, temp2] = z ? [x + y, x] : [x - y, y];
      //   return temp1 * temp2;
      // }
      kExprLocalGet, 0, kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprIf, if_sig_64,
        kExprI64Add, kExprLocalGet, 0,
      kExprElse,
        kExprI64Sub, kExprLocalGet, 1,
      kExprEnd,
      kExprI64Mul])
    .exportFunc();

  let wasm = builder.instantiate().exports;

  assertEquals(-200, wasm.if_then_else_32(10, 20, 0));
  assertEquals(300, wasm.if_then_else_32(10, 20, 1));
  assertEquals(-200n, wasm.if_then_else_64(10n, 20n, 0));
  assertEquals(300n, wasm.if_then_else_64(10n, 20n, 1));
})();

(function OneArmedIf() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  builder.addFunction("one_armed_if", kSig_i_ii)
    .addBody([
      // f(x, y) {
      //   if (y) x = x + 1;
      //   return x;
      // }
      kExprLocalGet, 1,
      kExprIf, kWasmVoid,
        kExprLocalGet, 0, kExprI32Const, 1, kExprI32Add, kExprLocalSet, 0,
      kExprEnd,
      kExprLocalGet, 0])
    .exportFunc();

  let wasm = builder.instantiate().exports;

  assertEquals(10, wasm.one_armed_if(10, 0));
  assertEquals(11, wasm.one_armed_if(10, -1));
})();

(function BlockAndBr() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let block_sig = builder.addType(kSig_ii_ii);

  builder.addFunction("block_and_br", kSig_i_iii)
    .addBody([
      // f(x, y, z) {
      //   temp1 = x + y;
      //   temp2 = x;
      //   if (z) goto block;
      //   temp2 = temp2 * y;
      //  block:
      //   return temp1 + temp2;
      // }
      kExprLocalGet, 0, kExprLocalGet, 1,
      kExprBlock, block_sig,
        kExprI32Add,
        kExprLocalGet, 0,
        kExprLocalGet, 2,
        kExprBrIf, 0,
        kExprLocalGet, 1,
        kExprI32Mul,
      kExprEnd,
      kExprI32Add])
    .exportFunc();

  let wasm = builder.instantiate().exports;

  assertEquals((10 + 20) + (10 * 20), wasm.block_and_br(10, 20, 0));
  assertEquals((10 + 20) + 10, wasm.block_and_br(10, 20, 1));
})();

(function Loop() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let loop_sig = builder.addType(kSig_i_i);

  // Works for positive numbers only.
  builder.addFunction("factorial", kSig_i_i)
    .addBody([
      kExprI32Const, 1,
      kExprLoop, loop_sig,
        kExprLocalGet, 0,
        kExprI32Mul,
        kExprLocalGet, 0, kExprI32Const, 1, kExprI32Sub, kExprLocalSet, 0,
        kExprLocalGet, 0,
        kExprI32Const, 1,
        kExprI32GtS,
        kExprBrIf, 0,
      kExprEnd])
    .exportFunc();

  builder.addFunction("factorial_with_br_if_return", kSig_i_i)
    .addLocals(kWasmI32, 1)
    .addBody([
      kExprI32Const, 1, kExprLocalSet, 1,
      kExprLoop, kWasmVoid,
        kExprLocalGet, 1,
        kExprLocalGet, 0, kExprI32Const, 1, kExprI32LtS,
        kExprBrIf, 1,
        kExprLocalGet, 0, kExprI32Mul, kExprLocalSet, 1,
        kExprLocalGet, 0, kExprI32Const, 1, kExprI32Sub, kExprLocalSet, 0,
        kExprBr, 0,
      kExprEnd,
      kExprUnreachable])
    .exportFunc();

  let wasm = builder.instantiate().exports;

  assertEquals(1, wasm.factorial(1));
  assertEquals(24, wasm.factorial(4));
  assertEquals(720, wasm.factorial(6));

  assertEquals(1, wasm.factorial_with_br_if_return(0));
  assertEquals(1, wasm.factorial_with_br_if_return(1));
  assertEquals(24, wasm.factorial_with_br_if_return(4));
  assertEquals(720, wasm.factorial_with_br_if_return(6));
})();

(function Multireturn() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  builder.addFunction("swap", kSig_ii_ii)
    .addBody([kExprI32Const, 42, // garbage
              kExprLocalGet, 1, kExprLocalGet, 0, kExprReturn])
    .exportFunc();

  let wasm = builder.instantiate().exports;

  assertEquals([1, 0], wasm.swap(0, 1));
})();

(function BrTable() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let block_sig = builder.addType(kSig_i_i);

  builder.addFunction("br_table", kSig_i_i)
    .addBody([
      kExprLocalGet, 0,
      kExprBlock, block_sig,
        kExprBlock, block_sig,
          kExprLocalGet, 0,
          kExprBrTable, 2, 2, 1, 0,
        kExprEnd,
        kExprI32Const, 1, kExprI32Add, kExprReturn,
      kExprEnd,
      kExprI32Const, 2, kExprI32Sub])
    .exportFunc();

  let wasm = builder.instantiate().exports;

  assertEquals(0, wasm.br_table(0));
  assertEquals(-1, wasm.br_table(1));
  assertEquals(23, wasm.br_table(22));
})();

(function TestSubZeroFromTruncatedOptimization() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("subZeroFromTruncated", makeSig([kWasmI64], [kWasmI32]))
    .exportFunc()
    .addBody([
      // i32.sub(i32.wrap_i64(local.get 0), 0)
      // should be optimized to i32.wrap_i64(local.get 0)
      kExprLocalGet, 0,
      kExprI32ConvertI64,
      kExprI32Const, 0,
      kExprI32Sub,
    ]);
  let instance = builder.instantiate();
  assertEquals(123, instance.exports.subZeroFromTruncated(123n));
})();
                                                                                                                                                               node-23.7.0/deps/v8/test/mjsunit/wasm/turboshaft/br-table-analysis.js                               0000664 0000000 0000000 00000005557 14746647661 0025530 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --no-liftoff --no-wasm-lazy-compilation
// Flags: --turboshaft-wasm --enable-testing-opcode-in-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function BrTablePrimaryIsDefault() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let block_sig = builder.addType(kSig_i_i);

  builder.addFunction("br_table", kSig_i_i)
    .addBody([
      kExprLocalGet, 0,
      kExprBlock, block_sig,
        kExprBlock, block_sig,
          kExprLocalGet, 0,
          kExprBrTable, 4, 2, 0, 1, 0, 1, 0,
        kExprEnd,
        kExprI32Const, 1, kExprI32Add, kExprReturn,
      kExprEnd,
      kExprI32Const, 2, kExprI32Sub])
    .exportFunc();

  let wasm = builder.instantiate().exports;

  assertEquals(0, wasm.br_table(0));
  assertEquals(2, wasm.br_table(1));
  assertEquals(0, wasm.br_table(2));
  assertEquals(4, wasm.br_table(3));
  assertEquals(2, wasm.br_table(4));
  assertEquals(3, wasm.br_table(5));
  assertEquals(8, wasm.br_table(10));
})();

(function BrTablePrimaryIsNotDefault() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let block_sig = builder.addType(kSig_i_i);

  builder.addFunction("br_table", kSig_i_i)
    .addBody([
      kExprLocalGet, 0,
      kExprBlock, block_sig,
        kExprBlock, block_sig,
          kExprLocalGet, 0,
          kExprBrTable, 5, 2, 1, 1, 1, 1, 0,
        kExprEnd,
        kExprI32Const, 1, kExprI32Add, kExprReturn,
      kExprEnd,
      kExprI32Const, 2, kExprI32Sub])
    .exportFunc();

  let wasm = builder.instantiate().exports;

  assertEquals(0, wasm.br_table(0));
  assertEquals(-1, wasm.br_table(1));
  assertEquals(0, wasm.br_table(2));
  assertEquals(1, wasm.br_table(3));
  assertEquals(2, wasm.br_table(4));
  assertEquals(6, wasm.br_table(5));
  assertEquals(7, wasm.br_table(6));
  assertEquals(11, wasm.br_table(10));
})();

(function BrTablePrimaryIsNotDefaultTwoOrOthers() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let block_sig = builder.addType(kSig_i_i);

  builder.addFunction("br_table", kSig_i_i)
    .addBody([
      kExprLocalGet, 0,
      kExprBlock, block_sig,
        kExprBlock, block_sig,
          kExprLocalGet, 0,
          kExprBrTable, 6, 2, 1, 0, 0, 0, 2, 1,
        kExprEnd,
        kExprI32Const, 1, kExprI32Add, kExprReturn,
      kExprEnd,
      kExprI32Const, 2, kExprI32Sub])
    .exportFunc();

  let wasm = builder.instantiate().exports;

  assertEquals(0, wasm.br_table(0));
  assertEquals(-1, wasm.br_table(1));
  assertEquals(3, wasm.br_table(2));
  assertEquals(4, wasm.br_table(3));
  assertEquals(5, wasm.br_table(4));
  assertEquals(5, wasm.br_table(5));
  assertEquals(4, wasm.br_table(6));
  assertEquals(8, wasm.br_table(10));
})();
                                                                                                                                                 node-23.7.0/deps/v8/test/mjsunit/wasm/turboshaft/instruction-selection.js                           0000664 0000000 0000000 00000030353 14746647661 0026553 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --no-liftoff --no-wasm-lazy-compilation --experimental-wasm-stringref
// Flags: --turboshaft-wasm --turboshaft-wasm-instruction-selection-experimental
// Flags: --turboshaft-wasm-instruction-selection-staged

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

(function TrivialFunctions() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("id", makeSig([kWasmI32], [kWasmI32]))
    .addBody([kExprLocalGet, 0])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(42, wasm.id(42));

})();

(function ArithmeticInt32() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let maddSig = makeSig([kWasmI32, kWasmI32, kWasmI32], [kWasmI32]);
  builder.addFunction("madd", maddSig)
    .addBody([
      // local[0] + (local[1] * local[2])
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprI32Mul,
      kExprI32Add
    ])
    .exportFunc();
  builder.addFunction("madd2", maddSig)
    .addBody([
      // (local[0] * local[1]) + local[2]
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI32Mul,
      kExprLocalGet, 2,
      kExprI32Add
    ])
    .exportFunc();
  builder.addFunction("addConstant", makeSig([kWasmI32], [kWasmI32]))
    .addBody([kExprLocalGet, 0, ...wasmI32Const(-7), kExprI32Add])
    .exportFunc();
  builder.addFunction("add", makeSig([kWasmI32, kWasmI32], [kWasmI32]))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Add])
    .exportFunc();
  builder.addFunction("msub", maddSig)
    .addBody([
      // local[0] - (local[1] * local[2])
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprI32Mul,
      kExprI32Sub
    ])
    .exportFunc();
  builder.addFunction("subConstant", makeSig([kWasmI32], [kWasmI32]))
    .addBody([kExprLocalGet, 0, ...wasmI32Const(-7), kExprI32Sub])
    .exportFunc();
  builder.addFunction("sub", makeSig([kWasmI32, kWasmI32], [kWasmI32]))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Sub])
    .exportFunc();
  builder.addFunction("mulConstant", makeSig([kWasmI32], [kWasmI32]))
    // Can be lowered to local[0] + local[0] << 3.
    .addBody([kExprLocalGet, 0, ...wasmI32Const(9), kExprI32Mul])
    .exportFunc();
  builder.addFunction("mulNegate", makeSig([kWasmI32, kWasmI32], [kWasmI32]))
    .addBody([
      // (0 - local[0]) * local[1]
      kExprI32Const, 0,
      kExprLocalGet, 0,
      kExprI32Sub,
      kExprLocalGet, 1,
      kExprI32Mul])
    .exportFunc();
  builder.addFunction("mulNegate2", makeSig([kWasmI32, kWasmI32], [kWasmI32]))
    .addBody([
      // local[0] * (0 - local[1])
      kExprLocalGet, 0,
      kExprI32Const, 0,
      kExprLocalGet, 1,
      kExprI32Sub,
      kExprI32Mul])
    .exportFunc();
  builder.addFunction("mul", makeSig([kWasmI32, kWasmI32], [kWasmI32]))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI32Mul])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(3 + (4 * 5), wasm.madd(3, 4, 5));
  assertEquals((3 * 4) + 5, wasm.madd2(3, 4, 5));
  assertEquals(5 + -7, wasm.addConstant(5));
  assertEquals(5 + -7, wasm.add(5, -7));

  assertEquals(3 - (4 * 5), wasm.msub(3, 4, 5));
  assertEquals(5 - -7, wasm.subConstant(5));
  assertEquals(5 - -7, wasm.sub(5, -7));

  assertEquals(42 * 9, wasm.mulConstant(42));
  assertEquals(-42 * 4, wasm.mulNegate(42, 4));
  assertEquals(42 * -4, wasm.mulNegate2(42, 4));
  assertEquals(5 * -7, wasm.mul(5, -7));
})();

(function ArithmeticInt64() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let maddSig = makeSig([kWasmI64, kWasmI64, kWasmI64], [kWasmI64]);
  builder.addFunction("madd", maddSig)
    .addBody([
      // local[0] + (local[1] * local[2])
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprI64Mul,
      kExprI64Add
    ])
    .exportFunc();
  builder.addFunction("madd2", maddSig)
    .addBody([
      // (local[0] * local[1]) + local[2]
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI64Mul,
      kExprLocalGet, 2,
      kExprI64Add
    ])
    .exportFunc();
  builder.addFunction("addConstant", makeSig([kWasmI64], [kWasmI64]))
    .addBody([kExprLocalGet, 0, ...wasmI64Const(-7), kExprI64Add])
    .exportFunc();
  builder.addFunction("add", makeSig([kWasmI64, kWasmI64], [kWasmI64]))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI64Add])
    .exportFunc();
  builder.addFunction("msub", maddSig)
    .addBody([
      // local[0] - (local[1] * local[2])
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprI64Mul,
      kExprI64Sub
    ])
    .exportFunc();
  builder.addFunction("subConstant", makeSig([kWasmI64], [kWasmI64]))
    .addBody([kExprLocalGet, 0, ...wasmI64Const(-7), kExprI64Sub])
    .exportFunc();
  builder.addFunction("sub", makeSig([kWasmI64, kWasmI64], [kWasmI64]))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI64Sub])
    .exportFunc();
  builder.addFunction("mulConstant", makeSig([kWasmI64], [kWasmI64]))
    // Can be lowered to local[0] + local[0] << 3.
    .addBody([kExprLocalGet, 0, ...wasmI64Const(9), kExprI64Mul])
    .exportFunc();
  builder.addFunction("mulNegate", makeSig([kWasmI64, kWasmI64], [kWasmI64]))
    .addBody([
      // (0 - local[0]) * local[1]
      kExprI64Const, 0,
      kExprLocalGet, 0,
      kExprI64Sub,
      kExprLocalGet, 1,
      kExprI64Mul])
    .exportFunc();
  builder.addFunction("mulNegate2", makeSig([kWasmI64, kWasmI64], [kWasmI64]))
    .addBody([
      // local[0] * (0 - local[1])
      kExprLocalGet, 0,
      kExprI64Const, 0,
      kExprLocalGet, 1,
      kExprI64Sub,
      kExprI64Mul])
    .exportFunc();
  builder.addFunction("mul", makeSig([kWasmI64, kWasmI64], [kWasmI64]))
    .addBody([kExprLocalGet, 0, kExprLocalGet, 1, kExprI64Mul])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(3n + (4n * 5n), wasm.madd(3n, 4n, 5n));
  assertEquals((3n * 4n) + 5n, wasm.madd2(3n, 4n, 5n));
  assertEquals(5n + -7n, wasm.addConstant(5n));
  assertEquals(5n + -7n, wasm.add(5n, -7n));

  assertEquals(3n - (4n * 5n), wasm.msub(3n, 4n, 5n));
  assertEquals(5n - -7n, wasm.subConstant(5n));
  assertEquals(5n - -7n, wasm.sub(5n, -7n));

  assertEquals(42n * 9n, wasm.mulConstant(42n));
  assertEquals(-42n * 4n, wasm.mulNegate(42n, 4n));
  assertEquals(42n * -4n, wasm.mulNegate2(42n, 4n));
  assertEquals(5n * -7n, wasm.mul(5n, -7n));
})();

(function Loads() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  builder.addFunction("isString", makeSig([kWasmExternRef], [kWasmI32]))
  .addBody([
    kExprLocalGet, 0,
    kGCPrefix, kExprAnyConvertExtern,
    kGCPrefix, kExprRefTest, kStringRefCode,
  ])
  .exportFunc();

  // Loops emit stack checks (which includes loading from the root register).
  let loop_sig = builder.addType(kSig_i_i);
  // Works for positive numbers only.
  builder.addFunction("factorial", kSig_i_i)
    .addBody([
      kExprI32Const, 1,
      kExprLoop, loop_sig,
        kExprLocalGet, 0,
        kExprI32Mul,
        kExprLocalGet, 0,
        kExprI32Const, 1,
        kExprI32Sub,
        kExprLocalTee, 0,
        kExprI32Const, 1,
        kExprI32GtS,
        kExprBrIf, 0,
      kExprEnd])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(0, wasm.isString({}));
  assertEquals(0, wasm.isString(1));
  assertEquals(0, wasm.isString(1.5));
  assertEquals(0, wasm.isString(-0.0));
  assertEquals(0, wasm.isString(null));
  assertEquals(1, wasm.isString("test"));

  assertEquals(1, wasm.factorial(1));
  assertEquals(24, wasm.factorial(4));
  assertEquals(720, wasm.factorial(6));
})();

(function LoadsAndStoresArrays() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let arrayI32 = builder.addArray(kWasmI32, true);
  let arrayI8 = builder.addArray(kWasmI8, true);

  let tests = [
    ["I32", arrayI32, kExprArrayGet],
    ["I8", arrayI8, kExprArrayGetS],
  ];

  for (let [name, arrayIndex, arrayGetOp] of tests) {
    let createSig = makeSig([kWasmI32], [kWasmAnyRef]);
    let setSig = makeSig([kWasmAnyRef, kWasmI32, kWasmI32], []);
    let getSig = makeSig([kWasmAnyRef, kWasmI32], [kWasmI32]);

    builder.addFunction(`createArray${name}`, createSig)
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprArrayNewDefault, arrayIndex,
    ])
    .exportFunc();

    builder.addFunction(`set${name}`, setSig)
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprRefCastNull, arrayIndex,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kGCPrefix, kExprArraySet, arrayIndex,
    ])
    .exportFunc();

    builder.addFunction(`get${name}`, getSig)
    .addBody([
      kExprLocalGet, 0,
      kGCPrefix, kExprRefCastNull, arrayIndex,
      kExprLocalGet, 1,
      kGCPrefix, arrayGetOp, arrayIndex,
    ])
    .exportFunc();
  }

  let wasm = builder.instantiate().exports;

  for (let [name, arrayIndex, arrayGetOp] of tests) {
    print(`- test array${name}`);
    let size = 20;
    let array = wasm[`createArray${name}`](size);
    for (let i = 0; i < size; ++i) {
      wasm[`set${name}`](array, i, i * 2);
    }
    for (let i = 0; i < size; ++i) {
      assertEquals(i * 2, wasm[`get${name}`](array, i));
    }
    assertTraps(kTrapNullDereference, () => wasm[`get${name}`](null, 1, 1));
    assertTraps(kTrapNullDereference, () => wasm[`set${name}`](null, 1));
  }
})();

(function LoadsAndStoresStruct() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let struct = builder.addStruct([
    makeField(kWasmI8, false),
    makeField(kWasmI32, false),
    makeField(kWasmI64, false),
    makeField(kWasmAnyRef, false)
  ]);

  builder.addFunction(`createStruct`,
      makeSig([kWasmI32, kWasmI32, kWasmI64, kWasmAnyRef], [kWasmAnyRef]))
    .addBody([
      kExprLocalGet, 0, kExprLocalGet, 1, kExprLocalGet, 2, kExprLocalGet, 3,
      kGCPrefix, kExprStructNew, struct,
    ])
    .exportFunc();


  builder.addFunction(`get`,
      makeSig([kWasmAnyRef], [kWasmI32, kWasmI32, kWasmI64, kWasmAnyRef]))
  .addLocals(wasmRefNullType(struct), 1 )
  .addBody([
    kExprLocalGet, 0,
    kGCPrefix, kExprRefCastNull, struct,
    kExprLocalTee, 1,
    kGCPrefix, kExprStructGetS, struct, 0,
    kExprLocalGet, 1,
    kGCPrefix, kExprStructGet, struct, 1,
    kExprLocalGet, 1,
    kGCPrefix, kExprStructGet, struct, 2,
    kExprLocalGet, 1,
    kGCPrefix, kExprStructGet, struct, 3,
  ])
  .exportFunc();

  let wasm = builder.instantiate().exports;
  let myStruct = wasm.createStruct(1, 2, 3n, null);
  assertEquals([1, 2, 3n, null], wasm.get(myStruct));
  assertTraps(kTrapNullDereference, () => wasm.get(null));

})();

(function I64BitAnd() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("and", makeSig([kWasmI64, kWasmI64], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI64And,
    ])
    .exportFunc();

  builder.addFunction("maskAfterShift", makeSig([kWasmI64], [kWasmI64]))
    .addBody([
      // return (local[0] >> 3) & 7;
      kExprLocalGet, 0,
      kExprI64Const, 3,
      kExprI64ShrU,
      kExprI64Const, 7,
      kExprI64And,
    ])
    .exportFunc();

  builder.addFunction("shiftAfterMask", makeSig([kWasmI64], [kWasmI64]))
    .addBody([
      // return (local[0] & 56) >> 3;
      kExprLocalGet, 0,
      kExprI64Const, 56,
      kExprI64And,
      kExprI64Const, 3,
      kExprI64ShrU,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(
    0b10101010_00000000_01010101_00000000n, wasm.and(
    0b10101010_00000000_11111111_01010101n,
    0b11111111_11111111_01010101_00000000n));
  assertEquals(0b101n, wasm.maskAfterShift(0b1010101010101010n));
  assertEquals(0b101n, wasm.shiftAfterMask(0b1010101010101010n));
})();

(function SignedExtendRightShiftValue() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("shrsExtend", makeSig([kWasmI32], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      kExprI32Const, 11,
      kExprI32ShrS,
      kExprI64SConvertI32,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(42n, wasm.shrsExtend(42 << 11));
  assertEquals(-41n, wasm.shrsExtend(-41 << 11));
})();
                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/mjsunit/wasm/turboshaft/int64-lowering.js                                  0000664 0000000 0000000 00000054515 14746647661 0025005 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Flags: --no-liftoff --no-wasm-lazy-compilation
// Flags: --turboshaft-wasm --enable-testing-opcode-in-wasm

d8.file.execute("test/mjsunit/wasm/wasm-module-builder.js");

// Make sure turboshaft bails out graciously for non-implemented features.
(function I64Identity() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("id", makeSig([kWasmI64], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(0n, wasm.id(0n));
  assertEquals(1n, wasm.id(1n));
  assertEquals(-1n, wasm.id(-1n));
  assertEquals(0x123456789ABCn, wasm.id(0x123456789ABCn));
  assertEquals(-0x123456789ABCn, wasm.id(-0x123456789ABCn));
})();

(function I64Constants() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("main", makeSig([], [kWasmI64, kWasmI64, kWasmI64]))
    .addBody([
      ...wasmI64Const(0),
      ...wasmI64Const(-12345),
      ...wasmI64Const(0x123456789ABCDEFn),
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals([0n, -12345n, 0x123456789ABCDEFn], wasm.main());
})();

(function I64Multiplication() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("mul", makeSig([kWasmI64, kWasmI64], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI64Mul,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(0n, wasm.mul(0n, 5n));
  assertEquals(0n, wasm.mul(5n, 0n));
  assertEquals(5n, wasm.mul(1n, 5n));
  assertEquals(-5n, wasm.mul(5n, -1n));
  assertEquals(35n, wasm.mul(-5n, -7n));
  assertEquals(0xfffffffffn * 0xfn, wasm.mul(0xfffffffffn, 0xfn));
})();

(function I64Addition() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("add", makeSig([kWasmI64, kWasmI64], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI64Add,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(3n, wasm.add(1n, 2n));
  assertEquals(0n, wasm.add(100n, -100n));
  assertEquals(0x12345678n + 0xABCDEF1234n,
               wasm.add(0x12345678n, 0xABCDEF1234n));
})();

(function I64Subtraction() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("sub", makeSig([kWasmI64, kWasmI64], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI64Sub,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(-1n, wasm.sub(1n, 2n));
  assertEquals(200n, wasm.sub(100n, -100n));
  assertEquals(0x12345678n - 0xABCDEF1234n,
               wasm.sub(0x12345678n, 0xABCDEF1234n));
  assertEquals(0n, wasm.sub(0x123456789ABCDEFn, 0x123456789ABCDEFn));
})();

(function I64BitAnd() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("and", makeSig([kWasmI64, kWasmI64], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI64And,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(
    0b10101010_00000000_11111111_01010101n, wasm.and(
    0b10101010_00000000_11111111_01010101n,
    0b10101010_00000000_11111111_01010101n));
  assertEquals(
    0b10101010_00000000_01010101_00000000n, wasm.and(
    0b10101010_00000000_11111111_01010101n,
    0b11111111_11111111_01010101_00000000n));
})();

(function I64BitOr() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("or", makeSig([kWasmI64, kWasmI64], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI64Ior,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(
    0b10101010_00000000_11111111_01010101n, wasm.or(
    0b10101010_00000000_11111111_01010101n,
    0b10101010_00000000_11111111_01010101n));
  assertEquals(
    0b11111111_11111111_11111111_01010101n, wasm.or(
    0b10101010_00000000_11111111_01010101n,
    0b11111111_11111111_01010101_00000000n));
})();

(function I64BitXor() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("xor", makeSig([kWasmI64, kWasmI64], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI64Xor,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(
    0b10101010_00000000_11111111_01010101n, wasm.xor(
    0b10101010_00000000_11111111_01010101n,
    0b00000000_00000000_00000000_00000000n));
  assertEquals(
    0b11111111_11111111_11111111_01010101n, wasm.xor(
    0b10101010_00000000_11111111_01010101n,
    0b01010101_11111111_00000000_00000000n));
})();

(function I64BitShl() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("shl", makeSig([kWasmI64, kWasmI64], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI64Shl,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(0x123456789n, wasm.shl(0x123456789n, 0n));
  assertEquals(0x1234567890000n, wasm.shl(0x123456789n, 16n));
  assertEquals(0x3456789000000000n, wasm.shl(0x123456789n, 36n));
  assertEquals(31n << 56n, wasm.shl(31n, -8n));
  assertEquals(31n << 1n, wasm.shl(31n, 65n));
})();

(function I64BitShrs() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("shrs", makeSig([kWasmI64, kWasmI64], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI64ShrS,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(0x123456789n, wasm.shrs(0x123456789n, 0n));
  assertEquals(0x12345n, wasm.shrs(0x123456789n, 16n));
  assertEquals(-0x2n, wasm.shrs(-0x123456789n, 32n));
  assertEquals(-0x1n, wasm.shrs(-0x123456789n, 33n));
  assertEquals(-0x1n, wasm.shrs(-0x123456789n, 40n));
  assertEquals(-0x123456789n, wasm.shrs(-0x123456789n, 64n));
  assertEquals(31n >> 56n, wasm.shrs(31n, -8n));
  assertEquals(31n >> 1n, wasm.shrs(31n, 65n));
})();

(function I64BitShrU() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("shru", makeSig([kWasmI64, kWasmI64], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI64ShrU,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(0x123456789n, wasm.shru(0x123456789n, 0n));
  assertEquals(0x12345n, wasm.shru(0x123456789n, 16n));
  assertEquals(0xFFFFFFFEn, wasm.shru(-0x123456789n, 32n));
  assertEquals(0xFn, wasm.shru(-0x123456789n, 60n));
  assertEquals(-0x123456789n, wasm.shru(-0x123456789n, 64n));
  assertEquals(31n >> 56n, wasm.shru(31n, -8n));
  assertEquals(31n >> 1n, wasm.shru(31n, 65n));
})();

(function I64BitRol() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("rol", makeSig([kWasmI64, kWasmI64], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI64Rol,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(0x123456789n, wasm.rol(0x123456789n, 0n));
  assertEquals(0x1234567890000n, wasm.rol(0x123456789n, 16n));
  assertEquals(0x3456789000000012n, wasm.rol(0x123456789n, 36n));
  assertEquals(0x34567890ABCDEF12n, wasm.rol(0xABCDEF1234567890n, 32n));
  assertEquals(0x4D5E6F78091A2B3Cn, wasm.rol(0x123456789ABCDEF0n, 31n));
  assertEquals(0x3579BDE02468ACF1n, wasm.rol(0x123456789ABCDEF0n, 33n));
  assertEquals(31n << 56n, wasm.rol(31n, -8n));
  assertEquals(31n << 1n, wasm.rol(31n, 65n));
})();

(function I64BitRolStaticRhs() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();

  let tests = [
    // [lhs, rhs, expected]
    [0x123456789n, 0n, 0x123456789n],
    [0x12345678_11111111n, 32n, 0x11111111_12345678n],
    [0x1_23456789n, 16n, 0x12345_67890000n],
    [0x1_23456789n, 36n, 0x34567890_00000012n],
    [31n, -8, 31n << 56n],
    [31n, 65n, 31n << 1n],
  ];

  for (const [lhs, rhs, expected] of tests) {
    builder.addFunction(`rol${rhs}`, makeSig([kWasmI64], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      ...wasmI64Const(rhs),
      kExprI64Rol,
    ])
    .exportFunc();
  }

  let wasm = builder.instantiate().exports;

  for (const [lhs, rhs, expected] of tests) {
    print(`test i64.rol(${lhs}, ${rhs}) == ${expected}`);
    assertEquals(expected, wasm[`rol${rhs}`](lhs));
  }
})();

(function I64BitRor() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("ror", makeSig([kWasmI64, kWasmI64], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI64Ror,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(0x123456789n, wasm.ror(0x123456789n, 0n));
  assertEquals(0x6789000000012345n, wasm.ror(0x123456789n, 16n));
  assertEquals(0x1234567890000000n, wasm.ror(0x123456789n, 36n));
  assertEquals(0x34567890ABCDEF12n, wasm.ror(0xABCDEF1234567890n, 32n));
  assertEquals(0x3579BDE02468ACF1n, wasm.ror(0x123456789ABCDEF0n, 31n));
  assertEquals(0x4D5E6F78091A2B3Cn, wasm.ror(0x123456789ABCDEF0n, 33n));
  assertEquals(31n << 8n, wasm.ror(31n, -8n));
  assertEquals(31n << 1n, wasm.ror(31n, 127n));
})();

(function I64Equals() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("eq", makeSig([kWasmI64, kWasmI64], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI64Eq,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(1, wasm.eq(0n, 0n));
  assertEquals(1, wasm.eq(-123n, -123n));
  assertEquals(0, wasm.eq(-123n, 123n));
  assertEquals(0, wasm.eq(0x12345678_87654321n, 0x87654321_12345678n));
  assertEquals(0, wasm.eq(0x12345678_87654321n, 0x1234567A_87654321n));
  assertEquals(0, wasm.eq(0x12345678_87654321n, 0x12345678_8765432An));
})();

(function I64NotEquals() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("ne", makeSig([kWasmI64, kWasmI64], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI64Ne,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(0, wasm.ne(0n, 0n));
  assertEquals(0, wasm.ne(-123n, -123n));
  assertEquals(1, wasm.ne(-123n, 123n));
  assertEquals(1, wasm.ne(0x12345678_87654321n, 0x87654321_12345678n));
  assertEquals(1, wasm.ne(0x12345678_87654321n, 0x1234567A_87654321n));
  assertEquals(1, wasm.ne(0x12345678_87654321n, 0x12345678_8765432An));
})();

(function I64LessThanSigned() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("lts", makeSig([kWasmI64, kWasmI64], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI64LtS,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(0, wasm.lts(0n, 0n));
  assertEquals(1, wasm.lts(-123n, 123n));
  assertEquals(0, wasm.lts(123n, -123n));
  assertEquals(1, wasm.lts(0x12345678_12488421n, 0x12488421_12345678n));
  assertEquals(0, wasm.lts(0x12488421_12345678n, 0x12345678_12488421n));
  assertEquals(0, wasm.lts(0x12345678_87654321n, 0x12345678_87654320n));
  assertEquals(1, wasm.lts(0x12345678_87654321n, 0x12345678_87654322n));
})();

(function I64LessThanOrEqualSigned() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("les", makeSig([kWasmI64, kWasmI64], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI64LeS,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(1, wasm.les(0n, 0n));
  assertEquals(1, wasm.les(-123n, 123n));
  assertEquals(0, wasm.les(123n, -123n));
  assertEquals(1, wasm.les(0x12345678_12488421n, 0x12488421_12345678n));
  assertEquals(0, wasm.les(0x12488421_12345678n, 0x12345678_12488421n));
  assertEquals(0, wasm.les(0x12345678_87654321n, 0x12345678_87654320n));
  assertEquals(1, wasm.les(0x12345678_87654321n, 0x12345678_87654322n));
})();

(function I64LessThanUnsigned() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("ltu", makeSig([kWasmI64, kWasmI64], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI64LtU,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(0, wasm.ltu(0n, 0n));
  assertEquals(0, wasm.ltu(-123n, 123n));
  assertEquals(1, wasm.ltu(123n, -123n));
  assertEquals(1, wasm.ltu(0x12345678_12488421n, 0x12488421_12345678n));
  assertEquals(0, wasm.ltu(0x12488421_12345678n, 0x12345678_12488421n));
  assertEquals(0, wasm.ltu(0x12345678_87654321n, 0x12345678_87654320n));
  assertEquals(1, wasm.ltu(0x12345678_87654321n, 0x12345678_87654322n));
})();

(function I64LessThanOrEqualUnsigned() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("leu", makeSig([kWasmI64, kWasmI64], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI64LeU,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(1, wasm.leu(0n, 0n));
  assertEquals(0, wasm.leu(-123n, 123n));
  assertEquals(1, wasm.leu(123n, -123n));
  assertEquals(1, wasm.leu(0x12345678_12488421n, 0x12488421_12345678n));
  assertEquals(0, wasm.leu(0x12488421_12345678n, 0x12345678_12488421n));
  assertEquals(0, wasm.leu(0x12345678_87654321n, 0x12345678_87654320n));
  assertEquals(1, wasm.leu(0x12345678_87654321n, 0x12345678_87654322n));
})();

(function I64EqualsZero() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("eqz", makeSig([kWasmI64], [kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kExprI64Eqz,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(1, wasm.eqz(0n));
  assertEquals(0, wasm.eqz(1n));
  assertEquals(0, wasm.eqz(-1n));
  assertEquals(0, wasm.eqz(0x100_00000000n));
})();

(function I64Call() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let callee = builder.addFunction("callee",
      makeSig([kWasmI64], [kWasmI64]))
    .addBody([kExprLocalGet, 0])
    .exportFunc();
  builder.addFunction("call", makeSig([kWasmI64], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      kExprCallFunction, callee.index,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(123n, wasm.callee(123n));
  assertEquals(123n, wasm.call(123n));
})();

(function I64CallMultiReturn() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  let callee = builder.addFunction("callee",
      makeSig([kWasmI32, kWasmI64, kWasmI64, kWasmI32],
              [kWasmI32, kWasmI64, kWasmI64, kWasmI32]))
    .addBody([
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprLocalGet, 2,
      kExprLocalGet, 3,
    ])
    .exportFunc();
  builder.addFunction("call",
      makeSig([kWasmI64, kWasmI64], [kWasmI32, kWasmI64, kWasmI64, kWasmI32]))
    .addBody([
      kExprI32Const, 11,
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI32Const, 22,
      kExprCallFunction, callee.index,
    ])
    .exportFunc();

  builder.addFunction("tailCall",
      makeSig([kWasmI64, kWasmI64], [kWasmI32, kWasmI64, kWasmI64, kWasmI32]))
    .addBody([
      kExprI32Const, 11,
      kExprLocalGet, 0,
      kExprLocalGet, 1,
      kExprI32Const, 22,
      kExprReturnCall, callee.index,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals([11, 123n, -1n, 22], wasm.callee(11, 123n, -1n, 22));
  assertEquals([11, 123n, -1n, 22], wasm.call(123n, -1n));
  assertEquals([11, 123n, -1n, 22], wasm.tailCall(123n, -1n));

  assertEquals([11, -123n, 123n, 22], wasm.callee(11, -123n, 123n, 22));
  assertEquals([11, -123n, 123n, 22], wasm.call(-123n, 123n));
  assertEquals([11, -123n, 123n, 22], wasm.tailCall(-123n, 123n));
})();

(function I64CountLeadingZeros() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("clz", makeSig([kWasmI64], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      kExprI64Clz,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(0n, wasm.clz(-1n));
  assertEquals(64n, wasm.clz(0n));
  assertEquals(47n, wasm.clz(0x1FFFFn));
})();

(function I64CountTrailingZeros() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("ctz", makeSig([kWasmI64], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      kExprI64Ctz,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(0n, wasm.ctz(-1n));
  assertEquals(64n, wasm.ctz(0n));
  assertEquals(17n, wasm.ctz(0xE0000n));
})();

(function I64PopCount() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("popcnt", makeSig([kWasmI64], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      kExprI64Popcnt,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(64n, wasm.popcnt(-1n));
  assertEquals(0n, wasm.popcnt(0n));
  assertEquals(10n, wasm.popcnt(0b10101011111100001n));
})();

(function I64ConvertFromInt32() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("fromI32", makeSig([kWasmI32], [kWasmI64, kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      kExprI64SConvertI32,
      kExprLocalGet, 0,
      kExprI64UConvertI32,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals([0n, 0n], wasm.fromI32(0));
  assertEquals([123n, 123n], wasm.fromI32(123));
  assertEquals([-1n, 0xFFFFFFFFn], wasm.fromI32(-1));
  assertEquals([-2147483648n, 2147483648n], wasm.fromI32(0x80000000));
})();

(function I64ConvertFromF64() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("reinterpretF64", makeSig([kWasmF64], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      kExprI64ReinterpretF64
    ])
    .exportFunc();
  builder.addFunction("signedF64", makeSig([kWasmF64], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      kExprI64SConvertF64,
    ])
    .exportFunc();
  builder.addFunction("unsignedF64", makeSig([kWasmF64], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      kExprI64UConvertF64,
    ])
    .exportFunc();
  builder.addFunction("signedSatF64", makeSig([kWasmF64], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      kNumericPrefix, kExprI64SConvertSatF64,
    ])
    .exportFunc();
  builder.addFunction("unsignedSatF64", makeSig([kWasmF64], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      kNumericPrefix, kExprI64UConvertSatF64,
    ])
    .exportFunc();

  let wasm = builder.instantiate().exports;
  assertEquals(0n, wasm.reinterpretF64(0));
  assertEquals(4638355772470722560n, wasm.reinterpretF64(123));
  assertEquals(-4585016264384053248n, wasm.reinterpretF64(-123));

  assertEquals(0xFF_12345678n, wasm.signedF64(0xFF_12345678));
  assertEquals(-0xFF_12345678n, wasm.signedF64(-0xFF_12345678));
  assertTraps(kTrapFloatUnrepresentable, () => wasm.signedF64(NaN));
  assertTraps(kTrapFloatUnrepresentable, () => wasm.signedF64(Infinity));
  assertTraps(kTrapFloatUnrepresentable, () => wasm.signedF64(-Infinity));

  assertEquals(0xFF_12345678n, wasm.unsignedF64(0xFF_12345678));
  assertTraps(kTrapFloatUnrepresentable, () => wasm.unsignedF64(-1));
  assertTraps(kTrapFloatUnrepresentable, () => wasm.unsignedF64(NaN));
  assertTraps(kTrapFloatUnrepresentable, () => wasm.unsignedF64(Infinity));
  assertTraps(kTrapFloatUnrepresentable, () => wasm.unsignedF64(-Infinity));

  assertEquals(0xFF_12345678n, wasm.signedSatF64(0xFF_12345678));
  assertEquals(-0xFF_12345678n, wasm.signedSatF64(-0xFF_12345678));
  assertEquals(0n, wasm.signedSatF64(NaN));
  assertEquals(9223372036854775807n, wasm.signedSatF64(Infinity));
  assertEquals(-9223372036854775808n, wasm.signedSatF64(-Infinity));

  assertEquals(0xFF_12345678n, wasm.unsignedSatF64(0xFF_12345678));
  assertEquals(0n, wasm.unsignedSatF64(-0xFF_12345678));
  assertEquals(0n, wasm.unsignedSatF64(NaN));
  assertEquals(-1n, wasm.unsignedSatF64(Infinity));
  assertEquals(0n, wasm.unsignedSatF64(-Infinity));
})();

(function I64ConvertFromF32() {
  print(arguments.callee.name);
  let builder = new WasmModuleBuilder();
  builder.addFunction("signedF32", makeSig([kWasmF32], [kWasmI64]))
    .addBody([
      kExprLocalGet, 0,
      kExprI64SConvertF32,
    ])
    .exportFunc();
  builder.addFunction("unsignedF32", makeSig([