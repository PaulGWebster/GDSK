LEMENTS, kFuncRefCode,
              U32V_1(3), REF_FUNC_ELEMENT(0), REF_FUNC_ELEMENT(0),
              REF_NULL_ELEMENT),
      // code ------------------------------------------------------------------
      ONE_EMPTY_BODY};
  EXPECT_VERIFIES(data);
  EXPECT_OFF_END_FAILURE(data, arraysize(data) - 5);
}

TEST_F(WasmModuleVerifyTest, PassiveElementSegmentExternRef) {
  static const uint8_t data[] = {
      // sig#0 -----------------------------------------------------------------
      TYPE_SECTION_ONE_SIG_VOID_VOID,
      // funcs -----------------------------------------------------------------
      ONE_EMPTY_FUNCTION(SIG_INDEX(0)),
      // table declaration -----------------------------------------------------
      SECTION(Table, ENTRY_COUNT(1), kFuncRefCode, kNoMaximum, 1),
      // element segments  -----------------------------------------------------
      SECTION(Element, ENTRY_COUNT(1), PASSIVE_WITH_ELEMENTS, kExternRefCode,
              U32V_1(0)),
      // code ------------------------------------------------------------------
      ONE_EMPTY_BODY};
  EXPECT_VERIFIES(data);
}

TEST_F(WasmModuleVerifyTest, PassiveElementSegmentWithIndices) {
  static const uint8_t data[] = {
      // sig#0 -----------------------------------------------------------------
      TYPE_SECTION_ONE_SIG_VOID_VOID,
      // funcs -----------------------------------------------------------------
      ONE_EMPTY_FUNCTION(SIG_INDEX(0)),
      // table declaration -----------------------------------------------------
      SECTION(Table, ENTRY_COUNT(1), kFuncRefCode, kNoMaximum, 1),
      // element segments ------------------------------------------------------
      SECTION(Element, ENTRY_COUNT(1), PASSIVE, kExternalFunction,
              ENTRY_COUNT(3), U32V_1(0), U32V_1(0), U32V_1(0)),
      // code ------------------------------------------------------------------
      ONE_EMPTY_BODY};
  EXPECT_VERIFIES(data);
  EXPECT_OFF_END_FAILURE(data, arraysize(data) - 5);
}

TEST_F(WasmModuleVerifyTest, DeclarativeElementSegmentFuncRef) {
  static const uint8_t data[] = {
      // sig#0 -----------------------------------------------------------------
      TYPE_SECTION_ONE_SIG_VOID_VOID,
      // funcs -----------------------------------------------------------------
      ONE_EMPTY_FUNCTION(SIG_INDEX(0)),
      // element segments  -----------------------------------------------------
      SECTION(Element,                    // section name
              ENTRY_COUNT(1),             // entry count
              DECLARATIVE_WITH_ELEMENTS,  // flags
              kFuncRefCode,               // local type
              U32V_1(0)),                 // func ref count
      // code ------------------------------------------------------------------
      ONE_EMPTY_BODY};
  EXPECT_VERIFIES(data);
}

TEST_F(WasmModuleVerifyTest, DeclarativeElementSegmentWithInvalidIndex) {
  static const uint8_t data[] = {
      // sig#0 -----------------------------------------------------------------
      TYPE_SECTION_ONE_SIG_VOID_VOID,
      // funcs -----------------------------------------------------------------
      ONE_EMPTY_FUNCTION(SIG_INDEX(0)),
      // element segments  -----------------------------------------------------
      SECTION(Element,            // section name
              ENTRY_COUNT(1),     // entry count
              DECLARATIVE,        // flags
              kExternalFunction,  // type
              ENTRY_COUNT(2),     // func index count
              U32V_1(0),          // func index
              U32V_1(1)),         // func index
      // code ------------------------------------------------------------------
      ONE_EMPTY_BODY};
  EXPECT_FAILURE_WITH_MSG(data, "function index 1 out of bounds");
}

TEST_F(WasmModuleVerifyTest, DataCountSectionCorrectPlacement) {
  static const uint8_t data[] = {SECTION(Element, ENTRY_COUNT(0)),
                                 SECTION(DataCount, ENTRY_COUNT(0)),
                                 SECTION(Code, ENTRY_COUNT(0))};
  EXPECT_VERIFIES(data);
}

TEST_F(WasmModuleVerifyTest, DataCountSectionAfterCode) {
  static const uint8_t data[] = {SECTION(Code, ENTRY_COUNT(0)),
                                 SECTION(DataCount, ENTRY_COUNT(0))};
  ModuleResult result = DecodeModule(base::ArrayVector(data));
  EXPECT_NOT_OK(result,
                "The DataCount section must appear before the Code section");
}

TEST_F(WasmModuleVerifyTest, DataCountSectionBeforeElement) {
  static const uint8_t data[] = {SECTION(DataCount, ENTRY_COUNT(0)),
                                 SECTION(Element, ENTRY_COUNT(0))};
  ModuleResult result = DecodeModule(base::ArrayVector(data));
  EXPECT_NOT_OK(result, "unexpected section <Element>");
}

TEST_F(WasmModuleVerifyTest, DataCountSectionAfterStartBeforeElement) {
  static_assert(kStartSectionCode + 1 == kElementSectionCode);
  static const uint8_t data[] = {
      // We need the start section for this test, but the start section must
      // reference a valid function, which requires the type and function
      // sections too.
      TYPE_SECTION(1, SIG_ENTRY_v_v),      // Type section.
      FUNCTION_SECTION(1, 0),              // Function section.
      SECTION(Start, U32V_1(0)),           // Start section.
      SECTION(DataCount, ENTRY_COUNT(0)),  // DataCount section.
      SECTION(Element, ENTRY_COUNT(0))     // Element section.
  };
  ModuleResult result = DecodeModule(base::ArrayVector(data));
  EXPECT_NOT_OK(result, "unexpected section <Element>");
}

TEST_F(WasmModuleVerifyTest, MultipleDataCountSections) {
  static const uint8_t data[] = {SECTION(DataCount, ENTRY_COUNT(0)),
                                 SECTION(DataCount, ENTRY_COUNT(0))};
  ModuleResult result = DecodeModule(base::ArrayVector(data));
  EXPECT_NOT_OK(result, "Multiple DataCount sections not allowed");
}

TEST_F(WasmModuleVerifyTest, DataCountSegmentCountMatch) {
  static const uint8_t data[] = {
      SECTION(Memory, ENTRY_COUNT(1), kNoMaximum, 1),  // Memory section.
      SECTION(DataCount, ENTRY_COUNT(1)),              // DataCount section.
      SECTION(Data, ENTRY_COUNT(1), LINEAR_MEMORY_INDEX_0,  // Data section.
              WASM_INIT_EXPR_I32V_1(12), ADD_COUNT('h', 'i'))};

  EXPECT_VERIFIES(data);
}

TEST_F(WasmModuleVerifyTest, DataCountSegmentCount_greater) {
  static const uint8_t data[] = {
      SECTION(Memory, ENTRY_COUNT(1), kNoMaximum, 1),  // Memory section.
      SECTION(DataCount, ENTRY_COUNT(3)),              // DataCount section.
      SECTION(Data, ENTRY_COUNT(0))};                  // Data section.
  ModuleResult result = DecodeModule(base::ArrayVector(data));
  EXPECT_NOT_OK(result, "data segments count 0 mismatch (3 expected)");
}

TEST_F(WasmModuleVerifyTest, DataCountSegmentCount_less) {
  static const uint8_t data[] = {
      SECTION(Memory, ENTRY_COUNT(1), kNoMaximum, 1),  // Memory section.
      SECTION(DataCount, ENTRY_COUNT(0)),              // DataCount section.
      SECTION(Data, ENTRY_COUNT(1), LINEAR_MEMORY_INDEX_0,  // Data section.
              WASM_INIT_EXPR_I32V_1(12), ADD_COUNT('a', 'b', 'c'))};
  ModuleResult result = DecodeModule(base::ArrayVector(data));
  EXPECT_NOT_OK(result, "data segments count 1 mismatch (0 expected)");
}

TEST_F(WasmModuleVerifyTest, DataCountSegmentCount_omitted) {
  static const uint8_t data[] = {SECTION(Memory, ENTRY_COUNT(1), kNoMaximum, 1),
                                 SECTION(DataCount, ENTRY_COUNT(1))};
  ModuleResult result = DecodeModule(base::ArrayVector(data));
  EXPECT_NOT_OK(result, "data segments count 0 mismatch (1 expected)");
}

TEST_F(WasmModuleVerifyTest, GcStructIdsPass) {
  static const uint8_t data[] = {SECTION(
      Type, ENTRY_COUNT(1),                         // One recursive group...
      kWasmRecursiveTypeGroupCode, ENTRY_COUNT(3),  // with three entries.
      WASM_STRUCT_DEF(FIELD_COUNT(3), STRUCT_FIELD(kI32Code, true),
                      STRUCT_FIELD(WASM_OPT_REF(0), true),
                      STRUCT_FIELD(WASM_OPT_REF(1), true)),
      WASM_STRUCT_DEF(FIELD_COUNT(2), STRUCT_FIELD(WASM_OPT_REF(0), true),
                      STRUCT_FIELD(WASM_OPT_REF(2), true)),
      WASM_ARRAY_DEF(WASM_OPT_REF(0), true))};
  ModuleResult result = DecodeModule(base::ArrayVector(data));
  EXPECT_OK(result);
}

TEST_F(WasmModuleVerifyTest, OutOfBoundsTypeInGlobal) {
  static const uint8_t data[] = {
      SECTION(Global, ENTRY_COUNT(1), kRefCode, 0, WASM_REF_NULL(0), kExprEnd)};
  ModuleResult result = DecodeModule(base::ArrayVector(data));
  EXPECT_NOT_OK(result, "Type index 0 is out of bounds");
}

TEST_F(WasmModuleVerifyTest, OutOfBoundsTypeInType) {
  static const uint8_t data[] = {SECTION(
      Type, ENTRY_COUNT(1),
      WASM_STRUCT_DEF(FIELD_COUNT(1),
                      STRUCT_FIELD(WASM_REF_TYPE(ValueType::Ref(1)), true)))};
  ModuleResult result = DecodeModule(base::ArrayVector(data));
  EXPECT_NOT_OK(result, "Type index 1 is out of bounds");
}

TEST_F(WasmModuleVerifyTest, RecursiveTypeOutsideRecursiveGroup) {
  static const uint8_t data[] = {
      SECTION(Type, ENTRY_COUNT(1),
              WASM_STRUCT_DEF(
                  FIELD_COUNT(1),
                  STRUCT_FIELD(WASM_REF_TYPE(ValueType::RefNull(0)), true)))};
  ModuleResult result = DecodeModule(base::ArrayVector(data));
  EXPECT_OK(result);
}

TEST_F(WasmModuleVerifyTest, OutOfBoundsSupertype) {
  static const uint8_t data[] = {
      SECTION(Type, ENTRY_COUNT(1), kWasmRecursiveTypeGroupCode, ENTRY_COUNT(1),
              kWasmSubtypeCode, ENTRY_COUNT(1), 1,
              WASM_STRUCT_DEF(FIELD_COUNT(1), STRUCT_FIELD(kI32Code, true)))};
  ModuleResult result = DecodeModule(base::ArrayVector(data));
  EXPECT_NOT_OK(result, "type 0: supertype 1 out of bounds");
}

TEST_F(WasmModuleVerifyTest, ForwardSupertypeSameType) {
  static const uint8_t data[] = {
      SECTION(Type, ENTRY_COUNT(1), kWasmRecursiveTypeGroupCode, ENTRY_COUNT(1),
              kWasmSubtypeCode, ENTRY_COUNT(1), 0,
              WASM_STRUCT_DEF(FIELD_COUNT(1), STRUCT_FIELD(kI32Code, true)))};
  ModuleResult result = DecodeModule(base::ArrayVector(data));
  EXPECT_NOT_OK(result, "type 0: forward-declared supertype 0");
}

TEST_F(WasmModuleVerifyTest, ForwardSupertypeSameRecGroup) {
  static const uint8_t data[] = {
      SECTION(Type, ENTRY_COUNT(1), kWasmRecursiveTypeGroupCode, ENTRY_COUNT(2),
              kWasmSubtypeCode, ENTRY_COUNT(1), 0,
              WASM_STRUCT_DEF(FIELD_COUNT(1), STRUCT_FIELD(kI32Code, true)),
              WASM_STRUCT_DEF(FIELD_COUNT(1), STRUCT_FIELD(kI32Code, true)))};
  ModuleResult result = DecodeModule(base::ArrayVector(data));
  EXPECT_NOT_OK(result, "type 0: forward-declared supertype 0");
}

TEST_F(WasmModuleVerifyTest, IllegalPackedFields) {
  static const uint8_t data[] = {
      SECTION(Global, ENTRY_COUNT(1), kI16Code, 0, WASM_INIT_EXPR_I32V_1(13))};

  ModuleResult result = DecodeModule(base::ArrayVector(data));

  EXPECT_NOT_OK(result, "invalid value type");
}

TEST_F(WasmModuleVerifyTest, Memory64DataSegment) {
  WASM_FEATURE_SCOPE(memory64);
  for (bool enable_memory64 : {false, true}) {
    for (bool use_memory64 : {false, true}) {
      uint8_t const_opcode = use_memory64 ? kExprI64Const : kExprI32Const;
      const uint8_t data[] = {
          SECTION(Memory, ENTRY_COUNT(1),
                  enable_memory64 ? kMemory64WithMaximum : kWithMaximum, 28,
                  28),
          SECTION(Data, ENTRY_COUNT(1), ACTIVE_NO_INDEX,  // -
                  const_opcode, 0, kExprEnd,              // dest addr
                  U32V_1(3),                              // source size
                  'a', 'b', 'c')                          // data bytes
      };

      if (enable_memory64 == use_memory64) {
        EXPECT_VERIFIES(data);
      } else if (enable_memory64) {
        EXPECT_FAILURE_WITH_MSG(data, "expected i64, got i32");
      } else {
        EXPECT_FAILURE_WITH_MSG(data, "expected i32, got i64");
      }
    }
  }
}

TEST_F(WasmModuleVerifyTest, InvalidSharedType) {
  // Fails if the feature is not enabled.
  const uint8_t data[] = {
      SECTION(Type, ENTRY_COUNT(1),
              WASM_STRUCT_DEF(FIELD_COUNT(1), kRefNullCode, kSharedFlagCode,
                              kAnyRefCode))};

  ModuleResult result = DecodeModule(base::ArrayVector(data));

  EXPECT_NOT_OK(
      result, "invalid heap type 0x65, enable with --experimental-wasm-shared");
}

TEST_F(WasmModuleVerifyTest, InvalidSharedGlobal) {
  // Fails if the feature is not enabled.
  const uint8_t data[] = {
      SECTION(Global, ENTRY_COUNT(1), kI32Code, 0b11, kExprI32Const, 0)};

  ModuleResult result = DecodeModule(base::ArrayVector(data));

  EXPECT_NOT_OK(
      result,
      "invalid global flags 0x3 (enable via --experimental-wasm-shared)");
}

#undef EXPECT_INIT_EXPR
#undef EXPECT_INIT_EXPR_FAIL
#undef WASM_INIT_EXPR_I32V_1
#undef WASM_INIT_EXPR_I32V_2
#undef WASM_INIT_EXPR_I32V_3
#undef WASM_INIT_EXPR_I32V_4
#undef WASM_INIT_EXPR_I32V_5
#undef WASM_INIT_EXPR_F32
#undef WASM_INIT_EXPR_I64
#undef WASM_INIT_EXPR_F64
#undef WASM_INIT_EXPR_EXTERN_REF_NULL
#undef WASM_INIT_EXPR_FUNC_REF_NULL
#undef WASM_INIT_EXPR_REF_FUNC
#undef WASM_INIT_EXPR_GLOBAL
#undef REF_NULL_ELEMENT
#undef REF_FUNC_ELEMENT
#undef EMPTY_BODY
#undef NOP_BODY
#undef SIG_ENTRY_i_i
#undef UNKNOWN_SECTION
#undef ADD_COUNT
#undef SECTION
#undef TYPE_SECTION
#undef FUNCTION_SECTION
#undef FOO_STRING
#undef NO_LOCAL_NAMES
#undef EMPTY_TYPE_SECTION
#undef EMPTY_FUNCTION_SECTION
#undef EMPTY_FUNCTION_BODIES_SECTION
#undef SECTION_NAMES
#undef EMPTY_NAMES_SECTION
#undef SECTION_SRC_MAP
#undef SECTION_COMPILATION_HINTS
#undef X1
#undef X2
#undef X3
#undef X4
#undef ONE_EMPTY_FUNCTION
#undef TWO_EMPTY_FUNCTIONS
#undef THREE_EMPTY_FUNCTIONS
#undef FOUR_EMPTY_FUNCTIONS
#undef ONE_EMPTY_BODY
#undef TWO_EMPTY_BODIES
#undef THREE_EMPTY_BODIES
#undef FOUR_EMPTY_BODIES
#undef TYPE_SECTION_ONE_SIG_VOID_VOID
#undef LINEAR_MEMORY_INDEX_0

#undef FIELD_COUNT
#undef STRUCT_FIELD
#undef WASM_REF
#undef WASM_OPT_REF
#undef WASM_STRUCT_DEF
#undef WASM_ARRAY_DEF
#undef WASM_FUNCTION_DEF
#undef EXCEPTION_ENTRY
#undef EXPECT_VERIFIES
#undef EXPECT_FAILURE_LEN
#undef EXPECT_FAILURE
#undef EXPECT_OFF_END_FAILURE
#undef EXPECT_OK
#undef EXPECT_NOT_OK

}  // namespace module_decoder_unittest
}  // namespace wasm
}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/unittests/wasm/signature-hashing-unittest.cc                               0000664 0000000 0000000 00000004637 14746647661 0025653 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/wasm/signature-hashing.h"

#include "test/unittests/test-utils.h"

namespace v8::internal::wasm::signature_hashing_unittest {

#if V8_ENABLE_SANDBOX

class WasmSignatureHashingTest : public TestWithPlatform {
 public:
  uint64_t H(std::initializer_list<ValueType> params,
             std::initializer_list<ValueType> returns) {
    const FunctionSig* sig = FunctionSig::Build(&zone_, returns, params);
    return SignatureHasher::Hash(sig);
  }

 private:
  AccountingAllocator allocator_;
  Zone zone_{&allocator_, "WasmSignatureHashingTestZone"};
};

TEST_F(WasmSignatureHashingTest, SignatureHashing) {
  ValueType i = kWasmI32;
  ValueType l = kWasmI64;
  ValueType d = kWasmF64;
  ValueType s = kWasmS128;
  ValueType r = kWasmExternRef;
  USE(l);

  std::vector<uint64_t> distinct_hashes{
      // Some simple signatures.
      H({}, {}),   // --
      H({i}, {}),  // --
      H({r}, {}),  // --
      H({}, {i}),  // --
      H({}, {r}),  // --

      // These two have the same number of parameters, but need different
      // numbers of stack slots for them. Assume that no more than 8
      // untagged params can be passed in registers; the 9th must be on the
      // stack.
      H({d, d, d, d, d, d, d, d, d}, {}),  // --
      H({d, d, d, d, d, d, d, d, s}, {}),  // --

#if V8_TARGET_ARCH_32_BIT
      // Same, but only relevant for 32-bit platforms.
      H({i, i, i, i, i, i, i, i, i}, {}),  // --
      H({i, i, i, i, i, i, i, i, l}, {}),
#endif  // V8_TARGET_ARCH_32_BIT

      // Same, but for returns. We only use 2 return registers.
      H({}, {d, d, d, d}),  // --
      H({}, {d, d, s, d}),  // --

      // These two have the same number of stack parameters, but some are
      // tagged.
      H({i, i, i, i, i, i, i, i, i, i}, {}),  // --
      H({i, i, i, i, i, i, i, i, i, r}, {}),  // --
  };

  for (size_t j = 0; j < distinct_hashes.size(); j++) {
    for (size_t k = j + 1; k < distinct_hashes.size(); k++) {
      uint64_t hash_j = distinct_hashes[j];
      uint64_t hash_k = distinct_hashes[k];
      if (hash_j == hash_k) {
        PrintF("Hash collision for signatures %zu and %zu\n", j, k);
      }
      EXPECT_NE(hash_j, hash_k);
    }
  }
}

#endif  // V8_ENABLE_SANDBOX

}  // namespace v8::internal::wasm::signature_hashing_unittest
                                                                                                 node-23.7.0/deps/v8/test/unittests/wasm/simd-shuffle-unittest.cc                                    0000664 0000000 0000000 00000050114 14746647661 0024610 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/wasm/simd-shuffle.h"

#include "test/unittests/test-utils.h"
#include "testing/gmock-support.h"

using ::testing::ElementsAre;

namespace v8 {
namespace internal {
namespace wasm {
// Helper to make calls to private wasm shuffle functions.
class SimdShuffleTest : public ::testing::Test {
 public:
  template <int Size, typename = std::enable_if_t<Size == kSimd128Size ||
                                                  Size == kSimd256Size>>
  using Shuffle = std::array<uint8_t, Size>;

  template <int Size, typename = std::enable_if_t<Size == kSimd128Size ||
                                                  Size == kSimd256Size>>
  struct TestShuffle {
    Shuffle<Size> non_canonical;
    Shuffle<Size> canonical;
    bool needs_swap;
    bool is_swizzle;
  };

  // Call testing members in wasm.
  static void CanonicalizeShuffle(bool inputs_equal,
                                  Shuffle<kSimd128Size>* shuffle,
                                  bool* needs_swap, bool* is_swizzle) {
    SimdShuffle::CanonicalizeShuffle(inputs_equal, &(*shuffle)[0], needs_swap,
                                     is_swizzle);
  }

  static bool TryMatchIdentity(const Shuffle<kSimd128Size>& shuffle) {
    return SimdShuffle::TryMatchIdentity(&shuffle[0]);
  }
  template <int LANES>
  static bool TryMatchSplat(const Shuffle<kSimd128Size>& shuffle, int* index) {
    return SimdShuffle::TryMatchSplat<LANES>(&shuffle[0], index);
  }
  static bool TryMatch64x2Shuffle(const Shuffle<kSimd128Size>& shuffle,
                                  uint8_t* shuffle64x2) {
    return SimdShuffle::TryMatch64x2Shuffle(&shuffle[0], shuffle64x2);
  }
  static bool TryMatch32x4Shuffle(const Shuffle<kSimd128Size>& shuffle,
                                  uint8_t* shuffle32x4) {
    return SimdShuffle::TryMatch32x4Shuffle(&shuffle[0], shuffle32x4);
  }
  static bool TryMatch32x8Shuffle(const Shuffle<kSimd256Size>& shuffle,
                                  uint8_t* shuffle32x8) {
    return SimdShuffle::TryMatch32x8Shuffle(&shuffle[0], shuffle32x8);
  }
  static bool TryMatch32x4Reverse(const uint8_t* shuffle32x4) {
    return SimdShuffle::TryMatch32x4Reverse(shuffle32x4);
  }
  static bool TryMatch32x4OneLaneSwizzle(const uint8_t* shuffle32x4,
                                         uint8_t* from, uint8_t* to) {
    return SimdShuffle::TryMatch32x4OneLaneSwizzle(shuffle32x4, from, to);
  }
  static bool TryMatch16x8Shuffle(const Shuffle<kSimd128Size>& shuffle,
                                  uint8_t* shuffle16x8) {
    return SimdShuffle::TryMatch16x8Shuffle(&shuffle[0], shuffle16x8);
  }
  static bool TryMatchConcat(const Shuffle<kSimd128Size>& shuffle,
                             uint8_t* offset) {
    return SimdShuffle::TryMatchConcat(&shuffle[0], offset);
  }
  static bool TryMatchBlend(const Shuffle<kSimd128Size>& shuffle) {
    return SimdShuffle::TryMatchBlend(&shuffle[0]);
  }
#ifdef V8_TARGET_ARCH_X64
  static bool TryMatchVpshufd(const uint8_t* shuffle32x8, uint8_t* control) {
    return SimdShuffle::TryMatchVpshufd(shuffle32x8, control);
  }
  static bool TryMatchShufps256(const uint8_t* shuffle32x8, uint8_t* control) {
    return SimdShuffle::TryMatchShufps256(shuffle32x8, control);
  }
#endif  // V8_TARGET_ARCH_X64
};

template <int Size, typename = std::enable_if_t<Size == kSimd128Size ||
                                                Size == kSimd256Size>>
bool operator==(const SimdShuffleTest::Shuffle<Size>& a,
                const SimdShuffleTest::Shuffle<Size>& b) {
  for (int i = 0; i < Size; ++i) {
    if (a[i] != b[i]) return false;
  }
  return true;
}

TEST_F(SimdShuffleTest, CanonicalizeShuffle) {
  const bool kInputsEqual = true;
  const bool kNeedsSwap = true;
  const bool kIsSwizzle = true;

  bool needs_swap;
  bool is_swizzle;

  // Test canonicalization driven by input shuffle.
  TestShuffle<kSimd128Size> test_shuffles[] = {
      // Identity is canonical.
      {{{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}},
       {{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}},
       !kNeedsSwap,
       kIsSwizzle},
      // Non-canonical identity requires a swap.
      {{{16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31}},
       {{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}},
       kNeedsSwap,
       kIsSwizzle},
      // General shuffle, canonical is unchanged.
      {{{0, 16, 1, 17, 2, 18, 3, 19, 4, 20, 5, 21, 6, 22, 7, 23}},
       {{0, 16, 1, 17, 2, 18, 3, 19, 4, 20, 5, 21, 6, 22, 7, 23}},
       !kNeedsSwap,
       !kIsSwizzle},
      // Non-canonical shuffle requires a swap.
      {{{16, 0, 17, 1, 18, 2, 19, 3, 20, 4, 21, 5, 22, 6, 23, 7}},
       {{0, 16, 1, 17, 2, 18, 3, 19, 4, 20, 5, 21, 6, 22, 7, 23}},
       kNeedsSwap,
       !kIsSwizzle},
  };
  for (size_t i = 0; i < arraysize(test_shuffles); ++i) {
    Shuffle<kSimd128Size> shuffle = test_shuffles[i].non_canonical;
    CanonicalizeShuffle(!kInputsEqual, &shuffle, &needs_swap, &is_swizzle);
    EXPECT_EQ(shuffle, test_shuffles[i].canonical);
    EXPECT_EQ(needs_swap, test_shuffles[i].needs_swap);
    EXPECT_EQ(is_swizzle, test_shuffles[i].is_swizzle);
  }

  // Test canonicalization when inputs are equal (explicit swizzle).
  TestShuffle<kSimd128Size> test_swizzles[] = {
      // Identity is canonical.
      {{{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}},
       {{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}},
       !kNeedsSwap,
       kIsSwizzle},
      // Non-canonical identity requires a swap.
      {{{16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31}},
       {{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}},
       !kNeedsSwap,
       kIsSwizzle},
      // Canonicalized to swizzle.
      {{{0, 16, 1, 17, 2, 18, 3, 19, 4, 20, 5, 21, 6, 22, 7, 23}},
       {{0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7}},
       !kNeedsSwap,
       kIsSwizzle},
      // Canonicalized to swizzle.
      {{{16, 0, 17, 1, 18, 2, 19, 3, 20, 4, 21, 5, 22, 6, 23, 7}},
       {{0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7}},
       !kNeedsSwap,
       kIsSwizzle},
  };
  for (size_t i = 0; i < arraysize(test_swizzles); ++i) {
    Shuffle<kSimd128Size> shuffle = test_swizzles[i].non_canonical;
    CanonicalizeShuffle(kInputsEqual, &shuffle, &needs_swap, &is_swizzle);
    EXPECT_EQ(shuffle, test_swizzles[i].canonical);
    EXPECT_EQ(needs_swap, test_swizzles[i].needs_swap);
    EXPECT_EQ(is_swizzle, test_swizzles[i].is_swizzle);
  }
}

TEST_F(SimdShuffleTest, TryMatchIdentity) {
  // Match shuffle that returns first source operand.
  EXPECT_TRUE(TryMatchIdentity(
      {{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}}));
  // The non-canonicalized identity shuffle doesn't match.
  EXPECT_FALSE(TryMatchIdentity(
      {{16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31}}));
  // Even one lane out of place is not an identity shuffle.
  EXPECT_FALSE(TryMatchIdentity(
      {{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 31}}));
}

TEST_F(SimdShuffleTest, TryMatchSplat) {
  int index;
  // All lanes from the same 32 bit source lane.
  EXPECT_TRUE(TryMatchSplat<4>(
      {{4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7}}, &index));
  EXPECT_EQ(1, index);
  // It shouldn't match for other vector shapes.
  EXPECT_FALSE(TryMatchSplat<8>(
      {{4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7}}, &index));
  EXPECT_FALSE(TryMatchSplat<16>(
      {{4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7, 4, 5, 6, 7}}, &index));
  // All lanes from the same 16 bit source lane.
  EXPECT_TRUE(TryMatchSplat<8>(
      {{16, 17, 16, 17, 16, 17, 16, 17, 16, 17, 16, 17, 16, 17, 16, 17}},
      &index));
  EXPECT_EQ(8, index);
  // It shouldn't match for other vector shapes.
  EXPECT_FALSE(TryMatchSplat<4>(
      {{16, 17, 16, 17, 16, 17, 16, 17, 16, 17, 16, 17, 16, 17, 16, 17}},
      &index));
  EXPECT_FALSE(TryMatchSplat<16>(
      {{16, 17, 16, 17, 16, 17, 16, 17, 16, 17, 16, 17, 16, 17, 16, 17}},
      &index));
  // All lanes from the same 8 bit source lane.
  EXPECT_TRUE(TryMatchSplat<16>(
      {{7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7}}, &index));
  EXPECT_EQ(7, index);
  // It shouldn't match for other vector shapes.
  EXPECT_FALSE(TryMatchSplat<4>(
      {{7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7}}, &index));
  EXPECT_FALSE(TryMatchSplat<8>(
      {{7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7}}, &index));
}

TEST_F(SimdShuffleTest, TryMatchConcat) {
  uint8_t offset;
  // Ascending indices, jump at end to same input (concatenating swizzle).
  EXPECT_TRUE(TryMatchConcat(
      {{3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2}}, &offset));
  EXPECT_EQ(3, offset);
  // Ascending indices, jump at end to other input (concatenating shuffle).
  EXPECT_TRUE(TryMatchConcat(
      {{4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19}}, &offset));
  EXPECT_EQ(4, offset);

  // Shuffles that should not match:
  // Ascending indices, but jump isn't at end/beginning.
  EXPECT_FALSE(TryMatchConcat(
      {{3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5, 6}}, &offset));
  // Ascending indices, but multiple jumps.
  EXPECT_FALSE(TryMatchConcat(
      {{0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3}}, &offset));
}

TEST_F(SimdShuffleTest, TryMatch32x4Shuffle) {
  uint8_t shuffle32x4[4];
  // Match if each group of 4 bytes is from the same 32 bit lane.
  EXPECT_TRUE(TryMatch32x4Shuffle(
      {{12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 16, 17, 18, 19}},
      shuffle32x4));
  EXPECT_EQ(3, shuffle32x4[0]);
  EXPECT_EQ(2, shuffle32x4[1]);
  EXPECT_EQ(1, shuffle32x4[2]);
  EXPECT_EQ(4, shuffle32x4[3]);
  // Bytes must be in order in the 32 bit lane.
  EXPECT_FALSE(TryMatch32x4Shuffle(
      {{12, 13, 14, 14, 8, 9, 10, 11, 4, 5, 6, 7, 16, 17, 18, 19}},
      shuffle32x4));
  // Each group must start with the first byte in the 32 bit lane.
  EXPECT_FALSE(TryMatch32x4Shuffle(
      {{13, 14, 15, 12, 8, 9, 10, 11, 4, 5, 6, 7, 16, 17, 18, 19}},
      shuffle32x4));
}

TEST_F(SimdShuffleTest, TryMatch32x8Shuffle) {
  uint8_t shuffle32x8[8];
  // Match if each group of 4 bytes is from the same 32 bit lane.
  EXPECT_TRUE(TryMatch32x8Shuffle(
      {{12, 13, 14, 15, 8,  9,  10, 11, 4,  5,  6,  7,  16, 17, 18, 19,
        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0,  1,  2,  3}},
      shuffle32x8));
  EXPECT_EQ(3, shuffle32x8[0]);
  EXPECT_EQ(2, shuffle32x8[1]);
  EXPECT_EQ(1, shuffle32x8[2]);
  EXPECT_EQ(4, shuffle32x8[3]);
  EXPECT_EQ(5, shuffle32x8[4]);
  EXPECT_EQ(6, shuffle32x8[5]);
  EXPECT_EQ(7, shuffle32x8[6]);
  EXPECT_EQ(0, shuffle32x8[7]);
  // Bytes must be in order in the 32 bit lane.
  EXPECT_FALSE(TryMatch32x8Shuffle(
      {{12, 13, 14, 14, 8,  9,  10, 11, 4,  5,  6,  7,  16, 17, 18, 19,
        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0,  1,  2,  3}},
      shuffle32x8));
  // Each group must start with the first byte in the 32 bit lane.
  EXPECT_FALSE(TryMatch32x8Shuffle(
      {{13, 14, 15, 12, 8,  9,  10, 11, 4,  5,  6,  7,  16, 17, 18, 19,
        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 0,  1,  2,  3}},
      shuffle32x8));
}

TEST_F(SimdShuffleTest, TryMatch32x4Reverse) {
  uint8_t shuffle32x4[4];
  // low
  EXPECT_TRUE(TryMatch32x4Shuffle(
      {{12, 13, 14, 15, 8, 9, 10, 11, 4, 5, 6, 7, 0, 1, 2, 3}}, shuffle32x4));
  EXPECT_EQ(3, shuffle32x4[0]);
  EXPECT_EQ(2, shuffle32x4[1]);
  EXPECT_EQ(1, shuffle32x4[2]);
  EXPECT_EQ(0, shuffle32x4[3]);
  EXPECT_TRUE(TryMatch32x4Reverse(shuffle32x4));

  // high
  Shuffle<kSimd128Size> high_rev = {28, 29, 30, 31, 24, 25, 26, 27,
                                    20, 21, 22, 23, 16, 17, 18, 19};
  EXPECT_TRUE(TryMatch32x4Shuffle(high_rev, shuffle32x4));
  EXPECT_EQ(7, shuffle32x4[0]);
  EXPECT_EQ(6, shuffle32x4[1]);
  EXPECT_EQ(5, shuffle32x4[2]);
  EXPECT_EQ(4, shuffle32x4[3]);

  bool needs_swap = false;
  bool is_swizzle = false;
  CanonicalizeShuffle(false, &high_rev, &needs_swap, &is_swizzle);
  EXPECT_TRUE(needs_swap);
  EXPECT_TRUE(is_swizzle);
  EXPECT_TRUE(TryMatch32x4Shuffle(high_rev, shuffle32x4));
  EXPECT_TRUE(TryMatch32x4Reverse(shuffle32x4));
}

TEST_F(SimdShuffleTest, TryMatch32x4OneLaneSwizzle) {
  uint8_t shuffle32x4[4];
  uint8_t from = 0;
  uint8_t to = 0;
  // low
  EXPECT_TRUE(TryMatch32x4Shuffle(
      {{12, 13, 14, 15, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}},
      shuffle32x4));
  EXPECT_EQ(3, shuffle32x4[0]);
  EXPECT_EQ(1, shuffle32x4[1]);
  EXPECT_EQ(2, shuffle32x4[2]);
  EXPECT_EQ(3, shuffle32x4[3]);
  EXPECT_TRUE(TryMatch32x4OneLaneSwizzle(shuffle32x4, &from, &to));
  EXPECT_EQ(from, 3);
  EXPECT_EQ(to, 0);

  // high
  Shuffle<kSimd128Size> high_one = {16, 17, 18, 19, 20, 21, 22, 23,
                                    20, 21, 22, 23, 28, 29, 30, 31};
  EXPECT_TRUE(TryMatch32x4Shuffle(high_one, shuffle32x4));
  EXPECT_EQ(4, shuffle32x4[0]);
  EXPECT_EQ(5, shuffle32x4[1]);
  EXPECT_EQ(5, shuffle32x4[2]);
  EXPECT_EQ(7, shuffle32x4[3]);

  bool needs_swap = false;
  bool is_swizzle = false;
  CanonicalizeShuffle(false, &high_one, &needs_swap, &is_swizzle);
  EXPECT_TRUE(needs_swap);
  EXPECT_TRUE(is_swizzle);
  EXPECT_TRUE(TryMatch32x4Shuffle(high_one, shuffle32x4));
  EXPECT_TRUE(TryMatch32x4OneLaneSwizzle(shuffle32x4, &from, &to));
  EXPECT_EQ(from, 1);
  EXPECT_EQ(to, 2);
}

TEST_F(SimdShuffleTest, TryMatch16x8Shuffle) {
  uint8_t shuffle16x8[8];
  // Match if each group of 2 bytes is from the same 16 bit lane.
  EXPECT_TRUE(TryMatch16x8Shuffle(
      {{12, 13, 30, 31, 8, 9, 26, 27, 4, 5, 22, 23, 16, 17, 2, 3}},
      shuffle16x8));
  EXPECT_EQ(6, shuffle16x8[0]);
  EXPECT_EQ(15, shuffle16x8[1]);
  EXPECT_EQ(4, shuffle16x8[2]);
  EXPECT_EQ(13, shuffle16x8[3]);
  EXPECT_EQ(2, shuffle16x8[4]);
  EXPECT_EQ(11, shuffle16x8[5]);
  EXPECT_EQ(8, shuffle16x8[6]);
  EXPECT_EQ(1, shuffle16x8[7]);
  // Bytes must be in order in the 16 bit lane.
  EXPECT_FALSE(TryMatch16x8Shuffle(
      {{12, 13, 30, 30, 8, 9, 26, 27, 4, 5, 22, 23, 16, 17, 2, 3}},
      shuffle16x8));
  // Each group must start with the first byte in the 16 bit lane.
  EXPECT_FALSE(TryMatch16x8Shuffle(
      {{12, 13, 31, 30, 8, 9, 26, 27, 4, 5, 22, 23, 16, 17, 2, 3}},
      shuffle16x8));
}

TEST_F(SimdShuffleTest, TryMatchBlend) {
  // Match if each byte remains in place.
  EXPECT_TRUE(TryMatchBlend(
      {{0, 17, 2, 19, 4, 21, 6, 23, 8, 25, 10, 27, 12, 29, 14, 31}}));
  // Identity is a blend.
  EXPECT_TRUE(
      TryMatchBlend({{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15}}));
  // Even one lane out of place is not a blend.
  EXPECT_FALSE(TryMatchBlend(
      {{1, 17, 2, 19, 4, 21, 6, 23, 8, 25, 10, 27, 12, 29, 14, 31}}));
}

TEST_F(SimdShuffleTest, PairwiseReduce) {
  uint8_t shuffle64x2[2];
  EXPECT_TRUE(TryMatch64x2Shuffle(
      {{8, 9, 10, 11, 12, 13, 14, 15, 0, 1, 2, 3, 4, 5, 6, 7}}, shuffle64x2));
  EXPECT_TRUE(SimdShuffle::TryMatch64x2Reduce(shuffle64x2));

  constexpr uint8_t pairwise_32x4[] = {4,  5,  6,  7,  0, 1, 2, 3,
                                       12, 13, 14, 15, 0, 1, 2, 3};
  constexpr uint8_t pairwise_32x2[] = {8, 9, 10, 11, 0, 1, 2, 3,
                                       0, 1, 2,  3,  0, 1, 2, 3};
  EXPECT_TRUE(
      SimdShuffle::TryMatch32x4PairwiseReduce(pairwise_32x4, pairwise_32x2));
}

TEST_F(SimdShuffleTest, UpperToLowerReduce) {
  constexpr uint8_t upper_to_lower_32x4[] = {8, 9, 10, 11, 12, 13, 14, 15,
                                             0, 1, 2,  3,  0,  1,  2,  3};
  constexpr uint8_t upper_to_lower_32x2[] = {4, 5, 6, 7, 0, 1, 2, 3,
                                             0, 1, 2, 3, 0, 1, 2, 3};
  EXPECT_TRUE(SimdShuffle::TryMatch32x4UpperToLowerReduce(upper_to_lower_32x4,
                                                          upper_to_lower_32x2));

  constexpr uint8_t upper_to_lower_16x8[] = {8, 9, 10, 11, 12, 13, 14, 15, 0,
                                             1, 0, 1,  0,  1,  0,  1,  0};
  constexpr uint8_t upper_to_lower_16x4[] = {4, 5, 6, 7, 0, 1, 0, 1,
                                             0, 1, 0, 1, 0, 1, 0, 1};
  constexpr uint8_t upper_to_lower_16x2[] = {2, 3, 0, 1, 0, 1, 0, 1,
                                             0, 1, 0, 1, 0, 1, 0, 1};
  EXPECT_TRUE(SimdShuffle::TryMatch16x8UpperToLowerReduce(
      upper_to_lower_16x8, upper_to_lower_16x4, upper_to_lower_16x2));

  constexpr uint8_t upper_to_lower_8x16[] = {8, 9, 10, 11, 12, 13, 14, 15, 0,
                                             1, 0, 1,  0,  1,  0,  1,  0};
  constexpr uint8_t upper_to_lower_8x8[] = {4, 5, 6, 7, 0, 1, 0, 1,
                                            0, 1, 0, 1, 0, 1, 0, 1};
  constexpr uint8_t upper_to_lower_8x4[] = {2, 3, 0, 1, 0, 1, 0, 1,
                                            0, 1, 0, 1, 0, 1, 0, 1};
  constexpr uint8_t upper_to_lower_8x2[] = {1, 0, 0, 1, 0, 1, 0, 1,
                                            0, 1, 0, 1, 0, 1, 0, 1};
  EXPECT_TRUE(SimdShuffle::TryMatch8x16UpperToLowerReduce(
      upper_to_lower_8x16, upper_to_lower_8x8, upper_to_lower_8x4,
      upper_to_lower_8x2));
}

TEST_F(SimdShuffleTest, Shuffle64x2) {
  constexpr uint8_t identity_64x2[] = {0, 1, 2,  3,  4,  5,  6,  7,
                                       8, 9, 10, 11, 12, 13, 14, 15};
  uint8_t shuffle64x2[2];
  EXPECT_TRUE(SimdShuffle::TryMatch64x2Shuffle(identity_64x2, shuffle64x2));
  EXPECT_EQ(shuffle64x2[0], 0);
  EXPECT_EQ(shuffle64x2[1], 1);

  constexpr uint8_t rev_64x2[] = {8, 9, 10, 11, 12, 13, 14, 15,
                                  0, 1, 2,  3,  4,  5,  6,  7};
  EXPECT_TRUE(SimdShuffle::TryMatch64x2Shuffle(rev_64x2, shuffle64x2));
  EXPECT_EQ(shuffle64x2[0], 1);
  EXPECT_EQ(shuffle64x2[1], 0);

  constexpr uint8_t dup0_64x2[] = {0, 1, 2, 3, 4, 5, 6, 7,
                                   0, 1, 2, 3, 4, 5, 6, 7};
  EXPECT_TRUE(SimdShuffle::TryMatch64x2Shuffle(dup0_64x2, shuffle64x2));
  EXPECT_EQ(shuffle64x2[0], 0);
  EXPECT_EQ(shuffle64x2[1], 0);

  constexpr uint8_t dup1_64x2[] = {8, 9, 10, 11, 12, 13, 14, 15,
                                   8, 9, 10, 11, 12, 13, 14, 15};
  EXPECT_TRUE(SimdShuffle::TryMatch64x2Shuffle(dup1_64x2, shuffle64x2));
  EXPECT_EQ(shuffle64x2[0], 1);
  EXPECT_EQ(shuffle64x2[1], 1);
}

TEST(SimdShufflePackTest, PackShuffle4) {
  uint8_t arr[4]{0b0001, 0b0010, 0b0100, 0b1000};
  EXPECT_EQ(0b00001001, SimdShuffle::PackShuffle4(arr));
}

TEST(SimdShufflePackTest, PackBlend8) {
  uint8_t arr[8]{0, 2, 4, 6, 8, 10, 12, 14};
  EXPECT_EQ(0b11110000, SimdShuffle::PackBlend8(arr));
}

TEST(SimdShufflePackTest, PackBlend4) {
  uint8_t arr[4]{0, 2, 4, 6};
  EXPECT_EQ(0b11110000, SimdShuffle::PackBlend4(arr));
}

TEST(SimdShufflePackTest, Pack4Lanes) {
  uint8_t arr[4]{0x01, 0x08, 0xa0, 0x7c};
  EXPECT_EQ(0x7ca00801, SimdShuffle::Pack4Lanes(arr));
}

TEST(SimdShufflePackTest, Pack16Lanes) {
  uint8_t arr[16]{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
  uint32_t imms[4]{0};
  SimdShuffle::Pack16Lanes(imms, arr);
  EXPECT_THAT(imms,
              ElementsAre(0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c));
}

#ifdef V8_TARGET_ARCH_X64
TEST_F(SimdShuffleTest, TryMatchVpshufd) {
  uint8_t shuffle32x8[8];
  EXPECT_TRUE(TryMatch32x8Shuffle(
      {{12, 13, 14, 15, 8,  9,  10, 11, 4,  5,  6,  7,  0,  1,  2,  3,
        28, 29, 30, 31, 24, 25, 26, 27, 20, 21, 22, 23, 16, 17, 18, 19}},
      shuffle32x8));

  EXPECT_EQ(shuffle32x8[0], 3);
  EXPECT_EQ(shuffle32x8[1], 2);
  EXPECT_EQ(shuffle32x8[2], 1);
  EXPECT_EQ(shuffle32x8[3], 0);
  EXPECT_EQ(shuffle32x8[4], 7);
  EXPECT_EQ(shuffle32x8[5], 6);
  EXPECT_EQ(shuffle32x8[6], 5);
  EXPECT_EQ(shuffle32x8[7], 4);

  uint8_t control;
  EXPECT_TRUE(TryMatchVpshufd(shuffle32x8, &control));
  EXPECT_EQ(control, 0b00'01'10'11);
}

TEST_F(SimdShuffleTest, TryMatchShufps256) {
  uint8_t shuffle32x8[8];
  EXPECT_TRUE(TryMatch32x8Shuffle(
      {{12, 13, 14, 15, 8,  9,  10, 11, 36, 37, 38, 39, 32, 33, 34, 35,
        28, 29, 30, 31, 24, 25, 26, 27, 52, 53, 54, 55, 48, 49, 50, 51}},
      shuffle32x8));
  EXPECT_EQ(shuffle32x8[0], 3);
  EXPECT_EQ(shuffle32x8[1], 2);
  EXPECT_EQ(shuffle32x8[2], 9);
  EXPECT_EQ(shuffle32x8[3], 8);
  EXPECT_EQ(shuffle32x8[4], 7);
  EXPECT_EQ(shuffle32x8[5], 6);
  EXPECT_EQ(shuffle32x8[6], 13);
  EXPECT_EQ(shuffle32x8[7], 12);

  uint8_t control;
  EXPECT_TRUE(TryMatchShufps256(shuffle32x8, &control));
  EXPECT_EQ(control, 0b00'01'10'11);
}

#endif  // V8_TARGET_ARCH_X64

}  // namespace wasm
}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/test/unittests/wasm/streaming-decoder-unittest.cc                               0000664 0000000 0000000 00000054135 14746647661 0025625 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "test/unittests/test-utils.h"

#include "src/objects/objects-inl.h"

#include "src/wasm/module-decoder.h"
#include "src/wasm/streaming-decoder.h"

#include "src/objects/descriptor-array.h"
#include "src/objects/dictionary.h"
#include "test/common/wasm/wasm-macro-gen.h"

namespace v8 {
namespace internal {
namespace wasm {

struct MockStreamingResult {
  size_t num_sections = 0;
  size_t num_functions = 0;
  bool error;
  base::OwnedVector<const uint8_t> received_bytes;

  bool ok() const { return !error; }

  MockStreamingResult() = default;
};

class NoTracer {
 public:
  void Bytes(const uint8_t* start, uint32_t count) {}
  void Description(const char* desc) {}
};

class MockStreamingProcessor : public StreamingProcessor {
 public:
  explicit MockStreamingProcessor(MockStreamingResult* result)
      : result_(result) {}

  bool ProcessModuleHeader(base::Vector<const uint8_t> bytes) override {
    Decoder decoder(bytes.begin(), bytes.end());
    uint32_t magic_word = decoder.consume_u32("wasm magic", ITracer::NoTrace);
    if (decoder.failed() || magic_word != kWasmMagic) {
      result_->error = WasmError(0, "expected wasm magic");
      return false;
    }
    uint32_t magic_version =
        decoder.consume_u32("wasm version", ITracer::NoTrace);
    if (decoder.failed() || magic_version != kWasmVersion) {
      result_->error = WasmError(4, "expected wasm version");
      return false;
    }
    return true;
  }

  // Process all sections but the code section.
  bool ProcessSection(SectionCode section_code,
                      base::Vector<const uint8_t> bytes,
                      uint32_t offset) override {
    ++result_->num_sections;
    return true;
  }

  bool ProcessCodeSectionHeader(int num_functions, uint32_t offset,
                                std::shared_ptr<WireBytesStorage>,
                                int code_section_start,
                                int code_section_length) override {
    return true;
  }

  // Process a function body.
  bool ProcessFunctionBody(base::Vector<const uint8_t> bytes,
                           uint32_t offset) override {
    ++result_->num_functions;
    return true;
  }

  void OnFinishedChunk() override {}

  // Finish the processing of the stream.
  void OnFinishedStream(base::OwnedVector<const uint8_t> bytes,
                        bool after_error) override {
    result_->received_bytes = std::move(bytes);
    result_->error = after_error;
  }

  void OnAbort() override {}

  bool Deserialize(base::Vector<const uint8_t> module_bytes,
                   base::Vector<const uint8_t> wire_bytes) override {
    return false;
  }

 private:
  MockStreamingResult* const result_;
};

class WasmStreamingDecoderTest : public ::testing::Test {
 public:
  void ExpectVerifies(base::Vector<const uint8_t> data,
                      size_t expected_sections, size_t expected_functions) {
    for (int split = 0; split <= data.length(); ++split) {
      MockStreamingResult result;
      auto stream = StreamingDecoder::CreateAsyncStreamingDecoder(
          std::make_unique<MockStreamingProcessor>(&result));
      stream->OnBytesReceived(data.SubVector(0, split));
      stream->OnBytesReceived(data.SubVector(split, data.length()));
      stream->Finish();
      EXPECT_TRUE(result.ok());
      EXPECT_EQ(expected_sections, result.num_sections);
      EXPECT_EQ(expected_functions, result.num_functions);
      EXPECT_EQ(data, result.received_bytes.as_vector());
    }
  }

  void ExpectFailure(base::Vector<const uint8_t> data) {
    for (int split = 0; split <= data.length(); ++split) {
      MockStreamingResult result;
      auto stream = StreamingDecoder::CreateAsyncStreamingDecoder(
          std::make_unique<MockStreamingProcessor>(&result));
      stream->OnBytesReceived(data.SubVector(0, split));
      stream->OnBytesReceived(data.SubVector(split, data.length()));
      stream->Finish();
      EXPECT_FALSE(result.ok());
      EXPECT_TRUE(result.error);
    }
  }
};

TEST_F(WasmStreamingDecoderTest, EmptyStream) {
  MockStreamingResult result;
  auto stream = StreamingDecoder::CreateAsyncStreamingDecoder(
      std::make_unique<MockStreamingProcessor>(&result));
  stream->Finish();
  EXPECT_FALSE(result.ok());
}

TEST_F(WasmStreamingDecoderTest, IncompleteModuleHeader) {
  const uint8_t data[] = {U32_LE(kWasmMagic), U32_LE(kWasmVersion)};
  {
    MockStreamingResult result;
    auto stream = StreamingDecoder::CreateAsyncStreamingDecoder(
        std::make_unique<MockStreamingProcessor>(&result));
    stream->OnBytesReceived(base::VectorOf(data, 1));
    stream->Finish();
    EXPECT_FALSE(result.ok());
  }
  for (uint32_t length = 1; length < sizeof(data); ++length) {
    ExpectFailure(base::VectorOf(data, length));
  }
}

TEST_F(WasmStreamingDecoderTest, MagicAndVersion) {
  const uint8_t data[] = {U32_LE(kWasmMagic), U32_LE(kWasmVersion)};
  ExpectVerifies(base::ArrayVector(data), 0, 0);
}

TEST_F(WasmStreamingDecoderTest, BadMagic) {
  for (uint32_t x = 1; x; x <<= 1) {
    const uint8_t data[] = {U32_LE(kWasmMagic ^ x), U32_LE(kWasmVersion)};
    ExpectFailure(base::ArrayVector(data));
  }
}

TEST_F(WasmStreamingDecoderTest, BadVersion) {
  for (uint32_t x = 1; x; x <<= 1) {
    const uint8_t data[] = {U32_LE(kWasmMagic), U32_LE(kWasmVersion ^ x)};
    ExpectFailure(base::ArrayVector(data));
  }
}

TEST_F(WasmStreamingDecoderTest, OneSection) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      0x1,                   // Section ID
      0x6,                   // Section Length
      0x0,                   // Payload
      0x0,                   // 2
      0x0,                   // 3
      0x0,                   // 4
      0x0,                   // 5
      0x0                    // 6
  };
  ExpectVerifies(base::ArrayVector(data), 1, 0);
}

TEST_F(WasmStreamingDecoderTest, OneSection_b) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      0x1,                   // Section ID
      0x86,                  // Section Length = 6 (LEB)
      0x0,                   // --
      0x0,                   // Payload
      0x0,                   // 2
      0x0,                   // 3
      0x0,                   // 4
      0x0,                   // 5
      0x0                    // 6
  };
  ExpectVerifies(base::ArrayVector(data), 1, 0);
}

TEST_F(WasmStreamingDecoderTest, OneShortSection) {
  // Short section means that section length + payload is less than 5 bytes,
  // which is the maximum size of the length field.
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      0x1,                   // Section ID
      0x2,                   // Section Length
      0x0,                   // Payload
      0x0                    // 2
  };
  ExpectVerifies(base::ArrayVector(data), 1, 0);
}

TEST_F(WasmStreamingDecoderTest, OneShortSection_b) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      0x1,                   // Section ID
      0x82,                  // Section Length = 2 (LEB)
      0x80,                  // --
      0x0,                   // --
      0x0,                   // Payload
      0x0                    // 2
  };
  ExpectVerifies(base::ArrayVector(data), 1, 0);
}

TEST_F(WasmStreamingDecoderTest, OneEmptySection) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      0x1,                   // Section ID
      0x0                    // Section Length
  };
  ExpectVerifies(base::ArrayVector(data), 1, 0);
}

TEST_F(WasmStreamingDecoderTest, OneSectionNotEnoughPayload1) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      0x1,                   // Section ID
      0x6,                   // Section Length
      0x0,                   // Payload
      0x0,                   // 2
      0x0,                   // 3
      0x0,                   // 4
      0x0                    // 5
  };
  ExpectFailure(base::ArrayVector(data));
}

TEST_F(WasmStreamingDecoderTest, OneSectionNotEnoughPayload2) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      0x1,                   // Section ID
      0x6,                   // Section Length
      0x0                    // Payload
  };
  ExpectFailure(base::ArrayVector(data));
}

TEST_F(WasmStreamingDecoderTest, OneSectionInvalidLength) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      0x1,                   // Section ID
      0x80,                  // Section Length (invalid LEB)
      0x80,                  // --
      0x80,                  // --
      0x80,                  // --
      0x80,                  // --
  };
  ExpectFailure(base::ArrayVector(data));
}

TEST_F(WasmStreamingDecoderTest, TwoLongSections) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      0x1,                   // Section ID
      0x6,                   // Section Length
      0x0,                   // Payload
      0x0,                   // 2
      0x0,                   // 3
      0x0,                   // 4
      0x0,                   // 5
      0x0,                   // 6
      0x2,                   // Section ID
      0x7,                   // Section Length
      0x0,                   // Payload
      0x0,                   // 2
      0x0,                   // 3
      0x0,                   // 4
      0x0,                   // 5
      0x0,                   // 6
      0x0                    // 7
  };
  ExpectVerifies(base::ArrayVector(data), 2, 0);
}

TEST_F(WasmStreamingDecoderTest, TwoShortSections) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      0x1,                   // Section ID
      0x1,                   // Section Length
      0x0,                   // Payload
      0x2,                   // Section ID
      0x2,                   // Section Length
      0x0,                   // Payload
      0x0,                   // 2
  };
  ExpectVerifies(base::ArrayVector(data), 2, 0);
}

TEST_F(WasmStreamingDecoderTest, TwoSectionsShortLong) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      0x1,                   // Section ID
      0x1,                   // Section Length
      0x0,                   // Payload
      0x2,                   // Section ID
      0x7,                   // Section Length
      0x0,                   // Payload
      0x0,                   // 2
      0x0,                   // 3
      0x0,                   // 4
      0x0,                   // 5
      0x0,                   // 6
      0x0                    // 7
  };
  ExpectVerifies(base::ArrayVector(data), 2, 0);
}

TEST_F(WasmStreamingDecoderTest, TwoEmptySections) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      0x1,                   // Section ID
      0x0,                   // Section Length
      0x2,                   // Section ID
      0x0                    // Section Length
  };
  ExpectVerifies(base::ArrayVector(data), 2, 0);
}

TEST_F(WasmStreamingDecoderTest, OneFunction) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      kCodeSectionCode,      // Section ID
      0x8,                   // Section Length
      0x1,                   // Number of Functions
      0x6,                   // Function Length
      0x0,                   // Function
      0x0,                   // 2
      0x0,                   // 3
      0x0,                   // 4
      0x0,                   // 5
      0x0,                   // 6
  };
  ExpectVerifies(base::ArrayVector(data), 0, 1);
}

TEST_F(WasmStreamingDecoderTest, OneShortFunction) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      kCodeSectionCode,      // Section ID
      0x3,                   // Section Length
      0x1,                   // Number of Functions
      0x1,                   // Function Length
      0x0,                   // Function
  };
  ExpectVerifies(base::ArrayVector(data), 0, 1);
}

TEST_F(WasmStreamingDecoderTest, EmptyFunction) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      kCodeSectionCode,      // Section ID
      0x2,                   // Section Length
      0x1,                   // Number of Functions
      0x0,                   // Function Length  -- ERROR
  };
  ExpectFailure(base::ArrayVector(data));
}

TEST_F(WasmStreamingDecoderTest, TwoFunctions) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      kCodeSectionCode,      // Section ID
      0x10,                  // Section Length
      0x2,                   // Number of Functions
      0x6,                   // Function Length
      0x0,                   // Function
      0x0,                   // 2
      0x0,                   // 3
      0x0,                   // 4
      0x0,                   // 5
      0x0,                   // 6
      0x7,                   // Function Length
      0x0,                   // Function
      0x0,                   // 2
      0x0,                   // 3
      0x0,                   // 4
      0x0,                   // 5
      0x0,                   // 6
      0x0,                   // 7
  };
  ExpectVerifies(base::ArrayVector(data), 0, 2);
}

TEST_F(WasmStreamingDecoderTest, TwoFunctions_b) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      kCodeSectionCode,      // Section ID
      0xB,                   // Section Length
      0x2,                   // Number of Functions
      0x1,                   // Function Length
      0x0,                   // Function
      0x7,                   // Function Length
      0x0,                   // Function
      0x0,                   // 2
      0x0,                   // 3
      0x0,                   // 4
      0x0,                   // 5
      0x0,                   // 6
      0x0,                   // 7
  };
  ExpectVerifies(base::ArrayVector(data), 0, 2);
}

TEST_F(WasmStreamingDecoderTest, CodeSectionLengthZero) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      kCodeSectionCode,      // Section ID
      0x0,                   // Section Length
  };
  ExpectFailure(base::ArrayVector(data));
}

TEST_F(WasmStreamingDecoderTest, CodeSectionLengthTooHigh) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      kCodeSectionCode,      // Section ID
      0xD,                   // Section Length
      0x2,                   // Number of Functions
      0x7,                   // Function Length
      0x0,                   // Function
      0x0,                   // 2
      0x0,                   // 3
      0x0,                   // 4
      0x0,                   // 5
      0x0,                   // 6
      0x0,                   // 7
      0x1,                   // Function Length
      0x0,                   // Function
  };
  ExpectFailure(base::ArrayVector(data));
}

TEST_F(WasmStreamingDecoderTest, CodeSectionLengthTooHighZeroFunctions) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      kCodeSectionCode,      // Section ID
      0xD,                   // Section Length
      0x0,                   // Number of Functions
  };
  ExpectFailure(base::ArrayVector(data));
}

TEST_F(WasmStreamingDecoderTest, CodeSectionLengthTooLow) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      kCodeSectionCode,      // Section ID
      0x9,                   // Section Length
      0x2,                   // Number of Functions  <0>
      0x7,                   // Function Length      <1>
      0x0,                   // Function             <2>
      0x0,                   // 2                    <3>
      0x0,                   // 3                    <3>
      0x0,                   // 4                    <4>
      0x0,                   // 5                    <5>
      0x0,                   // 6                    <6>
      0x0,                   // 7                    <7>
      0x1,                   // Function Length      <8> -- ERROR
      0x0,                   // Function
  };
  ExpectFailure(base::ArrayVector(data));
}

TEST_F(WasmStreamingDecoderTest, CodeSectionLengthTooLowEndsInNumFunctions) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      kCodeSectionCode,      // Section ID
      0x1,                   // Section Length
      0x82,                  // Number of Functions  <0>
      0x80,                  // --                   <1> -- ERROR
      0x00,                  // --
      0x7,                   // Function Length
      0x0,                   // Function
      0x0,                   // 2
      0x0,                   // 3
      0x0,                   // 4
      0x0,                   // 5
      0x0,                   // 6
      0x0,                   // 7
      0x1,                   // Function Length
      0x0,                   // Function
  };
  ExpectFailure(base::ArrayVector(data));
}

TEST_F(WasmStreamingDecoderTest, CodeSectionLengthTooLowEndsInFunctionLength) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      kCodeSectionCode,      // Section ID
      0x5,                   // Section Length
      0x82,                  // Number of Functions  <0>
      0x80,                  // --                   <1>
      0x00,                  // --                   <2>
      0x87,                  // Function Length      <3>
      0x80,                  // --                   <4>
      0x00,                  // --                   <5> -- ERROR
      0x0,                   // Function
      0x0,                   // 2
      0x0,                   // 3
      0x0,                   // 4
      0x0,                   // 5
      0x0,                   // 6
      0x0,                   // 7
      0x1,                   // Function Length
      0x0,                   // Function
  };
  ExpectFailure(base::ArrayVector(data));
}

TEST_F(WasmStreamingDecoderTest, NumberOfFunctionsTooHigh) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      kCodeSectionCode,      // Section ID
      0xB,                   // Section Length
      0x4,                   // Number of Functions
      0x7,                   // Function Length
      0x0,                   // Function
      0x0,                   // 2
      0x0,                   // 3
      0x0,                   // 4
      0x0,                   // 5
      0x0,                   // 6
      0x0,                   // 7
      0x1,                   // Function Length
      0x0,                   // Function
  };
  ExpectFailure(base::ArrayVector(data));
}

TEST_F(WasmStreamingDecoderTest, NumberOfFunctionsTooLow) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      kCodeSectionCode,      // Section ID
      0x8,                   // Section Length
      0x2,                   // Number of Functions
      0x1,                   // Function Length
      0x0,                   // Function
      0x2,                   // Function Length
      0x0,                   // Function byte#0
      0x0,                   // Function byte#1   -- ERROR
      0x1,                   // Function Length
      0x0                    // Function
  };
  ExpectFailure(base::ArrayVector(data));
}

TEST_F(WasmStreamingDecoderTest, TwoCodeSections) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      kCodeSectionCode,      // Section ID
      0x3,                   // Section Length
      0x1,                   // Number of Functions
      0x1,                   // Function Length
      0x0,                   // Function
      kCodeSectionCode,      // Section ID      -- ERROR
      0x3,                   // Section Length
      0x1,                   // Number of Functions
      0x1,                   // Function Length
      0x0,                   // Function
  };
  ExpectFailure(base::ArrayVector(data));
}

TEST_F(WasmStreamingDecoderTest, UnknownSection) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      kCodeSectionCode,      // Section ID
      0x3,                   // Section Length
      0x1,                   // Number of Functions
      0x1,                   // Function Length
      0x0,                   // Function
      kUnknownSectionCode,   // Section ID
      0x3,                   // Section Length
      0x1,                   // Name Length
      0x1,                   // Name
      0x0,                   // Content
  };
  ExpectVerifies(base::ArrayVector(data), 1, 1);
}

TEST_F(WasmStreamingDecoderTest, UnknownSectionSandwich) {
  const uint8_t data[] = {
      U32_LE(kWasmMagic),    // --
      U32_LE(kWasmVersion),  // --
      kCodeSectionCode,      // Section ID
      0x3,                   // Section Length
      0x1,                   // Number of Functions
      0x1,                   // Function Length
      0x0,                   // Function
      kUnknownSectionCode,   // Section ID
      0x3,                   // Section Length
      0x1,                   // Name Length
      0x1,                   // Name
      0x0,                   // Content
      kCodeSectionCode,      // Section ID     -- ERROR
      0x3,                   // Section Length
      0x1,                   // Number of Functions
      0x1,                   // Function Length
      0x0,                   // Function
  };
  ExpectFailure(base::ArrayVector(data));
}

TEST_F(WasmStreamingDecoderTest, InvalidSectionCode) {
  uint8_t kInvalidSectionCode = 61;
  const uint8_t data[] = {WASM_MODULE_HEADER, SECTION(Invalid)};
  ExpectFailure(base::ArrayVector(data));
}

}  // namespace wasm
}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/unittests/wasm/string-builder-unittest.cc                                  0000664 0000000 0000000 00000002473 14746647661 0025161 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/wasm/string-builder.h"

#include "testing/gtest/include/gtest/gtest.h"

namespace v8::internal::wasm {
namespace string_builder_unittest {

TEST(StringBuilder, Simple) {
  StringBuilder sb;
  sb << "foo"
     << "bar" << -42 << "\n";
  EXPECT_STREQ(std::string(sb.start(), sb.length()).c_str(), "foobar-42\n");
}

TEST(StringBuilder, DontLeak) {
  // Should be bigger than StringBuilder::kStackSize = 256.
  constexpr size_t kMoreThanStackBufferSize = 300;
  StringBuilder sb;
  const char* on_stack = sb.start();
  sb.allocate(kMoreThanStackBufferSize);
  const char* on_heap = sb.start();
  // If this fails, then kMoreThanStackBufferSize was too small.
  ASSERT_NE(on_stack, on_heap);
  // Still don't leak on further growth.
  sb.allocate(kMoreThanStackBufferSize * 4);
}

TEST(StringBuilder, SuperLongStrings) {
  // Should be bigger than StringBuilder::kChunkSize = 1024 * 1024.
  constexpr size_t kMoreThanChunkSize = 2 * 1024 * 1024;
  StringBuilder sb;
  char* s = sb.allocate(kMoreThanChunkSize);
  for (size_t i = 0; i < kMoreThanChunkSize; i++) {
    s[i] = 'a';
  }
}

}  // namespace string_builder_unittest
}  // namespace v8::internal::wasm
                                                                                                                                                                                                     node-23.7.0/deps/v8/test/unittests/wasm/struct-types-unittest.cc                                    0000664 0000000 0000000 00000004460 14746647661 0024713 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/wasm/struct-types.h"

#include "test/unittests/test-utils.h"
#include "testing/gtest/include/gtest/gtest.h"

namespace v8::internal::wasm {
namespace struct_types_unittest {

class StructTypesTest : public TestWithZone {};

TEST_F(StructTypesTest, Empty) {
  StructType::Builder builder(this->zone(), 0);
  StructType* type = builder.Build();
  EXPECT_EQ(0u, type->total_fields_size());
}

TEST_F(StructTypesTest, OneField) {
  StructType::Builder builder(this->zone(), 1);
  builder.AddField(kWasmI32, true);
  StructType* type = builder.Build();
  uint32_t expected = std::max(kUInt32Size, kTaggedSize);
  EXPECT_EQ(expected, type->total_fields_size());
  EXPECT_EQ(0u, type->field_offset(0));
}

TEST_F(StructTypesTest, Packing) {
  StructType::Builder builder(this->zone(), 5);
  builder.AddField(kWasmI64, true);
  builder.AddField(kWasmI8, true);
  builder.AddField(kWasmI32, true);
  builder.AddField(kWasmI16, true);
  builder.AddField(kWasmI8, true);
  StructType* type = builder.Build();
  EXPECT_EQ(16u, type->total_fields_size());
  EXPECT_EQ(0u, type->field_offset(0));
  EXPECT_EQ(8u, type->field_offset(1));
  EXPECT_EQ(12u, type->field_offset(2));
  EXPECT_EQ(10u, type->field_offset(3));
  EXPECT_EQ(9u, type->field_offset(4));
}

TEST_F(StructTypesTest, CopyingOffsets) {
  StructType::Builder builder(this->zone(), 5);
  builder.AddField(kWasmI64, true);
  builder.AddField(kWasmI8, true);
  builder.AddField(kWasmI32, true);
  builder.AddField(kWasmI16, true);
  builder.AddField(kWasmI8, true);
  StructType* type = builder.Build();

  StructType::Builder copy_builder(this->zone(), type->field_count());
  for (uint32_t i = 0; i < type->field_count(); i++) {
    copy_builder.AddField(type->field(i), type->mutability(i),
                          type->field_offset(i));
  }
  copy_builder.set_total_fields_size(type->total_fields_size());

  StructType* copy = copy_builder.Build();
  for (uint32_t i = 0; i < type->field_count(); i++) {
    EXPECT_EQ(type->field_offset(i), copy->field_offset(i));
  }
  EXPECT_EQ(type->total_fields_size(), copy->total_fields_size());
}

}  // namespace struct_types_unittest
}  // namespace v8::internal::wasm
                                                                                                                                                                                                                node-23.7.0/deps/v8/test/unittests/wasm/subtyping-unittest.cc                                       0000664 0000000 0000000 00000102405 14746647661 0024247 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/wasm/canonical-types.h"
#include "src/wasm/wasm-subtyping.h"
#include "test/common/flag-utils.h"
#include "test/common/wasm/flag-utils.h"
#include "test/unittests/test-utils.h"

namespace v8::internal::wasm::subtyping_unittest {

class WasmSubtypingTest : public TestWithPlatform {};
using FieldInit = std::pair<ValueType, bool>;

constexpr ValueType ref(uint32_t index) { return ValueType::Ref(index); }
constexpr ValueType refNull(uint32_t index) {
  return ValueType::RefNull(index);
}

FieldInit mut(ValueType type) { return FieldInit(type, true); }
FieldInit immut(ValueType type) { return FieldInit(type, false); }

void DefineStruct(WasmModule* module, std::initializer_list<FieldInit> fields,
                  uint32_t supertype = kNoSuperType, bool is_final = false,
                  bool is_shared = false, bool in_singleton_rec_group = true) {
  StructType::Builder builder(&module->signature_zone,
                              static_cast<uint32_t>(fields.size()));
  for (FieldInit field : fields) {
    builder.AddField(field.first, field.second);
  }
  module->AddStructTypeForTesting(builder.Build(), supertype, is_final,
                                  is_shared);
  if (in_singleton_rec_group) {
    GetTypeCanonicalizer()->AddRecursiveSingletonGroup(module);
  }
}

void DefineArray(WasmModule* module, FieldInit element_type,
                 uint32_t supertype = kNoSuperType, bool is_final = false,
                 bool is_shared = false, bool in_singleton_rec_group = true) {
  module->AddArrayTypeForTesting(module->signature_zone.New<ArrayType>(
                                     element_type.first, element_type.second),
                                 supertype, is_final, is_shared);
  if (in_singleton_rec_group) {
    GetTypeCanonicalizer()->AddRecursiveSingletonGroup(module);
  }
}

void DefineSignature(WasmModule* module,
                     std::initializer_list<ValueType> params,
                     std::initializer_list<ValueType> returns,
                     uint32_t supertype = kNoSuperType, bool is_final = false,
                     bool is_shared = false,
                     bool in_singleton_rec_group = true) {
  module->AddSignatureForTesting(
      FunctionSig::Build(&module->signature_zone, returns, params), supertype,
      is_final, is_shared);
  if (in_singleton_rec_group) {
    GetTypeCanonicalizer()->AddRecursiveGroup(module, 1);
  }
}

TEST_F(WasmSubtypingTest, Subtyping) {
  v8::internal::AccountingAllocator allocator;
  WasmModule module1_;
  WasmModule module2_;

  WasmModule* module1 = &module1_;
  WasmModule* module2 = &module2_;

  // Set up two identical modules.
  for (WasmModule* module : {module1, module2}) {
    /*  0 */ DefineStruct(module, {mut(ref(2)), immut(refNull(2))});
    /*  1 */ DefineStruct(module, {mut(ref(2)), immut(ref(2))}, 0);
    /*  2 */ DefineArray(module, immut(ref(0)));
    /*  3 */ DefineArray(module, immut(ref(1)), 2);
    /*  4 */ DefineStruct(module, {mut(ref(2)), immut(ref(3)), immut(kWasmF64)},
                          1);
    /*  5 */ DefineStruct(module, {mut(refNull(2)), immut(ref(2))});
    /*  6 */ DefineArray(module, mut(kWasmI32));
    /*  7 */ DefineArray(module, immut(kWasmI32));
    /*  8 */ DefineStruct(module, {mut(kWasmI32), immut(refNull(8))});
    /*  9 */ DefineStruct(module, {mut(kWasmI32), immut(refNull(8))}, 8);
    /* 10 */ DefineSignature(module, {}, {});
    /* 11 */ DefineSignature(module, {kWasmI32}, {kWasmI32});
    /* 12 */ DefineSignature(module, {kWasmI32, kWasmI32}, {kWasmI32});
    /* 13 */ DefineSignature(module, {ref(1)}, {kWasmI32});
    /* 14 */ DefineSignature(module, {ref(0)}, {kWasmI32}, 13);
    /* 15 */ DefineSignature(module, {ref(0)}, {ref(0)});
    /* 16 */ DefineSignature(module, {ref(0)}, {ref(4)}, 15);
    /* 17 */ DefineStruct(module, {mut(kWasmI32), immut(refNull(17))});

    // Rec. group.
    /* 18 */ DefineStruct(module, {mut(kWasmI32), immut(refNull(17))}, 17,
                          false, false, false);
    /* 19 */ DefineArray(module, {mut(refNull(21))}, kNoSuperType, false, false,
                         false);
    /* 20 */ DefineSignature(module, {kWasmI32}, {kWasmI32}, kNoSuperType,
                             false, false, false);
    /* 21 */ DefineSignature(module, {kWasmI32}, {kWasmI32}, 20, false, false,
                             false);
    GetTypeCanonicalizer()->AddRecursiveGroup(module, 4);

    // Identical rec. group.
    /* 22 */ DefineStruct(module, {mut(kWasmI32), immut(refNull(17))}, 17,
                          false, false, false);
    /* 23 */ DefineArray(module, {mut(refNull(25))}, kNoSuperType, false, false,
                         false);
    /* 24 */ DefineSignature(module, {kWasmI32}, {kWasmI32}, kNoSuperType,
                             false, false, false);
    /* 25 */ DefineSignature(module, {kWasmI32}, {kWasmI32}, 24, false, false,
                             false);
    GetTypeCanonicalizer()->AddRecursiveGroup(module, 4);

    // Nonidentical rec. group: the last function extends a type outside the
    // recursive group.
    /* 26 */ DefineStruct(module, {mut(kWasmI32), immut(refNull(17))}, 17,
                          false, false, false);
    /* 27 */ DefineArray(module, {mut(refNull(29))}, kNoSuperType, false, false,
                         false);
    /* 28 */ DefineSignature(module, {kWasmI32}, {kWasmI32}, kNoSuperType,
                             false, false, false);
    /* 29 */ DefineSignature(module, {kWasmI32}, {kWasmI32}, 20, false, false,
                             false);
    GetTypeCanonicalizer()->AddRecursiveGroup(module, 4);

    /* 30 */ DefineStruct(module, {mut(kWasmI32), immut(refNull(18))}, 18);
    /* 31 */ DefineStruct(
        module, {mut(ref(2)), immut(refNull(2)), immut(kWasmS128)}, 1);

    // Final types
    /* 32 */ DefineStruct(module, {mut(kWasmI32)}, kNoSuperType, true);
    /* 33 */ DefineStruct(module, {mut(kWasmI32), mut(kWasmI64)}, 32, true);
    /* 34 */ DefineStruct(module, {mut(kWasmI32)}, kNoSuperType, true);
    /* 35 */ DefineStruct(module, {mut(kWasmI32)}, kNoSuperType, false);

    // Shared types.
    /* 36 */ DefineStruct(module, {mut(kWasmI32)}, kNoSuperType);
    /* 37 */ DefineStruct(module, {mut(kWasmI32), mut(kWasmI64)}, 36);
    /* 38 */ DefineStruct(module, {mut(kWasmI32)}, kNoSuperType, false, true);
    /* 39 */ DefineStruct(module, {mut(kWasmI32), mut(kWasmI64)}, 38, false,
                          true);
    /* 40 */ DefineStruct(module, {mut(kWasmI32)}, kNoSuperType, false, true);
    /* 41 */ DefineSignature(module, {kWasmI32}, {kWasmI32}, false, true, true);
  }

  constexpr ValueType numeric_types[] = {kWasmI32, kWasmI64, kWasmF32, kWasmF64,
                                         kWasmS128};
  constexpr ValueType ref_types[] = {
      kWasmFuncRef,     kWasmEqRef,         kWasmStructRef,
      kWasmArrayRef,    kWasmI31Ref,        kWasmAnyRef,
      kWasmExternRef,   kWasmNullExternRef, kWasmNullRef,
      kWasmNullFuncRef, kWasmStringRef,     kWasmStringViewIter,
      kWasmExnRef,      kWasmNullExnRef,    kWasmRefNullExternString,
      refNull(0),   // struct
      ref(0),       // struct
      refNull(2),   // array
      ref(2),       // array
      refNull(11),  // signature
      ref(11)       // signature
  };

// Some macros to help managing types and modules.
#define SUBTYPE(type1, type2) \
  EXPECT_TRUE(IsSubtypeOf(type1, type2, module1, module))
#define SUBTYPE_IFF(type1, type2, condition) \
  EXPECT_EQ(IsSubtypeOf(type1, type2, module1, module), condition)
#define NOT_SUBTYPE(type1, type2) \
  EXPECT_FALSE(IsSubtypeOf(type1, type2, module1, module))
// Use only with indexed types.
#define VALID_SUBTYPE(type1, type2)                                        \
  EXPECT_TRUE(ValidSubtypeDefinition(type1.ref_index(), type2.ref_index(), \
                                     module1, module));                    \
  EXPECT_TRUE(IsSubtypeOf(type1, type2, module1, module));
#define NOT_VALID_SUBTYPE(type1, type2)                                     \
  EXPECT_FALSE(ValidSubtypeDefinition(type1.ref_index(), type2.ref_index(), \
                                      module1, module));
#define IDENTICAL(index1, index2)                         \
  EXPECT_TRUE(EquivalentTypes(ValueType::RefNull(index1), \
                              ValueType::RefNull(index2), module1, module));
#define DISTINCT(index1, index2)                           \
  EXPECT_FALSE(EquivalentTypes(ValueType::RefNull(index1), \
                               ValueType::RefNull(index2), module1, module));
// For union and intersection, we have a version that also checks the module,
// and one that does not.
#define UNION(type1, type2, type_result) \
  EXPECT_EQ(Union(type1, type2, module1, module).type, type_result)
#define UNION_M(type1, type2, type_result, module_result) \
  EXPECT_EQ(Union(type1, type2, module1, module),         \
            TypeInModule(type_result, module_result))
#define INTERSECTION(type1, type2, type_result) \
  EXPECT_EQ(Intersection(type1, type2, module1, module).type, type_result)
#define INTERSECTION_M(type1, type2, type_result, module_result) \
  EXPECT_EQ(Intersection(type1, type2, module1, module),         \
            TypeInModule(type_result, module_result))

  for (WasmModule* module : {module1, module2}) {
    // Type judgements across modules should work the same as within one module.

    // Value types are unrelated, except if they are equal.
    for (ValueType subtype : numeric_types) {
      for (ValueType supertype : numeric_types) {
        SUBTYPE_IFF(subtype, supertype, subtype == supertype);
      }
    }

    // Value types are unrelated with reference types.
    for (ValueType value_type : numeric_types) {
      for (ValueType ref_type : ref_types) {
        NOT_SUBTYPE(value_type, ref_type);
        NOT_SUBTYPE(ref_type, value_type);
      }
    }

    for (ValueType ref_type : ref_types) {
      const bool is_extern = ref_type == kWasmExternRef ||
                             ref_type == kWasmNullExternRef ||
                             ref_type == kWasmRefNullExternString;
      const bool is_any_func = ref_type == kWasmFuncRef ||
                               ref_type == kWasmNullFuncRef ||
                               ref_type == refNull(11) || ref_type == ref(11);
      const bool is_string_view = ref_type == kWasmStringViewIter ||
                                  ref_type == kWasmStringViewWtf8 ||
                                  ref_type == kWasmStringViewWtf16;
      const bool is_exn =
          ref_type == kWasmExnRef || ref_type == kWasmNullExnRef;
      SCOPED_TRACE("ref_type: " + ref_type.name());
      // Concrete reference types, i31ref, structref and arrayref are subtypes
      // of eqref, externref/funcref/anyref/exnref/functions are not.
      SUBTYPE_IFF(ref_type, kWasmEqRef,
                  ref_type != kWasmAnyRef && !is_any_func && !is_extern &&
                      !is_string_view && ref_type != kWasmStringRef && !is_exn);
      // Struct types are subtypes of structref.
      SUBTYPE_IFF(ref_type, kWasmStructRef,
                  ref_type == kWasmStructRef || ref_type == kWasmNullRef ||
                      ref_type == ref(0) || ref_type == refNull(0));
      // Array types are subtypes of arrayref.
      SUBTYPE_IFF(ref_type, kWasmArrayRef,
                  ref_type == kWasmArrayRef || ref_type == ref(2) ||
                      ref_type == kWasmNullRef || ref_type == refNull(2));
      // Functions are subtypes of funcref.
      SUBTYPE_IFF(ref_type, kWasmFuncRef, is_any_func);
      // Each reference type is a subtype of itself.
      SUBTYPE(ref_type, ref_type);
      // Each non-func, non-extern, non-string-view, non-string-iter reference
      // type is a subtype of anyref.
      SUBTYPE_IFF(ref_type, kWasmAnyRef,
                  !is_any_func && !is_extern && !is_string_view && !is_exn);
      // Only anyref is a subtype of anyref.
      SUBTYPE_IFF(kWasmAnyRef, ref_type, ref_type == kWasmAnyRef);
      // Only externref and nullexternref are subtypes of externref.
      SUBTYPE_IFF(ref_type, kWasmExternRef, is_extern);
      // Only nullexternref is a subtype of nullexternref.
      SUBTYPE_IFF(ref_type, kWasmNullExternRef, ref_type == kWasmNullExternRef);
      // Each nullable non-func, non-extern reference type is a supertype of
      // nullref.
      SUBTYPE_IFF(
          kWasmNullRef, ref_type,
          ref_type.is_nullable() && !is_any_func && !is_extern && !is_exn);
      // Only nullref is a subtype of nullref.
      SUBTYPE_IFF(ref_type, kWasmNullRef, ref_type == kWasmNullRef);
      // Only nullable funcs are supertypes of nofunc.
      SUBTYPE_IFF(kWasmNullFuncRef, ref_type,
                  ref_type.is_nullable() && is_any_func);
      // Only nullfuncref is a subtype of nullfuncref.
      SUBTYPE_IFF(ref_type, kWasmNullFuncRef, ref_type == kWasmNullFuncRef);

      // Make sure symmetric relations are symmetric.
      for (ValueType ref_type2 : ref_types) {
        if (ref_type == ref_type2) {
          EXPECT_TRUE(EquivalentTypes(ref_type, ref_type2, module, module1));
          EXPECT_TRUE(EquivalentTypes(ref_type2, ref_type, module1, module));
        } else {
          EXPECT_FALSE(EquivalentTypes(ref_type, ref_type2, module, module1));
          EXPECT_FALSE(EquivalentTypes(ref_type2, ref_type, module1, module));
        }
      }
    }

    // The rest of ref. types are unrelated.
    for (ValueType type_1 :
         {kWasmFuncRef, kWasmI31Ref, kWasmArrayRef, kWasmExnRef}) {
      for (ValueType type_2 :
           {kWasmFuncRef, kWasmI31Ref, kWasmArrayRef, kWasmExnRef}) {
        SUBTYPE_IFF(type_1, type_2, type_1 == type_2);
      }
    }

    // Unrelated refs are unrelated.
    NOT_VALID_SUBTYPE(ref(0), ref(2));
    NOT_VALID_SUBTYPE(refNull(3), refNull(1));
    // ref is a subtype of ref null for the same struct/array.
    VALID_SUBTYPE(ref(0), refNull(0));
    VALID_SUBTYPE(ref(2), refNull(2));
    // ref null is not a subtype of ref for the same struct/array.
    NOT_SUBTYPE(refNull(0), ref(0));
    NOT_SUBTYPE(refNull(2), ref(2));
    // ref is a subtype of ref null if the same is true for the underlying
    // structs/arrays.
    VALID_SUBTYPE(ref(3), refNull(2));
    // Prefix subtyping for structs.
    VALID_SUBTYPE(refNull(4), refNull(0));
    // Mutable fields are invariant.
    NOT_VALID_SUBTYPE(ref(0), ref(5));
    // Immutable fields are covariant.
    VALID_SUBTYPE(ref(1), ref(0));
    // Prefix subtyping + immutable field covariance for structs.
    VALID_SUBTYPE(refNull(4), refNull(1));
    // No subtyping between mutable/immutable fields.
    NOT_VALID_SUBTYPE(ref(7), ref(6));
    NOT_VALID_SUBTYPE(ref(6), ref(7));
    // Recursive types.
    VALID_SUBTYPE(ref(9), ref(8));

    // Identical rtts are subtypes of each other.
    SUBTYPE(ValueType::Rtt(5), ValueType::Rtt(5));
    // Rtts of unrelated types are unrelated.
    NOT_SUBTYPE(ValueType::Rtt(1), ValueType::Rtt(2));
    // Rtts of subtypes are not related.
    NOT_SUBTYPE(ValueType::Rtt(1), ValueType::Rtt(0));

    // Function subtyping;
    // Unrelated function types are unrelated.
    NOT_VALID_SUBTYPE(ref(10), ref(11));
    // Function type with different parameter counts are unrelated.
    NOT_VALID_SUBTYPE(ref(12), ref(11));
    // Parameter contravariance holds.
    VALID_SUBTYPE(ref(14), ref(13));
    // Return type covariance holds.
    VALID_SUBTYPE(ref(16), ref(15));
    // Identical types are subtype-related.
    VALID_SUBTYPE(ref(10), ref(10));
    VALID_SUBTYPE(ref(11), ref(11));

    // Canonicalization tests.

    // Groups should only be canonicalized to identical groups.
    IDENTICAL(18, 22);
    IDENTICAL(19, 23);
    IDENTICAL(20, 24);
    IDENTICAL(21, 25);

    DISTINCT(18, 26);
    DISTINCT(19, 27);
    DISTINCT(20, 28);
    DISTINCT(21, 29);

    // A type should not be canonicalized to an identical one with a different
    // group structure.
    DISTINCT(18, 17);

    // A subtype should also be subtype of an equivalent type.
    VALID_SUBTYPE(ref(30), ref(18));
    VALID_SUBTYPE(ref(30), ref(22));
    NOT_SUBTYPE(ref(30), ref(26));

    // Final types

    // A type is not a valid subtype of a final type.
    NOT_VALID_SUBTYPE(ref(33), ref(32));
    IDENTICAL(32, 34);
    // A final and a non-final type are distinct.
    DISTINCT(32, 35);

    /* Shared types */
    // A shared type can be a subtype of a shared type.
    VALID_SUBTYPE(ref(39), ref(38));
    // A shared type is not a valid subtype of a non-shared type and vice versa.
    NOT_VALID_SUBTYPE(ref(39), ref(36));
    NOT_VALID_SUBTYPE(ref(37), ref(38));
    // Two shared types are identical. A shared and non-shared type are
    // distinct.
    IDENTICAL(38, 40);
    DISTINCT(36, 38);
    // Abstract types
    SUBTYPE(ValueType::Ref(HeapType::kEqShared),
            ValueType::Ref(HeapType::kAnyShared));
    NOT_SUBTYPE(ValueType::Ref(HeapType::kEqShared),
                ValueType::Ref(HeapType::kAny));
    NOT_SUBTYPE(ValueType::Ref(HeapType::kEq),
                ValueType::Ref(HeapType::kAnyShared));
    NOT_SUBTYPE(ValueType::Ref(HeapType::kFuncShared),
                ValueType::Ref(HeapType::kAnyShared));
    SUBTYPE(ValueType::RefNull(HeapType::kNoneShared),
            ValueType::RefNull(HeapType::kI31Shared));
    SUBTYPE(ValueType::RefNull(HeapType::kNoFuncShared),
            ValueType::RefNull(HeapType::kFuncShared));
    SUBTYPE(ref(40), ValueType::RefNull(HeapType::kEqShared));
    SUBTYPE(ValueType::RefNull(HeapType::kNoneShared), refNull(40));
    NOT_SUBTYPE(ref(40), ValueType::RefNull(HeapType::kEq));
    NOT_SUBTYPE(ref(40), ValueType::RefNull(HeapType::kExternShared));
    SUBTYPE(ref(41), ValueType::RefNull(HeapType::kFuncShared));
    SUBTYPE(ValueType::RefNull(HeapType::kNoFuncShared), refNull(41));
    NOT_SUBTYPE(ref(41), ValueType::RefNull(HeapType::kAnyShared));
    NOT_SUBTYPE(ref(41), ValueType::RefNull(HeapType::kFunc));
    NOT_SUBTYPE(ref(0), ValueType::Ref(HeapType::kStructShared));
    NOT_SUBTYPE(ref(2), ValueType::Ref(HeapType::kArrayShared));
    NOT_SUBTYPE(ref(10), ValueType::Ref(HeapType::kFuncShared));

    // Rtts of identical types are subtype-related.
    SUBTYPE(ValueType::Rtt(8), ValueType::Rtt(17));

    // Unions and intersections.

    // Distinct numeric types are unrelated.
    for (ValueType type1 : numeric_types) {
      for (ValueType type2 : numeric_types) {
        UNION(type1, type2, (type1 == type2 ? type1 : kWasmBottom));
        INTERSECTION(type1, type2, (type1 == type2 ? type1 : kWasmBottom));
      }
    }
    // Numeric and reference types are unrelated.
    for (ValueType type1 : numeric_types) {
      for (ValueType type2 : ref_types) {
        UNION(type1, type2, kWasmBottom);
        INTERSECTION(type1, type2, kWasmBottom);
      }
    }

    // Reference type vs. itself and anyref.
    for (ValueType type : ref_types) {
      SCOPED_TRACE(type.name());
      UNION(type, type, type);
      INTERSECTION(type, type, type);
      if (type == kWasmStringViewIter || type == kWasmStringViewWtf8 ||
          type == kWasmStringViewWtf16) {
        // String views aren't subtypes of any nor supertypes of null.
        INTERSECTION(type, kWasmAnyRef, kWasmBottom);
        INTERSECTION(type, kWasmNullRef, kWasmBottom);
        continue;
      }
      if (type == kWasmFuncRef || type == kWasmNullFuncRef || type == ref(11) ||
          type == refNull(11) || type == kWasmExternRef ||
          type == kWasmNullExternRef || type == kWasmRefNullExternString) {
        // func and extern types don't share the same type hierarchy as anyref.
        INTERSECTION(type, kWasmAnyRef, kWasmBottom);
        continue;
      }
      bool is_exn = type == kWasmExnRef || type == kWasmNullExnRef;
      UNION(kWasmAnyRef, type, is_exn ? kWasmBottom : kWasmAnyRef);
      INTERSECTION(kWasmAnyRef, type, is_exn ? kWasmBottom : type);
      UNION(kWasmAnyRef.AsNonNull(), type,
            is_exn               ? kWasmBottom
            : type.is_nullable() ? kWasmAnyRef
                                 : kWasmAnyRef.AsNonNull());
      INTERSECTION(kWasmAnyRef.AsNonNull(), type,
                   is_exn                 ? kWasmBottom
                   : type != kWasmNullRef ? type.AsNonNull()
                                          : kWasmBottom);
    }

    // Abstract types vs abstract types.
    UNION(kWasmEqRef, kWasmStructRef, kWasmEqRef);
    UNION(kWasmEqRef, kWasmI31Ref, kWasmEqRef);
    UNION(kWasmEqRef, kWasmArrayRef, kWasmEqRef);
    UNION(kWasmEqRef, kWasmNullRef, kWasmEqRef);
    UNION(kWasmStructRef, kWasmI31Ref, kWasmEqRef);
    UNION(kWasmStructRef, kWasmArrayRef, kWasmEqRef);
    UNION(kWasmStructRef, kWasmNullRef, kWasmStructRef.AsNullable());
    UNION(kWasmI31Ref.AsNonNull(), kWasmArrayRef.AsNonNull(),
          kWasmEqRef.AsNonNull());
    UNION(kWasmI31Ref, kWasmNullRef, kWasmI31Ref.AsNullable());
    UNION(kWasmArrayRef, kWasmNullRef, kWasmArrayRef.AsNullable());
    UNION(kWasmStructRef.AsNonNull(), kWasmI31Ref.AsNonNull(),
          kWasmEqRef.AsNonNull());
    UNION(kWasmI31Ref.AsNonNull(), kWasmArrayRef, kWasmEqRef);
    UNION(kWasmAnyRef, kWasmNullRef, kWasmAnyRef);
    UNION(kWasmExternRef, kWasmNullExternRef, kWasmExternRef);
    UNION(kWasmRefNullExternString, kWasmNullExternRef,
          kWasmRefNullExternString);
    UNION(kWasmRefNullExternString.AsNonNull(), kWasmNullExternRef,
          kWasmRefNullExternString);
    UNION(kWasmRefNullExternString, kWasmExternRef, kWasmExternRef);
    UNION(kWasmRefNullExternString, kWasmAnyRef, kWasmBottom);
    UNION(kWasmRefNullExternString, kWasmFuncRef, kWasmBottom);
    // Imported strings and stringref represent the same values. Still, they are
    // in different type hierarchies and therefore incompatible (e.g. due to
    // different null representation).
    // (There is no interoperability between stringref and imported strings as
    // they are competing proposals.)
    UNION(kWasmRefNullExternString, kWasmStringRef, kWasmBottom);
    UNION(kWasmRefNullExternString.AsNonNull(), kWasmStringRef.AsNonNull(),
          kWasmBottom);
    UNION(kWasmFuncRef, kWasmNullFuncRef, kWasmFuncRef);
    UNION(kWasmFuncRef, kWasmStructRef, kWasmBottom);
    UNION(kWasmFuncRef, kWasmArrayRef, kWasmBottom);
    UNION(kWasmFuncRef, kWasmAnyRef, kWasmBottom);
    UNION(kWasmFuncRef, kWasmEqRef, kWasmBottom);
    UNION(kWasmStringRef, kWasmAnyRef, kWasmAnyRef);
    UNION(kWasmStringRef, kWasmStructRef, kWasmAnyRef);
    UNION(kWasmStringRef, kWasmArrayRef, kWasmAnyRef);
    UNION(kWasmStringRef, kWasmFuncRef, kWasmBottom);
    UNION(kWasmStringViewIter, kWasmStringRef, kWasmBottom);
    UNION(kWasmStringViewWtf8, kWasmStringRef, kWasmBottom);
    UNION(kWasmStringViewWtf16, kWasmStringRef, kWasmBottom);
    UNION(kWasmStringViewIter, kWasmAnyRef, kWasmBottom);
    UNION(kWasmStringViewWtf8, kWasmAnyRef, kWasmBottom);
    UNION(kWasmStringViewWtf16, kWasmAnyRef, kWasmBottom);
    UNION(kWasmNullFuncRef, kWasmEqRef, kWasmBottom);

    INTERSECTION(kWasmExternRef, kWasmEqRef, kWasmBottom);
    INTERSECTION(kWasmExternRef, kWasmStructRef, kWasmBottom);
    INTERSECTION(kWasmExternRef, kWasmI31Ref.AsNonNull(), kWasmBottom);
    INTERSECTION(kWasmExternRef, kWasmArrayRef, kWasmBottom);
    INTERSECTION(kWasmExternRef, kWasmNullRef, kWasmBottom);
    INTERSECTION(kWasmExternRef, kWasmFuncRef, kWasmBottom);
    INTERSECTION(kWasmNullExternRef, kWasmEqRef, kWasmBottom);
    INTERSECTION(kWasmNullExternRef, kWasmStructRef, kWasmBottom);
    INTERSECTION(kWasmNullExternRef, kWasmI31Ref, kWasmBottom);
    INTERSECTION(kWasmNullExternRef, kWasmArrayRef, kWasmBottom);
    INTERSECTION(kWasmNullExternRef, kWasmNullRef, kWasmBottom);
    INTERSECTION(kWasmNullExternRef, kWasmExternRef, kWasmNullExternRef);
    INTERSECTION(kWasmNullExternRef, kWasmExternRef.AsNonNull(), kWasmBottom);
    INTERSECTION(kWasmRefNullExternString, kWasmEqRef, kWasmBottom);
    INTERSECTION(kWasmRefNullExternString, kWasmAnyRef, kWasmBottom);
    INTERSECTION(kWasmRefNullExternString, kWasmFuncRef.AsNonNull(),
                 kWasmBottom);
    INTERSECTION(kWasmRefNullExternString, kWasmNullRef, kWasmBottom);
    INTERSECTION(kWasmRefNullExternString, kWasmNullExternRef,
                 kWasmNullExternRef);
    INTERSECTION(kWasmRefNullExternString.AsNonNull(), kWasmNullExternRef,
                 kWasmBottom);
    INTERSECTION(kWasmRefNullExternString, kWasmExternRef,
                 kWasmRefNullExternString);
    INTERSECTION(kWasmRefNullExternString, kWasmExternRef.AsNonNull(),
                 kWasmRefNullExternString.AsNonNull());

    INTERSECTION(kWasmFuncRef, kWasmEqRef, kWasmBottom);
    INTERSECTION(kWasmFuncRef, kWasmStructRef, kWasmBottom);
    INTERSECTION(kWasmFuncRef, kWasmI31Ref.AsNonNull(), kWasmBottom);
    INTERSECTION(kWasmFuncRef, kWasmArrayRef, kWasmBottom);
    INTERSECTION(kWasmFuncRef, kWasmNullRef, kWasmBottom);
    INTERSECTION(kWasmFuncRef, kWasmNullExternRef, kWasmBottom);
    INTERSECTION(kWasmNullFuncRef, kWasmEqRef, kWasmBottom);
    INTERSECTION(kWasmNullFuncRef, kWasmStructRef, kWasmBottom);
    INTERSECTION(kWasmNullFuncRef, kWasmI31Ref, kWasmBottom);
    INTERSECTION(kWasmNullFuncRef, kWasmArrayRef, kWasmBottom);
    INTERSECTION(kWasmNullFuncRef, kWasmNullRef, kWasmBottom);
    INTERSECTION(kWasmNullFuncRef, kWasmFuncRef, kWasmNullFuncRef);
    INTERSECTION(kWasmNullFuncRef, kWasmFuncRef.AsNonNull(), kWasmBottom);
    INTERSECTION(kWasmNullFuncRef, kWasmNullExternRef, kWasmBottom);

    INTERSECTION(kWasmEqRef, kWasmStructRef, kWasmStructRef);
    INTERSECTION(kWasmEqRef, kWasmI31Ref, kWasmI31Ref);
    INTERSECTION(kWasmEqRef, kWasmArrayRef, kWasmArrayRef);
    INTERSECTION(kWasmEqRef, kWasmNullRef, kWasmNullRef);
    INTERSECTION(kWasmEqRef, kWasmFuncRef, kWasmBottom);
    INTERSECTION(kWasmStructRef, kWasmI31Ref, kWasmNullRef);
    INTERSECTION(kWasmStructRef, kWasmArrayRef, kWasmNullRef);
    INTERSECTION(kWasmStructRef, kWasmNullRef, kWasmNullRef);
    INTERSECTION(kWasmI31Ref, kWasmArrayRef, kWasmNullRef);
    INTERSECTION(kWasmI31Ref.AsNonNull(), kWasmNullRef, kWasmBottom);
    INTERSECTION(kWasmArrayRef.AsNonNull(), kWasmNullRef, kWasmBottom);

    ValueType struct_type = ref(0);
    ValueType array_type = ref(2);
    ValueType function_type = ref(11);

    // Abstract vs indexed types.
    UNION(kWasmFuncRef, function_type, kWasmFuncRef);
    UNION(kWasmFuncRef, struct_type, kWasmBottom);
    UNION(kWasmFuncRef, array_type, kWasmBottom);
    INTERSECTION(kWasmFuncRef, struct_type, kWasmBottom);
    INTERSECTION(kWasmFuncRef, array_type, kWasmBottom);
    INTERSECTION_M(kWasmFuncRef, function_type, function_type, module);

    UNION(kWasmExnRef, struct_type, kWasmBottom);
    UNION(kWasmExnRef, array_type, kWasmBottom);
    UNION(kWasmExnRef, function_type, kWasmBottom);
    INTERSECTION(kWasmExnRef, struct_type, kWasmBottom);
    INTERSECTION(kWasmExnRef, array_type, kWasmBottom);
    INTERSECTION(kWasmExnRef, function_type, kWasmBottom);

    UNION(kWasmNullFuncRef, function_type, function_type.AsNullable());
    UNION(kWasmNullFuncRef, struct_type, kWasmBottom);
    UNION(kWasmNullFuncRef, array_type, kWasmBottom);
    INTERSECTION(kWasmNullFuncRef, struct_type, kWasmBottom);
    INTERSECTION(kWasmNullFuncRef, struct_type.AsNullable(), kWasmBottom);
    INTERSECTION(kWasmNullFuncRef, array_type, kWasmBottom);
    INTERSECTION(kWasmNullFuncRef, array_type.AsNullable(), kWasmBottom);
    INTERSECTION(kWasmNullFuncRef, function_type, kWasmBottom);
    INTERSECTION(kWasmNullFuncRef, function_type.AsNullable(),
                 kWasmNullFuncRef);

    UNION(kWasmEqRef, struct_type, kWasmEqRef);
    UNION(kWasmEqRef, array_type, kWasmEqRef);
    INTERSECTION(kWasmEqRef, struct_type, struct_type);
    INTERSECTION(kWasmEqRef, array_type, array_type);
    INTERSECTION(kWasmEqRef, function_type, kWasmBottom);

    UNION(kWasmStructRef, struct_type, kWasmStructRef);
    UNION(kWasmStructRef, array_type, kWasmEqRef);
    UNION(kWasmStructRef, function_type, kWasmBottom);
    INTERSECTION_M(kWasmStructRef, struct_type, struct_type, module);
    INTERSECTION(kWasmStructRef, array_type, kWasmBottom);
    INTERSECTION(kWasmStructRef, function_type, kWasmBottom);

    UNION(kWasmI31Ref, struct_type, kWasmEqRef);
    UNION(kWasmI31Ref, array_type, kWasmEqRef);
    INTERSECTION(kWasmI31Ref, struct_type, kWasmBottom);
    INTERSECTION(kWasmI31Ref, array_type, kWasmBottom);
    INTERSECTION(kWasmI31Ref, function_type, kWasmBottom);

    UNION(kWasmArrayRef, struct_type, kWasmEqRef);
    UNION(kWasmArrayRef, array_type, kWasmArrayRef);
    UNION(kWasmArrayRef, function_type, kWasmBottom);
    INTERSECTION(kWasmArrayRef, struct_type, kWasmBottom);
    INTERSECTION_M(kWasmArrayRef, array_type, array_type, module);
    INTERSECTION(kWasmArrayRef, function_type, kWasmBottom);

    UNION_M(kWasmNullRef, struct_type, struct_type.AsNullable(), module);
    UNION_M(kWasmNullRef, array_type, array_type.AsNullable(), module);
    UNION(kWasmNullRef, function_type, kWasmBottom);
    INTERSECTION(kWasmNullRef, struct_type, kWasmBottom);
    INTERSECTION(kWasmNullRef, array_type, kWasmBottom);
    INTERSECTION(kWasmNullRef, function_type, kWasmBottom);
    INTERSECTION(kWasmNullRef, struct_type.AsNullable(), kWasmNullRef);
    INTERSECTION(kWasmNullRef, array_type.AsNullable(), kWasmNullRef);
    INTERSECTION(kWasmNullRef, function_type.AsNullable(), kWasmBottom);

    UNION(struct_type, kWasmStringRef, kWasmAnyRef);
    UNION(array_type, kWasmStringRef, kWasmAnyRef);
    UNION(function_type, kWasmStringRef, kWasmBottom);

    UNION(struct_type, kWasmRefNullExternString, kWasmBottom);
    UNION(array_type, kWasmRefNullExternString, kWasmBottom);
    UNION(function_type, kWasmRefNullExternString, kWasmBottom);

    // Indexed types of different kinds.
    UNION(struct_type, array_type, kWasmEqRef.AsNonNull());
    INTERSECTION(struct_type, array_type, kWasmBottom);
    INTERSECTION(struct_type, function_type, kWasmBottom);
    INTERSECTION(array_type, function_type, kWasmBottom);

    // Nullable vs. non-nullable.
    UNION(struct_type, struct_type.AsNullable(), struct_type.AsNullable());
    INTERSECTION(struct_type, struct_type.AsNullable(), struct_type);
    UNION(kWasmStructRef, kWasmStructRef.AsNullable(),
          kWasmStructRef.AsNullable());
    INTERSECTION(kWasmStructRef, kWasmStructRef.AsNullable(), kWasmStructRef);

    // Concrete types of the same kind.
    // Subtyping relation.
    UNION_M(refNull(4), ref(1), refNull(1), module1);
    INTERSECTION_M(refNull(4), ref(1), ref(4), module1);
    INTERSECTION_M(refNull(1), refNull(4), refNull(4), module);
    // Common ancestor.
    UNION_M(ref(4), ref(31), ref(1), module1);
    INTERSECTION(ref(4), ref(31), kWasmBottom);
    // No common ancestor.
    UNION(ref(6), refNull(2), kWasmArrayRef.AsNullable());
    INTERSECTION(ref(6), refNull(2), kWasmBottom);
    UNION(ref(0), ref(17), kWasmStructRef.AsNonNull());
    INTERSECTION(ref(0), ref(17), kWasmBottom);
    UNION(ref(10), refNull(11), kWasmFuncRef);
    INTERSECTION(ref(10), refNull(11), kWasmBottom);

    // Shared types
    ValueType struct_shared = ref(40);
    ValueType function_shared = ref(41);
    UNION(struct_shared, struct_shared.AsNullable(),
          struct_shared.AsNullable());
    UNION(struct_shared, struct_type, kWasmBottom);
    UNION(struct_shared, function_shared, kWasmBottom);
    UNION(struct_shared, ValueType::Ref(HeapType::kI31Shared),
          ValueType::Ref(HeapType::kEqShared));
    UNION(struct_shared, ValueType::Ref(HeapType::kAnyShared),
          ValueType::Ref(HeapType::kAnyShared));
    UNION(struct_shared, ValueType::Ref(HeapType::kNoneShared), struct_shared);
    UNION(struct_shared, ValueType::Ref(HeapType::kAny), kWasmBottom);
    INTERSECTION(struct_shared, struct_shared.AsNullable(), struct_shared);
    INTERSECTION(struct_shared, struct_type, kWasmBottom);
    INTERSECTION(struct_shared, function_shared, kWasmBottom);
    INTERSECTION(struct_shared.AsNullable(),
                 ValueType::RefNull(HeapType::kI31Shared),
                 ValueType::RefNull(HeapType::kNoneShared));
    INTERSECTION(struct_shared, ValueType::Ref(HeapType::kAnyShared),
                 struct_shared);
    INTERSECTION(struct_shared.AsNullable(),
                 ValueType::RefNull(HeapType::kNoneShared),
                 ValueType::RefNull(HeapType::kNoneShared));
    INTERSECTION(struct_shared, ValueType::Ref(HeapType::kAny), kWasmBottom);
    UNION(function_shared, ValueType::Ref(HeapType::kFuncShared),
          ValueType::Ref(HeapType::kFuncShared));
    UNION(function_shared, ValueType::Ref(HeapType::kFunc), kWasmBottom);
    UNION(function_shared, ValueType::Ref(HeapType::kEqShared), kWasmBottom);
    UNION(function_shared, ValueType::Ref(HeapType::kNoFuncShared),
          function_shared);
    UNION(function_shared, ValueType::Ref(HeapType::kNoExternShared),
          kWasmBottom);
    INTERSECTION(function_shared, ValueType::Ref(HeapType::kFuncShared),
                 function_shared);
    INTERSECTION(function_shared, ValueType::Ref(HeapType::kFunc), kWasmBottom);
    INTERSECTION(function_shared, ValueType::Ref(HeapType::kEqShared),
                 kWasmBottom);
    INTERSECTION(function_shared.AsNullable(),
                 ValueType::RefNull(HeapType::kNoFuncShared),
                 ValueType::RefNull(HeapType::kNoFuncShared));
    INTERSECTION(function_shared, ValueType::Ref(HeapType::kNoExternShared),
                 kWasmBottom);
  }
#undef SUBTYPE
#undef NOT_SUBTYPE
#undef SUBTYPE_IFF
#undef VALID_SUBTYPE
#undef NOT_VALID_SUBTYPE
#undef IDENTICAL
#undef DISTINCT
#undef UNION
#undef UNION_M
#undef INTERSECTION
#undef INTERSECTION_M
}

}  // namespace v8::internal::wasm::subtyping_unittest
                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/unittests/wasm/trap-handler-native-unittest.cc                             0000664 0000000 0000000 00000063707 14746647661 0026103 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "include/v8config.h"

#if V8_OS_LINUX || V8_OS_FREEBSD
#include <signal.h>
#include <ucontext.h>
#elif V8_OS_DARWIN
#include <signal.h>
#include <sys/ucontext.h>
#elif V8_OS_WIN
#include <windows.h>
#endif

#include "testing/gtest/include/gtest/gtest.h"

#if V8_OS_POSIX
#include "include/v8-wasm-trap-handler-posix.h"
#elif V8_OS_WIN
#include "include/v8-wasm-trap-handler-win.h"
#endif
#include "src/base/page-allocator.h"
#include "src/base/vector.h"
#include "src/codegen/assembler-inl.h"
#include "src/codegen/macro-assembler-inl.h"
#include "src/execution/simulator.h"
#include "src/objects/backing-store.h"
#include "src/trap-handler/trap-handler.h"
#include "src/utils/allocation.h"
#include "src/wasm/wasm-engine.h"
#include "test/common/assembler-tester.h"
#include "test/unittests/test-utils.h"

#if V8_TRAP_HANDLER_SUPPORTED

#if V8_HOST_ARCH_ARM64 && (!V8_OS_LINUX && !V8_OS_DARWIN)
#error Unsupported platform
#endif

namespace v8 {
namespace internal {
namespace wasm {

namespace {
#if V8_HOST_ARCH_X64
constexpr Register scratch = r10;
#endif
bool g_test_handler_executed = false;
#if V8_OS_LINUX || V8_OS_DARWIN || V8_OS_FREEBSD
struct sigaction g_old_segv_action;
struct sigaction g_old_other_action;  // FPE or TRAP, depending on x64 or arm64.
struct sigaction g_old_bus_action;    // We get SIGBUS on Mac sometimes.
#elif V8_OS_WIN
void* g_registered_handler = nullptr;
#endif

// The recovery address allows us to recover from an intentional crash.
Address g_recovery_address;
// Flag to indicate if the test handler should call the trap handler as a first
// chance handler.
bool g_use_as_first_chance_handler = false;
}  // namespace

#define __ masm.

enum TrapHandlerStyle : int {
  // The test uses the default trap handler of V8.
  kDefault = 0,
  // The test installs the trap handler callback in its own test handler.
  kCallback = 1
};

std::string PrintTrapHandlerTestParam(
    ::testing::TestParamInfo<TrapHandlerStyle> info) {
  switch (info.param) {
    case kDefault:
      return "DefaultTrapHandler";
    case kCallback:
      return "Callback";
  }
  UNREACHABLE();
}

class TrapHandlerTest : public TestWithIsolate,
                        public ::testing::WithParamInterface<TrapHandlerStyle> {
 protected:
  void SetUp() override {
    InstallFallbackHandler();
    SetupTrapHandler(GetParam());
    backing_store_ = BackingStore::AllocateWasmMemory(
        i_isolate(), 1, 1, WasmMemoryFlag::kWasmMemory32,
        SharedFlag::kNotShared);
    CHECK(backing_store_);
    EXPECT_TRUE(backing_store_->has_guard_regions());
    // The allocated backing store ends with a guard page.
    crash_address_ = reinterpret_cast<Address>(backing_store_->buffer_start()) +
                     backing_store_->byte_length() + 32;
    // Allocate a buffer for the generated code.
    buffer_ = AllocateAssemblerBuffer(AssemblerBase::kDefaultBufferSize,
                                      GetRandomMmapAddr());

    InitRecoveryCode();
  }

  void InstallFallbackHandler() {
#if V8_OS_LINUX || V8_OS_DARWIN || V8_OS_FREEBSD
    // Set up a signal handler to recover from the expected crash.
    struct sigaction action;
    action.sa_sigaction = SignalHandler;
    sigemptyset(&action.sa_mask);
    action.sa_flags = SA_SIGINFO;
    // SIGSEGV happens for wasm oob memory accesses on Linux.
    EXPECT_EQ(0, sigaction(SIGSEGV, &action, &g_old_segv_action));
    // SIGBUS happens for wasm oob memory accesses on macOS.
    EXPECT_EQ(0, sigaction(SIGBUS, &action, &g_old_bus_action));
#if V8_HOST_ARCH_X64
    // SIGFPE to simulate crashes which are not handled by the trap handler.
    EXPECT_EQ(0, sigaction(SIGFPE, &action, &g_old_other_action));
#elif V8_HOST_ARCH_ARM64
    // SIGTRAP to simulate crashes which are not handled by the trap handler.
    EXPECT_EQ(0, sigaction(SIGTRAP, &action, &g_old_other_action));
#elif V8_HOST_ARCH_LOONG64
    // SIGTRAP to simulate crashes which are not handled by the trap handler.
    EXPECT_EQ(0, sigaction(SIGTRAP, &action, &g_old_other_action));
#elif V8_HOST_ARCH_RISCV64
    // SIGTRAP to simulate crashes which are not handled by the trap handler.
    EXPECT_EQ(0, sigaction(SIGTRAP, &action, &g_old_other_action));
#else
#error Unsupported platform
#endif
#elif V8_OS_WIN
    g_registered_handler =
        AddVectoredExceptionHandler(/*first=*/0, TestHandler);
#endif
  }

  void TearDown() override {
    // We should always have left wasm code.
    EXPECT_TRUE(!GetThreadInWasmFlag());
    buffer_.reset();
    recovery_buffer_.reset();
    backing_store_.reset();

    // Clean up the trap handler
    trap_handler::RemoveTrapHandler();
    if (!g_test_handler_executed) {
#if V8_OS_LINUX || V8_OS_DARWIN || V8_OS_FREEBSD
      // The test handler cleans up the signal handler setup in the test. If the
      // test handler was not called, we have to do the cleanup ourselves.
      EXPECT_EQ(0, sigaction(SIGSEGV, &g_old_segv_action, nullptr));
      EXPECT_EQ(0, sigaction(SIGBUS, &g_old_bus_action, nullptr));
#if V8_HOST_ARCH_X64
      EXPECT_EQ(0, sigaction(SIGFPE, &g_old_other_action, nullptr));
#elif V8_HOST_ARCH_ARM64
      EXPECT_EQ(0, sigaction(SIGTRAP, &g_old_other_action, nullptr));
#elif V8_HOST_ARCH_LOONG64
      EXPECT_EQ(0, sigaction(SIGTRAP, &g_old_other_action, nullptr));
#elif V8_HOST_ARCH_RISCV64
      EXPECT_EQ(0, sigaction(SIGTRAP, &g_old_other_action, nullptr));
#else
#error Unsupported platform
#endif
#elif V8_OS_WIN
      RemoveVectoredExceptionHandler(g_registered_handler);
      g_registered_handler = nullptr;
#endif
    }
  }

  void InitRecoveryCode() {
    // Create a code snippet where we can jump to to recover from a signal or
    // exception. The code snippet only consists of a return statement.
    recovery_buffer_ = AllocateAssemblerBuffer(
        AssemblerBase::kDefaultBufferSize, GetRandomMmapAddr());

    MacroAssembler masm(nullptr, AssemblerOptions{}, CodeObjectRequired::kNo,
                        recovery_buffer_->CreateView());
    int recovery_offset = __ pc_offset();
#if V8_HOST_ARCH_X64
    __ Pop(scratch);
#endif
    __ Ret();
    CodeDesc desc;
    masm.GetCode(static_cast<LocalIsolate*>(nullptr), &desc);
    recovery_buffer_->MakeExecutable();
    g_recovery_address =
        reinterpret_cast<Address>(desc.buffer + recovery_offset);
  }

#if V8_OS_LINUX || V8_OS_DARWIN || V8_OS_FREEBSD
  static void SignalHandler(int signal, siginfo_t* info, void* context) {
    if (g_use_as_first_chance_handler) {
      if (v8::TryHandleWebAssemblyTrapPosix(signal, info, context)) {
        return;
      }
    }

    // Reset the signal handler, to avoid that this signal handler is called
    // repeatedly.
    sigaction(SIGSEGV, &g_old_segv_action, nullptr);
#if V8_HOST_ARCH_X64
    sigaction(SIGFPE, &g_old_other_action, nullptr);
#elif V8_HOST_ARCH_ARM64
    sigaction(SIGTRAP, &g_old_other_action, nullptr);
#elif V8_HOST_ARCH_LOONG64
    sigaction(SIGTRAP, &g_old_other_action, nullptr);
#elif V8_HOST_ARCH_RISCV64
    sigaction(SIGTRAP, &g_old_other_action, nullptr);
#else
#error Unsupported platform
#endif
    sigaction(SIGBUS, &g_old_bus_action, nullptr);

    g_test_handler_executed = true;
    // Set the $rip to the recovery code.
    ucontext_t* uc = reinterpret_cast<ucontext_t*>(context);
#if V8_OS_DARWIN && V8_HOST_ARCH_ARM64
    uc->uc_mcontext->__ss.__pc = g_recovery_address;
#elif V8_OS_DARWIN && V8_HOST_ARCH_X64
    uc->uc_mcontext->__ss.__rip = g_recovery_address;
#elif V8_OS_LINUX && V8_HOST_ARCH_ARM64
    uc->uc_mcontext.pc = g_recovery_address;
#elif V8_OS_LINUX && V8_HOST_ARCH_LOONG64
    uc->uc_mcontext.__pc = g_recovery_address;
#elif V8_OS_LINUX && V8_HOST_ARCH_RISCV64
    uc->uc_mcontext.__gregs[REG_PC] = g_recovery_address;
#elif V8_OS_LINUX && V8_HOST_ARCH_X64
    uc->uc_mcontext.gregs[REG_RIP] = g_recovery_address;
#elif V8_OS_FREEBSD
    uc->uc_mcontext.mc_rip = g_recovery_address;
#else
#error Unsupported platform
#endif
  }
#endif

#if V8_OS_WIN
  static LONG WINAPI TestHandler(EXCEPTION_POINTERS* exception) {
    if (g_use_as_first_chance_handler) {
      if (v8::TryHandleWebAssemblyTrapWindows(exception)) {
        return EXCEPTION_CONTINUE_EXECUTION;
      }
    }
    RemoveVectoredExceptionHandler(g_registered_handler);
    g_registered_handler = nullptr;
    g_test_handler_executed = true;
    exception->ContextRecord->Rip = g_recovery_address;
    return EXCEPTION_CONTINUE_EXECUTION;
  }
#endif

  void SetupTrapHandler(TrapHandlerStyle style) {
    bool use_default_handler = style == kDefault;
    g_use_as_first_chance_handler = !use_default_handler;
    CHECK(v8::V8::EnableWebAssemblyTrapHandler(use_default_handler));
  }

 public:
  void GenerateSetThreadInWasmFlagCode(MacroAssembler* masm) {
#if V8_HOST_ARCH_X64
    masm->Move(scratch,
               i_isolate()->thread_local_top()->thread_in_wasm_flag_address_,
               RelocInfo::NO_INFO);
    masm->movl(MemOperand(scratch, 0), Immediate(1));
#elif V8_HOST_ARCH_ARM64
    UseScratchRegisterScope temps(masm);
    Register addr = temps.AcquireX();
    masm->Mov(addr,
              i_isolate()->thread_local_top()->thread_in_wasm_flag_address_);
    Register one = temps.AcquireX();
    masm->Mov(one, 1);
    masm->Str(one, MemOperand(addr));
#elif V8_HOST_ARCH_LOONG64
    UseScratchRegisterScope temps(masm);
    Register addr = temps.Acquire();
    masm->li(
        addr,
        static_cast<int64_t>(
            i_isolate()->thread_local_top()->thread_in_wasm_flag_address_));
    Register one = temps.Acquire();
    masm->li(one, 1);
    masm->St_d(one, MemOperand(addr, 0));
#elif V8_HOST_ARCH_RISCV64
    UseScratchRegisterScope temps(masm);
    Register addr = temps.Acquire();
    masm->li(
        addr,
        static_cast<int64_t>(
            i_isolate()->thread_local_top()->thread_in_wasm_flag_address_));
    Register one = temps.Acquire();
    masm->li(one, 1);
    masm->StoreWord(one, MemOperand(addr, 0));
#else
#error Unsupported platform
#endif
  }

  void GenerateResetThreadInWasmFlagCode(MacroAssembler* masm) {
#if V8_HOST_ARCH_X64
    masm->Move(scratch,
               i_isolate()->thread_local_top()->thread_in_wasm_flag_address_,
               RelocInfo::NO_INFO);
    masm->movl(MemOperand(scratch, 0), Immediate(0));
#elif V8_HOST_ARCH_ARM64
    UseScratchRegisterScope temps(masm);
    Register addr = temps.AcquireX();
    masm->Mov(addr,
              i_isolate()->thread_local_top()->thread_in_wasm_flag_address_);
    masm->Str(xzr, MemOperand(addr));
#elif V8_HOST_ARCH_LOONG64
    UseScratchRegisterScope temps(masm);
    Register addr = temps.Acquire();
    masm->li(
        addr,
        static_cast<int64_t>(
            i_isolate()->thread_local_top()->thread_in_wasm_flag_address_));
    masm->St_d(zero_reg, MemOperand(addr, 0));
#elif V8_HOST_ARCH_RISCV64
    UseScratchRegisterScope temps(masm);
    Register addr = temps.Acquire();
    masm->li(
        addr,
        static_cast<int64_t>(
            i_isolate()->thread_local_top()->thread_in_wasm_flag_address_));
    masm->StoreWord(zero_reg, MemOperand(addr, 0));
#else
#error Unsupported platform
#endif
  }

  bool GetThreadInWasmFlag() {
    return *reinterpret_cast<int*>(
        trap_handler::GetThreadInWasmThreadLocalAddress());
  }

  // Execute the code in buffer.
  void ExecuteBuffer() {
    buffer_->MakeExecutable();
    GeneratedCode<void>::FromAddress(
        i_isolate(), reinterpret_cast<Address>(buffer_->start()))
        .Call();
    EXPECT_FALSE(g_test_handler_executed);
  }

  // Execute the code in buffer. We expect a crash which we recover from in the
  // test handler.
  void ExecuteExpectCrash(TestingAssemblerBuffer* buffer,
                          bool check_wasm_flag = true) {
    EXPECT_FALSE(g_test_handler_executed);
    buffer->MakeExecutable();
    GeneratedCode<void>::FromAddress(i_isolate(),
                                     reinterpret_cast<Address>(buffer->start()))
        .Call();
    EXPECT_TRUE(g_test_handler_executed);
    g_test_handler_executed = false;
    if (check_wasm_flag) {
      EXPECT_FALSE(GetThreadInWasmFlag());
    }
  }

  bool test_handler_executed() { return g_test_handler_executed; }

  // The backing store used for testing the trap handler.
  std::unique_ptr<BackingStore> backing_store_;

  // Address within the guard region of the wasm memory. Accessing this memory
  // address causes a signal or exception.
  Address crash_address_;

  // Buffer for generated code.
  std::unique_ptr<TestingAssemblerBuffer> buffer_;
  // Buffer for the code for the landing pad of the test handler.
  std::unique_ptr<TestingAssemblerBuffer> recovery_buffer_;
};

// TODO(almuthanna): These tests were skipped because they cause a crash when
// they are ran on Fuchsia. This issue should be solved later on
// Ticket: https://crbug.com/1028617
#if !defined(V8_TARGET_OS_FUCHSIA)
TEST_P(TrapHandlerTest, TestTrapHandlerRecovery) {
  // Test that the wasm trap handler can recover a memory access violation in
  // wasm code (we fake the wasm code and the access violation).
  MacroAssembler masm(nullptr, AssemblerOptions{}, CodeObjectRequired::kNo,
                      buffer_->CreateView());
#if V8_HOST_ARCH_X64
  __ Push(scratch);
  GenerateSetThreadInWasmFlagCode(&masm);
  __ Move(scratch, crash_address_, RelocInfo::NO_INFO);
  uint32_t crash_offset = __ pc_offset();
  __ testl(MemOperand(scratch, 0), Immediate(1));
  uint32_t recovery_offset = __ pc_offset();
  GenerateResetThreadInWasmFlagCode(&masm);
  __ Pop(scratch);
#elif V8_HOST_ARCH_ARM64
  GenerateSetThreadInWasmFlagCode(&masm);
  UseScratchRegisterScope temps(&masm);
  Register scratch = temps.AcquireX();
  __ Mov(scratch, crash_address_);
  uint32_t crash_offset = __ pc_offset();
  __ Ldr(scratch, MemOperand(scratch));
  uint32_t recovery_offset = __ pc_offset();
  GenerateResetThreadInWasmFlagCode(&masm);
#elif V8_HOST_ARCH_LOONG64
  GenerateSetThreadInWasmFlagCode(&masm);
  UseScratchRegisterScope temps(&masm);
  Register scratch = temps.Acquire();
  __ li(scratch, static_cast<int64_t>(crash_address_));
  uint32_t crash_offset = __ pc_offset();
  __ Ld_d(scratch, MemOperand(scratch, 0));
  uint32_t recovery_offset = __ pc_offset();
  GenerateResetThreadInWasmFlagCode(&masm);
#elif V8_HOST_ARCH_RISCV64
  GenerateSetThreadInWasmFlagCode(&masm);
  UseScratchRegisterScope temps(&masm);
  Register scratch = temps.Acquire();
  __ li(scratch, static_cast<int64_t>(crash_address_));
  uint32_t crash_offset = __ pc_offset();
  __ LoadWord(scratch, MemOperand(scratch, 0));
  uint32_t recovery_offset = __ pc_offset();
  GenerateResetThreadInWasmFlagCode(&masm);
#else
#error Unsupported platform
#endif
  __ Ret();
  CodeDesc desc;
  masm.GetCode(static_cast<LocalIsolate*>(nullptr), &desc);

  trap_handler::ProtectedInstructionData protected_instruction{crash_offset};
  trap_handler::RegisterHandlerData(reinterpret_cast<Address>(desc.buffer),
                                    desc.instr_size, 1, &protected_instruction);

  uintptr_t landing_pad =
      reinterpret_cast<uintptr_t>(buffer_->start()) + recovery_offset;
  trap_handler::SetLandingPad(landing_pad);
  ExecuteBuffer();
  trap_handler::SetLandingPad(0);
}

TEST_P(TrapHandlerTest, TestReleaseHandlerData) {
  // Test that after we release handler data in the trap handler, it cannot
  // recover from the specific memory access violation anymore.
  MacroAssembler masm(nullptr, AssemblerOptions{}, CodeObjectRequired::kNo,
                      buffer_->CreateView());
#if V8_HOST_ARCH_X64
  __ Push(scratch);
  GenerateSetThreadInWasmFlagCode(&masm);
  __ Move(scratch, crash_address_, RelocInfo::NO_INFO);
  uint32_t crash_offset = __ pc_offset();
  __ testl(MemOperand(scratch, 0), Immediate(1));
  uint32_t recovery_offset = __ pc_offset();
  GenerateResetThreadInWasmFlagCode(&masm);
  __ Pop(scratch);
#elif V8_HOST_ARCH_ARM64
  GenerateSetThreadInWasmFlagCode(&masm);
  UseScratchRegisterScope temps(&masm);
  Register scratch = temps.AcquireX();
  __ Mov(scratch, crash_address_);
  uint32_t crash_offset = __ pc_offset();
  __ Ldr(scratch, MemOperand(scratch));
  uint32_t recovery_offset = __ pc_offset();
  GenerateResetThreadInWasmFlagCode(&masm);
#elif V8_HOST_ARCH_LOONG64
  GenerateSetThreadInWasmFlagCode(&masm);
  UseScratchRegisterScope temps(&masm);
  Register scratch = temps.Acquire();
  __ li(scratch, static_cast<int64_t>(crash_address_));
  uint32_t crash_offset = __ pc_offset();
  __ Ld_d(scratch, MemOperand(scratch, 0));
  uint32_t recovery_offset = __ pc_offset();
  GenerateResetThreadInWasmFlagCode(&masm);
#elif V8_HOST_ARCH_RISCV64
  GenerateSetThreadInWasmFlagCode(&masm);
  UseScratchRegisterScope temps(&masm);
  Register scratch = temps.Acquire();
  __ li(scratch, static_cast<int64_t>(crash_address_));
  uint32_t crash_offset = __ pc_offset();
  __ LoadWord(scratch, MemOperand(scratch, 0));
  uint32_t recovery_offset = __ pc_offset();
  GenerateResetThreadInWasmFlagCode(&masm);
#else
#error Unsupported platform
#endif
  __ Ret();
  CodeDesc desc;
  masm.GetCode(static_cast<LocalIsolate*>(nullptr), &desc);

  trap_handler::ProtectedInstructionData protected_instruction{crash_offset};
  int handler_id = trap_handler::RegisterHandlerData(
      reinterpret_cast<Address>(desc.buffer), desc.instr_size, 1,
      &protected_instruction);

  uintptr_t landing_pad =
      reinterpret_cast<uintptr_t>(buffer_->start()) + recovery_offset;
  trap_handler::SetLandingPad(landing_pad);
  ExecuteBuffer();
  // Deregister from the trap handler. The trap handler should not do the
  // recovery now.
  trap_handler::ReleaseHandlerData(handler_id);

  ExecuteExpectCrash(buffer_.get());
  trap_handler::SetLandingPad(0);
}

TEST_P(TrapHandlerTest, TestNoThreadInWasmFlag) {
  // That that if the thread_in_wasm flag is not set, the trap handler does not
  // get active.
  MacroAssembler masm(nullptr, AssemblerOptions{}, CodeObjectRequired::kNo,
                      buffer_->CreateView());
#if V8_HOST_ARCH_X64
  __ Push(scratch);
  __ Move(scratch, crash_address_, RelocInfo::NO_INFO);
  uint32_t crash_offset = __ pc_offset();
  __ testl(MemOperand(scratch, 0), Immediate(1));
  __ Pop(scratch);
#elif V8_HOST_ARCH_ARM64
  UseScratchRegisterScope temps(&masm);
  Register scratch = temps.AcquireX();
  __ Mov(scratch, crash_address_);
  uint32_t crash_offset = __ pc_offset();
  __ Ldr(scratch, MemOperand(scratch));
#elif V8_HOST_ARCH_LOONG64
  UseScratchRegisterScope temps(&masm);
  Register scratch = temps.Acquire();
  __ li(scratch, static_cast<int64_t>(crash_address_));
  uint32_t crash_offset = __ pc_offset();
  __ Ld_d(scratch, MemOperand(scratch, 0));
#elif V8_HOST_ARCH_RISCV64
  UseScratchRegisterScope temps(&masm);
  Register scratch = temps.Acquire();
  __ li(scratch, static_cast<int64_t>(crash_address_));
  uint32_t crash_offset = __ pc_offset();
  __ LoadWord(scratch, MemOperand(scratch, 0));
#else
#error Unsupported platform
#endif
  __ Ret();
  CodeDesc desc;
  masm.GetCode(static_cast<LocalIsolate*>(nullptr), &desc);

  trap_handler::ProtectedInstructionData protected_instruction{crash_offset};
  trap_handler::RegisterHandlerData(reinterpret_cast<Address>(desc.buffer),
                                    desc.instr_size, 1, &protected_instruction);

  ExecuteExpectCrash(buffer_.get());
}

TEST_P(TrapHandlerTest, TestCrashInWasmNoProtectedInstruction) {
  // Test that if the crash in wasm happened at an instruction which is not
  // protected, then the trap handler does not handle it.
  MacroAssembler masm(nullptr, AssemblerOptions{}, CodeObjectRequired::kNo,
                      buffer_->CreateView());
#if V8_HOST_ARCH_X64
  __ Push(scratch);
  GenerateSetThreadInWasmFlagCode(&masm);
  uint32_t no_crash_offset = __ pc_offset();
  __ Move(scratch, crash_address_, RelocInfo::NO_INFO);
  __ testl(MemOperand(scratch, 0), Immediate(1));
  GenerateResetThreadInWasmFlagCode(&masm);
  __ Pop(scratch);
#elif V8_HOST_ARCH_ARM64
  GenerateSetThreadInWasmFlagCode(&masm);
  UseScratchRegisterScope temps(&masm);
  Register scratch = temps.AcquireX();
  uint32_t no_crash_offset = __ pc_offset();
  __ Mov(scratch, crash_address_);
  __ Ldr(scratch, MemOperand(scratch));
  GenerateResetThreadInWasmFlagCode(&masm);
#elif V8_HOST_ARCH_LOONG64
  GenerateSetThreadInWasmFlagCode(&masm);
  UseScratchRegisterScope temps(&masm);
  Register scratch = temps.Acquire();
  uint32_t no_crash_offset = __ pc_offset();
  __ li(scratch, static_cast<int64_t>(crash_address_));
  __ Ld_d(scratch, MemOperand(scratch, 0));
  GenerateResetThreadInWasmFlagCode(&masm);
#elif V8_HOST_ARCH_RISCV64
  GenerateSetThreadInWasmFlagCode(&masm);
  UseScratchRegisterScope temps(&masm);
  Register scratch = temps.Acquire();
  uint32_t no_crash_offset = __ pc_offset();
  __ li(scratch, static_cast<int64_t>(crash_address_));
  __ LoadWord(scratch, MemOperand(scratch, 0));
  GenerateResetThreadInWasmFlagCode(&masm);
#else
#error Unsupported platform
#endif
  __ Ret();
  CodeDesc desc;
  masm.GetCode(static_cast<LocalIsolate*>(nullptr), &desc);

  trap_handler::ProtectedInstructionData protected_instruction{no_crash_offset};
  trap_handler::RegisterHandlerData(reinterpret_cast<Address>(desc.buffer),
                                    desc.instr_size, 1, &protected_instruction);

  ExecuteExpectCrash(buffer_.get());
}

TEST_P(TrapHandlerTest, TestCrashInWasmWrongCrashType) {
  // Test that if the crash reason is not a memory access violation, then the
  // wasm trap handler does not handle it.
  MacroAssembler masm(nullptr, AssemblerOptions{}, CodeObjectRequired::kNo,
                      buffer_->CreateView());
#if V8_HOST_ARCH_X64
  __ Push(scratch);
  GenerateSetThreadInWasmFlagCode(&masm);
  __ xorq(scratch, scratch);
  uint32_t crash_offset = __ pc_offset();
  __ divq(scratch);
  GenerateResetThreadInWasmFlagCode(&masm);
  __ Pop(scratch);
#elif V8_HOST_ARCH_ARM64
  GenerateSetThreadInWasmFlagCode(&masm);
  UseScratchRegisterScope temps(&masm);
  uint32_t crash_offset = __ pc_offset();
  __ Trap();
  GenerateResetThreadInWasmFlagCode(&masm);
#elif V8_HOST_ARCH_LOONG64
  GenerateSetThreadInWasmFlagCode(&masm);
  UseScratchRegisterScope temps(&masm);
  uint32_t crash_offset = __ pc_offset();
  __ Trap();
  GenerateResetThreadInWasmFlagCode(&masm);
#elif V8_HOST_ARCH_RISCV64
  GenerateSetThreadInWasmFlagCode(&masm);
  UseScratchRegisterScope temps(&masm);
  uint32_t crash_offset = __ pc_offset();
  __ Trap();
  GenerateResetThreadInWasmFlagCode(&masm);
#else
#error Unsupported platform
#endif
  __ Ret();
  CodeDesc desc;
  masm.GetCode(static_cast<LocalIsolate*>(nullptr), &desc);

  trap_handler::ProtectedInstructionData protected_instruction{crash_offset};
  trap_handler::RegisterHandlerData(reinterpret_cast<Address>(desc.buffer),
                                    desc.instr_size, 1, &protected_instruction);

#if V8_OS_POSIX
  // On Posix, the V8 default trap handler does not register for SIGFPE,
  // therefore the thread-in-wasm flag is never reset in this test. We
  // therefore do not check the value of this flag.
  bool check_wasm_flag = GetParam() != kDefault;
#elif V8_OS_WIN
  // On Windows, the trap handler returns immediately if not an exception of
  // interest.
  bool check_wasm_flag = false;
#else
  bool check_wasm_flag = true;
#endif
  ExecuteExpectCrash(buffer_.get(), check_wasm_flag);
  if (!check_wasm_flag) {
    // Reset the thread-in-wasm flag because it was probably not reset in the
    // trap handler.
    *trap_handler::GetThreadInWasmThreadLocalAddress() = 0;
  }
}
#endif

class CodeRunner : public v8::base::Thread {
 public:
  CodeRunner(TrapHandlerTest* test, TestingAssemblerBuffer* buffer)
      : Thread(Options("CodeRunner")), test_(test), buffer_(buffer) {}

  void Run() override { test_->ExecuteExpectCrash(buffer_); }

 private:
  TrapHandlerTest* test_;
  TestingAssemblerBuffer* buffer_;
};

// TODO(almuthanna): This test was skipped because it causes a crash when it is
// ran on Fuchsia. This issue should be solved later on
// Ticket: https://crbug.com/1028617
#if !defined(V8_TARGET_OS_FUCHSIA)
TEST_P(TrapHandlerTest, TestCrashInOtherThread) {
  // Test setup:
  // The current thread enters wasm land (sets the thread_in_wasm flag)
  // A second thread crashes at a protected instruction without having the flag
  // set.
  MacroAssembler masm(nullptr, AssemblerOptions{}, CodeObjectRequired::kNo,
                      buffer_->CreateView());
#if V8_HOST_ARCH_X64
  __ Push(scratch);
  __ Move(scratch, crash_address_, RelocInfo::NO_INFO);
  uint32_t crash_offset = __ pc_offset();
  __ testl(MemOperand(scratch, 0), Immediate(1));
  __ Pop(scratch);
#elif V8_HOST_ARCH_ARM64
  UseScratchRegisterScope temps(&masm);
  Register scratch = temps.AcquireX();
  __ Mov(scratch, crash_address_);
  uint32_t crash_offset = __ pc_offset();
  __ Ldr(scratch, MemOperand(scratch));
#elif V8_HOST_ARCH_LOONG64
  UseScratchRegisterScope temps(&masm);
  Register scratch = temps.Acquire();
  __ li(scratch, static_cast<int64_t>(crash_address_));
  uint32_t crash_offset = __ pc_offset();
  __ Ld_d(scratch, MemOperand(scratch, 0));
#elif V8_HOST_ARCH_RISCV64
  UseScratchRegisterScope temps(&masm);
  Register scratch = temps.Acquire();
  __ li(scratch, static_cast<int64_t>(crash_address_));
  uint32_t crash_offset = __ pc_offset();
  __ LoadWord(scratch, MemOperand(scratch, 0));
#else
#error Unsupported platform
#endif
  __ Ret();
  CodeDesc desc;
  masm.GetCode(static_cast<LocalIsolate*>(nullptr), &desc);

  trap_handler::ProtectedInstructionData protected_instruction{crash_offset};
  trap_handler::RegisterHandlerData(reinterpret_cast<Address>(desc.buffer),
                                    desc.instr_size, 1, &protected_instruction);

  CodeRunner runner(this, buffer_.get());
  EXPECT_FALSE(GetThreadInWasmFlag());
  // Set the thread-in-wasm flag manually in this thread.
  *trap_handler::GetThreadInWasmThreadLocalAddress() = 1;
  EXPECT_TRUE(runner.Start());
  runner.Join();
  EXPECT_TRUE(GetThreadInWasmFlag());
  // Reset the thread-in-wasm flag.
  *trap_handler::GetThreadInWasmThreadLocalAddress() = 0;
}
#endif

#if !V8_OS_FUCHSIA
INSTANTIATE_TEST_SUITE_P(Traps, TrapHandlerTest,
                         ::testing::Values(kDefault, kCallback),
                         PrintTrapHandlerTestParam);
#endif  // !V8_OS_FUCHSIA

#undef __
}  // namespace wasm
}  // namespace internal
}  // namespace v8

#endif
                                                         node-23.7.0/deps/v8/test/unittests/wasm/trap-handler-posix-unittest.cc                              0000664 0000000 0000000 00000003753 14746647661 0025752 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "include/v8-initialization.h"
#include "src/trap-handler/trap-handler.h"
#include "testing/gtest/include/gtest/gtest.h"

#if V8_OS_POSIX
#include <setjmp.h>
#include <signal.h>
#endif

namespace {

#if V8_TRAP_HANDLER_SUPPORTED

void CrashOnPurpose() { *reinterpret_cast<volatile int*>(42); }

// When using V8::RegisterDefaultSignalHandler, we save the old one to fall back
// on if V8 doesn't handle the signal. This allows tools like ASan to register a
// handler early on during the process startup and still generate stack traces
// on failures.
class SignalHandlerFallbackTest : public ::testing::Test {
 protected:
  void SetUp() override {
    struct sigaction action;
    action.sa_sigaction = SignalHandler;
    sigemptyset(&action.sa_mask);
    action.sa_flags = SA_SIGINFO;
    sigaction(SIGSEGV, &action, &old_segv_action_);
    sigaction(SIGBUS, &action, &old_bus_action_);
  }

  void TearDown() override {
    // be a good citizen and restore the old signal handler.
    sigaction(SIGSEGV, &old_segv_action_, nullptr);
    sigaction(SIGBUS, &old_bus_action_, nullptr);
  }

  static sigjmp_buf continuation_;

 private:
  static void SignalHandler(int signal, siginfo_t* info, void*) {
    siglongjmp(continuation_, 1);
  }
  struct sigaction old_segv_action_;
  struct sigaction old_bus_action_;  // We get SIGBUS on Mac sometimes.
};
sigjmp_buf SignalHandlerFallbackTest::continuation_;

TEST_F(SignalHandlerFallbackTest, DoTest) {
  const int save_sigs = 1;
  if (!sigsetjmp(continuation_, save_sigs)) {
    constexpr bool kUseDefaultTrapHandler = true;
    EXPECT_TRUE(v8::V8::EnableWebAssemblyTrapHandler(kUseDefaultTrapHandler));
    CrashOnPurpose();
    FAIL();
  } else {
    // Our signal handler ran.
    v8::internal::trap_handler::RemoveTrapHandler();
    SUCCEED();
    return;
  }
  FAIL();
}

#endif

}  //  namespace
                     node-23.7.0/deps/v8/test/unittests/wasm/trap-handler-simulator-unittest.cc                          0000664 0000000 0000000 00000014261 14746647661 0026623 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/trap-handler/trap-handler-simulator.h"

#include <cstdint>

#include "include/v8-initialization.h"
#include "src/codegen/macro-assembler-inl.h"
#include "src/execution/simulator.h"
#include "src/trap-handler/trap-handler.h"
#include "test/common/assembler-tester.h"
#include "test/unittests/test-utils.h"

#ifdef V8_TRAP_HANDLER_VIA_SIMULATOR

namespace v8 {
namespace internal {
namespace trap_handler {

constexpr uintptr_t kFakePc = 11;

class SimulatorTrapHandlerTest : public TestWithIsolate {
 public:
  ~SimulatorTrapHandlerTest() {
    if (inaccessible_memory_) {
      auto* page_allocator = GetArrayBufferPageAllocator();
      CHECK(page_allocator->FreePages(inaccessible_memory_,
                                      page_allocator->AllocatePageSize()));
    }
  }

  void SetThreadInWasm() {
    EXPECT_EQ(0, *thread_in_wasm);
    *thread_in_wasm = 1;
  }

  void ResetThreadInWasm() {
    EXPECT_EQ(1, *thread_in_wasm);
    *thread_in_wasm = 0;
  }

  uintptr_t InaccessibleMemoryPtr() {
    if (!inaccessible_memory_) {
      auto* page_allocator = GetArrayBufferPageAllocator();
      size_t page_size = page_allocator->AllocatePageSize();
      inaccessible_memory_ =
          reinterpret_cast<uint8_t*>(page_allocator->AllocatePages(
              nullptr, /* size */ page_size, /* align */ page_size,
              PageAllocator::kNoAccess));
      CHECK_NOT_NULL(inaccessible_memory_);
    }
    return reinterpret_cast<uintptr_t>(inaccessible_memory_);
  }

  int* thread_in_wasm = trap_handler::GetThreadInWasmThreadLocalAddress();

 private:
  uint8_t* inaccessible_memory_ = nullptr;
};

TEST_F(SimulatorTrapHandlerTest, ProbeMemorySuccess) {
  int x = 47;
  EXPECT_EQ(0u, ProbeMemory(reinterpret_cast<uintptr_t>(&x), kFakePc));
}

TEST_F(SimulatorTrapHandlerTest, ProbeMemoryFailNullptr) {
  constexpr uintptr_t kNullAddress = 0;
  EXPECT_DEATH_IF_SUPPORTED(ProbeMemory(kNullAddress, kFakePc), "");
}

TEST_F(SimulatorTrapHandlerTest, ProbeMemoryFailInaccessible) {
  EXPECT_DEATH_IF_SUPPORTED(ProbeMemory(InaccessibleMemoryPtr(), kFakePc), "");
}

TEST_F(SimulatorTrapHandlerTest, ProbeMemoryFailWhileInWasm) {
  // Test that we still crash if the trap handler is set up and the "thread in
  // wasm" flag is set, but the PC is not registered as a protected instruction.
  constexpr bool kUseDefaultHandler = true;
  CHECK(v8::V8::EnableWebAssemblyTrapHandler(kUseDefaultHandler));

  SetThreadInWasm();
  EXPECT_DEATH_IF_SUPPORTED(ProbeMemory(InaccessibleMemoryPtr(), kFakePc), "");
}

namespace {
uintptr_t v8_landing_pad() {
  EmbeddedData embedded_data = EmbeddedData::FromBlob();
  return embedded_data.InstructionStartOf(Builtin::kWasmTrapHandlerLandingPad);
}
}  // namespace

TEST_F(SimulatorTrapHandlerTest, ProbeMemoryWithTrapHandled) {
  constexpr bool kUseDefaultHandler = true;
  CHECK(v8::V8::EnableWebAssemblyTrapHandler(kUseDefaultHandler));

  ProtectedInstructionData fake_protected_instruction{kFakePc};
  int handler_data_index =
      RegisterHandlerData(0, 128, 1, &fake_protected_instruction);

  SetThreadInWasm();
  EXPECT_EQ(v8_landing_pad(), ProbeMemory(InaccessibleMemoryPtr(), kFakePc));

  // Reset everything.
  ResetThreadInWasm();
  ReleaseHandlerData(handler_data_index);
  RemoveTrapHandler();
}

TEST_F(SimulatorTrapHandlerTest, ProbeMemoryWithLandingPad) {
  EXPECT_EQ(0u, GetRecoveredTrapCount());

  // Test that the trap handler can recover a memory access violation in
  // wasm code (we fake the wasm code and the access violation).
  std::unique_ptr<TestingAssemblerBuffer> buffer = AllocateAssemblerBuffer();

#ifdef V8_TARGET_ARCH_ARM64
  constexpr Register scratch = x0;
  MacroAssembler masm(nullptr, AssemblerOptions{}, CodeObjectRequired::kNo,
                      buffer->CreateView());
  // Generate an illegal memory access.
  masm.Mov(scratch, InaccessibleMemoryPtr());
  uint32_t crash_offset = masm.pc_offset();
  masm.Str(scratch, MemOperand(scratch, 0));  // load from inaccessible memory.
  uint32_t recovery_offset = masm.pc_offset();
  // Return.
  masm.Ret();
#elif V8_TARGET_ARCH_LOONG64
  constexpr Register scratch = a0;
  MacroAssembler masm(nullptr, AssemblerOptions{}, CodeObjectRequired::kNo,
                      buffer->CreateView());
  // Generate an illegal memory access.
  masm.li(scratch, static_cast<int64_t>(InaccessibleMemoryPtr()));
  uint32_t crash_offset = masm.pc_offset();
  masm.St_d(scratch, MemOperand(scratch, 0));  // load from inaccessible memory.
  uint32_t recovery_offset = masm.pc_offset();
  // Return.
  masm.Ret();
#elif V8_TARGET_ARCH_RISCV64
  constexpr Register scratch = a0;
  MacroAssembler masm(nullptr, AssemblerOptions{}, CodeObjectRequired::kNo,
                      buffer->CreateView());
  // Generate an illegal memory access.
  masm.li(scratch, static_cast<int64_t>(InaccessibleMemoryPtr()));
  uint32_t crash_offset = masm.pc_offset();
  masm.StoreWord(scratch,
                 MemOperand(scratch, 0));  // load from inaccessible memory.
  uint32_t recovery_offset = masm.pc_offset();
  // Return.
  masm.Ret();
#else
#error Unsupported platform
#endif

  CodeDesc desc;
  masm.GetCode(static_cast<LocalIsolate*>(nullptr), &desc);

  constexpr bool kUseDefaultHandler = true;
  CHECK(v8::V8::EnableWebAssemblyTrapHandler(kUseDefaultHandler));

  ProtectedInstructionData protected_instruction{crash_offset};
  int handler_data_index =
      RegisterHandlerData(reinterpret_cast<Address>(desc.buffer),
                          desc.instr_size, 1, &protected_instruction);

  // Now execute the code.
  buffer->MakeExecutable();
  GeneratedCode<void> code = GeneratedCode<void>::FromAddress(
      i_isolate(), reinterpret_cast<Address>(desc.buffer));

  trap_handler::SetLandingPad(reinterpret_cast<uintptr_t>(buffer->start()) +
                              recovery_offset);
  SetThreadInWasm();
  code.Call();
  ResetThreadInWasm();

  ReleaseHandlerData(handler_data_index);
  RemoveTrapHandler();
  trap_handler::SetLandingPad(0);

  EXPECT_EQ(1u, GetRecoveredTrapCount());
}

}  // namespace trap_handler
}  // namespace internal
}  // namespace v8

#endif  // V8_TRAP_HANDLER_VIA_SIMULATOR
                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/unittests/wasm/trap-handler-win-unittest.cc                                0000664 0000000 0000000 00000007061 14746647661 0025401 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <windows.h>

#include "include/v8-initialization.h"
#include "include/v8-platform.h"
#include "src/base/page-allocator.h"
#include "src/trap-handler/trap-handler.h"
#include "src/utils/allocation.h"
#include "test/unittests/test-utils.h"
#include "testing/gtest/include/gtest/gtest.h"

namespace {

#if V8_TRAP_HANDLER_SUPPORTED

bool g_handler_got_executed = false;
// The start address of the virtual memory we use to cause an exception.
i::Address g_start_address;

// When using V8::EnableWebAssemblyTrapHandler, we save the old one to fall back
// on if V8 doesn't handle the exception. This allows tools like ASan to
// register a handler early on during the process startup and still generate
// stack traces on failures.
class ExceptionHandlerFallbackTest : public v8::TestWithPlatform {
 protected:
  void SetUp() override {
    // Register this handler as the last handler.
    registered_handler_ = AddVectoredExceptionHandler(/*first=*/0, TestHandler);
    CHECK_NOT_NULL(registered_handler_);

    v8::PageAllocator* page_allocator = i::GetPlatformPageAllocator();
    // We only need a single page.
    size_t size = page_allocator->AllocatePageSize();
    void* hint = page_allocator->GetRandomMmapAddr();
    i::VirtualMemory mem(page_allocator, size, hint, size);
    g_start_address = mem.address();
    // Set the permissions of the memory to no-access.
    CHECK(mem.SetPermissions(g_start_address, size,
                             v8::PageAllocator::kNoAccess));
    mem_ = std::move(mem);
  }

  void WriteToTestMemory(int value) {
    *reinterpret_cast<volatile int*>(g_start_address) = value;
  }

  int ReadFromTestMemory() {
    return *reinterpret_cast<volatile int*>(g_start_address);
  }

  void TearDown() override {
    // be a good citizen and remove the exception handler.
    ULONG result = RemoveVectoredExceptionHandler(registered_handler_);
    EXPECT_TRUE(result);
  }

 private:
  static LONG WINAPI TestHandler(EXCEPTION_POINTERS* exception) {
    g_handler_got_executed = true;
    v8::PageAllocator* page_allocator = i::GetPlatformPageAllocator();
    // Make the allocated memory accessible so that from now on memory accesses
    // do not cause an exception anymore.
    EXPECT_TRUE(i::SetPermissions(page_allocator, g_start_address,
                                  page_allocator->AllocatePageSize(),
                                  v8::PageAllocator::kReadWrite));
    // The memory access should work now, we can continue execution.
    return EXCEPTION_CONTINUE_EXECUTION;
  }

  i::VirtualMemory mem_;
  void* registered_handler_;
};

TEST_F(ExceptionHandlerFallbackTest, DoTest) {
  constexpr bool kUseDefaultTrapHandler = true;
  EXPECT_TRUE(v8::V8::EnableWebAssemblyTrapHandler(kUseDefaultTrapHandler));
  // In the original test setup the test memory is protected against any kind of
  // access. Therefore the access here causes an access violation exception,
  // which should be caught by the exception handler we install above. In the
  // exception handler we change the permission of the test memory to make it
  // accessible, and then return from the exception handler to execute the
  // memory access again. This time we expect the memory access to work.
  constexpr int test_value = 42;
  WriteToTestMemory(test_value);
  EXPECT_EQ(test_value, ReadFromTestMemory());
  EXPECT_TRUE(g_handler_got_executed);
  v8::internal::trap_handler::RemoveTrapHandler();
}

#endif

}  //  namespace
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/unittests/wasm/wasm-code-manager-unittest.cc                               0000664 0000000 0000000 00000010751 14746647661 0025514 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "test/unittests/test-utils.h"
#include "testing/gmock/include/gmock/gmock.h"

#include "src/wasm/function-compiler.h"
#include "src/wasm/jump-table-assembler.h"
#include "src/wasm/wasm-code-manager.h"
#include "src/wasm/wasm-engine.h"

namespace v8 {
namespace internal {
namespace wasm {
namespace wasm_heap_unittest {

class DisjointAllocationPoolTest : public ::testing::Test {
 public:
  void CheckPool(const DisjointAllocationPool& mem,
                 std::initializer_list<base::AddressRegion> expected_regions);
  void CheckRange(base::AddressRegion region1, base::AddressRegion region2);
  DisjointAllocationPool Make(
      std::initializer_list<base::AddressRegion> regions);
};

void DisjointAllocationPoolTest::CheckPool(
    const DisjointAllocationPool& mem,
    std::initializer_list<base::AddressRegion> expected_regions) {
  const auto& regions = mem.regions();
  EXPECT_EQ(regions.size(), expected_regions.size());
  auto iter = expected_regions.begin();
  for (auto it = regions.begin(), e = regions.end(); it != e; ++it, ++iter) {
    EXPECT_EQ(*it, *iter);
  }
}

void DisjointAllocationPoolTest::CheckRange(base::AddressRegion region1,
                                            base::AddressRegion region2) {
  EXPECT_EQ(region1, region2);
}

DisjointAllocationPool DisjointAllocationPoolTest::Make(
    std::initializer_list<base::AddressRegion> regions) {
  DisjointAllocationPool ret;
  for (auto& region : regions) {
    ret.Merge(region);
  }
  return ret;
}

TEST_F(DisjointAllocationPoolTest, ConstructEmpty) {
  DisjointAllocationPool a;
  EXPECT_TRUE(a.IsEmpty());
  CheckPool(a, {});
  a.Merge({1, 4});
  CheckPool(a, {{1, 4}});
}

TEST_F(DisjointAllocationPoolTest, ConstructWithRange) {
  DisjointAllocationPool a({1, 4});
  EXPECT_FALSE(a.IsEmpty());
  CheckPool(a, {{1, 4}});
}

TEST_F(DisjointAllocationPoolTest, SimpleExtract) {
  DisjointAllocationPool a = Make({{1, 4}});
  base::AddressRegion b = a.Allocate(2);
  CheckPool(a, {{3, 2}});
  CheckRange(b, {1, 2});
  a.Merge(b);
  CheckPool(a, {{1, 4}});
  EXPECT_EQ(a.regions().size(), uint32_t{1});
  EXPECT_EQ(a.regions().begin()->begin(), uint32_t{1});
  EXPECT_EQ(a.regions().begin()->end(), uint32_t{5});
}

TEST_F(DisjointAllocationPoolTest, ExtractAll) {
  DisjointAllocationPool a({1, 4});
  base::AddressRegion b = a.Allocate(4);
  CheckRange(b, {1, 4});
  EXPECT_TRUE(a.IsEmpty());
  a.Merge(b);
  CheckPool(a, {{1, 4}});
}

TEST_F(DisjointAllocationPoolTest, FailToExtract) {
  DisjointAllocationPool a = Make({{1, 4}});
  base::AddressRegion b = a.Allocate(5);
  CheckPool(a, {{1, 4}});
  EXPECT_TRUE(b.is_empty());
}

TEST_F(DisjointAllocationPoolTest, FailToExtractExact) {
  DisjointAllocationPool a = Make({{1, 4}, {10, 4}});
  base::AddressRegion b = a.Allocate(5);
  CheckPool(a, {{1, 4}, {10, 4}});
  EXPECT_TRUE(b.is_empty());
}

TEST_F(DisjointAllocationPoolTest, ExtractExact) {
  DisjointAllocationPool a = Make({{1, 4}, {10, 5}});
  base::AddressRegion b = a.Allocate(5);
  CheckPool(a, {{1, 4}});
  CheckRange(b, {10, 5});
}

TEST_F(DisjointAllocationPoolTest, Merging) {
  DisjointAllocationPool a = Make({{10, 5}, {20, 5}});
  a.Merge({15, 5});
  CheckPool(a, {{10, 15}});
}

TEST_F(DisjointAllocationPoolTest, MergingFirst) {
  DisjointAllocationPool a = Make({{10, 5}, {20, 5}});
  a.Merge({5, 5});
  CheckPool(a, {{5, 10}, {20, 5}});
}

TEST_F(DisjointAllocationPoolTest, MergingAbove) {
  DisjointAllocationPool a = Make({{10, 5}, {25, 5}});
  a.Merge({20, 5});
  CheckPool(a, {{10, 5}, {20, 10}});
}

TEST_F(DisjointAllocationPoolTest, MergingMore) {
  DisjointAllocationPool a = Make({{10, 5}, {20, 5}, {30, 5}});
  a.Merge({15, 5});
  a.Merge({25, 5});
  CheckPool(a, {{10, 25}});
}

TEST_F(DisjointAllocationPoolTest, MergingSkip) {
  DisjointAllocationPool a = Make({{10, 5}, {20, 5}, {30, 5}});
  a.Merge({25, 5});
  CheckPool(a, {{10, 5}, {20, 15}});
}

TEST_F(DisjointAllocationPoolTest, MergingSkipLargerSrc) {
  DisjointAllocationPool a = Make({{10, 5}, {20, 5}, {30, 5}});
  a.Merge({25, 5});
  a.Merge({35, 5});
  CheckPool(a, {{10, 5}, {20, 20}});
}

TEST_F(DisjointAllocationPoolTest, MergingSkipLargerSrcWithGap) {
  DisjointAllocationPool a = Make({{10, 5}, {20, 5}, {30, 5}});
  a.Merge({25, 5});
  a.Merge({36, 4});
  CheckPool(a, {{10, 5}, {20, 15}, {36, 4}});
}

}  // namespace wasm_heap_unittest
}  // namespace wasm
}  // namespace internal
}  // namespace v8
                       node-23.7.0/deps/v8/test/unittests/wasm/wasm-compiler-unittest.cc                                   0000664 0000000 0000000 00000010572 14746647661 0025005 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/compiler/wasm-compiler.h"

#include "src/codegen/machine-type.h"
#include "src/codegen/signature.h"
#include "src/compiler/linkage.h"
#include "src/wasm/value-type.h"
#include "src/wasm/wasm-linkage.h"
#include "test/unittests/test-utils.h"

namespace v8 {
namespace internal {
namespace wasm {

class WasmCallDescriptorTest : public TestWithZone {};

TEST_F(WasmCallDescriptorTest, TestExternRefIsGrouped) {
  constexpr size_t kMaxCount = 30;
  ValueType params[kMaxCount];

  for (size_t i = 0; i < kMaxCount; i += 2) {
    params[i] = kWasmExternRef;
    EXPECT_TRUE(i + 1 < kMaxCount);
    params[i + 1] = kWasmI32;
  }

  for (size_t count = 1; count <= kMaxCount; ++count) {
    FunctionSig sig(/*return_count=*/0, count, params);
    compiler::CallDescriptor* desc =
        compiler::GetWasmCallDescriptor(zone(), &sig);

    // The WasmInstance is the implicit first parameter.
    EXPECT_EQ(count + 1, desc->ParameterCount());

    bool has_untagged_stack_param = false;
    bool has_tagged_register_param = false;
    int max_tagged_stack_location = std::numeric_limits<int>::min();
    int min_untagged_stack_location = std::numeric_limits<int>::max();
    for (size_t i = 1; i < desc->ParameterCount(); ++i) {
      // InputLocation i + 1, because target is the first input.
      LinkageLocation location = desc->GetInputLocation(i + 1);
      if (desc->GetParameterType(i).IsTagged()) {
        if (location.IsRegister()) {
          has_tagged_register_param = true;
        } else {
          EXPECT_TRUE(location.IsCallerFrameSlot());
          max_tagged_stack_location =
              std::max(max_tagged_stack_location, location.AsCallerFrameSlot());
        }
      } else {  // !isTagged()
        if (location.IsCallerFrameSlot()) {
          has_untagged_stack_param = true;
          min_untagged_stack_location = std::min(min_untagged_stack_location,
                                                 location.AsCallerFrameSlot());
        } else {
          EXPECT_TRUE(location.IsRegister());
        }
      }
    }
    // There should never be a tagged parameter in a register and an untagged
    // parameter on the stack at the same time.
    EXPECT_EQ(false, has_tagged_register_param && has_untagged_stack_param);
    EXPECT_TRUE(max_tagged_stack_location < min_untagged_stack_location);
  }
}

TEST_F(WasmCallDescriptorTest, Regress_1174500) {
  // Our test signature should have just enough params and returns to force
  // 1 param and 1 return to be allocated as stack slots. Use FP registers to
  // avoid interference with implicit parameters, like the Wasm Instance.
  constexpr int kParamRegisters = arraysize(kFpParamRegisters);
  constexpr int kParams = kParamRegisters + 1;
  constexpr int kReturnRegisters = arraysize(kFpReturnRegisters);
  constexpr int kReturns = kReturnRegisters + 1;
  ValueType types[kReturns + kParams];
  // One S128 return slot which shouldn't be padded unless the arguments area
  // of the frame requires it.
  for (int i = 0; i < kReturnRegisters; ++i) types[i] = kWasmF32;
  types[kReturnRegisters] = kWasmS128;
  // One F32 parameter slot to misalign the parameter area.
  for (int i = 0; i < kParamRegisters; ++i) types[kReturns + i] = kWasmF32;
  types[kReturns + kParamRegisters] = kWasmF32;

  FunctionSig sig(kReturns, kParams, types);
  compiler::CallDescriptor* desc =
      compiler::GetWasmCallDescriptor(zone(), &sig);

  // Get the location of our stack parameter slot. Skip the implicit Wasm
  // instance parameter.
  LinkageLocation last_param = desc->GetInputLocation(kParams + 1);
  EXPECT_TRUE(last_param.IsCallerFrameSlot());
  EXPECT_EQ(MachineType::Float32(), last_param.GetType());
  EXPECT_EQ(-1, last_param.GetLocation());

  // The stack return slot should be right above our last parameter, and any
  // argument padding slots. The return slot itself should not be padded.
  const int padding = ShouldPadArguments(1);
  const int first_return_slot = -1 - (padding + 1);
  LinkageLocation return_location = desc->GetReturnLocation(kReturns - 1);
  EXPECT_TRUE(return_location.IsCallerFrameSlot());
  EXPECT_EQ(MachineType::Simd128(), return_location.GetType());
  EXPECT_EQ(first_return_slot, return_location.GetLocation());
}

}  // namespace wasm
}  // namespace internal
}  // namespace v8
                                                                                                                                      node-23.7.0/deps/v8/test/unittests/wasm/wasm-disassembler-unittest-bad-name-section.wasm.inc        0000664 0000000 0000000 00000012622 14746647661 0032104 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // This Wasm module has a name section which is invalid in that it
// contains each sub-section twice.

  0x00, 0x61, 0x73, 0x6d,  // wasm magic
  0x01, 0x00, 0x00, 0x00,  // wasm version

  // The only purpose of this table section is to trigger lazy decoding
  // of the name section.
  0x04,                    // section kind: Table
  0x04,                    // section length 4
  0x01, 0x70, 0x00,        // table count 1:  funcref no maximum
  0x00,                    // initial size 0

  0x00,                    // section kind: Unknown
  0xb3, 0x01,              // section length 179
  0x04,                    // section name length: 4
  0x6e, 0x61, 0x6d, 0x65,  // section name: name

  0x01,              // name type: function
  0x04,              // payload length: 4
  0x01,              // names count 1
  0x00, 0x01, 0x78,  // index 0 name length 1 "x"

  0x02,              // name type: local
  0x0b,              // payload length: 11
  0x02,              // outer count 2
  0x00, 0x01,        // outer index 0 inner count 1
  0x00, 0x01, 0x78,  // inner index 0 name length 1 "x"
  0x01, 0x01,        // outer index 1 inner count 1
  0x00, 0x01, 0x78,  // inner index 0 name length 1 "x"

  0x03,              // name type: label
  0x0b,              // payload length: 11
  0x02,              // outer count 2
  0x00, 0x01,        // outer index 0 inner count 1
  0x00, 0x01, 0x78,  // inner index 0 name length 1 "x"
  0x01, 0x01,        // outer index 1 inner count 1
  0x00, 0x01, 0x78,  // inner index 0 name length 1 "x"

  0x04,              // name type: type
  0x04,              // payload length: 4
  0x01,              // names count 1
  0x00, 0x01, 0x78,  // index 0 name length 1 "x"

  0x05,              // name type: table
  0x04,              // payload length: 4
  0x01,              // names count 1
  0x00, 0x01, 0x78,  // index 0 name length 1 "x"

  0x06,              // name type: memory
  0x04,              // payload length: 4
  0x01,              // names count 1
  0x00, 0x01, 0x78,  // index 0 name length 1 "x"

  0x07,              // name type: global
  0x04,              // payload length: 4
  0x01,              // names count 1
  0x00, 0x01, 0x78,  // index 0 name length 1 "x"

  0x08,              // name type: element segment
  0x04,              // payload length: 4
  0x01,              // names count 1
  0x00, 0x01, 0x78,  // index 0 name length 1 "x"

  0x09,              // name type: data segment
  0x04,              // payload length: 4
  0x01,              // names count 1
  0x00, 0x01, 0x78,  // index 0 name length 1 "x"

  0x0a,              // name type: field
  0x0b,              // payload length: 11
  0x02,              // outer count 2
  0x00, 0x01,        // outer index 0 inner count 1
  0x00, 0x01, 0x78,  // inner index 0 name length 1 "x"
  0x01, 0x01,        // outer index 1 inner count 1
  0x00, 0x01, 0x78,  // inner index 0 name length 1 "x"

  0x0b,              // name type: tag
  0x04,              // payload length: 4
  0x01,              // names count 1
  0x00, 0x01, 0x78,  // index 0 name length 1 "x"

  0x01,              // name type: function
  0x04,              // payload length: 4
  0x01,              // names count 1
  0x00, 0x01, 0x78,  // index 0 name length 1 "x"

  0x02,              // name type: local
  0x0b,              // payload length: 11
  0x02,              // outer count 2
  0x00, 0x01,        // outer index 0 inner count 1
  0x00, 0x01, 0x78,  // inner index 0 name length 1 "x"
  0x01, 0x01,        // outer index 1 inner count 1
  0x00, 0x01, 0x78,  // inner index 0 name length 1 "x"

  0x03,              // name type: label
  0x0b,              // payload length: 11
  0x02,              // outer count 2
  0x00, 0x01,        // outer index 0 inner count 1
  0x00, 0x01, 0x78,  // inner index 0 name length 1 "x"
  0x01, 0x01,        // outer index 1 inner count 1
  0x00, 0x01, 0x78,  // inner index 0 name length 1 "x"

  0x04,              // name type: type
  0x04,              // payload length: 4
  0x01,              // names count 1
  0x00, 0x01, 0x78,  // index 0 name length 1 "x"

  0x05,              // name type: table
  0x04,              // payload length: 4
  0x01,              // names count 1
  0x00, 0x01, 0x78,  // index 0 name length 1 "x"

  0x06,              // name type: memory
  0x04,              // payload length: 4
  0x01,              // names count 1
  0x00, 0x01, 0x78,  // index 0 name length 1 "x"

  0x07,              // name type: global
  0x04,              // payload length: 4
  0x01,              // names count 1
  0x00, 0x01, 0x78,  // index 0 name length 1 "x"

  0x08,              // name type: element segment
  0x04,              // payload length: 4
  0x01,              // names count 1
  0x00, 0x01, 0x78,  // index 0 name length 1 "x"

  0x09,              // name type: data segment
  0x04,              // payload length: 4
  0x01,              // names count 1
  0x00, 0x01, 0x78,  // index 0 name length 1 "x"

  0x0a,              // name type: field
  0x0b,              // payload length: 11
  0x02,              // outer count 2
  0x00, 0x01,        // outer index 0 inner count 1
  0x00, 0x01, 0x78,  // inner index 0 name length 1 "x"
  0x01, 0x01,        // outer index 1 inner count 1
  0x00, 0x01, 0x78,  // inner index 0 name length 1 "x"

  0x0b,              // name type: tag
  0x04,              // payload length: 4
  0x01,              // names count 1
  0x00, 0x01, 0x78,  // index 0 name length 1 "x"
                                                                                                              node-23.7.0/deps/v8/test/unittests/wasm/wasm-disassembler-unittest-exnref.wasm.inc                  0000664 0000000 0000000 00000002752 14746647661 0030270 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                          0x00, 0x61, 0x73, 0x6d,  // wasm magic
  0x01, 0x00, 0x00, 0x00,  // wasm version

  0x01,                    // section kind: Type
  0x09,                    // section length 9
  0x02,                    // types count 2
  0x60,                    //  kind: func
  0x00,                    // param count 0
  0x00,                    // return count 0
  0x60,                    //  kind: func
  0x01, 0x7f,              // param count 1:  i32
  0x01, 0x7f,              // return count 1:  i32

  0x03,                    // section kind: Function
  0x02,                    // section length 2
  0x01, 0x01,              // functions count 1: 0 $func0 (param i32) (result i32)

  0x0d,                    // section kind: Tag
  0x03,                    // section length 3
  0x01, 0x00, 0x00,        // tag count 1:

  0x0a,                    // section kind: Code
  0x16,                    // section length 22
  0x01,                    // functions count 1
                           // function #0 $func0
  0x14,                    // body size 20
  0x00,                    // 0 entries in locals list
  0x02, 0x40,              // block $label0
  0x1f, 0x7f, 0x01, 0x00, 0x00, 0x00,  // try_table (result i32) catch $tag0 $label0
  0x41, 0x00,              // i32.const 0
  0x0c, 0x00,              // br $label0
  0x0b,                    // end $label0
  0x0c, 0x01,              // br 1
  0x0b,                    // end
  0x41, 0x00,              // i32.const 0
  0x0b,                    // end
                      node-23.7.0/deps/v8/test/unittests/wasm/wasm-disassembler-unittest-exnref.wat.inc                   0000664 0000000 0000000 00000000604 14746647661 0030106 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        ;; expected = R"---(;; This is a polyglot C++/WAT file.
;; Comment lines are ignored and not expected in the disassembler output.
(module
  (tag $tag0)
  (func $func0 (param $var0 i32) (result i32)
    block $label0
      try_table $label1 (result i32) catch $tag0 $label0
        i32.const 0
        br $label1
      end $label1
      br 1
    end $label0
    i32.const 0
  )
)
;;)---";
                                                                                                                            node-23.7.0/deps/v8/test/unittests/wasm/wasm-disassembler-unittest-gc.wasm.inc                      0000664 0000000 0000000 00000015653 14746647661 0027376 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                          0x00, 0x61, 0x73, 0x6d,  // wasm magic
  0x01, 0x00, 0x00, 0x00,  // wasm version

  0x01,                    // section kind: Type
  0x4b,                    // section length 75
  0x10,                    // types count 16
  0x4e, 0x00,              // empty rec.group
  0x4e, 0x00,              // empty rec.group
  0x50, 0x00, 0x5f, 0x00,  // type #0 $type0 subtype, supertype count 0, kind: struct, field count 0
  0x5f, 0x01, 0x7f, 0x00,  // type #1 $type1 kind: struct, field count 1:  i32 immutable
  0x5f, 0x02,              // type #2 $type2 kind: struct, field count 2
  0x7f, 0x01,              // i32 mutable
  0x7e, 0x01,              // i64 mutable
  0x5f, 0x02,              // type #3 $type3 kind: struct, field count 2
  0x78, 0x00,              //  i8 immutable
  0x77, 0x01,              //  i16 mutable
  0x5e, 0x7e, 0x00,        // type #4 $type4 kind: array i64 immutable
  0x5e, 0x7e, 0x01,        // type #5 $type5 kind: array i64 mutable
  0x5e, 0x78, 0x00,        // type #6 $type6 kind: array i8 immutable
  0x5f, 0x01, 0x64, 0x00, 0x00,  // type #7 $type7 kind: struct, field count 1:  (ref $type0) immutable
  0x4e,                    // rec. group definition
  0x02,                    // recursive group size 2
  0x5f, 0x01, 0x64, 0x09, 0x00,  // type #8 $type8 kind: struct, field count 1:  (ref $type9) immutable
  0x5f, 0x01, 0x64, 0x08, 0x00,  // type #9 $type9 kind: struct, field count 1:  (ref $type8) immutable
  0x50, 0x01, 0x00,        // type #10 $type10 subtype, supertype count 1: supertype 0
  0x5f, 0x01, 0x7f, 0x00,  //  kind: struct, field count 1:  i32 immutable
  0x60,                    // type #11 $type11 kind: func
  0x02,                    // param count 2
  0x64, 0x01, 0x6d,        // (ref $type1) eqref
  0x00,                    // return count 0
  0x4f, 0x01, 0x00,        // type #12 $type12 final subtype, supertype count 1: supertype 0
  0x5f, 0x01, 0x7f, 0x01,  //  kind: struct, field count 1:  i32 mutable
  0x4e, 0x00,              // empty rec.group
  0x4e, 0x00,              // empty rec.group

  0x02,                    // section kind: Import
  0x30,                    // section length 48
  0x02,                    // imports count 2
                           // import #0
  0x03,                    // module name length: 3
  0x65, 0x6e, 0x76,        // module name: env
  0x0f,                    // field name length: 15
  0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64,
  0x5f, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c,
                           // field name: imported_global
  0x03, 0x64, 0x07, 0x00,  // kind: global (ref $type7) immutable
                           // import #1
  0x03,                    // module name length: 3
  0x65, 0x6e, 0x76,        // module name: env
  0x0e,                    // field name length: 14
  0x61, 0x6e, 0x6f, 0x74, 0x68, 0x65, 0x72, 0x5f,
  0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c,
                           // field name: another_global
  0x03, 0x64, 0x08, 0x00,  // kind: global (ref $type8) immutable

  0x03,                    // section kind: Function
  0x02,                    // section length 2
  0x01, 0x0b,              // functions count 1: 0 $func0 (param (ref $type1) eqref)

  0x06,                    // section kind: Global
  0x0b,                    // section length 11
  0x02,                    // globals count 2
  0x6e, 0x00,              // global #2: anyref immutable
  0xd0, 0x71, 0x0b,        // ref.null none
  0x6d, 0x01,              // global #3: eqref mutable
  0xd0, 0x71, 0x0b,        // ref.null none

  0x0a,                    // section kind: Code
  0x9d, 0x01,              // section length 157
  0x01,                    // functions count 1
                           // function #0 $func0
  0x9a, 0x01,              // body size 154
  0x00,                    // 0 entries in locals list
  0xfb, 0x01, 0x01,        // struct.new_default $type1
  0xfb, 0x02, 0x01, 0x00,  // struct.get $type1 $field0
  0x1a,                    // drop
  0xfb, 0x01, 0x02,        // struct.new_default $type2
  0x41, 0x00,              // i32.const 0
  0xfb, 0x05, 0x02, 0x00,  // struct.set $type2 $field0
  0xfb, 0x01, 0x03,        // struct.new_default $type3
  0xfb, 0x03, 0x03, 0x00,  // struct.get_s $type3 $field0
  0x1a,                    // drop
  0xfb, 0x01, 0x03,        // struct.new_default $type3
  0xfb, 0x04, 0x03, 0x01,  // struct.get_u $type3 $field1
  0x1a,                    // drop
  0xfb, 0x08, 0x04, 0x00,  // array.new_fixed $type4 0
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0xfb, 0x07, 0x04,        // array.new_default $type4
  0xfb, 0x0f,              // array.len
  0x1a,                    // drop
  0x42, 0x00,              // i64.const 0
  0x41, 0x00,              // i32.const 0
  0xfb, 0x06, 0x04,        // array.new $type4
  0x41, 0x00,              // i32.const 0
  0xfb, 0x0b, 0x04,        // array.get $type4
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0xfb, 0x07, 0x05,        // array.new_default $type5
  0x41, 0x00,              // i32.const 0
  0x42, 0x00,              // i64.const 0
  0xfb, 0x0e, 0x05,        // array.set $type5
  0x41, 0x00,              // i32.const 0
  0xfb, 0x07, 0x06,        // array.new_default $type6
  0x41, 0x00,              // i32.const 0
  0xfb, 0x0c, 0x06,        // array.get_s $type6
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0xfb, 0x07, 0x06,        // array.new_default $type6
  0x41, 0x00,              // i32.const 0
  0xfb, 0x0d, 0x06,        // array.get_u $type6
  0x1a,                    // drop
  0x20, 0x01,              // local.get $var1
  0x20, 0x01,              // local.get $var1
  0xd3,                    // ref.eq
  0x1a,                    // drop
  0x20, 0x01,              // local.get $var1
  0xfb, 0x14, 0x00,        // ref.test $type0
  0x1a,                    // drop
  0x20, 0x00,              // local.get $var0
  0xfb, 0x16, 0x00,        // ref.cast $type0
  0x1a,                    // drop
  0x20, 0x00,              // local.get $var0
  0xfb, 0x15, 0x00,        // ref.test null $type0
  0x1a,                    // drop
  0x20, 0x00,              // local.get $var0
  0xfb, 0x17, 0x00,        // ref.cast null $type0
  0x1a,                    // drop
  0x02, 0x64, 0x01,        // block (result (ref $type1)) $label0
  0x20, 0x00,              // local.get $var0
  0xd6, 0x00,              // br_on_non_null $label0
  0x20, 0x00,              // local.get $var0
  0xfb, 0x18, 0x01, 0x00, 0x00, 0x01,
                           // br_on_cast $label0 (ref null $type0) (ref $type1)
  0x1a,                    // drop
  0x20, 0x00,              // local.get $var0
  0xfb, 0x19, 0x02, 0x00, 0x00, 0x01,
                           // br_on_cast_fail $label0 (ref $type0)
                           //   (ref null $type1)
  0x1a,                    // drop
  0x20, 0x00,              // local.get $var0
  0x0b,                    // end $label0
  0x1a,                    // drop
  0x0b,                    // end
                                                                                     node-23.7.0/deps/v8/test/unittests/wasm/wasm-disassembler-unittest-gc.wat.inc                       0000664 0000000 0000000 00000005476 14746647661 0027224 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        ;; expected = R"---(;; This is a polyglot C++/WAT file.
;; Comment lines are ignored and not expected in the disassembler output.
(module
  ;; Empty recgroups are useless but supported.
  (rec)
  (rec)
  ;; Structs.
  (type $type0 (struct))
  (type $type1 (struct (field $field0 i32)))
  (type $type2 (struct (field $field0 (mut i32)) (field $field1 (mut i64))))
  (type $type3 (struct (field $field0 i8) (field $field1 (mut i16))))
  ;; Arrays.
  (type $type4 (array (field i64)))
  (type $type5 (array (field (mut i64))))
  (type $type6 (array (field i8)))
  ;; References to other types, mutual recursion.
  (type $type7 (struct (field $field0 (ref $type0))))
  (rec
    (type $type8 (struct (field $field0 (ref $type9))))
    (type $type9 (struct (field $field0 (ref $type8))))
  )
  ;; Subtyping constraints.
  (type $type10 (sub $type0 (struct (field $field0 i32))))
  (type $type12 (sub final $type0 (struct (field $field0 (mut i32)))))
  ;; Empty recgroups are useless but supported.
  (rec)
  (rec)
  ;; Globals using reference types.
  (global $env.imported_global (;0;) (import "env" "imported_global") (ref $type7))
  (global $env.another_global (;1;) (import "env" "another_global") (ref $type8))
  (global $global2 anyref (ref.null none))
  (global $global3 (mut eqref) (ref.null none))
  ;; Function with GC instructions and taking GC types as parameters.
  (func $func0 (param $var0 (ref $type1)) (param $var1 eqref)
    ;; Structs.
    struct.new_default $type1
    struct.get $type1 $field0
    drop
    struct.new_default $type2
    i32.const 0
    struct.set $type2 $field0
    struct.new_default $type3
    struct.get_s $type3 $field0
    drop
    struct.new_default $type3
    struct.get_u $type3 $field1
    drop
    ;; Arrays.
    array.new_fixed $type4 0
    drop
    i32.const 0
    array.new_default $type4
    array.len
    drop
    i64.const 0
    i32.const 0
    array.new $type4
    i32.const 0
    array.get $type4
    drop
    i32.const 0
    array.new_default $type5
    i32.const 0
    i64.const 0
    array.set $type5
    i32.const 0
    array.new_default $type6
    i32.const 0
    array.get_s $type6
    drop
    i32.const 0
    array.new_default $type6
    i32.const 0
    array.get_u $type6
    drop
    ;; References.
    local.get $var1
    local.get $var1
    ref.eq
    drop
    local.get $var1
    ref.test $type0
    drop
    local.get $var0
    ref.cast $type0
    drop
    local.get $var0
    ref.test null $type0
    drop
    local.get $var0
    ref.cast null $type0
    drop
    ;; Branches.
    block $label0 (result (ref $type1))
      local.get $var0
      br_on_non_null $label0
      local.get $var0
      br_on_cast $label0 (ref null $type0) (ref $type1)
      drop
      local.get $var0
      br_on_cast_fail $label0 (ref $type0) (ref null $type1)
      drop
      local.get $var0
    end $label0
    drop
  )
)
;;)---";
                                                                                                                                                                                                  node-23.7.0/deps/v8/test/unittests/wasm/wasm-disassembler-unittest-mvp.wasm.inc                     0000664 0000000 0000000 00000061113 14746647661 0027577 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                          0x00, 0x61, 0x73, 0x6d,  // wasm magic
  0x01, 0x00, 0x00, 0x00,  // wasm version

  0x01,                    // section kind: Type
  0x1d,                    // section length 29
  0x07,                    // types count 7
  0x60,                    // type #0 $type0 kind: func
  0x00,                    // param count 0
  0x00,                    // return count 0
  0x60,                    // type #1 $type1 kind: func
  0x01, 0x7f,              // param count 1:  i32
  0x00,                    // return count 0
  0x60,                    // type #2 $type2 kind: func
  0x00,                    // param count 0
  0x01, 0x7f,              // return count 1:  i32
  0x60,                    // type #3 $type3 kind: func
  0x00,                    // param count 0
  0x01, 0x7e,              // return count 1:  i64
  0x60,                    // type #4 $type4 kind: func
  0x00,                    // param count 0
  0x01, 0x7d,              // return count 1:  f32
  0x60,                    // type #5 $type5 kind: func
  0x00,                    // param count 0
  0x01, 0x7c,              // return count 1:  f64
  0x60,                    // type #6 $type6 kind: func
  0x01, 0x7e,              // param count 1:  i64
  0x01, 0x7c,              // return count 1:  f64

  0x02,                    // section kind: Import
  0x30,                    // section length 48
  0x02,                    // imports count 2
                           // import #0
  0x03,                    // module name length: 3
  0x65, 0x6e, 0x76,        // module name: env
  0x0f,                    // field name length: 15
  0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 
  0x5f, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 
                           // field name: imported_global
  0x03, 0x7f, 0x00,        // kind: global i32 immutable
                           // import #1
  0x03,                    // module name length: 3
  0x65, 0x6e, 0x76,        // module name: env
  0x11,                    // field name length: 17
  0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 
  0x5f, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 
  0x6e,                    // field name: imported_function
  0x00, 0x00,              // kind: function

  0x03,                    // section kind: Function
  0x09,                    // section length 9
  0x08,                    // functions count 8
  0x01,                    // 1 $func1 (param i32)
  0x02,                    // 2 $func2 (result i32)
  0x03,                    // 3 $func3 (result i64)
  0x04,                    // 4 $func4 (result f32)
  0x05,                    // 5 $func5 (result f64)
  0x00,                    // 6 $func6
  0x00,                    // 7 $func7
  0x00,                    // 8 $exported_function

  0x04,                    // section kind: Table
  0x04,                    // section length 4
  0x01, 0x70, 0x00,        // table count 1:  funcref no maximum
  0x04,                    // initial size 4

  0x05,                    // section kind: Memory
  0x04,                    // section length 4
  0x01, 0x01,              // memory count 1:  with maximum
  0x00,                    // initial size 0
  0x01,                    // maximum size 1

  0x06,                    // section kind: Global
  0x10,                    // section length 16
  0x03,                    // globals count 3
  0x7f, 0x01,              // global #1: i32 mutable
  0x41, 0x00, 0x0b,        // i32.const 0
  0x7f, 0x00,              // global #2: i32 immutable
  0x23, 0x00, 0x0b,        // global.get $env.imported_global
  0x7e, 0x00,              // global #3: i64 immutable
  0x42, 0x00, 0x0b,        // i64.const 0

  0x07,                    // section kind: Export
  0x27,                    // section length 39
  0x02,                    // exports count 2
                           // export # 0
  0x0f,                    // field name length: 15
  0x65, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 
  0x5f, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 
                           // field name: exported_global
  0x03, 0x03,              // kind: global index: 3
                           // export # 1
  0x11,                    // field name length: 17
  0x65, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 
  0x5f, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 
  0x6e,                    // field name: exported_function
  0x00, 0x08,              // kind: function index: 8

  0x09,                    // section kind: Element
  0x0a,                    // section length 10
  0x01, 0x00,              // segment count 1: flag: active, offset:
  0x41, 0x00, 0x0b,        // i32.const 0
  0x04,                    // number of elements 4
  0x00,                    // index: 0
  0x01,                    // index: 1
  0x01,                    // index: 1
  0x03,                    // index: 3

  0x0a,                    // section kind: Code
  0xdc, 0x07,              // section length 988
  0x08,                    // functions count 8
                           // function #1 $func1
  0x14,                    // body size 20
  0x01,                    // 1 entries in locals list
  0x01, 0x7e,              // 1 local of type i64
  0x20, 0x00,              // local.get $var0
  0x22, 0x00,              // local.tee $var0
  0x21, 0x00,              // local.set $var0
  0x20, 0x01,              // local.get $var1
  0x22, 0x01,              // local.tee $var1
  0x21, 0x01,              // local.set $var1
  0x23, 0x01,              // global.get $global1
  0x24, 0x01,              // global.set $global1
  0x0b,                    // end
                           // function #2 $func2
  0x8c, 0x01,              // body size 140
  0x00,                    // 0 entries in locals list
  0x41, 0x00,              // i32.const 0
  0x45,                    // i32.eqz
  0x41, 0x01,              // i32.const 1
  0x46,                    // i32.eq
  0x41, 0x7f,              // i32.const -1
  0x47,                    // i32.ne
  0x41, 0xff, 0xff, 0xff, 0xff, 0x07,  // i32.const 2147483647
  0x48,                    // i32.lt_s
  0x41, 0x80, 0x80, 0x80, 0x80, 0x78,  // i32.const -2147483648
  0x49,                    // i32.lt_u
  0x41, 0x00,              // i32.const 0
  0x4a,                    // i32.gt_s
  0x41, 0x00,              // i32.const 0
  0x4b,                    // i32.gt_u
  0x41, 0x00,              // i32.const 0
  0x4c,                    // i32.le_s
  0x41, 0x00,              // i32.const 0
  0x4d,                    // i32.le_u
  0x41, 0x00,              // i32.const 0
  0x4e,                    // i32.ge_s
  0x41, 0x00,              // i32.const 0
  0x4f,                    // i32.ge_u
  0x67,                    // i32.clz
  0x68,                    // i32.ctz
  0x69,                    // i32.popcnt
  0x41, 0x00,              // i32.const 0
  0x6a,                    // i32.add
  0x41, 0x00,              // i32.const 0
  0x6b,                    // i32.sub
  0x41, 0x00,              // i32.const 0
  0x6c,                    // i32.mul
  0x41, 0x00,              // i32.const 0
  0x6d,                    // i32.div_s
  0x41, 0x00,              // i32.const 0
  0x6e,                    // i32.div_u
  0x41, 0x00,              // i32.const 0
  0x6f,                    // i32.rem_s
  0x41, 0x00,              // i32.const 0
  0x70,                    // i32.rem_u
  0x41, 0x00,              // i32.const 0
  0x71,                    // i32.and
  0x41, 0x00,              // i32.const 0
  0x72,                    // i32.or
  0x41, 0x00,              // i32.const 0
  0x73,                    // i32.xor
  0x41, 0x00,              // i32.const 0
  0x74,                    // i32.shl
  0x41, 0x00,              // i32.const 0
  0x75,                    // i32.shr_s
  0x41, 0x00,              // i32.const 0
  0x76,                    // i32.shr_u
  0x41, 0x00,              // i32.const 0
  0x77,                    // i32.rotl
  0x41, 0x00,              // i32.const 0
  0x78,                    // i32.rotr
  0x1a,                    // drop
  0x42, 0x00,              // i64.const 0
  0xa7,                    // i32.wrap_i64
  0x1a,                    // drop
  0x43, 0x00, 0x00, 0x00, 0x00,  // f32.const 0.0
  0xa8,                    // i32.trunc_f32_s
  0x1a,                    // drop
  0x43, 0x00, 0x00, 0x00, 0x00,  // f32.const 0.0
  0xa9,                    // i32.trunc_f32_u
  0x1a,                    // drop
  0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // f64.const 0.0
  0xaa,                    // i32.trunc_f64_s
  0x1a,                    // drop
  0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // f64.const 0.0
  0xab,                    // i32.trunc_f64_u
  0x1a,                    // drop
  0x43, 0x00, 0x00, 0x00, 0x00,  // f32.const 0.0
  0xbc,                    // i32.reinterpret_f32
  0xc0,                    // i32.extend8_s
  0xc1,                    // i32.extend16_s
  0x0b,                    // end
                           // function #3 $func3
  0xc0, 0x01,              // body size 192
  0x00,                    // 0 entries in locals list
  0x42, 0x00,              // i64.const 0
  0x50,                    // i64.eqz
  0x1a,                    // drop
  0x42, 0x01,              // i64.const 1
  0x42, 0x7f,              // i64.const -1
  0x51,                    // i64.eq
  0x1a,                    // drop
  0x42, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x7f,  // i64.const -9223372036854775808
  0x42, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,  // i64.const 9223372036854775807
  0x52,                    // i64.ne
  0x1a,                    // drop
  0x42, 0x00,              // i64.const 0
  0x42, 0x00,              // i64.const 0
  0x53,                    // i64.lt_s
  0x1a,                    // drop
  0x42, 0x00,              // i64.const 0
  0x42, 0x00,              // i64.const 0
  0x54,                    // i64.lt_u
  0x1a,                    // drop
  0x42, 0x00,              // i64.const 0
  0x42, 0x00,              // i64.const 0
  0x55,                    // i64.gt_s
  0x1a,                    // drop
  0x42, 0x00,              // i64.const 0
  0x42, 0x00,              // i64.const 0
  0x56,                    // i64.gt_u
  0x1a,                    // drop
  0x42, 0x00,              // i64.const 0
  0x42, 0x00,              // i64.const 0
  0x57,                    // i64.le_s
  0x1a,                    // drop
  0x42, 0x00,              // i64.const 0
  0x42, 0x00,              // i64.const 0
  0x58,                    // i64.le_u
  0x1a,                    // drop
  0x42, 0x00,              // i64.const 0
  0x42, 0x00,              // i64.const 0
  0x59,                    // i64.ge_s
  0x1a,                    // drop
  0x42, 0x00,              // i64.const 0
  0x42, 0x00,              // i64.const 0
  0x5a,                    // i64.ge_u
  0x1a,                    // drop
  0x42, 0x00,              // i64.const 0
  0x79,                    // i64.clz
  0x7a,                    // i64.ctz
  0x7b,                    // i64.popcnt
  0x42, 0x00,              // i64.const 0
  0x7c,                    // i64.add
  0x42, 0x00,              // i64.const 0
  0x7d,                    // i64.sub
  0x42, 0x00,              // i64.const 0
  0x7e,                    // i64.mul
  0x42, 0x00,              // i64.const 0
  0x7f,                    // i64.div_s
  0x42, 0x00,              // i64.const 0
  0x80,                    // i64.div_u
  0x42, 0x00,              // i64.const 0
  0x81,                    // i64.rem_s
  0x42, 0x00,              // i64.const 0
  0x82,                    // i64.rem_u
  0x42, 0x00,              // i64.const 0
  0x83,                    // i64.and
  0x42, 0x00,              // i64.const 0
  0x84,                    // i64.or
  0x42, 0x00,              // i64.const 0
  0x85,                    // i64.xor
  0x42, 0x00,              // i64.const 0
  0x86,                    // i64.shl
  0x42, 0x00,              // i64.const 0
  0x87,                    // i64.shr_s
  0x42, 0x00,              // i64.const 0
  0x88,                    // i64.shr_u
  0x42, 0x00,              // i64.const 0
  0x89,                    // i64.rotl
  0x42, 0x00,              // i64.const 0
  0x8a,                    // i64.rotr
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0xac,                    // i64.extend_i32_s
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0xad,                    // i64.extend_i32_u
  0x1a,                    // drop
  0x43, 0x00, 0x00, 0x00, 0x00,  // f32.const 0.0
  0xae,                    // i64.trunc_f32_s
  0x1a,                    // drop
  0x43, 0x00, 0x00, 0x00, 0x00,  // f32.const 0.0
  0xaf,                    // i64.trunc_f32_u
  0x1a,                    // drop
  0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // f64.const 0.0
  0xb0,                    // i64.trunc_f64_s
  0x1a,                    // drop
  0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // f64.const 0.0
  0xb1,                    // i64.trunc_f64_u
  0x1a,                    // drop
  0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // f64.const 0.0
  0xbd,                    // i64.reinterpret_f64
  0xc2,                    // i64.extend8_s
  0xc3,                    // i64.extend16_s
  0xc4,                    // i64.extend32_s
  0x0b,                    // end
                           // function #4 $func4
  0x9f, 0x01,              // body size 159
  0x00,                    // 0 entries in locals list
  0x43, 0x00, 0x00, 0x00, 0x00,  // f32.const 0.0
  0x43, 0x00, 0x00, 0x00, 0x80,  // f32.const -0.0
  0x5b,                    // f32.eq
  0x1a,                    // drop
  0x43, 0x00, 0x00, 0x80, 0x3f,  // f32.const 1
  0x43, 0x00, 0x00, 0x80, 0xbf,  // f32.const -1
  0x5c,                    // f32.ne
  0x1a,                    // drop
  0x43, 0x00, 0x00, 0x80, 0x7f,  // f32.const inf
  0x43, 0x00, 0x00, 0x80, 0xff,  // f32.const -inf
  0x5d,                    // f32.lt
  0x1a,                    // drop
  0x43, 0x00, 0x00, 0xc0, 0x7f,  // f32.const nan
  0x43, 0x00, 0x00, 0xc0, 0xff,  // f32.const -nan
  0x5e,                    // f32.gt
  0x1a,                    // drop
  0x43, 0x01, 0x00, 0x80, 0x7f,  // f32.const +nan:0x1
  0x43, 0xff, 0xff, 0x8f, 0x7f,  // f32.const +nan:0xfffff
  0x5f,                    // f32.le
  0x1a,                    // drop
  0x43, 0xcd, 0xcc, 0xcc, 0x3d,  // f32.const 0.100000001
  0x43, 0x3c, 0xb4, 0x96, 0x49,  // f32.const 1234567.5
  0x60,                    // f32.ge
  0x1a,                    // drop
  0x43, 0x00, 0x00, 0x00, 0x00,  // f32.const 0.0
  0x8b,                    // f32.abs
  0x8c,                    // f32.neg
  0x8d,                    // f32.ceil
  0x8e,                    // f32.floor
  0x8f,                    // f32.trunc
  0x90,                    // f32.nearest
  0x91,                    // f32.sqrt
  0x43, 0x00, 0x00, 0x00, 0x00,  // f32.const 0.0
  0x92,                    // f32.add
  0x43, 0x00, 0x00, 0x00, 0x00,  // f32.const 0.0
  0x93,                    // f32.sub
  0x43, 0x00, 0x00, 0x00, 0x00,  // f32.const 0.0
  0x94,                    // f32.mul
  0x43, 0x00, 0x00, 0x00, 0x00,  // f32.const 0.0
  0x95,                    // f32.div
  0x43, 0x00, 0x00, 0x00, 0x00,  // f32.const 0.0
  0x96,                    // f32.min
  0x43, 0x00, 0x00, 0x00, 0x00,  // f32.const 0.0
  0x97,                    // f32.max
  0x43, 0x00, 0x00, 0x00, 0x00,  // f32.const 0.0
  0x98,                    // f32.copysign
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0xb2,                    // f32.convert_i32_s
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0xb3,                    // f32.convert_i32_u
  0x1a,                    // drop
  0x42, 0x00,              // i64.const 0
  0xb4,                    // f32.convert_i64_s
  0x1a,                    // drop
  0x42, 0x00,              // i64.const 0
  0xb5,                    // f32.convert_i64_u
  0x1a,                    // drop
  0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // f64.const 0.0
  0xb6,                    // f32.demote_f64
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0xbe,                    // f32.reinterpret_i32
  0x0b,                    // end
                           // function #5 $func5
  0xeb, 0x01,              // body size 235
  0x00,                    // 0 entries in locals list
  0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // f64.const 0.0
  0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,  // f64.const -0.0
  0x61,                    // f64.eq
  0x1a,                    // drop
  0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f,  // f64.const 1
  0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xbf,  // f64.const -1
  0x62,                    // f64.ne
  0x1a,                    // drop
  0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x7f,  // f64.const inf
  0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff,  // f64.const -inf
  0x63,                    // f64.lt
  0x1a,                    // drop
  0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x7f,  // f64.const nan
  0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff,  // f64.const -nan
  0x64,                    // f64.gt
  0x1a,                    // drop
  0x44, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x7f,  // f64.const +nan:0x1
  0x44, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x7f,  // f64.const +nan:0xfffffffffffff
  0x65,                    // f64.le
  0x1a,                    // drop
  0x44, 0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0xb9, 0x3f,  // f64.const 0.1
  0x44, 0x00, 0x00, 0x00, 0x80, 0x87, 0xd6, 0x32, 0x41,  // f64.const 1234567.5
  0x66,                    // f64.ge
  0x1a,                    // drop
  0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // f64.const 0.0
  0x99,                    // f64.abs
  0x9a,                    // f64.neg
  0x9b,                    // f64.ceil
  0x9c,                    // f64.floor
  0x9d,                    // f64.trunc
  0x9e,                    // f64.nearest
  0x9f,                    // f64.sqrt
  0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // f64.const 0.0
  0xa0,                    // f64.add
  0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // f64.const 0.0
  0xa1,                    // f64.sub
  0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // f64.const 0.0
  0xa2,                    // f64.mul
  0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // f64.const 0.0
  0xa3,                    // f64.div
  0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // f64.const 0.0
  0xa4,                    // f64.min
  0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // f64.const 0.0
  0xa5,                    // f64.max
  0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // f64.const 0.0
  0xa6,                    // f64.copysign
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0xb7,                    // f64.convert_i32_s
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0xb8,                    // f64.convert_i32_u
  0x1a,                    // drop
  0x42, 0x00,              // i64.const 0
  0xb9,                    // f64.convert_i64_s
  0x1a,                    // drop
  0x42, 0x00,              // i64.const 0
  0xba,                    // f64.convert_i64_u
  0x1a,                    // drop
  0x43, 0x00, 0x00, 0x00, 0x00,  // f32.const 0.0
  0xbb,                    // f64.promote_f32
  0x1a,                    // drop
  0x42, 0x00,              // i64.const 0
  0xbf,                    // f64.reinterpret_i64
  0x0b,                    // end
                           // function #6 $func6
  0x3c,                    // body size 60
  0x00,                    // 0 entries in locals list
  0x10, 0x07,              // call $func7
  0x42, 0x00,              // i64.const 0
  0x41, 0x00,              // i32.const 0
  0x11, 0x06, 0x00,        // call_indirect (param i64) (result f64)
  0x0f,                    // return
  0x02, 0x40,              // block $label0
  0x03, 0x40,              // loop $label1
  0x02, 0x7e,              // block (result i64)
  0x03, 0x7e,              // loop (result i64) $label2
  0x0c, 0x03,              // br $label0
  0x41, 0x00,              // i32.const 0
  0x0d, 0x02,              // br_if $label1
  0x41, 0x00,              // i32.const 0
  0x0e, 0x03, 0x03, 0x02, 0x02, 0x00,  // br_table $label0 $label1 $label1 $label2
  0x42, 0x00,              // i64.const 0
  0x0b,                    // end $label2
  0x0b,                    // end
  0x1a,                    // drop
  0x0b,                    // end $label1
  0x0b,                    // end $label0
  0x42, 0x00,              // i64.const 0
  0x42, 0x01,              // i64.const 1
  0x41, 0x00,              // i32.const 0
  0x1b,                    // select
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0x04, 0x7e,              // if (result i64)
  0x42, 0x00,              // i64.const 0
  0x05,                    // else
  0x42, 0x01,              // i64.const 1
  0x0b,                    // end
  0x1a,                    // drop
  0x0b,                    // end
                           // function #7 $func7
  0xa4, 0x01,              // body size 164
  0x00,                    // 0 entries in locals list
  0x41, 0x00,              // i32.const 0
  0x28, 0x02, 0x00,        // i32.load
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0x29, 0x03, 0x03,        // i64.load offset=3
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0x2a, 0x01, 0x00,        // f32.load align=2
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0x2b, 0x02, 0x03,        // f64.load offset=3 align=4
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0x2c, 0x00, 0x00,        // i32.load8_s
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0x2d, 0x00, 0x00,        // i32.load8_u
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0x2e, 0x01, 0x00,        // i32.load16_s
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0x2f, 0x01, 0x00,        // i32.load16_u
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0x30, 0x00, 0x00,        // i64.load8_s
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0x31, 0x00, 0x00,        // i64.load8_u
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0x32, 0x01, 0x00,        // i64.load16_s
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0x33, 0x01, 0x00,        // i64.load16_u
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0x34, 0x02, 0x00,        // i64.load32_s
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0x35, 0x02, 0x00,        // i64.load32_u
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0x41, 0x00,              // i32.const 0
  0x36, 0x02, 0x00,        // i32.store
  0x41, 0x00,              // i32.const 0
  0x42, 0x00,              // i64.const 0
  0x37, 0x03, 0x00,        // i64.store
  0x41, 0x00,              // i32.const 0
  0x43, 0x00, 0x00, 0x00, 0x00,  // f32.const 0.0
  0x38, 0x02, 0x00,        // f32.store
  0x41, 0x00,              // i32.const 0
  0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // f64.const 0.0
  0x39, 0x03, 0x00,        // f64.store
  0x41, 0x00,              // i32.const 0
  0x41, 0x00,              // i32.const 0
  0x3a, 0x00, 0x00,        // i32.store8
  0x41, 0x00,              // i32.const 0
  0x41, 0x00,              // i32.const 0
  0x3b, 0x01, 0x00,        // i32.store16
  0x41, 0x00,              // i32.const 0
  0x42, 0x00,              // i64.const 0
  0x3c, 0x00, 0x00,        // i64.store8
  0x41, 0x00,              // i32.const 0
  0x42, 0x00,              // i64.const 0
  0x3d, 0x01, 0x00,        // i64.store16
  0x41, 0x00,              // i32.const 0
  0x42, 0x00,              // i64.const 0
  0x3e, 0x02, 0x00,        // i64.store32
  0x3f, 0x00,              // memory.size
  0x40, 0x00,              // memory.grow
  0x1a,                    // drop
  0x0b,                    // end
                           // function #8 $exported_function
  0x04,                    // body size 4
  0x00,                    // 0 entries in locals list
  0x01,                    // nop
  0x00,                    // unreachable
  0x0b,                    // end

  0x0b,                    // section kind: Data
  0x0b,                    // section length 11
  0x01, 0x00,              // data segments count 1: flag: active no index
  0x23, 0x00, 0x0b,        // global.get $env.imported_global
  0x05,                    // source size 5
  0x66, 0x6f, 0x6f, 0x0a, 0x00,  // segment data
                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/unittests/wasm/wasm-disassembler-unittest-mvp.wat.inc                      0000664 0000000 0000000 00000020757 14746647661 0027434 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        ;; expected = R"---(;; This is a polyglot C++/WAT file.
;; Comment lines are ignored and not expected in the disassembler output.
(module
  ;; Imports.
  (global $env.imported_global (;0;) (import "env" "imported_global") i32)
  (func $env.imported_function (;0;) (import "env" "imported_function"))
  ;; Table and memory sections.
  (table $table0 4 funcref)
  (memory $memory0 0 1)
  ;; Non-imported globals: mutable, non-mutable, exported.
  (global $global1 (mut i32) (i32.const 0))
  (global $global2 i32 (global.get $env.imported_global))
  (global $exported_global (;3;) (export "exported_global") i64 (i64.const 0))
  ;; Element section for table initialization.
  (elem $elem0 (i32.const 0) (ref func) (ref.func $env.imported_function) (ref.func $func1) (ref.func $func1) (ref.func $func3))
  ;; Instructions on globals, locals, parameters.
  (func $func1 (param $var0 i32)
    (local $var1 i64)
    local.get $var0
    local.tee $var0
    local.set $var0
    local.get $var1
    local.tee $var1
    local.set $var1
    global.get $global1
    global.set $global1
  )
  ;; i32 operations.
  (func $func2 (result i32)
    ;; Comparisons and constant literals.
    i32.const 0
    i32.eqz
    i32.const 1
    i32.eq
    i32.const -1
    i32.ne
    i32.const 2147483647
    i32.lt_s
    i32.const -2147483648
    i32.lt_u
    i32.const 0
    i32.gt_s
    i32.const 0
    i32.gt_u
    i32.const 0
    i32.le_s
    i32.const 0
    i32.le_u
    i32.const 0
    i32.ge_s
    i32.const 0
    i32.ge_u
    ;; Bitcounting.
    i32.clz
    i32.ctz
    i32.popcnt
    ;; Arithmetic and logic.
    i32.const 0
    i32.add
    i32.const 0
    i32.sub
    i32.const 0
    i32.mul
    i32.const 0
    i32.div_s
    i32.const 0
    i32.div_u
    i32.const 0
    i32.rem_s
    i32.const 0
    i32.rem_u
    i32.const 0
    i32.and
    i32.const 0
    i32.or
    i32.const 0
    i32.xor
    i32.const 0
    i32.shl
    i32.const 0
    i32.shr_s
    i32.const 0
    i32.shr_u
    i32.const 0
    i32.rotl
    i32.const 0
    i32.rotr
    drop
    ;; Conversions.
    i64.const 0
    i32.wrap_i64
    drop
    f32.const 0.0
    i32.trunc_f32_s
    drop
    f32.const 0.0
    i32.trunc_f32_u
    drop
    f64.const 0.0
    i32.trunc_f64_s
    drop
    f64.const 0.0
    i32.trunc_f64_u
    drop
    f32.const 0.0
    i32.reinterpret_f32
    i32.extend8_s
    i32.extend16_s
  )
  ;; i64 operations.
  (func $func3 (result i64)
    ;; Comparisons and constant literals.
    i64.const 0
    i64.eqz
    drop
    i64.const 1
    i64.const -1
    i64.eq
    drop
    i64.const -9223372036854775808
    i64.const 9223372036854775807
    i64.ne
    drop
    i64.const 0
    i64.const 0
    i64.lt_s
    drop
    i64.const 0
    i64.const 0
    i64.lt_u
    drop
    i64.const 0
    i64.const 0
    i64.gt_s
    drop
    i64.const 0
    i64.const 0
    i64.gt_u
    drop
    i64.const 0
    i64.const 0
    i64.le_s
    drop
    i64.const 0
    i64.const 0
    i64.le_u
    drop
    i64.const 0
    i64.const 0
    i64.ge_s
    drop
    i64.const 0
    i64.const 0
    i64.ge_u
    drop
    ;; Bitcounting.
    i64.const 0
    i64.clz
    i64.ctz
    i64.popcnt
    ;; Arithmetic and logic.
    i64.const 0
    i64.add
    i64.const 0
    i64.sub
    i64.const 0
    i64.mul
    i64.const 0
    i64.div_s
    i64.const 0
    i64.div_u
    i64.const 0
    i64.rem_s
    i64.const 0
    i64.rem_u
    i64.const 0
    i64.and
    i64.const 0
    i64.or
    i64.const 0
    i64.xor
    i64.const 0
    i64.shl
    i64.const 0
    i64.shr_s
    i64.const 0
    i64.shr_u
    i64.const 0
    i64.rotl
    i64.const 0
    i64.rotr
    drop
    ;; Conversions.
    i32.const 0
    i64.extend_i32_s
    drop
    i32.const 0
    i64.extend_i32_u
    drop
    f32.const 0.0
    i64.trunc_f32_s
    drop
    f32.const 0.0
    i64.trunc_f32_u
    drop
    f64.const 0.0
    i64.trunc_f64_s
    drop
    f64.const 0.0
    i64.trunc_f64_u
    drop
    f64.const 0.0
    i64.reinterpret_f64
    i64.extend8_s
    i64.extend16_s
    i64.extend32_s
  )
  ;; f32 operations.
  (func $func4 (result f32)
    ;; Comparisons and constant literals.
    f32.const 0.0
    f32.const -0.0
    f32.eq
    drop
    f32.const 1
    f32.const -1
    f32.ne
    drop
    f32.const inf
    f32.const -inf
    f32.lt
    drop
    f32.const nan
    f32.const -nan
    f32.gt
    drop
    ;; Non-canonical NaN encodings.
    f32.const +nan:0x1
    f32.const +nan:0xfffff
    f32.le
    drop
    ;; TODO(dlehmann): Change to `0.1`, once `ImmediatesPrinter` is improved to
    ;; print floats as shortest round-trippable decimal representation.
    f32.const 0.100000001
    f32.const 1234567.5
    f32.ge
    drop
    ;; Arithmetic.
    f32.const 0.0
    f32.abs
    f32.neg
    f32.ceil
    f32.floor
    f32.trunc
    f32.nearest
    f32.sqrt
    f32.const 0.0
    f32.add
    f32.const 0.0
    f32.sub
    f32.const 0.0
    f32.mul
    f32.const 0.0
    f32.div
    f32.const 0.0
    f32.min
    f32.const 0.0
    f32.max
    f32.const 0.0
    f32.copysign
    drop
    ;; Conversions.
    i32.const 0
    f32.convert_i32_s
    drop
    i32.const 0
    f32.convert_i32_u
    drop
    i64.const 0
    f32.convert_i64_s
    drop
    i64.const 0
    f32.convert_i64_u
    drop
    f64.const 0.0
    f32.demote_f64
    drop
    i32.const 0
    f32.reinterpret_i32
  )
  ;; f64 operations.
  (func $func5 (result f64)
    ;; Comparisons and constant literals.
    f64.const 0.0
    f64.const -0.0
    f64.eq
    drop
    f64.const 1
    f64.const -1
    f64.ne
    drop
    f64.const inf
    f64.const -inf
    f64.lt
    drop
    f64.const nan
    f64.const -nan
    f64.gt
    drop
    ;; Non-canonical NaN encodings.
    f64.const +nan:0x1
    f64.const +nan:0xfffffffffffff
    f64.le
    drop
    f64.const 0.1
    f64.const 1234567.5
    f64.ge
    drop
    ;; Arithmetic.
    f64.const 0.0
    f64.abs
    f64.neg
    f64.ceil
    f64.floor
    f64.trunc
    f64.nearest
    f64.sqrt
    f64.const 0.0
    f64.add
    f64.const 0.0
    f64.sub
    f64.const 0.0
    f64.mul
    f64.const 0.0
    f64.div
    f64.const 0.0
    f64.min
    f64.const 0.0
    f64.max
    f64.const 0.0
    f64.copysign
    drop
    ;; Conversions.
    i32.const 0
    f64.convert_i32_s
    drop
    i32.const 0
    f64.convert_i32_u
    drop
    i64.const 0
    f64.convert_i64_s
    drop
    i64.const 0
    f64.convert_i64_u
    drop
    f32.const 0.0
    f64.promote_f32
    drop
    i64.const 0
    f64.reinterpret_i64
  )
  ;; Control-flow.
  (func $func6
    ;; Calls and return.
    call $func7
    i64.const 0
    i32.const 0
    call_indirect (param i64) (result f64)
    return
    ;; Blocks and loops, with and without block type.
    block $label0
      loop $label1
        block (result i64)
          loop $label2 (result i64)
            ;; Branches
            br $label0
            i32.const 0
            br_if $label1
            i32.const 0
            br_table $label0 $label1 $label1 $label2
            i64.const 0
          end $label2
        end
        drop
      end $label1
    end $label0
    ;; Select and if.
    i64.const 0
    i64.const 1
    i32.const 0
    select
    drop
    i32.const 0
    if (result i64)
      i64.const 0
    else
      i64.const 1
    end
    drop
  )
  ;; Memory operations.
  (func $func7
    ;; Loads.
    i32.const 0
    i32.load
    drop
    i32.const 0
    ;; Non-default memargs.
    i64.load offset=3
    drop
    i32.const 0
    f32.load align=2
    drop
    i32.const 0
    f64.load offset=3 align=4
    drop
    i32.const 0
    i32.load8_s
    drop
    i32.const 0
    i32.load8_u
    drop
    i32.const 0
    i32.load16_s
    drop
    i32.const 0
    i32.load16_u
    drop
    i32.const 0
    i64.load8_s
    drop
    i32.const 0
    i64.load8_u
    drop
    i32.const 0
    i64.load16_s
    drop
    i32.const 0
    i64.load16_u
    drop
    i32.const 0
    i64.load32_s
    drop
    i32.const 0
    i64.load32_u
    drop
    ;; Stores.
    i32.const 0
    i32.const 0
    i32.store
    i32.const 0
    i64.const 0
    i64.store
    i32.const 0
    f32.const 0.0
    f32.store
    i32.const 0
    f64.const 0.0
    f64.store
    i32.const 0
    i32.const 0
    i32.store8
    i32.const 0
    i32.const 0
    i32.store16
    i32.const 0
    i64.const 0
    i64.store8
    i32.const 0
    i64.const 0
    i64.store16
    i32.const 0
    i64.const 0
    i64.store32
    ;; Other memory instructions.
    memory.size
    memory.grow
    drop
  )
  ;; Other instructions. (Also an exported function.)
  (func $exported_function (;8;) (export "exported_function")
    nop
    unreachable
  )
  ;; Data and element sections.
  (data (global.get $env.imported_global) "foo\0a\00")
)
;;)---";
                 node-23.7.0/deps/v8/test/unittests/wasm/wasm-disassembler-unittest-names.wasm.inc                   0000664 0000000 0000000 00000022674 14746647661 0030111 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                          0x00, 0x61, 0x73, 0x6d,  // wasm magic
  0x01, 0x00, 0x00, 0x00,  // wasm version

  0x01,                    // section kind: Type
  0x0a,                    // section length 10
  0x02,                    // types count 2
  0x60,                    //  kind: func
  0x00,                    // param count 0
  0x00,                    // return count 0
  0x60,                    //  kind: func
  0x03,                    // param count 3
  0x7f, 0x7f, 0x7e,        // i32 i32 i64
  0x00,                    // return count 0

  0x02,                    // section kind: Import
  0x30,                    // section length 48
  0x02,                    // imports count 2
                           // import #0
  0x03,                    // module name length: 3
  0x65, 0x6e, 0x76,        // module name: env
  0x0f,                    // field name length: 15
  0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 
  0x5f, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 
                           // field name: imported_global
  0x03, 0x7f, 0x00,        // kind: global i32 immutable
                           // import #1
  0x03,                    // module name length: 3
  0x65, 0x6e, 0x76,        // module name: env
  0x11,                    // field name length: 17
  0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 
  0x5f, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 
  0x6e,                    // field name: imported_function
  0x00, 0x00,              // kind: function

  0x03,                    // section kind: Function
  0x03,                    // section length 3
  0x02,                    // functions count 2
  0x01,                    // 1 $function_with_name (param i32 i32 i64)
  0x00,                    // 2 $exported_function_with_name

  0x04,                    // section kind: Table
  0x04,                    // section length 4
  0x01, 0x70, 0x00,        // table count 1:  funcref no maximum
  0x00,                    // initial size 0

  0x05,                    // section kind: Memory
  0x03,                    // section length 3
  0x01, 0x00,              // memory count 1:  no maximum
  0x00,                    // initial size 0

  0x06,                    // section kind: Global
  0x0b,                    // section length 11
  0x02,                    // globals count 2
  0x7f, 0x00,              // global #1: i32 immutable
  0x41, 0x00, 0x0b,        // i32.const 0
  0x7f, 0x00,              // global #2: i32 immutable
  0x41, 0x00, 0x0b,        // i32.const 0

  0x07,                    // section kind: Export
  0x27,                    // section length 39
  0x02,                    // exports count 2
                           // export # 0
  0x0f,                    // field name length: 15
  0x65, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 
  0x5f, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 
                           // field name: exported_global
  0x03, 0x02,              // kind: global index: 2
                           // export # 1
  0x11,                    // field name length: 17
  0x65, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 
  0x5f, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 
  0x6e,                    // field name: exported_function
  0x00, 0x02,              // kind: function index: 2

  0x09,                    // section kind: Element
  0x05,                    // section length 5
  0x01, 0x01, 0x00,        // segment count 1: flag: passive, element type: function
  0x01, 0x01,              // number of elements 1: index: 1

  0x0a,                    // section kind: Code
  0x1d,                    // section length 29
  0x02,                    // functions count 2
                           // function #1 $function_with_name
  0x0b,                    // body size 11
  0x00,                    // 0 entries in locals list
  0x20, 0x00,              // local.get $param_with_name_1
  0x1a,                    // drop
  0x20, 0x01,              // local.get $param_with_name_2
  0x1a,                    // drop
  0x20, 0x02,              // local.get $param_with_name_3
  0x1a,                    // drop
  0x0b,                    // end
                           // function #2 $exported_function_with_name
  0x0f,                    // body size 15
  0x02,                    // 2 entries in locals list
  0x02, 0x7f,              // 2 locals of type i32
  0x01, 0x7e,              // 1 local of type i64
  0x20, 0x00,              // local.get $local_with_name_1
  0x1a,                    // drop
  0x20, 0x01,              // local.get $local_with_name_2
  0x1a,                    // drop
  0x20, 0x02,              // local.get $local_with_name_3
  0x1a,                    // drop
  0x0b,                    // end

  0x0b,                    // section kind: Data
  0x0b,                    // section length 11
  0x01, 0x00,              // data segments count 1: flag: active no index
  0x41, 0x00, 0x0b,        // i32.const 0
  0x05,                    // source size 5
  0x66, 0x6f, 0x6f, 0x0a, 0x00,  // segment data

  0x00,                    // section kind: Unknown
  0xd8, 0x02,              // section length 344
  0x04,                    // section name length: 4
  0x6e, 0x61, 0x6d, 0x65,  // section name: name
  0x01,                    // name type: function
  0x4f,                    // payload length: 79
  0x03,                    // names count 3
  0x00, 0x1b,              // index 0 name length: 27
  0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 
  0x5f, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 
  0x6e, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x6e, 
  0x61, 0x6d, 0x65,        // name: imported_function_with_name
  0x01, 0x12,              // index 1 name length: 18
  0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 
  0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x6e, 0x61, 
  0x6d, 0x65,              // name: function_with_name
  0x02, 0x1b,              // index 2 name length: 27
  0x65, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 
  0x5f, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 
  0x6e, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x6e, 
  0x61, 0x6d, 0x65,        // name: exported_function_with_name
  0x02,                    // name type: local
  0x79,                    // payload length: 121
  0x03,                    // outer count 3
  0x00, 0x00,              // outer index 0 inner count 0
  0x01, 0x03,              // outer index 1 inner count 3
  0x00, 0x11,              // inner index 0 name length: 17
  0x70, 0x61, 0x72, 0x61, 0x6d, 0x5f, 0x77, 0x69, 
  0x74, 0x68, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x5f, 
  0x31,                    // name: param_with_name_1
  0x01, 0x11,              // inner index 1 name length: 17
  0x70, 0x61, 0x72, 0x61, 0x6d, 0x5f, 0x77, 0x69, 
  0x74, 0x68, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x5f, 
  0x32,                    // name: param_with_name_2
  0x02, 0x11,              // inner index 2 name length: 17
  0x70, 0x61, 0x72, 0x61, 0x6d, 0x5f, 0x77, 0x69, 
  0x74, 0x68, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x5f, 
  0x33,                    // name: param_with_name_3
  0x02, 0x03,              // outer index 2 inner count 3
  0x00, 0x11,              // inner index 0 name length: 17
  0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x5f, 0x77, 0x69, 
  0x74, 0x68, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x5f, 
  0x31,                    // name: local_with_name_1
  0x01, 0x11,              // inner index 1 name length: 17
  0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x5f, 0x77, 0x69, 
  0x74, 0x68, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x5f, 
  0x32,                    // name: local_with_name_2
  0x02, 0x11,              // inner index 2 name length: 17
  0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x5f, 0x77, 0x69, 
  0x74, 0x68, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x5f, 
  0x33,                    // name: local_with_name_3
  0x05,                    // name type: table
  0x12,                    // payload length: 18
  0x01,                    // names count 1
  0x00, 0x0f,              // index 0 name length: 15
  0x74, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x77, 0x69, 
  0x74, 0x68, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 
                           // name: table_with_name
  0x06,                    // name type: memory
  0x13,                    // payload length: 19
  0x01,                    // names count 1
  0x00, 0x10,              // index 0 name length: 16
  0x6d, 0x65, 0x6d, 0x6f, 0x72, 0x79, 0x5f, 0x77, 
  0x69, 0x74, 0x68, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 
                           // name: memory_with_name
  0x07,                    // name type: global
  0x49,                    // payload length: 73
  0x03,                    // names count 3
  0x00, 0x19,              // index 0 name length: 25
  0x69, 0x6d, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 
  0x5f, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x5f, 
  0x77, 0x69, 0x74, 0x68, 0x5f, 0x6e, 0x61, 0x6d, 
  0x65,                    // name: imported_global_with_name
  0x01, 0x10,              // index 1 name length: 16
  0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x5f, 0x77, 
  0x69, 0x74, 0x68, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 
                           // name: global_with_name
  0x02, 0x19,              // index 2 name length: 25
  0x65, 0x78, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 
  0x5f, 0x67, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x5f, 
  0x77, 0x69, 0x74, 0x68, 0x5f, 0x6e, 0x61, 0x6d, 
  0x65,                    // name: exported_global_with_name
  0x08,                    // name type: element segment
  0x11,                    // payload length: 17
  0x01,                    // names count 1
  0x00, 0x0e,              // index 0 name length: 14
  0x65, 0x6c, 0x65, 0x6d, 0x5f, 0x77, 0x69, 0x74, 
  0x68, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 
                           // name: elem_with_name
                                                                    node-23.7.0/deps/v8/test/unittests/wasm/wasm-disassembler-unittest-names.wat.inc                    0000664 0000000 0000000 00000003340 14746647661 0027722 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        ;; expected = R"---(;; This is a polyglot C++/WAT file.
;; Comment lines are ignored and not expected in the disassembler output.
(module
  ;; TODO(jkummerow): This type name is missing from the disassembler ouput.
  ;; (type $type_with_name (;0;) (func (param f32)))
  (global $imported_global_with_name (;0;) (import "env" "imported_global") i32)
  (func $imported_function_with_name (;0;) (import "env" "imported_function"))
  (table $table_with_name (;0;) 0 funcref)
  (memory $memory_with_name (;0;) 0)
  (global $global_with_name (;1;) i32 (i32.const 0))
  (global $exported_global_with_name (;2;) (export "exported_global") i32 (i32.const 0))
  (elem $elem_with_name (;0;) (ref func) (ref.func $function_with_name))
  (func $function_with_name (;1;) (param $param_with_name_1 (;0;) i32) (param $param_with_name_2 (;1;) i32) (param $param_with_name_3 (;2;) i64)
    local.get $param_with_name_1
    drop
    local.get $param_with_name_2
    drop
    local.get $param_with_name_3
    drop
  )
  (func $exported_function_with_name (;2;) (export "exported_function")
    ;; Local variables.
    (local $local_with_name_1 i32)
    (local $local_with_name_2 i32)
    (local $local_with_name_3 i64)
    local.get $local_with_name_1
    drop
    local.get $local_with_name_2
    drop
    local.get $local_with_name_3
    drop
  )
  ;; TODO(jkummerow): Functions with a named type are printed with their type
  ;; inline instead of as follows.
  ;; (func $another_function (;3;) (type $type_with_name)
  ;; )
  ;; For compatibility with the legacy DevTools behavior, we don't print data
  ;; segment names. If we change that, uncomment the following line.
  ;; (data $data_with_name (;0;) (i32.const 0) "foo\0a\00")
  (data (i32.const 0) "foo\0a\00")
)
;;)---";
                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/unittests/wasm/wasm-disassembler-unittest-simd.wasm.inc                    0000664 0000000 0000000 00000053076 14746647661 0027742 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                          0x00, 0x61, 0x73, 0x6d,  // wasm magic
  0x01, 0x00, 0x00, 0x00,  // wasm version

  0x01,                    // section kind: Type
  0x08,                    // section length 8
  0x02,                    // types count 2
  0x60,                    //  kind: func
  0x00,                    // param count 0
  0x01, 0x7b,              // return count 1:  v128
  0x60,                    //  kind: func
  0x00,                    // param count 0
  0x00,                    // return count 0

  0x03,                    // section kind: Function
  0x03,                    // section length 3
  0x02,                    // functions count 2
  0x00,                    // 0 $func0 (result v128)
  0x01,                    // 1 $func1

  0x05,                    // section kind: Memory
  0x03,                    // section length 3
  0x01, 0x00,              // memory count 1:  no maximum
  0x00,                    // initial size 0

  0x0a,                    // section kind: Code
  0xed, 0x08,              // section length 1133
  0x02,                    // functions count 2
                           // function #0 $func0
  0x14,                    // body size 20
  0x00,                    // 0 entries in locals list
  0xfd, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // v128.const i32x4 0x00000000 0x00000000 0x00000000 0x00000000
  0x0b,                    // end
                           // function #1 $func1
  0xd5, 0x08,              // body size 1109
  0x00,                    // 0 entries in locals list
  0x41, 0x00,              // i32.const 0
  0xfd, 0x00, 0x04, 0x00,  // v128.load
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0xfd, 0x01, 0x03, 0x03,  // v128.load8x8_s offset=3
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0xfd, 0x02, 0x01, 0x00,  // v128.load8x8_u align=2
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0xfd, 0x03, 0x02, 0x03,  // v128.load16x4_s offset=3 align=4
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0xfd, 0x04, 0x03, 0x00,  // v128.load16x4_u
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0xfd, 0x05, 0x03, 0x00,  // v128.load32x2_s
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0xfd, 0x06, 0x03, 0x00,  // v128.load32x2_u
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0xfd, 0x07, 0x00, 0x00,  // v128.load8_splat
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0xfd, 0x08, 0x01, 0x00,  // v128.load16_splat
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0xfd, 0x09, 0x02, 0x00,  // v128.load32_splat
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0xfd, 0x0a, 0x03, 0x00,  // v128.load64_splat
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0xfd, 0x5c, 0x02, 0x00,  // v128.load32_zero
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0xfd, 0x5d, 0x03, 0x00,  // v128.load64_zero
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0x10, 0x00,              // call $func0
  0xfd, 0x0b, 0x04, 0x00,  // v128.store
  0x41, 0x00,              // i32.const 0
  0x10, 0x00,              // call $func0
  0xfd, 0x54, 0x00, 0x00, 0x00,  // v128.load8_lane 0
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0x10, 0x00,              // call $func0
  0xfd, 0x55, 0x01, 0x00, 0x01,  // v128.load16_lane 1
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0x10, 0x00,              // call $func0
  0xfd, 0x56, 0x02, 0x00, 0x03,  // v128.load32_lane 3
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0x10, 0x00,              // call $func0
  0xfd, 0x57, 0x03, 0x00, 0x00,  // v128.load64_lane 0
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0x10, 0x00,              // call $func0
  0xfd, 0x59, 0x01, 0x00, 0x00,  // v128.store16_lane 0
  0x41, 0x00,              // i32.const 0
  0x10, 0x00,              // call $func0
  0xfd, 0x5a, 0x02, 0x00, 0x01,  // v128.store32_lane 1
  0x41, 0x00,              // i32.const 0
  0x10, 0x00,              // call $func0
  0xfd, 0x5b, 0x03, 0x00, 0x00,  // v128.store64_lane 0
  0x10, 0x00,              // call $func0
  0x10, 0x00,              // call $func0
  0xfd, 0x0d, 0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x02, 0x03,  // i8x16.shuffle 0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3
  0x10, 0x00,              // call $func0
  0xfd, 0x0e,              // i8x16.swizzle
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0xfd, 0x0f,              // i8x16.splat
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0xfd, 0x10,              // i16x8.splat
  0x1a,                    // drop
  0x41, 0x00,              // i32.const 0
  0xfd, 0x11,              // i32x4.splat
  0x1a,                    // drop
  0x42, 0x00,              // i64.const 0
  0xfd, 0x12,              // i64x2.splat
  0x1a,                    // drop
  0x43, 0x00, 0x00, 0x00, 0x00,  // f32.const 0.0
  0xfd, 0x13,              // f32x4.splat
  0x1a,                    // drop
  0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // f64.const 0.0
  0xfd, 0x14,              // f64x2.splat
  0x1a,                    // drop
  0x10, 0x00,              // call $func0
  0xfd, 0x15, 0x00,        // i8x16.extract_lane_s 0
  0x1a,                    // drop
  0x10, 0x00,              // call $func0
  0xfd, 0x16, 0x00,        // i8x16.extract_lane_u 0
  0x1a,                    // drop
  0x10, 0x00,              // call $func0
  0xfd, 0x18, 0x00,        // i16x8.extract_lane_s 0
  0x1a,                    // drop
  0x10, 0x00,              // call $func0
  0xfd, 0x19, 0x00,        // i16x8.extract_lane_u 0
  0x1a,                    // drop
  0x10, 0x00,              // call $func0
  0xfd, 0x1b, 0x00,        // i32x4.extract_lane 0
  0x1a,                    // drop
  0x10, 0x00,              // call $func0
  0xfd, 0x1d, 0x00,        // i64x2.extract_lane 0
  0x1a,                    // drop
  0x10, 0x00,              // call $func0
  0xfd, 0x1f, 0x00,        // f32x4.extract_lane 0
  0x1a,                    // drop
  0x10, 0x00,              // call $func0
  0xfd, 0x21, 0x00,        // f64x2.extract_lane 0
  0x1a,                    // drop
  0x10, 0x00,              // call $func0
  0x41, 0x00,              // i32.const 0
  0xfd, 0x17, 0x00,        // i8x16.replace_lane 0
  0x41, 0x00,              // i32.const 0
  0xfd, 0x1a, 0x00,        // i16x8.replace_lane 0
  0x41, 0x00,              // i32.const 0
  0xfd, 0x1c, 0x00,        // i32x4.replace_lane 0
  0x42, 0x00,              // i64.const 0
  0xfd, 0x1e, 0x00,        // i64x2.replace_lane 0
  0x43, 0x00, 0x00, 0x00, 0x00,  // f32.const 0.0
  0xfd, 0x20, 0x00,        // f32x4.replace_lane 0
  0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // f64.const 0.0
  0xfd, 0x22, 0x00,        // f64x2.replace_lane 0
  0x10, 0x00,              // call $func0
  0xfd, 0x23,              // i8x16.eq
  0x10, 0x00,              // call $func0
  0xfd, 0x24,              // i8x16.ne
  0x10, 0x00,              // call $func0
  0xfd, 0x25,              // i8x16.lt_s
  0x10, 0x00,              // call $func0
  0xfd, 0x26,              // i8x16.lt_u
  0x10, 0x00,              // call $func0
  0xfd, 0x27,              // i8x16.gt_s
  0x10, 0x00,              // call $func0
  0xfd, 0x28,              // i8x16.gt_u
  0x10, 0x00,              // call $func0
  0xfd, 0x29,              // i8x16.le_s
  0x10, 0x00,              // call $func0
  0xfd, 0x2a,              // i8x16.le_u
  0x10, 0x00,              // call $func0
  0xfd, 0x2b,              // i8x16.ge_s
  0x10, 0x00,              // call $func0
  0xfd, 0x2c,              // i8x16.ge_u
  0x10, 0x00,              // call $func0
  0xfd, 0x2d,              // i16x8.eq
  0x10, 0x00,              // call $func0
  0xfd, 0x2e,              // i16x8.ne
  0x10, 0x00,              // call $func0
  0xfd, 0x2f,              // i16x8.lt_s
  0x10, 0x00,              // call $func0
  0xfd, 0x30,              // i16x8.lt_u
  0x10, 0x00,              // call $func0
  0xfd, 0x31,              // i16x8.gt_s
  0x10, 0x00,              // call $func0
  0xfd, 0x32,              // i16x8.gt_u
  0x10, 0x00,              // call $func0
  0xfd, 0x33,              // i16x8.le_s
  0x10, 0x00,              // call $func0
  0xfd, 0x34,              // i16x8.le_u
  0x10, 0x00,              // call $func0
  0xfd, 0x35,              // i16x8.ge_s
  0x10, 0x00,              // call $func0
  0xfd, 0x36,              // i16x8.ge_u
  0x10, 0x00,              // call $func0
  0xfd, 0x37,              // i32x4.eq
  0x10, 0x00,              // call $func0
  0xfd, 0x38,              // i32x4.ne
  0x10, 0x00,              // call $func0
  0xfd, 0x39,              // i32x4.lt_s
  0x10, 0x00,              // call $func0
  0xfd, 0x3a,              // i32x4.lt_u
  0x10, 0x00,              // call $func0
  0xfd, 0x3b,              // i32x4.gt_s
  0x10, 0x00,              // call $func0
  0xfd, 0x3c,              // i32x4.gt_u
  0x10, 0x00,              // call $func0
  0xfd, 0x3d,              // i32x4.le_s
  0x10, 0x00,              // call $func0
  0xfd, 0x3e,              // i32x4.le_u
  0x10, 0x00,              // call $func0
  0xfd, 0x3f,              // i32x4.ge_s
  0x10, 0x00,              // call $func0
  0xfd, 0x40,              // i32x4.ge_u
  0x10, 0x00,              // call $func0
  0xfd, 0xd6, 0x01,        // i64x2.eq
  0x10, 0x00,              // call $func0
  0xfd, 0xd7, 0x01,        // i64x2.ne
  0x10, 0x00,              // call $func0
  0xfd, 0xd8, 0x01,        // i64x2.lt_s
  0x10, 0x00,              // call $func0
  0xfd, 0xd9, 0x01,        // i64x2.gt_s
  0x10, 0x00,              // call $func0
  0xfd, 0xda, 0x01,        // i64x2.le_s
  0x10, 0x00,              // call $func0
  0xfd, 0xdb, 0x01,        // i64x2.ge_s
  0x10, 0x00,              // call $func0
  0xfd, 0x41,              // f32x4.eq
  0x10, 0x00,              // call $func0
  0xfd, 0x42,              // f32x4.ne
  0x10, 0x00,              // call $func0
  0xfd, 0x43,              // f32x4.lt
  0x10, 0x00,              // call $func0
  0xfd, 0x44,              // f32x4.gt
  0x10, 0x00,              // call $func0
  0xfd, 0x45,              // f32x4.le
  0x10, 0x00,              // call $func0
  0xfd, 0x46,              // f32x4.ge
  0x10, 0x00,              // call $func0
  0xfd, 0x47,              // f64x2.eq
  0x10, 0x00,              // call $func0
  0xfd, 0x48,              // f64x2.ne
  0x10, 0x00,              // call $func0
  0xfd, 0x49,              // f64x2.lt
  0x10, 0x00,              // call $func0
  0xfd, 0x4a,              // f64x2.gt
  0x10, 0x00,              // call $func0
  0xfd, 0x4b,              // f64x2.le
  0x10, 0x00,              // call $func0
  0xfd, 0x4c,              // f64x2.ge
  0xfd, 0x4d,              // v128.not
  0x10, 0x00,              // call $func0
  0xfd, 0x4e,              // v128.and
  0x10, 0x00,              // call $func0
  0xfd, 0x4f,              // v128.andnot
  0x10, 0x00,              // call $func0
  0xfd, 0x50,              // v128.or
  0x10, 0x00,              // call $func0
  0xfd, 0x51,              // v128.xor
  0x10, 0x00,              // call $func0
  0x10, 0x00,              // call $func0
  0xfd, 0x52,              // v128.bitselect
  0xfd, 0x53,              // v128.any_true
  0x1a,                    // drop
  0x10, 0x00,              // call $func0
  0xfd, 0x5e,              // f32x4.demote_f64x2_zero
  0xfd, 0x5f,              // f64x2.promote_low_f32x4
  0xfd, 0x60,              // i8x16.abs
  0xfd, 0x61,              // i8x16.neg
  0xfd, 0x62,              // i8x16.popcnt
  0xfd, 0x63,              // i8x16.all_true
  0x1a,                    // drop
  0x10, 0x00,              // call $func0
  0xfd, 0x64,              // i8x16.bitmask
  0x1a,                    // drop
  0x10, 0x00,              // call $func0
  0x10, 0x00,              // call $func0
  0xfd, 0x65,              // i8x16.narrow_i16x8_s
  0x10, 0x00,              // call $func0
  0xfd, 0x66,              // i8x16.narrow_i16x8_u
  0x41, 0x00,              // i32.const 0
  0xfd, 0x6b,              // i8x16.shl
  0x41, 0x00,              // i32.const 0
  0xfd, 0x6c,              // i8x16.shr_s
  0x41, 0x00,              // i32.const 0
  0xfd, 0x6d,              // i8x16.shr_u
  0x10, 0x00,              // call $func0
  0xfd, 0x6e,              // i8x16.add
  0x10, 0x00,              // call $func0
  0xfd, 0x6f,              // i8x16.add_sat_s
  0x10, 0x00,              // call $func0
  0xfd, 0x70,              // i8x16.add_sat_u
  0x10, 0x00,              // call $func0
  0xfd, 0x71,              // i8x16.sub
  0x10, 0x00,              // call $func0
  0xfd, 0x72,              // i8x16.sub_sat_s
  0x10, 0x00,              // call $func0
  0xfd, 0x73,              // i8x16.sub_sat_u
  0x10, 0x00,              // call $func0
  0xfd, 0x76,              // i8x16.min_s
  0x10, 0x00,              // call $func0
  0xfd, 0x77,              // i8x16.min_u
  0x10, 0x00,              // call $func0
  0xfd, 0x78,              // i8x16.max_s
  0x10, 0x00,              // call $func0
  0xfd, 0x79,              // i8x16.max_u
  0x10, 0x00,              // call $func0
  0xfd, 0x7b,              // i8x16.avgr_u
  0xfd, 0x80, 0x01,        // i16x8.abs
  0xfd, 0x81, 0x01,        // i16x8.neg
  0x10, 0x00,              // call $func0
  0xfd, 0x82, 0x01,        // i16x8.q15mulr_sat_s
  0xfd, 0x83, 0x01,        // i16x8.all_true
  0x1a,                    // drop
  0x10, 0x00,              // call $func0
  0xfd, 0x84, 0x01,        // i16x8.bitmask
  0x1a,                    // drop
  0x10, 0x00,              // call $func0
  0x10, 0x00,              // call $func0
  0xfd, 0x85, 0x01,        // i16x8.narrow_i32x4_s
  0x10, 0x00,              // call $func0
  0xfd, 0x86, 0x01,        // i16x8.narrow_i32x4_u
  0xfd, 0x87, 0x01,        // i16x8.extend_low_i8x16_s
  0xfd, 0x88, 0x01,        // i16x8.extend_high_i8x16_s
  0xfd, 0x89, 0x01,        // i16x8.extend_low_i8x16_u
  0xfd, 0x8a, 0x01,        // i16x8.extend_high_i8x16_u
  0x41, 0x00,              // i32.const 0
  0xfd, 0x8b, 0x01,        // i16x8.shl
  0x41, 0x00,              // i32.const 0
  0xfd, 0x8c, 0x01,        // i16x8.shr_s
  0x41, 0x00,              // i32.const 0
  0xfd, 0x8d, 0x01,        // i16x8.shr_u
  0x10, 0x00,              // call $func0
  0xfd, 0x8e, 0x01,        // i16x8.add
  0x10, 0x00,              // call $func0
  0xfd, 0x8f, 0x01,        // i16x8.add_sat_s
  0x10, 0x00,              // call $func0
  0xfd, 0x90, 0x01,        // i16x8.add_sat_u
  0x10, 0x00,              // call $func0
  0xfd, 0x91, 0x01,        // i16x8.sub
  0x10, 0x00,              // call $func0
  0xfd, 0x92, 0x01,        // i16x8.sub_sat_s
  0x10, 0x00,              // call $func0
  0xfd, 0x93, 0x01,        // i16x8.sub_sat_u
  0x10, 0x00,              // call $func0
  0xfd, 0x95, 0x01,        // i16x8.mul
  0x10, 0x00,              // call $func0
  0xfd, 0x96, 0x01,        // i16x8.min_s
  0x10, 0x00,              // call $func0
  0xfd, 0x97, 0x01,        // i16x8.min_u
  0x10, 0x00,              // call $func0
  0xfd, 0x98, 0x01,        // i16x8.max_s
  0x10, 0x00,              // call $func0
  0xfd, 0x99, 0x01,        // i16x8.max_u
  0x10, 0x00,              // call $func0
  0xfd, 0x9b, 0x01,        // i16x8.avgr_u
  0xfd, 0xa0, 0x01,        // i32x4.abs
  0xfd, 0xa1, 0x01,        // i32x4.neg
  0xfd, 0xa3, 0x01,        // i32x4.all_true
  0x1a,                    // drop
  0x10, 0x00,              // call $func0
  0xfd, 0xa4, 0x01,        // i32x4.bitmask
  0x1a,                    // drop
  0x10, 0x00,              // call $func0
  0xfd, 0xa7, 0x01,        // i32x4.extend_low_i16x8_s
  0xfd, 0xa8, 0x01,        // i32x4.extend_high_i16x8_s
  0xfd, 0xa9, 0x01,        // i32x4.extend_low_i16x8_u
  0xfd, 0xaa, 0x01,        // i32x4.extend_high_i16x8_u
  0x41, 0x00,              // i32.const 0
  0xfd, 0xab, 0x01,        // i32x4.shl
  0x41, 0x00,              // i32.const 0
  0xfd, 0xac, 0x01,        // i32x4.shr_s
  0x41, 0x00,              // i32.const 0
  0xfd, 0xad, 0x01,        // i32x4.shr_u
  0x10, 0x00,              // call $func0
  0xfd, 0xae, 0x01,        // i32x4.add
  0x10, 0x00,              // call $func0
  0xfd, 0xb1, 0x01,        // i32x4.sub
  0x10, 0x00,              // call $func0
  0xfd, 0xb5, 0x01,        // i32x4.mul
  0x10, 0x00,              // call $func0
  0xfd, 0xb6, 0x01,        // i32x4.min_s
  0x10, 0x00,              // call $func0
  0xfd, 0xb7, 0x01,        // i32x4.min_u
  0x10, 0x00,              // call $func0
  0xfd, 0xb8, 0x01,        // i32x4.max_s
  0x10, 0x00,              // call $func0
  0xfd, 0xb9, 0x01,        // i32x4.max_u
  0x10, 0x00,              // call $func0
  0xfd, 0xba, 0x01,        // i32x4.dot_i16x8_s
  0xfd, 0xc0, 0x01,        // i64x2.abs
  0xfd, 0xc1, 0x01,        // i64x2.neg
  0xfd, 0xc3, 0x01,        // i64x2.all_true
  0x1a,                    // drop
  0x10, 0x00,              // call $func0
  0xfd, 0xc4, 0x01,        // i64x2.bitmask
  0x1a,                    // drop
  0x10, 0x00,              // call $func0
  0xfd, 0xc7, 0x01,        // i64x2.extend_low_i32x4_s
  0xfd, 0xc8, 0x01,        // i64x2.extend_high_i32x4_s
  0xfd, 0xc9, 0x01,        // i64x2.extend_low_i32x4_u
  0xfd, 0xca, 0x01,        // i64x2.extend_high_i32x4_u
  0x41, 0x00,              // i32.const 0
  0xfd, 0xcb, 0x01,        // i64x2.shl
  0x41, 0x00,              // i32.const 0
  0xfd, 0xcc, 0x01,        // i64x2.shr_s
  0x41, 0x00,              // i32.const 0
  0xfd, 0xcd, 0x01,        // i64x2.shr_u
  0x10, 0x00,              // call $func0
  0xfd, 0xce, 0x01,        // i64x2.add
  0x10, 0x00,              // call $func0
  0xfd, 0xd1, 0x01,        // i64x2.sub
  0x10, 0x00,              // call $func0
  0xfd, 0xd5, 0x01,        // i64x2.mul
  0xfd, 0x67,              // f32x4.ceil
  0xfd, 0x68,              // f32x4.floor
  0xfd, 0x69,              // f32x4.trunc
  0xfd, 0x6a,              // f32x4.nearest
  0xfd, 0xe0, 0x01,        // f32x4.abs
  0xfd, 0xe1, 0x01,        // f32x4.neg
  0xfd, 0xe3, 0x01,        // f32x4.sqrt
  0x10, 0x00,              // call $func0
  0xfd, 0xe4, 0x01,        // f32x4.add
  0x10, 0x00,              // call $func0
  0xfd, 0xe5, 0x01,        // f32x4.sub
  0x10, 0x00,              // call $func0
  0xfd, 0xe6, 0x01,        // f32x4.mul
  0x10, 0x00,              // call $func0
  0xfd, 0xe7, 0x01,        // f32x4.div
  0x10, 0x00,              // call $func0
  0xfd, 0xe8, 0x01,        // f32x4.min
  0x10, 0x00,              // call $func0
  0xfd, 0xe9, 0x01,        // f32x4.max
  0x10, 0x00,              // call $func0
  0xfd, 0xea, 0x01,        // f32x4.pmin
  0x10, 0x00,              // call $func0
  0xfd, 0xeb, 0x01,        // f32x4.pmax
  0xfd, 0x74,              // f64x2.ceil
  0xfd, 0x75,              // f64x2.floor
  0xfd, 0x7a,              // f64x2.trunc
  0xfd, 0x94, 0x01,        // f64x2.nearest
  0xfd, 0xec, 0x01,        // f64x2.abs
  0xfd, 0xed, 0x01,        // f64x2.neg
  0xfd, 0xef, 0x01,        // f64x2.sqrt
  0x10, 0x00,              // call $func0
  0xfd, 0xf0, 0x01,        // f64x2.add
  0x10, 0x00,              // call $func0
  0xfd, 0xf1, 0x01,        // f64x2.sub
  0x10, 0x00,              // call $func0
  0xfd, 0xf2, 0x01,        // f64x2.mul
  0x10, 0x00,              // call $func0
  0xfd, 0xf3, 0x01,        // f64x2.div
  0x10, 0x00,              // call $func0
  0xfd, 0xf4, 0x01,        // f64x2.min
  0x10, 0x00,              // call $func0
  0xfd, 0xf5, 0x01,        // f64x2.max
  0x10, 0x00,              // call $func0
  0xfd, 0xf6, 0x01,        // f64x2.pmin
  0x10, 0x00,              // call $func0
  0xfd, 0xf7, 0x01,        // f64x2.pmax
  0xfd, 0x7c,              // i16x8.extadd_pairwise_i8x16_s
  0xfd, 0x7d,              // i16x8.extadd_pairwise_i8x16_u
  0xfd, 0x7e,              // i32x4.extadd_pairwise_i16x8_s
  0xfd, 0x7f,              // i32x4.extadd_pairwise_i16x8_u
  0x10, 0x00,              // call $func0
  0xfd, 0x9c, 0x01,        // i16x8.extmul_low_i8x16_s
  0x10, 0x00,              // call $func0
  0xfd, 0x9d, 0x01,        // i16x8.extmul_high_i8x16_s
  0x10, 0x00,              // call $func0
  0xfd, 0x9e, 0x01,        // i16x8.extmul_low_i8x16_u
  0x10, 0x00,              // call $func0
  0xfd, 0x9f, 0x01,        // i16x8.extmul_high_i8x16_u
  0x10, 0x00,              // call $func0
  0xfd, 0xbc, 0x01,        // i32x4.extmul_low_i16x8_s
  0x10, 0x00,              // call $func0
  0xfd, 0xbd, 0x01,        // i32x4.extmul_high_i16x8_s
  0x10, 0x00,              // call $func0
  0xfd, 0xbe, 0x01,        // i32x4.extmul_low_i16x8_u
  0x10, 0x00,              // call $func0
  0xfd, 0xbf, 0x01,        // i32x4.extmul_high_i16x8_u
  0x10, 0x00,              // call $func0
  0xfd, 0xdc, 0x01,        // i64x2.extmul_low_i32x4_s
  0x10, 0x00,              // call $func0
  0xfd, 0xdd, 0x01,        // i64x2.extmul_high_i32x4_s
  0x10, 0x00,              // call $func0
  0xfd, 0xde, 0x01,        // i64x2.extmul_low_i32x4_u
  0x10, 0x00,              // call $func0
  0xfd, 0xdf, 0x01,        // i64x2.extmul_high_i32x4_u
  0xfd, 0xf8, 0x01,        // i32x4.trunc_sat_f32x4_s
  0xfd, 0xf9, 0x01,        // i32x4.trunc_sat_f32x4_u
  0xfd, 0xfa, 0x01,        // f32x4.convert_i32x4_s
  0xfd, 0xfb, 0x01,        // f32x4.convert_i32x4_u
  0xfd, 0xfc, 0x01,        // i32x4.trunc_sat_f64x2_s_zero
  0xfd, 0xfd, 0x01,        // i32x4.trunc_sat_f64x2_u_zero
  0xfd, 0xfe, 0x01,        // f64x2.convert_low_i32x4_s
  0xfd, 0xff, 0x01,        // f64x2.convert_low_i32x4_u
  0x1a,                    // drop
  0x0b,                    // end
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/test/unittests/wasm/wasm-disassembler-unittest-simd.wat.inc                     0000664 0000000 0000000 00000021501 14746647661 0027552 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        ;; expected = R"---(;; This is a polyglot C++/WAT file.
;; Comment lines are ignored and not expected in the disassembler output.
(module
  (memory $memory0 0)
  ;; Function with SIMD type and constant.
  (func $func0 (result v128)
    ;; We always print v128 constants as hexadecimal 4*i32.
    v128.const i32x4 0x00000000 0x00000000 0x00000000 0x00000000
  )
  (func $func1
    ;; SIMD load and stores.
    i32.const 0
    v128.load
    drop
    i32.const 0
    ;; Non-default memargs.
    v128.load8x8_s offset=3
    drop
    i32.const 0
    v128.load8x8_u align=2
    drop
    i32.const 0
    v128.load16x4_s offset=3 align=4
    drop
    i32.const 0
    v128.load16x4_u
    drop
    i32.const 0
    v128.load32x2_s
    drop
    i32.const 0
    v128.load32x2_u
    drop
    i32.const 0
    v128.load8_splat
    drop
    i32.const 0
    v128.load16_splat
    drop
    i32.const 0
    v128.load32_splat
    drop
    i32.const 0
    v128.load64_splat
    drop
    i32.const 0
    v128.load32_zero
    drop
    i32.const 0
    v128.load64_zero
    drop
    i32.const 0
    ;; Call function instead of repeating large immediate(s) all the time.
    call $func0
    v128.store
    i32.const 0
    call $func0
    v128.load8_lane 0
    drop
    i32.const 0
    call $func0
    v128.load16_lane 1
    drop
    i32.const 0
    call $func0
    v128.load32_lane 3
    drop
    i32.const 0
    call $func0
    v128.load64_lane 0
    drop
    i32.const 0
    call $func0
    v128.store16_lane 0
    i32.const 0
    call $func0
    v128.store32_lane 1
    i32.const 0
    call $func0
    v128.store64_lane 0
    ;; Other SIMD instructions.
    call $func0
    call $func0
    i8x16.shuffle 0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3
    call $func0
    i8x16.swizzle
    drop
    ;; splat
    i32.const 0
    i8x16.splat
    drop
    i32.const 0
    i16x8.splat
    drop
    i32.const 0
    i32x4.splat
    drop
    i64.const 0
    i64x2.splat
    drop
    f32.const 0.0
    f32x4.splat
    drop
    f64.const 0.0
    f64x2.splat
    drop
    ;; extract_lane and replace_lane
    call $func0
    i8x16.extract_lane_s 0
    drop
    call $func0
    i8x16.extract_lane_u 0
    drop
    call $func0
    i16x8.extract_lane_s 0
    drop
    call $func0
    i16x8.extract_lane_u 0
    drop
    call $func0
    i32x4.extract_lane 0
    drop
    call $func0
    i64x2.extract_lane 0
    drop
    call $func0
    f32x4.extract_lane 0
    drop
    call $func0
    f64x2.extract_lane 0
    drop
    call $func0
    i32.const 0
    i8x16.replace_lane 0
    i32.const 0
    i16x8.replace_lane 0
    i32.const 0
    i32x4.replace_lane 0
    i64.const 0
    i64x2.replace_lane 0
    f32.const 0.0
    f32x4.replace_lane 0
    f64.const 0.0
    f64x2.replace_lane 0
    ;; Comparisons: i8
    call $func0
    i8x16.eq
    call $func0
    i8x16.ne
    call $func0
    i8x16.lt_s
    call $func0
    i8x16.lt_u
    call $func0
    i8x16.gt_s
    call $func0
    i8x16.gt_u
    call $func0
    i8x16.le_s
    call $func0
    i8x16.le_u
    call $func0
    i8x16.ge_s
    call $func0
    i8x16.ge_u
    ;; Comparisons: i16
    call $func0
    i16x8.eq
    call $func0
    i16x8.ne
    call $func0
    i16x8.lt_s
    call $func0
    i16x8.lt_u
    call $func0
    i16x8.gt_s
    call $func0
    i16x8.gt_u
    call $func0
    i16x8.le_s
    call $func0
    i16x8.le_u
    call $func0
    i16x8.ge_s
    call $func0
    i16x8.ge_u
    ;; Comparisons: i32
    call $func0
    i32x4.eq
    call $func0
    i32x4.ne
    call $func0
    i32x4.lt_s
    call $func0
    i32x4.lt_u
    call $func0
    i32x4.gt_s
    call $func0
    i32x4.gt_u
    call $func0
    i32x4.le_s
    call $func0
    i32x4.le_u
    call $func0
    i32x4.ge_s
    call $func0
    i32x4.ge_u
    ;; Comparisons: i64
    call $func0
    i64x2.eq
    call $func0
    i64x2.ne
    call $func0
    i64x2.lt_s
    call $func0
    i64x2.gt_s
    call $func0
    i64x2.le_s
    call $func0
    i64x2.ge_s
    ;; Comparisons: f32
    call $func0
    f32x4.eq
    call $func0
    f32x4.ne
    call $func0
    f32x4.lt
    call $func0
    f32x4.gt
    call $func0
    f32x4.le
    call $func0
    f32x4.ge
    ;; Comparisons: f64
    call $func0
    f64x2.eq
    call $func0
    f64x2.ne
    call $func0
    f64x2.lt
    call $func0
    f64x2.gt
    call $func0
    f64x2.le
    call $func0
    f64x2.ge
    ;; Bitwise operations.
    v128.not
    call $func0
    v128.and
    call $func0
    v128.andnot
    call $func0
    v128.or
    call $func0
    v128.xor
    call $func0
    call $func0
    v128.bitselect
    v128.any_true
    drop
    ;; Floating-point demotion and promotions.
    call $func0
    f32x4.demote_f64x2_zero
    f64x2.promote_low_f32x4
    ;; i8 operations.
    i8x16.abs
    i8x16.neg
    i8x16.popcnt
    i8x16.all_true
    drop
    call $func0
    i8x16.bitmask
    drop
    call $func0
    call $func0
    i8x16.narrow_i16x8_s
    call $func0
    i8x16.narrow_i16x8_u
    i32.const 0
    i8x16.shl
    i32.const 0
    i8x16.shr_s
    i32.const 0
    i8x16.shr_u
    call $func0
    i8x16.add
    call $func0
    i8x16.add_sat_s
    call $func0
    i8x16.add_sat_u
    call $func0
    i8x16.sub
    call $func0
    i8x16.sub_sat_s
    call $func0
    i8x16.sub_sat_u
    call $func0
    i8x16.min_s
    call $func0
    i8x16.min_u
    call $func0
    i8x16.max_s
    call $func0
    i8x16.max_u
    call $func0
    i8x16.avgr_u
    ;; i16 operations.
    i16x8.abs
    i16x8.neg
    call $func0
    i16x8.q15mulr_sat_s
    i16x8.all_true
    drop
    call $func0
    i16x8.bitmask
    drop
    call $func0
    call $func0
    i16x8.narrow_i32x4_s
    call $func0
    i16x8.narrow_i32x4_u
    i16x8.extend_low_i8x16_s
    i16x8.extend_high_i8x16_s
    i16x8.extend_low_i8x16_u
    i16x8.extend_high_i8x16_u
    i32.const 0
    i16x8.shl
    i32.const 0
    i16x8.shr_s
    i32.const 0
    i16x8.shr_u
    call $func0
    i16x8.add
    call $func0
    i16x8.add_sat_s
    call $func0
    i16x8.add_sat_u
    call $func0
    i16x8.sub
    call $func0
    i16x8.sub_sat_s
    call $func0
    i16x8.sub_sat_u
    call $func0
    i16x8.mul
    call $func0
    i16x8.min_s
    call $func0
    i16x8.min_u
    call $func0
    i16x8.max_s
    call $func0
    i16x8.max_u
    call $func0
    i16x8.avgr_u
    ;; i32 operations.
    i32x4.abs
    i32x4.neg
    i32x4.all_true
    drop
    call $func0
    i32x4.bitmask
    drop
    call $func0
    i32x4.extend_low_i16x8_s
    i32x4.extend_high_i16x8_s
    i32x4.extend_low_i16x8_u
    i32x4.extend_high_i16x8_u
    i32.const 0
    i32x4.shl
    i32.const 0
    i32x4.shr_s
    i32.const 0
    i32x4.shr_u
    call $func0
    i32x4.add
    call $func0
    i32x4.sub
    call $func0
    i32x4.mul
    call $func0
    i32x4.min_s
    call $func0
    i32x4.min_u
    call $func0
    i32x4.max_s
    call $func0
    i32x4.max_u
    call $func0
    i32x4.dot_i16x8_s
    ;; i64 operations.
    i64x2.abs
    i64x2.neg
    i64x2.all_true
    drop
    call $func0
    i64x2.bitmask
    drop
    call $func0
    i64x2.extend_low_i32x4_s
    i64x2.extend_high_i32x4_s
    i64x2.extend_low_i32x4_u
    i64x2.extend_high_i32x4_u
    i32.const 0
    i64x2.shl
    i32.const 0
    i64x2.shr_s
    i32.const 0
    i64x2.shr_u
    call $func0
    i64x2.add
    call $func0
    i64x2.sub
    call $func0
    i64x2.mul
    ;; f32 operations.
    f32x4.ceil
    f32x4.floor
    f32x4.trunc
    f32x4.nearest
    f32x4.abs
    f32x4.neg
    f32x4.sqrt
    call $func0
    f32x4.add
    call $func0
    f32x4.sub
    call $func0
    f32x4.mul
    call $func0
    f32x4.div
    call $func0
    f32x4.min
    call $func0
    f32x4.max
    call $func0
    f32x4.pmin
    call $func0
    f32x4.pmax
    ;; f64 operations.
    f64x2.ceil
    f64x2.floor
    f64x2.trunc
    f64x2.nearest
    f64x2.abs
    f64x2.neg
    f64x2.sqrt
    call $func0
    f64x2.add
    call $func0
    f64x2.sub
    call $func0
    f64x2.mul
    call $func0
    f64x2.div
    call $func0
    f64x2.min
    call $func0
    f64x2.max
    call $func0
    f64x2.pmin
    call $func0
    f64x2.pmax
    ;; Extended integer arithmetic.
    i16x8.extadd_pairwise_i8x16_s
    i16x8.extadd_pairwise_i8x16_u
    i32x4.extadd_pairwise_i16x8_s
    i32x4.extadd_pairwise_i16x8_u
    call $func0
    i16x8.extmul_low_i8x16_s
    call $func0
    i16x8.extmul_high_i8x16_s
    call $func0
    i16x8.extmul_low_i8x16_u
    call $func0
    i16x8.extmul_high_i8x16_u
    call $func0
    i32x4.extmul_low_i16x8_s
    call $func0
    i32x4.extmul_high_i16x8_s
    call $func0
    i32x4.extmul_low_i16x8_u
    call $func0
    i32x4.extmul_high_i16x8_u
    call $func0
    i64x2.extmul_low_i32x4_s
    call $func0
    i64x2.extmul_high_i32x4_s
    call $func0
    i64x2.extmul_low_i32x4_u
    call $func0
    i64x2.extmul_high_i32x4_u
    ;; Conversions.
    i32x4.trunc_sat_f32x4_s
    i32x4.trunc_sat_f32x4_u
    f32x4.convert_i32x4_s
    f32x4.convert_i32x4_u
    i32x4.trunc_sat_f64x2_s_zero
    i32x4.trunc_sat_f64x2_u_zero
    f64x2.convert_low_i32x4_s
    f64x2.convert_low_i32x4_u
    drop
  )
)
;;)---";
                                                                                                                                                                                               node-23.7.0/deps/v8/test/unittests/wasm/wasm-disassembler-unittest-stringref.wasm.inc               0000664 0000000 0000000 00000002366 14746647661 0031005 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                          0x00, 0x61, 0x73, 0x6d,  // wasm magic
  0x01, 0x00, 0x00, 0x00,  // wasm version

  0x01,                    // section kind: Type
  0x06,                    // section length 6
  0x01, 0x4e,              // types count 1: rec. group definition
  0x01, 0x60,              // recursive group size 1:  kind: func
  0x00,                    // param count 0
  0x00,                    // return count 0

  0x03,                    // section kind: Function
  0x02,                    // section length 2
  0x01, 0x00,              // functions count 1: 0 $func0

  0x0e,                    // section kind: StringRef
  0x06,                    // section length 6
  0x00,                    // deferred string literal count 0
  0x01, 0x03,              // string literal count 1: string literal length: 3
  0x66, 0x6f, 0x6f,        // string literal: foo

  0x0a,                    // section kind: Code
  0x09,                    // section length 9
  0x01,                    // functions count 1
                           // function #0 $func0
  0x07,                    // body size 7
  0x00,                    // 0 entries in locals list
  0xfb, 0x82, 0x01, 0x00,  // string.const "foo" (;0;)
  0x1a,                    // drop
  0x0b,                    // end
                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/unittests/wasm/wasm-disassembler-unittest-stringref.wat.inc                0000664 0000000 0000000 00000000411 14746647661 0030616 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        ;; expected = R"---(;; This is a polyglot C++/WAT file.
;; Comment lines are ignored and not expected in the disassembler output.
(module
  (rec
    (type $type0 (func))
  )
  (string "foo" (;0;))
  (func $func0
    string.const "foo" (;0;)
    drop
  )
)
;;)---";
                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/unittests/wasm/wasm-disassembler-unittest-too-many-ends.wasm.inc           0000664 0000000 0000000 00000002321 14746647661 0031463 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        0x00, 0x61, 0x73, 0x6d,  // wasm magic
0x01, 0x00, 0x00, 0x00,  // wasm version

0x01,                    // section kind: Type
0x04,                    // section length 4
0x01, 0x60,              // types count 1:  kind: func
0x00,                    // param count 0
0x00,                    // return count 0

0x03,                    // section kind: Function
0x02,                    // section length 2
0x01, 0x00,              // functions count 1: 0 $doubleEnd

0x07,                    // section kind: Export
0x0d,                    // section length 13
0x01,                    // exports count 1: export # 0
0x09,                    // field name length: 9
0x64, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x45, 0x6e,
0x64,                    // field name: doubleEnd
0x00, 0x00,              // kind: function index: 0

0x0a,                    // section kind: Code
0x07,                    // section length 7
0x01,                    // functions count 1
                          // function #0 $doubleEnd
0x05,                    // body size 5
0x00,                    // 0 entries in locals list
0x01,                    // nop
0x0b,                    // end
0x0b,                    // end
0x0b,                    // end
                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/unittests/wasm/wasm-disassembler-unittest-too-many-ends.wat.inc            0000664 0000000 0000000 00000000267 14746647661 0031316 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        ;; expected = R"---(;; This is a polyglot C++/WAT file.
(module
  (func $doubleEnd (;0;) (export "doubleEnd")
    nop
  )
  ;; Unexpected end byte
  ;; Unexpected end byte
)
;;)---";
                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/unittests/wasm/wasm-disassembler-unittest.cc                               0000664 0000000 0000000 00000014250 14746647661 0025645 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <regex>
#include <string>

#include "src/base/vector.h"
#include "src/wasm/module-decoder.h"
#include "src/wasm/string-builder-multiline.h"
#include "src/wasm/wasm-disassembler-impl.h"
#include "test/unittests/test-utils.h"
#include "testing/gtest/include/gtest/gtest.h"

namespace v8 {
namespace internal {
namespace wasm {

class WasmDisassemblerTest : public ::v8::TestWithPlatform {};

// Code that is shared for all tests, the only difference is the input module
// and expected disassembler output.
void CheckDisassemblerOutput(base::Vector<const uint8_t> module_bytes,
                             std::string expected_output) {
  AccountingAllocator allocator;

  std::unique_ptr<OffsetsProvider> offsets = AllocateOffsetsProvider();
  ModuleResult module_result =
      DecodeWasmModuleForDisassembler(module_bytes, offsets.get());
  ASSERT_TRUE(module_result.ok())
      << "Decoding error: " << module_result.error().message() << " at offset "
      << module_result.error().offset();
  WasmModule* module = module_result.value().get();

  ModuleWireBytes wire_bytes(module_bytes);
  NamesProvider names(module, module_bytes);

  MultiLineStringBuilder output_sb;

  constexpr bool kNoOffsets = false;
  ModuleDisassembler md(output_sb, module, &names, wire_bytes, &allocator,
                        std::move(offsets));
  constexpr size_t max_mb = 100;  // Even 1 would be enough.
  md.PrintModule({0, 2}, max_mb);

  std::ostringstream output;
  output_sb.WriteTo(output, kNoOffsets);

  // Remove comment lines from expected output since they cannot be recovered
  // by a disassembler.
  // They were also used as part of the C++/WAT polyglot trick described below.
  std::regex comment_regex(" *;;[^\\n]*\\n?");
  expected_output = std::regex_replace(expected_output, comment_regex, "");
  std::string output_str = std::regex_replace(output.str(), comment_regex, "");

  EXPECT_EQ(expected_output, output_str);
}

TEST_F(WasmDisassemblerTest, Mvp) {
  // If you want to extend this test (and the other tests below):
  // 1. Modify the included .wat.inc file(s), e.g., add more instructions.
  // 2. Convert the Wasm text file to a Wasm binary with `wat2wasm`.
  // 3. Convert the Wasm binary to an array init expression with
  // `wami --full-hexdump` and paste it into the included file below.
  // One liner example (Linux):
  // wat2wasm wasm-disassembler-unittest-mvp.wat.inc --output=-
  // | wami --full-hexdump
  // | head -n-1 | tail -n+2 > wasm-disassembler-unittest-mvp.wasm.inc
  constexpr uint8_t module_bytes[] = {
#include "wasm-disassembler-unittest-mvp.wasm.inc"
  };

  // Little trick: polyglot C++/WebAssembly text file.
  // We want to include the expected disassembler text output as a string into
  // this test (instead of reading it from the file at runtime, which would make
  // it dependent on the current working directory).
  // At the same time, we want the included file itself to be valid WAT, such
  // that it can be processed e.g. by wat2wasm to build the module bytes above.
  // For that to work, we abuse that ;; starts a line comment in WAT, but at
  // the same time, ;; in C++ are just two empty statements, which are no
  // harm when including the file here either.
  std::string expected;
#include "wasm-disassembler-unittest-mvp.wat.inc"

  CheckDisassemblerOutput(base::ArrayVector(module_bytes), expected);
}

TEST_F(WasmDisassemblerTest, Names) {
  // You can create a binary with a custom name section from the text format via
  // `wat2wasm --debug-names`.
  constexpr uint8_t module_bytes[] = {
#include "wasm-disassembler-unittest-names.wasm.inc"
  };
  std::string expected;
#include "wasm-disassembler-unittest-names.wat.inc"
  CheckDisassemblerOutput(base::ArrayVector(module_bytes), expected);
}

TEST_F(WasmDisassemblerTest, InvalidNameSection) {
  constexpr uint8_t module_bytes[] = {
#include "wasm-disassembler-unittest-bad-name-section.wasm.inc"
  };
  std::string expected(
      "(module\n"
      "  (table $x (;0;) 0 funcref)\n"
      ")\n");
  CheckDisassemblerOutput(base::ArrayVector(module_bytes), expected);
}

TEST_F(WasmDisassemblerTest, Simd) {
  constexpr uint8_t module_bytes[] = {
#include "wasm-disassembler-unittest-simd.wasm.inc"
  };
  std::string expected;
#include "wasm-disassembler-unittest-simd.wat.inc"
  CheckDisassemblerOutput(base::ArrayVector(module_bytes), expected);
}

TEST_F(WasmDisassemblerTest, Gc) {
  // Since WABT's `wat2wasm` didn't support some GC features yet, I used
  // Binaryen's `wasm-as --enable-gc --hybrid` here to produce the binary.
  constexpr uint8_t module_bytes[] = {
#include "wasm-disassembler-unittest-gc.wasm.inc"
  };
  std::string expected;
#include "wasm-disassembler-unittest-gc.wat.inc"
  CheckDisassemblerOutput(base::ArrayVector(module_bytes), expected);
}

TEST_F(WasmDisassemblerTest, TooManyends) {
  constexpr uint8_t module_bytes[] = {
#include "wasm-disassembler-unittest-too-many-ends.wasm.inc"
  };
  std::string expected;
#include "wasm-disassembler-unittest-too-many-ends.wat.inc"
  CheckDisassemblerOutput(base::ArrayVector(module_bytes), expected);
}

TEST_F(WasmDisassemblerTest, Stringref) {
  constexpr uint8_t module_bytes[] = {
#include "wasm-disassembler-unittest-stringref.wasm.inc"
  };
  std::string expected;
#include "wasm-disassembler-unittest-stringref.wat.inc"
  CheckDisassemblerOutput(base::ArrayVector(module_bytes), expected);
}

TEST_F(WasmDisassemblerTest, Exnref) {
  constexpr uint8_t module_bytes[] = {
#include "wasm-disassembler-unittest-exnref.wasm.inc"
  };
  std::string expected;
#include "wasm-disassembler-unittest-exnref.wat.inc"
  CheckDisassemblerOutput(base::ArrayVector(module_bytes), expected);
}

// TODO(dlehmann): Add tests for the following Wasm features and extensions:
// - custom name section for Wasm GC constructs (struct and array type names,
// struct fields).
// - exception-related instructions (try, catch, catch_all, delegate) and named
// exception tags.
// - atomic instructions (threads proposal, 0xfe prefix).
// - some "numeric" instructions (0xfc prefix).

}  // namespace wasm
}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/unittests/wasm/wasm-gdbserver-unittest.cc                                  0000664 0000000 0000000 00000020003 14746647661 0025144 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <string>

#include "src/debug/wasm/gdb-server/packet.h"
#include "src/debug/wasm/gdb-server/session.h"
#include "src/debug/wasm/gdb-server/transport.h"
#include "test/unittests/test-utils.h"
#include "testing/gmock/include/gmock/gmock.h"

namespace v8 {
namespace internal {
namespace wasm {
namespace gdb_server {

using ::testing::_;
using ::testing::Return;
using ::testing::SetArrayArgument;
using ::testing::StrEq;

class WasmGdbRemoteTest : public ::testing::Test {};

TEST_F(WasmGdbRemoteTest, GdbRemotePacketAddChars) {
  Packet packet;

  // Read empty packet
  bool end_of_packet = packet.EndOfPacket();
  EXPECT_TRUE(end_of_packet);

  // Add raw chars
  packet.AddRawChar('4');
  packet.AddRawChar('2');

  std::string str;
  packet.GetString(&str);
  EXPECT_EQ("42", str);
}

TEST_F(WasmGdbRemoteTest, GdbRemotePacketAddBlock) {
  static const uint8_t block[] = {0x01, 0x02, 0x03, 0x04, 0x05,
                                  0x06, 0x07, 0x08, 0x09};
  static const size_t kLen = sizeof(block) / sizeof(uint8_t);
  Packet packet;
  packet.AddBlock(block, kLen);

  uint8_t buffer[kLen];
  bool ok = packet.GetBlock(buffer, kLen);
  EXPECT_TRUE(ok);
  EXPECT_EQ(0, memcmp(block, buffer, kLen));

  packet.Rewind();
  std::string str;
  ok = packet.GetString(&str);
  EXPECT_TRUE(ok);
  EXPECT_EQ("010203040506070809", str);
}

TEST_F(WasmGdbRemoteTest, GdbRemotePacketAddString) {
  Packet packet;
  packet.AddHexString("foobar");

  std::string str;
  bool ok = packet.GetString(&str);
  EXPECT_TRUE(ok);
  EXPECT_EQ("666f6f626172", str);

  packet.Clear();
  packet.AddHexString("GDB");
  ok = packet.GetString(&str);
  EXPECT_TRUE(ok);
  EXPECT_EQ("474442", str);
}

TEST_F(WasmGdbRemoteTest, GdbRemotePacketAddNumbers) {
  Packet packet;

  static const uint64_t u64_val = 0xdeadbeef89abcdef;
  static const uint8_t u8_val = 0x42;
  packet.AddNumberSep(u64_val, ';');
  packet.AddWord8(u8_val);

  std::string str;
  packet.GetString(&str);
  EXPECT_EQ("deadbeef89abcdef;42", str);

  packet.Rewind();
  uint64_t val = 0;
  char sep = '\0';
  bool ok = packet.GetNumberSep(&val, &sep);
  EXPECT_TRUE(ok);
  EXPECT_EQ(u64_val, val);
  uint8_t b = 0;
  ok = packet.GetWord8(&b);
  EXPECT_TRUE(ok);
  EXPECT_EQ(u8_val, b);
}

TEST_F(WasmGdbRemoteTest, GdbRemotePacketSequenceNumber) {
  Packet packet_with_sequence_num;
  packet_with_sequence_num.AddWord8(42);
  packet_with_sequence_num.AddRawChar(':');
  packet_with_sequence_num.AddHexString("foobar");

  int32_t sequence_num = 0;
  packet_with_sequence_num.ParseSequence();
  bool ok = packet_with_sequence_num.GetSequence(&sequence_num);
  EXPECT_TRUE(ok);
  EXPECT_EQ(42, sequence_num);

  Packet packet_without_sequence_num;
  packet_without_sequence_num.AddHexString("foobar");

  packet_without_sequence_num.ParseSequence();
  ok = packet_without_sequence_num.GetSequence(&sequence_num);
  EXPECT_FALSE(ok);
}

TEST_F(WasmGdbRemoteTest, GdbRemotePacketRunLengthEncoded) {
  Packet packet1;
  packet1.AddRawChar('0');
  packet1.AddRawChar('*');
  packet1.AddRawChar(' ');

  std::string str1;
  bool ok = packet1.GetHexString(&str1);
  EXPECT_TRUE(ok);
  EXPECT_EQ("0000", std::string(packet1.GetPayload()));

  Packet packet2;
  packet2.AddRawChar('1');
  packet2.AddRawChar('2');
  packet2.AddRawChar('3');
  packet2.AddRawChar('*');
  packet2.AddRawChar(' ');
  packet2.AddRawChar('a');
  packet2.AddRawChar('b');

  std::string str2;
  ok = packet2.GetHexString(&str2);
  EXPECT_TRUE(ok);
  EXPECT_EQ("123333ab", std::string(packet2.GetPayload()));
}

TEST_F(WasmGdbRemoteTest, GdbRemoteUtilStringSplit) {
  std::vector<std::string> parts1 = StringSplit({}, ",");
  EXPECT_EQ(size_t(0), parts1.size());

  auto parts2 = StringSplit("a", nullptr);
  EXPECT_EQ(size_t(1), parts2.size());
  EXPECT_EQ("a", parts2[0]);

  auto parts3 = StringSplit(";a;bc;def;", ",");
  EXPECT_EQ(size_t(1), parts3.size());
  EXPECT_EQ(";a;bc;def;", parts3[0]);

  auto parts4 = StringSplit(";a;bc;def;", ";");
  EXPECT_EQ(size_t(3), parts4.size());
  EXPECT_EQ("a", parts4[0]);
  EXPECT_EQ("bc", parts4[1]);
  EXPECT_EQ("def", parts4[2]);
}

class MockTransport : public TransportBase {
 public:
  MOCK_METHOD(bool, AcceptConnection, (), (override));
  MOCK_METHOD(bool, Read, (char*, int32_t), (override));
  MOCK_METHOD(bool, Write, (const char*, int32_t), (override));
  MOCK_METHOD(bool, IsDataAvailable, (), (const, override));
  MOCK_METHOD(void, Disconnect, (), (override));
  MOCK_METHOD(void, Close, (), (override));
  MOCK_METHOD(void, WaitForDebugStubEvent, (), (override));
  MOCK_METHOD(bool, SignalThreadEvent, (), (override));
};

TEST_F(WasmGdbRemoteTest, GdbRemoteSessionSendPacket) {
  const char* ack_buffer = "+";

  MockTransport mock_transport;
  EXPECT_CALL(mock_transport, Write(StrEq("$474442#39"), 10))
      .WillOnce(Return(true));
  EXPECT_CALL(mock_transport, Read(_, _))
      .Times(1)
      .WillOnce(
          DoAll(SetArrayArgument<0>(ack_buffer, ack_buffer + 1), Return(true)));

  Session session(&mock_transport);

  Packet packet;
  packet.AddHexString("GDB");
  bool ok = session.SendPacket(&packet);
  EXPECT_TRUE(ok);
}

TEST_F(WasmGdbRemoteTest, GdbRemoteSessionSendPacketDisconnectOnNoAck) {
  MockTransport mock_transport;
  EXPECT_CALL(mock_transport, Write(StrEq("$474442#39"), 10))
      .Times(1)
      .WillOnce(Return(true));
  EXPECT_CALL(mock_transport, Read(_, _)).Times(1).WillOnce(Return(false));
  EXPECT_CALL(mock_transport, Disconnect()).Times(1);

  Session session(&mock_transport);

  Packet packet;
  packet.AddHexString("GDB");
  bool ok = session.SendPacket(&packet);
  EXPECT_FALSE(ok);
}

TEST_F(WasmGdbRemoteTest, GdbRemoteSessionGetPacketCheckChecksum) {
  const char* buffer_bad = "$47#00";
  const char* buffer_ok = "$47#6b";

  MockTransport mock_transport;
  EXPECT_CALL(mock_transport, Read(_, _))
      .WillOnce(
          DoAll(SetArrayArgument<0>(buffer_bad, buffer_bad + 1), Return(true)))
      .WillOnce(DoAll(SetArrayArgument<0>(buffer_bad + 1, buffer_bad + 2),
                      Return(true)))
      .WillOnce(DoAll(SetArrayArgument<0>(buffer_bad + 2, buffer_bad + 3),
                      Return(true)))
      .WillOnce(DoAll(SetArrayArgument<0>(buffer_bad + 3, buffer_bad + 4),
                      Return(true)))
      .WillOnce(DoAll(SetArrayArgument<0>(buffer_bad + 4, buffer_bad + 5),
                      Return(true)))
      .WillOnce(DoAll(SetArrayArgument<0>(buffer_bad + 5, buffer_bad + 6),
                      Return(true)))
      .WillOnce(
          DoAll(SetArrayArgument<0>(buffer_ok, buffer_ok + 1), Return(true)))
      .WillOnce(DoAll(SetArrayArgument<0>(buffer_ok + 1, buffer_ok + 2),
                      Return(true)))
      .WillOnce(DoAll(SetArrayArgument<0>(buffer_ok + 2, buffer_ok + 3),
                      Return(true)))
      .WillOnce(DoAll(SetArrayArgument<0>(buffer_ok + 3, buffer_ok + 4),
                      Return(true)))
      .WillOnce(DoAll(SetArrayArgument<0>(buffer_ok + 4, buffer_ok + 5),
                      Return(true)))
      .WillOnce(DoAll(SetArrayArgument<0>(buffer_ok + 5, buffer_ok + 6),
                      Return(true)));
  EXPECT_CALL(mock_transport, Write(StrEq("-"), 1))  // Signal bad packet
      .Times(1)
      .WillOnce(Return(true));
  EXPECT_CALL(mock_transport, Write(StrEq("+"), 1))  // Signal ack
      .Times(1)
      .WillOnce(Return(true));

  Session session(&mock_transport);

  Packet packet;
  bool ok = session.GetPacket(&packet);
  EXPECT_TRUE(ok);
  char ch;
  ok = packet.GetBlock(&ch, 1);
  EXPECT_TRUE(ok);
  EXPECT_EQ('G', ch);
}

TEST_F(WasmGdbRemoteTest, GdbRemoteSessionGetPacketDisconnectOnReadFailure) {
  MockTransport mock_transport;
  EXPECT_CALL(mock_transport, Read(_, _)).Times(1).WillOnce(Return(false));
  EXPECT_CALL(mock_transport, Disconnect()).Times(1);

  Session session(&mock_transport);
  Packet packet;
  bool ok = session.GetPacket(&packet);
  EXPECT_FALSE(ok);
}

}  // namespace gdb_server
}  // namespace wasm
}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/unittests/wasm/wasm-macro-gen-unittest.cc                                  0000664 0000000 0000000 00000027115 14746647661 0025044 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "test/unittests/test-utils.h"

#include "test/common/wasm/wasm-macro-gen.h"

namespace v8 {
namespace internal {
namespace wasm {

class WasmMacroGenTest : public TestWithZone {};

#define EXPECT_SIZE(size, ...)                          \
  do {                                                  \
    uint8_t code[] = {__VA_ARGS__};                     \
    USE(code);                                          \
    EXPECT_EQ(static_cast<size_t>(size), sizeof(code)); \
  } while (false)

TEST_F(WasmMacroGenTest, Constants) {
  EXPECT_SIZE(2, WASM_ONE);
  EXPECT_SIZE(2, WASM_ZERO);

  EXPECT_SIZE(2, WASM_I32V_1(-22));
  EXPECT_SIZE(2, WASM_I32V_1(54));

  EXPECT_SIZE(2, WASM_I32V_1(1));
  EXPECT_SIZE(3, WASM_I32V_2(200));
  EXPECT_SIZE(4, WASM_I32V_3(10000));
  EXPECT_SIZE(5, WASM_I32V_4(-9828934));
  EXPECT_SIZE(6, WASM_I32V_5(-1119828934));

  EXPECT_SIZE(2, WASM_I64V_1(1));
  EXPECT_SIZE(3, WASM_I64V_2(300));
  EXPECT_SIZE(4, WASM_I64V_3(10000));
  EXPECT_SIZE(5, WASM_I64V_4(-9828934));
  EXPECT_SIZE(6, WASM_I64V_5(-1119828934));
  EXPECT_SIZE(10, WASM_I64V_9(0x123456789ABCDEF0ULL));

  EXPECT_SIZE(5, WASM_F32(1.0f));
  EXPECT_SIZE(5, WASM_F32(10000.0f));
  EXPECT_SIZE(5, WASM_F32(-9828934.0f));

  EXPECT_SIZE(9, WASM_F64(1.5));
  EXPECT_SIZE(9, WASM_F64(10200.0));
  EXPECT_SIZE(9, WASM_F64(-9818934.0));
}

TEST_F(WasmMacroGenTest, Statements) {
  EXPECT_SIZE(1, WASM_NOP);
  EXPECT_SIZE(1, WASM_END);

  EXPECT_SIZE(4, WASM_LOCAL_SET(0, WASM_ZERO));

  EXPECT_SIZE(4, WASM_GLOBAL_SET(0, WASM_ZERO));

  EXPECT_SIZE(7, WASM_STORE_MEM(MachineType::Int32(), WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(6, WASM_IF(WASM_ZERO, WASM_NOP));

  EXPECT_SIZE(8, WASM_IF_ELSE(WASM_ZERO, WASM_NOP, WASM_NOP));

  EXPECT_SIZE(5, WASM_SELECT(WASM_ZERO, WASM_NOP, WASM_NOP));

  EXPECT_SIZE(2, WASM_BR(0));
  EXPECT_SIZE(4, WASM_BR_IF(0, WASM_ZERO));

  EXPECT_SIZE(4, WASM_BLOCK(WASM_NOP));
  EXPECT_SIZE(5, WASM_BLOCK(WASM_NOP, WASM_NOP));
  EXPECT_SIZE(6, WASM_BLOCK(WASM_NOP, WASM_NOP, WASM_NOP));

  EXPECT_SIZE(5, WASM_INFINITE_LOOP);

  EXPECT_SIZE(4, WASM_LOOP(WASM_NOP));
  EXPECT_SIZE(5, WASM_LOOP(WASM_NOP, WASM_NOP));
  EXPECT_SIZE(6, WASM_LOOP(WASM_NOP, WASM_NOP, WASM_NOP));
  EXPECT_SIZE(5, WASM_LOOP(WASM_BR(0)));
  EXPECT_SIZE(7, WASM_LOOP(WASM_BR_IF(0, WASM_ZERO)));

  EXPECT_SIZE(1, WASM_RETURN0);
  EXPECT_SIZE(3, WASM_RETURN(WASM_ZERO));

  EXPECT_SIZE(1, WASM_UNREACHABLE);
}

TEST_F(WasmMacroGenTest, MacroStatements) {
  EXPECT_SIZE(11, WASM_WHILE(WASM_ZERO, WASM_NOP));
  EXPECT_SIZE(7, WASM_INC_LOCAL(0));
  EXPECT_SIZE(7, WASM_INC_LOCAL_BY(0, 3));

  EXPECT_SIZE(2, WASM_CONTINUE(0));
}

TEST_F(WasmMacroGenTest, BrTable) {
  EXPECT_SIZE(5, WASM_BR_TABLE(WASM_ZERO, 1, BR_TARGET(0)));
  EXPECT_SIZE(6, WASM_BR_TABLE(WASM_ZERO, 2, BR_TARGET(0), BR_TARGET(0)));
}

TEST_F(WasmMacroGenTest, Expressions) {
  EXPECT_SIZE(2, WASM_LOCAL_GET(0));
  EXPECT_SIZE(2, WASM_LOCAL_GET(1));
  EXPECT_SIZE(2, WASM_LOCAL_GET(12));
  EXPECT_SIZE(2, WASM_GLOBAL_GET(0));
  EXPECT_SIZE(2, WASM_GLOBAL_GET(1));
  EXPECT_SIZE(2, WASM_GLOBAL_GET(12));
  EXPECT_SIZE(5, WASM_LOAD_MEM(MachineType::Int32(), WASM_ZERO));
  EXPECT_SIZE(5, WASM_LOAD_MEM(MachineType::Float64(), WASM_ZERO));
  EXPECT_SIZE(5, WASM_LOAD_MEM(MachineType::Float32(), WASM_ZERO));

  EXPECT_SIZE(3, WASM_NOT(WASM_ZERO));

  EXPECT_SIZE(4, WASM_BRV(1, WASM_ZERO));
  EXPECT_SIZE(6, WASM_BRV_IF(1, WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(5, WASM_BLOCK(WASM_ZERO));
  EXPECT_SIZE(6, WASM_BLOCK(WASM_NOP, WASM_ZERO));
  EXPECT_SIZE(7, WASM_BLOCK(WASM_NOP, WASM_NOP, WASM_ZERO));

  EXPECT_SIZE(5, WASM_LOOP(WASM_ZERO));
  EXPECT_SIZE(6, WASM_LOOP(WASM_NOP, WASM_ZERO));
  EXPECT_SIZE(7, WASM_LOOP(WASM_NOP, WASM_NOP, WASM_ZERO));
}

TEST_F(WasmMacroGenTest, CallFunction) {
  EXPECT_SIZE(2, WASM_CALL_FUNCTION0(0));
  EXPECT_SIZE(2, WASM_CALL_FUNCTION0(1));
  EXPECT_SIZE(2, WASM_CALL_FUNCTION0(11));

  EXPECT_SIZE(4, WASM_CALL_FUNCTION(0, WASM_ZERO));
  EXPECT_SIZE(6, WASM_CALL_FUNCTION(1, WASM_ZERO, WASM_ZERO));
}

TEST_F(WasmMacroGenTest, CallIndirect) {
  EXPECT_SIZE(5, WASM_CALL_INDIRECT(0, WASM_ZERO));
  EXPECT_SIZE(5, WASM_CALL_INDIRECT(1, WASM_ZERO));
  EXPECT_SIZE(5, WASM_CALL_INDIRECT(11, WASM_ZERO));

  EXPECT_SIZE(7, WASM_CALL_INDIRECT(0, WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(9, WASM_CALL_INDIRECT(1, WASM_ZERO, WASM_ZERO, WASM_ZERO));
}

TEST_F(WasmMacroGenTest, Int32Ops) {
  EXPECT_SIZE(5, WASM_I32_ADD(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_SUB(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_MUL(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_DIVS(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_DIVU(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_REMS(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_REMU(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_AND(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_IOR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_XOR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_SHL(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_SHR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_SAR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_ROR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_ROL(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_EQ(WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(5, WASM_I32_LTS(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_LES(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_LTU(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_LEU(WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(5, WASM_I32_GTS(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_GES(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_GTU(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I32_GEU(WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(3, WASM_I32_CLZ(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I32_CTZ(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I32_POPCNT(WASM_ZERO));

  EXPECT_SIZE(3, WASM_I32_EQZ(WASM_ZERO));
}

TEST_F(WasmMacroGenTest, Int64Ops) {
  EXPECT_SIZE(5, WASM_I64_ADD(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_SUB(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_MUL(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_DIVS(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_DIVU(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_REMS(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_REMU(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_AND(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_IOR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_XOR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_SHL(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_SHR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_SAR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_ROR(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_ROL(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_EQ(WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(5, WASM_I64_LTS(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_LES(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_LTU(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_LEU(WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(5, WASM_I64_GTS(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_GES(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_GTU(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_I64_GEU(WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(3, WASM_I64_CLZ(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I64_CTZ(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I64_POPCNT(WASM_ZERO));

  EXPECT_SIZE(3, WASM_I64_EQZ(WASM_ZERO));
}

TEST_F(WasmMacroGenTest, Float32Ops) {
  EXPECT_SIZE(5, WASM_F32_ADD(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_SUB(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_MUL(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_DIV(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_MIN(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_MAX(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_COPYSIGN(WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(3, WASM_F32_ABS(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_NEG(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_CEIL(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_FLOOR(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_TRUNC(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_NEARESTINT(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_SQRT(WASM_ZERO));

  EXPECT_SIZE(5, WASM_F32_EQ(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_LT(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_LE(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_GT(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F32_GE(WASM_ZERO, WASM_ZERO));
}

TEST_F(WasmMacroGenTest, Float64Ops) {
  EXPECT_SIZE(5, WASM_F64_ADD(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_SUB(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_MUL(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_DIV(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_MIN(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_MAX(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_COPYSIGN(WASM_ZERO, WASM_ZERO));

  EXPECT_SIZE(3, WASM_F64_ABS(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_NEG(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_CEIL(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_FLOOR(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_TRUNC(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_NEARESTINT(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_SQRT(WASM_ZERO));

  EXPECT_SIZE(5, WASM_F64_EQ(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_LT(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_LE(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_GT(WASM_ZERO, WASM_ZERO));
  EXPECT_SIZE(5, WASM_F64_GE(WASM_ZERO, WASM_ZERO));
}

TEST_F(WasmMacroGenTest, Conversions) {
  EXPECT_SIZE(3, WASM_I32_SCONVERT_F32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I32_SCONVERT_F64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I32_UCONVERT_F32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I32_UCONVERT_F64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I32_CONVERT_I64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I64_SCONVERT_F32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I64_SCONVERT_F64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I64_UCONVERT_F32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I64_UCONVERT_F64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I64_SCONVERT_I32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_I64_UCONVERT_I32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_SCONVERT_I32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_UCONVERT_I32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_SCONVERT_I64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_UCONVERT_I64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_CONVERT_F64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F32_REINTERPRET_I32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_SCONVERT_I32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_UCONVERT_I32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_SCONVERT_I64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_UCONVERT_I64(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_CONVERT_F32(WASM_ZERO));
  EXPECT_SIZE(3, WASM_F64_REINTERPRET_I64(WASM_ZERO));
}

static const MachineType kMemTypes[] = {
    MachineType::Int8(),   MachineType::Uint8(),  MachineType::Int16(),
    MachineType::Uint16(), MachineType::Int32(),  MachineType::Uint32(),
    MachineType::Int64(),  MachineType::Uint64(), MachineType::Float32(),
    MachineType::Float64()};

TEST_F(WasmMacroGenTest, LoadsAndStores) {
  for (size_t i = 0; i < arraysize(kMemTypes); i++) {
    EXPECT_SIZE(5, WASM_LOAD_MEM(kMemTypes[i], WASM_ZERO));
  }
  for (size_t i = 0; i < arraysize(kMemTypes); i++) {
    EXPECT_SIZE(7, WASM_STORE_MEM(kMemTypes[i], WASM_ZERO, WASM_LOCAL_GET(0)));
  }
}

TEST_F(WasmMacroGenTest, LoadsAndStoresWithOffset) {
  for (size_t i = 0; i < arraysize(kMemTypes); i++) {
    EXPECT_SIZE(5, WASM_LOAD_MEM_OFFSET(kMemTypes[i], 11, WASM_ZERO));
  }
  for (size_t i = 0; i < arraysize(kMemTypes); i++) {
    EXPECT_SIZE(7, WASM_STORE_MEM_OFFSET(kMemTypes[i], 13, WASM_ZERO,
                                         WASM_LOCAL_GET(0)));
  }
}

#undef EXPECT_SIZE

}  // namespace wasm
}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/unittests/wasm/wasm-module-builder-unittest.cc                             0000664 0000000 0000000 00000001676 14746647661 0026111 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "test/unittests/test-utils.h"

#include "src/init/v8.h"

#include "src/objects/objects-inl.h"
#include "src/wasm/function-body-decoder.h"
#include "src/wasm/wasm-module-builder.h"

#include "test/common/wasm/test-signatures.h"

namespace v8 {
namespace internal {
namespace wasm {

class WasmModuleBuilderTest : public TestWithZone {
 protected:
  void AddLocal(WasmFunctionBuilder* f, ValueType type) {
    uint16_t index = f->AddLocal(type);
    f->EmitGetLocal(index);
  }
};

TEST_F(WasmModuleBuilderTest, Regression_647329) {
  // Test crashed with asan.
  ZoneBuffer buffer(zone());
  const size_t kSize = ZoneBuffer::kInitialSize * 3 + 4096 + 100;
  uint8_t data[kSize] = {0};
  buffer.write(data, kSize);
}

}  // namespace wasm
}  // namespace internal
}  // namespace v8
                                                                  node-23.7.0/deps/v8/test/unittests/wasm/wasm-module-sourcemap-unittest.cc                           0000664 0000000 0000000 00000024117 14746647661 0026454 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/wasm/wasm-module-sourcemap.h"
#include <memory>

#include "src/api/api.h"
#include "test/common/wasm/flag-utils.h"
#include "test/common/wasm/test-signatures.h"
#include "test/common/wasm/wasm-macro-gen.h"
#include "test/unittests/test-utils.h"
#include "testing/gmock-support.h"

namespace v8 {
namespace internal {
namespace wasm {

class WasmModuleSourceMapTest : public TestWithIsolateAndZone {};

TEST_F(WasmModuleSourceMapTest, InvalidSourceMap) {
  auto i_isolate = isolate();
  v8::Isolate* v8_isolate = reinterpret_cast<v8::Isolate*>(i_isolate);

  // Incomplete source map without "sources" entry.
  char incomplete_src_map[] =
      "{\"version\":3,\"names\":[],\"mappings\":\"6/"
      "BAGA,0DAIA,2DAIA,IAEA,+BACA,wCADA,mBAGA,4CCXA,6BACA,IACA,4BACA,gBADA,"
      "mBAIA,4BACA,QADA,mBAIA,4BACA,gBADA,mBAVA,mBAcA\"}";
  auto incomplete_src_map_str =
      v8::String::NewFromUtf8(v8_isolate, incomplete_src_map).ToLocalChecked();
  std::unique_ptr<WasmModuleSourceMap> incomplete_src_map_ptr(
      new WasmModuleSourceMap(v8_isolate, incomplete_src_map_str));
  EXPECT_FALSE(incomplete_src_map_ptr->IsValid());

  // Miswrite key "mappings" as "mapping".
  char wrong_key[] =
      "{\"version\":3,\"sources\":[\"./"
      "test.h\",\"main.cpp\"],\"names\":[],\"mapping\":\"6/"
      "BAGA,0DAIA,2DAIA,IAEA,+BACA,wCADA,mBAGA,4CCXA,6BACA,IACA,4BACA,gBADA,"
      "mBAIA,4BACA,QADA,mBAIA,4BACA,gBADA,mBAVA,mBAcA\"}";
  auto wrong_key_str =
      v8::String::NewFromUtf8(v8_isolate, wrong_key).ToLocalChecked();
  std::unique_ptr<WasmModuleSourceMap> wrong_key_ptr(
      new WasmModuleSourceMap(v8_isolate, wrong_key_str));
  EXPECT_FALSE(wrong_key_ptr->IsValid());

  // Wrong version number.
  char wrong_ver[] =
      "{\"version\":2,\"sources\":[\"./"
      "test.h\",\"main.cpp\"],\"names\":[],\"mappings\":\"6/"
      "BAGA,0DAIA,2DAIA,IAEA,+BACA,wCADA,mBAGA,4CCXA,6BACA,IACA,4BACA,gBADA,"
      "mBAIA,4BACA,QADA,mBAIA,4BACA,gBADA,mBAVA,mBAcA\"}";
  auto wrong_ver_str =
      v8::String::NewFromUtf8(v8_isolate, wrong_ver).ToLocalChecked();
  std::unique_ptr<WasmModuleSourceMap> wrong_ver_ptr(
      new WasmModuleSourceMap(v8_isolate, wrong_ver_str));
  EXPECT_FALSE(wrong_ver_ptr->IsValid());

  // Wrong type of "version" entry.
  char ver_as_arr[] =
      "{\"version\":[3],\"sources\":[\"./"
      "test.h\",\"main.cpp\"],\"names\":[],\"mappings\":\"6/"
      "BAGA,0DAIA,2DAIA,IAEA,+BACA,wCADA,mBAGA,4CCXA,6BACA,IACA,4BACA,gBADA,"
      "mBAIA,4BACA,QADA,mBAIA,4BACA,gBADA,mBAVA,mBAcA\"}";
  auto ver_as_arr_str =
      v8::String::NewFromUtf8(v8_isolate, ver_as_arr).ToLocalChecked();
  std::unique_ptr<WasmModuleSourceMap> ver_as_arr_ptr(
      new WasmModuleSourceMap(v8_isolate, ver_as_arr_str));
  EXPECT_FALSE(ver_as_arr_ptr->IsValid());

  // Wrong type of "sources" entry.
  char sources_as_str[] =
      "{\"version\":3,\"sources\":\"./"
      "test.h,main.cpp\",\"names\":[],\"mappings\":\"6/"
      "BAGA,0DAIA,2DAIA,IAEA,+BACA,wCADA,mBAGA,4CCXA,6BACA,IACA,4BACA,gBADA,"
      "mBAIA,4BACA,QADA,mBAIA,4BACA,gBADA,mBAVA,mBAcA\"}";
  auto sources_as_str_str =
      v8::String::NewFromUtf8(v8_isolate, sources_as_str).ToLocalChecked();
  std::unique_ptr<WasmModuleSourceMap> sources_as_str_ptr(
      new WasmModuleSourceMap(v8_isolate, sources_as_str_str));
  EXPECT_FALSE(sources_as_str_ptr->IsValid());

  // Invalid "mappings" entry.
  char wrong_mappings[] =
      "{\"version\":3,\"sources\":[\"./"
      "test.h\",\"main.cpp\"],\"names\":[],\"mappings\":\"6/"
      "&BAGA,0DAIA,2DAIA,IAEA,+BACA,wCADA,mBAGA,4CCXA,6BACA,IACA,4BACA,gBADA,"
      "mBAIA,4BACA,QADA,mBAIA,4BACA,gBADA,mBAVA,mBAcA\"}";
  auto wrong_mappings_str =
      v8::String::NewFromUtf8(v8_isolate, wrong_mappings).ToLocalChecked();
  std::unique_ptr<WasmModuleSourceMap> wrong_mappings_ptr(
      new WasmModuleSourceMap(v8_isolate, wrong_mappings_str));
  EXPECT_FALSE(wrong_mappings_ptr->IsValid());
}

TEST_F(WasmModuleSourceMapTest, HasSource) {
  char src_map[] =
      "{\"version\":3,\"sources\":[\"./"
      "test.h\",\"main.cpp\"],\"names\":[],\"mappings\":\"6/"
      "BAGA,0DAIA,2DAIA,IAEA,+BACA,wCADA,mBAGA,4CCXA,6BACA,IACA,4BACA,gBADA,"
      "mBAIA,4BACA,QADA,mBAIA,4BACA,gBADA,mBAVA,mBAcA\"}";
  auto i_isolate = isolate();
  v8::Isolate* v8_isolate = reinterpret_cast<v8::Isolate*>(i_isolate);
  auto src_map_str =
      v8::String::NewFromUtf8(v8_isolate, src_map).ToLocalChecked();
  std::unique_ptr<WasmModuleSourceMap> src_map_ptr(
      new WasmModuleSourceMap(v8_isolate, src_map_str));
  EXPECT_TRUE(src_map_ptr->IsValid());

  EXPECT_FALSE(src_map_ptr->HasSource(0x387, 0x3AF));
  EXPECT_FALSE(src_map_ptr->HasSource(0x3B0, 0x3B5));
  EXPECT_FALSE(src_map_ptr->HasSource(0x3B6, 0x3BC));
  EXPECT_FALSE(src_map_ptr->HasSource(0x3BD, 0x3C7));
  EXPECT_FALSE(src_map_ptr->HasSource(0x3C8, 0x3DA));
  EXPECT_TRUE(src_map_ptr->HasSource(0x3DB, 0x414));
  EXPECT_TRUE(src_map_ptr->HasSource(0x415, 0x44E));
  EXPECT_TRUE(src_map_ptr->HasSource(0x450, 0x4DC));
  EXPECT_TRUE(src_map_ptr->HasSource(0x4DE, 0x5F1));
  EXPECT_FALSE(src_map_ptr->HasSource(0x5F3, 0x437A));
  EXPECT_FALSE(src_map_ptr->HasSource(0x437C, 0x5507));
  EXPECT_FALSE(src_map_ptr->HasSource(0x5508, 0x5557));
  EXPECT_FALSE(src_map_ptr->HasSource(0x5559, 0x5609));
  EXPECT_FALSE(src_map_ptr->HasSource(0x560A, 0x563D));
  EXPECT_FALSE(src_map_ptr->HasSource(0x563E, 0x564A));
  EXPECT_FALSE(src_map_ptr->HasSource(0x564B, 0x5656));
  EXPECT_FALSE(src_map_ptr->HasSource(0x5658, 0x5713));
  EXPECT_FALSE(src_map_ptr->HasSource(0x5715, 0x59B0));
  EXPECT_FALSE(src_map_ptr->HasSource(0x59B1, 0x59BC));
  EXPECT_FALSE(src_map_ptr->HasSource(0x59BD, 0x59C6));
  EXPECT_FALSE(src_map_ptr->HasSource(0x59C7, 0x59D8));
  EXPECT_FALSE(src_map_ptr->HasSource(0x59D9, 0x59E7));
  EXPECT_FALSE(src_map_ptr->HasSource(0x59E9, 0x5B50));
  EXPECT_FALSE(src_map_ptr->HasSource(0x5B52, 0x5C53));
  EXPECT_FALSE(src_map_ptr->HasSource(0x5C54, 0x5C57));
  EXPECT_FALSE(src_map_ptr->HasSource(0x5C59, 0x5EBD));
  EXPECT_FALSE(src_map_ptr->HasSource(0x5EBF, 0x6030));
  EXPECT_FALSE(src_map_ptr->HasSource(0x6031, 0x608D));
  EXPECT_FALSE(src_map_ptr->HasSource(0x608E, 0x609E));
  EXPECT_FALSE(src_map_ptr->HasSource(0x609F, 0x60B3));
  EXPECT_FALSE(src_map_ptr->HasSource(0x60B4, 0x60BD));
}

TEST_F(WasmModuleSourceMapTest, HasValidEntry) {
  char src_map[] =
      "{\"version\":3,\"sources\":[\"./"
      "test.h\",\"main.cpp\"],\"names\":[],\"mappings\":\"6/"
      "BAGA,0DAIA,2DAIA,IAEA,+BACA,wCADA,mBAGA,4CCXA,6BACA,IACA,4BACA,gBADA,"
      "mBAIA,4BACA,QADA,mBAIA,4BACA,gBADA,mBAVA,mBAcA\"}";
  auto i_isolate = isolate();
  v8::Isolate* v8_isolate = reinterpret_cast<v8::Isolate*>(i_isolate);
  auto src_map_str =
      v8::String::NewFromUtf8(v8_isolate, src_map).ToLocalChecked();
  std::unique_ptr<WasmModuleSourceMap> src_map_ptr(
      new WasmModuleSourceMap(v8_isolate, src_map_str));
  EXPECT_TRUE(src_map_ptr->IsValid());

  EXPECT_FALSE(src_map_ptr->HasValidEntry(0x450, 0x467));
  EXPECT_FALSE(src_map_ptr->HasValidEntry(0x450, 0x450));
  EXPECT_TRUE(src_map_ptr->HasValidEntry(0x450, 0x47A));
  EXPECT_TRUE(src_map_ptr->HasValidEntry(0x450, 0x4A9));
  EXPECT_FALSE(src_map_ptr->HasValidEntry(0x4DE, 0x4F5));
  EXPECT_TRUE(src_map_ptr->HasValidEntry(0x4DE, 0x541));
  EXPECT_TRUE(src_map_ptr->HasValidEntry(0x4DE, 0x57D));
  EXPECT_TRUE(src_map_ptr->HasValidEntry(0x4DE, 0x5B7));
  EXPECT_FALSE(src_map_ptr->HasValidEntry(0x4DE, 0x4DE));
  EXPECT_TRUE(src_map_ptr->HasValidEntry(0x4DE, 0x500));
  EXPECT_TRUE(src_map_ptr->HasValidEntry(0x4DE, 0x521));
  EXPECT_TRUE(src_map_ptr->HasValidEntry(0x4DE, 0x560));
  EXPECT_TRUE(src_map_ptr->HasValidEntry(0x4DE, 0x597));
}

TEST_F(WasmModuleSourceMapTest, GetFilename) {
  char src_map[] =
      "{\"version\":3,\"sources\":[\"./"
      "test.h\",\"main.cpp\"],\"names\":[],\"mappings\":\"6/"
      "BAGA,0DAIA,2DAIA,IAEA,+BACA,wCADA,mBAGA,4CCXA,6BACA,IACA,4BACA,gBADA,"
      "mBAIA,4BACA,QADA,mBAIA,4BACA,gBADA,mBAVA,mBAcA\"}";
  auto i_isolate = isolate();
  v8::Isolate* v8_isolate = reinterpret_cast<v8::Isolate*>(i_isolate);
  auto src_map_str =
      v8::String::NewFromUtf8(v8_isolate, src_map).ToLocalChecked();
  std::unique_ptr<WasmModuleSourceMap> src_map_ptr(
      new WasmModuleSourceMap(v8_isolate, src_map_str));
  EXPECT_TRUE(src_map_ptr->IsValid());

  EXPECT_STREQ("./test.h", src_map_ptr->GetFilename(0x47A).c_str());
  EXPECT_STREQ("./test.h", src_map_ptr->GetFilename(0x4A9).c_str());
  EXPECT_STREQ("main.cpp", src_map_ptr->GetFilename(0x500).c_str());
  EXPECT_STREQ("main.cpp", src_map_ptr->GetFilename(0x521).c_str());
  EXPECT_STREQ("main.cpp", src_map_ptr->GetFilename(0x541).c_str());
  EXPECT_STREQ("main.cpp", src_map_ptr->GetFilename(0x560).c_str());
  EXPECT_STREQ("main.cpp", src_map_ptr->GetFilename(0x57D).c_str());
  EXPECT_STREQ("main.cpp", src_map_ptr->GetFilename(0x597).c_str());
  EXPECT_STREQ("main.cpp", src_map_ptr->GetFilename(0x5B7).c_str());
}

TEST_F(WasmModuleSourceMapTest, SourceLine) {
  char src_map[] =
      "{\"version\":3,\"sources\":[\"./"
      "test.h\",\"main.cpp\"],\"names\":[],\"mappings\":\"6/"
      "BAGA,0DAIA,2DAIA,IAEA,+BACA,wCADA,mBAGA,4CCXA,6BACA,IACA,4BACA,gBADA,"
      "mBAIA,4BACA,QADA,mBAIA,4BACA,gBADA,mBAVA,mBAcA\"}";
  auto i_isolate = isolate();
  v8::Isolate* v8_isolate = reinterpret_cast<v8::Isolate*>(i_isolate);
  auto src_map_str =
      v8::String::NewFromUtf8(v8_isolate, src_map).ToLocalChecked();
  std::unique_ptr<WasmModuleSourceMap> src_map_ptr(
      new WasmModuleSourceMap(v8_isolate, src_map_str));
  EXPECT_TRUE(src_map_ptr->IsValid());

  EXPECT_EQ(13ul, src_map_ptr->GetSourceLine(0x47A));
  EXPECT_EQ(14ul, src_map_ptr->GetSourceLine(0x4A9));
  EXPECT_EQ(5ul, src_map_ptr->GetSourceLine(0x500));
  EXPECT_EQ(7ul, src_map_ptr->GetSourceLine(0x521));
  EXPECT_EQ(8ul, src_map_ptr->GetSourceLine(0x541));
  EXPECT_EQ(11ul, src_map_ptr->GetSourceLine(0x560));
  EXPECT_EQ(12ul, src_map_ptr->GetSourceLine(0x57D));
  EXPECT_EQ(15ul, src_map_ptr->GetSourceLine(0x597));
  EXPECT_EQ(16ul, src_map_ptr->GetSourceLine(0x5B7));
}
}  // namespace wasm
}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/unittests/zone/                                                            0000775 0000000 0000000 00000000000 14746647661 0020041 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/test/unittests/zone/zone-allocator-unittest.cc                                  0000664 0000000 0000000 00000007761 14746647661 0025171 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/zone/zone-allocator.h"

#include <list>
#include <vector>

#include "test/unittests/test-utils.h"
#include "testing/gtest/include/gtest/gtest.h"

namespace v8 {
namespace internal {

template <template <typename T> typename Allocator>
void TestWithStdContainers() {
  AccountingAllocator accounting_allocator;
  Zone zone(&accounting_allocator, ZONE_NAME);
  Allocator<int> zone_allocator(&zone);

  // Vector does not require allocator rebinding, list and set do.
  {
    std::vector<int, Allocator<int>> v(10, zone_allocator);
    for (int i = 1; i <= 100; ++i) v.push_back(i);
    int sum_of_v = 0;
    for (int i : v) sum_of_v += i;
    CHECK_EQ(5050, sum_of_v);
  }

  {
    std::list<int, Allocator<int>> l(zone_allocator);
    for (int i = 1; i <= 100; ++i) l.push_back(i);
    int sum_of_l = 0;
    for (int i : l) sum_of_l += i;
    CHECK_EQ(5050, sum_of_l);
  }

  {
    std::set<int, std::less<int>, Allocator<int>> s(zone_allocator);
    for (int i = 1; i <= 100; ++i) s.insert(i);
    int sum_of_s = 0;
    for (int i : s) sum_of_s += i;
    CHECK_EQ(5050, sum_of_s);
  }
}

using ZoneAllocatorTest = TestWithPlatform;

TEST_F(ZoneAllocatorTest, UseWithStdContainers) {
  TestWithStdContainers<ZoneAllocator>();
}

using RecyclingZoneAllocatorTest = TestWithPlatform;

TEST_F(RecyclingZoneAllocatorTest, ReuseSameSize) {
  AccountingAllocator accounting_allocator;
  Zone zone(&accounting_allocator, ZONE_NAME);
  RecyclingZoneAllocator<int> zone_allocator(&zone);

  int* allocated = zone_allocator.allocate(10);
  zone_allocator.deallocate(allocated, 10);
  CHECK_EQ(zone_allocator.allocate(10), allocated);
}

TEST_F(RecyclingZoneAllocatorTest, ReuseSmallerSize) {
  AccountingAllocator accounting_allocator;
  Zone zone(&accounting_allocator, ZONE_NAME);
  RecyclingZoneAllocator<int> zone_allocator(&zone);

  int* allocated = zone_allocator.allocate(100);
  zone_allocator.deallocate(allocated, 100);
  CHECK_EQ(zone_allocator.allocate(10), allocated);
}

TEST_F(RecyclingZoneAllocatorTest, DontReuseTooSmallSize) {
  AccountingAllocator accounting_allocator;
  Zone zone(&accounting_allocator, ZONE_NAME);
  RecyclingZoneAllocator<int> zone_allocator(&zone);

  // The sizeof(FreeBlock) will be larger than a single int, so we can't keep
  // store the free list in the deallocated block.
  int* allocated = zone_allocator.allocate(1);
  zone_allocator.deallocate(allocated, 1);
  CHECK_NE(zone_allocator.allocate(1), allocated);
}

TEST_F(RecyclingZoneAllocatorTest, ReuseMultipleSize) {
  AccountingAllocator accounting_allocator;
  Zone zone(&accounting_allocator, ZONE_NAME);
  RecyclingZoneAllocator<int> zone_allocator(&zone);

  int* allocated1 = zone_allocator.allocate(10);
  int* allocated2 = zone_allocator.allocate(20);
  int* allocated3 = zone_allocator.allocate(30);
  zone_allocator.deallocate(allocated1, 10);
  zone_allocator.deallocate(allocated2, 20);
  zone_allocator.deallocate(allocated3, 30);
  CHECK_EQ(zone_allocator.allocate(10), allocated3);
  CHECK_EQ(zone_allocator.allocate(10), allocated2);
  CHECK_EQ(zone_allocator.allocate(10), allocated1);
}

TEST_F(RecyclingZoneAllocatorTest, DontChainSmallerSizes) {
  AccountingAllocator accounting_allocator;
  Zone zone(&accounting_allocator, ZONE_NAME);
  RecyclingZoneAllocator<int> zone_allocator(&zone);

  int* allocated1 = zone_allocator.allocate(10);
  int* allocated2 = zone_allocator.allocate(5);
  int* allocated3 = zone_allocator.allocate(10);
  zone_allocator.deallocate(allocated1, 10);
  zone_allocator.deallocate(allocated2, 5);
  zone_allocator.deallocate(allocated3, 10);
  CHECK_EQ(zone_allocator.allocate(5), allocated3);
  CHECK_EQ(zone_allocator.allocate(5), allocated1);
  CHECK_NE(zone_allocator.allocate(5), allocated2);
}

TEST_F(RecyclingZoneAllocatorTest, UseWithStdContainers) {
  TestWithStdContainers<RecyclingZoneAllocator>();
}

}  // namespace internal
}  // namespace v8
               node-23.7.0/deps/v8/test/unittests/zone/zone-chunk-list-unittest.cc                                 0000664 0000000 0000000 00000025020 14746647661 0025256 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/zone/zone-chunk-list.h"

#include "src/zone/accounting-allocator.h"
#include "src/zone/zone.h"
#include "test/unittests/test-utils.h"
#include "testing/gtest/include/gtest/gtest.h"

namespace v8 {
namespace internal {

const size_t kItemCount = size_t(1) << 10;

class ZoneChunkListTest : public TestWithPlatform {};

TEST_F(ZoneChunkListTest, ForwardIterationTest) {
  AccountingAllocator allocator;
  Zone zone(&allocator, ZONE_NAME);

  ZoneChunkList<uintptr_t> zone_chunk_list(&zone);
  EXPECT_EQ(zone_chunk_list.begin(), zone_chunk_list.end());

  for (size_t i = 0; i < kItemCount; ++i) {
    zone_chunk_list.push_back(static_cast<uintptr_t>(i));
  }
  EXPECT_NE(zone_chunk_list.begin(), zone_chunk_list.end());

  size_t count = 0;

  for (uintptr_t item : zone_chunk_list) {
    EXPECT_EQ(static_cast<size_t>(item), count);
    count++;
  }

  EXPECT_EQ(count, kItemCount);
}

TEST_F(ZoneChunkListTest, ReverseIterationTest) {
  AccountingAllocator allocator;
  Zone zone(&allocator, ZONE_NAME);

  ZoneChunkList<uintptr_t> zone_chunk_list(&zone);
  EXPECT_EQ(zone_chunk_list.rbegin(), zone_chunk_list.rend());

  for (size_t i = 0; i < kItemCount; ++i) {
    zone_chunk_list.push_back(static_cast<uintptr_t>(i));
  }
  EXPECT_NE(zone_chunk_list.rbegin(), zone_chunk_list.rend());

  size_t count = 0;

  for (auto it = zone_chunk_list.rbegin(); it != zone_chunk_list.rend(); ++it) {
    EXPECT_EQ(static_cast<size_t>(*it), kItemCount - count - 1);
    count++;
  }

  EXPECT_EQ(count, kItemCount);
}

TEST_F(ZoneChunkListTest, PushFrontTest) {
  AccountingAllocator allocator;
  Zone zone(&allocator, ZONE_NAME);

  ZoneChunkList<uintptr_t> zone_chunk_list(&zone);

  for (size_t i = 0; i < kItemCount; ++i) {
    zone_chunk_list.push_front(static_cast<uintptr_t>(i));
  }

  size_t count = 0;

  for (uintptr_t item : zone_chunk_list) {
    EXPECT_EQ(static_cast<size_t>(item), kItemCount - count - 1);
    count++;
  }

  EXPECT_EQ(count, kItemCount);
}

TEST_F(ZoneChunkListTest, RewindTest) {
  AccountingAllocator allocator;
  Zone zone(&allocator, ZONE_NAME);

  ZoneChunkList<uintptr_t> zone_chunk_list(&zone);

  for (size_t i = 0; i < kItemCount; ++i) {
    zone_chunk_list.push_back(static_cast<uintptr_t>(i));
  }

  zone_chunk_list.Rewind(42);

  size_t count = 0;

  for (uintptr_t item : zone_chunk_list) {
    EXPECT_EQ(static_cast<size_t>(item), count);
    count++;
  }

  EXPECT_EQ(count, 42u);
  EXPECT_EQ(count, zone_chunk_list.size());

  zone_chunk_list.Rewind(0);

  count = 0;

  for (uintptr_t item : zone_chunk_list) {
    USE(item);
    count++;
  }

  EXPECT_EQ(count, 0u);
  EXPECT_EQ(count, zone_chunk_list.size());

  zone_chunk_list.Rewind(100);

  count = 0;

  for (uintptr_t item : zone_chunk_list) {
    EXPECT_EQ(static_cast<size_t>(item), count);
    count++;
  }

  EXPECT_EQ(count, 0u);
  EXPECT_EQ(count, zone_chunk_list.size());
}

TEST_F(ZoneChunkListTest, FindTest) {
  AccountingAllocator allocator;
  Zone zone(&allocator, ZONE_NAME);

  ZoneChunkList<uintptr_t> zone_chunk_list(&zone);

  for (size_t i = 0; i < kItemCount; ++i) {
    zone_chunk_list.push_back(static_cast<uintptr_t>(i));
  }

  const size_t index = kItemCount / 2 + 42;

  EXPECT_EQ(*zone_chunk_list.Find(index), static_cast<uintptr_t>(index));

  *zone_chunk_list.Find(index) = 42;

  EXPECT_EQ(*zone_chunk_list.Find(index), 42u);
}

TEST_F(ZoneChunkListTest, CopyToTest) {
  AccountingAllocator allocator;
  Zone zone(&allocator, ZONE_NAME);

  ZoneChunkList<uintptr_t> zone_chunk_list(&zone);

  for (size_t i = 0; i < kItemCount; ++i) {
    zone_chunk_list.push_back(static_cast<uintptr_t>(i));
  }

  uintptr_t* array = zone.AllocateArray<uintptr_t>(kItemCount);

  zone_chunk_list.CopyTo(array);

  for (size_t i = 0; i < kItemCount; ++i) {
    EXPECT_EQ(array[i], static_cast<uintptr_t>(i));
  }
}

TEST_F(ZoneChunkListTest, SmallCopyToTest) {
  AccountingAllocator allocator;
  Zone zone(&allocator, ZONE_NAME);

  ZoneChunkList<uint8_t> zone_chunk_list(&zone);

  for (size_t i = 0; i < kItemCount; ++i) {
    zone_chunk_list.push_back(static_cast<uint8_t>(i & 0xFF));
  }

  uint8_t* array = zone.AllocateArray<uint8_t>(kItemCount);

  zone_chunk_list.CopyTo(array);

  for (size_t i = 0; i < kItemCount; ++i) {
    EXPECT_EQ(array[i], static_cast<uint8_t>(i & 0xFF));
  }
}

struct Fubar {
  size_t a_;
  size_t b_;
};

TEST_F(ZoneChunkListTest, BigCopyToTest) {
  AccountingAllocator allocator;
  Zone zone(&allocator, ZONE_NAME);

  ZoneChunkList<Fubar> zone_chunk_list(&zone);

  for (size_t i = 0; i < kItemCount; ++i) {
    zone_chunk_list.push_back({i, i + 5});
  }

  Fubar* array = zone.AllocateArray<Fubar>(kItemCount);

  zone_chunk_list.CopyTo(array);

  for (size_t i = 0; i < kItemCount; ++i) {
    EXPECT_EQ(array[i].a_, i);
    EXPECT_EQ(array[i].b_, i + 5);
  }
}

void TestForwardIterationOfConstList(
    const ZoneChunkList<uintptr_t>& zone_chunk_list) {
  size_t count = 0;

  for (uintptr_t item : zone_chunk_list) {
    EXPECT_EQ(static_cast<size_t>(item), count);
    count++;
  }

  EXPECT_EQ(count, kItemCount);
}

TEST_F(ZoneChunkListTest, ConstForwardIterationTest) {
  AccountingAllocator allocator;
  Zone zone(&allocator, ZONE_NAME);

  ZoneChunkList<uintptr_t> zone_chunk_list(&zone);

  for (size_t i = 0; i < kItemCount; ++i) {
    zone_chunk_list.push_back(static_cast<uintptr_t>(i));
  }

  TestForwardIterationOfConstList(zone_chunk_list);
}

TEST_F(ZoneChunkListTest, RewindAndIterate) {
  // Regression test for https://bugs.chromium.org/p/v8/issues/detail?id=7478
  AccountingAllocator allocator;
  Zone zone(&allocator, ZONE_NAME);

  ZoneChunkList<int> zone_chunk_list(&zone);

  // Fill the list enough so that it will contain 2 chunks.
  int chunk_size = static_cast<int>(ZoneChunkList<int>::kInitialChunkCapacity);
  for (int i = 0; i < chunk_size + 1; ++i) {
    zone_chunk_list.push_back(i);
  }

  // Rewind and fill the first chunk again.
  zone_chunk_list.Rewind();
  for (int i = 0; i < chunk_size; ++i) {
    zone_chunk_list.push_back(i);
  }

  std::vector<int> expected;
  for (int i = 0; i < chunk_size; ++i) {
    expected.push_back(i);
  }
  std::vector<int> got;

  // Iterate. This used to not yield the expected result, since the end iterator
  // was in a weird state, and the running iterator didn't reach it after the
  // first chunk.
  auto it = zone_chunk_list.begin();
  while (it != zone_chunk_list.end()) {
    int value = *it;
    got.push_back(value);
    ++it;
  }
  CHECK_EQ(expected.size(), got.size());
  for (size_t i = 0; i < expected.size(); ++i) {
    CHECK_EQ(expected[i], got[i]);
  }
}

TEST_F(ZoneChunkListTest, AdvanceZeroTest) {
  AccountingAllocator allocator;
  Zone zone(&allocator, ZONE_NAME);

  ZoneChunkList<uintptr_t> zone_chunk_list(&zone);

  for (size_t i = 0; i < kItemCount; ++i) {
    zone_chunk_list.push_back(static_cast<uintptr_t>(i));
  }

  auto iterator_advance = zone_chunk_list.begin();

  iterator_advance.Advance(0);

  CHECK_EQ(iterator_advance, zone_chunk_list.begin());
}

TEST_F(ZoneChunkListTest, AdvancePartwayTest) {
  AccountingAllocator allocator;
  Zone zone(&allocator, ZONE_NAME);

  ZoneChunkList<uintptr_t> zone_chunk_list(&zone);

  for (size_t i = 0; i < kItemCount; ++i) {
    zone_chunk_list.push_back(static_cast<uintptr_t>(i));
  }

  auto iterator_advance = zone_chunk_list.begin();
  auto iterator_one_by_one = zone_chunk_list.begin();

  iterator_advance.Advance(kItemCount / 2);
  for (size_t i = 0; i < kItemCount / 2; ++i) {
    ++iterator_one_by_one;
  }

  CHECK_EQ(iterator_advance, iterator_one_by_one);
}

TEST_F(ZoneChunkListTest, AdvanceEndTest) {
  AccountingAllocator allocator;
  Zone zone(&allocator, ZONE_NAME);

  ZoneChunkList<uintptr_t> zone_chunk_list(&zone);

  for (size_t i = 0; i < kItemCount; ++i) {
    zone_chunk_list.push_back(static_cast<uintptr_t>(i));
  }

  auto iterator_advance = zone_chunk_list.begin();

  iterator_advance.Advance(kItemCount);

  CHECK_EQ(iterator_advance, zone_chunk_list.end());
}

TEST_F(ZoneChunkListTest, FindOverChunkBoundary) {
  AccountingAllocator allocator;
  Zone zone(&allocator, ZONE_NAME);

  ZoneChunkList<int> zone_chunk_list(&zone);

  // Make sure we get two chunks.
  int chunk_size = static_cast<int>(ZoneChunkList<int>::kInitialChunkCapacity);
  for (int i = 0; i < chunk_size + 1; ++i) {
    zone_chunk_list.push_back(i);
  }

  for (int i = 0; i < chunk_size + 1; ++i) {
    CHECK_EQ(i, *zone_chunk_list.Find(i));
  }
}

TEST_F(ZoneChunkListTest, SplitAt) {
  AccountingAllocator allocator;
  Zone zone(&allocator, ZONE_NAME);

  ZoneChunkList<size_t> zone_chunk_list(&zone);

  // Make sure we get two chunks.
  for (size_t i = 0; i < kItemCount + 1; ++i) {
    zone_chunk_list.push_back(i);
  }

  ZoneChunkList<size_t> split_end =
      zone_chunk_list.SplitAt(zone_chunk_list.end());

  CHECK(split_end.empty());
  size_t count = 0;
  for (size_t item : zone_chunk_list) {
    CHECK_EQ(item, count);
    count++;
  }
  CHECK_EQ(count, kItemCount + 1);

  ZoneChunkList<size_t> split_begin =
      zone_chunk_list.SplitAt(zone_chunk_list.begin());

  CHECK(zone_chunk_list.empty());
  count = 0;
  for (size_t item : split_begin) {
    CHECK_EQ(item, count);
    count++;
  }
  CHECK_EQ(count, kItemCount + 1);

  size_t mid = kItemCount / 2 + 42;
  ZoneChunkList<size_t> split_mid = split_begin.SplitAt(split_begin.Find(mid));

  count = 0;
  for (size_t item : split_begin) {
    CHECK_EQ(item, count);
    count++;
  }
  CHECK_EQ(count, kItemCount / 2 + 42);
  for (size_t item : split_mid) {
    CHECK_EQ(item, count);
    count++;
  }
  CHECK_EQ(count, kItemCount + 1);
}

TEST_F(ZoneChunkListTest, SplitAtLastChunk) {
  AccountingAllocator allocator;
  Zone zone(&allocator, ZONE_NAME);

  ZoneChunkList<size_t> zone_chunk_list(&zone);
  zone_chunk_list.push_back(0);
  zone_chunk_list.push_back(1);

  ZoneChunkList<size_t> split_last =
      zone_chunk_list.SplitAt(++zone_chunk_list.begin());
  CHECK_EQ(zone_chunk_list.size(), 1);
  CHECK_EQ(zone_chunk_list.front(), 0);
  CHECK_EQ(split_last.size(), 1);
  CHECK_EQ(split_last.front(), 1);
}

TEST_F(ZoneChunkListTest, Append) {
  AccountingAllocator allocator;
  Zone zone(&allocator, ZONE_NAME);

  ZoneChunkList<size_t> zone_chunk_list(&zone);
  zone_chunk_list.push_back(0);

  ZoneChunkList<size_t> other(&zone);
  other.push_back(1);

  zone_chunk_list.Append(other);

  size_t count = 0;
  for (size_t item : zone_chunk_list) {
    CHECK_EQ(item, count++);
  }
  CHECK_EQ(count, zone_chunk_list.size());
  CHECK(other.empty());
}

}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/unittests/zone/zone-compact-set-unittest.cc                                0000664 0000000 0000000 00000016554 14746647661 0025430 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/zone/zone-compact-set.h"

#include "src/zone/zone.h"
#include "test/unittests/test-utils.h"
#include "testing/gtest/include/gtest/gtest.h"

namespace v8 {
namespace internal {

struct HandleLike {
  int* ptr;
};

bool operator==(HandleLike lhs, HandleLike rhs) { return lhs.ptr == rhs.ptr; }

template <>
struct ZoneCompactSetTraits<HandleLike> {
  using handle_type = HandleLike;
  using data_type = int;

  static data_type* HandleToPointer(handle_type handle) { return handle.ptr; }
  static handle_type PointerToHandle(data_type* ptr) { return HandleLike{ptr}; }
};

class ZoneCompactSetTest : public TestWithZone {
 public:
  HandleLike NewHandleLike(int value) {
    return HandleLike{zone()->New<int>(value)};
  }
};

TEST_F(ZoneCompactSetTest, Empty) {
  ZoneCompactSet<HandleLike> zone_compact_set;

  EXPECT_EQ(zone_compact_set.size(), 0u);
  EXPECT_TRUE(zone_compact_set.is_empty());
}

TEST_F(ZoneCompactSetTest, SingleValue) {
  ZoneCompactSet<HandleLike> zone_compact_set;

  HandleLike handle = NewHandleLike(5);
  zone_compact_set.insert(handle, zone());

  EXPECT_EQ(zone_compact_set.size(), 1u);
  EXPECT_FALSE(zone_compact_set.is_empty());
  EXPECT_EQ(zone_compact_set.at(0), handle);
  EXPECT_TRUE(zone_compact_set.contains(handle));
}

TEST_F(ZoneCompactSetTest, MultipleValue) {
  ZoneCompactSet<HandleLike> zone_compact_set;

  HandleLike handle1 = NewHandleLike(5);
  HandleLike handle2 = NewHandleLike(8);
  HandleLike handle3 = NewHandleLike(2);
  HandleLike handle4 = NewHandleLike(1);

  zone_compact_set.insert(handle1, zone());
  zone_compact_set.insert(handle2, zone());
  zone_compact_set.insert(handle3, zone());
  zone_compact_set.insert(handle4, zone());

  EXPECT_EQ(zone_compact_set.size(), 4u);
  EXPECT_FALSE(zone_compact_set.is_empty());

  EXPECT_TRUE(zone_compact_set.contains(handle1));
  EXPECT_TRUE(zone_compact_set.contains(handle2));
  EXPECT_TRUE(zone_compact_set.contains(handle3));
  EXPECT_TRUE(zone_compact_set.contains(handle4));
}

TEST_F(ZoneCompactSetTest, DuplicateValue) {
  ZoneCompactSet<HandleLike> zone_compact_set;

  HandleLike handle1 = NewHandleLike(5);
  HandleLike handle2 = NewHandleLike(8);

  zone_compact_set.insert(handle1, zone());
  zone_compact_set.insert(handle1, zone());
  zone_compact_set.insert(handle2, zone());
  zone_compact_set.insert(handle2, zone());

  EXPECT_EQ(zone_compact_set.size(), 2u);
  EXPECT_FALSE(zone_compact_set.is_empty());

  EXPECT_TRUE(zone_compact_set.contains(handle1));
  EXPECT_TRUE(zone_compact_set.contains(handle2));
}

TEST_F(ZoneCompactSetTest, RemoveSingleValue) {
  ZoneCompactSet<HandleLike> zone_compact_set;

  HandleLike handle1 = NewHandleLike(5);

  zone_compact_set.insert(handle1, zone());

  EXPECT_EQ(zone_compact_set.size(), 1u);

  zone_compact_set.remove(handle1, zone());

  EXPECT_EQ(zone_compact_set.size(), 0u);
  EXPECT_TRUE(zone_compact_set.is_empty());

  EXPECT_FALSE(zone_compact_set.contains(handle1));
}

TEST_F(ZoneCompactSetTest, RemoveFromMultipleValue) {
  ZoneCompactSet<HandleLike> zone_compact_set;

  HandleLike handle1 = NewHandleLike(5);
  HandleLike handle2 = NewHandleLike(8);

  zone_compact_set.insert(handle1, zone());
  zone_compact_set.insert(handle2, zone());

  EXPECT_EQ(zone_compact_set.size(), 2u);

  zone_compact_set.remove(handle1, zone());

  EXPECT_EQ(zone_compact_set.size(), 1u);
  EXPECT_FALSE(zone_compact_set.is_empty());

  EXPECT_FALSE(zone_compact_set.contains(handle1));
  EXPECT_TRUE(zone_compact_set.contains(handle2));
}

TEST_F(ZoneCompactSetTest, RemoveFromEvenMoreMultipleValue) {
  ZoneCompactSet<HandleLike> zone_compact_set;

  HandleLike handle1 = NewHandleLike(5);
  HandleLike handle2 = NewHandleLike(8);
  HandleLike handle3 = NewHandleLike(1);
  HandleLike handle4 = NewHandleLike(2);

  zone_compact_set.insert(handle1, zone());
  zone_compact_set.insert(handle2, zone());
  zone_compact_set.insert(handle3, zone());
  zone_compact_set.insert(handle4, zone());

  EXPECT_EQ(zone_compact_set.size(), 4u);

  zone_compact_set.remove(handle2, zone());

  EXPECT_EQ(zone_compact_set.size(), 3u);
  EXPECT_FALSE(zone_compact_set.is_empty());

  EXPECT_TRUE(zone_compact_set.contains(handle1));
  EXPECT_FALSE(zone_compact_set.contains(handle2));
  EXPECT_TRUE(zone_compact_set.contains(handle3));
  EXPECT_TRUE(zone_compact_set.contains(handle4));
}

TEST_F(ZoneCompactSetTest, RemoveNonExistent) {
  ZoneCompactSet<HandleLike> zone_compact_set;

  HandleLike handle1 = NewHandleLike(5);
  HandleLike handle2 = NewHandleLike(8);
  HandleLike handle3 = NewHandleLike(1);

  zone_compact_set.insert(handle1, zone());
  zone_compact_set.insert(handle2, zone());

  zone_compact_set.remove(handle3, zone());

  EXPECT_EQ(zone_compact_set.size(), 2u);
  EXPECT_FALSE(zone_compact_set.is_empty());

  EXPECT_TRUE(zone_compact_set.contains(handle1));
  EXPECT_TRUE(zone_compact_set.contains(handle2));
  EXPECT_FALSE(zone_compact_set.contains(handle3));
}

TEST_F(ZoneCompactSetTest, ContainsEmptySubset) {
  ZoneCompactSet<HandleLike> zone_compact_set;
  ZoneCompactSet<HandleLike> zone_compact_subset;

  HandleLike handle1 = NewHandleLike(5);
  HandleLike handle2 = NewHandleLike(8);

  zone_compact_set.insert(handle1, zone());
  zone_compact_set.insert(handle2, zone());

  EXPECT_TRUE(zone_compact_set.contains(zone_compact_subset));
  EXPECT_FALSE(zone_compact_subset.contains(zone_compact_set));
}

TEST_F(ZoneCompactSetTest, ContainsSingleElementSubset) {
  ZoneCompactSet<HandleLike> zone_compact_set;
  ZoneCompactSet<HandleLike> zone_compact_subset;

  HandleLike handle1 = NewHandleLike(5);
  HandleLike handle2 = NewHandleLike(8);

  zone_compact_set.insert(handle1, zone());
  zone_compact_set.insert(handle2, zone());

  zone_compact_subset.insert(handle1, zone());

  EXPECT_TRUE(zone_compact_set.contains(zone_compact_subset));
  EXPECT_FALSE(zone_compact_subset.contains(zone_compact_set));
}

TEST_F(ZoneCompactSetTest, ContainsMultiElementSubset) {
  ZoneCompactSet<HandleLike> zone_compact_set;
  ZoneCompactSet<HandleLike> zone_compact_subset;

  HandleLike handle1 = NewHandleLike(5);
  HandleLike handle2 = NewHandleLike(8);
  HandleLike handle3 = NewHandleLike(2);
  HandleLike handle4 = NewHandleLike(1);

  zone_compact_set.insert(handle1, zone());
  zone_compact_set.insert(handle2, zone());
  zone_compact_set.insert(handle3, zone());
  zone_compact_set.insert(handle4, zone());

  zone_compact_subset.insert(handle2, zone());
  zone_compact_subset.insert(handle3, zone());

  EXPECT_TRUE(zone_compact_set.contains(zone_compact_subset));
  EXPECT_FALSE(zone_compact_subset.contains(zone_compact_set));
}

TEST_F(ZoneCompactSetTest, DoesNotContainsNonSubset) {
  ZoneCompactSet<HandleLike> zone_compact_set;
  ZoneCompactSet<HandleLike> zone_compact_other_set;

  HandleLike handle1 = NewHandleLike(5);
  HandleLike handle2 = NewHandleLike(8);
  HandleLike handle3 = NewHandleLike(2);
  HandleLike handle4 = NewHandleLike(1);

  zone_compact_set.insert(handle1, zone());
  zone_compact_set.insert(handle2, zone());
  zone_compact_set.insert(handle3, zone());

  zone_compact_other_set.insert(handle2, zone());
  zone_compact_other_set.insert(handle4, zone());

  EXPECT_FALSE(zone_compact_set.contains(zone_compact_other_set));
  EXPECT_FALSE(zone_compact_other_set.contains(zone_compact_set));
}

}  // namespace internal
}  // namespace v8
                                                                                                                                                    node-23.7.0/deps/v8/test/unittests/zone/zone-unittest.cc                                            0000664 0000000 0000000 00000001410 14746647661 0023174 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/zone/zone.h"

#include "src/zone/accounting-allocator.h"
#include "test/unittests/test-utils.h"
#include "testing/gtest/include/gtest/gtest.h"

namespace v8 {
namespace internal {

class ZoneTest : public TestWithPlatform {};

// This struct is just a type tag for Zone::Allocate<T>(size_t) call.
struct ZoneTestTag {};

TEST_F(ZoneTest, 8ByteAlignment) {
  AccountingAllocator allocator;
  Zone zone(&allocator, ZONE_NAME);

  for (size_t i = 0; i < 16; ++i) {
    ASSERT_EQ(reinterpret_cast<intptr_t>(zone.Allocate<ZoneTestTag>(i)) % 8, 0);
  }
}

}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/unittests/zone/zone-vector-unittest.cc                                     0000664 0000000 0000000 00000023122 14746647661 0024500 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <optional>

#include "src/zone/zone-containers.h"
#include "test/unittests/test-utils.h"
#include "testing/gtest/include/gtest/gtest.h"

namespace v8::internal {

template <class T>
class LiveSet {
 public:
  void Add(const T* new_entry) {
    CHECK(!Contains(new_entry));
    set_.insert(new_entry);
  }

  void Remove(const T* old_entry) {
    CHECK(Contains(old_entry));
    set_.erase(old_entry);
  }

  void CheckContainsAll(ZoneVector<T>& vector) {
    CHECK_EQ(vector.size(), set_.size());
    for (const T* m = vector.begin(); m != vector.end(); m++) {
      CHECK(Contains(m));
    }
  }

  void CheckEmpty() { CHECK_EQ(0, set_.size()); }

 private:
  bool Contains(const T* entry) {
    // std::set::contains is a C++20 extension.
    return set_.find(entry) != set_.end();
  }

  std::set<const T*> set_;
};

template <typename T>
LiveSet<T>& live_set() {
  static LiveSet<T> static_live_set;
  return static_live_set;
}

class Trivial {
 public:
  Trivial() : id_(0) {}
  explicit Trivial(int id) : id_(id) {}

  int id() const { return id_; }

 private:
  int id_;
};

static_assert(std::is_trivially_copyable_v<Trivial>);

template <>
class LiveSet<Trivial> {
 public:
  void Add(const Trivial* new_entry) { UNREACHABLE(); }
  void Remove(const Trivial* old_entry) { UNREACHABLE(); }
  void CheckContainsAll(ZoneVector<Trivial>&) {}
  void CheckEmpty() {}
};

class CopyAssignable {
 public:
  CopyAssignable() : id_(0) { live_set<CopyAssignable>().Add(this); }
  explicit CopyAssignable(int id) : id_(id) {
    live_set<CopyAssignable>().Add(this);
  }
  CopyAssignable(const CopyAssignable& other) V8_NOEXCEPT : id_(other.id_) {
    live_set<CopyAssignable>().Add(this);
  }
  ~CopyAssignable() { live_set<CopyAssignable>().Remove(this); }
  CopyAssignable& operator=(const CopyAssignable& other) V8_NOEXCEPT = default;

  CopyAssignable(CopyAssignable&& other) = delete;
  CopyAssignable& operator=(CopyAssignable&& other) = delete;

  int id() const { return id_; }

 private:
  int id_;
};

static_assert(!std::is_trivially_copyable_v<CopyAssignable>);
static_assert(std::is_copy_assignable_v<CopyAssignable>);
static_assert(!std::is_move_assignable_v<CopyAssignable>);

class MoveAssignable {
 public:
  MoveAssignable() : id_(0) { live_set<MoveAssignable>().Add(this); }
  explicit MoveAssignable(int id) : id_(id) {
    live_set<MoveAssignable>().Add(this);
  }
  MoveAssignable(const MoveAssignable& other) V8_NOEXCEPT : id_(other.id_) {
    live_set<MoveAssignable>().Add(this);
  }
  MoveAssignable(MoveAssignable&& other) V8_NOEXCEPT : id_(other.id_) {
    live_set<MoveAssignable>().Add(this);
  }
  MoveAssignable& operator=(const MoveAssignable& other) = delete;
  MoveAssignable& operator=(MoveAssignable&& other) V8_NOEXCEPT {
    id_ = other.id_;
    return *this;
  }
  ~MoveAssignable() { live_set<MoveAssignable>().Remove(this); }

  int id() const { return id_; }

 private:
  int id_;
};

static_assert(!std::is_trivially_copyable_v<MoveAssignable>);
static_assert(std::is_move_assignable_v<MoveAssignable>);
static_assert(!std::is_copy_assignable_v<MoveAssignable>);

class NotAssignable {
 public:
  NotAssignable() : id_(0) { live_set<NotAssignable>().Add(this); }
  explicit NotAssignable(int id) : id_(id) {
    live_set<NotAssignable>().Add(this);
  }
  NotAssignable(const NotAssignable& other) V8_NOEXCEPT : id_(other.id_) {
    live_set<NotAssignable>().Add(this);
  }
  NotAssignable& operator=(const NotAssignable& other) = delete;
  ~NotAssignable() { live_set<NotAssignable>().Remove(this); }

  NotAssignable(NotAssignable&& other) = delete;
  NotAssignable& operator=(NotAssignable&& other) = delete;

  int id() const { return id_; }

 private:
  int id_;
};

static_assert(!std::is_trivially_copyable_v<NotAssignable>);
static_assert(!std::is_copy_assignable_v<NotAssignable>);
static_assert(!std::is_move_assignable_v<NotAssignable>);

class ZoneVectorTest : public TestWithZone {
 public:
  template <class T>
  void CheckConsistency(ZoneVector<T>& vector, std::initializer_list<int> ids) {
    live_set<T>().CheckContainsAll(vector);
    CHECK_EQ(vector.size(), ids.size());
    auto it = ids.begin();
    for (size_t i = 0; i < ids.size(); i++) {
      CHECK_EQ(*it++, vector[i].id());
    }
  }

  template <class T>
  void Basic() {
    {
      // Constructor with definition.
      ZoneVector<T> v(1, T(1), zone());
      CheckConsistency(v, {1});
    }
    live_set<T>().CheckEmpty();

    {
      // Constructor with initializer list.
      ZoneVector<T> v({T(1), T(2), T(3)}, zone());
      CheckConsistency(v, {1, 2, 3});
    }
    live_set<T>().CheckEmpty();

    {
      std::optional<ZoneVector<T>> v1;
      v1.emplace({T(1), T(2), T(3)}, zone());
      CheckConsistency(v1.value(), {1, 2, 3});
      {
        // Copy assignment with growth.
        ZoneVector<T> v2 = v1.value();
        v1.reset();
        CheckConsistency(v2, {1, 2, 3});
      }
      v1.emplace({T(1), T(2), T(3)}, zone());
      CheckConsistency(v1.value(), {1, 2, 3});

      // Copy assignment without growth.
      ZoneVector<T> v3({T(4), T(5), T(6)}, zone());
      v3 = v1.value();
      v1.reset();
      CheckConsistency(v3, {1, 2, 3});

      // Move assignment.
      {
        ZoneVector<T> v4(std::move(v3));
        CheckConsistency(v4, {1, 2, 3});
      }
      CheckConsistency(v3, {});
    }
    live_set<T>().CheckEmpty();
  }

  template <class T>
  void Assign() {
    {
      // Assign with sufficient capacity.
      ZoneVector<T> v({T(1), T(2), T(3)}, zone());
      v.assign(2, T(4));
      CheckConsistency(v, {4, 4});
      // This time, capacity > size.
      v.assign(3, T(5));
      CheckConsistency(v, {5, 5, 5});
    }

    {
      // Assign with capacity growth.
      ZoneVector<T> v({T(1)}, zone());
      v.assign(2, T(4));
      CheckConsistency(v, {4, 4});
    }

    live_set<T>().CheckEmpty();
  }

  template <class T>
  void Insert() {
    // Check that we can insert (by iterator) in the right positions.
    {
      ZoneVector<T> v({T(2), T(4)}, zone());
      {
        T src1[] = {T(1)};
        T src3[] = {T(3)};
        T src5[] = {T(5)};
        v.insert(&v.at(0), src1, std::end(src1));
        v.insert(&v.at(2), src3, std::end(src3));
        v.insert(v.end(), src5, std::end(src5));
      }
      CheckConsistency(v, {1, 2, 3, 4, 5});
    }

    // Check that we can insert (by count) in the right positions.
    {
      ZoneVector<T> v({T(2), T(4)}, zone());
      v.insert(&v.at(0), 1, T(1));
      v.insert(&v.at(2), 1, T(3));
      v.insert(v.end(), 1, T(5));
      CheckConsistency(v, {1, 2, 3, 4, 5});
    }

    // Test the "insufficient capacity" case in PrepareForInsertion.
    {
      ZoneVector<T> v(zone());
      CHECK_EQ(0, v.capacity());
      v.insert(v.begin(), 1, T(5));
      CheckConsistency(v, {5});
      {
        T src[] = {T(1), T(2), T(3), T(4)};
        v.insert(v.begin(), src, std::end(src));
      }
      CheckConsistency(v, {1, 2, 3, 4, 5});
    }

    // Test "case 1" of sufficient capacity in PrepareForInsertion.
    {
      ZoneVector<T> v({T(1), T(2), T(3), T(4), T(5)}, zone());
      v.reserve(10);
      CHECK_EQ(10, v.capacity());
      CheckConsistency(v, {1, 2, 3, 4, 5});
      {
        T src[] = {T(11), T(12), T(13), T(14)};
        v.insert(&v.at(3), src, std::end(src));
      }
      CheckConsistency(v, {1, 2, 3, 11, 12, 13, 14, 4, 5});
    }

    // Test "case 2" of sufficient capacity in PrepareForInsertion.
    {
      ZoneVector<T> v({T(1), T(2), T(3), T(4), T(5)}, zone());
      v.reserve(10);
      {
        T src[] = {T(11), T(12)};
        v.insert(&v.at(2), src, std::end(src));
      }
      CheckConsistency(v, {1, 2, 11, 12, 3, 4, 5});
    }
    live_set<T>().CheckEmpty();

    // For good measure, test the edge case where we're inserting exactly
    // as many elements as we're moving.
    {
      ZoneVector<T> v({T(1), T(2), T(3), T(4)}, zone());
      v.reserve(10);
      {
        T src[] = {T(11), T(12)};
        v.insert(&v.at(2), src, std::end(src));
      }
    }
  }

  template <class T>
  void Erase() {
    // Erase one element.
    {
      ZoneVector<T> v({T(1), T(2), T(3)}, zone());
      v.erase(&v.at(1));
      CheckConsistency(v, {1, 3});
    }
    // Erase a range.
    {
      ZoneVector<T> v({T(1), T(2), T(3), T(4)}, zone());
      v.erase(&v.at(1), &v.at(3));
      CheckConsistency(v, {1, 4});
    }
    // Erase first element.
    {
      ZoneVector<T> v({T(1), T(2), T(3)}, zone());
      v.erase(v.begin());
      CheckConsistency(v, {2, 3});
    }
    // Erase last element.
    {
      ZoneVector<T> v({T(1), T(2), T(3)}, zone());
      v.erase(&v.at(2));
      CheckConsistency(v, {1, 2});
    }
    // Erase nothing (empty range).
    {
      ZoneVector<T> v({T(1), T(2), T(3)}, zone());
      v.erase(v.begin(), v.begin());
      CheckConsistency(v, {1, 2, 3});
      v.erase(&v.at(1), &v.at(1));
      CheckConsistency(v, {1, 2, 3});
      v.erase(v.end(), v.end());
      CheckConsistency(v, {1, 2, 3});
    }
    live_set<T>().CheckEmpty();
  }
};

TEST_F(ZoneVectorTest, Basic) {
  Basic<Trivial>();
  Basic<CopyAssignable>();
  Basic<MoveAssignable>();
  Basic<NotAssignable>();
}

TEST_F(ZoneVectorTest, Assign) {
  Assign<Trivial>();
  Assign<CopyAssignable>();
  Assign<MoveAssignable>();
  Assign<NotAssignable>();
}

TEST_F(ZoneVectorTest, Insert) {
  Insert<Trivial>();
  Insert<CopyAssignable>();
  Insert<MoveAssignable>();
  Insert<NotAssignable>();
}

TEST_F(ZoneVectorTest, Erase) {
  Erase<Trivial>();
  Erase<CopyAssignable>();
  Erase<MoveAssignable>();
  Erase<NotAssignable>();
}

}  // namespace v8::internal
                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/wasm-api-tests/                                                            0000775 0000000 0000000 00000000000 14746647661 0017702 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/test/wasm-api-tests/BUILD.gn                                                    0000664 0000000 0000000 00000001764 14746647661 0021077 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2019 The V8 project authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("../../gni/v8.gni")

v8_executable("wasm_api_tests") {
  testonly = true

  deps = [
    "../:common_test_headers",
    "../..:v8_internal_headers",
    "../..:v8_maybe_icu",
    "../..:wee8",
    "//build/win:default_exe_manifest",
    "//testing/gmock",
    "//testing/gtest",
  ]

  data_deps = [ "../../tools:v8_testrunner" ]

  data = [
    "testcfg.py",
    "wasm-api-tests.status",
  ]

  configs = [ "../..:internal_config_base" ]

  sources = [
    "../../testing/gmock-support.h",
    "../../testing/gtest-support.h",
    "callbacks.cc",
    "finalize.cc",
    "globals.cc",
    "hostref.cc",
    "memory.cc",
    "multi-return.cc",
    "reflect.cc",
    "regressions.cc",
    "run-all-wasm-api-tests.cc",
    "serialize.cc",
    "startup-errors.cc",
    "table.cc",
    "threads.cc",
    "traps.cc",
    "wasm-api-test.h",
  ]
}
            node-23.7.0/deps/v8/test/wasm-api-tests/DEPS                                                        0000664 0000000 0000000 00000000106 14746647661 0020355 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        include_rules = [
  "+src",
  "+testing",
  "+third_party/wasm-api"
]
                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/wasm-api-tests/callbacks.cc                                                0000664 0000000 0000000 00000031170 14746647661 0022132 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "test/wasm-api-tests/wasm-api-test.h"

#include "src/execution/isolate.h"
#include "src/heap/heap.h"
#include "src/wasm/c-api.h"

namespace v8 {
namespace internal {
namespace wasm {

namespace {

own<Trap> Stage2(void* env, const Val args[], Val results[]) {
  printf("Stage2...\n");
  WasmCapiTest* self = reinterpret_cast<WasmCapiTest*>(env);
  Func* stage3 = self->GetExportedFunction(1);
  own<Trap> trap = stage3->call(args, results);
  if (trap) {
    printf("Stage2: got exception: %s\n", trap->message().get());
  } else {
    printf("Stage2: call successful\n");
  }
  return trap;
}

own<Trap> Stage4_GC(void* env, const Val args[], Val results[]) {
  printf("Stage4...\n");
  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(env);
  isolate->heap()->PreciseCollectAllGarbage(GCFlag::kForced,
                                            GarbageCollectionReason::kTesting);
  results[0] = Val::i32(args[0].i32() + 1);
  return nullptr;
}

class WasmCapiCallbacksTest : public WasmCapiTest {
 public:
  WasmCapiCallbacksTest() : WasmCapiTest() {
    // Build the following function:
    // int32 stage1(int32 arg0) { return stage2(arg0); }
    uint32_t stage2_index =
        builder()->AddImport(base::CStrVector("stage2"), wasm_i_i_sig());
    uint8_t code[] = {WASM_CALL_FUNCTION(stage2_index, WASM_LOCAL_GET(0))};
    AddExportedFunction(base::CStrVector("stage1"), code, sizeof(code));

    stage2_ = Func::make(store(), cpp_i_i_sig(), Stage2, this);
  }

  Func* stage2() { return stage2_.get(); }
  void AddExportedFunction(base::Vector<const char> name, uint8_t code[],
                           size_t code_size) {
    WasmCapiTest::AddExportedFunction(name, code, code_size, wasm_i_i_sig());
  }

 private:
  own<Func> stage2_;
};

}  // namespace

TEST_F(WasmCapiCallbacksTest, Trap) {
  // Build the following function:
  // int32 stage3_trap(int32 arg0) { unreachable(); }
  uint8_t code[] = {WASM_UNREACHABLE};
  AddExportedFunction(base::CStrVector("stage3_trap"), code, sizeof(code));

  Extern* imports[] = {stage2()};
  Instantiate(imports);
  Val args[] = {Val::i32(42)};
  Val results[1];
  own<Trap> trap = GetExportedFunction(0)->call(args, results);
  EXPECT_NE(trap, nullptr);
  printf("Stage0: Got trap as expected: %s\n", trap->message().get());
}

TEST_F(WasmCapiCallbacksTest, GC) {
  // Build the following function:
  // int32 stage3_to4(int32 arg0) { return stage4(arg0); }
  uint32_t stage4_index =
      builder()->AddImport(base::CStrVector("stage4"), wasm_i_i_sig());
  uint8_t code[] = {WASM_CALL_FUNCTION(stage4_index, WASM_LOCAL_GET(0))};
  AddExportedFunction(base::CStrVector("stage3_to4"), code, sizeof(code));

  i::Isolate* isolate =
      reinterpret_cast<::wasm::StoreImpl*>(store())->i_isolate();
  own<Func> stage4 = Func::make(store(), cpp_i_i_sig(), Stage4_GC, isolate);
  EXPECT_EQ(cpp_i_i_sig()->params().size(), stage4->type()->params().size());
  EXPECT_EQ(cpp_i_i_sig()->results().size(), stage4->type()->results().size());
  Extern* imports[] = {stage2(), stage4.get()};
  Instantiate(imports);
  Val args[] = {Val::i32(42)};
  Val results[1];
  own<Trap> trap = GetExportedFunction(0)->call(args, results);
  EXPECT_EQ(trap, nullptr);
  EXPECT_EQ(43, results[0].i32());
}

namespace {

own<Trap> FibonacciC(void* env, const Val args[], Val results[]) {
  int32_t x = args[0].i32();
  if (x == 0 || x == 1) {
    results[0] = Val::i32(x);
    return nullptr;
  }
  WasmCapiTest* self = reinterpret_cast<WasmCapiTest*>(env);
  Func* fibo_wasm = self->GetExportedFunction(0);
  // Aggressively re-use existing arrays. That's maybe not great coding
  // style, but this test intentionally ensures that it works if someone
  // insists on doing it.
  Val recursive_args[] = {Val::i32(x - 1)};
  own<Trap> trap = fibo_wasm->call(recursive_args, results);
  DCHECK_NULL(trap);
  int32_t x1 = results[0].i32();
  recursive_args[0] = Val::i32(x - 2);
  trap = fibo_wasm->call(recursive_args, results);
  DCHECK_NULL(trap);
  int32_t x2 = results[0].i32();
  results[0] = Val::i32(x1 + x2);
  return nullptr;
}

}  // namespace

TEST_F(WasmCapiTest, Recursion) {
  // Build the following function:
  // int32 fibonacci_wasm(int32 arg0) {
  //   if (arg0 == 0) return 0;
  //   if (arg0 == 1) return 1;
  //   return fibonacci_c(arg0 - 1) + fibonacci_c(arg0 - 2);
  // }
  uint32_t fibo_c_index =
      builder()->AddImport(base::CStrVector("fibonacci_c"), wasm_i_i_sig());
  uint8_t code_fibo[] = {
      WASM_IF(WASM_I32_EQ(WASM_LOCAL_GET(0), WASM_ZERO),
              WASM_RETURN(WASM_ZERO)),
      WASM_IF(WASM_I32_EQ(WASM_LOCAL_GET(0), WASM_ONE), WASM_RETURN(WASM_ONE)),
      // Muck with the parameter to ensure callers don't depend on its value.
      WASM_LOCAL_SET(0, WASM_I32_SUB(WASM_LOCAL_GET(0), WASM_ONE)),
      WASM_RETURN(WASM_I32_ADD(
          WASM_CALL_FUNCTION(fibo_c_index, WASM_LOCAL_GET(0)),
          WASM_CALL_FUNCTION(fibo_c_index,
                             WASM_I32_SUB(WASM_LOCAL_GET(0), WASM_ONE))))};
  AddExportedFunction(base::CStrVector("fibonacci_wasm"), code_fibo,
                      sizeof(code_fibo), wasm_i_i_sig());

  own<Func> fibonacci = Func::make(store(), cpp_i_i_sig(), FibonacciC, this);
  Extern* imports[] = {fibonacci.get()};
  Instantiate(imports);
  // Enough iterations to make it interesting, few enough to keep it fast.
  Val args[] = {Val::i32(15)};
  Val results[1];
  own<Trap> result = GetExportedFunction(0)->call(args, results);
  EXPECT_EQ(result, nullptr);
  EXPECT_EQ(610, results[0].i32());
}

namespace {

own<Trap> PlusOne(const Val args[], Val results[]) {
  int32_t a0 = args[0].i32();
  results[0] = Val::i32(a0 + 1);
  int64_t a1 = args[1].i64();
  results[1] = Val::i64(a1 + 1);
  float a2 = args[2].f32();
  results[2] = Val::f32(a2 + 1);
  double a3 = args[3].f64();
  results[3] = Val::f64(a3 + 1);
  results[4] = Val::ref(args[4].ref()->copy());  // No +1 for Refs.
  return nullptr;
}

own<Trap> PlusOneWithManyArgs(const Val args[], Val results[]) {
  int32_t a0 = args[0].i32();
  results[0] = Val::i32(a0 + 1);
  int64_t a1 = args[1].i64();
  results[1] = Val::i64(a1 + 1);
  float a2 = args[2].f32();
  results[2] = Val::f32(a2 + 1);
  double a3 = args[3].f64();
  results[3] = Val::f64(a3 + 1);
  results[4] = Val::ref(args[4].ref()->copy());  // No +1 for Refs.
  int32_t a5 = args[5].i32();
  results[5] = Val::i32(a5 + 1);
  int64_t a6 = args[6].i64();
  results[6] = Val::i64(a6 + 1);
  float a7 = args[7].f32();
  results[7] = Val::f32(a7 + 1);
  double a8 = args[8].f64();
  results[8] = Val::f64(a8 + 1);
  int32_t a9 = args[9].i32();
  results[9] = Val::i32(a9 + 1);
  int64_t a10 = args[10].i64();
  results[10] = Val::i64(a10 + 1);
  float a11 = args[11].f32();
  results[11] = Val::f32(a11 + 1);
  double a12 = args[12].f64();
  results[12] = Val::f64(a12 + 1);
  int32_t a13 = args[13].i32();
  results[13] = Val::i32(a13 + 1);
  return nullptr;
}
}  // namespace

TEST_F(WasmCapiTest, DirectCallCapiFunction) {
  own<FuncType> cpp_sig =
      FuncType::make(ownvec<ValType>::make(
                         ValType::make(::wasm::I32), ValType::make(::wasm::I64),
                         ValType::make(::wasm::F32), ValType::make(::wasm::F64),
                         ValType::make(::wasm::ANYREF)),
                     ownvec<ValType>::make(
                         ValType::make(::wasm::I32), ValType::make(::wasm::I64),
                         ValType::make(::wasm::F32), ValType::make(::wasm::F64),
                         ValType::make(::wasm::ANYREF)));
  own<Func> func = Func::make(store(), cpp_sig.get(), PlusOne);
  Extern* imports[] = {func.get()};
  ValueType wasm_types[] = {kWasmI32,       kWasmI64,      kWasmF32, kWasmF64,
                            kWasmExternRef, kWasmI32,      kWasmI64, kWasmF32,
                            kWasmF64,       kWasmExternRef};
  FunctionSig wasm_sig(5, 5, wasm_types);
  int func_index = builder()->AddImport(base::CStrVector("func"), &wasm_sig);
  builder()->ExportImportedFunction(base::CStrVector("func"), func_index);
  Instantiate(imports);
  int32_t a0 = 42;
  int64_t a1 = 0x1234c0ffee;
  float a2 = 1234.5;
  double a3 = 123.45;
  Val args[] = {Val::i32(a0), Val::i64(a1), Val::f32(a2), Val::f64(a3),
                Val::ref(func->copy())};
  Val results[5];
  // Test that {func} can be called directly.
  own<Trap> trap = func->call(args, results);
  EXPECT_EQ(nullptr, trap);
  EXPECT_EQ(a0 + 1, results[0].i32());
  EXPECT_EQ(a1 + 1, results[1].i64());
  EXPECT_EQ(a2 + 1, results[2].f32());
  EXPECT_EQ(a3 + 1, results[3].f64());
  EXPECT_TRUE(func->same(results[4].ref()));

  // Test that {func} can be called after import/export round-tripping.
  trap = GetExportedFunction(0)->call(args, results);
  EXPECT_EQ(nullptr, trap);
  EXPECT_EQ(a0 + 1, results[0].i32());
  EXPECT_EQ(a1 + 1, results[1].i64());
  EXPECT_EQ(a2 + 1, results[2].f32());
  EXPECT_EQ(a3 + 1, results[3].f64());
  EXPECT_TRUE(func->same(results[4].ref()));
}

TEST_F(WasmCapiTest, DirectCallCapiFunctionWithManyArgs) {
  // Test with many arguments to make sure that CWasmArgumentsPacker won't use
  // its buffer-on-stack optimization.
  own<FuncType> cpp_sig = FuncType::make(
      ownvec<ValType>::make(
          ValType::make(::wasm::I32), ValType::make(::wasm::I64),
          ValType::make(::wasm::F32), ValType::make(::wasm::F64),
          ValType::make(::wasm::ANYREF), ValType::make(::wasm::I32),
          ValType::make(::wasm::I64), ValType::make(::wasm::F32),
          ValType::make(::wasm::F64), ValType::make(::wasm::I32),
          ValType::make(::wasm::I64), ValType::make(::wasm::F32),
          ValType::make(::wasm::F64), ValType::make(::wasm::I32)),
      ownvec<ValType>::make(
          ValType::make(::wasm::I32), ValType::make(::wasm::I64),
          ValType::make(::wasm::F32), ValType::make(::wasm::F64),
          ValType::make(::wasm::ANYREF), ValType::make(::wasm::I32),
          ValType::make(::wasm::I64), ValType::make(::wasm::F32),
          ValType::make(::wasm::F64), ValType::make(::wasm::I32),
          ValType::make(::wasm::I64), ValType::make(::wasm::F32),
          ValType::make(::wasm::F64), ValType::make(::wasm::I32)));
  own<Func> func = Func::make(store(), cpp_sig.get(), PlusOneWithManyArgs);
  Extern* imports[] = {func.get()};
  ValueType wasm_types[] = {
      kWasmI32,       kWasmI64, kWasmF32, kWasmF64, kWasmExternRef, kWasmI32,
      kWasmI64,       kWasmF32, kWasmF64, kWasmI32, kWasmI64,       kWasmF32,
      kWasmF64,       kWasmI32, kWasmI32, kWasmI64, kWasmF32,       kWasmF64,
      kWasmExternRef, kWasmI32, kWasmI64, kWasmF32, kWasmF64,       kWasmI32,
      kWasmI64,       kWasmF32, kWasmF64, kWasmI32};
  FunctionSig wasm_sig(14, 14, wasm_types);
  int func_index = builder()->AddImport(base::CStrVector("func"), &wasm_sig);
  builder()->ExportImportedFunction(base::CStrVector("func"), func_index);
  Instantiate(imports);
  int32_t a0 = 42;
  int64_t a1 = 0x1234c0ffee;
  float a2 = 1234.5;
  double a3 = 123.45;
  Val args[] = {
      Val::i32(a0),           Val::i64(a1), Val::f32(a2), Val::f64(a3),
      Val::ref(func->copy()), Val::i32(a0), Val::i64(a1), Val::f32(a2),
      Val::f64(a3),           Val::i32(a0), Val::i64(a1), Val::f32(a2),
      Val::f64(a3),           Val::i32(a0)};
  Val results[14];
  // Test that {func} can be called directly.
  own<Trap> trap = func->call(args, results);
  EXPECT_EQ(nullptr, trap);
  EXPECT_EQ(a0 + 1, results[0].i32());
  EXPECT_EQ(a1 + 1, results[1].i64());
  EXPECT_EQ(a2 + 1, results[2].f32());
  EXPECT_EQ(a3 + 1, results[3].f64());
  EXPECT_TRUE(func->same(results[4].ref()));
  EXPECT_EQ(a0 + 1, results[5].i32());
  EXPECT_EQ(a1 + 1, results[6].i64());
  EXPECT_EQ(a2 + 1, results[7].f32());
  EXPECT_EQ(a3 + 1, results[8].f64());
  EXPECT_EQ(a0 + 1, results[9].i32());
  EXPECT_EQ(a1 + 1, results[10].i64());
  EXPECT_EQ(a2 + 1, results[11].f32());
  EXPECT_EQ(a3 + 1, results[12].f64());
  EXPECT_EQ(a0 + 1, results[13].i32());

  // Test that {func} can be called after import/export round-tripping.
  trap = GetExportedFunction(0)->call(args, results);
  EXPECT_EQ(nullptr, trap);
  EXPECT_EQ(a0 + 1, results[0].i32());
  EXPECT_EQ(a1 + 1, results[1].i64());
  EXPECT_EQ(a2 + 1, results[2].f32());
  EXPECT_EQ(a3 + 1, results[3].f64());
  EXPECT_TRUE(func->same(results[4].ref()));
  EXPECT_EQ(a0 + 1, results[5].i32());
  EXPECT_EQ(a1 + 1, results[6].i64());
  EXPECT_EQ(a2 + 1, results[7].f32());
  EXPECT_EQ(a3 + 1, results[8].f64());
  EXPECT_EQ(a0 + 1, results[9].i32());
  EXPECT_EQ(a1 + 1, results[10].i64());
  EXPECT_EQ(a2 + 1, results[11].f32());
  EXPECT_EQ(a3 + 1, results[12].f64());
  EXPECT_EQ(a0 + 1, results[13].i32());
}
}  // namespace wasm
}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/wasm-api-tests/finalize.cc                                                 0000664 0000000 0000000 00000015343 14746647661 0022020 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "test/wasm-api-tests/wasm-api-test.h"

namespace v8 {
namespace internal {
namespace wasm {

namespace {

int g_instances_finalized = 0;
int g_functions_finalized = 0;
int g_foreigns_finalized = 0;
int g_modules_finalized = 0;

const int kModuleMagic = 42;

void FinalizeInstance(void* data) {
  int iteration = static_cast<int>(reinterpret_cast<intptr_t>(data));
  g_instances_finalized += iteration;
}

void FinalizeFunction(void* data) {
  int iteration = static_cast<int>(reinterpret_cast<intptr_t>(data));
  g_functions_finalized += iteration;
}

void FinalizeForeign(void* data) {
  int iteration = static_cast<int>(reinterpret_cast<intptr_t>(data));
  g_foreigns_finalized += iteration;
}

void FinalizeModule(void* data) {
  g_modules_finalized += static_cast<int>(reinterpret_cast<intptr_t>(data));
}

void RunInStore(Store* store, base::Vector<const uint8_t> wire_bytes,
                int iterations) {
  vec<byte_t> binary = vec<byte_t>::make(
      wire_bytes.size(),
      reinterpret_cast<byte_t*>(const_cast<uint8_t*>(wire_bytes.begin())));
  own<Module> module = Module::make(store, binary);
  module->set_host_info(reinterpret_cast<void*>(kModuleMagic), &FinalizeModule);
  for (int iteration = 0; iteration < iterations; iteration++) {
    void* finalizer_data = reinterpret_cast<void*>(iteration);
    own<Instance> instance = Instance::make(store, module.get(), nullptr);
    EXPECT_NE(nullptr, instance.get());
    instance->set_host_info(finalizer_data, &FinalizeInstance);

    own<Func> func = instance->exports()[0]->func()->copy();
    ASSERT_NE(func, nullptr);
    func->set_host_info(finalizer_data, &FinalizeFunction);
    Val args[] = {Val::i32(iteration)};
    Val results[1];
    func->call(args, results);
    EXPECT_EQ(iteration, results[0].i32());

    own<Foreign> foreign = Foreign::make(store);
    foreign->set_host_info(finalizer_data, &FinalizeForeign);
  }
}

}  // namespace

TEST_F(WasmCapiTest, InstanceFinalization) {
  // Add a dummy function: f(x) { return x; }
  uint8_t code[] = {WASM_RETURN(WASM_LOCAL_GET(0))};
  AddExportedFunction(base::CStrVector("f"), code, sizeof(code),
                      wasm_i_i_sig());
  Compile();
  g_instances_finalized = 0;
  g_functions_finalized = 0;
  g_foreigns_finalized = 0;
  g_modules_finalized = 0;
  module()->set_host_info(reinterpret_cast<void*>(kModuleMagic),
                          &FinalizeModule);
  static const int kIterations = 10;
  RunInStore(store(), wire_bytes(), kIterations);
  {
    own<Store> store2 = Store::make(engine());
    RunInStore(store2.get(), wire_bytes(), kIterations);
  }
  RunInStore(store(), wire_bytes(), kIterations);
  Shutdown();
  // Verify that (1) all finalizers were called, and (2) they passed the
  // correct host data: the loop above sets {i} as data, and the finalizer
  // callbacks add them all up, so the expected value after three rounds is
  // 3 * sum([0, 1, ..., kIterations - 1]), which per Gauss's formula is:
  static const int kExpected = 3 * ((kIterations * (kIterations - 1)) / 2);
  EXPECT_EQ(g_instances_finalized, kExpected);
  // There are two functions per iteration.
  EXPECT_EQ(g_functions_finalized, kExpected);
  EXPECT_EQ(g_foreigns_finalized, kExpected);
  EXPECT_EQ(g_modules_finalized, 4 * kModuleMagic);
}

namespace {

own<Trap> CapiFunction(void* env, const Val args[], Val results[]) {
  int offset = static_cast<int>(reinterpret_cast<intptr_t>(env));
  results[0] = Val::i32(offset + args[0].i32());
  return nullptr;
}

int g_host_data_finalized = 0;
int g_capi_function_finalized = 0;

void FinalizeCapiFunction(void* data) {
  int value = static_cast<int>(reinterpret_cast<intptr_t>(data));
  g_capi_function_finalized += value;
}

void FinalizeHostData(void* data) {
  g_host_data_finalized += static_cast<int>(reinterpret_cast<intptr_t>(data));
}

}  // namespace

TEST_F(WasmCapiTest, CapiFunctionLifetimes) {
  uint32_t func_index =
      builder()->AddImport(base::CStrVector("f"), wasm_i_i_sig());
  builder()->ExportImportedFunction(base::CStrVector("f"), func_index);
  Compile();
  own<Instance> instance;
  void* kHostData = reinterpret_cast<void*>(1234);
  int base_summand = 1000;
  {
    // Test that the own<> pointers for Func and FuncType can go out of scope
    // without affecting the ability of the Func to be called later.
    own<FuncType> capi_func_type =
        FuncType::make(ownvec<ValType>::make(ValType::make(::wasm::I32)),
                       ownvec<ValType>::make(ValType::make(::wasm::I32)));
    own<Func> capi_func =
        Func::make(store(), capi_func_type.get(), &CapiFunction,
                   reinterpret_cast<void*>(base_summand));
    Extern* imports[] = {capi_func.get()};
    instance = Instance::make(store(), module(), imports);
    // TODO(jkummerow): It may or may not be desirable to be able to set
    // host data even here and have it survive the import/export dance.
    // We are awaiting resolution of the discussion at:
    // https://github.com/WebAssembly/wasm-c-api/issues/100
  }
  {
    ownvec<Extern> exports = instance->exports();
    Func* exported_func = exports[0]->func();
    constexpr int kArg = 123;
    Val args[] = {Val::i32(kArg)};
    Val results[1];
    exported_func->call(args, results);
    EXPECT_EQ(base_summand + kArg, results[0].i32());
    // Host data should survive destruction of the own<> pointer.
    exported_func->set_host_info(kHostData);
  }
  {
    ownvec<Extern> exports = instance->exports();
    Func* exported_func = exports[0]->func();
    EXPECT_EQ(kHostData, exported_func->get_host_info());
  }
  // Test that a Func can have its own internal metadata, an {env}, and
  // separate {host info}, without any of that interfering with each other.
  g_host_data_finalized = 0;
  g_capi_function_finalized = 0;
  base_summand = 23;
  constexpr int kFinalizerData = 345;
  {
    own<FuncType> capi_func_type =
        FuncType::make(ownvec<ValType>::make(ValType::make(::wasm::I32)),
                       ownvec<ValType>::make(ValType::make(::wasm::I32)));
    own<Func> capi_func = Func::make(
        store(), capi_func_type.get(), &CapiFunction,
        reinterpret_cast<void*>(base_summand), &FinalizeCapiFunction);
    capi_func->set_host_info(reinterpret_cast<void*>(kFinalizerData),
                             &FinalizeHostData);
    constexpr int kArg = 19;
    Val args[] = {Val::i32(kArg)};
    Val results[1];
    capi_func->call(args, results);
    EXPECT_EQ(base_summand + kArg, results[0].i32());
  }
  instance.reset();
  Shutdown();
  EXPECT_EQ(base_summand, g_capi_function_finalized);
  EXPECT_EQ(kFinalizerData, g_host_data_finalized);
}

}  // namespace wasm
}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/wasm-api-tests/globals.cc                                                  0000664 0000000 0000000 00000021356 14746647661 0021643 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "test/wasm-api-tests/wasm-api-test.h"

namespace v8 {
namespace internal {
namespace wasm {

using ::wasm::GlobalType;

TEST_F(WasmCapiTest, Globals) {
  const bool kMutable = true;
  const bool kImmutable = false;

  // Define imported and exported globals in the module.
  const uint32_t cfi_index = builder()->AddGlobalImport(
      base::CStrVector("const f32"), kWasmF32, kImmutable);
  const uint32_t cii_index = builder()->AddGlobalImport(
      base::CStrVector("const i64"), kWasmI64, kImmutable);
  const uint32_t vfi_index = builder()->AddGlobalImport(
      base::CStrVector("var f32"), kWasmF32, kMutable);
  const uint32_t vii_index = builder()->AddGlobalImport(
      base::CStrVector("var i64"), kWasmI64, kMutable);
  const int kNumImported = 4;

  const uint32_t cfe_index =
      kNumImported +
      builder()->AddExportedGlobal(kWasmF32, kImmutable, WasmInitExpr(5.f),
                                   base::CStrVector("const f32"));
  const uint32_t cie_index =
      kNumImported + builder()->AddExportedGlobal(
                         kWasmI64, kImmutable, WasmInitExpr(int64_t{6}),
                         base::CStrVector("const i64"));
  const uint32_t vfe_index =
      kNumImported + builder()->AddExportedGlobal(kWasmF32, kMutable,
                                                  WasmInitExpr(7.f),
                                                  base::CStrVector("var f32"));
  const uint32_t vie_index =
      kNumImported + builder()->AddExportedGlobal(kWasmI64, kMutable,
                                                  WasmInitExpr(int64_t{8}),
                                                  base::CStrVector("var i64"));

  // Define functions for inspecting globals.
  ValueType f32_type[] = {kWasmF32};
  ValueType i64_type[] = {kWasmI64};
  FunctionSig return_f32(1, 0, f32_type);
  FunctionSig return_i64(1, 0, i64_type);
  uint8_t gcfi[] = {WASM_GLOBAL_GET(cfi_index)};
  AddExportedFunction(base::CStrVector("get const f32 import"), gcfi,
                      sizeof(gcfi), &return_f32);
  uint8_t gcii[] = {WASM_GLOBAL_GET(cii_index)};
  AddExportedFunction(base::CStrVector("get const i64 import"), gcii,
                      sizeof(gcii), &return_i64);
  uint8_t gvfi[] = {WASM_GLOBAL_GET(vfi_index)};
  AddExportedFunction(base::CStrVector("get var f32 import"), gvfi,
                      sizeof(gvfi), &return_f32);
  uint8_t gvii[] = {WASM_GLOBAL_GET(vii_index)};
  AddExportedFunction(base::CStrVector("get var i64 import"), gvii,
                      sizeof(gvii), &return_i64);

  uint8_t gcfe[] = {WASM_GLOBAL_GET(cfe_index)};
  AddExportedFunction(base::CStrVector("get const f32 export"), gcfe,
                      sizeof(gcfe), &return_f32);
  uint8_t gcie[] = {WASM_GLOBAL_GET(cie_index)};
  AddExportedFunction(base::CStrVector("get const i64 export"), gcie,
                      sizeof(gcie), &return_i64);
  uint8_t gvfe[] = {WASM_GLOBAL_GET(vfe_index)};
  AddExportedFunction(base::CStrVector("get var f32 export"), gvfe,
                      sizeof(gvfe), &return_f32);
  uint8_t gvie[] = {WASM_GLOBAL_GET(vie_index)};
  AddExportedFunction(base::CStrVector("get var i64 export"), gvie,
                      sizeof(gvie), &return_i64);

  // Define functions for manipulating globals.
  FunctionSig param_f32(0, 1, f32_type);
  FunctionSig param_i64(0, 1, i64_type);
  uint8_t svfi[] = {WASM_GLOBAL_SET(vfi_index, WASM_LOCAL_GET(0))};
  AddExportedFunction(base::CStrVector("set var f32 import"), svfi,
                      sizeof(svfi), &param_f32);
  uint8_t svii[] = {WASM_GLOBAL_SET(vii_index, WASM_LOCAL_GET(0))};
  AddExportedFunction(base::CStrVector("set var i64 import"), svii,
                      sizeof(svii), &param_i64);
  uint8_t svfe[] = {WASM_GLOBAL_SET(vfe_index, WASM_LOCAL_GET(0))};
  AddExportedFunction(base::CStrVector("set var f32 export"), svfe,
                      sizeof(svfe), &param_f32);
  uint8_t svie[] = {WASM_GLOBAL_SET(vie_index, WASM_LOCAL_GET(0))};
  AddExportedFunction(base::CStrVector("set var i64 export"), svie,
                      sizeof(svie), &param_i64);

  // Create imported globals.
  own<GlobalType> const_f32_type =
      GlobalType::make(ValType::make(::wasm::F32), ::wasm::CONST);
  own<GlobalType> const_i64_type =
      GlobalType::make(ValType::make(::wasm::I64), ::wasm::CONST);
  own<GlobalType> var_f32_type =
      GlobalType::make(ValType::make(::wasm::F32), ::wasm::VAR);
  own<GlobalType> var_i64_type =
      GlobalType::make(ValType::make(::wasm::I64), ::wasm::VAR);
  own<Global> const_f32_import =
      Global::make(store(), const_f32_type.get(), Val::f32(1));
  own<Global> const_i64_import =
      Global::make(store(), const_i64_type.get(), Val::i64(2));
  own<Global> var_f32_import =
      Global::make(store(), var_f32_type.get(), Val::f32(3));
  own<Global> var_i64_import =
      Global::make(store(), var_i64_type.get(), Val::i64(4));
  Extern* imports[] = {const_f32_import.get(), const_i64_import.get(),
                       var_f32_import.get(), var_i64_import.get()};

  Instantiate(imports);

  // Extract exports.
  size_t i = 0;
  Global* const_f32_export = GetExportedGlobal(i++);
  Global* const_i64_export = GetExportedGlobal(i++);
  Global* var_f32_export = GetExportedGlobal(i++);
  Global* var_i64_export = GetExportedGlobal(i++);
  Func* get_const_f32_import = GetExportedFunction(i++);
  Func* get_const_i64_import = GetExportedFunction(i++);
  Func* get_var_f32_import = GetExportedFunction(i++);
  Func* get_var_i64_import = GetExportedFunction(i++);
  Func* get_const_f32_export = GetExportedFunction(i++);
  Func* get_const_i64_export = GetExportedFunction(i++);
  Func* get_var_f32_export = GetExportedFunction(i++);
  Func* get_var_i64_export = GetExportedFunction(i++);
  Func* set_var_f32_import = GetExportedFunction(i++);
  Func* set_var_i64_import = GetExportedFunction(i++);
  Func* set_var_f32_export = GetExportedFunction(i++);
  Func* set_var_i64_export = GetExportedFunction(i++);

  // Try cloning.
  EXPECT_TRUE(var_f32_import->copy()->same(var_f32_import.get()));

  // Check initial values.
  EXPECT_EQ(1.f, const_f32_import->get().f32());
  EXPECT_EQ(2, const_i64_import->get().i64());
  EXPECT_EQ(3.f, var_f32_import->get().f32());
  EXPECT_EQ(4, var_i64_import->get().i64());
  EXPECT_EQ(5.f, const_f32_export->get().f32());
  EXPECT_EQ(6, const_i64_export->get().i64());
  EXPECT_EQ(7.f, var_f32_export->get().f32());
  EXPECT_EQ(8, var_i64_export->get().i64());
  Val result[1];
  get_const_f32_import->call(nullptr, result);
  EXPECT_EQ(1.f, result[0].f32());
  get_const_i64_import->call(nullptr, result);
  EXPECT_EQ(2, result[0].i64());
  get_var_f32_import->call(nullptr, result);
  EXPECT_EQ(3.f, result[0].f32());
  get_var_i64_import->call(nullptr, result);
  EXPECT_EQ(4, result[0].i64());
  get_const_f32_export->call(nullptr, result);
  EXPECT_EQ(5.f, result[0].f32());
  get_const_i64_export->call(nullptr, result);
  EXPECT_EQ(6, result[0].i64());
  get_var_f32_export->call(nullptr, result);
  EXPECT_EQ(7.f, result[0].f32());
  get_var_i64_export->call(nullptr, result);
  EXPECT_EQ(8, result[0].i64());

  // Modify variables through the API and check again.
  var_f32_import->set(Val::f32(33));
  var_i64_import->set(Val::i64(34));
  var_f32_export->set(Val::f32(35));
  var_i64_export->set(Val::i64(36));

  EXPECT_EQ(33.f, var_f32_import->get().f32());
  EXPECT_EQ(34, var_i64_import->get().i64());
  EXPECT_EQ(35.f, var_f32_export->get().f32());
  EXPECT_EQ(36, var_i64_export->get().i64());

  get_var_f32_import->call(nullptr, result);
  EXPECT_EQ(33.f, result[0].f32());
  get_var_i64_import->call(nullptr, result);
  EXPECT_EQ(34, result[0].i64());
  get_var_f32_export->call(nullptr, result);
  EXPECT_EQ(35.f, result[0].f32());
  get_var_i64_export->call(nullptr, result);
  EXPECT_EQ(36, result[0].i64());

  // Modify variables through calls and check again.
  Val args[1];
  args[0] = Val::f32(73);
  set_var_f32_import->call(args, nullptr);
  args[0] = Val::i64(74);
  set_var_i64_import->call(args, nullptr);
  args[0] = Val::f32(75);
  set_var_f32_export->call(args, nullptr);
  args[0] = Val::i64(76);
  set_var_i64_export->call(args, nullptr);

  EXPECT_EQ(73.f, var_f32_import->get().f32());
  EXPECT_EQ(74, var_i64_import->get().i64());
  EXPECT_EQ(75.f, var_f32_export->get().f32());
  EXPECT_EQ(76, var_i64_export->get().i64());

  get_var_f32_import->call(nullptr, result);
  EXPECT_EQ(73.f, result[0].f32());
  get_var_i64_import->call(nullptr, result);
  EXPECT_EQ(74, result[0].i64());
  get_var_f32_export->call(nullptr, result);
  EXPECT_EQ(75.f, result[0].f32());
  get_var_i64_export->call(nullptr, result);
  EXPECT_EQ(76, result[0].i64());
}

}  // namespace wasm
}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/test/wasm-api-tests/hostref.cc                                                  0000664 0000000 0000000 00000015173 14746647661 0021672 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <iostream>

#include "test/wasm-api-tests/wasm-api-test.h"

namespace v8 {
namespace internal {
namespace wasm {

using ::wasm::Frame;
using ::wasm::Message;

namespace {

own<Trap> IdentityCallback(const Val args[], Val results[]) {
  results[0] = args[0].copy();
  return nullptr;
}

}  // namespace

TEST_F(WasmCapiTest, HostRef) {
  ValueType rr_reps[] = {kWasmExternRef, kWasmExternRef};
  ValueType ri_reps[] = {kWasmExternRef, kWasmI32};
  ValueType ir_reps[] = {kWasmI32, kWasmExternRef};
  // Naming convention: result_params_sig.
  FunctionSig r_r_sig(1, 1, rr_reps);
  FunctionSig v_r_sig(0, 1, rr_reps);
  FunctionSig r_v_sig(1, 0, rr_reps);
  FunctionSig v_ir_sig(0, 2, ir_reps);
  FunctionSig r_i_sig(1, 1, ri_reps);
  uint32_t func_index = builder()->AddImport(base::CStrVector("f"), &r_r_sig);
  const bool kMutable = true;
  uint32_t global_index = builder()->AddExportedGlobal(
      kWasmExternRef, kMutable, WasmInitExpr::RefNullConst(HeapType::kExtern),
      base::CStrVector("global"));
  uint32_t table_index = builder()->AddTable(kWasmExternRef, 10);
  builder()->AddExport(base::CStrVector("table"), kExternalTable, table_index);
  uint8_t global_set_code[] = {
      WASM_GLOBAL_SET(global_index, WASM_LOCAL_GET(0))};
  AddExportedFunction(base::CStrVector("global.set"), global_set_code,
                      sizeof(global_set_code), &v_r_sig);
  uint8_t global_get_code[] = {WASM_GLOBAL_GET(global_index)};
  AddExportedFunction(base::CStrVector("global.get"), global_get_code,
                      sizeof(global_get_code), &r_v_sig);
  uint8_t table_set_code[] = {
      WASM_TABLE_SET(table_index, WASM_LOCAL_GET(0), WASM_LOCAL_GET(1))};
  AddExportedFunction(base::CStrVector("table.set"), table_set_code,
                      sizeof(table_set_code), &v_ir_sig);
  uint8_t table_get_code[] = {WASM_TABLE_GET(table_index, WASM_LOCAL_GET(0))};
  AddExportedFunction(base::CStrVector("table.get"), table_get_code,
                      sizeof(table_get_code), &r_i_sig);
  uint8_t func_call_code[] = {
      WASM_CALL_FUNCTION(func_index, WASM_LOCAL_GET(0))};
  AddExportedFunction(base::CStrVector("func.call"), func_call_code,
                      sizeof(func_call_code), &r_r_sig);

  own<FuncType> func_type =
      FuncType::make(ownvec<ValType>::make(ValType::make(::wasm::ANYREF)),
                     ownvec<ValType>::make(ValType::make(::wasm::ANYREF)));
  own<Func> callback = Func::make(store(), func_type.get(), IdentityCallback);
  Extern* imports[] = {callback.get()};
  Instantiate(imports);

  Global* global = GetExportedGlobal(0);
  Table* table = GetExportedTable(1);
  const Func* global_set = GetExportedFunction(2);
  const Func* global_get = GetExportedFunction(3);
  const Func* table_set = GetExportedFunction(4);
  const Func* table_get = GetExportedFunction(5);
  const Func* func_call = GetExportedFunction(6);

  own<Foreign> host1 = Foreign::make(store());
  own<Foreign> host2 = Foreign::make(store());
  host1->set_host_info(reinterpret_cast<void*>(1));
  host2->set_host_info(reinterpret_cast<void*>(2));

  // Basic checks.
  EXPECT_TRUE(host1->copy()->same(host1.get()));
  EXPECT_TRUE(host2->copy()->same(host2.get()));
  Val val = Val::ref(host1->copy());
  EXPECT_TRUE(val.ref()->copy()->same(host1.get()));
  own<Ref> ref = val.release_ref();
  EXPECT_EQ(nullptr, val.ref());
  EXPECT_TRUE(ref->copy()->same(host1.get()));

  // Interact with the Global.
  Val args[2];
  Val results[1];
  own<Trap> trap = global_get->call(nullptr, results);
  EXPECT_EQ(nullptr, trap);
  EXPECT_EQ(nullptr, results[0].release_ref());
  args[0] = Val::ref(host1.get()->copy());
  trap = global_set->call(args, nullptr);
  EXPECT_EQ(nullptr, trap);
  trap = global_get->call(nullptr, results);
  EXPECT_EQ(nullptr, trap);
  EXPECT_TRUE(results[0].release_ref()->same(host1.get()));
  args[0] = Val::ref(host2.get()->copy());
  trap = global_set->call(args, nullptr);
  EXPECT_EQ(nullptr, trap);
  trap = global_get->call(nullptr, results);
  EXPECT_EQ(nullptr, trap);
  EXPECT_TRUE(results[0].release_ref()->same(host2.get()));
  args[0] = Val::ref(own<Ref>());
  trap = global_set->call(args, nullptr);
  EXPECT_EQ(nullptr, trap);
  trap = global_get->call(nullptr, results);
  EXPECT_EQ(nullptr, trap);
  EXPECT_EQ(nullptr, results[0].release_ref());

  EXPECT_EQ(nullptr, global->get().release_ref());
  global->set(Val(host2->copy()));
  trap = global_get->call(nullptr, results);
  EXPECT_EQ(nullptr, trap);
  EXPECT_TRUE(results[0].release_ref()->same(host2.get()));
  EXPECT_TRUE(global->get().release_ref()->same(host2.get()));

  // Interact with the Table.
  args[0] = Val::i32(0);
  trap = table_get->call(args, results);
  EXPECT_EQ(nullptr, trap);
  EXPECT_EQ(nullptr, results[0].release_ref());
  args[0] = Val::i32(1);
  trap = table_get->call(args, results);
  EXPECT_EQ(nullptr, trap);
  EXPECT_EQ(nullptr, results[0].release_ref());
  args[0] = Val::i32(0);
  args[1] = Val::ref(host1.get()->copy());
  trap = table_set->call(args, nullptr);
  EXPECT_EQ(nullptr, trap);
  args[0] = Val::i32(1);
  args[1] = Val::ref(host2.get()->copy());
  trap = table_set->call(args, nullptr);
  EXPECT_EQ(nullptr, trap);
  args[0] = Val::i32(0);
  trap = table_get->call(args, results);
  EXPECT_EQ(nullptr, trap);
  EXPECT_TRUE(results[0].release_ref()->same(host1.get()));
  args[0] = Val::i32(1);
  trap = table_get->call(args, results);
  EXPECT_EQ(nullptr, trap);
  EXPECT_TRUE(results[0].release_ref()->same(host2.get()));
  args[0] = Val::i32(0);
  args[1] = Val::ref(own<Ref>());
  trap = table_set->call(args, nullptr);
  EXPECT_EQ(nullptr, trap);
  trap = table_get->call(args, results);
  EXPECT_EQ(nullptr, trap);
  EXPECT_EQ(nullptr, results[0].release_ref());

  EXPECT_EQ(nullptr, table->get(2));
  table->set(2, host1.get());
  args[0] = Val::i32(2);
  trap = table_get->call(args, results);
  EXPECT_EQ(nullptr, trap);
  EXPECT_TRUE(results[0].release_ref()->same(host1.get()));
  EXPECT_TRUE(table->get(2)->same(host1.get()));

  // Interact with the Function.
  args[0] = Val::ref(own<Ref>());
  trap = func_call->call(args, results);
  EXPECT_EQ(nullptr, trap);
  EXPECT_EQ(nullptr, results[0].release_ref());
  args[0] = Val::ref(host1.get()->copy());
  trap = func_call->call(args, results);
  EXPECT_EQ(nullptr, trap);
  EXPECT_TRUE(results[0].release_ref()->same(host1.get()));
  args[0] = Val::ref(host2.get()->copy());
  trap = func_call->call(args, results);
  EXPECT_EQ(nullptr, trap);
  EXPECT_TRUE(results[0].release_ref()->same(host2.get()));
}

}  // namespace wasm
}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/wasm-api-tests/memory.cc                                                   0000664 0000000 0000000 00000010064 14746647661 0021522 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "test/wasm-api-tests/wasm-api-test.h"

namespace v8 {
namespace internal {
namespace wasm {

using ::wasm::Limits;
using ::wasm::MemoryType;

TEST_F(WasmCapiTest, Memory) {
  builder()->AddMemory(2, 3);
  builder()->AddExport(base::CStrVector("memory"), kExternalMemory, 0);

  ValueType i32_type[] = {kWasmI32, kWasmI32};
  FunctionSig return_i32(1, 0, i32_type);
  FunctionSig param_i32_return_i32(1, 1, i32_type);
  FunctionSig param_i32_i32(0, 2, i32_type);
  uint8_t size_code[] = {WASM_MEMORY_SIZE};
  AddExportedFunction(base::CStrVector("size"), size_code, sizeof(size_code),
                      &return_i32);
  uint8_t load_code[] = {WASM_LOAD_MEM(MachineType::Int8(), WASM_LOCAL_GET(0))};
  AddExportedFunction(base::CStrVector("load"), load_code, sizeof(load_code),
                      &param_i32_return_i32);
  uint8_t store_code[] = {WASM_STORE_MEM(MachineType::Int8(), WASM_LOCAL_GET(0),
                                         WASM_LOCAL_GET(1))};
  AddExportedFunction(base::CStrVector("store"), store_code, sizeof(store_code),
                      &param_i32_i32);

  uint8_t data[] = {0x1, 0x2, 0x3, 0x4};
  builder()->AddDataSegment(data, sizeof(data), 0x1000);

  Instantiate(nullptr);

  Memory* memory = GetExportedMemory(0);
  Func* size_func = GetExportedFunction(1);
  Func* load_func = GetExportedFunction(2);
  Func* store_func = GetExportedFunction(3);

  // Try cloning.
  EXPECT_TRUE(memory->copy()->same(memory));

  // Check initial state.
  EXPECT_EQ(2u, memory->size());
  EXPECT_EQ(0x20000u, memory->data_size());
  EXPECT_EQ(0, memory->data()[0]);
  EXPECT_EQ(1, memory->data()[0x1000]);
  EXPECT_EQ(4, memory->data()[0x1003]);
  Val args[2];
  Val result[1];
  // size == 2
  size_func->call(nullptr, result);
  EXPECT_EQ(2, result[0].i32());
  // load(0) == 0
  args[0] = Val::i32(0x0);
  load_func->call(args, result);
  EXPECT_EQ(0, result[0].i32());
  // load(0x1000) == 1
  args[0] = Val::i32(0x1000);
  load_func->call(args, result);
  EXPECT_EQ(1, result[0].i32());
  // load(0x1003) == 4
  args[0] = Val::i32(0x1003);
  load_func->call(args, result);
  EXPECT_EQ(4, result[0].i32());
  // load(0x1FFFF) == 0
  args[0] = Val::i32(0x1FFFF);
  load_func->call(args, result);
  EXPECT_EQ(0, result[0].i32());
  // load(0x20000) -> trap
  args[0] = Val::i32(0x20000);
  own<Trap> trap = load_func->call(args, result);
  EXPECT_NE(nullptr, trap.get());

  // Mutate memory.
  memory->data()[0x1003] = 5;
  args[0] = Val::i32(0x1002);
  args[1] = Val::i32(6);
  trap = store_func->call(args, nullptr);
  EXPECT_EQ(nullptr, trap.get());
  args[0] = Val::i32(0x20000);
  trap = store_func->call(args, nullptr);
  EXPECT_NE(nullptr, trap.get());
  EXPECT_EQ(6, memory->data()[0x1002]);
  EXPECT_EQ(5, memory->data()[0x1003]);
  args[0] = Val::i32(0x1002);
  load_func->call(args, result);
  EXPECT_EQ(6, result[0].i32());
  args[0] = Val::i32(0x1003);
  load_func->call(args, result);
  EXPECT_EQ(5, result[0].i32());

  // Grow memory.
  EXPECT_EQ(true, memory->grow(1));
  EXPECT_EQ(3u, memory->size());
  EXPECT_EQ(0x30000u, memory->data_size());
  args[0] = Val::i32(0x20000);
  trap = load_func->call(args, result);
  EXPECT_EQ(nullptr, trap.get());
  EXPECT_EQ(0, result[0].i32());
  trap = store_func->call(args, nullptr);
  EXPECT_EQ(nullptr, trap.get());
  args[0] = Val::i32(0x30000);
  trap = load_func->call(args, result);
  EXPECT_NE(nullptr, trap.get());
  trap = store_func->call(args, nullptr);
  EXPECT_NE(nullptr, trap.get());
  EXPECT_EQ(false, memory->grow(1));
  EXPECT_EQ(true, memory->grow(0));

  // Create standalone memory.
  // TODO(wasm): Once Wasm allows multiple memories, turn this into an import.
  own<MemoryType> mem_type = MemoryType::make(Limits(5, 5));
  own<Memory> memory2 = Memory::make(store(), mem_type.get());
  EXPECT_EQ(5u, memory2->size());
  EXPECT_EQ(false, memory2->grow(1));
  EXPECT_EQ(true, memory2->grow(0));
}

}  // namespace wasm
}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/wasm-api-tests/multi-return.cc                                             0000664 0000000 0000000 00000003534 14746647661 0022665 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "test/wasm-api-tests/wasm-api-test.h"

namespace v8 {
namespace internal {
namespace wasm {

using ::wasm::I32;
using ::wasm::I64;

namespace {

own<Trap> Callback(const Val args[], Val results[]) {
  results[0] = args[3].copy();
  results[1] = args[1].copy();
  results[2] = args[2].copy();
  results[3] = args[0].copy();
  return nullptr;
}

}  // namespace

TEST_F(WasmCapiTest, MultiReturn) {
  ValueType reps[] = {kWasmI32, kWasmI64, kWasmI64, kWasmI32,
                      kWasmI32, kWasmI64, kWasmI64, kWasmI32};
  FunctionSig sig(4, 4, reps);
  uint32_t func_index = builder()->AddImport(base::CStrVector("f"), &sig);
  uint8_t code[] = {WASM_CALL_FUNCTION(func_index, WASM_LOCAL_GET(0),
                                       WASM_LOCAL_GET(2), WASM_LOCAL_GET(1),
                                       WASM_LOCAL_GET(3))};
  AddExportedFunction(base::CStrVector("g"), code, sizeof(code), &sig);

  ownvec<ValType> types =
      ownvec<ValType>::make(ValType::make(I32), ValType::make(I64),
                            ValType::make(I64), ValType::make(I32));
  own<FuncType> func_type =
      FuncType::make(types.deep_copy(), types.deep_copy());
  own<Func> callback = Func::make(store(), func_type.get(), Callback);
  Extern* imports[] = {callback.get()};
  Instantiate(imports);

  Func* run_func = GetExportedFunction(0);
  Val args[] = {Val::i32(1), Val::i64(2), Val::i64(3), Val::i32(4)};
  Val results[4];
  own<Trap> trap = run_func->call(args, results);
  EXPECT_EQ(nullptr, trap);
  EXPECT_EQ(4, results[0].i32());
  EXPECT_EQ(3, results[1].i64());
  EXPECT_EQ(2, results[2].i64());
  EXPECT_EQ(1, results[3].i32());
}

}  // namespace wasm
}  // namespace internal
}  // namespace v8
                                                                                                                                                                    node-23.7.0/deps/v8/test/wasm-api-tests/reflect.cc                                                  0000664 0000000 0000000 00000007242 14746647661 0021642 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "test/wasm-api-tests/wasm-api-test.h"

#include "src/execution/isolate.h"
#include "src/heap/heap.h"
#include "src/wasm/c-api.h"

namespace v8 {
namespace internal {
namespace wasm {

using ::wasm::ExportType;
using ::wasm::GlobalType;
using ::wasm::MemoryType;
using ::wasm::TableType;

namespace {

const char* kFuncName = "func1";
const char* kGlobalName = "global2";
const char* kTableName = "table3";
const char* kMemoryName = "memory4";

void ExpectName(const char* expected, const ::wasm::Name& name) {
  size_t len = strlen(expected);
  EXPECT_EQ(len, name.size());
  EXPECT_EQ(0, strncmp(expected, name.get(), len));
}

}  // namespace

TEST_F(WasmCapiTest, Reflect) {
  // Create a module exporting a function, a global, a table, and a memory.
  uint8_t code[] = {WASM_UNREACHABLE};
  ValueType types[] = {kWasmI32, kWasmExternRef, kWasmI32,
                       kWasmI64, kWasmF32,       kWasmF64};
  FunctionSig sig(2, 4, types);
  AddExportedFunction(base::CStrVector(kFuncName), code, sizeof(code), &sig);

  builder()->AddExportedGlobal(kWasmF64, false, WasmInitExpr(0.0),
                               base::CStrVector(kGlobalName));

  builder()->AddTable(kWasmFuncRef, 12, 12);
  builder()->AddExport(base::CStrVector(kTableName), kExternalTable, 0);

  builder()->AddMemory(1);
  builder()->AddExport(base::CStrVector(kMemoryName), kExternalMemory, 0);

  Instantiate(nullptr);

  ownvec<ExportType> export_types = module()->exports();
  const ownvec<Extern>& exports = this->exports();
  EXPECT_EQ(exports.size(), export_types.size());
  EXPECT_EQ(4u, exports.size());
  for (size_t i = 0; i < exports.size(); i++) {
    ::wasm::ExternKind kind = exports[i]->kind();
    const ::wasm::ExternType* extern_type = export_types[i]->type();
    EXPECT_EQ(kind, extern_type->kind());
    if (kind == ::wasm::EXTERN_FUNC) {
      ExpectName(kFuncName, export_types[i]->name());
      const FuncType* type = extern_type->func();
      const ownvec<ValType>& params = type->params();
      EXPECT_EQ(4u, params.size());
      EXPECT_EQ(::wasm::I32, params[0]->kind());
      EXPECT_EQ(::wasm::I64, params[1]->kind());
      EXPECT_EQ(::wasm::F32, params[2]->kind());
      EXPECT_EQ(::wasm::F64, params[3]->kind());
      const ownvec<ValType>& results = type->results();
      EXPECT_EQ(2u, results.size());
      EXPECT_EQ(::wasm::I32, results[0]->kind());
      EXPECT_EQ(::wasm::ANYREF, results[1]->kind());

      const Func* func = exports[i]->func();
      EXPECT_EQ(4u, func->param_arity());
      EXPECT_EQ(2u, func->result_arity());

    } else if (kind == ::wasm::EXTERN_GLOBAL) {
      ExpectName(kGlobalName, export_types[i]->name());
      const GlobalType* type = extern_type->global();
      EXPECT_EQ(::wasm::F64, type->content()->kind());
      EXPECT_EQ(::wasm::CONST, type->mutability());

    } else if (kind == ::wasm::EXTERN_TABLE) {
      ExpectName(kTableName, export_types[i]->name());
      const TableType* type = extern_type->table();
      EXPECT_EQ(::wasm::FUNCREF, type->element()->kind());
      ::wasm::Limits limits = type->limits();
      EXPECT_EQ(12u, limits.min);
      EXPECT_EQ(12u, limits.max);

    } else if (kind == ::wasm::EXTERN_MEMORY) {
      ExpectName(kMemoryName, export_types[i]->name());
      const MemoryType* type = extern_type->memory();
      ::wasm::Limits limits = type->limits();
      EXPECT_EQ(1u, limits.min);
      EXPECT_EQ(std::numeric_limits<uint32_t>::max(), limits.max);

    } else {
      UNREACHABLE();
    }
  }
}

}  // namespace wasm
}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/wasm-api-tests/regressions.cc                                              0000664 0000000 0000000 00000001525 14746647661 0022557 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "test/wasm-api-tests/wasm-api-test.h"

namespace v8 {
namespace internal {
namespace wasm {

TEST_F(WasmCapiTest, Regressions) {
  FunctionSig sig(0, 0, nullptr);
  uint8_t code[] = {WASM_UNREACHABLE};
  WasmFunctionBuilder* start_func = builder()->AddFunction(&sig);
  start_func->EmitCode(code, static_cast<uint32_t>(sizeof(code)));
  start_func->Emit(kExprEnd);
  builder()->MarkStartFunction(start_func);
  builder()->AddImport(base::CStrVector("dummy"), &sig);

  // Ensure we can validate.
  bool valid = Validate();
  EXPECT_EQ(valid, true);

  // Ensure we can compile after validating.
  Compile();
}

}  // namespace wasm
}  // namespace internal
}  // namespace v8
                                                                                                                                                                           node-23.7.0/deps/v8/test/wasm-api-tests/run-all-wasm-api-tests.cc                                   0000664 0000000 0000000 00000001701 14746647661 0024436 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "include/v8-initialization.h"
#include "src/flags/flags.h"
#include "src/trap-handler/trap-handler.h"
#include "testing/gmock/include/gmock/gmock.h"
#include "testing/gtest/include/gtest/gtest.h"

int main(int argc, char** argv) {
  // Don't catch SEH exceptions and continue as the following tests might hang
  // in an broken environment on windows.
  GTEST_FLAG_SET(catch_exceptions, false);
  testing::InitGoogleMock(&argc, argv);
  v8::V8::SetFlagsFromCommandLine(&argc, argv, true);
  v8::V8::InitializeExternalStartupData(argv[0]);
  if (V8_TRAP_HANDLER_SUPPORTED) {
    constexpr bool kUseDefaultTrapHandler = true;
    if (!v8::V8::EnableWebAssemblyTrapHandler(kUseDefaultTrapHandler)) {
      FATAL("Could not register trap handler");
    }
  }

  return RUN_ALL_TESTS();
}
                                                               node-23.7.0/deps/v8/test/wasm-api-tests/serialize.cc                                                0000664 0000000 0000000 00000004746 14746647661 0022213 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "src/common/ptr-compr-inl.h"
#include "src/execution/isolate.h"
#include "src/wasm/c-api.h"
#include "test/wasm-api-tests/wasm-api-test.h"

namespace v8 {
namespace internal {
namespace wasm {

namespace {

bool g_callback_called;

own<Trap> Callback(const Val args[], Val results[]) {
  g_callback_called = true;
  return nullptr;
}

}  // namespace

TEST_F(WasmCapiTest, Serialize) {
  FunctionSig sig(0, 0, nullptr);
  uint32_t callback_index =
      builder()->AddImport(base::CStrVector("callback"), &sig);
  uint8_t code[] = {WASM_CALL_FUNCTION0(callback_index)};
  AddExportedFunction(base::CStrVector("run"), code, sizeof(code), &sig);
  Compile();

  vec<byte_t> serialized = module()->serialize();
  EXPECT_TRUE(serialized);  // Serialization succeeded.

  // We reset the module and collect it to make sure the NativeModuleCache does
  // not contain it anymore. Otherwise deserialization will not happen.
  ResetModule();
  {
    Isolate* isolate =
        reinterpret_cast<::wasm::StoreImpl*>(store())->i_isolate();
    // This method might be called on a thread that's not bound to any Isolate
    // and thus pointer compression schemes might have cage base value unset.
    // Ensure cage bases are initialized so that the V8 heap can be accessed.
    i::PtrComprCageAccessScope ptr_compr_cage_access_scope(isolate);
    Heap* heap = isolate->heap();
    heap->PreciseCollectAllGarbage(GCFlag::kForced,
                                   GarbageCollectionReason::kTesting);
    heap->PreciseCollectAllGarbage(GCFlag::kForced,
                                   GarbageCollectionReason::kTesting);
  }
  own<Module> deserialized = Module::deserialize(store(), serialized);

  // Try to serialize the module again. This can fail if deserialization does
  // not set up a clean state.
  deserialized->serialize();

  own<FuncType> callback_type =
      FuncType::make(ownvec<ValType>::make(), ownvec<ValType>::make());
  own<Func> callback = Func::make(store(), callback_type.get(), Callback);
  Extern* imports[] = {callback.get()};

  own<Instance> instance = Instance::make(store(), deserialized.get(), imports);
  ownvec<Extern> exports = instance->exports();
  Func* run = exports[0]->func();
  g_callback_called = false;
  run->call();
  EXPECT_TRUE(g_callback_called);
}

}  // namespace wasm
}  // namespace internal
}  // namespace v8
                          node-23.7.0/deps/v8/test/wasm-api-tests/startup-errors.cc                                           0000664 0000000 0000000 00000004235 14746647661 0023231 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "test/wasm-api-tests/wasm-api-test.h"

namespace v8 {
namespace internal {
namespace wasm {

namespace {

own<Trap> DummyCallback(const Val args[], Val results[]) { return nullptr; }

}  // namespace

TEST_F(WasmCapiTest, StartupErrors) {
  FunctionSig sig(0, 0, nullptr);
  uint8_t code[] = {WASM_UNREACHABLE};
  WasmFunctionBuilder* start_func = builder()->AddFunction(&sig);
  start_func->EmitCode(code, static_cast<uint32_t>(sizeof(code)));
  start_func->Emit(kExprEnd);
  builder()->MarkStartFunction(start_func);
  builder()->AddImport(base::CStrVector("dummy"), &sig);
  Compile();
  own<Trap> trap;

  // Try to make an Instance with non-matching imports.
  own<Func> bad_func = Func::make(store(), cpp_i_i_sig(), DummyCallback);
  Extern* bad_imports[] = {bad_func.get()};
  own<Instance> instance =
      Instance::make(store(), module(), bad_imports, &trap);
  EXPECT_EQ(nullptr, instance);
  EXPECT_NE(nullptr, trap);
  EXPECT_STREQ(
      "Uncaught LinkError: instantiation: Import #0 \"\" \"dummy\": "
      "imported function does not match the expected type",
      trap->message().get());
  EXPECT_EQ(nullptr, trap->origin());
  // Don't crash if there is no {trap}.
  instance = Instance::make(store(), module(), bad_imports, nullptr);
  EXPECT_EQ(nullptr, instance);

  // Try to make an instance with a {start} function that traps.
  own<FuncType> good_sig =
      FuncType::make(ownvec<ValType>::make(), ownvec<ValType>::make());
  own<Func> good_func = Func::make(store(), good_sig.get(), DummyCallback);
  Extern* good_imports[] = {good_func.get()};
  instance = Instance::make(store(), module(), good_imports, &trap);
  EXPECT_EQ(nullptr, instance);
  EXPECT_NE(nullptr, trap);
  EXPECT_STREQ("Uncaught RuntimeError: unreachable", trap->message().get());
  EXPECT_NE(nullptr, trap->origin());
  // Don't crash if there is no {trap}.
  instance = Instance::make(store(), module(), good_imports, nullptr);
  EXPECT_EQ(nullptr, instance);
}

}  // namespace wasm
}  // namespace internal
}  // namespace v8
                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/wasm-api-tests/table.cc                                                    0000664 0000000 0000000 00000007602 14746647661 0021305 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "test/wasm-api-tests/wasm-api-test.h"

namespace v8 {
namespace internal {
namespace wasm {

using ::wasm::FUNCREF;
using ::wasm::Limits;
using ::wasm::TableType;

namespace {

own<Trap> Negate(const Val args[], Val results[]) {
  results[0] = Val(-args[0].i32());
  return nullptr;
}

void ExpectTrap(const Func* func, int arg1, int arg2) {
  Val args[2] = {Val::i32(arg1), Val::i32(arg2)};
  Val results[1];
  own<Trap> trap = func->call(args, results);
  EXPECT_NE(nullptr, trap);
}

void ExpectResult(int expected, const Func* func, int arg1, int arg2) {
  Val args[2] = {Val::i32(arg1), Val::i32(arg2)};
  Val results[1];
  own<Trap> trap = func->call(args, results);
  EXPECT_EQ(nullptr, trap);
  EXPECT_EQ(expected, results[0].i32());
}

}  // namespace

TEST_F(WasmCapiTest, Table) {
  const uint32_t table_index = builder()->AddTable(kWasmFuncRef, 2, 10);
  builder()->AddExport(base::CStrVector("table"), kExternalTable, table_index);
  const uint32_t sig_i_i_index = builder()->AddSignature(wasm_i_i_sig(), true);
  ValueType reps[] = {kWasmI32, kWasmI32, kWasmI32};
  FunctionSig call_sig(1, 2, reps);
  uint8_t call_code[] = {
      WASM_CALL_INDIRECT(sig_i_i_index, WASM_LOCAL_GET(0), WASM_LOCAL_GET(1))};
  AddExportedFunction(base::CStrVector("call_indirect"), call_code,
                      sizeof(call_code), &call_sig);
  uint8_t f_code[] = {WASM_LOCAL_GET(0)};
  AddExportedFunction(base::CStrVector("f"), f_code, sizeof(f_code),
                      wasm_i_i_sig());
  uint8_t g_code[] = {WASM_I32V_1(42)};
  AddExportedFunction(base::CStrVector("g"), g_code, sizeof(g_code),
                      wasm_i_i_sig());
  // Set table[1] to {f}, which has function index 1.
  builder()->SetIndirectFunction(
      table_index, 1, 1,
      WasmModuleBuilder::WasmElemSegment::kRelativeToImports);

  Instantiate(nullptr);

  Table* table = GetExportedTable(0);
  Func* call_indirect = GetExportedFunction(1);
  Func* f = GetExportedFunction(2);
  Func* g = GetExportedFunction(3);
  own<Func> h = Func::make(store(), cpp_i_i_sig(), Negate);

  // Try cloning.
  EXPECT_TRUE(table->copy()->same(table));

  // Check initial table state.
  EXPECT_EQ(2u, table->size());
  EXPECT_EQ(nullptr, table->get(0));
  EXPECT_NE(nullptr, table->get(1));
  ExpectTrap(call_indirect, 0, 0);
  ExpectResult(7, call_indirect, 7, 1);
  ExpectTrap(call_indirect, 0, 2);

  // Mutate table.
  EXPECT_TRUE(table->set(0, g));
  EXPECT_TRUE(table->set(1, nullptr));
  EXPECT_FALSE(table->set(2, f));
  EXPECT_NE(nullptr, table->get(0));
  EXPECT_EQ(nullptr, table->get(1));
  ExpectResult(42, call_indirect, 7, 0);
  ExpectTrap(call_indirect, 0, 1);
  ExpectTrap(call_indirect, 0, 2);

  // Grow table.
  EXPECT_TRUE(table->grow(3));
  EXPECT_EQ(5u, table->size());
  EXPECT_TRUE(table->set(2, f));
  EXPECT_TRUE(table->set(3, h.get()));
  EXPECT_FALSE(table->set(5, nullptr));
  EXPECT_NE(nullptr, table->get(2));
  EXPECT_NE(nullptr, table->get(3));
  EXPECT_EQ(nullptr, table->get(4));
  ExpectResult(5, call_indirect, 5, 2);
  ExpectResult(-6, call_indirect, 6, 3);
  ExpectTrap(call_indirect, 0, 4);
  ExpectTrap(call_indirect, 0, 5);
  EXPECT_TRUE(table->grow(2, f));
  EXPECT_EQ(7u, table->size());
  EXPECT_NE(nullptr, table->get(5));
  EXPECT_NE(nullptr, table->get(6));
  EXPECT_FALSE(table->grow(5));
  EXPECT_TRUE(table->grow(3));
  EXPECT_TRUE(table->grow(0));

  // Create standalone table.
  // TODO(wasm+): Once Wasm allows multiple tables, turn this into import.
  own<TableType> tabletype =
      TableType::make(ValType::make(FUNCREF), Limits(5, 5));
  own<Table> table2 = Table::make(store(), tabletype.get());
  EXPECT_EQ(5u, table2->size());
  EXPECT_FALSE(table2->grow(1));
  EXPECT_TRUE(table2->grow(0));
}

}  // namespace wasm
}  // namespace internal
}  // namespace v8
                                                                                                                              node-23.7.0/deps/v8/test/wasm-api-tests/testcfg.py                                                  0000664 0000000 0000000 00000004205 14746647661 0021714 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2019 the V8 project authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import os

from testrunner.local import command
from testrunner.local import utils
from testrunner.local import testsuite
from testrunner.objects import testcase

SHELL = "wasm_api_tests"


class VariantsGenerator(testsuite.VariantsGenerator):
  def _get_variants(self, test):
    return self._standard_variant


class TestLoader(testsuite.TestLoader):
  def _list_test_filenames(self):
    output = None
    for i in range(3): # Try 3 times in case of errors.
      args = ['--gtest_list_tests'] + self.test_config.extra_flags
      cmd = self.ctx.command(
          cmd_prefix=self.test_config.command_prefix,
          shell=self.ctx.platform_shell(SHELL, args,
                                        self.test_config.shell_dir),
          args=args)
      output = cmd.execute()
      if output.exit_code == 0:
        break

      print("Test executable failed to list the tests (try %d).\n\nCmd:" % i)
      print(cmd)
      print("\nStdout:")
      print(output.stdout)
      print("\nStderr:")
      print(output.stderr)
      print("\nExit code: %d" % output.exit_code)
    else:
      raise Exception("Test executable failed to list the tests.")

    # TODO create an ExecutableTestLoader for refactoring this similar to
    # JSTestLoader.
    test_names = []
    test_case = ''
    for line in output.stdout.splitlines():
      test_desc = line.strip().split()[0]
      if test_desc.endswith('.'):
        test_case = test_desc
      elif test_case and test_desc:
        test_names.append(test_case + test_desc)

    return sorted(test_names)


class TestSuite(testsuite.TestSuite):
  def _test_loader_class(self):
    return TestLoader

  def _test_class(self):
    return TestCase

  def _variants_gen_class(self):
    return VariantsGenerator


class TestCase(testcase.TestCase):
  def _get_suite_flags(self):
    return (
        [f"--gtest_filter={self.name}"] +
        [f"--gtest_random_seed={self.random_seed}"] +
        ["--gtest_print_time=0"]
    )

  def get_shell(self):
    return SHELL
                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/wasm-api-tests/threads.cc                                                  0000664 0000000 0000000 00000006577 14746647661 0021662 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "test/wasm-api-tests/wasm-api-test.h"

#include <mutex>
#include <thread>

namespace v8 {
namespace internal {
namespace wasm {

using ::wasm::Shared;

namespace {

const int kNumThreads = 10;
const int kIterationsPerThread = 3;
int g_traces;

own<Trap> Callback(void* env, const Val args[], Val results[]) {
  std::lock_guard<std::mutex> lock(*reinterpret_cast<std::mutex*>(env));
  g_traces += args[0].i32();
  return nullptr;
}

void Main(Engine* engine, Shared<Module>* shared, std::mutex* mutex, int id) {
  own<Store> store = Store::make(engine);
  own<Module> module = Module::obtain(store.get(), shared);
  EXPECT_NE(nullptr, module.get());
  for (int i = 0; i < kIterationsPerThread; i++) {
    std::this_thread::sleep_for(std::chrono::microseconds(100));

    // Create imports.
    own<FuncType> func_type =
        FuncType::make(ownvec<ValType>::make(ValType::make(::wasm::I32)),
                       ownvec<ValType>::make());
    own<Func> func = Func::make(store.get(), func_type.get(), Callback, mutex);
    own<::wasm::GlobalType> global_type =
        ::wasm::GlobalType::make(ValType::make(::wasm::I32), ::wasm::CONST);
    own<Global> global =
        Global::make(store.get(), global_type.get(), Val::i32(id));

    // Instantiate and run.
    // With the current implementation of the WasmModuleBuilder, global
    // imports always come before function imports, regardless of the
    // order of builder()->Add*Import() calls below.
    Extern* imports[] = {global.get(), func.get()};
    own<Instance> instance = Instance::make(store.get(), module.get(), imports);
    ownvec<Extern> exports = instance->exports();
    Func* run_func = exports[0]->func();
    run_func->call();
  }
}

}  // namespace

TEST_F(WasmCapiTest, Threads) {
  // Create module.
  ValueType i32_type[] = {kWasmI32};
  FunctionSig param_i32(0, 1, i32_type);
  uint32_t callback_index =
      builder()->AddImport(base::CStrVector("callback"), &param_i32);
  uint32_t global_index =
      builder()->AddGlobalImport(base::CStrVector("id"), kWasmI32, false);

  uint8_t code[] = {
      WASM_CALL_FUNCTION(callback_index, WASM_GLOBAL_GET(global_index))};
  FunctionSig empty_sig(0, 0, nullptr);
  AddExportedFunction(base::CStrVector("run"), code, sizeof(code), &empty_sig);
  Compile();
  own<Shared<Module>> shared = module()->share();

  // Spawn threads.
  g_traces = 0;
  std::mutex mutex;
  std::thread threads[kNumThreads];
  for (int i = 0; i < kNumThreads; i++) {
    threads[i] = std::thread(Main, engine(), shared.get(), &mutex, i);
  }
  for (int i = 0; i < kNumThreads; i++) {
    threads[i].join();
  }
  // Each thread in each iteration adds its ID to {traces}, so in the end
  // we expect kIterationsPerThread * sum([0, ..., kNumThreads-1]).
  // Per Gauss:
  const int kExpected =
      kIterationsPerThread * (kNumThreads - 1) * kNumThreads / 2;
  EXPECT_EQ(kExpected, g_traces);
}

TEST_F(WasmCapiTest, MultiStoresOneThread) {
  // These Stores intentionally have overlapping, but non-nested lifetimes.
  own<Store> store1 = Store::make(engine());
  own<Store> store2 = Store::make(engine());
  own<Store> store3 = Store::make(engine());
  store1.reset();
  store2.reset();
  store3.reset();
}

}  // namespace wasm
}  // namespace internal
}  // namespace v8
                                                                                                                                 node-23.7.0/deps/v8/test/wasm-api-tests/traps.cc                                                    0000664 0000000 0000000 00000011752 14746647661 0021350 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "test/wasm-api-tests/wasm-api-test.h"

#include "src/execution/isolate.h"
#include "src/wasm/c-api.h"
#include "src/wasm/module-decoder.h"
#include "src/wasm/wasm-engine.h"

#include <iostream>

namespace v8 {
namespace internal {
namespace wasm {

using ::wasm::Frame;
using ::wasm::Message;

namespace {

own<Trap> FailCallback(void* env, const Val args[], Val results[]) {
  Store* store = reinterpret_cast<Store*>(env);
  Message message = Message::make(std::string("callback abort"));
  return Trap::make(store, message);
}

void ExpectMessage(const char* expected, const Message& message) {
  size_t len = strlen(expected);
  EXPECT_EQ(len, message.size());
  EXPECT_EQ(0, strncmp(expected, message.get(), len));
}

}  // namespace

TEST_F(WasmCapiTest, Traps) {
  ValueType i32_type[] = {kWasmI32};
  FunctionSig sig(1, 0, i32_type);
  uint32_t callback_index =
      builder()->AddImport(base::CStrVector("callback"), &sig);
  uint8_t code[] = {WASM_CALL_FUNCTION0(callback_index)};
  AddExportedFunction(base::CStrVector("callback"), code, sizeof(code), &sig);

  uint8_t code2[] = {WASM_CALL_FUNCTION0(3)};
  AddExportedFunction(base::CStrVector("unreachable"), code2, sizeof(code2),
                      &sig);
  // The first constant is a 4-byte dummy so that the {unreachable} trap
  // has a more interesting offset. This is called by code2.
  uint8_t code3[] = {WASM_I32V_3(0), WASM_UNREACHABLE, WASM_I32V_1(1)};
  AddFunction(code3, sizeof(code3), &sig);

  // Check that traps returned from a C callback are uncatchable in Wasm.
  uint8_t code4[] = {WASM_TRY_CATCH_ALL_T(
      kWasmI32, WASM_CALL_FUNCTION0(callback_index), WASM_I32V(42))};
  AddExportedFunction(base::CStrVector("uncatchable"), code4, sizeof(code4),
                      &sig);

  own<FuncType> func_type =
      FuncType::make(ownvec<ValType>::make(),
                     ownvec<ValType>::make(ValType::make(::wasm::I32)));
  own<Func> cpp_callback = Func::make(store(), func_type.get(), FailCallback,
                                      reinterpret_cast<void*>(store()));
  Extern* imports[] = {cpp_callback.get()};
  Instantiate(imports);

  // Use internal machinery to parse the module to find the function offsets.
  // This makes the test more robust than hardcoding them.
  ModuleResult result =
      DecodeWasmModule(WasmEnabledFeatures::All(), wire_bytes(), false,
                       ModuleOrigin::kWasmOrigin);
  ASSERT_TRUE(result.ok());
  const WasmFunction* func1 = &result.value()->functions[1];
  const WasmFunction* func2 = &result.value()->functions[2];
  const WasmFunction* func3 = &result.value()->functions[3];
  const uint32_t func1_offset = func1->code.offset();
  const uint32_t func2_offset = func2->code.offset();
  const uint32_t func3_offset = func3->code.offset();

  Func* cpp_trapping_func = GetExportedFunction(0);
  own<Trap> cpp_trap = cpp_trapping_func->call();
  EXPECT_NE(nullptr, cpp_trap.get());
  ExpectMessage("Uncaught Error: callback abort", cpp_trap->message());
  own<Frame> frame = cpp_trap->origin();
  EXPECT_TRUE(frame->instance()->same(instance()));
  EXPECT_EQ(1u, frame->func_index());
  EXPECT_EQ(1u, frame->func_offset());
  EXPECT_EQ(func1_offset + frame->func_offset(), frame->module_offset());
  ownvec<Frame> trace = cpp_trap->trace();
  EXPECT_EQ(1u, trace.size());
  frame.reset(trace[0].release());
  EXPECT_TRUE(frame->instance()->same(instance()));
  EXPECT_EQ(1u, frame->func_index());
  EXPECT_EQ(1u, frame->func_offset());
  EXPECT_EQ(func1_offset + frame->func_offset(), frame->module_offset());

  Func* wasm_trapping_func = GetExportedFunction(1);
  own<Trap> wasm_trap = wasm_trapping_func->call();
  EXPECT_NE(nullptr, wasm_trap.get());
  ExpectMessage("Uncaught RuntimeError: unreachable", wasm_trap->message());
  frame = wasm_trap->origin();
  EXPECT_TRUE(frame->instance()->same(instance()));
  EXPECT_EQ(3u, frame->func_index());
  EXPECT_EQ(5u, frame->func_offset());
  EXPECT_EQ(func3_offset + frame->func_offset(), frame->module_offset());
  trace = wasm_trap->trace();
  EXPECT_EQ(2u, trace.size());

  frame.reset(trace[0].release());
  EXPECT_TRUE(frame->instance()->same(instance()));
  EXPECT_EQ(3u, frame->func_index());
  EXPECT_EQ(5u, frame->func_offset());
  EXPECT_EQ(func3_offset + frame->func_offset(), frame->module_offset());

  frame.reset(trace[1].release());
  EXPECT_TRUE(frame->instance()->same(instance()));
  EXPECT_EQ(2u, frame->func_index());
  EXPECT_EQ(1u, frame->func_offset());
  EXPECT_EQ(func2_offset + frame->func_offset(), frame->module_offset());

  Func* wasm_uncatchable_func = GetExportedFunction(2);
  Val* args = nullptr;
  Val results[1] = {Val(3.14)};  // Sentinel value.
  own<Trap> uncatchable_trap = wasm_uncatchable_func->call(args, results);
  EXPECT_NE(nullptr, uncatchable_trap.get());
  EXPECT_EQ(::wasm::F64, results[0].kind());
}

}  // namespace wasm
}  // namespace internal
}  // namespace v8
                      node-23.7.0/deps/v8/test/wasm-api-tests/wasm-api-test.h                                             0000664 0000000 0000000 00000012601 14746647661 0022546 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef TEST_WASM_API_TESTS_WASM_API_TEST_H_
#define TEST_WASM_API_TESTS_WASM_API_TEST_H_

#include "src/wasm/wasm-module-builder.h"
#include "src/wasm/wasm-opcodes.h"
#include "src/zone/accounting-allocator.h"
#include "src/zone/zone.h"
#include "test/common/wasm/wasm-macro-gen.h"
#include "testing/gtest/include/gtest/gtest.h"
#include "third_party/wasm-api/wasm.hh"

namespace v8 {
namespace internal {
namespace wasm {

using ::wasm::Engine;
using ::wasm::Extern;
using ::wasm::Foreign;
using ::wasm::Func;
using ::wasm::FuncType;
using ::wasm::Global;
using ::wasm::Instance;
using ::wasm::Memory;
using ::wasm::Module;
using ::wasm::own;
using ::wasm::ownvec;
using ::wasm::Ref;
using ::wasm::Store;
using ::wasm::Table;
using ::wasm::Trap;
using ::wasm::Val;
using ::wasm::ValType;
using ::wasm::vec;

class WasmCapiTest : public ::testing::Test {
 public:
  WasmCapiTest()
      : Test(),
        engine_(Engine::make()),
        allocator_(std::make_unique<AccountingAllocator>()),
        zone_(std::make_unique<Zone>(allocator_.get(), ZONE_NAME)),
        wire_bytes_(zone_.get()),
        builder_(zone_->New<WasmModuleBuilder>(zone_.get())),
        exports_(ownvec<Extern>::make()),
        binary_(vec<byte_t>::make()),
        wasm_i_i_sig_(1, 1, wasm_i_i_sig_types_) {
    store_ = Store::make(engine_.get());
    cpp_i_i_sig_ =
        FuncType::make(ownvec<ValType>::make(ValType::make(::wasm::I32)),
                       ownvec<ValType>::make(ValType::make(::wasm::I32)));
  }

  bool Validate() {
    if (binary_.size() == 0) {
      builder_->WriteTo(&wire_bytes_);
      size_t size = wire_bytes_.end() - wire_bytes_.begin();
      binary_ = vec<byte_t>::make(
          size,
          reinterpret_cast<byte_t*>(const_cast<uint8_t*>(wire_bytes_.begin())));
    }

    return Module::validate(store_.get(), binary_);
  }

  void Compile() {
    if (binary_.size() == 0) {
      builder_->WriteTo(&wire_bytes_);
      size_t size = wire_bytes_.end() - wire_bytes_.begin();
      binary_ = vec<byte_t>::make(
          size,
          reinterpret_cast<byte_t*>(const_cast<uint8_t*>(wire_bytes_.begin())));
    }

    module_ = Module::make(store_.get(), binary_);
    DCHECK_NE(module_.get(), nullptr);
  }

  void Instantiate(Extern* imports[]) {
    Compile();
    instance_ = Instance::make(store_.get(), module_.get(), imports);
    DCHECK_NE(instance_.get(), nullptr);
    exports_ = instance_->exports();
  }

  void AddExportedFunction(base::Vector<const char> name, uint8_t code[],
                           size_t code_size, FunctionSig* sig) {
    WasmFunctionBuilder* fun = builder()->AddFunction(sig);
    fun->EmitCode(code, static_cast<uint32_t>(code_size));
    fun->Emit(kExprEnd);
    builder()->AddExport(name, fun);
  }

  void AddFunction(uint8_t code[], size_t code_size, FunctionSig* sig) {
    WasmFunctionBuilder* fun = builder()->AddFunction(sig);
    fun->EmitCode(code, static_cast<uint32_t>(code_size));
    fun->Emit(kExprEnd);
  }

  Func* GetExportedFunction(size_t index) {
    DCHECK_GT(exports_.size(), index);
    Extern* exported = exports_[index].get();
    DCHECK_EQ(exported->kind(), ::wasm::EXTERN_FUNC);
    Func* func = exported->func();
    DCHECK_NE(func, nullptr);
    return func;
  }

  Global* GetExportedGlobal(size_t index) {
    DCHECK_GT(exports_.size(), index);
    Extern* exported = exports_[index].get();
    DCHECK_EQ(exported->kind(), ::wasm::EXTERN_GLOBAL);
    Global* global = exported->global();
    DCHECK_NE(global, nullptr);
    return global;
  }

  Memory* GetExportedMemory(size_t index) {
    DCHECK_GT(exports_.size(), index);
    Extern* exported = exports_[index].get();
    DCHECK_EQ(exported->kind(), ::wasm::EXTERN_MEMORY);
    Memory* memory = exported->memory();
    DCHECK_NE(memory, nullptr);
    return memory;
  }

  Table* GetExportedTable(size_t index) {
    DCHECK_GT(exports_.size(), index);
    Extern* exported = exports_[index].get();
    DCHECK_EQ(exported->kind(), ::wasm::EXTERN_TABLE);
    Table* table = exported->table();
    DCHECK_NE(table, nullptr);
    return table;
  }

  void ResetModule() { module_.reset(); }

  void Shutdown() {
    exports_.reset();
    instance_.reset();
    module_.reset();
    store_.reset();
    builder_ = nullptr;
    zone_.reset();
    allocator_.reset();
    engine_.reset();
  }

  WasmModuleBuilder* builder() { return builder_; }
  Engine* engine() { return engine_.get(); }
  Store* store() { return store_.get(); }
  Module* module() { return module_.get(); }
  Instance* instance() { return instance_.get(); }
  const ownvec<Extern>& exports() { return exports_; }
  base::Vector<const uint8_t> wire_bytes() {
    return base::VectorOf(wire_bytes_);
  }

  FunctionSig* wasm_i_i_sig() { return &wasm_i_i_sig_; }
  FuncType* cpp_i_i_sig() { return cpp_i_i_sig_.get(); }

 private:
  own<Engine> engine_;
  own<AccountingAllocator> allocator_;
  own<Zone> zone_;
  ZoneBuffer wire_bytes_;
  WasmModuleBuilder* builder_;
  own<Store> store_;
  own<Module> module_;
  own<Instance> instance_;
  ownvec<Extern> exports_;
  vec<byte_t> binary_;
  own<FuncType> cpp_i_i_sig_;
  ValueType wasm_i_i_sig_types_[2] = {kWasmI32, kWasmI32};
  FunctionSig wasm_i_i_sig_;
};

}  // namespace wasm
}  // namespace internal
}  // namespace v8

#endif  // TEST_WASM_API_TESTS_WASM_API_TEST_H_
                                                                                                                               node-23.7.0/deps/v8/test/wasm-api-tests/wasm-api-tests.status                                       0000664 0000000 0000000 00000001450 14746647661 0024025 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2019 the V8 project authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

[

# TODO(v8:7777): Change this once wasm is supported in jitless mode.
['not has_webassembly or variant == jitless', {
  '*': [SKIP],
}],  # not has_webassembly or variant == jitless

################################################################################
['variant == stress_snapshot', {
  '*': [SKIP],  # only relevant for mjsunit tests.
}],

################################################################################
['third_party_heap', {
  # Requires a second isolate
  'WasmCapiTest.InstanceFinalization': [SKIP],
  'WasmCapiTest.MultiStoresOneThread': [SKIP],
  'WasmCapiTest.Threads': [SKIP],
}], # third_party_heap

]
                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/wasm-js/                                                                   0000775 0000000 0000000 00000000000 14746647661 0016405 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/test/wasm-js/BUILD.gn                                                           0000664 0000000 0000000 00000000514 14746647661 0017572 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2018 the V8 project authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

group("v8_wasm_js") {
  testonly = true

  data_deps = [
    "../..:d8",
    "../../tools:v8_testrunner",
  ]

  data = [
    "./",
    "../mjsunit/mjsunit.js",
  ]
}
                                                                                                                                                                                    node-23.7.0/deps/v8/test/wasm-js/OWNERS                                                             0000664 0000000 0000000 00000000033 14746647661 0017341 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        file:../../src/wasm/OWNERS
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/wasm-js/after.js                                                           0000664 0000000 0000000 00000000352 14746647661 0020044 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// Tell the test harness that we are done with all tests.
done();
                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/wasm-js/report.js                                                          0000664 0000000 0000000 00000002260 14746647661 0020256 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

function check_test_results(tests, status) {
  let failed_counter = 0;
  for (let test of tests) {
    const PASS = 0;
    const FAIL = 1;
    const TIMEOUT = 2;
    const NOTRUN = 3;
    const PRECONDITION_FAILED = 4;

      if (test.status !== PASS) {
        console.log();
        if (test.status === FAIL) {
          console.log("Test failed");
        } else if(test.status === TIMEOUT) {
          console.log("Timeout");
        } else if(test.status === NOTRUN) {
          console.log("Test did not run");
        } else if (test.status === PRECONDITION_FAILED) {
          console.log("Test precondition failed");
        } else {
          console.log("Unknown error code:", test.status);
        }
        console.log("Message:");
        console.log(test.message);
        console.log("Stack trace:");
        console.log(test.stack);
        failed_counter++;
      }
  }

  setTimeout(() => assertEquals(0, failed_counter));
}

add_completion_callback(check_test_results);
setup(() => {}, {'explicit_done': true});
                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/wasm-js/testcfg.py                                                         0000664 0000000 0000000 00000007131 14746647661 0020420 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2018 the V8 project authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import os
import re

from pathlib import Path

from testrunner.local import testsuite
from testrunner.objects import testcase

ANY_JS = ".any.js"
WPT_ROOT = "/wasm/jsapi/"
META_SCRIPT_REGEXP = re.compile(r"META:\s*script=(.*)")
META_TIMEOUT_REGEXP = re.compile(r"META:\s*timeout=(.*)")

proposal_flags = [
    {
        'name': 'js-types',
        'flags': ['--experimental-wasm-type-reflection']
    },
    {
        'name': 'tail-call',
        'flags': []
    },
    {
        'name': 'memory64',
        'flags': ['--experimental-wasm-memory64']
    },
    {
        'name': 'extended-const',
        'flags': []
    },
    {
        'name': 'function-references',
        'flags': []
    },
    {
        'name': 'gc',
        'flags': []
    },
    {
        'name': 'jspi',
        'flags': ['--experimental-wasm-jspi']
    },
]


class TestLoader(testsuite.JSTestLoader):
  @property
  def extensions(self):
    return [ANY_JS]


class TestSuite(testsuite.TestSuite):

  def __init__(self, ctx, *args, **kwargs):
    super(TestSuite, self).__init__(ctx, *args, **kwargs)
    self.mjsunit_js = self.root.parent / "mjsunit" /"mjsunit.js"
    self.test_root = self.root / "tests"
    self._test_loader.test_root = self.test_root

  def _test_loader_class(self):
    return TestLoader

  def _test_class(self):
    return TestCase

def get_proposal_identifier(proposal):
  return f"proposals/{proposal['name']}"

class TestCase(testcase.D8TestCase):
  def _get_timeout_param(self):
    source = self.get_source()
    timeout_params = META_TIMEOUT_REGEXP.findall(source)
    if not timeout_params:
      return None

    if timeout_params[0] in ["long"]:
      return timeout_params[0]
    else:
      print("unknown timeout param %s in %s%s"
            % (timeout_params[0], self.path, ANY_JS))
      return None

  def _get_files_params(self):
    files = [self.suite.mjsunit_js,
             self.suite.root / "third_party" / "testharness.js",
             self.suite.root / "testharness-additions.js",
             self.suite.root / "report.js"]

    source = self.get_source()
    current_dir = self._get_source_path().parent
    for script in META_SCRIPT_REGEXP.findall(source):
      if script.startswith(WPT_ROOT):
        # Matched an absolute path, strip the root and replace it with our
        # local root.
        found = False
        for proposal in proposal_flags:
          prop_path = get_proposal_identifier(proposal)
          if prop_path in current_dir.as_posix():
            found = True
            script = self.suite.test_root / prop_path / script[len(WPT_ROOT):]
        if 'wpt' in current_dir.as_posix():
          found = True
          script = self.suite.test_root / 'wpt' / script[len(WPT_ROOT):]
        if not found:
          script = self.suite.test_root / script[len(WPT_ROOT):]
      elif not Path(script).is_absolute():
        # Matched a relative path, prepend this test's directory.
        script = current_dir / script
      else:
        raise Exception(f"Unexpected absolute path for script: \"{script}\"");

      files.append(script)

    files.extend([self._get_source_path(), self.suite.root / "after.js"])
    return files

  def _get_source_flags(self):
    for proposal in proposal_flags:
      if get_proposal_identifier(proposal) in self.name:
        return proposal['flags']
    return ['--wasm-staging']

  def _get_source_path(self):
    # All tests are named `path/name.any.js`
    return self.suite.test_root / self.path_and_suffix(ANY_JS)
                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/wasm-js/testharness-additions.js                                           0000664 0000000 0000000 00000001370 14746647661 0023263 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

function assert_throws(code, func, description) {
  try {
    func();
  } catch (e) {
    assert_true(
        e.name === code.name,
        'expected exception ' + code.name + ', got ' + e.name);
    return;
  }
  assert_true(
      false, 'expected exception ' + code.name + ', no exception thrown');
}

function promise_rejects(test, expected, promise, description) {
  return promise
      .then(() => assert_unreached('Should have rejected: ' + description))
      .catch(function(e) {
        assert_throws(expected, function() {
          throw e;
        }, description);
      });
}
                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/wasm-js/tests.tar.gz.sha1                                                  0000664 0000000 0000000 00000000050 14746647661 0021524 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        98fb8d1f2e32e0602a704fa23daef28b8f5e8b76                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/wasm-js/third_party/                                                       0000775 0000000 0000000 00000000000 14746647661 0020736 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/test/wasm-js/third_party/LICENSE.testharness                                    0000664 0000000 0000000 00000002736 14746647661 0024315 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # The 3-Clause BSD License

Copyright 2019 web-platform-tests contributors

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                                  node-23.7.0/deps/v8/test/wasm-js/third_party/testharness.js                                         0000664 0000000 0000000 00000425214 14746647661 0023647 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*global self*/
/*jshint latedef: nofunc*/
/*
Distributed under both the W3C Test Suite License [1] and the W3C
3-clause BSD License [2]. To contribute to a W3C Test Suite, see the
policies and contribution forms [3].

[1] http://www.w3.org/Consortium/Legal/2008/04-testsuite-license
[2] http://www.w3.org/Consortium/Legal/2008/03-bsd-license
[3] http://www.w3.org/2004/10/27-testcases
*/

/* Documentation: https://web-platform-tests.org/writing-tests/testharness-api.html
 * (../docs/_writing-tests/testharness-api.md) */

(function (global_scope)
{
    var debug = false;
    // default timeout is 10 seconds, test can override if needed
    var settings = {
        output:true,
        harness_timeout:{
            "normal":10000,
            "long":60000
        },
        test_timeout:null,
        message_events: ["start", "test_state", "result", "completion"]
    };

    var xhtml_ns = "http://www.w3.org/1999/xhtml";

    /*
     * TestEnvironment is an abstraction for the environment in which the test
     * harness is used. Each implementation of a test environment has to provide
     * the following interface:
     *
     * interface TestEnvironment {
     *   // Invoked after the global 'tests' object has been created and it's
     *   // safe to call add_*_callback() to register event handlers.
     *   void on_tests_ready();
     *
     *   // Invoked after setup() has been called to notify the test environment
     *   // of changes to the test harness properties.
     *   void on_new_harness_properties(object properties);
     *
     *   // Should return a new unique default test name.
     *   DOMString next_default_test_name();
     *
     *   // Should return the test harness timeout duration in milliseconds.
     *   float test_timeout();
     * };
     */

    /*
     * A test environment with a DOM. The global object is 'window'. By default
     * test results are displayed in a table. Any parent windows receive
     * callbacks or messages via postMessage() when test events occur. See
     * apisample11.html and apisample12.html.
     */
    function WindowTestEnvironment() {
        this.name_counter = 0;
        this.window_cache = null;
        this.output_handler = null;
        this.all_loaded = false;
        var this_obj = this;
        this.message_events = [];
        this.dispatched_messages = [];

        this.message_functions = {
            start: [add_start_callback, remove_start_callback,
                    function (properties) {
                        this_obj._dispatch("start_callback", [properties],
                                           {type: "start", properties: properties});
                    }],

            test_state: [add_test_state_callback, remove_test_state_callback,
                         function(test) {
                             this_obj._dispatch("test_state_callback", [test],
                                                {type: "test_state",
                                                 test: test.structured_clone()});
                         }],
            result: [add_result_callback, remove_result_callback,
                     function (test) {
                         this_obj.output_handler.show_status();
                         this_obj._dispatch("result_callback", [test],
                                            {type: "result",
                                             test: test.structured_clone()});
                     }],
            completion: [add_completion_callback, remove_completion_callback,
                         function (tests, harness_status) {
                             var cloned_tests = map(tests, function(test) {
                                 return test.structured_clone();
                             });
                             this_obj._dispatch("completion_callback", [tests, harness_status],
                                                {type: "complete",
                                                 tests: cloned_tests,
                                                 status: harness_status.structured_clone()});
                         }]
        }

        on_event(window, 'load', function() {
            this_obj.all_loaded = true;
        });

        on_event(window, 'message', function(event) {
            if (event.data && event.data.type === "getmessages" && event.source) {
                // A window can post "getmessages" to receive a duplicate of every
                // message posted by this environment so far. This allows subscribers
                // from fetch_tests_from_window to 'catch up' to the current state of
                // this environment.
                for (var i = 0; i < this_obj.dispatched_messages.length; ++i)
                {
                    event.source.postMessage(this_obj.dispatched_messages[i], "*");
                }
            }
        });
    }

    WindowTestEnvironment.prototype._dispatch = function(selector, callback_args, message_arg) {
        this.dispatched_messages.push(message_arg);
        this._forEach_windows(
                function(w, same_origin) {
                    if (same_origin) {
                        try {
                            var has_selector = selector in w;
                        } catch(e) {
                            // If document.domain was set at some point same_origin can be
                            // wrong and the above will fail.
                            has_selector = false;
                        }
                        if (has_selector) {
                            try {
                                w[selector].apply(undefined, callback_args);
                            } catch (e) {
                                if (debug) {
                                    throw e;
                                }
                            }
                        }
                    }
                    if (supports_post_message(w) && w !== self) {
                        w.postMessage(message_arg, "*");
                    }
                });
    };

    WindowTestEnvironment.prototype._forEach_windows = function(callback) {
        // Iterate over the windows [self ... top, opener]. The callback is passed
        // two objects, the first one is the window object itself, the second one
        // is a boolean indicating whether or not it's on the same origin as the
        // current window.
        var cache = this.window_cache;
        if (!cache) {
            cache = [[self, true]];
            var w = self;
            var i = 0;
            var so;
            while (w != w.parent) {
                w = w.parent;
                so = is_same_origin(w);
                cache.push([w, so]);
                i++;
            }
            w = window.opener;
            if (w) {
                cache.push([w, is_same_origin(w)]);
            }
            this.window_cache = cache;
        }

        forEach(cache,
                function(a) {
                    callback.apply(null, a);
                });
    };

    WindowTestEnvironment.prototype.on_tests_ready = function() {
        var output = new Output();
        this.output_handler = output;

        var this_obj = this;

        add_start_callback(function (properties) {
            this_obj.output_handler.init(properties);
        });

        add_test_state_callback(function(test) {
            this_obj.output_handler.show_status();
        });

        add_result_callback(function (test) {
            this_obj.output_handler.show_status();
        });

        add_completion_callback(function (tests, harness_status) {
            this_obj.output_handler.show_results(tests, harness_status);
        });
        this.setup_messages(settings.message_events);
    };

    WindowTestEnvironment.prototype.setup_messages = function(new_events) {
        var this_obj = this;
        forEach(settings.message_events, function(x) {
            var current_dispatch = this_obj.message_events.indexOf(x) !== -1;
            var new_dispatch = new_events.indexOf(x) !== -1;
            if (!current_dispatch && new_dispatch) {
                this_obj.message_functions[x][0](this_obj.message_functions[x][2]);
            } else if (current_dispatch && !new_dispatch) {
                this_obj.message_functions[x][1](this_obj.message_functions[x][2]);
            }
        });
        this.message_events = new_events;
    }

    WindowTestEnvironment.prototype.next_default_test_name = function() {
        var suffix = this.name_counter > 0 ? " " + this.name_counter : "";
        this.name_counter++;
        return get_title() + suffix;
    };

    WindowTestEnvironment.prototype.on_new_harness_properties = function(properties) {
        this.output_handler.setup(properties);
        if (properties.hasOwnProperty("message_events")) {
            this.setup_messages(properties.message_events);
        }
    };

    WindowTestEnvironment.prototype.add_on_loaded_callback = function(callback) {
        on_event(window, 'load', callback);
    };

    WindowTestEnvironment.prototype.test_timeout = function() {
        var metas = document.getElementsByTagName("meta");
        for (var i = 0; i < metas.length; i++) {
            if (metas[i].name == "timeout") {
                if (metas[i].content == "long") {
                    return settings.harness_timeout.long;
                }
                break;
            }
        }
        return settings.harness_timeout.normal;
    };

    /*
     * Base TestEnvironment implementation for a generic web worker.
     *
     * Workers accumulate test results. One or more clients can connect and
     * retrieve results from a worker at any time.
     *
     * WorkerTestEnvironment supports communicating with a client via a
     * MessagePort.  The mechanism for determining the appropriate MessagePort
     * for communicating with a client depends on the type of worker and is
     * implemented by the various specializations of WorkerTestEnvironment
     * below.
     *
     * A client document using testharness can use fetch_tests_from_worker() to
     * retrieve results from a worker. See apisample16.html.
     */
    function WorkerTestEnvironment() {
        this.name_counter = 0;
        this.all_loaded = true;
        this.message_list = [];
        this.message_ports = [];
    }

    WorkerTestEnvironment.prototype._dispatch = function(message) {
        this.message_list.push(message);
        for (var i = 0; i < this.message_ports.length; ++i)
        {
            this.message_ports[i].postMessage(message);
        }
    };

    // The only requirement is that port has a postMessage() method. It doesn't
    // have to be an instance of a MessagePort, and often isn't.
    WorkerTestEnvironment.prototype._add_message_port = function(port) {
        this.message_ports.push(port);
        for (var i = 0; i < this.message_list.length; ++i)
        {
            port.postMessage(this.message_list[i]);
        }
    };

    WorkerTestEnvironment.prototype.next_default_test_name = function() {
        var suffix = this.name_counter > 0 ? " " + this.name_counter : "";
        this.name_counter++;
        return get_title() + suffix;
    };

    WorkerTestEnvironment.prototype.on_new_harness_properties = function() {};

    WorkerTestEnvironment.prototype.on_tests_ready = function() {
        var this_obj = this;
        add_start_callback(
                function(properties) {
                    this_obj._dispatch({
                        type: "start",
                        properties: properties,
                    });
                });
        add_test_state_callback(
                function(test) {
                    this_obj._dispatch({
                        type: "test_state",
                        test: test.structured_clone()
                    });
                });
        add_result_callback(
                function(test) {
                    this_obj._dispatch({
                        type: "result",
                        test: test.structured_clone()
                    });
                });
        add_completion_callback(
                function(tests, harness_status) {
                    this_obj._dispatch({
                        type: "complete",
                        tests: map(tests,
                            function(test) {
                                return test.structured_clone();
                            }),
                        status: harness_status.structured_clone()
                    });
                });
    };

    WorkerTestEnvironment.prototype.add_on_loaded_callback = function() {};

    WorkerTestEnvironment.prototype.test_timeout = function() {
        // Tests running in a worker don't have a default timeout. I.e. all
        // worker tests behave as if settings.explicit_timeout is true.
        return null;
    };

    /*
     * Dedicated web workers.
     * https://html.spec.whatwg.org/multipage/workers.html#dedicatedworkerglobalscope
     *
     * This class is used as the test_environment when testharness is running
     * inside a dedicated worker.
     */
    function DedicatedWorkerTestEnvironment() {
        WorkerTestEnvironment.call(this);
        // self is an instance of DedicatedWorkerGlobalScope which exposes
        // a postMessage() method for communicating via the message channel
        // established when the worker is created.
        this._add_message_port(self);
    }
    DedicatedWorkerTestEnvironment.prototype = Object.create(WorkerTestEnvironment.prototype);

    DedicatedWorkerTestEnvironment.prototype.on_tests_ready = function() {
        WorkerTestEnvironment.prototype.on_tests_ready.call(this);
        // In the absence of an onload notification, we a require dedicated
        // workers to explicitly signal when the tests are done.
        tests.wait_for_finish = true;
    };

    /*
     * Shared web workers.
     * https://html.spec.whatwg.org/multipage/workers.html#sharedworkerglobalscope
     *
     * This class is used as the test_environment when testharness is running
     * inside a shared web worker.
     */
    function SharedWorkerTestEnvironment() {
        WorkerTestEnvironment.call(this);
        var this_obj = this;
        // Shared workers receive message ports via the 'onconnect' event for
        // each connection.
        self.addEventListener("connect",
                function(message_event) {
                    this_obj._add_message_port(message_event.source);
                }, false);
    }
    SharedWorkerTestEnvironment.prototype = Object.create(WorkerTestEnvironment.prototype);

    SharedWorkerTestEnvironment.prototype.on_tests_ready = function() {
        WorkerTestEnvironment.prototype.on_tests_ready.call(this);
        // In the absence of an onload notification, we a require shared
        // workers to explicitly signal when the tests are done.
        tests.wait_for_finish = true;
    };

    /*
     * Service workers.
     * http://www.w3.org/TR/service-workers/
     *
     * This class is used as the test_environment when testharness is running
     * inside a service worker.
     */
    function ServiceWorkerTestEnvironment() {
        WorkerTestEnvironment.call(this);
        this.all_loaded = false;
        this.on_loaded_callback = null;
        var this_obj = this;
        self.addEventListener("message",
                function(event) {
                    if (event.data && event.data.type && event.data.type === "connect") {
                        this_obj._add_message_port(event.source);
                    }
                }, false);

        // The oninstall event is received after the service worker script and
        // all imported scripts have been fetched and executed. It's the
        // equivalent of an onload event for a document. All tests should have
        // been added by the time this event is received, thus it's not
        // necessary to wait until the onactivate event. However, tests for
        // installed service workers need another event which is equivalent to
        // the onload event because oninstall is fired only on installation. The
        // onmessage event is used for that purpose since tests using
        // testharness.js should ask the result to its service worker by
        // PostMessage. If the onmessage event is triggered on the service
        // worker's context, that means the worker's script has been evaluated.
        on_event(self, "install", on_all_loaded);
        on_event(self, "message", on_all_loaded);
        function on_all_loaded() {
            if (this_obj.all_loaded)
                return;
            this_obj.all_loaded = true;
            if (this_obj.on_loaded_callback) {
              this_obj.on_loaded_callback();
            }
        }
    }

    ServiceWorkerTestEnvironment.prototype = Object.create(WorkerTestEnvironment.prototype);

    ServiceWorkerTestEnvironment.prototype.add_on_loaded_callback = function(callback) {
        if (this.all_loaded) {
            callback();
        } else {
            this.on_loaded_callback = callback;
        }
    };

    /*
     * JavaScript shells.
     *
     * This class is used as the test_environment when testharness is running
     * inside a JavaScript shell.
     */
    function ShellTestEnvironment() {
        this.name_counter = 0;
        this.all_loaded = false;
        this.on_loaded_callback = null;
        Promise.resolve().then(function() {
            this.all_loaded = true
            if (this.on_loaded_callback) {
                this.on_loaded_callback();
            }
        }.bind(this));
        this.message_list = [];
        this.message_ports = [];
    }

    ShellTestEnvironment.prototype.next_default_test_name = function() {
        var suffix = this.name_counter > 0 ? " " + this.name_counter : "";
        this.name_counter++;
        return "Untitled" + suffix;
    };

    ShellTestEnvironment.prototype.on_new_harness_properties = function() {};

    ShellTestEnvironment.prototype.on_tests_ready = function() {};

    ShellTestEnvironment.prototype.add_on_loaded_callback = function(callback) {
        if (this.all_loaded) {
            callback();
        } else {
            this.on_loaded_callback = callback;
        }
    };

    ShellTestEnvironment.prototype.test_timeout = function() {
        // Tests running in a shell don't have a default timeout, so behave as
        // if settings.explicit_timeout is true.
        return null;
    };

    function create_test_environment() {
        if ('document' in global_scope) {
            return new WindowTestEnvironment();
        }
        if ('DedicatedWorkerGlobalScope' in global_scope &&
            global_scope instanceof DedicatedWorkerGlobalScope) {
            return new DedicatedWorkerTestEnvironment();
        }
        if ('SharedWorkerGlobalScope' in global_scope &&
            global_scope instanceof SharedWorkerGlobalScope) {
            return new SharedWorkerTestEnvironment();
        }
        if ('ServiceWorkerGlobalScope' in global_scope &&
            global_scope instanceof ServiceWorkerGlobalScope) {
            return new ServiceWorkerTestEnvironment();
        }
        if ('WorkerGlobalScope' in global_scope &&
            global_scope instanceof WorkerGlobalScope) {
            return new DedicatedWorkerTestEnvironment();
        }

        if (!('location' in global_scope)) {
            return new ShellTestEnvironment();
        }

        throw new Error("Unsupported test environment");
    }

    var test_environment = create_test_environment();

    function is_shared_worker(worker) {
        return 'SharedWorker' in global_scope && worker instanceof SharedWorker;
    }

    function is_service_worker(worker) {
        // The worker object may be from another execution context,
        // so do not use instanceof here.
        return 'ServiceWorker' in global_scope &&
            Object.prototype.toString.call(worker) == '[object ServiceWorker]';
    }

    /*
     * API functions
     */
    function test(func, name, properties)
    {
        if (tests.promise_setup_called) {
            tests.status.status = tests.status.ERROR;
            tests.status.message = '`test` invoked after `promise_setup`';
            tests.complete();
        }
        var test_name = name ? name : test_environment.next_default_test_name();
        var test_obj = new Test(test_name, properties);
        var value = test_obj.step(func, test_obj, test_obj);

        if (value !== undefined) {
            var msg = "Test named \"" + test_name +
                "\" inappropriately returned a value";

            try {
                if (value && value.hasOwnProperty("then")) {
                    msg += ", consider using `promise_test` instead";
                }
            } catch (err) {}

            tests.status.status = tests.status.ERROR;
            tests.status.message = msg;
        }

        if (test_obj.phase === test_obj.phases.STARTED) {
            test_obj.done();
        }
    }

    function async_test(func, name, properties)
    {
        if (tests.promise_setup_called) {
            tests.status.status = tests.status.ERROR;
            tests.status.message = '`async_test` invoked after `promise_setup`';
            tests.complete();
        }
        if (typeof func !== "function") {
            properties = name;
            name = func;
            func = null;
        }
        var test_name = name ? name : test_environment.next_default_test_name();
        var test_obj = new Test(test_name, properties);
        if (func) {
            test_obj.step(func, test_obj, test_obj);
        }
        return test_obj;
    }

    function promise_test(func, name, properties) {
        if (typeof func !== "function") {
            properties = name;
            name = func;
            func = null;
        }
        var test_name = name ? name : test_environment.next_default_test_name();
        var test = new Test(test_name, properties);
        test._is_promise_test = true;

        // If there is no promise tests queue make one.
        if (!tests.promise_tests) {
            tests.promise_tests = Promise.resolve();
        }
        tests.promise_tests = tests.promise_tests.then(function() {
            return new Promise(function(resolve) {
                var promise = test.step(func, test, test);

                test.step(function() {
                    assert(!!promise, "promise_test", null,
                           "test body must return a 'thenable' object (received ${value})",
                           {value:promise});
                    assert(typeof promise.then === "function", "promise_test", null,
                           "test body must return a 'thenable' object (received an object with no `then` method)",
                           null);
                });

                // Test authors may use the `step` method within a
                // `promise_test` even though this reflects a mixture of
                // asynchronous control flow paradigms. The "done" callback
                // should be registered prior to the resolution of the
                // user-provided Promise to avoid timeouts in cases where the
                // Promise does not settle but a `step` function has thrown an
                // error.
                add_test_done_callback(test, resolve);

                Promise.resolve(promise)
                    .catch(test.step_func(
                        function(value) {
                            if (value instanceof AssertionError) {
                                throw value;
                            }
                            assert(false, "promise_test", null,
                                   "Unhandled rejection with value: ${value}", {value:value});
                        }))
                    .then(function() {
                        test.done();
                    });
                });
        });
    }

    /**
     * Make a copy of a Promise in the current realm.
     *
     * @param {Promise} promise the given promise that may be from a different
     *                          realm
     * @returns {Promise}
     *
     * An arbitrary promise provided by the caller may have originated in
     * another frame that have since navigated away, rendering the frame's
     * document inactive. Such a promise cannot be used with `await` or
     * Promise.resolve(), as microtasks associated with it may be prevented
     * from being run. See https://github.com/whatwg/html/issues/5319 for a
     * particular case.
     *
     * In functions we define here, there is an expectation from the caller
     * that the promise is from the current realm, that can always be used with
     * `await`, etc. We therefore create a new promise in this realm that
     * inherit the value and status from the given promise.
     */

    function bring_promise_to_current_realm(promise) {
        return new Promise(promise.then.bind(promise));
    }

    function promise_rejects_js(test, constructor, promise, description) {
        return bring_promise_to_current_realm(promise)
            .then(test.unreached_func("Should have rejected: " + description))
            .catch(function(e) {
                assert_throws_js_impl(constructor, function() { throw e },
                                      description, "promise_rejects_js");
            });
    }

    /**
     * Assert that a Promise is rejected with the right DOMException.
     *
     * @param test the test argument passed to promise_test
     * @param {number|string} type.  See documentation for assert_throws_dom.
     *
     * For the remaining arguments, there are two ways of calling
     * promise_rejects_dom:
     *
     * 1) If the DOMException is expected to come from the current global, the
     * third argument should be the promise expected to reject, and a fourth,
     * optional, argument is the assertion description.
     *
     * 2) If the DOMException is expected to come from some other global, the
     * third argument should be the DOMException constructor from that global,
     * the fourth argument the promise expected to reject, and the fifth,
     * optional, argument the assertion description.
     */

    function promise_rejects_dom(test, type, promiseOrConstructor, descriptionOrPromise, maybeDescription) {
        let constructor, promise, description;
        if (typeof promiseOrConstructor === "function" &&
            promiseOrConstructor.name === "DOMException") {
            constructor = promiseOrConstructor;
            promise = descriptionOrPromise;
            description = maybeDescription;
        } else {
            constructor = self.DOMException;
            promise = promiseOrConstructor;
            description = descriptionOrPromise;
            assert(maybeDescription === undefined,
                   "Too many args pased to no-constructor version of promise_rejects_dom");
        }
        return bring_promise_to_current_realm(promise)
            .then(test.unreached_func("Should have rejected: " + description))
            .catch(function(e) {
                assert_throws_dom_impl(type, function() { throw e }, description,
                                       "promise_rejects_dom", constructor);
            });
    }

    function promise_rejects_exactly(test, exception, promise, description) {
        return bring_promise_to_current_realm(promise)
            .then(test.unreached_func("Should have rejected: " + description))
            .catch(function(e) {
                assert_throws_exactly_impl(exception, function() { throw e },
                                           description, "promise_rejects_exactly");
            });
    }

    /**
     * This constructor helper allows DOM events to be handled using Promises,
     * which can make it a lot easier to test a very specific series of events,
     * including ensuring that unexpected events are not fired at any point.
     */
    function EventWatcher(test, watchedNode, eventTypes, timeoutPromise)
    {
        if (typeof eventTypes == 'string') {
            eventTypes = [eventTypes];
        }

        var waitingFor = null;

        // This is null unless we are recording all events, in which case it
        // will be an Array object.
        var recordedEvents = null;

        var eventHandler = test.step_func(function(evt) {
            assert_true(!!waitingFor,
                        'Not expecting event, but got ' + evt.type + ' event');
            assert_equals(evt.type, waitingFor.types[0],
                          'Expected ' + waitingFor.types[0] + ' event, but got ' +
                          evt.type + ' event instead');

            if (Array.isArray(recordedEvents)) {
                recordedEvents.push(evt);
            }

            if (waitingFor.types.length > 1) {
                // Pop first event from array
                waitingFor.types.shift();
                return;
            }
            // We need to null out waitingFor before calling the resolve function
            // since the Promise's resolve handlers may call wait_for() which will
            // need to set waitingFor.
            var resolveFunc = waitingFor.resolve;
            waitingFor = null;
            // Likewise, we should reset the state of recordedEvents.
            var result = recordedEvents || evt;
            recordedEvents = null;
            resolveFunc(result);
        });

        for (var i = 0; i < eventTypes.length; i++) {
            watchedNode.addEventListener(eventTypes[i], eventHandler, false);
        }

        /**
         * Returns a Promise that will resolve after the specified event or
         * series of events has occurred.
         *
         * @param options An optional options object. If the 'record' property
         *                on this object has the value 'all', when the Promise
         *                returned by this function is resolved,  *all* Event
         *                objects that were waited for will be returned as an
         *                array.
         *
         * For example,
         *
         * ```js
         * const watcher = new EventWatcher(t, div, [ 'animationstart',
         *                                            'animationiteration',
         *                                            'animationend' ]);
         * return watcher.wait_for([ 'animationstart', 'animationend' ],
         *                         { record: 'all' }).then(evts => {
         *   assert_equals(evts[0].elapsedTime, 0.0);
         *   assert_equals(evts[1].elapsedTime, 2.0);
         * });
         * ```
         */
        this.wait_for = function(types, options) {
            if (waitingFor) {
                return Promise.reject('Already waiting for an event or events');
            }
            if (typeof types == 'string') {
                types = [types];
            }
            if (options && options.record && options.record === 'all') {
                recordedEvents = [];
            }
            return new Promise(function(resolve, reject) {
                var timeout = test.step_func(function() {
                    // If the timeout fires after the events have been received
                    // or during a subsequent call to wait_for, ignore it.
                    if (!waitingFor || waitingFor.resolve !== resolve)
                        return;

                    // This should always fail, otherwise we should have
                    // resolved the promise.
                    assert_true(waitingFor.types.length == 0,
                                'Timed out waiting for ' + waitingFor.types.join(', '));
                    var result = recordedEvents;
                    recordedEvents = null;
                    var resolveFunc = waitingFor.resolve;
                    waitingFor = null;
                    resolveFunc(result);
                });

                if (timeoutPromise) {
                    timeoutPromise().then(timeout);
                }

                waitingFor = {
                    types: types,
                    resolve: resolve,
                    reject: reject
                };
            });
        };

        function stop_watching() {
            for (var i = 0; i < eventTypes.length; i++) {
                watchedNode.removeEventListener(eventTypes[i], eventHandler, false);
            }
        };

        test._add_cleanup(stop_watching);

        return this;
    }
    expose(EventWatcher, 'EventWatcher');

    function setup(func_or_properties, maybe_properties)
    {
        var func = null;
        var properties = {};
        if (arguments.length === 2) {
            func = func_or_properties;
            properties = maybe_properties;
        } else if (func_or_properties instanceof Function) {
            func = func_or_properties;
        } else {
            properties = func_or_properties;
        }
        tests.setup(func, properties);
        test_environment.on_new_harness_properties(properties);
    }

    function promise_setup(func, maybe_properties)
    {
        if (typeof func !== "function") {
            tests.set_status(tests.status.ERROR,
                             "promise_test invoked without a function");
            tests.complete();
            return;
        }
        tests.promise_setup_called = true;

        if (!tests.promise_tests) {
            tests.promise_tests = Promise.resolve();
        }

        tests.promise_tests = tests.promise_tests
            .then(function()
                  {
                      var properties = maybe_properties || {};
                      var result;

                      tests.setup(null, properties);
                      result = func();
                      test_environment.on_new_harness_properties(properties);

                      if (!result || typeof result.then !== "function") {
                          throw "Non-thenable returned by function passed to `promise_setup`";
                      }
                      return result;
                  })
            .catch(function(e)
                   {
                       tests.set_status(tests.status.ERROR,
                                        String(e),
                                        e && e.stack);
                       tests.complete();
                   });
    }

    function done() {
        if (tests.tests.length === 0) {
            // `done` is invoked after handling uncaught exceptions, so if the
            // harness status is already set, the corresponding message is more
            // descriptive than the generic message defined here.
            if (tests.status.status === null) {
                tests.status.status = tests.status.ERROR;
                tests.status.message = "done() was called without first defining any tests";
            }

            tests.complete();
            return;
        }
        if (tests.file_is_test) {
            // file is test files never have asynchronous cleanup logic,
            // meaning the fully-synchronous `done` function can be used here.
            tests.tests[0].done();
        }
        tests.end_wait();
    }

    function generate_tests(func, args, properties) {
        forEach(args, function(x, i)
                {
                    var name = x[0];
                    test(function()
                         {
                             func.apply(this, x.slice(1));
                         },
                         name,
                         Array.isArray(properties) ? properties[i] : properties);
                });
    }

    /*
     * Register a function as a DOM event listener to the given object for the
     * event bubbling phase.
     *
     * This function was deprecated in November of 2019.
     */
    function on_event(object, event, callback)
    {
        object.addEventListener(event, callback, false);
    }

    function step_timeout(f, t) {
        var outer_this = this;
        var args = Array.prototype.slice.call(arguments, 2);
        return setTimeout(function() {
            f.apply(outer_this, args);
        }, t * tests.timeout_multiplier);
    }

    expose(test, 'test');
    expose(async_test, 'async_test');
    expose(promise_test, 'promise_test');
    expose(promise_rejects_js, 'promise_rejects_js');
    expose(promise_rejects_dom, 'promise_rejects_dom');
    expose(promise_rejects_exactly, 'promise_rejects_exactly');
    expose(generate_tests, 'generate_tests');
    expose(setup, 'setup');
    expose(promise_setup, 'promise_setup');
    expose(done, 'done');
    expose(on_event, 'on_event');
    expose(step_timeout, 'step_timeout');

    /*
     * Return a string truncated to the given length, with ... added at the end
     * if it was longer.
     */
    function truncate(s, len)
    {
        if (s.length > len) {
            return s.substring(0, len - 3) + "...";
        }
        return s;
    }

    /*
     * Return true if object is probably a Node object.
     */
    function is_node(object)
    {
        // I use duck-typing instead of instanceof, because
        // instanceof doesn't work if the node is from another window (like an
        // iframe's contentWindow):
        // http://www.w3.org/Bugs/Public/show_bug.cgi?id=12295
        try {
            var has_node_properties = ("nodeType" in object &&
                                       "nodeName" in object &&
                                       "nodeValue" in object &&
                                       "childNodes" in object);
        } catch (e) {
            // We're probably cross-origin, which means we aren't a node
            return false;
        }

        if (has_node_properties) {
            try {
                object.nodeType;
            } catch (e) {
                // The object is probably Node.prototype or another prototype
                // object that inherits from it, and not a Node instance.
                return false;
            }
            return true;
        }
        return false;
    }

    var replacements = {
        "0": "0",
        "1": "x01",
        "2": "x02",
        "3": "x03",
        "4": "x04",
        "5": "x05",
        "6": "x06",
        "7": "x07",
        "8": "b",
        "9": "t",
        "10": "n",
        "11": "v",
        "12": "f",
        "13": "r",
        "14": "x0e",
        "15": "x0f",
        "16": "x10",
        "17": "x11",
        "18": "x12",
        "19": "x13",
        "20": "x14",
        "21": "x15",
        "22": "x16",
        "23": "x17",
        "24": "x18",
        "25": "x19",
        "26": "x1a",
        "27": "x1b",
        "28": "x1c",
        "29": "x1d",
        "30": "x1e",
        "31": "x1f",
        "0xfffd": "ufffd",
        "0xfffe": "ufffe",
        "0xffff": "uffff",
    };

    /*
     * Convert a value to a nice, human-readable string
     */
    function format_value(val, seen)
    {
        if (!seen) {
            seen = [];
        }
        if (typeof val === "object" && val !== null) {
            if (seen.indexOf(val) >= 0) {
                return "[...]";
            }
            seen.push(val);
        }
        if (Array.isArray(val)) {
            let output = "[";
            if (val.beginEllipsis !== undefined) {
                output += "…, ";
            }
            output += val.map(function(x) {return format_value(x, seen);}).join(", ");
            if (val.endEllipsis !== undefined) {
                output += ", …";
            }
            return output + "]";
        }

        switch (typeof val) {
        case "string":
            val = val.replace(/\\/g, "\\\\");
            for (var p in replacements) {
                var replace = "\\" + replacements[p];
                val = val.replace(RegExp(String.fromCharCode(p), "g"), replace);
            }
            return '"' + val.replace(/"/g, '\\"') + '"';
        case "boolean":
        case "undefined":
            return String(val);
        case "number":
            // In JavaScript, -0 === 0 and String(-0) == "0", so we have to
            // special-case.
            if (val === -0 && 1/val === -Infinity) {
                return "-0";
            }
            return String(val);
        case "object":
            if (val === null) {
                return "null";
            }

            // Special-case Node objects, since those come up a lot in my tests.  I
            // ignore namespaces.
            if (is_node(val)) {
                switch (val.nodeType) {
                case Node.ELEMENT_NODE:
                    var ret = "<" + val.localName;
                    for (var i = 0; i < val.attributes.length; i++) {
                        ret += " " + val.attributes[i].name + '="' + val.attributes[i].value + '"';
                    }
                    ret += ">" + val.innerHTML + "</" + val.localName + ">";
                    return "Element node " + truncate(ret, 60);
                case Node.TEXT_NODE:
                    return 'Text node "' + truncate(val.data, 60) + '"';
                case Node.PROCESSING_INSTRUCTION_NODE:
                    return "ProcessingInstruction node with target " + format_value(truncate(val.target, 60)) + " and data " + format_value(truncate(val.data, 60));
                case Node.COMMENT_NODE:
                    return "Comment node <!--" + truncate(val.data, 60) + "-->";
                case Node.DOCUMENT_NODE:
                    return "Document node with " + val.childNodes.length + (val.childNodes.length == 1 ? " child" : " children");
                case Node.DOCUMENT_TYPE_NODE:
                    return "DocumentType node";
                case Node.DOCUMENT_FRAGMENT_NODE:
                    return "DocumentFragment node with " + val.childNodes.length + (val.childNodes.length == 1 ? " child" : " children");
                default:
                    return "Node object of unknown type";
                }
            }

        /* falls through */
        default:
            try {
                return typeof val + ' "' + truncate(String(val), 1000) + '"';
            } catch(e) {
                return ("[stringifying object threw " + String(e) +
                        " with type " + String(typeof e) + "]");
            }
        }
    }
    expose(format_value, "format_value");

    /*
     * Assertions
     */

    function assert_true(actual, description)
    {
        assert(actual === true, "assert_true", description,
                                "expected true got ${actual}", {actual:actual});
    }
    expose(assert_true, "assert_true");

    function assert_false(actual, description)
    {
        assert(actual === false, "assert_false", description,
                                 "expected false got ${actual}", {actual:actual});
    }
    expose(assert_false, "assert_false");

    function same_value(x, y) {
        if (y !== y) {
            //NaN case
            return x !== x;
        }
        if (x === 0 && y === 0) {
            //Distinguish +0 and -0
            return 1/x === 1/y;
        }
        return x === y;
    }

    function assert_equals(actual, expected, description)
    {
         /*
          * Test if two primitives are equal or two objects
          * are the same object
          */
        if (typeof actual != typeof expected) {
            assert(false, "assert_equals", description,
                          "expected (" + typeof expected + ") ${expected} but got (" + typeof actual + ") ${actual}",
                          {expected:expected, actual:actual});
            return;
        }
        assert(same_value(actual, expected), "assert_equals", description,
                                             "expected ${expected} but got ${actual}",
                                             {expected:expected, actual:actual});
    }
    expose(assert_equals, "assert_equals");

    function assert_not_equals(actual, expected, description)
    {
         /*
          * Test if two primitives are unequal or two objects
          * are different objects
          */
        assert(!same_value(actual, expected), "assert_not_equals", description,
                                              "got disallowed value ${actual}",
                                              {actual:actual});
    }
    expose(assert_not_equals, "assert_not_equals");

    function assert_in_array(actual, expected, description)
    {
        assert(expected.indexOf(actual) != -1, "assert_in_array", description,
                                               "value ${actual} not in array ${expected}",
                                               {actual:actual, expected:expected});
    }
    expose(assert_in_array, "assert_in_array");

    // This function was deprecated in July of 2015.
    // See https://github.com/web-platform-tests/wpt/issues/2033
    function assert_object_equals(actual, expected, description)
    {
         assert(typeof actual === "object" && actual !== null, "assert_object_equals", description,
                                                               "value is ${actual}, expected object",
                                                               {actual: actual});
         //This needs to be improved a great deal
         function check_equal(actual, expected, stack)
         {
             stack.push(actual);

             var p;
             for (p in actual) {
                 assert(expected.hasOwnProperty(p), "assert_object_equals", description,
                                                    "unexpected property ${p}", {p:p});

                 if (typeof actual[p] === "object" && actual[p] !== null) {
                     if (stack.indexOf(actual[p]) === -1) {
                         check_equal(actual[p], expected[p], stack);
                     }
                 } else {
                     assert(same_value(actual[p], expected[p]), "assert_object_equals", description,
                                                       "property ${p} expected ${expected} got ${actual}",
                                                       {p:p, expected:expected[p], actual:actual[p]});
                 }
             }
             for (p in expected) {
                 assert(actual.hasOwnProperty(p),
                        "assert_object_equals", description,
                        "expected property ${p} missing", {p:p});
             }
             stack.pop();
         }
         check_equal(actual, expected, []);
    }
    expose(assert_object_equals, "assert_object_equals");

    function assert_array_equals(actual, expected, description)
    {
        const max_array_length = 20;
        function shorten_array(arr, offset = 0) {
            // Make ", …" only show up when it would likely reduce the length, not accounting for
            // fonts.
            if (arr.length < max_array_length + 2) {
                return arr;
            }
            // By default we want half the elements after the offset and half before
            // But if that takes us past the end of the array, we have more before, and
            // if it takes us before the start we have more after.
            const length_after_offset = Math.floor(max_array_length / 2);
            let upper_bound = Math.min(length_after_offset + offset, arr.length);
            const lower_bound = Math.max(upper_bound - max_array_length, 0);

            if (lower_bound === 0) {
                upper_bound = max_array_length;
            }

            const output = arr.slice(lower_bound, upper_bound);
            if (lower_bound > 0) {
                output.beginEllipsis = true;
            }
            if (upper_bound < arr.length) {
                output.endEllipsis = true;
            }
            return output;
        }

        assert(typeof actual === "object" && actual !== null && "length" in actual,
               "assert_array_equals", description,
               "value is ${actual}, expected array",
               {actual:actual});
        assert(actual.length === expected.length,
               "assert_array_equals", description,
               "lengths differ, expected array ${expected} length ${expectedLength}, got ${actual} length ${actualLength}",
               {expected:shorten_array(expected, expected.length - 1), expectedLength:expected.length,
                actual:shorten_array(actual, actual.length - 1), actualLength:actual.length
               });

        for (var i = 0; i < actual.length; i++) {
            assert(actual.hasOwnProperty(i) === expected.hasOwnProperty(i),
                   "assert_array_equals", description,
                   "expected property ${i} to be ${expected} but was ${actual} (expected array ${arrayExpected} got ${arrayActual})",
                   {i:i, expected:expected.hasOwnProperty(i) ? "present" : "missing",
                    actual:actual.hasOwnProperty(i) ? "present" : "missing",
                    arrayExpected:shorten_array(expected, i), arrayActual:shorten_array(actual, i)});
            assert(same_value(expected[i], actual[i]),
                   "assert_array_equals", description,
                   "expected property ${i} to be ${expected} but got ${actual} (expected array ${arrayExpected} got ${arrayActual})",
                   {i:i, expected:expected[i], actual:actual[i],
                    arrayExpected:shorten_array(expected, i), arrayActual:shorten_array(actual, i)});
        }
    }
    expose(assert_array_equals, "assert_array_equals");

    function assert_array_approx_equals(actual, expected, epsilon, description)
    {
        /*
         * Test if two primitive arrays are equal within +/- epsilon
         */
        assert(actual.length === expected.length,
               "assert_array_approx_equals", description,
               "lengths differ, expected ${expected} got ${actual}",
               {expected:expected.length, actual:actual.length});

        for (var i = 0; i < actual.length; i++) {
            assert(actual.hasOwnProperty(i) === expected.hasOwnProperty(i),
                   "assert_array_approx_equals", description,
                   "property ${i}, property expected to be ${expected} but was ${actual}",
                   {i:i, expected:expected.hasOwnProperty(i) ? "present" : "missing",
                    actual:actual.hasOwnProperty(i) ? "present" : "missing"});
            assert(typeof actual[i] === "number",
                   "assert_array_approx_equals", description,
                   "property ${i}, expected a number but got a ${type_actual}",
                   {i:i, type_actual:typeof actual[i]});
            assert(Math.abs(actual[i] - expected[i]) <= epsilon,
                   "assert_array_approx_equals", description,
                   "property ${i}, expected ${expected} +/- ${epsilon}, expected ${expected} but got ${actual}",
                   {i:i, expected:expected[i], actual:actual[i], epsilon:epsilon});
        }
    }
    expose(assert_array_approx_equals, "assert_array_approx_equals");

    function assert_approx_equals(actual, expected, epsilon, description)
    {
        /*
         * Test if two primitive numbers are equal within +/- epsilon
         */
        assert(typeof actual === "number",
               "assert_approx_equals", description,
               "expected a number but got a ${type_actual}",
               {type_actual:typeof actual});

        assert(Math.abs(actual - expected) <= epsilon,
               "assert_approx_equals", description,
               "expected ${expected} +/- ${epsilon} but got ${actual}",
               {expected:expected, actual:actual, epsilon:epsilon});
    }
    expose(assert_approx_equals, "assert_approx_equals");

    function assert_less_than(actual, expected, description)
    {
        /*
         * Test if a primitive number is less than another
         */
        assert(typeof actual === "number",
               "assert_less_than", description,
               "expected a number but got a ${type_actual}",
               {type_actual:typeof actual});

        assert(actual < expected,
               "assert_less_than", description,
               "expected a number less than ${expected} but got ${actual}",
               {expected:expected, actual:actual});
    }
    expose(assert_less_than, "assert_less_than");

    function assert_greater_than(actual, expected, description)
    {
        /*
         * Test if a primitive number is greater than another
         */
        assert(typeof actual === "number",
               "assert_greater_than", description,
               "expected a number but got a ${type_actual}",
               {type_actual:typeof actual});

        assert(actual > expected,
               "assert_greater_than", description,
               "expected a number greater than ${expected} but got ${actual}",
               {expected:expected, actual:actual});
    }
    expose(assert_greater_than, "assert_greater_than");

    function assert_between_exclusive(actual, lower, upper, description)
    {
        /*
         * Test if a primitive number is between two others
         */
        assert(typeof actual === "number",
               "assert_between_exclusive", description,
               "expected a number but got a ${type_actual}",
               {type_actual:typeof actual});

        assert(actual > lower && actual < upper,
               "assert_between_exclusive", description,
               "expected a number greater than ${lower} " +
               "and less than ${upper} but got ${actual}",
               {lower:lower, upper:upper, actual:actual});
    }
    expose(assert_between_exclusive, "assert_between_exclusive");

    function assert_less_than_equal(actual, expected, description)
    {
        /*
         * Test if a primitive number is less than or equal to another
         */
        assert(typeof actual === "number",
               "assert_less_than_equal", description,
               "expected a number but got a ${type_actual}",
               {type_actual:typeof actual});

        assert(actual <= expected,
               "assert_less_than_equal", description,
               "expected a number less than or equal to ${expected} but got ${actual}",
               {expected:expected, actual:actual});
    }
    expose(assert_less_than_equal, "assert_less_than_equal");

    function assert_greater_than_equal(actual, expected, description)
    {
        /*
         * Test if a primitive number is greater than or equal to another
         */
        assert(typeof actual === "number",
               "assert_greater_than_equal", description,
               "expected a number but got a ${type_actual}",
               {type_actual:typeof actual});

        assert(actual >= expected,
               "assert_greater_than_equal", description,
               "expected a number greater than or equal to ${expected} but got ${actual}",
               {expected:expected, actual:actual});
    }
    expose(assert_greater_than_equal, "assert_greater_than_equal");

    function assert_between_inclusive(actual, lower, upper, description)
    {
        /*
         * Test if a primitive number is between to two others or equal to either of them
         */
        assert(typeof actual === "number",
               "assert_between_inclusive", description,
               "expected a number but got a ${type_actual}",
               {type_actual:typeof actual});

        assert(actual >= lower && actual <= upper,
               "assert_between_inclusive", description,
               "expected a number greater than or equal to ${lower} " +
               "and less than or equal to ${upper} but got ${actual}",
               {lower:lower, upper:upper, actual:actual});
    }
    expose(assert_between_inclusive, "assert_between_inclusive");

    function assert_regexp_match(actual, expected, description) {
        /*
         * Test if a string (actual) matches a regexp (expected)
         */
        assert(expected.test(actual),
               "assert_regexp_match", description,
               "expected ${expected} but got ${actual}",
               {expected:expected, actual:actual});
    }
    expose(assert_regexp_match, "assert_regexp_match");

    function assert_class_string(object, class_string, description) {
        var actual = {}.toString.call(object);
        var expected = "[object " + class_string + "]";
        assert(same_value(actual, expected), "assert_class_string", description,
                                             "expected ${expected} but got ${actual}",
                                             {expected:expected, actual:actual});
    }
    expose(assert_class_string, "assert_class_string");


    function assert_own_property(object, property_name, description) {
        assert(object.hasOwnProperty(property_name),
               "assert_own_property", description,
               "expected property ${p} missing", {p:property_name});
    }
    expose(assert_own_property, "assert_own_property");

    function assert_not_own_property(object, property_name, description) {
        assert(!object.hasOwnProperty(property_name),
               "assert_not_own_property", description,
               "unexpected property ${p} is found on object", {p:property_name});
    }
    expose(assert_not_own_property, "assert_not_own_property");

    function _assert_inherits(name) {
        return function (object, property_name, description)
        {
            assert(typeof object === "object" || typeof object === "function" ||
                   // Or has [[IsHTMLDDA]] slot
                   String(object) === "[object HTMLAllCollection]",
                   name, description,
                   "provided value is not an object");

            assert("hasOwnProperty" in object,
                   name, description,
                   "provided value is an object but has no hasOwnProperty method");

            assert(!object.hasOwnProperty(property_name),
                   name, description,
                   "property ${p} found on object expected in prototype chain",
                   {p:property_name});

            assert(property_name in object,
                   name, description,
                   "property ${p} not found in prototype chain",
                   {p:property_name});
        };
    }
    expose(_assert_inherits("assert_inherits"), "assert_inherits");
    expose(_assert_inherits("assert_idl_attribute"), "assert_idl_attribute");

    function assert_readonly(object, property_name, description)
    {
         var initial_value = object[property_name];
         try {
             //Note that this can have side effects in the case where
             //the property has PutForwards
             object[property_name] = initial_value + "a"; //XXX use some other value here?
             assert(same_value(object[property_name], initial_value),
                    "assert_readonly", description,
                    "changing property ${p} succeeded",
                    {p:property_name});
         } finally {
             object[property_name] = initial_value;
         }
    }
    expose(assert_readonly, "assert_readonly");

    /**
     * Assert a JS Error with the expected constructor is thrown.
     *
     * @param {object} constructor The expected exception constructor.
     * @param {Function} func Function which should throw.
     * @param {string} description Error description for the case that the error is not thrown.
     */
    function assert_throws_js(constructor, func, description)
    {
        assert_throws_js_impl(constructor, func, description,
                              "assert_throws_js");
    }
    expose(assert_throws_js, "assert_throws_js");

    /**
     * Like assert_throws_js but allows specifying the assertion type
     * (assert_throws_js or promise_rejects_js, in practice).
     */
    function assert_throws_js_impl(constructor, func, description,
                                   assertion_type)
    {
        try {
            func.call(this);
            assert(false, assertion_type, description,
                   "${func} did not throw", {func:func});
        } catch (e) {
            if (e instanceof AssertionError) {
                throw e;
            }

            // Basic sanity-checks on the thrown exception.
            assert(typeof e === "object",
                   assertion_type, description,
                   "${func} threw ${e} with type ${type}, not an object",
                   {func:func, e:e, type:typeof e});

            assert(e !== null,
                   assertion_type, description,
                   "${func} threw null, not an object",
                   {func:func});

            // Basic sanity-check on the passed-in constructor
            assert(typeof constructor == "function",
                   assertion_type, description,
                   "${constructor} is not a constructor",
                   {constructor:constructor});
            var obj = constructor;
            while (obj) {
                if (typeof obj === "function" &&
                    obj.name === "Error") {
                    break;
                }
                obj = Object.getPrototypeOf(obj);
            }
            assert(obj != null,
                   assertion_type, description,
                   "${constructor} is not an Error subtype",
                   {constructor:constructor});

            // And checking that our exception is reasonable
            assert(e.constructor === constructor &&
                   e.name === constructor.name,
                   assertion_type, description,
                   "${func} threw ${actual} (${actual_name}) expected instance of ${expected} (${expected_name})",
                   {func:func, actual:e, actual_name:e.name,
                    expected:constructor,
                    expected_name:constructor.name});
        }
    }

    /**
     * Assert a DOMException with the expected type is thrown.
     *
     * @param {number|string} type The expected exception name or code.  See the
     *        table of names and codes at
     *        https://heycam.github.io/webidl/#dfn-error-names-table
     *        If a number is passed it should be one of the numeric code values
     *        in that table (e.g. 3, 4, etc).  If a string is passed it can
     *        either be an exception name (e.g. "HierarchyRequestError",
     *        "WrongDocumentError") or the name of the corresponding error code
     *        (e.g. "HIERARCHY_REQUEST_ERR", "WRONG_DOCUMENT_ERR").
     *
     * For the remaining arguments, there are two ways of calling
     * promise_rejects_dom:
     *
     * 1) If the DOMException is expected to come from the current global, the
     * second argument should be the function expected to throw and a third,
     * optional, argument is the assertion description.
     *
     * 2) If the DOMException is expected to come from some other global, the
     * second argument should be the DOMException constructor from that global,
     * the third argument the function expected to throw, and the fourth, optional,
     * argument the assertion description.
     */
    function assert_throws_dom(type, funcOrConstructor, descriptionOrFunc, maybeDescription)
    {
        let constructor, func, description;
        if (funcOrConstructor.name === "DOMException") {
            constructor = funcOrConstructor;
            func = descriptionOrFunc;
            description = maybeDescription;
        } else {
            constructor = self.DOMException;
            func = funcOrConstructor;
            description = descriptionOrFunc;
            assert(maybeDescription === undefined,
                   "Too many args pased to no-constructor version of assert_throws_dom");
        }
        assert_throws_dom_impl(type, func, description, "assert_throws_dom", constructor)
    }
    expose(assert_throws_dom, "assert_throws_dom");

    /**
     * Similar to assert_throws_dom but allows specifying the assertion type
     * (assert_throws_dom or promise_rejects_dom, in practice).  The
     * "constructor" argument must be the DOMException constructor from the
     * global we expect the exception to come from.
     */
    function assert_throws_dom_impl(type, func, description, assertion_type, constructor)
    {
        try {
            func.call(this);
            assert(false, assertion_type, description,
                   "${func} did not throw", {func:func});
        } catch (e) {
            if (e instanceof AssertionError) {
                throw e;
            }

            // Basic sanity-checks on the thrown exception.
            assert(typeof e === "object",
                   assertion_type, description,
                   "${func} threw ${e} with type ${type}, not an object",
                   {func:func, e:e, type:typeof e});

            assert(e !== null,
                   assertion_type, description,
                   "${func} threw null, not an object",
                   {func:func});

            // Sanity-check our type
            assert(typeof type == "number" ||
                   typeof type == "string",
                   assertion_type, description,
                   "${type} is not a number or string",
                   {type:type});

            var codename_name_map = {
                INDEX_SIZE_ERR: 'IndexSizeError',
                HIERARCHY_REQUEST_ERR: 'HierarchyRequestError',
                WRONG_DOCUMENT_ERR: 'WrongDocumentError',
                INVALID_CHARACTER_ERR: 'InvalidCharacterError',
                NO_MODIFICATION_ALLOWED_ERR: 'NoModificationAllowedError',
                NOT_FOUND_ERR: 'NotFoundError',
                NOT_SUPPORTED_ERR: 'NotSupportedError',
                INUSE_ATTRIBUTE_ERR: 'InUseAttributeError',
                INVALID_STATE_ERR: 'InvalidStateError',
                SYNTAX_ERR: 'SyntaxError',
                INVALID_MODIFICATION_ERR: 'InvalidModificationError',
                NAMESPACE_ERR: 'NamespaceError',
                INVALID_ACCESS_ERR: 'InvalidAccessError',
                TYPE_MISMATCH_ERR: 'TypeMismatchError',
                SECURITY_ERR: 'SecurityError',
                NETWORK_ERR: 'NetworkError',
                ABORT_ERR: 'AbortError',
                URL_MISMATCH_ERR: 'URLMismatchError',
                QUOTA_EXCEEDED_ERR: 'QuotaExceededError',
                TIMEOUT_ERR: 'TimeoutError',
                INVALID_NODE_TYPE_ERR: 'InvalidNodeTypeError',
                DATA_CLONE_ERR: 'DataCloneError'
            };

            var name_code_map = {
                IndexSizeError: 1,
                HierarchyRequestError: 3,
                WrongDocumentError: 4,
                InvalidCharacterError: 5,
                NoModificationAllowedError: 7,
                NotFoundError: 8,
                NotSupportedError: 9,
                InUseAttributeError: 10,
                InvalidStateError: 11,
                SyntaxError: 12,
                InvalidModificationError: 13,
                NamespaceError: 14,
                InvalidAccessError: 15,
                TypeMismatchError: 17,
                SecurityError: 18,
                NetworkError: 19,
                AbortError: 20,
                URLMismatchError: 21,
                QuotaExceededError: 22,
                TimeoutError: 23,
                InvalidNodeTypeError: 24,
                DataCloneError: 25,

                EncodingError: 0,
                NotReadableError: 0,
                UnknownError: 0,
                ConstraintError: 0,
                DataError: 0,
                TransactionInactiveError: 0,
                ReadOnlyError: 0,
                VersionError: 0,
                OperationError: 0,
                NotAllowedError: 0
            };

            var code_name_map = {};
            for (var key in name_code_map) {
                if (name_code_map[key] > 0) {
                    code_name_map[name_code_map[key]] = key;
                }
            }

            var required_props = {};
            var name;

            if (typeof type === "number") {
                if (type === 0) {
                    throw new AssertionError('Test bug: ambiguous DOMException code 0 passed to assert_throws_dom()');
                } else if (!(type in code_name_map)) {
                    throw new AssertionError('Test bug: unrecognized DOMException code "' + type + '" passed to assert_throws_dom()');
                }
                name = code_name_map[type];
                required_props.code = type;
            } else if (typeof type === "string") {
                name = type in codename_name_map ? codename_name_map[type] : type;
                if (!(name in name_code_map)) {
                    throw new AssertionError('Test bug: unrecognized DOMException code name or name "' + type + '" passed to assert_throws_dom()');
                }

                required_props.code = name_code_map[name];
            }

            if (required_props.code === 0 ||
               ("name" in e &&
                e.name !== e.name.toUpperCase() &&
                e.name !== "DOMException")) {
                // New style exception: also test the name property.
                required_props.name = name;
            }

            for (var prop in required_props) {
                assert(prop in e && e[prop] == required_props[prop],
                       assertion_type, description,
                       "${func} threw ${e} that is not a DOMException " + type + ": property ${prop} is equal to ${actual}, expected ${expected}",
                       {func:func, e:e, prop:prop, actual:e[prop], expected:required_props[prop]});
            }

            // Check that the exception is from the right global.  This check is last
            // so more specific, and more informative, checks on the properties can
            // happen in case a totally incorrect exception is thrown.
            assert(e.constructor === constructor,
                   assertion_type, description,
                   "${func} threw an exception from the wrong global",
                   {func});

        }
    }

    /**
     * Assert the provided value is thrown.
     *
     * @param {value} exception The expected exception.
     * @param {Function} func Function which should throw.
     * @param {string} description Error description for the case that the error is not thrown.
     */
    function assert_throws_exactly(exception, func, description)
    {
        assert_throws_exactly_impl(exception, func, description,
                                   "assert_throws_exactly");
    }
    expose(assert_throws_exactly, "assert_throws_exactly");

    /**
     * Like assert_throws_exactly but allows specifying the assertion type
     * (assert_throws_exactly or promise_rejects_exactly, in practice).
     */
    function assert_throws_exactly_impl(exception, func, description,
                                        assertion_type)
    {
        try {
            func.call(this);
            assert(false, assertion_type, description,
                   "${func} did not throw", {func:func});
        } catch (e) {
            if (e instanceof AssertionError) {
                throw e;
            }

            assert(same_value(e, exception), assertion_type, description,
                   "${func} threw ${e} but we expected it to throw ${exception}",
                   {func:func, e:e, exception:exception});
        }
    }

    function assert_unreached(description) {
         assert(false, "assert_unreached", description,
                "Reached unreachable code");
    }
    expose(assert_unreached, "assert_unreached");

    function assert_any(assert_func, actual, expected_array)
    {
        var args = [].slice.call(arguments, 3);
        var errors = [];
        var passed = false;
        forEach(expected_array,
                function(expected)
                {
                    try {
                        assert_func.apply(this, [actual, expected].concat(args));
                        passed = true;
                    } catch (e) {
                        errors.push(e.message);
                    }
                });
        if (!passed) {
            throw new AssertionError(errors.join("\n\n"));
        }
    }
    expose(assert_any, "assert_any");

    /**
     * Assert that a feature is implemented, based on a 'truthy' condition.
     *
     * This function should be used to early-exit from tests in which there is
     * no point continuing without support for a non-optional spec or spec
     * feature. For example:
     *
     *     assert_implements(window.Foo, 'Foo is not supported');
     *
     * @param {object} condition The truthy value to test
     * @param {string} description Error description for the case that the condition is not truthy.
     */
    function assert_implements(condition, description) {
        assert(!!condition, "assert_implements", description);
    }
    expose(assert_implements, "assert_implements")

    /**
     * Assert that an optional feature is implemented, based on a 'truthy' condition.
     *
     * This function should be used to early-exit from tests in which there is
     * no point continuing without support for an explicitly optional spec or
     * spec feature. For example:
     *
     *     assert_implements_optional(video.canPlayType("video/webm"),
     *                                "webm video playback not supported");
     *
     * @param {object} condition The truthy value to test
     * @param {string} description Error description for the case that the condition is not truthy.
     */
    function assert_implements_optional(condition, description) {
        if (!condition) {
            throw new OptionalFeatureUnsupportedError(description);
        }
    }
    expose(assert_implements_optional, "assert_implements_optional")

    function Test(name, properties)
    {
        if (tests.file_is_test && tests.tests.length) {
            throw new Error("Tried to create a test with file_is_test");
        }
        this.name = name;

        this.phase = (tests.is_aborted || tests.phase === tests.phases.COMPLETE) ?
            this.phases.COMPLETE : this.phases.INITIAL;

        this.status = this.NOTRUN;
        this.timeout_id = null;
        this.index = null;

        this.properties = properties || {};
        this.timeout_length = settings.test_timeout;
        if (this.timeout_length !== null) {
            this.timeout_length *= tests.timeout_multiplier;
        }

        this.message = null;
        this.stack = null;

        this.steps = [];
        this._is_promise_test = false;

        this.cleanup_callbacks = [];
        this._user_defined_cleanup_count = 0;
        this._done_callbacks = [];

        // Tests declared following harness completion are likely an indication
        // of a programming error, but they cannot be reported
        // deterministically.
        if (tests.phase === tests.phases.COMPLETE) {
            return;
        }

        tests.push(this);
    }

    Test.statuses = {
        PASS:0,
        FAIL:1,
        TIMEOUT:2,
        NOTRUN:3,
        PRECONDITION_FAILED:4
    };

    Test.prototype = merge({}, Test.statuses);

    Test.prototype.phases = {
        INITIAL:0,
        STARTED:1,
        HAS_RESULT:2,
        CLEANING:3,
        COMPLETE:4
    };

    Test.prototype.structured_clone = function()
    {
        if (!this._structured_clone) {
            var msg = this.message;
            msg = msg ? String(msg) : msg;
            this._structured_clone = merge({
                name:String(this.name),
                properties:merge({}, this.properties),
                phases:merge({}, this.phases)
            }, Test.statuses);
        }
        this._structured_clone.status = this.status;
        this._structured_clone.message = this.message;
        this._structured_clone.stack = this.stack;
        this._structured_clone.index = this.index;
        this._structured_clone.phase = this.phase;
        return this._structured_clone;
    };

    Test.prototype.step = function(func, this_obj)
    {
        if (this.phase > this.phases.STARTED) {
            return;
        }
        this.phase = this.phases.STARTED;
        //If we don't get a result before the harness times out that will be a test timeout
        this.set_status(this.TIMEOUT, "Test timed out");

        tests.started = true;
        tests.notify_test_state(this);

        if (this.timeout_id === null) {
            this.set_timeout();
        }

        this.steps.push(func);

        if (arguments.length === 1) {
            this_obj = this;
        }

        try {
            return func.apply(this_obj, Array.prototype.slice.call(arguments, 2));
        } catch (e) {
            if (this.phase >= this.phases.HAS_RESULT) {
                return;
            }
            var status = e instanceof OptionalFeatureUnsupportedError ? this.PRECONDITION_FAILED : this.FAIL;
            var message = String((typeof e === "object" && e !== null) ? e.message : e);
            var stack = e.stack ? e.stack : null;

            this.set_status(status, message, stack);
            this.phase = this.phases.HAS_RESULT;
            this.done();
        }
    };

    Test.prototype.step_func = function(func, this_obj)
    {
        var test_this = this;

        if (arguments.length === 1) {
            this_obj = test_this;
        }

        return function()
        {
            return test_this.step.apply(test_this, [func, this_obj].concat(
                Array.prototype.slice.call(arguments)));
        };
    };

    Test.prototype.step_func_done = function(func, this_obj)
    {
        var test_this = this;

        if (arguments.length === 1) {
            this_obj = test_this;
        }

        return function()
        {
            if (func) {
                test_this.step.apply(test_this, [func, this_obj].concat(
                    Array.prototype.slice.call(arguments)));
            }
            test_this.done();
        };
    };

    Test.prototype.unreached_func = function(description)
    {
        return this.step_func(function() {
            assert_unreached(description);
        });
    };

    Test.prototype.step_timeout = function(f, timeout) {
        var test_this = this;
        var args = Array.prototype.slice.call(arguments, 2);
        return setTimeout(this.step_func(function() {
            return f.apply(test_this, args);
        }), timeout * tests.timeout_multiplier);
    }

    /*
     * Private method for registering cleanup functions. `testharness.js`
     * internals should use this method instead of the public `add_cleanup`
     * method in order to hide implementation details from the harness status
     * message in the case errors.
     */
    Test.prototype._add_cleanup = function(callback) {
        this.cleanup_callbacks.push(callback);
    };

    /*
     * Schedule a function to be run after the test result is known, regardless
     * of passing or failing state. The behavior of this function will not
     * influence the result of the test, but if an exception is thrown, the
     * test harness will report an error.
     */
    Test.prototype.add_cleanup = function(callback) {
        this._user_defined_cleanup_count += 1;
        this._add_cleanup(callback);
    };

    Test.prototype.set_timeout = function()
    {
        if (this.timeout_length !== null) {
            var this_obj = this;
            this.timeout_id = setTimeout(function()
                                         {
                                             this_obj.timeout();
                                         }, this.timeout_length);
        }
    };

    Test.prototype.set_status = function(status, message, stack)
    {
        this.status = status;
        this.message = message;
        this.stack = stack ? stack : null;
    };

    Test.prototype.timeout = function()
    {
        this.timeout_id = null;
        this.set_status(this.TIMEOUT, "Test timed out");
        this.phase = this.phases.HAS_RESULT;
        this.done();
    };

    Test.prototype.force_timeout = Test.prototype.timeout;

    /**
     * Update the test status, initiate "cleanup" functions, and signal test
     * completion.
     */
    Test.prototype.done = function()
    {
        if (this.phase >= this.phases.CLEANING) {
            return;
        }

        if (this.phase <= this.phases.STARTED) {
            this.set_status(this.PASS, null);
        }

        if (global_scope.clearTimeout) {
            clearTimeout(this.timeout_id);
        }

        this.cleanup();
    };

    function add_test_done_callback(test, callback)
    {
        if (test.phase === test.phases.COMPLETE) {
            callback();
            return;
        }

        test._done_callbacks.push(callback);
    }

    /*
     * Invoke all specified cleanup functions. If one or more produce an error,
     * the context is in an unpredictable state, so all further testing should
     * be cancelled.
     */
    Test.prototype.cleanup = function() {
        var error_count = 0;
        var bad_value_count = 0;
        function on_error() {
            error_count += 1;
            // Abort tests immediately so that tests declared within subsequent
            // cleanup functions are not run.
            tests.abort();
        }
        var this_obj = this;
        var results = [];

        this.phase = this.phases.CLEANING;

        forEach(this.cleanup_callbacks,
                function(cleanup_callback) {
                    var result;

                    try {
                        result = cleanup_callback();
                    } catch (e) {
                        on_error();
                        return;
                    }

                    if (!is_valid_cleanup_result(this_obj, result)) {
                        bad_value_count += 1;
                        // Abort tests immediately so that tests declared
                        // within subsequent cleanup functions are not run.
                        tests.abort();
                    }

                    results.push(result);
                });

        if (!this._is_promise_test) {
            cleanup_done(this_obj, error_count, bad_value_count);
        } else {
            all_async(results,
                      function(result, done) {
                          if (result && typeof result.then === "function") {
                              result
                                  .then(null, on_error)
                                  .then(done);
                          } else {
                              done();
                          }
                      },
                      function() {
                          cleanup_done(this_obj, error_count, bad_value_count);
                      });
        }
    };

    /**
     * Determine if the return value of a cleanup function is valid for a given
     * test. Any test may return the value `undefined`. Tests created with
     * `promise_test` may alternatively return "thenable" object values.
     */
    function is_valid_cleanup_result(test, result) {
        if (result === undefined) {
            return true;
        }

        if (test._is_promise_test) {
            return result && typeof result.then === "function";
        }

        return false;
    }

    function cleanup_done(test, error_count, bad_value_count) {
        if (error_count || bad_value_count) {
            var total = test._user_defined_cleanup_count;

            tests.status.status = tests.status.ERROR;
            tests.status.message = "Test named '" + test.name +
                "' specified " + total +
                " 'cleanup' function" + (total > 1 ? "s" : "");

            if (error_count) {
                tests.status.message += ", and " + error_count + " failed";
            }

            if (bad_value_count) {
                var type = test._is_promise_test ?
                   "non-thenable" : "non-undefined";
                tests.status.message += ", and " + bad_value_count +
                    " returned a " + type + " value";
            }

            tests.status.message += ".";

            tests.status.stack = null;
        }

        test.phase = test.phases.COMPLETE;
        tests.result(test);
        forEach(test._done_callbacks,
                function(callback) {
                    callback();
                });
        test._done_callbacks.length = 0;
    }

    /*
     * A RemoteTest object mirrors a Test object on a remote worker. The
     * associated RemoteWorker updates the RemoteTest object in response to
     * received events. In turn, the RemoteTest object replicates these events
     * on the local document. This allows listeners (test result reporting
     * etc..) to transparently handle local and remote events.
     */
    function RemoteTest(clone) {
        var this_obj = this;
        Object.keys(clone).forEach(
                function(key) {
                    this_obj[key] = clone[key];
                });
        this.index = null;
        this.phase = this.phases.INITIAL;
        this.update_state_from(clone);
        this._done_callbacks = [];
        tests.push(this);
    }

    RemoteTest.prototype.structured_clone = function() {
        var clone = {};
        Object.keys(this).forEach(
                (function(key) {
                    var value = this[key];
                    // `RemoteTest` instances are responsible for managing
                    // their own "done" callback functions, so those functions
                    // are not relevant in other execution contexts. Because of
                    // this (and because Function values cannot be serialized
                    // for cross-realm transmittance), the property should not
                    // be considered when cloning instances.
                    if (key === '_done_callbacks' ) {
                        return;
                    }

                    if (typeof value === "object" && value !== null) {
                        clone[key] = merge({}, value);
                    } else {
                        clone[key] = value;
                    }
                }).bind(this));
        clone.phases = merge({}, this.phases);
        return clone;
    };

    /**
     * `RemoteTest` instances are objects which represent tests running in
     * another realm. They do not define "cleanup" functions (if necessary,
     * such functions are defined on the associated `Test` instance within the
     * external realm). However, `RemoteTests` may have "done" callbacks (e.g.
     * as attached by the `Tests` instance responsible for tracking the overall
     * test status in the parent realm). The `cleanup` method delegates to
     * `done` in order to ensure that such callbacks are invoked following the
     * completion of the `RemoteTest`.
     */
    RemoteTest.prototype.cleanup = function() {
        this.done();
    };
    RemoteTest.prototype.phases = Test.prototype.phases;
    RemoteTest.prototype.update_state_from = function(clone) {
        this.status = clone.status;
        this.message = clone.message;
        this.stack = clone.stack;
        if (this.phase === this.phases.INITIAL) {
            this.phase = this.phases.STARTED;
        }
    };
    RemoteTest.prototype.done = function() {
        this.phase = this.phases.COMPLETE;

        forEach(this._done_callbacks,
                function(callback) {
                    callback();
                });
    }

    /*
     * A RemoteContext listens for test events from a remote test context, such
     * as another window or a worker. These events are then used to construct
     * and maintain RemoteTest objects that mirror the tests running in the
     * remote context.
     *
     * An optional third parameter can be used as a predicate to filter incoming
     * MessageEvents.
     */
    function RemoteContext(remote, message_target, message_filter) {
        this.running = true;
        this.started = false;
        this.tests = new Array();
        this.early_exception = null;

        var this_obj = this;
        // If remote context is cross origin assigning to onerror is not
        // possible, so silently catch those errors.
        try {
          remote.onerror = function(error) { this_obj.remote_error(error); };
        } catch (e) {
          // Ignore.
        }

        // Keeping a reference to the remote object and the message handler until
        // remote_done() is seen prevents the remote object and its message channel
        // from going away before all the messages are dispatched.
        this.remote = remote;
        this.message_target = message_target;
        this.message_handler = function(message) {
            var passesFilter = !message_filter || message_filter(message);
            // The reference to the `running` property in the following
            // condition is unnecessary because that value is only set to
            // `false` after the `message_handler` function has been
            // unsubscribed.
            // TODO: Simplify the condition by removing the reference.
            if (this_obj.running && message.data && passesFilter &&
                (message.data.type in this_obj.message_handlers)) {
                this_obj.message_handlers[message.data.type].call(this_obj, message.data);
            }
        };

        if (self.Promise) {
            this.done = new Promise(function(resolve) {
                this_obj.doneResolve = resolve;
            });
        }

        this.message_target.addEventListener("message", this.message_handler);
    }

    RemoteContext.prototype.remote_error = function(error) {
        if (error.preventDefault) {
            error.preventDefault();
        }

        // Defer interpretation of errors until the testing protocol has
        // started and the remote test's `allow_uncaught_exception` property
        // is available.
        if (!this.started) {
            this.early_exception = error;
        } else if (!this.allow_uncaught_exception) {
            this.report_uncaught(error);
        }
    };

    RemoteContext.prototype.report_uncaught = function(error) {
        var message = error.message || String(error);
        var filename = (error.filename ? " " + error.filename: "");
        // FIXME: Display remote error states separately from main document
        // error state.
        tests.set_status(tests.status.ERROR,
                         "Error in remote" + filename + ": " + message,
                         error.stack);
    };

    RemoteContext.prototype.start = function(data) {
        this.started = true;
        this.allow_uncaught_exception = data.properties.allow_uncaught_exception;

        if (this.early_exception && !this.allow_uncaught_exception) {
            this.report_uncaught(this.early_exception);
        }
    };

    RemoteContext.prototype.test_state = function(data) {
        var remote_test = this.tests[data.test.index];
        if (!remote_test) {
            remote_test = new RemoteTest(data.test);
            this.tests[data.test.index] = remote_test;
        }
        remote_test.update_state_from(data.test);
        tests.notify_test_state(remote_test);
    };

    RemoteContext.prototype.test_done = function(data) {
        var remote_test = this.tests[data.test.index];
        remote_test.update_state_from(data.test);
        remote_test.done();
        tests.result(remote_test);
    };

    RemoteContext.prototype.remote_done = function(data) {
        if (tests.status.status === null &&
            data.status.status !== data.status.OK) {
            tests.set_status(data.status.status, data.status.message, data.status.sack);
        }

        this.message_target.removeEventListener("message", this.message_handler);
        this.running = false;

        // If remote context is cross origin assigning to onerror is not
        // possible, so silently catch those errors.
        try {
          this.remote.onerror = null;
        } catch (e) {
          // Ignore.
        }

        this.remote = null;
        this.message_target = null;
        if (this.doneResolve) {
            this.doneResolve();
        }

        if (tests.all_done()) {
            tests.complete();
        }
    };

    RemoteContext.prototype.message_handlers = {
        start: RemoteContext.prototype.start,
        test_state: RemoteContext.prototype.test_state,
        result: RemoteContext.prototype.test_done,
        complete: RemoteContext.prototype.remote_done
    };

    /*
     * Harness
     */

    function TestsStatus()
    {
        this.status = null;
        this.message = null;
        this.stack = null;
    }

    TestsStatus.statuses = {
        OK:0,
        ERROR:1,
        TIMEOUT:2,
        PRECONDITION_FAILED:3
    };

    TestsStatus.prototype = merge({}, TestsStatus.statuses);

    TestsStatus.prototype.structured_clone = function()
    {
        if (!this._structured_clone) {
            var msg = this.message;
            msg = msg ? String(msg) : msg;
            this._structured_clone = merge({
                status:this.status,
                message:msg,
                stack:this.stack
            }, TestsStatus.statuses);
        }
        return this._structured_clone;
    };

    function Tests()
    {
        this.tests = [];
        this.num_pending = 0;

        this.phases = {
            INITIAL:0,
            SETUP:1,
            HAVE_TESTS:2,
            HAVE_RESULTS:3,
            COMPLETE:4
        };
        this.phase = this.phases.INITIAL;

        this.properties = {};

        this.wait_for_finish = false;
        this.processing_callbacks = false;

        this.allow_uncaught_exception = false;

        this.file_is_test = false;
        // This value is lazily initialized in order to avoid introducing a
        // dependency on ECMAScript 2015 Promises to all tests.
        this.promise_tests = null;
        this.promise_setup_called = false;

        this.timeout_multiplier = 1;
        this.timeout_length = test_environment.test_timeout();
        this.timeout_id = null;

        this.start_callbacks = [];
        this.test_state_callbacks = [];
        this.test_done_callbacks = [];
        this.all_done_callbacks = [];

        this.pending_remotes = [];

        this.status = new TestsStatus();

        var this_obj = this;

        test_environment.add_on_loaded_callback(function() {
            if (this_obj.all_done()) {
                this_obj.complete();
            }
        });

        this.set_timeout();
    }

    Tests.prototype.setup = function(func, properties)
    {
        if (this.phase >= this.phases.HAVE_RESULTS) {
            return;
        }

        if (this.phase < this.phases.SETUP) {
            this.phase = this.phases.SETUP;
        }

        this.properties = properties;

        for (var p in properties) {
            if (properties.hasOwnProperty(p)) {
                var value = properties[p];
                if (p == "allow_uncaught_exception") {
                    this.allow_uncaught_exception = value;
                } else if (p == "explicit_done" && value) {
                    this.wait_for_finish = true;
                } else if (p == "explicit_timeout" && value) {
                    this.timeout_length = null;
                    if (this.timeout_id)
                    {
                        clearTimeout(this.timeout_id);
                    }
                } else if (p == "single_test" && value) {
                    this.set_file_is_test();
                } else if (p == "timeout_multiplier") {
                    this.timeout_multiplier = value;
                    if (this.timeout_length) {
                         this.timeout_length *= this.timeout_multiplier;
                    }
                }
            }
        }

        if (func) {
            try {
                func();
            } catch (e) {
                this.status.status = e instanceof OptionalFeatureUnsupportedError ? this.status.PRECONDITION_FAILED : this.status.ERROR;
                this.status.message = String(e);
                this.status.stack = e.stack ? e.stack : null;
                this.complete();
            }
        }
        this.set_timeout();
    };

    Tests.prototype.set_file_is_test = function() {
        if (this.tests.length > 0) {
            throw new Error("Tried to set file as test after creating a test");
        }
        this.wait_for_finish = true;
        this.file_is_test = true;
        // Create the test, which will add it to the list of tests
        async_test();
    };

    Tests.prototype.set_status = function(status, message, stack)
    {
        this.status.status = status;
        this.status.message = message;
        this.status.stack = stack ? stack : null;
    };

    Tests.prototype.set_timeout = function() {
        if (global_scope.clearTimeout) {
            var this_obj = this;
            clearTimeout(this.timeout_id);
            if (this.timeout_length !== null) {
                this.timeout_id = setTimeout(function() {
                                                 this_obj.timeout();
                                             }, this.timeout_length);
            }
        }
    };

    Tests.prototype.timeout = function() {
        var test_in_cleanup = null;

        if (this.status.status === null) {
            forEach(this.tests,
                    function(test) {
                        // No more than one test is expected to be in the
                        // "CLEANUP" phase at any time
                        if (test.phase === test.phases.CLEANING) {
                            test_in_cleanup = test;
                        }

                        test.phase = test.phases.COMPLETE;
                    });

            // Timeouts that occur while a test is in the "cleanup" phase
            // indicate that some global state was not properly reverted. This
            // invalidates the overall test execution, so the timeout should be
            // reported as an error and cancel the execution of any remaining
            // tests.
            if (test_in_cleanup) {
                this.status.status = this.status.ERROR;
                this.status.message = "Timeout while running cleanup for " +
                    "test named \"" + test_in_cleanup.name + "\".";
                tests.status.stack = null;
            } else {
                this.status.status = this.status.TIMEOUT;
            }
        }

        this.complete();
    };

    Tests.prototype.end_wait = function()
    {
        this.wait_for_finish = false;
        if (this.all_done()) {
            this.complete();
        }
    };

    Tests.prototype.push = function(test)
    {
        if (this.phase < this.phases.HAVE_TESTS) {
            this.start();
        }
        this.num_pending++;
        test.index = this.tests.push(test);
        this.notify_test_state(test);
    };

    Tests.prototype.notify_test_state = function(test) {
        var this_obj = this;
        forEach(this.test_state_callbacks,
                function(callback) {
                    callback(test, this_obj);
                });
    };

    Tests.prototype.all_done = function() {
        return this.tests.length > 0 && test_environment.all_loaded &&
                (this.num_pending === 0 || this.is_aborted) && !this.wait_for_finish &&
                !this.processing_callbacks &&
                !this.pending_remotes.some(function(w) { return w.running; });
    };

    Tests.prototype.start = function() {
        this.phase = this.phases.HAVE_TESTS;
        this.notify_start();
    };

    Tests.prototype.notify_start = function() {
        var this_obj = this;
        forEach (this.start_callbacks,
                 function(callback)
                 {
                     callback(this_obj.properties);
                 });
    };

    Tests.prototype.result = function(test)
    {
        // If the harness has already transitioned beyond the `HAVE_RESULTS`
        // phase, subsequent tests should not cause it to revert.
        if (this.phase <= this.phases.HAVE_RESULTS) {
            this.phase = this.phases.HAVE_RESULTS;
        }
        this.num_pending--;
        this.notify_result(test);
    };

    Tests.prototype.notify_result = function(test) {
        var this_obj = this;
        this.processing_callbacks = true;
        forEach(this.test_done_callbacks,
                function(callback)
                {
                    callback(test, this_obj);
                });
        this.processing_callbacks = false;
        if (this_obj.all_done()) {
            this_obj.complete();
        }
    };

    Tests.prototype.complete = function() {
        if (this.phase === this.phases.COMPLETE) {
            return;
        }
        var this_obj = this;
        var all_complete = function() {
            this_obj.phase = this_obj.phases.COMPLETE;
            this_obj.notify_complete();
        };
        var incomplete = filter(this.tests,
                                function(test) {
                                    return test.phase < test.phases.COMPLETE;
                                });

        /**
         * To preserve legacy behavior, overall test completion must be
         * signaled synchronously.
         */
        if (incomplete.length === 0) {
            all_complete();
            return;
        }

        all_async(incomplete,
                  function(test, testDone)
                  {
                      if (test.phase === test.phases.INITIAL) {
                          test.phase = test.phases.COMPLETE;
                          testDone();
                      } else {
                          add_test_done_callback(test, testDone);
                          test.cleanup();
                      }
                  },
                  all_complete);
    };

    /**
     * Update the harness status to reflect an unrecoverable harness error that
     * should cancel all further testing. Update all previously-defined tests
     * which have not yet started to indicate that they will not be executed.
     */
    Tests.prototype.abort = function() {
        this.status.status = this.status.ERROR;
        this.is_aborted = true;

        forEach(this.tests,
                function(test) {
                    if (test.phase === test.phases.INITIAL) {
                        test.phase = test.phases.COMPLETE;
                    }
                });
    };

    /*
     * Determine if any tests share the same `name` property. Return an array
     * containing the names of any such duplicates.
     */
    Tests.prototype.find_duplicates = function() {
        var names = Object.create(null);
        var duplicates = [];

        forEach (this.tests,
                 function(test)
                 {
                     if (test.name in names && duplicates.indexOf(test.name) === -1) {
                        duplicates.push(test.name);
                     }
                     names[test.name] = true;
                 });

        return duplicates;
    };

    function code_unit_str(char) {
        return 'U+' + char.charCodeAt(0).toString(16);
    }

    function sanitize_unpaired_surrogates(str) {
        return str.replace(/([\ud800-\udbff])(?![\udc00-\udfff])/g,
                           function(_, unpaired)
                           {
                               return code_unit_str(unpaired);
                           })
                  // This replacement is intentionally implemented without an
                  // ES2018 negative lookbehind assertion to support runtimes
                  // which do not yet implement that language feature.
                  .replace(/(^|[^\ud800-\udbff])([\udc00-\udfff])/g,
                           function(_, previous, unpaired) {
                              if (/[\udc00-\udfff]/.test(previous)) {
                                  previous = code_unit_str(previous);
                              }

                              return previous + code_unit_str(unpaired);
                           });
    }

    function sanitize_all_unpaired_surrogates(tests) {
        forEach (tests,
                 function (test)
                 {
                     var sanitized = sanitize_unpaired_surrogates(test.name);

                     if (test.name !== sanitized) {
                         test.name = sanitized;
                         delete test._structured_clone;
                     }
                 });
    }

    Tests.prototype.notify_complete = function() {
        var this_obj = this;
        var duplicates;

        if (this.status.status === null) {
            duplicates = this.find_duplicates();

            // Some transports adhere to UTF-8's restriction on unpaired
            // surrogates. Sanitize the titles so that the results can be
            // consistently sent via all transports.
            sanitize_all_unpaired_surrogates(this.tests);

            // Test names are presumed to be unique within test files--this
            // allows consumers to use them for identification purposes.
            // Duplicated names violate this expectation and should therefore
            // be reported as an error.
            if (duplicates.length) {
                this.status.status = this.status.ERROR;
                this.status.message =
                   duplicates.length + ' duplicate test name' +
                   (duplicates.length > 1 ? 's' : '') + ': "' +
                   duplicates.join('", "') + '"';
            } else {
                this.status.status = this.status.OK;
            }
        }

        forEach (this.all_done_callbacks,
                 function(callback)
                 {
                     callback(this_obj.tests, this_obj.status);
                 });
    };

    /*
     * Constructs a RemoteContext that tracks tests from a specific worker.
     */
    Tests.prototype.create_remote_worker = function(worker) {
        var message_port;

        if (is_service_worker(worker)) {
            message_port = navigator.serviceWorker;
            worker.postMessage({type: "connect"});
        } else if (is_shared_worker(worker)) {
            message_port = worker.port;
            message_port.start();
        } else {
            message_port = worker;
        }

        return new RemoteContext(worker, message_port);
    };

    /*
     * Constructs a RemoteContext that tracks tests from a specific window.
     */
    Tests.prototype.create_remote_window = function(remote) {
        remote.postMessage({type: "getmessages"}, "*");
        return new RemoteContext(
            remote,
            window,
            function(msg) {
                return msg.source === remote;
            }
        );
    };

    Tests.prototype.fetch_tests_from_worker = function(worker) {
        if (this.phase >= this.phases.COMPLETE) {
            return;
        }

        var remoteContext = this.create_remote_worker(worker);
        this.pending_remotes.push(remoteContext);
        return remoteContext.done;
    };

    function fetch_tests_from_worker(port) {
        return tests.fetch_tests_from_worker(port);
    }
    expose(fetch_tests_from_worker, 'fetch_tests_from_worker');

    Tests.prototype.fetch_tests_from_window = function(remote) {
        if (this.phase >= this.phases.COMPLETE) {
            return;
        }

        this.pending_remotes.push(this.create_remote_window(remote));
    };

    function fetch_tests_from_window(window) {
        tests.fetch_tests_from_window(window);
    }
    expose(fetch_tests_from_window, 'fetch_tests_from_window');

    function timeout() {
        if (tests.timeout_length === null) {
            tests.timeout();
        }
    }
    expose(timeout, 'timeout');

    function add_start_callback(callback) {
        tests.start_callbacks.push(callback);
    }

    function add_test_state_callback(callback) {
        tests.test_state_callbacks.push(callback);
    }

    function add_result_callback(callback) {
        tests.test_done_callbacks.push(callback);
    }

    function add_completion_callback(callback) {
        tests.all_done_callbacks.push(callback);
    }

    expose(add_start_callback, 'add_start_callback');
    expose(add_test_state_callback, 'add_test_state_callback');
    expose(add_result_callback, 'add_result_callback');
    expose(add_completion_callback, 'add_completion_callback');

    function remove(array, item) {
        var index = array.indexOf(item);
        if (index > -1) {
            array.splice(index, 1);
        }
    }

    function remove_start_callback(callback) {
        remove(tests.start_callbacks, callback);
    }

    function remove_test_state_callback(callback) {
        remove(tests.test_state_callbacks, callback);
    }

    function remove_result_callback(callback) {
        remove(tests.test_done_callbacks, callback);
    }

    function remove_completion_callback(callback) {
       remove(tests.all_done_callbacks, callback);
    }

    /*
     * Output listener
    */

    function Output() {
        this.output_document = document;
        this.output_node = null;
        this.enabled = settings.output;
        this.phase = this.INITIAL;
    }

    Output.prototype.INITIAL = 0;
    Output.prototype.STARTED = 1;
    Output.prototype.HAVE_RESULTS = 2;
    Output.prototype.COMPLETE = 3;

    Output.prototype.setup = function(properties) {
        if (this.phase > this.INITIAL) {
            return;
        }

        //If output is disabled in testharnessreport.js the test shouldn't be
        //able to override that
        this.enabled = this.enabled && (properties.hasOwnProperty("output") ?
                                        properties.output : settings.output);
    };

    Output.prototype.init = function(properties) {
        if (this.phase >= this.STARTED) {
            return;
        }
        if (properties.output_document) {
            this.output_document = properties.output_document;
        } else {
            this.output_document = document;
        }
        this.phase = this.STARTED;
    };

    Output.prototype.resolve_log = function() {
        var output_document;
        if (this.output_node) {
            return;
        }
        if (typeof this.output_document === "function") {
            output_document = this.output_document.apply(undefined);
        } else {
            output_document = this.output_document;
        }
        if (!output_document) {
            return;
        }
        var node = output_document.getElementById("log");
        if (!node) {
            if (output_document.readyState === "loading") {
                return;
            }
            node = output_document.createElementNS("http://www.w3.org/1999/xhtml", "div");
            node.id = "log";
            if (output_document.body) {
                output_document.body.appendChild(node);
            } else {
                var root = output_document.documentElement;
                var is_html = (root &&
                               root.namespaceURI == "http://www.w3.org/1999/xhtml" &&
                               root.localName == "html");
                var is_svg = (output_document.defaultView &&
                              "SVGSVGElement" in output_document.defaultView &&
                              root instanceof output_document.defaultView.SVGSVGElement);
                if (is_svg) {
                    var foreignObject = output_document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
                    foreignObject.setAttribute("width", "100%");
                    foreignObject.setAttribute("height", "100%");
                    root.appendChild(foreignObject);
                    foreignObject.appendChild(node);
                } else if (is_html) {
                    root.appendChild(output_document.createElementNS("http://www.w3.org/1999/xhtml", "body"))
                        .appendChild(node);
                } else {
                    root.appendChild(node);
                }
            }
        }
        this.output_document = output_document;
        this.output_node = node;
    };

    Output.prototype.show_status = function() {
        if (this.phase < this.STARTED) {
            this.init();
        }
        if (!this.enabled || this.phase === this.COMPLETE) {
            return;
        }
        this.resolve_log();
        if (this.phase < this.HAVE_RESULTS) {
            this.phase = this.HAVE_RESULTS;
        }
        var done_count = tests.tests.length - tests.num_pending;
        if (this.output_node) {
            if (done_count < 100 ||
                (done_count < 1000 && done_count % 100 === 0) ||
                done_count % 1000 === 0) {
                this.output_node.textContent = "Running, " +
                    done_count + " complete, " +
                    tests.num_pending + " remain";
            }
        }
    };

    Output.prototype.show_results = function (tests, harness_status) {
        if (this.phase >= this.COMPLETE) {
            return;
        }
        if (!this.enabled) {
            return;
        }
        if (!this.output_node) {
            this.resolve_log();
        }
        this.phase = this.COMPLETE;

        var log = this.output_node;
        if (!log) {
            return;
        }
        var output_document = this.output_document;

        while (log.lastChild) {
            log.removeChild(log.lastChild);
        }

        var stylesheet = output_document.createElementNS(xhtml_ns, "style");
        stylesheet.textContent = stylesheetContent;
        var heads = output_document.getElementsByTagName("head");
        if (heads.length) {
            heads[0].appendChild(stylesheet);
        }

        var status_text_harness = {};
        status_text_harness[harness_status.OK] = "OK";
        status_text_harness[harness_status.ERROR] = "Error";
        status_text_harness[harness_status.TIMEOUT] = "Timeout";
        status_text_harness[harness_status.PRECONDITION_FAILED] = "Optional Feature Unsupported";

        var status_text = {};
        status_text[Test.prototype.PASS] = "Pass";
        status_text[Test.prototype.FAIL] = "Fail";
        status_text[Test.prototype.TIMEOUT] = "Timeout";
        status_text[Test.prototype.NOTRUN] = "Not Run";
        status_text[Test.prototype.PRECONDITION_FAILED] = "Optional Feature Unsupported";

        var status_number = {};
        forEach(tests,
                function(test) {
                    var status = status_text[test.status];
                    if (status_number.hasOwnProperty(status)) {
                        status_number[status] += 1;
                    } else {
                        status_number[status] = 1;
                    }
                });

        function status_class(status)
        {
            return status.replace(/\s/g, '').toLowerCase();
        }

        var summary_template = ["section", {"id":"summary"},
                                ["h2", {}, "Summary"],
                                function()
                                {

                                    var status = status_text_harness[harness_status.status];
                                    var rv = [["section", {},
                                               ["p", {},
                                                "Harness status: ",
                                                ["span", {"class":status_class(status)},
                                                 status
                                                ],
                                               ]
                                              ]];

                                    if (harness_status.status === harness_status.ERROR) {
                                        rv[0].push(["pre", {}, harness_status.message]);
                                        if (harness_status.stack) {
                                            rv[0].push(["pre", {}, harness_status.stack]);
                                        }
                                    }
                                    return rv;
                                },
                                ["p", {}, "Found ${num_tests} tests"],
                                function() {
                                    var rv = [["div", {}]];
                                    var i = 0;
                                    while (status_text.hasOwnProperty(i)) {
                                        if (status_number.hasOwnProperty(status_text[i])) {
                                            var status = status_text[i];
                                            rv[0].push(["div", {"class":status_class(status)},
                                                        ["label", {},
                                                         ["input", {type:"checkbox", checked:"checked"}],
                                                         status_number[status] + " " + status]]);
                                        }
                                        i++;
                                    }
                                    return rv;
                                },
                               ];

        log.appendChild(render(summary_template, {num_tests:tests.length}, output_document));

        forEach(output_document.querySelectorAll("section#summary label"),
                function(element)
                {
                    on_event(element, "click",
                             function(e)
                             {
                                 if (output_document.getElementById("results") === null) {
                                     e.preventDefault();
                                     return;
                                 }
                                 var result_class = element.parentNode.getAttribute("class");
                                 var style_element = output_document.querySelector("style#hide-" + result_class);
                                 var input_element = element.querySelector("input");
                                 if (!style_element && !input_element.checked) {
                                     style_element = output_document.createElementNS(xhtml_ns, "style");
                                     style_element.id = "hide-" + result_class;
                                     style_element.textContent = "table#results > tbody > tr."+result_class+"{display:none}";
                                     output_document.body.appendChild(style_element);
                                 } else if (style_element && input_element.checked) {
                                     style_element.parentNode.removeChild(style_element);
                                 }
                             });
                });

        // This use of innerHTML plus manual escaping is not recommended in
        // general, but is necessary here for performance.  Using textContent
        // on each individual <td> adds tens of seconds of execution time for
        // large test suites (tens of thousands of tests).
        function escape_html(s)
        {
            return s.replace(/\&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#39;");
        }

        function has_assertions()
        {
            for (var i = 0; i < tests.length; i++) {
                if (tests[i].properties.hasOwnProperty("assert")) {
                    return true;
                }
            }
            return false;
        }

        function get_assertion(test)
        {
            if (test.properties.hasOwnProperty("assert")) {
                if (Array.isArray(test.properties.assert)) {
                    return test.properties.assert.join(' ');
                }
                return test.properties.assert;
            }
            return '';
        }

        log.appendChild(document.createElementNS(xhtml_ns, "section"));
        var assertions = has_assertions();
        var html = "<h2>Details</h2><table id='results' " + (assertions ? "class='assertions'" : "" ) + ">" +
            "<thead><tr><th>Result</th><th>Test Name</th>" +
            (assertions ? "<th>Assertion</th>" : "") +
            "<th>Message</th></tr></thead>" +
            "<tbody>";
        for (var i = 0; i < tests.length; i++) {
            html += '<tr class="' +
                escape_html(status_class(status_text[tests[i].status])) +
                '"><td>' +
                escape_html(status_text[tests[i].status]) +
                "</td><td>" +
                escape_html(tests[i].name) +
                "</td><td>" +
                (assertions ? escape_html(get_assertion(tests[i])) + "</td><td>" : "") +
                escape_html(tests[i].message ? tests[i].message : " ") +
                (tests[i].stack ? "<pre>" +
                 escape_html(tests[i].stack) +
                 "</pre>": "") +
                "</td></tr>";
        }
        html += "</tbody></table>";
        try {
            log.lastChild.innerHTML = html;
        } catch (e) {
            log.appendChild(document.createElementNS(xhtml_ns, "p"))
               .textContent = "Setting innerHTML for the log threw an exception.";
            log.appendChild(document.createElementNS(xhtml_ns, "pre"))
               .textContent = html;
        }
    };

    /*
     * Template code
     *
     * A template is just a JavaScript structure. An element is represented as:
     *
     * [tag_name, {attr_name:attr_value}, child1, child2]
     *
     * the children can either be strings (which act like text nodes), other templates or
     * functions (see below)
     *
     * A text node is represented as
     *
     * ["{text}", value]
     *
     * String values have a simple substitution syntax; ${foo} represents a variable foo.
     *
     * It is possible to embed logic in templates by using a function in a place where a
     * node would usually go. The function must either return part of a template or null.
     *
     * In cases where a set of nodes are required as output rather than a single node
     * with children it is possible to just use a list
     * [node1, node2, node3]
     *
     * Usage:
     *
     * render(template, substitutions) - take a template and an object mapping
     * variable names to parameters and return either a DOM node or a list of DOM nodes
     *
     * substitute(template, substitutions) - take a template and variable mapping object,
     * make the variable substitutions and return the substituted template
     *
     */

    function is_single_node(template)
    {
        return typeof template[0] === "string";
    }

    function substitute(template, substitutions)
    {
        if (typeof template === "function") {
            var replacement = template(substitutions);
            if (!replacement) {
                return null;
            }

            return substitute(replacement, substitutions);
        }

        if (is_single_node(template)) {
            return substitute_single(template, substitutions);
        }

        return filter(map(template, function(x) {
                              return substitute(x, substitutions);
                          }), function(x) {return x !== null;});
    }

    function substitute_single(template, substitutions)
    {
        var substitution_re = /\$\{([^ }]*)\}/g;

        function do_substitution(input) {
            var components = input.split(substitution_re);
            var rv = [];
            for (var i = 0; i < components.length; i += 2) {
                rv.push(components[i]);
                if (components[i + 1]) {
                    rv.push(String(substitutions[components[i + 1]]));
                }
            }
            return rv;
        }

        function substitute_attrs(attrs, rv)
        {
            rv[1] = {};
            for (var name in template[1]) {
                if (attrs.hasOwnProperty(name)) {
                    var new_name = do_substitution(name).join("");
                    var new_value = do_substitution(attrs[name]).join("");
                    rv[1][new_name] = new_value;
                }
            }
        }

        function substitute_children(children, rv)
        {
            for (var i = 0; i < children.length; i++) {
                if (children[i] instanceof Object) {
                    var replacement = substitute(children[i], substitutions);
                    if (replacement !== null) {
                        if (is_single_node(replacement)) {
                            rv.push(replacement);
                        } else {
                            extend(rv, replacement);
                        }
                    }
                } else {
                    extend(rv, do_substitution(String(children[i])));
                }
            }
            return rv;
        }

        var rv = [];
        rv.push(do_substitution(String(template[0])).join(""));

        if (template[0] === "{text}") {
            substitute_children(template.slice(1), rv);
        } else {
            substitute_attrs(template[1], rv);
            substitute_children(template.slice(2), rv);
        }

        return rv;
    }

    function make_dom_single(template, doc)
    {
        var output_document = doc || document;
        var element;
        if (template[0] === "{text}") {
            element = output_document.createTextNode("");
            for (var i = 1; i < template.length; i++) {
                element.data += template[i];
            }
        } else {
            element = output_document.createElementNS(xhtml_ns, template[0]);
            for (var name in template[1]) {
                if (template[1].hasOwnProperty(name)) {
                    element.setAttribute(name, template[1][name]);
                }
            }
            for (var i = 2; i < template.length; i++) {
                if (template[i] instanceof Object) {
                    var sub_element = make_dom(template[i]);
                    element.appendChild(sub_element);
                } else {
                    var text_node = output_document.createTextNode(template[i]);
                    element.appendChild(text_node);
                }
            }
        }

        return element;
    }

    function make_dom(template, substitutions, output_document)
    {
        if (is_single_node(template)) {
            return make_dom_single(template, output_document);
        }

        return map(template, function(x) {
                       return make_dom_single(x, output_document);
                   });
    }

    function render(template, substitutions, output_document)
    {
        return make_dom(substitute(template, substitutions), output_document);
    }

    /*
     * Utility functions
     */
    function assert(expected_true, function_name, description, error, substitutions)
    {
        if (expected_true !== true) {
            var msg = make_message(function_name, description,
                                   error, substitutions);
            throw new AssertionError(msg);
        }
    }

    function AssertionError(message)
    {
        this.message = message;
        this.stack = this.get_stack();
    }
    expose(AssertionError, "AssertionError");

    AssertionError.prototype = Object.create(Error.prototype);

    AssertionError.prototype.get_stack = function() {
        var stack = new Error().stack;
        // IE11 does not initialize 'Error.stack' until the object is thrown.
        if (!stack) {
            try {
                throw new Error();
            } catch (e) {
                stack = e.stack;
            }
        }

        // 'Error.stack' is not supported in all browsers/versions
        if (!stack) {
            return "(Stack trace unavailable)";
        }

        var lines = stack.split("\n");

        // Create a pattern to match stack frames originating within testharness.js.  These include the
        // script URL, followed by the line/col (e.g., '/resources/testharness.js:120:21').
        // Escape the URL per http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
        // in case it contains RegExp characters.
        var script_url = get_script_url();
        var re_text = script_url ? script_url.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') : "\\btestharness.js";
        var re = new RegExp(re_text + ":\\d+:\\d+");

        // Some browsers include a preamble that specifies the type of the error object.  Skip this by
        // advancing until we find the first stack frame originating from testharness.js.
        var i = 0;
        while (!re.test(lines[i]) && i < lines.length) {
            i++;
        }

        // Then skip the top frames originating from testharness.js to begin the stack at the test code.
        while (re.test(lines[i]) && i < lines.length) {
            i++;
        }

        // Paranoid check that we didn't skip all frames.  If so, return the original stack unmodified.
        if (i >= lines.length) {
            return stack;
        }

        return lines.slice(i).join("\n");
    }

    function OptionalFeatureUnsupportedError(message)
    {
        AssertionError.call(this, message);
    }
    OptionalFeatureUnsupportedError.prototype = Object.create(AssertionError.prototype);
    expose(OptionalFeatureUnsupportedError, "OptionalFeatureUnsupportedError");

    function make_message(function_name, description, error, substitutions)
    {
        for (var p in substitutions) {
            if (substitutions.hasOwnProperty(p)) {
                substitutions[p] = format_value(substitutions[p]);
            }
        }
        var node_form = substitute(["{text}", "${function_name}: ${description}" + error],
                                   merge({function_name:function_name,
                                          description:(description?description + " ":"")},
                                          substitutions));
        return node_form.slice(1).join("");
    }

    function filter(array, callable, thisObj) {
        var rv = [];
        for (var i = 0; i < array.length; i++) {
            if (array.hasOwnProperty(i)) {
                var pass = callable.call(thisObj, array[i], i, array);
                if (pass) {
                    rv.push(array[i]);
                }
            }
        }
        return rv;
    }

    function map(array, callable, thisObj)
    {
        var rv = [];
        rv.length = array.length;
        for (var i = 0; i < array.length; i++) {
            if (array.hasOwnProperty(i)) {
                rv[i] = callable.call(thisObj, array[i], i, array);
            }
        }
        return rv;
    }

    function extend(array, items)
    {
        Array.prototype.push.apply(array, items);
    }

    function forEach(array, callback, thisObj)
    {
        for (var i = 0; i < array.length; i++) {
            if (array.hasOwnProperty(i)) {
                callback.call(thisObj, array[i], i, array);
            }
        }
    }

    /**
     * Immediately invoke a "iteratee" function with a series of values in
     * parallel and invoke a final "done" function when all of the "iteratee"
     * invocations have signaled completion.
     *
     * If all callbacks complete synchronously (or if no callbacks are
     * specified), the `done_callback` will be invoked synchronously. It is the
     * responsibility of the caller to ensure asynchronicity in cases where
     * that is desired.
     *
     * @param {array} value Zero or more values to use in the invocation of
     *                      `iter_callback`
     * @param {function} iter_callback A function that will be invoked once for
     *                                 each of the provided `values`. Two
     *                                 arguments will be available in each
     *                                 invocation: the value from `values` and
     *                                 a function that must be invoked to
     *                                 signal completion
     * @param {function} done_callback A function that will be invoked after
     *                                 all operations initiated by the
     *                                 `iter_callback` function have signaled
     *                                 completion
     */
    function all_async(values, iter_callback, done_callback)
    {
        var remaining = values.length;

        if (remaining === 0) {
            done_callback();
        }

        forEach(values,
                function(element) {
                    var invoked = false;
                    var elDone = function() {
                        if (invoked) {
                            return;
                        }

                        invoked = true;
                        remaining -= 1;

                        if (remaining === 0) {
                            done_callback();
                        }
                    };

                    iter_callback(element, elDone);
                });
    }

    function merge(a,b)
    {
        var rv = {};
        var p;
        for (p in a) {
            rv[p] = a[p];
        }
        for (p in b) {
            rv[p] = b[p];
        }
        return rv;
    }

    function expose(object, name)
    {
        var components = name.split(".");
        var target = global_scope;
        for (var i = 0; i < components.length - 1; i++) {
            if (!(components[i] in target)) {
                target[components[i]] = {};
            }
            target = target[components[i]];
        }
        target[components[components.length - 1]] = object;
    }

    function is_same_origin(w) {
        try {
            'random_prop' in w;
            return true;
        } catch (e) {
            return false;
        }
    }

    /** Returns the 'src' URL of the first <script> tag in the page to include the file 'testharness.js'. */
    function get_script_url()
    {
        if (!('document' in global_scope)) {
            return undefined;
        }

        var scripts = document.getElementsByTagName("script");
        for (var i = 0; i < scripts.length; i++) {
            var src;
            if (scripts[i].src) {
                src = scripts[i].src;
            } else if (scripts[i].href) {
                //SVG case
                src = scripts[i].href.baseVal;
            }

            var matches = src && src.match(/^(.*\/|)testharness\.js$/);
            if (matches) {
                return src;
            }
        }
        return undefined;
    }

    /** Returns the <title> or filename or "Untitled" */
    function get_title()
    {
        if ('document' in global_scope) {
            //Don't use document.title to work around an Opera bug in XHTML documents
            var title = document.getElementsByTagName("title")[0];
            if (title && title.firstChild && title.firstChild.data) {
                return title.firstChild.data;
            }
        }
        if ('META_TITLE' in global_scope && META_TITLE) {
            return META_TITLE;
        }
        if ('location' in global_scope) {
            return location.pathname.substring(location.pathname.lastIndexOf('/') + 1, location.pathname.indexOf('.'));
        }
        return "Untitled";
    }

    function supports_post_message(w)
    {
        var supports;
        var type;
        // Given IE implements postMessage across nested iframes but not across
        // windows or tabs, you can't infer cross-origin communication from the presence
        // of postMessage on the current window object only.
        //
        // Touching the postMessage prop on a window can throw if the window is
        // not from the same origin AND post message is not supported in that
        // browser. So just doing an existence test here won't do, you also need
        // to wrap it in a try..catch block.
        try {
            type = typeof w.postMessage;
            if (type === "function") {
                supports = true;
            }

            // IE8 supports postMessage, but implements it as a host object which
            // returns "object" as its `typeof`.
            else if (type === "object") {
                supports = true;
            }

            // This is the case where postMessage isn't supported AND accessing a
            // window property across origins does NOT throw (e.g. old Safari browser).
            else {
                supports = false;
            }
        } catch (e) {
            // This is the case where postMessage isn't supported AND accessing a
            // window property across origins throws (e.g. old Firefox browser).
            supports = false;
        }
        return supports;
    }

    /**
     * Setup globals
     */

    var tests = new Tests();

    if (global_scope.addEventListener) {
        var error_handler = function(error, message, stack) {
            var optional_unsupported = error instanceof OptionalFeatureUnsupportedError;
            if (tests.file_is_test) {
                var test = tests.tests[0];
                if (test.phase >= test.phases.HAS_RESULT) {
                    return;
                }
                var status = optional_unsupported ? test.PRECONDITION_FAILED : test.FAIL;
                test.set_status(status, message, stack);
                test.phase = test.phases.HAS_RESULT;
            } else if (!tests.allow_uncaught_exception) {
                var status = optional_unsupported ? tests.status.PRECONDITION_FAILED : tests.status.ERROR;
                tests.status.status = status;
                tests.status.message = message;
                tests.status.stack = stack;
            }

            // Do not transition to the "complete" phase if the test has been
            // configured to allow uncaught exceptions. This gives the test an
            // opportunity to define subtests based on the exception reporting
            // behavior.
            if (!tests.allow_uncaught_exception) {
                done();
            }
        };

        addEventListener("error", function(e) {
            var message = e.message;
            var stack;
            if (e.error && e.error.stack) {
                stack = e.error.stack;
            } else {
                stack = e.filename + ":" + e.lineno + ":" + e.colno;
            }
            error_handler(e.error, message, stack);
        }, false);

        addEventListener("unhandledrejection", function(e) {
            var message;
            if (e.reason && e.reason.message) {
                message = "Unhandled rejection: " + e.reason.message;
            } else {
                message = "Unhandled rejection";
            }
            var stack;
            if (e.reason && e.reason.stack) {
                stack = e.reason.stack;
            }
            error_handler(e.reason, message, stack);
        }, false);
    }

    test_environment.on_tests_ready();

    /**
     * Stylesheet
     */
     var stylesheetContent = "\
html {\
    font-family:DejaVu Sans, Bitstream Vera Sans, Arial, Sans;\
}\
\
#log .warning,\
#log .warning a {\
  color: black;\
  background: yellow;\
}\
\
#log .error,\
#log .error a {\
  color: white;\
  background: red;\
}\
\
section#summary {\
    margin-bottom:1em;\
}\
\
table#results {\
    border-collapse:collapse;\
    table-layout:fixed;\
    width:100%;\
}\
\
table#results th:first-child,\
table#results td:first-child {\
    width:8em;\
}\
\
table#results th:last-child,\
table#results td:last-child {\
    width:50%;\
}\
\
table#results.assertions th:last-child,\
table#results.assertions td:last-child {\
    width:35%;\
}\
\
table#results th {\
    padding:0;\
    padding-bottom:0.5em;\
    border-bottom:medium solid black;\
}\
\
table#results td {\
    padding:1em;\
    padding-bottom:0.5em;\
    border-bottom:thin solid black;\
}\
\
tr.pass > td:first-child {\
    color:green;\
}\
\
tr.fail > td:first-child {\
    color:red;\
}\
\
tr.timeout > td:first-child {\
    color:red;\
}\
\
tr.notrun > td:first-child {\
    color:blue;\
}\
\
tr.optionalunsupported > td:first-child {\
    color:blue;\
}\
\
.pass > td:first-child, .fail > td:first-child, .timeout > td:first-child, .notrun > td:first-child, .optionalunsupported > td:first-child {\
    font-variant:small-caps;\
}\
\
table#results span {\
    display:block;\
}\
\
table#results span.expected {\
    font-family:DejaVu Sans Mono, Bitstream Vera Sans Mono, Monospace;\
    white-space:pre;\
}\
\
table#results span.actual {\
    font-family:DejaVu Sans Mono, Bitstream Vera Sans Mono, Monospace;\
    white-space:pre;\
}\
\
span.ok {\
    color:green;\
}\
\
tr.error {\
    color:red;\
}\
\
span.timeout {\
    color:red;\
}\
\
span.ok, span.timeout, span.error {\
    font-variant:small-caps;\
}\
";

})(this);
// vim: set expandtab shiftwidth=4 tabstop=4:
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/test/wasm-js/wasm-js.status                                                     0000664 0000000 0000000 00000007377 14746647661 0021251 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2018 the V8 project authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

[

[ALWAYS, {
  # This test can only be executed in the browser
  'wpt/idlharness': [SKIP],
  # Failing WPT tests
  'wpt/exception/type.tentative': [FAIL],
  'wpt/function/constructor.tentative': [FAIL],
  # TODO(v8): Should work after
  # https://github.com/WebAssembly/exception-handling/pull/257 landed and the
  # tests have been updated.
  'wpt/exception/getArg.tentative': [FAIL],

  # Failing spec tests after test update
  'proposals/js-types/function/constructor.tentative': [FAIL],
  'proposals/gc/gc/casts.tentative': [FAIL],
  'wpt/gc/casts.tentative': [FAIL],
  'proposals/memory64/table/constructor': [FAIL],
  'wpt/module/moduleSource': [FAIL],

  # This is a spec test of the https://github.com/WebAssembly/esm-integration
  # proposal which V8 does not implement yet.
  'wpt/module/moduleSource.tentative': [FAIL],

  # Outdated proposal tests.
  'proposals/js-types/table/get-set': [FAIL],
  'proposals/memory64/table/get-set': [FAIL],
  'proposals/tail-call/table/get-set': [FAIL],
  'proposals/js-types/memory/constructor': [FAIL],
  'proposals/tail-call/memory/constructor': [FAIL],
  'proposals/js-types/interface': [FAIL],
  'proposals/memory64/interface': [FAIL],
  'proposals/simd/interface': [FAIL],
  'proposals/tail-call/interface': [FAIL],

  # TODO(v8:10556): Remove sub-typing in the reference-types implementation
  'proposals/js-types/constructor/instantiate': [FAIL],
  'proposals/js-types/global/value-get-set': [FAIL],
  'proposals/js-types/instance/constructor': [FAIL],

  # Limits tests are slow, and not useful to run for the proposals:
  'proposals/extended-const/limits': [SKIP],
  'proposals/js-types/limits': [SKIP],
  'proposals/memory64/limits': [SKIP],
  'proposals/multi-memory/limits': [SKIP],
  'proposals/tail-call/limits': [SKIP],

  # Tests that need to run sequentially (e.g. due to memory consumption).
  # TODO(14258): Switch back to [PASS, HEAVY] once wasm-js tests allow more
  # than one memory. Github issue:
  # https://github.com/WebAssembly/multi-memory/issues/49
  'limits': [FAIL, HEAVY],

  # TODO(thibaudm): Test failing after the type-reflection change around
  # WebAssembly.Function.type. The tests should be updated anyway since they
  # still use the old API (which works but is deprecated).
  'proposals/js-promise-integration/js-promise-integration/js-promise-integration': [FAIL],
}], # ALWAYS

['system == android', {
  # Slow, and we always have the same limits anyway.
  # Android bots don't have enough memory to run the test.
  'limits': [SKIP],
}],  # 'system == android'

['arch == s390 or arch == s390x or system == aix', {
  # https://bugs.chromium.org/p/v8/issues/detail?id=8402
  'instance/constructor': [SKIP],
  'constructor/instantiate': [SKIP],
}],  # 'arch == s390 or arch == s390x or system == aix'

['arch == ppc64', {
  # Test needs larger than supported single code space.
  'limits': [SKIP],
}],  # 'arch == ppc64'

['mode == debug or simulator_run or variant != default or arch == arm or tsan or msan or asan', {
  # Slow, and we always have the same limits anyway.
  # ODroid bots don't have enough memory to run the test.
  'limits': [SKIP],
}],  # mode == debug or simulator_run or variant != default or arch == arm or tsan or msan or asan

##############################################################################
# TODO(v8:7777): Change this once wasm is supported in jitless mode.
['not has_webassembly or variant == jitless', {
  '*': [SKIP],
}],  # not has_webassembly or variant == jitless

################################################################################
['variant == stress_snapshot', {
  '*': [SKIP],  # only relevant for mjsunit tests.
}],

]
                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/wasm-spec-tests/                                                           0000775 0000000 0000000 00000000000 14746647661 0020063 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/test/wasm-spec-tests/BUILD.gn                                                   0000664 0000000 0000000 00000000467 14746647661 0021257 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2018 the V8 project authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

group("v8_wasm_spec_tests") {
  testonly = true

  data_deps = [
    "../..:d8",
    "../../tools:v8_testrunner",
  ]

  data = [
    "./",
  ]
}
                                                                                                                                                                                                         node-23.7.0/deps/v8/test/wasm-spec-tests/DIR_METADATA                                               0000664 0000000 0000000 00000000641 14746647661 0021665 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Metadata information for this directory.
#
# For more information on DIR_METADATA files, see:
#   https://source.chromium.org/chromium/infra/infra/+/master:go/src/infra/tools/dirmd/README.md
#
# For the schema of this file, see Metadata message:
#   https://source.chromium.org/chromium/infra/infra/+/master:go/src/infra/tools/dirmd/proto/dir_metadata.proto

monorail {
  component: "Blink>JavaScript>WebAssembly"
}                                                                                               node-23.7.0/deps/v8/test/wasm-spec-tests/OWNERS                                                     0000664 0000000 0000000 00000000033 14746647661 0021017 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        file:../../src/wasm/OWNERS
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/wasm-spec-tests/testcfg.py                                                 0000664 0000000 0000000 00000003451 14746647661 0022077 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2017 the V8 project authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import os

from testrunner.local import testsuite
from testrunner.objects import testcase

proposal_flags = [
    {
        'name': 'js-types',
        'flags': ['--experimental-wasm-type-reflection']
    },
    {
        'name': 'tail-call',
        'flags': []
    },
    {
        'name': 'memory64',
        'flags': ['--experimental-wasm-memory64']
    },
    {
        'name': 'extended-const',
        'flags': []
    },
    {
        'name': 'function-references',
        'flags': []
    },
    {
        'name': 'gc',
        'flags': []
    },
    {
        'name': 'multi-memory',
        'flags': ['--experimental-wasm-multi-memory']
    },
    {
        'name': 'exception-handling',
        # This flag enables the *new* exception handling proposal. The legacy
        # proposal is enabled by default.
        'flags': ['--experimental-wasm-exnref', '--turboshaft-wasm']
    },
    {
        'name': 'js-promise-integration',
        'flags': ['--experimental-wasm-jspi']
    }
]


class TestLoader(testsuite.JSTestLoader):
  pass

class TestSuite(testsuite.TestSuite):

  def __init__(self, ctx, *args, **kwargs):
    super(TestSuite, self).__init__(ctx, *args, **kwargs)
    self.test_root = self.root / "tests"
    self._test_loader.test_root = self.test_root

  def _test_loader_class(self):
    return TestLoader

  def _test_class(self):
    return TestCase

class TestCase(testcase.D8TestCase):
  def _get_files_params(self):
    return [self.suite.test_root / self.path_js]

  def _get_source_flags(self):
    for proposal in proposal_flags:
      if f"proposals/{proposal['name']}" in self.name:
        return proposal['flags']
    return []
                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/wasm-spec-tests/tests.tar.gz.sha1                                          0000664 0000000 0000000 00000000050 14746647661 0023202 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        3548183660d38fac0b5fc96171a19b1340ea902c                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/wasm-spec-tests/wasm-spec-tests.status                                     0000664 0000000 0000000 00000023450 14746647661 0024373 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2016 the V8 project authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

[
[ALWAYS, {
  'skip-stack-guard-page': [PASS, ['((arch == ppc or arch == ppc64 or arch == s390 or arch == s390x) and simulator_run)', SKIP]],
  # Missing rebase in the proposal repository.
  'proposals/js-types/table': [FAIL],
  # "data" is supposed to fail for "data segment does not fit"; missing rebase
  # on https://github.com/WebAssembly/spec/commit/7fa2f20a.
  'proposals/memory64/data': [FAIL],
  # "elem" is supposed to fail for "elements segment does not fit"; missing
  # rebase on https://github.com/WebAssembly/spec/commit/7fa2f20a.
  'proposals/memory64/elem': [FAIL],
  # "imports" is supposed to fail for "multiple tables"; missing rebase on
  # https://github.com/WebAssembly/spec/commit/7fa2f20a.
  'proposals/memory64/imports': [FAIL],
  # "linking" is supposed to fail for "elements segment does not fit"; missing
  # rebase on https://github.com/WebAssembly/spec/commit/7fa2f20a.
  'proposals/memory64/linking': [FAIL],
  # "table" is supposed to fail for "multiple tables"; missing rebase on
  # https://github.com/WebAssembly/spec/commit/7fa2f20a.
  'proposals/memory64/table': [FAIL],
  # "unreached-invalid" is supposed to fail for "type mismatch"; missing rebase
  # on https://github.com/WebAssembly/spec/commit/7fa2f20a.
  'proposals/memory64/unreached-invalid': [FAIL],

  'proposals/gc/imports': [FAIL],
  'proposals/extended-const/imports': [FAIL],
  'proposals/js-types/imports': [FAIL],
  'proposals/tail-call/imports': [FAIL],

  # TODO(wasm): Roll newest tests into "js-types" repository.
  'proposals/js-types/globals': [FAIL],

  # Tests that need to run sequentially (e.g. due to memory consumption).
  'simd_f32x4*': [PASS, HEAVY],
  'simd_f64x2*': [PASS, HEAVY],
  'f32*': [PASS, HEAVY],
  'f64*': [PASS, HEAVY],

  # TODO(https://issues.chromium.org/342316792) Failing test after spec test update
  'proposals/tail-call/memory': [FAIL],
  'proposals/js-types/memory': [FAIL],
  'proposals/exception-handling/memory': [FAIL],
  'proposals/extended-const/memory': [FAIL],
  'proposals/js-promise-integration/memory': [FAIL],

  # The function-references spec tests haven't been updated to the final
  # binary encoding. We don't care, because the GC tests are up to date and
  # we'll ship both proposals together.
  'proposals/function-references/*': [SKIP],

  # These break with the GC proposal (because they check that certain modules
  # don't validate that become valid with GC). The GC proposal will update them
  # when it is merged into the main spec repository.
  'data': [FAIL],
  'proposals/extended-const/data': [FAIL],
  'proposals/multi-memory/data': [FAIL],

  # These break with the GC proposal (because they check that certain modules
  # don't validate that become valid with GC). The GC proposal will update them
  # when it is merged into the main spec repository.
  # With the GC proposal global.get is a constant instruction, independent on
  # the type of the global. In the main spec repository, only global.get of
  # imported globals are allowed.
  'elem': [FAIL],
  'proposals/extended-const/elem': [FAIL],
  'proposals/js-types/elem': [FAIL],
  'proposals/multi-memory/elem': [FAIL],
  'proposals/tail-call/elem': [FAIL],
  'proposals/exception-handling/elem': [FAIL],
  'proposals/js-promise-integration/elem': [FAIL],

  'global': [FAIL],
  'proposals/extended-const/global': [FAIL],

  # These tests need to be rebased on the multi-memory proposal once it's
  # merged into the main repository. They test that not more than one memory
  # can be declared ("memory" / "memory64") or imported ("imports"), or that
  # the byte for encoding the memory index is a single byte (and no LEB,
  # "binary").
  'binary': [FAIL],
  'imports': [FAIL],
  'memory': [FAIL],
  'proposals/extended-const/binary': [FAIL],
  'proposals/gc/binary': [FAIL],
  'proposals/js-types/binary': [FAIL],
  'proposals/memory64/binary': [FAIL],
  'proposals/memory64/memory64': [FAIL],
  'proposals/memory64/memory': [FAIL],
  'proposals/tail-call/binary': [FAIL],
  'proposals/exception-handling/binary': [FAIL],
  'proposals/exception-handling/imports': [FAIL],

  # The test is incorrect as it exports a function with an exnref in the
  # signature, which is a runtime type error.
  'proposals/exception-handling/ref_null': [FAIL]
}],  # ALWAYS

['arch == arm and not simulator_run', {
  # See https://crbug.com/v8/10938 denormals not handled correctly on ARM.
  'simd_f32x4': [PASS, FAIL],
  'simd_f32x4_arith': [PASS, FAIL],
  'simd_f32x4_cmp': [PASS, FAIL],
  # This test only has 1 problematic use of f32x4.min and f32x4.div, consider
  # removing it from upstream, then we can run this test.
  'simd_splat' : [PASS, FAIL],
  'simd_f32x4_pmin_pmax' : [PASS, FAIL],
}],  # arch == arm and not simulator_run

['arch == mips64el or arch == mips64', {
  # These tests fail because mips does not support the correct NaN bit patterns.
  'float_misc': [SKIP],
  'float_exprs': [SKIP],
  'f32': [SKIP],
  'f64': [SKIP],
  'f32_bitwise': [SKIP],
  'f64_bitwise': [SKIP],
  'proposals/reference-types/conversions':  [SKIP],
  'proposals/bulk-memory-operations/conversions': [SKIP],
  'proposals/js-types/f32': [SKIP],
  'proposals/js-types/f64': [SKIP],
  'proposals/js-types/f32_bitwise': [SKIP],
  'proposals/js-types/f64_bitwise': [SKIP],
  'proposals/js-types/float_exprs': [SKIP],
  'proposals/js-types/float_misc': [SKIP],
  'proposals/js-types/conversions': [SKIP],
  'proposals/bulk-memory-operations/f32': [SKIP],
  'proposals/bulk-memory-operations/f64': [SKIP],
  'proposals/reference-types/f32': [SKIP],
  'proposals/reference-types/f64': [SKIP],
  'proposals/bulk-memory-operations/float_misc': [SKIP],
  'proposals/reference-types/float_misc': [SKIP],
  'proposals/tail-call/f32': [SKIP],
  'proposals/tail-call/f32_bitwise': [SKIP],
  'proposals/tail-call/f64': [SKIP],
  'proposals/tail-call/f64_bitwise': [SKIP],
  'proposals/tail-call/float_exprs': [SKIP],
  'proposals/tail-call/float_misc': [SKIP],
  'proposals/tail-call/conversions': [SKIP],
}],  # 'arch == mips64el or arch == mips64'

['(arch == mips64el or arch == mips64) and not simulator_run', {
  # This test fail because mips does not support the correct NaN bit patterns.
  # But it doesn't fail in simulator.
  'conversions': [SKIP],
}],  # '(arch == mips64el or arch == mips64) and not simulator_run'

['(arch == mips64el or arch == loong64) and simulator_run', {
  # These tests need larger stack size on simulator.
  'skip-stack-guard-page': '--sim-stack-size=8192',
  'proposals/tail-call/skip-stack-guard-page': '--sim-stack-size=8192',
}],  # '(arch == mips64el or arch == loong64) and simulator_run'

['arch == riscv64', {
   # These tests need larger stack size on simulator.
   'skip-stack-guard-page': '--sim-stack-size=8192',
   'proposals/tail-call/skip-stack-guard-page': '--sim-stack-size=8192',
}],  # 'arch == riscv64'



['arch == riscv32', {
   # These tests need larger stack size on simulator.
   'skip-stack-guard-page': '--sim-stack-size=8192',
   'proposals/tail-call/skip-stack-guard-page': '--sim-stack-size=8192',

   'func': ['variant == stress', SKIP],
}],  # 'arch == riscv32'

['arch == ppc or arch == ppc64', {
  # These tests fail because ppc float min and max doesn't convert sNaN to qNaN.
  'f32': [SKIP],
  'f64': [SKIP],
  'proposals/js-types/f32': [SKIP],
  'proposals/js-types/f64': [SKIP],
  'proposals/bulk-memory-operations/f32': [SKIP],
  'proposals/bulk-memory-operations/f64': [SKIP],
  'proposals/reference-types/f32': [SKIP],
  'proposals/reference-types/f64': [SKIP],
  'proposals/tail-call/f32': [SKIP],
  'proposals/tail-call/f64': [SKIP],
  # This test fails because ppc float to double doesn't convert sNaN to qNaN.
  'conversions': [SKIP],
  'proposals/js-types/conversions': [SKIP],
  'proposals/bulk-memory-operations/conversions': [SKIP],
  'proposals/reference-types/conversions':  [SKIP],
  'proposals/tail-call/conversions':  [SKIP],
}],  # 'arch == ppc or arch == ppc64'

['arch == s390 or arch == s390x', {
  # These tests fail because s390 float min and max doesn't convert sNaN to qNaN.
  'f32': [SKIP],
  'f64': [SKIP],
  'proposals/js-types/f32': [SKIP],
  'proposals/js-types/f64': [SKIP],
  'proposals/bulk-memory-operations/f32': [SKIP],
  'proposals/bulk-memory-operations/f64': [SKIP],
  'proposals/reference-types/f32': [SKIP],
  'proposals/reference-types/f64': [SKIP],
  'proposals/tail-call/f32': [SKIP],
  'proposals/tail-call/f64': [SKIP],
}],  # 'arch == s390 or arch == s390x'

##############################################################################
# TODO(v8:7777): Change this once wasm is supported in jitless mode.
['not has_webassembly or variant == jitless', {
  '*': [SKIP],
}],  # not has_webassembly or variant == jitless

##############################################################################
['variant == stress_snapshot', {
  '*': [SKIP],  # only relevant for mjsunit tests.
}],  # variant == stress_snapshot

##############################################################################
['no_simd_hardware == True', {
  'linking': [SKIP],
  'simd*': [SKIP],
  'proposals/js-types/linking': [SKIP],
  'proposals/multi-memory/simd_memory-multi': [SKIP],
  'proposals/tail-call/simd_lane': [SKIP],
  'proposals/memory64/simd_address': [SKIP],
}],  # no_simd_hardware == True

##############################################################################
['variant == stress', {
  # Spec tests are executing long enough even without stress mode.
  # As stress mode is unlikely to flush out bugs, skip the tests there.
  '*': [SKIP],
}],  # variant == stress

##############################################################################
# Skip tests that require a large amount of virtual address space (inside the
# sandbox if that is enabled) if tsan is enabled.
['tsan == True', {
  'memory_copy': [SKIP],
}],  # tsan == True

]
                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/webkit/                                                                    0000775 0000000 0000000 00000000000 14746647661 0016311 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/test/webkit/Array-isArray-expected.txt                                          0000664 0000000 0000000 00000004204 14746647661 0023337 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Test to ensure correct behaviour of Array.array

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS Array.isArray([]) is true
PASS Array.isArray(new Array) is true
PASS Array.isArray(Array()) is true
PASS Array.isArray('abc'.match(/(a)*/g)) is true
PASS (function(){ return Array.isArray(arguments); })() is false
PASS Array.isArray() is false
PASS Array.isArray(null) is false
PASS Array.isArray(undefined) is false
PASS Array.isArray(true) is false
PASS Array.isArray(false) is false
PASS Array.isArray('a string') is false
PASS Array.isArray({}) is false
PASS Array.isArray({length: 5}) is false
PASS Array.isArray({__proto__: Array.prototype, length:1, 0:1, 1:2}) is false
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/webkit/Array-isArray.js                                                    0000664 0000000 0000000 00000004135 14746647661 0021340 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description("Test to ensure correct behaviour of Array.array");

shouldBeTrue("Array.isArray([])");
shouldBeTrue("Array.isArray(new Array)");
shouldBeTrue("Array.isArray(Array())");
shouldBeTrue("Array.isArray('abc'.match(/(a)*/g))");
shouldBeFalse("(function(){ return Array.isArray(arguments); })()");
shouldBeFalse("Array.isArray()");
shouldBeFalse("Array.isArray(null)");
shouldBeFalse("Array.isArray(undefined)");
shouldBeFalse("Array.isArray(true)");
shouldBeFalse("Array.isArray(false)");
shouldBeFalse("Array.isArray('a string')");
shouldBeFalse("Array.isArray({})");
shouldBeFalse("Array.isArray({length: 5})");
shouldBeFalse("Array.isArray({__proto__: Array.prototype, length:1, 0:1, 1:2})");
                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/webkit/BUILD.gn                                                            0000664 0000000 0000000 00000000456 14746647661 0017503 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2018 the V8 project authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

group("v8_webkit") {
  testonly = true

  data_deps = [
    "../..:d8",
    "../../tools:v8_testrunner",
  ]

  data = [
    "./",
  ]
}
                                                                                                                                                                                                                  node-23.7.0/deps/v8/test/webkit/JSON-stringify-replacer-expected.txt                                0000664 0000000 0000000 00000006537 14746647661 0025244 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Test to ensure correct behaviour of replacer functions in JSON.stringify

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS JSON.stringify(object, returnUndefined) is undefined.
PASS JSON.stringify(array, returnUndefined) is undefined.
PASS JSON.stringify(object, returnObjectFor1) is '{"0":0,"1":{},"2":2}'
PASS JSON.stringify(array, returnObjectFor1) is '[0,{},2,null]'
PASS JSON.stringify(object, returnArrayFor1) is '{"0":0,"1":[],"2":2}'
PASS JSON.stringify(array, returnArrayFor1) is '[0,[],2,null]'
PASS JSON.stringify(object, returnUndefinedFor1) is '{"0":0,"2":2}'
PASS JSON.stringify(array, returnUndefinedFor1) is '[0,null,2,null]'
PASS JSON.stringify(object, returnFunctionFor1) is '{"0":0,"2":2}'
PASS JSON.stringify(array, returnFunctionFor1) is '[0,null,2,null]'
PASS JSON.stringify(object, returnNullFor1) is '{"0":0,"1":null,"2":2}'
PASS JSON.stringify(array, returnNullFor1) is '[0,null,2,null]'
PASS JSON.stringify(object, returnStringForUndefined) is '{"0":0,"1":1,"2":2,"3":"undefined value"}'
PASS JSON.stringify(array, returnStringForUndefined) is '[0,1,2,"undefined value"]'
PASS JSON.stringify(object, returnCycleObjectFor1) threw exception TypeError: Converting circular structure to JSON
    --> starting at object with constructor 'Object'
    --- property '1' closes the circle.
PASS JSON.stringify(array, returnCycleObjectFor1) threw exception TypeError: Converting circular structure to JSON
    --> starting at object with constructor 'Object'
    --- property '1' closes the circle.
PASS JSON.stringify(object, returnCycleArrayFor1) threw exception TypeError: Converting circular structure to JSON
    --> starting at object with constructor 'Array'
    --- index 1 closes the circle.
PASS JSON.stringify(array, returnCycleArrayFor1) threw exception TypeError: Converting circular structure to JSON
    --> starting at object with constructor 'Array'
    --- index 1 closes the circle.
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                 node-23.7.0/deps/v8/test/webkit/JSON-stringify-replacer.js                                          0000664 0000000 0000000 00000007254 14746647661 0023237 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description("Test to ensure correct behaviour of replacer functions in JSON.stringify");

var object = {0:0, 1:1, 2:2, 3:undefined};
var array = [0, 1, 2, undefined];
function returnUndefined(){}
function returnObjectFor1(k, v) {
    if (k == "1")
        return {};
    return v;
}
function returnArrayFor1(k, v) {
    if (k == "1")
        return [];
    return v;
}
function returnUndefinedFor1(k, v) {
    if (k == "1")
        return undefined;
    return v;
}
function returnNullFor1(k, v) {
    if (k == "1")
        return null;
    return v;
}
function returnCycleObjectFor1(k, v) {
    if (k == "1")
        return object;
    return v;
}
function returnCycleArrayFor1(k, v) {
    if (k == "1")
        return array;
    return v;
}
function returnFunctionFor1(k, v) {
    if (k == "1")
        return function(){};
    return v;
}
function returnStringForUndefined(k, v) {
    if (v === undefined)
        return "undefined value";
    return v;
}

shouldBeUndefined("JSON.stringify(object, returnUndefined)");
shouldBeUndefined("JSON.stringify(array, returnUndefined)");

shouldBe("JSON.stringify(object, returnObjectFor1)", '\'{"0":0,"1":{},"2":2}\'');
shouldBe("JSON.stringify(array, returnObjectFor1)", '\'[0,{},2,null]\'');

shouldBe("JSON.stringify(object, returnArrayFor1)", '\'{"0":0,"1":[],"2":2}\'');
shouldBe("JSON.stringify(array, returnArrayFor1)", '\'[0,[],2,null]\'');

shouldBe("JSON.stringify(object, returnUndefinedFor1)", '\'{"0":0,"2":2}\'');
shouldBe("JSON.stringify(array, returnUndefinedFor1)", '\'[0,null,2,null]\'');

shouldBe("JSON.stringify(object, returnFunctionFor1)", '\'{"0":0,"2":2}\'');
shouldBe("JSON.stringify(array, returnFunctionFor1)", '\'[0,null,2,null]\'');

shouldBe("JSON.stringify(object, returnNullFor1)", '\'{"0":0,"1":null,"2":2}\'');
shouldBe("JSON.stringify(array, returnNullFor1)", '\'[0,null,2,null]\'');

shouldBe("JSON.stringify(object, returnStringForUndefined)", '\'{"0":0,"1":1,"2":2,"3":"undefined value"}\'');
shouldBe("JSON.stringify(array, returnStringForUndefined)", '\'[0,1,2,"undefined value"]\'');

shouldThrow("JSON.stringify(object, returnCycleObjectFor1)");
shouldThrow("JSON.stringify(array, returnCycleObjectFor1)");

shouldThrow("JSON.stringify(object, returnCycleArrayFor1)");
shouldThrow("JSON.stringify(array, returnCycleArrayFor1)");
                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/test/webkit/Object-create-expected.txt                                          0000664 0000000 0000000 00000006142 14746647661 0023323 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Test to ensure correct behaviour of Object.defineProperties

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS Object.create() threw exception TypeError: Object prototype may only be an Object or null: undefined.
PASS Object.create('a string') threw exception TypeError: Object prototype may only be an Object or null: a string.
PASS Object.create({}, 'a string') threw exception TypeError: Property description must be an object: a.
PASS Object.create(null, 'a string') threw exception TypeError: Property description must be an object: a.
PASS JSON.stringify(Object.create(null,{property:{value:'foo', enumerable:true}, property2:{value:'foo', enumerable:true}})) is '{"property":"foo","property2":"foo"}'
PASS JSON.stringify(Object.create({},{property:{value:'foo', enumerable:true}, property2:{value:'foo', enumerable:true}})) is '{"property":"foo","property2":"foo"}'
PASS JSON.stringify(Object.create({},{property:{value:'foo'}, property2:{value:'foo', enumerable:true}})) is '{"property2":"foo"}'
PASS JSON.stringify(Object.create(null,{property:{value:'foo'}, property2:{value:'foo', enumerable:true}})) is '{"property2":"foo"}'
PASS Object.getPrototypeOf(Object.create(Array.prototype)) is Array.prototype
PASS Object.getPrototypeOf(Object.create(null)) is null
PASS Object.create(null, DescriptorWithValueGetter).foo is true
PASS Object.create(null, DescriptorWithEnumerableGetter).foo is true
PASS Object.create(null, DescriptorWithConfigurableGetter).foo is true
PASS Object.create(null, DescriptorWithWritableGetter).foo is true
PASS Object.create(null, DescriptorWithGetGetter).foo is true
PASS Object.create(null, DescriptorWithSetGetter).foo is true
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/webkit/Object-create.js                                                    0000664 0000000 0000000 00000007046 14746647661 0021325 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description("Test to ensure correct behaviour of Object.defineProperties");

shouldThrow("Object.create()");
shouldThrow("Object.create('a string')");
shouldThrow("Object.create({}, 'a string')");
shouldThrow("Object.create(null, 'a string')");
shouldBe("JSON.stringify(Object.create(null,{property:{value:'foo', enumerable:true}, property2:{value:'foo', enumerable:true}}))", '\'{"property":"foo","property2":"foo"}\'');
shouldBe("JSON.stringify(Object.create({},{property:{value:'foo', enumerable:true}, property2:{value:'foo', enumerable:true}}))", '\'{"property":"foo","property2":"foo"}\'');
shouldBe("JSON.stringify(Object.create({},{property:{value:'foo'}, property2:{value:'foo', enumerable:true}}))", '\'{"property2":"foo"}\'');
shouldBe("JSON.stringify(Object.create(null,{property:{value:'foo'}, property2:{value:'foo', enumerable:true}}))", '\'{"property2":"foo"}\'');
shouldBe("Object.getPrototypeOf(Object.create(Array.prototype))", "Array.prototype");
shouldBe("Object.getPrototypeOf(Object.create(null))", "null");
function valueGet() { return true; }
var DescriptorWithValueGetter = { foo: Object.create(null, { value: { get: valueGet }})};
var DescriptorWithEnumerableGetter = { foo: Object.create(null, { value: {value: true}, enumerable: { get: valueGet }})};
var DescriptorWithConfigurableGetter = { foo: Object.create(null, { value: {value: true}, configurable: { get: valueGet }})};
var DescriptorWithWritableGetter = { foo: Object.create(null, { value: {value: true}, writable: { get: valueGet }})};
var DescriptorWithGetGetter = { foo: Object.create(null, { get: { get: function() { return valueGet } }})};
var DescriptorWithSetGetter = { foo: Object.create(null, { get: { value: valueGet}, set: { get: function(){ return valueGet; } }})};
shouldBeTrue("Object.create(null, DescriptorWithValueGetter).foo");
shouldBeTrue("Object.create(null, DescriptorWithEnumerableGetter).foo");
shouldBeTrue("Object.create(null, DescriptorWithConfigurableGetter).foo");
shouldBeTrue("Object.create(null, DescriptorWithWritableGetter).foo");
shouldBeTrue("Object.create(null, DescriptorWithGetGetter).foo");
shouldBeTrue("Object.create(null, DescriptorWithSetGetter).foo");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/webkit/Object-defineProperties-expected.txt                                0000664 0000000 0000000 00000005766 14746647661 0025402 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Test to ensure correct behaviour of Object.defineProperties

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS Object.defineProperties() threw exception TypeError: Object.defineProperties called on non-object.
PASS Object.defineProperties('a string') threw exception TypeError: Object.defineProperties called on non-object.
PASS Object.defineProperties({}, 'a string') threw exception TypeError: Property description must be an object: a.
PASS JSON.stringify(Object.defineProperties({},{property:{value:'foo', enumerable:true}, property2:{value:'foo', enumerable:true}})) is '{"property":"foo","property2":"foo"}'
PASS JSON.stringify(Object.defineProperties({},{property:{value:'foo'}, property2:{value:'foo', enumerable:true}})) is '{"property2":"foo"}'
PASS JSON.stringify(Object.defineProperties({property:'foo'},{property:{value:'foo', enumerable:true}, property2:{value:'foo', enumerable:true}})) is '{"property":"foo","property2":"foo"}'
PASS JSON.stringify(Object.defineProperties({property:'foo'},{property:{value:'foo', enumerable:false}, property2:{value:'foo', enumerable:true}})) is '{"property2":"foo"}'
PASS JSON.stringify(Object.defineProperties({property:'foo'},{property:{value:'foo'}, property2:{value:'foo', enumerable:true}})) is '{"property":"foo","property2":"foo"}'
PASS Object.defineProperties(emptyObject, {foo:{value: true}, bar:{get:function(){}, writable:true}}) threw exception TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute, #<Object>.
PASS 'foo' in emptyObject is false
PASS successfullyParsed is true

TEST COMPLETE

          node-23.7.0/deps/v8/test/webkit/Object-defineProperties.js                                          0000664 0000000 0000000 00000005255 14746647661 0023371 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description("Test to ensure correct behaviour of Object.defineProperties");

shouldThrow("Object.defineProperties()");
shouldThrow("Object.defineProperties('a string')");
shouldThrow("Object.defineProperties({}, 'a string')");
shouldBe("JSON.stringify(Object.defineProperties({},{property:{value:'foo', enumerable:true}, property2:{value:'foo', enumerable:true}}))", '\'{"property":"foo","property2":"foo"}\'');
shouldBe("JSON.stringify(Object.defineProperties({},{property:{value:'foo'}, property2:{value:'foo', enumerable:true}}))", '\'{"property2":"foo"}\'');
shouldBe("JSON.stringify(Object.defineProperties({property:'foo'},{property:{value:'foo', enumerable:true}, property2:{value:'foo', enumerable:true}}))", '\'{"property":"foo","property2":"foo"}\'');
shouldBe("JSON.stringify(Object.defineProperties({property:'foo'},{property:{value:'foo', enumerable:false}, property2:{value:'foo', enumerable:true}}))", '\'{"property2":"foo"}\'');
shouldBe("JSON.stringify(Object.defineProperties({property:'foo'},{property:{value:'foo'}, property2:{value:'foo', enumerable:true}}))", '\'{"property":"foo","property2":"foo"}\'');
emptyObject={};
shouldThrow("Object.defineProperties(emptyObject, {foo:{value: true}, bar:{get:function(){}, writable:true}})");
shouldBeFalse("'foo' in emptyObject");
                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/webkit/Object-keys-expected.txt                                            0000664 0000000 0000000 00000004012 14746647661 0023025 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Test to ensure correct behaviour of Object.keys

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS Object.keys({}) is []
PASS Object.keys({a:null}) is ['a']
PASS Object.keys({a:null, b:null}) is ['a', 'b']
PASS Object.keys({b:null, a:null}) is ['b', 'a']
PASS Object.keys([]) is []
PASS Object.keys([null]) is ['0']
PASS Object.keys([null,null]) is ['0','1']
PASS Object.keys([null,null,,,,null]) is ['0','1','5']
PASS Object.keys({__proto__:{a:null}}) is []
PASS Object.keys({__proto__:[1,2,3]}) is []
PASS x=[];x.__proto__=[1,2,3];Object.keys(x) is []
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/webkit/Object-keys.js                                                      0000664 0000000 0000000 00000004003 14746647661 0021023 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description("Test to ensure correct behaviour of Object.keys");

shouldBe("Object.keys({})", "[]");
shouldBe("Object.keys({a:null})", "['a']");
shouldBe("Object.keys({a:null, b:null})", "['a', 'b']");
shouldBe("Object.keys({b:null, a:null})", "['b', 'a']");
shouldBe("Object.keys([])", "[]");
shouldBe("Object.keys([null])", "['0']");
shouldBe("Object.keys([null,null])", "['0','1']");
shouldBe("Object.keys([null,null,,,,null])", "['0','1','5']");
shouldBe("Object.keys({__proto__:{a:null}})", "[]");
shouldBe("Object.keys({__proto__:[1,2,3]})", "[]");
shouldBe("x=[];x.__proto__=[1,2,3];Object.keys(x)", "[]");
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/webkit/ToNumber-expected.txt                                               0000664 0000000 0000000 00000012626 14746647661 0022413 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Test the JavaScript ToNumber operation.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS +undefined is NaN
PASS +null is 0
PASS +false is 0
PASS +true is 1
PASS +2 is 2
PASS +'' is 0
PASS +' ' is 0
PASS +' 1' is 1
PASS +'1 ' is 1
PASS +'x1' is NaN
PASS +'1x' is NaN
PASS +'0x1' is 1
PASS +'1x0' is NaN
PASS +(nullCharacter + '1') is NaN
PASS +('1' + nullCharacter) is NaN
PASS +('1' + nullCharacter + '1') is NaN
PASS +(nonASCIICharacter + '1') is NaN
PASS +('1' + nonASCIICharacter) is NaN
PASS +('1' + nonASCIICharacter + '1') is NaN
PASS +('1' + nonASCIINonSpaceCharacter) is NaN
PASS +(nonASCIINonSpaceCharacter + '1') is NaN
PASS +('1' + nonASCIINonSpaceCharacter + '1') is NaN
PASS +(illegalUTF16Sequence + '1') is NaN
PASS +('1' + illegalUTF16Sequence) is NaN
PASS +('1' + illegalUTF16Sequence + '1') is NaN
PASS +'inf' is NaN
PASS +'infinity' is NaN
PASS +'Inf' is NaN
PASS +'+inf' is NaN
PASS +'+infinity' is NaN
PASS +'+Inf' is NaN
PASS +'-inf' is NaN
PASS +'-infinity' is NaN
PASS +'-Inf' is NaN
PASS +'Infinity' is Infinity
PASS +'+Infinity' is Infinity
PASS +'-Infinity' is -Infinity
PASS +'++1' is NaN
PASS +'AB' is NaN
PASS +'0xAB' is 171
PASS +'1e1' is 10
PASS +'1E1' is 10
PASS +tab is 0
PASS +nbsp is 0
PASS +ff is 0
PASS +vt is 0
PASS +cr is 0
PASS +lf is 0
PASS +ls is 0
PASS +ps is 0
PASS +oghamSpaceMark is 0
PASS +mongolianVowelSeparator is NaN
PASS +enQuad is 0
PASS +emQuad is 0
PASS +enSpace is 0
PASS +emSpace is 0
PASS +threePerEmSpace is 0
PASS +fourPerEmSpace is 0
PASS +sixPerEmSpace is 0
PASS +figureSpace is 0
PASS +punctuationSpace is 0
PASS +thinSpace is 0
PASS +hairSpace is 0
PASS +narrowNoBreakSpace is 0
PASS +mediumMathematicalSpace is 0
PASS +ideographicSpace is 0
PASS +(tab + '1') is 1
PASS +(nbsp + '1') is 1
PASS +(ff + '1') is 1
PASS +(vt + '1') is 1
PASS +(cr + '1') is 1
PASS +(lf + '1') is 1
PASS +(ls + '1') is 1
PASS +(ps + '1') is 1
PASS +(oghamSpaceMark + '1') is 1
PASS +(mongolianVowelSeparator + '1') is NaN
PASS +(enQuad + '1') is 1
PASS +(emQuad + '1') is 1
PASS +(enSpace + '1') is 1
PASS +(emSpace + '1') is 1
PASS +(threePerEmSpace + '1') is 1
PASS +(fourPerEmSpace + '1') is 1
PASS +(sixPerEmSpace + '1') is 1
PASS +(figureSpace + '1') is 1
PASS +(punctuationSpace + '1') is 1
PASS +(thinSpace + '1') is 1
PASS +(hairSpace + '1') is 1
PASS +(narrowNoBreakSpace + '1') is 1
PASS +(mediumMathematicalSpace + '1') is 1
PASS +(ideographicSpace + '1') is 1
PASS +('1' + tab) is 1
PASS +('1' + nbsp) is 1
PASS +('1' + ff) is 1
PASS +('1' + vt) is 1
PASS +('1' + cr) is 1
PASS +('1' + lf) is 1
PASS +('1' + ls) is 1
PASS +('1' + ps) is 1
PASS +('1' + oghamSpaceMark) is 1
PASS +('1' + mongolianVowelSeparator) is NaN
PASS +('1' + enQuad) is 1
PASS +('1' + emQuad) is 1
PASS +('1' + enSpace) is 1
PASS +('1' + emSpace) is 1
PASS +('1' + threePerEmSpace) is 1
PASS +('1' + fourPerEmSpace) is 1
PASS +('1' + sixPerEmSpace) is 1
PASS +('1' + figureSpace) is 1
PASS +('1' + punctuationSpace) is 1
PASS +('1' + thinSpace) is 1
PASS +('1' + hairSpace) is 1
PASS +('1' + narrowNoBreakSpace) is 1
PASS +('1' + mediumMathematicalSpace) is 1
PASS +('1' + ideographicSpace) is 1
PASS +('1' + tab + '1') is NaN
PASS +('1' + nbsp + '1') is NaN
PASS +('1' + ff + '1') is NaN
PASS +('1' + vt + '1') is NaN
PASS +('1' + cr + '1') is NaN
PASS +('1' + lf + '1') is NaN
PASS +('1' + ls + '1') is NaN
PASS +('1' + ps + '1') is NaN
PASS +('1' + oghamSpaceMark + '1') is NaN
PASS +('1' + mongolianVowelSeparator + '1') is NaN
PASS +('1' + enQuad + '1') is NaN
PASS +('1' + emQuad + '1') is NaN
PASS +('1' + enSpace + '1') is NaN
PASS +('1' + emSpace + '1') is NaN
PASS +('1' + threePerEmSpace + '1') is NaN
PASS +('1' + fourPerEmSpace + '1') is NaN
PASS +('1' + sixPerEmSpace + '1') is NaN
PASS +('1' + figureSpace + '1') is NaN
PASS +('1' + punctuationSpace + '1') is NaN
PASS +('1' + thinSpace + '1') is NaN
PASS +('1' + hairSpace + '1') is NaN
PASS +('1' + narrowNoBreakSpace + '1') is NaN
PASS +('1' + mediumMathematicalSpace + '1') is NaN
PASS +('1' + ideographicSpace + '1') is NaN
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                          node-23.7.0/deps/v8/test/webkit/ToNumber.js                                                         0000664 0000000 0000000 00000017215 14746647661 0020410 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description('Test the JavaScript ToNumber operation.')

var nullCharacter = String.fromCharCode(0);
var nonASCIICharacter = String.fromCharCode(0x100);
var nonASCIINonSpaceCharacter = String.fromCharCode(0x13A0);
var illegalUTF16Sequence = String.fromCharCode(0xD800);

var tab = String.fromCharCode(9);
var nbsp = String.fromCharCode(0xA0);
var ff = String.fromCharCode(0xC);
var vt = String.fromCharCode(0xB);
var cr = String.fromCharCode(0xD);
var lf = String.fromCharCode(0xA);
var ls = String.fromCharCode(0x2028);
var ps = String.fromCharCode(0x2029);

var oghamSpaceMark = String.fromCharCode(0x1680);
var mongolianVowelSeparator = String.fromCharCode(0x180E);
var enQuad = String.fromCharCode(0x2000);
var emQuad = String.fromCharCode(0x2001);
var enSpace = String.fromCharCode(0x2002);
var emSpace = String.fromCharCode(0x2003);
var threePerEmSpace = String.fromCharCode(0x2004);
var fourPerEmSpace = String.fromCharCode(0x2005);
var sixPerEmSpace = String.fromCharCode(0x2006);
var figureSpace = String.fromCharCode(0x2007);
var punctuationSpace = String.fromCharCode(0x2008);
var thinSpace = String.fromCharCode(0x2009);
var hairSpace = String.fromCharCode(0x200A);
var narrowNoBreakSpace = String.fromCharCode(0x202F);
var mediumMathematicalSpace = String.fromCharCode(0x205F);
var ideographicSpace = String.fromCharCode(0x3000);

shouldBe("+undefined", "NaN");
shouldBe("+null", "0");
shouldBe("+false", "0");
shouldBe("+true", "1");
shouldBe("+2", "2");
shouldBe("+''", "0");
shouldBe("+' '", "0");
shouldBe("+' 1'", "1");
shouldBe("+'1 '", "1");
shouldBe("+'x1'", "NaN");
shouldBe("+'1x'", "NaN");
shouldBe("+'0x1'", "1");
shouldBe("+'1x0'", "NaN");
shouldBe("+(nullCharacter + '1')", "NaN");
shouldBe("+('1' + nullCharacter)", "NaN");
shouldBe("+('1' + nullCharacter + '1')", "NaN");
shouldBe("+(nonASCIICharacter + '1')", "NaN");
shouldBe("+('1' + nonASCIICharacter)", "NaN");
shouldBe("+('1' + nonASCIICharacter + '1')", "NaN");
shouldBe("+('1' + nonASCIINonSpaceCharacter)", "NaN");
shouldBe("+(nonASCIINonSpaceCharacter + '1')", "NaN");
shouldBe("+('1' + nonASCIINonSpaceCharacter + '1')", "NaN");
shouldBe("+(illegalUTF16Sequence + '1')", "NaN");
shouldBe("+('1' + illegalUTF16Sequence)", "NaN");
shouldBe("+('1' + illegalUTF16Sequence + '1')", "NaN");
shouldBe("+'inf'", "NaN");
shouldBe("+'infinity'", "NaN");
shouldBe("+'Inf'", "NaN");
shouldBe("+'+inf'", "NaN");
shouldBe("+'+infinity'", "NaN");
shouldBe("+'+Inf'", "NaN");
shouldBe("+'-inf'", "NaN");
shouldBe("+'-infinity'", "NaN");
shouldBe("+'-Inf'", "NaN");
shouldBe("+'Infinity'", "Infinity");
shouldBe("+'+Infinity'", "Infinity");
shouldBe("+'-Infinity'", "-Infinity");
shouldBe("+'++1'", "NaN");
shouldBe("+'AB'", "NaN");
shouldBe("+'0xAB'", "171");
shouldBe("+'1e1'", "10");
shouldBe("+'1E1'", "10");
shouldBe("+tab", "0");
shouldBe("+nbsp", "0");
shouldBe("+ff", "0");
shouldBe("+vt", "0");
shouldBe("+cr", "0");
shouldBe("+lf", "0");
shouldBe("+ls", "0");
shouldBe("+ps", "0");
shouldBe("+oghamSpaceMark", "0");
shouldBe("+mongolianVowelSeparator", "NaN");
shouldBe("+enQuad", "0");
shouldBe("+emQuad", "0");
shouldBe("+enSpace", "0");
shouldBe("+emSpace", "0");
shouldBe("+threePerEmSpace", "0");
shouldBe("+fourPerEmSpace", "0");
shouldBe("+sixPerEmSpace", "0");
shouldBe("+figureSpace", "0");
shouldBe("+punctuationSpace", "0");
shouldBe("+thinSpace", "0");
shouldBe("+hairSpace", "0");
shouldBe("+narrowNoBreakSpace", "0");
shouldBe("+mediumMathematicalSpace", "0");
shouldBe("+ideographicSpace", "0");
shouldBe("+(tab + '1')", "1");
shouldBe("+(nbsp + '1')", "1");
shouldBe("+(ff + '1')", "1");
shouldBe("+(vt + '1')", "1");
shouldBe("+(cr + '1')", "1");
shouldBe("+(lf + '1')", "1");
shouldBe("+(ls + '1')", "1");
shouldBe("+(ps + '1')", "1");
shouldBe("+(oghamSpaceMark + '1')", "1");
shouldBe("+(mongolianVowelSeparator + '1')", "NaN");
shouldBe("+(enQuad + '1')", "1");
shouldBe("+(emQuad + '1')", "1");
shouldBe("+(enSpace + '1')", "1");
shouldBe("+(emSpace + '1')", "1");
shouldBe("+(threePerEmSpace + '1')", "1");
shouldBe("+(fourPerEmSpace + '1')", "1");
shouldBe("+(sixPerEmSpace + '1')", "1");
shouldBe("+(figureSpace + '1')", "1");
shouldBe("+(punctuationSpace + '1')", "1");
shouldBe("+(thinSpace + '1')", "1");
shouldBe("+(hairSpace + '1')", "1");
shouldBe("+(narrowNoBreakSpace + '1')", "1");
shouldBe("+(mediumMathematicalSpace + '1')", "1");
shouldBe("+(ideographicSpace + '1')", "1");
shouldBe("+('1' + tab)", "1");
shouldBe("+('1' + nbsp)", "1");
shouldBe("+('1' + ff)", "1");
shouldBe("+('1' + vt)", "1");
shouldBe("+('1' + cr)", "1");
shouldBe("+('1' + lf)", "1");
shouldBe("+('1' + ls)", "1");
shouldBe("+('1' + ps)", "1");
shouldBe("+('1' + oghamSpaceMark)", "1");
shouldBe("+('1' + mongolianVowelSeparator)", "NaN");
shouldBe("+('1' + enQuad)", "1");
shouldBe("+('1' + emQuad)", "1");
shouldBe("+('1' + enSpace)", "1");
shouldBe("+('1' + emSpace)", "1");
shouldBe("+('1' + threePerEmSpace)", "1");
shouldBe("+('1' + fourPerEmSpace)", "1");
shouldBe("+('1' + sixPerEmSpace)", "1");
shouldBe("+('1' + figureSpace)", "1");
shouldBe("+('1' + punctuationSpace)", "1");
shouldBe("+('1' + thinSpace)", "1");
shouldBe("+('1' + hairSpace)", "1");
shouldBe("+('1' + narrowNoBreakSpace)", "1");
shouldBe("+('1' + mediumMathematicalSpace)", "1");
shouldBe("+('1' + ideographicSpace)", "1");
shouldBe("+('1' + tab + '1')", "NaN");
shouldBe("+('1' + nbsp + '1')", "NaN");
shouldBe("+('1' + ff + '1')", "NaN");
shouldBe("+('1' + vt + '1')", "NaN");
shouldBe("+('1' + cr + '1')", "NaN");
shouldBe("+('1' + lf + '1')", "NaN");
shouldBe("+('1' + ls + '1')", "NaN");
shouldBe("+('1' + ps + '1')", "NaN");
shouldBe("+('1' + oghamSpaceMark + '1')", "NaN");
shouldBe("+('1' + mongolianVowelSeparator + '1')", "NaN");
shouldBe("+('1' + enQuad + '1')", "NaN");
shouldBe("+('1' + emQuad + '1')", "NaN");
shouldBe("+('1' + enSpace + '1')", "NaN");
shouldBe("+('1' + emSpace + '1')", "NaN");
shouldBe("+('1' + threePerEmSpace + '1')", "NaN");
shouldBe("+('1' + fourPerEmSpace + '1')", "NaN");
shouldBe("+('1' + sixPerEmSpace + '1')", "NaN");
shouldBe("+('1' + figureSpace + '1')", "NaN");
shouldBe("+('1' + punctuationSpace + '1')", "NaN");
shouldBe("+('1' + thinSpace + '1')", "NaN");
shouldBe("+('1' + hairSpace + '1')", "NaN");
shouldBe("+('1' + narrowNoBreakSpace + '1')", "NaN");
shouldBe("+('1' + mediumMathematicalSpace + '1')", "NaN");
shouldBe("+('1' + ideographicSpace + '1')", "NaN");
                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/webkit/add-recovery-expected.txt                                           0000664 0000000 0000000 00000003701 14746647661 0023236 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This tests that speculation recovery of destructive additions on unboxed integers works.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS destructiveAddForBoxedInteger({x:1}, 2, 4) is 9
PASS destructiveAddForBoxedInteger({x:2147483647}, 2, 4) is 2147483655
PASS destructiveAddForBoxedInteger({x:2}, 2147483647, 4) is 4294967300
PASS destructiveAddForBoxedInteger({x:2147483647}, 2147483647, 4) is 6442450945
PASS destructiveAddForBoxedInteger({x:1}, 2, 2147483647) is 2147483652
PASS successfullyParsed is true

TEST COMPLETE

                                                               node-23.7.0/deps/v8/test/webkit/add-recovery.js                                                     0000664 0000000 0000000 00000004153 14746647661 0021236 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(
"This tests that speculation recovery of destructive additions on unboxed integers works."
);

function destructiveAddForBoxedInteger(a,b,c) {
    var a_ = a.x;
    var d = a_ + b;
    return c + d + b;
}

// warm-up foo to be integer
for (var i = 0; i < 100; ++i) {
    destructiveAddForBoxedInteger({x:1}, 2, 3);
}

shouldBe("destructiveAddForBoxedInteger({x:1}, 2, 4)", "9");
shouldBe("destructiveAddForBoxedInteger({x:2147483647}, 2, 4)", "2147483655");
shouldBe("destructiveAddForBoxedInteger({x:2}, 2147483647, 4)", "4294967300");
shouldBe("destructiveAddForBoxedInteger({x:2147483647}, 2147483647, 4)", "6442450945");
shouldBe("destructiveAddForBoxedInteger({x:1}, 2, 2147483647)", "2147483652");
                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/webkit/apply-varargs-expected.txt                                          0000664 0000000 0000000 00000003523 14746647661 0023444 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Test that we properly fill in missing args with "undefined" in JIT code.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS caller(0) is undefined
PASS caller(1) is undefined
PASS caller(2) is undefined
PASS caller(3) is undefined
PASS caller(4) is undefined
PASS caller(5) is undefined
PASS caller(6) is undefined
PASS caller(7) is undefined
PASS caller(8) is undefined
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                             node-23.7.0/deps/v8/test/webkit/apply-varargs.js                                                    0000664 0000000 0000000 00000006470 14746647661 0021446 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description('Test that we properly fill in missing args with "undefined" in JIT code.');

// Regression test for <rdar://problem/10763509>


function callee(a1, a2, a3, a4, a5, a6, a7, a8)
{
    // We expect that the unused actual parameters will be filled
    // with undefined.
    if (a1 !== undefined)
        return "Arg1 is wrong";
    if (a2 !== undefined)
        return "Arg2 is wrong";
    if (a3 !== undefined)
        return "Arg3 is wrong";
    if (a4 !== undefined)
        return "Arg4 is wrong";
    if (a5 !== undefined)
        return "Arg5 is wrong";
    if (a6 !== undefined)
        return "Arg6 is wrong";
    if (a7 !== undefined)
        return "Arg7 is wrong";
    if (a8 !== undefined)
        return "Arg8 is wrong";

    return undefined;
}

function dummy(a1, a2, a3, a4, a5, a6, a7, a8)
{
}

function BaseObj()
{
}

function caller(testArgCount)
{
    var baseObj = new BaseObj();

    var allArgs = [0, "String", callee, true, null, 2.5, [1, 2, 3], {'a': 1, 'b' : 2}];
    argCounts = [8, testArgCount];

    for (argCountIndex = 0; argCountIndex < argCounts.length; argCountIndex++) {
        argCount = argCounts[argCountIndex];

        var varArgs = [];
        for (i = 0; i < argCount; i++)
            varArgs[i] = undefined;

        for (numCalls = 0; numCalls < 10; numCalls++) {
            // Run multiple times so that the JIT kicks in
            dummy.apply(baseObj, allArgs);
            var result = callee.apply(baseObj, varArgs);
            if (result != undefined)
                return result;
        }
    }

    return undefined;
}

shouldBe("caller(0)", 'undefined');
shouldBe("caller(1)", 'undefined');
shouldBe("caller(2)", 'undefined');
shouldBe("caller(3)", 'undefined');
shouldBe("caller(4)", 'undefined');
shouldBe("caller(5)", 'undefined');
shouldBe("caller(6)", 'undefined');
shouldBe("caller(7)", 'undefined');
shouldBe("caller(8)", 'undefined');

var successfullyParsed = true;
                                                                                                                                                                                                        node-23.7.0/deps/v8/test/webkit/arguments-bad-index-expected.txt                                    0000664 0000000 0000000 00000003373 14746647661 0024515 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This test checks whether arguments crashes when passed a bad index.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS indexArguments(1, "a") is "a"
PASS indexArguments("1 ", "a") is undefined
PASS indexArguments(0xDEADBEEF) is undefined
PASS indexArguments(0xFFFFFFFF) is undefined
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/webkit/arguments-bad-index.js                                              0000664 0000000 0000000 00000003377 14746647661 0022517 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(
"This test checks whether arguments crashes when passed a bad index."
);

function indexArguments(index)
{
    return arguments[index];
}

shouldBe('indexArguments(1, "a")', '"a"');
shouldBe('indexArguments("1 ", "a")', 'undefined');
shouldBe('indexArguments(0xDEADBEEF)', 'undefined');
shouldBe('indexArguments(0xFFFFFFFF)', 'undefined');
                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/webkit/array-constructor-host-call-expected.txt                            0000664 0000000 0000000 00000003377 14746647661 0026250 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This tests that array construction via a host call works.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS array instanceof Array is true
PASS array.length is 100
PASS array instanceof Array is true
PASS array.length is 100
PASS array instanceof Array is true
PASS array.length is 100
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/webkit/array-constructor-host-call.js                                      0000664 0000000 0000000 00000003330 14746647661 0024233 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(
"This tests that array construction via a host call works."
);

function constructArray(arrayConstructor) {
    return new arrayConstructor(100);
}

for (var i = 0; i < 3; ++i) {
    var array = constructArray(Array);
    shouldBeTrue("array instanceof Array");
    shouldBe("array.length", "100");
}
                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/webkit/array-defineOwnProperty-expected.txt                                0000664 0000000 0000000 00000013171 14746647661 0025453 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This test checks the behavior of [[DefineOwnProperty]] applied to Array objects (see ES5.1 15.4.5.1).

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS Object.defineProperty([], 'x', { get:function(){return true;} }).x is true
PASS Object.defineProperty([], 'length', { value: 1 }).length is 1
PASS var a = Object.defineProperty([], 'length', { writable: false }); a[1] = 1; a.length is 0
PASS var a = Object.defineProperty([], 'length', { writable: false }); a.length = 1; a.length is 0
PASS var a = Object.defineProperty([], 'length', {}); a.length = 1; a.length is 1
PASS Object.defineProperty([], 'length', { get:function(){return true;} }) threw exception TypeError: Cannot redefine property: length.
PASS Object.defineProperty([], 'length', { enumerable: true }) threw exception TypeError: Cannot redefine property: length.
PASS Object.defineProperty([], 'length', { configurable: true }) threw exception TypeError: Cannot redefine property: length.
PASS Object.defineProperty(Object.defineProperty([], 'length', { writable: false }), 'length', { writable: true }) threw exception TypeError: Cannot redefine property: length.
PASS var a = Object.defineProperty([], '0', { value: 42 }); a[0] is 42
PASS var a = Object.defineProperty([42], '0', { writable: false }); a[0] = 1; a[0] is 42
PASS var a = Object.defineProperty([42], '0', { enumerable: false }); a[0] + Object.keys(a).length is 42
PASS var a = Object.defineProperty([42], '0', { configurable: false }); a.length = 0; a[0] is 42
PASS var foo = 0; Object.defineProperty([], '0', { set:function(x){foo = x;} })[0] = 42; foo is 42
PASS Object.defineProperty([], '0', { get:function(){return true;} })[0] is true
PASS Object.defineProperty(Object.defineProperty([true], '0', { configurable:true, writable: false }), '0', { writable: true })[0] is true
PASS Object.defineProperty(Object.defineProperty([true], '0', { configurable:false, writable: false }), '0', { writable: true })[0] threw exception TypeError: Cannot redefine property: 0.
PASS Object.defineProperty(Object.defineProperty([], '0', { value: 1, writable:true }), '0', { value: 2 })[0] is 2
PASS Object.defineProperty(Object.defineProperty([], '0', { value: 1 }), '0', { value: 1 })[0] is 1
PASS Object.defineProperty(Object.defineProperty([], '0', { value: Number.NaN }), '0', { value: -Number.NaN })[0] is Number.NaN
PASS Object.defineProperty(Object.defineProperty([], '0', { value: 'okay'.substring(0,2) }), '0', { value: 'not ok'.substring(4,6) })[0] is "ok"
PASS Object.defineProperty(Object.defineProperty([], '0', { value: true }), '0', { value: true })[0] is true
PASS Object.defineProperty(Object.defineProperty([], '0', { value: false }), '0', { value: false })[0] is false
PASS Object.defineProperty(Object.defineProperty([], '0', { value: null }), '0', { value: null })[0] is null
PASS Object.defineProperty(Object.defineProperty([], '0', { value: undefined }), '0', { value: undefined })[0] is undefined
PASS Object.defineProperty(Object.defineProperty([], '0', { value: Math }), '0', { value: Math })[0] is Math
PASS Object.defineProperty(Object.defineProperty([], '0', { value: 1 }), '0', { value: 2 })[0] threw exception TypeError: Cannot redefine property: 0.
PASS Object.defineProperty(Object.defineProperty([], '0', { value: 'okay' }), '0', { value: 'not ok' })[0] threw exception TypeError: Cannot redefine property: 0.
PASS Object.defineProperty(Object.defineProperty([], '0', { value: true }), '0', { value: false })[0] threw exception TypeError: Cannot redefine property: 0.
PASS Object.defineProperty(Object.defineProperty([], '0', { value: false }), '0', { value: true })[0] threw exception TypeError: Cannot redefine property: 0.
PASS Object.defineProperty(Object.defineProperty([], '0', { value: Math }), '0', { value: Object })[0] threw exception TypeError: Cannot redefine property: 0.
PASS Object.defineProperty(Object.defineProperty([], '0', { value: null }), '0', { value: undefined })[0] threw exception TypeError: Cannot redefine property: 0.
PASS Object.defineProperty(Object.defineProperty([], '0', { value: undefined }), '0', { value: null })[0] threw exception TypeError: Cannot redefine property: 0.
PASS arrObj[0] = 42; arrObj.set; is true
PASS arrObj[1] = true; arrObj[1]; is true
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/webkit/array-defineOwnProperty.js                                          0000664 0000000 0000000 00000014357 14746647661 0023460 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description("This test checks the behavior of [[DefineOwnProperty]] applied to Array objects (see ES5.1 15.4.5.1).");

// Test that properties other than length, array indices are handled as normal.
shouldBeTrue("Object.defineProperty([], 'x', { get:function(){return true;} }).x");

// The length property can be set, and can be made read-only.
shouldBe("Object.defineProperty([], 'length', { value: 1 }).length", '1');
shouldBe("var a = Object.defineProperty([], 'length', { writable: false }); a[1] = 1; a.length", '0');
shouldBe("var a = Object.defineProperty([], 'length', { writable: false }); a.length = 1; a.length", '0');
// If writable is not specified, it should not change.
shouldBe("var a = Object.defineProperty([], 'length', {}); a.length = 1; a.length", '1');

// The length property can be replaced with an accessor, or made either enumerable or configurable.
shouldThrow("Object.defineProperty([], 'length', { get:function(){return true;} })");
shouldThrow("Object.defineProperty([], 'length', { enumerable: true })");
shouldThrow("Object.defineProperty([], 'length', { configurable: true })");
shouldThrow("Object.defineProperty(Object.defineProperty([], 'length', { writable: false }), 'length', { writable: true })");

// The value of an indexed property can be set.
shouldBe("var a = Object.defineProperty([], '0', { value: 42 }); a[0]", '42');
// An indexed property can be made non-writable/enumerable/configurable.
shouldBe("var a = Object.defineProperty([42], '0', { writable: false }); a[0] = 1; a[0]", '42');
shouldBe("var a = Object.defineProperty([42], '0', { enumerable: false }); a[0] + Object.keys(a).length", '42');
shouldBe("var a = Object.defineProperty([42], '0', { configurable: false }); a.length = 0; a[0]", '42');
// An indexed property can be defined as an accessor.
shouldBe("var foo = 0; Object.defineProperty([], '0', { set:function(x){foo = x;} })[0] = 42; foo", '42');
shouldBeTrue("Object.defineProperty([], '0', { get:function(){return true;} })[0]")
// A configurable, non-writable property can be made writable, but a non-configurable one cannot.
shouldBeTrue("Object.defineProperty(Object.defineProperty([true], '0', { configurable:true, writable: false }), '0', { writable: true })[0]");
shouldThrow("Object.defineProperty(Object.defineProperty([true], '0', { configurable:false, writable: false }), '0', { writable: true })[0]");

// Reassigning the value is okay if the property is writable.
shouldBe("Object.defineProperty(Object.defineProperty([], '0', { value: 1, writable:true }), '0', { value: 2 })[0]", '2');
// Reassigning the value is okay if the value doesn't change.
shouldBe("Object.defineProperty(Object.defineProperty([], '0', { value: 1 }), '0', { value: 1 })[0]", '1');
shouldBe("Object.defineProperty(Object.defineProperty([], '0', { value: Number.NaN }), '0', { value: -Number.NaN })[0]", 'Number.NaN');
shouldBe("Object.defineProperty(Object.defineProperty([], '0', { value: 'okay'.substring(0,2) }), '0', { value: 'not ok'.substring(4,6) })[0]", '"ok"');
shouldBe("Object.defineProperty(Object.defineProperty([], '0', { value: true }), '0', { value: true })[0]", 'true');
shouldBe("Object.defineProperty(Object.defineProperty([], '0', { value: false }), '0', { value: false })[0]", 'false');
shouldBe("Object.defineProperty(Object.defineProperty([], '0', { value: null }), '0', { value: null })[0]", 'null');
shouldBe("Object.defineProperty(Object.defineProperty([], '0', { value: undefined }), '0', { value: undefined })[0]", 'undefined');
shouldBe("Object.defineProperty(Object.defineProperty([], '0', { value: Math }), '0', { value: Math })[0]", 'Math');
// Reassigning the value is not okay if the value changes.
shouldThrow("Object.defineProperty(Object.defineProperty([], '0', { value: 1 }), '0', { value: 2 })[0]");
shouldThrow("Object.defineProperty(Object.defineProperty([], '0', { value: 'okay' }), '0', { value: 'not ok' })[0]");
shouldThrow("Object.defineProperty(Object.defineProperty([], '0', { value: true }), '0', { value: false })[0]");
shouldThrow("Object.defineProperty(Object.defineProperty([], '0', { value: false }), '0', { value: true })[0]");
shouldThrow("Object.defineProperty(Object.defineProperty([], '0', { value: Math }), '0', { value: Object })[0]");
// Reassigning the value is not okay if the type changes.
shouldThrow("Object.defineProperty(Object.defineProperty([], '0', { value: null }), '0', { value: undefined })[0]");
shouldThrow("Object.defineProperty(Object.defineProperty([], '0', { value: undefined }), '0', { value: null })[0]");

Object.defineProperty(Array.prototype, "0", { set: function () { throw false; } });
Object.defineProperty(Array.prototype, "1", { set: function () { throw false; } });
var arrObj = [ , false ];
Object.defineProperty(arrObj, "0", { set: function (x) { this.set = x === 42; } });
shouldBeTrue("arrObj[0] = 42; arrObj.set;");
shouldBeTrue("arrObj[1] = true; arrObj[1];");

successfullyParsed = true;
                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/webkit/array-enumerators-functions-expected.txt                            0000664 0000000 0000000 00000427401 14746647661 0026347 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This test checks the behavior of the various array enumeration functions in certain edge case scenarios

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS count=0;lastIndex=-1;copyArray(simpleArray).every(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(simpleArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).every(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(emptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).every(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeEmptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).every(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeSparseArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).every(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(simpleArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).every(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(emptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).every(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeEmptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).every(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeSparseArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).every(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(simpleArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).every(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(emptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).every(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeEmptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).every(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeSparseArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).every(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(simpleArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).every(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(emptyArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).every(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeEmptyArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).every(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeSparseArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).every(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(simpleArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).every(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(emptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).every(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeEmptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).every(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeSparseArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).every(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(simpleArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).every(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(emptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).every(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeEmptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).every(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeSparseArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).every(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(simpleArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).every(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(emptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).every(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeEmptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).every(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeSparseArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).forEach(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(simpleArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).forEach(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(emptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).forEach(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeEmptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).forEach(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeSparseArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).forEach(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(simpleArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).forEach(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(emptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).forEach(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeEmptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).forEach(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeSparseArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).forEach(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(simpleArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).forEach(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(emptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).forEach(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeEmptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).forEach(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeSparseArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).forEach(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(simpleArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).forEach(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(emptyArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).forEach(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeEmptyArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).forEach(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeSparseArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).forEach(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(simpleArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).forEach(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(emptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).forEach(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeEmptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).forEach(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeSparseArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).forEach(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(simpleArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).forEach(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(emptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).forEach(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeEmptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).forEach(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeSparseArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).forEach(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(simpleArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).forEach(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(emptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).forEach(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeEmptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).forEach(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeSparseArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).some(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(simpleArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).some(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(emptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).some(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeEmptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).some(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeSparseArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).some(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(simpleArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).some(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(emptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).some(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeEmptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).some(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeSparseArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).some(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(simpleArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).some(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(emptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).some(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeEmptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).some(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeSparseArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).some(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(simpleArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).some(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(emptyArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).some(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeEmptyArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).some(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeSparseArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).some(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(simpleArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).some(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(emptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).some(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeEmptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).some(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeSparseArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).some(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(simpleArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).some(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(emptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).some(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeEmptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).some(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeSparseArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).some(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(simpleArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).some(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(emptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).some(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeEmptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).some(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeSparseArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).filter(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(simpleArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).filter(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(emptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).filter(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeEmptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).filter(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeSparseArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).filter(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(simpleArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).filter(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(emptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).filter(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeEmptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).filter(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeSparseArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).filter(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(simpleArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).filter(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(emptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).filter(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeEmptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).filter(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeSparseArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).filter(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(simpleArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).filter(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(emptyArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).filter(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeEmptyArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).filter(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeSparseArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).filter(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(simpleArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).filter(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(emptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).filter(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeEmptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).filter(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeSparseArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).filter(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(simpleArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).filter(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(emptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).filter(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeEmptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).filter(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeSparseArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).filter(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(simpleArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).filter(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(emptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).filter(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeEmptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).filter(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeSparseArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduce(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(simpleArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduce(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(emptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduce(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeEmptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduce(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeSparseArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduce(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(simpleArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduce(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(emptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduce(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeEmptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduce(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeSparseArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduce(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(simpleArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduce(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(emptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduce(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeEmptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduce(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeSparseArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduce(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(simpleArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduce(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(emptyArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduce(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeEmptyArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduce(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeSparseArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduce(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(simpleArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduce(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(emptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduce(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeEmptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduce(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeSparseArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduce(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(simpleArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduce(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(emptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduce(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeEmptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduce(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeSparseArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduce(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(simpleArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduce(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(emptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduce(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeEmptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduce(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeSparseArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).map(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toObject(simpleArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).map(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toObject(emptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).map(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeSparseArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).map(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toObject(simpleArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).map(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toObject(emptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).map(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeSparseArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).map(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toObject(simpleArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).map(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toObject(emptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).map(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeSparseArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).map(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toObject(simpleArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).map(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toObject(emptyArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).map(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeSparseArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).map(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toObject(simpleArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).map(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toObject(emptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).map(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeSparseArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).map(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toObject(simpleArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).map(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toObject(emptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).map(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeSparseArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).map(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toObject(simpleArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).map(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toObject(emptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).map(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeSparseArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduceRight(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(simpleArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduceRight(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(emptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduceRight(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeEmptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduceRight(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeSparseArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduceRight(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(simpleArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduceRight(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(emptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduceRight(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeEmptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduceRight(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeSparseArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduceRight(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(simpleArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduceRight(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(emptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduceRight(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeEmptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduceRight(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeSparseArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduceRight(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(simpleArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduceRight(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(emptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduceRight(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeEmptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduceRight(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeSparseArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduceRight(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(simpleArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduceRight(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(emptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduceRight(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeEmptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduceRight(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeSparseArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduceRight(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(simpleArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduceRight(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(emptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduceRight(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeEmptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduceRight(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeSparseArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).every(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(simpleArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).every(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(emptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).every(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(largeEmptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).every(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(largeSparseArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).every(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(simpleArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).every(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(emptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).every(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(largeEmptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).every(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(largeSparseArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).every(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(simpleArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).every(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(emptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).every(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(largeEmptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).every(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(largeSparseArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).every(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(simpleArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).every(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(emptyArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).every(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(largeEmptyArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).every(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(largeSparseArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).every(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(simpleArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).every(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(emptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).every(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(largeEmptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).every(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(largeSparseArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).every(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(simpleArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).every(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(emptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).every(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(largeEmptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).every(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(largeSparseArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).every(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(simpleArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).every(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(emptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).every(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(largeEmptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).every(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.every.call(toUnorderedObject(largeSparseArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).forEach(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(simpleArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).forEach(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(emptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).forEach(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(largeEmptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).forEach(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(largeSparseArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).forEach(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(simpleArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).forEach(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(emptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).forEach(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(largeEmptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).forEach(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(largeSparseArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).forEach(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(simpleArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).forEach(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(emptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).forEach(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(largeEmptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).forEach(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(largeSparseArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).forEach(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(simpleArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).forEach(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(emptyArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).forEach(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(largeEmptyArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).forEach(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(largeSparseArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).forEach(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(simpleArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).forEach(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(emptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).forEach(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(largeEmptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).forEach(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(largeSparseArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).forEach(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(simpleArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).forEach(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(emptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).forEach(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(largeEmptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).forEach(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(largeSparseArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).forEach(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(simpleArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).forEach(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(emptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).forEach(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(largeEmptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).forEach(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.forEach.call(toUnorderedObject(largeSparseArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).some(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(simpleArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).some(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(emptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).some(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(largeEmptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).some(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(largeSparseArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).some(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(simpleArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).some(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(emptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).some(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(largeEmptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).some(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(largeSparseArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).some(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(simpleArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).some(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(emptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).some(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(largeEmptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).some(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(largeSparseArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).some(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(simpleArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).some(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(emptyArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).some(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(largeEmptyArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).some(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(largeSparseArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).some(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(simpleArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).some(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(emptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).some(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(largeEmptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).some(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(largeSparseArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).some(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(simpleArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).some(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(emptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).some(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(largeEmptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).some(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(largeSparseArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).some(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(simpleArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).some(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(emptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).some(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(largeEmptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).some(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.some.call(toUnorderedObject(largeSparseArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).filter(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(simpleArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).filter(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(emptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).filter(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(largeEmptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).filter(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(largeSparseArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).filter(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(simpleArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).filter(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(emptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).filter(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(largeEmptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).filter(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(largeSparseArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).filter(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(simpleArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).filter(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(emptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).filter(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(largeEmptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).filter(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(largeSparseArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).filter(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(simpleArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).filter(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(emptyArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).filter(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(largeEmptyArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).filter(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(largeSparseArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).filter(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(simpleArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).filter(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(emptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).filter(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(largeEmptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).filter(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(largeSparseArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).filter(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(simpleArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).filter(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(emptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).filter(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(largeEmptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).filter(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(largeSparseArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).filter(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(simpleArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).filter(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(emptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).filter(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(largeEmptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).filter(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.filter.call(toUnorderedObject(largeSparseArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduce(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(simpleArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduce(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(emptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduce(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(largeEmptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduce(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(largeSparseArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduce(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(simpleArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduce(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(emptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduce(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(largeEmptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduce(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(largeSparseArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduce(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(simpleArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduce(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(emptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduce(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(largeEmptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduce(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(largeSparseArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduce(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(simpleArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduce(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(emptyArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduce(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(largeEmptyArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduce(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(largeSparseArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduce(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(simpleArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduce(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(emptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduce(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(largeEmptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduce(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(largeSparseArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduce(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(simpleArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduce(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(emptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduce(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(largeEmptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduce(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(largeSparseArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduce(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(simpleArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduce(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(emptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduce(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(largeEmptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduce(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.reduce.call(toUnorderedObject(largeSparseArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).map(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toUnorderedObject(simpleArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).map(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toUnorderedObject(emptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).map(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toUnorderedObject(largeSparseArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).map(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toUnorderedObject(simpleArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).map(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toUnorderedObject(emptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).map(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toUnorderedObject(largeSparseArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).map(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toUnorderedObject(simpleArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).map(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toUnorderedObject(emptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).map(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toUnorderedObject(largeSparseArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).map(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toUnorderedObject(simpleArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).map(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toUnorderedObject(emptyArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).map(forwarders[f], returnIndex, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toUnorderedObject(largeSparseArray), forwarders[f], returnIndex, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).map(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toUnorderedObject(simpleArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).map(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toUnorderedObject(emptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).map(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toUnorderedObject(largeSparseArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).map(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toUnorderedObject(simpleArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).map(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toUnorderedObject(emptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).map(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toUnorderedObject(largeSparseArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).map(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toUnorderedObject(simpleArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).map(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toUnorderedObject(emptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).map(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.map.call(toUnorderedObject(largeSparseArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduceRight(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toUnorderedObject(simpleArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduceRight(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toUnorderedObject(emptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduceRight(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toUnorderedObject(largeEmptyArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduceRight(forwarders[f], returnFalse, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toUnorderedObject(largeSparseArray), forwarders[f], returnFalse, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduceRight(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toUnorderedObject(simpleArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduceRight(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toUnorderedObject(emptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduceRight(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toUnorderedObject(largeEmptyArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduceRight(forwarders[f], returnTrue, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toUnorderedObject(largeSparseArray), forwarders[f], returnTrue, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduceRight(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toUnorderedObject(simpleArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduceRight(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toUnorderedObject(emptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduceRight(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toUnorderedObject(largeEmptyArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduceRight(forwarders[f], returnElem, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toUnorderedObject(largeSparseArray), forwarders[f], returnElem, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduceRight(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toUnorderedObject(simpleArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduceRight(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toUnorderedObject(emptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduceRight(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toUnorderedObject(largeEmptyArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduceRight(forwarders[f], increaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toUnorderedObject(largeSparseArray), forwarders[f], increaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduceRight(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toUnorderedObject(simpleArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduceRight(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toUnorderedObject(emptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduceRight(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toUnorderedObject(largeEmptyArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduceRight(forwarders[f], decreaseLength, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toUnorderedObject(largeSparseArray), forwarders[f], decreaseLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduceRight(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toUnorderedObject(simpleArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduceRight(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toUnorderedObject(emptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduceRight(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toUnorderedObject(largeEmptyArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduceRight(forwarders[f], halveLength, 0) is count=0;lastIndex=-1;Array.prototype.reduceRight.call(toUnorderedObject(largeSparseArray), forwarders[f], halveLength, 0)
PASS count=0;lastIndex=-1;copyArray(simpleArray).every(forwarders[f], returnFalse, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(simpleArray), forwarders[f], returnFalse, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(simpleArray), forwarders[f], returnFalse, 0); count is 1
PASS count=0;lastIndex=-1;copyArray(emptyArray).every(forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(emptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(emptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).every(forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeEmptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeEmptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).every(forwarders[f], returnFalse, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeSparseArray), forwarders[f], returnFalse, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeSparseArray), forwarders[f], returnFalse, 0); count is 1
PASS count=0;lastIndex=-1;copyArray(simpleArray).every(forwarders[f], returnTrue, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(simpleArray), forwarders[f], returnTrue, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(simpleArray), forwarders[f], returnTrue, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).every(forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(emptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(emptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).every(forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeEmptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeEmptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).every(forwarders[f], returnTrue, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeSparseArray), forwarders[f], returnTrue, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeSparseArray), forwarders[f], returnTrue, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).every(forwarders[f], returnElem, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(simpleArray), forwarders[f], returnElem, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(simpleArray), forwarders[f], returnElem, 0); count is 1
PASS count=0;lastIndex=-1;copyArray(emptyArray).every(forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(emptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(emptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).every(forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeEmptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeEmptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).every(forwarders[f], returnElem, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeSparseArray), forwarders[f], returnElem, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeSparseArray), forwarders[f], returnElem, 0); count is 1
PASS count=0;lastIndex=-1;copyArray(simpleArray).every(forwarders[f], returnIndex, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(simpleArray), forwarders[f], returnIndex, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(simpleArray), forwarders[f], returnIndex, 0); count is 1
PASS count=0;lastIndex=-1;copyArray(emptyArray).every(forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(emptyArray), forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(emptyArray), forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).every(forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeEmptyArray), forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeEmptyArray), forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).every(forwarders[f], returnIndex, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeSparseArray), forwarders[f], returnIndex, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeSparseArray), forwarders[f], returnIndex, 0); count is 1
PASS count=0;lastIndex=-1;copyArray(simpleArray).every(forwarders[f], increaseLength, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(simpleArray), forwarders[f], increaseLength, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(simpleArray), forwarders[f], increaseLength, 0); count is 1
PASS count=0;lastIndex=-1;copyArray(emptyArray).every(forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(emptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(emptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).every(forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeEmptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeEmptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).every(forwarders[f], increaseLength, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeSparseArray), forwarders[f], increaseLength, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeSparseArray), forwarders[f], increaseLength, 0); count is 1
PASS count=0;lastIndex=-1;copyArray(simpleArray).every(forwarders[f], decreaseLength, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(simpleArray), forwarders[f], decreaseLength, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(simpleArray), forwarders[f], decreaseLength, 0); count is 1
PASS count=0;lastIndex=-1;copyArray(emptyArray).every(forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(emptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(emptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).every(forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeEmptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeEmptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).every(forwarders[f], decreaseLength, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeSparseArray), forwarders[f], decreaseLength, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeSparseArray), forwarders[f], decreaseLength, 0); count is 1
PASS count=0;lastIndex=-1;copyArray(simpleArray).every(forwarders[f], halveLength, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(simpleArray), forwarders[f], halveLength, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(simpleArray), forwarders[f], halveLength, 0); count is 1
PASS count=0;lastIndex=-1;copyArray(emptyArray).every(forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(emptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(emptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).every(forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeEmptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeEmptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).every(forwarders[f], halveLength, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeSparseArray), forwarders[f], halveLength, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.every.call(toObject(largeSparseArray), forwarders[f], halveLength, 0); count is 1
PASS count=0;lastIndex=-1;copyArray(simpleArray).forEach(forwarders[f], returnFalse, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(simpleArray), forwarders[f], returnFalse, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(simpleArray), forwarders[f], returnFalse, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).forEach(forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(emptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(emptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).forEach(forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeEmptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeEmptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).forEach(forwarders[f], returnFalse, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeSparseArray), forwarders[f], returnFalse, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeSparseArray), forwarders[f], returnFalse, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).forEach(forwarders[f], returnTrue, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(simpleArray), forwarders[f], returnTrue, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(simpleArray), forwarders[f], returnTrue, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).forEach(forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(emptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(emptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).forEach(forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeEmptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeEmptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).forEach(forwarders[f], returnTrue, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeSparseArray), forwarders[f], returnTrue, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeSparseArray), forwarders[f], returnTrue, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).forEach(forwarders[f], returnElem, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(simpleArray), forwarders[f], returnElem, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(simpleArray), forwarders[f], returnElem, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).forEach(forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(emptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(emptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).forEach(forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeEmptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeEmptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).forEach(forwarders[f], returnElem, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeSparseArray), forwarders[f], returnElem, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeSparseArray), forwarders[f], returnElem, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).forEach(forwarders[f], returnIndex, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(simpleArray), forwarders[f], returnIndex, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(simpleArray), forwarders[f], returnIndex, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).forEach(forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(emptyArray), forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(emptyArray), forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).forEach(forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeEmptyArray), forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeEmptyArray), forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).forEach(forwarders[f], returnIndex, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeSparseArray), forwarders[f], returnIndex, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeSparseArray), forwarders[f], returnIndex, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).forEach(forwarders[f], increaseLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(simpleArray), forwarders[f], increaseLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(simpleArray), forwarders[f], increaseLength, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).forEach(forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(emptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(emptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).forEach(forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeEmptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeEmptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).forEach(forwarders[f], increaseLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeSparseArray), forwarders[f], increaseLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeSparseArray), forwarders[f], increaseLength, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).forEach(forwarders[f], decreaseLength, 0); count is 3
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(simpleArray), forwarders[f], decreaseLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(simpleArray), forwarders[f], decreaseLength, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).forEach(forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(emptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(emptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).forEach(forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeEmptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeEmptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).forEach(forwarders[f], decreaseLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeSparseArray), forwarders[f], decreaseLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeSparseArray), forwarders[f], decreaseLength, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).forEach(forwarders[f], halveLength, 0); count is 3
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(simpleArray), forwarders[f], halveLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(simpleArray), forwarders[f], halveLength, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).forEach(forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(emptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(emptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).forEach(forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeEmptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeEmptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).forEach(forwarders[f], halveLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeSparseArray), forwarders[f], halveLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.forEach.call(toObject(largeSparseArray), forwarders[f], halveLength, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).some(forwarders[f], returnFalse, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(simpleArray), forwarders[f], returnFalse, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(simpleArray), forwarders[f], returnFalse, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).some(forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(emptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(emptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).some(forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeEmptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeEmptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).some(forwarders[f], returnFalse, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeSparseArray), forwarders[f], returnFalse, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeSparseArray), forwarders[f], returnFalse, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).some(forwarders[f], returnTrue, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(simpleArray), forwarders[f], returnTrue, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(simpleArray), forwarders[f], returnTrue, 0); count is 1
PASS count=0;lastIndex=-1;copyArray(emptyArray).some(forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(emptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(emptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).some(forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeEmptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeEmptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).some(forwarders[f], returnTrue, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeSparseArray), forwarders[f], returnTrue, 0); count is 1
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeSparseArray), forwarders[f], returnTrue, 0); count is 1
PASS count=0;lastIndex=-1;copyArray(simpleArray).some(forwarders[f], returnElem, 0); count is 2
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(simpleArray), forwarders[f], returnElem, 0); count is 2
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(simpleArray), forwarders[f], returnElem, 0); count is 2
PASS count=0;lastIndex=-1;copyArray(emptyArray).some(forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(emptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(emptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).some(forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeEmptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeEmptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).some(forwarders[f], returnElem, 0); count is 2
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeSparseArray), forwarders[f], returnElem, 0); count is 2
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeSparseArray), forwarders[f], returnElem, 0); count is 2
PASS count=0;lastIndex=-1;copyArray(simpleArray).some(forwarders[f], returnIndex, 0); count is 2
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(simpleArray), forwarders[f], returnIndex, 0); count is 2
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(simpleArray), forwarders[f], returnIndex, 0); count is 2
PASS count=0;lastIndex=-1;copyArray(emptyArray).some(forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(emptyArray), forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(emptyArray), forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).some(forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeEmptyArray), forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeEmptyArray), forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).some(forwarders[f], returnIndex, 0); count is 2
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeSparseArray), forwarders[f], returnIndex, 0); count is 2
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeSparseArray), forwarders[f], returnIndex, 0); count is 2
PASS count=0;lastIndex=-1;copyArray(simpleArray).some(forwarders[f], increaseLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(simpleArray), forwarders[f], increaseLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(simpleArray), forwarders[f], increaseLength, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).some(forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(emptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(emptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).some(forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeEmptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeEmptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).some(forwarders[f], increaseLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeSparseArray), forwarders[f], increaseLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeSparseArray), forwarders[f], increaseLength, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).some(forwarders[f], decreaseLength, 0); count is 3
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(simpleArray), forwarders[f], decreaseLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(simpleArray), forwarders[f], decreaseLength, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).some(forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(emptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(emptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).some(forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeEmptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeEmptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).some(forwarders[f], decreaseLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeSparseArray), forwarders[f], decreaseLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeSparseArray), forwarders[f], decreaseLength, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).some(forwarders[f], halveLength, 0); count is 3
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(simpleArray), forwarders[f], halveLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(simpleArray), forwarders[f], halveLength, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).some(forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(emptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(emptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).some(forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeEmptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeEmptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).some(forwarders[f], halveLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeSparseArray), forwarders[f], halveLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.some.call(toObject(largeSparseArray), forwarders[f], halveLength, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).filter(forwarders[f], returnFalse, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(simpleArray), forwarders[f], returnFalse, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(simpleArray), forwarders[f], returnFalse, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).filter(forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(emptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(emptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).filter(forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeEmptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeEmptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).filter(forwarders[f], returnFalse, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeSparseArray), forwarders[f], returnFalse, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeSparseArray), forwarders[f], returnFalse, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).filter(forwarders[f], returnTrue, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(simpleArray), forwarders[f], returnTrue, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(simpleArray), forwarders[f], returnTrue, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).filter(forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(emptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(emptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).filter(forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeEmptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeEmptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).filter(forwarders[f], returnTrue, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeSparseArray), forwarders[f], returnTrue, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeSparseArray), forwarders[f], returnTrue, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).filter(forwarders[f], returnElem, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(simpleArray), forwarders[f], returnElem, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(simpleArray), forwarders[f], returnElem, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).filter(forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(emptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(emptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).filter(forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeEmptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeEmptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).filter(forwarders[f], returnElem, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeSparseArray), forwarders[f], returnElem, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeSparseArray), forwarders[f], returnElem, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).filter(forwarders[f], returnIndex, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(simpleArray), forwarders[f], returnIndex, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(simpleArray), forwarders[f], returnIndex, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).filter(forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(emptyArray), forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(emptyArray), forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).filter(forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeEmptyArray), forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeEmptyArray), forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).filter(forwarders[f], returnIndex, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeSparseArray), forwarders[f], returnIndex, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeSparseArray), forwarders[f], returnIndex, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).filter(forwarders[f], increaseLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(simpleArray), forwarders[f], increaseLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(simpleArray), forwarders[f], increaseLength, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).filter(forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(emptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(emptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).filter(forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeEmptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeEmptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).filter(forwarders[f], increaseLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeSparseArray), forwarders[f], increaseLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeSparseArray), forwarders[f], increaseLength, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).filter(forwarders[f], decreaseLength, 0); count is 3
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(simpleArray), forwarders[f], decreaseLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(simpleArray), forwarders[f], decreaseLength, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).filter(forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(emptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(emptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).filter(forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeEmptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeEmptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).filter(forwarders[f], decreaseLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeSparseArray), forwarders[f], decreaseLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeSparseArray), forwarders[f], decreaseLength, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).filter(forwarders[f], halveLength, 0); count is 3
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(simpleArray), forwarders[f], halveLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(simpleArray), forwarders[f], halveLength, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).filter(forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(emptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(emptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).filter(forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeEmptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeEmptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).filter(forwarders[f], halveLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeSparseArray), forwarders[f], halveLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.filter.call(toObject(largeSparseArray), forwarders[f], halveLength, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduce(forwarders[f], returnFalse, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(simpleArray), forwarders[f], returnFalse, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(simpleArray), forwarders[f], returnFalse, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduce(forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(emptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(emptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduce(forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeEmptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeEmptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduce(forwarders[f], returnFalse, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeSparseArray), forwarders[f], returnFalse, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeSparseArray), forwarders[f], returnFalse, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduce(forwarders[f], returnTrue, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(simpleArray), forwarders[f], returnTrue, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(simpleArray), forwarders[f], returnTrue, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduce(forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(emptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(emptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduce(forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeEmptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeEmptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduce(forwarders[f], returnTrue, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeSparseArray), forwarders[f], returnTrue, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeSparseArray), forwarders[f], returnTrue, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduce(forwarders[f], returnElem, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(simpleArray), forwarders[f], returnElem, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(simpleArray), forwarders[f], returnElem, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduce(forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(emptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(emptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduce(forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeEmptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeEmptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduce(forwarders[f], returnElem, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeSparseArray), forwarders[f], returnElem, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeSparseArray), forwarders[f], returnElem, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduce(forwarders[f], returnIndex, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(simpleArray), forwarders[f], returnIndex, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(simpleArray), forwarders[f], returnIndex, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduce(forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(emptyArray), forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(emptyArray), forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduce(forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeEmptyArray), forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeEmptyArray), forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduce(forwarders[f], returnIndex, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeSparseArray), forwarders[f], returnIndex, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeSparseArray), forwarders[f], returnIndex, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduce(forwarders[f], increaseLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(simpleArray), forwarders[f], increaseLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(simpleArray), forwarders[f], increaseLength, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduce(forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(emptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(emptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduce(forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeEmptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeEmptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduce(forwarders[f], increaseLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeSparseArray), forwarders[f], increaseLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeSparseArray), forwarders[f], increaseLength, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduce(forwarders[f], decreaseLength, 0); count is 3
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(simpleArray), forwarders[f], decreaseLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(simpleArray), forwarders[f], decreaseLength, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduce(forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(emptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(emptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduce(forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeEmptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeEmptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduce(forwarders[f], decreaseLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeSparseArray), forwarders[f], decreaseLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeSparseArray), forwarders[f], decreaseLength, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduce(forwarders[f], halveLength, 0); count is 3
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(simpleArray), forwarders[f], halveLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(simpleArray), forwarders[f], halveLength, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduce(forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(emptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(emptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduce(forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeEmptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeEmptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduce(forwarders[f], halveLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeSparseArray), forwarders[f], halveLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.reduce.call(toObject(largeSparseArray), forwarders[f], halveLength, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).map(forwarders[f], returnFalse, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(simpleArray), forwarders[f], returnFalse, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(simpleArray), forwarders[f], returnFalse, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).map(forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(emptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(emptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).map(forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeEmptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeEmptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).map(forwarders[f], returnFalse, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeSparseArray), forwarders[f], returnFalse, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeSparseArray), forwarders[f], returnFalse, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).map(forwarders[f], returnTrue, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(simpleArray), forwarders[f], returnTrue, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(simpleArray), forwarders[f], returnTrue, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).map(forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(emptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(emptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).map(forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeEmptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeEmptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).map(forwarders[f], returnTrue, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeSparseArray), forwarders[f], returnTrue, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeSparseArray), forwarders[f], returnTrue, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).map(forwarders[f], returnElem, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(simpleArray), forwarders[f], returnElem, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(simpleArray), forwarders[f], returnElem, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).map(forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(emptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(emptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).map(forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeEmptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeEmptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).map(forwarders[f], returnElem, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeSparseArray), forwarders[f], returnElem, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeSparseArray), forwarders[f], returnElem, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).map(forwarders[f], returnIndex, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(simpleArray), forwarders[f], returnIndex, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(simpleArray), forwarders[f], returnIndex, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).map(forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(emptyArray), forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(emptyArray), forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).map(forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeEmptyArray), forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeEmptyArray), forwarders[f], returnIndex, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).map(forwarders[f], returnIndex, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeSparseArray), forwarders[f], returnIndex, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeSparseArray), forwarders[f], returnIndex, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).map(forwarders[f], increaseLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(simpleArray), forwarders[f], increaseLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(simpleArray), forwarders[f], increaseLength, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).map(forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(emptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(emptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).map(forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeEmptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeEmptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).map(forwarders[f], increaseLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeSparseArray), forwarders[f], increaseLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeSparseArray), forwarders[f], increaseLength, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).map(forwarders[f], decreaseLength, 0); count is 3
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(simpleArray), forwarders[f], decreaseLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(simpleArray), forwarders[f], decreaseLength, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).map(forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(emptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(emptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).map(forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeEmptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeEmptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).map(forwarders[f], decreaseLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeSparseArray), forwarders[f], decreaseLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeSparseArray), forwarders[f], decreaseLength, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).map(forwarders[f], halveLength, 0); count is 3
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(simpleArray), forwarders[f], halveLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(simpleArray), forwarders[f], halveLength, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).map(forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(emptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(emptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).map(forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeEmptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeEmptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).map(forwarders[f], halveLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeSparseArray), forwarders[f], halveLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.map.call(toObject(largeSparseArray), forwarders[f], halveLength, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduceRight(forwarders[f], returnFalse, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(simpleArray), forwarders[f], returnFalse, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(simpleArray), forwarders[f], returnFalse, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduceRight(forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(emptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(emptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduceRight(forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeEmptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeEmptyArray), forwarders[f], returnFalse, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduceRight(forwarders[f], returnFalse, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeSparseArray), forwarders[f], returnFalse, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeSparseArray), forwarders[f], returnFalse, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduceRight(forwarders[f], returnTrue, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(simpleArray), forwarders[f], returnTrue, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(simpleArray), forwarders[f], returnTrue, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduceRight(forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(emptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(emptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduceRight(forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeEmptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeEmptyArray), forwarders[f], returnTrue, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduceRight(forwarders[f], returnTrue, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeSparseArray), forwarders[f], returnTrue, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeSparseArray), forwarders[f], returnTrue, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduceRight(forwarders[f], returnElem, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(simpleArray), forwarders[f], returnElem, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(simpleArray), forwarders[f], returnElem, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduceRight(forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(emptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(emptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduceRight(forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeEmptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeEmptyArray), forwarders[f], returnElem, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduceRight(forwarders[f], returnElem, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeSparseArray), forwarders[f], returnElem, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeSparseArray), forwarders[f], returnElem, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduceRight(forwarders[f], increaseLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(simpleArray), forwarders[f], increaseLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(simpleArray), forwarders[f], increaseLength, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduceRight(forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(emptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(emptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduceRight(forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeEmptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeEmptyArray), forwarders[f], increaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduceRight(forwarders[f], increaseLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeSparseArray), forwarders[f], increaseLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeSparseArray), forwarders[f], increaseLength, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduceRight(forwarders[f], decreaseLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(simpleArray), forwarders[f], decreaseLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(simpleArray), forwarders[f], decreaseLength, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduceRight(forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(emptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(emptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduceRight(forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeEmptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeEmptyArray), forwarders[f], decreaseLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduceRight(forwarders[f], decreaseLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeSparseArray), forwarders[f], decreaseLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeSparseArray), forwarders[f], decreaseLength, 0); count is 7
PASS count=0;lastIndex=-1;copyArray(simpleArray).reduceRight(forwarders[f], halveLength, 0); count is 4
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(simpleArray), forwarders[f], halveLength, 0); count is 6
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(simpleArray), forwarders[f], halveLength, 0); count is 6
PASS count=0;lastIndex=-1;copyArray(emptyArray).reduceRight(forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(emptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(emptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeEmptyArray).reduceRight(forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeEmptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeEmptyArray), forwarders[f], halveLength, 0); count is 0
PASS count=0;lastIndex=-1;copyArray(largeSparseArray).reduceRight(forwarders[f], halveLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeSparseArray), forwarders[f], halveLength, 0); count is 7
PASS count=0;lastIndex=-1;Array.prototype.reduceRight.call(toObject(largeSparseArray), forwarders[f], halveLength, 0); count is 7
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/webkit/array-enumerators-functions.js                                      0000664 0000000 0000000 00000016311 14746647661 0024337 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(
"This test checks the behavior of the various array enumeration functions in certain edge case scenarios"
);

var functions = ["every", "forEach", "some", "filter", "reduce", "map", "reduceRight"];
var forwarders = [
    function(elem, index, array) { return currentFunc.call(this, elem, index, array); },
    function(elem, index, array) { return currentFunc.call(this, elem, index, array); },
    function(elem, index, array) { return currentFunc.call(this, elem, index, array); },
    function(elem, index, array) { return currentFunc.call(this, elem, index, array); },
    function(prev, elem, index, array) { return currentFunc.call(this, elem, index, array); },
    function(elem, index, array) { return currentFunc.call(this, elem, index, array); },
    function(prev, elem, index, array) { return currentFunc.call(this, elem, index, array); }
];

function toObject(array) {
    var o = {};
    for (var i in array)
        o[i] = array[i];
    o.length = array.length;
    return o;
}
function toUnorderedObject(array) {
    var o = {};
    var props = [];
    for (var i in array)
        props.push(i);
    for (var i = props.length - 1; i >= 0; i--)
        o[props[i]] = array[props[i]];
    o.length = array.length;
    return o;
}
function returnFalse() { count++; return false; }
function returnTrue() { count++; return true; }
function returnElem(elem) { count++; return elem; }
function returnIndex(a, index) { if (lastIndex >= index) throw "Unordered traversal"; lastIndex = index; count++; return index; }
function increaseLength(a, b, array) { count++; array.length++; }
function decreaseLength(a, b, array) { count++; array.length--; }
function halveLength(a, b, array) { count++; if (!array.halved) array.length = (array.length / 2) | 0; array.halved = true; }

var testFunctions = ["returnFalse", "returnTrue", "returnElem", "returnIndex", "increaseLength", "decreaseLength", "halveLength"];

var simpleArray = [0,1,2,3,4,5];
var emptyArray = [];
var largeEmptyArray = new Array(300);
var largeSparseArray = [0,1,2,3,4,5];
largeSparseArray[299] = 299;

var arrays = ["simpleArray", "emptyArray", "largeEmptyArray", "largeSparseArray"];
function copyArray(a) {
    var g = [];
    for (var i in a)
        g[i] = a[i];
    return g;
}

// Test object and array behaviour matches
for (var f = 0; f < functions.length; f++) {
    for (var t = 0; t < testFunctions.length; t++) {
        for (var a = 0; a < arrays.length; a++) {
            var functionName = functions[f];
            currentFunc = this[testFunctions[t]];
            if (arrays[a] === "largeEmptyArray" && functionName === "map")
                continue;
            if (currentFunc === returnIndex && functionName === "reduceRight")
                continue;
            shouldBe("count=0;lastIndex=-1;copyArray("+arrays[a]+")."+functionName+"(forwarders[f], "+testFunctions[t]+", 0)",
                     "count=0;lastIndex=-1;Array.prototype."+functionName+".call(toObject("+arrays[a]+"), forwarders[f], "+testFunctions[t]+", 0)");
        }
    }
}

// Test unordered object and array behaviour matches
for (var f = 0; f < functions.length; f++) {
    for (var t = 0; t < testFunctions.length; t++) {
        for (var a = 0; a < arrays.length; a++) {
            var functionName = functions[f];
            currentFunc = this[testFunctions[t]];
            if (arrays[a] === "largeEmptyArray" && functionName === "map")
                continue;
            if (currentFunc === returnIndex && functionName === "reduceRight")
                continue;
            shouldBe("count=0;lastIndex=-1;copyArray("+arrays[a]+")."+functionName+"(forwarders[f], "+testFunctions[t]+", 0)",
                     "count=0;lastIndex=-1;Array.prototype."+functionName+".call(toUnorderedObject("+arrays[a]+"), forwarders[f], "+testFunctions[t]+", 0)");
        }
    }
}

// Test number of function calls
var callCounts = [
[[1,0,0,1],[6,0,0,7],[1,0,0,1],[1,0,0,1],[1,0,0,1],[1,0,0,1],[1,0,0,1]],
[[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[3,0,0,6],[3,0,0,6]],
[[6,0,0,7],[1,0,0,1],[2,0,0,2],[2,0,0,2],[6,0,0,7],[3,0,0,6],[3,0,0,6]],
[[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[3,0,0,6],[3,0,0,6]],
[[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[3,0,0,6],[3,0,0,6]],
[[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[3,0,0,6],[3,0,0,6]],
[[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[4,0,0,7]]
];
var objCallCounts = [
[[1,0,0,1],[6,0,0,7],[1,0,0,1],[1,0,0,1],[1,0,0,1],[1,0,0,1],[1,0,0,1]],
[[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7]],
[[6,0,0,7],[1,0,0,1],[2,0,0,2],[2,0,0,2],[6,0,0,7],[6,0,0,7],[6,0,0,7]],
[[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7]],
[[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7]],
[[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7]],
[[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7],[6,0,0,7]]
];
for (var f = 0; f < functions.length; f++) {
    for (var t = 0; t < testFunctions.length; t++) {
        for (var a = 0; a < arrays.length; a++) {
            var functionName = functions[f];
            currentFunc = this[testFunctions[t]];
            if (currentFunc === returnIndex && functionName === "reduceRight")
                continue;
            var expectedCnt = "" + callCounts[f][t][a];
            shouldBe("count=0;lastIndex=-1;copyArray("+arrays[a]+")."+functionName+"(forwarders[f], "+testFunctions[t]+", 0); count", expectedCnt);
            var expectedCnt = "" + objCallCounts[f][t][a];
            shouldBe("count=0;lastIndex=-1;Array.prototype."+functionName+".call(toObject("+arrays[a]+"), forwarders[f], "+testFunctions[t]+", 0); count", expectedCnt);
            shouldBe("count=0;lastIndex=-1;Array.prototype."+functionName+".call(toObject("+arrays[a]+"), forwarders[f], "+testFunctions[t]+", 0); count", expectedCnt);
        }
    }
}
                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/webkit/array-every-expected.txt                                            0000664 0000000 0000000 00000007021 14746647661 0023117 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This test checks the behavior of the every() method on Array objects.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


1.0 Single Argument Testing
PASS [12, 5, 8, 130, 44].every(isBigEnough) is false
PASS [12, 54, 18, 130, 44].every(isBigEnough) is true

2.0 Two Argument Testing
PASS [12, 5, 10, 130, 44].every(isBigEnough, predicate) is false
PASS [12, 54, 18, 130, 44].every(isBigEnough, predicate) is true

3.0 Array Mutation Tests

3.1 Array Element Removal
PASS [12, 5, 8, 130, 44].every(isBigEnoughAndPop) is false
PASS [12, 54, 18, 130, 44].every(isBigEnoughAndPop) is true

3.2 Array Element Changing
PASS [12, 5, 8, 130, 44].every(isBigEnoughAndChange) is false
PASS [12, 54, 18, 130, 44].every(isBigEnoughAndChange) is false

3.3 Array Element Addition
PASS [12, 5, 8, 130, 44].every(isBigEnoughAndPush) is false
PASS [12, 54, 18, 130, 44].every(isBigEnoughAndPush) is false

4.0 Exception Test
PASS [12, 5, 8, 130, 44].every(isBigEnoughAndException) threw exception exception from function.
PASS [12, 54, 18, 130, 44].every(isBigEnoughAndException) threw exception exception from function.

5.0 Wrong Type for Callback Test
PASS [12, 5, 8, 130, 44].every(5) threw exception TypeError: number 5 is not a function.
PASS [12, 5, 8, 130, 44].every('wrong') threw exception TypeError: string "wrong" is not a function.
PASS [12, 5, 8, 130, 44].every(new Object()) threw exception TypeError: object is not a function.
PASS [12, 5, 8, 130, 44].every(null) threw exception TypeError: object null is not a function.
PASS [12, 5, 8, 130, 44].every(undefined) threw exception TypeError: undefined is not a function.
PASS [12, 5, 8, 130, 44].every() threw exception TypeError: undefined is not a function.

6.0 Early Exit ("Short Circuiting")
PASS [12, 5, 8, 130, 44].every(isBigEnoughShortCircuit) is false
PASS accumulator.toString() is [12, 5].toString()
PASS [12, 54, 18, 130, 44].every(isBigEnoughShortCircuit) is true
PASS accumulator.toString() is [12, 54, 18, 130, 44].toString()

7.0 Behavior for Holes in Arrays
PASS arr.every(isNotUndefined) is true
PASS arr.every(isNotUndefined) is true
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/webkit/array-every.js                                                      0000664 0000000 0000000 00000010652 14746647661 0021121 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(
"This test checks the behavior of the every() method on Array objects."
);

debug("1.0 Single Argument Testing");
function isBigEnough(element, index, array) {
    return (element >= 10);
}
shouldBeFalse("[12, 5, 8, 130, 44].every(isBigEnough)");
shouldBeTrue("[12, 54, 18, 130, 44].every(isBigEnough)");
debug("");

debug("2.0 Two Argument Testing");
var predicate = {
    comparison:     11,
    isBigEnough:    function(s) {
                        return (s >= comparison);
                    }
};
shouldBeFalse("[12, 5, 10, 130, 44].every(isBigEnough, predicate)");
shouldBeTrue("[12, 54, 18, 130, 44].every(isBigEnough, predicate)");
debug("");

debug("3.0 Array Mutation Tests");
debug("");

debug("3.1 Array Element Removal");
function isBigEnoughAndPop(element, index, array) {
    array.pop();
    return (element >= 10);
}
shouldBeFalse("[12, 5, 8, 130, 44].every(isBigEnoughAndPop)");
shouldBeTrue("[12, 54, 18, 130, 44].every(isBigEnoughAndPop)");
debug("");

debug("3.2 Array Element Changing");
function isBigEnoughAndChange(element, index, array) {
    array[array.length-1-index]= 5;
    return (element >= 10);
}
shouldBeFalse("[12, 5, 8, 130, 44].every(isBigEnoughAndChange)");
shouldBeFalse("[12, 54, 18, 130, 44].every(isBigEnoughAndChange)");
debug("");

debug("3.3 Array Element Addition");
function isBigEnoughAndPush(element, index, array) {
    array.push(131);
    return (element >= 131);
}
shouldBeFalse("[12, 5, 8, 130, 44].every(isBigEnoughAndPush)");
shouldBeFalse("[12, 54, 18, 130, 44].every(isBigEnoughAndPush)");
debug("");

debug("4.0 Exception Test");
function isBigEnoughAndException(element, index, array) {
    if(index==1) throw "exception from function";
    return (element >= 10);
}
shouldThrow("[12, 5, 8, 130, 44].every(isBigEnoughAndException)", '"exception from function"');
shouldThrow("[12, 54, 18, 130, 44].every(isBigEnoughAndException)", '"exception from function"');
debug("");

debug("5.0 Wrong Type for Callback Test");
shouldThrow("[12, 5, 8, 130, 44].every(5)");
shouldThrow("[12, 5, 8, 130, 44].every('wrong')");
shouldThrow("[12, 5, 8, 130, 44].every(new Object())");
shouldThrow("[12, 5, 8, 130, 44].every(null)");
shouldThrow("[12, 5, 8, 130, 44].every(undefined)");
shouldThrow("[12, 5, 8, 130, 44].every()");
debug("");

debug('6.0 Early Exit ("Short Circuiting")');
var accumulator = new Array();
function isBigEnoughShortCircuit(element, index, array) {
    accumulator.push(element);
    return (element >= 10);
}
shouldBeFalse("[12, 5, 8, 130, 44].every(isBigEnoughShortCircuit)");
shouldBe("accumulator.toString()", "[12, 5].toString()");
accumulator.length = 0;
shouldBeTrue("[12, 54, 18, 130, 44].every(isBigEnoughShortCircuit)");
shouldBe("accumulator.toString()", "[12, 54, 18, 130, 44].toString()");
debug("");

debug('7.0 Behavior for Holes in Arrays');
var arr = [5, 5, 5, 5];
delete arr[1];
function isNotUndefined(element, index, array) {
    return typeof element !== "undefined";
}
shouldBeTrue("arr.every(isNotUndefined)");
arr = new Array(20);
shouldBeTrue("arr.every(isNotUndefined)");
                                                                                      node-23.7.0/deps/v8/test/webkit/array-filter-expected.txt                                           0000664 0000000 0000000 00000007722 14746647661 0023262 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Tests for Array.prototype.filter

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS [undefined].filter(passUndefined) is [undefined]
PASS (new Array(20)).filter(passUndefined) is []
PASS [0,1,2,3,4,5,6,7,8,9].filter(passEven) is [0,2,4,6,8]
PASS [0,1,2,3,4,5,6,7,8,9].filter(passAfter5) is [5,6,7,8,9]
PASS mixPartialAndFast.filter(passAfter5) is [5,6,7,8,9,sparseArrayLength-1]
PASS toObject([undefined]).filter(passUndefined) is [undefined]
PASS toObject(new Array(20)).filter(passUndefined) is []
PASS toObject([0,1,2,3,4,5,6,7,8,9]).filter(passEven) is [0,2,4,6,8]
PASS toObject([0,1,2,3,4,5,6,7,8,9]).filter(passAfter5) is [5,6,7,8,9]
PASS toObject(mixPartialAndFast).filter(passAfter5) is [5,6,7,8,9,sparseArrayLength-1]
PASS reverseInsertionOrder([undefined]).filter(passUndefined) is [undefined]
PASS reverseInsertionOrder(new Array(20)).filter(passUndefined) is []
PASS reverseInsertionOrder([0,1,2,3,4,5,6,7,8,9]).filter(passEven) is [0,2,4,6,8]
PASS reverseInsertionOrder([0,1,2,3,4,5,6,7,8,9]).filter(passAfter5) is [5,6,7,8,9]
PASS reverseInsertionOrder(mixPartialAndFast).filter(passAfter5) is [5,6,7,8,9,sparseArrayLength-1]
,0,[object Object]
PASS reverseInsertionOrder([undefined]).filter(filterLog(passUndefined)) is [undefined]
PASS reverseInsertionOrder(new Array(20)).filter(filterLog(passUndefined)) is []
0,0,[object Object]
1,1,[object Object]
2,2,[object Object]
3,3,[object Object]
4,4,[object Object]
PASS reverseInsertionOrder([0,1,2,3,4]).filter(filterLog(passEven)) is [0,2,4]
0,0,[object Object]
1,1,[object Object]
2,2,[object Object]
3,3,[object Object]
4,4,[object Object]
5,5,[object Object]
6,6,[object Object]
7,7,[object Object]
8,8,[object Object]
9,9,[object Object]
10099,10099,[object Object]
PASS reverseInsertionOrder(mixPartialAndFast).filter(filterLog(passAfter5)) is [5,6,7,8,9,sparseArrayLength-1]
,0,
PASS ([undefined]).filter(filterLog(passUndefined)) is [undefined]
PASS (new Array(20)).filter(filterLog(passUndefined)) is []
0,0,0,1,2,3,4
1,1,0,1,2,3,4
2,2,0,1,2,3,4
3,3,0,1,2,3,4
4,4,0,1,2,3,4
PASS ([0,1,2,3,4]).filter(filterLog(passEven)) is [0,2,4]
0,0,0,1,2,3,4,5,6,7,8,9,
1,1,0,1,2,3,4,5,6,7,8,9,
2,2,0,1,2,3,4,5,6,7,8,9,
3,3,0,1,2,3,4,5,6,7,8,9,
4,4,0,1,2,3,4,5,6,7,8,9,
5,5,0,1,2,3,4,5,6,7,8,9,
6,6,0,1,2,3,4,5,6,7,8,9,
7,7,0,1,2,3,4,5,6,7,8,9,
8,8,0,1,2,3,4,5,6,7,8,9,
9,9,0,1,2,3,4,5,6,7,8,9,
10099,10099,0,1,2,3,4,5,6,7,8,9,
PASS (mixPartialAndFast).filter(filterLog(passAfter5)) is [5,6,7,8,9,sparseArrayLength-1]
PASS [1,2,3].filter(function(i,j,k,l,m){ return m=!m; }) is [1,2,3]
PASS successfullyParsed is true

TEST COMPLETE

                                              node-23.7.0/deps/v8/test/webkit/array-filter.js                                                     0000664 0000000 0000000 00000011112 14746647661 0021244 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description("Tests for Array.prototype.filter");

function passUndefined(element, index, array) {
    return typeof element === "undefined";
}
function passEven(a) {
    return !(a & 1);
}
function passAfter5(element, index) {
    return index >= 5;
}
var sparseArrayLength = 10100;
mixPartialAndFast = new Array(sparseArrayLength);
mixPartialAndFast[sparseArrayLength - 1] = sparseArrayLength - 1;
for(var i = 0; i < 10; i++)
    mixPartialAndFast[i] = i;
function toObject(array) {
    var result = {};
    result.length = array.length;
    for (var i in array)
        result[i] = array[i];
    result.filter=Array.prototype.filter;
    return result;
}
function reverseInsertionOrder(array) {
    var obj = toObject(array);
    var props = [];
    for (var i in obj)
        props.push(i);
    var result = {};
    for (var i = props.length - 1; i >= 0; i--)
        result[props[i]] = obj[props[i]];
    result.filter=Array.prototype.filter;
    return result;
}
function filterLog(f) {
    return function(i,j) {
        try {
        debug([i,j,arguments[2].toString().substring(0,20)].toString());
        return f.apply(this, arguments);
        } catch(e) {
            console.error(e);
        }
    }
}

shouldBe("[undefined].filter(passUndefined)", "[undefined]");
shouldBe("(new Array(20)).filter(passUndefined)", "[]");
shouldBe("[0,1,2,3,4,5,6,7,8,9].filter(passEven)", "[0,2,4,6,8]");
shouldBe("[0,1,2,3,4,5,6,7,8,9].filter(passAfter5)", "[5,6,7,8,9]");
shouldBe("mixPartialAndFast.filter(passAfter5)", "[5,6,7,8,9,sparseArrayLength-1]");

// Generic Object
shouldBe("toObject([undefined]).filter(passUndefined)", "[undefined]");
shouldBe("toObject(new Array(20)).filter(passUndefined)", "[]");
shouldBe("toObject([0,1,2,3,4,5,6,7,8,9]).filter(passEven)", "[0,2,4,6,8]");
shouldBe("toObject([0,1,2,3,4,5,6,7,8,9]).filter(passAfter5)", "[5,6,7,8,9]");
shouldBe("toObject(mixPartialAndFast).filter(passAfter5)", "[5,6,7,8,9,sparseArrayLength-1]");

// Reversed generic Object
shouldBe("reverseInsertionOrder([undefined]).filter(passUndefined)", "[undefined]");
shouldBe("reverseInsertionOrder(new Array(20)).filter(passUndefined)", "[]");
shouldBe("reverseInsertionOrder([0,1,2,3,4,5,6,7,8,9]).filter(passEven)", "[0,2,4,6,8]");
shouldBe("reverseInsertionOrder([0,1,2,3,4,5,6,7,8,9]).filter(passAfter5)", "[5,6,7,8,9]");
shouldBe("reverseInsertionOrder(mixPartialAndFast).filter(passAfter5)", "[5,6,7,8,9,sparseArrayLength-1]");

// Log evaluation order
shouldBe("reverseInsertionOrder([undefined]).filter(filterLog(passUndefined))", "[undefined]");
shouldBe("reverseInsertionOrder(new Array(20)).filter(filterLog(passUndefined))", "[]");
shouldBe("reverseInsertionOrder([0,1,2,3,4]).filter(filterLog(passEven))", "[0,2,4]");
shouldBe("reverseInsertionOrder(mixPartialAndFast).filter(filterLog(passAfter5))", "[5,6,7,8,9,sparseArrayLength-1]");
shouldBe("([undefined]).filter(filterLog(passUndefined))", "[undefined]");
shouldBe("(new Array(20)).filter(filterLog(passUndefined))", "[]");
shouldBe("([0,1,2,3,4]).filter(filterLog(passEven))", "[0,2,4]");
shouldBe("(mixPartialAndFast).filter(filterLog(passAfter5))", "[5,6,7,8,9,sparseArrayLength-1]");

shouldBe("[1,2,3].filter(function(i,j,k,l,m){ return m=!m; })", "[1,2,3]")
                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/webkit/array-holes-expected.txt                                            0000664 0000000 0000000 00000012143 14746647661 0023100 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This tests that arrays have holes that you can see the prototype through, not just missing values.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS var a = []; a.length = 1; showHoles(a) is '[hole]'
PASS var a = []; a[0] = undefined; showHoles(a) is '[undefined]'
PASS var a = []; a[0] = undefined; delete a[0]; showHoles(a) is '[hole]'
PASS showHoles([0, , 2]) is '[0, hole, 2]'
PASS showHoles([0, 1, ,]) is '[0, 1, hole]'
PASS showHoles([0, , 2].concat([3, , 5])) is '[0, hole, 2, 3, hole, 5]'
PASS showHoles([0, , 2, 3].reverse()) is '[3, 2, hole, 0]'
PASS a = [0, , 2, 3]; a.shift(); showHoles(a) is '[hole, 2, 3]'
PASS showHoles([0, , 2, 3].slice(0, 3)) is '[0, hole, 2]'
PASS showHoles([0, , 2, 3].sort()) is '[0, 2, 3, hole]'
PASS showHoles([0, undefined, 2, 3].sort()) is '[0, 2, 3, undefined]'
PASS a = [0, , 2, 3]; a.splice(2, 3, 5, 6); showHoles(a) is '[0, hole, 5, 6]'
PASS a = [0, , 2, 3]; a.unshift(4); showHoles(a) is '[4, 0, hole, 2, 3]'
PASS showHoles([0, , 2, 3].filter(returnTrue)) is '[0, 2, 3]'
PASS showHoles([0, undefined, 2, 3].filter(returnTrue)) is '[0, undefined, 2, 3]'
PASS showHoles([0, , 2, 3].map(returnTrue)) is '[true, hole, true, true]'
PASS showHoles([0, undefined, 2, 3].map(returnTrue)) is '[true, true, true, true]'
PASS a = []; [0, , 2, 3].every(addToArrayReturnTrue); showHoles(a) is '[0, 2, 3]'
PASS a = []; [0, undefined, 2, 3].every(addToArrayReturnTrue); showHoles(a) is '[0, undefined, 2, 3]'
PASS a = []; [0, , 2, 3].forEach(addToArray); showHoles(a) is '[0, 2, 3]'
PASS a = []; [0, undefined, 2, 3].forEach(addToArray); showHoles(a) is '[0, undefined, 2, 3]'
PASS a = []; [0, , 2, 3].some(addToArrayReturnFalse); showHoles(a) is '[0, 2, 3]'
PASS a = []; [0, undefined, 2, 3].some(addToArrayReturnFalse); showHoles(a) is '[0, undefined, 2, 3]'
PASS [0, , 2, 3].indexOf() is -1
PASS [0, undefined, 2, 3].indexOf() is 1
PASS [0, , 2, 3].lastIndexOf() is -1
PASS [0, undefined, 2, 3].lastIndexOf() is 1
PASS showHoles([0, , 2]) is '[0, hole, 2]'
PASS showHoles([0, 1, ,]) is '[0, 1, hole]'
PASS showHoles([0, , 2].concat([3, , 5])) is '[0, peekaboo, 2, 3, peekaboo, 5]'
PASS showHoles([0, , 2, 3].reverse()) is '[3, 2, peekaboo, 0]'
PASS a = [0, , 2, 3]; a.shift(); showHoles(a) is '[peekaboo, 2, 3]'
PASS showHoles([0, , 2, 3].slice(0, 3)) is '[0, peekaboo, 2]'
PASS showHoles([0, , 2, 3].sort()) is '[0, 2, 3, peekaboo]'
PASS showHoles([0, undefined, 2, 3].sort()) is '[0, 2, 3, undefined]'
PASS a = [0, , 2, 3]; a.splice(2, 3, 5, 6); showHoles(a) is '[0, hole, 5, 6]'
PASS a = [0, , 2, 3]; a.unshift(4); showHoles(a) is '[4, 0, peekaboo, 2, 3]'
PASS showHoles([0, , 2, 3].filter(returnTrue)) is '[0, peekaboo, 2, 3]'
PASS showHoles([0, undefined, 2, 3].filter(returnTrue)) is '[0, undefined, 2, 3]'
PASS showHoles([0, , 2, 3].map(returnTrue)) is '[true, true, true, true]'
PASS showHoles([0, undefined, 2, 3].map(returnTrue)) is '[true, true, true, true]'
PASS a = []; [0, , 2, 3].every(addToArrayReturnTrue); showHoles(a) is '[0, peekaboo, 2, 3]'
PASS a = []; [0, undefined, 2, 3].every(addToArrayReturnTrue); showHoles(a) is '[0, undefined, 2, 3]'
PASS a = []; [0, , 2, 3].forEach(addToArray); showHoles(a) is '[0, peekaboo, 2, 3]'
PASS a = []; [0, undefined, 2, 3].forEach(addToArray); showHoles(a) is '[0, undefined, 2, 3]'
PASS a = []; [0, , 2, 3].some(addToArrayReturnFalse); showHoles(a) is '[0, peekaboo, 2, 3]'
PASS a = []; [0, undefined, 2, 3].some(addToArrayReturnFalse); showHoles(a) is '[0, undefined, 2, 3]'
PASS [0, , 2, 3].indexOf() is -1
PASS [0, , 2, 3].indexOf('peekaboo') is 1
PASS [0, undefined, 2, 3].indexOf() is 1
PASS [0, , 2, 3].lastIndexOf() is -1
PASS [0, , 2, 3].lastIndexOf('peekaboo') is 1
PASS [0, undefined, 2, 3].lastIndexOf() is 1
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/webkit/array-holes.js                                                      0000664 0000000 0000000 00000014463 14746647661 0021105 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description("This tests that arrays have holes that you can see the prototype through, not just missing values.");

function isHole(array, index)
{
    if (index >= array.length)
        return "bad index: past length";
    // Check if we can see through the hole into another room.
    Array.prototype[index] = "room";
    var isHole = array[index] == "room";
    delete Array.prototype[index];
    return isHole;
}

function showHoles(array)
{
    var string = "[";
    for (i = 0; i < array.length; ++i) {
        if (i)
            string += ", ";
        if (isHole(array, i))
            string += "hole";
        else
            string += array[i];
    }
    string += "]";
    return string;
}

function returnTrue()
{
    return true;
}

var a;

function addToArray(arg)
{
    a.push(arg);
}

function addToArrayReturnFalse(arg)
{
    a.push(arg);
    return false;
}

function addToArrayReturnTrue(arg)
{
    a.push(arg);
    return true;
}

shouldBe("var a = []; a.length = 1; showHoles(a)", "'[hole]'");
shouldBe("var a = []; a[0] = undefined; showHoles(a)", "'[undefined]'");
shouldBe("var a = []; a[0] = undefined; delete a[0]; showHoles(a)", "'[hole]'");

shouldBe("showHoles([0, , 2])", "'[0, hole, 2]'");
shouldBe("showHoles([0, 1, ,])", "'[0, 1, hole]'");
shouldBe("showHoles([0, , 2].concat([3, , 5]))", "'[0, hole, 2, 3, hole, 5]'");
shouldBe("showHoles([0, , 2, 3].reverse())", "'[3, 2, hole, 0]'");
shouldBe("a = [0, , 2, 3]; a.shift(); showHoles(a)", "'[hole, 2, 3]'");
shouldBe("showHoles([0, , 2, 3].slice(0, 3))", "'[0, hole, 2]'");
shouldBe("showHoles([0, , 2, 3].sort())", "'[0, 2, 3, hole]'");
shouldBe("showHoles([0, undefined, 2, 3].sort())", "'[0, 2, 3, undefined]'");
shouldBe("a = [0, , 2, 3]; a.splice(2, 3, 5, 6); showHoles(a)", "'[0, hole, 5, 6]'");
shouldBe("a = [0, , 2, 3]; a.unshift(4); showHoles(a)", "'[4, 0, hole, 2, 3]'");
shouldBe("showHoles([0, , 2, 3].filter(returnTrue))", "'[0, 2, 3]'");
shouldBe("showHoles([0, undefined, 2, 3].filter(returnTrue))", "'[0, undefined, 2, 3]'");
shouldBe("showHoles([0, , 2, 3].map(returnTrue))", "'[true, hole, true, true]'");
shouldBe("showHoles([0, undefined, 2, 3].map(returnTrue))", "'[true, true, true, true]'");
shouldBe("a = []; [0, , 2, 3].every(addToArrayReturnTrue); showHoles(a)", "'[0, 2, 3]'");
shouldBe("a = []; [0, undefined, 2, 3].every(addToArrayReturnTrue); showHoles(a)", "'[0, undefined, 2, 3]'");
shouldBe("a = []; [0, , 2, 3].forEach(addToArray); showHoles(a)", "'[0, 2, 3]'");
shouldBe("a = []; [0, undefined, 2, 3].forEach(addToArray); showHoles(a)", "'[0, undefined, 2, 3]'");
shouldBe("a = []; [0, , 2, 3].some(addToArrayReturnFalse); showHoles(a)", "'[0, 2, 3]'");
shouldBe("a = []; [0, undefined, 2, 3].some(addToArrayReturnFalse); showHoles(a)", "'[0, undefined, 2, 3]'");
shouldBe("[0, , 2, 3].indexOf()", "-1");
shouldBe("[0, undefined, 2, 3].indexOf()", "1");
shouldBe("[0, , 2, 3].lastIndexOf()", "-1");
shouldBe("[0, undefined, 2, 3].lastIndexOf()", "1");

Object.prototype[1] = "peekaboo";

shouldBe("showHoles([0, , 2])", "'[0, hole, 2]'");
shouldBe("showHoles([0, 1, ,])", "'[0, 1, hole]'");
shouldBe("showHoles([0, , 2].concat([3, , 5]))", "'[0, peekaboo, 2, 3, peekaboo, 5]'");
shouldBe("showHoles([0, , 2, 3].reverse())", "'[3, 2, peekaboo, 0]'");
shouldBe("a = [0, , 2, 3]; a.shift(); showHoles(a)", "'[peekaboo, 2, 3]'");
shouldBe("showHoles([0, , 2, 3].slice(0, 3))", "'[0, peekaboo, 2]'");
shouldBe("showHoles([0, , 2, 3].sort())", "'[0, 2, 3, peekaboo]'");
shouldBe("showHoles([0, undefined, 2, 3].sort())", "'[0, 2, 3, undefined]'");
shouldBe("a = [0, , 2, 3]; a.splice(2, 3, 5, 6); showHoles(a)", "'[0, hole, 5, 6]'");
shouldBe("a = [0, , 2, 3]; a.unshift(4); showHoles(a)", "'[4, 0, peekaboo, 2, 3]'");
shouldBe("showHoles([0, , 2, 3].filter(returnTrue))", "'[0, peekaboo, 2, 3]'");
shouldBe("showHoles([0, undefined, 2, 3].filter(returnTrue))", "'[0, undefined, 2, 3]'");
shouldBe("showHoles([0, , 2, 3].map(returnTrue))", "'[true, true, true, true]'");
shouldBe("showHoles([0, undefined, 2, 3].map(returnTrue))", "'[true, true, true, true]'");
shouldBe("a = []; [0, , 2, 3].every(addToArrayReturnTrue); showHoles(a)", "'[0, peekaboo, 2, 3]'");
shouldBe("a = []; [0, undefined, 2, 3].every(addToArrayReturnTrue); showHoles(a)", "'[0, undefined, 2, 3]'");
shouldBe("a = []; [0, , 2, 3].forEach(addToArray); showHoles(a)", "'[0, peekaboo, 2, 3]'");
shouldBe("a = []; [0, undefined, 2, 3].forEach(addToArray); showHoles(a)", "'[0, undefined, 2, 3]'");
shouldBe("a = []; [0, , 2, 3].some(addToArrayReturnFalse); showHoles(a)", "'[0, peekaboo, 2, 3]'");
shouldBe("a = []; [0, undefined, 2, 3].some(addToArrayReturnFalse); showHoles(a)", "'[0, undefined, 2, 3]'");
shouldBe("[0, , 2, 3].indexOf()", "-1");
shouldBe("[0, , 2, 3].indexOf('peekaboo')", "1");
shouldBe("[0, undefined, 2, 3].indexOf()", "1");
shouldBe("[0, , 2, 3].lastIndexOf()", "-1");
shouldBe("[0, , 2, 3].lastIndexOf('peekaboo')", "1");
shouldBe("[0, undefined, 2, 3].lastIndexOf()", "1");

delete Object.prototype[1];
                                                                                                                                                                                                             node-23.7.0/deps/v8/test/webkit/array-index-immediate-types-expected.txt                            0000664 0000000 0000000 00000003454 14746647661 0026200 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This test checks the behaviour of indexing an Array with immediate types.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS array[0] is "Zero"
PASS array[null] is undefined
PASS array[undefined] is undefined
PASS array[true] is undefined
PASS array[false] is undefined
PASS putSelf([0], 0); is true
PASS putSelf([0], 1/9); is true
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                    node-23.7.0/deps/v8/test/webkit/array-index-immediate-types.js                                      0000664 0000000 0000000 00000003605 14746647661 0024174 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(
"This test checks the behaviour of indexing an Array with immediate types."
);

var array = ["Zero", "One"];

shouldBe("array[0]", '"Zero"');
shouldBe("array[null]", "undefined");
shouldBe("array[undefined]", "undefined");
shouldBe("array[true]", "undefined");
shouldBe("array[false]", "undefined");

function putSelf(array, index)
{
    index = index << 0;
    array[index] = index;
    return true;
}

shouldBeTrue("putSelf([0], 0);");
shouldBeTrue("putSelf([0], 1/9);");
                                                                                                                           node-23.7.0/deps/v8/test/webkit/array-indexing-expected.txt                                         0000664 0000000 0000000 00000003244 14746647661 0023575 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This test checks that array accessing doesn't do the wrong thing for negative indices

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS a.length is 0
PASS a["-5"] is a[-5]
PASS a[4] is undefined
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/test/webkit/array-indexing.js                                                   0000664 0000000 0000000 00000003331 14746647661 0021570 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(
"This test checks that array accessing doesn't do the wrong thing for negative indices"
);
var a = [];
a[-5] =  true;
shouldBe('a.length', '0');
shouldBe('a["-5"]', 'a[-5]');

// Just some bounds paranoia
a = [1,2,3,4];
shouldBe('a[4]', 'undefined');

a = [];
for (var i = 0; i > -1000; i--) a[i] = i;
                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/webkit/array-iterate-backwards-expected.txt                                0000664 0000000 0000000 00000003251 14746647661 0025362 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This test checks that iterating a large array backwards works correctly.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS verify(32768) is true
PASS verify(65536) is true
PASS verify(120000) is true
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/webkit/array-iterate-backwards.js                                          0000664 0000000 0000000 00000003716 14746647661 0023366 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(
"This test checks that iterating a large array backwards works correctly."
);

var bytes = new Array();

function prepare(nbytes) {
    var i = nbytes - 1;
    while (i >= 0) {
        bytes[i] = new Number(i);
        i -= 1;
    }
}

function verify(nbytes) {
    var i = nbytes - 1;
    while (i >= 0) {
        if (bytes[i] != i)
            return false;
        i -= 1;
    }
    return true;
}

prepare(32768);
shouldBeTrue('verify(32768)');

prepare(65536);
shouldBeTrue('verify(65536)');

prepare(120000);
shouldBeTrue('verify(120000)');
                                                  node-23.7.0/deps/v8/test/webkit/array-lastIndexOf-expected.txt                                      0000664 0000000 0000000 00000003552 14746647661 0024212 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This test checks lastIndexOf for various values in an array

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS lastIndex is -1
PASS lastIndex is 2
PASS lastIndex is 3
PASS lastIndex is -1
PASS lastIndex is 3
PASS lastIndex is 0
PASS lastIndex is 0
PASS lastIndex is 3
PASS lastIndex is -1
PASS lastIndex is -1
PASS lastIndex is -1
PASS lastIndex is 19
PASS lastIndex is -1
PASS lastIndex is -1
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                      node-23.7.0/deps/v8/test/webkit/array-lastIndexOf.js                                                0000664 0000000 0000000 00000005220 14746647661 0022202 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(
'This test checks lastIndexOf for various values in an array'
);


var testArray = [2, 5, 9, 2];
var lastIndex = 0;

lastIndex = testArray.lastIndexOf(2,-500);
shouldBe('lastIndex', '-1');
lastIndex = testArray.lastIndexOf(9,500);
shouldBe('lastIndex', '2');
lastIndex = testArray.lastIndexOf(2);
shouldBe('lastIndex', '3');
lastIndex = testArray.lastIndexOf(7);
shouldBe('lastIndex', '-1');
lastIndex = testArray.lastIndexOf(2, 3);
shouldBe('lastIndex', '3');
lastIndex = testArray.lastIndexOf(2, 2);
shouldBe('lastIndex', '0');
lastIndex = testArray.lastIndexOf(2, -2);
shouldBe('lastIndex', '0');
lastIndex = testArray.lastIndexOf(2, -1);
shouldBe('lastIndex', '3');

delete testArray[1];

lastIndex = testArray.lastIndexOf(undefined);
shouldBe('lastIndex', '-1');

delete testArray[3];

lastIndex = testArray.lastIndexOf(undefined);
shouldBe('lastIndex', '-1');

testArray = new Array(20);

lastIndex = testArray.lastIndexOf(undefined);
shouldBe('lastIndex', '-1');

testArray[19] = undefined;

lastIndex = testArray.lastIndexOf(undefined);
shouldBe('lastIndex', '19');

lastIndex = testArray.lastIndexOf(undefined, 18);
shouldBe('lastIndex', '-1');

delete testArray[19];

lastIndex = testArray.lastIndexOf(undefined);
shouldBe('lastIndex', '-1');
                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/webkit/array-proto-func-length-getter-except-expected.txt                  0000664 0000000 0000000 00000004610 14746647661 0030117 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This test checks that functions on the array prototype correctly handle exceptions from length getters when called on non-array objects.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS test(Array.prototype.join) is true
PASS test(Array.prototype.pop) is true
PASS test(Array.prototype.push) is true
PASS test(Array.prototype.reverse) is true
PASS test(Array.prototype.shift) is true
PASS test(Array.prototype.slice) is true
PASS test(Array.prototype.sort) is true
PASS test(Array.prototype.splice) is true
PASS test(Array.prototype.unshift) is true
PASS test(Array.prototype.indexOf) is true
PASS test(Array.prototype.lastIndexOf) is true
PASS test(Array.prototype.every) is true
PASS test(Array.prototype.some) is true
PASS test(Array.prototype.forEach) is true
PASS test(Array.prototype.map) is true
PASS test(Array.prototype.filter) is true
PASS test(Array.prototype.reduce) is true
PASS test(Array.prototype.reduceRight) is true
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                        node-23.7.0/deps/v8/test/webkit/array-proto-func-length-getter-except.js                            0000664 0000000 0000000 00000005254 14746647661 0026122 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(
"This test checks that functions on the array prototype correctly handle exceptions from length getters when called on non-array objects."
);

var testObj = {
    0: "a",
    1: "b",
    2: "c"
};
var lengthGetter = {
    get: (function() { throw true; })
}
Object.defineProperty(testObj, "length", lengthGetter);

function test(f) {
    try {
        f.call(testObj, undefined);
        return false;
    } catch (e) {
        return e === true;
    }
}

shouldBeTrue("test(Array.prototype.join)");
shouldBeTrue("test(Array.prototype.pop)");
shouldBeTrue("test(Array.prototype.push)");
shouldBeTrue("test(Array.prototype.reverse)");
shouldBeTrue("test(Array.prototype.shift)");
shouldBeTrue("test(Array.prototype.slice)");
shouldBeTrue("test(Array.prototype.sort)");
shouldBeTrue("test(Array.prototype.splice)");
shouldBeTrue("test(Array.prototype.unshift)");
shouldBeTrue("test(Array.prototype.indexOf)");
shouldBeTrue("test(Array.prototype.lastIndexOf)");
shouldBeTrue("test(Array.prototype.every)");
shouldBeTrue("test(Array.prototype.some)");
shouldBeTrue("test(Array.prototype.forEach)");
shouldBeTrue("test(Array.prototype.map)");
shouldBeTrue("test(Array.prototype.filter)");
shouldBeTrue("test(Array.prototype.reduce)");
shouldBeTrue("test(Array.prototype.reduceRight)");
                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/test/webkit/array-proto-func-property-getter-except-expected.txt                0000664 0000000 0000000 00000004613 14746647661 0030525 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This test checks that functions on the array prototype correctly handle exceptions from property getters when called on non-array objects.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS test(Array.prototype.sort) is true
PASS test(Array.prototype.every) is true
PASS test(Array.prototype.some) is true
PASS test(Array.prototype.forEach) is true
PASS test(Array.prototype.map) is true
PASS test(Array.prototype.filter) is true
PASS test(Array.prototype.reduce) is true
PASS test(Array.prototype.reduceRight) is true
PASS test(Array.prototype.join) is true
PASS test(Array.prototype.pop) is true
PASS test(Array.prototype.push) is false
PASS test(Array.prototype.reverse) is true
PASS test(Array.prototype.shift) is true
PASS test(Array.prototype.slice) is true
PASS test(Array.prototype.splice) is true
PASS test(Array.prototype.unshift) is true
PASS test(Array.prototype.indexOf) is true
PASS test(Array.prototype.lastIndexOf) is true
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                     node-23.7.0/deps/v8/test/webkit/array-proto-func-property-getter-except.js                          0000664 0000000 0000000 00000005733 14746647661 0026527 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(
"This test checks that functions on the array prototype correctly handle exceptions from property getters when called on non-array objects."
);

function test(f) {

    var testObj = {
        length: 3
    };
    var propertyGetter = {
        get: (function() { throw true; })
    }
    Object.defineProperty(testObj, 0, propertyGetter);
    Object.defineProperty(testObj, 1, propertyGetter);
    Object.defineProperty(testObj, 2, propertyGetter);

    try {
        f.call(testObj, function(){});
        return false;
    } catch (e) {
        return e === true;
    }
}

// This test makes sense for these functions: (they should get all properties on the array)
shouldBeTrue("test(Array.prototype.sort)");
shouldBeTrue("test(Array.prototype.every)");
shouldBeTrue("test(Array.prototype.some)");
shouldBeTrue("test(Array.prototype.forEach)");
shouldBeTrue("test(Array.prototype.map)");
shouldBeTrue("test(Array.prototype.filter)");
shouldBeTrue("test(Array.prototype.reduce)");
shouldBeTrue("test(Array.prototype.reduceRight)");

// Probably not testing much of anything in these cases, but make sure they don't crash!
shouldBeTrue("test(Array.prototype.join)");
shouldBeTrue("test(Array.prototype.pop)");
shouldBeFalse("test(Array.prototype.push)");
shouldBeTrue("test(Array.prototype.reverse)");
shouldBeTrue("test(Array.prototype.shift)");
shouldBeTrue("test(Array.prototype.slice)");
shouldBeTrue("test(Array.prototype.splice)");
shouldBeTrue("test(Array.prototype.unshift)");
shouldBeTrue("test(Array.prototype.indexOf)");
shouldBeTrue("test(Array.prototype.lastIndexOf)");
                                     node-23.7.0/deps/v8/test/webkit/array-reduce-expected.txt                                           0000664 0000000 0000000 00000010252 14746647661 0023234 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This test checks the behavior of the reduce() method on a number of objects.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS [0,1,2,3].reduce(function(a,b){ return a + b; }) is 6
PASS [1,2,3].reduce(function(a,b){ return a + b; }) is 6
PASS [0,1,2,3].reduce(function(a,b){ return a + b; }, 4) is 10
PASS [1,2,3].reduce(function(a,b){ return a + b; }, 4) is 10
PASS toObject([0,1,2,3]).reduce(function(a,b){ return a + b; }) is 6
PASS toObject([1,2,3]).reduce(function(a,b){ return a + b; }) is 6
PASS toObject([0,1,2,3]).reduce(function(a,b){ return a + b; }, 4) is 10
PASS toObject([1,2,3]).reduce(function(a,b){ return a + b; }, 4) is 10
PASS toUnorderedObject([0,1,2,3]).reduce(function(a,b){ return a + b; }) is 6
PASS toUnorderedObject([1,2,3]).reduce(function(a,b){ return a + b; }) is 6
PASS toUnorderedObject([0,1,2,3]).reduce(function(a,b){ return a + b; }, 4) is 10
PASS toUnorderedObject([1,2,3]).reduce(function(a,b){ return a + b; }, 4) is 10
PASS sparseArray.reduce(function(a,b){ return a + b; }, 0) is 10
PASS toObject(sparseArray).reduce(function(a,b){ return a + b; }, 0) is 10
PASS sparseArray.reduce(function(a,b){ callCount++; }); callCount is 0
PASS toObject(sparseArray).reduce(function(a,b){ callCount++; }); callCount is 0
PASS sparseArray.reduce(function(a,b){ callCount++; }, 0); callCount is 1
PASS toObject(sparseArray).reduce(function(a,b){ callCount++; }, 0); callCount is 1
PASS [0,1,2,3,4].reduce(function(a,b){ callCount++; }, 0); callCount is 5
PASS [0,1,2,3,4].reduce(function(a,b){ callCount++; }); callCount is 4
PASS [1, 2, 3, 4].reduce(function(a,b, i, thisObj){ thisObj.length--; callCount++; return a + b; }, 0); callCount is 2
PASS [1, 2, 3, 4].reduce(function(a,b, i, thisObj){ thisObj.length++; callCount++; return a + b; }, 0); callCount is 4
PASS toObject([1, 2, 3, 4]).reduce(function(a,b, i, thisObj){ thisObj.length--; callCount++; return a + b; }, 0); callCount is 4
PASS toObject([1, 2, 3, 4]).reduce(function(a,b, i, thisObj){ thisObj.length++; callCount++; return a + b; }, 0); callCount is 4
PASS [[0,1], [2,3], [4,5]].reduce(function(a,b) {return a.concat(b);}, []) is [0,1,2,3,4,5]
PASS toObject([[0,1], [2,3], [4,5]]).reduce(function(a,b) {return a.concat(b);}, []) is [0,1,2,3,4,5]
PASS toObject([0,1,2,3,4,5]).reduce(function(a,b,i) {return a.concat([i,b]);}, []) is [0,0,1,1,2,2,3,3,4,4,5,5]
PASS toUnorderedObject([[0,1], [2,3], [4,5]]).reduce(function(a,b) {return a.concat(b);}, []) is [0,1,2,3,4,5]
PASS toUnorderedObject([0,1,2,3,4,5]).reduce(function(a,b,i) {return a.concat([i,b]);}, []) is [0,0,1,1,2,2,3,3,4,4,5,5]
PASS [0,1,2,3,4,5].reduce(function(a,b,i) {return a.concat([i,b]);}, []) is [0,0,1,1,2,2,3,3,4,4,5,5]
PASS [2,3].reduce(function() {'use strict'; return this;}) is undefined
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/webkit/array-reduce.js                                                     0000664 0000000 0000000 00000011741 14746647661 0021236 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(
"This test checks the behavior of the reduce() method on a number of objects."
);

function toObject(array) {
    var o = {};
    for (var i in array)
        o[i] = array[i];
    o.length = array.length;
    o.reduce = Array.prototype.reduce;
    return o;
}
function toUnorderedObject(array) {
    var o = {};
    var props = [];
    for (var i in array)
        props.push(i);
    for (var i = props.length - 1; i >= 0; i--)
        o[props[i]] = array[props[i]];
    o.length = array.length;
    o.reduce = Array.prototype.reduce;
    return o;
}

shouldBe("[0,1,2,3].reduce(function(a,b){ return a + b; })", "6");
shouldBe("[1,2,3].reduce(function(a,b){ return a + b; })", "6");
shouldBe("[0,1,2,3].reduce(function(a,b){ return a + b; }, 4)", "10");
shouldBe("[1,2,3].reduce(function(a,b){ return a + b; }, 4)", "10");
shouldBe("toObject([0,1,2,3]).reduce(function(a,b){ return a + b; })", "6");
shouldBe("toObject([1,2,3]).reduce(function(a,b){ return a + b; })", "6");
shouldBe("toObject([0,1,2,3]).reduce(function(a,b){ return a + b; }, 4)", "10");
shouldBe("toObject([1,2,3]).reduce(function(a,b){ return a + b; }, 4)", "10");
shouldBe("toUnorderedObject([0,1,2,3]).reduce(function(a,b){ return a + b; })", "6");
shouldBe("toUnorderedObject([1,2,3]).reduce(function(a,b){ return a + b; })", "6");
shouldBe("toUnorderedObject([0,1,2,3]).reduce(function(a,b){ return a + b; }, 4)", "10");
shouldBe("toUnorderedObject([1,2,3]).reduce(function(a,b){ return a + b; }, 4)", "10");
sparseArray = [];
sparseArray[10] = 10;
shouldBe("sparseArray.reduce(function(a,b){ return a + b; }, 0)", "10");
shouldBe("toObject(sparseArray).reduce(function(a,b){ return a + b; }, 0)", "10");
var callCount = 0;
shouldBe("sparseArray.reduce(function(a,b){ callCount++; }); callCount", "0");
callCount = 0;
shouldBe("toObject(sparseArray).reduce(function(a,b){ callCount++; }); callCount", "0");
var callCount = 0;
shouldBe("sparseArray.reduce(function(a,b){ callCount++; }, 0); callCount", "1");
callCount = 0;
shouldBe("toObject(sparseArray).reduce(function(a,b){ callCount++; }, 0); callCount", "1");
callCount = 0;
shouldBe("[0,1,2,3,4].reduce(function(a,b){ callCount++; }, 0); callCount", "5");
callCount = 0;
shouldBe("[0,1,2,3,4].reduce(function(a,b){ callCount++; }); callCount", "4");
callCount = 0;
shouldBe("[1, 2, 3, 4].reduce(function(a,b, i, thisObj){ thisObj.length--; callCount++; return a + b; }, 0); callCount", "2");
callCount = 0;
shouldBe("[1, 2, 3, 4].reduce(function(a,b, i, thisObj){ thisObj.length++; callCount++; return a + b; }, 0); callCount", "4");
callCount = 0;
shouldBe("toObject([1, 2, 3, 4]).reduce(function(a,b, i, thisObj){ thisObj.length--; callCount++; return a + b; }, 0); callCount", "4");
callCount = 0;
shouldBe("toObject([1, 2, 3, 4]).reduce(function(a,b, i, thisObj){ thisObj.length++; callCount++; return a + b; }, 0); callCount", "4");

shouldBe("[[0,1], [2,3], [4,5]].reduce(function(a,b) {return a.concat(b);}, [])", "[0,1,2,3,4,5]");
shouldBe("toObject([[0,1], [2,3], [4,5]]).reduce(function(a,b) {return a.concat(b);}, [])", "[0,1,2,3,4,5]");
shouldBe("toObject([0,1,2,3,4,5]).reduce(function(a,b,i) {return a.concat([i,b]);}, [])", "[0,0,1,1,2,2,3,3,4,4,5,5]");
shouldBe("toUnorderedObject([[0,1], [2,3], [4,5]]).reduce(function(a,b) {return a.concat(b);}, [])", "[0,1,2,3,4,5]");
shouldBe("toUnorderedObject([0,1,2,3,4,5]).reduce(function(a,b,i) {return a.concat([i,b]);}, [])", "[0,0,1,1,2,2,3,3,4,4,5,5]");
shouldBe("[0,1,2,3,4,5].reduce(function(a,b,i) {return a.concat([i,b]);}, [])", "[0,0,1,1,2,2,3,3,4,4,5,5]");
shouldBe("[2,3].reduce(function() {'use strict'; return this;})", "undefined");
                               node-23.7.0/deps/v8/test/webkit/array-reduceRight-expected.txt                                      0000664 0000000 0000000 00000010710 14746647661 0024231 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This test checks the behavior of the reduceRight() method on a number of objects.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS [0,1,2,3].reduceRight(function(a,b){ return a + b; }) is 6
PASS [1,2,3].reduceRight(function(a,b){ return a + b; }) is 6
PASS [0,1,2,3].reduceRight(function(a,b){ return a + b; }, 4) is 10
PASS [1,2,3].reduceRight(function(a,b){ return a + b; }, 4) is 10
PASS toObject([0,1,2,3]).reduceRight(function(a,b){ return a + b; }) is 6
PASS toObject([1,2,3]).reduceRight(function(a,b){ return a + b; }) is 6
PASS toObject([0,1,2,3]).reduceRight(function(a,b){ return a + b; }, 4) is 10
PASS toObject([1,2,3]).reduceRight(function(a,b){ return a + b; }, 4) is 10
PASS toUnorderedObject([0,1,2,3]).reduceRight(function(a,b){ return a + b; }) is 6
PASS toUnorderedObject([1,2,3]).reduceRight(function(a,b){ return a + b; }) is 6
PASS toUnorderedObject([0,1,2,3]).reduceRight(function(a,b){ return a + b; }, 4) is 10
PASS toUnorderedObject([1,2,3]).reduceRight(function(a,b){ return a + b; }, 4) is 10
PASS sparseArray.reduceRight(function(a,b){ return a + b; }, 0) is 10
PASS toObject(sparseArray).reduceRight(function(a,b){ return a + b; }, 0) is 10
PASS sparseArray.reduceRight(function(a,b){ callCount++; }); callCount is 0
PASS toObject(sparseArray).reduceRight(function(a,b){ callCount++; }); callCount is 0
PASS sparseArray.reduceRight(function(a,b){ callCount++; }, 0); callCount is 1
PASS toObject(sparseArray).reduceRight(function(a,b){ callCount++; }, 0); callCount is 1
PASS [0,1,2,3,4].reduceRight(function(a,b){ callCount++; }, 0); callCount is 5
PASS [0,1,2,3,4].reduceRight(function(a,b){ callCount++; }); callCount is 4
PASS [1, 2, 3, 4].reduceRight(function(a,b, i, thisObj){ thisObj.length--; callCount++; return a + b; }, 0); callCount is 4
PASS [1, 2, 3, 4].reduceRight(function(a,b, i, thisObj){ thisObj.length = 1; callCount++; return a + b; }, 0); callCount is 2
PASS [1, 2, 3, 4].reduceRight(function(a,b, i, thisObj){ thisObj.length++; callCount++; return a + b; }, 0); callCount is 4
PASS toObject([1, 2, 3, 4]).reduceRight(function(a,b, i, thisObj){ thisObj.length--; callCount++; return a + b; }, 0); callCount is 4
PASS toObject([1, 2, 3, 4]).reduceRight(function(a,b, i, thisObj){ thisObj.length++; callCount++; return a + b; }, 0); callCount is 4
PASS [[0,1], [2,3], [4,5]].reduceRight(function(a,b) {return a.concat(b);}, []) is [4,5,2,3,0,1]
PASS toObject([[0,1], [2,3], [4,5]]).reduceRight(function(a,b) {return a.concat(b);}, []) is [4,5,2,3,0,1]
PASS toObject([0,1,2,3,4,5]).reduceRight(function(a,b,i) {return a.concat([i,b]);}, []) is [5,5,4,4,3,3,2,2,1,1,0,0]
PASS toUnorderedObject([[0,1], [2,3], [4,5]]).reduceRight(function(a,b) {return a.concat(b);}, []) is [4,5,2,3,0,1]
PASS toUnorderedObject([0,1,2,3,4,5]).reduceRight(function(a,b,i) {return a.concat([i,b]);}, []) is [5,5,4,4,3,3,2,2,1,1,0,0]
PASS [0,1,2,3,4,5].reduceRight(function(a,b,i) {return a.concat([i,b]);}, []) is [5,5,4,4,3,3,2,2,1,1,0,0]
PASS [2,3].reduceRight(function() {'use strict'; return this;}) is undefined
PASS successfullyParsed is true

TEST COMPLETE

                                                        node-23.7.0/deps/v8/test/webkit/array-reduceRight.js                                                0000664 0000000 0000000 00000012452 14746647661 0022234 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(
"This test checks the behavior of the reduceRight() method on a number of objects."
);

function toObject(array) {
    var o = {};
    for (var i in array)
        o[i] = array[i];
    o.length = array.length;
    o.reduceRight = Array.prototype.reduceRight;
    return o;
}
function toUnorderedObject(array) {
    var o = {};
    var props = [];
    for (var i in array)
        props.push(i);
    for (var i = props.length - 1; i >= 0; i--)
        o[props[i]] = array[props[i]];
    o.length = array.length;
    o.reduceRight = Array.prototype.reduceRight;
    return o;
}

shouldBe("[0,1,2,3].reduceRight(function(a,b){ return a + b; })", "6");
shouldBe("[1,2,3].reduceRight(function(a,b){ return a + b; })", "6");
shouldBe("[0,1,2,3].reduceRight(function(a,b){ return a + b; }, 4)", "10");
shouldBe("[1,2,3].reduceRight(function(a,b){ return a + b; }, 4)", "10");
shouldBe("toObject([0,1,2,3]).reduceRight(function(a,b){ return a + b; })", "6");
shouldBe("toObject([1,2,3]).reduceRight(function(a,b){ return a + b; })", "6");
shouldBe("toObject([0,1,2,3]).reduceRight(function(a,b){ return a + b; }, 4)", "10");
shouldBe("toObject([1,2,3]).reduceRight(function(a,b){ return a + b; }, 4)", "10");
shouldBe("toUnorderedObject([0,1,2,3]).reduceRight(function(a,b){ return a + b; })", "6");
shouldBe("toUnorderedObject([1,2,3]).reduceRight(function(a,b){ return a + b; })", "6");
shouldBe("toUnorderedObject([0,1,2,3]).reduceRight(function(a,b){ return a + b; }, 4)", "10");
shouldBe("toUnorderedObject([1,2,3]).reduceRight(function(a,b){ return a + b; }, 4)", "10");
sparseArray = [];
sparseArray[10] = 10;
shouldBe("sparseArray.reduceRight(function(a,b){ return a + b; }, 0)", "10");
shouldBe("toObject(sparseArray).reduceRight(function(a,b){ return a + b; }, 0)", "10");
var callCount = 0;
shouldBe("sparseArray.reduceRight(function(a,b){ callCount++; }); callCount", "0");
callCount = 0;
shouldBe("toObject(sparseArray).reduceRight(function(a,b){ callCount++; }); callCount", "0");
var callCount = 0;
shouldBe("sparseArray.reduceRight(function(a,b){ callCount++; }, 0); callCount", "1");
callCount = 0;
shouldBe("toObject(sparseArray).reduceRight(function(a,b){ callCount++; }, 0); callCount", "1");
callCount = 0;
shouldBe("[0,1,2,3,4].reduceRight(function(a,b){ callCount++; }, 0); callCount", "5");
callCount = 0;
shouldBe("[0,1,2,3,4].reduceRight(function(a,b){ callCount++; }); callCount", "4");
callCount = 0;
shouldBe("[1, 2, 3, 4].reduceRight(function(a,b, i, thisObj){ thisObj.length--; callCount++; return a + b; }, 0); callCount", "4");
callCount = 0;
shouldBe("[1, 2, 3, 4].reduceRight(function(a,b, i, thisObj){ thisObj.length = 1; callCount++; return a + b; }, 0); callCount", "2");
callCount = 0;
shouldBe("[1, 2, 3, 4].reduceRight(function(a,b, i, thisObj){ thisObj.length++; callCount++; return a + b; }, 0); callCount", "4");
callCount = 0;
shouldBe("toObject([1, 2, 3, 4]).reduceRight(function(a,b, i, thisObj){ thisObj.length--; callCount++; return a + b; }, 0); callCount", "4");
callCount = 0;
shouldBe("toObject([1, 2, 3, 4]).reduceRight(function(a,b, i, thisObj){ thisObj.length++; callCount++; return a + b; }, 0); callCount", "4");

shouldBe("[[0,1], [2,3], [4,5]].reduceRight(function(a,b) {return a.concat(b);}, [])", "[4,5,2,3,0,1]");
shouldBe("toObject([[0,1], [2,3], [4,5]]).reduceRight(function(a,b) {return a.concat(b);}, [])", "[4,5,2,3,0,1]");
shouldBe("toObject([0,1,2,3,4,5]).reduceRight(function(a,b,i) {return a.concat([i,b]);}, [])", "[5,5,4,4,3,3,2,2,1,1,0,0]");
shouldBe("toUnorderedObject([[0,1], [2,3], [4,5]]).reduceRight(function(a,b) {return a.concat(b);}, [])", "[4,5,2,3,0,1]");
shouldBe("toUnorderedObject([0,1,2,3,4,5]).reduceRight(function(a,b,i) {return a.concat([i,b]);}, [])", "[5,5,4,4,3,3,2,2,1,1,0,0]");
shouldBe("[0,1,2,3,4,5].reduceRight(function(a,b,i) {return a.concat([i,b]);}, [])", "[5,5,4,4,3,3,2,2,1,1,0,0]");
shouldBe("[2,3].reduceRight(function() {'use strict'; return this;})", "undefined");
                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/webkit/array-reset-large-index-expected.txt                                0000664 0000000 0000000 00000003240 14746647661 0025303 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This test puts an item in a big index and then tries to change it. It should change successfully.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS array[10001] is 5
PASS array[10002] is "b"
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/webkit/array-reset-large-index.js                                          0000664 0000000 0000000 00000003260 14746647661 0023303 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(
"This test puts an item in a big index and then tries to change it. It should change successfully."
);

var array = [];
array[10001] = 0;
array[10001] = 5;
array[10002] = "a";
array[10002] = "b";

shouldBe('array[10001]', '5');
shouldBe('array[10002]', '"b"');
                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/webkit/array-sort-numericCompare-expected.txt                              0000664 0000000 0000000 00000003425 14746647661 0025727 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This tests that a call to array.sort(compareFunction) works correctly for numeric comparisons (arg1 - arg2), and also for things that might look like numeric comparisons.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS [3,1,5,2,4].sort(doSort) is [1,2,3,4,5]
PASS [3,1,5,2,4].sort(dontSort) is [3,1,5,2,4]
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/webkit/array-sort-numericCompare.js                                        0000664 0000000 0000000 00000003447 14746647661 0023731 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(
"This tests that a call to array.sort(compareFunction) works correctly for numeric comparisons (arg1 - arg2), and also for things that might look like numeric comparisons."
);

function doSort(x, y)
{
    return x - y;
}

function dontSort(w, x, y)
{
    return x - y;
}

shouldBe("[3,1,5,2,4].sort(doSort)", "[1,2,3,4,5]");
shouldBe("[3,1,5,2,4].sort(dontSort)", "[3,1,5,2,4]");
                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/webkit/array-sort-reentrance-expected.txt                                  0000664 0000000 0000000 00000003173 14746647661 0025104 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This tests that a call to array.sort(compareFunction) does not crash from within a sort comparison function.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/test/webkit/array-sort-reentrance.js                                            0000664 0000000 0000000 00000003402 14746647661 0023075 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(
"This tests that a call to array.sort(compareFunction) does not crash from within a sort comparison function."
);

var numbers1 = [1, 2, 3, 4, 5, 6, 7];
var numbers2 = numbers1.slice();

function compareFn1(a, b) {
    return b - a;
}

function compareFn2(a, b) {
    numbers1.sort(compareFn1);
    return b - a;
}

numbers2.sort(compareFn2);
                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/test/webkit/array-sort-small-sparse-array-with-large-length-expected.txt        0000664 0000000 0000000 00000003257 14746647661 0032020 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Tests that we can quickly sort a small sparse array that has a large length.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


array[0] = 42
PASS result is "42"
PASS array.length is 10000001
PASS array[0] is 42
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/webkit/array-sort-small-sparse-array-with-large-length.js                  0000664 0000000 0000000 00000003450 14746647661 0030011 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(
"Tests that we can quickly sort a small sparse array that has a large length."
);

var array = [];
array[10000000] = 42;
array.sort();
var result = "";
for (var s in array) {
    debug("array[" + s + "] = " + array[s]);
    if (result)
        result += ",";
    result += array[s];
}
shouldBe("result", "\"42\"");
shouldBe("array.length", "10000001");
shouldBe("array[0]", "42");
                                                                                                                                                                                                                        node-23.7.0/deps/v8/test/webkit/array-sort-sparse-expected.txt                                      0000664 0000000 0000000 00000003301 14746647661 0024244 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This tests that arrays and array like objects containing holes are sorted correctly.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS testSort([,undefined,0,1]) is true
PASS testSort({length:4,1:undefined,2:0,3:1}) is true
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/test/webkit/array-sort-sparse.js                                                0000664 0000000 0000000 00000003346 14746647661 0022253 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(
"This tests that arrays and array like objects containing holes are sorted correctly."
);

function testSort(x)
{
    [].sort.call(x)
    return x[0] < x[1] && x[2] === undefined && !(3 in x) && x.length == 4;
}

shouldBeTrue("testSort([,undefined,0,1])");
shouldBeTrue("testSort({length:4,1:undefined,2:0,3:1})");
                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/test/webkit/array-splice-expected.txt                                           0000664 0000000 0000000 00000004203 14746647661 0023243 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This tests array.splice behavior.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS arr is ['a','b','c','d']
PASS arr.splice(2) is ['c','d']
PASS arr is ['a','b']
PASS arr.splice(0) is ['a','b']
PASS arr is []
PASS arr.splice() is []
PASS arr is ['a','b','c','d']
PASS arr.splice(undefined) is ['a','b','c','d']
PASS arr is []
PASS arr.splice(null) is ['a','b','c','d']
PASS arr is []
PASS arr.splice(100) is []
PASS arr is ['a','b','c','d']
PASS arr.splice(-1) is ['d']
PASS arr is ['a','b','c']
PASS arr.splice(2, undefined) is []
PASS arr.splice(2, null) is []
PASS arr.splice(2, -1) is []
PASS arr is ['a','b','c']
PASS arr.splice(2, 100) is ['c']
PASS arr is ['a','b']
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/webkit/array-splice.js                                                     0000664 0000000 0000000 00000004460 14746647661 0021246 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(
"This tests array.splice behavior."
);

var arr = ['a','b','c','d'];
shouldBe("arr", "['a','b','c','d']");
shouldBe("arr.splice(2)", "['c','d']");
shouldBe("arr", "['a','b']");
shouldBe("arr.splice(0)", "['a','b']");
shouldBe("arr", "[]")

arr = ['a','b','c','d'];
shouldBe("arr.splice()", "[]")
shouldBe("arr", "['a','b','c','d']");
shouldBe("arr.splice(undefined)", "['a','b','c','d']")
shouldBe("arr", "[]");

arr = ['a','b','c','d'];
shouldBe("arr.splice(null)", "['a','b','c','d']")
shouldBe("arr", "[]");

arr = ['a','b','c','d'];
shouldBe("arr.splice(100)", "[]")
shouldBe("arr", "['a','b','c','d']");
shouldBe("arr.splice(-1)", "['d']")
shouldBe("arr", "['a','b','c']");

shouldBe("arr.splice(2, undefined)", "[]")
shouldBe("arr.splice(2, null)", "[]")
shouldBe("arr.splice(2, -1)", "[]")
shouldBe("arr", "['a','b','c']");
shouldBe("arr.splice(2, 100)", "['c']")
shouldBe("arr", "['a','b']");
                                                                                                                                                                                                                node-23.7.0/deps/v8/test/webkit/array-tostring-and-join-expected.txt                                0000664 0000000 0000000 00000003200 14746647661 0025326 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This test checks that toString and join share the same HashSet for visited elements.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS arr.join() is '1,2,,**'
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/webkit/array-tostring-and-join.js                                          0000664 0000000 0000000 00000003252 14746647661 0023333 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(

"This test checks that toString and join share the same HashSet for visited elements."

);

var arr = [1, 2];
var obj = {};
obj.__proto__.toString = function() { return "*" + arr + "*"; }
arr[2] = arr;
arr[3] = obj;

shouldBe("arr.join()", "'1,2,,**'");
                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/webkit/array-type-speculation-expected.txt                                 0000664 0000000 0000000 00000003707 14746647661 0025301 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This tests that storing into something that is not array does not crash.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS result is "foo"
PASS result is "foo"
PASS result is undefined
PASS result is undefined
PASS result is undefined
PASS result is "foo"
PASS result is undefined
PASS result is "foo"
PASS result is "foo"
PASS result is undefined
PASS result is "foo"
PASS result is undefined
PASS result is undefined
PASS result is undefined
PASS result is "foo"
PASS result is "foo"
PASS successfullyParsed is true

TEST COMPLETE

                                                         node-23.7.0/deps/v8/test/webkit/array-type-speculation.js                                           0000664 0000000 0000000 00000005574 14746647661 0023303 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(
"This tests that storing into something that is not array does not crash."
);

theCode = "\n\
function storeFooByValOrDoArithmetic(o, p1, p2, v) {\n\
    var x;\n\
    if (p1) {\n\
        x = o.foo;\n\
    } else {\n\
        x = v;\n\
        if (p2) {\n\
            x--;\n\
        } else {\n\
            x++;\n\
        }\n\
    }\n\
    x[5] = \"foo\";\n\
}\n\
\n\
function runTheTest(p1, p2) {\n\
    var o = new Object();\n\
    o.foo = new Object();\n\
    storeFooByValOrDoArithmetic(o, p1, p2, 1);\n\
    return o.foo[5];\n\
}\n";

function runWithPredicates(predicateArray) {
    var myCode = theCode;

    for (var i = 0; i < predicateArray.length; ++i) {
        myCode += "result = runTheTest(" + predicateArray[i][0] + ", " + predicateArray[i][1] + ");\n";
        myCode += "shouldBe(\"result\", " + predicateArray[i][2] + ");\n";
    }

    eval(myCode);
}

runWithPredicates([[true, true, "\"\\\"foo\\\"\""], [true, false, "\"\\\"foo\\\"\""], [false, true, "\"undefined\""], [false, false, "\"undefined\""]]);
runWithPredicates([[false, false, "\"undefined\""], [true, false, "\"\\\"foo\\\"\""], [false, true, "\"undefined\""], [true, true, "\"\\\"foo\\\"\""]]);
runWithPredicates([[true, true, "\"\\\"foo\\\"\""], [false, true, "\"undefined\""], [true, false, "\"\\\"foo\\\"\""], [false, false, "\"undefined\""]]);
runWithPredicates([[false, false, "\"undefined\""], [false, true, "\"undefined\""], [true, false, "\"\\\"foo\\\"\""], [true, true, "\"\\\"foo\\\"\""]]);
                                                                                                                                    node-23.7.0/deps/v8/test/webkit/avl-crash-expected.txt                                              0000664 0000000 0000000 00000003143 14746647661 0022532 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This test checks for a crash in sort() that was seen on a particular input data set.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/test/webkit/avl-crash.js                                                        0000664 0000000 0000000 00000006011 14746647661 0020525 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(
"This test checks for a crash in sort() that was seen on a particular input data set."
);

function natcompare(a, b) {
    if (a == b)
        return 0;
    return (a < b) ? -1 : 1;
}

SubwayData = [
"23rd St-Broadway ",
"45 Road-Court Sq",
"LIC-Court Sq",
"LIC-Court Sq",
"23rd St-Park Ave S",
"241st St",
"242nd St",
"25th Ave",
"25th St",
"28th St-7th Ave",
"28th St-Broadway",
"28th St-Park Ave S",
"2nd Ave-Houston St",
"30th Ave",
"33rd St",
"33rd St-Park Ave",
"34th St-6th Ave",
"34th St-7th Ave",
"34th St-8th Ave",
"36th Ave",
"36th St",
"36th St",
"39th Ave",
"3rd Ave-138th St",
"3rd Ave-149th St",
"3rd Ave-14th St",
"40th St",
"42nd St-5th Ave-6th Ave",
"42nd St-5th Ave-6th Ave",
"45th St",
"46th St",
"46th St",
"47-50th Sts-Rockefeller Center",
"49th St-7th Ave",
"50th St-New Utrecht Ave",
"9th Ave",
"90th St-Elmhurst Ave",
"96th St",
"96th St",
"96th St",
"9th St-4th Ave",
"Alabama Ave",
"Allerton Ave",
"Aqueduct-North Conduit Ave",
"Astor Place",
"Astoria Blvd",
"Atlantic Ave",
"Atlantic Ave-Pacific St",
"Ave H",
"Ave N",
"Ave P",
"Ave U",
"Ave U",
"Ave U",
"Ave X",
"Bay Pkwy",
"Bay Pkwy",
"Bay Pkwy-22nd Ave",
"Bay Ridge Ave",
"Baychester Ave",
"Beach 105th St",
"Beach 25th St",
"Beach 36th St",
"Beach 44th St",
"Beach 60th St",
"Beach 67th St",
"Beach 90th St",
"Beach 98th St",
"Bedford Ave",
"Bedford Park Blvd",
"Broadway",
"Broadway",
"Bronx Park East",
"Brook Ave",
"Buhre Ave",
"Burke Ave",
"Burnside Ave",
"Bushwick Ave",
"Uptown Bleecker St-Lafayette St",
"Downtown Bleecker St-Lafayette St",
"Canal Street",
"Canal Street",
"Canal Street",
"Canal-Church Sts"
];

SubwayData.sort(natcompare)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/test/webkit/bitops-type-tag-expected.txt                                        0000664 0000000 0000000 00000003414 14746647661 0023703 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Ensure various bit operators correctly tag the final result value

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS aDouble>>27 is 0
PASS aDouble>>27|0 is 0
PASS aDouble>>0 is 100000000
PASS aDouble>>0|0 is 100000000
PASS aDouble|0 is 100000000
PASS (function(x){ return 2147483648>>>x; })(31) is 1
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/test/webkit/bitops-type-tag.js                                                  0000664 0000000 0000000 00000003365 14746647661 0021706 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description("Ensure various bit operators correctly tag the final result value");

aDouble = 100000000.5;
shouldBe("aDouble>>27", "0");
shouldBe("aDouble>>27|0", "0");
shouldBe("aDouble>>0", "100000000");
shouldBe("aDouble>>0|0", "100000000");
shouldBe("aDouble|0", "100000000");

shouldBe("(function(x){ return 2147483648>>>x; })(31)", "1");
                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/test/webkit/boolean-argument-prediction-expected.txt                            0000664 0000000 0000000 00000004335 14746647661 0026253 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This tests that arguments predicted to be boolean are checked.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS predictBooleanArgument(true) is "yes"
PASS predictBooleanArgument(false) is "no"
PASS predictBooleanArgument(true) is "yes"
PASS predictBooleanArgument(false) is "no"
PASS predictBooleanArgument(0) is "no"
PASS predictBooleanArgument(1) is "yes"
PASS predictBooleanArgument(2) is "yes"
PASS predictBooleanArgument(3) is "yes"
PASS predictBooleanArgument(4) is "yes"
PASS predictBooleanArgument(true) is "yes"
PASS predictBooleanArgument(false) is "no"
PASS predictBooleanArgument(0) is "no"
PASS predictBooleanArgument(1) is "yes"
PASS predictBooleanArgument(2) is "yes"
PASS predictBooleanArgument(3) is "yes"
PASS predictBooleanArgument(4) is "yes"
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/test/webkit/boolean-argument-prediction.js                                      0000664 0000000 0000000 00000005277 14746647661 0024257 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(
"This tests that arguments predicted to be boolean are checked."
);

function predictBooleanArgument(b) {
    if (b) {
        return "yes";
    } else {
        return "no";
    }
}

shouldBe("predictBooleanArgument(true)", "\"yes\"");
shouldBe("predictBooleanArgument(false)", "\"no\"");

for (var i = 0; i < 1000; ++i) {
    predictBooleanArgument(true);
    predictBooleanArgument(false);
}

shouldBe("predictBooleanArgument(true)", "\"yes\"");
shouldBe("predictBooleanArgument(false)", "\"no\"");

shouldBe("predictBooleanArgument(0)", "\"no\"");
shouldBe("predictBooleanArgument(1)", "\"yes\"");
shouldBe("predictBooleanArgument(2)", "\"yes\"");
shouldBe("predictBooleanArgument(3)", "\"yes\"");
shouldBe("predictBooleanArgument(4)", "\"yes\"");

for (var i = 0; i < 1000; ++i) {
    predictBooleanArgument(0);
    predictBooleanArgument(1);
    predictBooleanArgument(2);
    predictBooleanArgument(3);
    predictBooleanArgument(4);
}

shouldBe("predictBooleanArgument(true)", "\"yes\"");
shouldBe("predictBooleanArgument(false)", "\"no\"");

shouldBe("predictBooleanArgument(0)", "\"no\"");
shouldBe("predictBooleanArgument(1)", "\"yes\"");
shouldBe("predictBooleanArgument(2)", "\"yes\"");
shouldBe("predictBooleanArgument(3)", "\"yes\"");
shouldBe("predictBooleanArgument(4)", "\"yes\"");
                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/test/webkit/boxed-double-to-int-expected.txt                                    0000664 0000000 0000000 00000003436 14746647661 0024440 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This tests that converting a boxed double to an integer does not crash the register allocator.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS boxedDoubleToInt(1, 2) is 3.5
PASS boxedDoubleToInt(3, 4) is 4.5
PASS boxedDoubleToInt(5, 6) is 7.5
PASS boxedDoubleToInt(7, 8) is 8.5
PASS boxedDoubleToInt(9, 10) is 11.5
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                                  node-23.7.0/deps/v8/test/webkit/boxed-double-to-int.js                                              0000664 0000000 0000000 00000003514 14746647661 0022433 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(
"This tests that converting a boxed double to an integer does not crash the register allocator."
);

function boxedDoubleToInt(x, y) {
    var y = x / 2;
    var z = y + 2;
    return (y | 1) + z;
}

shouldBe("boxedDoubleToInt(1, 2)", "3.5");
shouldBe("boxedDoubleToInt(3, 4)", "4.5");
shouldBe("boxedDoubleToInt(5, 6)", "7.5");
shouldBe("boxedDoubleToInt(7, 8)", "8.5");
shouldBe("boxedDoubleToInt(9, 10)", "11.5");
                                                                                                                                                                                    node-23.7.0/deps/v8/test/webkit/break-ASI-expected.txt                                              0000664 0000000 0000000 00000003662 14746647661 0022356 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Test to make sure we don't incorrectly insert a semi colon after a break statement

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS do { if(0) break
;else true; } while (0) is true
PASS do { if(0) continue
;else true; } while (0) is true
PASS (function(){if (0) return
;else return true;})() is true
PASS do { if(0) throw 'x';else true; } while (0) is true
PASS if (0) throw
'Shouldn't have parsed this.'; threw exception SyntaxError: Illegal newline after throw.
PASS successfullyParsed is true

TEST COMPLETE

                                                                              node-23.7.0/deps/v8/test/webkit/break-ASI.js                                                        0000664 0000000 0000000 00000003464 14746647661 0020354 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description("Test to make sure we don't incorrectly insert a semi colon after a break statement");

shouldBeTrue("do { if(0) break\n;else true; } while (0)")
shouldBeTrue("do { if(0) continue\n;else true; } while (0)")
shouldBeTrue("(function(){if (0) return\n;else return true;})()")
shouldBeTrue("do { if(0) throw 'x';else true; } while (0)")
shouldThrow("if (0) throw\n'Shouldn\'t have parsed this.';")
                                                                                                                                                                                                            node-23.7.0/deps/v8/test/webkit/cached-call-uninitialized-arguments-expected.txt                    0000664 0000000 0000000 00000003300 14746647661 0027636 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This test checks that uninitialized parameters for cached call functions correctly defaults to undefined.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS arg4 is undefined.
PASS arg5 is undefined.
PASS arg6 is undefined.
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/test/webkit/cached-call-uninitialized-arguments.js                              0000664 0000000 0000000 00000004776 14746647661 0025656 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(
"This test checks that uninitialized parameters for cached call functions correctly defaults to undefined."

);

function doForEach(arr) {
    function callback(element, index, array, arg4, arg5, arg6) {

        function shouldBeUndefined(_a) {
            var exception;
            var _av;
            try {
                _av = eval(_a);
            } catch (e) {
                exception = e;
            }

            if (exception)
                testFailed(_a + " should be undefined. Threw exception " + exception);
            else if (typeof _av == "undefined")
                testPassed(_a + " is undefined.");
            else
                testFailed(_a + " should be undefined. Was " + _av);
        }

        shouldBeUndefined("arg4");
        shouldBeUndefined("arg5");
        shouldBeUndefined("arg6");
    }

    arr.forEach(callback);
}

function callAfterRecursingForDepth(depth, func, arr) {
    if (depth > 0) {
        callAfterRecursingForDepth(depth - 1, func, arr);
    } else {
        func(arr);
    }
}

var arr = [1];
callAfterRecursingForDepth(20, doForEach, arr);
  node-23.7.0/deps/v8/test/webkit/call-apply-crash-expected.txt                                       0000664 0000000 0000000 00000003227 14746647661 0024011 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Test to ensure that the registerfile is grown correctly when calling apply

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS Did not crash using apply
PASS Did not crash using apply
PASS successfullyParsed is true

TEST COMPLETE

                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/test/webkit/call-apply-crash.js                                                 0000664 0000000 0000000 00000003527 14746647661 0022012 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description("Test to ensure that the registerfile is grown correctly when calling apply");

function testLog() { testPassed(this); }
(function () {
    Function.prototype.call.apply(testLog, arguments);
})('Did not crash using apply', 0, 0); // needs 3+ arguments
(function () {
    arguments; // reify the arguments object.
    Function.prototype.call.apply(testLog, arguments);
})('Did not crash using apply', 0, 0); // needs 3+ arguments
                                                                                                                                                                         node-23.7.0/deps/v8/test/webkit/char-at-expected.txt                                                0000664 0000000 0000000 00000007650 14746647661 0022200 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2013 the V8 project authors. All rights reserved.
# Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1.  Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
# 2.  Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This is a test of the charAt and charCodeAt string functions.

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


PASS "".charAt() is ""
PASS "".charCodeAt() is NaN
PASS "".charAt(undefined) is ""
PASS "".charCodeAt(undefined) is NaN
PASS "".charAt(0) is ""
PASS "".charCodeAt(0) is NaN
PASS "".charAt(null) is ""
PASS "".charCodeAt(null) is NaN
PASS "".charAt(false) is ""
PASS "".charCodeAt(false) is NaN
PASS "".charAt(true) is ""
PASS "".charCodeAt(true) is NaN
PASS "".charAt(0) is ""
PASS "".charCodeAt(0) is NaN
PASS "".charAt(0.1) is ""
PASS "".charCodeAt(0.1) is NaN
PASS "".charAt(999) is ""
PASS "".charCodeAt(999) is NaN
PASS "".charAt(Infinity) is ""
PASS "".charCodeAt(Infinity) is NaN
PASS "".charAt(-1) is ""
PASS "".charCodeAt(-1) is NaN
PASS "".charAt(-Infinity) is ""
PASS "".charCodeAt(-Infinity) is NaN
PASS "".charAt(NaN) is ""
PASS "".charCodeAt(NaN) is NaN
PASS "x".charAt() is "x"
PASS "x".charCodeAt() is 120
PASS "x".charAt(undefined) is "x"
PASS "x".charCodeAt(undefined) is 120
PASS "x".charAt(0) is "x"
PASS "x".charCodeAt(0) is 120
PASS "x".charAt(null) is "x"
PASS "x".charCodeAt(null) is 120
PASS "x".charAt(false) is "x"
PASS "x".charCodeAt(false) is 120
PASS "x".charAt(true) is ""
PASS "x".charCodeAt(true) is NaN
PASS "x".charAt(0) is "x"
PASS "x".charCodeAt(0) is 120
PASS "x".charAt(0.1) is "x"
PASS "x".charCodeAt(0.1) is 120
PASS "x".charAt(999) is ""
PASS "x".charCodeAt(999) is NaN
PASS "x".charAt(Infinity) is ""
PASS "x".charCodeAt(Infinity) is NaN
PASS "x".charAt(-1) is ""
PASS "x".charCodeAt(-1) is NaN
PASS "x".charAt(-Infinity) is ""
PASS "x".charCodeAt(-Infinity) is NaN
PASS "x".charAt(NaN) is "x"
PASS "x".charCodeAt(NaN) is 120
PASS "xy".charAt() is "x"
PASS "xy".charCodeAt() is 120
PASS "xy".charAt(undefined) is "x"
PASS "xy".charCodeAt(undefined) is 120
PASS "xy".charAt(0) is "x"
PASS "xy".charCodeAt(0) is 120
PASS "xy".charAt(null) is "x"
PASS "xy".charCodeAt(null) is 120
PASS "xy".charAt(false) is "x"
PASS "xy".charCodeAt(false) is 120
PASS "xy".charAt(true) is "y"
PASS "xy".charCodeAt(true) is 121
PASS "xy".charAt(0) is "x"
PASS "xy".charCodeAt(0) is 120
PASS "xy".charAt(0.1) is "x"
PASS "xy".charCodeAt(0.1) is 120
PASS "xy".charAt(999) is ""
PASS "xy".charCodeAt(999) is NaN
PASS "xy".charAt(Infinity) is ""
PASS "xy".charCodeAt(Infinity) is NaN
PASS "xy".charAt(-1) is ""
PASS "xy".charCodeAt(-1) is NaN
PASS "xy".charAt(-Infinity) is ""
PASS "xy".charCodeAt(-Infinity) is NaN
PASS "xy".charAt(NaN) is "x"
PASS "xy".charCodeAt(NaN) is 120
PASS successfullyParsed is true

TEST COMPLETE

                                                                                        node-23.7.0/deps/v8/test/webkit/char-at.js                                                          0000664 0000000 0000000 00000006645 14746647661 0020201 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2013 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description(
'This is a test of the charAt and charCodeAt string functions.'
);

var undefined;

var cases = [
    ["", "omitted"],
    ["", undefined],
    ["", 0],
    ["", null],
    ["", false],
    ["", true],
    ["", 0.0],
    ["", 0.1],
    ["", 999],
    ["", 1/0],
    ["", -1],
    ["", -1/0],
    ["", 0/0],

    ["x", "omitted"],
    ["x", undefined],
    ["x", 0],
    ["x", null],
    ["x", false],
    ["x", true],
    ["x", 0.0],
    ["x", 0.1],
    ["x", 999],
    ["x", 1/0],
    ["x", -1],
    ["x", -1/0],
    ["x", 0/0],

    ["xy", "omitted"],
    ["xy", undefined],
    ["xy", 0],
    ["xy", null],
    ["xy", false],
    ["xy", true],
    ["xy", 0.0],
    ["xy", 0.1],
    ["xy", 999],
    ["xy", 1/0],
    ["xy", -1],
    ["xy", -1/0],
    ["xy", 0/0],
];

var answers = [['""', 'NaN'],
['""', 'NaN'],
['""', 'NaN'],
['""', 'NaN'],
['""', 'NaN'],
['""', 'NaN'],
['""', 'NaN'],
['""', 'NaN'],
['""', 'NaN'],
['""', 'NaN'],
['""', 'NaN'],
['""', 'NaN'],
['""', 'NaN'],
['"x"', '120'],
['"x"', '120'],
['"x"', '120'],
['"x"', '120'],
['"x"', '120'],
['""', 'NaN'],
['"x"', '120'],
['"x"', '120'],
['""', 'NaN'],
['""', 'NaN'],
['""', 'NaN'],
['""', 'NaN'],
['"x"', '120'],
['"x"', '120'],
['"x"', '120'],
['"x"', '120'],
['"x"', '120'],
['"x"', '120'],
['"y"', '121'],
['"x"', '120'],
['"x"', '120'],
['""', 'NaN'],
['""', 'NaN'],
['""', 'NaN'],
['""', 'NaN'],
['"x"', '120']];

for (var i = 0; i < cases.length; ++i)
{
    var item = cases[i];
    var result = answers[i];
    if (item[1] == "omitted") {
        shouldBe('"' + item[0] + '".charAt()', result[0]);
        if (result[1] == 'NaN')
            shouldBeNaN('"' + item[0] + '".charCodeAt()');
        else
            shouldBe('"' + item[0] + '".charCodeAt()', result[1]);
    } else {
        shouldBe('"' + item[0] + '".charAt(' + item[1] + ')', result[0]);
        if (result[1] == 'NaN')
            shouldBeNaN('"' + item[0] + '".charCodeAt(' + item[1] + ')');
        else
            shouldBe('"' + item[0] + '".charCodeAt(' + item[1] + ')', result[1]);
    }
}
                                                                                           node-23.7.0/deps/v8/test/webkit/class-constructor-return-expected.txt                               0000664 0000000 0000000 00000015112 14746647661 0025656 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        Tests for ES6 class constructor return values

On success, you will see a series of "PASS" messages, followed by "TEST COMPLETE".


Base class
PASS (new BaseNoReturn) instanceof BaseNoReturn is true
PASS (new BaseReturnImplicit) instanceof BaseReturnImplicit is true
PASS (new BaseReturnImplicit) !== undefined is true
PASS (new BaseReturnUndefined) instanceof BaseReturnUndefined is true
PASS (new BaseReturnUndefined) !== undefined is true
PASS (new BaseReturnThis) instanceof BaseReturnThis is true
PASS (new BaseReturnObject) instanceof BaseReturnObject is false
PASS typeof (new BaseReturnObject) === "object" is true
PASS (new BaseReturnObject2) instanceof BaseReturnObject is false
PASS (new BaseReturnObject2) === globalVariable is true
PASS (new BaseReturnString) instanceof BaseReturnString is true
PASS typeof (new BaseReturnString) !== "string" is true
PASS (new BaseReturnNumber) instanceof BaseReturnNumber is true
PASS typeof (new BaseReturnNumber) !== "number" is true
PASS (new BaseReturnNull) instanceof BaseReturnNull is true
PASS (new BaseReturnNull) !== null is true
PASS (new BaseReturnSymbol) instanceof BaseReturnSymbol is true
PASS (new BaseReturnSymbol) !== globalSymbol is true
PASS (new BaseThrow) threw exception Thrown Exception String.

Function constructor (non-class)
PASS (new FunctionNoReturn) instanceof FunctionNoReturn is true
PASS (new FunctionReturnImplicit) instanceof FunctionReturnImplicit is true
PASS (new FunctionReturnImplicit) !== undefined is true
PASS (new FunctionReturnUndefined) instanceof FunctionReturnUndefined is true
PASS (new FunctionReturnUndefined) !== undefined is true
PASS (new FunctionReturnThis) instanceof FunctionReturnThis is true
PASS (new FunctionReturnObject) instanceof FunctionReturnObject is false
PASS typeof (new FunctionReturnObject) === "object" is true
PASS (new FunctionReturnObject2) instanceof FunctionReturnObject is false
PASS (new FunctionReturnObject2) === globalVariable is true
PASS (new FunctionReturnString) instanceof FunctionReturnString is true
PASS typeof (new FunctionReturnString) !== "string" is true
PASS (new FunctionReturnNumber) instanceof FunctionReturnNumber is true
PASS typeof (new FunctionReturnNumber) !== "number" is true
PASS (new FunctionReturnNull) instanceof FunctionReturnNull is true
PASS (new FunctionReturnNull) !== null is true
PASS (new FunctionReturnSymbol) instanceof FunctionReturnSymbol is true
PASS (new FunctionReturnSymbol) !== globalSymbol is true
PASS (new FunctionThrow) threw exception Thrown Exception String.

Derived class calling super()
PASS (new DerivedNoReturn) instanceof DerivedNoReturn is true
PASS (new DerivedReturnImplicit) instanceof DerivedReturnImplicit is true
PASS (new DerivedReturnImplicit) !== undefined is true
PASS (new DerivedReturnUndefined) instanceof DerivedReturnUndefined is true
PASS (new DerivedReturnUndefined) !== undefined is true
PASS (new DerivedReturnThis) instanceof DerivedReturnThis is true
PASS (new DerivedReturnObject) instanceof DerivedReturnObject is false
PASS typeof (new DerivedReturnObject) === "object" is true
PASS (new DerivedReturnObject2) instanceof DerivedReturnObject2 is false
PASS (new DerivedReturnObject2) === globalVariable is true
PASS (new DerivedReturnString) threw exception TypeError: Derived constructors may only return object or undefined.
PASS (new DerivedReturnNumber) threw exception TypeError: Derived constructors may only return object or undefined.
PASS (new DerivedReturnNull) threw exception TypeError: Derived constructors may only return object or undefined.
PASS (new DerivedReturnSymbol) threw exception TypeError: Derived constructors may only return object or undefined.
PASS (new DerivedThrow) threw exception Thrown Exception String.

Derived class not calling super()
PASS (new DerivedNoSuperNoReturn) threw exception ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor.
PASS (new DerivedNoSuperReturnImplicit) threw exception ReferenceError: DerivedNoSuperReturnImplicit is not defined.
PASS (new DerivedNoSuperReturnUndefined) threw exception ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor.
PASS (new DerivedNoSuperReturnThis) threw exception ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor.
PASS (new DerivedNoSuperReturnObject) did not throw exception.
PASS (new DerivedNoSuperReturnObject2) did not throw exception.
PASS (new DerivedNoSuperReturnString) threw exception TypeError: Derived constructors may only return object or undefined.
PASS (new DerivedNoSuperReturnNumber) threw exception TypeError: Derived constructors may only return object or undefined.
PASS (new DerivedNoSuperReturnNull) threw exception TypeError: Derived constructors may only return object or undefined.
PASS (new DerivedNoSuperReturnSymbol) threw exception TypeError: Derived constructors may only return object or undefined.
PASS (new DerivedNoSuperThrow) threw exception Thrown Exception String.

Derived class with default constructor and base class returning different values
PASS (new DerivedDefaultConstructorWithBaseNoReturn) instanceof DerivedDefaultConstructorWithBaseNoReturn is true
PASS (new DerivedDefaultConstructorWithBaseReturnImplicit) instanceof DerivedDefaultConstructorWithBaseReturnImplicit is true
PASS (new DerivedDefaultConstructorWithBaseReturnUndefined) instanceof DerivedDefaultConstructorWithBaseReturnUndefined is true
PASS (new DerivedDefaultConstructorWithBaseReturnObject) instanceof DerivedDefaultConstructorWithBaseReturnObject is false
PASS typeof (new DerivedDefaultConstructorWithBaseReturnObject) === "object" is true
PASS (new DerivedDefaultConstructorWithBaseReturnObject2) instanceof DerivedDefaultConstructorWithBaseReturnObject2 is false
PASS (new DerivedDefaultConstructorWithBaseReturnObject2) === globalVariable is true
PASS (new DerivedDefaultConstructorWithBaseReturnThis) instanceof DerivedDefaultConstructorWithBaseReturnThis is true
PASS (new DerivedDefaultConstructorWithBaseReturnString) instanceof DerivedDefaultConstructorWithBaseReturnString is true
PASS (new DerivedDefaultConstructorWithBaseReturnNumber) instanceof DerivedDefaultConstructorWithBaseReturnNumber is true
PASS (new DerivedDefaultConstructorWithBaseReturnNull) instanceof DerivedDefaultConstructorWithBaseReturnNull is true
PASS (new DerivedDefaultConstructorWithBaseReturnSymbol) instanceof DerivedDefaultConstructorWithBaseReturnSymbol is true
PASS (new DerivedDefaultConstructorWithBaseThrow) threw exception Thrown Exception String.
PASS successfullyParsed is true

TEST COMPLETE
                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/test/webkit/class-constructor-return.js                                         0000664 0000000 0000000 00000030551 14746647661 0023660 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Copyright (C) 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1.  Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
// 2.  Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS'' AND ANY
// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
// DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
// ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

description('Tests for ES6 class constructor return values');

// ES6
// - 9.2.2 [[Construct]] (ECMAScript Function Objects)
// - 12.3.5.1 Runtime Semantics: Evaluation (The super Keyword)
// - 14.5.14 Runtime Semantics: ClassDefinitionEvaluation (Default Constructor)

var globalVariable = {name:"globalVariable"};
var globalSymbol = Symbol();

debug('Base class');
class BaseNoReturn { constructor() { } };
class BaseReturnImplicit { constructor() { return; } };
class BaseReturnUndefined { constructor() { return undefined; } };
class BaseReturnThis { constructor() { return this; } };
class BaseReturnObject { constructor() { return {a:1}; } };
class BaseReturnObject2 { constructor() { return globalVariable; } };
class BaseReturnString { constructor() { return "test"; } };
class BaseReturnNumber { constructor() { return 1; } };
class BaseReturnNull { constructor() { return null; } };
class BaseReturnSymbol { constructor() { return Symbol(); } };
class BaseThrow { constructor() { throw "Thrown Exception String"; } };

// Base - Implicit => return this.
shouldBeTrue('(new BaseNoReturn) instanceof BaseNoReturn');

// Base - Early return => return this.
shouldBeTrue('(new BaseReturnImplicit) instanceof BaseReturnImplicit');
shouldBeTrue('(new BaseReturnImplicit) !== undefined');
shouldBeTrue('(new BaseReturnUndefined) instanceof BaseReturnUndefined');
shouldBeTrue('(new BaseReturnUndefined) !== undefined');

// Base - return this => return this.
shouldBeTrue('(new BaseReturnThis) instanceof BaseReturnThis');

// Base - return Object => return object, not instance.
shouldBeFalse('(new BaseReturnObject) instanceof BaseReturnObject');
shouldBeTrue('typeof (new BaseReturnObject) === "object"');
shouldBeFalse('(new BaseReturnObject2) instanceof BaseReturnObject');
shouldBeTrue('(new BaseReturnObject2) === globalVariable');

// Base - return non-Object => return this.
shouldBeTrue('(new BaseReturnString) instanceof BaseReturnString');
shouldBeTrue('typeof (new BaseReturnString) !== "string"');
shouldBeTrue('(new BaseReturnNumber) instanceof BaseReturnNumber');
shouldBeTrue('typeof (new BaseReturnNumber) !== "number"');
shouldBeTrue('(new BaseReturnNull) instanceof BaseReturnNull');
shouldBeTrue('(new BaseReturnNull) !== null');
shouldBeTrue('(new BaseReturnSymbol) instanceof BaseReturnSymbol');
shouldBeTrue('(new BaseReturnSymbol) !== globalSymbol');

// Base - throw => throw
shouldThrow('(new BaseThrow)');

// Same behavior for Functions.
debug(''); debug('Function constructor (non-class)');
function FunctionNoReturn() { };
function FunctionReturnImplicit() { return; };
function FunctionReturnUndefined() { return undefined; };
function FunctionReturnThis() { return this; };
function FunctionReturnObject() { return {a:1}; };
function FunctionReturnObject2() { return globalVariable; };
function FunctionReturnString() { return "test"; };
function FunctionReturnNumber() { return 1; };
function FunctionReturnNull() { return null; };
function FunctionReturnSymbol() { return Symbol(); };
function FunctionThrow() { throw "Thrown Exception String"; };

shouldBeTrue('(new FunctionNoReturn) instanceof FunctionNoReturn');
shouldBeTrue('(new FunctionReturnImplicit) instanceof FunctionReturnImplicit');
shouldBeTrue('(new FunctionReturnImplicit) !== undefined');
shouldBeTrue('(new FunctionReturnUndefined) instanceof FunctionReturnUndefined');
shouldBeTrue('(new FunctionReturnUndefined) !== undefined');
shouldBeTrue('(new FunctionReturnThis) instanceof FunctionReturnThis');
shouldBeFalse('(new FunctionReturnObject) instanceof FunctionReturnObject');
shouldBeTrue('typeof (new FunctionReturnObject) === "object"');
shouldBeFalse('(new FunctionReturnObject2) instanceof FunctionReturnObject');
shouldBeTrue('(new FunctionReturnObject2) === globalVariable');
shouldBeTrue('(new FunctionReturnString) instanceof FunctionReturnString');
shouldBeTrue('typeof (new FunctionReturnString) !== "string"');
shouldBeTrue('(new FunctionReturnNumber) instanceof FunctionReturnNumber');
shouldBeTrue('typeof (new FunctionReturnNumber) !== "number"');
shouldBeTrue('(new FunctionReturnNull) instanceof FunctionReturnNull');
shouldBeTrue('(new FunctionReturnNull) !== null');
shouldBeTrue('(new FunctionReturnSymbol) instanceof FunctionReturnSymbol');
shouldBeTrue('(new FunctionReturnSymbol) !== globalSymbol');
shouldThrow('(new FunctionThrow)');


debug(''); debug('Derived class calling super()');
class DerivedNoReturn extends BaseNoReturn { constructor() { super(); } };
class DerivedReturnImplicit extends BaseNoReturn { constructor() { super(); return; } };
class DerivedReturnUndefined extends BaseNoReturn { constructor() { super(); return undefined; } };
class DerivedReturnThis extends BaseNoReturn { constructor() { super(); return this; } };
class DerivedReturnObject extends BaseNoReturn { constructor() { super(); return {a:1}; } };
class DerivedReturnObject2 extends BaseNoReturn { constructor() { super(); return globalVariable; } };
class DerivedReturnString extends BaseNoReturn { constructor() { super(); return "test"; } };
class DerivedReturnNumber extends BaseNoReturn { constructor() { super(); return 1; } };
class DerivedReturnNull extends BaseNoReturn { constructor() { 