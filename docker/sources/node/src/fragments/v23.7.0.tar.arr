clone. followed by multiple numbers), should also demangle.
  EXPECT_TRUE(Demangle("_ZL3Foov.clone.123.456", tmp, sizeof(tmp)));
  EXPECT_STREQ("Foo()", tmp);
  // (a long valid suffix), should demangle.
  EXPECT_TRUE(Demangle("_ZL3Foov.part.9.165493.constprop.775.31805", tmp,
                       sizeof(tmp)));
  EXPECT_STREQ("Foo()", tmp);
  // Invalid (. without anything else), should not demangle.
  EXPECT_FALSE(Demangle("_ZL3Foov.", tmp, sizeof(tmp)));
  // Invalid (. with mix of alpha and digits), should not demangle.
  EXPECT_FALSE(Demangle("_ZL3Foov.abc123", tmp, sizeof(tmp)));
  // Invalid (.clone. not followed by number), should not demangle.
  EXPECT_FALSE(Demangle("_ZL3Foov.clone.", tmp, sizeof(tmp)));
  // Invalid (.constprop. not followed by number), should not demangle.
  EXPECT_FALSE(Demangle("_ZL3Foov.isra.2.constprop.", tmp, sizeof(tmp)));
}

TEST(Demangle, Discriminators) {
  char tmp[80];

  // Source:
  //
  // using Thunk = void (*)();
  //
  // Thunk* f() {
  //   static Thunk thunks[12] = {};
  //
  // #define THUNK(i) [backslash here]
  //   do { struct S { static void g() {} }; thunks[i] = &S::g; } while (0)
  //
  //   THUNK(0);
  //   [... repeat for 1 to 10 ...]
  //   THUNK(11);
  //
  //   return thunks;
  // }
  //
  // The test inputs are manglings of some of the S::g member functions.

  // The first one omits the discriminator.
  EXPECT_TRUE(Demangle("_ZZ1fvEN1S1gEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f()::S::g()", tmp);

  // The second one encodes 0.
  EXPECT_TRUE(Demangle("_ZZ1fvEN1S1gE_0v", tmp, sizeof(tmp)));
  EXPECT_STREQ("f()::S::g()", tmp);

  // The eleventh one encodes 9.
  EXPECT_TRUE(Demangle("_ZZ1fvEN1S1gE_9v", tmp, sizeof(tmp)));
  EXPECT_STREQ("f()::S::g()", tmp);

  // The twelfth one encodes 10 with extra underscores delimiting it.
  EXPECT_TRUE(Demangle("_ZZ1fvEN1S1gE__10_v", tmp, sizeof(tmp)));
  EXPECT_STREQ("f()::S::g()", tmp);
}

TEST(Demangle, SingleDigitDiscriminatorFollowedByADigit) {
  char tmp[80];

  // Don't parse 911 as a number.
  EXPECT_TRUE(Demangle("_ZZ1fvEN1S1gE_911return_type", tmp, sizeof(tmp)));
  EXPECT_STREQ("f()::S::g()", tmp);
}

TEST(Demangle, LiteralOfGlobalNamespaceEnumType) {
  char tmp[80];

  // void f<(E)42>()
  EXPECT_TRUE(Demangle("_Z1fIL1E42EEvv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, NullptrLiterals) {
  char tmp[80];

  // void f<nullptr>()
  EXPECT_TRUE(Demangle("_Z1fILDnEEvv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);

  // also void f<nullptr>()
  EXPECT_TRUE(Demangle("_Z1fILDn0EEvv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, StringLiterals) {
  char tmp[80];

  // void f<"<char const [42]>">()
  EXPECT_TRUE(Demangle("_Z1fILA42_KcEEvv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, ComplexFloatingPointLiterals) {
  char tmp[80];

  // Source (use g++ -fext-numeric-literals to compile):
  //
  // using C = double _Complex;
  // template <class T> void f(char (&)[sizeof(C{sizeof(T)} + 4.0j)]) {}
  // template void f<int>(char (&)[sizeof(C{sizeof(int)} + 4.0j)]);
  //
  // GNU demangling:
  //
  // void f<int>(char (&) [sizeof (double _Complex{sizeof (int)}+
  // ((double _Complex)0000000000000000_4010000000000000))])
  EXPECT_TRUE(Demangle(
      "_Z1fIiEvRAszpltlCdstT_ELS0_0000000000000000_4010000000000000E_c",
      tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, Float128) {
  char tmp[80];

  // S::operator _Float128() const
  EXPECT_TRUE(Demangle("_ZNK1ScvDF128_Ev", tmp, sizeof(tmp)));
  EXPECT_STREQ("S::operator _Float128()", tmp);
}

TEST(Demangle, Float128x) {
  char tmp[80];

  // S::operator _Float128x() const
  EXPECT_TRUE(Demangle("_ZNK1ScvDF128xEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("S::operator _Float128x()", tmp);
}

TEST(Demangle, Bfloat16) {
  char tmp[80];

  // S::operator std::bfloat16_t() const
  EXPECT_TRUE(Demangle("_ZNK1ScvDF16bEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("S::operator std::bfloat16_t()", tmp);
}

TEST(Demangle, SimpleSignedBitInt) {
  char tmp[80];

  // S::operator _BitInt(256)() const
  EXPECT_TRUE(Demangle("_ZNK1ScvDB256_Ev", tmp, sizeof(tmp)));
  EXPECT_STREQ("S::operator _BitInt(256)()", tmp);
}

TEST(Demangle, SimpleUnsignedBitInt) {
  char tmp[80];

  // S::operator unsigned _BitInt(256)() const
  EXPECT_TRUE(Demangle("_ZNK1ScvDU256_Ev", tmp, sizeof(tmp)));
  EXPECT_STREQ("S::operator unsigned _BitInt(256)()", tmp);
}

TEST(Demangle, DependentBitInt) {
  char tmp[80];

  // S::operator _BitInt(256)<256>() const
  EXPECT_TRUE(Demangle("_ZNK1ScvDBT__ILi256EEEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("S::operator _BitInt(?)<>()", tmp);
}

TEST(Demangle, ConversionToPointerType) {
  char tmp[80];

  // S::operator int*() const
  EXPECT_TRUE(Demangle("_ZNK1ScvPiEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("S::operator int*()", tmp);
}

TEST(Demangle, ConversionToLvalueReferenceType) {
  char tmp[80];

  // S::operator int&() const
  EXPECT_TRUE(Demangle("_ZNK1ScvRiEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("S::operator int&()", tmp);
}

TEST(Demangle, ConversionToRvalueReferenceType) {
  char tmp[80];

  // S::operator int&&() const
  EXPECT_TRUE(Demangle("_ZNK1ScvOiEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("S::operator int&&()", tmp);
}

TEST(Demangle, ConversionToComplexFloatingPointType) {
  char tmp[80];

  // S::operator float _Complex() const
  EXPECT_TRUE(Demangle("_ZNK1ScvCfEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("S::operator float _Complex()", tmp);
}

TEST(Demangle, ConversionToImaginaryFloatingPointType) {
  char tmp[80];

  // S::operator float _Imaginary() const
  EXPECT_TRUE(Demangle("_ZNK1ScvGfEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("S::operator float _Imaginary()", tmp);
}

TEST(Demangle, ConversionToPointerToCvQualifiedType) {
  char tmp[80];

  // S::operator int const volatile restrict*() const
  EXPECT_TRUE(Demangle("_ZNK1ScvPrVKiEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("S::operator int const volatile restrict*()", tmp);
}

TEST(Demangle, ConversionToLayeredPointerType) {
  char tmp[80];

  // S::operator int const* const*() const
  EXPECT_TRUE(Demangle("_ZNK1ScvPKPKiEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("S::operator int const* const*()", tmp);
}

TEST(Demangle, ConversionToTypeWithExtendedQualifier) {
  char tmp[80];

  // S::operator int const AS128*() const
  //
  // Because our scan of easy type constructors stops at the extended qualifier,
  // the demangling preserves the * but loses the const.
  EXPECT_TRUE(Demangle("_ZNK1ScvPU5AS128KiEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("S::operator int*()", tmp);
}

TEST(Demangle, GlobalInitializers) {
  char tmp[80];

  // old form without suffix
  EXPECT_TRUE(Demangle("_ZGR1v", tmp, sizeof(tmp)));
  EXPECT_STREQ("reference temporary for v", tmp);

  // modern form for the whole initializer
  EXPECT_TRUE(Demangle("_ZGR1v_", tmp, sizeof(tmp)));
  EXPECT_STREQ("reference temporary for v", tmp);

  // next subobject in depth-first preorder traversal
  EXPECT_TRUE(Demangle("_ZGR1v0_", tmp, sizeof(tmp)));
  EXPECT_STREQ("reference temporary for v", tmp);

  // subobject with a larger seq-id
  EXPECT_TRUE(Demangle("_ZGR1v1Z_", tmp, sizeof(tmp)));
  EXPECT_STREQ("reference temporary for v", tmp);
}

TEST(Demangle, StructuredBindings) {
  char tmp[80];

  // Source:
  //
  // struct S { int a, b; };
  // const auto& [x, y] = S{1, 2};

  // [x, y]
  EXPECT_TRUE(Demangle("_ZDC1x1yE", tmp, sizeof(tmp)));

  // reference temporary for [x, y]
  EXPECT_TRUE(Demangle("_ZGRDC1x1yE_", tmp, sizeof(tmp)));
}

// Test the GNU abi_tag extension.
TEST(Demangle, AbiTags) {
  char tmp[80];

  // Mangled name generated via:
  // struct [[gnu::abi_tag("abc")]] A{};
  // A a;
  EXPECT_TRUE(Demangle("_Z1aB3abc", tmp, sizeof(tmp)));
  EXPECT_STREQ("a[abi:abc]", tmp);

  // Mangled name generated via:
  // struct B {
  //   B [[gnu::abi_tag("xyz")]] (){};
  // };
  // B b;
  EXPECT_TRUE(Demangle("_ZN1BC2B3xyzEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("B::B[abi:xyz]()", tmp);

  // Mangled name generated via:
  // [[gnu::abi_tag("foo", "bar")]] void C() {}
  EXPECT_TRUE(Demangle("_Z1CB3barB3foov", tmp, sizeof(tmp)));
  EXPECT_STREQ("C[abi:bar][abi:foo]()", tmp);
}

TEST(Demangle, SimpleGnuVectorSize) {
  char tmp[80];

  // Source:
  //
  // #define VECTOR(size) __attribute__((vector_size(size)))
  // void f(int x VECTOR(32)) {}
  //
  // The attribute's size is a number of bytes.  The compiler verifies that this
  // value corresponds to a whole number of elements and emits the number of
  // elements as a <number> in the mangling.  With sizeof(int) == 4, that yields
  // 32/4 = 8.
  //
  // LLVM demangling:
  //
  // f(int vector[8])
  EXPECT_TRUE(Demangle("_Z1fDv8_i", tmp, sizeof(tmp)));
  EXPECT_STREQ("f()", tmp);
}

TEST(Demangle, GnuVectorSizeIsATemplateParameter) {
  char tmp[80];

  // Source:
  //
  // #define VECTOR(size) __attribute__((vector_size(size)))
  // template <int n> void f(int x VECTOR(n)) {}
  // template void f<32>(int x VECTOR(32));
  //
  // LLVM demangling:
  //
  // void f<32>(int vector[32])
  //
  // Because the size was dependent on a template parameter, it was encoded
  // using the general expression encoding.  Nothing in the mangling says how
  // big the element type is, so the demangler is unable to show the element
  // count 8 instead of the byte count 32.  Arguably it would have been better
  // to make the narrow production encode the byte count, so that nondependent
  // and dependent versions of a 32-byte vector would both come out as
  // vector[32].
  EXPECT_TRUE(Demangle("_Z1fILi32EEvDvT__i", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, GnuVectorSizeIsADependentOperatorExpression) {
  char tmp[80];

  // Source:
  //
  // #define VECTOR(size) __attribute__((vector_size(size)))
  // template <int n> void f(int x VECTOR(2 * n)) {}
  // template void f<32>(int x VECTOR(2 * 32));
  //
  // LLVM demangling:
  //
  // void f<32>(int vector[2 * 32])
  EXPECT_TRUE(Demangle("_Z1fILi32EEvDvmlLi2ET__i", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, SimpleAddressSpace) {
  char tmp[80];

  // Source:
  //
  // void f(const int __attribute__((address_space(128)))*) {}
  //
  // LLVM demangling:
  //
  // f(int const AS128*)
  //
  // Itanium ABI 5.1.5.1, "Qualified types", notes that address_space is mangled
  // nonuniformly as a legacy exception: the number is part of the source-name
  // if nondependent but is an expression in template-args if dependent.  Thus
  // it is a convenient test case for both forms.
  EXPECT_TRUE(Demangle("_Z1fPU5AS128Ki", tmp, sizeof(tmp)));
  EXPECT_STREQ("f()", tmp);
}

TEST(Demangle, DependentAddressSpace) {
  char tmp[80];

  // Source:
  //
  // template <int n> void f (const int __attribute__((address_space(n)))*) {}
  // template void f<128>(const int __attribute__((address_space(128)))*);
  //
  // LLVM demangling:
  //
  // void f<128>(int AS<128>*)
  EXPECT_TRUE(Demangle("_Z1fILi128EEvPU2ASIT_Ei", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, TransactionSafeEntryPoint) {
  char tmp[80];

  EXPECT_TRUE(Demangle("_ZGTt1fv", tmp, sizeof(tmp)));
  EXPECT_STREQ("transaction clone for f()", tmp);
}

TEST(Demangle, TransactionSafeFunctionType) {
  char tmp[80];

  // GNU demangling: f(void (*)() transaction_safe)
  EXPECT_TRUE(Demangle("_Z1fPDxFvvE", tmp, sizeof(tmp)));
  EXPECT_STREQ("f()", tmp);
}

TEST(Demangle, TemplateParameterObject) {
  char tmp[80];

  // Source:
  //
  // struct S { int x, y; };
  // template <S s, const S* p = &s> void f() {}
  // template void f<S{1, 2}>();
  //
  // LLVM demangling:
  //
  // void f<S{1, 2}, &template parameter object for S{1, 2}>()
  EXPECT_TRUE(Demangle("_Z1fIXtl1SLi1ELi2EEEXadL_ZTAXtlS0_Li1ELi2EEEEEEvv",
                       tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);

  // The name of the object standing alone.
  //
  // LLVM demangling: template parameter object for S{1, 2}
  EXPECT_TRUE(Demangle("_ZTAXtl1SLi1ELi2EEE", tmp, sizeof(tmp)));
  EXPECT_STREQ("template parameter object", tmp);
}

TEST(Demangle, EnableIfAttributeOnGlobalFunction) {
  char tmp[80];

  // int f(long l) __attribute__((enable_if(l >= 0, ""))) { return l; }
  //
  // f(long) [enable_if:fp >= 0]
  EXPECT_TRUE(Demangle("_Z1fUa9enable_ifIXgefL0p_Li0EEEl", tmp, sizeof(tmp)));
  EXPECT_STREQ("f()", tmp);
}

TEST(Demangle, EnableIfAttributeOnNamespaceScopeFunction) {
  char tmp[80];

  // namespace ns {
  // int f(long l) __attribute__((enable_if(l >= 0, ""))) { return l; }
  // }  // namespace ns
  //
  // ns::f(long) [enable_if:fp >= 0]
  EXPECT_TRUE(Demangle("_ZN2ns1fEUa9enable_ifIXgefL0p_Li0EEEl",
              tmp, sizeof(tmp)));
  EXPECT_STREQ("ns::f()", tmp);
}

TEST(Demangle, EnableIfAttributeOnFunctionTemplate) {
  char tmp[80];

  // template <class T>
  // T f(T t) __attribute__((enable_if(t >= T{}, ""))) { return t; }
  // template int f<int>(int);
  //
  // int f<int>(int) [enable_if:fp >= int{}]
  EXPECT_TRUE(Demangle("_Z1fIiEUa9enable_ifIXgefL0p_tliEEET_S0_",
              tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, ThisPointerInDependentSignature) {
  char tmp[80];

  // decltype(g<int>(this)) S::f<int>()
  EXPECT_TRUE(Demangle("_ZN1S1fIiEEDTcl1gIT_EfpTEEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("S::f<>()", tmp);
}

TEST(Demangle, DependentMemberOperatorCall) {
  char tmp[80];

  // decltype(fp.operator()()) f<C>(C)
  EXPECT_TRUE(Demangle("_Z1fI1CEDTcldtfp_onclEET_", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, TypeNestedUnderDecltype) {
  char tmp[80];

  // Source:
  //
  // template <class T> struct S { using t = int; };
  // template <class T> decltype(S<T>{})::t f() { return {}; }
  // void g() { f<int>(); }
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(S<int>{})::t f<int>()
  EXPECT_TRUE(Demangle("_Z1fIiENDTtl1SIT_EEE1tEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, ElaboratedTypes) {
  char tmp[80];

  // Source:
  //
  // template <class T> struct S { class C {}; };
  // template <class T> void f(class S<T>::C) {}
  // template void f<int>(class S<int>::C);
  //
  // LLVM demangling:
  //
  // void f<int>(struct S<int>::C)
  EXPECT_TRUE(Demangle("_Z1fIiEvTsN1SIT_E1CE", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);

  // The like for unions.
  EXPECT_TRUE(Demangle("_Z1fIiEvTuN1SIT_E1CE", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);

  // The like for enums.
  EXPECT_TRUE(Demangle("_Z1fIiEvTeN1SIT_E1CE", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

// Test subobject-address template parameters.
TEST(Demangle, SubobjectAddresses) {
  char tmp[80];

  // void f<a.<char const at offset 123>>()
  EXPECT_TRUE(Demangle("_Z1fIXsoKcL_Z1aE123EEEvv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);

  // void f<&a.<char const at offset 0>>()
  EXPECT_TRUE(Demangle("_Z1fIXadsoKcL_Z1aEEEEvv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);

  // void f<&a.<char const at offset 123>>()
  EXPECT_TRUE(Demangle("_Z1fIXadsoKcL_Z1aE123EEEvv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);

  // void f<&a.<char const at offset 123>>(), past the end this time
  EXPECT_TRUE(Demangle("_Z1fIXadsoKcL_Z1aE123pEEEvv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);

  // void f<&a.<char const at offset 0>>() with union-selectors
  EXPECT_TRUE(Demangle("_Z1fIXadsoKcL_Z1aE__1_234EEEvv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);

  // void f<&a.<char const at offset 123>>(), past the end, with union-selector
  EXPECT_TRUE(Demangle("_Z1fIXadsoKcL_Z1aE123_456pEEEvv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, Preincrement) {
  char tmp[80];

  // Source:
  //
  // template <class T> auto f(T t) -> decltype(T{++t}) { return t; }
  // template auto f<int>(int t) -> decltype(int{++t});
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(int{++fp}) f<int>(int)
  EXPECT_TRUE(Demangle("_Z1fIiEDTtlT_pp_fp_EES0_", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, Postincrement) {
  char tmp[80];

  // Source:
  //
  // template <class T> auto f(T t) -> decltype(T{t++}) { return t; }
  // template auto f<int>(int t) -> decltype(int{t++});
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(int{fp++}) f<int>(int)
  EXPECT_TRUE(Demangle("_Z1fIiEDTtlT_ppfp_EES0_", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, Predecrement) {
  char tmp[80];

  // Source:
  //
  // template <class T> auto f(T t) -> decltype(T{--t}) { return t; }
  // template auto f<int>(int t) -> decltype(int{--t});
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(int{--fp}) f<int>(int)
  EXPECT_TRUE(Demangle("_Z1fIiEDTtlT_mm_fp_EES0_", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, Postdecrement) {
  char tmp[80];

  // Source:
  //
  // template <class T> auto f(T t) -> decltype(T{t--}) { return t; }
  // template auto f<int>(int t) -> decltype(int{t--});
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(int{fp--}) f<int>(int)
  EXPECT_TRUE(Demangle("_Z1fIiEDTtlT_mmfp_EES0_", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, UnaryFoldExpressions) {
  char tmp[80];

  // Source:
  //
  // template <bool b> struct S {};
  //
  // template <class... T> auto f(T... t) -> S<((sizeof(T) == 4) || ...)> {
  //   return {};
  // }
  //
  // void g() { f(1, 2L); }
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // S<((sizeof (int) == 4, sizeof (long) == 4) || ...)> f<int, long>(int, long)
  EXPECT_TRUE(Demangle("_Z1fIJilEE1SIXfrooeqstT_Li4EEEDpS1_",
                       tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);

  // The like with a left fold.
  //
  // S<(... || (sizeof (int) == 4, sizeof (long) == 4))> f<int, long>(int, long)
  EXPECT_TRUE(Demangle("_Z1fIJilEE1SIXflooeqstT_Li4EEEDpS1_",
                       tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, BinaryFoldExpressions) {
  char tmp[80];

  // Source:
  //
  // template <bool b> struct S {};
  //
  // template <class... T> auto f(T... t)
  //     -> S<((sizeof(T) == 4) || ... || false)> {
  //   return {};
  // }
  //
  // void g() { f(1, 2L); }
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // S<((sizeof (int) == 4, sizeof (long) == 4) || ... || false)>
  // f<int, long>(int, long)
  EXPECT_TRUE(Demangle("_Z1fIJilEE1SIXfRooeqstT_Li4ELb0EEEDpS1_",
                       tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);

  // The like with a left fold.
  //
  // S<(false || ... || (sizeof (int) == 4, sizeof (long) == 4))>
  // f<int, long>(int, long)
  EXPECT_TRUE(Demangle("_Z1fIJilEE1SIXfLooLb0EeqstT_Li4EEEDpS1_",
                       tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, SizeofPacks) {
  char tmp[80];

  // template <size_t i> struct S {};
  //
  // template <class... T> auto f(T... p) -> S<sizeof...(T)> { return {}; }
  // template auto f<int, long>(int, long) -> S<2>;
  //
  // template <class... T> auto g(T... p) -> S<sizeof...(p)> { return {}; }
  // template auto g<int, long>(int, long) -> S<2>;

  // S<sizeof...(int, long)> f<int, long>(int, long)
  EXPECT_TRUE(Demangle("_Z1fIJilEE1SIXsZT_EEDpT_", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);

  // S<sizeof... (fp)> g<int, long>(int, long)
  EXPECT_TRUE(Demangle("_Z1gIJilEE1SIXsZfp_EEDpT_", tmp, sizeof(tmp)));
  EXPECT_STREQ("g<>()", tmp);
}

TEST(Demangle, SizeofPackInvolvingAnAliasTemplate) {
  char tmp[80];

  // Source:
  //
  // template <class... T> using A = char[sizeof...(T)];
  // template <class... U> void f(const A<U..., int>&) {}
  // template void f<int>(const A<int, int>&);
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // void f<int>(char const (&) [sizeof... (int, int)])
  EXPECT_TRUE(Demangle("_Z1fIJiEEvRAsPDpT_iE_Kc", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, UserDefinedLiteral) {
  char tmp[80];

  // Source:
  //
  // unsigned long long operator""_lit(unsigned long long x) { return x; }
  //
  // LLVM demangling:
  //
  // operator"" _lit(unsigned long long)
  EXPECT_TRUE(Demangle("_Zli4_lity", tmp, sizeof(tmp)));
  EXPECT_STREQ("operator\"\" _lit()", tmp);
}

TEST(Demangle, Spaceship) {
  char tmp[80];

  // #include <compare>
  //
  // struct S { auto operator<=>(const S&) const = default; };
  // auto (S::*f) = &S::operator<=>;  // make sure S::operator<=> is emitted
  //
  // template <class T> auto g(T x, T y) -> decltype(x <=> y) {
  //   return x <=> y;
  // }
  // template auto g<S>(S x, S y) -> decltype(x <=> y);

  // S::operator<=>(S const&) const
  EXPECT_TRUE(Demangle("_ZNK1SssERKS_", tmp, sizeof(tmp)));
  EXPECT_STREQ("S::operator<=>()", tmp);

  // decltype(fp <=> fp0) g<S>(S, S)
  EXPECT_TRUE(Demangle("_Z1gI1SEDTssfp_fp0_ET_S2_", tmp, sizeof(tmp)));
  EXPECT_STREQ("g<>()", tmp);
}

TEST(Demangle, CoAwait) {
  char tmp[80];

  // ns::Awaitable::operator co_await() const
  EXPECT_TRUE(Demangle("_ZNK2ns9AwaitableawEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("ns::Awaitable::operator co_await()", tmp);
}

TEST(Demangle, VendorExtendedExpressions) {
  char tmp[80];

  // void f<__e()>()
  EXPECT_TRUE(Demangle("_Z1fIXu3__eEEEvv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);

  // void f<__e(int, long)>()
  EXPECT_TRUE(Demangle("_Z1fIXu3__eilEEEvv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, DirectListInitialization) {
  char tmp[80];

  // template <class T> decltype(T{}) f() { return T{}; }
  // template decltype(int{}) f<int>();
  //
  // struct XYZ { int x, y, z; };
  // template <class T> decltype(T{1, 2, 3}) g() { return T{1, 2, 3}; }
  // template decltype(XYZ{1, 2, 3}) g<XYZ>();
  //
  // template <class T> decltype(T{.x = 1, .y = 2, .z = 3}) h() {
  //   return T{.x = 1, .y = 2, .z = 3};
  // }
  // template decltype(XYZ{.x = 1, .y = 2, .z = 3}) h<XYZ>();
  //
  // // The following two cases require full C99 designated initializers,
  // // not part of C++ but likely available as an extension if you ask your
  // // compiler nicely.
  //
  // struct A { int a[4]; };
  // template <class T> decltype(T{.a[2] = 42}) i() { return T{.a[2] = 42}; }
  // template decltype(A{.a[2] = 42}) i<A>();
  //
  // template <class T> decltype(T{.a[1 ... 3] = 42}) j() {
  //   return T{.a[1 ... 3] = 42};
  // }
  // template decltype(A{.a[1 ... 3] = 42}) j<A>();

  // decltype(int{}) f<int>()
  EXPECT_TRUE(Demangle("_Z1fIiEDTtlT_EEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);

  // decltype(XYZ{1, 2, 3}) g<XYZ>()
  EXPECT_TRUE(Demangle("_Z1gI3XYZEDTtlT_Li1ELi2ELi3EEEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("g<>()", tmp);

  // decltype(XYZ{.x = 1, .y = 2, .z = 3}) h<XYZ>()
  EXPECT_TRUE(Demangle("_Z1hI3XYZEDTtlT_di1xLi1Edi1yLi2Edi1zLi3EEEv",
                       tmp, sizeof(tmp)));
  EXPECT_STREQ("h<>()", tmp);

  // decltype(A{.a[2] = 42}) i<A>()
  EXPECT_TRUE(Demangle("_Z1iI1AEDTtlT_di1adxLi2ELi42EEEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("i<>()", tmp);

  // decltype(A{.a[1 ... 3] = 42}) j<A>()
  EXPECT_TRUE(Demangle("_Z1jI1AEDTtlT_di1adXLi1ELi3ELi42EEEv",
                       tmp, sizeof(tmp)));
  EXPECT_STREQ("j<>()", tmp);
}

TEST(Demangle, SimpleInitializerLists) {
  char tmp[80];

  // Common preamble of source-code examples in this test function:
  //
  // #include <initializer_list>
  //
  // template <class T> void g(std::initializer_list<T>) {}

  // Source:
  //
  // template <class T> auto f() -> decltype(g<T>({})) {}
  // template auto f<int>() -> decltype(g<int>({}));
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(g<int>({})) f<int>()
  EXPECT_TRUE(Demangle("_Z1fIiEDTcl1gIT_EilEEEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);

  // Source:
  //
  // template <class T> auto f(T x) -> decltype(g({x})) {}
  // template auto f<int>(int x) -> decltype(g({x}));
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(g({fp})) f<int>(int)
  EXPECT_TRUE(Demangle("_Z1fIiEDTcl1gilfp_EEET_", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);

  // Source:
  //
  // template <class T> auto f(T x, T y) -> decltype(g({x, y})) {}
  // template auto f<int>(int x, int y) -> decltype(g({x, y}));
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(g({fp, fp0})) f<int>(int, int)
  EXPECT_TRUE(Demangle("_Z1fIiEDTcl1gilfp_fp0_EEET_S1_", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, BracedListImplicitlyConstructingAClassObject) {
  char tmp[80];

  // Source:
  //
  // struct S { int v; };
  // void g(S) {}
  // template <class T> auto f(T x) -> decltype(g({.v = x})) {}
  // template auto f<int>(int x) -> decltype(g({.v = x}));
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(g({.v = fp})) f<int>(int)
  EXPECT_TRUE(Demangle("_Z1fIiEDTcl1gildi1vfp_EEET_", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, SimpleNewExpression) {
  char tmp[80];

  // Source:
  //
  // template <class T> decltype(T{*new T}) f() { return T{}; }
  // template decltype(int{*new int}) f<int>();
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(int{*(new int)}) f<int>()
  EXPECT_TRUE(Demangle("_Z1fIiEDTtlT_denw_S0_EEEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, NewExpressionWithEmptyParentheses) {
  char tmp[80];

  // Source:
  //
  // template <class T> decltype(T{*new T()}) f() { return T{}; }
  // template decltype(int{*new int()}) f<int>();
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(int{*(new int)}) f<int>()
  EXPECT_TRUE(Demangle("_Z1fIiEDTtlT_denw_S0_piEEEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, NewExpressionWithNonemptyParentheses) {
  char tmp[80];

  // Source:
  //
  // template <class T> decltype(T{*new T(42)}) f() { return T{}; }
  // template decltype(int{*new int(42)}) f<int>();
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(int{*(new int(42))}) f<int>()
  EXPECT_TRUE(Demangle("_Z1fIiEDTtlT_denw_S0_piLi42EEEEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, PlacementNewExpression) {
  char tmp[80];

  // Source:
  //
  // #include <new>
  //
  // template <class T> auto f(T t) -> decltype(T{*new (&t) T(42)}) {
  //   return t;
  // }
  // template auto f<int>(int t) -> decltype(int{*new (&t) int(42)});
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(int{*(new(&fp) int(42))}) f<int>(int)
  EXPECT_TRUE(Demangle("_Z1fIiEDTtlT_denwadfp__S0_piLi42EEEES0_",
                       tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, GlobalScopeNewExpression) {
  char tmp[80];

  // Source:
  //
  // template <class T> decltype(T{*::new T}) f() { return T{}; }
  // template decltype(int{*::new int}) f<int>();
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(int{*(::new int)}) f<int>()
  EXPECT_TRUE(Demangle("_Z1fIiEDTtlT_degsnw_S0_EEEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, NewExpressionWithEmptyBraces) {
  char tmp[80];

  // Source:
  //
  // template <class T> decltype(T{*new T{}}) f() { return T{}; }
  // template decltype(int{*new int{}}) f<int>();
  //
  // GNU demangling:
  //
  // decltype (int{*(new int{})}) f<int>()
  EXPECT_TRUE(Demangle("_Z1fIiEDTtlT_denw_S0_ilEEEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, NewExpressionWithNonemptyBraces) {
  char tmp[80];

  // Source:
  //
  // template <class T> decltype(T{*new T{42}}) f() { return T{}; }
  // template decltype(int{*new int{42}}) f<int>();
  //
  // GNU demangling:
  //
  // decltype (int{*(new int{42})}) f<int>()
  EXPECT_TRUE(Demangle("_Z1fIiEDTtlT_denw_S0_ilLi42EEEEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, SimpleArrayNewExpression) {
  char tmp[80];

  // Source:
  //
  // template <class T> decltype(T{*new T[1]}) f() { return T{}; }
  // template decltype(int{*new int[1]}) f<int>();
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(int{*(new[] int)}) f<int>()
  EXPECT_TRUE(Demangle("_Z1fIiEDTtlT_dena_S0_EEEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, ArrayNewExpressionWithEmptyParentheses) {
  char tmp[80];

  // Source:
  //
  // template <class T> decltype(T{*new T[1]()}) f() { return T{}; }
  // template decltype(int{*new int[1]()}) f<int>();
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(int{*(new[] int)}) f<int>()
  EXPECT_TRUE(Demangle("_Z1fIiEDTtlT_dena_S0_piEEEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, ArrayPlacementNewExpression) {
  char tmp[80];

  // Source:
  //
  // #include <new>
  //
  // template <class T> auto f(T t) -> decltype(T{*new (&t) T[1]}) {
  //   return T{};
  // }
  // template auto f<int>(int t) -> decltype(int{*new (&t) int[1]});
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(int{*(new[](&fp) int)}) f<int>(int)
  EXPECT_TRUE(Demangle("_Z1fIiEDTtlT_denaadfp__S0_EEES0_", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, GlobalScopeArrayNewExpression) {
  char tmp[80];

  // Source:
  //
  // template <class T> decltype(T{*::new T[1]}) f() { return T{}; }
  // template decltype(int{*::new int[1]}) f<int>();
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(int{*(::new[] int)}) f<int>()
  EXPECT_TRUE(Demangle("_Z1fIiEDTtlT_degsna_S0_EEEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, ArrayNewExpressionWithTwoElementsInBraces) {
  char tmp[80];

  // Source:
  //
  // template <class T> decltype(T{*new T[2]{1, 2}}) f() { return T{}; }
  // template decltype(int{*new int[2]{1, 2}}) f<int>();
  //
  // GNU demangling:
  //
  // decltype (int{*(new int{1, 2})}) f<int>()
  EXPECT_TRUE(Demangle("_Z1fIiEDTtlT_dena_S0_ilLi1ELi2EEEEv",
                       tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, SimpleDeleteExpression) {
  char tmp[80];

  // Source:
  //
  // template <class T> auto f(T* p) -> decltype(delete p) {}
  // template auto f<int>(int* p) -> decltype(delete p);
  //
  // LLVM demangling:
  //
  // decltype(delete fp) f<int>(int*)
  EXPECT_TRUE(Demangle("_Z1fIiEDTdlfp_EPT_", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, GlobalScopeDeleteExpression) {
  char tmp[80];

  // Source:
  //
  // template <class T> auto f(T* p) -> decltype(::delete p) {}
  // template auto f<int>(int* p) -> decltype(::delete p);
  //
  // LLVM demangling:
  //
  // decltype(::delete fp) f<int>(int*)
  EXPECT_TRUE(Demangle("_Z1fIiEDTgsdlfp_EPT_", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, SimpleArrayDeleteExpression) {
  char tmp[80];

  // Source:
  //
  // template <class T> auto f(T* a) -> decltype(delete[] a) {}
  // template auto f<int>(int* a) -> decltype(delete[] a);
  //
  // LLVM demangling:
  //
  // decltype(delete[] fp) f<int>(int*)
  EXPECT_TRUE(Demangle("_Z1fIiEDTdafp_EPT_", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, GlobalScopeArrayDeleteExpression) {
  char tmp[80];

  // Source:
  //
  // template <class T> auto f(T* a) -> decltype(::delete[] a) {}
  // template auto f<int>(int* a) -> decltype(::delete[] a);
  //
  // LLVM demangling:
  //
  // decltype(::delete[] fp) f<int>(int*)
  EXPECT_TRUE(Demangle("_Z1fIiEDTgsdafp_EPT_", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, ReferenceQualifiedFunctionTypes) {
  char tmp[80];

  // void f(void (*)() const &, int)
  EXPECT_TRUE(Demangle("_Z1fPKFvvREi", tmp, sizeof(tmp)));
  EXPECT_STREQ("f()", tmp);

  // void f(void (*)() &&, int)
  EXPECT_TRUE(Demangle("_Z1fPFvvOEi", tmp, sizeof(tmp)));
  EXPECT_STREQ("f()", tmp);

  // void f(void (*)(int&) &, int)
  EXPECT_TRUE(Demangle("_Z1fPFvRiREi", tmp, sizeof(tmp)));
  EXPECT_STREQ("f()", tmp);

  // void f(void (*)(S&&) &&, int)
  EXPECT_TRUE(Demangle("_Z1fPFvO1SOEi", tmp, sizeof(tmp)));
  EXPECT_STREQ("f()", tmp);
}

TEST(Demangle, DynamicCast) {
  char tmp[80];

  // Source:
  //
  // template <class T> auto f(T* p) -> decltype(dynamic_cast<const T*>(p)) {
  //   return p;
  // }
  // struct S {};
  // void g(S* p) { f(p); }
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(dynamic_cast<S const*>(fp)) f<S>(S*)
  EXPECT_TRUE(Demangle("_Z1fI1SEDTdcPKT_fp_EPS1_", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, StaticCast) {
  char tmp[80];

  // Source:
  //
  // template <class T> auto f(T* p) -> decltype(static_cast<const T*>(p)) {
  //   return p;
  // }
  // void g(int* p) { f(p); }
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(static_cast<int const*>(fp)) f<int>(int*)
  EXPECT_TRUE(Demangle("_Z1fIiEDTscPKT_fp_EPS0_", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, ConstCast) {
  char tmp[80];

  // Source:
  //
  // template <class T> auto f(T* p) -> decltype(const_cast<const T*>(p)) {
  //   return p;
  // }
  // void g(int* p) { f(p); }
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(const_cast<int const*>(fp)) f<int>(int*)
  EXPECT_TRUE(Demangle("_Z1fIiEDTccPKT_fp_EPS0_", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, ReinterpretCast) {
  char tmp[80];

  // Source:
  //
  // template <class T> auto f(T* p)
  //     -> decltype(reinterpret_cast<const T*>(p)) {
  //   return p;
  // }
  // void g(int* p) { f(p); }
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(reinterpret_cast<int const*>(fp)) f<int>(int*)
  EXPECT_TRUE(Demangle("_Z1fIiEDTrcPKT_fp_EPS0_", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, TypeidType) {
  char tmp[80];

  // Source:
  //
  // #include <typeinfo>
  //
  // template <class T> decltype(typeid(T).name()) f(T) { return nullptr; }
  // template decltype(typeid(int).name()) f<int>(int);
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(typeid (int).name()) f<int>(int)
  EXPECT_TRUE(Demangle("_Z1fIiEDTcldttiT_4nameEES0_", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, TypeidExpression) {
  char tmp[80];

  // Source:
  //
  // #include <typeinfo>
  //
  // template <class T> decltype(typeid(T{}).name()) f(T) { return nullptr; }
  // template decltype(typeid(int{}).name()) f<int>(int);
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(typeid (int{}).name()) f<int>(int)
  EXPECT_TRUE(Demangle("_Z1fIiEDTcldttetlT_E4nameEES0_", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, AlignofType) {
  char tmp[80];

  // Source:
  //
  // template <class T> T f(T (&a)[alignof(T)]) { return a[0]; }
  // template int f<int>(int (&)[alignof(int)]);
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // int f<int>(int (&) [alignof (int)])
  EXPECT_TRUE(Demangle("_Z1fIiET_RAatS0__S0_", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, AlignofExpression) {
  char tmp[80];

  // Source (note that this uses a GNU extension; it is not standard C++):
  //
  // template <class T> T f(T (&a)[alignof(T{})]) { return a[0]; }
  // template int f<int>(int (&)[alignof(int{})]);
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // int f<int>(int (&) [alignof (int{})])
  EXPECT_TRUE(Demangle("_Z1fIiET_RAaztlS0_E_S0_", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, NoexceptExpression) {
  char tmp[80];

  // Source:
  //
  // template <class T> void f(T (&a)[noexcept(T{})]) {}
  // template void f<int>(int (&)[noexcept(int{})]);
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // void f<int>(int (&) [noexcept (int{})])
  EXPECT_TRUE(Demangle("_Z1fIiEvRAnxtlT_E_S0_", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, UnaryThrow) {
  char tmp[80];

  // Source:
  //
  // template <bool b> decltype(b ? throw b : 0) f() { return 0; }
  // template decltype(false ? throw false : 0) f<false>();
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(false ? throw false : 0) f<false>()
  EXPECT_TRUE(Demangle("_Z1fILb0EEDTquT_twT_Li0EEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, NullaryThrow) {
  char tmp[80];

  // Source:
  //
  // template <bool b> decltype(b ? throw : 0) f() { return 0; }
  // template decltype(false ? throw : 0) f<false>();
  //
  // Full LLVM demangling of the instantiation of f:
  //
  // decltype(false ? throw : 0) f<false>()
  EXPECT_TRUE(Demangle("_Z1fILb0EEDTquT_trLi0EEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);
}

TEST(Demangle, ThreadLocalWrappers) {
  char tmp[80];

  EXPECT_TRUE(Demangle("_ZTWN2ns3varE", tmp, sizeof(tmp)));
  EXPECT_STREQ("thread-local wrapper routine for ns::var", tmp);

  EXPECT_TRUE(Demangle("_ZTHN2ns3varE", tmp, sizeof(tmp)));
  EXPECT_STREQ("thread-local initialization routine for ns::var", tmp);
}

TEST(Demangle, DubiousSrStSymbols) {
  char tmp[80];

  // GNU demangling (not accepted by LLVM):
  //
  // S<std::u<char>::v> f<char>()
  EXPECT_TRUE(Demangle("_Z1fIcE1SIXsrSt1uIT_E1vEEv", tmp, sizeof(tmp)));
  EXPECT_STREQ("f<>()", tmp);

  // A real case from the wild.
  //
  // GNU demangling (not accepted by LLVM) with line breaks and indentation
  // added for readability:
  //
  // __gnu_cxx::__enable_if<std::__is_char<char>::__value, bool>::__type
  // std::operator==<char>(
  //     std::__cxx11::basic_string<char, std::char_traits<char>,
  //                                std::allocator<char> > const&,
  //     std::__cxx11::basic_string<char, std::char_traits<char>,
  //                                std::allocator<char> > const&)
  EXPECT_TRUE(Demangle(
      "_ZSteqIcEN9__gnu_cxx11__enable_if"
      "IXsrSt9__is_charIT_E7__valueEbE"
      "6__typeE"
      "RKNSt7__cxx1112basic_stringIS3_St11char_traitsIS3_ESaIS3_EEESE_",
      tmp, sizeof(tmp)));
  EXPECT_STREQ("std::operator==<>()", tmp);
}

// Test one Rust symbol to exercise Demangle's delegation path.  Rust demangling
// itself is more thoroughly tested in demangle_rust_test.cc.
TEST(Demangle, DelegatesToDemangleRustSymbolEncoding) {
  char tmp[80];

  EXPECT_TRUE(Demangle("_RNvC8my_crate7my_func", tmp, sizeof(tmp)));
  EXPECT_STREQ("my_crate::my_func", tmp);
}

// Tests that verify that Demangle footprint is within some limit.
// They are not to be run under sanitizers as the sanitizers increase
// stack consumption by about 4x.
#if defined(ABSL_INTERNAL_HAVE_DEBUGGING_STACK_CONSUMPTION) && \
    !defined(ABSL_HAVE_ADDRESS_SANITIZER) &&                   \
    !defined(ABSL_HAVE_MEMORY_SANITIZER) &&                    \
    !defined(ABSL_HAVE_THREAD_SANITIZER)

static const char *g_mangled;
static char g_demangle_buffer[4096];
static char *g_demangle_result;

static void DemangleSignalHandler(int signo) {
  if (Demangle(g_mangled, g_demangle_buffer, sizeof(g_demangle_buffer))) {
    g_demangle_result = g_demangle_buffer;
  } else {
    g_demangle_result = nullptr;
  }
}

// Call Demangle and figure out the stack footprint of this call.
static const char *DemangleStackConsumption(const char *mangled,
                                            int *stack_consumed) {
  g_mangled = mangled;
  *stack_consumed = GetSignalHandlerStackConsumption(DemangleSignalHandler);
  LOG(INFO) << "Stack consumption of Demangle: " << *stack_consumed;
  return g_demangle_result;
}

// Demangle stack consumption should be within 8kB for simple mangled names
// with some level of nesting. With alternate signal stack we have 64K,
// but some signal handlers run on thread stack, and could have arbitrarily
// little space left (so we don't want to make this number too large).
const int kStackConsumptionUpperLimit = 8192;

// Returns a mangled name nested to the given depth.
static std::string NestedMangledName(int depth) {
  std::string mangled_name = "_Z1a";
  if (depth > 0) {
    mangled_name += "IXL";
    mangled_name += NestedMangledName(depth - 1);
    mangled_name += "EEE";
  }
  return mangled_name;
}

TEST(Demangle, DemangleStackConsumption) {
  // Measure stack consumption of Demangle for nested mangled names of varying
  // depth.  Since Demangle is implemented as a recursive descent parser,
  // stack consumption will grow as the nesting depth increases.  By measuring
  // the stack consumption for increasing depths, we can see the growing
  // impact of any stack-saving changes made to the code for Demangle.
  int stack_consumed = 0;

  const char *demangled =
      DemangleStackConsumption("_Z6foobarv", &stack_consumed);
  EXPECT_STREQ("foobar()", demangled);
  EXPECT_GT(stack_consumed, 0);
  EXPECT_LT(stack_consumed, kStackConsumptionUpperLimit);

  const std::string nested_mangled_name0 = NestedMangledName(0);
  demangled = DemangleStackConsumption(nested_mangled_name0.c_str(),
                                       &stack_consumed);
  EXPECT_STREQ("a", demangled);
  EXPECT_GT(stack_consumed, 0);
  EXPECT_LT(stack_consumed, kStackConsumptionUpperLimit);

  const std::string nested_mangled_name1 = NestedMangledName(1);
  demangled = DemangleStackConsumption(nested_mangled_name1.c_str(),
                                       &stack_consumed);
  EXPECT_STREQ("a<>", demangled);
  EXPECT_GT(stack_consumed, 0);
  EXPECT_LT(stack_consumed, kStackConsumptionUpperLimit);

  const std::string nested_mangled_name2 = NestedMangledName(2);
  demangled = DemangleStackConsumption(nested_mangled_name2.c_str(),
                                       &stack_consumed);
  EXPECT_STREQ("a<>", demangled);
  EXPECT_GT(stack_consumed, 0);
  EXPECT_LT(stack_consumed, kStackConsumptionUpperLimit);

  const std::string nested_mangled_name3 = NestedMangledName(3);
  demangled = DemangleStackConsumption(nested_mangled_name3.c_str(),
                                       &stack_consumed);
  EXPECT_STREQ("a<>", demangled);
  EXPECT_GT(stack_consumed, 0);
  EXPECT_LT(stack_consumed, kStackConsumptionUpperLimit);
}

#endif  // Stack consumption tests

static void TestOnInput(const char* input) {
  static const int kOutSize = 1048576;
  auto out = absl::make_unique<char[]>(kOutSize);
  Demangle(input, out.get(), kOutSize);
}

TEST(DemangleRegression, NegativeLength) {
  TestOnInput("_ZZn4");
}

TEST(DemangleRegression, DeeplyNestedArrayType) {
  const int depth = 100000;
  std::string data = "_ZStI";
  data.reserve(data.size() + 3 * depth + 1);
  for (int i = 0; i < depth; i++) {
    data += "A1_";
  }
  TestOnInput(data.c_str());
}

struct Base {
  virtual ~Base() = default;
};

struct Derived : public Base {};

TEST(DemangleStringTest, SupportsSymbolNameReturnedByTypeId) {
  EXPECT_EQ(DemangleString(typeid(int).name()), "int");
  // We want to test that `DemangleString` can demangle the symbol names
  // returned by `typeid`, but without hard-coding the actual demangled values
  // (because they are platform-specific).
  EXPECT_THAT(
      DemangleString(typeid(Base).name()),
      ContainsRegex("absl.*debugging_internal.*anonymous namespace.*::Base"));
  EXPECT_THAT(DemangleString(typeid(Derived).name()),
              ContainsRegex(
                  "absl.*debugging_internal.*anonymous namespace.*::Derived"));
}

}  // namespace
}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl
               node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/internal/elf_mem_image.cc                 0000664 0000000 0000000 00000032411 14746647661 0030163 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Allow dynamic symbol lookup in an in-memory Elf image.
//

#include "absl/debugging/internal/elf_mem_image.h"

#ifdef ABSL_HAVE_ELF_MEM_IMAGE  // defined in elf_mem_image.h

#include <string.h>

#include <cassert>
#include <cstddef>
#include <cstdint>

#include "absl/base/config.h"
#include "absl/base/internal/raw_logging.h"

// From binutils/include/elf/common.h (this doesn't appear to be documented
// anywhere else).
//
//   /* This flag appears in a Versym structure.  It means that the symbol
//      is hidden, and is only visible with an explicit version number.
//      This is a GNU extension.  */
//   #define VERSYM_HIDDEN           0x8000
//
//   /* This is the mask for the rest of the Versym information.  */
//   #define VERSYM_VERSION          0x7fff

#define VERSYM_VERSION 0x7fff

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace debugging_internal {

namespace {

#if __SIZEOF_POINTER__ == 4
const int kElfClass = ELFCLASS32;
int ElfBind(const ElfW(Sym) *symbol) { return ELF32_ST_BIND(symbol->st_info); }
int ElfType(const ElfW(Sym) *symbol) { return ELF32_ST_TYPE(symbol->st_info); }
#elif __SIZEOF_POINTER__ == 8
const int kElfClass = ELFCLASS64;
int ElfBind(const ElfW(Sym) *symbol) { return ELF64_ST_BIND(symbol->st_info); }
int ElfType(const ElfW(Sym) *symbol) { return ELF64_ST_TYPE(symbol->st_info); }
#else
const int kElfClass = -1;
int ElfBind(const ElfW(Sym) *) {
  ABSL_RAW_LOG(FATAL, "Unexpected word size");
  return 0;
}
int ElfType(const ElfW(Sym) *) {
  ABSL_RAW_LOG(FATAL, "Unexpected word size");
  return 0;
}
#endif

// Extract an element from one of the ELF tables, cast it to desired type.
// This is just a simple arithmetic and a glorified cast.
// Callers are responsible for bounds checking.
template <typename T>
const T *GetTableElement(const ElfW(Ehdr) * ehdr, ElfW(Off) table_offset,
                         ElfW(Word) element_size, size_t index) {
  return reinterpret_cast<const T*>(reinterpret_cast<const char *>(ehdr)
                                    + table_offset
                                    + index * element_size);
}

}  // namespace

// The value of this variable doesn't matter; it's used only for its
// unique address.
const int ElfMemImage::kInvalidBaseSentinel = 0;

ElfMemImage::ElfMemImage(const void *base) {
  ABSL_RAW_CHECK(base != kInvalidBase, "bad pointer");
  Init(base);
}

uint32_t ElfMemImage::GetNumSymbols() const { return num_syms_; }

const ElfW(Sym) * ElfMemImage::GetDynsym(uint32_t index) const {
  ABSL_RAW_CHECK(index < GetNumSymbols(), "index out of range");
  return dynsym_ + index;
}

const ElfW(Versym) *ElfMemImage::GetVersym(uint32_t index) const {
  ABSL_RAW_CHECK(index < GetNumSymbols(), "index out of range");
  return versym_ + index;
}

const ElfW(Phdr) *ElfMemImage::GetPhdr(int index) const {
  ABSL_RAW_CHECK(index >= 0 && index < ehdr_->e_phnum, "index out of range");
  return GetTableElement<ElfW(Phdr)>(ehdr_, ehdr_->e_phoff, ehdr_->e_phentsize,
                                     static_cast<size_t>(index));
}

const char *ElfMemImage::GetDynstr(ElfW(Word) offset) const {
  ABSL_RAW_CHECK(offset < strsize_, "offset out of range");
  return dynstr_ + offset;
}

const void *ElfMemImage::GetSymAddr(const ElfW(Sym) *sym) const {
  if (sym->st_shndx == SHN_UNDEF || sym->st_shndx >= SHN_LORESERVE) {
    // Symbol corresponds to "special" (e.g. SHN_ABS) section.
    return reinterpret_cast<const void *>(sym->st_value);
  }
  ABSL_RAW_CHECK(link_base_ < sym->st_value, "symbol out of range");
  return GetTableElement<char>(ehdr_, 0, 1, sym->st_value - link_base_);
}

const ElfW(Verdef) *ElfMemImage::GetVerdef(int index) const {
  ABSL_RAW_CHECK(0 <= index && static_cast<size_t>(index) <= verdefnum_,
                 "index out of range");
  const ElfW(Verdef) *version_definition = verdef_;
  while (version_definition->vd_ndx < index && version_definition->vd_next) {
    const char *const version_definition_as_char =
        reinterpret_cast<const char *>(version_definition);
    version_definition =
        reinterpret_cast<const ElfW(Verdef) *>(version_definition_as_char +
                                               version_definition->vd_next);
  }
  return version_definition->vd_ndx == index ? version_definition : nullptr;
}

const ElfW(Verdaux) *ElfMemImage::GetVerdefAux(
    const ElfW(Verdef) *verdef) const {
  return reinterpret_cast<const ElfW(Verdaux) *>(verdef+1);
}

const char *ElfMemImage::GetVerstr(ElfW(Word) offset) const {
  ABSL_RAW_CHECK(offset < strsize_, "offset out of range");
  return dynstr_ + offset;
}

void ElfMemImage::Init(const void *base) {
  ehdr_      = nullptr;
  dynsym_    = nullptr;
  dynstr_    = nullptr;
  versym_    = nullptr;
  verdef_    = nullptr;
  num_syms_ = 0;
  strsize_   = 0;
  verdefnum_ = 0;
  // Sentinel: PT_LOAD .p_vaddr can't possibly be this.
  link_base_ = ~ElfW(Addr){0};  // NOLINT(readability/braces)
  if (!base) {
    return;
  }
  const char *const base_as_char = reinterpret_cast<const char *>(base);
  if (base_as_char[EI_MAG0] != ELFMAG0 || base_as_char[EI_MAG1] != ELFMAG1 ||
      base_as_char[EI_MAG2] != ELFMAG2 || base_as_char[EI_MAG3] != ELFMAG3) {
    assert(false);
    return;
  }
  int elf_class = base_as_char[EI_CLASS];
  if (elf_class != kElfClass) {
    assert(false);
    return;
  }
  switch (base_as_char[EI_DATA]) {
    case ELFDATA2LSB: {
#ifndef ABSL_IS_LITTLE_ENDIAN
      assert(false);
      return;
#endif
      break;
    }
    case ELFDATA2MSB: {
#ifndef ABSL_IS_BIG_ENDIAN
      assert(false);
      return;
#endif
      break;
    }
    default: {
      assert(false);
      return;
    }
  }

  ehdr_ = reinterpret_cast<const ElfW(Ehdr) *>(base);
  const ElfW(Phdr) *dynamic_program_header = nullptr;
  for (int i = 0; i < ehdr_->e_phnum; ++i) {
    const ElfW(Phdr) *const program_header = GetPhdr(i);
    switch (program_header->p_type) {
      case PT_LOAD:
        if (!~link_base_) {
          link_base_ = program_header->p_vaddr;
        }
        break;
      case PT_DYNAMIC:
        dynamic_program_header = program_header;
        break;
    }
  }
  if (!~link_base_ || !dynamic_program_header) {
    assert(false);
    // Mark this image as not present. Can not recur infinitely.
    Init(nullptr);
    return;
  }
  ptrdiff_t relocation =
      base_as_char - reinterpret_cast<const char *>(link_base_);
  ElfW(Dyn)* dynamic_entry = reinterpret_cast<ElfW(Dyn)*>(
      static_cast<intptr_t>(dynamic_program_header->p_vaddr) + relocation);
  uint32_t *sysv_hash = nullptr;
  uint32_t *gnu_hash = nullptr;
  for (; dynamic_entry->d_tag != DT_NULL; ++dynamic_entry) {
    const auto value =
        static_cast<intptr_t>(dynamic_entry->d_un.d_val) + relocation;
    switch (dynamic_entry->d_tag) {
      case DT_HASH:
        sysv_hash = reinterpret_cast<uint32_t *>(value);
        break;
      case DT_GNU_HASH:
        gnu_hash = reinterpret_cast<uint32_t *>(value);
        break;
      case DT_SYMTAB:
        dynsym_ = reinterpret_cast<ElfW(Sym) *>(value);
        break;
      case DT_STRTAB:
        dynstr_ = reinterpret_cast<const char *>(value);
        break;
      case DT_VERSYM:
        versym_ = reinterpret_cast<ElfW(Versym) *>(value);
        break;
      case DT_VERDEF:
        verdef_ = reinterpret_cast<ElfW(Verdef) *>(value);
        break;
      case DT_VERDEFNUM:
        verdefnum_ = static_cast<size_t>(dynamic_entry->d_un.d_val);
        break;
      case DT_STRSZ:
        strsize_ = static_cast<size_t>(dynamic_entry->d_un.d_val);
        break;
      default:
        // Unrecognized entries explicitly ignored.
        break;
    }
  }
  if ((!sysv_hash && !gnu_hash) || !dynsym_ || !dynstr_ || !versym_ ||
      !verdef_ || !verdefnum_ || !strsize_) {
    assert(false);  // invalid VDSO
    // Mark this image as not present. Can not recur infinitely.
    Init(nullptr);
    return;
  }
  if (sysv_hash) {
    num_syms_ = sysv_hash[1];
  } else {
    assert(gnu_hash);
    // Compute the number of symbols for DT_GNU_HASH, which is specified by
    // https://sourceware.org/gnu-gabi/program-loading-and-dynamic-linking.txt
    uint32_t nbuckets = gnu_hash[0];
    // The buckets array is located after the header (4 uint32) and the bloom
    // filter (size_t array of gnu_hash[2] elements).
    uint32_t *buckets = gnu_hash + 4 + sizeof(size_t) / 4 * gnu_hash[2];
    // Find the chain of the last non-empty bucket.
    uint32_t idx = 0;
    for (uint32_t i = nbuckets; i > 0;) {
      idx = buckets[--i];
      if (idx != 0) break;
    }
    if (idx != 0) {
      // Find the last element of the chain, which has an odd value.
      // Add one to get the number of symbols.
      uint32_t *chain = buckets + nbuckets - gnu_hash[1];
      while (chain[idx++] % 2 == 0) {
      }
    }
    num_syms_ = idx;
  }
}

bool ElfMemImage::LookupSymbol(const char *name,
                               const char *version,
                               int type,
                               SymbolInfo *info_out) const {
  for (const SymbolInfo& info : *this) {
    if (strcmp(info.name, name) == 0 && strcmp(info.version, version) == 0 &&
        ElfType(info.symbol) == type) {
      if (info_out) {
        *info_out = info;
      }
      return true;
    }
  }
  return false;
}

bool ElfMemImage::LookupSymbolByAddress(const void *address,
                                        SymbolInfo *info_out) const {
  for (const SymbolInfo& info : *this) {
    const char *const symbol_start =
        reinterpret_cast<const char *>(info.address);
    const char *const symbol_end = symbol_start + info.symbol->st_size;
    if (symbol_start <= address && address < symbol_end) {
      if (info_out) {
        // Client wants to know details for that symbol (the usual case).
        if (ElfBind(info.symbol) == STB_GLOBAL) {
          // Strong symbol; just return it.
          *info_out = info;
          return true;
        } else {
          // Weak or local. Record it, but keep looking for a strong one.
          *info_out = info;
        }
      } else {
        // Client only cares if there is an overlapping symbol.
        return true;
      }
    }
  }
  return false;
}

ElfMemImage::SymbolIterator::SymbolIterator(const void *const image,
                                            uint32_t index)
    : index_(index), image_(image) {}

const ElfMemImage::SymbolInfo *ElfMemImage::SymbolIterator::operator->() const {
  return &info_;
}

const ElfMemImage::SymbolInfo& ElfMemImage::SymbolIterator::operator*() const {
  return info_;
}

bool ElfMemImage::SymbolIterator::operator==(const SymbolIterator &rhs) const {
  return this->image_ == rhs.image_ && this->index_ == rhs.index_;
}

bool ElfMemImage::SymbolIterator::operator!=(const SymbolIterator &rhs) const {
  return !(*this == rhs);
}

ElfMemImage::SymbolIterator &ElfMemImage::SymbolIterator::operator++() {
  this->Update(1);
  return *this;
}

ElfMemImage::SymbolIterator ElfMemImage::begin() const {
  SymbolIterator it(this, 0);
  it.Update(0);
  return it;
}

ElfMemImage::SymbolIterator ElfMemImage::end() const {
  return SymbolIterator(this, GetNumSymbols());
}

void ElfMemImage::SymbolIterator::Update(uint32_t increment) {
  const ElfMemImage *image = reinterpret_cast<const ElfMemImage *>(image_);
  ABSL_RAW_CHECK(image->IsPresent() || increment == 0, "");
  if (!image->IsPresent()) {
    return;
  }
  index_ += increment;
  if (index_ >= image->GetNumSymbols()) {
    index_ = image->GetNumSymbols();
    return;
  }
  const ElfW(Sym)    *symbol = image->GetDynsym(index_);
  const ElfW(Versym) *version_symbol = image->GetVersym(index_);
  ABSL_RAW_CHECK(symbol && version_symbol, "");
  const char *const symbol_name = image->GetDynstr(symbol->st_name);
#if defined(__NetBSD__)
  const int version_index = version_symbol->vs_vers & VERSYM_VERSION;
#else
  const ElfW(Versym) version_index = version_symbol[0] & VERSYM_VERSION;
#endif
  const ElfW(Verdef) *version_definition = nullptr;
  const char *version_name = "";
  if (symbol->st_shndx == SHN_UNDEF) {
    // Undefined symbols reference DT_VERNEED, not DT_VERDEF, and
    // version_index could well be greater than verdefnum_, so calling
    // GetVerdef(version_index) may trigger assertion.
  } else {
    version_definition = image->GetVerdef(version_index);
  }
  if (version_definition) {
    // I am expecting 1 or 2 auxiliary entries: 1 for the version itself,
    // optional 2nd if the version has a parent.
    ABSL_RAW_CHECK(
        version_definition->vd_cnt == 1 || version_definition->vd_cnt == 2,
        "wrong number of entries");
    const ElfW(Verdaux) *version_aux = image->GetVerdefAux(version_definition);
    version_name = image->GetVerstr(version_aux->vda_name);
  }
  info_.name    = symbol_name;
  info_.version = version_name;
  info_.address = image->GetSymAddr(symbol);
  info_.symbol  = symbol;
}

}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_HAVE_ELF_MEM_IMAGE
                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/internal/elf_mem_image.h                  0000664 0000000 0000000 00000011462 14746647661 0030030 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * Copyright 2017 The Abseil Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Allow dynamic symbol lookup for in-memory Elf images.

#ifndef ABSL_DEBUGGING_INTERNAL_ELF_MEM_IMAGE_H_
#define ABSL_DEBUGGING_INTERNAL_ELF_MEM_IMAGE_H_

// Including this will define the __GLIBC__ macro if glibc is being
// used.
#include <climits>
#include <cstdint>

#include "absl/base/config.h"

// Maybe one day we can rewrite this file not to require the elf
// symbol extensions in glibc, but for right now we need them.
#ifdef ABSL_HAVE_ELF_MEM_IMAGE
#error ABSL_HAVE_ELF_MEM_IMAGE cannot be directly set
#endif

#if defined(__ELF__) && !defined(__OpenBSD__) && !defined(__QNX__) && \
    !defined(__native_client__) && !defined(__asmjs__) &&             \
    !defined(__wasm__) && !defined(__HAIKU__) && !defined(__sun) &&   \
    !defined(__VXWORKS__) && !defined(__hexagon__)
#define ABSL_HAVE_ELF_MEM_IMAGE 1
#endif

#ifdef ABSL_HAVE_ELF_MEM_IMAGE

#include <link.h>  // for ElfW

#if defined(__FreeBSD__) && !defined(ElfW)
#define ElfW(x) __ElfN(x)
#endif

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace debugging_internal {

// An in-memory ELF image (may not exist on disk).
class ElfMemImage {
 private:
  // Sentinel: there could never be an elf image at &kInvalidBaseSentinel.
  static const int kInvalidBaseSentinel;

 public:
  // Sentinel: there could never be an elf image at this address.
  static constexpr const void *const kInvalidBase =
    static_cast<const void*>(&kInvalidBaseSentinel);

  // Information about a single vdso symbol.
  // All pointers are into .dynsym, .dynstr, or .text of the VDSO.
  // Do not free() them or modify through them.
  struct SymbolInfo {
    const char      *name;      // E.g. "__vdso_getcpu"
    const char      *version;   // E.g. "LINUX_2.6", could be ""
                                // for unversioned symbol.
    const void      *address;   // Relocated symbol address.
    const ElfW(Sym) *symbol;    // Symbol in the dynamic symbol table.
  };

  // Supports iteration over all dynamic symbols.
  class SymbolIterator {
   public:
    friend class ElfMemImage;
    const SymbolInfo *operator->() const;
    const SymbolInfo &operator*() const;
    SymbolIterator& operator++();
    bool operator!=(const SymbolIterator &rhs) const;
    bool operator==(const SymbolIterator &rhs) const;
   private:
    SymbolIterator(const void *const image, uint32_t index);
    void Update(uint32_t incr);
    SymbolInfo info_;
    uint32_t index_;
    const void *const image_;
  };


  explicit ElfMemImage(const void *base);
  void                 Init(const void *base);
  bool                 IsPresent() const { return ehdr_ != nullptr; }
  const ElfW(Phdr)*    GetPhdr(int index) const;
  const ElfW(Sym) * GetDynsym(uint32_t index) const;
  const ElfW(Versym)*  GetVersym(uint32_t index) const;
  const ElfW(Verdef)*  GetVerdef(int index) const;
  const ElfW(Verdaux)* GetVerdefAux(const ElfW(Verdef) *verdef) const;
  const char*          GetDynstr(ElfW(Word) offset) const;
  const void*          GetSymAddr(const ElfW(Sym) *sym) const;
  const char*          GetVerstr(ElfW(Word) offset) const;
  uint32_t GetNumSymbols() const;

  SymbolIterator begin() const;
  SymbolIterator end() const;

  // Look up versioned dynamic symbol in the image.
  // Returns false if image is not present, or doesn't contain given
  // symbol/version/type combination.
  // If info_out is non-null, additional details are filled in.
  bool LookupSymbol(const char *name, const char *version,
                    int symbol_type, SymbolInfo *info_out) const;

  // Find info about symbol (if any) which overlaps given address.
  // Returns true if symbol was found; false if image isn't present
  // or doesn't have a symbol overlapping given address.
  // If info_out is non-null, additional details are filled in.
  bool LookupSymbolByAddress(const void *address, SymbolInfo *info_out) const;

 private:
  const ElfW(Ehdr) *ehdr_;
  const ElfW(Sym) *dynsym_;
  const ElfW(Versym) *versym_;
  const ElfW(Verdef) *verdef_;
  const char *dynstr_;
  uint32_t num_syms_;
  size_t strsize_;
  size_t verdefnum_;
  ElfW(Addr) link_base_;     // Link-time base (p_vaddr of first PT_LOAD).
};

}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_HAVE_ELF_MEM_IMAGE

#endif  // ABSL_DEBUGGING_INTERNAL_ELF_MEM_IMAGE_H_
                                                                                                                                                                                                              node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/internal/examine_stack.cc                 0000664 0000000 0000000 00000026275 14746647661 0030243 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
// Copyright 2018 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

#include "absl/debugging/internal/examine_stack.h"

#ifndef _WIN32
#include <unistd.h>
#endif

#include "absl/base/config.h"

#ifdef ABSL_HAVE_MMAP
#include <sys/mman.h>
#if defined(MAP_ANON) && !defined(MAP_ANONYMOUS)
#define MAP_ANONYMOUS MAP_ANON
#endif
#endif

#if defined(__linux__) || defined(__APPLE__)
#include <sys/ucontext.h>
#endif

#include <csignal>
#include <cstdio>

#include "absl/base/attributes.h"
#include "absl/base/internal/raw_logging.h"
#include "absl/base/macros.h"
#include "absl/debugging/stacktrace.h"
#include "absl/debugging/symbolize.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace debugging_internal {

namespace {
constexpr int kDefaultDumpStackFramesLimit = 64;
// The %p field width for printf() functions is two characters per byte,
// and two extra for the leading "0x".
constexpr int kPrintfPointerFieldWidth = 2 + 2 * sizeof(void*);

ABSL_CONST_INIT SymbolizeUrlEmitter debug_stack_trace_hook = nullptr;

// Async-signal safe mmap allocator.
void* Allocate(size_t num_bytes) {
#ifdef ABSL_HAVE_MMAP
  void* p = ::mmap(nullptr, num_bytes, PROT_READ | PROT_WRITE,
                   MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  return p == MAP_FAILED ? nullptr : p;
#else
  (void)num_bytes;
  return nullptr;
#endif  // ABSL_HAVE_MMAP
}

void Deallocate(void* p, size_t size) {
#ifdef ABSL_HAVE_MMAP
  ::munmap(p, size);
#else
  (void)p;
  (void)size;
#endif  // ABSL_HAVE_MMAP
}

// Print a program counter only.
void DumpPC(OutputWriter* writer, void* writer_arg, void* const pc,
            const char* const prefix) {
  char buf[100];
  snprintf(buf, sizeof(buf), "%s@ %*p\n", prefix, kPrintfPointerFieldWidth, pc);
  writer(buf, writer_arg);
}

// Print a program counter and the corresponding stack frame size.
void DumpPCAndFrameSize(OutputWriter* writer, void* writer_arg, void* const pc,
                        int framesize, const char* const prefix) {
  char buf[100];
  if (framesize <= 0) {
    snprintf(buf, sizeof(buf), "%s@ %*p  (unknown)\n", prefix,
             kPrintfPointerFieldWidth, pc);
  } else {
    snprintf(buf, sizeof(buf), "%s@ %*p  %9d\n", prefix,
             kPrintfPointerFieldWidth, pc, framesize);
  }
  writer(buf, writer_arg);
}

// Print a program counter and the corresponding symbol.
void DumpPCAndSymbol(OutputWriter* writer, void* writer_arg, void* const pc,
                     const char* const prefix) {
  char tmp[1024];
  const char* symbol = "(unknown)";
  // Symbolizes the previous address of pc because pc may be in the
  // next function.  The overrun happens when the function ends with
  // a call to a function annotated noreturn (e.g. CHECK).
  // If symbolization of pc-1 fails, also try pc on the off-chance
  // that we crashed on the first instruction of a function (that
  // actually happens very often for e.g. __restore_rt).
  const uintptr_t prev_pc = reinterpret_cast<uintptr_t>(pc) - 1;
  if (absl::Symbolize(reinterpret_cast<const char*>(prev_pc), tmp,
                      sizeof(tmp)) ||
      absl::Symbolize(pc, tmp, sizeof(tmp))) {
    symbol = tmp;
  }
  char buf[1024];
  snprintf(buf, sizeof(buf), "%s@ %*p  %s\n", prefix, kPrintfPointerFieldWidth,
           pc, symbol);
  writer(buf, writer_arg);
}

// Print a program counter, its stack frame size, and its symbol name.
// Note that there is a separate symbolize_pc argument. Return addresses may be
// at the end of the function, and this allows the caller to back up from pc if
// appropriate.
void DumpPCAndFrameSizeAndSymbol(OutputWriter* writer, void* writer_arg,
                                 void* const pc, void* const symbolize_pc,
                                 int framesize, const char* const prefix) {
  char tmp[1024];
  const char* symbol = "(unknown)";
  if (absl::Symbolize(symbolize_pc, tmp, sizeof(tmp))) {
    symbol = tmp;
  }
  char buf[1024];
  if (framesize <= 0) {
    snprintf(buf, sizeof(buf), "%s@ %*p  (unknown)  %s\n", prefix,
             kPrintfPointerFieldWidth, pc, symbol);
  } else {
    snprintf(buf, sizeof(buf), "%s@ %*p  %9d  %s\n", prefix,
             kPrintfPointerFieldWidth, pc, framesize, symbol);
  }
  writer(buf, writer_arg);
}

}  // namespace

void RegisterDebugStackTraceHook(SymbolizeUrlEmitter hook) {
  debug_stack_trace_hook = hook;
}

SymbolizeUrlEmitter GetDebugStackTraceHook() { return debug_stack_trace_hook; }

// Returns the program counter from signal context, nullptr if
// unknown. vuc is a ucontext_t*. We use void* to avoid the use of
// ucontext_t on non-POSIX systems.
void* GetProgramCounter(void* const vuc) {
#ifdef __linux__
  if (vuc != nullptr) {
    ucontext_t* context = reinterpret_cast<ucontext_t*>(vuc);
#if defined(__aarch64__)
    return reinterpret_cast<void*>(context->uc_mcontext.pc);
#elif defined(__alpha__)
    return reinterpret_cast<void*>(context->uc_mcontext.sc_pc);
#elif defined(__arm__)
    return reinterpret_cast<void*>(context->uc_mcontext.arm_pc);
#elif defined(__hppa__)
    return reinterpret_cast<void*>(context->uc_mcontext.sc_iaoq[0]);
#elif defined(__i386__)
    if (14 < ABSL_ARRAYSIZE(context->uc_mcontext.gregs))
      return reinterpret_cast<void*>(context->uc_mcontext.gregs[14]);
#elif defined(__ia64__)
    return reinterpret_cast<void*>(context->uc_mcontext.sc_ip);
#elif defined(__m68k__)
    return reinterpret_cast<void*>(context->uc_mcontext.gregs[16]);
#elif defined(__mips__)
    return reinterpret_cast<void*>(context->uc_mcontext.pc);
#elif defined(__powerpc64__)
    return reinterpret_cast<void*>(context->uc_mcontext.gp_regs[32]);
#elif defined(__powerpc__)
    return reinterpret_cast<void*>(context->uc_mcontext.uc_regs->gregs[32]);
#elif defined(__riscv)
    return reinterpret_cast<void*>(context->uc_mcontext.__gregs[REG_PC]);
#elif defined(__s390__) && !defined(__s390x__)
    return reinterpret_cast<void*>(context->uc_mcontext.psw.addr & 0x7fffffff);
#elif defined(__s390__) && defined(__s390x__)
    return reinterpret_cast<void*>(context->uc_mcontext.psw.addr);
#elif defined(__sh__)
    return reinterpret_cast<void*>(context->uc_mcontext.pc);
#elif defined(__sparc__) && !defined(__arch64__)
    return reinterpret_cast<void*>(context->uc_mcontext.gregs[19]);
#elif defined(__sparc__) && defined(__arch64__)
    return reinterpret_cast<void*>(context->uc_mcontext.mc_gregs[19]);
#elif defined(__x86_64__)
    if (16 < ABSL_ARRAYSIZE(context->uc_mcontext.gregs))
      return reinterpret_cast<void*>(context->uc_mcontext.gregs[16]);
#elif defined(__e2k__)
    return reinterpret_cast<void*>(context->uc_mcontext.cr0_hi);
#elif defined(__loongarch__)
    return reinterpret_cast<void*>(context->uc_mcontext.__pc);
#else
#error "Undefined Architecture."
#endif
  }
#elif defined(__APPLE__)
  if (vuc != nullptr) {
    ucontext_t* signal_ucontext = reinterpret_cast<ucontext_t*>(vuc);
#if defined(__aarch64__)
    return reinterpret_cast<void*>(
        __darwin_arm_thread_state64_get_pc(signal_ucontext->uc_mcontext->__ss));
#elif defined(__arm__)
#if __DARWIN_UNIX03
    return reinterpret_cast<void*>(signal_ucontext->uc_mcontext->__ss.__pc);
#else
    return reinterpret_cast<void*>(signal_ucontext->uc_mcontext->ss.pc);
#endif
#elif defined(__i386__)
#if __DARWIN_UNIX03
    return reinterpret_cast<void*>(signal_ucontext->uc_mcontext->__ss.__eip);
#else
    return reinterpret_cast<void*>(signal_ucontext->uc_mcontext->ss.eip);
#endif
#elif defined(__x86_64__)
#if __DARWIN_UNIX03
    return reinterpret_cast<void*>(signal_ucontext->uc_mcontext->__ss.__rip);
#else
    return reinterpret_cast<void*>(signal_ucontext->uc_mcontext->ss.rip);
#endif
#endif
  }
#elif defined(__akaros__)
  auto* ctx = reinterpret_cast<struct user_context*>(vuc);
  return reinterpret_cast<void*>(get_user_ctx_pc(ctx));
#endif
  static_cast<void>(vuc);
  return nullptr;
}

void DumpPCAndFrameSizesAndStackTrace(void* const pc, void* const stack[],
                                      int frame_sizes[], int depth,
                                      int min_dropped_frames,
                                      bool symbolize_stacktrace,
                                      OutputWriter* writer, void* writer_arg) {
  if (pc != nullptr) {
    // We don't know the stack frame size for PC, use 0.
    if (symbolize_stacktrace) {
      DumpPCAndFrameSizeAndSymbol(writer, writer_arg, pc, pc, 0, "PC: ");
    } else {
      DumpPCAndFrameSize(writer, writer_arg, pc, 0, "PC: ");
    }
  }
  for (int i = 0; i < depth; i++) {
    if (symbolize_stacktrace) {
      // Pass the previous address of pc as the symbol address because pc is a
      // return address, and an overrun may occur when the function ends with a
      // call to a function annotated noreturn (e.g. CHECK). Note that we don't
      // do this for pc above, as the adjustment is only correct for return
      // addresses.
      DumpPCAndFrameSizeAndSymbol(writer, writer_arg, stack[i],
                                  reinterpret_cast<char*>(stack[i]) - 1,
                                  frame_sizes[i], "    ");
    } else {
      DumpPCAndFrameSize(writer, writer_arg, stack[i], frame_sizes[i], "    ");
    }
  }
  if (min_dropped_frames > 0) {
    char buf[100];
    snprintf(buf, sizeof(buf), "    @ ... and at least %d more frames\n",
             min_dropped_frames);
    writer(buf, writer_arg);
  }
}

// Dump current stack trace as directed by writer.
// Make sure this function is not inlined to avoid skipping too many top frames.
ABSL_ATTRIBUTE_NOINLINE
void DumpStackTrace(int min_dropped_frames, int max_num_frames,
                    bool symbolize_stacktrace, OutputWriter* writer,
                    void* writer_arg) {
  // Print stack trace
  void* stack_buf[kDefaultDumpStackFramesLimit];
  void** stack = stack_buf;
  int num_stack = kDefaultDumpStackFramesLimit;
  size_t allocated_bytes = 0;

  if (num_stack >= max_num_frames) {
    // User requested fewer frames than we already have space for.
    num_stack = max_num_frames;
  } else {
    const size_t needed_bytes =
        static_cast<size_t>(max_num_frames) * sizeof(stack[0]);
    void* p = Allocate(needed_bytes);
    if (p != nullptr) {  // We got the space.
      num_stack = max_num_frames;
      stack = reinterpret_cast<void**>(p);
      allocated_bytes = needed_bytes;
    }
  }

  int depth = absl::GetStackTrace(stack, num_stack, min_dropped_frames + 1);
  for (int i = 0; i < depth; i++) {
    if (symbolize_stacktrace) {
      DumpPCAndSymbol(writer, writer_arg, stack[static_cast<size_t>(i)],
                      "    ");
    } else {
      DumpPC(writer, writer_arg, stack[static_cast<size_t>(i)], "    ");
    }
  }

  auto hook = GetDebugStackTraceHook();
  if (hook != nullptr) {
    (*hook)(stack, depth, writer, writer_arg);
  }

  if (allocated_bytes != 0) Deallocate(stack, allocated_bytes);
}

}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/internal/examine_stack.h                  0000664 0000000 0000000 00000005007 14746647661 0030073 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
// Copyright 2018 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

#ifndef ABSL_DEBUGGING_INTERNAL_EXAMINE_STACK_H_
#define ABSL_DEBUGGING_INTERNAL_EXAMINE_STACK_H_

#include "absl/base/config.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace debugging_internal {

// Type of function used for printing in stack trace dumping, etc.
// We avoid closures to keep things simple.
typedef void OutputWriter(const char*, void*);

// RegisterDebugStackTraceHook() allows to register a single routine
// `hook` that is called each time DumpStackTrace() is called.
// `hook` may be called from a signal handler.
typedef void (*SymbolizeUrlEmitter)(void* const stack[], int depth,
                                    OutputWriter* writer, void* writer_arg);

// Registration of SymbolizeUrlEmitter for use inside of a signal handler.
// This is inherently unsafe and must be signal safe code.
void RegisterDebugStackTraceHook(SymbolizeUrlEmitter hook);
SymbolizeUrlEmitter GetDebugStackTraceHook();

// Returns the program counter from signal context, or nullptr if
// unknown. `vuc` is a ucontext_t*. We use void* to avoid the use of
// ucontext_t on non-POSIX systems.
void* GetProgramCounter(void* const vuc);

// Uses `writer` to dump the program counter, stack trace, and stack
// frame sizes.
void DumpPCAndFrameSizesAndStackTrace(void* const pc, void* const stack[],
                                      int frame_sizes[], int depth,
                                      int min_dropped_frames,
                                      bool symbolize_stacktrace,
                                      OutputWriter* writer, void* writer_arg);

// Dump current stack trace omitting the topmost `min_dropped_frames` stack
// frames.
void DumpStackTrace(int min_dropped_frames, int max_num_frames,
                    bool symbolize_stacktrace, OutputWriter* writer,
                    void* writer_arg);

}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_DEBUGGING_INTERNAL_EXAMINE_STACK_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/internal/stack_consumption.cc             0000664 0000000 0000000 00000020222 14746647661 0031155 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
// Copyright 2018 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/debugging/internal/stack_consumption.h"

#ifdef ABSL_INTERNAL_HAVE_DEBUGGING_STACK_CONSUMPTION

#include <signal.h>
#include <string.h>
#include <sys/mman.h>
#include <unistd.h>

#include "absl/base/attributes.h"
#include "absl/base/internal/raw_logging.h"

#if defined(MAP_ANON) && !defined(MAP_ANONYMOUS)
#define MAP_ANONYMOUS MAP_ANON
#endif

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace debugging_internal {
namespace {

// This code requires that we know the direction in which the stack
// grows. It is commonly believed that this can be detected by putting
// a variable on the stack and then passing its address to a function
// that compares the address of this variable to the address of a
// variable on the function's own stack. However, this is unspecified
// behavior in C++: If two pointers p and q of the same type point to
// different objects that are not members of the same object or
// elements of the same array or to different functions, or if only
// one of them is null, the results of p<q, p>q, p<=q, and p>=q are
// unspecified. Therefore, instead we hardcode the direction of the
// stack on platforms we know about.
#if defined(__i386__) || defined(__x86_64__) || defined(__ppc__) || \
    defined(__aarch64__) || defined(__riscv)
constexpr bool kStackGrowsDown = true;
#else
#error Need to define kStackGrowsDown
#endif

// To measure the stack footprint of some code, we create a signal handler
// (for SIGUSR2 say) that exercises this code on an alternate stack. This
// alternate stack is initialized to some known pattern (0x55, 0x55, 0x55,
// ...). We then self-send this signal, and after the signal handler returns,
// look at the alternate stack buffer to see what portion has been touched.
//
// This trick gives us the the stack footprint of the signal handler.  But the
// signal handler, even before the code for it is exercised, consumes some
// stack already. We however only want the stack usage of the code inside the
// signal handler. To measure this accurately, we install two signal handlers:
// one that does nothing and just returns, and the user-provided signal
// handler. The difference between the stack consumption of these two signals
// handlers should give us the stack foorprint of interest.

void EmptySignalHandler(int) {}

// This is arbitrary value, and could be increase further, at the cost of
// memset()ting it all to known sentinel value.
constexpr int kAlternateStackSize = 64 << 10;  // 64KiB

constexpr int kSafetyMargin = 32;
constexpr char kAlternateStackFillValue = 0x55;

// These helper functions look at the alternate stack buffer, and figure
// out what portion of this buffer has been touched - this is the stack
// consumption of the signal handler running on this alternate stack.
// This function will return -1 if the alternate stack buffer has not been
// touched. It will abort the program if the buffer has overflowed or is about
// to overflow.
int GetStackConsumption(const void* const altstack) {
  const char* begin;
  int increment;
  if (kStackGrowsDown) {
    begin = reinterpret_cast<const char*>(altstack);
    increment = 1;
  } else {
    begin = reinterpret_cast<const char*>(altstack) + kAlternateStackSize - 1;
    increment = -1;
  }

  for (int usage_count = kAlternateStackSize; usage_count > 0; --usage_count) {
    if (*begin != kAlternateStackFillValue) {
      ABSL_RAW_CHECK(usage_count <= kAlternateStackSize - kSafetyMargin,
                     "Buffer has overflowed or is about to overflow");
      return usage_count;
    }
    begin += increment;
  }

  ABSL_RAW_LOG(FATAL, "Unreachable code");
  return -1;
}

}  // namespace

int GetSignalHandlerStackConsumption(void (*signal_handler)(int)) {
  // The alt-signal-stack cannot be heap allocated because there is a
  // bug in glibc-2.2 where some signal handler setup code looks at the
  // current stack pointer to figure out what thread is currently running.
  // Therefore, the alternate stack must be allocated from the main stack
  // itself.
  void* altstack = mmap(nullptr, kAlternateStackSize, PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  ABSL_RAW_CHECK(altstack != MAP_FAILED, "mmap() failed");

  // Set up the alt-signal-stack (and save the older one).
  stack_t sigstk;
  memset(&sigstk, 0, sizeof(sigstk));
  sigstk.ss_sp = altstack;
  sigstk.ss_size = kAlternateStackSize;
  sigstk.ss_flags = 0;
  stack_t old_sigstk;
  memset(&old_sigstk, 0, sizeof(old_sigstk));
  ABSL_RAW_CHECK(sigaltstack(&sigstk, &old_sigstk) == 0,
                 "sigaltstack() failed");

  // Set up SIGUSR1 and SIGUSR2 signal handlers (and save the older ones).
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  struct sigaction old_sa1, old_sa2;
  sigemptyset(&sa.sa_mask);
  sa.sa_flags = SA_ONSTACK;

  // SIGUSR1 maps to EmptySignalHandler.
  sa.sa_handler = EmptySignalHandler;
  ABSL_RAW_CHECK(sigaction(SIGUSR1, &sa, &old_sa1) == 0, "sigaction() failed");

  // SIGUSR2 maps to signal_handler.
  sa.sa_handler = signal_handler;
  ABSL_RAW_CHECK(sigaction(SIGUSR2, &sa, &old_sa2) == 0, "sigaction() failed");

  // Send SIGUSR1 signal and measure the stack consumption of the empty
  // signal handler.
  // The first signal might use more stack space. Run once and ignore the
  // results to get that out of the way.
  ABSL_RAW_CHECK(kill(getpid(), SIGUSR1) == 0, "kill() failed");

  memset(altstack, kAlternateStackFillValue, kAlternateStackSize);
  ABSL_RAW_CHECK(kill(getpid(), SIGUSR1) == 0, "kill() failed");
  int base_stack_consumption = GetStackConsumption(altstack);

  // Send SIGUSR2 signal and measure the stack consumption of signal_handler.
  ABSL_RAW_CHECK(kill(getpid(), SIGUSR2) == 0, "kill() failed");
  int signal_handler_stack_consumption = GetStackConsumption(altstack);

  // Now restore the old alt-signal-stack and signal handlers.
  if (old_sigstk.ss_sp == nullptr && old_sigstk.ss_size == 0 &&
      (old_sigstk.ss_flags & SS_DISABLE)) {
    // https://git.musl-libc.org/cgit/musl/commit/src/signal/sigaltstack.c?id=7829f42a2c8944555439380498ab8b924d0f2070
    // The original stack has ss_size==0 and ss_flags==SS_DISABLE, but some
    // versions of musl have a bug that rejects ss_size==0. Work around this by
    // setting ss_size to MINSIGSTKSZ, which should be ignored by the kernel
    // when SS_DISABLE is set.
    old_sigstk.ss_size = static_cast<size_t>(MINSIGSTKSZ);
  }
  ABSL_RAW_CHECK(sigaltstack(&old_sigstk, nullptr) == 0,
                 "sigaltstack() failed");
  ABSL_RAW_CHECK(sigaction(SIGUSR1, &old_sa1, nullptr) == 0,
                 "sigaction() failed");
  ABSL_RAW_CHECK(sigaction(SIGUSR2, &old_sa2, nullptr) == 0,
                 "sigaction() failed");

  ABSL_RAW_CHECK(munmap(altstack, kAlternateStackSize) == 0, "munmap() failed");
  if (signal_handler_stack_consumption != -1 && base_stack_consumption != -1) {
    return signal_handler_stack_consumption - base_stack_consumption;
  }
  return -1;
}

}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl

#else

// https://github.com/abseil/abseil-cpp/issues/1465
// CMake builds on Apple platforms error when libraries are empty.
// Our CMake configuration can avoid this error on header-only libraries,
// but since this library is conditionally empty, including a single
// variable is an easy workaround.
#ifdef __APPLE__
namespace absl {
ABSL_NAMESPACE_BEGIN
namespace debugging_internal {
extern const char kAvoidEmptyStackConsumptionLibraryWarning;
const char kAvoidEmptyStackConsumptionLibraryWarning = 0;
}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl
#endif  // __APPLE__

#endif  // ABSL_INTERNAL_HAVE_DEBUGGING_STACK_CONSUMPTION
                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/internal/stack_consumption.h              0000664 0000000 0000000 00000004037 14746647661 0031025 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
// Copyright 2018 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Helper function for measuring stack consumption of signal handlers.

#ifndef ABSL_DEBUGGING_INTERNAL_STACK_CONSUMPTION_H_
#define ABSL_DEBUGGING_INTERNAL_STACK_CONSUMPTION_H_

#include "absl/base/config.h"

// The code in this module is not portable.
// Use this feature test macro to detect its availability.
#ifdef ABSL_INTERNAL_HAVE_DEBUGGING_STACK_CONSUMPTION
#error ABSL_INTERNAL_HAVE_DEBUGGING_STACK_CONSUMPTION cannot be set directly
#elif !defined(__APPLE__) && !defined(_WIN32) && !defined(__Fuchsia__) && \
    (defined(__i386__) || defined(__x86_64__) || defined(__ppc__) || \
     defined(__aarch64__) || defined(__riscv))
#define ABSL_INTERNAL_HAVE_DEBUGGING_STACK_CONSUMPTION 1

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace debugging_internal {

// Returns the stack consumption in bytes for the code exercised by
// signal_handler.  To measure stack consumption, signal_handler is registered
// as a signal handler, so the code that it exercises must be async-signal
// safe.  The argument of signal_handler is an implementation detail of signal
// handlers and should ignored by the code for signal_handler.  Use global
// variables to pass information between your test code and signal_handler.
int GetSignalHandlerStackConsumption(void (*signal_handler)(int));

}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_INTERNAL_HAVE_DEBUGGING_STACK_CONSUMPTION

#endif  // ABSL_DEBUGGING_INTERNAL_STACK_CONSUMPTION_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/internal/stack_consumption_test.cc        0000664 0000000 0000000 00000002653 14746647661 0032224 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
// Copyright 2018 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/debugging/internal/stack_consumption.h"

#ifdef ABSL_INTERNAL_HAVE_DEBUGGING_STACK_CONSUMPTION

#include <string.h>

#include "gtest/gtest.h"
#include "absl/log/log.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace debugging_internal {
namespace {

static void SimpleSignalHandler(int signo) {
  char buf[100];
  memset(buf, 'a', sizeof(buf));

  // Never true, but prevents compiler from optimizing buf out.
  if (signo == 0) {
    LOG(INFO) << static_cast<void*>(buf);
  }
}

TEST(SignalHandlerStackConsumptionTest, MeasuresStackConsumption) {
  // Our handler should consume reasonable number of bytes.
  EXPECT_GE(GetSignalHandlerStackConsumption(SimpleSignalHandler), 100);
}

}  // namespace
}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_INTERNAL_HAVE_DEBUGGING_STACK_CONSUMPTION
                                                                                     node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/internal/stacktrace_aarch64-inl.inc       0000664 0000000 0000000 00000024644 14746647661 0032026 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #ifndef ABSL_DEBUGGING_INTERNAL_STACKTRACE_AARCH64_INL_H_
#define ABSL_DEBUGGING_INTERNAL_STACKTRACE_AARCH64_INL_H_

// Generate stack tracer for aarch64

#if defined(__linux__)
#include <signal.h>
#include <sys/mman.h>
#include <ucontext.h>
#include <unistd.h>
#endif

#include <atomic>
#include <cassert>
#include <cstdint>
#include <iostream>
#include <limits>

#include "absl/base/attributes.h"
#include "absl/debugging/internal/address_is_readable.h"
#include "absl/debugging/internal/vdso_support.h"  // a no-op on non-elf or non-glibc systems
#include "absl/debugging/stacktrace.h"

static const size_t kUnknownFrameSize = 0;
// Stack end to use when we don't know the actual stack end
// (effectively just the end of address space).
constexpr uintptr_t kUnknownStackEnd =
    std::numeric_limits<size_t>::max() - sizeof(void *);

#if defined(__linux__)
// Returns the address of the VDSO __kernel_rt_sigreturn function, if present.
static const unsigned char* GetKernelRtSigreturnAddress() {
  constexpr uintptr_t kImpossibleAddress = 1;
  ABSL_CONST_INIT static std::atomic<uintptr_t> memoized{kImpossibleAddress};
  uintptr_t address = memoized.load(std::memory_order_relaxed);
  if (address != kImpossibleAddress) {
    return reinterpret_cast<const unsigned char*>(address);
  }

  address = reinterpret_cast<uintptr_t>(nullptr);

#ifdef ABSL_HAVE_VDSO_SUPPORT
  absl::debugging_internal::VDSOSupport vdso;
  if (vdso.IsPresent()) {
    absl::debugging_internal::VDSOSupport::SymbolInfo symbol_info;
    auto lookup = [&](int type) {
      return vdso.LookupSymbol("__kernel_rt_sigreturn", "LINUX_2.6.39", type,
                               &symbol_info);
    };
    if ((!lookup(STT_FUNC) && !lookup(STT_NOTYPE)) ||
        symbol_info.address == nullptr) {
      // Unexpected: VDSO is present, yet the expected symbol is missing
      // or null.
      assert(false && "VDSO is present, but doesn't have expected symbol");
    } else {
      if (reinterpret_cast<uintptr_t>(symbol_info.address) !=
          kImpossibleAddress) {
        address = reinterpret_cast<uintptr_t>(symbol_info.address);
      } else {
        assert(false && "VDSO returned invalid address");
      }
    }
  }
#endif

  memoized.store(address, std::memory_order_relaxed);
  return reinterpret_cast<const unsigned char*>(address);
}
#endif  // __linux__

// Compute the size of a stack frame in [low..high).  We assume that
// low < high.  Return size of kUnknownFrameSize.
template<typename T>
static size_t ComputeStackFrameSize(const T* low,
                                           const T* high) {
  const char* low_char_ptr = reinterpret_cast<const char *>(low);
  const char* high_char_ptr = reinterpret_cast<const char *>(high);
  return low < high ? static_cast<size_t>(high_char_ptr - low_char_ptr)
                    : kUnknownFrameSize;
}

// Saves stack info that is expensive to calculate to avoid recalculating per frame.
struct StackInfo {
  uintptr_t stack_low;
  uintptr_t stack_high;
  uintptr_t sig_stack_low;
  uintptr_t sig_stack_high;
};

static bool InsideSignalStack(void** ptr, const StackInfo* stack_info) {
  uintptr_t comparable_ptr = reinterpret_cast<uintptr_t>(ptr);
  if (stack_info->sig_stack_high == kUnknownStackEnd)
    return false;
  return (comparable_ptr >= stack_info->sig_stack_low &&
          comparable_ptr < stack_info->sig_stack_high);
}

// Given a pointer to a stack frame, locate and return the calling
// stackframe, or return null if no stackframe can be found. Perform sanity
// checks (the strictness of which is controlled by the boolean parameter
// "STRICT_UNWINDING") to reduce the chance that a bad pointer is returned.
template<bool STRICT_UNWINDING, bool WITH_CONTEXT>
ABSL_ATTRIBUTE_NO_SANITIZE_ADDRESS  // May read random elements from stack.
ABSL_ATTRIBUTE_NO_SANITIZE_MEMORY  // May read random elements from stack.
static void **NextStackFrame(void **old_frame_pointer, const void *uc,
                             const StackInfo *stack_info) {
  void **new_frame_pointer = reinterpret_cast<void**>(*old_frame_pointer);

#if defined(__linux__)
  if (WITH_CONTEXT && uc != nullptr) {
    // Check to see if next frame's return address is __kernel_rt_sigreturn.
    if (old_frame_pointer[1] == GetKernelRtSigreturnAddress()) {
      const ucontext_t *ucv = static_cast<const ucontext_t *>(uc);
      // old_frame_pointer[0] is not suitable for unwinding, look at
      // ucontext to discover frame pointer before signal.
      void **const pre_signal_frame_pointer =
          reinterpret_cast<void **>(ucv->uc_mcontext.regs[29]);

      // The most recent signal always needs special handling to find the frame
      // pointer, but a nested signal does not.  If pre_signal_frame_pointer is
      // earlier in the stack than the old_frame_pointer, then use it. If it is
      // later, then we have already unwound through it and it needs no special
      // handling.
      if (pre_signal_frame_pointer >= old_frame_pointer) {
        new_frame_pointer = pre_signal_frame_pointer;
      }
  }
#endif

  // The frame pointer should be 8-byte aligned.
  if ((reinterpret_cast<uintptr_t>(new_frame_pointer) & 7) != 0)
    return nullptr;

  // Check that alleged frame pointer is actually readable. This is to
  // prevent "double fault" in case we hit the first fault due to e.g.
  // stack corruption.
  if (!absl::debugging_internal::AddressIsReadable(
          new_frame_pointer))
    return nullptr;
  }

  // Only check the size if both frames are in the same stack.
  if (InsideSignalStack(new_frame_pointer, stack_info) ==
      InsideSignalStack(old_frame_pointer, stack_info)) {
    // Check frame size.  In strict mode, we assume frames to be under
    // 100,000 bytes.  In non-strict mode, we relax the limit to 1MB.
    const size_t max_size = STRICT_UNWINDING ? 100000 : 1000000;
    const size_t frame_size =
        ComputeStackFrameSize(old_frame_pointer, new_frame_pointer);
    if (frame_size == kUnknownFrameSize)
       return nullptr;
    // A very large frame may mean corrupt memory or an erroneous frame
    // pointer. But also maybe just a plain-old large frame.  Assume that if the
    // frame is within a known stack, then it is valid.
    if (frame_size > max_size) {
      size_t stack_low = stack_info->stack_low;
      size_t stack_high = stack_info->stack_high;
      if (InsideSignalStack(new_frame_pointer, stack_info)) {
        stack_low = stack_info->sig_stack_low;
        stack_high = stack_info->sig_stack_high;
      }
      if (stack_high < kUnknownStackEnd &&
          static_cast<size_t>(getpagesize()) < stack_low) {
        const uintptr_t new_fp_u =
            reinterpret_cast<uintptr_t>(new_frame_pointer);
        // Stack bounds are known.
        if (!(stack_low < new_fp_u && new_fp_u <= stack_high)) {
          // new_frame_pointer is not within a known stack.
          return nullptr;
        }
      } else {
        // Stack bounds are unknown, prefer truncated stack to possible crash.
        return nullptr;
      }
    }
  }

  return new_frame_pointer;
}

template <bool IS_STACK_FRAMES, bool IS_WITH_CONTEXT>
// We count on the bottom frame being this one. See the comment
// at prev_return_address
ABSL_ATTRIBUTE_NOINLINE
ABSL_ATTRIBUTE_NO_SANITIZE_ADDRESS  // May read random elements from stack.
ABSL_ATTRIBUTE_NO_SANITIZE_MEMORY   // May read random elements from stack.
static int UnwindImpl(void** result, int* sizes, int max_depth, int skip_count,
                      const void *ucp, int *min_dropped_frames) {
#ifdef __GNUC__
  void **frame_pointer = reinterpret_cast<void**>(__builtin_frame_address(0));
#else
# error reading stack point not yet supported on this platform.
#endif
  skip_count++;    // Skip the frame for this function.
  int n = 0;

  // Assume that the first page is not stack.
  StackInfo stack_info;
  stack_info.stack_low = static_cast<uintptr_t>(getpagesize());
  stack_info.stack_high = kUnknownStackEnd;
  stack_info.sig_stack_low = stack_info.stack_low;
  stack_info.sig_stack_high = kUnknownStackEnd;

  // The frame pointer points to low address of a frame.  The first 64-bit
  // word of a frame points to the next frame up the call chain, which normally
  // is just after the high address of the current frame.  The second word of
  // a frame contains return address of to the caller.   To find a pc value
  // associated with the current frame, we need to go down a level in the call
  // chain.  So we remember return the address of the last frame seen.  This
  // does not work for the first stack frame, which belongs to UnwindImp() but
  // we skip the frame for UnwindImp() anyway.
  void* prev_return_address = nullptr;
  // The nth frame size is the difference between the nth frame pointer and the
  // the frame pointer below it in the call chain. There is no frame below the
  // leaf frame, but this function is the leaf anyway, and we skip it.
  void** prev_frame_pointer = nullptr;

   while (frame_pointer && n < max_depth) {
    if (skip_count > 0) {
      skip_count--;
    } else {
      result[n] = prev_return_address;
      if (IS_STACK_FRAMES) {
        sizes[n] = static_cast<int>(
            ComputeStackFrameSize(prev_frame_pointer, frame_pointer));
      }
      n++;
    }
    prev_return_address = frame_pointer[1];
    prev_frame_pointer = frame_pointer;
    // The absl::GetStackFrames routine is called when we are in some
    // informational context (the failure signal handler for example).
    // Use the non-strict unwinding rules to produce a stack trace
    // that is as complete as possible (even if it contains a few bogus
    // entries in some rare cases).
    frame_pointer = NextStackFrame<!IS_STACK_FRAMES, IS_WITH_CONTEXT>(
        frame_pointer, ucp, &stack_info);
  }

  if (min_dropped_frames != nullptr) {
    // Implementation detail: we clamp the max of frames we are willing to
    // count, so as not to spend too much time in the loop below.
    const int kMaxUnwind = 200;
    int num_dropped_frames = 0;
    for (int j = 0; frame_pointer != nullptr && j < kMaxUnwind; j++) {
      if (skip_count > 0) {
        skip_count--;
      } else {
        num_dropped_frames++;
      }
      frame_pointer = NextStackFrame<!IS_STACK_FRAMES, IS_WITH_CONTEXT>(
          frame_pointer, ucp, &stack_info);
    }
    *min_dropped_frames = num_dropped_frames;
  }
  return n;
}

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace debugging_internal {
bool StackTraceWorksForTest() {
  return true;
}
}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_DEBUGGING_INTERNAL_STACKTRACE_AARCH64_INL_H_
                                                                                            node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/internal/stacktrace_arm-inl.inc           0000664 0000000 0000000 00000012052 14746647661 0031343 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// This is inspired by Craig Silverstein's PowerPC stacktrace code.

#ifndef ABSL_DEBUGGING_INTERNAL_STACKTRACE_ARM_INL_H_
#define ABSL_DEBUGGING_INTERNAL_STACKTRACE_ARM_INL_H_

#include <cstdint>

#include "absl/debugging/stacktrace.h"

// WARNING:
// This only works if all your code is in either ARM or THUMB mode.  With
// interworking, the frame pointer of the caller can either be in r11 (ARM
// mode) or r7 (THUMB mode).  A callee only saves the frame pointer of its
// mode in a fixed location on its stack frame.  If the caller is a different
// mode, there is no easy way to find the frame pointer.  It can either be
// still in the designated register or saved on stack along with other callee
// saved registers.

// Given a pointer to a stack frame, locate and return the calling
// stackframe, or return nullptr if no stackframe can be found. Perform sanity
// checks (the strictness of which is controlled by the boolean parameter
// "STRICT_UNWINDING") to reduce the chance that a bad pointer is returned.
template<bool STRICT_UNWINDING>
static void **NextStackFrame(void **old_sp) {
  void **new_sp = (void**) old_sp[-1];

  // Check that the transition from frame pointer old_sp to frame
  // pointer new_sp isn't clearly bogus
  if (STRICT_UNWINDING) {
    // With the stack growing downwards, older stack frame must be
    // at a greater address that the current one.
    if (new_sp <= old_sp) return nullptr;
    // Assume stack frames larger than 100,000 bytes are bogus.
    if ((uintptr_t)new_sp - (uintptr_t)old_sp > 100000) return nullptr;
  } else {
    // In the non-strict mode, allow discontiguous stack frames.
    // (alternate-signal-stacks for example).
    if (new_sp == old_sp) return nullptr;
    // And allow frames upto about 1MB.
    if ((new_sp > old_sp)
        && ((uintptr_t)new_sp - (uintptr_t)old_sp > 1000000)) return nullptr;
  }
  if ((uintptr_t)new_sp & (sizeof(void *) - 1)) return nullptr;
  return new_sp;
}

// This ensures that absl::GetStackTrace sets up the Link Register properly.
#ifdef __GNUC__
void StacktraceArmDummyFunction() __attribute__((noinline));
void StacktraceArmDummyFunction() { __asm__ volatile(""); }
#else
# error StacktraceArmDummyFunction() needs to be ported to this platform.
#endif

template <bool IS_STACK_FRAMES, bool IS_WITH_CONTEXT>
static int UnwindImpl(void** result, int* sizes, int max_depth, int skip_count,
                      const void * /* ucp */, int *min_dropped_frames) {
#ifdef __GNUC__
  void **sp = reinterpret_cast<void**>(__builtin_frame_address(0));
#else
# error reading stack point not yet supported on this platform.
#endif

  // On ARM, the return address is stored in the link register (r14).
  // This is not saved on the stack frame of a leaf function.  To
  // simplify code that reads return addresses, we call a dummy
  // function so that the return address of this function is also
  // stored in the stack frame.  This works at least for gcc.
  StacktraceArmDummyFunction();

  int n = 0;
  while (sp && n < max_depth) {
    // The absl::GetStackFrames routine is called when we are in some
    // informational context (the failure signal handler for example).
    // Use the non-strict unwinding rules to produce a stack trace
    // that is as complete as possible (even if it contains a few bogus
    // entries in some rare cases).
    void **next_sp = NextStackFrame<!IS_STACK_FRAMES>(sp);

    if (skip_count > 0) {
      skip_count--;
    } else {
      result[n] = *sp;

      if (IS_STACK_FRAMES) {
        if (next_sp > sp) {
          sizes[n] = (uintptr_t)next_sp - (uintptr_t)sp;
        } else {
          // A frame-size of 0 is used to indicate unknown frame size.
          sizes[n] = 0;
        }
      }
      n++;
    }
    sp = next_sp;
  }
  if (min_dropped_frames != nullptr) {
    // Implementation detail: we clamp the max of frames we are willing to
    // count, so as not to spend too much time in the loop below.
    const int kMaxUnwind = 200;
    int num_dropped_frames = 0;
    for (int j = 0; sp != nullptr && j < kMaxUnwind; j++) {
      if (skip_count > 0) {
        skip_count--;
      } else {
        num_dropped_frames++;
      }
      sp = NextStackFrame<!IS_STACK_FRAMES>(sp);
    }
    *min_dropped_frames = num_dropped_frames;
  }
  return n;
}

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace debugging_internal {
bool StackTraceWorksForTest() {
  return false;
}
}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_DEBUGGING_INTERNAL_STACKTRACE_ARM_INL_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/internal/stacktrace_config.h              0000664 0000000 0000000 00000006506 14746647661 0030736 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /*
 * Copyright 2017 The Abseil Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.

 * Defines ABSL_STACKTRACE_INL_HEADER to the *-inl.h containing
 * actual unwinder implementation.
 * This header is "private" to stacktrace.cc.
 * DO NOT include it into any other files.
*/
#ifndef ABSL_DEBUGGING_INTERNAL_STACKTRACE_CONFIG_H_
#define ABSL_DEBUGGING_INTERNAL_STACKTRACE_CONFIG_H_

#include "absl/base/config.h"

#if defined(ABSL_STACKTRACE_INL_HEADER)
#error ABSL_STACKTRACE_INL_HEADER cannot be directly set

#elif defined(_WIN32)
#define ABSL_STACKTRACE_INL_HEADER \
    "absl/debugging/internal/stacktrace_win32-inl.inc"

#elif defined(__APPLE__)
#ifdef ABSL_HAVE_THREAD_LOCAL
// Thread local support required for UnwindImpl.
#define ABSL_STACKTRACE_INL_HEADER \
  "absl/debugging/internal/stacktrace_generic-inl.inc"
#endif  // defined(ABSL_HAVE_THREAD_LOCAL)

// Emscripten stacktraces rely on JS. Do not use them in standalone mode.
#elif defined(__EMSCRIPTEN__) && !defined(STANDALONE_WASM)
#define ABSL_STACKTRACE_INL_HEADER \
  "absl/debugging/internal/stacktrace_emscripten-inl.inc"

#elif defined(__linux__) && !defined(__ANDROID__)

#if defined(NO_FRAME_POINTER) && \
    (defined(__i386__) || defined(__x86_64__) || defined(__aarch64__))
// Note: The libunwind-based implementation is not available to open-source
// users.
#define ABSL_STACKTRACE_INL_HEADER \
  "absl/debugging/internal/stacktrace_libunwind-inl.inc"
#define STACKTRACE_USES_LIBUNWIND 1
#elif defined(NO_FRAME_POINTER) && defined(__has_include)
#if __has_include(<execinfo.h>)
// Note: When using glibc this may require -funwind-tables to function properly.
#define ABSL_STACKTRACE_INL_HEADER \
  "absl/debugging/internal/stacktrace_generic-inl.inc"
#endif  // __has_include(<execinfo.h>)
#elif defined(__i386__) || defined(__x86_64__)
#define ABSL_STACKTRACE_INL_HEADER \
  "absl/debugging/internal/stacktrace_x86-inl.inc"
#elif defined(__ppc__) || defined(__PPC__)
#define ABSL_STACKTRACE_INL_HEADER \
  "absl/debugging/internal/stacktrace_powerpc-inl.inc"
#elif defined(__aarch64__)
#define ABSL_STACKTRACE_INL_HEADER \
  "absl/debugging/internal/stacktrace_aarch64-inl.inc"
#elif defined(__riscv)
#define ABSL_STACKTRACE_INL_HEADER \
  "absl/debugging/internal/stacktrace_riscv-inl.inc"
#elif defined(__has_include)
#if __has_include(<execinfo.h>)
// Note: When using glibc this may require -funwind-tables to function properly.
#define ABSL_STACKTRACE_INL_HEADER \
  "absl/debugging/internal/stacktrace_generic-inl.inc"
#endif  // __has_include(<execinfo.h>)
#endif  // defined(__has_include)

#endif  // defined(__linux__) && !defined(__ANDROID__)

// Fallback to the empty implementation.
#if !defined(ABSL_STACKTRACE_INL_HEADER)
#define ABSL_STACKTRACE_INL_HEADER \
  "absl/debugging/internal/stacktrace_unimplemented-inl.inc"
#endif

#endif  // ABSL_DEBUGGING_INTERNAL_STACKTRACE_CONFIG_H_
                                                                                                                                                                                          node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/internal/stacktrace_emscripten-inl.inc    0000664 0000000 0000000 00000007414 14746647661 0032743 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Portable implementation - just use glibc
//
// Note:  The glibc implementation may cause a call to malloc.
// This can cause a deadlock in HeapProfiler.

#ifndef ABSL_DEBUGGING_INTERNAL_STACKTRACE_EMSCRIPTEN_INL_H_
#define ABSL_DEBUGGING_INTERNAL_STACKTRACE_EMSCRIPTEN_INL_H_

#include <emscripten.h>

#include <atomic>
#include <cstring>

#include "absl/base/attributes.h"
#include "absl/debugging/stacktrace.h"

extern "C" {
uintptr_t emscripten_stack_snapshot();
uint32_t emscripten_stack_unwind_buffer(uintptr_t pc, void *buffer,
                                        uint32_t depth);
}

// Sometimes, we can try to get a stack trace from within a stack
// trace, which can cause a self-deadlock.
// Protect against such reentrant call by failing to get a stack trace.
//
// We use __thread here because the code here is extremely low level -- it is
// called while collecting stack traces from within malloc and mmap, and thus
// can not call anything which might call malloc or mmap itself.
static __thread int recursive = 0;

// The stack trace function might be invoked very early in the program's
// execution (e.g. from the very first malloc).
// As such, we suppress usage of backtrace during this early stage of execution.
static std::atomic<bool> disable_stacktraces(true);  // Disabled until healthy.
// Waiting until static initializers run seems to be late enough.
// This file is included into stacktrace.cc so this will only run once.
ABSL_ATTRIBUTE_UNUSED static int stacktraces_enabler = []() {
  // Check if we can even create stacktraces. If not, bail early and leave
  // disable_stacktraces set as-is.
  // clang-format off
  if (!EM_ASM_INT({ return (typeof wasmOffsetConverter !== 'undefined'); })) {
    return 0;
  }
  // clang-format on
  disable_stacktraces.store(false, std::memory_order_relaxed);
  return 0;
}();

template <bool IS_STACK_FRAMES, bool IS_WITH_CONTEXT>
static int UnwindImpl(void **result, int *sizes, int max_depth, int skip_count,
                      const void *ucp, int *min_dropped_frames) {
  if (recursive || disable_stacktraces.load(std::memory_order_relaxed)) {
    return 0;
  }
  ++recursive;

  static_cast<void>(ucp);  // Unused.
  constexpr int kStackLength = 64;
  void *stack[kStackLength];

  int size;
  uintptr_t pc = emscripten_stack_snapshot();
  size = emscripten_stack_unwind_buffer(pc, stack, kStackLength);

  int result_count = size - skip_count;
  if (result_count < 0) result_count = 0;
  if (result_count > max_depth) result_count = max_depth;
  for (int i = 0; i < result_count; i++) result[i] = stack[i + skip_count];

  if (IS_STACK_FRAMES) {
    // No implementation for finding out the stack frame sizes yet.
    memset(sizes, 0, sizeof(*sizes) * result_count);
  }
  if (min_dropped_frames != nullptr) {
    if (size - skip_count - max_depth > 0) {
      *min_dropped_frames = size - skip_count - max_depth;
    } else {
      *min_dropped_frames = 0;
    }
  }

  --recursive;

  return result_count;
}

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace debugging_internal {
bool StackTraceWorksForTest() { return true; }
}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_DEBUGGING_INTERNAL_STACKTRACE_EMSCRIPTEN_INL_H_
                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/internal/stacktrace_generic-inl.inc       0000664 0000000 0000000 00000006523 14746647661 0032206 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Portable implementation - just use glibc
//
// Note:  The glibc implementation may cause a call to malloc.
// This can cause a deadlock in HeapProfiler.

#ifndef ABSL_DEBUGGING_INTERNAL_STACKTRACE_GENERIC_INL_H_
#define ABSL_DEBUGGING_INTERNAL_STACKTRACE_GENERIC_INL_H_

#include <execinfo.h>
#include <atomic>
#include <cstring>

#include "absl/debugging/stacktrace.h"
#include "absl/base/attributes.h"

// Sometimes, we can try to get a stack trace from within a stack
// trace, because we don't block signals inside this code (which would be too
// expensive: the two extra system calls per stack trace do matter here).
// That can cause a self-deadlock.
// Protect against such reentrant call by failing to get a stack trace.
//
// We use __thread here because the code here is extremely low level -- it is
// called while collecting stack traces from within malloc and mmap, and thus
// can not call anything which might call malloc or mmap itself.
static __thread int recursive = 0;

// The stack trace function might be invoked very early in the program's
// execution (e.g. from the very first malloc if using tcmalloc). Also, the
// glibc implementation itself will trigger malloc the first time it is called.
// As such, we suppress usage of backtrace during this early stage of execution.
static std::atomic<bool> disable_stacktraces(true);  // Disabled until healthy.

template <bool IS_STACK_FRAMES, bool IS_WITH_CONTEXT>
static int UnwindImpl(void** result, int* sizes, int max_depth, int skip_count,
                      const void *ucp, int *min_dropped_frames) {
  if (recursive || disable_stacktraces.load(std::memory_order_relaxed)) {
    return 0;
  }
  ++recursive;

  static_cast<void>(ucp);  // Unused.
  static const int kStackLength = 64;
  void * stack[kStackLength];
  int size;

  size = backtrace(stack, kStackLength);
  skip_count++;  // we want to skip the current frame as well
  int result_count = size - skip_count;
  if (result_count < 0)
    result_count = 0;
  if (result_count > max_depth)
    result_count = max_depth;
  for (int i = 0; i < result_count; i++)
    result[i] = stack[i + skip_count];

  if (IS_STACK_FRAMES) {
    // No implementation for finding out the stack frame sizes yet.
    memset(sizes, 0, sizeof(*sizes) * static_cast<size_t>(result_count));
  }
  if (min_dropped_frames != nullptr) {
    if (size - skip_count - max_depth > 0) {
      *min_dropped_frames = size - skip_count - max_depth;
    } else {
      *min_dropped_frames = 0;
    }
  }

  --recursive;

  return result_count;
}

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace debugging_internal {
bool StackTraceWorksForTest() {
  return false;
}
}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_DEBUGGING_INTERNAL_STACKTRACE_GENERIC_INL_H_
                                                                                                                                                                             node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/internal/stacktrace_powerpc-inl.inc       0000664 0000000 0000000 00000024172 14746647661 0032251 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Produce stack trace.  I'm guessing (hoping!) the code is much like
// for x86.  For apple machines, at least, it seems to be; see
//    https://developer.apple.com/documentation/mac/runtimehtml/RTArch-59.html
//    https://www.linux-foundation.org/spec/ELF/ppc64/PPC-elf64abi-1.9.html#STACK
// Linux has similar code: http://patchwork.ozlabs.org/linuxppc/patch?id=8882

#ifndef ABSL_DEBUGGING_INTERNAL_STACKTRACE_POWERPC_INL_H_
#define ABSL_DEBUGGING_INTERNAL_STACKTRACE_POWERPC_INL_H_

#if defined(__linux__)
#include <asm/ptrace.h>   // for PT_NIP.
#include <ucontext.h>     // for ucontext_t
#endif

#include <unistd.h>
#include <cassert>
#include <cstdint>
#include <cstdio>

#include "absl/base/attributes.h"
#include "absl/base/optimization.h"
#include "absl/base/port.h"
#include "absl/debugging/stacktrace.h"
#include "absl/debugging/internal/address_is_readable.h"
#include "absl/debugging/internal/vdso_support.h"  // a no-op on non-elf or non-glibc systems

// Given a stack pointer, return the saved link register value.
// Note that this is the link register for a callee.
static inline void *StacktracePowerPCGetLR(void **sp) {
  // PowerPC has 3 main ABIs, which say where in the stack the
  // Link Register is.  For DARWIN and AIX (used by apple and
  // linux ppc64), it's in sp[2].  For SYSV (used by linux ppc),
  // it's in sp[1].
#if defined(_CALL_AIX) || defined(_CALL_DARWIN)
  return *(sp+2);
#elif defined(_CALL_SYSV)
  return *(sp+1);
#elif defined(__APPLE__) || defined(__FreeBSD__) || \
    (defined(__linux__) && defined(__PPC64__))
  // This check is in case the compiler doesn't define _CALL_AIX/etc.
  return *(sp+2);
#elif defined(__linux)
  // This check is in case the compiler doesn't define _CALL_SYSV.
  return *(sp+1);
#else
#error Need to specify the PPC ABI for your architecture.
#endif
}

// Given a pointer to a stack frame, locate and return the calling
// stackframe, or return null if no stackframe can be found. Perform sanity
// checks (the strictness of which is controlled by the boolean parameter
// "STRICT_UNWINDING") to reduce the chance that a bad pointer is returned.
template<bool STRICT_UNWINDING, bool IS_WITH_CONTEXT>
ABSL_ATTRIBUTE_NO_SANITIZE_ADDRESS  // May read random elements from stack.
ABSL_ATTRIBUTE_NO_SANITIZE_MEMORY   // May read random elements from stack.
static void **NextStackFrame(void **old_sp, const void *uc) {
  void **new_sp = (void **) *old_sp;
  enum { kStackAlignment = 16 };

  // Check that the transition from frame pointer old_sp to frame
  // pointer new_sp isn't clearly bogus
  if (STRICT_UNWINDING) {
    // With the stack growing downwards, older stack frame must be
    // at a greater address that the current one.
    if (new_sp <= old_sp) return nullptr;
    // Assume stack frames larger than 100,000 bytes are bogus.
    if ((uintptr_t)new_sp - (uintptr_t)old_sp > 100000) return nullptr;
  } else {
    // In the non-strict mode, allow discontiguous stack frames.
    // (alternate-signal-stacks for example).
    if (new_sp == old_sp) return nullptr;
    // And allow frames upto about 1MB.
    if ((new_sp > old_sp)
        && ((uintptr_t)new_sp - (uintptr_t)old_sp > 1000000)) return nullptr;
  }
  if ((uintptr_t)new_sp % kStackAlignment != 0) return nullptr;

#if defined(__linux__)
  enum StackTraceKernelSymbolStatus {
      kNotInitialized = 0, kAddressValid, kAddressInvalid };

  if (IS_WITH_CONTEXT && uc != nullptr) {
    static StackTraceKernelSymbolStatus kernel_symbol_status =
        kNotInitialized;  // Sentinel: not computed yet.
    // Initialize with sentinel value: __kernel_rt_sigtramp_rt64 can not
    // possibly be there.
    static const unsigned char *kernel_sigtramp_rt64_address = nullptr;
    if (kernel_symbol_status == kNotInitialized) {
      absl::debugging_internal::VDSOSupport vdso;
      if (vdso.IsPresent()) {
        absl::debugging_internal::VDSOSupport::SymbolInfo
            sigtramp_rt64_symbol_info;
        if (!vdso.LookupSymbol(
                "__kernel_sigtramp_rt64", "LINUX_2.6.15",
                absl::debugging_internal::VDSOSupport::kVDSOSymbolType,
                &sigtramp_rt64_symbol_info) ||
            sigtramp_rt64_symbol_info.address == nullptr) {
          // Unexpected: VDSO is present, yet the expected symbol is missing
          // or null.
          assert(false && "VDSO is present, but doesn't have expected symbol");
          kernel_symbol_status = kAddressInvalid;
        } else {
          kernel_sigtramp_rt64_address =
              reinterpret_cast<const unsigned char *>(
                  sigtramp_rt64_symbol_info.address);
          kernel_symbol_status = kAddressValid;
        }
      } else {
        kernel_symbol_status = kAddressInvalid;
      }
    }

    if (new_sp != nullptr &&
        kernel_symbol_status == kAddressValid &&
        StacktracePowerPCGetLR(new_sp) == kernel_sigtramp_rt64_address) {
      const ucontext_t* signal_context =
          reinterpret_cast<const ucontext_t*>(uc);
      void **const sp_before_signal =
#if defined(__PPC64__)
          reinterpret_cast<void **>(signal_context->uc_mcontext.gp_regs[PT_R1]);
#else
          reinterpret_cast<void **>(
              signal_context->uc_mcontext.uc_regs->gregs[PT_R1]);
#endif
      // Check that alleged sp before signal is nonnull and is reasonably
      // aligned.
      if (sp_before_signal != nullptr &&
          ((uintptr_t)sp_before_signal % kStackAlignment) == 0) {
        // Check that alleged stack pointer is actually readable. This is to
        // prevent a "double fault" in case we hit the first fault due to e.g.
        // a stack corruption.
        if (absl::debugging_internal::AddressIsReadable(sp_before_signal)) {
          // Alleged stack pointer is readable, use it for further unwinding.
          new_sp = sp_before_signal;
        }
      }
    }
  }
#endif

  return new_sp;
}

// This ensures that absl::GetStackTrace sets up the Link Register properly.
ABSL_ATTRIBUTE_NOINLINE static void AbslStacktracePowerPCDummyFunction() {
  ABSL_BLOCK_TAIL_CALL_OPTIMIZATION();
}

template <bool IS_STACK_FRAMES, bool IS_WITH_CONTEXT>
ABSL_ATTRIBUTE_NO_SANITIZE_ADDRESS  // May read random elements from stack.
ABSL_ATTRIBUTE_NO_SANITIZE_MEMORY   // May read random elements from stack.
static int UnwindImpl(void** result, int* sizes, int max_depth, int skip_count,
                      const void *ucp, int *min_dropped_frames) {
  void **sp;
  // Apple macOS uses an old version of gnu as -- both Darwin 7.9.0 (Panther)
  // and Darwin 8.8.1 (Tiger) use as 1.38.  This means we have to use a
  // different asm syntax.  I don't know quite the best way to discriminate
  // systems using the old as from the new one; I've gone with __APPLE__.
#ifdef __APPLE__
  __asm__ volatile ("mr %0,r1" : "=r" (sp));
#else
  __asm__ volatile ("mr %0,1" : "=r" (sp));
#endif

  // On PowerPC, the "Link Register" or "Link Record" (LR), is a stack
  // entry that holds the return address of the subroutine call (what
  // instruction we run after our function finishes).  This is the
  // same as the stack-pointer of our parent routine, which is what we
  // want here.  While the compiler will always(?) set up LR for
  // subroutine calls, it may not for leaf functions (such as this one).
  // This routine forces the compiler (at least gcc) to push it anyway.
  AbslStacktracePowerPCDummyFunction();

  // The LR save area is used by the callee, so the top entry is bogus.
  skip_count++;

  int n = 0;

  // Unlike ABIs of X86 and ARM, PowerPC ABIs say that return address (in
  // the link register) of a function call is stored in the caller's stack
  // frame instead of the callee's.  When we look for the return address
  // associated with a stack frame, we need to make sure that there is a
  // caller frame before it.  So we call NextStackFrame before entering the
  // loop below and check next_sp instead of sp for loop termination.
  // The outermost frame is set up by runtimes and it does not have a
  // caller frame, so it is skipped.

  // The absl::GetStackFrames routine is called when we are in some
  // informational context (the failure signal handler for example).
  // Use the non-strict unwinding rules to produce a stack trace
  // that is as complete as possible (even if it contains a few
  // bogus entries in some rare cases).
  void **next_sp = NextStackFrame<!IS_STACK_FRAMES, IS_WITH_CONTEXT>(sp, ucp);

  while (next_sp && n < max_depth) {
    if (skip_count > 0) {
      skip_count--;
    } else {
      result[n] = StacktracePowerPCGetLR(sp);
      if (IS_STACK_FRAMES) {
        if (next_sp > sp) {
          sizes[n] = (uintptr_t)next_sp - (uintptr_t)sp;
        } else {
          // A frame-size of 0 is used to indicate unknown frame size.
          sizes[n] = 0;
        }
      }
      n++;
    }

    sp = next_sp;
    next_sp = NextStackFrame<!IS_STACK_FRAMES, IS_WITH_CONTEXT>(sp, ucp);
  }

  if (min_dropped_frames != nullptr) {
    // Implementation detail: we clamp the max of frames we are willing to
    // count, so as not to spend too much time in the loop below.
    const int kMaxUnwind = 1000;
    int num_dropped_frames = 0;
    for (int j = 0; next_sp != nullptr && j < kMaxUnwind; j++) {
      if (skip_count > 0) {
        skip_count--;
      } else {
        num_dropped_frames++;
      }
      next_sp = NextStackFrame<!IS_STACK_FRAMES, IS_WITH_CONTEXT>(next_sp, ucp);
    }
    *min_dropped_frames = num_dropped_frames;
  }
  return n;
}

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace debugging_internal {
bool StackTraceWorksForTest() {
  return true;
}
}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_DEBUGGING_INTERNAL_STACKTRACE_POWERPC_INL_H_
                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/internal/stacktrace_riscv-inl.inc         0000664 0000000 0000000 00000015327 14746647661 0031722 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2021 The Abseil Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef ABSL_DEBUGGING_INTERNAL_STACKTRACE_RISCV_INL_H_
#define ABSL_DEBUGGING_INTERNAL_STACKTRACE_RISCV_INL_H_

// Generate stack trace for riscv

#include <sys/ucontext.h>

#include "absl/base/config.h"
#if defined(__linux__)
#include <sys/mman.h>
#include <ucontext.h>
#include <unistd.h>
#endif

#include <atomic>
#include <cassert>
#include <cstdint>
#include <iostream>
#include <limits>
#include <utility>

#include "absl/base/attributes.h"
#include "absl/debugging/stacktrace.h"

static const uintptr_t kUnknownFrameSize = 0;

// Compute the size of a stack frame in [low..high).  We assume that low < high.
// Return size of kUnknownFrameSize.
template <typename T>
static inline uintptr_t ComputeStackFrameSize(const T *low, const T *high) {
  const char *low_char_ptr = reinterpret_cast<const char *>(low);
  const char *high_char_ptr = reinterpret_cast<const char *>(high);
  return low < high ? high_char_ptr - low_char_ptr : kUnknownFrameSize;
}

// Given a pointer to a stack frame, locate and return the calling stackframe,
// or return null if no stackframe can be found. Perform sanity checks (the
// strictness of which is controlled by the boolean parameter
// "STRICT_UNWINDING") to reduce the chance that a bad pointer is returned.
template <bool STRICT_UNWINDING, bool WITH_CONTEXT>
ABSL_ATTRIBUTE_NO_SANITIZE_ADDRESS  // May read random elements from stack.
ABSL_ATTRIBUTE_NO_SANITIZE_MEMORY   // May read random elements from stack.
static void ** NextStackFrame(void **old_frame_pointer, const void *uc,
                              const std::pair<size_t, size_t> range) {
  //               .
  //               .
  //               .
  //   +-> +----------------+
  //   |   | return address |
  //   |   |   previous fp  |
  //   |   |      ...       |
  //   |   +----------------+ <-+
  //   |   | return address |   |
  //   +---|-  previous fp  |   |
  //       |      ...       |   |
  // $fp ->|----------------+   |
  //       | return address |   |
  //       |   previous fp -|---+
  // $sp ->|      ...       |
  //       +----------------+
  void **new_frame_pointer = reinterpret_cast<void **>(old_frame_pointer[-2]);
  uintptr_t frame_pointer = reinterpret_cast<uintptr_t>(new_frame_pointer);

  // The RISCV ELF psABI mandates that the stack pointer is always 16-byte
  // aligned.
  // TODO(#1236) this doesn't hold for ILP32E which only mandates a 4-byte
  // alignment.
  if (frame_pointer & 15)
    return nullptr;

  // If the new frame pointer matches the signal context, avoid terminating
  // early to deal with alternate signal stacks.
  if (WITH_CONTEXT)
    if (const ucontext_t *ucv = static_cast<const ucontext_t *>(uc))
      // RISCV ELF psABI has the frame pointer at x8/fp/s0.
      // -- RISCV psABI Table 18.2
      if (ucv->uc_mcontext.__gregs[8] == frame_pointer)
        return new_frame_pointer;

  // Check frame size.  In strict mode, we assume frames to be under 100,000
  // bytes.  In non-strict mode, we relax the limit to 1MB.
  const uintptr_t max_size = STRICT_UNWINDING ? 100000 : 1000000;
  const uintptr_t frame_size =
      ComputeStackFrameSize(old_frame_pointer, new_frame_pointer);
  if (frame_size == kUnknownFrameSize) {
    if (STRICT_UNWINDING)
      return nullptr;

    // In non-strict mode permit non-contiguous stacks (e.g. alternate signal
    // frame handling).
    if (reinterpret_cast<uintptr_t>(new_frame_pointer) < range.first ||
        reinterpret_cast<uintptr_t>(new_frame_pointer) > range.second)
      return nullptr;
  }

  if (frame_size > max_size)
    return nullptr;

  return new_frame_pointer;
}

template <bool IS_STACK_FRAMES, bool IS_WITH_CONTEXT>
ABSL_ATTRIBUTE_NO_SANITIZE_ADDRESS  // May read random elements from stack.
ABSL_ATTRIBUTE_NO_SANITIZE_MEMORY   // May read random elements from stack.
static int UnwindImpl(void **result, int *sizes, int max_depth, int skip_count,
                      const void *ucp, int *min_dropped_frames) {
  // The `frame_pointer` that is computed here points to the top of the frame.
  // The two words preceding the address are the return address and the previous
  // frame pointer.
#if defined(__GNUC__)
  void **frame_pointer = reinterpret_cast<void **>(__builtin_frame_address(0));
#else
#error reading stack pointer not yet supported on this platform
#endif

  std::pair<size_t, size_t> stack = {
      // assume that the first page is not the stack.
      static_cast<size_t>(sysconf(_SC_PAGESIZE)),
      std::numeric_limits<size_t>::max() - sizeof(void *)
  };

  int n = 0;
  void *return_address = nullptr;
  while (frame_pointer && n < max_depth) {
    return_address = frame_pointer[-1];

    // The absl::GetStackFrames routine is called when we are in some
    // informational context (the failure signal handler for example).  Use the
    // non-strict unwinding rules to produce a stack trace that is as complete
    // as possible (even if it contains a few bogus entries in some rare cases).
    void **next_frame_pointer =
        NextStackFrame<!IS_STACK_FRAMES, IS_WITH_CONTEXT>(frame_pointer, ucp,
                                                          stack);

    if (skip_count > 0) {
      skip_count--;
    } else {
      result[n] = return_address;
      if (IS_STACK_FRAMES) {
        sizes[n] = ComputeStackFrameSize(frame_pointer, next_frame_pointer);
      }
      n++;
    }

    frame_pointer = next_frame_pointer;
  }

  if (min_dropped_frames != nullptr) {
    // Implementation detail: we clamp the max of frames we are willing to
    // count, so as not to spend too much time in the loop below.
    const int kMaxUnwind = 200;
    int num_dropped_frames = 0;
    for (int j = 0; frame_pointer != nullptr && j < kMaxUnwind; j++) {
      if (skip_count > 0) {
        skip_count--;
      } else {
        num_dropped_frames++;
      }
      frame_pointer =
          NextStackFrame<!IS_STACK_FRAMES, IS_WITH_CONTEXT>(frame_pointer, ucp,
                                                            stack);
    }
    *min_dropped_frames = num_dropped_frames;
  }

  return n;
}

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace debugging_internal {
bool StackTraceWorksForTest() { return true; }
}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif
                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/internal/stacktrace_unimplemented-inl.inc 0000664 0000000 0000000 00000001332 14746647661 0033431 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #ifndef ABSL_DEBUGGING_INTERNAL_STACKTRACE_UNIMPLEMENTED_INL_H_
#define ABSL_DEBUGGING_INTERNAL_STACKTRACE_UNIMPLEMENTED_INL_H_

template <bool IS_STACK_FRAMES, bool IS_WITH_CONTEXT>
static int UnwindImpl(void** /* result */, int* /* sizes */,
                      int /* max_depth */, int /* skip_count */,
                      const void* /* ucp */, int *min_dropped_frames) {
  if (min_dropped_frames != nullptr) {
    *min_dropped_frames = 0;
  }
  return 0;
}

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace debugging_internal {
bool StackTraceWorksForTest() {
  return false;
}
}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_DEBUGGING_INTERNAL_STACKTRACE_UNIMPLEMENTED_INL_H_
                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/internal/stacktrace_win32-inl.inc         0000664 0000000 0000000 00000007475 14746647661 0031543 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Produces a stack trace for Windows.  Normally, one could use
// stacktrace_x86-inl.h or stacktrace_x86_64-inl.h -- and indeed, that
// should work for binaries compiled using MSVC in "debug" mode.
// However, in "release" mode, Windows uses frame-pointer
// optimization, which makes getting a stack trace very difficult.
//
// There are several approaches one can take.  One is to use Windows
// intrinsics like StackWalk64.  These can work, but have restrictions
// on how successful they can be.  Another attempt is to write a
// version of stacktrace_x86-inl.h that has heuristic support for
// dealing with FPO, similar to what WinDbg does (see
// http://www.nynaeve.net/?p=97).  There are (non-working) examples of
// these approaches, complete with TODOs, in stacktrace_win32-inl.h#1
//
// The solution we've ended up doing is to call the undocumented
// windows function RtlCaptureStackBackTrace, which probably doesn't
// work with FPO but at least is fast, and doesn't require a symbol
// server.
//
// This code is inspired by a patch from David Vitek:
//   https://code.google.com/p/google-perftools/issues/detail?id=83

#ifndef ABSL_DEBUGGING_INTERNAL_STACKTRACE_WIN32_INL_H_
#define ABSL_DEBUGGING_INTERNAL_STACKTRACE_WIN32_INL_H_

#include <windows.h>    // for GetProcAddress and GetModuleHandle
#include <cassert>

typedef USHORT NTAPI RtlCaptureStackBackTrace_Function(
    IN ULONG frames_to_skip,
    IN ULONG frames_to_capture,
    OUT PVOID *backtrace,
    OUT PULONG backtrace_hash);

// It is not possible to load RtlCaptureStackBackTrace at static init time in
// UWP. CaptureStackBackTrace is the public version of RtlCaptureStackBackTrace
#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) && \
    !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
static RtlCaptureStackBackTrace_Function* const RtlCaptureStackBackTrace_fn =
    &::CaptureStackBackTrace;
#else
// Load the function we need at static init time, where we don't have
// to worry about someone else holding the loader's lock.
static RtlCaptureStackBackTrace_Function* const RtlCaptureStackBackTrace_fn =
    (RtlCaptureStackBackTrace_Function*)GetProcAddress(
        GetModuleHandleA("ntdll.dll"), "RtlCaptureStackBackTrace");
#endif  // WINAPI_PARTITION_APP && !WINAPI_PARTITION_DESKTOP

template <bool IS_STACK_FRAMES, bool IS_WITH_CONTEXT>
static int UnwindImpl(void** result, int* sizes, int max_depth, int skip_count,
                      const void*, int* min_dropped_frames) {
  USHORT n = 0;
  if (!RtlCaptureStackBackTrace_fn || skip_count < 0 || max_depth < 0) {
    // can't get a stacktrace with no function/invalid args
  } else {
    n = RtlCaptureStackBackTrace_fn(static_cast<ULONG>(skip_count) + 2,
                                    static_cast<ULONG>(max_depth), result, 0);
  }
  if (IS_STACK_FRAMES) {
    // No implementation for finding out the stack frame sizes yet.
    memset(sizes, 0, sizeof(*sizes) * n);
  }
  if (min_dropped_frames != nullptr) {
    // Not implemented.
    *min_dropped_frames = 0;
  }
  return n;
}

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace debugging_internal {
bool StackTraceWorksForTest() {
  return false;
}
}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_DEBUGGING_INTERNAL_STACKTRACE_WIN32_INL_H_
                                                                                                                                                                                                   node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/internal/stacktrace_x86-inl.inc           0000664 0000000 0000000 00000036252 14746647661 0031221 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Produce stack trace

#ifndef ABSL_DEBUGGING_INTERNAL_STACKTRACE_X86_INL_INC_
#define ABSL_DEBUGGING_INTERNAL_STACKTRACE_X86_INL_INC_

#if defined(__linux__) && (defined(__i386__) || defined(__x86_64__))
#include <ucontext.h>  // for ucontext_t
#endif

#if !defined(_WIN32)
#include <unistd.h>
#endif

#include <cassert>
#include <cstdint>
#include <limits>

#include "absl/base/attributes.h"
#include "absl/base/macros.h"
#include "absl/base/port.h"
#include "absl/debugging/internal/address_is_readable.h"
#include "absl/debugging/internal/vdso_support.h"  // a no-op on non-elf or non-glibc systems
#include "absl/debugging/stacktrace.h"

using absl::debugging_internal::AddressIsReadable;

#if defined(__linux__) && defined(__i386__)
// Count "push %reg" instructions in VDSO __kernel_vsyscall(),
// preceding "syscall" or "sysenter".
// If __kernel_vsyscall uses frame pointer, answer 0.
//
// kMaxBytes tells how many instruction bytes of __kernel_vsyscall
// to analyze before giving up. Up to kMaxBytes+1 bytes of
// instructions could be accessed.
//
// Here are known __kernel_vsyscall instruction sequences:
//
// SYSENTER (linux-2.6.26/arch/x86/vdso/vdso32/sysenter.S).
// Used on Intel.
//  0xffffe400 <__kernel_vsyscall+0>:       push   %ecx
//  0xffffe401 <__kernel_vsyscall+1>:       push   %edx
//  0xffffe402 <__kernel_vsyscall+2>:       push   %ebp
//  0xffffe403 <__kernel_vsyscall+3>:       mov    %esp,%ebp
//  0xffffe405 <__kernel_vsyscall+5>:       sysenter
//
// SYSCALL (see linux-2.6.26/arch/x86/vdso/vdso32/syscall.S).
// Used on AMD.
//  0xffffe400 <__kernel_vsyscall+0>:       push   %ebp
//  0xffffe401 <__kernel_vsyscall+1>:       mov    %ecx,%ebp
//  0xffffe403 <__kernel_vsyscall+3>:       syscall
//

// The sequence below isn't actually expected in Google fleet,
// here only for completeness. Remove this comment from OSS release.

// i386 (see linux-2.6.26/arch/x86/vdso/vdso32/int80.S)
//  0xffffe400 <__kernel_vsyscall+0>:       int $0x80
//  0xffffe401 <__kernel_vsyscall+1>:       ret
//
static const int kMaxBytes = 10;

// We use assert()s instead of DCHECK()s -- this is too low level
// for DCHECK().

static int CountPushInstructions(const unsigned char *const addr) {
  int result = 0;
  for (int i = 0; i < kMaxBytes; ++i) {
    if (addr[i] == 0x89) {
      // "mov reg,reg"
      if (addr[i + 1] == 0xE5) {
        // Found "mov %esp,%ebp".
        return 0;
      }
      ++i;  // Skip register encoding byte.
    } else if (addr[i] == 0x0F &&
               (addr[i + 1] == 0x34 || addr[i + 1] == 0x05)) {
      // Found "sysenter" or "syscall".
      return result;
    } else if ((addr[i] & 0xF0) == 0x50) {
      // Found "push %reg".
      ++result;
    } else if (addr[i] == 0xCD && addr[i + 1] == 0x80) {
      // Found "int $0x80"
      assert(result == 0);
      return 0;
    } else {
      // Unexpected instruction.
      assert(false && "unexpected instruction in __kernel_vsyscall");
      return 0;
    }
  }
  // Unexpected: didn't find SYSENTER or SYSCALL in
  // [__kernel_vsyscall, __kernel_vsyscall + kMaxBytes) interval.
  assert(false && "did not find SYSENTER or SYSCALL in __kernel_vsyscall");
  return 0;
}
#endif

// Assume stack frames larger than 100,000 bytes are bogus.
static const int kMaxFrameBytes = 100000;
// Stack end to use when we don't know the actual stack end
// (effectively just the end of address space).
constexpr uintptr_t kUnknownStackEnd =
    std::numeric_limits<size_t>::max() - sizeof(void *);

// Returns the stack frame pointer from signal context, 0 if unknown.
// vuc is a ucontext_t *.  We use void* to avoid the use
// of ucontext_t on non-POSIX systems.
static uintptr_t GetFP(const void *vuc) {
#if !defined(__linux__)
  static_cast<void>(vuc);  // Avoid an unused argument compiler warning.
#else
  if (vuc != nullptr) {
    auto *uc = reinterpret_cast<const ucontext_t *>(vuc);
#if defined(__i386__)
    const auto bp = uc->uc_mcontext.gregs[REG_EBP];
    const auto sp = uc->uc_mcontext.gregs[REG_ESP];
#elif defined(__x86_64__)
    const auto bp = uc->uc_mcontext.gregs[REG_RBP];
    const auto sp = uc->uc_mcontext.gregs[REG_RSP];
#else
    const uintptr_t bp = 0;
    const uintptr_t sp = 0;
#endif
    // Sanity-check that the base pointer is valid. It's possible that some
    // code in the process is compiled with --copt=-fomit-frame-pointer or
    // --copt=-momit-leaf-frame-pointer.
    //
    // TODO(bcmills): -momit-leaf-frame-pointer is currently the default
    // behavior when building with clang.  Talk to the C++ toolchain team about
    // fixing that.
    if (bp >= sp && bp - sp <= kMaxFrameBytes)
      return static_cast<uintptr_t>(bp);

    // If bp isn't a plausible frame pointer, return the stack pointer instead.
    // If we're lucky, it points to the start of a stack frame; otherwise, we'll
    // get one frame of garbage in the stack trace and fail the sanity check on
    // the next iteration.
    return static_cast<uintptr_t>(sp);
  }
#endif
  return 0;
}

// Given a pointer to a stack frame, locate and return the calling
// stackframe, or return null if no stackframe can be found. Perform sanity
// checks (the strictness of which is controlled by the boolean parameter
// "STRICT_UNWINDING") to reduce the chance that a bad pointer is returned.
template <bool STRICT_UNWINDING, bool WITH_CONTEXT>
ABSL_ATTRIBUTE_NO_SANITIZE_ADDRESS  // May read random elements from stack.
ABSL_ATTRIBUTE_NO_SANITIZE_MEMORY   // May read random elements from stack.
static void **NextStackFrame(void **old_fp, const void *uc,
                             size_t stack_low, size_t stack_high) {
  void **new_fp = (void **)*old_fp;

#if defined(__linux__) && defined(__i386__)
  if (WITH_CONTEXT && uc != nullptr) {
    // How many "push %reg" instructions are there at __kernel_vsyscall?
    // This is constant for a given kernel and processor, so compute
    // it only once.
    static int num_push_instructions = -1;  // Sentinel: not computed yet.
    // Initialize with sentinel value: __kernel_rt_sigreturn can not possibly
    // be there.
    static const unsigned char *kernel_rt_sigreturn_address = nullptr;
    static const unsigned char *kernel_vsyscall_address = nullptr;
    if (num_push_instructions == -1) {
#ifdef ABSL_HAVE_VDSO_SUPPORT
      absl::debugging_internal::VDSOSupport vdso;
      if (vdso.IsPresent()) {
        absl::debugging_internal::VDSOSupport::SymbolInfo
            rt_sigreturn_symbol_info;
        absl::debugging_internal::VDSOSupport::SymbolInfo vsyscall_symbol_info;
        if (!vdso.LookupSymbol("__kernel_rt_sigreturn", "LINUX_2.5", STT_FUNC,
                               &rt_sigreturn_symbol_info) ||
            !vdso.LookupSymbol("__kernel_vsyscall", "LINUX_2.5", STT_FUNC,
                               &vsyscall_symbol_info) ||
            rt_sigreturn_symbol_info.address == nullptr ||
            vsyscall_symbol_info.address == nullptr) {
          // Unexpected: 32-bit VDSO is present, yet one of the expected
          // symbols is missing or null.
          assert(false && "VDSO is present, but doesn't have expected symbols");
          num_push_instructions = 0;
        } else {
          kernel_rt_sigreturn_address =
              reinterpret_cast<const unsigned char *>(
                  rt_sigreturn_symbol_info.address);
          kernel_vsyscall_address =
              reinterpret_cast<const unsigned char *>(
                  vsyscall_symbol_info.address);
          num_push_instructions =
              CountPushInstructions(kernel_vsyscall_address);
        }
      } else {
        num_push_instructions = 0;
      }
#else  // ABSL_HAVE_VDSO_SUPPORT
      num_push_instructions = 0;
#endif  // ABSL_HAVE_VDSO_SUPPORT
    }
    if (num_push_instructions != 0 && kernel_rt_sigreturn_address != nullptr &&
        old_fp[1] == kernel_rt_sigreturn_address) {
      const ucontext_t *ucv = static_cast<const ucontext_t *>(uc);
      // This kernel does not use frame pointer in its VDSO code,
      // and so %ebp is not suitable for unwinding.
      void **const reg_ebp =
          reinterpret_cast<void **>(ucv->uc_mcontext.gregs[REG_EBP]);
      const unsigned char *const reg_eip =
          reinterpret_cast<unsigned char *>(ucv->uc_mcontext.gregs[REG_EIP]);
      if (new_fp == reg_ebp && kernel_vsyscall_address <= reg_eip &&
          reg_eip - kernel_vsyscall_address < kMaxBytes) {
        // We "stepped up" to __kernel_vsyscall, but %ebp is not usable.
        // Restore from 'ucv' instead.
        void **const reg_esp =
            reinterpret_cast<void **>(ucv->uc_mcontext.gregs[REG_ESP]);
        // Check that alleged %esp is not null and is reasonably aligned.
        if (reg_esp &&
            ((uintptr_t)reg_esp & (sizeof(reg_esp) - 1)) == 0) {
          // Check that alleged %esp is actually readable. This is to prevent
          // "double fault" in case we hit the first fault due to e.g. stack
          // corruption.
          void *const reg_esp2 = reg_esp[num_push_instructions - 1];
          if (AddressIsReadable(reg_esp2)) {
            // Alleged %esp is readable, use it for further unwinding.
            new_fp = reinterpret_cast<void **>(reg_esp2);
          }
        }
      }
    }
  }
#endif

  const uintptr_t old_fp_u = reinterpret_cast<uintptr_t>(old_fp);
  const uintptr_t new_fp_u = reinterpret_cast<uintptr_t>(new_fp);

  // Check that the transition from frame pointer old_fp to frame
  // pointer new_fp isn't clearly bogus.  Skip the checks if new_fp
  // matches the signal context, so that we don't skip out early when
  // using an alternate signal stack.
  //
  // TODO(bcmills): The GetFP call should be completely unnecessary when
  // ENABLE_COMBINED_UNWINDER is set (because we should be back in the thread's
  // stack by this point), but it is empirically still needed (e.g. when the
  // stack includes a call to abort).  unw_get_reg returns UNW_EBADREG for some
  // frames.  Figure out why GetValidFrameAddr and/or libunwind isn't doing what
  // it's supposed to.
  if (STRICT_UNWINDING &&
      (!WITH_CONTEXT || uc == nullptr || new_fp_u != GetFP(uc))) {
    // With the stack growing downwards, older stack frame must be
    // at a greater address that the current one.
    if (new_fp_u <= old_fp_u) return nullptr;

    // If we get a very large frame size, it may be an indication that we
    // guessed frame pointers incorrectly and now risk a paging fault
    // dereferencing a wrong frame pointer. Or maybe not because large frames
    // are possible as well. The main stack is assumed to be readable,
    // so we assume the large frame is legit if we know the real stack bounds
    // and are within the stack.
    if (new_fp_u - old_fp_u > kMaxFrameBytes) {
      if (stack_high < kUnknownStackEnd &&
          static_cast<size_t>(getpagesize()) < stack_low) {
        // Stack bounds are known.
        if (!(stack_low < new_fp_u && new_fp_u <= stack_high)) {
          // new_fp_u is not within the known stack.
          return nullptr;
        }
      } else {
        // Stack bounds are unknown, prefer truncated stack to possible crash.
        return nullptr;
      }
    }
    if (stack_low < old_fp_u && old_fp_u <= stack_high) {
      // Old BP was in the expected stack region...
      if (!(stack_low < new_fp_u && new_fp_u <= stack_high)) {
        // ... but new BP is outside of expected stack region.
        // It is most likely bogus.
        return nullptr;
      }
    } else {
      // We may be here if we are executing in a co-routine with a
      // separate stack. We can't do safety checks in this case.
    }
  } else {
    if (new_fp == nullptr) return nullptr;  // skip AddressIsReadable() below
    // In the non-strict mode, allow discontiguous stack frames.
    // (alternate-signal-stacks for example).
    if (new_fp == old_fp) return nullptr;
  }

  if (new_fp_u & (sizeof(void *) - 1)) return nullptr;
#ifdef __i386__
  // On 32-bit machines, the stack pointer can be very close to
  // 0xffffffff, so we explicitly check for a pointer into the
  // last two pages in the address space
  if (new_fp_u >= 0xffffe000) return nullptr;
#endif
#if !defined(_WIN32)
  if (!STRICT_UNWINDING) {
    // Lax sanity checks cause a crash in 32-bit tcmalloc/crash_reason_test
    // on AMD-based machines with VDSO-enabled kernels.
    // Make an extra sanity check to insure new_fp is readable.
    // Note: NextStackFrame<false>() is only called while the program
    //       is already on its last leg, so it's ok to be slow here.

    if (!AddressIsReadable(new_fp)) {
      return nullptr;
    }
  }
#endif
  return new_fp;
}

template <bool IS_STACK_FRAMES, bool IS_WITH_CONTEXT>
ABSL_ATTRIBUTE_NO_SANITIZE_ADDRESS  // May read random elements from stack.
ABSL_ATTRIBUTE_NO_SANITIZE_MEMORY   // May read random elements from stack.
ABSL_ATTRIBUTE_NOINLINE
static int UnwindImpl(void **result, int *sizes, int max_depth, int skip_count,
                      const void *ucp, int *min_dropped_frames) {
  int n = 0;
  void **fp = reinterpret_cast<void **>(__builtin_frame_address(0));

  // Assume that the first page is not stack.
  size_t stack_low = static_cast<size_t>(getpagesize());
  size_t stack_high = kUnknownStackEnd;

  while (fp && n < max_depth) {
    if (*(fp + 1) == reinterpret_cast<void *>(0)) {
      // In 64-bit code, we often see a frame that
      // points to itself and has a return address of 0.
      break;
    }
    void **next_fp = NextStackFrame<!IS_STACK_FRAMES, IS_WITH_CONTEXT>(
        fp, ucp, stack_low, stack_high);
    if (skip_count > 0) {
      skip_count--;
    } else {
      result[n] = *(fp + 1);
      if (IS_STACK_FRAMES) {
        if (next_fp > fp) {
          sizes[n] = static_cast<int>(
              reinterpret_cast<uintptr_t>(next_fp) -
              reinterpret_cast<uintptr_t>(fp));
        } else {
          // A frame-size of 0 is used to indicate unknown frame size.
          sizes[n] = 0;
        }
      }
      n++;
    }
    fp = next_fp;
  }
  if (min_dropped_frames != nullptr) {
    // Implementation detail: we clamp the max of frames we are willing to
    // count, so as not to spend too much time in the loop below.
    const int kMaxUnwind = 1000;
    int num_dropped_frames = 0;
    for (int j = 0; fp != nullptr && j < kMaxUnwind; j++) {
      if (skip_count > 0) {
        skip_count--;
      } else {
        num_dropped_frames++;
      }
      fp = NextStackFrame<!IS_STACK_FRAMES, IS_WITH_CONTEXT>(fp, ucp, stack_low,
                                                             stack_high);
    }
    *min_dropped_frames = num_dropped_frames;
  }
  return n;
}

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace debugging_internal {
bool StackTraceWorksForTest() {
  return true;
}
}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_DEBUGGING_INTERNAL_STACKTRACE_X86_INL_INC_
                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/internal/symbolize.h                      0000664 0000000 0000000 00000012312 14746647661 0027272 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file contains internal parts of the Abseil symbolizer.
// Do not depend on the anything in this file, it may change at anytime.

#ifndef ABSL_DEBUGGING_INTERNAL_SYMBOLIZE_H_
#define ABSL_DEBUGGING_INTERNAL_SYMBOLIZE_H_

#ifdef __cplusplus

#include <cstddef>
#include <cstdint>

#include "absl/base/config.h"
#include "absl/strings/string_view.h"

#ifdef ABSL_INTERNAL_HAVE_ELF_SYMBOLIZE
#error ABSL_INTERNAL_HAVE_ELF_SYMBOLIZE cannot be directly set
#elif defined(__ELF__) && defined(__GLIBC__) && !defined(__native_client__) \
      && !defined(__asmjs__) && !defined(__wasm__)
#define ABSL_INTERNAL_HAVE_ELF_SYMBOLIZE 1

#include <elf.h>
#include <link.h>  // For ElfW() macro.
#include <functional>
#include <string>

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace debugging_internal {

// Iterates over all sections, invoking callback on each with the section name
// and the section header.
//
// Returns true on success; otherwise returns false in case of errors.
//
// This is not async-signal-safe.
bool ForEachSection(int fd,
                    const std::function<bool(absl::string_view name,
                                             const ElfW(Shdr) &)>& callback);

// Gets the section header for the given name, if it exists. Returns true on
// success. Otherwise, returns false.
bool GetSectionHeaderByName(int fd, const char *name, size_t name_len,
                            ElfW(Shdr) *out);

}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_INTERNAL_HAVE_ELF_SYMBOLIZE

#ifdef ABSL_INTERNAL_HAVE_DARWIN_SYMBOLIZE
#error ABSL_INTERNAL_HAVE_DARWIN_SYMBOLIZE cannot be directly set
#elif defined(__APPLE__)
#define ABSL_INTERNAL_HAVE_DARWIN_SYMBOLIZE 1
#endif

#ifdef ABSL_INTERNAL_HAVE_EMSCRIPTEN_SYMBOLIZE
#error ABSL_INTERNAL_HAVE_EMSCRIPTEN_SYMBOLIZE cannot be directly set
#elif defined(__EMSCRIPTEN__)
#define ABSL_INTERNAL_HAVE_EMSCRIPTEN_SYMBOLIZE 1
#endif

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace debugging_internal {

struct SymbolDecoratorArgs {
  // The program counter we are getting symbolic name for.
  const void *pc;
  // 0 for main executable, load address for shared libraries.
  ptrdiff_t relocation;
  // Read-only file descriptor for ELF image covering "pc",
  // or -1 if no such ELF image exists in /proc/self/maps.
  int fd;
  // Output buffer, size.
  // Note: the buffer may not be empty -- default symbolizer may have already
  // produced some output, and earlier decorators may have adorned it in
  // some way. You are free to replace or augment the contents (within the
  // symbol_buf_size limit).
  char *const symbol_buf;
  size_t symbol_buf_size;
  // Temporary scratch space, size.
  // Use that space in preference to allocating your own stack buffer to
  // conserve stack.
  char *const tmp_buf;
  size_t tmp_buf_size;
  // User-provided argument
  void* arg;
};
using SymbolDecorator = void (*)(const SymbolDecoratorArgs *);

// Installs a function-pointer as a decorator. Returns a value less than zero
// if the system cannot install the decorator. Otherwise, returns a unique
// identifier corresponding to the decorator. This identifier can be used to
// uninstall the decorator - See RemoveSymbolDecorator() below.
int InstallSymbolDecorator(SymbolDecorator decorator, void* arg);

// Removes a previously installed function-pointer decorator. Parameter "ticket"
// is the return-value from calling InstallSymbolDecorator().
bool RemoveSymbolDecorator(int ticket);

// Remove all installed decorators.  Returns true if successful, false if
// symbolization is currently in progress.
bool RemoveAllSymbolDecorators();

// Registers an address range to a file mapping.
//
// Preconditions:
//   start <= end
//   filename != nullptr
//
// Returns true if the file was successfully registered.
bool RegisterFileMappingHint(const void* start, const void* end,
                             uint64_t offset, const char* filename);

// Looks up the file mapping registered by RegisterFileMappingHint for an
// address range. If there is one, the file name is stored in *filename and
// *start and *end are modified to reflect the registered mapping. Returns
// whether any hint was found.
bool GetFileMappingHint(const void** start, const void** end, uint64_t* offset,
                        const char** filename);

}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // __cplusplus

#include <stdbool.h>

#ifdef __cplusplus
extern "C"
#endif  // __cplusplus

    bool
    AbslInternalGetFileMappingHint(const void** start, const void** end,
                                   uint64_t* offset, const char** filename);

#endif  // ABSL_DEBUGGING_INTERNAL_SYMBOLIZE_H_
                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/internal/utf8_for_code_point.cc           0000664 0000000 0000000 00000004220 14746647661 0031351 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 The Abseil Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/debugging/internal/utf8_for_code_point.h"

#include <cstdint>

#include "absl/base/config.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace debugging_internal {
namespace {

// UTF-8 encoding bounds.
constexpr uint32_t kMinSurrogate = 0xd800, kMaxSurrogate = 0xdfff;
constexpr uint32_t kMax1ByteCodePoint = 0x7f;
constexpr uint32_t kMax2ByteCodePoint = 0x7ff;
constexpr uint32_t kMax3ByteCodePoint = 0xffff;
constexpr uint32_t kMaxCodePoint = 0x10ffff;

}  // namespace

Utf8ForCodePoint::Utf8ForCodePoint(uint64_t code_point) {
  if (code_point <= kMax1ByteCodePoint) {
    length = 1;
    bytes[0] = static_cast<char>(code_point);
    return;
  }

  if (code_point <= kMax2ByteCodePoint) {
    length = 2;
    bytes[0] = static_cast<char>(0xc0 | (code_point >> 6));
    bytes[1] = static_cast<char>(0x80 | (code_point & 0x3f));
    return;
  }

  if (kMinSurrogate <= code_point && code_point <= kMaxSurrogate) return;

  if (code_point <= kMax3ByteCodePoint) {
    length = 3;
    bytes[0] = static_cast<char>(0xe0 | (code_point >> 12));
    bytes[1] = static_cast<char>(0x80 | ((code_point >> 6) & 0x3f));
    bytes[2] = static_cast<char>(0x80 | (code_point & 0x3f));
    return;
  }

  if (code_point > kMaxCodePoint) return;

  length = 4;
  bytes[0] = static_cast<char>(0xf0 | (code_point >> 18));
  bytes[1] = static_cast<char>(0x80 | ((code_point >> 12) & 0x3f));
  bytes[2] = static_cast<char>(0x80 | ((code_point >> 6) & 0x3f));
  bytes[3] = static_cast<char>(0x80 | (code_point & 0x3f));
}

}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/internal/utf8_for_code_point.h            0000664 0000000 0000000 00000003124 14746647661 0031215 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 The Abseil Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef ABSL_DEBUGGING_INTERNAL_UTF8_FOR_CODE_POINT_H_
#define ABSL_DEBUGGING_INTERNAL_UTF8_FOR_CODE_POINT_H_

#include <cstdint>

#include "absl/base/config.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace debugging_internal {

struct Utf8ForCodePoint {
  // Converts a Unicode code point to the corresponding UTF-8 byte sequence.
  // Async-signal-safe to support use in symbolizing stack traces from a signal
  // handler.
  explicit Utf8ForCodePoint(uint64_t code_point);

  // Returns true if the constructor's code_point argument was valid.
  bool ok() const { return length != 0; }

  // If code_point was in range, then 1 <= length <= 4, and the UTF-8 encoding
  // is found in bytes[0 .. (length - 1)].  If code_point was invalid, then
  // length == 0.  In either case, the contents of bytes[length .. 3] are
  // unspecified.
  char bytes[4] = {};
  uint32_t length = 0;
};

}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_DEBUGGING_INTERNAL_UTF8_FOR_CODE_POINT_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/internal/utf8_for_code_point_test.cc      0000664 0000000 0000000 00000013077 14746647661 0032422 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2024 The Abseil Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/debugging/internal/utf8_for_code_point.h"

#include <cstdint>

#include "gtest/gtest.h"
#include "absl/base/config.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace debugging_internal {
namespace {

TEST(Utf8ForCodePointTest, RecognizesTheSmallestCodePoint) {
  Utf8ForCodePoint utf8(uint64_t{0});
  ASSERT_EQ(utf8.length, 1);
  EXPECT_EQ(utf8.bytes[0], '\0');
}

TEST(Utf8ForCodePointTest, RecognizesAsciiSmallA) {
  Utf8ForCodePoint utf8(uint64_t{'a'});
  ASSERT_EQ(utf8.length, 1);
  EXPECT_EQ(utf8.bytes[0], 'a');
}

TEST(Utf8ForCodePointTest, RecognizesTheLargestOneByteCodePoint) {
  Utf8ForCodePoint utf8(uint64_t{0x7f});
  ASSERT_EQ(utf8.length, 1);
  EXPECT_EQ(utf8.bytes[0], '\x7f');
}

TEST(Utf8ForCodePointTest, RecognizesTheSmallestTwoByteCodePoint) {
  Utf8ForCodePoint utf8(uint64_t{0x80});
  ASSERT_EQ(utf8.length, 2);
  EXPECT_EQ(utf8.bytes[0], static_cast<char>(0xc2));
  EXPECT_EQ(utf8.bytes[1], static_cast<char>(0x80));
}

TEST(Utf8ForCodePointTest, RecognizesSmallNWithTilde) {
  Utf8ForCodePoint utf8(uint64_t{0xf1});
  ASSERT_EQ(utf8.length, 2);
  const char* want = "ñ";
  EXPECT_EQ(utf8.bytes[0], want[0]);
  EXPECT_EQ(utf8.bytes[1], want[1]);
}

TEST(Utf8ForCodePointTest, RecognizesCapitalPi) {
  Utf8ForCodePoint utf8(uint64_t{0x3a0});
  ASSERT_EQ(utf8.length, 2);
  const char* want = "Π";
  EXPECT_EQ(utf8.bytes[0], want[0]);
  EXPECT_EQ(utf8.bytes[1], want[1]);
}

TEST(Utf8ForCodePointTest, RecognizesTheLargestTwoByteCodePoint) {
  Utf8ForCodePoint utf8(uint64_t{0x7ff});
  ASSERT_EQ(utf8.length, 2);
  EXPECT_EQ(utf8.bytes[0], static_cast<char>(0xdf));
  EXPECT_EQ(utf8.bytes[1], static_cast<char>(0xbf));
}

TEST(Utf8ForCodePointTest, RecognizesTheSmallestThreeByteCodePoint) {
  Utf8ForCodePoint utf8(uint64_t{0x800});
  ASSERT_EQ(utf8.length, 3);
  EXPECT_EQ(utf8.bytes[0], static_cast<char>(0xe0));
  EXPECT_EQ(utf8.bytes[1], static_cast<char>(0xa0));
  EXPECT_EQ(utf8.bytes[2], static_cast<char>(0x80));
}

TEST(Utf8ForCodePointTest, RecognizesTheChineseCharacterZhong1AsInZhong1Wen2) {
  Utf8ForCodePoint utf8(uint64_t{0x4e2d});
  ASSERT_EQ(utf8.length, 3);
  const char* want = "中";
  EXPECT_EQ(utf8.bytes[0], want[0]);
  EXPECT_EQ(utf8.bytes[1], want[1]);
  EXPECT_EQ(utf8.bytes[2], want[2]);
}

TEST(Utf8ForCodePointTest, RecognizesOneBeforeTheSmallestSurrogate) {
  Utf8ForCodePoint utf8(uint64_t{0xd7ff});
  ASSERT_EQ(utf8.length, 3);
  EXPECT_EQ(utf8.bytes[0], static_cast<char>(0xed));
  EXPECT_EQ(utf8.bytes[1], static_cast<char>(0x9f));
  EXPECT_EQ(utf8.bytes[2], static_cast<char>(0xbf));
}

TEST(Utf8ForCodePointTest, RejectsTheSmallestSurrogate) {
  Utf8ForCodePoint utf8(uint64_t{0xd800});
  EXPECT_EQ(utf8.length, 0);
}

TEST(Utf8ForCodePointTest, RejectsTheLargestSurrogate) {
  Utf8ForCodePoint utf8(uint64_t{0xdfff});
  EXPECT_EQ(utf8.length, 0);
}

TEST(Utf8ForCodePointTest, RecognizesOnePastTheLargestSurrogate) {
  Utf8ForCodePoint utf8(uint64_t{0xe000});
  ASSERT_EQ(utf8.length, 3);
  EXPECT_EQ(utf8.bytes[0], static_cast<char>(0xee));
  EXPECT_EQ(utf8.bytes[1], static_cast<char>(0x80));
  EXPECT_EQ(utf8.bytes[2], static_cast<char>(0x80));
}

TEST(Utf8ForCodePointTest, RecognizesTheLargestThreeByteCodePoint) {
  Utf8ForCodePoint utf8(uint64_t{0xffff});
  ASSERT_EQ(utf8.length, 3);
  EXPECT_EQ(utf8.bytes[0], static_cast<char>(0xef));
  EXPECT_EQ(utf8.bytes[1], static_cast<char>(0xbf));
  EXPECT_EQ(utf8.bytes[2], static_cast<char>(0xbf));
}

TEST(Utf8ForCodePointTest, RecognizesTheSmallestFourByteCodePoint) {
  Utf8ForCodePoint utf8(uint64_t{0x10000});
  ASSERT_EQ(utf8.length, 4);
  EXPECT_EQ(utf8.bytes[0], static_cast<char>(0xf0));
  EXPECT_EQ(utf8.bytes[1], static_cast<char>(0x90));
  EXPECT_EQ(utf8.bytes[2], static_cast<char>(0x80));
  EXPECT_EQ(utf8.bytes[3], static_cast<char>(0x80));
}

TEST(Utf8ForCodePointTest, RecognizesTheJackOfHearts) {
  Utf8ForCodePoint utf8(uint64_t{0x1f0bb});
  ASSERT_EQ(utf8.length, 4);
  const char* want = "🂻";
  EXPECT_EQ(utf8.bytes[0], want[0]);
  EXPECT_EQ(utf8.bytes[1], want[1]);
  EXPECT_EQ(utf8.bytes[2], want[2]);
  EXPECT_EQ(utf8.bytes[3], want[3]);
}

TEST(Utf8ForCodePointTest, RecognizesTheLargestFourByteCodePoint) {
  Utf8ForCodePoint utf8(uint64_t{0x10ffff});
  ASSERT_EQ(utf8.length, 4);
  EXPECT_EQ(utf8.bytes[0], static_cast<char>(0xf4));
  EXPECT_EQ(utf8.bytes[1], static_cast<char>(0x8f));
  EXPECT_EQ(utf8.bytes[2], static_cast<char>(0xbf));
  EXPECT_EQ(utf8.bytes[3], static_cast<char>(0xbf));
}

TEST(Utf8ForCodePointTest, RejectsTheSmallestOverlargeCodePoint) {
  Utf8ForCodePoint utf8(uint64_t{0x110000});
  EXPECT_EQ(utf8.length, 0);
}

TEST(Utf8ForCodePointTest, RejectsAThroughlyOverlargeCodePoint) {
  Utf8ForCodePoint utf8(uint64_t{0xffffffff00000000});
  EXPECT_EQ(utf8.length, 0);
}

TEST(Utf8ForCodePointTest, OkReturnsTrueForAValidCodePoint) {
  EXPECT_TRUE(Utf8ForCodePoint(uint64_t{0}).ok());
}

TEST(Utf8ForCodePointTest, OkReturnsFalseForAnInvalidCodePoint) {
  EXPECT_FALSE(Utf8ForCodePoint(uint64_t{0xffffffff00000000}).ok());
}

}  // namespace
}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/internal/vdso_support.cc                  0000664 0000000 0000000 00000015552 14746647661 0030173 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Allow dynamic symbol lookup in the kernel VDSO page.
//
// VDSOSupport -- a class representing kernel VDSO (if present).

#include "absl/debugging/internal/vdso_support.h"

#ifdef ABSL_HAVE_VDSO_SUPPORT     // defined in vdso_support.h

#if !defined(__has_include)
#define __has_include(header) 0
#endif

#include <errno.h>
#include <fcntl.h>
#if __has_include(<syscall.h>)
#include <syscall.h>
#elif __has_include(<sys/syscall.h>)
#include <sys/syscall.h>
#endif
#include <unistd.h>

#if !defined(__UCLIBC__) && defined(__GLIBC__) && \
    (__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 16))
#define ABSL_HAVE_GETAUXVAL
#endif

#ifdef ABSL_HAVE_GETAUXVAL
#include <sys/auxv.h>
#endif

#include "absl/base/dynamic_annotations.h"
#include "absl/base/internal/raw_logging.h"
#include "absl/base/port.h"

#ifndef AT_SYSINFO_EHDR
#define AT_SYSINFO_EHDR 33  // for crosstoolv10
#endif

#if defined(__NetBSD__)
using Elf32_auxv_t = Aux32Info;
using Elf64_auxv_t = Aux64Info;
#endif
#if defined(__FreeBSD__)
#if defined(__ELF_WORD_SIZE) && __ELF_WORD_SIZE == 64
using Elf64_auxv_t = Elf64_Auxinfo;
#endif
using Elf32_auxv_t = Elf32_Auxinfo;
#endif

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace debugging_internal {

ABSL_CONST_INIT
std::atomic<const void *> VDSOSupport::vdso_base_(
    debugging_internal::ElfMemImage::kInvalidBase);

ABSL_CONST_INIT std::atomic<VDSOSupport::GetCpuFn> VDSOSupport::getcpu_fn_(
    &InitAndGetCPU);

VDSOSupport::VDSOSupport()
    // If vdso_base_ is still set to kInvalidBase, we got here
    // before VDSOSupport::Init has been called. Call it now.
    : image_(vdso_base_.load(std::memory_order_relaxed) ==
                     debugging_internal::ElfMemImage::kInvalidBase
                 ? Init()
                 : vdso_base_.load(std::memory_order_relaxed)) {}

// NOTE: we can't use GoogleOnceInit() below, because we can be
// called by tcmalloc, and none of the *once* stuff may be functional yet.
//
// In addition, we hope that the VDSOSupportHelper constructor
// causes this code to run before there are any threads, and before
// InitGoogle() has executed any chroot or setuid calls.
//
// Finally, even if there is a race here, it is harmless, because
// the operation should be idempotent.
const void *VDSOSupport::Init() {
  const auto kInvalidBase = debugging_internal::ElfMemImage::kInvalidBase;
#ifdef ABSL_HAVE_GETAUXVAL
  if (vdso_base_.load(std::memory_order_relaxed) == kInvalidBase) {
    errno = 0;
    const void *const sysinfo_ehdr =
        reinterpret_cast<const void *>(getauxval(AT_SYSINFO_EHDR));
    if (errno == 0) {
      vdso_base_.store(sysinfo_ehdr, std::memory_order_relaxed);
    }
  }
#endif  // ABSL_HAVE_GETAUXVAL
  if (vdso_base_.load(std::memory_order_relaxed) == kInvalidBase) {
    int fd = open("/proc/self/auxv", O_RDONLY);
    if (fd == -1) {
      // Kernel too old to have a VDSO.
      vdso_base_.store(nullptr, std::memory_order_relaxed);
      getcpu_fn_.store(&GetCPUViaSyscall, std::memory_order_relaxed);
      return nullptr;
    }
    ElfW(auxv_t) aux;
    while (read(fd, &aux, sizeof(aux)) == sizeof(aux)) {
      if (aux.a_type == AT_SYSINFO_EHDR) {
#if defined(__NetBSD__)
        vdso_base_.store(reinterpret_cast<void *>(aux.a_v),
                         std::memory_order_relaxed);
#else
        vdso_base_.store(reinterpret_cast<void *>(aux.a_un.a_val),
                         std::memory_order_relaxed);
#endif
        break;
      }
    }
    close(fd);
    if (vdso_base_.load(std::memory_order_relaxed) == kInvalidBase) {
      // Didn't find AT_SYSINFO_EHDR in auxv[].
      vdso_base_.store(nullptr, std::memory_order_relaxed);
    }
  }
  GetCpuFn fn = &GetCPUViaSyscall;  // default if VDSO not present.
  if (vdso_base_.load(std::memory_order_relaxed)) {
    VDSOSupport vdso;
    SymbolInfo info;
    if (vdso.LookupSymbol("__vdso_getcpu", "LINUX_2.6", STT_FUNC, &info)) {
      fn = reinterpret_cast<GetCpuFn>(const_cast<void *>(info.address));
    }
  }
  // Subtle: this code runs outside of any locks; prevent compiler
  // from assigning to getcpu_fn_ more than once.
  getcpu_fn_.store(fn, std::memory_order_relaxed);
  return vdso_base_.load(std::memory_order_relaxed);
}

const void *VDSOSupport::SetBase(const void *base) {
  ABSL_RAW_CHECK(base != debugging_internal::ElfMemImage::kInvalidBase,
                 "internal error");
  const void *old_base = vdso_base_.load(std::memory_order_relaxed);
  vdso_base_.store(base, std::memory_order_relaxed);
  image_.Init(base);
  // Also reset getcpu_fn_, so GetCPU could be tested with simulated VDSO.
  getcpu_fn_.store(&InitAndGetCPU, std::memory_order_relaxed);
  return old_base;
}

bool VDSOSupport::LookupSymbol(const char *name,
                               const char *version,
                               int type,
                               SymbolInfo *info) const {
  return image_.LookupSymbol(name, version, type, info);
}

bool VDSOSupport::LookupSymbolByAddress(const void *address,
                                        SymbolInfo *info_out) const {
  return image_.LookupSymbolByAddress(address, info_out);
}

// NOLINT on 'long' because this routine mimics kernel api.
long VDSOSupport::GetCPUViaSyscall(unsigned *cpu,  // NOLINT(runtime/int)
                                   void *, void *) {
#ifdef SYS_getcpu
  return syscall(SYS_getcpu, cpu, nullptr, nullptr);
#else
  // x86_64 never implemented sys_getcpu(), except as a VDSO call.
  static_cast<void>(cpu);  // Avoid an unused argument compiler warning.
  errno = ENOSYS;
  return -1;
#endif
}

// Use fast __vdso_getcpu if available.
long VDSOSupport::InitAndGetCPU(unsigned *cpu,  // NOLINT(runtime/int)
                                void *x, void *y) {
  Init();
  GetCpuFn fn = getcpu_fn_.load(std::memory_order_relaxed);
  ABSL_RAW_CHECK(fn != &InitAndGetCPU, "Init() did not set getcpu_fn_");
  return (*fn)(cpu, x, y);
}

// This function must be very fast, and may be called from very
// low level (e.g. tcmalloc). Hence I avoid things like
// GoogleOnceInit() and ::operator new.
ABSL_ATTRIBUTE_NO_SANITIZE_MEMORY
int GetCPU() {
  unsigned cpu;
  long ret_code =  // NOLINT(runtime/int)
      (*VDSOSupport::getcpu_fn_)(&cpu, nullptr, nullptr);
  return ret_code == 0 ? static_cast<int>(cpu) : static_cast<int>(ret_code);
}

}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_HAVE_VDSO_SUPPORT
                                                                                                                                                      node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/internal/vdso_support.h                   0000664 0000000 0000000 00000013277 14746647661 0030037 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
// Copyright 2017 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// Allow dynamic symbol lookup in the kernel VDSO page.
//
// VDSO stands for "Virtual Dynamic Shared Object" -- a page of
// executable code, which looks like a shared library, but doesn't
// necessarily exist anywhere on disk, and which gets mmap()ed into
// every process by kernels which support VDSO, such as 2.6.x for 32-bit
// executables, and 2.6.24 and above for 64-bit executables.
//
// More details could be found here:
// http://www.trilithium.com/johan/2005/08/linux-gate/
//
// VDSOSupport -- a class representing kernel VDSO (if present).
//
// Example usage:
//  VDSOSupport vdso;
//  VDSOSupport::SymbolInfo info;
//  typedef (*FN)(unsigned *, void *, void *);
//  FN fn = nullptr;
//  if (vdso.LookupSymbol("__vdso_getcpu", "LINUX_2.6", STT_FUNC, &info)) {
//     fn = reinterpret_cast<FN>(info.address);
//  }

#ifndef ABSL_DEBUGGING_INTERNAL_VDSO_SUPPORT_H_
#define ABSL_DEBUGGING_INTERNAL_VDSO_SUPPORT_H_

#include <atomic>

#include "absl/base/attributes.h"
#include "absl/debugging/internal/elf_mem_image.h"

#ifdef ABSL_HAVE_ELF_MEM_IMAGE

#ifdef ABSL_HAVE_VDSO_SUPPORT
#error ABSL_HAVE_VDSO_SUPPORT cannot be directly set
#else
#define ABSL_HAVE_VDSO_SUPPORT 1
#endif

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace debugging_internal {

// NOTE: this class may be used from within tcmalloc, and can not
// use any memory allocation routines.
class VDSOSupport {
 public:
  VDSOSupport();

  typedef ElfMemImage::SymbolInfo SymbolInfo;
  typedef ElfMemImage::SymbolIterator SymbolIterator;

  // On PowerPC64 VDSO symbols can either be of type STT_FUNC or STT_NOTYPE
  // depending on how the kernel is built.  The kernel is normally built with
  // STT_NOTYPE type VDSO symbols.  Let's make things simpler first by using a
  // compile-time constant.
#ifdef __powerpc64__
  enum { kVDSOSymbolType = STT_NOTYPE };
#else
  enum { kVDSOSymbolType = STT_FUNC };
#endif

  // Answers whether we have a vdso at all.
  bool IsPresent() const { return image_.IsPresent(); }

  // Allow to iterate over all VDSO symbols.
  SymbolIterator begin() const { return image_.begin(); }
  SymbolIterator end() const { return image_.end(); }

  // Look up versioned dynamic symbol in the kernel VDSO.
  // Returns false if VDSO is not present, or doesn't contain given
  // symbol/version/type combination.
  // If info_out != nullptr, additional details are filled in.
  bool LookupSymbol(const char *name, const char *version,
                    int symbol_type, SymbolInfo *info_out) const;

  // Find info about symbol (if any) which overlaps given address.
  // Returns true if symbol was found; false if VDSO isn't present
  // or doesn't have a symbol overlapping given address.
  // If info_out != nullptr, additional details are filled in.
  bool LookupSymbolByAddress(const void *address, SymbolInfo *info_out) const;

  // Used only for testing. Replace real VDSO base with a mock.
  // Returns previous value of vdso_base_. After you are done testing,
  // you are expected to call SetBase() with previous value, in order to
  // reset state to the way it was.
  const void *SetBase(const void *s);

  // Computes vdso_base_ and returns it. Should be called as early as
  // possible; before any thread creation, chroot or setuid.
  static const void *Init();

 private:
  // image_ represents VDSO ELF image in memory.
  // image_.ehdr_ == nullptr implies there is no VDSO.
  ElfMemImage image_;

  // Cached value of auxv AT_SYSINFO_EHDR, computed once.
  // This is a tri-state:
  //   kInvalidBase   => value hasn't been determined yet.
  //              0   => there is no VDSO.
  //           else   => vma of VDSO Elf{32,64}_Ehdr.
  //
  // When testing with mock VDSO, low bit is set.
  // The low bit is always available because vdso_base_ is
  // page-aligned.
  static std::atomic<const void *> vdso_base_;

  // NOLINT on 'long' because these routines mimic kernel api.
  // The 'cache' parameter may be used by some versions of the kernel,
  // and should be nullptr or point to a static buffer containing at
  // least two 'long's.
  static long InitAndGetCPU(unsigned *cpu, void *cache,     // NOLINT 'long'.
                            void *unused);
  static long GetCPUViaSyscall(unsigned *cpu, void *cache,  // NOLINT 'long'.
                               void *unused);
  typedef long (*GetCpuFn)(unsigned *cpu, void *cache,      // NOLINT 'long'.
                           void *unused);

  // This function pointer may point to InitAndGetCPU,
  // GetCPUViaSyscall, or __vdso_getcpu at different stages of initialization.
  ABSL_CONST_INIT static std::atomic<GetCpuFn> getcpu_fn_;

  friend int GetCPU(void);  // Needs access to getcpu_fn_.

  VDSOSupport(const VDSOSupport&) = delete;
  VDSOSupport& operator=(const VDSOSupport&) = delete;
};

// Same as sched_getcpu() on later glibc versions.
// Return current CPU, using (fast) __vdso_getcpu@LINUX_2.6 if present,
// otherwise use syscall(SYS_getcpu,...).
// May return -1 with errno == ENOSYS if the kernel doesn't
// support SYS_getcpu.
int GetCPU();

}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_HAVE_ELF_MEM_IMAGE

#endif  // ABSL_DEBUGGING_INTERNAL_VDSO_SUPPORT_H_
                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/leak_check.cc                             0000664 0000000 0000000 00000004574 14746647661 0025663 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Wrappers around lsan_interface functions.
//
// These are always-available run-time functions manipulating the LeakSanitizer,
// even when the lsan_interface (and LeakSanitizer) is not available. When
// LeakSanitizer is not linked in, these functions become no-op stubs.

#include "absl/debugging/leak_check.h"

#include "absl/base/attributes.h"
#include "absl/base/config.h"

#if defined(ABSL_HAVE_LEAK_SANITIZER)

#include <sanitizer/lsan_interface.h>

#if ABSL_HAVE_ATTRIBUTE_WEAK
extern "C" ABSL_ATTRIBUTE_WEAK int __lsan_is_turned_off();
#endif

namespace absl {
ABSL_NAMESPACE_BEGIN
bool HaveLeakSanitizer() { return true; }

#if ABSL_HAVE_ATTRIBUTE_WEAK
bool LeakCheckerIsActive() {
  return !(&__lsan_is_turned_off && __lsan_is_turned_off());
}
#else
bool LeakCheckerIsActive() { return true; }
#endif

bool FindAndReportLeaks() { return __lsan_do_recoverable_leak_check() != 0; }
void DoIgnoreLeak(const void* ptr) { __lsan_ignore_object(ptr); }
void RegisterLivePointers(const void* ptr, size_t size) {
  __lsan_register_root_region(ptr, size);
}
void UnRegisterLivePointers(const void* ptr, size_t size) {
  __lsan_unregister_root_region(ptr, size);
}
LeakCheckDisabler::LeakCheckDisabler() { __lsan_disable(); }
LeakCheckDisabler::~LeakCheckDisabler() { __lsan_enable(); }
ABSL_NAMESPACE_END
}  // namespace absl

#else  // defined(ABSL_HAVE_LEAK_SANITIZER)

namespace absl {
ABSL_NAMESPACE_BEGIN
bool HaveLeakSanitizer() { return false; }
bool LeakCheckerIsActive() { return false; }
void DoIgnoreLeak(const void*) { }
void RegisterLivePointers(const void*, size_t) { }
void UnRegisterLivePointers(const void*, size_t) { }
LeakCheckDisabler::LeakCheckDisabler() = default;
LeakCheckDisabler::~LeakCheckDisabler() = default;
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // defined(ABSL_HAVE_LEAK_SANITIZER)
                                                                                                                                    node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/leak_check.h                              0000664 0000000 0000000 00000012615 14746647661 0025520 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// -----------------------------------------------------------------------------
// File: leak_check.h
// -----------------------------------------------------------------------------
//
// This file contains functions that affect leak checking behavior within
// targets built with the LeakSanitizer (LSan), a memory leak detector that is
// integrated within the AddressSanitizer (ASan) as an additional component, or
// which can be used standalone. LSan and ASan are included (or can be provided)
// as additional components for most compilers such as Clang, gcc and MSVC.
// Note: this leak checking API is not yet supported in MSVC.
// Leak checking is enabled by default in all ASan builds.
//
// https://clang.llvm.org/docs/LeakSanitizer.html
// https://github.com/google/sanitizers/wiki/AddressSanitizerLeakSanitizer
//
// GCC and Clang both automatically enable LeakSanitizer when AddressSanitizer
// is enabled. To use the mode, simply pass `-fsanitize=address` to both the
// compiler and linker. An example Bazel command could be
//
//   $ bazel test --copt=-fsanitize=address --linkopt=-fsanitize=address ...
//
// GCC and Clang auto support a standalone LeakSanitizer mode (a mode which does
// not also use AddressSanitizer). To use the mode, simply pass
// `-fsanitize=leak` to both the compiler and linker. Since GCC does not
// currently provide a way of detecting this mode at compile-time, GCC users
// must also pass -DLEAK_SANITIZER to the compiler. An example Bazel command
// could be
//
//   $ bazel test --copt=-DLEAK_SANITIZER --copt=-fsanitize=leak
//     --linkopt=-fsanitize=leak ...
//
// -----------------------------------------------------------------------------
#ifndef ABSL_DEBUGGING_LEAK_CHECK_H_
#define ABSL_DEBUGGING_LEAK_CHECK_H_

#include <cstddef>

#include "absl/base/config.h"

namespace absl {
ABSL_NAMESPACE_BEGIN

// HaveLeakSanitizer()
//
// Returns true if a leak-checking sanitizer (either ASan or standalone LSan) is
// currently built into this target.
bool HaveLeakSanitizer();

// LeakCheckerIsActive()
//
// Returns true if a leak-checking sanitizer (either ASan or standalone LSan) is
// currently built into this target and is turned on.
bool LeakCheckerIsActive();

// DoIgnoreLeak()
//
// Implements `IgnoreLeak()` below. This function should usually
// not be called directly; calling `IgnoreLeak()` is preferred.
void DoIgnoreLeak(const void* ptr);

// IgnoreLeak()
//
// Instruct the leak sanitizer to ignore leak warnings on the object referenced
// by the passed pointer, as well as all heap objects transitively referenced
// by it. The passed object pointer can point to either the beginning of the
// object or anywhere within it.
//
// Example:
//
//   static T* obj = IgnoreLeak(new T(...));
//
// If the passed `ptr` does not point to an actively allocated object at the
// time `IgnoreLeak()` is called, the call is a no-op; if it is actively
// allocated, leak sanitizer will assume this object is referenced even if
// there is no actual reference in user memory.
//
template <typename T>
T* IgnoreLeak(T* ptr) {
  DoIgnoreLeak(ptr);
  return ptr;
}

// FindAndReportLeaks()
//
// If any leaks are detected, prints a leak report and returns true.  This
// function may be called repeatedly, and does not affect end-of-process leak
// checking.
//
// Example:
// if (FindAndReportLeaks()) {
//   ... diagnostic already printed. Exit with failure code.
//   exit(1)
// }
bool FindAndReportLeaks();

// LeakCheckDisabler
//
// This helper class indicates that any heap allocations done in the code block
// covered by the scoped object, which should be allocated on the stack, will
// not be reported as leaks. Leak check disabling will occur within the code
// block and any nested function calls within the code block.
//
// Example:
//
//   void Foo() {
//     LeakCheckDisabler disabler;
//     ... code that allocates objects whose leaks should be ignored ...
//   }
//
// REQUIRES: Destructor runs in same thread as constructor
class LeakCheckDisabler {
 public:
  LeakCheckDisabler();
  LeakCheckDisabler(const LeakCheckDisabler&) = delete;
  LeakCheckDisabler& operator=(const LeakCheckDisabler&) = delete;
  ~LeakCheckDisabler();
};

// RegisterLivePointers()
//
// Registers `ptr[0,size-1]` as pointers to memory that is still actively being
// referenced and for which leak checking should be ignored. This function is
// useful if you store pointers in mapped memory, for memory ranges that we know
// are correct but for which normal analysis would flag as leaked code.
void RegisterLivePointers(const void* ptr, size_t size);

// UnRegisterLivePointers()
//
// Deregisters the pointers previously marked as active in
// `RegisterLivePointers()`, enabling leak checking of those pointers.
void UnRegisterLivePointers(const void* ptr, size_t size);

ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_DEBUGGING_LEAK_CHECK_H_
                                                                                                                   node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/leak_check_fail_test.cc                   0000664 0000000 0000000 00000002745 14746647661 0027713 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <memory>

#include "gtest/gtest.h"
#include "absl/debugging/leak_check.h"
#include "absl/log/log.h"

namespace {

TEST(LeakCheckTest, LeakMemory) {
  // This test is expected to cause lsan failures on program exit. Therefore the
  // test will be run only by leak_check_test.sh, which will verify a
  // failed exit code.

  char* foo = strdup("lsan should complain about this leaked string");
  LOG(INFO) << "Should detect leaked string " << foo;
}

TEST(LeakCheckTest, LeakMemoryAfterDisablerScope) {
  // This test is expected to cause lsan failures on program exit. Therefore the
  // test will be run only by external_leak_check_test.sh, which will verify a
  // failed exit code.
  { absl::LeakCheckDisabler disabler; }
  char* foo = strdup("lsan should also complain about this leaked string");
  LOG(INFO) << "Re-enabled leak detection.Should detect leaked string " << foo;
}

}  // namespace
                           node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/leak_check_test.cc                        0000664 0000000 0000000 00000002520 14746647661 0026707 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <string>

#include "gtest/gtest.h"
#include "absl/base/config.h"
#include "absl/debugging/leak_check.h"
#include "absl/log/log.h"

namespace {

TEST(LeakCheckTest, IgnoreLeakSuppressesLeakedMemoryErrors) {
  if (!absl::LeakCheckerIsActive()) {
    GTEST_SKIP() << "LeakChecker is not active";
  }
  auto foo = absl::IgnoreLeak(new std::string("some ignored leaked string"));
  LOG(INFO) << "Ignoring leaked string " << foo;
}

TEST(LeakCheckTest, LeakCheckDisablerIgnoresLeak) {
  if (!absl::LeakCheckerIsActive()) {
    GTEST_SKIP() << "LeakChecker is not active";
  }
  absl::LeakCheckDisabler disabler;
  auto foo = new std::string("some string leaked while checks are disabled");
  LOG(INFO) << "Ignoring leaked string " << foo;
}

}  // namespace
                                                                                                                                                                                node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/stacktrace.cc                             0000664 0000000 0000000 00000012316 14746647661 0025727 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Produce stack trace.
//
// There are three different ways we can try to get the stack trace:
//
// 1) Our hand-coded stack-unwinder.  This depends on a certain stack
//    layout, which is used by gcc (and those systems using a
//    gcc-compatible ABI) on x86 systems, at least since gcc 2.95.
//    It uses the frame pointer to do its work.
//
// 2) The libunwind library.  This is still in development, and as a
//    separate library adds a new dependency, but doesn't need a frame
//    pointer.  It also doesn't call malloc.
//
// 3) The gdb unwinder -- also the one used by the c++ exception code.
//    It's obviously well-tested, but has a fatal flaw: it can call
//    malloc() from the unwinder.  This is a problem because we're
//    trying to use the unwinder to instrument malloc().
//
// Note: if you add a new implementation here, make sure it works
// correctly when absl::GetStackTrace() is called with max_depth == 0.
// Some code may do that.

#include "absl/debugging/stacktrace.h"

#include <atomic>

#include "absl/base/attributes.h"
#include "absl/base/port.h"
#include "absl/debugging/internal/stacktrace_config.h"

#if defined(ABSL_STACKTRACE_INL_HEADER)
#include ABSL_STACKTRACE_INL_HEADER
#else
# error Cannot calculate stack trace: will need to write for your environment

# include "absl/debugging/internal/stacktrace_aarch64-inl.inc"
# include "absl/debugging/internal/stacktrace_arm-inl.inc"
# include "absl/debugging/internal/stacktrace_emscripten-inl.inc"
# include "absl/debugging/internal/stacktrace_generic-inl.inc"
# include "absl/debugging/internal/stacktrace_powerpc-inl.inc"
# include "absl/debugging/internal/stacktrace_riscv-inl.inc"
# include "absl/debugging/internal/stacktrace_unimplemented-inl.inc"
# include "absl/debugging/internal/stacktrace_win32-inl.inc"
# include "absl/debugging/internal/stacktrace_x86-inl.inc"
#endif

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace {

typedef int (*Unwinder)(void**, int*, int, int, const void*, int*);
std::atomic<Unwinder> custom;

template <bool IS_STACK_FRAMES, bool IS_WITH_CONTEXT>
ABSL_ATTRIBUTE_ALWAYS_INLINE inline int Unwind(void** result, int* sizes,
                                               int max_depth, int skip_count,
                                               const void* uc,
                                               int* min_dropped_frames) {
  Unwinder f = &UnwindImpl<IS_STACK_FRAMES, IS_WITH_CONTEXT>;
  Unwinder g = custom.load(std::memory_order_acquire);
  if (g != nullptr) f = g;

  // Add 1 to skip count for the unwinder function itself
  int size = (*f)(result, sizes, max_depth, skip_count + 1, uc,
                  min_dropped_frames);
  // To disable tail call to (*f)(...)
  ABSL_BLOCK_TAIL_CALL_OPTIMIZATION();
  return size;
}

}  // anonymous namespace

ABSL_ATTRIBUTE_NOINLINE ABSL_ATTRIBUTE_NO_TAIL_CALL int GetStackFrames(
    void** result, int* sizes, int max_depth, int skip_count) {
  return Unwind<true, false>(result, sizes, max_depth, skip_count, nullptr,
                             nullptr);
}

ABSL_ATTRIBUTE_NOINLINE ABSL_ATTRIBUTE_NO_TAIL_CALL int
GetStackFramesWithContext(void** result, int* sizes, int max_depth,
                          int skip_count, const void* uc,
                          int* min_dropped_frames) {
  return Unwind<true, true>(result, sizes, max_depth, skip_count, uc,
                            min_dropped_frames);
}

ABSL_ATTRIBUTE_NOINLINE ABSL_ATTRIBUTE_NO_TAIL_CALL int GetStackTrace(
    void** result, int max_depth, int skip_count) {
  return Unwind<false, false>(result, nullptr, max_depth, skip_count, nullptr,
                              nullptr);
}

ABSL_ATTRIBUTE_NOINLINE ABSL_ATTRIBUTE_NO_TAIL_CALL int
GetStackTraceWithContext(void** result, int max_depth, int skip_count,
                         const void* uc, int* min_dropped_frames) {
  return Unwind<false, true>(result, nullptr, max_depth, skip_count, uc,
                             min_dropped_frames);
}

void SetStackUnwinder(Unwinder w) {
  custom.store(w, std::memory_order_release);
}

int DefaultStackUnwinder(void** pcs, int* sizes, int depth, int skip,
                         const void* uc, int* min_dropped_frames) {
  skip++;  // For this function
  Unwinder f = nullptr;
  if (sizes == nullptr) {
    if (uc == nullptr) {
      f = &UnwindImpl<false, false>;
    } else {
      f = &UnwindImpl<false, true>;
    }
  } else {
    if (uc == nullptr) {
      f = &UnwindImpl<true, false>;
    } else {
      f = &UnwindImpl<true, true>;
    }
  }
  volatile int x = 0;
  int n = (*f)(pcs, sizes, depth, skip, uc, min_dropped_frames);
  x = 1; (void) x;  // To disable tail call to (*f)(...)
  return n;
}

ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/stacktrace.h                              0000664 0000000 0000000 00000024131 14746647661 0025567 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// -----------------------------------------------------------------------------
// File: stacktrace.h
// -----------------------------------------------------------------------------
//
// This file contains routines to extract the current stack trace and associated
// stack frames. These functions are thread-safe and async-signal-safe.
//
// Note that stack trace functionality is platform dependent and requires
// additional support from the compiler/build system in most cases. (That is,
// this functionality generally only works on platforms/builds that have been
// specifically configured to support it.)
//
// Note: stack traces in Abseil that do not utilize a symbolizer will result in
// frames consisting of function addresses rather than human-readable function
// names. (See symbolize.h for information on symbolizing these values.)

#ifndef ABSL_DEBUGGING_STACKTRACE_H_
#define ABSL_DEBUGGING_STACKTRACE_H_

#include "absl/base/config.h"

namespace absl {
ABSL_NAMESPACE_BEGIN

// GetStackFrames()
//
// Records program counter values for up to `max_depth` frames, skipping the
// most recent `skip_count` stack frames, stores their corresponding values
// and sizes in `results` and `sizes` buffers, and returns the number of frames
// stored. (Note that the frame generated for the `absl::GetStackFrames()`
// routine itself is also skipped.)
//
// Example:
//
//      main() { foo(); }
//      foo() { bar(); }
//      bar() {
//        void* result[10];
//        int sizes[10];
//        int depth = absl::GetStackFrames(result, sizes, 10, 1);
//      }
//
// The current stack frame would consist of three function calls: `bar()`,
// `foo()`, and then `main()`; however, since the `GetStackFrames()` call sets
// `skip_count` to `1`, it will skip the frame for `bar()`, the most recently
// invoked function call. It will therefore return 2 and fill `result` with
// program counters within the following functions:
//
//      result[0]       foo()
//      result[1]       main()
//
// (Note: in practice, a few more entries after `main()` may be added to account
// for startup processes.)
//
// Corresponding stack frame sizes will also be recorded:
//
//    sizes[0]       16
//    sizes[1]       16
//
// (Stack frame sizes of `16` above are just for illustration purposes.)
//
// Stack frame sizes of 0 or less indicate that those frame sizes couldn't
// be identified.
//
// This routine may return fewer stack frame entries than are
// available. Also note that `result` and `sizes` must both be non-null.
extern int GetStackFrames(void** result, int* sizes, int max_depth,
                          int skip_count);

// GetStackFramesWithContext()
//
// Records program counter values obtained from a signal handler. Records
// program counter values for up to `max_depth` frames, skipping the most recent
// `skip_count` stack frames, stores their corresponding values and sizes in
// `results` and `sizes` buffers, and returns the number of frames stored. (Note
// that the frame generated for the `absl::GetStackFramesWithContext()` routine
// itself is also skipped.)
//
// The `uc` parameter, if non-null, should be a pointer to a `ucontext_t` value
// passed to a signal handler registered via the `sa_sigaction` field of a
// `sigaction` struct. (See
// http://man7.org/linux/man-pages/man2/sigaction.2.html.) The `uc` value may
// help a stack unwinder to provide a better stack trace under certain
// conditions. `uc` may safely be null.
//
// The `min_dropped_frames` output parameter, if non-null, points to the
// location to note any dropped stack frames, if any, due to buffer limitations
// or other reasons. (This value will be set to `0` if no frames were dropped.)
// The number of total stack frames is guaranteed to be >= skip_count +
// max_depth + *min_dropped_frames.
extern int GetStackFramesWithContext(void** result, int* sizes, int max_depth,
                                     int skip_count, const void* uc,
                                     int* min_dropped_frames);

// GetStackTrace()
//
// Records program counter values for up to `max_depth` frames, skipping the
// most recent `skip_count` stack frames, stores their corresponding values
// in `results`, and returns the number of frames
// stored. Note that this function is similar to `absl::GetStackFrames()`
// except that it returns the stack trace only, and not stack frame sizes.
//
// Example:
//
//      main() { foo(); }
//      foo() { bar(); }
//      bar() {
//        void* result[10];
//        int depth = absl::GetStackTrace(result, 10, 1);
//      }
//
// This produces:
//
//      result[0]       foo
//      result[1]       main
//           ....       ...
//
// `result` must not be null.
extern int GetStackTrace(void** result, int max_depth, int skip_count);

// GetStackTraceWithContext()
//
// Records program counter values obtained from a signal handler. Records
// program counter values for up to `max_depth` frames, skipping the most recent
// `skip_count` stack frames, stores their corresponding values in `results`,
// and returns the number of frames stored. (Note that the frame generated for
// the `absl::GetStackFramesWithContext()` routine itself is also skipped.)
//
// The `uc` parameter, if non-null, should be a pointer to a `ucontext_t` value
// passed to a signal handler registered via the `sa_sigaction` field of a
// `sigaction` struct. (See
// http://man7.org/linux/man-pages/man2/sigaction.2.html.) The `uc` value may
// help a stack unwinder to provide a better stack trace under certain
// conditions. `uc` may safely be null.
//
// The `min_dropped_frames` output parameter, if non-null, points to the
// location to note any dropped stack frames, if any, due to buffer limitations
// or other reasons. (This value will be set to `0` if no frames were dropped.)
// The number of total stack frames is guaranteed to be >= skip_count +
// max_depth + *min_dropped_frames.
extern int GetStackTraceWithContext(void** result, int max_depth,
                                    int skip_count, const void* uc,
                                    int* min_dropped_frames);

// SetStackUnwinder()
//
// Provides a custom function for unwinding stack frames that will be used in
// place of the default stack unwinder when invoking the static
// GetStack{Frames,Trace}{,WithContext}() functions above.
//
// The arguments passed to the unwinder function will match the
// arguments passed to `absl::GetStackFramesWithContext()` except that sizes
// will be non-null iff the caller is interested in frame sizes.
//
// If unwinder is set to null, we revert to the default stack-tracing behavior.
//
// *****************************************************************************
// WARNING
// *****************************************************************************
//
// absl::SetStackUnwinder is not suitable for general purpose use.  It is
// provided for custom runtimes.
// Some things to watch out for when calling `absl::SetStackUnwinder()`:
//
// (a) The unwinder may be called from within signal handlers and
// therefore must be async-signal-safe.
//
// (b) Even after a custom stack unwinder has been unregistered, other
// threads may still be in the process of using that unwinder.
// Therefore do not clean up any state that may be needed by an old
// unwinder.
// *****************************************************************************
extern void SetStackUnwinder(int (*unwinder)(void** pcs, int* sizes,
                                             int max_depth, int skip_count,
                                             const void* uc,
                                             int* min_dropped_frames));

// DefaultStackUnwinder()
//
// Records program counter values of up to `max_depth` frames, skipping the most
// recent `skip_count` stack frames, and stores their corresponding values in
// `pcs`. (Note that the frame generated for this call itself is also skipped.)
// This function acts as a generic stack-unwinder; prefer usage of the more
// specific `GetStack{Trace,Frames}{,WithContext}()` functions above.
//
// If you have set your own stack unwinder (with the `SetStackUnwinder()`
// function above, you can still get the default stack unwinder by calling
// `DefaultStackUnwinder()`, which will ignore any previously set stack unwinder
// and use the default one instead.
//
// Because this function is generic, only `pcs` is guaranteed to be non-null
// upon return. It is legal for `sizes`, `uc`, and `min_dropped_frames` to all
// be null when called.
//
// The semantics are the same as the corresponding `GetStack*()` function in the
// case where `absl::SetStackUnwinder()` was never called. Equivalents are:
//
//                       null sizes         |        non-nullptr sizes
//             |==========================================================|
//     null uc | GetStackTrace()            | GetStackFrames()            |
// non-null uc | GetStackTraceWithContext() | GetStackFramesWithContext() |
//             |==========================================================|
extern int DefaultStackUnwinder(void** pcs, int* sizes, int max_depth,
                                int skip_count, const void* uc,
                                int* min_dropped_frames);

namespace debugging_internal {
// Returns true for platforms which are expected to have functioning stack trace
// implementations. Intended to be used for tests which want to exclude
// verification of logic known to be broken because stack traces are not
// working.
extern bool StackTraceWorksForTest();
}  // namespace debugging_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_DEBUGGING_STACKTRACE_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/stacktrace_benchmark.cc                   0000664 0000000 0000000 00000003321 14746647661 0027735 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 The Abseil Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/base/attributes.h"
#include "absl/base/config.h"
#include "absl/base/optimization.h"
#include "absl/debugging/stacktrace.h"
#include "benchmark/benchmark.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace {

static constexpr int kMaxStackDepth = 100;
static constexpr int kCacheSize = (1 << 16);
void* pcs[kMaxStackDepth];

ABSL_ATTRIBUTE_NOINLINE void func(benchmark::State& state, int x, int depth) {
  if (x <= 0) {
    // Touch a significant amount of memory so that the stack is likely to be
    // not cached in the L1 cache.
    state.PauseTiming();
    int* arr = new int[kCacheSize];
    for (int i = 0; i < kCacheSize; ++i) benchmark::DoNotOptimize(arr[i] = 100);
    delete[] arr;
    state.ResumeTiming();
    benchmark::DoNotOptimize(absl::GetStackTrace(pcs, depth, 0));
    return;
  }
  ABSL_BLOCK_TAIL_CALL_OPTIMIZATION();
  func(state, --x, depth);
}

void BM_GetStackTrace(benchmark::State& state) {
  int depth = state.range(0);
  for (auto s : state) {
    func(state, depth, depth);
  }
}

BENCHMARK(BM_GetStackTrace)->DenseRange(10, kMaxStackDepth, 10);
}  // namespace
ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/stacktrace_test.cc                        0000664 0000000 0000000 00000002667 14746647661 0026776 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/debugging/stacktrace.h"

#include "gtest/gtest.h"
#include "absl/base/macros.h"
#include "absl/base/optimization.h"

namespace {

// This test is currently only known to pass on Linux x86_64/aarch64.
#if defined(__linux__) && (defined(__x86_64__) || defined(__aarch64__))
ABSL_ATTRIBUTE_NOINLINE void Unwind(void* p) {
  ABSL_ATTRIBUTE_UNUSED static void* volatile sink = p;
  constexpr int kSize = 16;
  void* stack[kSize];
  int frames[kSize];
  absl::GetStackTrace(stack, kSize, 0);
  absl::GetStackFrames(stack, frames, kSize, 0);
}

ABSL_ATTRIBUTE_NOINLINE void HugeFrame() {
  char buffer[1 << 20];
  Unwind(buffer);
  ABSL_BLOCK_TAIL_CALL_OPTIMIZATION();
}

TEST(StackTrace, HugeFrame) {
  // Ensure that the unwinder is not confused by very large stack frames.
  HugeFrame();
  ABSL_BLOCK_TAIL_CALL_OPTIMIZATION();
}
#endif

}  // namespace
                                                                         node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/symbolize.cc                              0000664 0000000 0000000 00000003124 14746647661 0025615 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/debugging/symbolize.h"

#ifdef _WIN32
#include <winapifamily.h>
#if !(WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)) || \
    WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
// UWP doesn't have access to win32 APIs.
#define ABSL_INTERNAL_HAVE_SYMBOLIZE_WIN32
#endif
#endif

// Emscripten symbolization relies on JS. Do not use them in standalone mode.
#if defined(__EMSCRIPTEN__) && !defined(STANDALONE_WASM)
#define ABSL_INTERNAL_HAVE_SYMBOLIZE_WASM
#endif

#if defined(ABSL_INTERNAL_HAVE_ELF_SYMBOLIZE)
#include "absl/debugging/symbolize_elf.inc"
#elif defined(ABSL_INTERNAL_HAVE_SYMBOLIZE_WIN32)
// The Windows Symbolizer only works if PDB files containing the debug info
// are available to the program at runtime.
#include "absl/debugging/symbolize_win32.inc"
#elif defined(__APPLE__)
#include "absl/debugging/symbolize_darwin.inc"
#elif defined(ABSL_INTERNAL_HAVE_SYMBOLIZE_WASM)
#include "absl/debugging/symbolize_emscripten.inc"
#else
#include "absl/debugging/symbolize_unimplemented.inc"
#endif
                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/symbolize.h                               0000664 0000000 0000000 00000007061 14746647661 0025463 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// -----------------------------------------------------------------------------
// File: symbolize.h
// -----------------------------------------------------------------------------
//
// This file configures the Abseil symbolizer for use in converting instruction
// pointer addresses (program counters) into human-readable names (function
// calls, etc.) within Abseil code.
//
// The symbolizer may be invoked from several sources:
//
//   * Implicitly, through the installation of an Abseil failure signal handler.
//     (See failure_signal_handler.h for more information.)
//   * By calling `Symbolize()` directly on a program counter you obtain through
//     `absl::GetStackTrace()` or `absl::GetStackFrames()`. (See stacktrace.h
//     for more information.
//   * By calling `Symbolize()` directly on a program counter you obtain through
//     other means (which would be platform-dependent).
//
// In all of the above cases, the symbolizer must first be initialized before
// any program counter values can be symbolized. If you are installing a failure
// signal handler, initialize the symbolizer before you do so.
//
// Example:
//
//   int main(int argc, char** argv) {
//     // Initialize the Symbolizer before installing the failure signal handler
//     absl::InitializeSymbolizer(argv[0]);
//
//     // Now you may install the failure signal handler
//     absl::FailureSignalHandlerOptions options;
//     absl::InstallFailureSignalHandler(options);
//
//     // Start running your main program
//     ...
//     return 0;
//  }
//
#ifndef ABSL_DEBUGGING_SYMBOLIZE_H_
#define ABSL_DEBUGGING_SYMBOLIZE_H_

#include "absl/debugging/internal/symbolize.h"

namespace absl {
ABSL_NAMESPACE_BEGIN

// InitializeSymbolizer()
//
// Initializes the program counter symbolizer, given the path of the program
// (typically obtained through `main()`s `argv[0]`). The Abseil symbolizer
// allows you to read program counters (instruction pointer values) using their
// human-readable names within output such as stack traces.
//
// Example:
//
// int main(int argc, char *argv[]) {
//   absl::InitializeSymbolizer(argv[0]);
//   // Now you can use the symbolizer
// }
void InitializeSymbolizer(const char* argv0);
//
// Symbolize()
//
// Symbolizes a program counter (instruction pointer value) `pc` and, on
// success, writes the name to `out`. The symbol name is demangled, if possible.
// Note that the symbolized name may be truncated and will be NUL-terminated.
// Demangling is supported for symbols generated by GCC 3.x or newer). Returns
// `false` on failure.
//
// Example:
//
//   // Print a program counter and its symbol name.
//   static void DumpPCAndSymbol(void *pc) {
//     char tmp[1024];
//     const char *symbol = "(unknown)";
//     if (absl::Symbolize(pc, tmp, sizeof(tmp))) {
//       symbol = tmp;
//     }
//     absl::PrintF("%p  %s\n", pc, symbol);
//  }
bool Symbolize(const void *pc, char *out, int out_size);

ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_DEBUGGING_SYMBOLIZE_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/symbolize_darwin.inc                      0000664 0000000 0000000 00000006335 14746647661 0027354 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <cxxabi.h>
#include <execinfo.h>

#include <algorithm>
#include <cstring>

#include "absl/base/internal/raw_logging.h"
#include "absl/debugging/internal/demangle.h"
#include "absl/strings/numbers.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"

namespace absl {
ABSL_NAMESPACE_BEGIN

void InitializeSymbolizer(const char*) {}

namespace debugging_internal {
namespace {

static std::string GetSymbolString(absl::string_view backtrace_line) {
  // Example Backtrace lines:
  // 0   libimaging_shared.dylib             0x018c152a
  // _ZNSt11_Deque_baseIN3nik7mediadb4PageESaIS2_EE17_M_initialize_mapEm + 3478
  //
  // or
  // 0   libimaging_shared.dylib             0x0000000001895c39
  // _ZN3nik4util19register_shared_ptrINS_3gpu7TextureEEEvPKvS5_ + 39
  //
  // or
  // 0   mysterious_app                      0x0124000120120009 main + 17
  auto address_pos = backtrace_line.find(" 0x");
  if (address_pos == absl::string_view::npos) return std::string();
  absl::string_view symbol_view = backtrace_line.substr(address_pos + 1);

  auto space_pos = symbol_view.find(" ");
  if (space_pos == absl::string_view::npos) return std::string();
  symbol_view = symbol_view.substr(space_pos + 1);  // to mangled symbol

  auto plus_pos = symbol_view.find(" + ");
  if (plus_pos == absl::string_view::npos) return std::string();
  symbol_view = symbol_view.substr(0, plus_pos);  // strip remainng

  return std::string(symbol_view);
}

}  // namespace
}  // namespace debugging_internal

bool Symbolize(const void* pc, char* out, int out_size) {
  if (out_size <= 0 || pc == nullptr) {
    out = nullptr;
    return false;
  }

  // This allocates a char* array.
  char** frame_strings = backtrace_symbols(const_cast<void**>(&pc), 1);

  if (frame_strings == nullptr) return false;

  std::string symbol = debugging_internal::GetSymbolString(frame_strings[0]);
  free(frame_strings);

  char tmp_buf[1024];
  if (debugging_internal::Demangle(symbol.c_str(), tmp_buf, sizeof(tmp_buf))) {
    size_t len = strlen(tmp_buf);
    if (len + 1 <= static_cast<size_t>(out_size)) {  // +1 for '\0'
      assert(len < sizeof(tmp_buf));
      memmove(out, tmp_buf, len + 1);
    }
  } else {
    strncpy(out, symbol.c_str(), static_cast<size_t>(out_size));
  }

  if (out[out_size - 1] != '\0') {
    // strncpy() does not '\0' terminate when it truncates.
    static constexpr char kEllipsis[] = "...";
    size_t ellipsis_size =
        std::min(sizeof(kEllipsis) - 1, static_cast<size_t>(out_size) - 1);
    memcpy(out + out_size - ellipsis_size - 1, kEllipsis, ellipsis_size);
    out[out_size - 1] = '\0';
  }

  return true;
}

ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/symbolize_elf.inc                         0000664 0000000 0000000 00000164666 14746647661 0026652 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This library provides Symbolize() function that symbolizes program
// counters to their corresponding symbol names on linux platforms.
// This library has a minimal implementation of an ELF symbol table
// reader (i.e. it doesn't depend on libelf, etc.).
//
// The algorithm used in Symbolize() is as follows.
//
//   1. Go through a list of maps in /proc/self/maps and find the map
//   containing the program counter.
//
//   2. Open the mapped file and find a regular symbol table inside.
//   Iterate over symbols in the symbol table and look for the symbol
//   containing the program counter.  If such a symbol is found,
//   obtain the symbol name, and demangle the symbol if possible.
//   If the symbol isn't found in the regular symbol table (binary is
//   stripped), try the same thing with a dynamic symbol table.
//
// Note that Symbolize() is originally implemented to be used in
// signal handlers, hence it doesn't use malloc() and other unsafe
// operations.  It should be both thread-safe and async-signal-safe.
//
// Implementation note:
//
// We don't use heaps but only use stacks.  We want to reduce the
// stack consumption so that the symbolizer can run on small stacks.
//
// Here are some numbers collected with GCC 4.1.0 on x86:
// - sizeof(Elf32_Sym)  = 16
// - sizeof(Elf32_Shdr) = 40
// - sizeof(Elf64_Sym)  = 24
// - sizeof(Elf64_Shdr) = 64
//
// This implementation is intended to be async-signal-safe but uses some
// functions which are not guaranteed to be so, such as memchr() and
// memmove().  We assume they are async-signal-safe.

#include <dlfcn.h>
#include <elf.h>
#include <fcntl.h>
#include <link.h>  // For ElfW() macro.
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#include <algorithm>
#include <array>
#include <atomic>
#include <cerrno>
#include <cinttypes>
#include <climits>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>

#include "absl/base/casts.h"
#include "absl/base/dynamic_annotations.h"
#include "absl/base/internal/low_level_alloc.h"
#include "absl/base/internal/raw_logging.h"
#include "absl/base/internal/spinlock.h"
#include "absl/base/port.h"
#include "absl/debugging/internal/demangle.h"
#include "absl/debugging/internal/vdso_support.h"
#include "absl/strings/string_view.h"

#if defined(__FreeBSD__) && !defined(ElfW)
#define ElfW(x) __ElfN(x)
#endif

namespace absl {
ABSL_NAMESPACE_BEGIN

// Value of argv[0]. Used by MaybeInitializeObjFile().
static char *argv0_value = nullptr;

void InitializeSymbolizer(const char *argv0) {
#ifdef ABSL_HAVE_VDSO_SUPPORT
  // We need to make sure VDSOSupport::Init() is called before any setuid or
  // chroot calls, so InitializeSymbolizer() should be called very early in the
  // life of a program.
  absl::debugging_internal::VDSOSupport::Init();
#endif
  if (argv0_value != nullptr) {
    free(argv0_value);
    argv0_value = nullptr;
  }
  if (argv0 != nullptr && argv0[0] != '\0') {
    argv0_value = strdup(argv0);
  }
}

namespace debugging_internal {
namespace {

// Re-runs fn until it doesn't cause EINTR.
#define NO_INTR(fn) \
  do {              \
  } while ((fn) < 0 && errno == EINTR)

// On Linux, ELF_ST_* are defined in <linux/elf.h>.  To make this portable
// we define our own ELF_ST_BIND and ELF_ST_TYPE if not available.
#ifndef ELF_ST_BIND
#define ELF_ST_BIND(info) (((unsigned char)(info)) >> 4)
#endif

#ifndef ELF_ST_TYPE
#define ELF_ST_TYPE(info) (((unsigned char)(info)) & 0xF)
#endif

// Some platforms use a special .opd section to store function pointers.
const char kOpdSectionName[] = ".opd";

#if (defined(__powerpc__) && !(_CALL_ELF > 1)) || defined(__ia64)
// Use opd section for function descriptors on these platforms, the function
// address is the first word of the descriptor.
enum { kPlatformUsesOPDSections = 1 };
#else  // not PPC or IA64
enum { kPlatformUsesOPDSections = 0 };
#endif

// This works for PowerPC & IA64 only.  A function descriptor consist of two
// pointers and the first one is the function's entry.
const size_t kFunctionDescriptorSize = sizeof(void *) * 2;

const int kMaxDecorators = 10;  // Seems like a reasonable upper limit.

struct InstalledSymbolDecorator {
  SymbolDecorator fn;
  void *arg;
  int ticket;
};

int g_num_decorators;
InstalledSymbolDecorator g_decorators[kMaxDecorators];

struct FileMappingHint {
  const void *start;
  const void *end;
  uint64_t offset;
  const char *filename;
};

// Protects g_decorators.
// We are using SpinLock and not a Mutex here, because we may be called
// from inside Mutex::Lock itself, and it prohibits recursive calls.
// This happens in e.g. base/stacktrace_syscall_unittest.
// Moreover, we are using only TryLock(), if the decorator list
// is being modified (is busy), we skip all decorators, and possibly
// loose some info. Sorry, that's the best we could do.
ABSL_CONST_INIT absl::base_internal::SpinLock g_decorators_mu(
    absl::kConstInit, absl::base_internal::SCHEDULE_KERNEL_ONLY);

const int kMaxFileMappingHints = 8;
int g_num_file_mapping_hints;
FileMappingHint g_file_mapping_hints[kMaxFileMappingHints];
// Protects g_file_mapping_hints.
ABSL_CONST_INIT absl::base_internal::SpinLock g_file_mapping_mu(
    absl::kConstInit, absl::base_internal::SCHEDULE_KERNEL_ONLY);

// Async-signal-safe function to zero a buffer.
// memset() is not guaranteed to be async-signal-safe.
static void SafeMemZero(void* p, size_t size) {
  unsigned char *c = static_cast<unsigned char *>(p);
  while (size--) {
    *c++ = 0;
  }
}

struct ObjFile {
  ObjFile()
      : filename(nullptr),
        start_addr(nullptr),
        end_addr(nullptr),
        offset(0),
        fd(-1),
        elf_type(-1) {
    SafeMemZero(&elf_header, sizeof(elf_header));
    SafeMemZero(&phdr[0], sizeof(phdr));
  }

  char *filename;
  const void *start_addr;
  const void *end_addr;
  uint64_t offset;

  // The following fields are initialized on the first access to the
  // object file.
  int fd;
  int elf_type;
  ElfW(Ehdr) elf_header;

  // PT_LOAD program header describing executable code.
  // Normally we expect just one, but SWIFT binaries have two.
  // CUDA binaries have 3 (see cr/473913254 description).
  std::array<ElfW(Phdr), 4> phdr;
};

// Build 4-way associative cache for symbols. Within each cache line, symbols
// are replaced in LRU order.
enum {
  ASSOCIATIVITY = 4,
};
struct SymbolCacheLine {
  const void *pc[ASSOCIATIVITY];
  char *name[ASSOCIATIVITY];

  // age[i] is incremented when a line is accessed. it's reset to zero if the
  // i'th entry is read.
  uint32_t age[ASSOCIATIVITY];
};

// ---------------------------------------------------------------
// An async-signal-safe arena for LowLevelAlloc
static std::atomic<base_internal::LowLevelAlloc::Arena *> g_sig_safe_arena;

static base_internal::LowLevelAlloc::Arena *SigSafeArena() {
  return g_sig_safe_arena.load(std::memory_order_acquire);
}

static void InitSigSafeArena() {
  if (SigSafeArena() == nullptr) {
    base_internal::LowLevelAlloc::Arena *new_arena =
        base_internal::LowLevelAlloc::NewArena(
            base_internal::LowLevelAlloc::kAsyncSignalSafe);
    base_internal::LowLevelAlloc::Arena *old_value = nullptr;
    if (!g_sig_safe_arena.compare_exchange_strong(old_value, new_arena,
                                                  std::memory_order_release,
                                                  std::memory_order_relaxed)) {
      // We lost a race to allocate an arena; deallocate.
      base_internal::LowLevelAlloc::DeleteArena(new_arena);
    }
  }
}

// ---------------------------------------------------------------
// An AddrMap is a vector of ObjFile, using SigSafeArena() for allocation.

class AddrMap {
 public:
  AddrMap() : size_(0), allocated_(0), obj_(nullptr) {}
  ~AddrMap() { base_internal::LowLevelAlloc::Free(obj_); }
  size_t Size() const { return size_; }
  ObjFile *At(size_t i) { return &obj_[i]; }
  ObjFile *Add();
  void Clear();

 private:
  size_t size_;       // count of valid elements (<= allocated_)
  size_t allocated_;  // count of allocated elements
  ObjFile *obj_;      // array of allocated_ elements
  AddrMap(const AddrMap &) = delete;
  AddrMap &operator=(const AddrMap &) = delete;
};

void AddrMap::Clear() {
  for (size_t i = 0; i != size_; i++) {
    At(i)->~ObjFile();
  }
  size_ = 0;
}

ObjFile *AddrMap::Add() {
  if (size_ == allocated_) {
    size_t new_allocated = allocated_ * 2 + 50;
    ObjFile *new_obj_ =
        static_cast<ObjFile *>(base_internal::LowLevelAlloc::AllocWithArena(
            new_allocated * sizeof(*new_obj_), SigSafeArena()));
    if (obj_) {
      memcpy(new_obj_, obj_, allocated_ * sizeof(*new_obj_));
      base_internal::LowLevelAlloc::Free(obj_);
    }
    obj_ = new_obj_;
    allocated_ = new_allocated;
  }
  return new (&obj_[size_++]) ObjFile;
}

class CachingFile {
 public:
  // Setup reader for fd that uses buf[0, buf_size-1] as a cache.
  CachingFile(int fd, char *buf, size_t buf_size)
      : fd_(fd),
        cache_(buf),
        cache_size_(buf_size),
        cache_start_(0),
        cache_limit_(0) {}

  int fd() const { return fd_; }
  ssize_t ReadFromOffset(void *buf, size_t count, off_t offset);
  bool ReadFromOffsetExact(void *buf, size_t count, off_t offset);

 private:
  // Bytes [cache_start_, cache_limit_-1] from fd_ are stored in
  // a prefix of cache_[0, cache_size_-1].
  int fd_;
  char *cache_;
  size_t cache_size_;
  off_t cache_start_;
  off_t cache_limit_;
};

// ---------------------------------------------------------------

enum FindSymbolResult { SYMBOL_NOT_FOUND = 1, SYMBOL_TRUNCATED, SYMBOL_FOUND };

class Symbolizer {
 public:
  Symbolizer();
  ~Symbolizer();
  const char *GetSymbol(const void *const pc);

 private:
  char *CopyString(const char *s) {
    size_t len = strlen(s);
    char *dst = static_cast<char *>(
        base_internal::LowLevelAlloc::AllocWithArena(len + 1, SigSafeArena()));
    ABSL_RAW_CHECK(dst != nullptr, "out of memory");
    memcpy(dst, s, len + 1);
    return dst;
  }
  ObjFile *FindObjFile(const void *const start,
                       size_t size) ABSL_ATTRIBUTE_NOINLINE;
  static bool RegisterObjFile(const char *filename,
                              const void *const start_addr,
                              const void *const end_addr, uint64_t offset,
                              void *arg);
  SymbolCacheLine *GetCacheLine(const void *const pc);
  const char *FindSymbolInCache(const void *const pc);
  const char *InsertSymbolInCache(const void *const pc, const char *name);
  void AgeSymbols(SymbolCacheLine *line);
  void ClearAddrMap();
  FindSymbolResult GetSymbolFromObjectFile(const ObjFile &obj,
                                           const void *const pc,
                                           const ptrdiff_t relocation,
                                           char *out, size_t out_size,
                                           char *tmp_buf, size_t tmp_buf_size);
  const char *GetUncachedSymbol(const void *pc);

  enum {
    SYMBOL_BUF_SIZE = 3072,
    TMP_BUF_SIZE = 1024,
    SYMBOL_CACHE_LINES = 128,
    FILE_CACHE_SIZE = 8192,
  };

  AddrMap addr_map_;

  bool ok_;
  bool addr_map_read_;

  char symbol_buf_[SYMBOL_BUF_SIZE];
  char file_cache_[FILE_CACHE_SIZE];

  // tmp_buf_ will be used to store arrays of ElfW(Shdr) and ElfW(Sym)
  // so we ensure that tmp_buf_ is properly aligned to store either.
  alignas(16) char tmp_buf_[TMP_BUF_SIZE];
  static_assert(alignof(ElfW(Shdr)) <= 16,
                "alignment of tmp buf too small for Shdr");
  static_assert(alignof(ElfW(Sym)) <= 16,
                "alignment of tmp buf too small for Sym");

  SymbolCacheLine symbol_cache_[SYMBOL_CACHE_LINES];
};

static std::atomic<Symbolizer *> g_cached_symbolizer;

}  // namespace

static size_t SymbolizerSize() {
#if defined(__wasm__) || defined(__asmjs__)
  auto pagesize = static_cast<size_t>(getpagesize());
#else
  auto pagesize = static_cast<size_t>(sysconf(_SC_PAGESIZE));
#endif
  return ((sizeof(Symbolizer) - 1) / pagesize + 1) * pagesize;
}

// Return (and set null) g_cached_symbolized_state if it is not null.
// Otherwise return a new symbolizer.
static Symbolizer *AllocateSymbolizer() {
  InitSigSafeArena();
  Symbolizer *symbolizer =
      g_cached_symbolizer.exchange(nullptr, std::memory_order_acquire);
  if (symbolizer != nullptr) {
    return symbolizer;
  }
  return new (base_internal::LowLevelAlloc::AllocWithArena(
      SymbolizerSize(), SigSafeArena())) Symbolizer();
}

// Set g_cached_symbolize_state to s if it is null, otherwise
// delete s.
static void FreeSymbolizer(Symbolizer *s) {
  Symbolizer *old_cached_symbolizer = nullptr;
  if (!g_cached_symbolizer.compare_exchange_strong(old_cached_symbolizer, s,
                                                   std::memory_order_release,
                                                   std::memory_order_relaxed)) {
    s->~Symbolizer();
    base_internal::LowLevelAlloc::Free(s);
  }
}

Symbolizer::Symbolizer() : ok_(true), addr_map_read_(false) {
  for (SymbolCacheLine &symbol_cache_line : symbol_cache_) {
    for (size_t j = 0; j < ABSL_ARRAYSIZE(symbol_cache_line.name); ++j) {
      symbol_cache_line.pc[j] = nullptr;
      symbol_cache_line.name[j] = nullptr;
      symbol_cache_line.age[j] = 0;
    }
  }
}

Symbolizer::~Symbolizer() {
  for (SymbolCacheLine &symbol_cache_line : symbol_cache_) {
    for (char *s : symbol_cache_line.name) {
      base_internal::LowLevelAlloc::Free(s);
    }
  }
  ClearAddrMap();
}

// We don't use assert() since it's not guaranteed to be
// async-signal-safe.  Instead we define a minimal assertion
// macro. So far, we don't need pretty printing for __FILE__, etc.
#define SAFE_ASSERT(expr) ((expr) ? static_cast<void>(0) : abort())

// Read up to "count" bytes from file descriptor "fd" into the buffer
// starting at "buf" while handling short reads and EINTR.  On
// success, return the number of bytes read.  Otherwise, return -1.
static ssize_t ReadPersistent(int fd, void *buf, size_t count) {
  SAFE_ASSERT(fd >= 0);
  SAFE_ASSERT(count <= SSIZE_MAX);
  char *buf0 = reinterpret_cast<char *>(buf);
  size_t num_bytes = 0;
  while (num_bytes < count) {
    ssize_t len;
    NO_INTR(len = read(fd, buf0 + num_bytes, count - num_bytes));
    if (len < 0) {  // There was an error other than EINTR.
      ABSL_RAW_LOG(WARNING, "read failed: errno=%d", errno);
      return -1;
    }
    if (len == 0) {  // Reached EOF.
      break;
    }
    num_bytes += static_cast<size_t>(len);
  }
  SAFE_ASSERT(num_bytes <= count);
  return static_cast<ssize_t>(num_bytes);
}

// Read up to "count" bytes from "offset" into the buffer starting at "buf",
// while handling short reads and EINTR.  On success, return the number of bytes
// read.  Otherwise, return -1.
ssize_t CachingFile::ReadFromOffset(void *buf, size_t count, off_t offset) {
  char *dst = static_cast<char *>(buf);
  size_t read = 0;
  while (read < count) {
    // Look in cache first.
    if (offset >= cache_start_ && offset < cache_limit_) {
      const char *hit_start = &cache_[offset - cache_start_];
      const size_t n =
          std::min(count - read, static_cast<size_t>(cache_limit_ - offset));
      memcpy(dst, hit_start, n);
      dst += n;
      read += static_cast<size_t>(n);
      offset += static_cast<off_t>(n);
      continue;
    }

    cache_start_ = 0;
    cache_limit_ = 0;
    ssize_t n = pread(fd_, cache_, cache_size_, offset);
    if (n < 0) {
      if (errno == EINTR) {
        continue;
      }
      ABSL_RAW_LOG(WARNING, "read failed: errno=%d", errno);
      return -1;
    }
    if (n == 0) {  // Reached EOF.
      break;
    }

    cache_start_ = offset;
    cache_limit_ = offset + static_cast<off_t>(n);
    // Next iteration will copy from cache into dst.
  }
  return static_cast<ssize_t>(read);
}

// Try reading exactly "count" bytes from "offset" bytes into the buffer
// starting at "buf" while handling short reads and EINTR.  On success, return
// true. Otherwise, return false.
bool CachingFile::ReadFromOffsetExact(void *buf, size_t count, off_t offset) {
  ssize_t len = ReadFromOffset(buf, count, offset);
  return len >= 0 && static_cast<size_t>(len) == count;
}

// Returns elf_header.e_type if the file pointed by fd is an ELF binary.
static int FileGetElfType(CachingFile *file) {
  ElfW(Ehdr) elf_header;
  if (!file->ReadFromOffsetExact(&elf_header, sizeof(elf_header), 0)) {
    return -1;
  }
  if (memcmp(elf_header.e_ident, ELFMAG, SELFMAG) != 0) {
    return -1;
  }
  return elf_header.e_type;
}

// Read the section headers in the given ELF binary, and if a section
// of the specified type is found, set the output to this section header
// and return true.  Otherwise, return false.
// To keep stack consumption low, we would like this function to not get
// inlined.
static ABSL_ATTRIBUTE_NOINLINE bool GetSectionHeaderByType(
    CachingFile *file, ElfW(Half) sh_num, const off_t sh_offset,
    ElfW(Word) type, ElfW(Shdr) * out, char *tmp_buf, size_t tmp_buf_size) {
  ElfW(Shdr) *buf = reinterpret_cast<ElfW(Shdr) *>(tmp_buf);
  const size_t buf_entries = tmp_buf_size / sizeof(buf[0]);
  const size_t buf_bytes = buf_entries * sizeof(buf[0]);

  for (size_t i = 0; static_cast<int>(i) < sh_num;) {
    const size_t num_bytes_left =
        (static_cast<size_t>(sh_num) - i) * sizeof(buf[0]);
    const size_t num_bytes_to_read =
        (buf_bytes > num_bytes_left) ? num_bytes_left : buf_bytes;
    const off_t offset = sh_offset + static_cast<off_t>(i * sizeof(buf[0]));
    const ssize_t len = file->ReadFromOffset(buf, num_bytes_to_read, offset);
    if (len < 0) {
      ABSL_RAW_LOG(
          WARNING,
          "Reading %zu bytes from offset %ju returned %zd which is negative.",
          num_bytes_to_read, static_cast<intmax_t>(offset), len);
      return false;
    }
    if (static_cast<size_t>(len) % sizeof(buf[0]) != 0) {
      ABSL_RAW_LOG(
          WARNING,
          "Reading %zu bytes from offset %jd returned %zd which is not a "
          "multiple of %zu.",
          num_bytes_to_read, static_cast<intmax_t>(offset), len,
          sizeof(buf[0]));
      return false;
    }
    const size_t num_headers_in_buf = static_cast<size_t>(len) / sizeof(buf[0]);
    SAFE_ASSERT(num_headers_in_buf <= buf_entries);
    for (size_t j = 0; j < num_headers_in_buf; ++j) {
      if (buf[j].sh_type == type) {
        *out = buf[j];
        return true;
      }
    }
    i += num_headers_in_buf;
  }
  return false;
}

// There is no particular reason to limit section name to 63 characters,
// but there has (as yet) been no need for anything longer either.
const int kMaxSectionNameLen = 64;

// Small cache to use for miscellaneous file reads.
const int kSmallFileCacheSize = 100;

bool ForEachSection(int fd,
                    const std::function<bool(absl::string_view name,
                                             const ElfW(Shdr) &)> &callback) {
  char buf[kSmallFileCacheSize];
  CachingFile file(fd, buf, sizeof(buf));

  ElfW(Ehdr) elf_header;
  if (!file.ReadFromOffsetExact(&elf_header, sizeof(elf_header), 0)) {
    return false;
  }

  // Technically it can be larger, but in practice this never happens.
  if (elf_header.e_shentsize != sizeof(ElfW(Shdr))) {
    return false;
  }

  ElfW(Shdr) shstrtab;
  off_t shstrtab_offset = static_cast<off_t>(elf_header.e_shoff) +
                          elf_header.e_shentsize * elf_header.e_shstrndx;
  if (!file.ReadFromOffsetExact(&shstrtab, sizeof(shstrtab), shstrtab_offset)) {
    return false;
  }

  for (int i = 0; i < elf_header.e_shnum; ++i) {
    ElfW(Shdr) out;
    off_t section_header_offset =
        static_cast<off_t>(elf_header.e_shoff) + elf_header.e_shentsize * i;
    if (!file.ReadFromOffsetExact(&out, sizeof(out), section_header_offset)) {
      return false;
    }
    off_t name_offset = static_cast<off_t>(shstrtab.sh_offset) + out.sh_name;
    char header_name[kMaxSectionNameLen];
    ssize_t n_read =
        file.ReadFromOffset(&header_name, kMaxSectionNameLen, name_offset);
    if (n_read < 0) {
      return false;
    } else if (n_read > kMaxSectionNameLen) {
      // Long read?
      return false;
    }

    absl::string_view name(header_name,
                           strnlen(header_name, static_cast<size_t>(n_read)));
    if (!callback(name, out)) {
      break;
    }
  }
  return true;
}

// name_len should include terminating '\0'.
bool GetSectionHeaderByName(int fd, const char *name, size_t name_len,
                            ElfW(Shdr) * out) {
  char header_name[kMaxSectionNameLen];
  if (sizeof(header_name) < name_len) {
    ABSL_RAW_LOG(WARNING,
                 "Section name '%s' is too long (%zu); "
                 "section will not be found (even if present).",
                 name, name_len);
    // No point in even trying.
    return false;
  }

  char buf[kSmallFileCacheSize];
  CachingFile file(fd, buf, sizeof(buf));
  ElfW(Ehdr) elf_header;
  if (!file.ReadFromOffsetExact(&elf_header, sizeof(elf_header), 0)) {
    return false;
  }

  // Technically it can be larger, but in practice this never happens.
  if (elf_header.e_shentsize != sizeof(ElfW(Shdr))) {
    return false;
  }

  ElfW(Shdr) shstrtab;
  off_t shstrtab_offset = static_cast<off_t>(elf_header.e_shoff) +
                          elf_header.e_shentsize * elf_header.e_shstrndx;
  if (!file.ReadFromOffsetExact(&shstrtab, sizeof(shstrtab), shstrtab_offset)) {
    return false;
  }

  for (int i = 0; i < elf_header.e_shnum; ++i) {
    off_t section_header_offset =
        static_cast<off_t>(elf_header.e_shoff) + elf_header.e_shentsize * i;
    if (!file.ReadFromOffsetExact(out, sizeof(*out), section_header_offset)) {
      return false;
    }
    off_t name_offset = static_cast<off_t>(shstrtab.sh_offset) + out->sh_name;
    ssize_t n_read = file.ReadFromOffset(&header_name, name_len, name_offset);
    if (n_read < 0) {
      return false;
    } else if (static_cast<size_t>(n_read) != name_len) {
      // Short read -- name could be at end of file.
      continue;
    }
    if (memcmp(header_name, name, name_len) == 0) {
      return true;
    }
  }
  return false;
}

// Compare symbols at in the same address.
// Return true if we should pick symbol1.
static bool ShouldPickFirstSymbol(const ElfW(Sym) & symbol1,
                                  const ElfW(Sym) & symbol2) {
  // If one of the symbols is weak and the other is not, pick the one
  // this is not a weak symbol.
  char bind1 = ELF_ST_BIND(symbol1.st_info);
  char bind2 = ELF_ST_BIND(symbol1.st_info);
  if (bind1 == STB_WEAK && bind2 != STB_WEAK) return false;
  if (bind2 == STB_WEAK && bind1 != STB_WEAK) return true;

  // If one of the symbols has zero size and the other is not, pick the
  // one that has non-zero size.
  if (symbol1.st_size != 0 && symbol2.st_size == 0) {
    return true;
  }
  if (symbol1.st_size == 0 && symbol2.st_size != 0) {
    return false;
  }

  // If one of the symbols has no type and the other is not, pick the
  // one that has a type.
  char type1 = ELF_ST_TYPE(symbol1.st_info);
  char type2 = ELF_ST_TYPE(symbol1.st_info);
  if (type1 != STT_NOTYPE && type2 == STT_NOTYPE) {
    return true;
  }
  if (type1 == STT_NOTYPE && type2 != STT_NOTYPE) {
    return false;
  }

  // Pick the first one, if we still cannot decide.
  return true;
}

// Return true if an address is inside a section.
static bool InSection(const void *address, ptrdiff_t relocation,
                      const ElfW(Shdr) * section) {
  const char *start = reinterpret_cast<const char *>(
      section->sh_addr + static_cast<ElfW(Addr)>(relocation));
  size_t size = static_cast<size_t>(section->sh_size);
  return start <= address && address < (start + size);
}

static const char *ComputeOffset(const char *base, ptrdiff_t offset) {
  // Note: cast to intptr_t to avoid undefined behavior when base evaluates to
  // zero and offset is non-zero.
  return reinterpret_cast<const char *>(reinterpret_cast<intptr_t>(base) +
                                        offset);
}

// Read a symbol table and look for the symbol containing the
// pc. Iterate over symbols in a symbol table and look for the symbol
// containing "pc".  If the symbol is found, and its name fits in
// out_size, the name is written into out and SYMBOL_FOUND is returned.
// If the name does not fit, truncated name is written into out,
// and SYMBOL_TRUNCATED is returned. Out is NUL-terminated.
// If the symbol is not found, SYMBOL_NOT_FOUND is returned;
// To keep stack consumption low, we would like this function to not get
// inlined.
static ABSL_ATTRIBUTE_NOINLINE FindSymbolResult FindSymbol(
    const void *const pc, CachingFile *file, char *out, size_t out_size,
    ptrdiff_t relocation, const ElfW(Shdr) * strtab, const ElfW(Shdr) * symtab,
    const ElfW(Shdr) * opd, char *tmp_buf, size_t tmp_buf_size) {
  if (symtab == nullptr) {
    return SYMBOL_NOT_FOUND;
  }

  // Read multiple symbols at once to save read() calls.
  ElfW(Sym) *buf = reinterpret_cast<ElfW(Sym) *>(tmp_buf);
  const size_t buf_entries = tmp_buf_size / sizeof(buf[0]);

  const size_t num_symbols = symtab->sh_size / symtab->sh_entsize;

  // On platforms using an .opd section (PowerPC & IA64), a function symbol
  // has the address of a function descriptor, which contains the real
  // starting address.  However, we do not always want to use the real
  // starting address because we sometimes want to symbolize a function
  // pointer into the .opd section, e.g. FindSymbol(&foo,...).
  const bool pc_in_opd = kPlatformUsesOPDSections && opd != nullptr &&
                         InSection(pc, relocation, opd);
  const bool deref_function_descriptor_pointer =
      kPlatformUsesOPDSections && opd != nullptr && !pc_in_opd;

  ElfW(Sym) best_match;
  SafeMemZero(&best_match, sizeof(best_match));
  bool found_match = false;
  for (size_t i = 0; i < num_symbols;) {
    off_t offset =
        static_cast<off_t>(symtab->sh_offset + i * symtab->sh_entsize);
    const size_t num_remaining_symbols = num_symbols - i;
    const size_t entries_in_chunk =
        std::min(num_remaining_symbols, buf_entries);
    const size_t bytes_in_chunk = entries_in_chunk * sizeof(buf[0]);
    const ssize_t len = file->ReadFromOffset(buf, bytes_in_chunk, offset);
    SAFE_ASSERT(len >= 0);
    SAFE_ASSERT(static_cast<size_t>(len) % sizeof(buf[0]) == 0);
    const size_t num_symbols_in_buf = static_cast<size_t>(len) / sizeof(buf[0]);
    SAFE_ASSERT(num_symbols_in_buf <= entries_in_chunk);
    for (size_t j = 0; j < num_symbols_in_buf; ++j) {
      const ElfW(Sym) &symbol = buf[j];

      // For a DSO, a symbol address is relocated by the loading address.
      // We keep the original address for opd redirection below.
      const char *const original_start_address =
          reinterpret_cast<const char *>(symbol.st_value);
      const char *start_address =
          ComputeOffset(original_start_address, relocation);

#ifdef __arm__
      // ARM functions are always aligned to multiples of two bytes; the
      // lowest-order bit in start_address is ignored by the CPU and indicates
      // whether the function contains ARM (0) or Thumb (1) code. We don't care
      // about what encoding is being used; we just want the real start address
      // of the function.
      start_address = reinterpret_cast<const char *>(
          reinterpret_cast<uintptr_t>(start_address) & ~1u);
#endif

      if (deref_function_descriptor_pointer &&
          InSection(original_start_address, /*relocation=*/0, opd)) {
        // The opd section is mapped into memory.  Just dereference
        // start_address to get the first double word, which points to the
        // function entry.
        start_address = *reinterpret_cast<const char *const *>(start_address);
      }

      // If pc is inside the .opd section, it points to a function descriptor.
      const size_t size = pc_in_opd ? kFunctionDescriptorSize : symbol.st_size;
      const void *const end_address =
          ComputeOffset(start_address, static_cast<ptrdiff_t>(size));
      if (symbol.st_value != 0 &&  // Skip null value symbols.
          symbol.st_shndx != 0 &&  // Skip undefined symbols.
#ifdef STT_TLS
          ELF_ST_TYPE(symbol.st_info) != STT_TLS &&  // Skip thread-local data.
#endif                                               // STT_TLS
          ((start_address <= pc && pc < end_address) ||
           (start_address == pc && pc == end_address))) {
        if (!found_match || ShouldPickFirstSymbol(symbol, best_match)) {
          found_match = true;
          best_match = symbol;
        }
      }
    }
    i += num_symbols_in_buf;
  }

  if (found_match) {
    const off_t off =
        static_cast<off_t>(strtab->sh_offset) + best_match.st_name;
    const ssize_t n_read = file->ReadFromOffset(out, out_size, off);
    if (n_read <= 0) {
      // This should never happen.
      ABSL_RAW_LOG(WARNING,
                   "Unable to read from fd %d at offset %lld: n_read = %zd",
                   file->fd(), static_cast<long long>(off), n_read);
      return SYMBOL_NOT_FOUND;
    }
    ABSL_RAW_CHECK(static_cast<size_t>(n_read) <= out_size,
                   "ReadFromOffset read too much data.");

    // strtab->sh_offset points into .strtab-like section that contains
    // NUL-terminated strings: '\0foo\0barbaz\0...".
    //
    // sh_offset+st_name points to the start of symbol name, but we don't know
    // how long the symbol is, so we try to read as much as we have space for,
    // and usually over-read (i.e. there is a NUL somewhere before n_read).
    if (memchr(out, '\0', static_cast<size_t>(n_read)) == nullptr) {
      // Either out_size was too small (n_read == out_size and no NUL), or
      // we tried to read past the EOF (n_read < out_size) and .strtab is
      // corrupt (missing terminating NUL; should never happen for valid ELF).
      out[n_read - 1] = '\0';
      return SYMBOL_TRUNCATED;
    }
    return SYMBOL_FOUND;
  }

  return SYMBOL_NOT_FOUND;
}

// Get the symbol name of "pc" from the file pointed by "fd".  Process
// both regular and dynamic symbol tables if necessary.
// See FindSymbol() comment for description of return value.
FindSymbolResult Symbolizer::GetSymbolFromObjectFile(
    const ObjFile &obj, const void *const pc, const ptrdiff_t relocation,
    char *out, size_t out_size, char *tmp_buf, size_t tmp_buf_size) {
  ElfW(Shdr) symtab;
  ElfW(Shdr) strtab;
  ElfW(Shdr) opd;
  ElfW(Shdr) *opd_ptr = nullptr;

  // On platforms using an .opd sections for function descriptor, read
  // the section header.  The .opd section is in data segment and should be
  // loaded but we check that it is mapped just to be extra careful.
  if (kPlatformUsesOPDSections) {
    if (GetSectionHeaderByName(obj.fd, kOpdSectionName,
                               sizeof(kOpdSectionName) - 1, &opd) &&
        FindObjFile(reinterpret_cast<const char *>(opd.sh_addr) + relocation,
                    opd.sh_size) != nullptr) {
      opd_ptr = &opd;
    } else {
      return SYMBOL_NOT_FOUND;
    }
  }

  CachingFile file(obj.fd, file_cache_, sizeof(file_cache_));

  // Consult a regular symbol table, then fall back to the dynamic symbol table.
  for (const auto symbol_table_type : {SHT_SYMTAB, SHT_DYNSYM}) {
    if (!GetSectionHeaderByType(&file, obj.elf_header.e_shnum,
                                static_cast<off_t>(obj.elf_header.e_shoff),
                                static_cast<ElfW(Word)>(symbol_table_type),
                                &symtab, tmp_buf, tmp_buf_size)) {
      continue;
    }
    if (!file.ReadFromOffsetExact(
            &strtab, sizeof(strtab),
            static_cast<off_t>(obj.elf_header.e_shoff +
                               symtab.sh_link * sizeof(symtab)))) {
      continue;
    }
    const FindSymbolResult rc =
        FindSymbol(pc, &file, out, out_size, relocation, &strtab, &symtab,
                   opd_ptr, tmp_buf, tmp_buf_size);
    if (rc != SYMBOL_NOT_FOUND) {
      return rc;
    }
  }

  return SYMBOL_NOT_FOUND;
}

namespace {
// Thin wrapper around a file descriptor so that the file descriptor
// gets closed for sure.
class FileDescriptor {
 public:
  explicit FileDescriptor(int fd) : fd_(fd) {}
  FileDescriptor(const FileDescriptor &) = delete;
  FileDescriptor &operator=(const FileDescriptor &) = delete;

  ~FileDescriptor() {
    if (fd_ >= 0) {
      close(fd_);
    }
  }

  int get() const { return fd_; }

 private:
  const int fd_;
};

// Helper class for reading lines from file.
//
// Note: we don't use ProcMapsIterator since the object is big (it has
// a 5k array member) and uses async-unsafe functions such as sscanf()
// and snprintf().
class LineReader {
 public:
  explicit LineReader(int fd, char *buf, size_t buf_len)
      : fd_(fd),
        buf_len_(buf_len),
        buf_(buf),
        bol_(buf),
        eol_(buf),
        eod_(buf) {}

  LineReader(const LineReader &) = delete;
  LineReader &operator=(const LineReader &) = delete;

  // Read '\n'-terminated line from file.  On success, modify "bol"
  // and "eol", then return true.  Otherwise, return false.
  //
  // Note: if the last line doesn't end with '\n', the line will be
  // dropped.  It's an intentional behavior to make the code simple.
  bool ReadLine(const char **bol, const char **eol) {
    if (BufferIsEmpty()) {  // First time.
      const ssize_t num_bytes = ReadPersistent(fd_, buf_, buf_len_);
      if (num_bytes <= 0) {  // EOF or error.
        return false;
      }
      eod_ = buf_ + num_bytes;
      bol_ = buf_;
    } else {
      bol_ = eol_ + 1;            // Advance to the next line in the buffer.
      SAFE_ASSERT(bol_ <= eod_);  // "bol_" can point to "eod_".
      if (!HasCompleteLine()) {
        const auto incomplete_line_length = static_cast<size_t>(eod_ - bol_);
        // Move the trailing incomplete line to the beginning.
        memmove(buf_, bol_, incomplete_line_length);
        // Read text from file and append it.
        char *const append_pos = buf_ + incomplete_line_length;
        const size_t capacity_left = buf_len_ - incomplete_line_length;
        const ssize_t num_bytes =
            ReadPersistent(fd_, append_pos, capacity_left);
        if (num_bytes <= 0) {  // EOF or error.
          return false;
        }
        eod_ = append_pos + num_bytes;
        bol_ = buf_;
      }
    }
    eol_ = FindLineFeed();
    if (eol_ == nullptr) {  // '\n' not found.  Malformed line.
      return false;
    }
    *eol_ = '\0';  // Replace '\n' with '\0'.

    *bol = bol_;
    *eol = eol_;
    return true;
  }

 private:
  char *FindLineFeed() const {
    return reinterpret_cast<char *>(
        memchr(bol_, '\n', static_cast<size_t>(eod_ - bol_)));
  }

  bool BufferIsEmpty() const { return buf_ == eod_; }

  bool HasCompleteLine() const {
    return !BufferIsEmpty() && FindLineFeed() != nullptr;
  }

  const int fd_;
  const size_t buf_len_;
  char *const buf_;
  char *bol_;
  char *eol_;
  const char *eod_;  // End of data in "buf_".
};
}  // namespace

// Place the hex number read from "start" into "*hex".  The pointer to
// the first non-hex character or "end" is returned.
static const char *GetHex(const char *start, const char *end,
                          uint64_t *const value) {
  uint64_t hex = 0;
  const char *p;
  for (p = start; p < end; ++p) {
    int ch = *p;
    if ((ch >= '0' && ch <= '9') || (ch >= 'A' && ch <= 'F') ||
        (ch >= 'a' && ch <= 'f')) {
      hex = (hex << 4) |
            static_cast<uint64_t>(ch < 'A' ? ch - '0' : (ch & 0xF) + 9);
    } else {  // Encountered the first non-hex character.
      break;
    }
  }
  SAFE_ASSERT(p <= end);
  *value = hex;
  return p;
}

static const char *GetHex(const char *start, const char *end,
                          const void **const addr) {
  uint64_t hex = 0;
  const char *p = GetHex(start, end, &hex);
  *addr = reinterpret_cast<void *>(hex);
  return p;
}

// Normally we are only interested in "r?x" maps.
// On the PowerPC, function pointers point to descriptors in the .opd
// section.  The descriptors themselves are not executable code, so
// we need to relax the check below to "r??".
static bool ShouldUseMapping(const char *const flags) {
  return flags[0] == 'r' && (kPlatformUsesOPDSections || flags[2] == 'x');
}

// Read /proc/self/maps and run "callback" for each mmapped file found.  If
// "callback" returns false, stop scanning and return true. Else continue
// scanning /proc/self/maps. Return true if no parse error is found.
static ABSL_ATTRIBUTE_NOINLINE bool ReadAddrMap(
    bool (*callback)(const char *filename, const void *const start_addr,
                     const void *const end_addr, uint64_t offset, void *arg),
    void *arg, void *tmp_buf, size_t tmp_buf_size) {
  // Use /proc/self/task/<pid>/maps instead of /proc/self/maps. The latter
  // requires kernel to stop all threads, and is significantly slower when there
  // are 1000s of threads.
  char maps_path[80];
  snprintf(maps_path, sizeof(maps_path), "/proc/self/task/%d/maps", getpid());

  int maps_fd;
  NO_INTR(maps_fd = open(maps_path, O_RDONLY));
  FileDescriptor wrapped_maps_fd(maps_fd);
  if (wrapped_maps_fd.get() < 0) {
    ABSL_RAW_LOG(WARNING, "%s: errno=%d", maps_path, errno);
    return false;
  }

  // Iterate over maps and look for the map containing the pc.  Then
  // look into the symbol tables inside.
  LineReader reader(wrapped_maps_fd.get(), static_cast<char *>(tmp_buf),
                    tmp_buf_size);
  while (true) {
    const char *cursor;
    const char *eol;
    if (!reader.ReadLine(&cursor, &eol)) {  // EOF or malformed line.
      break;
    }

    const char *line = cursor;
    const void *start_address;
    // Start parsing line in /proc/self/maps.  Here is an example:
    //
    // 08048000-0804c000 r-xp 00000000 08:01 2142121    /bin/cat
    //
    // We want start address (08048000), end address (0804c000), flags
    // (r-xp) and file name (/bin/cat).

    // Read start address.
    cursor = GetHex(cursor, eol, &start_address);
    if (cursor == eol || *cursor != '-') {
      ABSL_RAW_LOG(WARNING, "Corrupt /proc/self/maps line: %s", line);
      return false;
    }
    ++cursor;  // Skip '-'.

    // Read end address.
    const void *end_address;
    cursor = GetHex(cursor, eol, &end_address);
    if (cursor == eol || *cursor != ' ') {
      ABSL_RAW_LOG(WARNING, "Corrupt /proc/self/maps line: %s", line);
      return false;
    }
    ++cursor;  // Skip ' '.

    // Read flags.  Skip flags until we encounter a space or eol.
    const char *const flags_start = cursor;
    while (cursor < eol && *cursor != ' ') {
      ++cursor;
    }
    // We expect at least four letters for flags (ex. "r-xp").
    if (cursor == eol || cursor < flags_start + 4) {
      ABSL_RAW_LOG(WARNING, "Corrupt /proc/self/maps: %s", line);
      return false;
    }

    // Check flags.
    if (!ShouldUseMapping(flags_start)) {
      continue;  // We skip this map.
    }
    ++cursor;  // Skip ' '.

    // Read file offset.
    uint64_t offset;
    cursor = GetHex(cursor, eol, &offset);
    ++cursor;  // Skip ' '.

    // Skip to file name.  "cursor" now points to dev.  We need to skip at least
    // two spaces for dev and inode.
    int num_spaces = 0;
    while (cursor < eol) {
      if (*cursor == ' ') {
        ++num_spaces;
      } else if (num_spaces >= 2) {
        // The first non-space character after  skipping two spaces
        // is the beginning of the file name.
        break;
      }
      ++cursor;
    }

    // Check whether this entry corresponds to our hint table for the true
    // filename.
    bool hinted =
        GetFileMappingHint(&start_address, &end_address, &offset, &cursor);
    if (!hinted && (cursor == eol || cursor[0] == '[')) {
      // not an object file, typically [vdso] or [vsyscall]
      continue;
    }
    if (!callback(cursor, start_address, end_address, offset, arg)) break;
  }
  return true;
}

// Find the objfile mapped in address region containing [addr, addr + len).
ObjFile *Symbolizer::FindObjFile(const void *const addr, size_t len) {
  for (int i = 0; i < 2; ++i) {
    if (!ok_) return nullptr;

    // Read /proc/self/maps if necessary
    if (!addr_map_read_) {
      addr_map_read_ = true;
      if (!ReadAddrMap(RegisterObjFile, this, tmp_buf_, TMP_BUF_SIZE)) {
        ok_ = false;
        return nullptr;
      }
    }

    size_t lo = 0;
    size_t hi = addr_map_.Size();
    while (lo < hi) {
      size_t mid = (lo + hi) / 2;
      if (addr < addr_map_.At(mid)->end_addr) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    if (lo != addr_map_.Size()) {
      ObjFile *obj = addr_map_.At(lo);
      SAFE_ASSERT(obj->end_addr > addr);
      if (addr >= obj->start_addr &&
          reinterpret_cast<const char *>(addr) + len <= obj->end_addr)
        return obj;
    }

    // The address mapping may have changed since it was last read.  Retry.
    ClearAddrMap();
  }
  return nullptr;
}

void Symbolizer::ClearAddrMap() {
  for (size_t i = 0; i != addr_map_.Size(); i++) {
    ObjFile *o = addr_map_.At(i);
    base_internal::LowLevelAlloc::Free(o->filename);
    if (o->fd >= 0) {
      close(o->fd);
    }
  }
  addr_map_.Clear();
  addr_map_read_ = false;
}

// Callback for ReadAddrMap to register objfiles in an in-memory table.
bool Symbolizer::RegisterObjFile(const char *filename,
                                 const void *const start_addr,
                                 const void *const end_addr, uint64_t offset,
                                 void *arg) {
  Symbolizer *impl = static_cast<Symbolizer *>(arg);

  // Files are supposed to be added in the increasing address order.  Make
  // sure that's the case.
  size_t addr_map_size = impl->addr_map_.Size();
  if (addr_map_size != 0) {
    ObjFile *old = impl->addr_map_.At(addr_map_size - 1);
    if (old->end_addr > end_addr) {
      ABSL_RAW_LOG(ERROR,
                   "Unsorted addr map entry: 0x%" PRIxPTR ": %s <-> 0x%" PRIxPTR
                   ": %s",
                   reinterpret_cast<uintptr_t>(end_addr), filename,
                   reinterpret_cast<uintptr_t>(old->end_addr), old->filename);
      return true;
    } else if (old->end_addr == end_addr) {
      // The same entry appears twice. This sometimes happens for [vdso].
      if (old->start_addr != start_addr ||
          strcmp(old->filename, filename) != 0) {
        ABSL_RAW_LOG(ERROR,
                     "Duplicate addr 0x%" PRIxPTR ": %s <-> 0x%" PRIxPTR ": %s",
                     reinterpret_cast<uintptr_t>(end_addr), filename,
                     reinterpret_cast<uintptr_t>(old->end_addr), old->filename);
      }
      return true;
    } else if (old->end_addr == start_addr &&
               reinterpret_cast<uintptr_t>(old->start_addr) - old->offset ==
                   reinterpret_cast<uintptr_t>(start_addr) - offset &&
               strcmp(old->filename, filename) == 0) {
      // Two contiguous map entries that span a contiguous region of the file,
      // perhaps because some part of the file was mlock()ed. Combine them.
      old->end_addr = end_addr;
      return true;
    }
  }
  ObjFile *obj = impl->addr_map_.Add();
  obj->filename = impl->CopyString(filename);
  obj->start_addr = start_addr;
  obj->end_addr = end_addr;
  obj->offset = offset;
  obj->elf_type = -1;  // filled on demand
  obj->fd = -1;        // opened on demand
  return true;
}

// This function wraps the Demangle function to provide an interface
// where the input symbol is demangled in-place.
// To keep stack consumption low, we would like this function to not
// get inlined.
static ABSL_ATTRIBUTE_NOINLINE void DemangleInplace(char *out, size_t out_size,
                                                    char *tmp_buf,
                                                    size_t tmp_buf_size) {
  if (Demangle(out, tmp_buf, tmp_buf_size)) {
    // Demangling succeeded. Copy to out if the space allows.
    size_t len = strlen(tmp_buf);
    if (len + 1 <= out_size) {  // +1 for '\0'.
      SAFE_ASSERT(len < tmp_buf_size);
      memmove(out, tmp_buf, len + 1);
    }
  }
}

SymbolCacheLine *Symbolizer::GetCacheLine(const void *const pc) {
  uintptr_t pc0 = reinterpret_cast<uintptr_t>(pc);
  pc0 >>= 3;  // drop the low 3 bits

  // Shuffle bits.
  pc0 ^= (pc0 >> 6) ^ (pc0 >> 12) ^ (pc0 >> 18);
  return &symbol_cache_[pc0 % SYMBOL_CACHE_LINES];
}

void Symbolizer::AgeSymbols(SymbolCacheLine *line) {
  for (uint32_t &age : line->age) {
    ++age;
  }
}

const char *Symbolizer::FindSymbolInCache(const void *const pc) {
  if (pc == nullptr) return nullptr;

  SymbolCacheLine *line = GetCacheLine(pc);
  for (size_t i = 0; i < ABSL_ARRAYSIZE(line->pc); ++i) {
    if (line->pc[i] == pc) {
      AgeSymbols(line);
      line->age[i] = 0;
      return line->name[i];
    }
  }
  return nullptr;
}

const char *Symbolizer::InsertSymbolInCache(const void *const pc,
                                            const char *name) {
  SAFE_ASSERT(pc != nullptr);

  SymbolCacheLine *line = GetCacheLine(pc);
  uint32_t max_age = 0;
  size_t oldest_index = 0;
  bool found_oldest_index = false;
  for (size_t i = 0; i < ABSL_ARRAYSIZE(line->pc); ++i) {
    if (line->pc[i] == nullptr) {
      AgeSymbols(line);
      line->pc[i] = pc;
      line->name[i] = CopyString(name);
      line->age[i] = 0;
      return line->name[i];
    }
    if (line->age[i] >= max_age) {
      max_age = line->age[i];
      oldest_index = i;
      found_oldest_index = true;
    }
  }

  AgeSymbols(line);
  ABSL_RAW_CHECK(found_oldest_index, "Corrupt cache");
  base_internal::LowLevelAlloc::Free(line->name[oldest_index]);
  line->pc[oldest_index] = pc;
  line->name[oldest_index] = CopyString(name);
  line->age[oldest_index] = 0;
  return line->name[oldest_index];
}

static void MaybeOpenFdFromSelfExe(ObjFile *obj) {
  if (memcmp(obj->start_addr, ELFMAG, SELFMAG) != 0) {
    return;
  }
  int fd = open("/proc/self/exe", O_RDONLY);
  if (fd == -1) {
    return;
  }
  // Verify that contents of /proc/self/exe matches in-memory image of
  // the binary. This can fail if the "deleted" binary is in fact not
  // the main executable, or for binaries that have the first PT_LOAD
  // segment smaller than 4K. We do it in four steps so that the
  // buffer is smaller and we don't consume too much stack space.
  const char *mem = reinterpret_cast<const char *>(obj->start_addr);
  for (int i = 0; i < 4; ++i) {
    char buf[1024];
    ssize_t n = read(fd, buf, sizeof(buf));
    if (n != sizeof(buf) || memcmp(buf, mem, sizeof(buf)) != 0) {
      close(fd);
      return;
    }
    mem += sizeof(buf);
  }
  obj->fd = fd;
}

static bool MaybeInitializeObjFile(ObjFile *obj) {
  if (obj->fd < 0) {
    obj->fd = open(obj->filename, O_RDONLY);

    if (obj->fd < 0) {
      // Getting /proc/self/exe here means that we were hinted.
      if (strcmp(obj->filename, "/proc/self/exe") == 0) {
        // /proc/self/exe may be inaccessible (due to setuid, etc.), so try
        // accessing the binary via argv0.
        if (argv0_value != nullptr) {
          obj->fd = open(argv0_value, O_RDONLY);
        }
      } else {
        MaybeOpenFdFromSelfExe(obj);
      }
    }

    if (obj->fd < 0) {
      ABSL_RAW_LOG(WARNING, "%s: open failed: errno=%d", obj->filename, errno);
      return false;
    }

    char buf[kSmallFileCacheSize];
    CachingFile file(obj->fd, buf, sizeof(buf));

    obj->elf_type = FileGetElfType(&file);
    if (obj->elf_type < 0) {
      ABSL_RAW_LOG(WARNING, "%s: wrong elf type: %d", obj->filename,
                   obj->elf_type);
      return false;
    }

    if (!file.ReadFromOffsetExact(&obj->elf_header, sizeof(obj->elf_header),
                                  0)) {
      ABSL_RAW_LOG(WARNING, "%s: failed to read elf header", obj->filename);
      return false;
    }
    const int phnum = obj->elf_header.e_phnum;
    const int phentsize = obj->elf_header.e_phentsize;
    auto phoff = static_cast<off_t>(obj->elf_header.e_phoff);
    size_t num_interesting_load_segments = 0;
    for (int j = 0; j < phnum; j++) {
      ElfW(Phdr) phdr;
      if (!file.ReadFromOffsetExact(&phdr, sizeof(phdr), phoff)) {
        ABSL_RAW_LOG(WARNING, "%s: failed to read program header %d",
                     obj->filename, j);
        return false;
      }
      phoff += phentsize;

#if defined(__powerpc__) && !(_CALL_ELF > 1)
      // On the PowerPC ELF v1 ABI, function pointers actually point to function
      // descriptors. These descriptors are stored in an .opd section, which is
      // mapped read-only. We thus need to look at all readable segments, not
      // just the executable ones.
      constexpr int interesting = PF_R;
#else
      constexpr int interesting = PF_X | PF_R;
#endif

      if (phdr.p_type != PT_LOAD
          || (phdr.p_flags & interesting) != interesting) {
        // Not a LOAD segment, not executable code, and not a function
        // descriptor.
        continue;
      }
      if (num_interesting_load_segments < obj->phdr.size()) {
        memcpy(&obj->phdr[num_interesting_load_segments++], &phdr, sizeof(phdr));
      } else {
        ABSL_RAW_LOG(
            WARNING, "%s: too many interesting LOAD segments: %zu >= %zu",
            obj->filename, num_interesting_load_segments, obj->phdr.size());
        break;
      }
    }
    if (num_interesting_load_segments == 0) {
      // This object has no interesting LOAD segments. That's unexpected.
      ABSL_RAW_LOG(WARNING, "%s: no interesting LOAD segments", obj->filename);
      return false;
    }
  }
  return true;
}

// The implementation of our symbolization routine.  If it
// successfully finds the symbol containing "pc" and obtains the
// symbol name, returns pointer to that symbol. Otherwise, returns nullptr.
// If any symbol decorators have been installed via InstallSymbolDecorator(),
// they are called here as well.
// To keep stack consumption low, we would like this function to not
// get inlined.
const char *Symbolizer::GetUncachedSymbol(const void *pc) {
  ObjFile *const obj = FindObjFile(pc, 1);
  ptrdiff_t relocation = 0;
  int fd = -1;
  if (obj != nullptr) {
    if (MaybeInitializeObjFile(obj)) {
      const size_t start_addr = reinterpret_cast<size_t>(obj->start_addr);
      if (obj->elf_type == ET_DYN && start_addr >= obj->offset) {
        // This object was relocated.
        //
        // For obj->offset > 0, adjust the relocation since a mapping at offset
        // X in the file will have a start address of [true relocation]+X.
        relocation = static_cast<ptrdiff_t>(start_addr - obj->offset);

        // Note: some binaries have multiple LOAD segments that can contain
        // function pointers. We must find the right one.
        ElfW(Phdr) *phdr = nullptr;
        for (size_t j = 0; j < obj->phdr.size(); j++) {
          ElfW(Phdr) &p = obj->phdr[j];
          if (p.p_type != PT_LOAD) {
            // We only expect PT_LOADs. This must be PT_NULL that we didn't
            // write over (i.e. we exhausted all interesting PT_LOADs).
            ABSL_RAW_CHECK(p.p_type == PT_NULL, "unexpected p_type");
            break;
          }
          if (pc < reinterpret_cast<void *>(start_addr + p.p_vaddr + p.p_memsz)) {
            phdr = &p;
            break;
          }
        }
        if (phdr == nullptr) {
          // That's unexpected. Hope for the best.
          ABSL_RAW_LOG(
              WARNING,
              "%s: unable to find LOAD segment for pc: %p, start_addr: %zx",
              obj->filename, pc, start_addr);
        } else {
          // Adjust relocation in case phdr.p_vaddr != 0.
          // This happens for binaries linked with `lld --rosegment`, and for
          // binaries linked with BFD `ld -z separate-code`.
          relocation -= phdr->p_vaddr - phdr->p_offset;
        }
      }

      fd = obj->fd;
      if (GetSymbolFromObjectFile(*obj, pc, relocation, symbol_buf_,
                                  sizeof(symbol_buf_), tmp_buf_,
                                  sizeof(tmp_buf_)) == SYMBOL_FOUND) {
        // Only try to demangle the symbol name if it fit into symbol_buf_.
        DemangleInplace(symbol_buf_, sizeof(symbol_buf_), tmp_buf_,
                        sizeof(tmp_buf_));
      }
    }
  } else {
#if ABSL_HAVE_VDSO_SUPPORT
    VDSOSupport vdso;
    if (vdso.IsPresent()) {
      VDSOSupport::SymbolInfo symbol_info;
      if (vdso.LookupSymbolByAddress(pc, &symbol_info)) {
        // All VDSO symbols are known to be short.
        size_t len = strlen(symbol_info.name);
        ABSL_RAW_CHECK(len + 1 < sizeof(symbol_buf_),
                       "VDSO symbol unexpectedly long");
        memcpy(symbol_buf_, symbol_info.name, len + 1);
      }
    }
#endif
  }

  if (g_decorators_mu.TryLock()) {
    if (g_num_decorators > 0) {
      SymbolDecoratorArgs decorator_args = {
          pc,       relocation,       fd,     symbol_buf_, sizeof(symbol_buf_),
          tmp_buf_, sizeof(tmp_buf_), nullptr};
      for (int i = 0; i < g_num_decorators; ++i) {
        decorator_args.arg = g_decorators[i].arg;
        g_decorators[i].fn(&decorator_args);
      }
    }
    g_decorators_mu.Unlock();
  }
  if (symbol_buf_[0] == '\0') {
    return nullptr;
  }
  symbol_buf_[sizeof(symbol_buf_) - 1] = '\0';  // Paranoia.
  return InsertSymbolInCache(pc, symbol_buf_);
}

const char *Symbolizer::GetSymbol(const void *pc) {
  const char *entry = FindSymbolInCache(pc);
  if (entry != nullptr) {
    return entry;
  }
  symbol_buf_[0] = '\0';

#ifdef __hppa__
  {
    // In some contexts (e.g., return addresses), PA-RISC uses the lowest two
    // bits of the address to indicate the privilege level. Clear those bits
    // before trying to symbolize.
    const auto pc_bits = reinterpret_cast<uintptr_t>(pc);
    const auto address = pc_bits & ~0x3;
    entry = GetUncachedSymbol(reinterpret_cast<const void *>(address));
    if (entry != nullptr) {
      return entry;
    }

    // In some contexts, PA-RISC also uses bit 1 of the address to indicate that
    // this is a cross-DSO function pointer. Such function pointers actually
    // point to a procedure label, a struct whose first 32-bit (pointer) element
    // actually points to the function text. With no symbol found for this
    // address so far, try interpreting it as a cross-DSO function pointer and
    // see how that goes.
    if (pc_bits & 0x2) {
      return GetUncachedSymbol(*reinterpret_cast<const void *const *>(address));
    }

    return nullptr;
  }
#else
  return GetUncachedSymbol(pc);
#endif
}

bool RemoveAllSymbolDecorators(void) {
  if (!g_decorators_mu.TryLock()) {
    // Someone else is using decorators. Get out.
    return false;
  }
  g_num_decorators = 0;
  g_decorators_mu.Unlock();
  return true;
}

bool RemoveSymbolDecorator(int ticket) {
  if (!g_decorators_mu.TryLock()) {
    // Someone else is using decorators. Get out.
    return false;
  }
  for (int i = 0; i < g_num_decorators; ++i) {
    if (g_decorators[i].ticket == ticket) {
      while (i < g_num_decorators - 1) {
        g_decorators[i] = g_decorators[i + 1];
        ++i;
      }
      g_num_decorators = i;
      break;
    }
  }
  g_decorators_mu.Unlock();
  return true;  // Decorator is known to be removed.
}

int InstallSymbolDecorator(SymbolDecorator decorator, void *arg) {
  static int ticket = 0;

  if (!g_decorators_mu.TryLock()) {
    // Someone else is using decorators. Get out.
    return -2;
  }
  int ret = ticket;
  if (g_num_decorators >= kMaxDecorators) {
    ret = -1;
  } else {
    g_decorators[g_num_decorators] = {decorator, arg, ticket++};
    ++g_num_decorators;
  }
  g_decorators_mu.Unlock();
  return ret;
}

bool RegisterFileMappingHint(const void *start, const void *end, uint64_t offset,
                             const char *filename) {
  SAFE_ASSERT(start <= end);
  SAFE_ASSERT(filename != nullptr);

  InitSigSafeArena();

  if (!g_file_mapping_mu.TryLock()) {
    return false;
  }

  bool ret = true;
  if (g_num_file_mapping_hints >= kMaxFileMappingHints) {
    ret = false;
  } else {
    // TODO(ckennelly): Move this into a string copy routine.
    size_t len = strlen(filename);
    char *dst = static_cast<char *>(
        base_internal::LowLevelAlloc::AllocWithArena(len + 1, SigSafeArena()));
    ABSL_RAW_CHECK(dst != nullptr, "out of memory");
    memcpy(dst, filename, len + 1);

    auto &hint = g_file_mapping_hints[g_num_file_mapping_hints++];
    hint.start = start;
    hint.end = end;
    hint.offset = offset;
    hint.filename = dst;
  }

  g_file_mapping_mu.Unlock();
  return ret;
}

bool GetFileMappingHint(const void **start, const void **end, uint64_t *offset,
                        const char **filename) {
  if (!g_file_mapping_mu.TryLock()) {
    return false;
  }
  bool found = false;
  for (int i = 0; i < g_num_file_mapping_hints; i++) {
    if (g_file_mapping_hints[i].start <= *start &&
        *end <= g_file_mapping_hints[i].end) {
      // We assume that the start_address for the mapping is the base
      // address of the ELF section, but when [start_address,end_address) is
      // not strictly equal to [hint.start, hint.end), that assumption is
      // invalid.
      //
      // This uses the hint's start address (even though hint.start is not
      // necessarily equal to start_address) to ensure the correct
      // relocation is computed later.
      *start = g_file_mapping_hints[i].start;
      *end = g_file_mapping_hints[i].end;
      *offset = g_file_mapping_hints[i].offset;
      *filename = g_file_mapping_hints[i].filename;
      found = true;
      break;
    }
  }
  g_file_mapping_mu.Unlock();
  return found;
}

}  // namespace debugging_internal

bool Symbolize(const void *pc, char *out, int out_size) {
  // Symbolization is very slow under tsan.
  ABSL_ANNOTATE_IGNORE_READS_AND_WRITES_BEGIN();
  SAFE_ASSERT(out_size >= 0);
  debugging_internal::Symbolizer *s = debugging_internal::AllocateSymbolizer();
  const char *name = s->GetSymbol(pc);
  bool ok = false;
  if (name != nullptr && out_size > 0) {
    strncpy(out, name, static_cast<size_t>(out_size));
    ok = true;
    if (out[static_cast<size_t>(out_size) - 1] != '\0') {
      // strncpy() does not '\0' terminate when it truncates.  Do so, with
      // trailing ellipsis.
      static constexpr char kEllipsis[] = "...";
      size_t ellipsis_size =
          std::min(strlen(kEllipsis), static_cast<size_t>(out_size) - 1);
      memcpy(out + static_cast<size_t>(out_size) - ellipsis_size - 1, kEllipsis,
             ellipsis_size);
      out[static_cast<size_t>(out_size) - 1] = '\0';
    }
  }
  debugging_internal::FreeSymbolizer(s);
  ABSL_ANNOTATE_IGNORE_READS_AND_WRITES_END();
  return ok;
}

ABSL_NAMESPACE_END
}  // namespace absl

extern "C" bool AbslInternalGetFileMappingHint(const void **start,
                                               const void **end, uint64_t *offset,
                                               const char **filename) {
  return absl::debugging_internal::GetFileMappingHint(start, end, offset,
                                                      filename);
}
                                                                          node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/symbolize_emscripten.inc                  0000664 0000000 0000000 00000004205 14746647661 0030233 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <cxxabi.h>
#include <emscripten.h>

#include <algorithm>
#include <cstring>

#include "absl/base/internal/raw_logging.h"
#include "absl/debugging/internal/demangle.h"
#include "absl/strings/numbers.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"

extern "C" {
const char* emscripten_pc_get_function(const void* pc);
}

// clang-format off
EM_JS(bool, HaveOffsetConverter, (),
      { return typeof wasmOffsetConverter !== 'undefined'; });
// clang-format on

namespace absl {
ABSL_NAMESPACE_BEGIN

void InitializeSymbolizer(const char*) {
  if (!HaveOffsetConverter()) {
    ABSL_RAW_LOG(INFO,
                 "Symbolization unavailable. Rebuild with -sWASM=1 "
                 "and -sUSE_OFFSET_CONVERTER=1.");
  }
}

bool Symbolize(const void* pc, char* out, int out_size) {
  // Check if we have the offset converter necessary for pc_get_function.
  // Without it, the program will abort().
  if (!HaveOffsetConverter()) {
    return false;
  }
  if (pc == nullptr || out_size <= 0) {
    return false;
  }
  const char* func_name = emscripten_pc_get_function(pc);
  if (func_name == nullptr) {
    return false;
  }

  strncpy(out, func_name, out_size);

  if (out[out_size - 1] != '\0') {
    // strncpy() does not '\0' terminate when it truncates.
    static constexpr char kEllipsis[] = "...";
    int ellipsis_size = std::min<int>(sizeof(kEllipsis) - 1, out_size - 1);
    memcpy(out + out_size - ellipsis_size - 1, kEllipsis, ellipsis_size);
    out[out_size - 1] = '\0';
  }

  return true;
}

ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/symbolize_test.cc                         0000664 0000000 0000000 00000055472 14746647661 0026671 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/debugging/symbolize.h"

#ifdef __EMSCRIPTEN__
#include <emscripten.h>
#endif

#ifndef _WIN32
#include <fcntl.h>
#include <sys/mman.h>
#endif

#include <cstring>
#include <iostream>
#include <memory>

#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "absl/base/attributes.h"
#include "absl/base/casts.h"
#include "absl/base/config.h"
#include "absl/base/internal/per_thread_tls.h"
#include "absl/base/optimization.h"
#include "absl/debugging/internal/stack_consumption.h"
#include "absl/log/check.h"
#include "absl/log/log.h"
#include "absl/memory/memory.h"
#include "absl/strings/string_view.h"

#if defined(MAP_ANON) && !defined(MAP_ANONYMOUS)
#define MAP_ANONYMOUS MAP_ANON
#endif

using testing::Contains;

#ifdef _WIN32
#define ABSL_SYMBOLIZE_TEST_NOINLINE __declspec(noinline)
#else
#define ABSL_SYMBOLIZE_TEST_NOINLINE ABSL_ATTRIBUTE_NOINLINE
#endif

// Functions to symbolize. Use C linkage to avoid mangled names.
extern "C" {
ABSL_SYMBOLIZE_TEST_NOINLINE void nonstatic_func() {
  // The next line makes this a unique function to prevent the compiler from
  // folding identical functions together.
  volatile int x = __LINE__;
  static_cast<void>(x);
  ABSL_BLOCK_TAIL_CALL_OPTIMIZATION();
}

ABSL_SYMBOLIZE_TEST_NOINLINE static void static_func() {
  // The next line makes this a unique function to prevent the compiler from
  // folding identical functions together.
  volatile int x = __LINE__;
  static_cast<void>(x);
  ABSL_BLOCK_TAIL_CALL_OPTIMIZATION();
}
}  // extern "C"

struct Foo {
  static void func(int x);
};

// A C++ method that should have a mangled name.
ABSL_SYMBOLIZE_TEST_NOINLINE void Foo::func(int) {
  // The next line makes this a unique function to prevent the compiler from
  // folding identical functions together.
  volatile int x = __LINE__;
  static_cast<void>(x);
  ABSL_BLOCK_TAIL_CALL_OPTIMIZATION();
}

// Create functions that will remain in different text sections in the
// final binary when linker option "-z,keep-text-section-prefix" is used.
int ABSL_ATTRIBUTE_SECTION_VARIABLE(.text.unlikely) unlikely_func() {
  return 0;
}

int ABSL_ATTRIBUTE_SECTION_VARIABLE(.text.hot) hot_func() { return 0; }

int ABSL_ATTRIBUTE_SECTION_VARIABLE(.text.startup) startup_func() { return 0; }

int ABSL_ATTRIBUTE_SECTION_VARIABLE(.text.exit) exit_func() { return 0; }

int /*ABSL_ATTRIBUTE_SECTION_VARIABLE(.text)*/ regular_func() { return 0; }

// Thread-local data may confuse the symbolizer, ensure that it does not.
// Variable sizes and order are important.
#if ABSL_PER_THREAD_TLS
static ABSL_PER_THREAD_TLS_KEYWORD char symbolize_test_thread_small[1];
static ABSL_PER_THREAD_TLS_KEYWORD char
    symbolize_test_thread_big[2 * 1024 * 1024];
#endif

#if !defined(__EMSCRIPTEN__)
static void *GetPCFromFnPtr(void *ptr) { return ptr; }

// Used below to hopefully inhibit some compiler/linker optimizations
// that may remove kHpageTextPadding, kPadding0, and kPadding1 from
// the binary.
static volatile bool volatile_bool = false;

// Force the binary to be large enough that a THP .text remap will succeed.
static constexpr size_t kHpageSize = 1 << 21;
const char kHpageTextPadding[kHpageSize * 4] ABSL_ATTRIBUTE_SECTION_VARIABLE(
        .text) = "";

#else
static void *GetPCFromFnPtr(void *ptr) {
  return EM_ASM_PTR(
      { return wasmOffsetConverter.convert(wasmTable.get($0).name, 0); }, ptr);
}

#endif  // !defined(__EMSCRIPTEN__)

static char try_symbolize_buffer[4096];

// A wrapper function for absl::Symbolize() to make the unit test simple.  The
// limit must be < sizeof(try_symbolize_buffer).  Returns null if
// absl::Symbolize() returns false, otherwise returns try_symbolize_buffer with
// the result of absl::Symbolize().
static const char *TrySymbolizeWithLimit(void *pc, int limit) {
  CHECK_LE(limit, sizeof(try_symbolize_buffer))
      << "try_symbolize_buffer is too small";

  // Use the heap to facilitate heap and buffer sanitizer tools.
  auto heap_buffer = absl::make_unique<char[]>(sizeof(try_symbolize_buffer));
  bool found = absl::Symbolize(pc, heap_buffer.get(), limit);
  if (found) {
    CHECK_LT(static_cast<int>(
                 strnlen(heap_buffer.get(), static_cast<size_t>(limit))),
             limit)
        << "absl::Symbolize() did not properly terminate the string";
    strncpy(try_symbolize_buffer, heap_buffer.get(),
            sizeof(try_symbolize_buffer) - 1);
    try_symbolize_buffer[sizeof(try_symbolize_buffer) - 1] = '\0';
  }

  return found ? try_symbolize_buffer : nullptr;
}

// A wrapper for TrySymbolizeWithLimit(), with a large limit.
static const char *TrySymbolize(void *pc) {
  return TrySymbolizeWithLimit(pc, sizeof(try_symbolize_buffer));
}

#if defined(ABSL_INTERNAL_HAVE_ELF_SYMBOLIZE) ||    \
    defined(ABSL_INTERNAL_HAVE_DARWIN_SYMBOLIZE) || \
    defined(ABSL_INTERNAL_HAVE_EMSCRIPTEN_SYMBOLIZE)

// Test with a return address.
void ABSL_ATTRIBUTE_NOINLINE TestWithReturnAddress() {
#if defined(ABSL_HAVE_ATTRIBUTE_NOINLINE)
  void *return_address = __builtin_return_address(0);
  const char *symbol = TrySymbolize(return_address);
  CHECK_NE(symbol, nullptr) << "TestWithReturnAddress failed";
  CHECK_STREQ(symbol, "main") << "TestWithReturnAddress failed";
  std::cout << "TestWithReturnAddress passed" << std::endl;
#endif
}

TEST(Symbolize, Cached) {
  // Compilers should give us pointers to them.
  EXPECT_STREQ("nonstatic_func",
               TrySymbolize(GetPCFromFnPtr((void *)(&nonstatic_func))));
  // The name of an internal linkage symbol is not specified; allow either a
  // mangled or an unmangled name here.
  const char *static_func_symbol =
      TrySymbolize(GetPCFromFnPtr((void *)(&static_func)));
  EXPECT_TRUE(strcmp("static_func", static_func_symbol) == 0 ||
              strcmp("static_func()", static_func_symbol) == 0);

  EXPECT_TRUE(nullptr == TrySymbolize(nullptr));
}

TEST(Symbolize, Truncation) {
  constexpr char kNonStaticFunc[] = "nonstatic_func";
  EXPECT_STREQ("nonstatic_func",
               TrySymbolizeWithLimit(GetPCFromFnPtr((void *)(&nonstatic_func)),
                                     strlen(kNonStaticFunc) + 1));
  EXPECT_STREQ("nonstatic_...",
               TrySymbolizeWithLimit(GetPCFromFnPtr((void *)(&nonstatic_func)),
                                     strlen(kNonStaticFunc) + 0));
  EXPECT_STREQ("nonstatic...",
               TrySymbolizeWithLimit(GetPCFromFnPtr((void *)(&nonstatic_func)),
                                     strlen(kNonStaticFunc) - 1));
  EXPECT_STREQ("n...", TrySymbolizeWithLimit(
                           GetPCFromFnPtr((void *)(&nonstatic_func)), 5));
  EXPECT_STREQ("...", TrySymbolizeWithLimit(
                          GetPCFromFnPtr((void *)(&nonstatic_func)), 4));
  EXPECT_STREQ("..", TrySymbolizeWithLimit(
                         GetPCFromFnPtr((void *)(&nonstatic_func)), 3));
  EXPECT_STREQ(
      ".", TrySymbolizeWithLimit(GetPCFromFnPtr((void *)(&nonstatic_func)), 2));
  EXPECT_STREQ(
      "", TrySymbolizeWithLimit(GetPCFromFnPtr((void *)(&nonstatic_func)), 1));
  EXPECT_EQ(nullptr, TrySymbolizeWithLimit(
                         GetPCFromFnPtr((void *)(&nonstatic_func)), 0));
}

TEST(Symbolize, SymbolizeWithDemangling) {
  Foo::func(100);
#ifdef __EMSCRIPTEN__
  // Emscripten's online symbolizer is more precise with arguments.
  EXPECT_STREQ("Foo::func(int)",
               TrySymbolize(GetPCFromFnPtr((void *)(&Foo::func))));
#else
  EXPECT_STREQ("Foo::func()",
               TrySymbolize(GetPCFromFnPtr((void *)(&Foo::func))));
#endif
}

TEST(Symbolize, SymbolizeSplitTextSections) {
  EXPECT_STREQ("unlikely_func()",
               TrySymbolize(GetPCFromFnPtr((void *)(&unlikely_func))));
  EXPECT_STREQ("hot_func()", TrySymbolize(GetPCFromFnPtr((void *)(&hot_func))));
  EXPECT_STREQ("startup_func()",
               TrySymbolize(GetPCFromFnPtr((void *)(&startup_func))));
  EXPECT_STREQ("exit_func()",
               TrySymbolize(GetPCFromFnPtr((void *)(&exit_func))));
  EXPECT_STREQ("regular_func()",
               TrySymbolize(GetPCFromFnPtr((void *)(&regular_func))));
}

// Tests that verify that Symbolize stack footprint is within some limit.
#ifdef ABSL_INTERNAL_HAVE_DEBUGGING_STACK_CONSUMPTION

static void *g_pc_to_symbolize;
static char g_symbolize_buffer[4096];
static char *g_symbolize_result;

static void SymbolizeSignalHandler(int signo) {
  if (absl::Symbolize(g_pc_to_symbolize, g_symbolize_buffer,
                      sizeof(g_symbolize_buffer))) {
    g_symbolize_result = g_symbolize_buffer;
  } else {
    g_symbolize_result = nullptr;
  }
}

// Call Symbolize and figure out the stack footprint of this call.
static const char *SymbolizeStackConsumption(void *pc, int *stack_consumed) {
  g_pc_to_symbolize = pc;
  *stack_consumed = absl::debugging_internal::GetSignalHandlerStackConsumption(
      SymbolizeSignalHandler);
  return g_symbolize_result;
}

static int GetStackConsumptionUpperLimit() {
  // Symbolize stack consumption should be within 2kB.
  int stack_consumption_upper_limit = 2048;
#if defined(ABSL_HAVE_ADDRESS_SANITIZER) || \
    defined(ABSL_HAVE_MEMORY_SANITIZER) || defined(ABSL_HAVE_THREAD_SANITIZER)
  // Account for sanitizer instrumentation requiring additional stack space.
  stack_consumption_upper_limit *= 5;
#endif
  return stack_consumption_upper_limit;
}

TEST(Symbolize, SymbolizeStackConsumption) {
  int stack_consumed = 0;

  const char *symbol =
      SymbolizeStackConsumption((void *)(&nonstatic_func), &stack_consumed);
  EXPECT_STREQ("nonstatic_func", symbol);
  EXPECT_GT(stack_consumed, 0);
  EXPECT_LT(stack_consumed, GetStackConsumptionUpperLimit());

  // The name of an internal linkage symbol is not specified; allow either a
  // mangled or an unmangled name here.
  symbol = SymbolizeStackConsumption((void *)(&static_func), &stack_consumed);
  EXPECT_TRUE(strcmp("static_func", symbol) == 0 ||
              strcmp("static_func()", symbol) == 0);
  EXPECT_GT(stack_consumed, 0);
  EXPECT_LT(stack_consumed, GetStackConsumptionUpperLimit());
}

TEST(Symbolize, SymbolizeWithDemanglingStackConsumption) {
  Foo::func(100);
  int stack_consumed = 0;

  const char *symbol =
      SymbolizeStackConsumption((void *)(&Foo::func), &stack_consumed);

  EXPECT_STREQ("Foo::func()", symbol);
  EXPECT_GT(stack_consumed, 0);
  EXPECT_LT(stack_consumed, GetStackConsumptionUpperLimit());
}

#endif  // ABSL_INTERNAL_HAVE_DEBUGGING_STACK_CONSUMPTION

#if !defined(ABSL_INTERNAL_HAVE_DARWIN_SYMBOLIZE) && \
    !defined(ABSL_INTERNAL_HAVE_EMSCRIPTEN_SYMBOLIZE)
// Use a 64K page size for PPC.
const size_t kPageSize = 64 << 10;
// We place a read-only symbols into the .text section and verify that we can
// symbolize them and other symbols after remapping them.
const char kPadding0[kPageSize * 4] ABSL_ATTRIBUTE_SECTION_VARIABLE(.text) = "";
const char kPadding1[kPageSize * 4] ABSL_ATTRIBUTE_SECTION_VARIABLE(.text) = "";

static int FilterElfHeader(struct dl_phdr_info *info, size_t size, void *data) {
  for (int i = 0; i < info->dlpi_phnum; i++) {
    if (info->dlpi_phdr[i].p_type == PT_LOAD &&
        info->dlpi_phdr[i].p_flags == (PF_R | PF_X)) {
      const void *const vaddr =
          absl::bit_cast<void *>(info->dlpi_addr + info->dlpi_phdr[i].p_vaddr);
      const auto segsize = info->dlpi_phdr[i].p_memsz;

      const char *self_exe;
      if (info->dlpi_name != nullptr && info->dlpi_name[0] != '\0') {
        self_exe = info->dlpi_name;
      } else {
        self_exe = "/proc/self/exe";
      }

      absl::debugging_internal::RegisterFileMappingHint(
          vaddr, reinterpret_cast<const char *>(vaddr) + segsize,
          info->dlpi_phdr[i].p_offset, self_exe);

      return 1;
    }
  }

  return 1;
}

TEST(Symbolize, SymbolizeWithMultipleMaps) {
  // Force kPadding0 and kPadding1 to be linked in.
  if (volatile_bool) {
    LOG(INFO) << kPadding0;
    LOG(INFO) << kPadding1;
  }

  // Verify we can symbolize everything.
  char buf[512];
  memset(buf, 0, sizeof(buf));
  absl::Symbolize(kPadding0, buf, sizeof(buf));
  EXPECT_STREQ("kPadding0", buf);

  memset(buf, 0, sizeof(buf));
  absl::Symbolize(kPadding1, buf, sizeof(buf));
  EXPECT_STREQ("kPadding1", buf);

  // Specify a hint for the executable segment.
  dl_iterate_phdr(FilterElfHeader, nullptr);

  // Reload at least one page out of kPadding0, kPadding1
  const char *ptrs[] = {kPadding0, kPadding1};

  for (const char *ptr : ptrs) {
    const int kMapFlags = MAP_ANONYMOUS | MAP_PRIVATE;
    void *addr = mmap(nullptr, kPageSize, PROT_READ, kMapFlags, 0, 0);
    ASSERT_NE(addr, MAP_FAILED);

    // kPadding[0-1] is full of zeroes, so we can remap anywhere within it, but
    // we ensure there is at least a full page of padding.
    void *remapped = reinterpret_cast<void *>(
        reinterpret_cast<uintptr_t>(ptr + kPageSize) & ~(kPageSize - 1ULL));

    const int kMremapFlags = (MREMAP_MAYMOVE | MREMAP_FIXED);
    void *ret = mremap(addr, kPageSize, kPageSize, kMremapFlags, remapped);
    ASSERT_NE(ret, MAP_FAILED);
  }

  // Invalidate the symbolization cache so we are forced to rely on the hint.
  absl::Symbolize(nullptr, buf, sizeof(buf));

  // Verify we can still symbolize.
  const char *expected[] = {"kPadding0", "kPadding1"};
  const size_t offsets[] = {0, kPageSize, 2 * kPageSize, 3 * kPageSize};

  for (int i = 0; i < 2; i++) {
    for (size_t offset : offsets) {
      memset(buf, 0, sizeof(buf));
      absl::Symbolize(ptrs[i] + offset, buf, sizeof(buf));
      EXPECT_STREQ(expected[i], buf);
    }
  }
}

// Appends string(*args->arg) to args->symbol_buf.
static void DummySymbolDecorator(
    const absl::debugging_internal::SymbolDecoratorArgs *args) {
  std::string *message = static_cast<std::string *>(args->arg);
  strncat(args->symbol_buf, message->c_str(),
          args->symbol_buf_size - strlen(args->symbol_buf) - 1);
}

TEST(Symbolize, InstallAndRemoveSymbolDecorators) {
  int ticket_a;
  std::string a_message("a");
  EXPECT_GE(ticket_a = absl::debugging_internal::InstallSymbolDecorator(
                DummySymbolDecorator, &a_message),
            0);

  int ticket_b;
  std::string b_message("b");
  EXPECT_GE(ticket_b = absl::debugging_internal::InstallSymbolDecorator(
                DummySymbolDecorator, &b_message),
            0);

  int ticket_c;
  std::string c_message("c");
  EXPECT_GE(ticket_c = absl::debugging_internal::InstallSymbolDecorator(
                DummySymbolDecorator, &c_message),
            0);

  // Use addresses 4 and 8 here to ensure that we always use valid addresses
  // even on systems that require instructions to be 32-bit aligned.
  char *address = reinterpret_cast<char *>(4);
  EXPECT_STREQ("abc", TrySymbolize(address));

  EXPECT_TRUE(absl::debugging_internal::RemoveSymbolDecorator(ticket_b));

  EXPECT_STREQ("ac", TrySymbolize(address + 4));

  // Cleanup: remove all remaining decorators so other stack traces don't
  // get mystery "ac" decoration.
  EXPECT_TRUE(absl::debugging_internal::RemoveSymbolDecorator(ticket_a));
  EXPECT_TRUE(absl::debugging_internal::RemoveSymbolDecorator(ticket_c));
}

// Some versions of Clang with optimizations enabled seem to be able
// to optimize away the .data section if no variables live in the
// section. This variable should get placed in the .data section, and
// the test below checks for the existence of a .data section.
static int in_data_section = 1;

TEST(Symbolize, ForEachSection) {
  int fd = TEMP_FAILURE_RETRY(open("/proc/self/exe", O_RDONLY));
  ASSERT_NE(fd, -1);

  std::vector<std::string> sections;
  ASSERT_TRUE(absl::debugging_internal::ForEachSection(
      fd, [&sections](const absl::string_view name, const ElfW(Shdr) &) {
        sections.emplace_back(name);
        return true;
      }));

  // Check for the presence of common section names.
  EXPECT_THAT(sections, Contains(".text"));
  EXPECT_THAT(sections, Contains(".rodata"));
  EXPECT_THAT(sections, Contains(".bss"));
  ++in_data_section;
  EXPECT_THAT(sections, Contains(".data"));

  close(fd);
}
#endif  // !ABSL_INTERNAL_HAVE_DARWIN_SYMBOLIZE &&
        // !ABSL_INTERNAL_HAVE_EMSCRIPTEN_SYMBOLIZE

// x86 specific tests.  Uses some inline assembler.
extern "C" {
inline void *ABSL_ATTRIBUTE_ALWAYS_INLINE inline_func() {
  void *pc = nullptr;
#if defined(__i386__)
  __asm__ __volatile__("call 1f;\n 1: pop %[PC]" : [PC] "=r"(pc));
#elif defined(__x86_64__)
  __asm__ __volatile__("leaq 0(%%rip),%[PC];\n" : [PC] "=r"(pc));
#endif
  return pc;
}

void *ABSL_ATTRIBUTE_NOINLINE non_inline_func() {
  void *pc = nullptr;
#if defined(__i386__)
  __asm__ __volatile__("call 1f;\n 1: pop %[PC]" : [PC] "=r"(pc));
#elif defined(__x86_64__)
  __asm__ __volatile__("leaq 0(%%rip),%[PC];\n" : [PC] "=r"(pc));
#endif
  return pc;
}

void ABSL_ATTRIBUTE_NOINLINE TestWithPCInsideNonInlineFunction() {
#if defined(ABSL_HAVE_ATTRIBUTE_NOINLINE) && \
    (defined(__i386__) || defined(__x86_64__))
  void *pc = non_inline_func();
  const char *symbol = TrySymbolize(pc);
  CHECK_NE(symbol, nullptr) << "TestWithPCInsideNonInlineFunction failed";
  CHECK_STREQ(symbol, "non_inline_func")
      << "TestWithPCInsideNonInlineFunction failed";
  std::cout << "TestWithPCInsideNonInlineFunction passed" << std::endl;
#endif
}

void ABSL_ATTRIBUTE_NOINLINE TestWithPCInsideInlineFunction() {
#if defined(ABSL_HAVE_ATTRIBUTE_ALWAYS_INLINE) && \
    (defined(__i386__) || defined(__x86_64__))
  void *pc = inline_func();  // Must be inlined.
  const char *symbol = TrySymbolize(pc);
  CHECK_NE(symbol, nullptr) << "TestWithPCInsideInlineFunction failed";
  CHECK_STREQ(symbol, __FUNCTION__) << "TestWithPCInsideInlineFunction failed";
  std::cout << "TestWithPCInsideInlineFunction passed" << std::endl;
#endif
}
}

#if defined(__arm__) && ABSL_HAVE_ATTRIBUTE(target) && \
    ((__ARM_ARCH >= 7) || !defined(__ARM_PCS_VFP))
// Test that we correctly identify bounds of Thumb functions on ARM.
//
// Thumb functions have the lowest-order bit set in their addresses in the ELF
// symbol table. This requires some extra logic to properly compute function
// bounds. To test this logic, nudge a Thumb function right up against an ARM
// function and try to symbolize the ARM function.
//
// A naive implementation will simply use the Thumb function's entry point as
// written in the symbol table and will therefore treat the Thumb function as
// extending one byte further in the instruction stream than it actually does.
// When asked to symbolize the start of the ARM function, it will identify an
// overlap between the Thumb and ARM functions, and it will return the name of
// the Thumb function.
//
// A correct implementation, on the other hand, will null out the lowest-order
// bit in the Thumb function's entry point. It will correctly compute the end of
// the Thumb function, it will find no overlap between the Thumb and ARM
// functions, and it will return the name of the ARM function.
//
// Unfortunately we cannot perform this test on armv6 or lower systems that use
// the hard float ABI because gcc refuses to compile thumb functions on such
// systems with a "sorry, unimplemented: Thumb-1 hard-float VFP ABI" error.

__attribute__((target("thumb"))) int ArmThumbOverlapThumb(int x) {
  return x * x * x;
}

__attribute__((target("arm"))) int ArmThumbOverlapArm(int x) {
  return x * x * x;
}

void ABSL_ATTRIBUTE_NOINLINE TestArmThumbOverlap() {
#if defined(ABSL_HAVE_ATTRIBUTE_NOINLINE)
  const char *symbol = TrySymbolize((void *)&ArmThumbOverlapArm);
  CHECK_NE(symbol, nullptr) << "TestArmThumbOverlap failed";
  CHECK_STREQ("ArmThumbOverlapArm()", symbol) << "TestArmThumbOverlap failed";
  std::cout << "TestArmThumbOverlap passed" << std::endl;
#endif
}

#endif  // defined(__arm__) && ABSL_HAVE_ATTRIBUTE(target) && ((__ARM_ARCH >= 7)
        // || !defined(__ARM_PCS_VFP))

#elif defined(_WIN32)
#if !defined(ABSL_CONSUME_DLL)

TEST(Symbolize, Basics) {
  EXPECT_STREQ("nonstatic_func", TrySymbolize((void *)(&nonstatic_func)));

  // The name of an internal linkage symbol is not specified; allow either a
  // mangled or an unmangled name here.
  const char *static_func_symbol = TrySymbolize((void *)(&static_func));
  ASSERT_TRUE(static_func_symbol != nullptr);
  EXPECT_TRUE(strstr(static_func_symbol, "static_func") != nullptr);

  EXPECT_TRUE(nullptr == TrySymbolize(nullptr));
}

TEST(Symbolize, Truncation) {
  constexpr char kNonStaticFunc[] = "nonstatic_func";
  EXPECT_STREQ("nonstatic_func",
               TrySymbolizeWithLimit((void *)(&nonstatic_func),
                                     strlen(kNonStaticFunc) + 1));
  EXPECT_STREQ("nonstatic_...",
               TrySymbolizeWithLimit((void *)(&nonstatic_func),
                                     strlen(kNonStaticFunc) + 0));
  EXPECT_STREQ("nonstatic...",
               TrySymbolizeWithLimit((void *)(&nonstatic_func),
                                     strlen(kNonStaticFunc) - 1));
  EXPECT_STREQ("n...", TrySymbolizeWithLimit((void *)(&nonstatic_func), 5));
  EXPECT_STREQ("...", TrySymbolizeWithLimit((void *)(&nonstatic_func), 4));
  EXPECT_STREQ("..", TrySymbolizeWithLimit((void *)(&nonstatic_func), 3));
  EXPECT_STREQ(".", TrySymbolizeWithLimit((void *)(&nonstatic_func), 2));
  EXPECT_STREQ("", TrySymbolizeWithLimit((void *)(&nonstatic_func), 1));
  EXPECT_EQ(nullptr, TrySymbolizeWithLimit((void *)(&nonstatic_func), 0));
}

TEST(Symbolize, SymbolizeWithDemangling) {
  const char *result = TrySymbolize((void *)(&Foo::func));
  ASSERT_TRUE(result != nullptr);
  EXPECT_TRUE(strstr(result, "Foo::func") != nullptr) << result;
}

#endif  // !defined(ABSL_CONSUME_DLL)
#else   // Symbolizer unimplemented
TEST(Symbolize, Unimplemented) {
  char buf[64];
  EXPECT_FALSE(absl::Symbolize((void *)(&nonstatic_func), buf, sizeof(buf)));
  EXPECT_FALSE(absl::Symbolize((void *)(&static_func), buf, sizeof(buf)));
  EXPECT_FALSE(absl::Symbolize((void *)(&Foo::func), buf, sizeof(buf)));
}

#endif

int main(int argc, char **argv) {
#if !defined(__EMSCRIPTEN__)
  // Make sure kHpageTextPadding is linked into the binary.
  if (volatile_bool) {
    LOG(INFO) << kHpageTextPadding;
  }
#endif  // !defined(__EMSCRIPTEN__)

#if ABSL_PER_THREAD_TLS
  // Touch the per-thread variables.
  symbolize_test_thread_small[0] = 0;
  symbolize_test_thread_big[0] = 0;
#endif

  absl::InitializeSymbolizer(argv[0]);
  testing::InitGoogleTest(&argc, argv);

#if defined(ABSL_INTERNAL_HAVE_ELF_SYMBOLIZE) ||        \
    defined(ABSL_INTERNAL_HAVE_EMSCRIPTEN_SYMBOLIZE) || \
    defined(ABSL_INTERNAL_HAVE_DARWIN_SYMBOLIZE)
  TestWithPCInsideInlineFunction();
  TestWithPCInsideNonInlineFunction();
  TestWithReturnAddress();
#if defined(__arm__) && ABSL_HAVE_ATTRIBUTE(target) && \
    ((__ARM_ARCH >= 7) || !defined(__ARM_PCS_VFP))
  TestArmThumbOverlap();
#endif
#endif

  return RUN_ALL_TESTS();
}
                                                                                                                                                                                                      node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/symbolize_unimplemented.inc               0000664 0000000 0000000 00000002410 14746647661 0030724 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <cstdint>

#include "absl/base/internal/raw_logging.h"

namespace absl {
ABSL_NAMESPACE_BEGIN

namespace debugging_internal {

int InstallSymbolDecorator(SymbolDecorator, void*) { return -1; }
bool RemoveSymbolDecorator(int) { return false; }
bool RemoveAllSymbolDecorators(void) { return false; }
bool RegisterFileMappingHint(const void *, const void *, uint64_t, const char *) {
  return false;
}
bool GetFileMappingHint(const void **, const void **, uint64_t *, const char **) {
  return false;
}

}  // namespace debugging_internal

void InitializeSymbolizer(const char*) {}
bool Symbolize(const void *, char *, int) { return false; }

ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/third_party/abseil-cpp/absl/debugging/symbolize_win32.inc                       0000664 0000000 0000000 00000005321 14746647661 0027024 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// See "Retrieving Symbol Information by Address":
// https://msdn.microsoft.com/en-us/library/windows/desktop/ms680578(v=vs.85).aspx

#include <windows.h>

// MSVC header dbghelp.h has a warning for an ignored typedef.
#pragma warning(push)
#pragma warning(disable:4091)
#include <dbghelp.h>
#pragma warning(pop)

#pragma comment(lib, "dbghelp.lib")

#include <algorithm>
#include <cstring>

#include "absl/base/internal/raw_logging.h"

namespace absl {
ABSL_NAMESPACE_BEGIN

static HANDLE process = NULL;

void InitializeSymbolizer(const char*) {
  if (process != nullptr) {
    return;
  }
  process = GetCurrentProcess();

  // Symbols are not loaded until a reference is made requiring the
  // symbols be loaded. This is the fastest, most efficient way to use
  // the symbol handler.
  SymSetOptions(SYMOPT_DEFERRED_LOADS | SYMOPT_UNDNAME);
  if (!SymInitialize(process, nullptr, true)) {
    // GetLastError() returns a Win32 DWORD, but we assign to
    // unsigned long long to simplify the ABSL_RAW_LOG case below.  The uniform
    // initialization guarantees this is not a narrowing conversion.
    const unsigned long long error{GetLastError()};  // NOLINT(runtime/int)
    ABSL_RAW_LOG(FATAL, "SymInitialize() failed: %llu", error);
  }
}

bool Symbolize(const void* pc, char* out, int out_size) {
  if (out_size <= 0) {
    return false;
  }
  alignas(SYMBOL_INFO) char buf[sizeof(SYMBOL_INFO) + MAX_SYM_NAME];
  SYMBOL_INFO* symbol = reinterpret_cast<SYMBOL_INFO*>(buf);
  symbol->SizeOfStruct = sizeof(SYMBOL_INFO);
  symbol->MaxNameLen = MAX_SYM_NAME;
  if (!SymFromAddr(process, reinterpret_cast<DWORD64>(pc), nullptr, symbol)) {
    return false;
  }
  const size_t out_size_t = static_cast<size_t>(out_size);
  strncpy(out, symbol->Name, out_size_t);
  if (out[out_size_t - 1] != '\0') {
    // strncpy() does not '\0' terminate when it truncates.
    static constexpr char kEllipsis[] = "...";
    size_t ellipsis_size =
        std::min(sizeof(kEllipsis) - 1, out_size_t - 1);
    memcpy(out + out_size_t - ellipsis_size - 1, kEllipsis, ellipsis_size);
    out[out_size_t - 1] = '\0';
  }
  return true;
}

ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/                                              0000775 0000000 0000000 00000000000 14746647661 0022432 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/BUILD.bazel                                   0000664 0000000 0000000 00000031713 14746647661 0024315 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #
# Copyright 2019 The Abseil Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

load(
    "//absl:copts/configure_copts.bzl",
    "ABSL_DEFAULT_COPTS",
    "ABSL_DEFAULT_LINKOPTS",
    "ABSL_TEST_COPTS",
)

package(
    default_visibility = ["//visibility:public"],
    features = [
        "header_modules",
        "layering_check",
        "parse_headers",
    ],
)

licenses(["notice"])

cc_library(
    name = "path_util",
    hdrs = [
        "internal/path_util.h",
    ],
    copts = ABSL_DEFAULT_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    visibility = [
        "//absl/flags:__pkg__",
    ],
    deps = [
        "//absl/base:config",
        "//absl/strings",
    ],
)

cc_library(
    name = "program_name",
    srcs = [
        "internal/program_name.cc",
    ],
    hdrs = [
        "internal/program_name.h",
    ],
    copts = ABSL_DEFAULT_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    visibility = [
        "//absl/flags:__pkg__",
        "//absl/log:__pkg__",
    ],
    deps = [
        ":path_util",
        "//absl/base:config",
        "//absl/base:core_headers",
        "//absl/strings",
        "//absl/synchronization",
    ],
)

cc_library(
    name = "config",
    srcs = [
        "usage_config.cc",
    ],
    hdrs = [
        "config.h",
        "usage_config.h",
    ],
    copts = ABSL_DEFAULT_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    deps = [
        ":path_util",
        ":program_name",
        "//absl/base:config",
        "//absl/base:core_headers",
        "//absl/strings",
        "//absl/synchronization",
    ],
)

cc_library(
    name = "marshalling",
    srcs = [
        "marshalling.cc",
    ],
    hdrs = [
        "marshalling.h",
    ],
    copts = ABSL_DEFAULT_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    deps = [
        "//absl/base:config",
        "//absl/base:core_headers",
        "//absl/base:log_severity",
        "//absl/numeric:int128",
        "//absl/strings",
        "//absl/strings:str_format",
        "//absl/types:optional",
    ],
)

cc_library(
    name = "commandlineflag_internal",
    srcs = [
        "internal/commandlineflag.cc",
    ],
    hdrs = [
        "internal/commandlineflag.h",
    ],
    copts = ABSL_DEFAULT_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    visibility = [
        "//visibility:private",
    ],
    deps = [
        "//absl/base:config",
        "//absl/base:fast_type_id",
    ],
)

cc_library(
    name = "commandlineflag",
    srcs = [
        "commandlineflag.cc",
    ],
    hdrs = [
        "commandlineflag.h",
    ],
    copts = ABSL_DEFAULT_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    deps = [
        ":commandlineflag_internal",
        "//absl/base:config",
        "//absl/base:fast_type_id",
        "//absl/strings",
        "//absl/types:optional",
    ],
)

cc_library(
    name = "private_handle_accessor",
    srcs = [
        "internal/private_handle_accessor.cc",
    ],
    hdrs = [
        "internal/private_handle_accessor.h",
    ],
    copts = ABSL_DEFAULT_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    visibility = [
        "//absl/flags:__pkg__",
    ],
    deps = [
        ":commandlineflag",
        ":commandlineflag_internal",
        "//absl/base:config",
        "//absl/strings",
    ],
)

cc_library(
    name = "reflection",
    srcs = [
        "reflection.cc",
    ],
    hdrs = [
        "internal/registry.h",
        "reflection.h",
    ],
    copts = ABSL_DEFAULT_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    deps = [
        ":commandlineflag",
        ":commandlineflag_internal",
        ":config",
        ":private_handle_accessor",
        "//absl/base:config",
        "//absl/base:core_headers",
        "//absl/base:no_destructor",
        "//absl/container:flat_hash_map",
        "//absl/strings",
        "//absl/synchronization",
    ],
)

cc_library(
    name = "flag_internal",
    srcs = [
        "internal/flag.cc",
    ],
    hdrs = [
        "internal/flag.h",
        "internal/sequence_lock.h",
    ],
    copts = ABSL_DEFAULT_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    visibility = ["//absl/base:__subpackages__"],
    deps = [
        ":commandlineflag",
        ":commandlineflag_internal",
        ":config",
        ":marshalling",
        ":reflection",
        "//absl/base",
        "//absl/base:config",
        "//absl/base:core_headers",
        "//absl/base:dynamic_annotations",
        "//absl/memory",
        "//absl/meta:type_traits",
        "//absl/strings",
        "//absl/synchronization",
        "//absl/utility",
    ],
)

cc_library(
    name = "flag",
    hdrs = [
        "declare.h",
        "flag.h",
    ],
    copts = ABSL_DEFAULT_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    deps = [
        ":commandlineflag",
        ":config",
        ":flag_internal",
        ":reflection",
        "//absl/base:config",
        "//absl/base:core_headers",
        "//absl/strings",
    ],
)

cc_library(
    name = "usage_internal",
    srcs = [
        "internal/usage.cc",
    ],
    hdrs = [
        "internal/usage.h",
    ],
    copts = ABSL_DEFAULT_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    visibility = [
        "//absl/flags:__pkg__",
    ],
    deps = [
        ":commandlineflag",
        ":config",
        ":flag",
        ":flag_internal",
        ":path_util",
        ":private_handle_accessor",
        ":program_name",
        ":reflection",
        "//absl/base:config",
        "//absl/base:core_headers",
        "//absl/strings",
        "//absl/synchronization",
    ],
)

cc_library(
    name = "usage",
    srcs = [
        "usage.cc",
    ],
    hdrs = [
        "usage.h",
    ],
    copts = ABSL_DEFAULT_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    deps = [
        ":usage_internal",
        "//absl/base:config",
        "//absl/base:core_headers",
        "//absl/base:raw_logging_internal",
        "//absl/strings",
        "//absl/synchronization",
    ],
)

cc_library(
    name = "parse",
    srcs = ["parse.cc"],
    hdrs = [
        "internal/parse.h",
        "parse.h",
    ],
    copts = ABSL_DEFAULT_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    deps = [
        ":commandlineflag",
        ":commandlineflag_internal",
        ":config",
        ":flag",
        ":flag_internal",
        ":private_handle_accessor",
        ":program_name",
        ":reflection",
        ":usage",
        ":usage_internal",
        "//absl/algorithm:container",
        "//absl/base:config",
        "//absl/base:core_headers",
        "//absl/strings",
        "//absl/synchronization",
    ],
)

############################################################################
# Unit tests in alphabetical order.

cc_test(
    name = "commandlineflag_test",
    size = "small",
    srcs = [
        "commandlineflag_test.cc",
    ],
    copts = ABSL_TEST_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    tags = [
        "no_test:os:android",
        "no_test:os:ios",
        "no_test_android",
        "no_test_ios",
        "no_test_wasm",
    ],
    deps = [
        ":commandlineflag",
        ":config",
        ":flag",
        ":private_handle_accessor",
        ":reflection",
        "//absl/memory",
        "//absl/strings",
        "@com_google_googletest//:gtest",
        "@com_google_googletest//:gtest_main",
    ],
)

cc_test(
    name = "config_test",
    size = "small",
    srcs = [
        "config_test.cc",
    ],
    copts = ABSL_TEST_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    deps = [
        ":config",
        "@com_google_googletest//:gtest",
        "@com_google_googletest//:gtest_main",
    ],
)

cc_test(
    name = "flag_test",
    size = "small",
    srcs = [
        "flag_test.cc",
        "flag_test_defs.cc",
    ],
    copts = ABSL_TEST_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    tags = [
        "no_test:os:android",
        "no_test:os:ios",
        "no_test_android",
        "no_test_ios",
        "no_test_wasm",
    ],
    deps = [
        ":config",
        ":flag",
        ":flag_internal",
        ":marshalling",
        ":parse",
        ":reflection",
        "//absl/base:core_headers",
        "//absl/base:malloc_internal",
        "//absl/base:raw_logging_internal",
        "//absl/numeric:int128",
        "//absl/strings",
        "//absl/time",
        "//absl/types:optional",
        "@com_google_googletest//:gtest",
        "@com_google_googletest//:gtest_main",
    ],
)

cc_binary(
    name = "flag_benchmark",
    testonly = True,
    srcs = [
        "flag_benchmark.cc",
    ],
    copts = ABSL_TEST_COPTS,
    linkopts = select({
        "//conditions:default": [],
    }) + ABSL_DEFAULT_LINKOPTS,
    tags = ["benchmark"],
    visibility = ["//visibility:private"],
    deps = [
        "flag_benchmark.lds",
        ":flag",
        ":marshalling",
        ":parse",
        ":reflection",
        "//absl/strings",
        "//absl/time",
        "//absl/types:optional",
        "@com_github_google_benchmark//:benchmark_main",
    ],
)

cc_test(
    name = "marshalling_test",
    size = "small",
    srcs = [
        "marshalling_test.cc",
    ],
    copts = ABSL_TEST_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    deps = [
        ":marshalling",
        "@com_google_googletest//:gtest",
        "@com_google_googletest//:gtest_main",
    ],
)

cc_test(
    name = "parse_test",
    size = "small",
    timeout = "moderate",
    srcs = [
        "parse_test.cc",
    ],
    copts = ABSL_TEST_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    tags = [
        "no_test:os:android",
        "no_test:os:ios",
        "no_test_android",
        "no_test_ios",
        "no_test_wasm",
    ],
    deps = [
        ":config",
        ":flag",
        ":parse",
        ":reflection",
        ":usage_internal",
        "//absl/base:scoped_set_env",
        "//absl/log",
        "//absl/strings",
        "//absl/types:span",
        "@com_google_googletest//:gtest",
        "@com_google_googletest//:gtest_main",
    ],
)

cc_test(
    name = "path_util_test",
    size = "small",
    srcs = [
        "internal/path_util_test.cc",
    ],
    copts = ABSL_TEST_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    deps = [
        ":path_util",
        "@com_google_googletest//:gtest",
        "@com_google_googletest//:gtest_main",
    ],
)

cc_test(
    name = "program_name_test",
    size = "small",
    srcs = [
        "internal/program_name_test.cc",
    ],
    copts = ABSL_TEST_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    tags = [
        "no_test_fuchsia_x64",
        "no_test_wasm",
    ],
    deps = [
        ":program_name",
        "//absl/strings",
        "@com_google_googletest//:gtest",
        "@com_google_googletest//:gtest_main",
    ],
)

cc_test(
    name = "reflection_test",
    size = "small",
    srcs = [
        "reflection_test.cc",
    ],
    copts = ABSL_TEST_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    tags = [
        "no_test:os:android",
        "no_test:os:ios",
        "no_test_android",
        "no_test_ios",
        "no_test_wasm",
    ],
    deps = [
        ":config",
        ":flag",
        ":reflection",
        "//absl/memory",
        "//absl/strings",
        "@com_google_googletest//:gtest",
        "@com_google_googletest//:gtest_main",
    ],
)

cc_test(
    name = "sequence_lock_test",
    size = "small",
    timeout = "moderate",
    srcs = [
        "internal/sequence_lock_test.cc",
    ],
    copts = ABSL_TEST_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    shard_count = 31,
    tags = ["no_test_wasm"],
    deps = [
        ":flag_internal",
        "//absl/base",
        "//absl/container:fixed_array",
        "//absl/time",
        "@com_google_googletest//:gtest",
        "@com_google_googletest//:gtest_main",
    ],
)

cc_test(
    name = "usage_config_test",
    size = "small",
    srcs = [
        "usage_config_test.cc",
    ],
    copts = ABSL_TEST_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    deps = [
        ":config",
        ":path_util",
        ":program_name",
        "//absl/strings",
        "@com_google_googletest//:gtest",
        "@com_google_googletest//:gtest_main",
    ],
)

cc_test(
    name = "usage_test",
    size = "small",
    srcs = [
        "internal/usage_test.cc",
    ],
    copts = ABSL_TEST_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    tags = [
        "no_test:os:android",
        "no_test:os:ios",
        "no_test_android",
        "no_test_ios",
        "no_test_wasm",
    ],
    deps = [
        ":config",
        ":flag",
        ":parse",
        ":path_util",
        ":program_name",
        ":reflection",
        ":usage",
        ":usage_internal",
        "//absl/strings",
        "@com_google_googletest//:gtest",
    ],
)
                                                     node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/BUILD.gn                                      0000664 0000000 0000000 00000015771 14746647661 0023632 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2019 The Chromium Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//third_party/abseil-cpp/absl.gni")

absl_source_set("path_util") {
  public = [ "internal/path_util.h" ]
  deps = [
    "//third_party/abseil-cpp/absl/base:config",
    "//third_party/abseil-cpp/absl/strings:string_view",
  ]
  visibility = [ ":*" ]
}

absl_source_set("program_name") {
  sources = [ "internal/program_name.cc" ]
  public = [ "internal/program_name.h" ]
  deps = [
    ":path_util",
    "//third_party/abseil-cpp/absl/base:config",
    "//third_party/abseil-cpp/absl/base:core_headers",
    "//third_party/abseil-cpp/absl/strings:string_view",
    "//third_party/abseil-cpp/absl/synchronization",
  ]
  visibility = [
    ":*",
    "../log:*",
  ]
}

# Since absl/flags are only used by some test binaries (e.g. in WebRTC),
# there is no need to strip flags from mobile platforms binaries.
# This does not affect Chromium.
config("absl_flags_config") {
  defines = [ "ABSL_FLAGS_STRIP_NAMES=0" ]
}

absl_source_set("config") {
  sources = [ "usage_config.cc" ]
  public_configs = [ ":absl_flags_config" ]
  public = [
    "config.h",
    "usage_config.h",
  ]
  deps = [
    ":path_util",
    ":program_name",
    "//third_party/abseil-cpp/absl/base:config",
    "//third_party/abseil-cpp/absl/base:core_headers",
    "//third_party/abseil-cpp/absl/strings",
    "//third_party/abseil-cpp/absl/strings:string_view",
    "//third_party/abseil-cpp/absl/synchronization",
  ]
}

absl_source_set("marshalling") {
  sources = [ "marshalling.cc" ]
  public = [ "marshalling.h" ]
  deps = [
    "//third_party/abseil-cpp/absl/base:config",
    "//third_party/abseil-cpp/absl/base:core_headers",
    "//third_party/abseil-cpp/absl/base:log_severity",
    "//third_party/abseil-cpp/absl/numeric:int128",
    "//third_party/abseil-cpp/absl/strings",
    "//third_party/abseil-cpp/absl/strings:str_format",
    "//third_party/abseil-cpp/absl/strings:string_view",
    "//third_party/abseil-cpp/absl/types:optional",
  ]
}

absl_source_set("commandlineflag_internal") {
  visibility = [ ":*" ]
  public = [ "internal/commandlineflag.h" ]
  sources = [ "internal/commandlineflag.cc" ]
  deps = [
    "//third_party/abseil-cpp/absl/base:config",
    "//third_party/abseil-cpp/absl/base:fast_type_id",
  ]
}

absl_source_set("commandlineflag") {
  sources = [ "commandlineflag.cc" ]
  public = [ "commandlineflag.h" ]
  deps = [
    ":commandlineflag_internal",
    "//third_party/abseil-cpp/absl/base:config",
    "//third_party/abseil-cpp/absl/base:fast_type_id",
    "//third_party/abseil-cpp/absl/strings:string_view",
    "//third_party/abseil-cpp/absl/types:optional",
  ]
}

absl_source_set("private_handle_accessor") {
  sources = [ "internal/private_handle_accessor.cc" ]
  public = [ "internal/private_handle_accessor.h" ]
  deps = [
    ":commandlineflag",
    ":commandlineflag_internal",
    "//third_party/abseil-cpp/absl/base:config",
    "//third_party/abseil-cpp/absl/strings:string_view",
  ]
  visibility = [ ":*" ]
}

absl_source_set("reflection") {
  sources = [ "reflection.cc" ]
  public = [
    "internal/registry.h",
    "reflection.h",
  ]
  deps = [
    ":commandlineflag",
    ":commandlineflag_internal",
    ":config",
    ":private_handle_accessor",
    "//third_party/abseil-cpp/absl/base:config",
    "//third_party/abseil-cpp/absl/base:core_headers",
    "//third_party/abseil-cpp/absl/base:no_destructor",
    "//third_party/abseil-cpp/absl/container:flat_hash_map",
    "//third_party/abseil-cpp/absl/strings",
    "//third_party/abseil-cpp/absl/strings:string_view",
    "//third_party/abseil-cpp/absl/synchronization",
  ]
}

absl_source_set("flag_internal") {
  sources = [ "internal/flag.cc" ]
  public = [
    "internal/flag.h",
    "internal/sequence_lock.h",
  ]
  deps = [
    ":commandlineflag",
    ":commandlineflag_internal",
    ":config",
    ":marshalling",
    ":reflection",
    "//third_party/abseil-cpp/absl/base",
    "//third_party/abseil-cpp/absl/base:config",
    "//third_party/abseil-cpp/absl/base:core_headers",
    "//third_party/abseil-cpp/absl/base:dynamic_annotations",
    "//third_party/abseil-cpp/absl/memory",
    "//third_party/abseil-cpp/absl/meta:type_traits",
    "//third_party/abseil-cpp/absl/strings",
    "//third_party/abseil-cpp/absl/strings:string_view",
    "//third_party/abseil-cpp/absl/synchronization",
    "//third_party/abseil-cpp/absl/utility",
  ]
  visibility = [
    ":*",
    "//third_party/abseil-cpp/absl/base/*",
  ]
}

absl_source_set("flag") {
  public = [
    "declare.h",
    "flag.h",
  ]
  deps = [
    ":commandlineflag",
    ":config",
    ":flag_internal",
    ":reflection",
    "//third_party/abseil-cpp/absl/base:config",
    "//third_party/abseil-cpp/absl/base:core_headers",
    "//third_party/abseil-cpp/absl/strings:string_view",
  ]
}

absl_source_set("usage_internal") {
  sources = [ "internal/usage.cc" ]
  public = [ "internal/usage.h" ]
  deps = [
    ":commandlineflag",
    ":config",
    ":flag",
    ":flag_internal",
    ":path_util",
    ":private_handle_accessor",
    ":program_name",
    ":reflection",
    "//third_party/abseil-cpp/absl/base:config",
    "//third_party/abseil-cpp/absl/base:core_headers",
    "//third_party/abseil-cpp/absl/strings",
    "//third_party/abseil-cpp/absl/strings:string_view",
    "//third_party/abseil-cpp/absl/synchronization",
  ]
  visibility = [ ":*" ]
}

absl_source_set("usage") {
  sources = [ "usage.cc" ]
  public = [ "usage.h" ]
  deps = [
    ":usage_internal",
    "//third_party/abseil-cpp/absl/base:config",
    "//third_party/abseil-cpp/absl/base:core_headers",
    "//third_party/abseil-cpp/absl/base:raw_logging_internal",
    "//third_party/abseil-cpp/absl/strings:string_view",
    "//third_party/abseil-cpp/absl/synchronization",
  ]
}

absl_source_set("parse") {
  sources = [ "parse.cc" ]
  public = [
    "internal/parse.h",
    "parse.h",
  ]
  deps = [
    ":commandlineflag",
    ":commandlineflag_internal",
    ":config",
    ":flag",
    ":flag_internal",
    ":private_handle_accessor",
    ":program_name",
    ":reflection",
    ":usage",
    ":usage_internal",
    "//third_party/abseil-cpp/absl/algorithm:container",
    "//third_party/abseil-cpp/absl/base:config",
    "//third_party/abseil-cpp/absl/base:core_headers",
    "//third_party/abseil-cpp/absl/strings",
    "//third_party/abseil-cpp/absl/strings:string_view",
    "//third_party/abseil-cpp/absl/synchronization",
  ]
}

absl_test("flag_test") {
  sources = [
    "flag_test.cc",
    "flag_test_defs.cc",
  ]
  deps = [
    ":config",
    ":flag",
    ":flag_internal",
    ":marshalling",
    ":parse",
    ":reflection",
    "//third_party/abseil-cpp/absl/base:core_headers",
    "//third_party/abseil-cpp/absl/base:malloc_internal",
    "//third_party/abseil-cpp/absl/base:raw_logging_internal",
    "//third_party/abseil-cpp/absl/numeric:int128",
    "//third_party/abseil-cpp/absl/strings",
    "//third_party/abseil-cpp/absl/strings:string_view",
    "//third_party/abseil-cpp/absl/time",
    "//third_party/abseil-cpp/absl/types:optional",
  ]
}
       node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/CMakeLists.txt                                0000664 0000000 0000000 00000020442 14746647661 0025174 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #
# Copyright 2019 The Abseil Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# Internal-only target, do not depend on directly.
absl_cc_library(
  NAME
    flags_path_util
  HDRS
    "internal/path_util.h"
  COPTS
    ${ABSL_DEFAULT_COPTS}
  LINKOPTS
    ${ABSL_DEFAULT_LINKOPTS}
  DEPS
    absl::config
    absl::strings
  PUBLIC
)

# Internal-only target, do not depend on directly.
absl_cc_library(
  NAME
    flags_program_name
  SRCS
    "internal/program_name.cc"
  HDRS
    "internal/program_name.h"
  COPTS
    ${ABSL_DEFAULT_COPTS}
  LINKOPTS
    ${ABSL_DEFAULT_LINKOPTS}
  DEPS
    absl::config
    absl::core_headers
    absl::flags_path_util
    absl::strings
    absl::synchronization
  PUBLIC
)

absl_cc_library(
  NAME
    flags_config
  SRCS
    "usage_config.cc"
  HDRS
    "config.h"
    "usage_config.h"
  COPTS
    ${ABSL_DEFAULT_COPTS}
  LINKOPTS
    ${ABSL_DEFAULT_LINKOPTS}
  DEPS
    absl::config
    absl::flags_path_util
    absl::flags_program_name
    absl::core_headers
    absl::strings
    absl::synchronization
)

absl_cc_library(
  NAME
    flags_marshalling
  SRCS
    "marshalling.cc"
  HDRS
    "marshalling.h"
  COPTS
    ${ABSL_DEFAULT_COPTS}
  LINKOPTS
    ${ABSL_DEFAULT_LINKOPTS}
  DEPS
    absl::config
    absl::core_headers
    absl::log_severity
    absl::int128
    absl::optional
    absl::strings
    absl::str_format
)

# Internal-only target, do not depend on directly.
absl_cc_library(
  NAME
    flags_commandlineflag_internal
  SRCS
    "internal/commandlineflag.cc"
  HDRS
    "internal/commandlineflag.h"
  COPTS
    ${ABSL_DEFAULT_COPTS}
  LINKOPTS
    ${ABSL_DEFAULT_LINKOPTS}
  DEPS
    absl::config
    absl::dynamic_annotations
    absl::fast_type_id
)

absl_cc_library(
  NAME
    flags_commandlineflag
  SRCS
    "commandlineflag.cc"
  HDRS
    "commandlineflag.h"
  COPTS
    ${ABSL_DEFAULT_COPTS}
  LINKOPTS
    ${ABSL_DEFAULT_LINKOPTS}
  DEPS
    absl::config
    absl::fast_type_id
    absl::flags_commandlineflag_internal
    absl::optional
    absl::strings
)

# Internal-only target, do not depend on directly.
absl_cc_library(
  NAME
    flags_private_handle_accessor
  SRCS
    "internal/private_handle_accessor.cc"
  HDRS
    "internal/private_handle_accessor.h"
  COPTS
    ${ABSL_DEFAULT_COPTS}
  LINKOPTS
    ${ABSL_DEFAULT_LINKOPTS}
  DEPS
    absl::config
    absl::flags_commandlineflag
    absl::flags_commandlineflag_internal
    absl::strings
)

absl_cc_library(
  NAME
    flags_reflection
  SRCS
    "reflection.cc"
  HDRS
    "reflection.h"
    "internal/registry.h"
  COPTS
    ${ABSL_DEFAULT_COPTS}
  LINKOPTS
    ${ABSL_DEFAULT_LINKOPTS}
  DEPS
    absl::config
    absl::flags_commandlineflag
    absl::flags_private_handle_accessor
    absl::flags_config
    absl::strings
    absl::synchronization
    absl::flat_hash_map
    absl::no_destructor
)

# Internal-only target, do not depend on directly.
absl_cc_library(
  NAME
    flags_internal
  SRCS
    "internal/flag.cc"
  HDRS
    "internal/flag.h"
    "internal/sequence_lock.h"
  COPTS
    ${ABSL_DEFAULT_COPTS}
  LINKOPTS
    ${ABSL_DEFAULT_LINKOPTS}
  DEPS
    absl::base
    absl::config
    absl::flags_commandlineflag
    absl::flags_commandlineflag_internal
    absl::flags_config
    absl::flags_marshalling
    absl::synchronization
    absl::meta
    absl::utility
  PUBLIC
)

absl_cc_library(
  NAME
    flags
  HDRS
    "declare.h"
    "flag.h"
  COPTS
    ${ABSL_DEFAULT_COPTS}
  LINKOPTS
    ${ABSL_DEFAULT_LINKOPTS}
  DEPS
    absl::config
    absl::flags_commandlineflag
    absl::flags_config
    absl::flags_internal
    absl::flags_reflection
    absl::core_headers
    absl::strings
)

# Internal-only target, do not depend on directly.
absl_cc_library(
  NAME
    flags_usage_internal
  SRCS
    "internal/usage.cc"
  HDRS
    "internal/usage.h"
  COPTS
    ${ABSL_DEFAULT_COPTS}
  LINKOPTS
    ${ABSL_DEFAULT_LINKOPTS}
  DEPS
    absl::config
    absl::flags_config
    absl::flags
    absl::flags_commandlineflag
    absl::flags_internal
    absl::flags_path_util
    absl::flags_private_handle_accessor
    absl::flags_program_name
    absl::flags_reflection
    absl::strings
    absl::synchronization
)

absl_cc_library(
  NAME
    flags_usage
  SRCS
    "usage.cc"
  HDRS
    "usage.h"
  COPTS
    ${ABSL_DEFAULT_COPTS}
  LINKOPTS
    ${ABSL_DEFAULT_LINKOPTS}
  DEPS
    absl::config
    absl::core_headers
    absl::flags_usage_internal
    absl::raw_logging_internal
    absl::strings
    absl::synchronization
)

absl_cc_library(
  NAME
    flags_parse
  SRCS
    "parse.cc"
  HDRS
    "internal/parse.h"
    "parse.h"
  COPTS
    ${ABSL_DEFAULT_COPTS}
  LINKOPTS
    ${ABSL_DEFAULT_LINKOPTS}
  DEPS
    absl::algorithm_container
    absl::config
    absl::core_headers
    absl::flags_config
    absl::flags
    absl::flags_commandlineflag
    absl::flags_commandlineflag_internal
    absl::flags_internal
    absl::flags_private_handle_accessor
    absl::flags_program_name
    absl::flags_reflection
    absl::flags_usage
    absl::strings
    absl::synchronization
)

############################################################################
# Unit tests in alphabetical order.

absl_cc_test(
  NAME
    flags_commandlineflag_test
  SRCS
    "commandlineflag_test.cc"
  COPTS
    ${ABSL_TEST_COPTS}
  DEPS
    absl::flags
    absl::flags_commandlineflag
    absl::flags_config
    absl::flags_private_handle_accessor
    absl::flags_reflection
    absl::memory
    absl::strings
    GTest::gtest_main
)

absl_cc_test(
  NAME
    flags_config_test
  SRCS
    "config_test.cc"
  COPTS
    ${ABSL_TEST_COPTS}
  DEPS
    absl::flags_config
    GTest::gtest_main
)

absl_cc_test(
  NAME
    flags_flag_test
  SRCS
    "flag_test.cc"
    "flag_test_defs.cc"
  COPTS
    ${ABSL_TEST_COPTS}
  DEPS
    absl::core_headers
    absl::flags
    absl::flags_config
    absl::flags_internal
    absl::flags_marshalling
    absl::flags_parse
    absl::flags_reflection
    absl::int128
    absl::optional
    absl::raw_logging_internal
    absl::strings
    absl::time
    GTest::gtest_main
)

absl_cc_test(
  NAME
    flags_marshalling_test
  SRCS
    "marshalling_test.cc"
  COPTS
    ${ABSL_TEST_COPTS}
  DEPS
    absl::flags_marshalling
    GTest::gtest_main
)

absl_cc_test(
  NAME
    flags_parse_test
  SRCS
    "parse_test.cc"
  COPTS
    ${ABSL_TEST_COPTS}
  DEPS
    absl::flags
    absl::flags_config
    absl::flags_parse
    absl::flags_reflection
    absl::flags_usage_internal
    absl::log
    absl::scoped_set_env
    absl::span
    absl::strings
    GTest::gmock_main
)

absl_cc_test(
  NAME
    flags_path_util_test
  SRCS
    "internal/path_util_test.cc"
  COPTS
    ${ABSL_TEST_COPTS}
  DEPS
    absl::flags_path_util
    GTest::gtest_main
)

absl_cc_test(
  NAME
    flags_program_name_test
  SRCS
    "internal/program_name_test.cc"
  COPTS
    ${ABSL_TEST_COPTS}
  DEPS
    absl::flags_program_name
    absl::strings
    GTest::gtest_main
)

absl_cc_test(
  NAME
    flags_reflection_test
  SRCS
    "reflection_test.cc"
  COPTS
    ${ABSL_TEST_COPTS}
  DEPS
    absl::flags
    absl::flags_config
    absl::flags_reflection
    absl::flags_usage
    absl::memory
    absl::strings
    GTest::gmock_main
)

absl_cc_test(
  NAME
    flags_sequence_lock_test
  SRCS
    "internal/sequence_lock_test.cc"
  COPTS
    ${ABSL_TEST_COPTS}
  DEPS
    absl::base
    absl::flags_internal
    absl::time
    GTest::gmock_main
)

absl_cc_test(
  NAME
    flags_usage_config_test
  SRCS
    "usage_config_test.cc"
  COPTS
    ${ABSL_TEST_COPTS}
  DEPS
    absl::flags_config
    absl::flags_path_util
    absl::flags_program_name
    absl::strings
    GTest::gtest_main
)

absl_cc_test(
  NAME
    flags_usage_test
  SRCS
    "internal/usage_test.cc"
  COPTS
    ${ABSL_TEST_COPTS}
  DEPS
    absl::flags_config
    absl::flags
    absl::flags_path_util
    absl::flags_program_name
    absl::flags_parse
    absl::flags_reflection
    absl::flags_usage
    absl::strings
    GTest::gmock
)
                                                                                                                                                                                                                              node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/commandlineflag.cc                            0000664 0000000 0000000 00000002143 14746647661 0026061 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
// Copyright 2020 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/flags/commandlineflag.h"

#include <string>

#include "absl/base/config.h"
#include "absl/flags/internal/commandlineflag.h"
#include "absl/strings/string_view.h"

namespace absl {
ABSL_NAMESPACE_BEGIN

bool CommandLineFlag::IsRetired() const { return false; }
bool CommandLineFlag::ParseFrom(absl::string_view value, std::string* error) {
  return ParseFrom(value, flags_internal::SET_FLAGS_VALUE,
                   flags_internal::kProgrammaticChange, *error);
}

ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/commandlineflag.h                             0000664 0000000 0000000 00000016460 14746647661 0025732 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
// Copyright 2020 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// -----------------------------------------------------------------------------
// File: commandlineflag.h
// -----------------------------------------------------------------------------
//
// This header file defines the `CommandLineFlag`, which acts as a type-erased
// handle for accessing metadata about the Abseil Flag in question.
//
// Because an actual Abseil flag is of an unspecified type, you should not
// manipulate or interact directly with objects of that type. Instead, use the
// CommandLineFlag type as an intermediary.
#ifndef ABSL_FLAGS_COMMANDLINEFLAG_H_
#define ABSL_FLAGS_COMMANDLINEFLAG_H_

#include <memory>
#include <string>

#include "absl/base/config.h"
#include "absl/base/internal/fast_type_id.h"
#include "absl/flags/internal/commandlineflag.h"
#include "absl/strings/string_view.h"
#include "absl/types/optional.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace flags_internal {
class PrivateHandleAccessor;
}  // namespace flags_internal

// CommandLineFlag
//
// This type acts as a type-erased handle for an instance of an Abseil Flag and
// holds reflection information pertaining to that flag. Use CommandLineFlag to
// access a flag's name, location, help string etc.
//
// To obtain an absl::CommandLineFlag, invoke `absl::FindCommandLineFlag()`
// passing it the flag name string.
//
// Example:
//
//   // Obtain reflection handle for a flag named "flagname".
//   const absl::CommandLineFlag* my_flag_data =
//        absl::FindCommandLineFlag("flagname");
//
//   // Now you can get flag info from that reflection handle.
//   std::string flag_location = my_flag_data->Filename();
//   ...

// These are only used as constexpr global objects.
// They do not use a virtual destructor to simplify their implementation.
// They are not destroyed except at program exit, so leaks do not matter.
#if defined(__GNUC__) && !defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wnon-virtual-dtor"
#endif
class CommandLineFlag {
 public:
  constexpr CommandLineFlag() = default;

  // Not copyable/assignable.
  CommandLineFlag(const CommandLineFlag&) = delete;
  CommandLineFlag& operator=(const CommandLineFlag&) = delete;

  // absl::CommandLineFlag::IsOfType()
  //
  // Return true iff flag has type T.
  template <typename T>
  inline bool IsOfType() const {
    return TypeId() == base_internal::FastTypeId<T>();
  }

  // absl::CommandLineFlag::TryGet()
  //
  // Attempts to retrieve the flag value. Returns value on success,
  // absl::nullopt otherwise.
  template <typename T>
  absl::optional<T> TryGet() const {
    if (IsRetired() || !IsOfType<T>()) {
      return absl::nullopt;
    }

    // Implementation notes:
    //
    // We are wrapping a union around the value of `T` to serve three purposes:
    //
    //  1. `U.value` has correct size and alignment for a value of type `T`
    //  2. The `U.value` constructor is not invoked since U's constructor does
    //     not do it explicitly.
    //  3. The `U.value` destructor is invoked since U's destructor does it
    //     explicitly. This makes `U` a kind of RAII wrapper around non default
    //     constructible value of T, which is destructed when we leave the
    //     scope. We do need to destroy U.value, which is constructed by
    //     CommandLineFlag::Read even though we left it in a moved-from state
    //     after std::move.
    //
    // All of this serves to avoid requiring `T` being default constructible.
    union U {
      T value;
      U() {}
      ~U() { value.~T(); }
    };
    U u;

    Read(&u.value);
    // allow retired flags to be "read", so we can report invalid access.
    if (IsRetired()) {
      return absl::nullopt;
    }
    return std::move(u.value);
  }

  // absl::CommandLineFlag::Name()
  //
  // Returns name of this flag.
  virtual absl::string_view Name() const = 0;

  // absl::CommandLineFlag::Filename()
  //
  // Returns name of the file where this flag is defined.
  virtual std::string Filename() const = 0;

  // absl::CommandLineFlag::Help()
  //
  // Returns help message associated with this flag.
  virtual std::string Help() const = 0;

  // absl::CommandLineFlag::IsRetired()
  //
  // Returns true iff this object corresponds to retired flag.
  virtual bool IsRetired() const;

  // absl::CommandLineFlag::DefaultValue()
  //
  // Returns the default value for this flag.
  virtual std::string DefaultValue() const = 0;

  // absl::CommandLineFlag::CurrentValue()
  //
  // Returns the current value for this flag.
  virtual std::string CurrentValue() const = 0;

  // absl::CommandLineFlag::ParseFrom()
  //
  // Sets the value of the flag based on specified string `value`. If the flag
  // was successfully set to new value, it returns true. Otherwise, sets `error`
  // to indicate the error, leaves the flag unchanged, and returns false.
  bool ParseFrom(absl::string_view value, std::string* error);

 protected:
  ~CommandLineFlag() = default;

 private:
  friend class flags_internal::PrivateHandleAccessor;

  // Sets the value of the flag based on specified string `value`. If the flag
  // was successfully set to new value, it returns true. Otherwise, sets `error`
  // to indicate the error, leaves the flag unchanged, and returns false. There
  // are three ways to set the flag's value:
  //  * Update the current flag value
  //  * Update the flag's default value
  //  * Update the current flag value if it was never set before
  // The mode is selected based on `set_mode` parameter.
  virtual bool ParseFrom(absl::string_view value,
                         flags_internal::FlagSettingMode set_mode,
                         flags_internal::ValueSource source,
                         std::string& error) = 0;

  // Returns id of the flag's value type.
  virtual flags_internal::FlagFastTypeId TypeId() const = 0;

  // Interface to save flag to some persistent state. Returns current flag state
  // or nullptr if flag does not support saving and restoring a state.
  virtual std::unique_ptr<flags_internal::FlagStateInterface> SaveState() = 0;

  // Copy-construct a new value of the flag's type in a memory referenced by
  // the dst based on the current flag's value.
  virtual void Read(void* dst) const = 0;

  // To be deleted. Used to return true if flag's current value originated from
  // command line.
  virtual bool IsSpecifiedOnCommandLine() const = 0;

  // Validates supplied value using validator or parseflag routine
  virtual bool ValidateInputValue(absl::string_view value) const = 0;

  // Checks that flags default value can be converted to string and back to the
  // flag's value type.
  virtual void CheckDefaultValueParsingRoundtrip() const = 0;
};
#if defined(__GNUC__) && !defined(__clang__)
#pragma GCC diagnostic pop
#endif

ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_FLAGS_COMMANDLINEFLAG_H_
                                                                                                                                                                                                                node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/commandlineflag_test.cc                       0000664 0000000 0000000 00000020464 14746647661 0027126 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
//  Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/flags/commandlineflag.h"

#include <memory>
#include <string>

#include "gtest/gtest.h"
#include "absl/flags/config.h"
#include "absl/flags/flag.h"
#include "absl/flags/internal/private_handle_accessor.h"
#include "absl/flags/reflection.h"
#include "absl/flags/usage_config.h"
#include "absl/memory/memory.h"
#include "absl/strings/match.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"

ABSL_FLAG(int, int_flag, 201, "int_flag help");
ABSL_FLAG(std::string, string_flag, "dflt",
          absl::StrCat("string_flag", " help"));
ABSL_RETIRED_FLAG(bool, bool_retired_flag, false, "bool_retired_flag help");

// These are only used to test default values.
ABSL_FLAG(int, int_flag2, 201, "");
ABSL_FLAG(std::string, string_flag2, "dflt", "");

namespace {

namespace flags = absl::flags_internal;

class CommandLineFlagTest : public testing::Test {
 protected:
  static void SetUpTestSuite() {
    // Install a function to normalize filenames before this test is run.
    absl::FlagsUsageConfig default_config;
    default_config.normalize_filename = &CommandLineFlagTest::NormalizeFileName;
    absl::SetFlagsUsageConfig(default_config);
  }

  void SetUp() override {
#if ABSL_FLAGS_STRIP_NAMES
    GTEST_SKIP() << "This test requires flag names to be present";
#endif
    flag_saver_ = absl::make_unique<absl::FlagSaver>();
  }
  void TearDown() override { flag_saver_.reset(); }

 private:
  static std::string NormalizeFileName(absl::string_view fname) {
#ifdef _WIN32
    std::string normalized(fname);
    std::replace(normalized.begin(), normalized.end(), '\\', '/');
    fname = normalized;
#endif
    return std::string(fname);
  }

  std::unique_ptr<absl::FlagSaver> flag_saver_;
};

TEST_F(CommandLineFlagTest, TestAttributesAccessMethods) {
  auto* flag_01 = absl::FindCommandLineFlag("int_flag");

  ASSERT_TRUE(flag_01);
  EXPECT_EQ(flag_01->Name(), "int_flag");
  EXPECT_EQ(flag_01->Help(), "int_flag help");
  EXPECT_TRUE(!flag_01->IsRetired());
  EXPECT_TRUE(flag_01->IsOfType<int>());
  EXPECT_TRUE(!flag_01->IsOfType<bool>());
  EXPECT_TRUE(!flag_01->IsOfType<std::string>());
  EXPECT_TRUE(absl::EndsWith(flag_01->Filename(),
                             "absl/flags/commandlineflag_test.cc"))
      << flag_01->Filename();

  auto* flag_02 = absl::FindCommandLineFlag("string_flag");

  ASSERT_TRUE(flag_02);
  EXPECT_EQ(flag_02->Name(), "string_flag");
  EXPECT_EQ(flag_02->Help(), "string_flag help");
  EXPECT_TRUE(!flag_02->IsRetired());
  EXPECT_TRUE(flag_02->IsOfType<std::string>());
  EXPECT_TRUE(!flag_02->IsOfType<bool>());
  EXPECT_TRUE(!flag_02->IsOfType<int>());
  EXPECT_TRUE(absl::EndsWith(flag_02->Filename(),
                             "absl/flags/commandlineflag_test.cc"))
      << flag_02->Filename();
}

// --------------------------------------------------------------------

TEST_F(CommandLineFlagTest, TestValueAccessMethods) {
  absl::SetFlag(&FLAGS_int_flag2, 301);
  auto* flag_01 = absl::FindCommandLineFlag("int_flag2");

  ASSERT_TRUE(flag_01);
  EXPECT_EQ(flag_01->CurrentValue(), "301");
  EXPECT_EQ(flag_01->DefaultValue(), "201");

  absl::SetFlag(&FLAGS_string_flag2, "new_str_value");
  auto* flag_02 = absl::FindCommandLineFlag("string_flag2");

  ASSERT_TRUE(flag_02);
  EXPECT_EQ(flag_02->CurrentValue(), "new_str_value");
  EXPECT_EQ(flag_02->DefaultValue(), "dflt");
}

// --------------------------------------------------------------------

TEST_F(CommandLineFlagTest, TestParseFromCurrentValue) {
  std::string err;

  auto* flag_01 = absl::FindCommandLineFlag("int_flag");
  EXPECT_FALSE(
      flags::PrivateHandleAccessor::IsSpecifiedOnCommandLine(*flag_01));

  EXPECT_TRUE(flags::PrivateHandleAccessor::ParseFrom(
      *flag_01, "11", flags::SET_FLAGS_VALUE, flags::kProgrammaticChange, err));
  EXPECT_EQ(absl::GetFlag(FLAGS_int_flag), 11);
  EXPECT_FALSE(
      flags::PrivateHandleAccessor::IsSpecifiedOnCommandLine(*flag_01));

  EXPECT_TRUE(flags::PrivateHandleAccessor::ParseFrom(
      *flag_01, "-123", flags::SET_FLAGS_VALUE, flags::kProgrammaticChange,
      err));
  EXPECT_EQ(absl::GetFlag(FLAGS_int_flag), -123);
  EXPECT_FALSE(
      flags::PrivateHandleAccessor::IsSpecifiedOnCommandLine(*flag_01));

  EXPECT_TRUE(!flags::PrivateHandleAccessor::ParseFrom(
      *flag_01, "xyz", flags::SET_FLAGS_VALUE, flags::kProgrammaticChange,
      err));
  EXPECT_EQ(absl::GetFlag(FLAGS_int_flag), -123);
  EXPECT_EQ(err, "Illegal value 'xyz' specified for flag 'int_flag'");
  EXPECT_FALSE(
      flags::PrivateHandleAccessor::IsSpecifiedOnCommandLine(*flag_01));

  EXPECT_TRUE(!flags::PrivateHandleAccessor::ParseFrom(
      *flag_01, "A1", flags::SET_FLAGS_VALUE, flags::kProgrammaticChange, err));
  EXPECT_EQ(absl::GetFlag(FLAGS_int_flag), -123);
  EXPECT_EQ(err, "Illegal value 'A1' specified for flag 'int_flag'");
  EXPECT_FALSE(
      flags::PrivateHandleAccessor::IsSpecifiedOnCommandLine(*flag_01));

  EXPECT_TRUE(flags::PrivateHandleAccessor::ParseFrom(
      *flag_01, "0x10", flags::SET_FLAGS_VALUE, flags::kProgrammaticChange,
      err));
  EXPECT_EQ(absl::GetFlag(FLAGS_int_flag), 16);
  EXPECT_FALSE(
      flags::PrivateHandleAccessor::IsSpecifiedOnCommandLine(*flag_01));

  EXPECT_TRUE(flags::PrivateHandleAccessor::ParseFrom(
      *flag_01, "011", flags::SET_FLAGS_VALUE, flags::kCommandLine, err));
  EXPECT_EQ(absl::GetFlag(FLAGS_int_flag), 11);
  EXPECT_TRUE(flags::PrivateHandleAccessor::IsSpecifiedOnCommandLine(*flag_01));

  EXPECT_TRUE(!flags::PrivateHandleAccessor::ParseFrom(
      *flag_01, "", flags::SET_FLAGS_VALUE, flags::kProgrammaticChange, err));
  EXPECT_EQ(err, "Illegal value '' specified for flag 'int_flag'");

  auto* flag_02 = absl::FindCommandLineFlag("string_flag");
  EXPECT_TRUE(flags::PrivateHandleAccessor::ParseFrom(
      *flag_02, "xyz", flags::SET_FLAGS_VALUE, flags::kProgrammaticChange,
      err));
  EXPECT_EQ(absl::GetFlag(FLAGS_string_flag), "xyz");

  EXPECT_TRUE(flags::PrivateHandleAccessor::ParseFrom(
      *flag_02, "", flags::SET_FLAGS_VALUE, flags::kProgrammaticChange, err));
  EXPECT_EQ(absl::GetFlag(FLAGS_string_flag), "");
}

// --------------------------------------------------------------------

TEST_F(CommandLineFlagTest, TestParseFromDefaultValue) {
  std::string err;

  auto* flag_01 = absl::FindCommandLineFlag("int_flag");

  EXPECT_TRUE(flags::PrivateHandleAccessor::ParseFrom(
      *flag_01, "111", flags::SET_FLAGS_DEFAULT, flags::kProgrammaticChange,
      err));
  EXPECT_EQ(flag_01->DefaultValue(), "111");

  auto* flag_02 = absl::FindCommandLineFlag("string_flag");

  EXPECT_TRUE(flags::PrivateHandleAccessor::ParseFrom(
      *flag_02, "abc", flags::SET_FLAGS_DEFAULT, flags::kProgrammaticChange,
      err));
  EXPECT_EQ(flag_02->DefaultValue(), "abc");
}

// --------------------------------------------------------------------

TEST_F(CommandLineFlagTest, TestParseFromIfDefault) {
  std::string err;

  auto* flag_01 = absl::FindCommandLineFlag("int_flag");

  EXPECT_TRUE(flags::PrivateHandleAccessor::ParseFrom(
      *flag_01, "22", flags::SET_FLAG_IF_DEFAULT, flags::kProgrammaticChange,
      err))
      << err;
  EXPECT_EQ(absl::GetFlag(FLAGS_int_flag), 22);

  EXPECT_TRUE(flags::PrivateHandleAccessor::ParseFrom(
      *flag_01, "33", flags::SET_FLAG_IF_DEFAULT, flags::kProgrammaticChange,
      err));
  EXPECT_EQ(absl::GetFlag(FLAGS_int_flag), 22);
  // EXPECT_EQ(err, "ERROR: int_flag is already set to 22");

  // Reset back to default value
  EXPECT_TRUE(flags::PrivateHandleAccessor::ParseFrom(
      *flag_01, "201", flags::SET_FLAGS_VALUE, flags::kProgrammaticChange,
      err));

  EXPECT_TRUE(flags::PrivateHandleAccessor::ParseFrom(
      *flag_01, "33", flags::SET_FLAG_IF_DEFAULT, flags::kProgrammaticChange,
      err));
  EXPECT_EQ(absl::GetFlag(FLAGS_int_flag), 201);
  // EXPECT_EQ(err, "ERROR: int_flag is already set to 201");
}

}  // namespace
                                                                                                                                                                                                            node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/config.h                                      0000664 0000000 0000000 00000004523 14746647661 0024054 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
//  Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef ABSL_FLAGS_CONFIG_H_
#define ABSL_FLAGS_CONFIG_H_

// Determine if we should strip string literals from the Flag objects.
// By default we strip string literals on mobile platforms.
#if !defined(ABSL_FLAGS_STRIP_NAMES)

#if defined(__ANDROID__)
#define ABSL_FLAGS_STRIP_NAMES 1

#elif defined(__APPLE__)
#include <TargetConditionals.h>
#if defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE
#define ABSL_FLAGS_STRIP_NAMES 1
#elif defined(TARGET_OS_EMBEDDED) && TARGET_OS_EMBEDDED
#define ABSL_FLAGS_STRIP_NAMES 1
#endif  // TARGET_OS_*
#endif

#endif  // !defined(ABSL_FLAGS_STRIP_NAMES)

#if !defined(ABSL_FLAGS_STRIP_NAMES)
// If ABSL_FLAGS_STRIP_NAMES wasn't set on the command line or above,
// the default is not to strip.
#define ABSL_FLAGS_STRIP_NAMES 0
#endif

#if !defined(ABSL_FLAGS_STRIP_HELP)
// By default, if we strip names, we also strip help.
#define ABSL_FLAGS_STRIP_HELP ABSL_FLAGS_STRIP_NAMES
#endif

// These macros represent the "source of truth" for the list of supported
// built-in types.
#define ABSL_FLAGS_INTERNAL_BUILTIN_TYPES(A) \
  A(bool, bool)                              \
  A(short, short)                            \
  A(unsigned short, unsigned_short)          \
  A(int, int)                                \
  A(unsigned int, unsigned_int)              \
  A(long, long)                              \
  A(unsigned long, unsigned_long)            \
  A(long long, long_long)                    \
  A(unsigned long long, unsigned_long_long)  \
  A(double, double)                          \
  A(float, float)

#define ABSL_FLAGS_INTERNAL_SUPPORTED_TYPES(A) \
  ABSL_FLAGS_INTERNAL_BUILTIN_TYPES(A)         \
  A(std::string, std_string)                   \
  A(std::vector<std::string>, std_vector_of_string)

#endif  // ABSL_FLAGS_CONFIG_H_
                                                                                                                                                                             node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/config_test.cc                                0000664 0000000 0000000 00000003655 14746647661 0025256 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //  Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/flags/config.h"

#ifdef __APPLE__
#include <TargetConditionals.h>
#endif

#include "gtest/gtest.h"

#ifndef ABSL_FLAGS_STRIP_NAMES
#error ABSL_FLAGS_STRIP_NAMES is not defined
#endif

#ifndef ABSL_FLAGS_STRIP_HELP
#error ABSL_FLAGS_STRIP_HELP is not defined
#endif

namespace {

// Test that ABSL_FLAGS_STRIP_NAMES and ABSL_FLAGS_STRIP_HELP are configured how
// we expect them to be configured by default. If you override this
// configuration, this test will fail, but the code should still be safe to use.
TEST(FlagsConfigTest, Test) {
#if defined(__ANDROID__)
  EXPECT_EQ(ABSL_FLAGS_STRIP_NAMES, 1);
  EXPECT_EQ(ABSL_FLAGS_STRIP_HELP, 1);
#elif defined(__myriad2__)
  EXPECT_EQ(ABSL_FLAGS_STRIP_NAMES, 0);
  EXPECT_EQ(ABSL_FLAGS_STRIP_HELP, 0);
#elif defined(TARGET_OS_IPHONE) && TARGET_OS_IPHONE
  EXPECT_EQ(ABSL_FLAGS_STRIP_NAMES, 1);
  EXPECT_EQ(ABSL_FLAGS_STRIP_HELP, 1);
#elif defined(TARGET_OS_EMBEDDED) && TARGET_OS_EMBEDDED
  EXPECT_EQ(ABSL_FLAGS_STRIP_NAMES, 1);
  EXPECT_EQ(ABSL_FLAGS_STRIP_HELP, 1);
#elif defined(__APPLE__)
  EXPECT_EQ(ABSL_FLAGS_STRIP_NAMES, 0);
  EXPECT_EQ(ABSL_FLAGS_STRIP_HELP, 0);
#elif defined(_WIN32)
  EXPECT_EQ(ABSL_FLAGS_STRIP_NAMES, 0);
  EXPECT_EQ(ABSL_FLAGS_STRIP_HELP, 0);
#elif defined(__linux__)
  EXPECT_EQ(ABSL_FLAGS_STRIP_NAMES, 0);
  EXPECT_EQ(ABSL_FLAGS_STRIP_HELP, 0);
#endif
}

}  // namespace
                                                                                   node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/declare.h                                     0000664 0000000 0000000 00000004570 14746647661 0024210 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
//  Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// -----------------------------------------------------------------------------
// File: declare.h
// -----------------------------------------------------------------------------
//
// This file defines the ABSL_DECLARE_FLAG macro, allowing you to declare an
// `absl::Flag` for use within a translation unit. You should place this
// declaration within the header file associated with the .cc file that defines
// and owns the `Flag`.

#ifndef ABSL_FLAGS_DECLARE_H_
#define ABSL_FLAGS_DECLARE_H_

#include "absl/base/config.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace flags_internal {

// absl::Flag<T> represents a flag of type 'T' created by ABSL_FLAG.
template <typename T>
class Flag;

}  // namespace flags_internal

// Flag
//
// Forward declaration of the `absl::Flag` type for use in defining the macro.
template <typename T>
using Flag = flags_internal::Flag<T>;

ABSL_NAMESPACE_END
}  // namespace absl

// ABSL_DECLARE_FLAG()
//
// This macro is a convenience for declaring use of an `absl::Flag` within a
// translation unit. This macro should be used within a header file to
// declare usage of the flag within any .cc file including that header file.
//
// The ABSL_DECLARE_FLAG(type, name) macro expands to:
//
//   extern absl::Flag<type> FLAGS_name;
#define ABSL_DECLARE_FLAG(type, name) ABSL_DECLARE_FLAG_INTERNAL(type, name)

// Internal implementation of ABSL_DECLARE_FLAG to allow macro expansion of its
// arguments. Clients must use ABSL_DECLARE_FLAG instead.
#define ABSL_DECLARE_FLAG_INTERNAL(type, name)               \
  extern absl::Flag<type> FLAGS_##name;                      \
  namespace absl /* block flags in namespaces */ {}          \
  /* second redeclaration is to allow applying attributes */ \
  extern absl::Flag<type> FLAGS_##name

#endif  // ABSL_FLAGS_DECLARE_H_
                                                                                                                                        node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/flag.h                                        0000664 0000000 0000000 00000031567 14746647661 0023530 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
//  Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// -----------------------------------------------------------------------------
// File: flag.h
// -----------------------------------------------------------------------------
//
// This header file defines the `absl::Flag<T>` type for holding command-line
// flag data, and abstractions to create, get and set such flag data.
//
// It is important to note that this type is **unspecified** (an implementation
// detail) and you do not construct or manipulate actual `absl::Flag<T>`
// instances. Instead, you define and declare flags using the
// `ABSL_FLAG()` and `ABSL_DECLARE_FLAG()` macros, and get and set flag values
// using the `absl::GetFlag()` and `absl::SetFlag()` functions.

#ifndef ABSL_FLAGS_FLAG_H_
#define ABSL_FLAGS_FLAG_H_

#include <cstdint>
#include <string>
#include <type_traits>

#include "absl/base/attributes.h"
#include "absl/base/config.h"
#include "absl/base/optimization.h"
#include "absl/flags/commandlineflag.h"
#include "absl/flags/config.h"
#include "absl/flags/internal/flag.h"
#include "absl/flags/internal/registry.h"
#include "absl/strings/string_view.h"

namespace absl {
ABSL_NAMESPACE_BEGIN

// Flag
//
// An `absl::Flag` holds a command-line flag value, providing a runtime
// parameter to a binary. Such flags should be defined in the global namespace
// and (preferably) in the module containing the binary's `main()` function.
//
// You should not construct and cannot use the `absl::Flag` type directly;
// instead, you should declare flags using the `ABSL_DECLARE_FLAG()` macro
// within a header file, and define your flag using `ABSL_FLAG()` within your
// header's associated `.cc` file. Such flags will be named `FLAGS_name`.
//
// Example:
//
//    .h file
//
//      // Declares usage of a flag named "FLAGS_count"
//      ABSL_DECLARE_FLAG(int, count);
//
//    .cc file
//
//      // Defines a flag named "FLAGS_count" with a default `int` value of 0.
//      ABSL_FLAG(int, count, 0, "Count of items to process");
//
// No public methods of `absl::Flag<T>` are part of the Abseil Flags API.
//
// For type support of Abseil Flags, see the marshalling.h header file, which
// discusses supported standard types, optional flags, and additional Abseil
// type support.

template <typename T>
using Flag = flags_internal::Flag<T>;

// GetFlag()
//
// Returns the value (of type `T`) of an `absl::Flag<T>` instance, by value. Do
// not construct an `absl::Flag<T>` directly and call `absl::GetFlag()`;
// instead, refer to flag's constructed variable name (e.g. `FLAGS_name`).
// Because this function returns by value and not by reference, it is
// thread-safe, but note that the operation may be expensive; as a result, avoid
// `absl::GetFlag()` within any tight loops.
//
// Example:
//
//   // FLAGS_count is a Flag of type `int`
//   int my_count = absl::GetFlag(FLAGS_count);
//
//   // FLAGS_firstname is a Flag of type `std::string`
//   std::string first_name = absl::GetFlag(FLAGS_firstname);
template <typename T>
ABSL_MUST_USE_RESULT T GetFlag(const absl::Flag<T>& flag) {
  return flags_internal::FlagImplPeer::InvokeGet<T>(flag);
}

// SetFlag()
//
// Sets the value of an `absl::Flag` to the value `v`. Do not construct an
// `absl::Flag<T>` directly and call `absl::SetFlag()`; instead, use the
// flag's variable name (e.g. `FLAGS_name`). This function is
// thread-safe, but is potentially expensive. Avoid setting flags in general,
// but especially within performance-critical code.
template <typename T>
void SetFlag(absl::Flag<T>* flag, const T& v) {
  flags_internal::FlagImplPeer::InvokeSet(*flag, v);
}

// Overload of `SetFlag()` to allow callers to pass in a value that is
// convertible to `T`. E.g., use this overload to pass a "const char*" when `T`
// is `std::string`.
template <typename T, typename V>
void SetFlag(absl::Flag<T>* flag, const V& v) {
  T value(v);
  flags_internal::FlagImplPeer::InvokeSet(*flag, value);
}

// GetFlagReflectionHandle()
//
// Returns the reflection handle corresponding to specified Abseil Flag
// instance. Use this handle to access flag's reflection information, like name,
// location, default value etc.
//
// Example:
//
//   std::string = absl::GetFlagReflectionHandle(FLAGS_count).DefaultValue();

template <typename T>
const CommandLineFlag& GetFlagReflectionHandle(const absl::Flag<T>& f) {
  return flags_internal::FlagImplPeer::InvokeReflect(f);
}

ABSL_NAMESPACE_END
}  // namespace absl


// ABSL_FLAG()
//
// This macro defines an `absl::Flag<T>` instance of a specified type `T`:
//
//   ABSL_FLAG(T, name, default_value, help);
//
// where:
//
//   * `T` is a supported flag type (see the list of types in `marshalling.h`),
//   * `name` designates the name of the flag (as a global variable
//     `FLAGS_name`),
//   * `default_value` is an expression holding the default value for this flag
//     (which must be implicitly convertible to `T`),
//   * `help` is the help text, which can also be an expression.
//
// This macro expands to a flag named 'FLAGS_name' of type 'T':
//
//   absl::Flag<T> FLAGS_name = ...;
//
// Note that all such instances are created as global variables.
//
// For `ABSL_FLAG()` values that you wish to expose to other translation units,
// it is recommended to define those flags within the `.cc` file associated with
// the header where the flag is declared.
//
// Note: do not construct objects of type `absl::Flag<T>` directly. Only use the
// `ABSL_FLAG()` macro for such construction.
#define ABSL_FLAG(Type, name, default_value, help) \
  ABSL_FLAG_IMPL(Type, name, default_value, help)

// ABSL_FLAG().OnUpdate()
//
// Defines a flag of type `T` with a callback attached:
//
//   ABSL_FLAG(T, name, default_value, help).OnUpdate(callback);
//
// `callback` should be convertible to `void (*)()`.
//
// After any setting of the flag value, the callback will be called at least
// once. A rapid sequence of changes may be merged together into the same
// callback. No concurrent calls to the callback will be made for the same
// flag. Callbacks are allowed to read the current value of the flag but must
// not mutate that flag.
//
// The update mechanism guarantees "eventual consistency"; if the callback
// derives an auxiliary data structure from the flag value, it is guaranteed
// that eventually the flag value and the derived data structure will be
// consistent.
//
// Note: ABSL_FLAG.OnUpdate() does not have a public definition. Hence, this
// comment serves as its API documentation.

// -----------------------------------------------------------------------------
// Implementation details below this section
// -----------------------------------------------------------------------------

// ABSL_FLAG_IMPL macro definition conditional on ABSL_FLAGS_STRIP_NAMES
#define ABSL_FLAG_IMPL_FLAG_PTR(flag) flag
#define ABSL_FLAG_IMPL_HELP_ARG(name)                      \
  absl::flags_internal::HelpArg<AbslFlagHelpGenFor##name>( \
      FLAGS_help_storage_##name)
#define ABSL_FLAG_IMPL_DEFAULT_ARG(Type, name) \
  absl::flags_internal::DefaultArg<Type, AbslFlagDefaultGenFor##name>(0)

#if ABSL_FLAGS_STRIP_NAMES
#define ABSL_FLAG_IMPL_FLAGNAME(txt) ""
#define ABSL_FLAG_IMPL_FILENAME() ""
#define ABSL_FLAG_IMPL_REGISTRAR(T, flag)                                      \
  absl::flags_internal::FlagRegistrar<T, false>(ABSL_FLAG_IMPL_FLAG_PTR(flag), \
                                                nullptr)
#else
#define ABSL_FLAG_IMPL_FLAGNAME(txt) txt
#define ABSL_FLAG_IMPL_FILENAME() __FILE__
#define ABSL_FLAG_IMPL_REGISTRAR(T, flag)                                     \
  absl::flags_internal::FlagRegistrar<T, true>(ABSL_FLAG_IMPL_FLAG_PTR(flag), \
                                               __FILE__)
#endif

// ABSL_FLAG_IMPL macro definition conditional on ABSL_FLAGS_STRIP_HELP

#if ABSL_FLAGS_STRIP_HELP
#define ABSL_FLAG_IMPL_FLAGHELP(txt) absl::flags_internal::kStrippedFlagHelp
#else
#define ABSL_FLAG_IMPL_FLAGHELP(txt) txt
#endif

// AbslFlagHelpGenFor##name is used to encapsulate both immediate (method Const)
// and lazy (method NonConst) evaluation of help message expression. We choose
// between the two via the call to HelpArg in absl::Flag instantiation below.
// If help message expression is constexpr evaluable compiler will optimize
// away this whole struct.
// TODO(rogeeff): place these generated structs into local namespace and apply
// ABSL_INTERNAL_UNIQUE_SHORT_NAME.
// TODO(rogeeff): Apply __attribute__((nodebug)) to FLAGS_help_storage_##name
#define ABSL_FLAG_IMPL_DECLARE_HELP_WRAPPER(name, txt)                       \
  struct AbslFlagHelpGenFor##name {                                          \
    /* The expression is run in the caller as part of the   */               \
    /* default value argument. That keeps temporaries alive */               \
    /* long enough for NonConst to work correctly.          */               \
    static constexpr absl::string_view Value(                                \
        absl::string_view absl_flag_help = ABSL_FLAG_IMPL_FLAGHELP(txt)) {   \
      return absl_flag_help;                                                 \
    }                                                                        \
    static std::string NonConst() { return std::string(Value()); }           \
  };                                                                         \
  constexpr auto FLAGS_help_storage_##name ABSL_INTERNAL_UNIQUE_SMALL_NAME() \
      ABSL_ATTRIBUTE_SECTION_VARIABLE(flags_help_cold) =                     \
          absl::flags_internal::HelpStringAsArray<AbslFlagHelpGenFor##name>( \
              0);

#define ABSL_FLAG_IMPL_DECLARE_DEF_VAL_WRAPPER(name, Type, default_value)     \
  struct AbslFlagDefaultGenFor##name {                                        \
    Type value = absl::flags_internal::InitDefaultValue<Type>(default_value); \
    static void Gen(void* absl_flag_default_loc) {                            \
      new (absl_flag_default_loc) Type(AbslFlagDefaultGenFor##name{}.value);  \
    }                                                                         \
  };

// ABSL_FLAG_IMPL
//
// Note: Name of registrar object is not arbitrary. It is used to "grab"
// global name for FLAGS_no<flag_name> symbol, thus preventing the possibility
// of defining two flags with names foo and nofoo.
#define ABSL_FLAG_IMPL(Type, name, default_value, help)                       \
  extern ::absl::Flag<Type> FLAGS_##name;                                     \
  namespace absl /* block flags in namespaces */ {}                           \
  ABSL_FLAG_IMPL_DECLARE_DEF_VAL_WRAPPER(name, Type, default_value)           \
  ABSL_FLAG_IMPL_DECLARE_HELP_WRAPPER(name, help)                             \
  ABSL_CONST_INIT absl::Flag<Type> FLAGS_##name{                              \
      ABSL_FLAG_IMPL_FLAGNAME(#name), ABSL_FLAG_IMPL_FILENAME(),              \
      ABSL_FLAG_IMPL_HELP_ARG(name), ABSL_FLAG_IMPL_DEFAULT_ARG(Type, name)}; \
  extern absl::flags_internal::FlagRegistrarEmpty FLAGS_no##name;             \
  absl::flags_internal::FlagRegistrarEmpty FLAGS_no##name =                   \
      ABSL_FLAG_IMPL_REGISTRAR(Type, FLAGS_##name)

// ABSL_RETIRED_FLAG
//
// Designates the flag (which is usually pre-existing) as "retired." A retired
// flag is a flag that is now unused by the program, but may still be passed on
// the command line, usually by production scripts. A retired flag is ignored
// and code can't access it at runtime.
//
// This macro registers a retired flag with given name and type, with a name
// identical to the name of the original flag you are retiring. The retired
// flag's type can change over time, so that you can retire code to support a
// custom flag type.
//
// This macro has the same signature as `ABSL_FLAG`. To retire a flag, simply
// replace an `ABSL_FLAG` definition with `ABSL_RETIRED_FLAG`, leaving the
// arguments unchanged (unless of course you actually want to retire the flag
// type at this time as well).
//
// `default_value` is only used as a double check on the type. `explanation` is
// unused.
// TODO(rogeeff): replace RETIRED_FLAGS with FLAGS once forward declarations of
// retired flags are cleaned up.
#define ABSL_RETIRED_FLAG(type, name, default_value, explanation)      \
  static absl::flags_internal::RetiredFlag<type> RETIRED_FLAGS_##name; \
  ABSL_ATTRIBUTE_UNUSED static const auto RETIRED_FLAGS_REG_##name =   \
      (RETIRED_FLAGS_##name.Retire(#name),                             \
       ::absl::flags_internal::FlagRegistrarEmpty{})

#endif  // ABSL_FLAGS_FLAG_H_
                                                                                                                                         node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/flag_benchmark.cc                             0000664 0000000 0000000 00000021137 14746647661 0025670 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
// Copyright 2020 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <stdint.h>

#include <string>
#include <vector>

#include "absl/flags/flag.h"
#include "absl/flags/marshalling.h"
#include "absl/flags/parse.h"
#include "absl/flags/reflection.h"
#include "absl/strings/string_view.h"
#include "absl/time/time.h"
#include "absl/types/optional.h"
#include "benchmark/benchmark.h"

namespace {
using String = std::string;
using VectorOfStrings = std::vector<std::string>;
using AbslDuration = absl::Duration;

// We do not want to take over marshalling for the types absl::optional<int>,
// absl::optional<std::string> which we do not own. Instead we introduce unique
// "aliases" to these types, which we do.
using AbslOptionalInt = absl::optional<int>;
struct OptionalInt : AbslOptionalInt {
  using AbslOptionalInt::AbslOptionalInt;
};
// Next two functions represent Abseil Flags marshalling for OptionalInt.
bool AbslParseFlag(absl::string_view src, OptionalInt* flag,
                   std::string* error) {
  int val;
  if (src.empty())
    flag->reset();
  else if (!absl::ParseFlag(src, &val, error))
    return false;
  *flag = val;
  return true;
}
std::string AbslUnparseFlag(const OptionalInt& flag) {
  return !flag ? "" : absl::UnparseFlag(*flag);
}

using AbslOptionalString = absl::optional<std::string>;
struct OptionalString : AbslOptionalString {
  using AbslOptionalString::AbslOptionalString;
};
// Next two functions represent Abseil Flags marshalling for OptionalString.
bool AbslParseFlag(absl::string_view src, OptionalString* flag,
                   std::string* error) {
  std::string val;
  if (src.empty())
    flag->reset();
  else if (!absl::ParseFlag(src, &val, error))
    return false;
  *flag = val;
  return true;
}
std::string AbslUnparseFlag(const OptionalString& flag) {
  return !flag ? "" : absl::UnparseFlag(*flag);
}

struct UDT {
  UDT() = default;
  UDT(const UDT&) {}
  UDT& operator=(const UDT&) { return *this; }
};
// Next two functions represent Abseil Flags marshalling for UDT.
bool AbslParseFlag(absl::string_view, UDT*, std::string*) { return true; }
std::string AbslUnparseFlag(const UDT&) { return ""; }

}  // namespace

#define BENCHMARKED_TYPES(A) \
  A(bool)                    \
  A(int16_t)                 \
  A(uint16_t)                \
  A(int32_t)                 \
  A(uint32_t)                \
  A(int64_t)                 \
  A(uint64_t)                \
  A(double)                  \
  A(float)                   \
  A(String)                  \
  A(VectorOfStrings)         \
  A(OptionalInt)             \
  A(OptionalString)          \
  A(AbslDuration)            \
  A(UDT)

#define REPLICATE_0(A, T, name, index) A(T, name, index)
#define REPLICATE_1(A, T, name, index) \
  REPLICATE_0(A, T, name, index##0) REPLICATE_0(A, T, name, index##1)
#define REPLICATE_2(A, T, name, index) \
  REPLICATE_1(A, T, name, index##0) REPLICATE_1(A, T, name, index##1)
#define REPLICATE_3(A, T, name, index) \
  REPLICATE_2(A, T, name, index##0) REPLICATE_2(A, T, name, index##1)
#define REPLICATE_4(A, T, name, index) \
  REPLICATE_3(A, T, name, index##0) REPLICATE_3(A, T, name, index##1)
#define REPLICATE_5(A, T, name, index) \
  REPLICATE_4(A, T, name, index##0) REPLICATE_4(A, T, name, index##1)
#define REPLICATE_6(A, T, name, index) \
  REPLICATE_5(A, T, name, index##0) REPLICATE_5(A, T, name, index##1)
#define REPLICATE_7(A, T, name, index) \
  REPLICATE_6(A, T, name, index##0) REPLICATE_6(A, T, name, index##1)
#define REPLICATE_8(A, T, name, index) \
  REPLICATE_7(A, T, name, index##0) REPLICATE_7(A, T, name, index##1)
#define REPLICATE_9(A, T, name, index) \
  REPLICATE_8(A, T, name, index##0) REPLICATE_8(A, T, name, index##1)
#if defined(_MSC_VER)
#define REPLICATE(A, T, name) \
  REPLICATE_7(A, T, name, 0) REPLICATE_7(A, T, name, 1)
#define SINGLE_FLAG(T) FLAGS_##T##_flag_00000000
#else
#define REPLICATE(A, T, name) \
  REPLICATE_9(A, T, name, 0) REPLICATE_9(A, T, name, 1)
#define SINGLE_FLAG(T) FLAGS_##T##_flag_0000000000
#endif
#define REPLICATE_ALL(A, T, name) \
  REPLICATE_9(A, T, name, 0) REPLICATE_9(A, T, name, 1)

#define COUNT(T, name, index) +1
constexpr size_t kNumFlags = 0 REPLICATE(COUNT, _, _);

#if defined(__clang__) && defined(__linux__)
// Force the flags used for benchmarks into a separate ELF section.
// This ensures that, even when other parts of the code might change size,
// the layout of the flags across cachelines is kept constant. This makes
// benchmark results more reproducible across unrelated code changes.
#pragma clang section data = ".benchmark_flags"
#endif
#define DEFINE_FLAG(T, name, index) ABSL_FLAG(T, name##_##index, {}, "");
#define FLAG_DEF(T) REPLICATE(DEFINE_FLAG, T, T##_flag)
BENCHMARKED_TYPES(FLAG_DEF)
#if defined(__clang__) && defined(__linux__)
#pragma clang section data = ""
#endif
// Register thousands of flags to bloat up the size of the registry.
// This mimics real life production binaries.
#define BLOAT_FLAG(_unused1, _unused2, index) \
  ABSL_FLAG(int, bloat_flag_##index, 0, "");
REPLICATE_ALL(BLOAT_FLAG, _, _)

namespace {

#define FLAG_PTR(T, name, index) &FLAGS_##name##_##index,
#define FLAG_PTR_ARR(T)                              \
  static constexpr absl::Flag<T>* FlagPtrs_##T[] = { \
      REPLICATE(FLAG_PTR, T, T##_flag)};
BENCHMARKED_TYPES(FLAG_PTR_ARR)

#define BM_SingleGetFlag(T)                                    \
  void BM_SingleGetFlag_##T(benchmark::State& state) {         \
    for (auto _ : state) {                                     \
      benchmark::DoNotOptimize(absl::GetFlag(SINGLE_FLAG(T))); \
    }                                                          \
  }                                                            \
  BENCHMARK(BM_SingleGetFlag_##T)->ThreadRange(1, 16);

BENCHMARKED_TYPES(BM_SingleGetFlag)

template <typename T>
struct Accumulator {
  using type = T;
};
template <>
struct Accumulator<String> {
  using type = size_t;
};
template <>
struct Accumulator<VectorOfStrings> {
  using type = size_t;
};
template <>
struct Accumulator<OptionalInt> {
  using type = bool;
};
template <>
struct Accumulator<OptionalString> {
  using type = bool;
};
template <>
struct Accumulator<UDT> {
  using type = bool;
};

template <typename T>
void Accumulate(typename Accumulator<T>::type& a, const T& f) {
  a += f;
}
void Accumulate(bool& a, bool f) { a = a || f; }
void Accumulate(size_t& a, const std::string& f) { a += f.size(); }
void Accumulate(size_t& a, const std::vector<std::string>& f) { a += f.size(); }
void Accumulate(bool& a, const OptionalInt& f) { a |= f.has_value(); }
void Accumulate(bool& a, const OptionalString& f) { a |= f.has_value(); }
void Accumulate(bool& a, const UDT& f) {
  a |= reinterpret_cast<int64_t>(&f) & 0x1;
}

#define BM_ManyGetFlag(T)                            \
  void BM_ManyGetFlag_##T(benchmark::State& state) { \
    Accumulator<T>::type res = {};                   \
    while (state.KeepRunningBatch(kNumFlags)) {      \
      for (auto* flag_ptr : FlagPtrs_##T) {          \
        Accumulate(res, absl::GetFlag(*flag_ptr));   \
      }                                              \
    }                                                \
    benchmark::DoNotOptimize(res);                   \
  }                                                  \
  BENCHMARK(BM_ManyGetFlag_##T)->ThreadRange(1, 8);

BENCHMARKED_TYPES(BM_ManyGetFlag)

void BM_ThreadedFindCommandLineFlag(benchmark::State& state) {
  char dummy[] = "dummy";
  char* argv[] = {dummy};
  // We need to ensure that flags have been parsed. That is where the registry
  // is finalized.
  absl::ParseCommandLine(1, argv);

  while (state.KeepRunningBatch(kNumFlags)) {
    for (auto* flag_ptr : FlagPtrs_bool) {
      benchmark::DoNotOptimize(absl::FindCommandLineFlag(flag_ptr->Name()));
    }
  }
}
BENCHMARK(BM_ThreadedFindCommandLineFlag)->ThreadRange(1, 16);

}  // namespace

#ifdef __llvm__
// To view disassembly use: gdb ${BINARY}  -batch -ex "disassemble /s $FUNC"
#define InvokeGetFlag(T)                                             \
  T AbslInvokeGetFlag##T() { return absl::GetFlag(SINGLE_FLAG(T)); } \
  int odr##T = (benchmark::DoNotOptimize(AbslInvokeGetFlag##T), 1);

BENCHMARKED_TYPES(InvokeGetFlag)
#endif  // __llvm__
                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/flag_benchmark.lds                            0000664 0000000 0000000 00000000540 14746647661 0026060 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* This linker script forces the flags used by flags_benchmark
 * into a separate page-aligned section. This isn't necessary for
 * correctness but ensures that the benchmark results are more
 * reproducible across unrelated code changes.
 */
SECTIONS {
  .benchmark_flags : {
    . = ALIGN(0x1000);
    * (.benchmark_flags);
  }
}

INSERT AFTER .data
                                                                                                                                                                node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/flag_test.cc                                  0000664 0000000 0000000 00000142077 14746647661 0024724 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
//  Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/flags/flag.h"

#include <stddef.h>
#include <stdint.h>

#include <atomic>
#include <string>
#include <thread>  // NOLINT
#include <vector>

#include "gtest/gtest.h"
#include "absl/base/attributes.h"
#include "absl/base/internal/raw_logging.h"
#include "absl/base/macros.h"
#include "absl/flags/config.h"
#include "absl/flags/declare.h"
#include "absl/flags/internal/flag.h"
#include "absl/flags/marshalling.h"
#include "absl/flags/parse.h"
#include "absl/flags/reflection.h"
#include "absl/flags/usage_config.h"
#include "absl/numeric/int128.h"
#include "absl/strings/match.h"
#include "absl/strings/numbers.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/str_split.h"
#include "absl/strings/string_view.h"
#include "absl/time/clock.h"
#include "absl/time/time.h"
#include "absl/types/optional.h"

ABSL_DECLARE_FLAG(int64_t, mistyped_int_flag);
ABSL_DECLARE_FLAG(std::vector<std::string>, mistyped_string_flag);

namespace {

namespace flags = absl::flags_internal;

std::string TestHelpMsg() { return "dynamic help"; }
#if defined(_MSC_VER) && !defined(__clang__)
std::string TestLiteralHelpMsg() { return "literal help"; }
#endif
template <typename T>
void TestMakeDflt(void* dst) {
  new (dst) T{};
}
void TestCallback() {}

struct UDT {
  UDT() = default;
  UDT(const UDT&) = default;
  UDT& operator=(const UDT&) = default;
};
bool AbslParseFlag(absl::string_view, UDT*, std::string*) { return true; }
std::string AbslUnparseFlag(const UDT&) { return ""; }

class FlagTest : public testing::Test {
 protected:
  static void SetUpTestSuite() {
    // Install a function to normalize filenames before this test is run.
    absl::FlagsUsageConfig default_config;
    default_config.normalize_filename = &FlagTest::NormalizeFileName;
    absl::SetFlagsUsageConfig(default_config);
  }

 private:
  static std::string NormalizeFileName(absl::string_view fname) {
#ifdef _WIN32
    std::string normalized(fname);
    std::replace(normalized.begin(), normalized.end(), '\\', '/');
    fname = normalized;
#endif
    return std::string(fname);
  }
  absl::FlagSaver flag_saver_;
};

struct S1 {
  S1() = default;
  S1(const S1&) = default;
  int32_t f1;
  int64_t f2;
};

struct S2 {
  S2() = default;
  S2(const S2&) = default;
  int64_t f1;
  double f2;
};

TEST_F(FlagTest, Traits) {
  EXPECT_EQ(flags::StorageKind<int>(),
            flags::FlagValueStorageKind::kValueAndInitBit);
  EXPECT_EQ(flags::StorageKind<bool>(),
            flags::FlagValueStorageKind::kValueAndInitBit);
  EXPECT_EQ(flags::StorageKind<double>(),
            flags::FlagValueStorageKind::kOneWordAtomic);
  EXPECT_EQ(flags::StorageKind<int64_t>(),
            flags::FlagValueStorageKind::kOneWordAtomic);

  EXPECT_EQ(flags::StorageKind<S1>(),
            flags::FlagValueStorageKind::kSequenceLocked);
  EXPECT_EQ(flags::StorageKind<S2>(),
            flags::FlagValueStorageKind::kSequenceLocked);
// Make sure absl::Duration uses the sequence-locked code path. MSVC 2015
// doesn't consider absl::Duration to be trivially-copyable so we just
// restrict this to clang as it seems to be a well-behaved compiler.
#ifdef __clang__
  EXPECT_EQ(flags::StorageKind<absl::Duration>(),
            flags::FlagValueStorageKind::kSequenceLocked);
#endif

  EXPECT_EQ(flags::StorageKind<std::string>(),
            flags::FlagValueStorageKind::kHeapAllocated);
  EXPECT_EQ(flags::StorageKind<std::vector<std::string>>(),
            flags::FlagValueStorageKind::kHeapAllocated);

  EXPECT_EQ(flags::StorageKind<absl::int128>(),
            flags::FlagValueStorageKind::kSequenceLocked);
  EXPECT_EQ(flags::StorageKind<absl::uint128>(),
            flags::FlagValueStorageKind::kSequenceLocked);
}

// --------------------------------------------------------------------

constexpr flags::FlagHelpArg help_arg{flags::FlagHelpMsg("literal help"),
                                      flags::FlagHelpKind::kLiteral};

using String = std::string;
using int128 = absl::int128;
using uint128 = absl::uint128;

#define DEFINE_CONSTRUCTED_FLAG(T, dflt, dflt_kind)                        \
  constexpr flags::FlagDefaultArg f1default##T{                            \
      flags::FlagDefaultSrc{dflt}, flags::FlagDefaultKind::dflt_kind};     \
  constexpr absl::Flag<T> f1##T{"f1", "file", help_arg, f1default##T};     \
  ABSL_CONST_INIT absl::Flag<T> f2##T {                                    \
    "f2", "file",                                                          \
        {flags::FlagHelpMsg(&TestHelpMsg), flags::FlagHelpKind::kGenFunc}, \
        flags::FlagDefaultArg {                                            \
      flags::FlagDefaultSrc(&TestMakeDflt<T>),                             \
          flags::FlagDefaultKind::kGenFunc                                 \
    }                                                                      \
  }

DEFINE_CONSTRUCTED_FLAG(bool, true, kOneWord);
DEFINE_CONSTRUCTED_FLAG(int16_t, 1, kOneWord);
DEFINE_CONSTRUCTED_FLAG(uint16_t, 2, kOneWord);
DEFINE_CONSTRUCTED_FLAG(int32_t, 3, kOneWord);
DEFINE_CONSTRUCTED_FLAG(uint32_t, 4, kOneWord);
DEFINE_CONSTRUCTED_FLAG(int64_t, 5, kOneWord);
DEFINE_CONSTRUCTED_FLAG(uint64_t, 6, kOneWord);
DEFINE_CONSTRUCTED_FLAG(float, 7.8, kOneWord);
DEFINE_CONSTRUCTED_FLAG(double, 9.10, kOneWord);
DEFINE_CONSTRUCTED_FLAG(String, &TestMakeDflt<String>, kGenFunc);
DEFINE_CONSTRUCTED_FLAG(UDT, &TestMakeDflt<UDT>, kGenFunc);
DEFINE_CONSTRUCTED_FLAG(int128, 13, kGenFunc);
DEFINE_CONSTRUCTED_FLAG(uint128, 14, kGenFunc);

template <typename T>
bool TestConstructionFor(const absl::Flag<T>& f1, absl::Flag<T>& f2) {
  EXPECT_EQ(absl::GetFlagReflectionHandle(f1).Name(), "f1");
  EXPECT_EQ(absl::GetFlagReflectionHandle(f1).Help(), "literal help");
  EXPECT_EQ(absl::GetFlagReflectionHandle(f1).Filename(), "file");

  flags::FlagRegistrar<T, false>(ABSL_FLAG_IMPL_FLAG_PTR(f2), nullptr)
      .OnUpdate(TestCallback);

  EXPECT_EQ(absl::GetFlagReflectionHandle(f2).Name(), "f2");
  EXPECT_EQ(absl::GetFlagReflectionHandle(f2).Help(), "dynamic help");
  EXPECT_EQ(absl::GetFlagReflectionHandle(f2).Filename(), "file");

  return true;
}

#define TEST_CONSTRUCTED_FLAG(T) TestConstructionFor(f1##T, f2##T);

TEST_F(FlagTest, TestConstruction) {
  TEST_CONSTRUCTED_FLAG(bool);
  TEST_CONSTRUCTED_FLAG(int16_t);
  TEST_CONSTRUCTED_FLAG(uint16_t);
  TEST_CONSTRUCTED_FLAG(int32_t);
  TEST_CONSTRUCTED_FLAG(uint32_t);
  TEST_CONSTRUCTED_FLAG(int64_t);
  TEST_CONSTRUCTED_FLAG(uint64_t);
  TEST_CONSTRUCTED_FLAG(float);
  TEST_CONSTRUCTED_FLAG(double);
  TEST_CONSTRUCTED_FLAG(String);
  TEST_CONSTRUCTED_FLAG(UDT);
  TEST_CONSTRUCTED_FLAG(int128);
  TEST_CONSTRUCTED_FLAG(uint128);
}

// --------------------------------------------------------------------

}  // namespace

ABSL_DECLARE_FLAG(bool, test_flag_01);
ABSL_DECLARE_FLAG(int, test_flag_02);
ABSL_DECLARE_FLAG(int16_t, test_flag_03);
ABSL_DECLARE_FLAG(uint16_t, test_flag_04);
ABSL_DECLARE_FLAG(int32_t, test_flag_05);
ABSL_DECLARE_FLAG(uint32_t, test_flag_06);
ABSL_DECLARE_FLAG(int64_t, test_flag_07);
ABSL_DECLARE_FLAG(uint64_t, test_flag_08);
ABSL_DECLARE_FLAG(double, test_flag_09);
ABSL_DECLARE_FLAG(float, test_flag_10);
ABSL_DECLARE_FLAG(std::string, test_flag_11);
ABSL_DECLARE_FLAG(absl::Duration, test_flag_12);
ABSL_DECLARE_FLAG(absl::int128, test_flag_13);
ABSL_DECLARE_FLAG(absl::uint128, test_flag_14);

namespace {

TEST_F(FlagTest, TestFlagDeclaration) {
#if ABSL_FLAGS_STRIP_NAMES
  GTEST_SKIP() << "This test requires flag names to be present";
#endif
  // test that we can access flag objects.
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_01).Name(),
            "test_flag_01");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_02).Name(),
            "test_flag_02");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_03).Name(),
            "test_flag_03");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_04).Name(),
            "test_flag_04");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_05).Name(),
            "test_flag_05");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_06).Name(),
            "test_flag_06");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_07).Name(),
            "test_flag_07");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_08).Name(),
            "test_flag_08");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_09).Name(),
            "test_flag_09");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_10).Name(),
            "test_flag_10");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_11).Name(),
            "test_flag_11");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_12).Name(),
            "test_flag_12");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_13).Name(),
            "test_flag_13");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_14).Name(),
            "test_flag_14");
}

}  // namespace

#if ABSL_FLAGS_STRIP_NAMES
// The intent of this helper struct and an expression below is to make sure that
// in the configuration where ABSL_FLAGS_STRIP_NAMES=1 registrar construction
// (in cases of no Tail calls like OnUpdate) is constexpr and thus can and
// should be completely optimized away, thus avoiding the cost/overhead of
// static initializers.
struct VerifyConsteval {
  friend consteval flags::FlagRegistrarEmpty operator+(
      flags::FlagRegistrarEmpty, VerifyConsteval) {
    return {};
  }
};

ABSL_FLAG(int, test_registrar_const_init, 0, "") + VerifyConsteval();
#endif

// --------------------------------------------------------------------

ABSL_FLAG(bool, test_flag_01, true, "test flag 01");
ABSL_FLAG(int, test_flag_02, 1234, "test flag 02");
ABSL_FLAG(int16_t, test_flag_03, -34, "test flag 03");
ABSL_FLAG(uint16_t, test_flag_04, 189, "test flag 04");
ABSL_FLAG(int32_t, test_flag_05, 10765, "test flag 05");
ABSL_FLAG(uint32_t, test_flag_06, 40000, "test flag 06");
ABSL_FLAG(int64_t, test_flag_07, -1234567, "test flag 07");
ABSL_FLAG(uint64_t, test_flag_08, 9876543, "test flag 08");
ABSL_FLAG(double, test_flag_09, -9.876e-50, "test flag 09");
ABSL_FLAG(float, test_flag_10, 1.234e12f, "test flag 10");
ABSL_FLAG(std::string, test_flag_11, "", "test flag 11");
ABSL_FLAG(absl::Duration, test_flag_12, absl::Minutes(10), "test flag 12");
ABSL_FLAG(absl::int128, test_flag_13, absl::MakeInt128(-1, 0), "test flag 13");
ABSL_FLAG(absl::uint128, test_flag_14, absl::MakeUint128(0, 0xFFFAAABBBCCCDDD),
          "test flag 14");

namespace {

TEST_F(FlagTest, TestFlagDefinition) {
#if ABSL_FLAGS_STRIP_NAMES
  GTEST_SKIP() << "This test requires flag names to be present";
#endif
  absl::string_view expected_file_name = "absl/flags/flag_test.cc";

  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_01).Name(),
            "test_flag_01");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_01).Help(),
            "test flag 01");
  EXPECT_TRUE(absl::EndsWith(
      absl::GetFlagReflectionHandle(FLAGS_test_flag_01).Filename(),
      expected_file_name))
      << absl::GetFlagReflectionHandle(FLAGS_test_flag_01).Filename();

  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_02).Name(),
            "test_flag_02");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_02).Help(),
            "test flag 02");
  EXPECT_TRUE(absl::EndsWith(
      absl::GetFlagReflectionHandle(FLAGS_test_flag_02).Filename(),
      expected_file_name))
      << absl::GetFlagReflectionHandle(FLAGS_test_flag_02).Filename();

  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_03).Name(),
            "test_flag_03");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_03).Help(),
            "test flag 03");
  EXPECT_TRUE(absl::EndsWith(
      absl::GetFlagReflectionHandle(FLAGS_test_flag_03).Filename(),
      expected_file_name))
      << absl::GetFlagReflectionHandle(FLAGS_test_flag_03).Filename();

  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_04).Name(),
            "test_flag_04");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_04).Help(),
            "test flag 04");
  EXPECT_TRUE(absl::EndsWith(
      absl::GetFlagReflectionHandle(FLAGS_test_flag_04).Filename(),
      expected_file_name))
      << absl::GetFlagReflectionHandle(FLAGS_test_flag_04).Filename();

  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_05).Name(),
            "test_flag_05");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_05).Help(),
            "test flag 05");
  EXPECT_TRUE(absl::EndsWith(
      absl::GetFlagReflectionHandle(FLAGS_test_flag_05).Filename(),
      expected_file_name))
      << absl::GetFlagReflectionHandle(FLAGS_test_flag_05).Filename();

  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_06).Name(),
            "test_flag_06");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_06).Help(),
            "test flag 06");
  EXPECT_TRUE(absl::EndsWith(
      absl::GetFlagReflectionHandle(FLAGS_test_flag_06).Filename(),
      expected_file_name))
      << absl::GetFlagReflectionHandle(FLAGS_test_flag_06).Filename();

  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_07).Name(),
            "test_flag_07");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_07).Help(),
            "test flag 07");
  EXPECT_TRUE(absl::EndsWith(
      absl::GetFlagReflectionHandle(FLAGS_test_flag_07).Filename(),
      expected_file_name))
      << absl::GetFlagReflectionHandle(FLAGS_test_flag_07).Filename();

  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_08).Name(),
            "test_flag_08");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_08).Help(),
            "test flag 08");
  EXPECT_TRUE(absl::EndsWith(
      absl::GetFlagReflectionHandle(FLAGS_test_flag_08).Filename(),
      expected_file_name))
      << absl::GetFlagReflectionHandle(FLAGS_test_flag_08).Filename();

  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_09).Name(),
            "test_flag_09");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_09).Help(),
            "test flag 09");
  EXPECT_TRUE(absl::EndsWith(
      absl::GetFlagReflectionHandle(FLAGS_test_flag_09).Filename(),
      expected_file_name))
      << absl::GetFlagReflectionHandle(FLAGS_test_flag_09).Filename();

  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_10).Name(),
            "test_flag_10");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_10).Help(),
            "test flag 10");
  EXPECT_TRUE(absl::EndsWith(
      absl::GetFlagReflectionHandle(FLAGS_test_flag_10).Filename(),
      expected_file_name))
      << absl::GetFlagReflectionHandle(FLAGS_test_flag_10).Filename();

  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_11).Name(),
            "test_flag_11");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_11).Help(),
            "test flag 11");
  EXPECT_TRUE(absl::EndsWith(
      absl::GetFlagReflectionHandle(FLAGS_test_flag_11).Filename(),
      expected_file_name))
      << absl::GetFlagReflectionHandle(FLAGS_test_flag_11).Filename();

  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_12).Name(),
            "test_flag_12");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_12).Help(),
            "test flag 12");
  EXPECT_TRUE(absl::EndsWith(
      absl::GetFlagReflectionHandle(FLAGS_test_flag_12).Filename(),
      expected_file_name))
      << absl::GetFlagReflectionHandle(FLAGS_test_flag_12).Filename();

  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_13).Name(),
            "test_flag_13");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_13).Help(),
            "test flag 13");
  EXPECT_TRUE(absl::EndsWith(
      absl::GetFlagReflectionHandle(FLAGS_test_flag_13).Filename(),
      expected_file_name))
      << absl::GetFlagReflectionHandle(FLAGS_test_flag_13).Filename();

  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_14).Name(),
            "test_flag_14");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_14).Help(),
            "test flag 14");
  EXPECT_TRUE(absl::EndsWith(
      absl::GetFlagReflectionHandle(FLAGS_test_flag_14).Filename(),
      expected_file_name))
      << absl::GetFlagReflectionHandle(FLAGS_test_flag_14).Filename();
}

// --------------------------------------------------------------------

TEST_F(FlagTest, TestDefault) {
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_01).DefaultValue(),
            "true");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_02).DefaultValue(),
            "1234");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_03).DefaultValue(),
            "-34");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_04).DefaultValue(),
            "189");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_05).DefaultValue(),
            "10765");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_06).DefaultValue(),
            "40000");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_07).DefaultValue(),
            "-1234567");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_08).DefaultValue(),
            "9876543");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_09).DefaultValue(),
            "-9.876e-50");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_10).DefaultValue(),
            "1.234e+12");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_11).DefaultValue(),
            "");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_12).DefaultValue(),
            "10m");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_13).DefaultValue(),
            "-18446744073709551616");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_14).DefaultValue(),
            "1152827684197027293");

  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_01).CurrentValue(),
            "true");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_02).CurrentValue(),
            "1234");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_03).CurrentValue(),
            "-34");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_04).CurrentValue(),
            "189");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_05).CurrentValue(),
            "10765");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_06).CurrentValue(),
            "40000");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_07).CurrentValue(),
            "-1234567");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_08).CurrentValue(),
            "9876543");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_09).CurrentValue(),
            "-9.876e-50");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_10).CurrentValue(),
            "1.234e+12");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_11).CurrentValue(),
            "");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_12).CurrentValue(),
            "10m");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_13).CurrentValue(),
            "-18446744073709551616");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_14).CurrentValue(),
            "1152827684197027293");

  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_01), true);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_02), 1234);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_03), -34);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_04), 189);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_05), 10765);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_06), 40000);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_07), -1234567);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 9876543);
  EXPECT_NEAR(absl::GetFlag(FLAGS_test_flag_09), -9.876e-50, 1e-55);
  EXPECT_NEAR(absl::GetFlag(FLAGS_test_flag_10), 1.234e12f, 1e5f);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_11), "");
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_12), absl::Minutes(10));
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_13), absl::MakeInt128(-1, 0));
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_14),
            absl::MakeUint128(0, 0xFFFAAABBBCCCDDD));
}

// --------------------------------------------------------------------

struct NonTriviallyCopyableAggregate {
  NonTriviallyCopyableAggregate() = default;
  // NOLINTNEXTLINE
  NonTriviallyCopyableAggregate(const NonTriviallyCopyableAggregate& rhs)
      : value(rhs.value) {}
  // NOLINTNEXTLINE
  NonTriviallyCopyableAggregate& operator=(
      const NonTriviallyCopyableAggregate& rhs) {
    value = rhs.value;
    return *this;
  }

  int value;
};
bool AbslParseFlag(absl::string_view src, NonTriviallyCopyableAggregate* f,
                   std::string* e) {
  return absl::ParseFlag(src, &f->value, e);
}
std::string AbslUnparseFlag(const NonTriviallyCopyableAggregate& ntc) {
  return absl::StrCat(ntc.value);
}

bool operator==(const NonTriviallyCopyableAggregate& ntc1,
                const NonTriviallyCopyableAggregate& ntc2) {
  return ntc1.value == ntc2.value;
}

}  // namespace

ABSL_FLAG(bool, test_flag_eb_01, {}, "");
ABSL_FLAG(int32_t, test_flag_eb_02, {}, "");
ABSL_FLAG(int64_t, test_flag_eb_03, {}, "");
ABSL_FLAG(double, test_flag_eb_04, {}, "");
ABSL_FLAG(std::string, test_flag_eb_05, {}, "");
ABSL_FLAG(NonTriviallyCopyableAggregate, test_flag_eb_06, {}, "");

namespace {

TEST_F(FlagTest, TestEmptyBracesDefault) {
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_eb_01).DefaultValue(),
            "false");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_eb_02).DefaultValue(),
            "0");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_eb_03).DefaultValue(),
            "0");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_eb_04).DefaultValue(),
            "0");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_eb_05).DefaultValue(),
            "");
  EXPECT_EQ(absl::GetFlagReflectionHandle(FLAGS_test_flag_eb_06).DefaultValue(),
            "0");

  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_eb_01), false);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_eb_02), 0);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_eb_03), 0);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_eb_04), 0.0);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_eb_05), "");
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_eb_06),
            NonTriviallyCopyableAggregate{});
}

// --------------------------------------------------------------------

TEST_F(FlagTest, TestGetSet) {
  absl::SetFlag(&FLAGS_test_flag_01, false);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_01), false);

  absl::SetFlag(&FLAGS_test_flag_02, 321);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_02), 321);

  absl::SetFlag(&FLAGS_test_flag_03, 67);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_03), 67);

  absl::SetFlag(&FLAGS_test_flag_04, 1);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_04), 1);

  absl::SetFlag(&FLAGS_test_flag_05, -908);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_05), -908);

  absl::SetFlag(&FLAGS_test_flag_06, 4001);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_06), 4001);

  absl::SetFlag(&FLAGS_test_flag_07, -23456);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_07), -23456);

  absl::SetFlag(&FLAGS_test_flag_08, 975310);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 975310);

  absl::SetFlag(&FLAGS_test_flag_09, 1.00001);
  EXPECT_NEAR(absl::GetFlag(FLAGS_test_flag_09), 1.00001, 1e-10);

  absl::SetFlag(&FLAGS_test_flag_10, -3.54f);
  EXPECT_NEAR(absl::GetFlag(FLAGS_test_flag_10), -3.54f, 1e-6f);

  absl::SetFlag(&FLAGS_test_flag_11, "asdf");
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_11), "asdf");

  absl::SetFlag(&FLAGS_test_flag_12, absl::Seconds(110));
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_12), absl::Seconds(110));

  absl::SetFlag(&FLAGS_test_flag_13, absl::MakeInt128(-1, 0));
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_13), absl::MakeInt128(-1, 0));

  absl::SetFlag(&FLAGS_test_flag_14, absl::MakeUint128(0, 0xFFFAAABBBCCCDDD));
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_14),
            absl::MakeUint128(0, 0xFFFAAABBBCCCDDD));
}

// --------------------------------------------------------------------

TEST_F(FlagTest, TestGetViaReflection) {
#if ABSL_FLAGS_STRIP_NAMES
  GTEST_SKIP() << "This test requires flag names to be present";
#endif
  auto* handle = absl::FindCommandLineFlag("test_flag_01");
  EXPECT_EQ(*handle->TryGet<bool>(), true);
  handle = absl::FindCommandLineFlag("test_flag_02");
  EXPECT_EQ(*handle->TryGet<int>(), 1234);
  handle = absl::FindCommandLineFlag("test_flag_03");
  EXPECT_EQ(*handle->TryGet<int16_t>(), -34);
  handle = absl::FindCommandLineFlag("test_flag_04");
  EXPECT_EQ(*handle->TryGet<uint16_t>(), 189);
  handle = absl::FindCommandLineFlag("test_flag_05");
  EXPECT_EQ(*handle->TryGet<int32_t>(), 10765);
  handle = absl::FindCommandLineFlag("test_flag_06");
  EXPECT_EQ(*handle->TryGet<uint32_t>(), 40000);
  handle = absl::FindCommandLineFlag("test_flag_07");
  EXPECT_EQ(*handle->TryGet<int64_t>(), -1234567);
  handle = absl::FindCommandLineFlag("test_flag_08");
  EXPECT_EQ(*handle->TryGet<uint64_t>(), 9876543);
  handle = absl::FindCommandLineFlag("test_flag_09");
  EXPECT_NEAR(*handle->TryGet<double>(), -9.876e-50, 1e-55);
  handle = absl::FindCommandLineFlag("test_flag_10");
  EXPECT_NEAR(*handle->TryGet<float>(), 1.234e12f, 1e5f);
  handle = absl::FindCommandLineFlag("test_flag_11");
  EXPECT_EQ(*handle->TryGet<std::string>(), "");
  handle = absl::FindCommandLineFlag("test_flag_12");
  EXPECT_EQ(*handle->TryGet<absl::Duration>(), absl::Minutes(10));
  handle = absl::FindCommandLineFlag("test_flag_13");
  EXPECT_EQ(*handle->TryGet<absl::int128>(), absl::MakeInt128(-1, 0));
  handle = absl::FindCommandLineFlag("test_flag_14");
  EXPECT_EQ(*handle->TryGet<absl::uint128>(),
            absl::MakeUint128(0, 0xFFFAAABBBCCCDDD));
}

// --------------------------------------------------------------------

TEST_F(FlagTest, ConcurrentSetAndGet) {
#if ABSL_FLAGS_STRIP_NAMES
  GTEST_SKIP() << "This test requires flag names to be present";
#endif
  static constexpr int kNumThreads = 8;
  // Two arbitrary durations. One thread will concurrently flip the flag
  // between these two values, while the other threads read it and verify
  // that no other value is seen.
  static const absl::Duration kValidDurations[] = {
      absl::Seconds(int64_t{0x6cebf47a9b68c802}) + absl::Nanoseconds(229702057),
      absl::Seconds(int64_t{0x23fec0307e4e9d3}) + absl::Nanoseconds(44555374)};
  absl::SetFlag(&FLAGS_test_flag_12, kValidDurations[0]);

  std::atomic<bool> stop{false};
  std::vector<std::thread> threads;
  auto* handle = absl::FindCommandLineFlag("test_flag_12");
  for (int i = 0; i < kNumThreads; i++) {
    threads.emplace_back([&]() {
      while (!stop.load(std::memory_order_relaxed)) {
        // Try loading the flag both directly and via a reflection
        // handle.
        absl::Duration v = absl::GetFlag(FLAGS_test_flag_12);
        EXPECT_TRUE(v == kValidDurations[0] || v == kValidDurations[1]);
        v = *handle->TryGet<absl::Duration>();
        EXPECT_TRUE(v == kValidDurations[0] || v == kValidDurations[1]);
      }
    });
  }
  absl::Time end_time = absl::Now() + absl::Seconds(1);
  int i = 0;
  while (absl::Now() < end_time) {
    absl::SetFlag(&FLAGS_test_flag_12,
                  kValidDurations[i++ % ABSL_ARRAYSIZE(kValidDurations)]);
  }
  stop.store(true, std::memory_order_relaxed);
  for (auto& t : threads) t.join();
}

// --------------------------------------------------------------------

int GetDflt1() { return 1; }

}  // namespace

ABSL_FLAG(int, test_int_flag_with_non_const_default, GetDflt1(),
          "test int flag non const default");
ABSL_FLAG(std::string, test_string_flag_with_non_const_default,
          absl::StrCat("AAA", "BBB"), "test string flag non const default");

namespace {

TEST_F(FlagTest, TestNonConstexprDefault) {
  EXPECT_EQ(absl::GetFlag(FLAGS_test_int_flag_with_non_const_default), 1);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_string_flag_with_non_const_default),
            "AAABBB");
}

// --------------------------------------------------------------------

}  // namespace

ABSL_FLAG(bool, test_flag_with_non_const_help, true,
          absl::StrCat("test ", "flag ", "non const help"));

namespace {

#if !ABSL_FLAGS_STRIP_HELP
TEST_F(FlagTest, TestNonConstexprHelp) {
  EXPECT_EQ(
      absl::GetFlagReflectionHandle(FLAGS_test_flag_with_non_const_help).Help(),
      "test flag non const help");
}
#endif  //! ABSL_FLAGS_STRIP_HELP

// --------------------------------------------------------------------

int cb_test_value = -1;
void TestFlagCB();

}  // namespace

ABSL_FLAG(int, test_flag_with_cb, 100, "").OnUpdate(TestFlagCB);

ABSL_FLAG(int, test_flag_with_lambda_cb, 200, "").OnUpdate([]() {
  cb_test_value = absl::GetFlag(FLAGS_test_flag_with_lambda_cb) +
                  absl::GetFlag(FLAGS_test_flag_with_cb);
});

namespace {

void TestFlagCB() { cb_test_value = absl::GetFlag(FLAGS_test_flag_with_cb); }

// Tests side-effects of callback invocation.
TEST_F(FlagTest, CallbackInvocation) {
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_with_cb), 100);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_with_lambda_cb), 200);
  EXPECT_EQ(cb_test_value, 300);

  absl::SetFlag(&FLAGS_test_flag_with_cb, 1);
  EXPECT_EQ(cb_test_value, 1);

  absl::SetFlag(&FLAGS_test_flag_with_lambda_cb, 3);
  EXPECT_EQ(cb_test_value, 4);
}

// --------------------------------------------------------------------

struct CustomUDT {
  CustomUDT() : a(1), b(1) {}
  CustomUDT(int a_, int b_) : a(a_), b(b_) {}

  friend bool operator==(const CustomUDT& f1, const CustomUDT& f2) {
    return f1.a == f2.a && f1.b == f2.b;
  }

  int a;
  int b;
};
bool AbslParseFlag(absl::string_view in, CustomUDT* f, std::string*) {
  std::vector<absl::string_view> parts =
      absl::StrSplit(in, ':', absl::SkipWhitespace());

  if (parts.size() != 2) return false;

  if (!absl::SimpleAtoi(parts[0], &f->a)) return false;

  if (!absl::SimpleAtoi(parts[1], &f->b)) return false;

  return true;
}
std::string AbslUnparseFlag(const CustomUDT& f) {
  return absl::StrCat(f.a, ":", f.b);
}

}  // namespace

ABSL_FLAG(CustomUDT, test_flag_custom_udt, CustomUDT(), "test flag custom UDT");

namespace {

TEST_F(FlagTest, TestCustomUDT) {
  EXPECT_EQ(flags::StorageKind<CustomUDT>(),
            flags::FlagValueStorageKind::kOneWordAtomic);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_custom_udt), CustomUDT(1, 1));
  absl::SetFlag(&FLAGS_test_flag_custom_udt, CustomUDT(2, 3));
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_custom_udt), CustomUDT(2, 3));
}

// MSVC produces link error on the type mismatch.
// Linux does not have build errors and validations work as expected.
#if !defined(_WIN32) && GTEST_HAS_DEATH_TEST
using FlagDeathTest = FlagTest;

TEST_F(FlagDeathTest, TestTypeMismatchValidations) {
#if ABSL_FLAGS_STRIP_NAMES
  GTEST_SKIP() << "This test requires flag names to be present";
#endif
#if !defined(NDEBUG)
  EXPECT_DEATH_IF_SUPPORTED(
      static_cast<void>(absl::GetFlag(FLAGS_mistyped_int_flag)),
      "Flag 'mistyped_int_flag' is defined as one type and declared "
      "as another");
  EXPECT_DEATH_IF_SUPPORTED(
      static_cast<void>(absl::GetFlag(FLAGS_mistyped_string_flag)),
      "Flag 'mistyped_string_flag' is defined as one type and "
      "declared as another");
#endif

  EXPECT_DEATH_IF_SUPPORTED(
      absl::SetFlag(&FLAGS_mistyped_int_flag, 1),
      "Flag 'mistyped_int_flag' is defined as one type and declared "
      "as another");
  EXPECT_DEATH_IF_SUPPORTED(
      absl::SetFlag(&FLAGS_mistyped_string_flag, std::vector<std::string>{}),
      "Flag 'mistyped_string_flag' is defined as one type and declared as "
      "another");
}

#endif

// --------------------------------------------------------------------

// A contrived type that offers implicit and explicit conversion from specific
// source types.
struct ConversionTestVal {
  ConversionTestVal() = default;
  explicit ConversionTestVal(int a_in) : a(a_in) {}

  enum class ViaImplicitConv { kTen = 10, kEleven };
  // NOLINTNEXTLINE
  ConversionTestVal(ViaImplicitConv from) : a(static_cast<int>(from)) {}

  int a;
};

bool AbslParseFlag(absl::string_view in, ConversionTestVal* val_out,
                   std::string*) {
  if (!absl::SimpleAtoi(in, &val_out->a)) {
    return false;
  }
  return true;
}
std::string AbslUnparseFlag(const ConversionTestVal& val) {
  return absl::StrCat(val.a);
}

}  // namespace

// Flag default values can be specified with a value that converts to the flag
// value type implicitly.
ABSL_FLAG(ConversionTestVal, test_flag_implicit_conv,
          ConversionTestVal::ViaImplicitConv::kTen,
          "test flag init via implicit conversion");

namespace {

TEST_F(FlagTest, CanSetViaImplicitConversion) {
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_implicit_conv).a, 10);
  absl::SetFlag(&FLAGS_test_flag_implicit_conv,
                ConversionTestVal::ViaImplicitConv::kEleven);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_implicit_conv).a, 11);
}

// --------------------------------------------------------------------

struct NonDfltConstructible {
 public:
  // This constructor tests that we can initialize the flag with int value
  NonDfltConstructible(int i) : value(i) {}  // NOLINT

  // This constructor tests that we can't initialize the flag with char value
  // but can with explicitly constructed NonDfltConstructible.
  explicit NonDfltConstructible(char c) : value(100 + static_cast<int>(c)) {}

  int value;
};

bool AbslParseFlag(absl::string_view in, NonDfltConstructible* ndc_out,
                   std::string*) {
  return absl::SimpleAtoi(in, &ndc_out->value);
}
std::string AbslUnparseFlag(const NonDfltConstructible& ndc) {
  return absl::StrCat(ndc.value);
}

}  // namespace

ABSL_FLAG(NonDfltConstructible, ndc_flag1, NonDfltConstructible('1'),
          "Flag with non default constructible type");
ABSL_FLAG(NonDfltConstructible, ndc_flag2, 0,
          "Flag with non default constructible type");

namespace {

TEST_F(FlagTest, TestNonDefaultConstructibleType) {
  EXPECT_EQ(absl::GetFlag(FLAGS_ndc_flag1).value, '1' + 100);
  EXPECT_EQ(absl::GetFlag(FLAGS_ndc_flag2).value, 0);

  absl::SetFlag(&FLAGS_ndc_flag1, NonDfltConstructible('A'));
  absl::SetFlag(&FLAGS_ndc_flag2, 25);

  EXPECT_EQ(absl::GetFlag(FLAGS_ndc_flag1).value, 'A' + 100);
  EXPECT_EQ(absl::GetFlag(FLAGS_ndc_flag2).value, 25);
}

}  // namespace

// --------------------------------------------------------------------

ABSL_RETIRED_FLAG(bool, old_bool_flag, true, "old descr");
ABSL_RETIRED_FLAG(int, old_int_flag, (int)std::sqrt(10), "old descr");
ABSL_RETIRED_FLAG(std::string, old_str_flag, "", absl::StrCat("old ", "descr"));

namespace {

bool initialization_order_fiasco_test ABSL_ATTRIBUTE_UNUSED = [] {
  // Iterate over all the flags during static initialization.
  // This should not trigger ASan's initialization-order-fiasco.
  auto* handle1 = absl::FindCommandLineFlag("flag_on_separate_file");
  auto* handle2 = absl::FindCommandLineFlag("retired_flag_on_separate_file");
  if (handle1 != nullptr && handle2 != nullptr) {
    return handle1->Name() == handle2->Name();
  }
  return true;
}();

TEST_F(FlagTest, TestRetiredFlagRegistration) {
  auto* handle = absl::FindCommandLineFlag("old_bool_flag");
  EXPECT_TRUE(handle->IsOfType<bool>());
  EXPECT_TRUE(handle->IsRetired());
  handle = absl::FindCommandLineFlag("old_int_flag");
  EXPECT_TRUE(handle->IsOfType<int>());
  EXPECT_TRUE(handle->IsRetired());
  handle = absl::FindCommandLineFlag("old_str_flag");
  EXPECT_TRUE(handle->IsOfType<std::string>());
  EXPECT_TRUE(handle->IsRetired());
}

}  // namespace

// --------------------------------------------------------------------

namespace {

// User-defined type with small alignment, but size exceeding 16.
struct SmallAlignUDT {
  SmallAlignUDT() : c('A'), s(12) {}
  char c;
  int16_t s;
  char bytes[14];
};

bool AbslParseFlag(absl::string_view, SmallAlignUDT*, std::string*) {
  return true;
}
std::string AbslUnparseFlag(const SmallAlignUDT&) { return ""; }

}  // namespace

ABSL_FLAG(SmallAlignUDT, test_flag_sa_udt, {}, "help");

namespace {

TEST_F(FlagTest, TestSmallAlignUDT) {
  EXPECT_EQ(flags::StorageKind<SmallAlignUDT>(),
            flags::FlagValueStorageKind::kSequenceLocked);
  SmallAlignUDT value = absl::GetFlag(FLAGS_test_flag_sa_udt);
  EXPECT_EQ(value.c, 'A');
  EXPECT_EQ(value.s, 12);

  value.c = 'B';
  value.s = 45;
  absl::SetFlag(&FLAGS_test_flag_sa_udt, value);
  value = absl::GetFlag(FLAGS_test_flag_sa_udt);
  EXPECT_EQ(value.c, 'B');
  EXPECT_EQ(value.s, 45);
}
}  // namespace

// --------------------------------------------------------------------

namespace {

// User-defined not trivially copyable type.
template <int id>
struct NonTriviallyCopyableUDT {
  NonTriviallyCopyableUDT() : c('A') { s_num_instance++; }
  NonTriviallyCopyableUDT(const NonTriviallyCopyableUDT& rhs) : c(rhs.c) {
    s_num_instance++;
  }
  NonTriviallyCopyableUDT& operator=(const NonTriviallyCopyableUDT& rhs) {
    c = rhs.c;
    return *this;
  }
  ~NonTriviallyCopyableUDT() { s_num_instance--; }

  static uint64_t s_num_instance;
  char c;
};

template <int id>
uint64_t NonTriviallyCopyableUDT<id>::s_num_instance = 0;

template <int id>
bool AbslParseFlag(absl::string_view txt, NonTriviallyCopyableUDT<id>* f,
                   std::string*) {
  f->c = txt.empty() ? '\0' : txt[0];
  return true;
}
template <int id>
std::string AbslUnparseFlag(const NonTriviallyCopyableUDT<id>&) {
  return "";
}

template <int id, typename F>
void TestExpectedLeaks(
    F&& f, uint64_t num_leaks,
    absl::optional<uint64_t> num_new_instances = absl::nullopt) {
  if (!num_new_instances.has_value()) num_new_instances = num_leaks;

  auto num_leaked_before = flags::NumLeakedFlagValues();
  auto num_instances_before = NonTriviallyCopyableUDT<id>::s_num_instance;
  f();
  EXPECT_EQ(num_leaked_before + num_leaks, flags::NumLeakedFlagValues());
  EXPECT_EQ(num_instances_before + num_new_instances.value(),
            NonTriviallyCopyableUDT<id>::s_num_instance);
}
}  // namespace

ABSL_FLAG(NonTriviallyCopyableUDT<1>, test_flag_ntc_udt1, {}, "help");
ABSL_FLAG(NonTriviallyCopyableUDT<2>, test_flag_ntc_udt2, {}, "help");
ABSL_FLAG(NonTriviallyCopyableUDT<3>, test_flag_ntc_udt3, {}, "help");
ABSL_FLAG(NonTriviallyCopyableUDT<4>, test_flag_ntc_udt4, {}, "help");
ABSL_FLAG(NonTriviallyCopyableUDT<5>, test_flag_ntc_udt5, {}, "help");

namespace {

TEST_F(FlagTest, TestNonTriviallyCopyableGetSetSet) {
  EXPECT_EQ(flags::StorageKind<NonTriviallyCopyableUDT<1>>(),
            flags::FlagValueStorageKind::kHeapAllocated);

  TestExpectedLeaks<1>(
      [&] {
        NonTriviallyCopyableUDT<1> value =
            absl::GetFlag(FLAGS_test_flag_ntc_udt1);
        EXPECT_EQ(value.c, 'A');
      },
      0);

  TestExpectedLeaks<1>(
      [&] {
        NonTriviallyCopyableUDT<1> value;
        value.c = 'B';
        absl::SetFlag(&FLAGS_test_flag_ntc_udt1, value);
        EXPECT_EQ(value.c, 'B');
      },
      1);

  TestExpectedLeaks<1>(
      [&] {
        NonTriviallyCopyableUDT<1> value;
        value.c = 'C';
        absl::SetFlag(&FLAGS_test_flag_ntc_udt1, value);
      },
      0);
}

TEST_F(FlagTest, TestNonTriviallyCopyableParseSet) {
  TestExpectedLeaks<2>(
      [&] {
        const char* in_argv[] = {"testbin", "--test_flag_ntc_udt2=A"};
        absl::ParseCommandLine(2, const_cast<char**>(in_argv));
      },
      0);

  TestExpectedLeaks<2>(
      [&] {
        NonTriviallyCopyableUDT<2> value;
        value.c = 'B';
        absl::SetFlag(&FLAGS_test_flag_ntc_udt2, value);
        EXPECT_EQ(value.c, 'B');
      },
      0);
}

TEST_F(FlagTest, TestNonTriviallyCopyableSet) {
  TestExpectedLeaks<3>(
      [&] {
        NonTriviallyCopyableUDT<3> value;
        value.c = 'B';
        absl::SetFlag(&FLAGS_test_flag_ntc_udt3, value);
        EXPECT_EQ(value.c, 'B');
      },
      0);
}

// One new instance created during initialization and stored in the flag.
auto premain_utd4_get =
    (TestExpectedLeaks<4>([] { (void)absl::GetFlag(FLAGS_test_flag_ntc_udt4); },
                          0, 1),
     false);

TEST_F(FlagTest, TestNonTriviallyCopyableGetBeforeMainParseGet) {
  TestExpectedLeaks<4>(
      [&] {
        const char* in_argv[] = {"testbin", "--test_flag_ntc_udt4=C"};
        absl::ParseCommandLine(2, const_cast<char**>(in_argv));
      },
      1);

  TestExpectedLeaks<4>(
      [&] {
        NonTriviallyCopyableUDT<4> value =
            absl::GetFlag(FLAGS_test_flag_ntc_udt4);
        EXPECT_EQ(value.c, 'C');
      },
      0);
}

// One new instance created during initialization, which is reused since it was
// never read.
auto premain_utd5_set = (TestExpectedLeaks<5>(
                             [] {
                               NonTriviallyCopyableUDT<5> value;
                               value.c = 'B';
                               absl::SetFlag(&FLAGS_test_flag_ntc_udt5, value);
                             },
                             0, 1),
                         false);

TEST_F(FlagTest, TestNonTriviallyCopyableSetParseGet) {
  TestExpectedLeaks<5>(
      [&] {
        const char* in_argv[] = {"testbin", "--test_flag_ntc_udt5=C"};
        absl::ParseCommandLine(2, const_cast<char**>(in_argv));
      },
      0);

  TestExpectedLeaks<5>(
      [&] {
        NonTriviallyCopyableUDT<5> value =
            absl::GetFlag(FLAGS_test_flag_ntc_udt5);
        EXPECT_EQ(value.c, 'C');
      },
      0);
}

}  // namespace

// --------------------------------------------------------------------

namespace {

enum TestE { A = 1, B = 2, C = 3 };

struct EnumWrapper {
  EnumWrapper() : e(A) {}

  TestE e;
};

bool AbslParseFlag(absl::string_view, EnumWrapper*, std::string*) {
  return true;
}
std::string AbslUnparseFlag(const EnumWrapper&) { return ""; }

}  // namespace

ABSL_FLAG(EnumWrapper, test_enum_wrapper_flag, {}, "help");

TEST_F(FlagTest, TesTypeWrappingEnum) {
  EnumWrapper value = absl::GetFlag(FLAGS_test_enum_wrapper_flag);
  EXPECT_EQ(value.e, A);

  value.e = B;
  absl::SetFlag(&FLAGS_test_enum_wrapper_flag, value);
  value = absl::GetFlag(FLAGS_test_enum_wrapper_flag);
  EXPECT_EQ(value.e, B);
}

// This is a compile test to ensure macros are expanded within ABSL_FLAG and
// ABSL_DECLARE_FLAG.
#define FLAG_NAME_MACRO(name) prefix_##name
ABSL_DECLARE_FLAG(int, FLAG_NAME_MACRO(test_macro_named_flag));
ABSL_FLAG(int, FLAG_NAME_MACRO(test_macro_named_flag), 0,
          "Testing macro expansion within ABSL_FLAG");

TEST_F(FlagTest, MacroWithinAbslFlag) {
  EXPECT_EQ(absl::GetFlag(FLAGS_prefix_test_macro_named_flag), 0);
  absl::SetFlag(&FLAGS_prefix_test_macro_named_flag, 1);
  EXPECT_EQ(absl::GetFlag(FLAGS_prefix_test_macro_named_flag), 1);
}

// --------------------------------------------------------------------

ABSL_FLAG(absl::optional<bool>, optional_bool, absl::nullopt, "help");
ABSL_FLAG(absl::optional<int>, optional_int, {}, "help");
ABSL_FLAG(absl::optional<double>, optional_double, 9.3, "help");
ABSL_FLAG(absl::optional<std::string>, optional_string, absl::nullopt, "help");
ABSL_FLAG(absl::optional<absl::Duration>, optional_duration, absl::nullopt,
          "help");
ABSL_FLAG(absl::optional<absl::optional<int>>, optional_optional_int,
          absl::nullopt, "help");
#if defined(ABSL_HAVE_STD_OPTIONAL) && !defined(ABSL_USES_STD_OPTIONAL)
ABSL_FLAG(std::optional<int64_t>, std_optional_int64, std::nullopt, "help");
#endif

namespace {

TEST_F(FlagTest, TestOptionalBool) {
  EXPECT_FALSE(absl::GetFlag(FLAGS_optional_bool).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_optional_bool), absl::nullopt);

  absl::SetFlag(&FLAGS_optional_bool, false);
  EXPECT_TRUE(absl::GetFlag(FLAGS_optional_bool).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_optional_bool), false);

  absl::SetFlag(&FLAGS_optional_bool, true);
  EXPECT_TRUE(absl::GetFlag(FLAGS_optional_bool).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_optional_bool), true);

  absl::SetFlag(&FLAGS_optional_bool, absl::nullopt);
  EXPECT_FALSE(absl::GetFlag(FLAGS_optional_bool).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_optional_bool), absl::nullopt);
}

// --------------------------------------------------------------------

TEST_F(FlagTest, TestOptionalInt) {
  EXPECT_FALSE(absl::GetFlag(FLAGS_optional_int).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_optional_int), absl::nullopt);

  absl::SetFlag(&FLAGS_optional_int, 0);
  EXPECT_TRUE(absl::GetFlag(FLAGS_optional_int).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_optional_int), 0);

  absl::SetFlag(&FLAGS_optional_int, 10);
  EXPECT_TRUE(absl::GetFlag(FLAGS_optional_int).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_optional_int), 10);

  absl::SetFlag(&FLAGS_optional_int, absl::nullopt);
  EXPECT_FALSE(absl::GetFlag(FLAGS_optional_int).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_optional_int), absl::nullopt);
}

// --------------------------------------------------------------------

TEST_F(FlagTest, TestOptionalDouble) {
  EXPECT_TRUE(absl::GetFlag(FLAGS_optional_double).has_value());
  EXPECT_DOUBLE_EQ(*absl::GetFlag(FLAGS_optional_double), 9.3);

  absl::SetFlag(&FLAGS_optional_double, 0.0);
  EXPECT_TRUE(absl::GetFlag(FLAGS_optional_double).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_optional_double), 0.0);

  absl::SetFlag(&FLAGS_optional_double, 1.234);
  EXPECT_TRUE(absl::GetFlag(FLAGS_optional_double).has_value());
  EXPECT_DOUBLE_EQ(*absl::GetFlag(FLAGS_optional_double), 1.234);

  absl::SetFlag(&FLAGS_optional_double, absl::nullopt);
  EXPECT_FALSE(absl::GetFlag(FLAGS_optional_double).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_optional_double), absl::nullopt);
}

// --------------------------------------------------------------------

TEST_F(FlagTest, TestOptionalString) {
  EXPECT_FALSE(absl::GetFlag(FLAGS_optional_string).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_optional_string), absl::nullopt);

  // Setting optional string to "" leads to undefined behavior.

  absl::SetFlag(&FLAGS_optional_string, " ");
  EXPECT_TRUE(absl::GetFlag(FLAGS_optional_string).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_optional_string), " ");

  absl::SetFlag(&FLAGS_optional_string, "QWERTY");
  EXPECT_TRUE(absl::GetFlag(FLAGS_optional_string).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_optional_string), "QWERTY");

  absl::SetFlag(&FLAGS_optional_string, absl::nullopt);
  EXPECT_FALSE(absl::GetFlag(FLAGS_optional_string).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_optional_string), absl::nullopt);
}

// --------------------------------------------------------------------

TEST_F(FlagTest, TestOptionalDuration) {
  EXPECT_FALSE(absl::GetFlag(FLAGS_optional_duration).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_optional_duration), absl::nullopt);

  absl::SetFlag(&FLAGS_optional_duration, absl::ZeroDuration());
  EXPECT_TRUE(absl::GetFlag(FLAGS_optional_duration).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_optional_duration), absl::Seconds(0));

  absl::SetFlag(&FLAGS_optional_duration, absl::Hours(3));
  EXPECT_TRUE(absl::GetFlag(FLAGS_optional_duration).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_optional_duration), absl::Hours(3));

  absl::SetFlag(&FLAGS_optional_duration, absl::nullopt);
  EXPECT_FALSE(absl::GetFlag(FLAGS_optional_duration).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_optional_duration), absl::nullopt);
}

// --------------------------------------------------------------------

TEST_F(FlagTest, TestOptionalOptional) {
  EXPECT_FALSE(absl::GetFlag(FLAGS_optional_optional_int).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_optional_optional_int), absl::nullopt);

  absl::optional<int> nullint{absl::nullopt};

  absl::SetFlag(&FLAGS_optional_optional_int, nullint);
  EXPECT_TRUE(absl::GetFlag(FLAGS_optional_optional_int).has_value());
  EXPECT_NE(absl::GetFlag(FLAGS_optional_optional_int), nullint);
  EXPECT_EQ(absl::GetFlag(FLAGS_optional_optional_int),
            absl::optional<absl::optional<int>>{nullint});

  absl::SetFlag(&FLAGS_optional_optional_int, 0);
  EXPECT_TRUE(absl::GetFlag(FLAGS_optional_optional_int).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_optional_optional_int), 0);

  absl::SetFlag(&FLAGS_optional_optional_int, absl::optional<int>{0});
  EXPECT_TRUE(absl::GetFlag(FLAGS_optional_optional_int).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_optional_optional_int), 0);
  EXPECT_EQ(absl::GetFlag(FLAGS_optional_optional_int), absl::optional<int>{0});

  absl::SetFlag(&FLAGS_optional_optional_int, absl::nullopt);
  EXPECT_FALSE(absl::GetFlag(FLAGS_optional_optional_int).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_optional_optional_int), absl::nullopt);
}

// --------------------------------------------------------------------

#if defined(ABSL_HAVE_STD_OPTIONAL) && !defined(ABSL_USES_STD_OPTIONAL)

TEST_F(FlagTest, TestStdOptional) {
  EXPECT_FALSE(absl::GetFlag(FLAGS_std_optional_int64).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_std_optional_int64), std::nullopt);

  absl::SetFlag(&FLAGS_std_optional_int64, 0);
  EXPECT_TRUE(absl::GetFlag(FLAGS_std_optional_int64).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_std_optional_int64), 0);

  absl::SetFlag(&FLAGS_std_optional_int64, 0xFFFFFFFFFF16);
  EXPECT_TRUE(absl::GetFlag(FLAGS_std_optional_int64).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_std_optional_int64), 0xFFFFFFFFFF16);

  absl::SetFlag(&FLAGS_std_optional_int64, std::nullopt);
  EXPECT_FALSE(absl::GetFlag(FLAGS_std_optional_int64).has_value());
  EXPECT_EQ(absl::GetFlag(FLAGS_std_optional_int64), std::nullopt);
}

// --------------------------------------------------------------------

#endif

}  // namespace
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/flag_test_defs.cc                             0000664 0000000 0000000 00000001776 14746647661 0025725 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
//  Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file is used to test the mismatch of the flag type between definition
// and declaration. These are definitions. flag_test.cc contains declarations.
#include <string>
#include "absl/flags/flag.h"

ABSL_FLAG(int, mistyped_int_flag, 0, "");
ABSL_FLAG(std::string, mistyped_string_flag, "", "");
ABSL_FLAG(bool, flag_on_separate_file, false, "");
ABSL_RETIRED_FLAG(bool, retired_flag_on_separate_file, false, "");
  node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/internal/                                     0000775 0000000 0000000 00000000000 14746647661 0024246 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/internal/commandlineflag.cc                   0000664 0000000 0000000 00000001513 14746647661 0027675 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
// Copyright 2020 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/flags/internal/commandlineflag.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace flags_internal {

FlagStateInterface::~FlagStateInterface() = default;

}  // namespace flags_internal
ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                     node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/internal/commandlineflag.h                    0000664 0000000 0000000 00000004705 14746647661 0027545 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
// Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef ABSL_FLAGS_INTERNAL_COMMANDLINEFLAG_H_
#define ABSL_FLAGS_INTERNAL_COMMANDLINEFLAG_H_

#include "absl/base/config.h"
#include "absl/base/internal/fast_type_id.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace flags_internal {

// An alias for flag fast type id. This value identifies the flag value type
// similarly to typeid(T), without relying on RTTI being available. In most
// cases this id is enough to uniquely identify the flag's value type. In a few
// cases we'll have to resort to using actual RTTI implementation if it is
// available.
using FlagFastTypeId = absl::base_internal::FastTypeIdType;

// Options that control SetCommandLineOptionWithMode.
enum FlagSettingMode {
  // update the flag's value unconditionally (can call this multiple times).
  SET_FLAGS_VALUE,
  // update the flag's value, but *only if* it has not yet been updated
  // with SET_FLAGS_VALUE, SET_FLAG_IF_DEFAULT, or "FLAGS_xxx = nondef".
  SET_FLAG_IF_DEFAULT,
  // set the flag's default value to this.  If the flag has not been updated
  // yet (via SET_FLAGS_VALUE, SET_FLAG_IF_DEFAULT, or "FLAGS_xxx = nondef")
  // change the flag's current value to the new default value as well.
  SET_FLAGS_DEFAULT
};

// Options that control ParseFrom: Source of a value.
enum ValueSource {
  // Flag is being set by value specified on a command line.
  kCommandLine,
  // Flag is being set by value specified in the code.
  kProgrammaticChange,
};

// Handle to FlagState objects. Specific flag state objects will restore state
// of a flag produced this flag state from method CommandLineFlag::SaveState().
class FlagStateInterface {
 public:
  virtual ~FlagStateInterface();

  // Restores the flag originated this object to the saved state.
  virtual void Restore() const = 0;
};

}  // namespace flags_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_FLAGS_INTERNAL_COMMANDLINEFLAG_H_
                                                           node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/internal/flag.cc                              0000664 0000000 0000000 00000060276 14746647661 0025501 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
// Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/flags/internal/flag.h"

#include <assert.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>

#include <array>
#include <atomic>
#include <cstring>
#include <memory>
#include <string>
#include <typeinfo>
#include <vector>

#include "absl/base/attributes.h"
#include "absl/base/call_once.h"
#include "absl/base/casts.h"
#include "absl/base/config.h"
#include "absl/base/const_init.h"
#include "absl/base/dynamic_annotations.h"
#include "absl/base/optimization.h"
#include "absl/flags/config.h"
#include "absl/flags/internal/commandlineflag.h"
#include "absl/flags/usage_config.h"
#include "absl/memory/memory.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"
#include "absl/synchronization/mutex.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace flags_internal {

// The help message indicating that the commandline flag has been stripped. It
// will not show up when doing "-help" and its variants. The flag is stripped
// if ABSL_FLAGS_STRIP_HELP is set to 1 before including absl/flags/flag.h
const char kStrippedFlagHelp[] = "\001\002\003\004 (unknown) \004\003\002\001";

namespace {

// Currently we only validate flag values for user-defined flag types.
bool ShouldValidateFlagValue(FlagFastTypeId flag_type_id) {
#define DONT_VALIDATE(T, _) \
  if (flag_type_id == base_internal::FastTypeId<T>()) return false;
  ABSL_FLAGS_INTERNAL_SUPPORTED_TYPES(DONT_VALIDATE)
#undef DONT_VALIDATE

  return true;
}

// RAII helper used to temporarily unlock and relock `absl::Mutex`.
// This is used when we need to ensure that locks are released while
// invoking user supplied callbacks and then reacquired, since callbacks may
// need to acquire these locks themselves.
class MutexRelock {
 public:
  explicit MutexRelock(absl::Mutex& mu) : mu_(mu) { mu_.Unlock(); }
  ~MutexRelock() { mu_.Lock(); }

  MutexRelock(const MutexRelock&) = delete;
  MutexRelock& operator=(const MutexRelock&) = delete;

 private:
  absl::Mutex& mu_;
};

// This is a freelist of leaked flag values and guard for its access.
// When we can't guarantee it is safe to reuse the memory for flag values,
// we move the memory to the freelist where it lives indefinitely, so it can
// still be safely accessed. This also prevents leak checkers from complaining
// about the leaked memory that can no longer be accessed through any pointer.
ABSL_CONST_INIT absl::Mutex s_freelist_guard(absl::kConstInit);
ABSL_CONST_INIT std::vector<void*>* s_freelist = nullptr;

void AddToFreelist(void* p) {
  absl::MutexLock l(&s_freelist_guard);
  if (!s_freelist) {
    s_freelist = new std::vector<void*>;
  }
  s_freelist->push_back(p);
}

}  // namespace

///////////////////////////////////////////////////////////////////////////////

uint64_t NumLeakedFlagValues() {
  absl::MutexLock l(&s_freelist_guard);
  return s_freelist == nullptr ? 0u : s_freelist->size();
}

///////////////////////////////////////////////////////////////////////////////
// Persistent state of the flag data.

class FlagImpl;

class FlagState : public flags_internal::FlagStateInterface {
 public:
  template <typename V>
  FlagState(FlagImpl& flag_impl, const V& v, bool modified,
            bool on_command_line, int64_t counter)
      : flag_impl_(flag_impl),
        value_(v),
        modified_(modified),
        on_command_line_(on_command_line),
        counter_(counter) {}

  ~FlagState() override {
    if (flag_impl_.ValueStorageKind() != FlagValueStorageKind::kHeapAllocated &&
        flag_impl_.ValueStorageKind() != FlagValueStorageKind::kSequenceLocked)
      return;
    flags_internal::Delete(flag_impl_.op_, value_.heap_allocated);
  }

 private:
  friend class FlagImpl;

  // Restores the flag to the saved state.
  void Restore() const override {
    if (!flag_impl_.RestoreState(*this)) return;

    ABSL_INTERNAL_LOG(INFO,
                      absl::StrCat("Restore saved value of ", flag_impl_.Name(),
                                   " to: ", flag_impl_.CurrentValue()));
  }

  // Flag and saved flag data.
  FlagImpl& flag_impl_;
  union SavedValue {
    explicit SavedValue(void* v) : heap_allocated(v) {}
    explicit SavedValue(int64_t v) : one_word(v) {}

    void* heap_allocated;
    int64_t one_word;
  } value_;
  bool modified_;
  bool on_command_line_;
  int64_t counter_;
};

///////////////////////////////////////////////////////////////////////////////
// Flag implementation, which does not depend on flag value type.

DynValueDeleter::DynValueDeleter(FlagOpFn op_arg) : op(op_arg) {}

void DynValueDeleter::operator()(void* ptr) const {
  if (op == nullptr) return;

  Delete(op, ptr);
}

MaskedPointer::MaskedPointer(ptr_t rhs, bool is_candidate) : ptr_(rhs) {
  if (is_candidate) {
    ApplyMask(kUnprotectedReadCandidate);
  }
}

bool MaskedPointer::IsUnprotectedReadCandidate() const {
  return CheckMask(kUnprotectedReadCandidate);
}

bool MaskedPointer::HasBeenRead() const { return CheckMask(kHasBeenRead); }

void MaskedPointer::Set(FlagOpFn op, const void* src, bool is_candidate) {
  flags_internal::Copy(op, src, Ptr());
  if (is_candidate) {
    ApplyMask(kUnprotectedReadCandidate);
  }
}
void MaskedPointer::MarkAsRead() { ApplyMask(kHasBeenRead); }

void MaskedPointer::ApplyMask(mask_t mask) {
  ptr_ = reinterpret_cast<ptr_t>(reinterpret_cast<mask_t>(ptr_) | mask);
}
bool MaskedPointer::CheckMask(mask_t mask) const {
  return (reinterpret_cast<mask_t>(ptr_) & mask) != 0;
}

void FlagImpl::Init() {
  new (&data_guard_) absl::Mutex;

  auto def_kind = static_cast<FlagDefaultKind>(def_kind_);

  switch (ValueStorageKind()) {
    case FlagValueStorageKind::kValueAndInitBit:
    case FlagValueStorageKind::kOneWordAtomic: {
      alignas(int64_t) std::array<char, sizeof(int64_t)> buf{};
      if (def_kind == FlagDefaultKind::kGenFunc) {
        (*default_value_.gen_func)(buf.data());
      } else {
        assert(def_kind != FlagDefaultKind::kDynamicValue);
        std::memcpy(buf.data(), &default_value_, Sizeof(op_));
      }
      if (ValueStorageKind() == FlagValueStorageKind::kValueAndInitBit) {
        // We presume here the memory layout of FlagValueAndInitBit struct.
        uint8_t initialized = 1;
        std::memcpy(buf.data() + Sizeof(op_), &initialized,
                    sizeof(initialized));
      }
      // Type can contain valid uninitialized bits, e.g. padding.
      ABSL_ANNOTATE_MEMORY_IS_INITIALIZED(buf.data(), buf.size());
      OneWordValue().store(absl::bit_cast<int64_t>(buf),
                           std::memory_order_release);
      break;
    }
    case FlagValueStorageKind::kSequenceLocked: {
      // For this storage kind the default_value_ always points to gen_func
      // during initialization.
      assert(def_kind == FlagDefaultKind::kGenFunc);
      (*default_value_.gen_func)(AtomicBufferValue());
      break;
    }
    case FlagValueStorageKind::kHeapAllocated:
      // For this storage kind the default_value_ always points to gen_func
      // during initialization.
      assert(def_kind == FlagDefaultKind::kGenFunc);
      // Flag value initially points to the internal buffer.
      MaskedPointer ptr_value = PtrStorage().load(std::memory_order_acquire);
      (*default_value_.gen_func)(ptr_value.Ptr());
      // Default value is a candidate for an unprotected read.
      PtrStorage().store(MaskedPointer(ptr_value.Ptr(), true),
                         std::memory_order_release);
      break;
  }
  seq_lock_.MarkInitialized();
}

absl::Mutex* FlagImpl::DataGuard() const {
  absl::call_once(const_cast<FlagImpl*>(this)->init_control_, &FlagImpl::Init,
                  const_cast<FlagImpl*>(this));

  // data_guard_ is initialized inside Init.
  return reinterpret_cast<absl::Mutex*>(&data_guard_);
}

void FlagImpl::AssertValidType(FlagFastTypeId rhs_type_id,
                               const std::type_info* (*gen_rtti)()) const {
  FlagFastTypeId lhs_type_id = flags_internal::FastTypeId(op_);

  // `rhs_type_id` is the fast type id corresponding to the declaration
  // visible at the call site. `lhs_type_id` is the fast type id
  // corresponding to the type specified in flag definition. They must match
  //  for this operation to be well-defined.
  if (ABSL_PREDICT_TRUE(lhs_type_id == rhs_type_id)) return;

  const std::type_info* lhs_runtime_type_id =
      flags_internal::RuntimeTypeId(op_);
  const std::type_info* rhs_runtime_type_id = (*gen_rtti)();

  if (lhs_runtime_type_id == rhs_runtime_type_id) return;

#ifdef ABSL_INTERNAL_HAS_RTTI
  if (*lhs_runtime_type_id == *rhs_runtime_type_id) return;
#endif

  ABSL_INTERNAL_LOG(
      FATAL, absl::StrCat("Flag '", Name(),
                          "' is defined as one type and declared as another"));
}

std::unique_ptr<void, DynValueDeleter> FlagImpl::MakeInitValue() const {
  void* res = nullptr;
  switch (DefaultKind()) {
    case FlagDefaultKind::kDynamicValue:
      res = flags_internal::Clone(op_, default_value_.dynamic_value);
      break;
    case FlagDefaultKind::kGenFunc:
      res = flags_internal::Alloc(op_);
      (*default_value_.gen_func)(res);
      break;
    default:
      res = flags_internal::Clone(op_, &default_value_);
      break;
  }
  return {res, DynValueDeleter{op_}};
}

void FlagImpl::StoreValue(const void* src, ValueSource source) {
  switch (ValueStorageKind()) {
    case FlagValueStorageKind::kValueAndInitBit:
    case FlagValueStorageKind::kOneWordAtomic: {
      // Load the current value to avoid setting 'init' bit manually.
      int64_t one_word_val = OneWordValue().load(std::memory_order_acquire);
      std::memcpy(&one_word_val, src, Sizeof(op_));
      OneWordValue().store(one_word_val, std::memory_order_release);
      seq_lock_.IncrementModificationCount();
      break;
    }
    case FlagValueStorageKind::kSequenceLocked: {
      seq_lock_.Write(AtomicBufferValue(), src, Sizeof(op_));
      break;
    }
    case FlagValueStorageKind::kHeapAllocated:
      MaskedPointer ptr_value = PtrStorage().load(std::memory_order_acquire);

      if (ptr_value.IsUnprotectedReadCandidate() && ptr_value.HasBeenRead()) {
        // If current value is a candidate for an unprotected read and if it was
        // already read at least once, follow up reads (if any) are done without
        // mutex protection. We can't guarantee it is safe to reuse this memory
        // since it may have been accessed by another thread concurrently, so
        // instead we move the memory to a freelist so it can still be safely
        // accessed, and allocate a new one for the new value.
        AddToFreelist(ptr_value.Ptr());
        ptr_value = MaskedPointer(Clone(op_, src), source == kCommandLine);
      } else {
        // Current value either was set programmatically or was never read.
        // We can reuse the memory since all accesses to this value (if any)
        // were protected by mutex. That said, if a new value comes from command
        // line it now becomes a candidate for an unprotected read.
        ptr_value.Set(op_, src, source == kCommandLine);
      }

      PtrStorage().store(ptr_value, std::memory_order_release);
      seq_lock_.IncrementModificationCount();
      break;
  }
  modified_ = true;
  InvokeCallback();
}

absl::string_view FlagImpl::Name() const { return name_; }

std::string FlagImpl::Filename() const {
  return flags_internal::GetUsageConfig().normalize_filename(filename_);
}

std::string FlagImpl::Help() const {
  return HelpSourceKind() == FlagHelpKind::kLiteral ? help_.literal
                                                    : help_.gen_func();
}

FlagFastTypeId FlagImpl::TypeId() const {
  return flags_internal::FastTypeId(op_);
}

int64_t FlagImpl::ModificationCount() const {
  return seq_lock_.ModificationCount();
}

bool FlagImpl::IsSpecifiedOnCommandLine() const {
  absl::MutexLock l(DataGuard());
  return on_command_line_;
}

std::string FlagImpl::DefaultValue() const {
  absl::MutexLock l(DataGuard());

  auto obj = MakeInitValue();
  return flags_internal::Unparse(op_, obj.get());
}

std::string FlagImpl::CurrentValue() const {
  auto* guard = DataGuard();  // Make sure flag initialized
  switch (ValueStorageKind()) {
    case FlagValueStorageKind::kValueAndInitBit:
    case FlagValueStorageKind::kOneWordAtomic: {
      const auto one_word_val =
          absl::bit_cast<std::array<char, sizeof(int64_t)>>(
              OneWordValue().load(std::memory_order_acquire));
      return flags_internal::Unparse(op_, one_word_val.data());
    }
    case FlagValueStorageKind::kSequenceLocked: {
      std::unique_ptr<void, DynValueDeleter> cloned(flags_internal::Alloc(op_),
                                                    DynValueDeleter{op_});
      ReadSequenceLockedData(cloned.get());
      return flags_internal::Unparse(op_, cloned.get());
    }
    case FlagValueStorageKind::kHeapAllocated: {
      absl::MutexLock l(guard);
      return flags_internal::Unparse(
          op_, PtrStorage().load(std::memory_order_acquire).Ptr());
    }
  }

  return "";
}

void FlagImpl::SetCallback(const FlagCallbackFunc mutation_callback) {
  absl::MutexLock l(DataGuard());

  if (callback_ == nullptr) {
    callback_ = new FlagCallback;
  }
  callback_->func = mutation_callback;

  InvokeCallback();
}

void FlagImpl::InvokeCallback() const {
  if (!callback_) return;

  // Make a copy of the C-style function pointer that we are about to invoke
  // before we release the lock guarding it.
  FlagCallbackFunc cb = callback_->func;

  // If the flag has a mutation callback this function invokes it. While the
  // callback is being invoked the primary flag's mutex is unlocked and it is
  // re-locked back after call to callback is completed. Callback invocation is
  // guarded by flag's secondary mutex instead which prevents concurrent
  // callback invocation. Note that it is possible for other thread to grab the
  // primary lock and update flag's value at any time during the callback
  // invocation. This is by design. Callback can get a value of the flag if
  // necessary, but it might be different from the value initiated the callback
  // and it also can be different by the time the callback invocation is
  // completed. Requires that *primary_lock be held in exclusive mode; it may be
  // released and reacquired by the implementation.
  MutexRelock relock(*DataGuard());
  absl::MutexLock lock(&callback_->guard);
  cb();
}

std::unique_ptr<FlagStateInterface> FlagImpl::SaveState() {
  absl::MutexLock l(DataGuard());

  bool modified = modified_;
  bool on_command_line = on_command_line_;
  switch (ValueStorageKind()) {
    case FlagValueStorageKind::kValueAndInitBit:
    case FlagValueStorageKind::kOneWordAtomic: {
      return absl::make_unique<FlagState>(
          *this, OneWordValue().load(std::memory_order_acquire), modified,
          on_command_line, ModificationCount());
    }
    case FlagValueStorageKind::kSequenceLocked: {
      void* cloned = flags_internal::Alloc(op_);
      // Read is guaranteed to be successful because we hold the lock.
      bool success =
          seq_lock_.TryRead(cloned, AtomicBufferValue(), Sizeof(op_));
      assert(success);
      static_cast<void>(success);
      return absl::make_unique<FlagState>(*this, cloned, modified,
                                          on_command_line, ModificationCount());
    }
    case FlagValueStorageKind::kHeapAllocated: {
      return absl::make_unique<FlagState>(
          *this,
          flags_internal::Clone(
              op_, PtrStorage().load(std::memory_order_acquire).Ptr()),
          modified, on_command_line, ModificationCount());
    }
  }
  return nullptr;
}

bool FlagImpl::RestoreState(const FlagState& flag_state) {
  absl::MutexLock l(DataGuard());
  if (flag_state.counter_ == ModificationCount()) {
    return false;
  }

  switch (ValueStorageKind()) {
    case FlagValueStorageKind::kValueAndInitBit:
    case FlagValueStorageKind::kOneWordAtomic:
      StoreValue(&flag_state.value_.one_word, kProgrammaticChange);
      break;
    case FlagValueStorageKind::kSequenceLocked:
    case FlagValueStorageKind::kHeapAllocated:
      StoreValue(flag_state.value_.heap_allocated, kProgrammaticChange);
      break;
  }

  modified_ = flag_state.modified_;
  on_command_line_ = flag_state.on_command_line_;

  return true;
}

template <typename StorageT>
StorageT* FlagImpl::OffsetValue() const {
  char* p = reinterpret_cast<char*>(const_cast<FlagImpl*>(this));
  // The offset is deduced via Flag value type specific op_.
  ptrdiff_t offset = flags_internal::ValueOffset(op_);

  return reinterpret_cast<StorageT*>(p + offset);
}

std::atomic<uint64_t>* FlagImpl::AtomicBufferValue() const {
  assert(ValueStorageKind() == FlagValueStorageKind::kSequenceLocked);
  return OffsetValue<std::atomic<uint64_t>>();
}

std::atomic<int64_t>& FlagImpl::OneWordValue() const {
  assert(ValueStorageKind() == FlagValueStorageKind::kOneWordAtomic ||
         ValueStorageKind() == FlagValueStorageKind::kValueAndInitBit);
  return OffsetValue<FlagOneWordValue>()->value;
}

std::atomic<MaskedPointer>& FlagImpl::PtrStorage() const {
  assert(ValueStorageKind() == FlagValueStorageKind::kHeapAllocated);
  return OffsetValue<FlagMaskedPointerValue>()->value;
}

// Attempts to parse supplied `value` string using parsing routine in the `flag`
// argument. If parsing successful, this function replaces the dst with newly
// parsed value. In case if any error is encountered in either step, the error
// message is stored in 'err'
std::unique_ptr<void, DynValueDeleter> FlagImpl::TryParse(
    absl::string_view value, std::string& err) const {
  std::unique_ptr<void, DynValueDeleter> tentative_value = MakeInitValue();

  std::string parse_err;
  if (!flags_internal::Parse(op_, value, tentative_value.get(), &parse_err)) {
    absl::string_view err_sep = parse_err.empty() ? "" : "; ";
    err = absl::StrCat("Illegal value '", value, "' specified for flag '",
                       Name(), "'", err_sep, parse_err);
    return nullptr;
  }

  return tentative_value;
}

void FlagImpl::Read(void* dst) const {
  auto* guard = DataGuard();  // Make sure flag initialized
  switch (ValueStorageKind()) {
    case FlagValueStorageKind::kValueAndInitBit:
    case FlagValueStorageKind::kOneWordAtomic: {
      const int64_t one_word_val =
          OneWordValue().load(std::memory_order_acquire);
      std::memcpy(dst, &one_word_val, Sizeof(op_));
      break;
    }
    case FlagValueStorageKind::kSequenceLocked: {
      ReadSequenceLockedData(dst);
      break;
    }
    case FlagValueStorageKind::kHeapAllocated: {
      absl::MutexLock l(guard);
      MaskedPointer ptr_value = PtrStorage().load(std::memory_order_acquire);

      flags_internal::CopyConstruct(op_, ptr_value.Ptr(), dst);

      // For unprotected read candidates, mark that the value as has been read.
      if (ptr_value.IsUnprotectedReadCandidate() && !ptr_value.HasBeenRead()) {
        ptr_value.MarkAsRead();
        PtrStorage().store(ptr_value, std::memory_order_release);
      }
      break;
    }
  }
}

int64_t FlagImpl::ReadOneWord() const {
  assert(ValueStorageKind() == FlagValueStorageKind::kOneWordAtomic ||
         ValueStorageKind() == FlagValueStorageKind::kValueAndInitBit);
  auto* guard = DataGuard();  // Make sure flag initialized
  (void)guard;
  return OneWordValue().load(std::memory_order_acquire);
}

bool FlagImpl::ReadOneBool() const {
  assert(ValueStorageKind() == FlagValueStorageKind::kValueAndInitBit);
  auto* guard = DataGuard();  // Make sure flag initialized
  (void)guard;
  return absl::bit_cast<FlagValueAndInitBit<bool>>(
             OneWordValue().load(std::memory_order_acquire))
      .value;
}

void FlagImpl::ReadSequenceLockedData(void* dst) const {
  size_t size = Sizeof(op_);
  // Attempt to read using the sequence lock.
  if (ABSL_PREDICT_TRUE(seq_lock_.TryRead(dst, AtomicBufferValue(), size))) {
    return;
  }
  // We failed due to contention. Acquire the lock to prevent contention
  // and try again.
  absl::ReaderMutexLock l(DataGuard());
  bool success = seq_lock_.TryRead(dst, AtomicBufferValue(), size);
  assert(success);
  static_cast<void>(success);
}

void FlagImpl::Write(const void* src) {
  absl::MutexLock l(DataGuard());

  if (ShouldValidateFlagValue(flags_internal::FastTypeId(op_))) {
    std::unique_ptr<void, DynValueDeleter> obj{flags_internal::Clone(op_, src),
                                               DynValueDeleter{op_}};
    std::string ignored_error;
    std::string src_as_str = flags_internal::Unparse(op_, src);
    if (!flags_internal::Parse(op_, src_as_str, obj.get(), &ignored_error)) {
      ABSL_INTERNAL_LOG(ERROR, absl::StrCat("Attempt to set flag '", Name(),
                                            "' to invalid value ", src_as_str));
    }
  }

  StoreValue(src, kProgrammaticChange);
}

// Sets the value of the flag based on specified string `value`. If the flag
// was successfully set to new value, it returns true. Otherwise, sets `err`
// to indicate the error, leaves the flag unchanged, and returns false. There
// are three ways to set the flag's value:
//  * Update the current flag value
//  * Update the flag's default value
//  * Update the current flag value if it was never set before
// The mode is selected based on 'set_mode' parameter.
bool FlagImpl::ParseFrom(absl::string_view value, FlagSettingMode set_mode,
                         ValueSource source, std::string& err) {
  absl::MutexLock l(DataGuard());

  switch (set_mode) {
    case SET_FLAGS_VALUE: {
      // set or modify the flag's value
      auto tentative_value = TryParse(value, err);
      if (!tentative_value) return false;

      StoreValue(tentative_value.get(), source);

      if (source == kCommandLine) {
        on_command_line_ = true;
      }
      break;
    }
    case SET_FLAG_IF_DEFAULT: {
      // set the flag's value, but only if it hasn't been set by someone else
      if (modified_) {
        // TODO(rogeeff): review and fix this semantic. Currently we do not fail
        // in this case if flag is modified. This is misleading since the flag's
        // value is not updated even though we return true.
        // *err = absl::StrCat(Name(), " is already set to ",
        //                     CurrentValue(), "\n");
        // return false;
        return true;
      }
      auto tentative_value = TryParse(value, err);
      if (!tentative_value) return false;

      StoreValue(tentative_value.get(), source);
      break;
    }
    case SET_FLAGS_DEFAULT: {
      auto tentative_value = TryParse(value, err);
      if (!tentative_value) return false;

      if (DefaultKind() == FlagDefaultKind::kDynamicValue) {
        void* old_value = default_value_.dynamic_value;
        default_value_.dynamic_value = tentative_value.release();
        tentative_value.reset(old_value);
      } else {
        default_value_.dynamic_value = tentative_value.release();
        def_kind_ = static_cast<uint8_t>(FlagDefaultKind::kDynamicValue);
      }

      if (!modified_) {
        // Need to set both default value *and* current, in this case.
        StoreValue(default_value_.dynamic_value, source);
        modified_ = false;
      }
      break;
    }
  }

  return true;
}

void FlagImpl::CheckDefaultValueParsingRoundtrip() const {
  std::string v = DefaultValue();

  absl::MutexLock lock(DataGuard());

  auto dst = MakeInitValue();
  std::string error;
  if (!flags_internal::Parse(op_, v, dst.get(), &error)) {
    ABSL_INTERNAL_LOG(
        FATAL,
        absl::StrCat("Flag ", Name(), " (from ", Filename(),
                     "): string form of default value '", v,
                     "' could not be parsed; error=", error));
  }

  // We do not compare dst to def since parsing/unparsing may make
  // small changes, e.g., precision loss for floating point types.
}

bool FlagImpl::ValidateInputValue(absl::string_view value) const {
  absl::MutexLock l(DataGuard());

  auto obj = MakeInitValue();
  std::string ignored_error;
  return flags_internal::Parse(op_, value, obj.get(), &ignored_error);
}

}  // namespace flags_internal
ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/internal/flag.h                               0000664 0000000 0000000 00000106305 14746647661 0025335 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
// Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef ABSL_FLAGS_INTERNAL_FLAG_H_
#define ABSL_FLAGS_INTERNAL_FLAG_H_

#include <stddef.h>
#include <stdint.h>

#include <atomic>
#include <cstring>
#include <memory>
#include <string>
#include <type_traits>
#include <typeinfo>

#include "absl/base/attributes.h"
#include "absl/base/call_once.h"
#include "absl/base/casts.h"
#include "absl/base/config.h"
#include "absl/base/optimization.h"
#include "absl/base/thread_annotations.h"
#include "absl/flags/commandlineflag.h"
#include "absl/flags/config.h"
#include "absl/flags/internal/commandlineflag.h"
#include "absl/flags/internal/registry.h"
#include "absl/flags/internal/sequence_lock.h"
#include "absl/flags/marshalling.h"
#include "absl/meta/type_traits.h"
#include "absl/strings/string_view.h"
#include "absl/synchronization/mutex.h"
#include "absl/utility/utility.h"

namespace absl {
ABSL_NAMESPACE_BEGIN

///////////////////////////////////////////////////////////////////////////////
// Forward declaration of absl::Flag<T> public API.
namespace flags_internal {
template <typename T>
class Flag;
}  // namespace flags_internal

template <typename T>
using Flag = flags_internal::Flag<T>;

template <typename T>
ABSL_MUST_USE_RESULT T GetFlag(const absl::Flag<T>& flag);

template <typename T>
void SetFlag(absl::Flag<T>* flag, const T& v);

template <typename T, typename V>
void SetFlag(absl::Flag<T>* flag, const V& v);

template <typename U>
const CommandLineFlag& GetFlagReflectionHandle(const absl::Flag<U>& f);

///////////////////////////////////////////////////////////////////////////////
// Flag value type operations, eg., parsing, copying, etc. are provided
// by function specific to that type with a signature matching FlagOpFn.

namespace flags_internal {

enum class FlagOp {
  kAlloc,
  kDelete,
  kCopy,
  kCopyConstruct,
  kSizeof,
  kFastTypeId,
  kRuntimeTypeId,
  kParse,
  kUnparse,
  kValueOffset,
};
using FlagOpFn = void* (*)(FlagOp, const void*, void*, void*);

// Forward declaration for Flag value specific operations.
template <typename T>
void* FlagOps(FlagOp op, const void* v1, void* v2, void* v3);

// Allocate aligned memory for a flag value.
inline void* Alloc(FlagOpFn op) {
  return op(FlagOp::kAlloc, nullptr, nullptr, nullptr);
}
// Deletes memory interpreting obj as flag value type pointer.
inline void Delete(FlagOpFn op, void* obj) {
  op(FlagOp::kDelete, nullptr, obj, nullptr);
}
// Copies src to dst interpreting as flag value type pointers.
inline void Copy(FlagOpFn op, const void* src, void* dst) {
  op(FlagOp::kCopy, src, dst, nullptr);
}
// Construct a copy of flag value in a location pointed by dst
// based on src - pointer to the flag's value.
inline void CopyConstruct(FlagOpFn op, const void* src, void* dst) {
  op(FlagOp::kCopyConstruct, src, dst, nullptr);
}
// Makes a copy of flag value pointed by obj.
inline void* Clone(FlagOpFn op, const void* obj) {
  void* res = flags_internal::Alloc(op);
  flags_internal::CopyConstruct(op, obj, res);
  return res;
}
// Returns true if parsing of input text is successful.
inline bool Parse(FlagOpFn op, absl::string_view text, void* dst,
                  std::string* error) {
  return op(FlagOp::kParse, &text, dst, error) != nullptr;
}
// Returns string representing supplied value.
inline std::string Unparse(FlagOpFn op, const void* val) {
  std::string result;
  op(FlagOp::kUnparse, val, &result, nullptr);
  return result;
}
// Returns size of flag value type.
inline size_t Sizeof(FlagOpFn op) {
  // This sequence of casts reverses the sequence from
  // `flags_internal::FlagOps()`
  return static_cast<size_t>(reinterpret_cast<intptr_t>(
      op(FlagOp::kSizeof, nullptr, nullptr, nullptr)));
}
// Returns fast type id corresponding to the value type.
inline FlagFastTypeId FastTypeId(FlagOpFn op) {
  return reinterpret_cast<FlagFastTypeId>(
      op(FlagOp::kFastTypeId, nullptr, nullptr, nullptr));
}
// Returns fast type id corresponding to the value type.
inline const std::type_info* RuntimeTypeId(FlagOpFn op) {
  return reinterpret_cast<const std::type_info*>(
      op(FlagOp::kRuntimeTypeId, nullptr, nullptr, nullptr));
}
// Returns offset of the field value_ from the field impl_ inside of
// absl::Flag<T> data. Given FlagImpl pointer p you can get the
// location of the corresponding value as:
//      reinterpret_cast<char*>(p) + ValueOffset().
inline ptrdiff_t ValueOffset(FlagOpFn op) {
  // This sequence of casts reverses the sequence from
  // `flags_internal::FlagOps()`
  return static_cast<ptrdiff_t>(reinterpret_cast<intptr_t>(
      op(FlagOp::kValueOffset, nullptr, nullptr, nullptr)));
}

// Returns an address of RTTI's typeid(T).
template <typename T>
inline const std::type_info* GenRuntimeTypeId() {
#ifdef ABSL_INTERNAL_HAS_RTTI
  return &typeid(T);
#else
  return nullptr;
#endif
}

///////////////////////////////////////////////////////////////////////////////
// Flag help auxiliary structs.

// This is help argument for absl::Flag encapsulating the string literal pointer
// or pointer to function generating it as well as enum descriminating two
// cases.
using HelpGenFunc = std::string (*)();

template <size_t N>
struct FixedCharArray {
  char value[N];

  template <size_t... I>
  static constexpr FixedCharArray<N> FromLiteralString(
      absl::string_view str, absl::index_sequence<I...>) {
    return (void)str, FixedCharArray<N>({{str[I]..., '\0'}});
  }
};

template <typename Gen, size_t N = Gen::Value().size()>
constexpr FixedCharArray<N + 1> HelpStringAsArray(int) {
  return FixedCharArray<N + 1>::FromLiteralString(
      Gen::Value(), absl::make_index_sequence<N>{});
}

template <typename Gen>
constexpr std::false_type HelpStringAsArray(char) {
  return std::false_type{};
}

union FlagHelpMsg {
  constexpr explicit FlagHelpMsg(const char* help_msg) : literal(help_msg) {}
  constexpr explicit FlagHelpMsg(HelpGenFunc help_gen) : gen_func(help_gen) {}

  const char* literal;
  HelpGenFunc gen_func;
};

enum class FlagHelpKind : uint8_t { kLiteral = 0, kGenFunc = 1 };

struct FlagHelpArg {
  FlagHelpMsg source;
  FlagHelpKind kind;
};

extern const char kStrippedFlagHelp[];

// These two HelpArg overloads allows us to select at compile time one of two
// way to pass Help argument to absl::Flag. We'll be passing
// AbslFlagHelpGenFor##name as Gen and integer 0 as a single argument to prefer
// first overload if possible. If help message is evaluatable on constexpr
// context We'll be able to make FixedCharArray out of it and we'll choose first
// overload. In this case the help message expression is immediately evaluated
// and is used to construct the absl::Flag. No additional code is generated by
// ABSL_FLAG Otherwise SFINAE kicks in and first overload is dropped from the
// consideration, in which case the second overload will be used. The second
// overload does not attempt to evaluate the help message expression
// immediately and instead delays the evaluation by returning the function
// pointer (&T::NonConst) generating the help message when necessary. This is
// evaluatable in constexpr context, but the cost is an extra function being
// generated in the ABSL_FLAG code.
template <typename Gen, size_t N>
constexpr FlagHelpArg HelpArg(const FixedCharArray<N>& value) {
  return {FlagHelpMsg(value.value), FlagHelpKind::kLiteral};
}

template <typename Gen>
constexpr FlagHelpArg HelpArg(std::false_type) {
  return {FlagHelpMsg(&Gen::NonConst), FlagHelpKind::kGenFunc};
}

///////////////////////////////////////////////////////////////////////////////
// Flag default value auxiliary structs.

// Signature for the function generating the initial flag value (usually
// based on default value supplied in flag's definition)
using FlagDfltGenFunc = void (*)(void*);

union FlagDefaultSrc {
  constexpr explicit FlagDefaultSrc(FlagDfltGenFunc gen_func_arg)
      : gen_func(gen_func_arg) {}

#define ABSL_FLAGS_INTERNAL_DFLT_FOR_TYPE(T, name) \
  T name##_value;                                  \
  constexpr explicit FlagDefaultSrc(T value) : name##_value(value) {}  // NOLINT
  ABSL_FLAGS_INTERNAL_BUILTIN_TYPES(ABSL_FLAGS_INTERNAL_DFLT_FOR_TYPE)
#undef ABSL_FLAGS_INTERNAL_DFLT_FOR_TYPE

  void* dynamic_value;
  FlagDfltGenFunc gen_func;
};

enum class FlagDefaultKind : uint8_t {
  kDynamicValue = 0,
  kGenFunc = 1,
  kOneWord = 2  // for default values UP to one word in size
};

struct FlagDefaultArg {
  FlagDefaultSrc source;
  FlagDefaultKind kind;
};

// This struct and corresponding overload to InitDefaultValue are used to
// facilitate usage of {} as default value in ABSL_FLAG macro.
// TODO(rogeeff): Fix handling types with explicit constructors.
struct EmptyBraces {};

template <typename T>
constexpr T InitDefaultValue(T t) {
  return t;
}

template <typename T>
constexpr T InitDefaultValue(EmptyBraces) {
  return T{};
}

template <typename ValueT, typename GenT,
          typename std::enable_if<std::is_integral<ValueT>::value, int>::type =
              ((void)GenT{}, 0)>
constexpr FlagDefaultArg DefaultArg(int) {
  return {FlagDefaultSrc(GenT{}.value), FlagDefaultKind::kOneWord};
}

template <typename ValueT, typename GenT>
constexpr FlagDefaultArg DefaultArg(char) {
  return {FlagDefaultSrc(&GenT::Gen), FlagDefaultKind::kGenFunc};
}

///////////////////////////////////////////////////////////////////////////////
// Flag storage selector traits. Each trait indicates what kind of storage kind
// to use for the flag value.

template <typename T>
using FlagUseValueAndInitBitStorage =
    std::integral_constant<bool, std::is_trivially_copyable<T>::value &&
                                     std::is_default_constructible<T>::value &&
                                     (sizeof(T) < 8)>;

template <typename T>
using FlagUseOneWordStorage =
    std::integral_constant<bool, std::is_trivially_copyable<T>::value &&
                                     (sizeof(T) <= 8)>;

template <class T>
using FlagUseSequenceLockStorage =
    std::integral_constant<bool, std::is_trivially_copyable<T>::value &&
                                     (sizeof(T) > 8)>;

enum class FlagValueStorageKind : uint8_t {
  kValueAndInitBit = 0,
  kOneWordAtomic = 1,
  kSequenceLocked = 2,
  kHeapAllocated = 3,
};

// This constexpr function returns the storage kind for the given flag value
// type.
template <typename T>
static constexpr FlagValueStorageKind StorageKind() {
  return FlagUseValueAndInitBitStorage<T>::value
             ? FlagValueStorageKind::kValueAndInitBit
         : FlagUseOneWordStorage<T>::value
             ? FlagValueStorageKind::kOneWordAtomic
         : FlagUseSequenceLockStorage<T>::value
             ? FlagValueStorageKind::kSequenceLocked
             : FlagValueStorageKind::kHeapAllocated;
}

// This is a base class for the storage classes used by kOneWordAtomic and
// kValueAndInitBit storage kinds. It literally just stores the one word value
// as an atomic. By default, it is initialized to a magic value that is unlikely
// a valid value for the flag value type.
struct FlagOneWordValue {
  constexpr static int64_t Uninitialized() {
    return static_cast<int64_t>(0xababababababababll);
  }

  constexpr FlagOneWordValue() : value(Uninitialized()) {}
  constexpr explicit FlagOneWordValue(int64_t v) : value(v) {}
  std::atomic<int64_t> value;
};

// This class represents a memory layout used by kValueAndInitBit storage kind.
template <typename T>
struct alignas(8) FlagValueAndInitBit {
  T value;
  // Use an int instead of a bool to guarantee that a non-zero value has
  // a bit set.
  uint8_t init;
};

// This class implements an aligned pointer with two options stored via masks
// in unused bits of the pointer value (due to alignment requirement).
//  - IsUnprotectedReadCandidate - indicates that the value can be switched to
//    unprotected read without a lock.
//  - HasBeenRead - indicates that the value has been read at least once.
//  - AllowsUnprotectedRead - combination of the two options above and indicates
//    that the value can now be read without a lock.
// Further details of these options and their use is covered in the description
// of the FlagValue<T, FlagValueStorageKind::kHeapAllocated> specialization.
class MaskedPointer {
 public:
  using mask_t = uintptr_t;
  using ptr_t = void*;

  static constexpr int RequiredAlignment() { return 4; }

  constexpr explicit MaskedPointer(ptr_t rhs) : ptr_(rhs) {}
  MaskedPointer(ptr_t rhs, bool is_candidate);

  void* Ptr() const {
    return reinterpret_cast<void*>(reinterpret_cast<mask_t>(ptr_) &
                                   kPtrValueMask);
  }
  bool AllowsUnprotectedRead() const {
    return (reinterpret_cast<mask_t>(ptr_) & kAllowsUnprotectedRead) ==
           kAllowsUnprotectedRead;
  }
  bool IsUnprotectedReadCandidate() const;
  bool HasBeenRead() const;

  void Set(FlagOpFn op, const void* src, bool is_candidate);
  void MarkAsRead();

 private:
  // Masks
  // Indicates that the flag value either default or originated from command
  // line.
  static constexpr mask_t kUnprotectedReadCandidate = 0x1u;
  // Indicates that flag has been read.
  static constexpr mask_t kHasBeenRead = 0x2u;
  static constexpr mask_t kAllowsUnprotectedRead =
      kUnprotectedReadCandidate | kHasBeenRead;
  static constexpr mask_t kPtrValueMask = ~kAllowsUnprotectedRead;

  void ApplyMask(mask_t mask);
  bool CheckMask(mask_t mask) const;

  ptr_t ptr_;
};

// This class implements a type erased storage of the heap allocated flag value.
// It is used as a base class for the storage class for kHeapAllocated storage
// kind. The initial_buffer is expected to have an alignment of at least
// MaskedPointer::RequiredAlignment(), so that the bits used by the
// MaskedPointer to store masks are set to 0. This guarantees that value starts
// in an uninitialized state.
struct FlagMaskedPointerValue {
  constexpr explicit FlagMaskedPointerValue(MaskedPointer::ptr_t initial_buffer)
      : value(MaskedPointer(initial_buffer)) {}

  std::atomic<MaskedPointer> value;
};

// This is the forward declaration for the template that represents a storage
// for the flag values. This template is expected to be explicitly specialized
// for each storage kind and it does not have a generic default
// implementation.
template <typename T,
          FlagValueStorageKind Kind = flags_internal::StorageKind<T>()>
struct FlagValue;

// This specialization represents the storage of flag values types with the
// kValueAndInitBit storage kind. It is based on the FlagOneWordValue class
// and relies on memory layout in FlagValueAndInitBit<T> to indicate that the
// value has been initialized or not.
template <typename T>
struct FlagValue<T, FlagValueStorageKind::kValueAndInitBit> : FlagOneWordValue {
  constexpr FlagValue() : FlagOneWordValue(0) {}
  bool Get(const SequenceLock&, T& dst) const {
    int64_t storage = value.load(std::memory_order_acquire);
    if (ABSL_PREDICT_FALSE(storage == 0)) {
      // This assert is to ensure that the initialization inside FlagImpl::Init
      // is able to set init member correctly.
      static_assert(offsetof(FlagValueAndInitBit<T>, init) == sizeof(T),
                    "Unexpected memory layout of FlagValueAndInitBit");
      return false;
    }
    dst = absl::bit_cast<FlagValueAndInitBit<T>>(storage).value;
    return true;
  }
};

// This specialization represents the storage of flag values types with the
// kOneWordAtomic storage kind. It is based on the FlagOneWordValue class
// and relies on the magic uninitialized state of default constructed instead of
// FlagOneWordValue to indicate that the value has been initialized or not.
template <typename T>
struct FlagValue<T, FlagValueStorageKind::kOneWordAtomic> : FlagOneWordValue {
  constexpr FlagValue() : FlagOneWordValue() {}
  bool Get(const SequenceLock&, T& dst) const {
    int64_t one_word_val = value.load(std::memory_order_acquire);
    if (ABSL_PREDICT_FALSE(one_word_val == FlagOneWordValue::Uninitialized())) {
      return false;
    }
    std::memcpy(&dst, static_cast<const void*>(&one_word_val), sizeof(T));
    return true;
  }
};

// This specialization represents the storage of flag values types with the
// kSequenceLocked storage kind. This storage is used by trivially copyable
// types with size greater than 8 bytes. This storage relies on uninitialized
// state of the SequenceLock to indicate that the value has been initialized or
// not. This storage also provides lock-free read access to the underlying
// value once it is initialized.
template <typename T>
struct FlagValue<T, FlagValueStorageKind::kSequenceLocked> {
  bool Get(const SequenceLock& lock, T& dst) const {
    return lock.TryRead(&dst, value_words, sizeof(T));
  }

  static constexpr int kNumWords =
      flags_internal::AlignUp(sizeof(T), sizeof(uint64_t)) / sizeof(uint64_t);

  alignas(T) alignas(
      std::atomic<uint64_t>) std::atomic<uint64_t> value_words[kNumWords];
};

// This specialization represents the storage of flag values types with the
// kHeapAllocated storage kind. This is a storage of last resort and is used
// if none of other storage kinds are applicable.
//
// Generally speaking the values with this storage kind can't be accessed
// atomically and thus can't be read without holding a lock. If we would ever
// want to avoid the lock, we'd need to leak the old value every time new flag
// value is being set (since we are in danger of having a race condition
// otherwise).
//
// Instead of doing that, this implementation attempts to cater to some common
// use cases by allowing at most 2 values to be leaked - default value and
// value set from the command line.
//
// This specialization provides an initial buffer for the first flag value. This
// is where the default value is going to be stored. We attempt to reuse this
// buffer if possible, including storing the value set from the command line
// there.
//
// As long as we only read this value, we can access it without a lock (in
// practice we still use the lock for the very first read to be able set
// "has been read" option on this flag).
//
// If flag is specified on the command line we store the parsed value either
// in the internal buffer (if the default value never been read) or we leak the
// default value and allocate the new storage for the parse value. This value is
// also a candidate for an unprotected read. If flag is set programmatically
// after the command line is parsed, the storage for this value is going to be
// leaked. Note that in both scenarios we are not going to have a real leak.
// Instead we'll store the leaked value pointers in the internal freelist to
// avoid triggering the memory leak checker complains.
//
// If the flag is ever set programmatically, it stops being the candidate for an
// unprotected read, and any follow up access to the flag value requires a lock.
// Note that if the value if set programmatically before the command line is
// parsed, we can switch back to enabling unprotected reads for that value.
template <typename T>
struct FlagValue<T, FlagValueStorageKind::kHeapAllocated>
    : FlagMaskedPointerValue {
  // We const initialize the value with unmasked pointer to the internal buffer,
  // making sure it is not a candidate for unprotected read. This way we can
  // ensure Init is done before any access to the flag value.
  constexpr FlagValue() : FlagMaskedPointerValue(&buffer[0]) {}

  bool Get(const SequenceLock&, T& dst) const {
    MaskedPointer ptr_value = value.load(std::memory_order_acquire);

    if (ABSL_PREDICT_TRUE(ptr_value.AllowsUnprotectedRead())) {
      ::new (static_cast<void*>(&dst)) T(*static_cast<T*>(ptr_value.Ptr()));
      return true;
    }
    return false;
  }

  alignas(MaskedPointer::RequiredAlignment()) alignas(
      T) char buffer[sizeof(T)]{};
};

///////////////////////////////////////////////////////////////////////////////
// Flag callback auxiliary structs.

// Signature for the mutation callback used by watched Flags
// The callback is noexcept.
// TODO(rogeeff): add noexcept after C++17 support is added.
using FlagCallbackFunc = void (*)();

struct FlagCallback {
  FlagCallbackFunc func;
  absl::Mutex guard;  // Guard for concurrent callback invocations.
};

///////////////////////////////////////////////////////////////////////////////
// Flag implementation, which does not depend on flag value type.
// The class encapsulates the Flag's data and access to it.

struct DynValueDeleter {
  explicit DynValueDeleter(FlagOpFn op_arg = nullptr);
  void operator()(void* ptr) const;

  FlagOpFn op;
};

class FlagState;

// These are only used as constexpr global objects.
// They do not use a virtual destructor to simplify their implementation.
// They are not destroyed except at program exit, so leaks do not matter.
#if defined(__GNUC__) && !defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wnon-virtual-dtor"
#endif
class FlagImpl final : public CommandLineFlag {
 public:
  constexpr FlagImpl(const char* name, const char* filename, FlagOpFn op,
                     FlagHelpArg help, FlagValueStorageKind value_kind,
                     FlagDefaultArg default_arg)
      : name_(name),
        filename_(filename),
        op_(op),
        help_(help.source),
        help_source_kind_(static_cast<uint8_t>(help.kind)),
        value_storage_kind_(static_cast<uint8_t>(value_kind)),
        def_kind_(static_cast<uint8_t>(default_arg.kind)),
        modified_(false),
        on_command_line_(false),
        callback_(nullptr),
        default_value_(default_arg.source),
        data_guard_{} {}

  // Constant access methods
  int64_t ReadOneWord() const ABSL_LOCKS_EXCLUDED(*DataGuard());
  bool ReadOneBool() const ABSL_LOCKS_EXCLUDED(*DataGuard());
  void Read(void* dst) const override ABSL_LOCKS_EXCLUDED(*DataGuard());
  void Read(bool* value) const ABSL_LOCKS_EXCLUDED(*DataGuard()) {
    *value = ReadOneBool();
  }
  template <typename T,
            absl::enable_if_t<flags_internal::StorageKind<T>() ==
                                  FlagValueStorageKind::kOneWordAtomic,
                              int> = 0>
  void Read(T* value) const ABSL_LOCKS_EXCLUDED(*DataGuard()) {
    int64_t v = ReadOneWord();
    std::memcpy(value, static_cast<const void*>(&v), sizeof(T));
  }
  template <typename T,
            typename std::enable_if<flags_internal::StorageKind<T>() ==
                                        FlagValueStorageKind::kValueAndInitBit,
                                    int>::type = 0>
  void Read(T* value) const ABSL_LOCKS_EXCLUDED(*DataGuard()) {
    *value = absl::bit_cast<FlagValueAndInitBit<T>>(ReadOneWord()).value;
  }

  // Mutating access methods
  void Write(const void* src) ABSL_LOCKS_EXCLUDED(*DataGuard());

  // Interfaces to operate on callbacks.
  void SetCallback(const FlagCallbackFunc mutation_callback)
      ABSL_LOCKS_EXCLUDED(*DataGuard());
  void InvokeCallback() const ABSL_EXCLUSIVE_LOCKS_REQUIRED(*DataGuard());

  // Used in read/write operations to validate source/target has correct type.
  // For example if flag is declared as absl::Flag<int> FLAGS_foo, a call to
  // absl::GetFlag(FLAGS_foo) validates that the type of FLAGS_foo is indeed
  // int. To do that we pass the assumed type id (which is deduced from type
  // int) as an argument `type_id`, which is in turn is validated against the
  // type id stored in flag object by flag definition statement.
  void AssertValidType(FlagFastTypeId type_id,
                       const std::type_info* (*gen_rtti)()) const;

 private:
  template <typename T>
  friend class Flag;
  friend class FlagState;

  // Ensures that `data_guard_` is initialized and returns it.
  absl::Mutex* DataGuard() const
      ABSL_LOCK_RETURNED(reinterpret_cast<absl::Mutex*>(data_guard_));
  // Returns heap allocated value of type T initialized with default value.
  std::unique_ptr<void, DynValueDeleter> MakeInitValue() const
      ABSL_EXCLUSIVE_LOCKS_REQUIRED(*DataGuard());
  // Flag initialization called via absl::call_once.
  void Init();

  // Offset value access methods. One per storage kind. These methods to not
  // respect const correctness, so be very careful using them.

  // This is a shared helper routine which encapsulates most of the magic. Since
  // it is only used inside the three routines below, which are defined in
  // flag.cc, we can define it in that file as well.
  template <typename StorageT>
  StorageT* OffsetValue() const;

  // The same as above, but used for sequencelock-protected storage.
  std::atomic<uint64_t>* AtomicBufferValue() const;

  // This is an accessor for a value stored as one word atomic. Returns a
  // mutable reference to an atomic value.
  std::atomic<int64_t>& OneWordValue() const;

  std::atomic<MaskedPointer>& PtrStorage() const;

  // Attempts to parse supplied `value` string. If parsing is successful,
  // returns new value. Otherwise returns nullptr.
  std::unique_ptr<void, DynValueDeleter> TryParse(absl::string_view value,
                                                  std::string& err) const
      ABSL_EXCLUSIVE_LOCKS_REQUIRED(*DataGuard());
  // Stores the flag value based on the pointer to the source.
  void StoreValue(const void* src, ValueSource source)
      ABSL_EXCLUSIVE_LOCKS_REQUIRED(*DataGuard());

  // Copy the flag data, protected by `seq_lock_` into `dst`.
  //
  // REQUIRES: ValueStorageKind() == kSequenceLocked.
  void ReadSequenceLockedData(void* dst) const
      ABSL_LOCKS_EXCLUDED(*DataGuard());

  FlagHelpKind HelpSourceKind() const {
    return static_cast<FlagHelpKind>(help_source_kind_);
  }
  FlagValueStorageKind ValueStorageKind() const {
    return static_cast<FlagValueStorageKind>(value_storage_kind_);
  }
  FlagDefaultKind DefaultKind() const
      ABSL_EXCLUSIVE_LOCKS_REQUIRED(*DataGuard()) {
    return static_cast<FlagDefaultKind>(def_kind_);
  }

  // CommandLineFlag interface implementation
  absl::string_view Name() const override;
  std::string Filename() const override;
  std::string Help() const override;
  FlagFastTypeId TypeId() const override;
  bool IsSpecifiedOnCommandLine() const override
      ABSL_LOCKS_EXCLUDED(*DataGuard());
  std::string DefaultValue() const override ABSL_LOCKS_EXCLUDED(*DataGuard());
  std::string CurrentValue() const override ABSL_LOCKS_EXCLUDED(*DataGuard());
  bool ValidateInputValue(absl::string_view value) const override
      ABSL_LOCKS_EXCLUDED(*DataGuard());
  void CheckDefaultValueParsingRoundtrip() const override
      ABSL_LOCKS_EXCLUDED(*DataGuard());

  int64_t ModificationCount() const ABSL_EXCLUSIVE_LOCKS_REQUIRED(*DataGuard());

  // Interfaces to save and restore flags to/from persistent state.
  // Returns current flag state or nullptr if flag does not support
  // saving and restoring a state.
  std::unique_ptr<FlagStateInterface> SaveState() override
      ABSL_LOCKS_EXCLUDED(*DataGuard());

  // Restores the flag state to the supplied state object. If there is
  // nothing to restore returns false. Otherwise returns true.
  bool RestoreState(const FlagState& flag_state)
      ABSL_LOCKS_EXCLUDED(*DataGuard());

  bool ParseFrom(absl::string_view value, FlagSettingMode set_mode,
                 ValueSource source, std::string& error) override
      ABSL_LOCKS_EXCLUDED(*DataGuard());

  // Immutable flag's state.

  // Flags name passed to ABSL_FLAG as second arg.
  const char* const name_;
  // The file name where ABSL_FLAG resides.
  const char* const filename_;
  // Type-specific operations vtable.
  const FlagOpFn op_;
  // Help message literal or function to generate it.
  const FlagHelpMsg help_;
  // Indicates if help message was supplied as literal or generator func.
  const uint8_t help_source_kind_ : 1;
  // Kind of storage this flag is using for the flag's value.
  const uint8_t value_storage_kind_ : 2;

  uint8_t : 0;  // The bytes containing the const bitfields must not be
                // shared with bytes containing the mutable bitfields.

  // Mutable flag's state (guarded by `data_guard_`).

  // def_kind_ is not guard by DataGuard() since it is accessed in Init without
  // locks.
  uint8_t def_kind_ : 2;
  // Has this flag's value been modified?
  bool modified_ : 1 ABSL_GUARDED_BY(*DataGuard());
  // Has this flag been specified on command line.
  bool on_command_line_ : 1 ABSL_GUARDED_BY(*DataGuard());

  // Unique tag for absl::call_once call to initialize this flag.
  absl::once_flag init_control_;

  // Sequence lock / mutation counter.
  flags_internal::SequenceLock seq_lock_;

  // Optional flag's callback and absl::Mutex to guard the invocations.
  FlagCallback* callback_ ABSL_GUARDED_BY(*DataGuard());
  // Either a pointer to the function generating the default value based on the
  // value specified in ABSL_FLAG or pointer to the dynamically set default
  // value via SetCommandLineOptionWithMode. def_kind_ is used to distinguish
  // these two cases.
  FlagDefaultSrc default_value_;

  // This is reserved space for an absl::Mutex to guard flag data. It will be
  // initialized in FlagImpl::Init via placement new.
  // We can't use "absl::Mutex data_guard_", since this class is not literal.
  // We do not want to use "absl::Mutex* data_guard_", since this would require
  // heap allocation during initialization, which is both slows program startup
  // and can fail. Using reserved space + placement new allows us to avoid both
  // problems.
  alignas(absl::Mutex) mutable char data_guard_[sizeof(absl::Mutex)];
};
#if defined(__GNUC__) && !defined(__clang__)
#pragma GCC diagnostic pop
#endif

///////////////////////////////////////////////////////////////////////////////
// The Flag object parameterized by the flag's value type. This class implements
// flag reflection handle interface.

template <typename T>
class Flag {
 public:
  constexpr Flag(const char* name, const char* filename, FlagHelpArg help,
                 const FlagDefaultArg default_arg)
      : impl_(name, filename, &FlagOps<T>, help,
              flags_internal::StorageKind<T>(), default_arg),
        value_() {}

  // CommandLineFlag interface
  absl::string_view Name() const { return impl_.Name(); }
  std::string Filename() const { return impl_.Filename(); }
  std::string Help() const { return impl_.Help(); }
  // Do not use. To be removed.
  bool IsSpecifiedOnCommandLine() const {
    return impl_.IsSpecifiedOnCommandLine();
  }
  std::string DefaultValue() const { return impl_.DefaultValue(); }
  std::string CurrentValue() const { return impl_.CurrentValue(); }

 private:
  template <typename, bool>
  friend class FlagRegistrar;
  friend class FlagImplPeer;

  T Get() const {
    // See implementation notes in CommandLineFlag::Get().
    union U {
      T value;
      U() {}
      ~U() { value.~T(); }
    };
    U u;

#if !defined(NDEBUG)
    impl_.AssertValidType(base_internal::FastTypeId<T>(), &GenRuntimeTypeId<T>);
#endif

    if (ABSL_PREDICT_FALSE(!value_.Get(impl_.seq_lock_, u.value))) {
      impl_.Read(&u.value);
    }
    return std::move(u.value);
  }
  void Set(const T& v) {
    impl_.AssertValidType(base_internal::FastTypeId<T>(), &GenRuntimeTypeId<T>);
    impl_.Write(&v);
  }

  // Access to the reflection.
  const CommandLineFlag& Reflect() const { return impl_; }

  // Flag's data
  // The implementation depends on value_ field to be placed exactly after the
  // impl_ field, so that impl_ can figure out the offset to the value and
  // access it.
  FlagImpl impl_;
  FlagValue<T> value_;
};

///////////////////////////////////////////////////////////////////////////////
// Trampoline for friend access

class FlagImplPeer {
 public:
  template <typename T, typename FlagType>
  static T InvokeGet(const FlagType& flag) {
    return flag.Get();
  }
  template <typename FlagType, typename T>
  static void InvokeSet(FlagType& flag, const T& v) {
    flag.Set(v);
  }
  template <typename FlagType>
  static const CommandLineFlag& InvokeReflect(const FlagType& f) {
    return f.Reflect();
  }
};

///////////////////////////////////////////////////////////////////////////////
// Implementation of Flag value specific operations routine.
template <typename T>
void* FlagOps(FlagOp op, const void* v1, void* v2, void* v3) {
  struct AlignedSpace {
    alignas(MaskedPointer::RequiredAlignment()) alignas(T) char buf[sizeof(T)];
  };
  using Allocator = std::allocator<AlignedSpace>;
  switch (op) {
    case FlagOp::kAlloc: {
      Allocator alloc;
      return std::allocator_traits<Allocator>::allocate(alloc, 1);
    }
    case FlagOp::kDelete: {
      T* p = static_cast<T*>(v2);
      p->~T();
      Allocator alloc;
      std::allocator_traits<Allocator>::deallocate(
          alloc, reinterpret_cast<AlignedSpace*>(p), 1);
      return nullptr;
    }
    case FlagOp::kCopy:
      *static_cast<T*>(v2) = *static_cast<const T*>(v1);
      return nullptr;
    case FlagOp::kCopyConstruct:
      new (v2) T(*static_cast<const T*>(v1));
      return nullptr;
    case FlagOp::kSizeof:
      return reinterpret_cast<void*>(static_cast<uintptr_t>(sizeof(T)));
    case FlagOp::kFastTypeId:
      return const_cast<void*>(base_internal::FastTypeId<T>());
    case FlagOp::kRuntimeTypeId:
      return const_cast<std::type_info*>(GenRuntimeTypeId<T>());
    case FlagOp::kParse: {
      // Initialize the temporary instance of type T based on current value in
      // destination (which is going to be flag's default value).
      T temp(*static_cast<T*>(v2));
      if (!absl::ParseFlag<T>(*static_cast<const absl::string_view*>(v1), &temp,
                              static_cast<std::string*>(v3))) {
        return nullptr;
      }
      *static_cast<T*>(v2) = std::move(temp);
      return v2;
    }
    case FlagOp::kUnparse:
      *static_cast<std::string*>(v2) =
          absl::UnparseFlag<T>(*static_cast<const T*>(v1));
      return nullptr;
    case FlagOp::kValueOffset: {
      // Round sizeof(FlagImp) to a multiple of alignof(FlagValue<T>) to get the
      // offset of the data.
      size_t round_to = alignof(FlagValue<T>);
      size_t offset = (sizeof(FlagImpl) + round_to - 1) / round_to * round_to;
      return reinterpret_cast<void*>(offset);
    }
  }
  return nullptr;
}

///////////////////////////////////////////////////////////////////////////////
// This class facilitates Flag object registration and tail expression-based
// flag definition, for example:
// ABSL_FLAG(int, foo, 42, "Foo help").OnUpdate(NotifyFooWatcher);
struct FlagRegistrarEmpty {};
template <typename T, bool do_register>
class FlagRegistrar {
 public:
  constexpr explicit FlagRegistrar(Flag<T>& flag, const char* filename)
      : flag_(flag) {
    if (do_register)
      flags_internal::RegisterCommandLineFlag(flag_.impl_, filename);
  }

  FlagRegistrar OnUpdate(FlagCallbackFunc cb) && {
    flag_.impl_.SetCallback(cb);
    return *this;
  }

  // Makes the registrar die gracefully as an empty struct on a line where
  // registration happens. Registrar objects are intended to live only as
  // temporary.
  constexpr operator FlagRegistrarEmpty() const { return {}; }  // NOLINT

 private:
  Flag<T>& flag_;  // Flag being registered (not owned).
};

///////////////////////////////////////////////////////////////////////////////
// Test only API
uint64_t NumLeakedFlagValues();

}  // namespace flags_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_FLAGS_INTERNAL_FLAG_H_
                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/internal/parse.h                              0000664 0000000 0000000 00000004604 14746647661 0025535 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
// Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef ABSL_FLAGS_INTERNAL_PARSE_H_
#define ABSL_FLAGS_INTERNAL_PARSE_H_

#include <iostream>
#include <ostream>
#include <string>
#include <vector>

#include "absl/base/config.h"
#include "absl/flags/declare.h"
#include "absl/flags/internal/usage.h"
#include "absl/strings/string_view.h"

ABSL_DECLARE_FLAG(std::vector<std::string>, flagfile);
ABSL_DECLARE_FLAG(std::vector<std::string>, fromenv);
ABSL_DECLARE_FLAG(std::vector<std::string>, tryfromenv);
ABSL_DECLARE_FLAG(std::vector<std::string>, undefok);

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace flags_internal {

enum class UsageFlagsAction { kHandleUsage, kIgnoreUsage };
enum class OnUndefinedFlag {
  kIgnoreUndefined,
  kReportUndefined,
  kAbortIfUndefined
};

// This is not a public interface. This interface exists to expose the ability
// to change help output stream in case of parsing errors. This is used by
// internal unit tests to validate expected outputs.
// When this was written, `EXPECT_EXIT` only supported matchers on stderr,
// but not on stdout.
std::vector<char*> ParseCommandLineImpl(
    int argc, char* argv[], UsageFlagsAction usage_flag_action,
    OnUndefinedFlag undef_flag_action,
    std::ostream& error_help_output = std::cout);

// --------------------------------------------------------------------
// Inspect original command line

// Returns true if flag with specified name was either present on the original
// command line or specified in flag file present on the original command line.
bool WasPresentOnCommandLine(absl::string_view flag_name);

// Return existing flags similar to the parameter, in order to help in case of
// misspellings.
std::vector<std::string> GetMisspellingHints(absl::string_view flag);

}  // namespace flags_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_FLAGS_INTERNAL_PARSE_H_
                                                                                                                            node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/internal/path_util.h                          0000664 0000000 0000000 00000004105 14746647661 0026410 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
//  Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef ABSL_FLAGS_INTERNAL_PATH_UTIL_H_
#define ABSL_FLAGS_INTERNAL_PATH_UTIL_H_

#include "absl/base/config.h"
#include "absl/strings/string_view.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace flags_internal {

// A portable interface that returns the basename of the filename passed as an
// argument. It is similar to basename(3)
// <https://linux.die.net/man/3/basename>.
// For example:
//     flags_internal::Basename("a/b/prog/file.cc")
// returns "file.cc"
//     flags_internal::Basename("file.cc")
// returns "file.cc"
inline absl::string_view Basename(absl::string_view filename) {
  auto last_slash_pos = filename.find_last_of("/\\");

  return last_slash_pos == absl::string_view::npos
             ? filename
             : filename.substr(last_slash_pos + 1);
}

// A portable interface that returns the directory name of the filename
// passed as an argument, including the trailing slash.
// Returns the empty string if a slash is not found in the input file name.
// For example:
//      flags_internal::Package("a/b/prog/file.cc")
// returns "a/b/prog/"
//      flags_internal::Package("file.cc")
// returns ""
inline absl::string_view Package(absl::string_view filename) {
  auto last_slash_pos = filename.find_last_of("/\\");

  return last_slash_pos == absl::string_view::npos
             ? absl::string_view()
             : filename.substr(0, last_slash_pos + 1);
}

}  // namespace flags_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_FLAGS_INTERNAL_PATH_UTIL_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/internal/path_util_test.cc                    0000664 0000000 0000000 00000003205 14746647661 0027605 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
//  Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/flags/internal/path_util.h"

#include "gtest/gtest.h"

namespace {

namespace flags = absl::flags_internal;

TEST(FlagsPathUtilTest, TestBasename) {
  EXPECT_EQ(flags::Basename(""), "");
  EXPECT_EQ(flags::Basename("a.cc"), "a.cc");
  EXPECT_EQ(flags::Basename("dir/a.cc"), "a.cc");
  EXPECT_EQ(flags::Basename("dir1/dir2/a.cc"), "a.cc");
  EXPECT_EQ(flags::Basename("../dir1/dir2/a.cc"), "a.cc");
  EXPECT_EQ(flags::Basename("/dir1/dir2/a.cc"), "a.cc");
  EXPECT_EQ(flags::Basename("/dir1/dir2/../dir3/a.cc"), "a.cc");
}

// --------------------------------------------------------------------

TEST(FlagsPathUtilTest, TestPackage) {
  EXPECT_EQ(flags::Package(""), "");
  EXPECT_EQ(flags::Package("a.cc"), "");
  EXPECT_EQ(flags::Package("dir/a.cc"), "dir/");
  EXPECT_EQ(flags::Package("dir1/dir2/a.cc"), "dir1/dir2/");
  EXPECT_EQ(flags::Package("../dir1/dir2/a.cc"), "../dir1/dir2/");
  EXPECT_EQ(flags::Package("/dir1/dir2/a.cc"), "/dir1/dir2/");
  EXPECT_EQ(flags::Package("/dir1/dir2/../dir3/a.cc"), "/dir1/dir2/../dir3/");
}

}  // namespace
                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/internal/private_handle_accessor.cc           0000664 0000000 0000000 00000004060 14746647661 0031424 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
// Copyright 2020 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/flags/internal/private_handle_accessor.h"

#include <memory>
#include <string>

#include "absl/base/config.h"
#include "absl/flags/commandlineflag.h"
#include "absl/flags/internal/commandlineflag.h"
#include "absl/strings/string_view.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace flags_internal {

FlagFastTypeId PrivateHandleAccessor::TypeId(const CommandLineFlag& flag) {
  return flag.TypeId();
}

std::unique_ptr<FlagStateInterface> PrivateHandleAccessor::SaveState(
    CommandLineFlag& flag) {
  return flag.SaveState();
}

bool PrivateHandleAccessor::IsSpecifiedOnCommandLine(
    const CommandLineFlag& flag) {
  return flag.IsSpecifiedOnCommandLine();
}

bool PrivateHandleAccessor::ValidateInputValue(const CommandLineFlag& flag,
                                               absl::string_view value) {
  return flag.ValidateInputValue(value);
}

void PrivateHandleAccessor::CheckDefaultValueParsingRoundtrip(
    const CommandLineFlag& flag) {
  flag.CheckDefaultValueParsingRoundtrip();
}

bool PrivateHandleAccessor::ParseFrom(CommandLineFlag& flag,
                                      absl::string_view value,
                                      flags_internal::FlagSettingMode set_mode,
                                      flags_internal::ValueSource source,
                                      std::string& error) {
  return flag.ParseFrom(value, set_mode, source, error);
}

}  // namespace flags_internal
ABSL_NAMESPACE_END
}  // namespace absl

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/internal/private_handle_accessor.h            0000664 0000000 0000000 00000004261 14746647661 0031271 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
// Copyright 2020 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef ABSL_FLAGS_INTERNAL_PRIVATE_HANDLE_ACCESSOR_H_
#define ABSL_FLAGS_INTERNAL_PRIVATE_HANDLE_ACCESSOR_H_

#include <memory>
#include <string>

#include "absl/base/config.h"
#include "absl/flags/commandlineflag.h"
#include "absl/flags/internal/commandlineflag.h"
#include "absl/strings/string_view.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace flags_internal {

// This class serves as a trampoline to access private methods of
// CommandLineFlag. This class is intended for use exclusively internally inside
// of the Abseil Flags implementation.
class PrivateHandleAccessor {
 public:
  // Access to CommandLineFlag::TypeId.
  static FlagFastTypeId TypeId(const CommandLineFlag& flag);

  // Access to CommandLineFlag::SaveState.
  static std::unique_ptr<FlagStateInterface> SaveState(CommandLineFlag& flag);

  // Access to CommandLineFlag::IsSpecifiedOnCommandLine.
  static bool IsSpecifiedOnCommandLine(const CommandLineFlag& flag);

  // Access to CommandLineFlag::ValidateInputValue.
  static bool ValidateInputValue(const CommandLineFlag& flag,
                                 absl::string_view value);

  // Access to CommandLineFlag::CheckDefaultValueParsingRoundtrip.
  static void CheckDefaultValueParsingRoundtrip(const CommandLineFlag& flag);

  static bool ParseFrom(CommandLineFlag& flag, absl::string_view value,
                        flags_internal::FlagSettingMode set_mode,
                        flags_internal::ValueSource source, std::string& error);
};

}  // namespace flags_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_FLAGS_INTERNAL_PRIVATE_HANDLE_ACCESSOR_H_
                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/internal/program_name.cc                      0000664 0000000 0000000 00000003456 14746647661 0027234 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
//  Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/flags/internal/program_name.h"

#include <string>

#include "absl/base/attributes.h"
#include "absl/base/config.h"
#include "absl/base/const_init.h"
#include "absl/base/thread_annotations.h"
#include "absl/flags/internal/path_util.h"
#include "absl/strings/string_view.h"
#include "absl/synchronization/mutex.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace flags_internal {

ABSL_CONST_INIT static absl::Mutex program_name_guard(absl::kConstInit);
ABSL_CONST_INIT static std::string* program_name
    ABSL_GUARDED_BY(program_name_guard) = nullptr;

std::string ProgramInvocationName() {
  absl::MutexLock l(&program_name_guard);

  return program_name ? *program_name : "UNKNOWN";
}

std::string ShortProgramInvocationName() {
  absl::MutexLock l(&program_name_guard);

  return program_name ? std::string(flags_internal::Basename(*program_name))
                      : "UNKNOWN";
}

void SetProgramInvocationName(absl::string_view prog_name_str) {
  absl::MutexLock l(&program_name_guard);

  if (!program_name)
    program_name = new std::string(prog_name_str);
  else
    program_name->assign(prog_name_str.data(), prog_name_str.size());
}

}  // namespace flags_internal
ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                  node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/internal/program_name.h                       0000664 0000000 0000000 00000003234 14746647661 0027070 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
//  Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef ABSL_FLAGS_INTERNAL_PROGRAM_NAME_H_
#define ABSL_FLAGS_INTERNAL_PROGRAM_NAME_H_

#include <string>

#include "absl/base/config.h"
#include "absl/strings/string_view.h"

// --------------------------------------------------------------------
// Program name

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace flags_internal {

// Returns program invocation name or "UNKNOWN" if `SetProgramInvocationName()`
// is never called. At the moment this is always set to argv[0] as part of
// library initialization.
std::string ProgramInvocationName();

// Returns base name for program invocation name. For example, if
//   ProgramInvocationName() == "a/b/mybinary"
// then
//   ShortProgramInvocationName() == "mybinary"
std::string ShortProgramInvocationName();

// Sets program invocation name to a new value. Should only be called once
// during program initialization, before any threads are spawned.
void SetProgramInvocationName(absl::string_view prog_name_str);

}  // namespace flags_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_FLAGS_INTERNAL_PROGRAM_NAME_H_
                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/internal/program_name_test.cc                 0000664 0000000 0000000 00000004036 14746647661 0030266 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
//  Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/flags/internal/program_name.h"

#include <string>

#include "gtest/gtest.h"
#include "absl/strings/match.h"
#include "absl/strings/string_view.h"

namespace {

namespace flags = absl::flags_internal;

TEST(FlagsPathUtilTest, TestProgamNameInterfaces) {
  flags::SetProgramInvocationName("absl/flags/program_name_test");
  std::string program_name = flags::ProgramInvocationName();
  for (char& c : program_name)
    if (c == '\\') c = '/';

#if !defined(__wasm__) && !defined(__asmjs__)
  const std::string expect_name = "absl/flags/program_name_test";
  const std::string expect_basename = "program_name_test";
#else
  // For targets that generate javascript or webassembly the invocation name
  // has the special value below.
  const std::string expect_name = "this.program";
  const std::string expect_basename = "this.program";
#endif

  EXPECT_TRUE(absl::EndsWith(program_name, expect_name)) << program_name;
  EXPECT_EQ(flags::ShortProgramInvocationName(), expect_basename);

  flags::SetProgramInvocationName("a/my_test");

  EXPECT_EQ(flags::ProgramInvocationName(), "a/my_test");
  EXPECT_EQ(flags::ShortProgramInvocationName(), "my_test");

  absl::string_view not_null_terminated("absl/aaa/bbb");
  not_null_terminated = not_null_terminated.substr(1, 10);

  flags::SetProgramInvocationName(not_null_terminated);

  EXPECT_EQ(flags::ProgramInvocationName(), "bsl/aaa/bb");
  EXPECT_EQ(flags::ShortProgramInvocationName(), "bb");
}

}  // namespace
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/internal/registry.h                           0000664 0000000 0000000 00000007107 14746647661 0026274 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
// Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef ABSL_FLAGS_INTERNAL_REGISTRY_H_
#define ABSL_FLAGS_INTERNAL_REGISTRY_H_

#include <functional>

#include "absl/base/config.h"
#include "absl/flags/commandlineflag.h"
#include "absl/flags/internal/commandlineflag.h"
#include "absl/strings/string_view.h"

// --------------------------------------------------------------------
// Global flags registry API.

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace flags_internal {

// Executes specified visitor for each non-retired flag in the registry. While
// callback are executed, the registry is locked and can't be changed.
void ForEachFlag(std::function<void(CommandLineFlag&)> visitor);

//-----------------------------------------------------------------------------

bool RegisterCommandLineFlag(CommandLineFlag&, const char* filename);

void FinalizeRegistry();

//-----------------------------------------------------------------------------
// Retired registrations:
//
// Retired flag registrations are treated specially. A 'retired' flag is
// provided only for compatibility with automated invocations that still
// name it.  A 'retired' flag:
//   - is not bound to a C++ FLAGS_ reference.
//   - has a type and a value, but that value is intentionally inaccessible.
//   - does not appear in --help messages.
//   - is fully supported by _all_ flag parsing routines.
//   - consumes args normally, and complains about type mismatches in its
//     argument.
//   - emits a complaint but does not die (e.g. LOG(ERROR)) if it is
//     accessed by name through the flags API for parsing or otherwise.
//
// The registrations for a flag happen in an unspecified order as the
// initializers for the namespace-scope objects of a program are run.
// Any number of weak registrations for a flag can weakly define the flag.
// One non-weak registration will upgrade the flag from weak to non-weak.
// Further weak registrations of a non-weak flag are ignored.
//
// This mechanism is designed to support moving dead flags into a
// 'graveyard' library.  An example migration:
//
//   0: Remove references to this FLAGS_flagname in the C++ codebase.
//   1: Register as 'retired' in old_lib.
//   2: Make old_lib depend on graveyard.
//   3: Add a redundant 'retired' registration to graveyard.
//   4: Remove the old_lib 'retired' registration.
//   5: Eventually delete the graveyard registration entirely.
//

// Retire flag with name "name" and type indicated by ops.
void Retire(const char* name, FlagFastTypeId type_id, char* buf);

constexpr size_t kRetiredFlagObjSize = 3 * sizeof(void*);
constexpr size_t kRetiredFlagObjAlignment = alignof(void*);

// Registered a retired flag with name 'flag_name' and type 'T'.
template <typename T>
class RetiredFlag {
 public:
  void Retire(const char* flag_name) {
    flags_internal::Retire(flag_name, base_internal::FastTypeId<T>(), buf_);
  }

 private:
  alignas(kRetiredFlagObjAlignment) char buf_[kRetiredFlagObjSize];
};

}  // namespace flags_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_FLAGS_INTERNAL_REGISTRY_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/internal/sequence_lock.h                      0000664 0000000 0000000 00000017014 14746647661 0027242 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
// Copyright 2020 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef ABSL_FLAGS_INTERNAL_SEQUENCE_LOCK_H_
#define ABSL_FLAGS_INTERNAL_SEQUENCE_LOCK_H_

#include <stddef.h>
#include <stdint.h>

#include <atomic>
#include <cassert>
#include <cstring>

#include "absl/base/optimization.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace flags_internal {

// Align 'x' up to the nearest 'align' bytes.
inline constexpr size_t AlignUp(size_t x, size_t align) {
  return align * ((x + align - 1) / align);
}

// A SequenceLock implements lock-free reads. A sequence counter is incremented
// before and after each write, and readers access the counter before and after
// accessing the protected data. If the counter is verified to not change during
// the access, and the sequence counter value was even, then the reader knows
// that the read was race-free and valid. Otherwise, the reader must fall back
// to a Mutex-based code path.
//
// This particular SequenceLock starts in an "uninitialized" state in which
// TryRead() returns false. It must be enabled by calling MarkInitialized().
// This serves as a marker that the associated flag value has not yet been
// initialized and a slow path needs to be taken.
//
// The memory reads and writes protected by this lock must use the provided
// `TryRead()` and `Write()` functions. These functions behave similarly to
// `memcpy()`, with one oddity: the protected data must be an array of
// `std::atomic<uint64>`. This is to comply with the C++ standard, which
// considers data races on non-atomic objects to be undefined behavior. See "Can
// Seqlocks Get Along With Programming Language Memory Models?"[1] by Hans J.
// Boehm for more details.
//
// [1] https://www.hpl.hp.com/techreports/2012/HPL-2012-68.pdf
class SequenceLock {
 public:
  constexpr SequenceLock() : lock_(kUninitialized) {}

  // Mark that this lock is ready for use.
  void MarkInitialized() {
    assert(lock_.load(std::memory_order_relaxed) == kUninitialized);
    lock_.store(0, std::memory_order_release);
  }

  // Copy "size" bytes of data from "src" to "dst", protected as a read-side
  // critical section of the sequence lock.
  //
  // Unlike traditional sequence lock implementations which loop until getting a
  // clean read, this implementation returns false in the case of concurrent
  // calls to `Write`. In such a case, the caller should fall back to a
  // locking-based slow path.
  //
  // Returns false if the sequence lock was not yet marked as initialized.
  //
  // NOTE: If this returns false, "dst" may be overwritten with undefined
  // (potentially uninitialized) data.
  bool TryRead(void* dst, const std::atomic<uint64_t>* src, size_t size) const {
    // Acquire barrier ensures that no loads done by f() are reordered
    // above the first load of the sequence counter.
    int64_t seq_before = lock_.load(std::memory_order_acquire);
    if (ABSL_PREDICT_FALSE(seq_before & 1) == 1) return false;
    RelaxedCopyFromAtomic(dst, src, size);
    // Another acquire fence ensures that the load of 'lock_' below is
    // strictly ordered after the RelaxedCopyToAtomic call above.
    std::atomic_thread_fence(std::memory_order_acquire);
    int64_t seq_after = lock_.load(std::memory_order_relaxed);
    return ABSL_PREDICT_TRUE(seq_before == seq_after);
  }

  // Copy "size" bytes from "src" to "dst" as a write-side critical section
  // of the sequence lock. Any concurrent readers will be forced to retry
  // until they get a read that does not conflict with this write.
  //
  // This call must be externally synchronized against other calls to Write,
  // but may proceed concurrently with reads.
  void Write(std::atomic<uint64_t>* dst, const void* src, size_t size) {
    // We can use relaxed instructions to increment the counter since we
    // are extenally synchronized. The std::atomic_thread_fence below
    // ensures that the counter updates don't get interleaved with the
    // copy to the data.
    int64_t orig_seq = lock_.load(std::memory_order_relaxed);
    assert((orig_seq & 1) == 0);  // Must be initially unlocked.
    lock_.store(orig_seq + 1, std::memory_order_relaxed);

    // We put a release fence between update to lock_ and writes to shared data.
    // Thus all stores to shared data are effectively release operations and
    // update to lock_ above cannot be re-ordered past any of them. Note that
    // this barrier is not for the fetch_add above.  A release barrier for the
    // fetch_add would be before it, not after.
    std::atomic_thread_fence(std::memory_order_release);
    RelaxedCopyToAtomic(dst, src, size);
    // "Release" semantics ensure that none of the writes done by
    // RelaxedCopyToAtomic() can be reordered after the following modification.
    lock_.store(orig_seq + 2, std::memory_order_release);
  }

  // Return the number of times that Write() has been called.
  //
  // REQUIRES: This must be externally synchronized against concurrent calls to
  // `Write()` or `IncrementModificationCount()`.
  // REQUIRES: `MarkInitialized()` must have been previously called.
  int64_t ModificationCount() const {
    int64_t val = lock_.load(std::memory_order_relaxed);
    assert(val != kUninitialized && (val & 1) == 0);
    return val / 2;
  }

  // REQUIRES: This must be externally synchronized against concurrent calls to
  // `Write()` or `ModificationCount()`.
  // REQUIRES: `MarkInitialized()` must have been previously called.
  void IncrementModificationCount() {
    int64_t val = lock_.load(std::memory_order_relaxed);
    assert(val != kUninitialized);
    lock_.store(val + 2, std::memory_order_relaxed);
  }

 private:
  // Perform the equivalent of "memcpy(dst, src, size)", but using relaxed
  // atomics.
  static void RelaxedCopyFromAtomic(void* dst, const std::atomic<uint64_t>* src,
                                    size_t size) {
    char* dst_byte = static_cast<char*>(dst);
    while (size >= sizeof(uint64_t)) {
      uint64_t word = src->load(std::memory_order_relaxed);
      std::memcpy(dst_byte, &word, sizeof(word));
      dst_byte += sizeof(word);
      src++;
      size -= sizeof(word);
    }
    if (size > 0) {
      uint64_t word = src->load(std::memory_order_relaxed);
      std::memcpy(dst_byte, &word, size);
    }
  }

  // Perform the equivalent of "memcpy(dst, src, size)", but using relaxed
  // atomics.
  static void RelaxedCopyToAtomic(std::atomic<uint64_t>* dst, const void* src,
                                  size_t size) {
    const char* src_byte = static_cast<const char*>(src);
    while (size >= sizeof(uint64_t)) {
      uint64_t word;
      std::memcpy(&word, src_byte, sizeof(word));
      dst->store(word, std::memory_order_relaxed);
      src_byte += sizeof(word);
      dst++;
      size -= sizeof(word);
    }
    if (size > 0) {
      uint64_t word = 0;
      std::memcpy(&word, src_byte, size);
      dst->store(word, std::memory_order_relaxed);
    }
  }

  static constexpr int64_t kUninitialized = -1;
  std::atomic<int64_t> lock_;
};

}  // namespace flags_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_FLAGS_INTERNAL_SEQUENCE_LOCK_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/internal/sequence_lock_test.cc                0000664 0000000 0000000 00000013250 14746647661 0030435 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2020 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
#include "absl/flags/internal/sequence_lock.h"

#include <algorithm>
#include <atomic>
#include <thread>  // NOLINT(build/c++11)
#include <tuple>
#include <vector>

#include "gtest/gtest.h"
#include "absl/base/internal/sysinfo.h"
#include "absl/container/fixed_array.h"
#include "absl/time/clock.h"

namespace {

namespace flags = absl::flags_internal;

class ConcurrentSequenceLockTest
    : public testing::TestWithParam<std::tuple<int, int>> {
 public:
  ConcurrentSequenceLockTest()
      : buf_bytes_(std::get<0>(GetParam())),
        num_threads_(std::get<1>(GetParam())) {}

 protected:
  const int buf_bytes_;
  const int num_threads_;
};

TEST_P(ConcurrentSequenceLockTest, ReadAndWrite) {
  const int buf_words =
      flags::AlignUp(buf_bytes_, sizeof(uint64_t)) / sizeof(uint64_t);

  // The buffer that will be protected by the SequenceLock.
  absl::FixedArray<std::atomic<uint64_t>> protected_buf(buf_words);
  for (auto& v : protected_buf) v = -1;

  flags::SequenceLock seq_lock;
  std::atomic<bool> stop{false};
  std::atomic<int64_t> bad_reads{0};
  std::atomic<int64_t> good_reads{0};
  std::atomic<int64_t> unsuccessful_reads{0};

  // Start a bunch of threads which read 'protected_buf' under the sequence
  // lock. The main thread will concurrently update 'protected_buf'. The updates
  // always consist of an array of identical integers. The reader ensures that
  // any data it reads matches that pattern (i.e. the reads are not "torn").
  std::vector<std::thread> threads;
  for (int i = 0; i < num_threads_; i++) {
    threads.emplace_back([&]() {
      absl::FixedArray<char> local_buf(buf_bytes_);
      while (!stop.load(std::memory_order_relaxed)) {
        if (seq_lock.TryRead(local_buf.data(), protected_buf.data(),
                             buf_bytes_)) {
          bool good = true;
          for (const auto& v : local_buf) {
            if (v != local_buf[0]) good = false;
          }
          if (good) {
            good_reads.fetch_add(1, std::memory_order_relaxed);
          } else {
            bad_reads.fetch_add(1, std::memory_order_relaxed);
          }
        } else {
          unsuccessful_reads.fetch_add(1, std::memory_order_relaxed);
        }
      }
    });
  }
  while (unsuccessful_reads.load(std::memory_order_relaxed) < num_threads_) {
    absl::SleepFor(absl::Milliseconds(1));
  }
  seq_lock.MarkInitialized();

  // Run a maximum of 5 seconds. On Windows, the scheduler behavior seems
  // somewhat unfair and without an explicit timeout for this loop, the tests
  // can run a long time.
  absl::Time deadline = absl::Now() + absl::Seconds(5);
  for (int i = 0; i < 100 && absl::Now() < deadline; i++) {
    absl::FixedArray<char> writer_buf(buf_bytes_);
    for (auto& v : writer_buf) v = i;
    seq_lock.Write(protected_buf.data(), writer_buf.data(), buf_bytes_);
    absl::SleepFor(absl::Microseconds(10));
  }
  stop.store(true, std::memory_order_relaxed);
  for (auto& t : threads) t.join();
  ASSERT_GE(good_reads, 0);
  ASSERT_EQ(bad_reads, 0);
}

// Simple helper for generating a range of thread counts.
// Generates [low, low*scale, low*scale^2, ...high)
// (even if high is between low*scale^k and low*scale^(k+1)).
std::vector<int> MultiplicativeRange(int low, int high, int scale) {
  std::vector<int> result;
  for (int current = low; current < high; current *= scale) {
    result.push_back(current);
  }
  result.push_back(high);
  return result;
}

#ifndef ABSL_HAVE_THREAD_SANITIZER
const int kMaxThreads = absl::base_internal::NumCPUs();
#else
// With TSAN, a lot of threads contending for atomic access on the sequence
// lock make this test run too slowly.
const int kMaxThreads = std::min(absl::base_internal::NumCPUs(), 4);
#endif

// Return all of the interesting buffer sizes worth testing:
// powers of two and adjacent values.
std::vector<int> InterestingBufferSizes() {
  std::vector<int> ret;
  for (int v : MultiplicativeRange(1, 128, 2)) {
    ret.push_back(v);
    if (v > 1) {
      ret.push_back(v - 1);
    }
    ret.push_back(v + 1);
  }
  return ret;
}

INSTANTIATE_TEST_SUITE_P(
    TestManyByteSizes, ConcurrentSequenceLockTest,
    testing::Combine(
        // Buffer size (bytes).
        testing::ValuesIn(InterestingBufferSizes()),
        // Number of reader threads.
        testing::ValuesIn(MultiplicativeRange(1, kMaxThreads, 2))));

// Simple single-threaded test, parameterized by the size of the buffer to be
// protected.
class SequenceLockTest : public testing::TestWithParam<int> {};

TEST_P(SequenceLockTest, SingleThreaded) {
  const int size = GetParam();
  absl::FixedArray<std::atomic<uint64_t>> protected_buf(
      flags::AlignUp(size, sizeof(uint64_t)) / sizeof(uint64_t));

  flags::SequenceLock seq_lock;
  seq_lock.MarkInitialized();

  std::vector<char> src_buf(size, 'x');
  seq_lock.Write(protected_buf.data(), src_buf.data(), size);

  std::vector<char> dst_buf(size, '0');
  ASSERT_TRUE(seq_lock.TryRead(dst_buf.data(), protected_buf.data(), size));
  ASSERT_EQ(src_buf, dst_buf);
}
INSTANTIATE_TEST_SUITE_P(TestManyByteSizes, SequenceLockTest,
                         // Buffer size (bytes).
                         testing::Range(1, 128));

}  // namespace
                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/internal/usage.cc                             0000664 0000000 0000000 00000041021 14746647661 0025657 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
// Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/flags/internal/usage.h"

#include <stdint.h>

#include <algorithm>
#include <cstdlib>
#include <functional>
#include <iterator>
#include <map>
#include <ostream>
#include <string>
#include <utility>
#include <vector>

#include "absl/base/attributes.h"
#include "absl/base/config.h"
#include "absl/base/const_init.h"
#include "absl/base/thread_annotations.h"
#include "absl/flags/commandlineflag.h"
#include "absl/flags/flag.h"
#include "absl/flags/internal/flag.h"
#include "absl/flags/internal/path_util.h"
#include "absl/flags/internal/private_handle_accessor.h"
#include "absl/flags/internal/program_name.h"
#include "absl/flags/internal/registry.h"
#include "absl/flags/usage_config.h"
#include "absl/strings/match.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/str_split.h"
#include "absl/strings/string_view.h"
#include "absl/strings/strip.h"
#include "absl/synchronization/mutex.h"

// Dummy global variables to prevent anyone else defining these.
bool FLAGS_help = false;
bool FLAGS_helpfull = false;
bool FLAGS_helpshort = false;
bool FLAGS_helppackage = false;
bool FLAGS_version = false;
bool FLAGS_only_check_args = false;
bool FLAGS_helpon = false;
bool FLAGS_helpmatch = false;

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace flags_internal {
namespace {

using PerFlagFilter = std::function<bool(const absl::CommandLineFlag&)>;

// Maximum length size in a human readable format.
constexpr size_t kHrfMaxLineLength = 80;

// This class is used to emit an XML element with `tag` and `text`.
// It adds opening and closing tags and escapes special characters in the text.
// For example:
// std::cout << XMLElement("title", "Milk & Cookies");
// prints "<title>Milk &amp; Cookies</title>"
class XMLElement {
 public:
  XMLElement(absl::string_view tag, absl::string_view txt)
      : tag_(tag), txt_(txt) {}

  friend std::ostream& operator<<(std::ostream& out,
                                  const XMLElement& xml_elem) {
    out << "<" << xml_elem.tag_ << ">";

    for (auto c : xml_elem.txt_) {
      switch (c) {
        case '"':
          out << "&quot;";
          break;
        case '\'':
          out << "&apos;";
          break;
        case '&':
          out << "&amp;";
          break;
        case '<':
          out << "&lt;";
          break;
        case '>':
          out << "&gt;";
          break;
        case '\n':
        case '\v':
        case '\f':
        case '\t':
          out << " ";
          break;
        default:
          if (IsValidXmlCharacter(static_cast<unsigned char>(c))) {
            out << c;
          }
          break;
      }
    }

    return out << "</" << xml_elem.tag_ << ">";
  }

 private:
  static bool IsValidXmlCharacter(unsigned char c) { return c >= 0x20; }
  absl::string_view tag_;
  absl::string_view txt_;
};

// --------------------------------------------------------------------
// Helper class to pretty-print info about a flag.

class FlagHelpPrettyPrinter {
 public:
  // Pretty printer holds on to the std::ostream& reference to direct an output
  // to that stream.
  FlagHelpPrettyPrinter(size_t max_line_len, size_t min_line_len,
                        size_t wrapped_line_indent, std::ostream& out)
      : out_(out),
        max_line_len_(max_line_len),
        min_line_len_(min_line_len),
        wrapped_line_indent_(wrapped_line_indent),
        line_len_(0),
        first_line_(true) {}

  void Write(absl::string_view str, bool wrap_line = false) {
    // Empty string - do nothing.
    if (str.empty()) return;

    std::vector<absl::string_view> tokens;
    if (wrap_line) {
      for (auto line : absl::StrSplit(str, absl::ByAnyChar("\n\r"))) {
        if (!tokens.empty()) {
          // Keep line separators in the input string.
          tokens.emplace_back("\n");
        }
        for (auto token :
             absl::StrSplit(line, absl::ByAnyChar(" \t"), absl::SkipEmpty())) {
          tokens.push_back(token);
        }
      }
    } else {
      tokens.push_back(str);
    }

    for (auto token : tokens) {
      bool new_line = (line_len_ == 0);

      // Respect line separators in the input string.
      if (token == "\n") {
        EndLine();
        continue;
      }

      // Write the token, ending the string first if necessary/possible.
      if (!new_line && (line_len_ + token.size() >= max_line_len_)) {
        EndLine();
        new_line = true;
      }

      if (new_line) {
        StartLine();
      } else {
        out_ << ' ';
        ++line_len_;
      }

      out_ << token;
      line_len_ += token.size();
    }
  }

  void StartLine() {
    if (first_line_) {
      line_len_ = min_line_len_;
      first_line_ = false;
    } else {
      line_len_ = min_line_len_ + wrapped_line_indent_;
    }
    out_ << std::string(line_len_, ' ');
  }
  void EndLine() {
    out_ << '\n';
    line_len_ = 0;
  }

 private:
  std::ostream& out_;
  const size_t max_line_len_;
  const size_t min_line_len_;
  const size_t wrapped_line_indent_;
  size_t line_len_;
  bool first_line_;
};

void FlagHelpHumanReadable(const CommandLineFlag& flag, std::ostream& out) {
  FlagHelpPrettyPrinter printer(kHrfMaxLineLength, 4, 2, out);

  // Flag name.
  printer.Write(absl::StrCat("--", flag.Name()));

  // Flag help.
  printer.Write(absl::StrCat("(", flag.Help(), ");"), /*wrap_line=*/true);

  // The listed default value will be the actual default from the flag
  // definition in the originating source file, unless the value has
  // subsequently been modified using SetCommandLineOption() with mode
  // SET_FLAGS_DEFAULT.
  std::string dflt_val = flag.DefaultValue();
  std::string curr_val = flag.CurrentValue();
  bool is_modified = curr_val != dflt_val;

  if (flag.IsOfType<std::string>()) {
    dflt_val = absl::StrCat("\"", dflt_val, "\"");
  }
  printer.Write(absl::StrCat("default: ", dflt_val, ";"));

  if (is_modified) {
    if (flag.IsOfType<std::string>()) {
      curr_val = absl::StrCat("\"", curr_val, "\"");
    }
    printer.Write(absl::StrCat("currently: ", curr_val, ";"));
  }

  printer.EndLine();
}

// Shows help for every filename which matches any of the filters
// If filters are empty, shows help for every file.
// If a flag's help message has been stripped (e.g. by adding '#define
// STRIP_FLAG_HELP 1' then this flag will not be displayed by '--help'
// and its variants.
void FlagsHelpImpl(std::ostream& out, PerFlagFilter filter_cb,
                   HelpFormat format, absl::string_view program_usage_message) {
  if (format == HelpFormat::kHumanReadable) {
    out << flags_internal::ShortProgramInvocationName() << ": "
        << program_usage_message << "\n\n";
  } else {
    // XML schema is not a part of our public API for now.
    out << "<?xml version=\"1.0\"?>\n"
        << "<!-- This output should be used with care. We do not report type "
           "names for flags with user defined types -->\n"
        << "<!-- Prefer flag only_check_args for validating flag inputs -->\n"
        // The document.
        << "<AllFlags>\n"
        // The program name and usage.
        << XMLElement("program", flags_internal::ShortProgramInvocationName())
        << '\n'
        << XMLElement("usage", program_usage_message) << '\n';
  }

  // Ordered map of package name to
  //   map of file name to
  //     vector of flags in the file.
  // This map is used to output matching flags grouped by package and file
  // name.
  std::map<std::string,
           std::map<std::string, std::vector<const absl::CommandLineFlag*>>>
      matching_flags;

  flags_internal::ForEachFlag([&](absl::CommandLineFlag& flag) {
    // Ignore retired flags.
    if (flag.IsRetired()) return;

    // If the flag has been stripped, pretend that it doesn't exist.
    if (flag.Help() == flags_internal::kStrippedFlagHelp) return;

    // Make sure flag satisfies the filter
    if (!filter_cb(flag)) return;

    std::string flag_filename = flag.Filename();

    matching_flags[std::string(flags_internal::Package(flag_filename))]
                  [flag_filename]
                      .push_back(&flag);
  });

  absl::string_view package_separator;  // controls blank lines between packages
  absl::string_view file_separator;     // controls blank lines between files
  for (auto& package : matching_flags) {
    if (format == HelpFormat::kHumanReadable) {
      out << package_separator;
      package_separator = "\n\n";
    }

    file_separator = "";
    for (auto& flags_in_file : package.second) {
      if (format == HelpFormat::kHumanReadable) {
        out << file_separator << "  Flags from " << flags_in_file.first
            << ":\n";
        file_separator = "\n";
      }

      std::sort(std::begin(flags_in_file.second),
                std::end(flags_in_file.second),
                [](const CommandLineFlag* lhs, const CommandLineFlag* rhs) {
                  return lhs->Name() < rhs->Name();
                });

      for (const auto* flag : flags_in_file.second) {
        flags_internal::FlagHelp(out, *flag, format);
      }
    }
  }

  if (format == HelpFormat::kHumanReadable) {
    FlagHelpPrettyPrinter printer(kHrfMaxLineLength, 0, 0, out);

    if (filter_cb && matching_flags.empty()) {
      printer.Write("No flags matched.\n", true);
    }
    printer.EndLine();
    printer.Write(
        "Try --helpfull to get a list of all flags or --help=substring "
        "shows help for flags which include specified substring in either "
        "in the name, or description or path.\n",
        true);
  } else {
    // The end of the document.
    out << "</AllFlags>\n";
  }
}

void FlagsHelpImpl(std::ostream& out,
                   flags_internal::FlagKindFilter filename_filter_cb,
                   HelpFormat format, absl::string_view program_usage_message) {
  FlagsHelpImpl(
      out,
      [&](const absl::CommandLineFlag& flag) {
        return filename_filter_cb && filename_filter_cb(flag.Filename());
      },
      format, program_usage_message);
}

}  // namespace

// --------------------------------------------------------------------
// Produces the help message describing specific flag.
void FlagHelp(std::ostream& out, const CommandLineFlag& flag,
              HelpFormat format) {
  if (format == HelpFormat::kHumanReadable)
    flags_internal::FlagHelpHumanReadable(flag, out);
}

// --------------------------------------------------------------------
// Produces the help messages for all flags matching the filename filter.
// If filter is empty produces help messages for all flags.
void FlagsHelp(std::ostream& out, absl::string_view filter, HelpFormat format,
               absl::string_view program_usage_message) {
  flags_internal::FlagKindFilter filter_cb = [&](absl::string_view filename) {
    return filter.empty() || absl::StrContains(filename, filter);
  };
  flags_internal::FlagsHelpImpl(out, filter_cb, format, program_usage_message);
}

// --------------------------------------------------------------------
// Checks all the 'usage' command line flags to see if any have been set.
// If so, handles them appropriately.
HelpMode HandleUsageFlags(std::ostream& out,
                          absl::string_view program_usage_message) {
  switch (GetFlagsHelpMode()) {
    case HelpMode::kNone:
      break;
    case HelpMode::kImportant:
      flags_internal::FlagsHelpImpl(
          out, flags_internal::GetUsageConfig().contains_help_flags,
          GetFlagsHelpFormat(), program_usage_message);
      break;

    case HelpMode::kShort:
      flags_internal::FlagsHelpImpl(
          out, flags_internal::GetUsageConfig().contains_helpshort_flags,
          GetFlagsHelpFormat(), program_usage_message);
      break;

    case HelpMode::kFull:
      flags_internal::FlagsHelp(out, "", GetFlagsHelpFormat(),
                                program_usage_message);
      break;

    case HelpMode::kPackage:
      flags_internal::FlagsHelpImpl(
          out, flags_internal::GetUsageConfig().contains_helppackage_flags,
          GetFlagsHelpFormat(), program_usage_message);
      break;

    case HelpMode::kMatch: {
      std::string substr = GetFlagsHelpMatchSubstr();
      if (substr.empty()) {
        // show all options
        flags_internal::FlagsHelp(out, substr, GetFlagsHelpFormat(),
                                  program_usage_message);
      } else {
        auto filter_cb = [&substr](const absl::CommandLineFlag& flag) {
          if (absl::StrContains(flag.Name(), substr)) return true;
          if (absl::StrContains(flag.Filename(), substr)) return true;
          if (absl::StrContains(flag.Help(), substr)) return true;

          return false;
        };
        flags_internal::FlagsHelpImpl(
            out, filter_cb, HelpFormat::kHumanReadable, program_usage_message);
      }
      break;
    }
    case HelpMode::kVersion:
      if (flags_internal::GetUsageConfig().version_string)
        out << flags_internal::GetUsageConfig().version_string();
      // Unlike help, we may be asking for version in a script, so return 0
      break;

    case HelpMode::kOnlyCheckArgs:
      break;
  }

  return GetFlagsHelpMode();
}

// --------------------------------------------------------------------
// Globals representing usage reporting flags

namespace {

ABSL_CONST_INIT absl::Mutex help_attributes_guard(absl::kConstInit);
ABSL_CONST_INIT std::string* match_substr
    ABSL_GUARDED_BY(help_attributes_guard) = nullptr;
ABSL_CONST_INIT HelpMode help_mode ABSL_GUARDED_BY(help_attributes_guard) =
    HelpMode::kNone;
ABSL_CONST_INIT HelpFormat help_format ABSL_GUARDED_BY(help_attributes_guard) =
    HelpFormat::kHumanReadable;

}  // namespace

std::string GetFlagsHelpMatchSubstr() {
  absl::MutexLock l(&help_attributes_guard);
  if (match_substr == nullptr) return "";
  return *match_substr;
}

void SetFlagsHelpMatchSubstr(absl::string_view substr) {
  absl::MutexLock l(&help_attributes_guard);
  if (match_substr == nullptr) match_substr = new std::string;
  match_substr->assign(substr.data(), substr.size());
}

HelpMode GetFlagsHelpMode() {
  absl::MutexLock l(&help_attributes_guard);
  return help_mode;
}

void SetFlagsHelpMode(HelpMode mode) {
  absl::MutexLock l(&help_attributes_guard);
  help_mode = mode;
}

HelpFormat GetFlagsHelpFormat() {
  absl::MutexLock l(&help_attributes_guard);
  return help_format;
}

void SetFlagsHelpFormat(HelpFormat format) {
  absl::MutexLock l(&help_attributes_guard);
  help_format = format;
}

// Deduces usage flags from the input argument in a form --name=value or
// --name. argument is already split into name and value before we call this
// function.
bool DeduceUsageFlags(absl::string_view name, absl::string_view value) {
  if (absl::ConsumePrefix(&name, "help")) {
    if (name.empty()) {
      if (value.empty()) {
        SetFlagsHelpMode(HelpMode::kImportant);
      } else {
        SetFlagsHelpMode(HelpMode::kMatch);
        SetFlagsHelpMatchSubstr(value);
      }
      return true;
    }

    if (name == "match") {
      SetFlagsHelpMode(HelpMode::kMatch);
      SetFlagsHelpMatchSubstr(value);
      return true;
    }

    if (name == "on") {
      SetFlagsHelpMode(HelpMode::kMatch);
      SetFlagsHelpMatchSubstr(absl::StrCat("/", value, "."));
      return true;
    }

    if (name == "full") {
      SetFlagsHelpMode(HelpMode::kFull);
      return true;
    }

    if (name == "short") {
      SetFlagsHelpMode(HelpMode::kShort);
      return true;
    }

    if (name == "package") {
      SetFlagsHelpMode(HelpMode::kPackage);
      return true;
    }

    return false;
  }

  if (name == "version") {
    SetFlagsHelpMode(HelpMode::kVersion);
    return true;
  }

  if (name == "only_check_args") {
    SetFlagsHelpMode(HelpMode::kOnlyCheckArgs);
    return true;
  }

  return false;
}

// --------------------------------------------------------------------

void MaybeExit(HelpMode mode) {
  switch (mode) {
    case flags_internal::HelpMode::kNone:
      return;
    case flags_internal::HelpMode::kOnlyCheckArgs:
    case flags_internal::HelpMode::kVersion:
      std::exit(0);
    default:  // For all the other modes we exit with 1
      std::exit(1);
  }
}

// --------------------------------------------------------------------

}  // namespace flags_internal
ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/internal/usage.h                              0000664 0000000 0000000 00000007143 14746647661 0025530 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
//  Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef ABSL_FLAGS_INTERNAL_USAGE_H_
#define ABSL_FLAGS_INTERNAL_USAGE_H_

#include <iosfwd>
#include <ostream>
#include <string>

#include "absl/base/config.h"
#include "absl/flags/commandlineflag.h"
#include "absl/strings/string_view.h"

// --------------------------------------------------------------------
// Usage reporting interfaces

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace flags_internal {

// The format to report the help messages in.
enum class HelpFormat {
  kHumanReadable,
};

// The kind of usage help requested.
enum class HelpMode {
  kNone,
  kImportant,
  kShort,
  kFull,
  kPackage,
  kMatch,
  kVersion,
  kOnlyCheckArgs
};

// Streams the help message describing `flag` to `out`.
// The default value for `flag` is included in the output.
void FlagHelp(std::ostream& out, const CommandLineFlag& flag,
              HelpFormat format = HelpFormat::kHumanReadable);

// Produces the help messages for all flags matching the filter. A flag matches
// the filter if it is defined in a file with a filename which includes
// filter string as a substring. You can use '/' and '.' to restrict the
// matching to a specific file names. For example:
//   FlagsHelp(out, "/path/to/file.");
// restricts help to only flags which resides in files named like:
//  .../path/to/file.<ext>
// for any extension 'ext'. If the filter is empty this function produces help
// messages for all flags.
void FlagsHelp(std::ostream& out, absl::string_view filter,
               HelpFormat format, absl::string_view program_usage_message);

// --------------------------------------------------------------------

// If any of the 'usage' related command line flags (listed on the bottom of
// this file) has been set this routine produces corresponding help message in
// the specified output stream and returns HelpMode that was handled. Otherwise
// it returns HelpMode::kNone.
HelpMode HandleUsageFlags(std::ostream& out,
                          absl::string_view program_usage_message);

// --------------------------------------------------------------------
// Encapsulates the logic of exiting the binary depending on handled help mode.

void MaybeExit(HelpMode mode);

// --------------------------------------------------------------------
// Globals representing usage reporting flags

// Returns substring to filter help output (--help=substr argument)
std::string GetFlagsHelpMatchSubstr();
// Returns the requested help mode.
HelpMode GetFlagsHelpMode();
// Returns the requested help format.
HelpFormat GetFlagsHelpFormat();

// These are corresponding setters to the attributes above.
void SetFlagsHelpMatchSubstr(absl::string_view);
void SetFlagsHelpMode(HelpMode);
void SetFlagsHelpFormat(HelpFormat);

// Deduces usage flags from the input argument in a form --name=value or
// --name. argument is already split into name and value before we call this
// function.
bool DeduceUsageFlags(absl::string_view name, absl::string_view value);

}  // namespace flags_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_FLAGS_INTERNAL_USAGE_H_
                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/internal/usage_test.cc                        0000664 0000000 0000000 00000046427 14746647661 0026735 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
//  Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/flags/internal/usage.h"

#include <stdint.h>

#include <sstream>
#include <string>

#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "absl/flags/config.h"
#include "absl/flags/flag.h"
#include "absl/flags/internal/parse.h"
#include "absl/flags/internal/program_name.h"
#include "absl/flags/reflection.h"
#include "absl/flags/usage.h"
#include "absl/flags/usage_config.h"
#include "absl/strings/match.h"
#include "absl/strings/string_view.h"

ABSL_FLAG(int, usage_reporting_test_flag_01, 101,
          "usage_reporting_test_flag_01 help message");
ABSL_FLAG(bool, usage_reporting_test_flag_02, false,
          "usage_reporting_test_flag_02 help message");
ABSL_FLAG(double, usage_reporting_test_flag_03, 1.03,
          "usage_reporting_test_flag_03 help message");
ABSL_FLAG(int64_t, usage_reporting_test_flag_04, 1000000000000004L,
          "usage_reporting_test_flag_04 help message");
ABSL_FLAG(std::string, usage_reporting_test_flag_07, "\r\n\f\v\a\b\t ",
          "usage_reporting_test_flag_07 help \r\n\f\v\a\b\t ");

static const char kTestUsageMessage[] = "Custom usage message";

struct UDT {
  UDT() = default;
  UDT(const UDT&) = default;
  UDT& operator=(const UDT&) = default;
};
static bool AbslParseFlag(absl::string_view, UDT*, std::string*) {
  return true;
}
static std::string AbslUnparseFlag(const UDT&) { return "UDT{}"; }

ABSL_FLAG(UDT, usage_reporting_test_flag_05, {},
          "usage_reporting_test_flag_05 help message");

ABSL_FLAG(
    std::string, usage_reporting_test_flag_06, {},
    "usage_reporting_test_flag_06 help message.\n"
    "\n"
    "Some more help.\n"
    "Even more long long long long long long long long long long long long "
    "help message.");

namespace {

namespace flags = absl::flags_internal;

static std::string NormalizeFileName(absl::string_view fname) {
#ifdef _WIN32
  std::string normalized(fname);
  std::replace(normalized.begin(), normalized.end(), '\\', '/');
  fname = normalized;
#endif

  auto absl_pos = fname.rfind("absl/");
  if (absl_pos != absl::string_view::npos) {
    fname = fname.substr(absl_pos);
  }
  return std::string(fname);
}

class UsageReportingTest : public testing::Test {
 protected:
  UsageReportingTest() {
    // Install default config for the use on this unit test.
    // Binary may install a custom config before tests are run.
    absl::FlagsUsageConfig default_config;
    default_config.normalize_filename = &NormalizeFileName;
    absl::SetFlagsUsageConfig(default_config);
  }
  ~UsageReportingTest() override {
    flags::SetFlagsHelpMode(flags::HelpMode::kNone);
    flags::SetFlagsHelpMatchSubstr("");
    flags::SetFlagsHelpFormat(flags::HelpFormat::kHumanReadable);
  }
  void SetUp() override {
#if ABSL_FLAGS_STRIP_NAMES
    GTEST_SKIP() << "This test requires flag names to be present";
#endif
  }

 private:
  absl::FlagSaver flag_saver_;
};

// --------------------------------------------------------------------

using UsageReportingDeathTest = UsageReportingTest;

TEST_F(UsageReportingDeathTest, TestSetProgramUsageMessage) {
#if !defined(GTEST_HAS_ABSL) || !GTEST_HAS_ABSL
  // Check for kTestUsageMessage set in main() below.
  EXPECT_EQ(absl::ProgramUsageMessage(), kTestUsageMessage);
#else
  // Check for part of the usage message set by GoogleTest.
  EXPECT_THAT(absl::ProgramUsageMessage(),
              ::testing::HasSubstr(
                  "This program contains tests written using Google Test"));
#endif

  EXPECT_DEATH_IF_SUPPORTED(
      absl::SetProgramUsageMessage("custom usage message"),
      ::testing::HasSubstr("SetProgramUsageMessage() called twice"));
}

// --------------------------------------------------------------------

TEST_F(UsageReportingTest, TestFlagHelpHRF_on_flag_01) {
  const auto* flag = absl::FindCommandLineFlag("usage_reporting_test_flag_01");
  std::stringstream test_buf;

  flags::FlagHelp(test_buf, *flag, flags::HelpFormat::kHumanReadable);
  EXPECT_EQ(
      test_buf.str(),
      R"(    --usage_reporting_test_flag_01 (usage_reporting_test_flag_01 help message);
      default: 101;
)");
}

TEST_F(UsageReportingTest, TestFlagHelpHRF_on_flag_02) {
  const auto* flag = absl::FindCommandLineFlag("usage_reporting_test_flag_02");
  std::stringstream test_buf;

  flags::FlagHelp(test_buf, *flag, flags::HelpFormat::kHumanReadable);
  EXPECT_EQ(
      test_buf.str(),
      R"(    --usage_reporting_test_flag_02 (usage_reporting_test_flag_02 help message);
      default: false;
)");
}

TEST_F(UsageReportingTest, TestFlagHelpHRF_on_flag_03) {
  const auto* flag = absl::FindCommandLineFlag("usage_reporting_test_flag_03");
  std::stringstream test_buf;

  flags::FlagHelp(test_buf, *flag, flags::HelpFormat::kHumanReadable);
  EXPECT_EQ(
      test_buf.str(),
      R"(    --usage_reporting_test_flag_03 (usage_reporting_test_flag_03 help message);
      default: 1.03;
)");
}

TEST_F(UsageReportingTest, TestFlagHelpHRF_on_flag_04) {
  const auto* flag = absl::FindCommandLineFlag("usage_reporting_test_flag_04");
  std::stringstream test_buf;

  flags::FlagHelp(test_buf, *flag, flags::HelpFormat::kHumanReadable);
  EXPECT_EQ(
      test_buf.str(),
      R"(    --usage_reporting_test_flag_04 (usage_reporting_test_flag_04 help message);
      default: 1000000000000004;
)");
}

TEST_F(UsageReportingTest, TestFlagHelpHRF_on_flag_05) {
  const auto* flag = absl::FindCommandLineFlag("usage_reporting_test_flag_05");
  std::stringstream test_buf;

  flags::FlagHelp(test_buf, *flag, flags::HelpFormat::kHumanReadable);
  EXPECT_EQ(
      test_buf.str(),
      R"(    --usage_reporting_test_flag_05 (usage_reporting_test_flag_05 help message);
      default: UDT{};
)");
}

// --------------------------------------------------------------------

TEST_F(UsageReportingTest, TestFlagsHelpHRF) {
  std::string usage_test_flags_out =
      R"(usage_test: Custom usage message

  Flags from absl/flags/internal/usage_test.cc:
    --usage_reporting_test_flag_01 (usage_reporting_test_flag_01 help message);
      default: 101;
    --usage_reporting_test_flag_02 (usage_reporting_test_flag_02 help message);
      default: false;
    --usage_reporting_test_flag_03 (usage_reporting_test_flag_03 help message);
      default: 1.03;
    --usage_reporting_test_flag_04 (usage_reporting_test_flag_04 help message);
      default: 1000000000000004;
    --usage_reporting_test_flag_05 (usage_reporting_test_flag_05 help message);
      default: UDT{};
    --usage_reporting_test_flag_06 (usage_reporting_test_flag_06 help message.

      Some more help.
      Even more long long long long long long long long long long long long help
      message.); default: "";)"

      "\n    --usage_reporting_test_flag_07 (usage_reporting_test_flag_07 "
      "help\n\n      \f\v\a\b ); default: \"\r\n\f\v\a\b\t \";\n"

      R"(
Try --helpfull to get a list of all flags or --help=substring shows help for
flags which include specified substring in either in the name, or description or
path.
)";

  std::stringstream test_buf_01;
  flags::FlagsHelp(test_buf_01, "usage_test.cc",
                   flags::HelpFormat::kHumanReadable, kTestUsageMessage);
  EXPECT_EQ(test_buf_01.str(), usage_test_flags_out);

  std::stringstream test_buf_02;
  flags::FlagsHelp(test_buf_02, "flags/internal/usage_test.cc",
                   flags::HelpFormat::kHumanReadable, kTestUsageMessage);
  EXPECT_EQ(test_buf_02.str(), usage_test_flags_out);

  std::stringstream test_buf_03;
  flags::FlagsHelp(test_buf_03, "usage_test", flags::HelpFormat::kHumanReadable,
                   kTestUsageMessage);
  EXPECT_EQ(test_buf_03.str(), usage_test_flags_out);

  std::stringstream test_buf_04;
  flags::FlagsHelp(test_buf_04, "flags/invalid_file_name.cc",
                   flags::HelpFormat::kHumanReadable, kTestUsageMessage);
  EXPECT_EQ(test_buf_04.str(),
            R"(usage_test: Custom usage message

No flags matched.

Try --helpfull to get a list of all flags or --help=substring shows help for
flags which include specified substring in either in the name, or description or
path.
)");

  std::stringstream test_buf_05;
  flags::FlagsHelp(test_buf_05, "", flags::HelpFormat::kHumanReadable,
                   kTestUsageMessage);
  std::string test_out = test_buf_05.str();
  absl::string_view test_out_str(test_out);
  EXPECT_TRUE(
      absl::StartsWith(test_out_str, "usage_test: Custom usage message"));
  EXPECT_TRUE(absl::StrContains(
      test_out_str, "Flags from absl/flags/internal/usage_test.cc:"));
  EXPECT_TRUE(
      absl::StrContains(test_out_str, "-usage_reporting_test_flag_01 "));
}

// --------------------------------------------------------------------

TEST_F(UsageReportingTest, TestNoUsageFlags) {
  std::stringstream test_buf;
  EXPECT_EQ(flags::HandleUsageFlags(test_buf, kTestUsageMessage),
            flags::HelpMode::kNone);
}

// --------------------------------------------------------------------

TEST_F(UsageReportingTest, TestUsageFlag_helpshort) {
  flags::SetFlagsHelpMode(flags::HelpMode::kShort);

  std::stringstream test_buf;
  EXPECT_EQ(flags::HandleUsageFlags(test_buf, kTestUsageMessage),
            flags::HelpMode::kShort);
  EXPECT_EQ(
      test_buf.str(),
      R"(usage_test: Custom usage message

  Flags from absl/flags/internal/usage_test.cc:
    --usage_reporting_test_flag_01 (usage_reporting_test_flag_01 help message);
      default: 101;
    --usage_reporting_test_flag_02 (usage_reporting_test_flag_02 help message);
      default: false;
    --usage_reporting_test_flag_03 (usage_reporting_test_flag_03 help message);
      default: 1.03;
    --usage_reporting_test_flag_04 (usage_reporting_test_flag_04 help message);
      default: 1000000000000004;
    --usage_reporting_test_flag_05 (usage_reporting_test_flag_05 help message);
      default: UDT{};
    --usage_reporting_test_flag_06 (usage_reporting_test_flag_06 help message.

      Some more help.
      Even more long long long long long long long long long long long long help
      message.); default: "";)"

      "\n    --usage_reporting_test_flag_07 (usage_reporting_test_flag_07 "
      "help\n\n      \f\v\a\b ); default: \"\r\n\f\v\a\b\t \";\n"

      R"(
Try --helpfull to get a list of all flags or --help=substring shows help for
flags which include specified substring in either in the name, or description or
path.
)");
}

// --------------------------------------------------------------------

TEST_F(UsageReportingTest, TestUsageFlag_help_simple) {
  flags::SetFlagsHelpMode(flags::HelpMode::kImportant);

  std::stringstream test_buf;
  EXPECT_EQ(flags::HandleUsageFlags(test_buf, kTestUsageMessage),
            flags::HelpMode::kImportant);
  EXPECT_EQ(
      test_buf.str(),
      R"(usage_test: Custom usage message

  Flags from absl/flags/internal/usage_test.cc:
    --usage_reporting_test_flag_01 (usage_reporting_test_flag_01 help message);
      default: 101;
    --usage_reporting_test_flag_02 (usage_reporting_test_flag_02 help message);
      default: false;
    --usage_reporting_test_flag_03 (usage_reporting_test_flag_03 help message);
      default: 1.03;
    --usage_reporting_test_flag_04 (usage_reporting_test_flag_04 help message);
      default: 1000000000000004;
    --usage_reporting_test_flag_05 (usage_reporting_test_flag_05 help message);
      default: UDT{};
    --usage_reporting_test_flag_06 (usage_reporting_test_flag_06 help message.

      Some more help.
      Even more long long long long long long long long long long long long help
      message.); default: "";)"

      "\n    --usage_reporting_test_flag_07 (usage_reporting_test_flag_07 "
      "help\n\n      \f\v\a\b ); default: \"\r\n\f\v\a\b\t \";\n"

      R"(
Try --helpfull to get a list of all flags or --help=substring shows help for
flags which include specified substring in either in the name, or description or
path.
)");
}

// --------------------------------------------------------------------

TEST_F(UsageReportingTest, TestUsageFlag_help_one_flag) {
  flags::SetFlagsHelpMode(flags::HelpMode::kMatch);
  flags::SetFlagsHelpMatchSubstr("usage_reporting_test_flag_06");

  std::stringstream test_buf;
  EXPECT_EQ(flags::HandleUsageFlags(test_buf, kTestUsageMessage),
            flags::HelpMode::kMatch);
  EXPECT_EQ(test_buf.str(),
            R"(usage_test: Custom usage message

  Flags from absl/flags/internal/usage_test.cc:
    --usage_reporting_test_flag_06 (usage_reporting_test_flag_06 help message.

      Some more help.
      Even more long long long long long long long long long long long long help
      message.); default: "";

Try --helpfull to get a list of all flags or --help=substring shows help for
flags which include specified substring in either in the name, or description or
path.
)");
}

// --------------------------------------------------------------------

TEST_F(UsageReportingTest, TestUsageFlag_help_multiple_flag) {
  flags::SetFlagsHelpMode(flags::HelpMode::kMatch);
  flags::SetFlagsHelpMatchSubstr("test_flag");

  std::stringstream test_buf;
  EXPECT_EQ(flags::HandleUsageFlags(test_buf, kTestUsageMessage),
            flags::HelpMode::kMatch);
  EXPECT_EQ(
      test_buf.str(),
      R"(usage_test: Custom usage message

  Flags from absl/flags/internal/usage_test.cc:
    --usage_reporting_test_flag_01 (usage_reporting_test_flag_01 help message);
      default: 101;
    --usage_reporting_test_flag_02 (usage_reporting_test_flag_02 help message);
      default: false;
    --usage_reporting_test_flag_03 (usage_reporting_test_flag_03 help message);
      default: 1.03;
    --usage_reporting_test_flag_04 (usage_reporting_test_flag_04 help message);
      default: 1000000000000004;
    --usage_reporting_test_flag_05 (usage_reporting_test_flag_05 help message);
      default: UDT{};
    --usage_reporting_test_flag_06 (usage_reporting_test_flag_06 help message.

      Some more help.
      Even more long long long long long long long long long long long long help
      message.); default: "";)"

      "\n    --usage_reporting_test_flag_07 (usage_reporting_test_flag_07 "
      "help\n\n      \f\v\a\b ); default: \"\r\n\f\v\a\b\t \";\n"

      R"(
Try --helpfull to get a list of all flags or --help=substring shows help for
flags which include specified substring in either in the name, or description or
path.
)");
}

// --------------------------------------------------------------------

TEST_F(UsageReportingTest, TestUsageFlag_helppackage) {
  flags::SetFlagsHelpMode(flags::HelpMode::kPackage);

  std::stringstream test_buf;
  EXPECT_EQ(flags::HandleUsageFlags(test_buf, kTestUsageMessage),
            flags::HelpMode::kPackage);
  EXPECT_EQ(
      test_buf.str(),
      R"(usage_test: Custom usage message

  Flags from absl/flags/internal/usage_test.cc:
    --usage_reporting_test_flag_01 (usage_reporting_test_flag_01 help message);
      default: 101;
    --usage_reporting_test_flag_02 (usage_reporting_test_flag_02 help message);
      default: false;
    --usage_reporting_test_flag_03 (usage_reporting_test_flag_03 help message);
      default: 1.03;
    --usage_reporting_test_flag_04 (usage_reporting_test_flag_04 help message);
      default: 1000000000000004;
    --usage_reporting_test_flag_05 (usage_reporting_test_flag_05 help message);
      default: UDT{};
    --usage_reporting_test_flag_06 (usage_reporting_test_flag_06 help message.

      Some more help.
      Even more long long long long long long long long long long long long help
      message.); default: "";)"

      "\n    --usage_reporting_test_flag_07 (usage_reporting_test_flag_07 "
      "help\n\n      \f\v\a\b ); default: \"\r\n\f\v\a\b\t \";\n"

      R"(
Try --helpfull to get a list of all flags or --help=substring shows help for
flags which include specified substring in either in the name, or description or
path.
)");
}

// --------------------------------------------------------------------

TEST_F(UsageReportingTest, TestUsageFlag_version) {
  flags::SetFlagsHelpMode(flags::HelpMode::kVersion);

  std::stringstream test_buf;
  EXPECT_EQ(flags::HandleUsageFlags(test_buf, kTestUsageMessage),
            flags::HelpMode::kVersion);
#ifndef NDEBUG
  EXPECT_EQ(test_buf.str(), "usage_test\nDebug build (NDEBUG not #defined)\n");
#else
  EXPECT_EQ(test_buf.str(), "usage_test\n");
#endif
}

// --------------------------------------------------------------------

TEST_F(UsageReportingTest, TestUsageFlag_only_check_args) {
  flags::SetFlagsHelpMode(flags::HelpMode::kOnlyCheckArgs);

  std::stringstream test_buf;
  EXPECT_EQ(flags::HandleUsageFlags(test_buf, kTestUsageMessage),
            flags::HelpMode::kOnlyCheckArgs);
  EXPECT_EQ(test_buf.str(), "");
}

// --------------------------------------------------------------------

TEST_F(UsageReportingTest, TestUsageFlag_helpon) {
  flags::SetFlagsHelpMode(flags::HelpMode::kMatch);
  flags::SetFlagsHelpMatchSubstr("/bla-bla.");

  std::stringstream test_buf_01;
  EXPECT_EQ(flags::HandleUsageFlags(test_buf_01, kTestUsageMessage),
            flags::HelpMode::kMatch);
  EXPECT_EQ(test_buf_01.str(),
            R"(usage_test: Custom usage message

No flags matched.

Try --helpfull to get a list of all flags or --help=substring shows help for
flags which include specified substring in either in the name, or description or
path.
)");

  flags::SetFlagsHelpMatchSubstr("/usage_test.");

  std::stringstream test_buf_02;
  EXPECT_EQ(flags::HandleUsageFlags(test_buf_02, kTestUsageMessage),
            flags::HelpMode::kMatch);
  EXPECT_EQ(
      test_buf_02.str(),
      R"(usage_test: Custom usage message

  Flags from absl/flags/internal/usage_test.cc:
    --usage_reporting_test_flag_01 (usage_reporting_test_flag_01 help message);
      default: 101;
    --usage_reporting_test_flag_02 (usage_reporting_test_flag_02 help message);
      default: false;
    --usage_reporting_test_flag_03 (usage_reporting_test_flag_03 help message);
      default: 1.03;
    --usage_reporting_test_flag_04 (usage_reporting_test_flag_04 help message);
      default: 1000000000000004;
    --usage_reporting_test_flag_05 (usage_reporting_test_flag_05 help message);
      default: UDT{};
    --usage_reporting_test_flag_06 (usage_reporting_test_flag_06 help message.

      Some more help.
      Even more long long long long long long long long long long long long help
      message.); default: "";)"

      "\n    --usage_reporting_test_flag_07 (usage_reporting_test_flag_07 "
      "help\n\n      \f\v\a\b ); default: \"\r\n\f\v\a\b\t \";\n"

      R"(
Try --helpfull to get a list of all flags or --help=substring shows help for
flags which include specified substring in either in the name, or description or
path.
)");
}

// --------------------------------------------------------------------

}  // namespace

int main(int argc, char* argv[]) {
  (void)absl::GetFlag(FLAGS_undefok);  // Force linking of parse.cc
  flags::SetProgramInvocationName("usage_test");
#if !defined(GTEST_HAS_ABSL) || !GTEST_HAS_ABSL
  // GoogleTest calls absl::SetProgramUsageMessage() already.
  absl::SetProgramUsageMessage(kTestUsageMessage);
#endif
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
                                                                                                                                                                                                                                         node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/marshalling.cc                                0000664 0000000 0000000 00000022234 14746647661 0025245 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
//  Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/flags/marshalling.h"

#include <stddef.h>

#include <cmath>
#include <limits>
#include <sstream>
#include <string>
#include <type_traits>
#include <vector>

#include "absl/base/config.h"
#include "absl/base/log_severity.h"
#include "absl/base/macros.h"
#include "absl/numeric/int128.h"
#include "absl/strings/ascii.h"
#include "absl/strings/match.h"
#include "absl/strings/numbers.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/str_format.h"
#include "absl/strings/str_join.h"
#include "absl/strings/str_split.h"
#include "absl/strings/string_view.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace flags_internal {

// --------------------------------------------------------------------
// AbslParseFlag specializations for boolean type.

bool AbslParseFlag(absl::string_view text, bool* dst, std::string*) {
  const char* kTrue[] = {"1", "t", "true", "y", "yes"};
  const char* kFalse[] = {"0", "f", "false", "n", "no"};
  static_assert(sizeof(kTrue) == sizeof(kFalse), "true_false_equal");

  text = absl::StripAsciiWhitespace(text);

  for (size_t i = 0; i < ABSL_ARRAYSIZE(kTrue); ++i) {
    if (absl::EqualsIgnoreCase(text, kTrue[i])) {
      *dst = true;
      return true;
    } else if (absl::EqualsIgnoreCase(text, kFalse[i])) {
      *dst = false;
      return true;
    }
  }
  return false;  // didn't match a legal input
}

// --------------------------------------------------------------------
// AbslParseFlag for integral types.

// Return the base to use for parsing text as an integer.  Leading 0x
// puts us in base 16.  But leading 0 does not put us in base 8. It
// caused too many bugs when we had that behavior.
static int NumericBase(absl::string_view text) {
  if (text.empty()) return 0;
  size_t num_start = (text[0] == '-' || text[0] == '+') ? 1 : 0;
  const bool hex = (text.size() >= num_start + 2 && text[num_start] == '0' &&
                    (text[num_start + 1] == 'x' || text[num_start + 1] == 'X'));
  return hex ? 16 : 10;
}

template <typename IntType>
inline bool ParseFlagImpl(absl::string_view text, IntType& dst) {
  text = absl::StripAsciiWhitespace(text);

  return absl::numbers_internal::safe_strtoi_base(text, &dst,
                                                  NumericBase(text));
}

bool AbslParseFlag(absl::string_view text, short* dst, std::string*) {
  int val;
  if (!ParseFlagImpl(text, val)) return false;
  if (static_cast<short>(val) != val)  // worked, but number out of range
    return false;
  *dst = static_cast<short>(val);
  return true;
}

bool AbslParseFlag(absl::string_view text, unsigned short* dst, std::string*) {
  unsigned int val;
  if (!ParseFlagImpl(text, val)) return false;
  if (static_cast<unsigned short>(val) !=
      val)  // worked, but number out of range
    return false;
  *dst = static_cast<unsigned short>(val);
  return true;
}

bool AbslParseFlag(absl::string_view text, int* dst, std::string*) {
  return ParseFlagImpl(text, *dst);
}

bool AbslParseFlag(absl::string_view text, unsigned int* dst, std::string*) {
  return ParseFlagImpl(text, *dst);
}

bool AbslParseFlag(absl::string_view text, long* dst, std::string*) {
  return ParseFlagImpl(text, *dst);
}

bool AbslParseFlag(absl::string_view text, unsigned long* dst, std::string*) {
  return ParseFlagImpl(text, *dst);
}

bool AbslParseFlag(absl::string_view text, long long* dst, std::string*) {
  return ParseFlagImpl(text, *dst);
}

bool AbslParseFlag(absl::string_view text, unsigned long long* dst,
                   std::string*) {
  return ParseFlagImpl(text, *dst);
}

bool AbslParseFlag(absl::string_view text, absl::int128* dst, std::string*) {
  text = absl::StripAsciiWhitespace(text);

  // check hex
  int base = NumericBase(text);
  if (!absl::numbers_internal::safe_strto128_base(text, dst, base)) {
    return false;
  }

  return base == 16 ? absl::SimpleHexAtoi(text, dst)
                    : absl::SimpleAtoi(text, dst);
}

bool AbslParseFlag(absl::string_view text, absl::uint128* dst, std::string*) {
  text = absl::StripAsciiWhitespace(text);

  // check hex
  int base = NumericBase(text);
  if (!absl::numbers_internal::safe_strtou128_base(text, dst, base)) {
    return false;
  }

  return base == 16 ? absl::SimpleHexAtoi(text, dst)
                    : absl::SimpleAtoi(text, dst);
}

// --------------------------------------------------------------------
// AbslParseFlag for floating point types.

bool AbslParseFlag(absl::string_view text, float* dst, std::string*) {
  return absl::SimpleAtof(text, dst);
}

bool AbslParseFlag(absl::string_view text, double* dst, std::string*) {
  return absl::SimpleAtod(text, dst);
}

// --------------------------------------------------------------------
// AbslParseFlag for strings.

bool AbslParseFlag(absl::string_view text, std::string* dst, std::string*) {
  dst->assign(text.data(), text.size());
  return true;
}

// --------------------------------------------------------------------
// AbslParseFlag for vector of strings.

bool AbslParseFlag(absl::string_view text, std::vector<std::string>* dst,
                   std::string*) {
  // An empty flag value corresponds to an empty vector, not a vector
  // with a single, empty std::string.
  if (text.empty()) {
    dst->clear();
    return true;
  }
  *dst = absl::StrSplit(text, ',', absl::AllowEmpty());
  return true;
}

// --------------------------------------------------------------------
// AbslUnparseFlag specializations for various builtin flag types.

std::string Unparse(bool v) { return v ? "true" : "false"; }
std::string Unparse(short v) { return absl::StrCat(v); }
std::string Unparse(unsigned short v) { return absl::StrCat(v); }
std::string Unparse(int v) { return absl::StrCat(v); }
std::string Unparse(unsigned int v) { return absl::StrCat(v); }
std::string Unparse(long v) { return absl::StrCat(v); }
std::string Unparse(unsigned long v) { return absl::StrCat(v); }
std::string Unparse(long long v) { return absl::StrCat(v); }
std::string Unparse(unsigned long long v) { return absl::StrCat(v); }
std::string Unparse(absl::int128 v) {
  std::stringstream ss;
  ss << v;
  return ss.str();
}
std::string Unparse(absl::uint128 v) {
  std::stringstream ss;
  ss << v;
  return ss.str();
}

template <typename T>
std::string UnparseFloatingPointVal(T v) {
  // digits10 is guaranteed to roundtrip correctly in string -> value -> string
  // conversions, but may not be enough to represent all the values correctly.
  std::string digit10_str =
      absl::StrFormat("%.*g", std::numeric_limits<T>::digits10, v);
  if (std::isnan(v) || std::isinf(v)) return digit10_str;

  T roundtrip_val = 0;
  std::string err;
  if (absl::ParseFlag(digit10_str, &roundtrip_val, &err) &&
      roundtrip_val == v) {
    return digit10_str;
  }

  // max_digits10 is the number of base-10 digits that are necessary to uniquely
  // represent all distinct values.
  return absl::StrFormat("%.*g", std::numeric_limits<T>::max_digits10, v);
}
std::string Unparse(float v) { return UnparseFloatingPointVal(v); }
std::string Unparse(double v) { return UnparseFloatingPointVal(v); }
std::string AbslUnparseFlag(absl::string_view v) { return std::string(v); }
std::string AbslUnparseFlag(const std::vector<std::string>& v) {
  return absl::StrJoin(v, ",");
}

}  // namespace flags_internal

bool AbslParseFlag(absl::string_view text, absl::LogSeverity* dst,
                   std::string* err) {
  text = absl::StripAsciiWhitespace(text);
  if (text.empty()) {
    *err = "no value provided";
    return false;
  }
  if (absl::EqualsIgnoreCase(text, "dfatal")) {
    *dst = absl::kLogDebugFatal;
    return true;
  }
  if (absl::EqualsIgnoreCase(text, "klogdebugfatal")) {
    *dst = absl::kLogDebugFatal;
    return true;
  }
  if (text.front() == 'k' || text.front() == 'K') text.remove_prefix(1);
  if (absl::EqualsIgnoreCase(text, "info")) {
    *dst = absl::LogSeverity::kInfo;
    return true;
  }
  if (absl::EqualsIgnoreCase(text, "warning")) {
    *dst = absl::LogSeverity::kWarning;
    return true;
  }
  if (absl::EqualsIgnoreCase(text, "error")) {
    *dst = absl::LogSeverity::kError;
    return true;
  }
  if (absl::EqualsIgnoreCase(text, "fatal")) {
    *dst = absl::LogSeverity::kFatal;
    return true;
  }
  std::underlying_type<absl::LogSeverity>::type numeric_value;
  if (absl::ParseFlag(text, &numeric_value, err)) {
    *dst = static_cast<absl::LogSeverity>(numeric_value);
    return true;
  }
  *err =
      "only integers, absl::LogSeverity enumerators, and DFATAL are accepted";
  return false;
}

std::string AbslUnparseFlag(absl::LogSeverity v) {
  if (v == absl::NormalizeLogSeverity(v)) return absl::LogSeverityName(v);
  return absl::UnparseFlag(static_cast<int>(v));
}

ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/marshalling.h                                 0000664 0000000 0000000 00000032730 14746647661 0025111 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
//  Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// -----------------------------------------------------------------------------
// File: marshalling.h
// -----------------------------------------------------------------------------
//
// This header file defines the API for extending Abseil flag support to
// custom types, and defines the set of overloads for fundamental types.
//
// Out of the box, the Abseil flags library supports the following types:
//
// * `bool`
// * `int16_t`
// * `uint16_t`
// * `int32_t`
// * `uint32_t`
// * `int64_t`
// * `uint64_t`
// * `float`
// * `double`
// * `std::string`
// * `std::vector<std::string>`
// * `std::optional<T>`
// * `absl::LogSeverity` (provided natively for layering reasons)
//
// Note that support for integral types is implemented using overloads for
// variable-width fundamental types (`short`, `int`, `long`, etc.). However,
// you should prefer the fixed-width integral types (`int32_t`, `uint64_t`,
// etc.) we've noted above within flag definitions.
//
// In addition, several Abseil libraries provide their own custom support for
// Abseil flags. Documentation for these formats is provided in the type's
// `AbslParseFlag()` definition.
//
// The Abseil time library provides the following support for civil time values:
//
// * `absl::CivilSecond`
// * `absl::CivilMinute`
// * `absl::CivilHour`
// * `absl::CivilDay`
// * `absl::CivilMonth`
// * `absl::CivilYear`
//
// and also provides support for the following absolute time values:
//
// * `absl::Duration`
// * `absl::Time`
//
// Additional support for Abseil types will be noted here as it is added.
//
// You can also provide your own custom flags by adding overloads for
// `AbslParseFlag()` and `AbslUnparseFlag()` to your type definitions. (See
// below.)
//
// -----------------------------------------------------------------------------
// Optional Flags
// -----------------------------------------------------------------------------
//
// The Abseil flags library supports flags of type `std::optional<T>` where
// `T` is a type of one of the supported flags. We refer to this flag type as
// an "optional flag." An optional flag is either "valueless", holding no value
// of type `T` (indicating that the flag has not been set) or a value of type
// `T`. The valueless state in C++ code is represented by a value of
// `std::nullopt` for the optional flag.
//
// Using `std::nullopt` as an optional flag's default value allows you to check
// whether such a flag was ever specified on the command line:
//
//   if (absl::GetFlag(FLAGS_foo).has_value()) {
//     // flag was set on command line
//   } else {
//     // flag was not passed on command line
//   }
//
// Using an optional flag in this manner avoids common workarounds for
// indicating such an unset flag (such as using sentinel values to indicate this
// state).
//
// An optional flag also allows a developer to pass a flag in an "unset"
// valueless state on the command line, allowing the flag to later be set in
// binary logic. An optional flag's valueless state is indicated by the special
// notation of passing the value as an empty string through the syntax `--flag=`
// or `--flag ""`.
//
//   $ binary_with_optional --flag_in_unset_state=
//   $ binary_with_optional --flag_in_unset_state ""
//
// Note: as a result of the above syntax requirements, an optional flag cannot
// be set to a `T` of any value which unparses to the empty string.
//
// -----------------------------------------------------------------------------
// Adding Type Support for Abseil Flags
// -----------------------------------------------------------------------------
//
// To add support for your user-defined type, add overloads of `AbslParseFlag()`
// and `AbslUnparseFlag()` as free (non-member) functions to your type. If `T`
// is a class type, these functions can be friend function definitions. These
// overloads must be added to the same namespace where the type is defined, so
// that they can be discovered by Argument-Dependent Lookup (ADL).
//
// Example:
//
//   namespace foo {
//
//   enum OutputMode { kPlainText, kHtml };
//
//   // AbslParseFlag converts from a string to OutputMode.
//   // Must be in same namespace as OutputMode.
//
//   // Parses an OutputMode from the command line flag value `text`. Returns
//   // `true` and sets `*mode` on success; returns `false` and sets `*error`
//   // on failure.
//   bool AbslParseFlag(absl::string_view text,
//                      OutputMode* mode,
//                      std::string* error) {
//     if (text == "plaintext") {
//       *mode = kPlainText;
//       return true;
//     }
//     if (text == "html") {
//       *mode = kHtml;
//      return true;
//     }
//     *error = "unknown value for enumeration";
//     return false;
//  }
//
//  // AbslUnparseFlag converts from an OutputMode to a string.
//  // Must be in same namespace as OutputMode.
//
//  // Returns a textual flag value corresponding to the OutputMode `mode`.
//  std::string AbslUnparseFlag(OutputMode mode) {
//    switch (mode) {
//      case kPlainText: return "plaintext";
//      case kHtml: return "html";
//    }
//    return absl::StrCat(mode);
//  }
//
// Notice that neither `AbslParseFlag()` nor `AbslUnparseFlag()` are class
// members, but free functions. `AbslParseFlag/AbslUnparseFlag()` overloads
// for a type should only be declared in the same file and namespace as said
// type. The proper `AbslParseFlag/AbslUnparseFlag()` implementations for a
// given type will be discovered via Argument-Dependent Lookup (ADL).
//
// `AbslParseFlag()` may need, in turn, to parse simpler constituent types
// using `absl::ParseFlag()`. For example, a custom struct `MyFlagType`
// consisting of a `std::pair<int, std::string>` would add an `AbslParseFlag()`
// overload for its `MyFlagType` like so:
//
// Example:
//
//   namespace my_flag_type {
//
//   struct MyFlagType {
//     std::pair<int, std::string> my_flag_data;
//   };
//
//   bool AbslParseFlag(absl::string_view text, MyFlagType* flag,
//                      std::string* err);
//
//   std::string AbslUnparseFlag(const MyFlagType&);
//
//   // Within the implementation, `AbslParseFlag()` will, in turn invoke
//   // `absl::ParseFlag()` on its constituent `int` and `std::string` types
//   // (which have built-in Abseil flag support).
//
//   bool AbslParseFlag(absl::string_view text, MyFlagType* flag,
//                      std::string* err) {
//     std::pair<absl::string_view, absl::string_view> tokens =
//         absl::StrSplit(text, ',');
//     if (!absl::ParseFlag(tokens.first, &flag->my_flag_data.first, err))
//         return false;
//     if (!absl::ParseFlag(tokens.second, &flag->my_flag_data.second, err))
//         return false;
//     return true;
//   }
//
//   // Similarly, for unparsing, we can simply invoke `absl::UnparseFlag()` on
//   // the constituent types.
//   std::string AbslUnparseFlag(const MyFlagType& flag) {
//     return absl::StrCat(absl::UnparseFlag(flag.my_flag_data.first),
//                         ",",
//                         absl::UnparseFlag(flag.my_flag_data.second));
//   }
#ifndef ABSL_FLAGS_MARSHALLING_H_
#define ABSL_FLAGS_MARSHALLING_H_

#include "absl/base/config.h"
#include "absl/numeric/int128.h"

#if defined(ABSL_HAVE_STD_OPTIONAL) && !defined(ABSL_USES_STD_OPTIONAL)
#include <optional>
#endif
#include <string>
#include <vector>

#include "absl/strings/string_view.h"
#include "absl/types/optional.h"

namespace absl {
ABSL_NAMESPACE_BEGIN

// Forward declaration to be used inside composable flag parse/unparse
// implementations
template <typename T>
inline bool ParseFlag(absl::string_view input, T* dst, std::string* error);
template <typename T>
inline std::string UnparseFlag(const T& v);

namespace flags_internal {

// Overloads of `AbslParseFlag()` and `AbslUnparseFlag()` for fundamental types.
bool AbslParseFlag(absl::string_view, bool*, std::string*);
bool AbslParseFlag(absl::string_view, short*, std::string*);           // NOLINT
bool AbslParseFlag(absl::string_view, unsigned short*, std::string*);  // NOLINT
bool AbslParseFlag(absl::string_view, int*, std::string*);             // NOLINT
bool AbslParseFlag(absl::string_view, unsigned int*, std::string*);    // NOLINT
bool AbslParseFlag(absl::string_view, long*, std::string*);            // NOLINT
bool AbslParseFlag(absl::string_view, unsigned long*, std::string*);   // NOLINT
bool AbslParseFlag(absl::string_view, long long*, std::string*);       // NOLINT
bool AbslParseFlag(absl::string_view, unsigned long long*,             // NOLINT
                   std::string*);
bool AbslParseFlag(absl::string_view, absl::int128*, std::string*);    // NOLINT
bool AbslParseFlag(absl::string_view, absl::uint128*, std::string*);   // NOLINT
bool AbslParseFlag(absl::string_view, float*, std::string*);
bool AbslParseFlag(absl::string_view, double*, std::string*);
bool AbslParseFlag(absl::string_view, std::string*, std::string*);
bool AbslParseFlag(absl::string_view, std::vector<std::string>*, std::string*);

template <typename T>
bool AbslParseFlag(absl::string_view text, absl::optional<T>* f,
                   std::string* err) {
  if (text.empty()) {
    *f = absl::nullopt;
    return true;
  }
  T value;
  if (!absl::ParseFlag(text, &value, err)) return false;

  *f = std::move(value);
  return true;
}

#if defined(ABSL_HAVE_STD_OPTIONAL) && !defined(ABSL_USES_STD_OPTIONAL)
template <typename T>
bool AbslParseFlag(absl::string_view text, std::optional<T>* f,
                   std::string* err) {
  if (text.empty()) {
    *f = std::nullopt;
    return true;
  }
  T value;
  if (!absl::ParseFlag(text, &value, err)) return false;

  *f = std::move(value);
  return true;
}
#endif

template <typename T>
bool InvokeParseFlag(absl::string_view input, T* dst, std::string* err) {
  // Comment on next line provides a good compiler error message if T
  // does not have AbslParseFlag(absl::string_view, T*, std::string*).
  return AbslParseFlag(input, dst, err);  // Is T missing AbslParseFlag?
}

// Strings and std:: containers do not have the same overload resolution
// considerations as fundamental types. Naming these 'AbslUnparseFlag' means we
// can avoid the need for additional specializations of Unparse (below).
std::string AbslUnparseFlag(absl::string_view v);
std::string AbslUnparseFlag(const std::vector<std::string>&);

template <typename T>
std::string AbslUnparseFlag(const absl::optional<T>& f) {
  return f.has_value() ? absl::UnparseFlag(*f) : "";
}

#if defined(ABSL_HAVE_STD_OPTIONAL) && !defined(ABSL_USES_STD_OPTIONAL)
template <typename T>
std::string AbslUnparseFlag(const std::optional<T>& f) {
  return f.has_value() ? absl::UnparseFlag(*f) : "";
}
#endif

template <typename T>
std::string Unparse(const T& v) {
  // Comment on next line provides a good compiler error message if T does not
  // have UnparseFlag.
  return AbslUnparseFlag(v);  // Is T missing AbslUnparseFlag?
}

// Overloads for builtin types.
std::string Unparse(bool v);
std::string Unparse(short v);               // NOLINT
std::string Unparse(unsigned short v);      // NOLINT
std::string Unparse(int v);                 // NOLINT
std::string Unparse(unsigned int v);        // NOLINT
std::string Unparse(long v);                // NOLINT
std::string Unparse(unsigned long v);       // NOLINT
std::string Unparse(long long v);           // NOLINT
std::string Unparse(unsigned long long v);  // NOLINT
std::string Unparse(absl::int128 v);
std::string Unparse(absl::uint128 v);
std::string Unparse(float v);
std::string Unparse(double v);

}  // namespace flags_internal

// ParseFlag()
//
// Parses a string value into a flag value of type `T`. Do not add overloads of
// this function for your type directly; instead, add an `AbslParseFlag()`
// free function as documented above.
//
// Some implementations of `AbslParseFlag()` for types which consist of other,
// constituent types which already have Abseil flag support, may need to call
// `absl::ParseFlag()` on those consituent string values. (See above.)
template <typename T>
inline bool ParseFlag(absl::string_view input, T* dst, std::string* error) {
  return flags_internal::InvokeParseFlag(input, dst, error);
}

// UnparseFlag()
//
// Unparses a flag value of type `T` into a string value. Do not add overloads
// of this function for your type directly; instead, add an `AbslUnparseFlag()`
// free function as documented above.
//
// Some implementations of `AbslUnparseFlag()` for types which consist of other,
// constituent types which already have Abseil flag support, may want to call
// `absl::UnparseFlag()` on those constituent types. (See above.)
template <typename T>
inline std::string UnparseFlag(const T& v) {
  return flags_internal::Unparse(v);
}

// Overloads for `absl::LogSeverity` can't (easily) appear alongside that type's
// definition because it is layered below flags.  See proper documentation in
// base/log_severity.h.
enum class LogSeverity : int;
bool AbslParseFlag(absl::string_view, absl::LogSeverity*, std::string*);
std::string AbslUnparseFlag(absl::LogSeverity);

ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_FLAGS_MARSHALLING_H_
                                        node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/marshalling_test.cc                           0000664 0000000 0000000 00000115645 14746647661 0026315 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
//  Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/flags/marshalling.h"

#include <stdint.h>

#include <cmath>
#include <limits>
#include <string>
#include <vector>

#include "gtest/gtest.h"

namespace {

TEST(MarshallingTest, TestBoolParsing) {
  std::string err;
  bool value;

  // True values.
  EXPECT_TRUE(absl::ParseFlag("True", &value, &err));
  EXPECT_TRUE(value);
  EXPECT_TRUE(absl::ParseFlag("true", &value, &err));
  EXPECT_TRUE(value);
  EXPECT_TRUE(absl::ParseFlag("TRUE", &value, &err));
  EXPECT_TRUE(value);

  EXPECT_TRUE(absl::ParseFlag("Yes", &value, &err));
  EXPECT_TRUE(value);
  EXPECT_TRUE(absl::ParseFlag("yes", &value, &err));
  EXPECT_TRUE(value);
  EXPECT_TRUE(absl::ParseFlag("YES", &value, &err));
  EXPECT_TRUE(value);

  EXPECT_TRUE(absl::ParseFlag("t", &value, &err));
  EXPECT_TRUE(value);
  EXPECT_TRUE(absl::ParseFlag("T", &value, &err));
  EXPECT_TRUE(value);

  EXPECT_TRUE(absl::ParseFlag("y", &value, &err));
  EXPECT_TRUE(value);
  EXPECT_TRUE(absl::ParseFlag("Y", &value, &err));
  EXPECT_TRUE(value);

  EXPECT_TRUE(absl::ParseFlag("1", &value, &err));
  EXPECT_TRUE(value);

  // False values.
  EXPECT_TRUE(absl::ParseFlag("False", &value, &err));
  EXPECT_FALSE(value);
  EXPECT_TRUE(absl::ParseFlag("false", &value, &err));
  EXPECT_FALSE(value);
  EXPECT_TRUE(absl::ParseFlag("FALSE", &value, &err));
  EXPECT_FALSE(value);

  EXPECT_TRUE(absl::ParseFlag("No", &value, &err));
  EXPECT_FALSE(value);
  EXPECT_TRUE(absl::ParseFlag("no", &value, &err));
  EXPECT_FALSE(value);
  EXPECT_TRUE(absl::ParseFlag("NO", &value, &err));
  EXPECT_FALSE(value);

  EXPECT_TRUE(absl::ParseFlag("f", &value, &err));
  EXPECT_FALSE(value);
  EXPECT_TRUE(absl::ParseFlag("F", &value, &err));
  EXPECT_FALSE(value);

  EXPECT_TRUE(absl::ParseFlag("n", &value, &err));
  EXPECT_FALSE(value);
  EXPECT_TRUE(absl::ParseFlag("N", &value, &err));
  EXPECT_FALSE(value);

  EXPECT_TRUE(absl::ParseFlag("0", &value, &err));
  EXPECT_FALSE(value);

  // Whitespace handling.
  EXPECT_TRUE(absl::ParseFlag("  true", &value, &err));
  EXPECT_TRUE(value);
  EXPECT_TRUE(absl::ParseFlag("true  ", &value, &err));
  EXPECT_TRUE(value);
  EXPECT_TRUE(absl::ParseFlag("  true   ", &value, &err));
  EXPECT_TRUE(value);

  // Invalid input.
  EXPECT_FALSE(absl::ParseFlag("", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("  ", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("\n", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("\t", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("2", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("11", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("tt", &value, &err));
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestInt16Parsing) {
  std::string err;
  int16_t value;

  // Decimal values.
  EXPECT_TRUE(absl::ParseFlag("1", &value, &err));
  EXPECT_EQ(value, 1);
  EXPECT_TRUE(absl::ParseFlag("0", &value, &err));
  EXPECT_EQ(value, 0);
  EXPECT_TRUE(absl::ParseFlag("-1", &value, &err));
  EXPECT_EQ(value, -1);
  EXPECT_TRUE(absl::ParseFlag("123", &value, &err));
  EXPECT_EQ(value, 123);
  EXPECT_TRUE(absl::ParseFlag("-18765", &value, &err));
  EXPECT_EQ(value, -18765);
  EXPECT_TRUE(absl::ParseFlag("+3", &value, &err));
  EXPECT_EQ(value, 3);

  // Leading zero values.
  EXPECT_TRUE(absl::ParseFlag("01", &value, &err));
  EXPECT_EQ(value, 1);
  EXPECT_TRUE(absl::ParseFlag("-001", &value, &err));
  EXPECT_EQ(value, -1);
  EXPECT_TRUE(absl::ParseFlag("0000100", &value, &err));
  EXPECT_EQ(value, 100);

  // Hex values.
  EXPECT_TRUE(absl::ParseFlag("0x10", &value, &err));
  EXPECT_EQ(value, 16);
  EXPECT_TRUE(absl::ParseFlag("0X234", &value, &err));
  EXPECT_EQ(value, 564);
  EXPECT_TRUE(absl::ParseFlag("-0x7FFD", &value, &err));
  EXPECT_EQ(value, -32765);
  EXPECT_TRUE(absl::ParseFlag("+0x31", &value, &err));
  EXPECT_EQ(value, 49);

  // Whitespace handling
  EXPECT_TRUE(absl::ParseFlag("10  ", &value, &err));
  EXPECT_EQ(value, 10);
  EXPECT_TRUE(absl::ParseFlag("  11", &value, &err));
  EXPECT_EQ(value, 11);
  EXPECT_TRUE(absl::ParseFlag("  012  ", &value, &err));
  EXPECT_EQ(value, 12);
  EXPECT_TRUE(absl::ParseFlag(" 0x22    ", &value, &err));
  EXPECT_EQ(value, 34);

  // Invalid values.
  EXPECT_FALSE(absl::ParseFlag("", &value, &err));
  EXPECT_FALSE(absl::ParseFlag(" ", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("  ", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("40000", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("--1", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("\n", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("\t", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("2U", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("FFF", &value, &err));
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestUint16Parsing) {
  std::string err;
  uint16_t value;

  // Decimal values.
  EXPECT_TRUE(absl::ParseFlag("1", &value, &err));
  EXPECT_EQ(value, 1);
  EXPECT_TRUE(absl::ParseFlag("0", &value, &err));
  EXPECT_EQ(value, 0);
  EXPECT_TRUE(absl::ParseFlag("123", &value, &err));
  EXPECT_EQ(value, 123);
  EXPECT_TRUE(absl::ParseFlag("+3", &value, &err));
  EXPECT_EQ(value, 3);

  // Leading zero values.
  EXPECT_TRUE(absl::ParseFlag("01", &value, &err));
  EXPECT_EQ(value, 1);
  EXPECT_TRUE(absl::ParseFlag("001", &value, &err));
  EXPECT_EQ(value, 1);
  EXPECT_TRUE(absl::ParseFlag("0000100", &value, &err));
  EXPECT_EQ(value, 100);

  // Hex values.
  EXPECT_TRUE(absl::ParseFlag("0x10", &value, &err));
  EXPECT_EQ(value, 16);
  EXPECT_TRUE(absl::ParseFlag("0X234", &value, &err));
  EXPECT_EQ(value, 564);
  EXPECT_TRUE(absl::ParseFlag("+0x31", &value, &err));
  EXPECT_EQ(value, 49);

  // Whitespace handling
  EXPECT_TRUE(absl::ParseFlag("10  ", &value, &err));
  EXPECT_EQ(value, 10);
  EXPECT_TRUE(absl::ParseFlag("  11", &value, &err));
  EXPECT_EQ(value, 11);
  EXPECT_TRUE(absl::ParseFlag("  012  ", &value, &err));
  EXPECT_EQ(value, 12);
  EXPECT_TRUE(absl::ParseFlag(" 0x22    ", &value, &err));
  EXPECT_EQ(value, 34);

  // Invalid values.
  EXPECT_FALSE(absl::ParseFlag("", &value, &err));
  EXPECT_FALSE(absl::ParseFlag(" ", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("  ", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("70000", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("-1", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("--1", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("\n", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("\t", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("2U", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("FFF", &value, &err));
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestInt32Parsing) {
  std::string err;
  int32_t value;

  // Decimal values.
  EXPECT_TRUE(absl::ParseFlag("1", &value, &err));
  EXPECT_EQ(value, 1);
  EXPECT_TRUE(absl::ParseFlag("0", &value, &err));
  EXPECT_EQ(value, 0);
  EXPECT_TRUE(absl::ParseFlag("-1", &value, &err));
  EXPECT_EQ(value, -1);
  EXPECT_TRUE(absl::ParseFlag("123", &value, &err));
  EXPECT_EQ(value, 123);
  EXPECT_TRUE(absl::ParseFlag("-98765", &value, &err));
  EXPECT_EQ(value, -98765);
  EXPECT_TRUE(absl::ParseFlag("+3", &value, &err));
  EXPECT_EQ(value, 3);

  // Leading zero values.
  EXPECT_TRUE(absl::ParseFlag("01", &value, &err));
  EXPECT_EQ(value, 1);
  EXPECT_TRUE(absl::ParseFlag("-001", &value, &err));
  EXPECT_EQ(value, -1);
  EXPECT_TRUE(absl::ParseFlag("0000100", &value, &err));
  EXPECT_EQ(value, 100);

  // Hex values.
  EXPECT_TRUE(absl::ParseFlag("0x10", &value, &err));
  EXPECT_EQ(value, 16);
  EXPECT_TRUE(absl::ParseFlag("0X234", &value, &err));
  EXPECT_EQ(value, 564);

  EXPECT_TRUE(absl::ParseFlag("-0x7FFFFFFD", &value, &err));
  EXPECT_EQ(value, -2147483645);
  EXPECT_TRUE(absl::ParseFlag("+0x31", &value, &err));
  EXPECT_EQ(value, 49);

  // Whitespace handling
  EXPECT_TRUE(absl::ParseFlag("10  ", &value, &err));
  EXPECT_EQ(value, 10);
  EXPECT_TRUE(absl::ParseFlag("  11", &value, &err));
  EXPECT_EQ(value, 11);
  EXPECT_TRUE(absl::ParseFlag("  012  ", &value, &err));
  EXPECT_EQ(value, 12);
  EXPECT_TRUE(absl::ParseFlag(" 0x22    ", &value, &err));
  EXPECT_EQ(value, 34);

  // Invalid values.
  EXPECT_FALSE(absl::ParseFlag("", &value, &err));
  EXPECT_FALSE(absl::ParseFlag(" ", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("  ", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("70000000000", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("--1", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("\n", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("\t", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("2U", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("FFF", &value, &err));
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestUint32Parsing) {
  std::string err;
  uint32_t value;

  // Decimal values.
  EXPECT_TRUE(absl::ParseFlag("1", &value, &err));
  EXPECT_EQ(value, 1);
  EXPECT_TRUE(absl::ParseFlag("0", &value, &err));
  EXPECT_EQ(value, 0);
  EXPECT_TRUE(absl::ParseFlag("123", &value, &err));
  EXPECT_EQ(value, 123);
  EXPECT_TRUE(absl::ParseFlag("+3", &value, &err));
  EXPECT_EQ(value, 3);

  // Leading zero values.
  EXPECT_TRUE(absl::ParseFlag("01", &value, &err));
  EXPECT_EQ(value, 1);
  EXPECT_TRUE(absl::ParseFlag("0000100", &value, &err));
  EXPECT_EQ(value, 100);

  // Hex values.
  EXPECT_TRUE(absl::ParseFlag("0x10", &value, &err));
  EXPECT_EQ(value, 16);
  EXPECT_TRUE(absl::ParseFlag("0X234", &value, &err));
  EXPECT_EQ(value, 564);
  EXPECT_TRUE(absl::ParseFlag("0xFFFFFFFD", &value, &err));
  EXPECT_EQ(value, 4294967293);
  EXPECT_TRUE(absl::ParseFlag("+0x31", &value, &err));
  EXPECT_EQ(value, 49);

  // Whitespace handling
  EXPECT_TRUE(absl::ParseFlag("10  ", &value, &err));
  EXPECT_EQ(value, 10);
  EXPECT_TRUE(absl::ParseFlag("  11", &value, &err));
  EXPECT_EQ(value, 11);
  EXPECT_TRUE(absl::ParseFlag("  012  ", &value, &err));
  EXPECT_EQ(value, 12);
  EXPECT_TRUE(absl::ParseFlag(" 0x22    ", &value, &err));
  EXPECT_EQ(value, 34);

  // Invalid values.
  EXPECT_FALSE(absl::ParseFlag("", &value, &err));
  EXPECT_FALSE(absl::ParseFlag(" ", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("  ", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("140000000000", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("-1", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("--1", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("\n", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("\t", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("2U", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("FFF", &value, &err));
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestInt64Parsing) {
  std::string err;
  int64_t value;

  // Decimal values.
  EXPECT_TRUE(absl::ParseFlag("1", &value, &err));
  EXPECT_EQ(value, 1);
  EXPECT_TRUE(absl::ParseFlag("0", &value, &err));
  EXPECT_EQ(value, 0);
  EXPECT_TRUE(absl::ParseFlag("-1", &value, &err));
  EXPECT_EQ(value, -1);
  EXPECT_TRUE(absl::ParseFlag("123", &value, &err));
  EXPECT_EQ(value, 123);
  EXPECT_TRUE(absl::ParseFlag("-98765", &value, &err));
  EXPECT_EQ(value, -98765);
  EXPECT_TRUE(absl::ParseFlag("+3", &value, &err));
  EXPECT_EQ(value, 3);

  // Leading zero values.
  EXPECT_TRUE(absl::ParseFlag("01", &value, &err));
  EXPECT_EQ(value, 1);
  EXPECT_TRUE(absl::ParseFlag("001", &value, &err));
  EXPECT_EQ(value, 1);
  EXPECT_TRUE(absl::ParseFlag("0000100", &value, &err));
  EXPECT_EQ(value, 100);

  // Hex values.
  EXPECT_TRUE(absl::ParseFlag("0x10", &value, &err));
  EXPECT_EQ(value, 16);
  EXPECT_TRUE(absl::ParseFlag("0XFFFAAABBBCCCDDD", &value, &err));
  EXPECT_EQ(value, 1152827684197027293);
  EXPECT_TRUE(absl::ParseFlag("-0x7FFFFFFFFFFFFFFE", &value, &err));
  EXPECT_EQ(value, -9223372036854775806);
  EXPECT_TRUE(absl::ParseFlag("-0x02", &value, &err));
  EXPECT_EQ(value, -2);
  EXPECT_TRUE(absl::ParseFlag("+0x31", &value, &err));
  EXPECT_EQ(value, 49);

  // Whitespace handling
  EXPECT_TRUE(absl::ParseFlag("10  ", &value, &err));
  EXPECT_EQ(value, 10);
  EXPECT_TRUE(absl::ParseFlag("  11", &value, &err));
  EXPECT_EQ(value, 11);
  EXPECT_TRUE(absl::ParseFlag("  012  ", &value, &err));
  EXPECT_EQ(value, 12);
  EXPECT_TRUE(absl::ParseFlag(" 0x7F    ", &value, &err));
  EXPECT_EQ(value, 127);

  // Invalid values.
  EXPECT_FALSE(absl::ParseFlag("", &value, &err));
  EXPECT_FALSE(absl::ParseFlag(" ", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("  ", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("0xFFFFFFFFFFFFFFFFFF", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("--1", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("\n", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("\t", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("2U", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("FFF", &value, &err));
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestUInt64Parsing) {
  std::string err;
  uint64_t value;

  // Decimal values.
  EXPECT_TRUE(absl::ParseFlag("1", &value, &err));
  EXPECT_EQ(value, 1);
  EXPECT_TRUE(absl::ParseFlag("0", &value, &err));
  EXPECT_EQ(value, 0);
  EXPECT_TRUE(absl::ParseFlag("123", &value, &err));
  EXPECT_EQ(value, 123);
  EXPECT_TRUE(absl::ParseFlag("+13", &value, &err));
  EXPECT_EQ(value, 13);

  // Leading zero values.
  EXPECT_TRUE(absl::ParseFlag("01", &value, &err));
  EXPECT_EQ(value, 1);
  EXPECT_TRUE(absl::ParseFlag("001", &value, &err));
  EXPECT_EQ(value, 1);
  EXPECT_TRUE(absl::ParseFlag("0000300", &value, &err));
  EXPECT_EQ(value, 300);

  // Hex values.
  EXPECT_TRUE(absl::ParseFlag("0x10", &value, &err));
  EXPECT_EQ(value, 16);
  EXPECT_TRUE(absl::ParseFlag("0XFFFF", &value, &err));
  EXPECT_EQ(value, 65535);
  EXPECT_TRUE(absl::ParseFlag("+0x31", &value, &err));
  EXPECT_EQ(value, 49);

  // Whitespace handling
  EXPECT_TRUE(absl::ParseFlag("10  ", &value, &err));
  EXPECT_EQ(value, 10);
  EXPECT_TRUE(absl::ParseFlag("  11", &value, &err));
  EXPECT_EQ(value, 11);
  EXPECT_TRUE(absl::ParseFlag("  012  ", &value, &err));
  EXPECT_EQ(value, 12);

  // Invalid values.
  EXPECT_FALSE(absl::ParseFlag("", &value, &err));
  EXPECT_FALSE(absl::ParseFlag(" ", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("  ", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("0xFFFFFFFFFFFFFFFFFF", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("-1", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("--1", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("\n", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("\t", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("2U", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("FFF", &value, &err));
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestInt128Parsing) {
  std::string err;
  absl::int128 value;

  // Decimal values.
  EXPECT_TRUE(absl::ParseFlag("0", &value, &err));
  EXPECT_EQ(value, 0);
  EXPECT_TRUE(absl::ParseFlag("1", &value, &err));
  EXPECT_EQ(value, 1);
  EXPECT_TRUE(absl::ParseFlag("-1", &value, &err));
  EXPECT_EQ(value, -1);
  EXPECT_TRUE(absl::ParseFlag("123", &value, &err));
  EXPECT_EQ(value, 123);
  EXPECT_TRUE(absl::ParseFlag("-98765", &value, &err));
  EXPECT_EQ(value, -98765);
  EXPECT_TRUE(absl::ParseFlag("+3", &value, &err));
  EXPECT_EQ(value, 3);

  // Leading zero values.
  EXPECT_TRUE(absl::ParseFlag("01", &value, &err));
  EXPECT_EQ(value, 1);
  EXPECT_TRUE(absl::ParseFlag("001", &value, &err));
  EXPECT_EQ(value, 1);
  EXPECT_TRUE(absl::ParseFlag("0000100", &value, &err));
  EXPECT_EQ(value, 100);

  // Hex values.
  EXPECT_TRUE(absl::ParseFlag("0x10", &value, &err));
  EXPECT_EQ(value, 16);
  EXPECT_TRUE(absl::ParseFlag("0xFFFAAABBBCCCDDD", &value, &err));
  EXPECT_EQ(value, 1152827684197027293);
  EXPECT_TRUE(absl::ParseFlag("0xFFF0FFFFFFFFFFFFFFF", &value, &err));
  EXPECT_EQ(value, absl::MakeInt128(0x000000000000fff, 0xFFFFFFFFFFFFFFF));

  EXPECT_TRUE(absl::ParseFlag("-0x10000000000000000", &value, &err));
  EXPECT_EQ(value, absl::MakeInt128(-1, 0));
  EXPECT_TRUE(absl::ParseFlag("+0x31", &value, &err));
  EXPECT_EQ(value, 49);

  // Whitespace handling
  EXPECT_TRUE(absl::ParseFlag("16  ", &value, &err));
  EXPECT_EQ(value, 16);
  EXPECT_TRUE(absl::ParseFlag("  16", &value, &err));
  EXPECT_EQ(value, 16);
  EXPECT_TRUE(absl::ParseFlag("  0100  ", &value, &err));
  EXPECT_EQ(value, 100);
  EXPECT_TRUE(absl::ParseFlag(" 0x7B    ", &value, &err));
  EXPECT_EQ(value, 123);

  // Invalid values.
  EXPECT_FALSE(absl::ParseFlag("", &value, &err));
  EXPECT_FALSE(absl::ParseFlag(" ", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("  ", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("--1", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("\n", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("\t", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("2U", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("FFF", &value, &err));
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestUint128Parsing) {
  std::string err;
  absl::uint128 value;

  // Decimal values.
  EXPECT_TRUE(absl::ParseFlag("0", &value, &err));
  EXPECT_EQ(value, 0);
  EXPECT_TRUE(absl::ParseFlag("1", &value, &err));
  EXPECT_EQ(value, 1);
  EXPECT_TRUE(absl::ParseFlag("123", &value, &err));
  EXPECT_EQ(value, 123);
  EXPECT_TRUE(absl::ParseFlag("+3", &value, &err));
  EXPECT_EQ(value, 3);

  // Leading zero values.
  EXPECT_TRUE(absl::ParseFlag("01", &value, &err));
  EXPECT_EQ(value, 1);
  EXPECT_TRUE(absl::ParseFlag("001", &value, &err));
  EXPECT_EQ(value, 1);
  EXPECT_TRUE(absl::ParseFlag("0000100", &value, &err));
  EXPECT_EQ(value, 100);

  // Hex values.
  EXPECT_TRUE(absl::ParseFlag("0x10", &value, &err));
  EXPECT_EQ(value, 16);
  EXPECT_TRUE(absl::ParseFlag("0xFFFAAABBBCCCDDD", &value, &err));
  EXPECT_EQ(value, 1152827684197027293);
  EXPECT_TRUE(absl::ParseFlag("0xFFF0FFFFFFFFFFFFFFF", &value, &err));
  EXPECT_EQ(value, absl::MakeInt128(0x000000000000fff, 0xFFFFFFFFFFFFFFF));
  EXPECT_TRUE(absl::ParseFlag("+0x31", &value, &err));
  EXPECT_EQ(value, 49);

  // Whitespace handling
  EXPECT_TRUE(absl::ParseFlag("16  ", &value, &err));
  EXPECT_EQ(value, 16);
  EXPECT_TRUE(absl::ParseFlag("  16", &value, &err));
  EXPECT_EQ(value, 16);
  EXPECT_TRUE(absl::ParseFlag("  0100  ", &value, &err));
  EXPECT_EQ(value, 100);
  EXPECT_TRUE(absl::ParseFlag(" 0x7B    ", &value, &err));
  EXPECT_EQ(value, 123);

  // Invalid values.
  EXPECT_FALSE(absl::ParseFlag("", &value, &err));
  EXPECT_FALSE(absl::ParseFlag(" ", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("  ", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("-1", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("--1", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("\n", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("\t", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("2U", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("FFF", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("-0x10000000000000000", &value, &err));
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestFloatParsing) {
  std::string err;
  float value;

  // Ordinary values.
  EXPECT_TRUE(absl::ParseFlag("1.3", &value, &err));
  EXPECT_FLOAT_EQ(value, 1.3f);
  EXPECT_TRUE(absl::ParseFlag("-0.1", &value, &err));
  EXPECT_DOUBLE_EQ(value, -0.1f);
  EXPECT_TRUE(absl::ParseFlag("+0.01", &value, &err));
  EXPECT_DOUBLE_EQ(value, 0.01f);

  // Scientific values.
  EXPECT_TRUE(absl::ParseFlag("1.2e3", &value, &err));
  EXPECT_DOUBLE_EQ(value, 1.2e3f);
  EXPECT_TRUE(absl::ParseFlag("9.8765402e-37", &value, &err));
  EXPECT_DOUBLE_EQ(value, 9.8765402e-37f);
  EXPECT_TRUE(absl::ParseFlag("0.11e+3", &value, &err));
  EXPECT_DOUBLE_EQ(value, 0.11e+3f);
  EXPECT_TRUE(absl::ParseFlag("1.e-2300", &value, &err));
  EXPECT_DOUBLE_EQ(value, 0.f);
  EXPECT_TRUE(absl::ParseFlag("1.e+2300", &value, &err));
  EXPECT_TRUE(std::isinf(value));

  // Leading zero values.
  EXPECT_TRUE(absl::ParseFlag("01.6", &value, &err));
  EXPECT_DOUBLE_EQ(value, 1.6f);
  EXPECT_TRUE(absl::ParseFlag("000.0001", &value, &err));
  EXPECT_DOUBLE_EQ(value, 0.0001f);

  // Trailing zero values.
  EXPECT_TRUE(absl::ParseFlag("-5.1000", &value, &err));
  EXPECT_DOUBLE_EQ(value, -5.1f);

  // Exceptional values.
  EXPECT_TRUE(absl::ParseFlag("NaN", &value, &err));
  EXPECT_TRUE(std::isnan(value));
  EXPECT_TRUE(absl::ParseFlag("Inf", &value, &err));
  EXPECT_TRUE(std::isinf(value));

  // Hex values
  EXPECT_TRUE(absl::ParseFlag("0x10.23p12", &value, &err));
  EXPECT_DOUBLE_EQ(value, 66096.f);
  EXPECT_TRUE(absl::ParseFlag("-0xF1.A3p-2", &value, &err));
  EXPECT_NEAR(value, -60.4092f, 5e-5f);
  EXPECT_TRUE(absl::ParseFlag("+0x0.0AAp-12", &value, &err));
  EXPECT_NEAR(value, 1.01328e-05f, 5e-11f);
  EXPECT_TRUE(absl::ParseFlag("0x.01p1", &value, &err));
  EXPECT_NEAR(value, 0.0078125f, 5e-8f);

  // Whitespace handling
  EXPECT_TRUE(absl::ParseFlag("10.1  ", &value, &err));
  EXPECT_DOUBLE_EQ(value, 10.1f);
  EXPECT_TRUE(absl::ParseFlag("  2.34", &value, &err));
  EXPECT_DOUBLE_EQ(value, 2.34f);
  EXPECT_TRUE(absl::ParseFlag("  5.7  ", &value, &err));
  EXPECT_DOUBLE_EQ(value, 5.7f);
  EXPECT_TRUE(absl::ParseFlag("  -0xE0.F3p01  ", &value, &err));
  EXPECT_NEAR(value, -449.8984375f, 5e-8f);

  // Invalid values.
  EXPECT_FALSE(absl::ParseFlag("", &value, &err));
  EXPECT_FALSE(absl::ParseFlag(" ", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("  ", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("--1", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("\n", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("\t", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("2.3xxx", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("0x0.1pAA", &value, &err));
  // TODO(rogeeff): below assertion should fail
  EXPECT_TRUE(absl::ParseFlag("0x0.1", &value, &err));
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestDoubleParsing) {
  std::string err;
  double value;

  // Ordinary values.
  EXPECT_TRUE(absl::ParseFlag("1.3", &value, &err));
  EXPECT_DOUBLE_EQ(value, 1.3);
  EXPECT_TRUE(absl::ParseFlag("-0.1", &value, &err));
  EXPECT_DOUBLE_EQ(value, -0.1);
  EXPECT_TRUE(absl::ParseFlag("+0.01", &value, &err));
  EXPECT_DOUBLE_EQ(value, 0.01);

  // Scientific values.
  EXPECT_TRUE(absl::ParseFlag("1.2e3", &value, &err));
  EXPECT_DOUBLE_EQ(value, 1.2e3);
  EXPECT_TRUE(absl::ParseFlag("9.00000002e-123", &value, &err));
  EXPECT_DOUBLE_EQ(value, 9.00000002e-123);
  EXPECT_TRUE(absl::ParseFlag("0.11e+3", &value, &err));
  EXPECT_DOUBLE_EQ(value, 0.11e+3);
  EXPECT_TRUE(absl::ParseFlag("1.e-2300", &value, &err));
  EXPECT_DOUBLE_EQ(value, 0);
  EXPECT_TRUE(absl::ParseFlag("1.e+2300", &value, &err));
  EXPECT_TRUE(std::isinf(value));

  // Leading zero values.
  EXPECT_TRUE(absl::ParseFlag("01.6", &value, &err));
  EXPECT_DOUBLE_EQ(value, 1.6);
  EXPECT_TRUE(absl::ParseFlag("000.0001", &value, &err));
  EXPECT_DOUBLE_EQ(value, 0.0001);

  // Trailing zero values.
  EXPECT_TRUE(absl::ParseFlag("-5.1000", &value, &err));
  EXPECT_DOUBLE_EQ(value, -5.1);

  // Exceptional values.
  EXPECT_TRUE(absl::ParseFlag("NaN", &value, &err));
  EXPECT_TRUE(std::isnan(value));
  EXPECT_TRUE(absl::ParseFlag("nan", &value, &err));
  EXPECT_TRUE(std::isnan(value));
  EXPECT_TRUE(absl::ParseFlag("Inf", &value, &err));
  EXPECT_TRUE(std::isinf(value));
  EXPECT_TRUE(absl::ParseFlag("inf", &value, &err));
  EXPECT_TRUE(std::isinf(value));

  // Hex values
  EXPECT_TRUE(absl::ParseFlag("0x10.23p12", &value, &err));
  EXPECT_DOUBLE_EQ(value, 66096);
  EXPECT_TRUE(absl::ParseFlag("-0xF1.A3p-2", &value, &err));
  EXPECT_NEAR(value, -60.4092, 5e-5);
  EXPECT_TRUE(absl::ParseFlag("+0x0.0AAp-12", &value, &err));
  EXPECT_NEAR(value, 1.01328e-05, 5e-11);
  EXPECT_TRUE(absl::ParseFlag("0x.01p1", &value, &err));
  EXPECT_NEAR(value, 0.0078125, 5e-8);

  // Whitespace handling
  EXPECT_TRUE(absl::ParseFlag("10.1  ", &value, &err));
  EXPECT_DOUBLE_EQ(value, 10.1);
  EXPECT_TRUE(absl::ParseFlag("  2.34", &value, &err));
  EXPECT_DOUBLE_EQ(value, 2.34);
  EXPECT_TRUE(absl::ParseFlag("  5.7  ", &value, &err));
  EXPECT_DOUBLE_EQ(value, 5.7);
  EXPECT_TRUE(absl::ParseFlag("  -0xE0.F3p01  ", &value, &err));
  EXPECT_NEAR(value, -449.8984375, 5e-8);

  // Invalid values.
  EXPECT_FALSE(absl::ParseFlag("", &value, &err));
  EXPECT_FALSE(absl::ParseFlag(" ", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("  ", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("--1", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("\n", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("\t", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("2.3xxx", &value, &err));
  EXPECT_FALSE(absl::ParseFlag("0x0.1pAA", &value, &err));
  // TODO(rogeeff): below assertion should fail
  EXPECT_TRUE(absl::ParseFlag("0x0.1", &value, &err));
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestStringParsing) {
  std::string err;
  std::string value;

  EXPECT_TRUE(absl::ParseFlag("", &value, &err));
  EXPECT_EQ(value, "");
  EXPECT_TRUE(absl::ParseFlag(" ", &value, &err));
  EXPECT_EQ(value, " ");
  EXPECT_TRUE(absl::ParseFlag("   ", &value, &err));
  EXPECT_EQ(value, "   ");
  EXPECT_TRUE(absl::ParseFlag("\n", &value, &err));
  EXPECT_EQ(value, "\n");
  EXPECT_TRUE(absl::ParseFlag("\t", &value, &err));
  EXPECT_EQ(value, "\t");
  EXPECT_TRUE(absl::ParseFlag("asdfg", &value, &err));
  EXPECT_EQ(value, "asdfg");
  EXPECT_TRUE(absl::ParseFlag("asdf ghjk", &value, &err));
  EXPECT_EQ(value, "asdf ghjk");
  EXPECT_TRUE(absl::ParseFlag("a\nb\nc", &value, &err));
  EXPECT_EQ(value, "a\nb\nc");
  EXPECT_TRUE(absl::ParseFlag("asd\0fgh", &value, &err));
  EXPECT_EQ(value, "asd");
  EXPECT_TRUE(absl::ParseFlag("\\\\", &value, &err));
  EXPECT_EQ(value, "\\\\");
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestVectorOfStringParsing) {
  std::string err;
  std::vector<std::string> value;

  EXPECT_TRUE(absl::ParseFlag("", &value, &err));
  EXPECT_EQ(value, std::vector<std::string>{});
  EXPECT_TRUE(absl::ParseFlag("1", &value, &err));
  EXPECT_EQ(value, std::vector<std::string>({"1"}));
  EXPECT_TRUE(absl::ParseFlag("a,b", &value, &err));
  EXPECT_EQ(value, std::vector<std::string>({"a", "b"}));
  EXPECT_TRUE(absl::ParseFlag("a,b,c,", &value, &err));
  EXPECT_EQ(value, std::vector<std::string>({"a", "b", "c", ""}));
  EXPECT_TRUE(absl::ParseFlag("a,,", &value, &err));
  EXPECT_EQ(value, std::vector<std::string>({"a", "", ""}));
  EXPECT_TRUE(absl::ParseFlag(",", &value, &err));
  EXPECT_EQ(value, std::vector<std::string>({"", ""}));
  EXPECT_TRUE(absl::ParseFlag("a, b,c ", &value, &err));
  EXPECT_EQ(value, std::vector<std::string>({"a", " b", "c "}));
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestOptionalBoolParsing) {
  std::string err;
  absl::optional<bool> value;

  EXPECT_TRUE(absl::ParseFlag("", &value, &err));
  EXPECT_FALSE(value.has_value());

  EXPECT_TRUE(absl::ParseFlag("true", &value, &err));
  EXPECT_TRUE(value.has_value());
  EXPECT_TRUE(*value);

  EXPECT_TRUE(absl::ParseFlag("false", &value, &err));
  EXPECT_TRUE(value.has_value());
  EXPECT_FALSE(*value);

  EXPECT_FALSE(absl::ParseFlag("nullopt", &value, &err));
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestOptionalIntParsing) {
  std::string err;
  absl::optional<int> value;

  EXPECT_TRUE(absl::ParseFlag("", &value, &err));
  EXPECT_FALSE(value.has_value());

  EXPECT_TRUE(absl::ParseFlag("10", &value, &err));
  EXPECT_TRUE(value.has_value());
  EXPECT_EQ(*value, 10);

  EXPECT_TRUE(absl::ParseFlag("0x1F", &value, &err));
  EXPECT_TRUE(value.has_value());
  EXPECT_EQ(*value, 31);

  EXPECT_FALSE(absl::ParseFlag("nullopt", &value, &err));
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestOptionalDoubleParsing) {
  std::string err;
  absl::optional<double> value;

  EXPECT_TRUE(absl::ParseFlag("", &value, &err));
  EXPECT_FALSE(value.has_value());

  EXPECT_TRUE(absl::ParseFlag("1.11", &value, &err));
  EXPECT_TRUE(value.has_value());
  EXPECT_EQ(*value, 1.11);

  EXPECT_TRUE(absl::ParseFlag("-0.12", &value, &err));
  EXPECT_TRUE(value.has_value());
  EXPECT_EQ(*value, -0.12);

  EXPECT_FALSE(absl::ParseFlag("nullopt", &value, &err));
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestOptionalStringParsing) {
  std::string err;
  absl::optional<std::string> value;

  EXPECT_TRUE(absl::ParseFlag("", &value, &err));
  EXPECT_FALSE(value.has_value());

  EXPECT_TRUE(absl::ParseFlag(" ", &value, &err));
  EXPECT_TRUE(value.has_value());
  EXPECT_EQ(*value, " ");

  EXPECT_TRUE(absl::ParseFlag("aqswde", &value, &err));
  EXPECT_TRUE(value.has_value());
  EXPECT_EQ(*value, "aqswde");

  EXPECT_TRUE(absl::ParseFlag("nullopt", &value, &err));
  EXPECT_TRUE(value.has_value());
  EXPECT_EQ(*value, "nullopt");
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestBoolUnparsing) {
  EXPECT_EQ(absl::UnparseFlag(true), "true");
  EXPECT_EQ(absl::UnparseFlag(false), "false");
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestInt16Unparsing) {
  int16_t value;

  value = 1;
  EXPECT_EQ(absl::UnparseFlag(value), "1");
  value = 0;
  EXPECT_EQ(absl::UnparseFlag(value), "0");
  value = -1;
  EXPECT_EQ(absl::UnparseFlag(value), "-1");
  value = 9876;
  EXPECT_EQ(absl::UnparseFlag(value), "9876");
  value = -987;
  EXPECT_EQ(absl::UnparseFlag(value), "-987");
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestUint16Unparsing) {
  uint16_t value;

  value = 1;
  EXPECT_EQ(absl::UnparseFlag(value), "1");
  value = 0;
  EXPECT_EQ(absl::UnparseFlag(value), "0");
  value = 19876;
  EXPECT_EQ(absl::UnparseFlag(value), "19876");
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestInt32Unparsing) {
  int32_t value;

  value = 1;
  EXPECT_EQ(absl::UnparseFlag(value), "1");
  value = 0;
  EXPECT_EQ(absl::UnparseFlag(value), "0");
  value = -1;
  EXPECT_EQ(absl::UnparseFlag(value), "-1");
  value = 12345;
  EXPECT_EQ(absl::UnparseFlag(value), "12345");
  value = -987;
  EXPECT_EQ(absl::UnparseFlag(value), "-987");
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestUint32Unparsing) {
  uint32_t value;

  value = 1;
  EXPECT_EQ(absl::UnparseFlag(value), "1");
  value = 0;
  EXPECT_EQ(absl::UnparseFlag(value), "0");
  value = 1234500;
  EXPECT_EQ(absl::UnparseFlag(value), "1234500");
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestInt64Unparsing) {
  int64_t value;

  value = 1;
  EXPECT_EQ(absl::UnparseFlag(value), "1");
  value = 0;
  EXPECT_EQ(absl::UnparseFlag(value), "0");
  value = -1;
  EXPECT_EQ(absl::UnparseFlag(value), "-1");
  value = 123456789L;
  EXPECT_EQ(absl::UnparseFlag(value), "123456789");
  value = -987654321L;
  EXPECT_EQ(absl::UnparseFlag(value), "-987654321");
  value = 0x7FFFFFFFFFFFFFFF;
  EXPECT_EQ(absl::UnparseFlag(value), "9223372036854775807");
  value = 0xFFFFFFFFFFFFFFFF;
  EXPECT_EQ(absl::UnparseFlag(value), "-1");
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestUint64Unparsing) {
  uint64_t value;

  value = 1;
  EXPECT_EQ(absl::UnparseFlag(value), "1");
  value = 0;
  EXPECT_EQ(absl::UnparseFlag(value), "0");
  value = 123456789L;
  EXPECT_EQ(absl::UnparseFlag(value), "123456789");
  value = 0xFFFFFFFFFFFFFFFF;
  EXPECT_EQ(absl::UnparseFlag(value), "18446744073709551615");
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestInt128Unparsing) {
  absl::int128 value;

  value = 1;
  EXPECT_EQ(absl::UnparseFlag(value), "1");
  value = 0;
  EXPECT_EQ(absl::UnparseFlag(value), "0");
  value = -1;
  EXPECT_EQ(absl::UnparseFlag(value), "-1");
  value = 123456789L;
  EXPECT_EQ(absl::UnparseFlag(value), "123456789");
  value = -987654321L;
  EXPECT_EQ(absl::UnparseFlag(value), "-987654321");
  value = 0x7FFFFFFFFFFFFFFF;
  EXPECT_EQ(absl::UnparseFlag(value), "9223372036854775807");
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestUint128Unparsing) {
  absl::uint128 value;

  value = 1;
  EXPECT_EQ(absl::UnparseFlag(value), "1");
  value = 0;
  EXPECT_EQ(absl::UnparseFlag(value), "0");
  value = 123456789L;
  EXPECT_EQ(absl::UnparseFlag(value), "123456789");
  value = absl::MakeUint128(0, 0xFFFFFFFFFFFFFFFF);
  EXPECT_EQ(absl::UnparseFlag(value), "18446744073709551615");
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestFloatUnparsing) {
  float value;

  value = 1.1f;
  EXPECT_EQ(absl::UnparseFlag(value), "1.1");
  value = 0.01f;
  EXPECT_EQ(absl::UnparseFlag(value), "0.01");
  value = 1.23e-2f;
  EXPECT_EQ(absl::UnparseFlag(value), "0.0123");
  value = -0.71f;
  EXPECT_EQ(absl::UnparseFlag(value), "-0.71");
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestDoubleUnparsing) {
  double value;

  value = 1.1;
  EXPECT_EQ(absl::UnparseFlag(value), "1.1");
  value = 0.01;
  EXPECT_EQ(absl::UnparseFlag(value), "0.01");
  value = 1.23e-2;
  EXPECT_EQ(absl::UnparseFlag(value), "0.0123");
  value = -0.71;
  EXPECT_EQ(absl::UnparseFlag(value), "-0.71");
  value = -0;
  EXPECT_EQ(absl::UnparseFlag(value), "0");
  value = std::nan("");
  EXPECT_EQ(absl::UnparseFlag(value), "nan");
  value = std::numeric_limits<double>::infinity();
  EXPECT_EQ(absl::UnparseFlag(value), "inf");
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestStringUnparsing) {
  EXPECT_EQ(absl::UnparseFlag(""), "");
  EXPECT_EQ(absl::UnparseFlag(" "), " ");
  EXPECT_EQ(absl::UnparseFlag("qwerty"), "qwerty");
  EXPECT_EQ(absl::UnparseFlag("ASDFGH"), "ASDFGH");
  EXPECT_EQ(absl::UnparseFlag("\n\t  "), "\n\t  ");
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestOptionalBoolUnparsing) {
  absl::optional<bool> value;

  EXPECT_EQ(absl::UnparseFlag(value), "");
  value = true;
  EXPECT_EQ(absl::UnparseFlag(value), "true");
  value = false;
  EXPECT_EQ(absl::UnparseFlag(value), "false");
  value = absl::nullopt;
  EXPECT_EQ(absl::UnparseFlag(value), "");
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestOptionalIntUnparsing) {
  absl::optional<int> value;

  EXPECT_EQ(absl::UnparseFlag(value), "");
  value = 0;
  EXPECT_EQ(absl::UnparseFlag(value), "0");
  value = -12;
  EXPECT_EQ(absl::UnparseFlag(value), "-12");
  value = absl::nullopt;
  EXPECT_EQ(absl::UnparseFlag(value), "");
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestOptionalDoubleUnparsing) {
  absl::optional<double> value;

  EXPECT_EQ(absl::UnparseFlag(value), "");
  value = 1.;
  EXPECT_EQ(absl::UnparseFlag(value), "1");
  value = -1.23;
  EXPECT_EQ(absl::UnparseFlag(value), "-1.23");
  value = absl::nullopt;
  EXPECT_EQ(absl::UnparseFlag(value), "");
}

// --------------------------------------------------------------------

TEST(MarshallingTest, TestOptionalStringUnparsing) {
  absl::optional<std::string> strvalue;
  EXPECT_EQ(absl::UnparseFlag(strvalue), "");

  strvalue = "asdfg";
  EXPECT_EQ(absl::UnparseFlag(strvalue), "asdfg");

  strvalue = " ";
  EXPECT_EQ(absl::UnparseFlag(strvalue), " ");

  strvalue = "";  // It is UB to set an optional string flag to ""
  EXPECT_EQ(absl::UnparseFlag(strvalue), "");
}

// --------------------------------------------------------------------

#if defined(ABSL_HAVE_STD_OPTIONAL) && !defined(ABSL_USES_STD_OPTIONAL)

TEST(MarshallingTest, TestStdOptionalUnparsing) {
  std::optional<std::string> strvalue;
  EXPECT_EQ(absl::UnparseFlag(strvalue), "");

  strvalue = "asdfg";
  EXPECT_EQ(absl::UnparseFlag(strvalue), "asdfg");

  strvalue = " ";
  EXPECT_EQ(absl::UnparseFlag(strvalue), " ");

  strvalue = "";  // It is UB to set an optional string flag to ""
  EXPECT_EQ(absl::UnparseFlag(strvalue), "");

  std::optional<int> intvalue;
  EXPECT_EQ(absl::UnparseFlag(intvalue), "");

  intvalue = 10;
  EXPECT_EQ(absl::UnparseFlag(intvalue), "10");
}

// --------------------------------------------------------------------

#endif

template <typename T>
void TestRoundtrip(T v) {
  T new_v;
  std::string err;
  EXPECT_TRUE(absl::ParseFlag(absl::UnparseFlag(v), &new_v, &err));
  EXPECT_EQ(new_v, v);
}

TEST(MarshallingTest, TestFloatRoundTrip) {
  TestRoundtrip(0.1f);
  TestRoundtrip(0.12f);
  TestRoundtrip(0.123f);
  TestRoundtrip(0.1234f);
  TestRoundtrip(0.12345f);
  TestRoundtrip(0.123456f);
  TestRoundtrip(0.1234567f);
  TestRoundtrip(0.12345678f);

  TestRoundtrip(0.1e20f);
  TestRoundtrip(0.12e20f);
  TestRoundtrip(0.123e20f);
  TestRoundtrip(0.1234e20f);
  TestRoundtrip(0.12345e20f);
  TestRoundtrip(0.123456e20f);
  TestRoundtrip(0.1234567e20f);
  TestRoundtrip(0.12345678e20f);

  TestRoundtrip(0.1e-20f);
  TestRoundtrip(0.12e-20f);
  TestRoundtrip(0.123e-20f);
  TestRoundtrip(0.1234e-20f);
  TestRoundtrip(0.12345e-20f);
  TestRoundtrip(0.123456e-20f);
  TestRoundtrip(0.1234567e-20f);
  TestRoundtrip(0.12345678e-20f);
}

TEST(MarshallingTest, TestDoubleRoundTrip) {
  TestRoundtrip(0.1);
  TestRoundtrip(0.12);
  TestRoundtrip(0.123);
  TestRoundtrip(0.1234);
  TestRoundtrip(0.12345);
  TestRoundtrip(0.123456);
  TestRoundtrip(0.1234567);
  TestRoundtrip(0.12345678);
  TestRoundtrip(0.123456789);
  TestRoundtrip(0.1234567891);
  TestRoundtrip(0.12345678912);
  TestRoundtrip(0.123456789123);
  TestRoundtrip(0.1234567891234);
  TestRoundtrip(0.12345678912345);
  TestRoundtrip(0.123456789123456);
  TestRoundtrip(0.1234567891234567);
  TestRoundtrip(0.12345678912345678);

  TestRoundtrip(0.1e50);
  TestRoundtrip(0.12e50);
  TestRoundtrip(0.123e50);
  TestRoundtrip(0.1234e50);
  TestRoundtrip(0.12345e50);
  TestRoundtrip(0.123456e50);
  TestRoundtrip(0.1234567e50);
  TestRoundtrip(0.12345678e50);
  TestRoundtrip(0.123456789e50);
  TestRoundtrip(0.1234567891e50);
  TestRoundtrip(0.12345678912e50);
  TestRoundtrip(0.123456789123e50);
  TestRoundtrip(0.1234567891234e50);
  TestRoundtrip(0.12345678912345e50);
  TestRoundtrip(0.123456789123456e50);
  TestRoundtrip(0.1234567891234567e50);
  TestRoundtrip(0.12345678912345678e50);

  TestRoundtrip(0.1e-50);
  TestRoundtrip(0.12e-50);
  TestRoundtrip(0.123e-50);
  TestRoundtrip(0.1234e-50);
  TestRoundtrip(0.12345e-50);
  TestRoundtrip(0.123456e-50);
  TestRoundtrip(0.1234567e-50);
  TestRoundtrip(0.12345678e-50);
  TestRoundtrip(0.123456789e-50);
  TestRoundtrip(0.1234567891e-50);
  TestRoundtrip(0.12345678912e-50);
  TestRoundtrip(0.123456789123e-50);
  TestRoundtrip(0.1234567891234e-50);
  TestRoundtrip(0.12345678912345e-50);
  TestRoundtrip(0.123456789123456e-50);
  TestRoundtrip(0.1234567891234567e-50);
  TestRoundtrip(0.12345678912345678e-50);
}

}  // namespace
                                                                                           node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/parse.cc                                      0000664 0000000 0000000 00000077621 14746647661 0024070 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
// Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/flags/parse.h"

#include <stdlib.h>

#include <algorithm>
#include <cstdint>
#include <cstdlib>
#include <fstream>
#include <iostream>
#include <ostream>
#include <string>
#include <tuple>
#include <utility>
#include <vector>

#ifdef _WIN32
#include <windows.h>
#endif

#include "absl/algorithm/container.h"
#include "absl/base/attributes.h"
#include "absl/base/config.h"
#include "absl/base/const_init.h"
#include "absl/base/thread_annotations.h"
#include "absl/flags/commandlineflag.h"
#include "absl/flags/config.h"
#include "absl/flags/flag.h"
#include "absl/flags/internal/commandlineflag.h"
#include "absl/flags/internal/flag.h"
#include "absl/flags/internal/parse.h"
#include "absl/flags/internal/private_handle_accessor.h"
#include "absl/flags/internal/program_name.h"
#include "absl/flags/internal/usage.h"
#include "absl/flags/reflection.h"
#include "absl/flags/usage.h"
#include "absl/flags/usage_config.h"
#include "absl/strings/ascii.h"
#include "absl/strings/internal/damerau_levenshtein_distance.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/str_join.h"
#include "absl/strings/string_view.h"
#include "absl/strings/strip.h"
#include "absl/synchronization/mutex.h"

// --------------------------------------------------------------------

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace flags_internal {
namespace {

ABSL_CONST_INIT absl::Mutex processing_checks_guard(absl::kConstInit);

ABSL_CONST_INIT bool flagfile_needs_processing
    ABSL_GUARDED_BY(processing_checks_guard) = false;
ABSL_CONST_INIT bool fromenv_needs_processing
    ABSL_GUARDED_BY(processing_checks_guard) = false;
ABSL_CONST_INIT bool tryfromenv_needs_processing
    ABSL_GUARDED_BY(processing_checks_guard) = false;

ABSL_CONST_INIT absl::Mutex specified_flags_guard(absl::kConstInit);
ABSL_CONST_INIT std::vector<const CommandLineFlag*>* specified_flags
    ABSL_GUARDED_BY(specified_flags_guard) = nullptr;

// Suggesting at most kMaxHints flags in case of misspellings.
ABSL_CONST_INIT const size_t kMaxHints = 100;
// Suggesting only flags which have a smaller distance than kMaxDistance.
ABSL_CONST_INIT const size_t kMaxDistance = 3;

struct SpecifiedFlagsCompare {
  bool operator()(const CommandLineFlag* a, const CommandLineFlag* b) const {
    return a->Name() < b->Name();
  }
  bool operator()(const CommandLineFlag* a, absl::string_view b) const {
    return a->Name() < b;
  }
  bool operator()(absl::string_view a, const CommandLineFlag* b) const {
    return a < b->Name();
  }
};

}  // namespace
}  // namespace flags_internal
ABSL_NAMESPACE_END
}  // namespace absl

// These flags influence how command line flags are parsed and are only intended
// to be set on the command line.  Avoid reading or setting them from C++ code.
ABSL_FLAG(std::vector<std::string>, flagfile, {},
          "comma-separated list of files to load flags from")
    .OnUpdate([]() {
      if (absl::GetFlag(FLAGS_flagfile).empty()) return;

      absl::MutexLock l(&absl::flags_internal::processing_checks_guard);

      // Setting this flag twice before it is handled most likely an internal
      // error and should be reviewed by developers.
      if (absl::flags_internal::flagfile_needs_processing) {
        ABSL_INTERNAL_LOG(WARNING, "flagfile set twice before it is handled");
      }

      absl::flags_internal::flagfile_needs_processing = true;
    });
ABSL_FLAG(std::vector<std::string>, fromenv, {},
          "comma-separated list of flags to set from the environment"
          " [use 'export FLAGS_flag1=value']")
    .OnUpdate([]() {
      if (absl::GetFlag(FLAGS_fromenv).empty()) return;

      absl::MutexLock l(&absl::flags_internal::processing_checks_guard);

      // Setting this flag twice before it is handled most likely an internal
      // error and should be reviewed by developers.
      if (absl::flags_internal::fromenv_needs_processing) {
        ABSL_INTERNAL_LOG(WARNING, "fromenv set twice before it is handled.");
      }

      absl::flags_internal::fromenv_needs_processing = true;
    });
ABSL_FLAG(std::vector<std::string>, tryfromenv, {},
          "comma-separated list of flags to try to set from the environment if "
          "present")
    .OnUpdate([]() {
      if (absl::GetFlag(FLAGS_tryfromenv).empty()) return;

      absl::MutexLock l(&absl::flags_internal::processing_checks_guard);

      // Setting this flag twice before it is handled most likely an internal
      // error and should be reviewed by developers.
      if (absl::flags_internal::tryfromenv_needs_processing) {
        ABSL_INTERNAL_LOG(WARNING,
                          "tryfromenv set twice before it is handled.");
      }

      absl::flags_internal::tryfromenv_needs_processing = true;
    });

// Rather than reading or setting --undefok from C++ code, please consider using
// ABSL_RETIRED_FLAG instead.
ABSL_FLAG(std::vector<std::string>, undefok, {},
          "comma-separated list of flag names that it is okay to specify "
          "on the command line even if the program does not define a flag "
          "with that name");

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace flags_internal {

namespace {

class ArgsList {
 public:
  ArgsList() : next_arg_(0) {}
  ArgsList(int argc, char* argv[]) : args_(argv, argv + argc), next_arg_(0) {}
  explicit ArgsList(const std::vector<std::string>& args)
      : args_(args), next_arg_(0) {}

  // Returns success status: true if parsing successful, false otherwise.
  bool ReadFromFlagfile(const std::string& flag_file_name);

  size_t Size() const { return args_.size() - next_arg_; }
  size_t FrontIndex() const { return next_arg_; }
  absl::string_view Front() const { return args_[next_arg_]; }
  void PopFront() { next_arg_++; }

 private:
  std::vector<std::string> args_;
  size_t next_arg_;
};

bool ArgsList::ReadFromFlagfile(const std::string& flag_file_name) {
  std::ifstream flag_file(flag_file_name);

  if (!flag_file) {
    flags_internal::ReportUsageError(
        absl::StrCat("Can't open flagfile ", flag_file_name), true);

    return false;
  }

  // This argument represents fake argv[0], which should be present in all arg
  // lists.
  args_.emplace_back("");

  std::string line;
  bool success = true;

  while (std::getline(flag_file, line)) {
    absl::string_view stripped = absl::StripLeadingAsciiWhitespace(line);

    if (stripped.empty() || stripped[0] == '#') {
      // Comment or empty line; just ignore.
      continue;
    }

    if (stripped[0] == '-') {
      if (stripped == "--") {
        flags_internal::ReportUsageError(
            "Flagfile can't contain position arguments or --", true);

        success = false;
        break;
      }

      args_.emplace_back(stripped);
      continue;
    }

    flags_internal::ReportUsageError(
        absl::StrCat("Unexpected line in the flagfile ", flag_file_name, ": ",
                     line),
        true);

    success = false;
  }

  return success;
}

// --------------------------------------------------------------------

// Reads the environment variable with name `name` and stores results in
// `value`. If variable is not present in environment returns false, otherwise
// returns true.
bool GetEnvVar(const char* var_name, std::string& var_value) {
#ifdef _WIN32
  char buf[1024];
  auto get_res = GetEnvironmentVariableA(var_name, buf, sizeof(buf));
  if (get_res >= sizeof(buf)) {
    return false;
  }

  if (get_res == 0) {
    return false;
  }

  var_value = std::string(buf, get_res);
#else
  const char* val = ::getenv(var_name);
  if (val == nullptr) {
    return false;
  }

  var_value = val;
#endif

  return true;
}

// --------------------------------------------------------------------

// Returns:
//  Flag name or empty if arg= --
//  Flag value after = in --flag=value (empty if --foo)
//  "Is empty value" status. True if arg= --foo=, false otherwise. This is
//  required to separate --foo from --foo=.
// For example:
//      arg           return values
//   "--foo=bar" -> {"foo", "bar", false}.
//   "--foo"     -> {"foo", "", false}.
//   "--foo="    -> {"foo", "", true}.
std::tuple<absl::string_view, absl::string_view, bool> SplitNameAndValue(
    absl::string_view arg) {
  // Allow -foo and --foo
  absl::ConsumePrefix(&arg, "-");

  if (arg.empty()) {
    return std::make_tuple("", "", false);
  }

  auto equal_sign_pos = arg.find('=');

  absl::string_view flag_name = arg.substr(0, equal_sign_pos);

  absl::string_view value;
  bool is_empty_value = false;

  if (equal_sign_pos != absl::string_view::npos) {
    value = arg.substr(equal_sign_pos + 1);
    is_empty_value = value.empty();
  }

  return std::make_tuple(flag_name, value, is_empty_value);
}

// --------------------------------------------------------------------

// Returns:
//  found flag or nullptr
//  is negative in case of --nofoo
std::tuple<CommandLineFlag*, bool> LocateFlag(absl::string_view flag_name) {
  CommandLineFlag* flag = absl::FindCommandLineFlag(flag_name);
  bool is_negative = false;

  if (!flag && absl::ConsumePrefix(&flag_name, "no")) {
    flag = absl::FindCommandLineFlag(flag_name);
    is_negative = true;
  }

  return std::make_tuple(flag, is_negative);
}

// --------------------------------------------------------------------

// Verify that default values of typed flags must be convertible to string and
// back.
void CheckDefaultValuesParsingRoundtrip() {
#ifndef NDEBUG
  flags_internal::ForEachFlag([&](CommandLineFlag& flag) {
    if (flag.IsRetired()) return;

#define ABSL_FLAGS_INTERNAL_IGNORE_TYPE(T, _) \
  if (flag.IsOfType<T>()) return;

    ABSL_FLAGS_INTERNAL_SUPPORTED_TYPES(ABSL_FLAGS_INTERNAL_IGNORE_TYPE)
#undef ABSL_FLAGS_INTERNAL_IGNORE_TYPE

    flags_internal::PrivateHandleAccessor::CheckDefaultValueParsingRoundtrip(
        flag);
  });
#endif
}

// --------------------------------------------------------------------

// Returns success status, which is true if we successfully read all flag files,
// in which case new ArgLists are appended to the input_args in a reverse order
// of file names in the input flagfiles list. This order ensures that flags from
// the first flagfile in the input list are processed before the second flagfile
// etc.
bool ReadFlagfiles(const std::vector<std::string>& flagfiles,
                   std::vector<ArgsList>& input_args) {
  bool success = true;
  for (auto it = flagfiles.rbegin(); it != flagfiles.rend(); ++it) {
    ArgsList al;

    if (al.ReadFromFlagfile(*it)) {
      input_args.push_back(al);
    } else {
      success = false;
    }
  }

  return success;
}

// Returns success status, which is true if were able to locate all environment
// variables correctly or if fail_on_absent_in_env is false. The environment
// variable names are expected to be of the form `FLAGS_<flag_name>`, where
// `flag_name` is a string from the input flag_names list. If successful we
// append a single ArgList at the end of the input_args.
bool ReadFlagsFromEnv(const std::vector<std::string>& flag_names,
                      std::vector<ArgsList>& input_args,
                      bool fail_on_absent_in_env) {
  bool success = true;
  std::vector<std::string> args;

  // This argument represents fake argv[0], which should be present in all arg
  // lists.
  args.emplace_back("");

  for (const auto& flag_name : flag_names) {
    // Avoid infinite recursion.
    if (flag_name == "fromenv" || flag_name == "tryfromenv") {
      flags_internal::ReportUsageError(
          absl::StrCat("Infinite recursion on flag ", flag_name), true);

      success = false;
      continue;
    }

    const std::string envname = absl::StrCat("FLAGS_", flag_name);
    std::string envval;
    if (!GetEnvVar(envname.c_str(), envval)) {
      if (fail_on_absent_in_env) {
        flags_internal::ReportUsageError(
            absl::StrCat(envname, " not found in environment"), true);

        success = false;
      }

      continue;
    }

    args.push_back(absl::StrCat("--", flag_name, "=", envval));
  }

  if (success) {
    input_args.emplace_back(args);
  }

  return success;
}

// --------------------------------------------------------------------

// Returns success status, which is true if were able to handle all generator
// flags (flagfile, fromenv, tryfromemv) successfully.
bool HandleGeneratorFlags(std::vector<ArgsList>& input_args,
                          std::vector<std::string>& flagfile_value) {
  bool success = true;

  absl::MutexLock l(&flags_internal::processing_checks_guard);

  // flagfile could have been set either on a command line or
  // programmatically before invoking ParseCommandLine. Note that we do not
  // actually process arguments specified in the flagfile, but instead
  // create a secondary arguments list to be processed along with the rest
  // of the command line arguments. Since we always the process most recently
  // created list of arguments first, this will result in flagfile argument
  // being processed before any other argument in the command line. If
  // FLAGS_flagfile contains more than one file name we create multiple new
  // levels of arguments in a reverse order of file names. Thus we always
  // process arguments from first file before arguments containing in a
  // second file, etc. If flagfile contains another
  // --flagfile inside of it, it will produce new level of arguments and
  // processed before the rest of the flagfile. We are also collecting all
  // flagfiles set on original command line. Unlike the rest of the flags,
  // this flag can be set multiple times and is expected to be handled
  // multiple times. We are collecting them all into a single list and set
  // the value of FLAGS_flagfile to that value at the end of the parsing.
  if (flags_internal::flagfile_needs_processing) {
    auto flagfiles = absl::GetFlag(FLAGS_flagfile);

    if (input_args.size() == 1) {
      flagfile_value.insert(flagfile_value.end(), flagfiles.begin(),
                            flagfiles.end());
    }

    success &= ReadFlagfiles(flagfiles, input_args);

    flags_internal::flagfile_needs_processing = false;
  }

  // Similar to flagfile fromenv/tryfromemv can be set both
  // programmatically and at runtime on a command line. Unlike flagfile these
  // can't be recursive.
  if (flags_internal::fromenv_needs_processing) {
    auto flags_list = absl::GetFlag(FLAGS_fromenv);

    success &= ReadFlagsFromEnv(flags_list, input_args, true);

    flags_internal::fromenv_needs_processing = false;
  }

  if (flags_internal::tryfromenv_needs_processing) {
    auto flags_list = absl::GetFlag(FLAGS_tryfromenv);

    success &= ReadFlagsFromEnv(flags_list, input_args, false);

    flags_internal::tryfromenv_needs_processing = false;
  }

  return success;
}

// --------------------------------------------------------------------

void ResetGeneratorFlags(const std::vector<std::string>& flagfile_value) {
  // Setting flagfile to the value which collates all the values set on a
  // command line and programmatically. So if command line looked like
  // --flagfile=f1 --flagfile=f2 the final value of the FLAGS_flagfile flag is
  // going to be {"f1", "f2"}
  if (!flagfile_value.empty()) {
    absl::SetFlag(&FLAGS_flagfile, flagfile_value);
    absl::MutexLock l(&flags_internal::processing_checks_guard);
    flags_internal::flagfile_needs_processing = false;
  }

  // fromenv/tryfromenv are set to <undefined> value.
  if (!absl::GetFlag(FLAGS_fromenv).empty()) {
    absl::SetFlag(&FLAGS_fromenv, {});
  }
  if (!absl::GetFlag(FLAGS_tryfromenv).empty()) {
    absl::SetFlag(&FLAGS_tryfromenv, {});
  }

  absl::MutexLock l(&flags_internal::processing_checks_guard);
  flags_internal::fromenv_needs_processing = false;
  flags_internal::tryfromenv_needs_processing = false;
}

// --------------------------------------------------------------------

// Returns:
//  success status
//  deduced value
// We are also mutating curr_list in case if we need to get a hold of next
// argument in the input.
std::tuple<bool, absl::string_view> DeduceFlagValue(const CommandLineFlag& flag,
                                                    absl::string_view value,
                                                    bool is_negative,
                                                    bool is_empty_value,
                                                    ArgsList* curr_list) {
  // Value is either an argument suffix after `=` in "--foo=<value>"
  // or separate argument in case of "--foo" "<value>".

  // boolean flags have these forms:
  //   --foo
  //   --nofoo
  //   --foo=true
  //   --foo=false
  //   --nofoo=<value> is not supported
  //   --foo <value> is not supported

  // non boolean flags have these forms:
  // --foo=<value>
  // --foo <value>
  // --nofoo is not supported

  if (flag.IsOfType<bool>()) {
    if (value.empty()) {
      if (is_empty_value) {
        // "--bool_flag=" case
        flags_internal::ReportUsageError(
            absl::StrCat(
                "Missing the value after assignment for the boolean flag '",
                flag.Name(), "'"),
            true);
        return std::make_tuple(false, "");
      }

      // "--bool_flag" case
      value = is_negative ? "0" : "1";
    } else if (is_negative) {
      // "--nobool_flag=Y" case
      flags_internal::ReportUsageError(
          absl::StrCat("Negative form with assignment is not valid for the "
                       "boolean flag '",
                       flag.Name(), "'"),
          true);
      return std::make_tuple(false, "");
    }
  } else if (is_negative) {
    // "--noint_flag=1" case
    flags_internal::ReportUsageError(
        absl::StrCat("Negative form is not valid for the flag '", flag.Name(),
                     "'"),
        true);
    return std::make_tuple(false, "");
  } else if (value.empty() && (!is_empty_value)) {
    if (curr_list->Size() == 1) {
      // "--int_flag" case
      flags_internal::ReportUsageError(
          absl::StrCat("Missing the value for the flag '", flag.Name(), "'"),
          true);
      return std::make_tuple(false, "");
    }

    // "--int_flag" "10" case
    curr_list->PopFront();
    value = curr_list->Front();

    // Heuristic to detect the case where someone treats a string arg
    // like a bool or just forgets to pass a value:
    // --my_string_var --foo=bar
    // We look for a flag of string type, whose value begins with a
    // dash and corresponds to known flag or standalone --.
    if (!value.empty() && value[0] == '-' && flag.IsOfType<std::string>()) {
      auto maybe_flag_name = std::get<0>(SplitNameAndValue(value.substr(1)));

      if (maybe_flag_name.empty() ||
          std::get<0>(LocateFlag(maybe_flag_name)) != nullptr) {
        // "--string_flag" "--known_flag" case
        ABSL_INTERNAL_LOG(
            WARNING,
            absl::StrCat("Did you really mean to set flag '", flag.Name(),
                         "' to the value '", value, "'?"));
      }
    }
  }

  return std::make_tuple(true, value);
}

// --------------------------------------------------------------------

bool CanIgnoreUndefinedFlag(absl::string_view flag_name) {
  auto undefok = absl::GetFlag(FLAGS_undefok);
  if (std::find(undefok.begin(), undefok.end(), flag_name) != undefok.end()) {
    return true;
  }

  if (absl::ConsumePrefix(&flag_name, "no") &&
      std::find(undefok.begin(), undefok.end(), flag_name) != undefok.end()) {
    return true;
  }

  return false;
}

// --------------------------------------------------------------------

void ReportUnrecognizedFlags(
    const std::vector<UnrecognizedFlag>& unrecognized_flags,
    bool report_as_fatal_error) {
  for (const auto& unrecognized : unrecognized_flags) {
    // Verify if flag_name has the "no" already removed
    std::vector<std::string> misspelling_hints;
    if (unrecognized.source == UnrecognizedFlag::kFromArgv) {
      misspelling_hints =
          flags_internal::GetMisspellingHints(unrecognized.flag_name);
    }

    if (misspelling_hints.empty()) {
      flags_internal::ReportUsageError(
          absl::StrCat("Unknown command line flag '", unrecognized.flag_name,
                       "'"),
          report_as_fatal_error);
    } else {
      flags_internal::ReportUsageError(
          absl::StrCat("Unknown command line flag '", unrecognized.flag_name,
                       "'. Did you mean: ",
                       absl::StrJoin(misspelling_hints, ", "), " ?"),
          report_as_fatal_error);
    }
  }
}

}  // namespace

// --------------------------------------------------------------------

bool WasPresentOnCommandLine(absl::string_view flag_name) {
  absl::ReaderMutexLock l(&specified_flags_guard);
  ABSL_INTERNAL_CHECK(specified_flags != nullptr,
                      "ParseCommandLine is not invoked yet");

  return std::binary_search(specified_flags->begin(), specified_flags->end(),
                            flag_name, SpecifiedFlagsCompare{});
}

// --------------------------------------------------------------------

struct BestHints {
  explicit BestHints(uint8_t _max) : best_distance(_max + 1) {}
  bool AddHint(absl::string_view hint, uint8_t distance) {
    if (hints.size() >= kMaxHints) return false;
    if (distance == best_distance) {
      hints.emplace_back(hint);
    }
    if (distance < best_distance) {
      best_distance = distance;
      hints = std::vector<std::string>{std::string(hint)};
    }
    return true;
  }

  uint8_t best_distance;
  std::vector<std::string> hints;
};

// Return the list of flags with the smallest Damerau-Levenshtein distance to
// the given flag.
std::vector<std::string> GetMisspellingHints(const absl::string_view flag) {
  const size_t maxCutoff = std::min(flag.size() / 2 + 1, kMaxDistance);
  auto undefok = absl::GetFlag(FLAGS_undefok);
  BestHints best_hints(static_cast<uint8_t>(maxCutoff));
  flags_internal::ForEachFlag([&](const CommandLineFlag& f) {
    if (best_hints.hints.size() >= kMaxHints) return;
    uint8_t distance = strings_internal::CappedDamerauLevenshteinDistance(
        flag, f.Name(), best_hints.best_distance);
    best_hints.AddHint(f.Name(), distance);
    // For boolean flags, also calculate distance to the negated form.
    if (f.IsOfType<bool>()) {
      const std::string negated_flag = absl::StrCat("no", f.Name());
      distance = strings_internal::CappedDamerauLevenshteinDistance(
          flag, negated_flag, best_hints.best_distance);
      best_hints.AddHint(negated_flag, distance);
    }
  });
  // Finally calculate distance to flags in "undefok".
  absl::c_for_each(undefok, [&](const absl::string_view f) {
    if (best_hints.hints.size() >= kMaxHints) return;
    uint8_t distance = strings_internal::CappedDamerauLevenshteinDistance(
        flag, f, best_hints.best_distance);
    best_hints.AddHint(absl::StrCat(f, " (undefok)"), distance);
  });
  return best_hints.hints;
}

// --------------------------------------------------------------------

std::vector<char*> ParseCommandLineImpl(int argc, char* argv[],
                                        UsageFlagsAction usage_flag_action,
                                        OnUndefinedFlag undef_flag_action,
                                        std::ostream& error_help_output) {
  std::vector<char*> positional_args;
  std::vector<UnrecognizedFlag> unrecognized_flags;

  auto help_mode = flags_internal::ParseAbseilFlagsOnlyImpl(
      argc, argv, positional_args, unrecognized_flags, usage_flag_action);

  if (undef_flag_action != OnUndefinedFlag::kIgnoreUndefined) {
    flags_internal::ReportUnrecognizedFlags(
        unrecognized_flags,
        (undef_flag_action == OnUndefinedFlag::kAbortIfUndefined));

    if (undef_flag_action == OnUndefinedFlag::kAbortIfUndefined) {
      if (!unrecognized_flags.empty()) {
        flags_internal::HandleUsageFlags(error_help_output,
        ProgramUsageMessage()); std::exit(1);
      }
    }
  }

  flags_internal::MaybeExit(help_mode);

  return positional_args;
}

// --------------------------------------------------------------------

// This function handles all Abseil Flags and built-in usage flags and, if any
// help mode was handled, it returns that help mode. The caller of this function
// can decide to exit based on the returned help mode.
// The caller may decide to handle unrecognized positional arguments and
// unrecognized flags first before exiting.
//
// Returns:
// * HelpMode::kFull if parsing errors were detected in recognized arguments
// * The HelpMode that was handled in case when `usage_flag_action` is
//   UsageFlagsAction::kHandleUsage and a usage flag was specified on the
//   commandline
// * Otherwise it returns HelpMode::kNone
HelpMode ParseAbseilFlagsOnlyImpl(
    int argc, char* argv[], std::vector<char*>& positional_args,
    std::vector<UnrecognizedFlag>& unrecognized_flags,
    UsageFlagsAction usage_flag_action) {
  ABSL_INTERNAL_CHECK(argc > 0, "Missing argv[0]");

  using flags_internal::ArgsList;
  using flags_internal::specified_flags;

  std::vector<std::string> flagfile_value;
  std::vector<ArgsList> input_args;

  // Once parsing has started we will not allow more flag registrations.
  flags_internal::FinalizeRegistry();

  // This routine does not return anything since we abort on failure.
  flags_internal::CheckDefaultValuesParsingRoundtrip();

  input_args.push_back(ArgsList(argc, argv));

  // Set program invocation name if it is not set before.
  if (flags_internal::ProgramInvocationName() == "UNKNOWN") {
    flags_internal::SetProgramInvocationName(argv[0]);
  }
  positional_args.push_back(argv[0]);

  absl::MutexLock l(&flags_internal::specified_flags_guard);
  if (specified_flags == nullptr) {
    specified_flags = new std::vector<const CommandLineFlag*>;
  } else {
    specified_flags->clear();
  }

  // Iterate through the list of the input arguments. First level are
  // arguments originated from argc/argv. Following levels are arguments
  // originated from recursive parsing of flagfile(s).
  bool success = true;
  while (!input_args.empty()) {
    // First we process the built-in generator flags.
    success &= flags_internal::HandleGeneratorFlags(input_args, flagfile_value);

    // Select top-most (most recent) arguments list. If it is empty drop it
    // and re-try.
    ArgsList& curr_list = input_args.back();

    // Every ArgsList starts with real or fake program name, so we can always
    // start by skipping it.
    curr_list.PopFront();

    if (curr_list.Size() == 0) {
      input_args.pop_back();
      continue;
    }

    // Handle the next argument in the current list. If the stack of argument
    // lists contains only one element - we are processing an argument from
    // the original argv.
    absl::string_view arg(curr_list.Front());
    bool arg_from_argv = input_args.size() == 1;

    // If argument does not start with '-' or is just "-" - this is
    // positional argument.
    if (!absl::ConsumePrefix(&arg, "-") || arg.empty()) {
      ABSL_INTERNAL_CHECK(arg_from_argv,
                          "Flagfile cannot contain positional argument");

      positional_args.push_back(argv[curr_list.FrontIndex()]);
      continue;
    }

    // Split the current argument on '=' to deduce the argument flag name and
    // value. If flag name is empty it means we've got an "--" argument. Value
    // can be empty either if there were no '=' in argument string at all or
    // an argument looked like "--foo=". In a latter case is_empty_value is
    // true.
    absl::string_view flag_name;
    absl::string_view value;
    bool is_empty_value = false;

    std::tie(flag_name, value, is_empty_value) =
        flags_internal::SplitNameAndValue(arg);

    // Standalone "--" argument indicates that the rest of the arguments are
    // positional. We do not support positional arguments in flagfiles.
    if (flag_name.empty()) {
      ABSL_INTERNAL_CHECK(arg_from_argv,
                          "Flagfile cannot contain positional argument");

      curr_list.PopFront();
      break;
    }

    // Locate the flag based on flag name. Handle both --foo and --nofoo.
    CommandLineFlag* flag = nullptr;
    bool is_negative = false;
    std::tie(flag, is_negative) = flags_internal::LocateFlag(flag_name);

    if (flag == nullptr) {
      // Usage flags are not modeled as Abseil flags. Locate them separately.
      if (flags_internal::DeduceUsageFlags(flag_name, value)) {
        continue;
      }
      unrecognized_flags.emplace_back(arg_from_argv
                                          ? UnrecognizedFlag::kFromArgv
                                          : UnrecognizedFlag::kFromFlagfile,
                                      flag_name);
      continue;
    }

    // Deduce flag's value (from this or next argument).
    bool value_success = true;
    std::tie(value_success, value) = flags_internal::DeduceFlagValue(
        *flag, value, is_negative, is_empty_value, &curr_list);
    success &= value_success;

    // Set the located flag to a new value, unless it is retired. Setting
    // retired flag fails, but we ignoring it here while also reporting access
    // to retired flag.
    std::string error;
    if (!flags_internal::PrivateHandleAccessor::ParseFrom(
            *flag, value, flags_internal::SET_FLAGS_VALUE,
            flags_internal::kCommandLine, error)) {
      if (flag->IsRetired()) continue;

      flags_internal::ReportUsageError(error, true);
      success = false;
    } else {
      specified_flags->push_back(flag);
    }
  }

  flags_internal::ResetGeneratorFlags(flagfile_value);

  // All the remaining arguments are positional.
  if (!input_args.empty()) {
    for (size_t arg_index = input_args.back().FrontIndex();
         arg_index < static_cast<size_t>(argc); ++arg_index) {
      positional_args.push_back(argv[arg_index]);
    }
  }

  // Trim and sort the vector.
  specified_flags->shrink_to_fit();
  std::sort(specified_flags->begin(), specified_flags->end(),
            flags_internal::SpecifiedFlagsCompare{});

  // Filter out unrecognized flags, which are ok to ignore.
  std::vector<UnrecognizedFlag> filtered;
  filtered.reserve(unrecognized_flags.size());
  for (const auto& unrecognized : unrecognized_flags) {
    if (flags_internal::CanIgnoreUndefinedFlag(unrecognized.flag_name))
      continue;
    filtered.push_back(unrecognized);
  }

  std::swap(unrecognized_flags, filtered);

  if (!success) {
#if ABSL_FLAGS_STRIP_NAMES
    flags_internal::ReportUsageError(
        "NOTE: command line flags are disabled in this build", true);
#else
    flags_internal::HandleUsageFlags(std::cerr, ProgramUsageMessage());
#endif
    return HelpMode::kFull;  // We just need to make sure the exit with
                             // code 1.
  }

  return usage_flag_action == UsageFlagsAction::kHandleUsage
             ? flags_internal::HandleUsageFlags(std::cout,
                                                ProgramUsageMessage())
             : HelpMode::kNone;
}

}  // namespace flags_internal

void ParseAbseilFlagsOnly(int argc, char* argv[],
                          std::vector<char*>& positional_args,
                          std::vector<UnrecognizedFlag>& unrecognized_flags) {
  auto help_mode = flags_internal::ParseAbseilFlagsOnlyImpl(
      argc, argv, positional_args, unrecognized_flags,
      flags_internal::UsageFlagsAction::kHandleUsage);

  flags_internal::MaybeExit(help_mode);
}

// --------------------------------------------------------------------

void ReportUnrecognizedFlags(
    const std::vector<UnrecognizedFlag>& unrecognized_flags) {
  flags_internal::ReportUnrecognizedFlags(unrecognized_flags, true);
}

// --------------------------------------------------------------------

std::vector<char*> ParseCommandLine(int argc, char* argv[]) {
  return flags_internal::ParseCommandLineImpl(
      argc, argv, flags_internal::UsageFlagsAction::kHandleUsage,
      flags_internal::OnUndefinedFlag::kAbortIfUndefined);
}

ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                               node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/parse.h                                       0000664 0000000 0000000 00000011626 14746647661 0023723 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
// Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// -----------------------------------------------------------------------------
// File: parse.h
// -----------------------------------------------------------------------------
//
// This file defines the main parsing function for Abseil flags:
// `absl::ParseCommandLine()`.

#ifndef ABSL_FLAGS_PARSE_H_
#define ABSL_FLAGS_PARSE_H_

#include <string>
#include <vector>

#include "absl/base/config.h"
#include "absl/flags/internal/parse.h"

namespace absl {
ABSL_NAMESPACE_BEGIN

// This type represent information about an unrecognized flag in the command
// line.
struct UnrecognizedFlag {
  enum Source { kFromArgv, kFromFlagfile };

  explicit UnrecognizedFlag(Source s, absl::string_view f)
      : source(s), flag_name(f) {}
  // This field indicates where we found this flag: on the original command line
  // or read in some flag file.
  Source source;
  // Name of the flag we did not recognize in --flag_name=value or --flag_name.
  std::string flag_name;
};

inline bool operator==(const UnrecognizedFlag& lhs,
                       const UnrecognizedFlag& rhs) {
  return lhs.source == rhs.source && lhs.flag_name == rhs.flag_name;
}

namespace flags_internal {

HelpMode ParseAbseilFlagsOnlyImpl(
    int argc, char* argv[], std::vector<char*>& positional_args,
    std::vector<UnrecognizedFlag>& unrecognized_flags,
    UsageFlagsAction usage_flag_action);

}  // namespace flags_internal

// ParseAbseilFlagsOnly()
//
// Parses a list of command-line arguments, passed in the `argc` and `argv[]`
// parameters, into a set of Abseil Flag values, returning any unparsed
// arguments in `positional_args` and `unrecognized_flags` output parameters.
//
// This function classifies all the arguments (including content of the
// flagfiles, if any) into one of the following groups:
//
//   * arguments specified as "--flag=value" or "--flag value" that match
//     registered or built-in Abseil Flags. These are "Abseil Flag arguments."
//   * arguments specified as "--flag" that are unrecognized as Abseil Flags
//   * arguments that are not specified as "--flag" are positional arguments
//   * arguments that follow the flag-terminating delimiter (`--`) are also
//     treated as positional arguments regardless of their syntax.
//
// All of the deduced Abseil Flag arguments are then parsed into their
// corresponding flag values. If any syntax errors are found in these arguments,
// the binary exits with code 1.
//
// This function also handles Abseil Flags built-in usage flags (e.g. --help)
// if any were present on the command line.
//
// All the remaining positional arguments including original program name
// (argv[0]) are are returned in the `positional_args` output parameter.
//
// All unrecognized flags that are not otherwise ignored are returned in the
// `unrecognized_flags` output parameter. Note that the special `undefok`
// flag allows you to specify flags which can be safely ignored; `undefok`
// specifies these flags as a comma-separated list. Any unrecognized flags
// that appear within `undefok` will therefore be ignored and not included in
// the `unrecognized_flag` output parameter.
//
void ParseAbseilFlagsOnly(int argc, char* argv[],
                          std::vector<char*>& positional_args,
                          std::vector<UnrecognizedFlag>& unrecognized_flags);

// ReportUnrecognizedFlags()
//
// Reports an error to `stderr` for all non-ignored unrecognized flags in
// the provided `unrecognized_flags` list.
void ReportUnrecognizedFlags(
    const std::vector<UnrecognizedFlag>& unrecognized_flags);

// ParseCommandLine()
//
// First parses Abseil Flags only from the command line according to the
// description in `ParseAbseilFlagsOnly`. In addition this function handles
// unrecognized and usage flags.
//
// If any unrecognized flags are located they are reported using
// `ReportUnrecognizedFlags`.
//
// If any errors detected during command line parsing, this routine reports a
// usage message and aborts the program.
//
// If any built-in usage flags were specified on the command line (e.g.
// `--help`), this function reports help messages and then gracefully exits the
// program.
//
// This function returns all the remaining positional arguments collected by
// `ParseAbseilFlagsOnly`.
std::vector<char*> ParseCommandLine(int argc, char* argv[]);

ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_FLAGS_PARSE_H_
                                                                                                          node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/parse_test.cc                                 0000664 0000000 0000000 00000075447 14746647661 0025133 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
// Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/flags/parse.h"

#include <stdlib.h>

#include <fstream>
#include <iostream>
#include <string>
#include <vector>

#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "absl/base/internal/scoped_set_env.h"
#include "absl/flags/config.h"
#include "absl/flags/flag.h"
#include "absl/flags/internal/parse.h"
#include "absl/flags/internal/usage.h"
#include "absl/flags/reflection.h"
#include "absl/log/log.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"
#include "absl/strings/substitute.h"
#include "absl/types/span.h"

#ifdef _WIN32
#include <windows.h>
#endif

// Define 125 similar flags to test kMaxHints for flag suggestions.
#define FLAG_MULT(x) F3(x)
#define TEST_FLAG_HEADER FLAG_HEADER_

#define F(name) ABSL_FLAG(int, name, 0, "")

#define F1(name) \
  F(name##1);    \
  F(name##2);    \
  F(name##3);    \
  F(name##4);    \
  F(name##5)
/**/
#define F2(name) \
  F1(name##1);   \
  F1(name##2);   \
  F1(name##3);   \
  F1(name##4);   \
  F1(name##5)
/**/
#define F3(name) \
  F2(name##1);   \
  F2(name##2);   \
  F2(name##3);   \
  F2(name##4);   \
  F2(name##5)
/**/

FLAG_MULT(TEST_FLAG_HEADER);

namespace {

using absl::base_internal::ScopedSetEnv;

struct UDT {
  UDT() = default;
  UDT(const UDT&) = default;
  UDT& operator=(const UDT&) = default;
  UDT(int v) : value(v) {}  // NOLINT

  int value;
};

bool AbslParseFlag(absl::string_view in, UDT* udt, std::string* err) {
  if (in == "A") {
    udt->value = 1;
    return true;
  }
  if (in == "AAA") {
    udt->value = 10;
    return true;
  }

  *err = "Use values A, AAA instead";
  return false;
}
std::string AbslUnparseFlag(const UDT& udt) {
  return udt.value == 1 ? "A" : "AAA";
}

std::string GetTestTmpDirEnvVar(const char* const env_var_name) {
#ifdef _WIN32
  char buf[MAX_PATH];
  auto get_res = GetEnvironmentVariableA(env_var_name, buf, sizeof(buf));
  if (get_res >= sizeof(buf) || get_res == 0) {
    return "";
  }

  return std::string(buf, get_res);
#else
  const char* val = ::getenv(env_var_name);
  if (val == nullptr) {
    return "";
  }

  return val;
#endif
}

const std::string& GetTestTempDir() {
  static std::string* temp_dir_name = []() -> std::string* {
    std::string* res = new std::string(GetTestTmpDirEnvVar("TEST_TMPDIR"));

    if (res->empty()) {
      *res = GetTestTmpDirEnvVar("TMPDIR");
    }

    if (res->empty()) {
#ifdef _WIN32
      char temp_path_buffer[MAX_PATH];

      auto len = GetTempPathA(MAX_PATH, temp_path_buffer);
      if (len < MAX_PATH && len != 0) {
        std::string temp_dir_name = temp_path_buffer;
        if (!absl::EndsWith(temp_dir_name, "\\")) {
          temp_dir_name.push_back('\\');
        }
        absl::StrAppend(&temp_dir_name, "parse_test.", GetCurrentProcessId());
        if (CreateDirectoryA(temp_dir_name.c_str(), nullptr)) {
          *res = temp_dir_name;
        }
      }
#else
      char temp_dir_template[] = "/tmp/parse_test.XXXXXX";
      if (auto* unique_name = ::mkdtemp(temp_dir_template)) {
        *res = unique_name;
      }
#endif
    }

    if (res->empty()) {
      LOG(FATAL) << "Failed to make temporary directory for data files";
    }

#ifdef _WIN32
    *res += "\\";
#else
    *res += "/";
#endif

    return res;
  }();

  return *temp_dir_name;
}

struct FlagfileData {
  const absl::string_view file_name;
  const absl::Span<const char* const> file_lines;
};

// clang-format off
constexpr const char* const ff1_data[] = {
    "# comment    ",
    "  # comment  ",
    "",
    "     ",
    "--int_flag=-1",
    "  --string_flag=q2w2  ",
    "  ##   ",
    "  --double_flag=0.1",
    "--bool_flag=Y  "
};

constexpr const char* const ff2_data[] = {
    "# Setting legacy flag",
    "--legacy_int=1111",
    "--legacy_bool",
    "--nobool_flag",
    "--legacy_str=aqsw",
    "--int_flag=100",
    "   ## ============="
};
// clang-format on

// Builds flagfile flag in the flagfile_flag buffer and returns it. This
// function also creates a temporary flagfile based on FlagfileData input.
// We create a flagfile in a temporary directory with the name specified in
// FlagfileData and populate it with lines specified in FlagfileData. If $0 is
// referenced in any of the lines in FlagfileData they are replaced with
// temporary directory location. This way we can test inclusion of one flagfile
// from another flagfile.
const char* GetFlagfileFlag(const std::vector<FlagfileData>& ffd,
                            std::string& flagfile_flag) {
  flagfile_flag = "--flagfile=";
  absl::string_view separator;
  for (const auto& flagfile_data : ffd) {
    std::string flagfile_name =
        absl::StrCat(GetTestTempDir(), flagfile_data.file_name);

    std::ofstream flagfile_out(flagfile_name);
    for (auto line : flagfile_data.file_lines) {
      flagfile_out << absl::Substitute(line, GetTestTempDir()) << "\n";
    }

    absl::StrAppend(&flagfile_flag, separator, flagfile_name);
    separator = ",";
  }

  return flagfile_flag.c_str();
}

}  // namespace

ABSL_FLAG(int, int_flag, 1, "");
ABSL_FLAG(double, double_flag, 1.1, "");
ABSL_FLAG(std::string, string_flag, "a", "");
ABSL_FLAG(bool, bool_flag, false, "");
ABSL_FLAG(UDT, udt_flag, -1, "");
ABSL_RETIRED_FLAG(int, legacy_int, 1, "");
ABSL_RETIRED_FLAG(bool, legacy_bool, false, "");
ABSL_RETIRED_FLAG(std::string, legacy_str, "l", "");

namespace {

namespace flags = absl::flags_internal;
using testing::AllOf;
using testing::ElementsAreArray;
using testing::HasSubstr;

class ParseTest : public testing::Test {
 public:
  ~ParseTest() override { flags::SetFlagsHelpMode(flags::HelpMode::kNone); }

  void SetUp() override {
#if ABSL_FLAGS_STRIP_NAMES
    GTEST_SKIP() << "This test requires flag names to be present";
#endif
  }

 private:
  absl::FlagSaver flag_saver_;
};

// --------------------------------------------------------------------

template <int N>
flags::HelpMode InvokeParseAbslOnlyImpl(const char* (&in_argv)[N]) {
  std::vector<char*> positional_args;
  std::vector<absl::UnrecognizedFlag> unrecognized_flags;

  return flags::ParseAbseilFlagsOnlyImpl(N, const_cast<char**>(in_argv),
                                         positional_args, unrecognized_flags,
                                         flags::UsageFlagsAction::kHandleUsage);
}

// --------------------------------------------------------------------

template <int N>
void InvokeParseAbslOnly(const char* (&in_argv)[N]) {
  std::vector<char*> positional_args;
  std::vector<absl::UnrecognizedFlag> unrecognized_flags;

  absl::ParseAbseilFlagsOnly(2, const_cast<char**>(in_argv), positional_args,
                             unrecognized_flags);
}

// --------------------------------------------------------------------

template <int N>
std::vector<char*> InvokeParseCommandLineImpl(const char* (&in_argv)[N]) {
  return flags::ParseCommandLineImpl(
      N, const_cast<char**>(in_argv), flags::UsageFlagsAction::kHandleUsage,
      flags::OnUndefinedFlag::kAbortIfUndefined, std::cerr);
}

// --------------------------------------------------------------------

template <int N>
std::vector<char*> InvokeParse(const char* (&in_argv)[N]) {
  return absl::ParseCommandLine(N, const_cast<char**>(in_argv));
}

// --------------------------------------------------------------------

template <int N>
void TestParse(const char* (&in_argv)[N], int int_flag_value,
               double double_flag_val, absl::string_view string_flag_val,
               bool bool_flag_val, int exp_position_args = 0) {
  auto out_args = InvokeParse(in_argv);

  EXPECT_EQ(out_args.size(), 1 + exp_position_args);
  EXPECT_STREQ(out_args[0], "testbin");

  EXPECT_EQ(absl::GetFlag(FLAGS_int_flag), int_flag_value);
  EXPECT_NEAR(absl::GetFlag(FLAGS_double_flag), double_flag_val, 0.0001);
  EXPECT_EQ(absl::GetFlag(FLAGS_string_flag), string_flag_val);
  EXPECT_EQ(absl::GetFlag(FLAGS_bool_flag), bool_flag_val);
}

// --------------------------------------------------------------------

TEST_F(ParseTest, TestEmptyArgv) {
  const char* in_argv[] = {"testbin"};

  auto out_args = InvokeParse(in_argv);

  EXPECT_EQ(out_args.size(), 1);
  EXPECT_STREQ(out_args[0], "testbin");
}

// --------------------------------------------------------------------

TEST_F(ParseTest, TestValidIntArg) {
  const char* in_args1[] = {
      "testbin",
      "--int_flag=10",
  };
  TestParse(in_args1, 10, 1.1, "a", false);

  const char* in_args2[] = {
      "testbin",
      "-int_flag=020",
  };
  TestParse(in_args2, 20, 1.1, "a", false);

  const char* in_args3[] = {
      "testbin",
      "--int_flag",
      "-30",
  };
  TestParse(in_args3, -30, 1.1, "a", false);

  const char* in_args4[] = {
      "testbin",
      "-int_flag",
      "0x21",
  };
  TestParse(in_args4, 33, 1.1, "a", false);
}

// --------------------------------------------------------------------

TEST_F(ParseTest, TestValidDoubleArg) {
  const char* in_args1[] = {
      "testbin",
      "--double_flag=2.3",
  };
  TestParse(in_args1, 1, 2.3, "a", false);

  const char* in_args2[] = {
      "testbin",
      "--double_flag=0x1.2",
  };
  TestParse(in_args2, 1, 1.125, "a", false);

  const char* in_args3[] = {
      "testbin",
      "--double_flag",
      "99.7",
  };
  TestParse(in_args3, 1, 99.7, "a", false);

  const char* in_args4[] = {
      "testbin",
      "--double_flag",
      "0x20.1",
  };
  TestParse(in_args4, 1, 32.0625, "a", false);
}

// --------------------------------------------------------------------

TEST_F(ParseTest, TestValidStringArg) {
  const char* in_args1[] = {
      "testbin",
      "--string_flag=aqswde",
  };
  TestParse(in_args1, 1, 1.1, "aqswde", false);

  const char* in_args2[] = {
      "testbin",
      "-string_flag=a=b=c",
  };
  TestParse(in_args2, 1, 1.1, "a=b=c", false);

  const char* in_args3[] = {
      "testbin",
      "--string_flag",
      "zaxscd",
  };
  TestParse(in_args3, 1, 1.1, "zaxscd", false);

  const char* in_args4[] = {
      "testbin",
      "-string_flag",
      "--int_flag",
  };
  TestParse(in_args4, 1, 1.1, "--int_flag", false);

  const char* in_args5[] = {
      "testbin",
      "--string_flag",
      "--no_a_flag=11",
  };
  TestParse(in_args5, 1, 1.1, "--no_a_flag=11", false);
}

// --------------------------------------------------------------------

TEST_F(ParseTest, TestValidBoolArg) {
  const char* in_args1[] = {
      "testbin",
      "--bool_flag",
  };
  TestParse(in_args1, 1, 1.1, "a", true);

  const char* in_args2[] = {
      "testbin",
      "--nobool_flag",
  };
  TestParse(in_args2, 1, 1.1, "a", false);

  const char* in_args3[] = {
      "testbin",
      "--bool_flag=true",
  };
  TestParse(in_args3, 1, 1.1, "a", true);

  const char* in_args4[] = {
      "testbin",
      "-bool_flag=false",
  };
  TestParse(in_args4, 1, 1.1, "a", false);
}

// --------------------------------------------------------------------

TEST_F(ParseTest, TestValidUDTArg) {
  const char* in_args1[] = {
      "testbin",
      "--udt_flag=A",
  };
  InvokeParse(in_args1);

  EXPECT_EQ(absl::GetFlag(FLAGS_udt_flag).value, 1);

  const char* in_args2[] = {"testbin", "--udt_flag", "AAA"};
  InvokeParse(in_args2);

  EXPECT_EQ(absl::GetFlag(FLAGS_udt_flag).value, 10);
}

// --------------------------------------------------------------------

TEST_F(ParseTest, TestValidMultipleArg) {
  const char* in_args1[] = {
      "testbin",           "--bool_flag",       "--int_flag=2",
      "--double_flag=0.1", "--string_flag=asd",
  };
  TestParse(in_args1, 2, 0.1, "asd", true);

  const char* in_args2[] = {
      "testbin", "--string_flag=", "--nobool_flag", "--int_flag",
      "-011",    "--double_flag",  "-1e-2",
  };
  TestParse(in_args2, -11, -0.01, "", false);

  const char* in_args3[] = {
      "testbin",          "--int_flag",         "-0", "--string_flag", "\"\"",
      "--bool_flag=true", "--double_flag=1e18",
  };
  TestParse(in_args3, 0, 1e18, "\"\"", true);
}

// --------------------------------------------------------------------

TEST_F(ParseTest, TestPositionalArgs) {
  const char* in_args1[] = {
      "testbin",
      "p1",
      "p2",
  };
  TestParse(in_args1, 1, 1.1, "a", false, 2);

  auto out_args1 = InvokeParse(in_args1);

  EXPECT_STREQ(out_args1[1], "p1");
  EXPECT_STREQ(out_args1[2], "p2");

  const char* in_args2[] = {
      "testbin",
      "--int_flag=2",
      "p1",
  };
  TestParse(in_args2, 2, 1.1, "a", false, 1);

  auto out_args2 = InvokeParse(in_args2);

  EXPECT_STREQ(out_args2[1], "p1");

  const char* in_args3[] = {"testbin", "p1",          "--int_flag=3",
                            "p2",      "--bool_flag", "true"};
  TestParse(in_args3, 3, 1.1, "a", true, 3);

  auto out_args3 = InvokeParse(in_args3);

  EXPECT_STREQ(out_args3[1], "p1");
  EXPECT_STREQ(out_args3[2], "p2");
  EXPECT_STREQ(out_args3[3], "true");

  const char* in_args4[] = {
      "testbin",
      "--",
      "p1",
      "p2",
  };
  TestParse(in_args4, 3, 1.1, "a", true, 2);

  auto out_args4 = InvokeParse(in_args4);

  EXPECT_STREQ(out_args4[1], "p1");
  EXPECT_STREQ(out_args4[2], "p2");

  const char* in_args5[] = {
      "testbin", "p1", "--int_flag=4", "--", "--bool_flag", "false", "p2",
  };
  TestParse(in_args5, 4, 1.1, "a", true, 4);

  auto out_args5 = InvokeParse(in_args5);

  EXPECT_STREQ(out_args5[1], "p1");
  EXPECT_STREQ(out_args5[2], "--bool_flag");
  EXPECT_STREQ(out_args5[3], "false");
  EXPECT_STREQ(out_args5[4], "p2");
}

// --------------------------------------------------------------------

using ParseDeathTest = ParseTest;

TEST_F(ParseDeathTest, TestUndefinedArg) {
  const char* in_args1[] = {
      "testbin",
      "--undefined_flag",
  };
  EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args1),
                            "Unknown command line flag 'undefined_flag'");

  const char* in_args2[] = {
      "testbin",
      "--noprefixed_flag",
  };
  EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args2),
                            "Unknown command line flag 'noprefixed_flag'");

  const char* in_args3[] = {
      "testbin",
      "--Int_flag=1",
  };
  EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args3),
                            "Unknown command line flag 'Int_flag'");
}

// --------------------------------------------------------------------

TEST_F(ParseDeathTest, TestInvalidBoolFlagFormat) {
  const char* in_args1[] = {
      "testbin",
      "--bool_flag=",
  };
  EXPECT_DEATH_IF_SUPPORTED(
      InvokeParse(in_args1),
      "Missing the value after assignment for the boolean flag 'bool_flag'");

  const char* in_args2[] = {
      "testbin",
      "--nobool_flag=true",
  };
  EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args2),
               "Negative form with assignment is not valid for the boolean "
               "flag 'bool_flag'");
}

// --------------------------------------------------------------------

TEST_F(ParseDeathTest, TestInvalidNonBoolFlagFormat) {
  const char* in_args1[] = {
      "testbin",
      "--nostring_flag",
  };
  EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args1),
               "Negative form is not valid for the flag 'string_flag'");

  const char* in_args2[] = {
      "testbin",
      "--int_flag",
  };
  EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args2),
               "Missing the value for the flag 'int_flag'");
}

// --------------------------------------------------------------------

TEST_F(ParseDeathTest, TestInvalidUDTFlagFormat) {
  const char* in_args1[] = {
      "testbin",
      "--udt_flag=1",
  };
  EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args1),
               "Illegal value '1' specified for flag 'udt_flag'; Use values A, "
               "AAA instead");

  const char* in_args2[] = {
      "testbin",
      "--udt_flag",
      "AA",
  };
  EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args2),
               "Illegal value 'AA' specified for flag 'udt_flag'; Use values "
               "A, AAA instead");
}

// --------------------------------------------------------------------

TEST_F(ParseDeathTest, TestFlagSuggestions) {
  const char* in_args1[] = {
      "testbin",
      "--legacy_boo",
  };
  EXPECT_DEATH_IF_SUPPORTED(
      InvokeParse(in_args1),
      "Unknown command line flag 'legacy_boo'. Did you mean: legacy_bool ?");

  const char* in_args2[] = {"testbin", "--foo", "--undefok=foo1"};
  EXPECT_DEATH_IF_SUPPORTED(
      InvokeParse(in_args2),
      "Unknown command line flag 'foo'. Did you mean: foo1 \\(undefok\\)?");

  const char* in_args3[] = {
      "testbin",
      "--nolegacy_ino",
  };
  EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args3),
                            "Unknown command line flag 'nolegacy_ino'. Did "
                            "you mean: nolegacy_bool, legacy_int ?");
}

// --------------------------------------------------------------------

TEST_F(ParseTest, GetHints) {
  EXPECT_THAT(absl::flags_internal::GetMisspellingHints("legacy_boo"),
              testing::ContainerEq(std::vector<std::string>{"legacy_bool"}));
  EXPECT_THAT(absl::flags_internal::GetMisspellingHints("nolegacy_itn"),
              testing::ContainerEq(std::vector<std::string>{"legacy_int"}));
  EXPECT_THAT(absl::flags_internal::GetMisspellingHints("nolegacy_int1"),
              testing::ContainerEq(std::vector<std::string>{"legacy_int"}));
  EXPECT_THAT(absl::flags_internal::GetMisspellingHints("nolegacy_int"),
              testing::ContainerEq(std::vector<std::string>{"legacy_int"}));
  EXPECT_THAT(absl::flags_internal::GetMisspellingHints("nolegacy_ino"),
              testing::ContainerEq(
                  std::vector<std::string>{"nolegacy_bool", "legacy_int"}));
  EXPECT_THAT(
      absl::flags_internal::GetMisspellingHints("FLAG_HEADER_000").size(), 100);
}

// --------------------------------------------------------------------

TEST_F(ParseTest, TestLegacyFlags) {
  const char* in_args1[] = {
      "testbin",
      "--legacy_int=11",
  };
  TestParse(in_args1, 1, 1.1, "a", false);

  const char* in_args2[] = {
      "testbin",
      "--legacy_bool",
  };
  TestParse(in_args2, 1, 1.1, "a", false);

  const char* in_args3[] = {
      "testbin",       "--legacy_int", "22",           "--int_flag=2",
      "--legacy_bool", "true",         "--legacy_str", "--string_flag=qwe",
  };
  TestParse(in_args3, 2, 1.1, "a", false, 1);
}

// --------------------------------------------------------------------

TEST_F(ParseTest, TestSimpleValidFlagfile) {
  std::string flagfile_flag;

  const char* in_args1[] = {
      "testbin",
      GetFlagfileFlag({{"parse_test.ff1", absl::MakeConstSpan(ff1_data)}},
                      flagfile_flag),
  };
  TestParse(in_args1, -1, 0.1, "q2w2  ", true);

  const char* in_args2[] = {
      "testbin",
      GetFlagfileFlag({{"parse_test.ff2", absl::MakeConstSpan(ff2_data)}},
                      flagfile_flag),
  };
  TestParse(in_args2, 100, 0.1, "q2w2  ", false);
}

// --------------------------------------------------------------------

TEST_F(ParseTest, TestValidMultiFlagfile) {
  std::string flagfile_flag;

  const char* in_args1[] = {
      "testbin",
      GetFlagfileFlag({{"parse_test.ff2", absl::MakeConstSpan(ff2_data)},
                       {"parse_test.ff1", absl::MakeConstSpan(ff1_data)}},
                      flagfile_flag),
  };
  TestParse(in_args1, -1, 0.1, "q2w2  ", true);
}

// --------------------------------------------------------------------

TEST_F(ParseTest, TestFlagfileMixedWithRegularFlags) {
  std::string flagfile_flag;

  const char* in_args1[] = {
      "testbin", "--int_flag=3",
      GetFlagfileFlag({{"parse_test.ff1", absl::MakeConstSpan(ff1_data)}},
                      flagfile_flag),
      "-double_flag=0.2"};
  TestParse(in_args1, -1, 0.2, "q2w2  ", true);
}

// --------------------------------------------------------------------

TEST_F(ParseTest, TestFlagfileInFlagfile) {
  std::string flagfile_flag;

  constexpr const char* const ff3_data[] = {
      "--flagfile=$0/parse_test.ff1",
      "--flagfile=$0/parse_test.ff2",
  };

  GetFlagfileFlag({{"parse_test.ff2", absl::MakeConstSpan(ff2_data)},
                   {"parse_test.ff1", absl::MakeConstSpan(ff1_data)}},
                      flagfile_flag);

  const char* in_args1[] = {
      "testbin",
      GetFlagfileFlag({{"parse_test.ff3", absl::MakeConstSpan(ff3_data)}},
                      flagfile_flag),
  };
  TestParse(in_args1, 100, 0.1, "q2w2  ", false);
}

// --------------------------------------------------------------------

TEST_F(ParseDeathTest, TestInvalidFlagfiles) {
  std::string flagfile_flag;

  constexpr const char* const ff4_data[] = {
    "--unknown_flag=10"
  };

  const char* in_args1[] = {
      "testbin",
      GetFlagfileFlag({{"parse_test.ff4",
                        absl::MakeConstSpan(ff4_data)}}, flagfile_flag),
  };
  EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args1),
               "Unknown command line flag 'unknown_flag'");

  constexpr const char* const ff5_data[] = {
    "--int_flag 10",
  };

  const char* in_args2[] = {
      "testbin",
      GetFlagfileFlag({{"parse_test.ff5",
                        absl::MakeConstSpan(ff5_data)}}, flagfile_flag),
  };
  EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args2),
               "Unknown command line flag 'int_flag 10'");

  constexpr const char* const ff6_data[] = {
      "--int_flag=10", "--", "arg1", "arg2", "arg3",
  };

  const char* in_args3[] = {
      "testbin",
      GetFlagfileFlag({{"parse_test.ff6", absl::MakeConstSpan(ff6_data)}},
                      flagfile_flag),
  };
  EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args3),
               "Flagfile can't contain position arguments or --");

  const char* in_args4[] = {
      "testbin",
      "--flagfile=invalid_flag_file",
  };
  EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args4),
                            "Can't open flagfile invalid_flag_file");

  constexpr const char* const ff7_data[] = {
      "--int_flag=10",
      "*bin*",
      "--str_flag=aqsw",
  };

  const char* in_args5[] = {
      "testbin",
      GetFlagfileFlag({{"parse_test.ff7", absl::MakeConstSpan(ff7_data)}},
                      flagfile_flag),
  };
  EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args5),
               "Unexpected line in the flagfile .*: \\*bin\\*");
}

// --------------------------------------------------------------------

TEST_F(ParseTest, TestReadingRequiredFlagsFromEnv) {
  const char* in_args1[] = {"testbin",
                            "--fromenv=int_flag,bool_flag,string_flag"};

  ScopedSetEnv set_int_flag("FLAGS_int_flag", "33");
  ScopedSetEnv set_bool_flag("FLAGS_bool_flag", "True");
  ScopedSetEnv set_string_flag("FLAGS_string_flag", "AQ12");

  TestParse(in_args1, 33, 1.1, "AQ12", true);
}

// --------------------------------------------------------------------

TEST_F(ParseDeathTest, TestReadingUnsetRequiredFlagsFromEnv) {
  const char* in_args1[] = {"testbin", "--fromenv=int_flag"};

  EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args1),
               "FLAGS_int_flag not found in environment");
}

// --------------------------------------------------------------------

TEST_F(ParseDeathTest, TestRecursiveFlagsFromEnv) {
  const char* in_args1[] = {"testbin", "--fromenv=tryfromenv"};

  ScopedSetEnv set_tryfromenv("FLAGS_tryfromenv", "int_flag");

  EXPECT_DEATH_IF_SUPPORTED(InvokeParse(in_args1),
                            "Infinite recursion on flag tryfromenv");
}

// --------------------------------------------------------------------

TEST_F(ParseTest, TestReadingOptionalFlagsFromEnv) {
  const char* in_args1[] = {
      "testbin", "--tryfromenv=int_flag,bool_flag,string_flag,other_flag"};

  ScopedSetEnv set_int_flag("FLAGS_int_flag", "17");
  ScopedSetEnv set_bool_flag("FLAGS_bool_flag", "Y");

  TestParse(in_args1, 17, 1.1, "a", true);
}

// --------------------------------------------------------------------

TEST_F(ParseTest, TestReadingFlagsFromEnvMoxedWithRegularFlags) {
  const char* in_args1[] = {
      "testbin",
      "--bool_flag=T",
      "--tryfromenv=int_flag,bool_flag",
      "--int_flag=-21",
  };

  ScopedSetEnv set_int_flag("FLAGS_int_flag", "-15");
  ScopedSetEnv set_bool_flag("FLAGS_bool_flag", "F");

  TestParse(in_args1, -21, 1.1, "a", false);
}

// --------------------------------------------------------------------

TEST_F(ParseDeathTest, TestSimpleHelpFlagHandling) {
  const char* in_args1[] = {
      "testbin",
      "--help",
  };

  EXPECT_EQ(InvokeParseAbslOnlyImpl(in_args1), flags::HelpMode::kImportant);
  EXPECT_EXIT(InvokeParse(in_args1), testing::ExitedWithCode(1), "");

  const char* in_args2[] = {
      "testbin",
      "--help",
      "--int_flag=3",
  };

  EXPECT_EQ(InvokeParseAbslOnlyImpl(in_args2), flags::HelpMode::kImportant);
  EXPECT_EQ(absl::GetFlag(FLAGS_int_flag), 3);

  const char* in_args3[] = {"testbin", "--help", "some_positional_arg"};

  EXPECT_EQ(InvokeParseAbslOnlyImpl(in_args3), flags::HelpMode::kImportant);
}

// --------------------------------------------------------------------

TEST_F(ParseTest, TestSubstringHelpFlagHandling) {
  const char* in_args1[] = {
      "testbin",
      "--help=abcd",
  };

  EXPECT_EQ(InvokeParseAbslOnlyImpl(in_args1), flags::HelpMode::kMatch);
  EXPECT_EQ(flags::GetFlagsHelpMatchSubstr(), "abcd");
}

// --------------------------------------------------------------------

TEST_F(ParseDeathTest, TestVersionHandling) {
  const char* in_args1[] = {
      "testbin",
      "--version",
  };

  EXPECT_EQ(InvokeParseAbslOnlyImpl(in_args1), flags::HelpMode::kVersion);
}

// --------------------------------------------------------------------

TEST_F(ParseTest, TestCheckArgsHandling) {
  const char* in_args1[] = {"testbin", "--only_check_args", "--int_flag=211"};

  EXPECT_EQ(InvokeParseAbslOnlyImpl(in_args1), flags::HelpMode::kOnlyCheckArgs);
  EXPECT_EXIT(InvokeParseAbslOnly(in_args1), testing::ExitedWithCode(0), "");
  EXPECT_EXIT(InvokeParse(in_args1), testing::ExitedWithCode(0), "");

  const char* in_args2[] = {"testbin", "--only_check_args", "--unknown_flag=a"};

  EXPECT_EQ(InvokeParseAbslOnlyImpl(in_args2), flags::HelpMode::kOnlyCheckArgs);
  EXPECT_EXIT(InvokeParseAbslOnly(in_args2), testing::ExitedWithCode(0), "");
  EXPECT_EXIT(InvokeParse(in_args2), testing::ExitedWithCode(1), "");
}

// --------------------------------------------------------------------

TEST_F(ParseTest, WasPresentOnCommandLine) {
  const char* in_args1[] = {
      "testbin",        "arg1", "--bool_flag",
      "--int_flag=211", "arg2", "--double_flag=1.1",
      "--string_flag",  "asd",  "--",
      "--some_flag",    "arg4",
  };

  InvokeParse(in_args1);

  EXPECT_TRUE(flags::WasPresentOnCommandLine("bool_flag"));
  EXPECT_TRUE(flags::WasPresentOnCommandLine("int_flag"));
  EXPECT_TRUE(flags::WasPresentOnCommandLine("double_flag"));
  EXPECT_TRUE(flags::WasPresentOnCommandLine("string_flag"));
  EXPECT_FALSE(flags::WasPresentOnCommandLine("some_flag"));
  EXPECT_FALSE(flags::WasPresentOnCommandLine("another_flag"));
}

// --------------------------------------------------------------------

TEST_F(ParseTest, ParseAbseilFlagsOnlySuccess) {
  const char* in_args[] = {
      "testbin",
      "arg1",
      "--bool_flag",
      "--int_flag=211",
      "arg2",
      "--double_flag=1.1",
      "--undef_flag1",
      "--undef_flag2=123",
      "--string_flag",
      "asd",
      "--",
      "--some_flag",
      "arg4",
  };

  std::vector<char*> positional_args;
  std::vector<absl::UnrecognizedFlag> unrecognized_flags;

  absl::ParseAbseilFlagsOnly(13, const_cast<char**>(in_args), positional_args,
                             unrecognized_flags);
  EXPECT_THAT(positional_args,
              ElementsAreArray(
                  {absl::string_view("testbin"), absl::string_view("arg1"),
                   absl::string_view("arg2"), absl::string_view("--some_flag"),
                   absl::string_view("arg4")}));
  EXPECT_THAT(unrecognized_flags,
              ElementsAreArray(
                  {absl::UnrecognizedFlag(absl::UnrecognizedFlag::kFromArgv,
                                          "undef_flag1"),
                   absl::UnrecognizedFlag(absl::UnrecognizedFlag::kFromArgv,
                                          "undef_flag2")}));
}

// --------------------------------------------------------------------

TEST_F(ParseDeathTest, ParseAbseilFlagsOnlyFailure) {
  const char* in_args[] = {
      "testbin",
      "--int_flag=21.1",
  };

  EXPECT_DEATH_IF_SUPPORTED(
      InvokeParseAbslOnly(in_args),
      "Illegal value '21.1' specified for flag 'int_flag'");
}

// --------------------------------------------------------------------

TEST_F(ParseTest, UndefOkFlagsAreIgnored) {
  const char* in_args[] = {
      "testbin",           "--undef_flag1",
      "--undef_flag2=123", "--undefok=undef_flag2",
      "--undef_flag3",     "value",
  };

  std::vector<char*> positional_args;
  std::vector<absl::UnrecognizedFlag> unrecognized_flags;

  absl::ParseAbseilFlagsOnly(6, const_cast<char**>(in_args), positional_args,
                             unrecognized_flags);
  EXPECT_THAT(positional_args, ElementsAreArray({absl::string_view("testbin"),
                                                 absl::string_view("value")}));
  EXPECT_THAT(unrecognized_flags,
              ElementsAreArray(
                  {absl::UnrecognizedFlag(absl::UnrecognizedFlag::kFromArgv,
                                          "undef_flag1"),
                   absl::UnrecognizedFlag(absl::UnrecognizedFlag::kFromArgv,
                                          "undef_flag3")}));
}

// --------------------------------------------------------------------

TEST_F(ParseTest, AllUndefOkFlagsAreIgnored) {
  const char* in_args[] = {
      "testbin",
      "--undef_flag1",
      "--undef_flag2=123",
      "--undefok=undef_flag2,undef_flag1,undef_flag3",
      "--undef_flag3",
      "value",
      "--",
      "--undef_flag4",
  };

  std::vector<char*> positional_args;
  std::vector<absl::UnrecognizedFlag> unrecognized_flags;

  absl::ParseAbseilFlagsOnly(8, const_cast<char**>(in_args), positional_args,
                             unrecognized_flags);
  EXPECT_THAT(positional_args,
              ElementsAreArray({absl::string_view("testbin"),
                                absl::string_view("value"),
                                absl::string_view("--undef_flag4")}));
  EXPECT_THAT(unrecognized_flags, testing::IsEmpty());
}

// --------------------------------------------------------------------

TEST_F(ParseDeathTest, ExitOnUnrecognizedFlagPrintsHelp) {
  const char* in_args[] = {
      "testbin",
      "--undef_flag1",
      "--help=int_flag",
  };

  EXPECT_EXIT(InvokeParseCommandLineImpl(in_args), testing::ExitedWithCode(1),
              AllOf(HasSubstr("Unknown command line flag 'undef_flag1'"),
                    HasSubstr("Try --helpfull to get a list of all flags")));
}

// --------------------------------------------------------------------

}  // namespace
                                                                                                                                                                                                                         node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/reflection.cc                                 0000664 0000000 0000000 00000027675 14746647661 0025114 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
//  Copyright 2020 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/flags/reflection.h"

#include <assert.h>

#include <atomic>
#include <string>

#include "absl/base/config.h"
#include "absl/base/no_destructor.h"
#include "absl/base/thread_annotations.h"
#include "absl/container/flat_hash_map.h"
#include "absl/flags/commandlineflag.h"
#include "absl/flags/internal/private_handle_accessor.h"
#include "absl/flags/internal/registry.h"
#include "absl/flags/usage_config.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"
#include "absl/synchronization/mutex.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace flags_internal {

// --------------------------------------------------------------------
// FlagRegistry
//    A FlagRegistry singleton object holds all flag objects indexed by their
//    names so that if you know a flag's name, you can access or set it. If the
//    function is named FooLocked(), you must own the registry lock before
//    calling the function; otherwise, you should *not* hold the lock, and the
//    function will acquire it itself if needed.
// --------------------------------------------------------------------

class FlagRegistry {
 public:
  FlagRegistry() = default;
  ~FlagRegistry() = default;

  // Store a flag in this registry. Takes ownership of *flag.
  void RegisterFlag(CommandLineFlag& flag, const char* filename);

  void Lock() ABSL_EXCLUSIVE_LOCK_FUNCTION(lock_) { lock_.Lock(); }
  void Unlock() ABSL_UNLOCK_FUNCTION(lock_) { lock_.Unlock(); }

  // Returns the flag object for the specified name, or nullptr if not found.
  // Will emit a warning if a 'retired' flag is specified.
  CommandLineFlag* FindFlag(absl::string_view name);

  static FlagRegistry& GlobalRegistry();  // returns a singleton registry

 private:
  friend class flags_internal::FlagSaverImpl;  // reads all the flags in order
                                               // to copy them
  friend void ForEachFlag(std::function<void(CommandLineFlag&)> visitor);
  friend void FinalizeRegistry();

  // The map from name to flag, for FindFlag().
  using FlagMap = absl::flat_hash_map<absl::string_view, CommandLineFlag*>;
  using FlagIterator = FlagMap::iterator;
  using FlagConstIterator = FlagMap::const_iterator;
  FlagMap flags_;
  std::vector<CommandLineFlag*> flat_flags_;
  std::atomic<bool> finalized_flags_{false};

  absl::Mutex lock_;

  // Disallow
  FlagRegistry(const FlagRegistry&);
  FlagRegistry& operator=(const FlagRegistry&);
};

namespace {

class FlagRegistryLock {
 public:
  explicit FlagRegistryLock(FlagRegistry& fr) : fr_(fr) { fr_.Lock(); }
  ~FlagRegistryLock() { fr_.Unlock(); }

 private:
  FlagRegistry& fr_;
};

}  // namespace

CommandLineFlag* FlagRegistry::FindFlag(absl::string_view name) {
  if (finalized_flags_.load(std::memory_order_acquire)) {
    // We could save some gcus here if we make `Name()` be non-virtual.
    // We could move the `const char*` name to the base class.
    auto it = std::partition_point(
        flat_flags_.begin(), flat_flags_.end(),
        [=](CommandLineFlag* f) { return f->Name() < name; });
    if (it != flat_flags_.end() && (*it)->Name() == name) return *it;
  }

  FlagRegistryLock frl(*this);
  auto it = flags_.find(name);
  return it != flags_.end() ? it->second : nullptr;
}

void FlagRegistry::RegisterFlag(CommandLineFlag& flag, const char* filename) {
  if (filename != nullptr &&
      flag.Filename() != GetUsageConfig().normalize_filename(filename)) {
    flags_internal::ReportUsageError(
        absl::StrCat(
            "Inconsistency between flag object and registration for flag '",
            flag.Name(),
            "', likely due to duplicate flags or an ODR violation. Relevant "
            "files: ",
            flag.Filename(), " and ", filename),
        true);
    std::exit(1);
  }

  FlagRegistryLock registry_lock(*this);

  std::pair<FlagIterator, bool> ins =
      flags_.insert(FlagMap::value_type(flag.Name(), &flag));
  if (ins.second == false) {  // means the name was already in the map
    CommandLineFlag& old_flag = *ins.first->second;
    if (flag.IsRetired() != old_flag.IsRetired()) {
      // All registrations must agree on the 'retired' flag.
      flags_internal::ReportUsageError(
          absl::StrCat(
              "Retired flag '", flag.Name(), "' was defined normally in file '",
              (flag.IsRetired() ? old_flag.Filename() : flag.Filename()), "'."),
          true);
    } else if (flags_internal::PrivateHandleAccessor::TypeId(flag) !=
               flags_internal::PrivateHandleAccessor::TypeId(old_flag)) {
      flags_internal::ReportUsageError(
          absl::StrCat("Flag '", flag.Name(),
                       "' was defined more than once but with "
                       "differing types. Defined in files '",
                       old_flag.Filename(), "' and '", flag.Filename(), "'."),
          true);
    } else if (old_flag.IsRetired()) {
      return;
    } else if (old_flag.Filename() != flag.Filename()) {
      flags_internal::ReportUsageError(
          absl::StrCat("Flag '", flag.Name(),
                       "' was defined more than once (in files '",
                       old_flag.Filename(), "' and '", flag.Filename(), "')."),
          true);
    } else {
      flags_internal::ReportUsageError(
          absl::StrCat(
              "Something is wrong with flag '", flag.Name(), "' in file '",
              flag.Filename(), "'. One possibility: file '", flag.Filename(),
              "' is being linked both statically and dynamically into this "
              "executable. e.g. some files listed as srcs to a test and also "
              "listed as srcs of some shared lib deps of the same test."),
          true);
    }
    // All cases above are fatal, except for the retired flags.
    std::exit(1);
  }
}

FlagRegistry& FlagRegistry::GlobalRegistry() {
  static absl::NoDestructor<FlagRegistry> global_registry;
  return *global_registry;
}

// --------------------------------------------------------------------

void ForEachFlag(std::function<void(CommandLineFlag&)> visitor) {
  FlagRegistry& registry = FlagRegistry::GlobalRegistry();

  if (registry.finalized_flags_.load(std::memory_order_acquire)) {
    for (const auto& i : registry.flat_flags_) visitor(*i);
  }

  FlagRegistryLock frl(registry);
  for (const auto& i : registry.flags_) visitor(*i.second);
}

// --------------------------------------------------------------------

bool RegisterCommandLineFlag(CommandLineFlag& flag, const char* filename) {
  FlagRegistry::GlobalRegistry().RegisterFlag(flag, filename);
  return true;
}

void FinalizeRegistry() {
  auto& registry = FlagRegistry::GlobalRegistry();
  FlagRegistryLock frl(registry);
  if (registry.finalized_flags_.load(std::memory_order_relaxed)) {
    // Was already finalized. Ignore the second time.
    return;
  }
  registry.flat_flags_.reserve(registry.flags_.size());
  for (const auto& f : registry.flags_) {
    registry.flat_flags_.push_back(f.second);
  }
  std::sort(std::begin(registry.flat_flags_), std::end(registry.flat_flags_),
            [](const CommandLineFlag* lhs, const CommandLineFlag* rhs) {
              return lhs->Name() < rhs->Name();
            });
  registry.flags_.clear();
  registry.finalized_flags_.store(true, std::memory_order_release);
}

// --------------------------------------------------------------------

namespace {

// These are only used as constexpr global objects.
// They do not use a virtual destructor to simplify their implementation.
// They are not destroyed except at program exit, so leaks do not matter.
#if defined(__GNUC__) && !defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wnon-virtual-dtor"
#endif
class RetiredFlagObj final : public CommandLineFlag {
 public:
  constexpr RetiredFlagObj(const char* name, FlagFastTypeId type_id)
      : name_(name), type_id_(type_id) {}

 private:
  absl::string_view Name() const override { return name_; }
  std::string Filename() const override {
    OnAccess();
    return "RETIRED";
  }
  FlagFastTypeId TypeId() const override { return type_id_; }
  std::string Help() const override {
    OnAccess();
    return "";
  }
  bool IsRetired() const override { return true; }
  bool IsSpecifiedOnCommandLine() const override {
    OnAccess();
    return false;
  }
  std::string DefaultValue() const override {
    OnAccess();
    return "";
  }
  std::string CurrentValue() const override {
    OnAccess();
    return "";
  }

  // Any input is valid
  bool ValidateInputValue(absl::string_view) const override {
    OnAccess();
    return true;
  }

  std::unique_ptr<flags_internal::FlagStateInterface> SaveState() override {
    return nullptr;
  }

  bool ParseFrom(absl::string_view, flags_internal::FlagSettingMode,
                 flags_internal::ValueSource, std::string&) override {
    OnAccess();
    return false;
  }

  void CheckDefaultValueParsingRoundtrip() const override { OnAccess(); }

  void Read(void*) const override { OnAccess(); }

  void OnAccess() const {
    flags_internal::ReportUsageError(
        absl::StrCat("Accessing retired flag '", name_, "'"), false);
  }

  // Data members
  const char* const name_;
  const FlagFastTypeId type_id_;
};
#if defined(__GNUC__) && !defined(__clang__)
#pragma GCC diagnostic pop
#endif

}  // namespace

void Retire(const char* name, FlagFastTypeId type_id, char* buf) {
  static_assert(sizeof(RetiredFlagObj) == kRetiredFlagObjSize, "");
  static_assert(alignof(RetiredFlagObj) == kRetiredFlagObjAlignment, "");
  auto* flag = ::new (static_cast<void*>(buf))
      flags_internal::RetiredFlagObj(name, type_id);
  FlagRegistry::GlobalRegistry().RegisterFlag(*flag, nullptr);
}

// --------------------------------------------------------------------

class FlagSaverImpl {
 public:
  FlagSaverImpl() = default;
  FlagSaverImpl(const FlagSaverImpl&) = delete;
  void operator=(const FlagSaverImpl&) = delete;

  // Saves the flag states from the flag registry into this object.
  // It's an error to call this more than once.
  void SaveFromRegistry() {
    assert(backup_registry_.empty());  // call only once!
    flags_internal::ForEachFlag([&](CommandLineFlag& flag) {
      if (auto flag_state =
              flags_internal::PrivateHandleAccessor::SaveState(flag)) {
        backup_registry_.emplace_back(std::move(flag_state));
      }
    });
  }

  // Restores the saved flag states into the flag registry.
  void RestoreToRegistry() {
    for (const auto& flag_state : backup_registry_) {
      flag_state->Restore();
    }
  }

 private:
  std::vector<std::unique_ptr<flags_internal::FlagStateInterface>>
      backup_registry_;
};

}  // namespace flags_internal

FlagSaver::FlagSaver() : impl_(new flags_internal::FlagSaverImpl) {
  impl_->SaveFromRegistry();
}

FlagSaver::~FlagSaver() {
  if (!impl_) return;

  impl_->RestoreToRegistry();
  delete impl_;
}

// --------------------------------------------------------------------

CommandLineFlag* FindCommandLineFlag(absl::string_view name) {
  if (name.empty()) return nullptr;
  flags_internal::FlagRegistry& registry =
      flags_internal::FlagRegistry::GlobalRegistry();
  return registry.FindFlag(name);
}

// --------------------------------------------------------------------

absl::flat_hash_map<absl::string_view, absl::CommandLineFlag*> GetAllFlags() {
  absl::flat_hash_map<absl::string_view, absl::CommandLineFlag*> res;
  flags_internal::ForEachFlag([&](CommandLineFlag& flag) {
    if (!flag.IsRetired()) res.insert({flag.Name(), &flag});
  });
  return res;
}

ABSL_NAMESPACE_END
}  // namespace absl
                                                                   node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/reflection.h                                  0000664 0000000 0000000 00000005503 14746647661 0024740 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
// Copyright 2020 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// -----------------------------------------------------------------------------
// File: reflection.h
// -----------------------------------------------------------------------------
//
// This file defines the routines to access and operate on an Abseil Flag's
// reflection handle.

#ifndef ABSL_FLAGS_REFLECTION_H_
#define ABSL_FLAGS_REFLECTION_H_

#include <string>

#include "absl/base/config.h"
#include "absl/container/flat_hash_map.h"
#include "absl/flags/commandlineflag.h"
#include "absl/flags/internal/commandlineflag.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace flags_internal {
class FlagSaverImpl;
}  // namespace flags_internal

// FindCommandLineFlag()
//
// Returns the reflection handle of an Abseil flag of the specified name, or
// `nullptr` if not found. This function will emit a warning if the name of a
// 'retired' flag is specified.
absl::CommandLineFlag* FindCommandLineFlag(absl::string_view name);

// Returns current state of the Flags registry in a form of mapping from flag
// name to a flag reflection handle.
absl::flat_hash_map<absl::string_view, absl::CommandLineFlag*> GetAllFlags();

//------------------------------------------------------------------------------
// FlagSaver
//------------------------------------------------------------------------------
//
// A FlagSaver object stores the state of flags in the scope where the FlagSaver
// is defined, allowing modification of those flags within that scope and
// automatic restoration of the flags to their previous state upon leaving the
// scope.
//
// A FlagSaver can be used within tests to temporarily change the test
// environment and restore the test case to its previous state.
//
// Example:
//
//   void MyFunc() {
//    absl::FlagSaver fs;
//    ...
//    absl::SetFlag(&FLAGS_myFlag, otherValue);
//    ...
//  } // scope of FlagSaver left, flags return to previous state
//
// This class is thread-safe.

class FlagSaver {
 public:
  FlagSaver();
  ~FlagSaver();

  FlagSaver(const FlagSaver&) = delete;
  void operator=(const FlagSaver&) = delete;

 private:
  flags_internal::FlagSaverImpl* impl_;
};

//-----------------------------------------------------------------------------

ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_FLAGS_REFLECTION_H_
                                                                                                                                                                                             node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/reflection_test.cc                            0000664 0000000 0000000 00000022157 14746647661 0026141 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
//  Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/flags/reflection.h"

#include <memory>
#include <string>

#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "absl/flags/config.h"
#include "absl/flags/flag.h"
#include "absl/memory/memory.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/str_split.h"

ABSL_FLAG(int, int_flag, 1, "int_flag help");
ABSL_FLAG(std::string, string_flag, "dflt", "string_flag help");
ABSL_RETIRED_FLAG(bool, bool_retired_flag, false, "bool_retired_flag help");

namespace {

class ReflectionTest : public testing::Test {
 protected:
  void SetUp() override {
#if ABSL_FLAGS_STRIP_NAMES
    GTEST_SKIP() << "This test requires flag names to be present";
#endif
    flag_saver_ = absl::make_unique<absl::FlagSaver>();
  }
  void TearDown() override { flag_saver_.reset(); }

 private:
  std::unique_ptr<absl::FlagSaver> flag_saver_;
};

// --------------------------------------------------------------------

TEST_F(ReflectionTest, TestFindCommandLineFlag) {
  auto* handle = absl::FindCommandLineFlag("some_flag");
  EXPECT_EQ(handle, nullptr);

  handle = absl::FindCommandLineFlag("int_flag");
  EXPECT_NE(handle, nullptr);

  handle = absl::FindCommandLineFlag("string_flag");
  EXPECT_NE(handle, nullptr);

  handle = absl::FindCommandLineFlag("bool_retired_flag");
  EXPECT_NE(handle, nullptr);
}

// --------------------------------------------------------------------

TEST_F(ReflectionTest, TestGetAllFlags) {
  auto all_flags = absl::GetAllFlags();
  EXPECT_NE(all_flags.find("int_flag"), all_flags.end());
  EXPECT_EQ(all_flags.find("bool_retired_flag"), all_flags.end());
  EXPECT_EQ(all_flags.find("some_undefined_flag"), all_flags.end());

  std::vector<absl::string_view> flag_names_first_attempt;
  auto all_flags_1 = absl::GetAllFlags();
  for (auto f : all_flags_1) {
    flag_names_first_attempt.push_back(f.first);
  }

  std::vector<absl::string_view> flag_names_second_attempt;
  auto all_flags_2 = absl::GetAllFlags();
  for (auto f : all_flags_2) {
    flag_names_second_attempt.push_back(f.first);
  }

  EXPECT_THAT(flag_names_first_attempt,
              ::testing::UnorderedElementsAreArray(flag_names_second_attempt));
}

// --------------------------------------------------------------------

struct CustomUDT {
  CustomUDT() : a(1), b(1) {}
  CustomUDT(int a_, int b_) : a(a_), b(b_) {}

  friend bool operator==(const CustomUDT& f1, const CustomUDT& f2) {
    return f1.a == f2.a && f1.b == f2.b;
  }

  int a;
  int b;
};
bool AbslParseFlag(absl::string_view in, CustomUDT* f, std::string*) {
  std::vector<absl::string_view> parts =
      absl::StrSplit(in, ':', absl::SkipWhitespace());

  if (parts.size() != 2) return false;

  if (!absl::SimpleAtoi(parts[0], &f->a)) return false;

  if (!absl::SimpleAtoi(parts[1], &f->b)) return false;

  return true;
}
std::string AbslUnparseFlag(const CustomUDT& f) {
  return absl::StrCat(f.a, ":", f.b);
}

}  // namespace

// --------------------------------------------------------------------

ABSL_FLAG(bool, test_flag_01, true, "");
ABSL_FLAG(int, test_flag_02, 1234, "");
ABSL_FLAG(int16_t, test_flag_03, -34, "");
ABSL_FLAG(uint16_t, test_flag_04, 189, "");
ABSL_FLAG(int32_t, test_flag_05, 10765, "");
ABSL_FLAG(uint32_t, test_flag_06, 40000, "");
ABSL_FLAG(int64_t, test_flag_07, -1234567, "");
ABSL_FLAG(uint64_t, test_flag_08, 9876543, "");
ABSL_FLAG(double, test_flag_09, -9.876e-50, "");
ABSL_FLAG(float, test_flag_10, 1.234e12f, "");
ABSL_FLAG(std::string, test_flag_11, "", "");
ABSL_FLAG(absl::Duration, test_flag_12, absl::Minutes(10), "");
static int counter = 0;
ABSL_FLAG(int, test_flag_13, 200, "").OnUpdate([]() { counter++; });
ABSL_FLAG(CustomUDT, test_flag_14, {}, "");

namespace {

TEST_F(ReflectionTest, TestFlagSaverInScope) {
  {
    absl::FlagSaver s;
    counter = 0;
    absl::SetFlag(&FLAGS_test_flag_01, false);
    absl::SetFlag(&FLAGS_test_flag_02, -1021);
    absl::SetFlag(&FLAGS_test_flag_03, 6009);
    absl::SetFlag(&FLAGS_test_flag_04, 44);
    absl::SetFlag(&FLAGS_test_flag_05, +800);
    absl::SetFlag(&FLAGS_test_flag_06, -40978756);
    absl::SetFlag(&FLAGS_test_flag_07, 23405);
    absl::SetFlag(&FLAGS_test_flag_08, 975310);
    absl::SetFlag(&FLAGS_test_flag_09, 1.00001);
    absl::SetFlag(&FLAGS_test_flag_10, -3.54f);
    absl::SetFlag(&FLAGS_test_flag_11, "asdf");
    absl::SetFlag(&FLAGS_test_flag_12, absl::Hours(20));
    absl::SetFlag(&FLAGS_test_flag_13, 4);
    absl::SetFlag(&FLAGS_test_flag_14, CustomUDT{-1, -2});
  }

  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_01), true);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_02), 1234);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_03), -34);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_04), 189);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_05), 10765);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_06), 40000);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_07), -1234567);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 9876543);
  EXPECT_NEAR(absl::GetFlag(FLAGS_test_flag_09), -9.876e-50, 1e-55);
  EXPECT_NEAR(absl::GetFlag(FLAGS_test_flag_10), 1.234e12f, 1e5f);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_11), "");
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_12), absl::Minutes(10));
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_13), 200);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_14), CustomUDT{});
  EXPECT_EQ(counter, 2);
}

// --------------------------------------------------------------------

TEST_F(ReflectionTest, TestFlagSaverVsUpdateViaReflection) {
  {
    absl::FlagSaver s;
    counter = 0;
    std::string error;
    EXPECT_TRUE(
        absl::FindCommandLineFlag("test_flag_01")->ParseFrom("false", &error))
        << error;
    EXPECT_TRUE(
        absl::FindCommandLineFlag("test_flag_02")->ParseFrom("-4536", &error))
        << error;
    EXPECT_TRUE(
        absl::FindCommandLineFlag("test_flag_03")->ParseFrom("111", &error))
        << error;
    EXPECT_TRUE(
        absl::FindCommandLineFlag("test_flag_04")->ParseFrom("909", &error))
        << error;
    EXPECT_TRUE(
        absl::FindCommandLineFlag("test_flag_05")->ParseFrom("-2004", &error))
        << error;
    EXPECT_TRUE(
        absl::FindCommandLineFlag("test_flag_06")->ParseFrom("1000023", &error))
        << error;
    EXPECT_TRUE(
        absl::FindCommandLineFlag("test_flag_07")->ParseFrom("69305", &error))
        << error;
    EXPECT_TRUE(absl::FindCommandLineFlag("test_flag_08")
                    ->ParseFrom("1000000001", &error))
        << error;
    EXPECT_TRUE(
        absl::FindCommandLineFlag("test_flag_09")->ParseFrom("2.09021", &error))
        << error;
    EXPECT_TRUE(
        absl::FindCommandLineFlag("test_flag_10")->ParseFrom("-33.1", &error))
        << error;
    EXPECT_TRUE(
        absl::FindCommandLineFlag("test_flag_11")->ParseFrom("ADD_FOO", &error))
        << error;
    EXPECT_TRUE(absl::FindCommandLineFlag("test_flag_12")
                    ->ParseFrom("3h11m16s", &error))
        << error;
    EXPECT_TRUE(
        absl::FindCommandLineFlag("test_flag_13")->ParseFrom("0", &error))
        << error;
    EXPECT_TRUE(
        absl::FindCommandLineFlag("test_flag_14")->ParseFrom("10:1", &error))
        << error;
  }

  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_01), true);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_02), 1234);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_03), -34);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_04), 189);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_05), 10765);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_06), 40000);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_07), -1234567);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 9876543);
  EXPECT_NEAR(absl::GetFlag(FLAGS_test_flag_09), -9.876e-50, 1e-55);
  EXPECT_NEAR(absl::GetFlag(FLAGS_test_flag_10), 1.234e12f, 1e5f);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_11), "");
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_12), absl::Minutes(10));
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_13), 200);
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_14), CustomUDT{});
  EXPECT_EQ(counter, 2);
}

// --------------------------------------------------------------------

TEST_F(ReflectionTest, TestMultipleFlagSaversInEnclosedScopes) {
  {
    absl::FlagSaver s;
    absl::SetFlag(&FLAGS_test_flag_08, 10);
    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 10);
    {
      absl::FlagSaver s;
      absl::SetFlag(&FLAGS_test_flag_08, 20);
      EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 20);
      {
        absl::FlagSaver s;
        absl::SetFlag(&FLAGS_test_flag_08, -200);
        EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), -200);
      }
      EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 20);
    }
    EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 10);
  }
  EXPECT_EQ(absl::GetFlag(FLAGS_test_flag_08), 9876543);
}

}  // namespace
                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/usage.cc                                      0000664 0000000 0000000 00000004464 14746647661 0024055 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
// Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
#include "absl/flags/usage.h"

#include <stdlib.h>

#include <string>

#include "absl/base/attributes.h"
#include "absl/base/config.h"
#include "absl/base/const_init.h"
#include "absl/base/internal/raw_logging.h"
#include "absl/base/thread_annotations.h"
#include "absl/flags/internal/usage.h"
#include "absl/strings/string_view.h"
#include "absl/synchronization/mutex.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace flags_internal {
namespace {
ABSL_CONST_INIT absl::Mutex usage_message_guard(absl::kConstInit);
ABSL_CONST_INIT std::string* program_usage_message
    ABSL_GUARDED_BY(usage_message_guard) = nullptr;
}  // namespace
}  // namespace flags_internal

// --------------------------------------------------------------------
// Sets the "usage" message to be used by help reporting routines.
void SetProgramUsageMessage(absl::string_view new_usage_message) {
  absl::MutexLock l(&flags_internal::usage_message_guard);

  if (flags_internal::program_usage_message != nullptr) {
    ABSL_INTERNAL_LOG(FATAL, "SetProgramUsageMessage() called twice.");
    std::exit(1);
  }

  flags_internal::program_usage_message = new std::string(new_usage_message);
}

// --------------------------------------------------------------------
// Returns the usage message set by SetProgramUsageMessage().
// Note: We able to return string_view here only because calling
// SetProgramUsageMessage twice is prohibited.
absl::string_view ProgramUsageMessage() {
  absl::MutexLock l(&flags_internal::usage_message_guard);

  return flags_internal::program_usage_message != nullptr
             ? absl::string_view(*flags_internal::program_usage_message)
             : "Warning: SetProgramUsageMessage() never called";
}

ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                            node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/usage.h                                       0000664 0000000 0000000 00000002751 14746647661 0023714 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
//  Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef ABSL_FLAGS_USAGE_H_
#define ABSL_FLAGS_USAGE_H_

#include "absl/base/config.h"
#include "absl/strings/string_view.h"

// --------------------------------------------------------------------
// Usage reporting interfaces

namespace absl {
ABSL_NAMESPACE_BEGIN

// Sets the "usage" message to be used by help reporting routines.
// For example:
//  absl::SetProgramUsageMessage(
//      absl::StrCat("This program does nothing.  Sample usage:\n", argv[0],
//                   " <uselessarg1> <uselessarg2>"));
// Do not include commandline flags in the usage: we do that for you!
// Note: Calling SetProgramUsageMessage twice will trigger a call to std::exit.
void SetProgramUsageMessage(absl::string_view new_usage_message);

// Returns the usage message set by SetProgramUsageMessage().
absl::string_view ProgramUsageMessage();

ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_FLAGS_USAGE_H_
                       node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/usage_config.cc                               0000664 0000000 0000000 00000012536 14746647661 0025401 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
//  Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/flags/usage_config.h"

#include <functional>
#include <iostream>
#include <string>

#include "absl/base/attributes.h"
#include "absl/base/config.h"
#include "absl/base/const_init.h"
#include "absl/base/thread_annotations.h"
#include "absl/flags/internal/path_util.h"
#include "absl/flags/internal/program_name.h"
#include "absl/strings/match.h"
#include "absl/strings/string_view.h"
#include "absl/strings/strip.h"
#include "absl/synchronization/mutex.h"

extern "C" {

// Additional report of fatal usage error message before we std::exit. Error is
// fatal if is_fatal argument to ReportUsageError is true.
ABSL_ATTRIBUTE_WEAK void ABSL_INTERNAL_C_SYMBOL(
    AbslInternalReportFatalUsageError)(absl::string_view) {}

}  // extern "C"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace flags_internal {

namespace {

// --------------------------------------------------------------------
// Returns true if flags defined in the filename should be reported with
// -helpshort flag.

bool ContainsHelpshortFlags(absl::string_view filename) {
  // By default we only want flags in binary's main. We expect the main
  // routine to reside in <program>.cc or <program>-main.cc or
  // <program>_main.cc, where the <program> is the name of the binary
  // (without .exe on Windows).
  auto suffix = flags_internal::Basename(filename);
  auto program_name = flags_internal::ShortProgramInvocationName();
  absl::string_view program_name_ref = program_name;
#if defined(_WIN32)
  absl::ConsumeSuffix(&program_name_ref, ".exe");
#endif
  if (!absl::ConsumePrefix(&suffix, program_name_ref))
    return false;
  return absl::StartsWith(suffix, ".") || absl::StartsWith(suffix, "-main.") ||
         absl::StartsWith(suffix, "_main.");
}

// --------------------------------------------------------------------
// Returns true if flags defined in the filename should be reported with
// -helppackage flag.

bool ContainsHelppackageFlags(absl::string_view filename) {
  // TODO(rogeeff): implement properly when registry is available.
  return ContainsHelpshortFlags(filename);
}

// --------------------------------------------------------------------
// Generates program version information into supplied output.

std::string VersionString() {
  std::string version_str(flags_internal::ShortProgramInvocationName());

  version_str += "\n";

#if !defined(NDEBUG)
  version_str += "Debug build (NDEBUG not #defined)\n";
#endif

  return version_str;
}

// --------------------------------------------------------------------
// Normalizes the filename specific to the build system/filesystem used.

std::string NormalizeFilename(absl::string_view filename) {
  // Skip any leading slashes
  auto pos = filename.find_first_not_of("\\/");
  if (pos == absl::string_view::npos) return "";

  filename.remove_prefix(pos);
  return std::string(filename);
}

// --------------------------------------------------------------------

ABSL_CONST_INIT absl::Mutex custom_usage_config_guard(absl::kConstInit);
ABSL_CONST_INIT FlagsUsageConfig* custom_usage_config
    ABSL_GUARDED_BY(custom_usage_config_guard) = nullptr;

}  // namespace

FlagsUsageConfig GetUsageConfig() {
  absl::MutexLock l(&custom_usage_config_guard);

  if (custom_usage_config) return *custom_usage_config;

  FlagsUsageConfig default_config;
  default_config.contains_helpshort_flags = &ContainsHelpshortFlags;
  default_config.contains_help_flags = &ContainsHelppackageFlags;
  default_config.contains_helppackage_flags = &ContainsHelppackageFlags;
  default_config.version_string = &VersionString;
  default_config.normalize_filename = &NormalizeFilename;

  return default_config;
}

void ReportUsageError(absl::string_view msg, bool is_fatal) {
  std::cerr << "ERROR: " << msg << std::endl;

  if (is_fatal) {
    ABSL_INTERNAL_C_SYMBOL(AbslInternalReportFatalUsageError)(msg);
  }
}

}  // namespace flags_internal

void SetFlagsUsageConfig(FlagsUsageConfig usage_config) {
  absl::MutexLock l(&flags_internal::custom_usage_config_guard);

  if (!usage_config.contains_helpshort_flags)
    usage_config.contains_helpshort_flags =
        flags_internal::ContainsHelpshortFlags;

  if (!usage_config.contains_help_flags)
    usage_config.contains_help_flags = flags_internal::ContainsHelppackageFlags;

  if (!usage_config.contains_helppackage_flags)
    usage_config.contains_helppackage_flags =
        flags_internal::ContainsHelppackageFlags;

  if (!usage_config.version_string)
    usage_config.version_string = flags_internal::VersionString;

  if (!usage_config.normalize_filename)
    usage_config.normalize_filename = flags_internal::NormalizeFilename;

  if (flags_internal::custom_usage_config)
    *flags_internal::custom_usage_config = usage_config;
  else
    flags_internal::custom_usage_config = new FlagsUsageConfig(usage_config);
}

ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                  node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/usage_config.h                                0000664 0000000 0000000 00000012065 14746647661 0025240 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
//  Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// -----------------------------------------------------------------------------
// File: usage_config.h
// -----------------------------------------------------------------------------
//
// This file defines the main usage reporting configuration interfaces and
// documents Abseil's supported built-in usage flags. If these flags are found
// when parsing a command-line, Abseil will exit the program and display
// appropriate help messages.
#ifndef ABSL_FLAGS_USAGE_CONFIG_H_
#define ABSL_FLAGS_USAGE_CONFIG_H_

#include <functional>
#include <string>

#include "absl/base/config.h"
#include "absl/strings/string_view.h"

// -----------------------------------------------------------------------------
// Built-in Usage Flags
// -----------------------------------------------------------------------------
//
// Abseil supports the following built-in usage flags. When passed, these flags
// exit the program and :
//
// * --help
//     Shows help on important flags for this binary
// * --helpfull
//     Shows help on all flags
// * --helpshort
//     Shows help on only the main module for this program
// * --helppackage
//     Shows help on all modules in the main package
// * --version
//     Shows the version and build info for this binary and exits
// * --only_check_args
//     Exits after checking all flags
// * --helpon
//     Shows help on the modules named by this flag value
// * --helpmatch
//     Shows help on modules whose name contains the specified substring

namespace absl {
ABSL_NAMESPACE_BEGIN

namespace flags_internal {
using FlagKindFilter = std::function<bool (absl::string_view)>;
}  // namespace flags_internal

// FlagsUsageConfig
//
// This structure contains the collection of callbacks for changing the behavior
// of the usage reporting routines in Abseil Flags.
struct FlagsUsageConfig {
  // Returns true if flags defined in the given source code file should be
  // reported with --helpshort flag. For example, if the file
  // "path/to/my/code.cc" defines the flag "--my_flag", and
  // contains_helpshort_flags("path/to/my/code.cc") returns true, invoking the
  // program with --helpshort will include information about --my_flag in the
  // program output.
  flags_internal::FlagKindFilter contains_helpshort_flags;

  // Returns true if flags defined in the filename should be reported with
  // --help flag. For example, if the file
  // "path/to/my/code.cc" defines the flag "--my_flag", and
  // contains_help_flags("path/to/my/code.cc") returns true, invoking the
  // program with --help will include information about --my_flag in the
  // program output.
  flags_internal::FlagKindFilter contains_help_flags;

  // Returns true if flags defined in the filename should be reported with
  // --helppackage flag. For example, if the file
  // "path/to/my/code.cc" defines the flag "--my_flag", and
  // contains_helppackage_flags("path/to/my/code.cc") returns true, invoking the
  // program with --helppackage will include information about --my_flag in the
  // program output.
  flags_internal::FlagKindFilter contains_helppackage_flags;

  // Generates string containing program version. This is the string reported
  // when user specifies --version in a command line.
  std::function<std::string()> version_string;

  // Normalizes the filename specific to the build system/filesystem used. This
  // routine is used when we report the information about the flag definition
  // location. For instance, if your build resides at some location you do not
  // want to expose in the usage output, you can trim it to show only relevant
  // part.
  // For example:
  //   normalize_filename("/my_company/some_long_path/src/project/file.cc")
  // might produce
  //   "project/file.cc".
  std::function<std::string(absl::string_view)> normalize_filename;
};

// SetFlagsUsageConfig()
//
// Sets the usage reporting configuration callbacks. If any of the callbacks are
// not set in usage_config instance, then the default value of the callback is
// used.
void SetFlagsUsageConfig(FlagsUsageConfig usage_config);

namespace flags_internal {

FlagsUsageConfig GetUsageConfig();

void ReportUsageError(absl::string_view msg, bool is_fatal);

}  // namespace flags_internal
ABSL_NAMESPACE_END
}  // namespace absl

extern "C" {

// Additional report of fatal usage error message before we std::exit. Error is
// fatal if is_fatal argument to ReportUsageError is true.
void ABSL_INTERNAL_C_SYMBOL(AbslInternalReportFatalUsageError)(
    absl::string_view);

}  // extern "C"

#endif  // ABSL_FLAGS_USAGE_CONFIG_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/third_party/abseil-cpp/absl/flags/usage_config_test.cc                          0000664 0000000 0000000 00000017157 14746647661 0026444 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //
//  Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/flags/usage_config.h"

#include <string>

#include "gtest/gtest.h"
#include "absl/flags/internal/path_util.h"
#include "absl/flags/internal/program_name.h"
#include "absl/strings/match.h"
#include "absl/strings/string_view.h"

namespace {

class FlagsUsageConfigTest : public testing::Test {
 protected:
  void SetUp() override {
    // Install Default config for the use on this unit test.
    // Binary may install a custom config before tests are run.
    absl::FlagsUsageConfig default_config;
    absl::SetFlagsUsageConfig(default_config);
  }
};

namespace flags = absl::flags_internal;

bool TstContainsHelpshortFlags(absl::string_view f) {
  return absl::StartsWith(flags::Basename(f), "progname.");
}

bool TstContainsHelppackageFlags(absl::string_view f) {
  return absl::EndsWith(flags::Package(f), "aaa/");
}

bool TstContainsHelpFlags(absl::string_view f) {
  return absl::EndsWith(flags::Package(f), "zzz/");
}

std::string TstVersionString() { return "program 1.0.0"; }

std::string TstNormalizeFilename(absl::string_view filename) {
  return std::string(filename.substr(2));
}

void TstReportUsageMessage(absl::string_view msg) {}

// --------------------------------------------------------------------

TEST_F(FlagsUsageConfigTest, TestGetSetFlagsUsageConfig) {
  EXPECT_TRUE(flags::GetUsageConfig().contains_helpshort_flags);
  EXPECT_TRUE(flags::GetUsageConfig().contains_help_flags);
  EXPECT_TRUE(flags::GetUsageConfig().contains_helppackage_flags);
  EXPECT_TRUE(flags::GetUsageConfig().version_string);
  EXPECT_TRUE(flags::GetUsageConfig().normalize_filename);

  absl::FlagsUsageConfig empty_config;
  empty_config.contains_helpshort_flags = &TstContainsHelpshortFlags;
  empty_config.contains_help_flags = &TstContainsHelpFlags;
  empty_config.contains_helppackage_flags = &TstContainsHelppackageFlags;
  empty_config.version_string = &TstVersionString;
  empty_config.normalize_filename = &TstNormalizeFilename;
  absl::SetFlagsUsageConfig(empty_config);

  EXPECT_TRUE(flags::GetUsageConfig().contains_helpshort_flags);
  EXPECT_TRUE(flags::GetUsageConfig().contains_help_flags);
  EXPECT_TRUE(flags::GetUsageConfig().contains_helppackage_flags);
  EXPECT_TRUE(flags::GetUsageConfig().version_string);
  EXPECT_TRUE(flags::GetUsageConfig().normalize_filename);
}

// --------------------------------------------------------------------

TEST_F(FlagsUsageConfigTest, TestContainsHelpshortFlags) {
#if defined(_WIN32)
  flags::SetProgramInvocationName("usage_config_test.exe");
#else
  flags::SetProgramInvocationName("usage_config_test");
#endif

  auto config = flags::GetUsageConfig();
  EXPECT_TRUE(config.contains_helpshort_flags("adir/cd/usage_config_test.cc"));
  EXPECT_TRUE(
      config.contains_helpshort_flags("aaaa/usage_config_test-main.cc"));
  EXPECT_TRUE(config.contains_helpshort_flags("abc/usage_config_test_main.cc"));
  EXPECT_FALSE(config.contains_helpshort_flags("usage_config_main.cc"));

  absl::FlagsUsageConfig empty_config;
  empty_config.contains_helpshort_flags = &TstContainsHelpshortFlags;
  absl::SetFlagsUsageConfig(empty_config);

  EXPECT_TRUE(
      flags::GetUsageConfig().contains_helpshort_flags("aaa/progname.cpp"));
  EXPECT_FALSE(
      flags::GetUsageConfig().contains_helpshort_flags("aaa/progmane.cpp"));
}

// --------------------------------------------------------------------

TEST_F(FlagsUsageConfigTest, TestContainsHelpFlags) {
  flags::SetProgramInvocationName("usage_config_test");

  auto config = flags::GetUsageConfig();
  EXPECT_TRUE(config.contains_help_flags("zzz/usage_config_test.cc"));
  EXPECT_TRUE(
      config.contains_help_flags("bdir/a/zzz/usage_config_test-main.cc"));
  EXPECT_TRUE(
      config.contains_help_flags("//aqse/zzz/usage_config_test_main.cc"));
  EXPECT_FALSE(config.contains_help_flags("zzz/aa/usage_config_main.cc"));

  absl::FlagsUsageConfig empty_config;
  empty_config.contains_help_flags = &TstContainsHelpFlags;
  absl::SetFlagsUsageConfig(empty_config);

  EXPECT_TRUE(flags::GetUsageConfig().contains_help_flags("zzz/main-body.c"));
  EXPECT_FALSE(
      flags::GetUsageConfig().contains_help_flags("zzz/dir/main-body.c"));
}

// --------------------------------------------------------------------

TEST_F(FlagsUsageConfigTest, TestContainsHelppackageFlags) {
  flags::SetProgramInvocationName("usage_config_test");

  auto config = flags::GetUsageConfig();
  EXPECT_TRUE(config.contains_helppackage_flags("aaa/usage_config_test.cc"));
  EXPECT_TRUE(
      config.contains_helppackage_flags("bbdir/aaa/usage_config_test-main.cc"));
  EXPECT_TRUE(config.contains_helppackage_flags(
      "//aqswde/aaa/usage_config_test_main.cc"));
  EXPECT_FALSE(config.contains_helppackage_flags("aadir/usage_config_main.cc"));

  absl::FlagsUsageConfig empty_config;
  empty_config.contains_helppackage_flags = &TstContainsHelppackageFlags;
  absl::SetFlagsUsageConfig(empty_config);

  EXPECT_TRUE(
      flags::GetUsageConfig().contains_helppackage_flags("aaa/main-body.c"));
  EXPECT_FALSE(
      flags::GetUsageConfig().contains_helppackage_flags("aadir/main-body.c"));
}

// --------------------------------------------------------------------

TEST_F(FlagsUsageConfigTest, TestVersionString) {
  flags::SetProgramInvocationName("usage_config_test");

#ifdef NDEBUG
  std::string expected_output = "usage_config_test\n";
#else
  std::string expected_output =
      "usage_config_test\nDebug build (NDEBUG not #defined)\n";
#endif

  EXPECT_EQ(flags::GetUsageConfig().version_string(), expected_output);

  absl::FlagsUsageConfig empty_config;
  empty_config.version_string = &TstVersionString;
  absl::SetFlagsUsageConfig(empty_config);

  EXPECT_EQ(flags::GetUsageConfig().version_string(), "program 1.0.0");
}

// --------------------------------------------------------------------

TEST_F(FlagsUsageConfigTest, TestNormalizeFilename) {
  // This tests the default implementation.
  EXPECT_EQ(flags::GetUsageConfig().normalize_filename("a/a.cc"), "a/a.cc");
  EXPECT_EQ(flags::GetUsageConfig().normalize_filename("/a/a.cc"), "a/a.cc");
  EXPECT_EQ(flags::GetUsageConfig().normalize_filename("///a/a.cc"), "a/a.cc");
  EXPECT_EQ(flags::GetUsageConfig().normalize_filename("/"), "");

  // This tests that the custom implementation is called.
  absl::FlagsUsageConfig empty_config;
  empty_config.normalize_filename = &TstNormalizeFilename;
  absl::SetFlagsUsageConfig(empty_config);

  EXPECT_EQ(flags::GetUsageConfig().normalize_filename("a/a.cc"), "a.cc");
  EXPECT_EQ(flags::GetUsageConfig().normalize_filename("aaa/a.cc"), "a/a.cc");

  // This tests that the default implementation is called.
  empty_config.normalize_filename = nullptr;
  absl::SetFlagsUsageConfig(empty_config);

  EXPECT_EQ(flags::GetUsageConfig().normalize_filename("a/a.cc"), "a/a.cc");
  EXPECT_EQ(flags::GetUsageConfig().normalize_filename("/a/a.cc"), "a/a.cc");
  EXPECT_EQ(flags::GetUsageConfig().normalize_filename("///a/a.cc"), "a/a.cc");
  EXPECT_EQ(flags::GetUsageConfig().normalize_filename("\\a\\a.cc"), "a\\a.cc");
  EXPECT_EQ(flags::GetUsageConfig().normalize_filename("//"), "");
  EXPECT_EQ(flags::GetUsageConfig().normalize_filename("\\\\"), "");
}

}  // namespace
                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/functional/                                         0000775 0000000 0000000 00000000000 14746647661 0023500 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/third_party/abseil-cpp/absl/functional/BUILD.bazel                              0000664 0000000 0000000 00000010036 14746647661 0025356 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #
# Copyright 2019 The Abseil Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

load(
    "//absl:copts/configure_copts.bzl",
    "ABSL_DEFAULT_COPTS",
    "ABSL_DEFAULT_LINKOPTS",
    "ABSL_TEST_COPTS",
)

package(
    default_visibility = ["//visibility:public"],
    features = [
        "header_modules",
        "layering_check",
        "parse_headers",
    ],
)

licenses(["notice"])

cc_library(
    name = "any_invocable",
    srcs = ["internal/any_invocable.h"],
    hdrs = ["any_invocable.h"],
    copts = ABSL_DEFAULT_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    deps = [
        "//absl/base:base_internal",
        "//absl/base:config",
        "//absl/base:core_headers",
        "//absl/meta:type_traits",
        "//absl/utility",
    ],
)

cc_test(
    name = "any_invocable_test",
    srcs = [
        "any_invocable_test.cc",
        "internal/any_invocable.h",
    ],
    copts = ABSL_TEST_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    deps = [
        ":any_invocable",
        "//absl/base:base_internal",
        "//absl/base:config",
        "//absl/base:core_headers",
        "//absl/meta:type_traits",
        "//absl/utility",
        "@com_google_googletest//:gtest",
        "@com_google_googletest//:gtest_main",
    ],
)

cc_library(
    name = "bind_front",
    srcs = ["internal/front_binder.h"],
    hdrs = ["bind_front.h"],
    copts = ABSL_DEFAULT_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    deps = [
        "//absl/base:base_internal",
        "//absl/container:compressed_tuple",
        "//absl/meta:type_traits",
        "//absl/utility",
    ],
)

cc_test(
    name = "bind_front_test",
    srcs = ["bind_front_test.cc"],
    copts = ABSL_TEST_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    deps = [
        ":bind_front",
        "//absl/memory",
        "@com_google_googletest//:gtest",
        "@com_google_googletest//:gtest_main",
    ],
)

cc_library(
    name = "function_ref",
    srcs = ["internal/function_ref.h"],
    hdrs = ["function_ref.h"],
    copts = ABSL_DEFAULT_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    deps = [
        ":any_invocable",
        "//absl/base:base_internal",
        "//absl/base:core_headers",
        "//absl/meta:type_traits",
    ],
)

cc_test(
    name = "function_ref_test",
    size = "small",
    srcs = ["function_ref_test.cc"],
    copts = ABSL_TEST_COPTS,
    deps = [
        ":any_invocable",
        ":function_ref",
        "//absl/container:test_instance_tracker",
        "//absl/memory",
        "@com_google_googletest//:gtest",
        "@com_google_googletest//:gtest_main",
    ],
)

cc_library(
    name = "overload",
    hdrs = ["overload.h"],
    copts = ABSL_DEFAULT_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    deps = [
        "//absl/base:config",
        "//absl/meta:type_traits",
    ],
)

cc_test(
    name = "overload_test",
    size = "small",
    srcs = ["overload_test.cc"],
    copts = ABSL_TEST_COPTS,
    deps = [
        ":overload",
        "//absl/base:config",
        "//absl/strings",
        "//absl/strings:string_view",
        "//absl/types:variant",
        "@com_google_googletest//:gtest",
        "@com_google_googletest//:gtest_main",
    ],
)

cc_test(
    name = "function_type_benchmark",
    srcs = [
        "function_type_benchmark.cc",
    ],
    copts = ABSL_TEST_COPTS,
    tags = ["benchmark"],
    visibility = ["//visibility:private"],
    deps = [
        ":any_invocable",
        ":function_ref",
        "//absl/base:core_headers",
        "@com_github_google_benchmark//:benchmark_main",
        "@com_google_googletest//:gtest",
    ],
)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/third_party/abseil-cpp/absl/functional/BUILD.gn                                 0000664 0000000 0000000 00000004475 14746647661 0024677 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2020 The Chromium Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//third_party/abseil-cpp/absl.gni")

absl_source_set("any_invocable") {
  sources = [ "internal/any_invocable.h" ]
  public = [ "any_invocable.h" ]
  deps = [
    "//third_party/abseil-cpp/absl/base:base_internal",
    "//third_party/abseil-cpp/absl/base:config",
    "//third_party/abseil-cpp/absl/base:core_headers",
    "//third_party/abseil-cpp/absl/meta:type_traits",
    "//third_party/abseil-cpp/absl/utility",
  ]
}

absl_test("any_invocable_test") {
  sources = [
    "any_invocable_test.cc",
    "internal/any_invocable.h",
  ]
  deps = [
    ":any_invocable",
    "//third_party/abseil-cpp/absl/base:base_internal",
    "//third_party/abseil-cpp/absl/base:config",
    "//third_party/abseil-cpp/absl/base:core_headers",
    "//third_party/abseil-cpp/absl/meta:type_traits",
    "//third_party/abseil-cpp/absl/utility",
  ]
}

absl_source_set("bind_front") {
  sources = [ "internal/front_binder.h" ]
  public = [ "bind_front.h" ]
  deps = [
    "//third_party/abseil-cpp/absl/base:base_internal",
    "//third_party/abseil-cpp/absl/container:compressed_tuple",
    "//third_party/abseil-cpp/absl/meta:type_traits",
    "//third_party/abseil-cpp/absl/utility",
  ]
}

absl_source_set("function_ref") {
  sources = [ "internal/function_ref.h" ]
  public = [ "function_ref.h" ]
  deps = [
    ":any_invocable",
    "//third_party/abseil-cpp/absl/base:base_internal",
    "//third_party/abseil-cpp/absl/base:core_headers",
    "//third_party/abseil-cpp/absl/meta:type_traits",
  ]
}

absl_test("function_ref_test") {
  sources = [ "function_ref_test.cc" ]
  deps = [
    ":any_invocable",
    ":function_ref",
    "//third_party/abseil-cpp/absl/container:test_instance_tracker",
    "//third_party/abseil-cpp/absl/memory",
  ]
}

absl_source_set("overload") {
  public = [ "overload.h" ]
  deps = [
    "//third_party/abseil-cpp/absl/base:config",
    "//third_party/abseil-cpp/absl/meta:type_traits",
  ]
}

absl_test("overload_test") {
  sources = [ "overload_test.cc" ]
  deps = [
    ":overload",
    "//third_party/abseil-cpp/absl/base:config",
    "//third_party/abseil-cpp/absl/strings",
    "//third_party/abseil-cpp/absl/strings:string_view",
    "//third_party/abseil-cpp/absl/types:variant",
  ]
}
                                                                                                                                                                                                   node-23.7.0/deps/v8/third_party/abseil-cpp/absl/functional/CMakeLists.txt                           0000664 0000000 0000000 00000004457 14746647661 0026252 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #
# Copyright 2019 The Abseil Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

absl_cc_library(
  NAME
    any_invocable
  SRCS
    "internal/any_invocable.h"
  HDRS
    "any_invocable.h"
  COPTS
    ${ABSL_DEFAULT_COPTS}
  DEPS
    absl::base_internal
    absl::config
    absl::core_headers
    absl::type_traits
    absl::utility
  PUBLIC
)

absl_cc_test(
  NAME
    any_invocable_test
  SRCS
    "any_invocable_test.cc"
    "internal/any_invocable.h"
  COPTS
    ${ABSL_TEST_COPTS}
  DEPS
    absl::any_invocable
    absl::base_internal
    absl::config
    absl::core_headers
    absl::type_traits
    absl::utility
    GTest::gmock_main
)

absl_cc_library(
  NAME
    bind_front
  SRCS
    "internal/front_binder.h"
  HDRS
    "bind_front.h"
  COPTS
    ${ABSL_DEFAULT_COPTS}
  DEPS
    absl::base_internal
    absl::compressed_tuple
  PUBLIC
)

absl_cc_test(
  NAME
    bind_front_test
  SRCS
    "bind_front_test.cc"
  COPTS
    ${ABSL_DEFAULT_COPTS}
  DEPS
    absl::bind_front
    absl::memory
    GTest::gmock_main
)

absl_cc_library(
  NAME
    function_ref
  SRCS
    "internal/function_ref.h"
  HDRS
    "function_ref.h"
  COPTS
    ${ABSL_DEFAULT_COPTS}
  DEPS
    absl::base_internal
    absl::core_headers
    absl::any_invocable
    absl::meta
  PUBLIC
)

absl_cc_test(
  NAME
    function_ref_test
  SRCS
    "function_ref_test.cc"
  COPTS
    ${ABSL_TEST_COPTS}
  DEPS
    absl::function_ref
    absl::memory
    absl::test_instance_tracker
    GTest::gmock_main
)

absl_cc_library(
  NAME
    overload
  HDRS
    "overload.h"
  COPTS
    ${ABSL_DEFAULT_COPTS}
  DEPS
    absl::meta
  PUBLIC
)

absl_cc_test(
  NAME
    overload_test
  SRCS
    "overload_test.cc"
  COPTS
    ${ABSL_TEST_COPTS}
  DEPS
    absl::config
    absl::overload
    absl::string_view
    absl::strings
    absl::variant
    GTest::gmock_main
)
                                                                                                                                                                                                                 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/functional/any_invocable.h                          0000664 0000000 0000000 00000031157 14746647661 0026471 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// -----------------------------------------------------------------------------
// File: any_invocable.h
// -----------------------------------------------------------------------------
//
// This header file defines an `absl::AnyInvocable` type that assumes ownership
// and wraps an object of an invocable type. (Invocable types adhere to the
// concept specified in https://en.cppreference.com/w/cpp/concepts/invocable.)
//
// In general, prefer `absl::AnyInvocable` when you need a type-erased
// function parameter that needs to take ownership of the type.
//
// NOTE: `absl::AnyInvocable` is similar to the C++23 `std::move_only_function`
// abstraction, but has a slightly different API and is not designed to be a
// drop-in replacement or C++11-compatible backfill of that type.
//
// Credits to Matt Calabrese (https://github.com/mattcalabrese) for the original
// implementation.

#ifndef ABSL_FUNCTIONAL_ANY_INVOCABLE_H_
#define ABSL_FUNCTIONAL_ANY_INVOCABLE_H_

#include <cstddef>
#include <functional>
#include <initializer_list>
#include <type_traits>
#include <utility>

#include "absl/base/config.h"
#include "absl/functional/internal/any_invocable.h"
#include "absl/meta/type_traits.h"
#include "absl/utility/utility.h"

namespace absl {
ABSL_NAMESPACE_BEGIN

// absl::AnyInvocable
//
// `absl::AnyInvocable` is a functional wrapper type, like `std::function`, that
// assumes ownership of an invocable object. Unlike `std::function`, an
// `absl::AnyInvocable` is more type-safe and provides the following additional
// benefits:
//
// * Properly adheres to const correctness of the underlying type
// * Is move-only so avoids concurrency problems with copied invocables and
//   unnecessary copies in general.
// * Supports reference qualifiers allowing it to perform unique actions (noted
//   below).
//
// `absl::AnyInvocable` is a template, and an `absl::AnyInvocable` instantiation
// may wrap any invocable object with a compatible function signature, e.g.
// having arguments and return types convertible to types matching the
// `absl::AnyInvocable` signature, and also matching any stated reference
// qualifiers, as long as that type is moveable. It therefore provides broad
// type erasure for functional objects.
//
// An `absl::AnyInvocable` is typically used as a type-erased function parameter
// for accepting various functional objects:
//
// // Define a function taking an AnyInvocable parameter.
// void my_func(absl::AnyInvocable<int()> f) {
//   ...
// };
//
// // That function can accept any invocable type:
//
// // Accept a function reference. We don't need to move a reference.
// int func1() { return 0; };
// my_func(func1);
//
// // Accept a lambda. We use std::move here because otherwise my_func would
// // copy the lambda.
// auto lambda = []() { return 0; };
// my_func(std::move(lambda));
//
// // Accept a function pointer. We don't need to move a function pointer.
// func2 = &func1;
// my_func(func2);
//
// // Accept an std::function by moving it. Note that the lambda is copyable
// // (satisfying std::function requirements) and moveable (satisfying
// // absl::AnyInvocable requirements).
// std::function<int()> func6 = []() { return 0; };
// my_func(std::move(func6));
//
// `AnyInvocable` also properly respects `const` qualifiers, reference
// qualifiers, and the `noexcept` specification (only in C++ 17 and beyond) as
// part of the user-specified function type (e.g.
// `AnyInvocable<void() const && noexcept>`). These qualifiers will be applied
// to the `AnyInvocable` object's `operator()`, and the underlying invocable
// must be compatible with those qualifiers.
//
// Comparison of const and non-const function types:
//
//   // Store a closure inside of `func` with the function type `int()`.
//   // Note that we have made `func` itself `const`.
//   const AnyInvocable<int()> func = [](){ return 0; };
//
//   func();  // Compile-error: the passed type `int()` isn't `const`.
//
//   // Store a closure inside of `const_func` with the function type
//   // `int() const`.
//   // Note that we have also made `const_func` itself `const`.
//   const AnyInvocable<int() const> const_func = [](){ return 0; };
//
//   const_func();  // Fine: `int() const` is `const`.
//
// In the above example, the call `func()` would have compiled if
// `std::function` were used even though the types are not const compatible.
// This is a bug, and using `absl::AnyInvocable` properly detects that bug.
//
// In addition to affecting the signature of `operator()`, the `const` and
// reference qualifiers of the function type also appropriately constrain which
// kinds of invocable objects you are allowed to place into the `AnyInvocable`
// instance. If you specify a function type that is const-qualified, then
// anything that you attempt to put into the `AnyInvocable` must be callable on
// a `const` instance of that type.
//
// Constraint example:
//
//   // Fine because the lambda is callable when `const`.
//   AnyInvocable<int() const> func = [=](){ return 0; };
//
//   // This is a compile-error because the lambda isn't callable when `const`.
//   AnyInvocable<int() const> error = [=]() mutable { return 0; };
//
// An `&&` qualifier can be used to express that an `absl::AnyInvocable`
// instance should be invoked at most once:
//
//   // Invokes `continuation` with the logical result of an operation when
//   // that operation completes (common in asynchronous code).
//   void CallOnCompletion(AnyInvocable<void(int)&&> continuation) {
//     int result_of_foo = foo();
//
//     // `std::move` is required because the `operator()` of `continuation` is
//     // rvalue-reference qualified.
//     std::move(continuation)(result_of_foo);
//   }
//
// Attempting to call `absl::AnyInvocable` multiple times in such a case
// results in undefined behavior.
//
// Invoking an empty `absl::AnyInvocable` results in undefined behavior:
//
//   // Create an empty instance using the default constructor.
//   AnyInvocable<void()> empty;
//   empty();  // WARNING: Undefined behavior!
template <class Sig>
class AnyInvocable : private internal_any_invocable::Impl<Sig> {
 private:
  static_assert(
      std::is_function<Sig>::value,
      "The template argument of AnyInvocable must be a function type.");

  using Impl = internal_any_invocable::Impl<Sig>;

 public:
  // The return type of Sig
  using result_type = typename Impl::result_type;

  // Constructors

  // Constructs the `AnyInvocable` in an empty state.
  // Invoking it results in undefined behavior.
  AnyInvocable() noexcept = default;
  AnyInvocable(std::nullptr_t) noexcept {}  // NOLINT

  // Constructs the `AnyInvocable` from an existing `AnyInvocable` by a move.
  // Note that `f` is not guaranteed to be empty after move-construction,
  // although it may be.
  AnyInvocable(AnyInvocable&& /*f*/) noexcept = default;

  // Constructs an `AnyInvocable` from an invocable object.
  //
  // Upon construction, `*this` is only empty if `f` is a function pointer or
  // member pointer type and is null, or if `f` is an `AnyInvocable` that is
  // empty.
  template <class F, typename = absl::enable_if_t<
                         internal_any_invocable::CanConvert<Sig, F>::value>>
  AnyInvocable(F&& f)  // NOLINT
      : Impl(internal_any_invocable::ConversionConstruct(),
             std::forward<F>(f)) {}

  // Constructs an `AnyInvocable` that holds an invocable object of type `T`,
  // which is constructed in-place from the given arguments.
  //
  // Example:
  //
  //   AnyInvocable<int(int)> func(
  //       absl::in_place_type<PossiblyImmovableType>, arg1, arg2);
  //
  template <class T, class... Args,
            typename = absl::enable_if_t<
                internal_any_invocable::CanEmplace<Sig, T, Args...>::value>>
  explicit AnyInvocable(absl::in_place_type_t<T>, Args&&... args)
      : Impl(absl::in_place_type<absl::decay_t<T>>,
             std::forward<Args>(args)...) {
    static_assert(std::is_same<T, absl::decay_t<T>>::value,
                  "The explicit template argument of in_place_type is required "
                  "to be an unqualified object type.");
  }

  // Overload of the above constructor to support list-initialization.
  template <class T, class U, class... Args,
            typename = absl::enable_if_t<internal_any_invocable::CanEmplace<
                Sig, T, std::initializer_list<U>&, Args...>::value>>
  explicit AnyInvocable(absl::in_place_type_t<T>,
                        std::initializer_list<U> ilist, Args&&... args)
      : Impl(absl::in_place_type<absl::decay_t<T>>, ilist,
             std::forward<Args>(args)...) {
    static_assert(std::is_same<T, absl::decay_t<T>>::value,
                  "The explicit template argument of in_place_type is required "
                  "to be an unqualified object type.");
  }

  // Assignment Operators

  // Assigns an `AnyInvocable` through move-assignment.
  // Note that `f` is not guaranteed to be empty after move-assignment
  // although it may be.
  AnyInvocable& operator=(AnyInvocable&& /*f*/) noexcept = default;

  // Assigns an `AnyInvocable` from a nullptr, clearing the `AnyInvocable`. If
  // not empty, destroys the target, putting `*this` into an empty state.
  AnyInvocable& operator=(std::nullptr_t) noexcept {
    this->Clear();
    return *this;
  }

  // Assigns an `AnyInvocable` from an existing `AnyInvocable` instance.
  //
  // Upon assignment, `*this` is only empty if `f` is a function pointer or
  // member pointer type and is null, or if `f` is an `AnyInvocable` that is
  // empty.
  template <class F, typename = absl::enable_if_t<
                         internal_any_invocable::CanAssign<Sig, F>::value>>
  AnyInvocable& operator=(F&& f) {
    *this = AnyInvocable(std::forward<F>(f));
    return *this;
  }

  // Assigns an `AnyInvocable` from a reference to an invocable object.
  // Upon assignment, stores a reference to the invocable object in the
  // `AnyInvocable` instance.
  template <
      class F,
      typename = absl::enable_if_t<
          internal_any_invocable::CanAssignReferenceWrapper<Sig, F>::value>>
  AnyInvocable& operator=(std::reference_wrapper<F> f) noexcept {
    *this = AnyInvocable(f);
    return *this;
  }

  // Destructor

  // If not empty, destroys the target.
  ~AnyInvocable() = default;

  // absl::AnyInvocable::swap()
  //
  // Exchanges the targets of `*this` and `other`.
  void swap(AnyInvocable& other) noexcept { std::swap(*this, other); }

  // absl::AnyInvocable::operator bool()
  //
  // Returns `true` if `*this` is not empty.
  //
  // WARNING: An `AnyInvocable` that wraps an empty `std::function` is not
  // itself empty. This behavior is consistent with the standard equivalent
  // `std::move_only_function`.
  //
  // In other words:
  //   std::function<void()> f;  // empty
  //   absl::AnyInvocable<void()> a = std::move(f);  // not empty
  //
  // Invoking an empty `AnyInvocable` results in undefined behavior.
  explicit operator bool() const noexcept { return this->HasValue(); }

  // Invokes the target object of `*this`. `*this` must not be empty.
  //
  // Note: The signature of this function call operator is the same as the
  //       template parameter `Sig`.
  using Impl::operator();

  // Equality operators

  // Returns `true` if `*this` is empty.
  friend bool operator==(const AnyInvocable& f, std::nullptr_t) noexcept {
    return !f.HasValue();
  }

  // Returns `true` if `*this` is empty.
  friend bool operator==(std::nullptr_t, const AnyInvocable& f) noexcept {
    return !f.HasValue();
  }

  // Returns `false` if `*this` is empty.
  friend bool operator!=(const AnyInvocable& f, std::nullptr_t) noexcept {
    return f.HasValue();
  }

  // Returns `false` if `*this` is empty.
  friend bool operator!=(std::nullptr_t, const AnyInvocable& f) noexcept {
    return f.HasValue();
  }

  // swap()
  //
  // Exchanges the targets of `f1` and `f2`.
  friend void swap(AnyInvocable& f1, AnyInvocable& f2) noexcept { f1.swap(f2); }

 private:
  // Friending other instantiations is necessary for conversions.
  template <bool /*SigIsNoexcept*/, class /*ReturnType*/, class... /*P*/>
  friend class internal_any_invocable::CoreImpl;
};

ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_FUNCTIONAL_ANY_INVOCABLE_H_
                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/functional/any_invocable_test.cc                    0000664 0000000 0000000 00000170541 14746647661 0027667 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/functional/any_invocable.h"

#include <cstddef>
#include <initializer_list>
#include <memory>
#include <numeric>
#include <type_traits>

#include "gtest/gtest.h"
#include "absl/base/config.h"
#include "absl/meta/type_traits.h"
#include "absl/utility/utility.h"

static_assert(absl::internal_any_invocable::kStorageSize >= sizeof(void*),
              "These tests assume that the small object storage is at least "
              "the size of a pointer.");

namespace {

// Helper macro used to avoid spelling `noexcept` in language versions older
// than C++17, where it is not part of the type system, in order to avoid
// compilation failures and internal compiler errors.
#if ABSL_INTERNAL_CPLUSPLUS_LANG >= 201703L
#define ABSL_INTERNAL_NOEXCEPT_SPEC(noex) noexcept(noex)
#else
#define ABSL_INTERNAL_NOEXCEPT_SPEC(noex)
#endif

// A dummy type we use when passing qualifiers to metafunctions
struct _ {};

template <class T>
struct Wrapper {
  template <class U,
            class = absl::enable_if_t<std::is_convertible<U, T>::value>>
  Wrapper(U&&);  // NOLINT
};

// This will cause a recursive trait instantiation if the SFINAE checks are
// not ordered correctly for constructibility.
static_assert(std::is_constructible<Wrapper<absl::AnyInvocable<void()>>,
                                    Wrapper<absl::AnyInvocable<void()>>>::value,
              "");

// A metafunction that takes the cv and l-value reference qualifiers that were
// associated with a function type (here passed via qualifiers of an object
// type), and .
template <class Qualifiers, class This>
struct QualifiersForThisImpl {
  static_assert(std::is_object<This>::value, "");
  using type =
      absl::conditional_t<std::is_const<Qualifiers>::value, const This, This>&;
};

template <class Qualifiers, class This>
struct QualifiersForThisImpl<Qualifiers&, This>
    : QualifiersForThisImpl<Qualifiers, This> {};

template <class Qualifiers, class This>
struct QualifiersForThisImpl<Qualifiers&&, This> {
  static_assert(std::is_object<This>::value, "");
  using type =
      absl::conditional_t<std::is_const<Qualifiers>::value, const This, This>&&;
};

template <class Qualifiers, class This>
using QualifiersForThis =
    typename QualifiersForThisImpl<Qualifiers, This>::type;

// A metafunction that takes the cv and l-value reference qualifier of T and
// applies them to U's function type qualifiers.
template <class T, class Fun>
struct GiveQualifiersToFunImpl;

template <class T, class R, class... P>
struct GiveQualifiersToFunImpl<T, R(P...)> {
  using type =
      absl::conditional_t<std::is_const<T>::value, R(P...) const, R(P...)>;
};

template <class T, class R, class... P>
struct GiveQualifiersToFunImpl<T&, R(P...)> {
  using type =
      absl::conditional_t<std::is_const<T>::value, R(P...) const&, R(P...)&>;
};

template <class T, class R, class... P>
struct GiveQualifiersToFunImpl<T&&, R(P...)> {
  using type =
      absl::conditional_t<std::is_const<T>::value, R(P...) const&&, R(P...) &&>;
};

// If noexcept is a part of the type system, then provide the noexcept forms.
#if defined(__cpp_noexcept_function_type)

template <class T, class R, class... P>
struct GiveQualifiersToFunImpl<T, R(P...) noexcept> {
  using type = absl::conditional_t<std::is_const<T>::value,
                                   R(P...) const noexcept, R(P...) noexcept>;
};

template <class T, class R, class... P>
struct GiveQualifiersToFunImpl<T&, R(P...) noexcept> {
  using type =
      absl::conditional_t<std::is_const<T>::value, R(P...) const & noexcept,
                          R(P...) & noexcept>;
};

template <class T, class R, class... P>
struct GiveQualifiersToFunImpl<T&&, R(P...) noexcept> {
  using type =
      absl::conditional_t<std::is_const<T>::value, R(P...) const && noexcept,
                          R(P...) && noexcept>;
};

#endif  // defined(__cpp_noexcept_function_type)

template <class T, class Fun>
using GiveQualifiersToFun = typename GiveQualifiersToFunImpl<T, Fun>::type;

// This is used in template parameters to decide whether or not to use a type
// that fits in the small object optimization storage.
enum class ObjSize { small, large };

// A base type that is used with classes as a means to insert an
// appropriately-sized dummy datamember when Size is ObjSize::large so that the
// user's class type is guaranteed to not fit in small object storage.
template <ObjSize Size>
struct TypeErasedPadding;

template <>
struct TypeErasedPadding<ObjSize::small> {};

template <>
struct TypeErasedPadding<ObjSize::large> {
  char dummy_data[absl::internal_any_invocable::kStorageSize + 1] = {};
};

struct Int {
  Int(int v) noexcept : value(v) {}  // NOLINT
#ifndef _MSC_VER
  Int(Int&&) noexcept {
    // NOTE: Prior to C++17, this not being called requires optimizations to
    //       take place when performing the top-level invocation. In practice,
    //       most supported compilers perform this optimization prior to C++17.
    std::abort();
  }
#else
  Int(Int&& v) noexcept = default;
#endif
  operator int() && noexcept { return value; }  // NOLINT

  int MemberFunctionAdd(int const& b, int c) noexcept {  // NOLINT
    return value + b + c;
  }

  int value;
};

enum class Movable { no, yes, nothrow, trivial };

enum class NothrowCall { no, yes };

enum class Destructible { nothrow, trivial };

enum class ObjAlign : std::size_t {
  normal = absl::internal_any_invocable::kAlignment,
  large = absl::internal_any_invocable::kAlignment * 2,
};

// A function-object template that has knobs for each property that can affect
// how the object is stored in AnyInvocable.
template <Movable Movability, Destructible Destructibility, class Qual,
          NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>
struct add;

#define ABSL_INTERNALS_ADD(qual)                                              \
  template <NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>  \
  struct alignas(static_cast<std::size_t>(Alignment))                         \
      add<Movable::trivial, Destructible::trivial, _ qual, CallExceptionSpec, \
          Size, Alignment> : TypeErasedPadding<Size> {                        \
    explicit add(int state_init) : state(state_init) {}                       \
    explicit add(std::initializer_list<int> state_init, int tail)             \
        : state(std::accumulate(std::begin(state_init), std::end(state_init), \
                                0) +                                          \
                tail) {}                                                      \
    add(add&& other) = default; /*NOLINT*/                                    \
    Int operator()(int a, int b, int c) qual                                  \
        ABSL_INTERNAL_NOEXCEPT_SPEC(CallExceptionSpec == NothrowCall::yes) {  \
      return state + a + b + c;                                               \
    }                                                                         \
    int state;                                                                \
  };                                                                          \
                                                                              \
  template <NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>  \
  struct alignas(static_cast<std::size_t>(Alignment))                         \
      add<Movable::trivial, Destructible::nothrow, _ qual, CallExceptionSpec, \
          Size, Alignment> : TypeErasedPadding<Size> {                        \
    explicit add(int state_init) : state(state_init) {}                       \
    explicit add(std::initializer_list<int> state_init, int tail)             \
        : state(std::accumulate(std::begin(state_init), std::end(state_init), \
                                0) +                                          \
                tail) {}                                                      \
    ~add() noexcept {}                                                        \
    add(add&& other) = default; /*NOLINT*/                                    \
    Int operator()(int a, int b, int c) qual                                  \
        ABSL_INTERNAL_NOEXCEPT_SPEC(CallExceptionSpec == NothrowCall::yes) {  \
      return state + a + b + c;                                               \
    }                                                                         \
    int state;                                                                \
  }

// Explicitly specify an empty argument.
// MSVC (at least up to _MSC_VER 1931, if not beyond) warns that
// ABSL_INTERNALS_ADD() is an undefined zero-arg overload.
#define ABSL_INTERNALS_NOARG
ABSL_INTERNALS_ADD(ABSL_INTERNALS_NOARG);
#undef ABSL_INTERNALS_NOARG

ABSL_INTERNALS_ADD(const);
ABSL_INTERNALS_ADD(&);
ABSL_INTERNALS_ADD(const&);
ABSL_INTERNALS_ADD(&&);       // NOLINT
ABSL_INTERNALS_ADD(const&&);  // NOLINT

#undef ABSL_INTERNALS_ADD

template <Destructible Destructibility, class Qual,
          NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>
struct add<Movable::no, Destructibility, Qual, CallExceptionSpec, Size,
           Alignment> : private add<Movable::trivial, Destructibility, Qual,
                                    CallExceptionSpec, Size, Alignment> {
  using Base = add<Movable::trivial, Destructibility, Qual, CallExceptionSpec,
                   Size, Alignment>;

  explicit add(int state_init) : Base(state_init) {}

  explicit add(std::initializer_list<int> state_init, int tail)
      : Base(state_init, tail) {}

  add(add&&) = delete;

  using Base::operator();
  using Base::state;
};

template <Destructible Destructibility, class Qual,
          NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>
struct add<Movable::yes, Destructibility, Qual, CallExceptionSpec, Size,
           Alignment> : private add<Movable::trivial, Destructibility, Qual,
                                    CallExceptionSpec, Size, Alignment> {
  using Base = add<Movable::trivial, Destructibility, Qual, CallExceptionSpec,
                   Size, Alignment>;

  explicit add(int state_init) : Base(state_init) {}

  explicit add(std::initializer_list<int> state_init, int tail)
      : Base(state_init, tail) {}

  add(add&& other) noexcept(false) : Base(other.state) {}  // NOLINT

  using Base::operator();
  using Base::state;
};

template <Destructible Destructibility, class Qual,
          NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>
struct add<Movable::nothrow, Destructibility, Qual, CallExceptionSpec, Size,
           Alignment> : private add<Movable::trivial, Destructibility, Qual,
                                    CallExceptionSpec, Size, Alignment> {
  using Base = add<Movable::trivial, Destructibility, Qual, CallExceptionSpec,
                   Size, Alignment>;

  explicit add(int state_init) : Base(state_init) {}

  explicit add(std::initializer_list<int> state_init, int tail)
      : Base(state_init, tail) {}

  add(add&& other) noexcept : Base(other.state) {}

  using Base::operator();
  using Base::state;
};

// Actual non-member functions rather than function objects
Int add_function(Int&& a, int b, int c) noexcept { return a.value + b + c; }

Int mult_function(Int&& a, int b, int c) noexcept { return a.value * b * c; }

Int square_function(Int const&& a) noexcept { return a.value * a.value; }

template <class Sig>
using AnyInvocable = absl::AnyInvocable<Sig>;

// Instantiations of this template contains all of the compile-time parameters
// for a given instantiation of the AnyInvocable test suite.
template <Movable Movability, Destructible Destructibility, class Qual,
          NothrowCall CallExceptionSpec, ObjSize Size, ObjAlign Alignment>
struct TestParams {
  static constexpr Movable kMovability = Movability;
  static constexpr Destructible kDestructibility = Destructibility;
  using Qualifiers = Qual;
  static constexpr NothrowCall kCallExceptionSpec = CallExceptionSpec;
  static constexpr bool kIsNoexcept = kCallExceptionSpec == NothrowCall::yes;
  static constexpr bool kIsRvalueQualified =
      std::is_rvalue_reference<Qual>::value;
  static constexpr ObjSize kSize = Size;
  static constexpr ObjAlign kAlignment = Alignment;

  // These types are used when testing with member object pointer Invocables
  using UnqualifiedUnaryFunType = int(Int const&&)
      ABSL_INTERNAL_NOEXCEPT_SPEC(CallExceptionSpec == NothrowCall::yes);
  using UnaryFunType = GiveQualifiersToFun<Qualifiers, UnqualifiedUnaryFunType>;
  using MemObjPtrType = int(Int::*);
  using UnaryAnyInvType = AnyInvocable<UnaryFunType>;
  using UnaryThisParamType = QualifiersForThis<Qualifiers, UnaryAnyInvType>;

  template <class T>
  static UnaryThisParamType ToUnaryThisParam(T&& fun) {
    return static_cast<UnaryThisParamType>(fun);
  }

  // This function type intentionally uses 3 "kinds" of parameter types.
  //     - A user-defined type
  //     - A reference type
  //     - A scalar type
  //
  // These were chosen because internal forwarding takes place on parameters
  // differently depending based on type properties (scalars are forwarded by
  // value).
  using ResultType = Int;
  using AnyInvocableFunTypeNotNoexcept = Int(Int, const int&, int);
  using UnqualifiedFunType =
      typename std::conditional<kIsNoexcept, Int(Int, const int&, int) noexcept,
                                Int(Int, const int&, int)>::type;
  using FunType = GiveQualifiersToFun<Qualifiers, UnqualifiedFunType>;
  using MemFunPtrType =
      typename std::conditional<kIsNoexcept,
                                Int (Int::*)(const int&, int) noexcept,
                                Int (Int::*)(const int&, int)>::type;
  using AnyInvType = AnyInvocable<FunType>;
  using AddType = add<kMovability, kDestructibility, Qualifiers,
                      kCallExceptionSpec, kSize, kAlignment>;
  using ThisParamType = QualifiersForThis<Qualifiers, AnyInvType>;

  template <class T>
  static ThisParamType ToThisParam(T&& fun) {
    return static_cast<ThisParamType>(fun);
  }

  // These typedefs are used when testing void return type covariance.
  using UnqualifiedVoidFunType =
      typename std::conditional<kIsNoexcept,
                                void(Int, const int&, int) noexcept,
                                void(Int, const int&, int)>::type;
  using VoidFunType = GiveQualifiersToFun<Qualifiers, UnqualifiedVoidFunType>;
  using VoidAnyInvType = AnyInvocable<VoidFunType>;
  using VoidThisParamType = QualifiersForThis<Qualifiers, VoidAnyInvType>;

  template <class T>
  static VoidThisParamType ToVoidThisParam(T&& fun) {
    return static_cast<VoidThisParamType>(fun);
  }

  using CompatibleAnyInvocableFunType =
      absl::conditional_t<std::is_rvalue_reference<Qual>::value,
                          GiveQualifiersToFun<const _&&, UnqualifiedFunType>,
                          GiveQualifiersToFun<const _&, UnqualifiedFunType>>;

  using CompatibleAnyInvType = AnyInvocable<CompatibleAnyInvocableFunType>;

  using IncompatibleInvocable =
      absl::conditional_t<std::is_rvalue_reference<Qual>::value,
                          GiveQualifiersToFun<_&, UnqualifiedFunType>(_::*),
                          GiveQualifiersToFun<_&&, UnqualifiedFunType>(_::*)>;
};

// Given a member-pointer type, this metafunction yields the target type of the
// pointer, not including the class-type. It is used to verify that the function
// call operator of AnyInvocable has the proper signature, corresponding to the
// function type that the user provided.
template <class MemberPtrType>
struct MemberTypeOfImpl;

template <class Class, class T>
struct MemberTypeOfImpl<T(Class::*)> {
  using type = T;
};

template <class MemberPtrType>
using MemberTypeOf = typename MemberTypeOfImpl<MemberPtrType>::type;

template <class T, class = void>
struct IsMemberSwappableImpl : std::false_type {
  static constexpr bool kIsNothrow = false;
};

template <class T>
struct IsMemberSwappableImpl<
    T, absl::void_t<decltype(std::declval<T&>().swap(std::declval<T&>()))>>
    : std::true_type {
  static constexpr bool kIsNothrow =
      noexcept(std::declval<T&>().swap(std::declval<T&>()));
};

template <class T>
using IsMemberSwappable = IsMemberSwappableImpl<T>;

template <class T>
using IsNothrowMemberSwappable =
    std::integral_constant<bool, IsMemberSwappableImpl<T>::kIsNothrow>;

template <class T>
class AnyInvTestBasic : public ::testing::Test {};

TYPED_TEST_SUITE_P(AnyInvTestBasic);

TYPED_TEST_P(AnyInvTestBasic, DefaultConstruction) {
  using AnyInvType = typename TypeParam::AnyInvType;

  AnyInvType fun;

  EXPECT_FALSE(static_cast<bool>(fun));

  EXPECT_TRUE(std::is_nothrow_default_constructible<AnyInvType>::value);
}

TYPED_TEST_P(AnyInvTestBasic, ConstructionNullptr) {
  using AnyInvType = typename TypeParam::AnyInvType;

  AnyInvType fun = nullptr;

  EXPECT_FALSE(static_cast<bool>(fun));

  EXPECT_TRUE(
      (std::is_nothrow_constructible<AnyInvType, std::nullptr_t>::value));
}

TYPED_TEST_P(AnyInvTestBasic, ConstructionNullFunctionPtr) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using UnqualifiedFunType = typename TypeParam::UnqualifiedFunType;

  UnqualifiedFunType* const null_fun_ptr = nullptr;
  AnyInvType fun = null_fun_ptr;

  EXPECT_FALSE(static_cast<bool>(fun));
}

TYPED_TEST_P(AnyInvTestBasic, ConstructionNullMemberFunctionPtr) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using MemFunPtrType = typename TypeParam::MemFunPtrType;

  const MemFunPtrType null_mem_fun_ptr = nullptr;
  AnyInvType fun = null_mem_fun_ptr;

  EXPECT_FALSE(static_cast<bool>(fun));
}

TYPED_TEST_P(AnyInvTestBasic, ConstructionNullMemberObjectPtr) {
  using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
  using MemObjPtrType = typename TypeParam::MemObjPtrType;

  const MemObjPtrType null_mem_obj_ptr = nullptr;
  UnaryAnyInvType fun = null_mem_obj_ptr;

  EXPECT_FALSE(static_cast<bool>(fun));
}

TYPED_TEST_P(AnyInvTestBasic, ConstructionMemberFunctionPtr) {
  using AnyInvType = typename TypeParam::AnyInvType;

  AnyInvType fun = &Int::MemberFunctionAdd;

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
}

TYPED_TEST_P(AnyInvTestBasic, ConstructionMemberObjectPtr) {
  using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;

  UnaryAnyInvType fun = &Int::value;

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(13, TypeParam::ToUnaryThisParam(fun)(13));
}

TYPED_TEST_P(AnyInvTestBasic, ConstructionFunctionReferenceDecay) {
  using AnyInvType = typename TypeParam::AnyInvType;

  AnyInvType fun = add_function;

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
}

TYPED_TEST_P(AnyInvTestBasic, ConstructionCompatibleAnyInvocableEmpty) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using CompatibleAnyInvType = typename TypeParam::CompatibleAnyInvType;

  CompatibleAnyInvType other;
  AnyInvType fun = std::move(other);

  EXPECT_FALSE(static_cast<bool>(other));  // NOLINT
  EXPECT_EQ(other, nullptr);               // NOLINT
  EXPECT_EQ(nullptr, other);               // NOLINT

  EXPECT_FALSE(static_cast<bool>(fun));
}

TYPED_TEST_P(AnyInvTestBasic, ConstructionCompatibleAnyInvocableNonempty) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using CompatibleAnyInvType = typename TypeParam::CompatibleAnyInvType;

  CompatibleAnyInvType other = &add_function;
  AnyInvType fun = std::move(other);

  EXPECT_FALSE(static_cast<bool>(other));  // NOLINT
  EXPECT_EQ(other, nullptr);               // NOLINT
  EXPECT_EQ(nullptr, other);               // NOLINT

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
}

TYPED_TEST_P(AnyInvTestBasic, ConversionToBool) {
  using AnyInvType = typename TypeParam::AnyInvType;

  {
    AnyInvType fun;

    // This tests contextually-convertible-to-bool.
    EXPECT_FALSE(fun ? true : false);  // NOLINT

    // Make sure that the conversion is not implicit.
    EXPECT_TRUE(
        (std::is_nothrow_constructible<bool, const AnyInvType&>::value));
    EXPECT_FALSE((std::is_convertible<const AnyInvType&, bool>::value));
  }

  {
    AnyInvType fun = &add_function;

    // This tests contextually-convertible-to-bool.
    EXPECT_TRUE(fun ? true : false);  // NOLINT
  }
}

TYPED_TEST_P(AnyInvTestBasic, Invocation) {
  using AnyInvType = typename TypeParam::AnyInvType;

  using FunType = typename TypeParam::FunType;
  using AnyInvCallType = MemberTypeOf<decltype(&AnyInvType::operator())>;

  // Make sure the function call operator of AnyInvocable always has the
  // type that was specified via the template argument.
  EXPECT_TRUE((std::is_same<AnyInvCallType, FunType>::value));

  AnyInvType fun = &add_function;

  EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
}

TYPED_TEST_P(AnyInvTestBasic, InPlaceConstruction) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using AddType = typename TypeParam::AddType;

  AnyInvType fun(absl::in_place_type<AddType>, 5);

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
}

TYPED_TEST_P(AnyInvTestBasic, InPlaceConstructionInitializerList) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using AddType = typename TypeParam::AddType;

  AnyInvType fun(absl::in_place_type<AddType>, {1, 2, 3, 4}, 5);

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(39, TypeParam::ToThisParam(fun)(7, 8, 9).value);
}

TYPED_TEST_P(AnyInvTestBasic, InPlaceNullFunPtrConstruction) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using UnqualifiedFunType = typename TypeParam::UnqualifiedFunType;

  AnyInvType fun(absl::in_place_type<UnqualifiedFunType*>, nullptr);

  // In-place construction does not lead to empty.
  EXPECT_TRUE(static_cast<bool>(fun));
}

TYPED_TEST_P(AnyInvTestBasic, InPlaceNullFunPtrConstructionValueInit) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using UnqualifiedFunType = typename TypeParam::UnqualifiedFunType;

  AnyInvType fun(absl::in_place_type<UnqualifiedFunType*>);

  // In-place construction does not lead to empty.
  EXPECT_TRUE(static_cast<bool>(fun));
}

TYPED_TEST_P(AnyInvTestBasic, InPlaceNullMemFunPtrConstruction) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using MemFunPtrType = typename TypeParam::MemFunPtrType;

  AnyInvType fun(absl::in_place_type<MemFunPtrType>, nullptr);

  // In-place construction does not lead to empty.
  EXPECT_TRUE(static_cast<bool>(fun));
}

TYPED_TEST_P(AnyInvTestBasic, InPlaceNullMemFunPtrConstructionValueInit) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using MemFunPtrType = typename TypeParam::MemFunPtrType;

  AnyInvType fun(absl::in_place_type<MemFunPtrType>);

  // In-place construction does not lead to empty.
  EXPECT_TRUE(static_cast<bool>(fun));
}

TYPED_TEST_P(AnyInvTestBasic, InPlaceNullMemObjPtrConstruction) {
  using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
  using MemObjPtrType = typename TypeParam::MemObjPtrType;

  UnaryAnyInvType fun(absl::in_place_type<MemObjPtrType>, nullptr);

  // In-place construction does not lead to empty.
  EXPECT_TRUE(static_cast<bool>(fun));
}

TYPED_TEST_P(AnyInvTestBasic, InPlaceNullMemObjPtrConstructionValueInit) {
  using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
  using MemObjPtrType = typename TypeParam::MemObjPtrType;

  UnaryAnyInvType fun(absl::in_place_type<MemObjPtrType>);

  // In-place construction does not lead to empty.
  EXPECT_TRUE(static_cast<bool>(fun));
}

TYPED_TEST_P(AnyInvTestBasic, InPlaceVoidCovarianceConstruction) {
  using VoidAnyInvType = typename TypeParam::VoidAnyInvType;
  using AddType = typename TypeParam::AddType;

  VoidAnyInvType fun(absl::in_place_type<AddType>, 5);

  EXPECT_TRUE(static_cast<bool>(fun));
}

TYPED_TEST_P(AnyInvTestBasic, MoveConstructionFromEmpty) {
  using AnyInvType = typename TypeParam::AnyInvType;

  AnyInvType source_fun;
  AnyInvType fun(std::move(source_fun));

  EXPECT_FALSE(static_cast<bool>(fun));

  EXPECT_TRUE(std::is_nothrow_move_constructible<AnyInvType>::value);
}

TYPED_TEST_P(AnyInvTestBasic, MoveConstructionFromNonEmpty) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using AddType = typename TypeParam::AddType;

  AnyInvType source_fun(absl::in_place_type<AddType>, 5);
  AnyInvType fun(std::move(source_fun));

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);

  EXPECT_TRUE(std::is_nothrow_move_constructible<AnyInvType>::value);
}

TYPED_TEST_P(AnyInvTestBasic, ComparisonWithNullptrEmpty) {
  using AnyInvType = typename TypeParam::AnyInvType;

  AnyInvType fun;

  EXPECT_TRUE(fun == nullptr);
  EXPECT_TRUE(nullptr == fun);

  EXPECT_FALSE(fun != nullptr);
  EXPECT_FALSE(nullptr != fun);
}

TYPED_TEST_P(AnyInvTestBasic, ComparisonWithNullptrNonempty) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using AddType = typename TypeParam::AddType;

  AnyInvType fun(absl::in_place_type<AddType>, 5);

  EXPECT_FALSE(fun == nullptr);
  EXPECT_FALSE(nullptr == fun);

  EXPECT_TRUE(fun != nullptr);
  EXPECT_TRUE(nullptr != fun);
}

TYPED_TEST_P(AnyInvTestBasic, ResultType) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using ExpectedResultType = typename TypeParam::ResultType;

  EXPECT_TRUE((std::is_same<typename AnyInvType::result_type,
                            ExpectedResultType>::value));
}

template <class T>
class AnyInvTestCombinatoric : public ::testing::Test {};

TYPED_TEST_SUITE_P(AnyInvTestCombinatoric);

TYPED_TEST_P(AnyInvTestCombinatoric, MoveAssignEmptyEmptyLhsRhs) {
  using AnyInvType = typename TypeParam::AnyInvType;

  AnyInvType source_fun;
  AnyInvType fun;

  fun = std::move(source_fun);

  EXPECT_FALSE(static_cast<bool>(fun));
}

TYPED_TEST_P(AnyInvTestCombinatoric, MoveAssignEmptyLhsNonemptyRhs) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using AddType = typename TypeParam::AddType;

  AnyInvType source_fun(absl::in_place_type<AddType>, 5);
  AnyInvType fun;

  fun = std::move(source_fun);

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
}

TYPED_TEST_P(AnyInvTestCombinatoric, MoveAssignNonemptyEmptyLhsRhs) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using AddType = typename TypeParam::AddType;

  AnyInvType source_fun;
  AnyInvType fun(absl::in_place_type<AddType>, 5);

  fun = std::move(source_fun);

  EXPECT_FALSE(static_cast<bool>(fun));
}

TYPED_TEST_P(AnyInvTestCombinatoric, MoveAssignNonemptyLhsNonemptyRhs) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using AddType = typename TypeParam::AddType;

  AnyInvType source_fun(absl::in_place_type<AddType>, 5);
  AnyInvType fun(absl::in_place_type<AddType>, 20);

  fun = std::move(source_fun);

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
}

TYPED_TEST_P(AnyInvTestCombinatoric, SelfMoveAssignEmpty) {
  using AnyInvType = typename TypeParam::AnyInvType;

  AnyInvType source_fun;
  source_fun = std::move(source_fun);

  // This space intentionally left blank.
}

TYPED_TEST_P(AnyInvTestCombinatoric, SelfMoveAssignNonempty) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using AddType = typename TypeParam::AddType;

  AnyInvType source_fun(absl::in_place_type<AddType>, 5);
  source_fun = std::move(source_fun);

  // This space intentionally left blank.
}

TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullptrEmptyLhs) {
  using AnyInvType = typename TypeParam::AnyInvType;

  AnyInvType fun;
  fun = nullptr;

  EXPECT_FALSE(static_cast<bool>(fun));
}

TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullFunctionPtrEmptyLhs) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using UnqualifiedFunType = typename TypeParam::UnqualifiedFunType;

  UnqualifiedFunType* const null_fun_ptr = nullptr;
  AnyInvType fun;
  fun = null_fun_ptr;

  EXPECT_FALSE(static_cast<bool>(fun));
}

TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullMemberFunctionPtrEmptyLhs) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using MemFunPtrType = typename TypeParam::MemFunPtrType;

  const MemFunPtrType null_mem_fun_ptr = nullptr;
  AnyInvType fun;
  fun = null_mem_fun_ptr;

  EXPECT_FALSE(static_cast<bool>(fun));
}

TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullMemberObjectPtrEmptyLhs) {
  using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
  using MemObjPtrType = typename TypeParam::MemObjPtrType;

  const MemObjPtrType null_mem_obj_ptr = nullptr;
  UnaryAnyInvType fun;
  fun = null_mem_obj_ptr;

  EXPECT_FALSE(static_cast<bool>(fun));
}

TYPED_TEST_P(AnyInvTestCombinatoric, AssignMemberFunctionPtrEmptyLhs) {
  using AnyInvType = typename TypeParam::AnyInvType;

  AnyInvType fun;
  fun = &Int::MemberFunctionAdd;

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
}

TYPED_TEST_P(AnyInvTestCombinatoric, AssignMemberObjectPtrEmptyLhs) {
  using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;

  UnaryAnyInvType fun;
  fun = &Int::value;

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(13, TypeParam::ToUnaryThisParam(fun)(13));
}

TYPED_TEST_P(AnyInvTestCombinatoric, AssignFunctionReferenceDecayEmptyLhs) {
  using AnyInvType = typename TypeParam::AnyInvType;

  AnyInvType fun;
  fun = add_function;

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
}

TYPED_TEST_P(AnyInvTestCombinatoric,
             AssignCompatibleAnyInvocableEmptyLhsEmptyRhs) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using CompatibleAnyInvType = typename TypeParam::CompatibleAnyInvType;

  CompatibleAnyInvType other;
  AnyInvType fun;
  fun = std::move(other);

  EXPECT_FALSE(static_cast<bool>(other));  // NOLINT
  EXPECT_EQ(other, nullptr);               // NOLINT
  EXPECT_EQ(nullptr, other);               // NOLINT

  EXPECT_FALSE(static_cast<bool>(fun));
}

TYPED_TEST_P(AnyInvTestCombinatoric,
             AssignCompatibleAnyInvocableEmptyLhsNonemptyRhs) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using CompatibleAnyInvType = typename TypeParam::CompatibleAnyInvType;

  CompatibleAnyInvType other = &add_function;
  AnyInvType fun;
  fun = std::move(other);

  EXPECT_FALSE(static_cast<bool>(other));  // NOLINT

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
}

TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullptrNonemptyLhs) {
  using AnyInvType = typename TypeParam::AnyInvType;

  AnyInvType fun = &mult_function;
  fun = nullptr;

  EXPECT_FALSE(static_cast<bool>(fun));
}

TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullFunctionPtrNonemptyLhs) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using UnqualifiedFunType = typename TypeParam::UnqualifiedFunType;

  UnqualifiedFunType* const null_fun_ptr = nullptr;
  AnyInvType fun = &mult_function;
  fun = null_fun_ptr;

  EXPECT_FALSE(static_cast<bool>(fun));
}

TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullMemberFunctionPtrNonemptyLhs) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using MemFunPtrType = typename TypeParam::MemFunPtrType;

  const MemFunPtrType null_mem_fun_ptr = nullptr;
  AnyInvType fun = &mult_function;
  fun = null_mem_fun_ptr;

  EXPECT_FALSE(static_cast<bool>(fun));
}

TYPED_TEST_P(AnyInvTestCombinatoric, AssignNullMemberObjectPtrNonemptyLhs) {
  using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;
  using MemObjPtrType = typename TypeParam::MemObjPtrType;

  const MemObjPtrType null_mem_obj_ptr = nullptr;
  UnaryAnyInvType fun = &square_function;
  fun = null_mem_obj_ptr;

  EXPECT_FALSE(static_cast<bool>(fun));
}

TYPED_TEST_P(AnyInvTestCombinatoric, AssignMemberFunctionPtrNonemptyLhs) {
  using AnyInvType = typename TypeParam::AnyInvType;

  AnyInvType fun = &mult_function;
  fun = &Int::MemberFunctionAdd;

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
}

TYPED_TEST_P(AnyInvTestCombinatoric, AssignMemberObjectPtrNonemptyLhs) {
  using UnaryAnyInvType = typename TypeParam::UnaryAnyInvType;

  UnaryAnyInvType fun = &square_function;
  fun = &Int::value;

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(13, TypeParam::ToUnaryThisParam(fun)(13));
}

TYPED_TEST_P(AnyInvTestCombinatoric, AssignFunctionReferenceDecayNonemptyLhs) {
  using AnyInvType = typename TypeParam::AnyInvType;

  AnyInvType fun = &mult_function;
  fun = add_function;

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
}

TYPED_TEST_P(AnyInvTestCombinatoric,
             AssignCompatibleAnyInvocableNonemptyLhsEmptyRhs) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using CompatibleAnyInvType = typename TypeParam::CompatibleAnyInvType;

  CompatibleAnyInvType other;
  AnyInvType fun = &mult_function;
  fun = std::move(other);

  EXPECT_FALSE(static_cast<bool>(other));  // NOLINT
  EXPECT_EQ(other, nullptr);               // NOLINT
  EXPECT_EQ(nullptr, other);               // NOLINT

  EXPECT_FALSE(static_cast<bool>(fun));
}

TYPED_TEST_P(AnyInvTestCombinatoric,
             AssignCompatibleAnyInvocableNonemptyLhsNonemptyRhs) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using CompatibleAnyInvType = typename TypeParam::CompatibleAnyInvType;

  CompatibleAnyInvType other = &add_function;
  AnyInvType fun = &mult_function;
  fun = std::move(other);

  EXPECT_FALSE(static_cast<bool>(other));  // NOLINT

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(24, TypeParam::ToThisParam(fun)(7, 8, 9).value);
}

TYPED_TEST_P(AnyInvTestCombinatoric, SwapEmptyLhsEmptyRhs) {
  using AnyInvType = typename TypeParam::AnyInvType;

  // Swap idiom
  {
    AnyInvType fun;
    AnyInvType other;

    using std::swap;
    swap(fun, other);

    EXPECT_FALSE(static_cast<bool>(fun));
    EXPECT_FALSE(static_cast<bool>(other));

    EXPECT_TRUE(
        absl::type_traits_internal::IsNothrowSwappable<AnyInvType>::value);
  }

  // Member swap
  {
    AnyInvType fun;
    AnyInvType other;

    fun.swap(other);

    EXPECT_FALSE(static_cast<bool>(fun));
    EXPECT_FALSE(static_cast<bool>(other));

    EXPECT_TRUE(IsNothrowMemberSwappable<AnyInvType>::value);
  }
}

TYPED_TEST_P(AnyInvTestCombinatoric, SwapEmptyLhsNonemptyRhs) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using AddType = typename TypeParam::AddType;

  // Swap idiom
  {
    AnyInvType fun;
    AnyInvType other(absl::in_place_type<AddType>, 5);

    using std::swap;
    swap(fun, other);

    EXPECT_TRUE(static_cast<bool>(fun));
    EXPECT_FALSE(static_cast<bool>(other));

    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);

    EXPECT_TRUE(
        absl::type_traits_internal::IsNothrowSwappable<AnyInvType>::value);
  }

  // Member swap
  {
    AnyInvType fun;
    AnyInvType other(absl::in_place_type<AddType>, 5);

    fun.swap(other);

    EXPECT_TRUE(static_cast<bool>(fun));
    EXPECT_FALSE(static_cast<bool>(other));

    EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);

    EXPECT_TRUE(IsNothrowMemberSwappable<AnyInvType>::value);
  }
}

TYPED_TEST_P(AnyInvTestCombinatoric, SwapNonemptyLhsEmptyRhs) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using AddType = typename TypeParam::AddType;

  // Swap idiom
  {
    AnyInvType fun(absl::in_place_type<AddType>, 5);
    AnyInvType other;

    using std::swap;
    swap(fun, other);

    EXPECT_FALSE(static_cast<bool>(fun));
    EXPECT_TRUE(static_cast<bool>(other));

    EXPECT_EQ(29, TypeParam::ToThisParam(other)(7, 8, 9).value);

    EXPECT_TRUE(
        absl::type_traits_internal::IsNothrowSwappable<AnyInvType>::value);
  }

  // Member swap
  {
    AnyInvType fun(absl::in_place_type<AddType>, 5);
    AnyInvType other;

    fun.swap(other);

    EXPECT_FALSE(static_cast<bool>(fun));
    EXPECT_TRUE(static_cast<bool>(other));

    EXPECT_EQ(29, TypeParam::ToThisParam(other)(7, 8, 9).value);

    EXPECT_TRUE(IsNothrowMemberSwappable<AnyInvType>::value);
  }
}

TYPED_TEST_P(AnyInvTestCombinatoric, SwapNonemptyLhsNonemptyRhs) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using AddType = typename TypeParam::AddType;

  // Swap idiom
  {
    AnyInvType fun(absl::in_place_type<AddType>, 5);
    AnyInvType other(absl::in_place_type<AddType>, 6);

    using std::swap;
    swap(fun, other);

    EXPECT_TRUE(static_cast<bool>(fun));
    EXPECT_TRUE(static_cast<bool>(other));

    EXPECT_EQ(30, TypeParam::ToThisParam(fun)(7, 8, 9).value);
    EXPECT_EQ(29, TypeParam::ToThisParam(other)(7, 8, 9).value);

    EXPECT_TRUE(
        absl::type_traits_internal::IsNothrowSwappable<AnyInvType>::value);
  }

  // Member swap
  {
    AnyInvType fun(absl::in_place_type<AddType>, 5);
    AnyInvType other(absl::in_place_type<AddType>, 6);

    fun.swap(other);

    EXPECT_TRUE(static_cast<bool>(fun));
    EXPECT_TRUE(static_cast<bool>(other));

    EXPECT_EQ(30, TypeParam::ToThisParam(fun)(7, 8, 9).value);
    EXPECT_EQ(29, TypeParam::ToThisParam(other)(7, 8, 9).value);

    EXPECT_TRUE(IsNothrowMemberSwappable<AnyInvType>::value);
  }
}

template <class T>
class AnyInvTestMovable : public ::testing::Test {};

TYPED_TEST_SUITE_P(AnyInvTestMovable);

TYPED_TEST_P(AnyInvTestMovable, ConversionConstructionUserDefinedType) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using AddType = typename TypeParam::AddType;

  AnyInvType fun(AddType(5));

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
}

TYPED_TEST_P(AnyInvTestMovable, ConversionConstructionVoidCovariance) {
  using VoidAnyInvType = typename TypeParam::VoidAnyInvType;
  using AddType = typename TypeParam::AddType;

  VoidAnyInvType fun(AddType(5));

  EXPECT_TRUE(static_cast<bool>(fun));
}

TYPED_TEST_P(AnyInvTestMovable, ConversionAssignUserDefinedTypeEmptyLhs) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using AddType = typename TypeParam::AddType;

  AnyInvType fun;
  fun = AddType(5);

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
}

TYPED_TEST_P(AnyInvTestMovable, ConversionAssignUserDefinedTypeNonemptyLhs) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using AddType = typename TypeParam::AddType;

  AnyInvType fun = &add_function;
  fun = AddType(5);

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);
}

TYPED_TEST_P(AnyInvTestMovable, ConversionAssignVoidCovariance) {
  using VoidAnyInvType = typename TypeParam::VoidAnyInvType;
  using AddType = typename TypeParam::AddType;

  VoidAnyInvType fun;
  fun = AddType(5);

  EXPECT_TRUE(static_cast<bool>(fun));
}

template <class T>
class AnyInvTestNoexceptFalse : public ::testing::Test {};

TYPED_TEST_SUITE_P(AnyInvTestNoexceptFalse);

TYPED_TEST_P(AnyInvTestNoexceptFalse, ConversionConstructionConstraints) {
  using AnyInvType = typename TypeParam::AnyInvType;

  EXPECT_TRUE((std::is_constructible<
               AnyInvType,
               typename TypeParam::AnyInvocableFunTypeNotNoexcept*>::value));
  EXPECT_FALSE((
      std::is_constructible<AnyInvType,
                            typename TypeParam::IncompatibleInvocable>::value));
}

TYPED_TEST_P(AnyInvTestNoexceptFalse, ConversionAssignConstraints) {
  using AnyInvType = typename TypeParam::AnyInvType;

  EXPECT_TRUE((std::is_assignable<
               AnyInvType&,
               typename TypeParam::AnyInvocableFunTypeNotNoexcept*>::value));
  EXPECT_FALSE(
      (std::is_assignable<AnyInvType&,
                          typename TypeParam::IncompatibleInvocable>::value));
}

template <class T>
class AnyInvTestNoexceptTrue : public ::testing::Test {};

TYPED_TEST_SUITE_P(AnyInvTestNoexceptTrue);

TYPED_TEST_P(AnyInvTestNoexceptTrue, ConversionConstructionConstraints) {
#if ABSL_INTERNAL_CPLUSPLUS_LANG < 201703L
  GTEST_SKIP() << "Noexcept was not part of the type system before C++17.";
#else
  using AnyInvType = typename TypeParam::AnyInvType;

  EXPECT_FALSE((std::is_constructible<
                AnyInvType,
                typename TypeParam::AnyInvocableFunTypeNotNoexcept*>::value));
  EXPECT_FALSE((
      std::is_constructible<AnyInvType,
                            typename TypeParam::IncompatibleInvocable>::value));
#endif
}

TYPED_TEST_P(AnyInvTestNoexceptTrue, ConversionAssignConstraints) {
#if ABSL_INTERNAL_CPLUSPLUS_LANG < 201703L
  GTEST_SKIP() << "Noexcept was not part of the type system before C++17.";
#else
  using AnyInvType = typename TypeParam::AnyInvType;

  EXPECT_FALSE((std::is_assignable<
                AnyInvType&,
                typename TypeParam::AnyInvocableFunTypeNotNoexcept*>::value));
  EXPECT_FALSE(
      (std::is_assignable<AnyInvType&,
                          typename TypeParam::IncompatibleInvocable>::value));
#endif
}

template <class T>
class AnyInvTestNonRvalue : public ::testing::Test {};

TYPED_TEST_SUITE_P(AnyInvTestNonRvalue);

TYPED_TEST_P(AnyInvTestNonRvalue, ConversionConstructionReferenceWrapper) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using AddType = typename TypeParam::AddType;

  AddType add(4);
  AnyInvType fun = std::ref(add);
  add.state = 5;

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(38, TypeParam::ToThisParam(fun)(10, 11, 12).value);
}

TYPED_TEST_P(AnyInvTestNonRvalue, NonMoveableResultType) {
#if ABSL_INTERNAL_CPLUSPLUS_LANG < 201703L
  GTEST_SKIP() << "Copy/move elision was not standard before C++17";
#else
  // Define a result type that cannot be copy- or move-constructed.
  struct Result {
    int x;

    explicit Result(const int x_in) : x(x_in) {}
    Result(Result&&) = delete;
  };

  static_assert(!std::is_move_constructible<Result>::value, "");
  static_assert(!std::is_copy_constructible<Result>::value, "");

  // Assumption check: it should nevertheless be possible to use functors that
  // return a Result struct according to the language rules.
  const auto return_17 = []() noexcept { return Result(17); };
  EXPECT_EQ(17, return_17().x);

  // Just like plain functors, it should work fine to use an AnyInvocable that
  // returns the non-moveable type.
  using UnqualifiedFun =
      absl::conditional_t<TypeParam::kIsNoexcept, Result() noexcept, Result()>;

  using Fun =
      GiveQualifiersToFun<typename TypeParam::Qualifiers, UnqualifiedFun>;

  AnyInvocable<Fun> any_inv(return_17);
  EXPECT_EQ(17, any_inv().x);
#endif
}

TYPED_TEST_P(AnyInvTestNonRvalue, ConversionAssignReferenceWrapperEmptyLhs) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using AddType = typename TypeParam::AddType;

  AddType add(4);
  AnyInvType fun;
  fun = std::ref(add);
  add.state = 5;
  EXPECT_TRUE(
      (std::is_nothrow_assignable<AnyInvType&,
                                  std::reference_wrapper<AddType>>::value));

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(38, TypeParam::ToThisParam(fun)(10, 11, 12).value);
}

TYPED_TEST_P(AnyInvTestNonRvalue, ConversionAssignReferenceWrapperNonemptyLhs) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using AddType = typename TypeParam::AddType;

  AddType add(4);
  AnyInvType fun = &mult_function;
  fun = std::ref(add);
  add.state = 5;
  EXPECT_TRUE(
      (std::is_nothrow_assignable<AnyInvType&,
                                  std::reference_wrapper<AddType>>::value));

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(29, TypeParam::ToThisParam(fun)(7, 8, 9).value);

  EXPECT_TRUE(static_cast<bool>(fun));
  EXPECT_EQ(38, TypeParam::ToThisParam(fun)(10, 11, 12).value);
}

template <class T>
class AnyInvTestRvalue : public ::testing::Test {};

TYPED_TEST_SUITE_P(AnyInvTestRvalue);

TYPED_TEST_P(AnyInvTestRvalue, ConversionConstructionReferenceWrapper) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using AddType = typename TypeParam::AddType;

  EXPECT_FALSE((
      std::is_convertible<std::reference_wrapper<AddType>, AnyInvType>::value));
}

TYPED_TEST_P(AnyInvTestRvalue, NonMoveableResultType) {
#if ABSL_INTERNAL_CPLUSPLUS_LANG < 201703L
  GTEST_SKIP() << "Copy/move elision was not standard before C++17";
#else
  // Define a result type that cannot be copy- or move-constructed.
  struct Result {
    int x;

    explicit Result(const int x_in) : x(x_in) {}
    Result(Result&&) = delete;
  };

  static_assert(!std::is_move_constructible<Result>::value, "");
  static_assert(!std::is_copy_constructible<Result>::value, "");

  // Assumption check: it should nevertheless be possible to use functors that
  // return a Result struct according to the language rules.
  const auto return_17 = []() noexcept { return Result(17); };
  EXPECT_EQ(17, return_17().x);

  // Just like plain functors, it should work fine to use an AnyInvocable that
  // returns the non-moveable type.
  using UnqualifiedFun =
      absl::conditional_t<TypeParam::kIsNoexcept, Result() noexcept, Result()>;

  using Fun =
      GiveQualifiersToFun<typename TypeParam::Qualifiers, UnqualifiedFun>;

  EXPECT_EQ(17, AnyInvocable<Fun>(return_17)().x);
#endif
}

TYPED_TEST_P(AnyInvTestRvalue, ConversionAssignReferenceWrapper) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using AddType = typename TypeParam::AddType;

  EXPECT_FALSE((
      std::is_assignable<AnyInvType&, std::reference_wrapper<AddType>>::value));
}

TYPED_TEST_P(AnyInvTestRvalue, NonConstCrashesOnSecondCall) {
  using AnyInvType = typename TypeParam::AnyInvType;
  using AddType = typename TypeParam::AddType;

  AnyInvType fun(absl::in_place_type<AddType>, 5);

  EXPECT_TRUE(static_cast<bool>(fun));
  std::move(fun)(7, 8, 9);

  // Ensure we're still valid
  EXPECT_TRUE(static_cast<bool>(fun));  // NOLINT(bugprone-use-after-move)

#if !defined(NDEBUG)
  EXPECT_DEATH_IF_SUPPORTED(std::move(fun)(7, 8, 9), "");
#endif
}

// Ensure that any qualifiers (in particular &&-qualifiers) do not affect
// when the destructor is actually run.
TYPED_TEST_P(AnyInvTestRvalue, QualifierIndependentObjectLifetime) {
  using AnyInvType = typename TypeParam::AnyInvType;

  auto refs = std::make_shared<std::nullptr_t>();
  {
    AnyInvType fun([refs](auto&&...) noexcept { return 0; });
    EXPECT_GT(refs.use_count(), 1);

    std::move(fun)(7, 8, 9);

    // Ensure destructor hasn't run even if rref-qualified
    EXPECT_GT(refs.use_count(), 1);
  }
  EXPECT_EQ(refs.use_count(), 1);
}

// NOTE: This test suite originally attempted to enumerate all possible
// combinations of type properties but the build-time started getting too large.
// Instead, it is now assumed that certain parameters are orthogonal and so
// some combinations are elided.

// A metafunction to form a TypeList of all cv and non-rvalue ref combinations,
// coupled with all of the other explicitly specified parameters.
template <Movable Mov, Destructible Dest, NothrowCall CallExceptionSpec,
          ObjSize Size, ObjAlign Align>
using NonRvalueQualifiedTestParams = ::testing::Types<               //
    TestParams<Mov, Dest, _, CallExceptionSpec, Size, Align>,        //
    TestParams<Mov, Dest, const _, CallExceptionSpec, Size, Align>,  //
    TestParams<Mov, Dest, _&, CallExceptionSpec, Size, Align>,       //
    TestParams<Mov, Dest, const _&, CallExceptionSpec, Size, Align>>;

// A metafunction to form a TypeList of const and non-const rvalue ref
// qualifiers, coupled with all of the other explicitly specified parameters.
template <Movable Mov, Destructible Dest, NothrowCall CallExceptionSpec,
          ObjSize Size, ObjAlign Align>
using RvalueQualifiedTestParams = ::testing::Types<
    TestParams<Mov, Dest, _&&, CallExceptionSpec, Size, Align>,       //
    TestParams<Mov, Dest, const _&&, CallExceptionSpec, Size, Align>  //
    >;

// All qualifier combinations and a noexcept function type
using TestParameterListNonRvalueQualifiersNothrowCall =
    NonRvalueQualifiedTestParams<Movable::trivial, Destructible::trivial,
                                 NothrowCall::yes, ObjSize::small,
                                 ObjAlign::normal>;
using TestParameterListRvalueQualifiersNothrowCall =
    RvalueQualifiedTestParams<Movable::trivial, Destructible::trivial,
                              NothrowCall::yes, ObjSize::small,
                              ObjAlign::normal>;

// All qualifier combinations and a non-noexcept function type
using TestParameterListNonRvalueQualifiersCallMayThrow =
    NonRvalueQualifiedTestParams<Movable::trivial, Destructible::trivial,
                                 NothrowCall::no, ObjSize::small,
                                 ObjAlign::normal>;
using TestParameterListRvalueQualifiersCallMayThrow =
    RvalueQualifiedTestParams<Movable::trivial, Destructible::trivial,
                              NothrowCall::no, ObjSize::small,
                              ObjAlign::normal>;

// Lists of various cases that should lead to remote storage
using TestParameterListRemoteMovable = ::testing::Types<
    // "Normal" aligned types that are large and have trivial destructors
    TestParams<Movable::trivial, Destructible::trivial, _, NothrowCall::no,
               ObjSize::large, ObjAlign::normal>,  //
    TestParams<Movable::nothrow, Destructible::trivial, _, NothrowCall::no,
               ObjSize::large, ObjAlign::normal>,  //
    TestParams<Movable::yes, Destructible::trivial, _, NothrowCall::no,
               ObjSize::small, ObjAlign::normal>,  //
    TestParams<Movable::yes, Destructible::trivial, _, NothrowCall::no,
               ObjSize::large, ObjAlign::normal>,  //

    // Same as above but with non-trivial destructors
    TestParams<Movable::trivial, Destructible::nothrow, _, NothrowCall::no,
               ObjSize::large, ObjAlign::normal>,  //
    TestParams<Movable::nothrow, Destructible::nothrow, _, NothrowCall::no,
               ObjSize::large, ObjAlign::normal>,  //
    TestParams<Movable::yes, Destructible::nothrow, _, NothrowCall::no,
               ObjSize::small, ObjAlign::normal>,  //
    TestParams<Movable::yes, Destructible::nothrow, _, NothrowCall::no,
               ObjSize::large, ObjAlign::normal>  //

// Dynamic memory allocation for over-aligned data was introduced in C++17.
// See https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0035r4.html
#if ABSL_INTERNAL_CPLUSPLUS_LANG >= 201703L
    // Types that must use remote storage because of a large alignment.
    ,
    TestParams<Movable::trivial, Destructible::trivial, _, NothrowCall::no,
               ObjSize::small, ObjAlign::large>,  //
    TestParams<Movable::nothrow, Destructible::trivial, _, NothrowCall::no,
               ObjSize::small, ObjAlign::large>,  //
    TestParams<Movable::trivial, Destructible::nothrow, _, NothrowCall::no,
               ObjSize::small, ObjAlign::large>,  //
    TestParams<Movable::nothrow, Destructible::nothrow, _, NothrowCall::no,
               ObjSize::small, ObjAlign::large>  //
#endif
    >;
using TestParameterListRemoteNonMovable = ::testing::Types<
    // "Normal" aligned types that are large and have trivial destructors
    TestParams<Movable::no, Destructible::trivial, _, NothrowCall::no,
               ObjSize::small, ObjAlign::normal>,  //
    TestParams<Movable::no, Destructible::trivial, _, NothrowCall::no,
               ObjSize::large, ObjAlign::normal>,  //
    // Same as above but with non-trivial destructors
    TestParams<Movable::no, Destructible::nothrow, _, NothrowCall::no,
               ObjSize::small, ObjAlign::normal>,  //
    TestParams<Movable::no, Destructible::nothrow, _, NothrowCall::no,
               ObjSize::large, ObjAlign::normal>  //
    >;

// Parameters that lead to local storage
using TestParameterListLocal = ::testing::Types<
    // Types that meet the requirements and have trivial destructors
    TestParams<Movable::trivial, Destructible::trivial, _, NothrowCall::no,
               ObjSize::small, ObjAlign::normal>,  //
    TestParams<Movable::nothrow, Destructible::trivial, _, NothrowCall::no,
               ObjSize::small, ObjAlign::normal>,  //

    // Same as above but with non-trivial destructors
    TestParams<Movable::trivial, Destructible::trivial, _, NothrowCall::no,
               ObjSize::small, ObjAlign::normal>,  //
    TestParams<Movable::nothrow, Destructible::trivial, _, NothrowCall::no,
               ObjSize::small, ObjAlign::normal>  //
    >;

// All of the tests that are run for every possible combination of types.
REGISTER_TYPED_TEST_SUITE_P(
    AnyInvTestBasic, DefaultConstruction, ConstructionNullptr,
    ConstructionNullFunctionPtr, ConstructionNullMemberFunctionPtr,
    ConstructionNullMemberObjectPtr, ConstructionMemberFunctionPtr,
    ConstructionMemberObjectPtr, ConstructionFunctionReferenceDecay,
    ConstructionCompatibleAnyInvocableEmpty,
    ConstructionCompatibleAnyInvocableNonempty, InPlaceConstruction,
    ConversionToBool, Invocation, InPlaceConstructionInitializerList,
    InPlaceNullFunPtrConstruction, InPlaceNullFunPtrConstructionValueInit,
    InPlaceNullMemFunPtrConstruction, InPlaceNullMemFunPtrConstructionValueInit,
    InPlaceNullMemObjPtrConstruction, InPlaceNullMemObjPtrConstructionValueInit,
    InPlaceVoidCovarianceConstruction, MoveConstructionFromEmpty,
    MoveConstructionFromNonEmpty, ComparisonWithNullptrEmpty,
    ComparisonWithNullptrNonempty, ResultType);

INSTANTIATE_TYPED_TEST_SUITE_P(
    NonRvalueCallMayThrow, AnyInvTestBasic,
    TestParameterListNonRvalueQualifiersCallMayThrow);
INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallMayThrow, AnyInvTestBasic,
                               TestParameterListRvalueQualifiersCallMayThrow);

INSTANTIATE_TYPED_TEST_SUITE_P(RemoteMovable, AnyInvTestBasic,
                               TestParameterListRemoteMovable);
INSTANTIATE_TYPED_TEST_SUITE_P(RemoteNonMovable, AnyInvTestBasic,
                               TestParameterListRemoteNonMovable);

INSTANTIATE_TYPED_TEST_SUITE_P(Local, AnyInvTestBasic, TestParameterListLocal);

INSTANTIATE_TYPED_TEST_SUITE_P(NonRvalueCallNothrow, AnyInvTestBasic,
                               TestParameterListNonRvalueQualifiersNothrowCall);
INSTANTIATE_TYPED_TEST_SUITE_P(CallNothrowRvalue, AnyInvTestBasic,
                               TestParameterListRvalueQualifiersNothrowCall);

// Tests for functions that take two operands.
REGISTER_TYPED_TEST_SUITE_P(
    AnyInvTestCombinatoric, MoveAssignEmptyEmptyLhsRhs,
    MoveAssignEmptyLhsNonemptyRhs, MoveAssignNonemptyEmptyLhsRhs,
    MoveAssignNonemptyLhsNonemptyRhs, SelfMoveAssignEmpty,
    SelfMoveAssignNonempty, AssignNullptrEmptyLhs,
    AssignNullFunctionPtrEmptyLhs, AssignNullMemberFunctionPtrEmptyLhs,
    AssignNullMemberObjectPtrEmptyLhs, AssignMemberFunctionPtrEmptyLhs,
    AssignMemberObjectPtrEmptyLhs, AssignFunctionReferenceDecayEmptyLhs,
    AssignCompatibleAnyInvocableEmptyLhsEmptyRhs,
    AssignCompatibleAnyInvocableEmptyLhsNonemptyRhs, AssignNullptrNonemptyLhs,
    AssignNullFunctionPtrNonemptyLhs, AssignNullMemberFunctionPtrNonemptyLhs,
    AssignNullMemberObjectPtrNonemptyLhs, AssignMemberFunctionPtrNonemptyLhs,
    AssignMemberObjectPtrNonemptyLhs, AssignFunctionReferenceDecayNonemptyLhs,
    AssignCompatibleAnyInvocableNonemptyLhsEmptyRhs,
    AssignCompatibleAnyInvocableNonemptyLhsNonemptyRhs, SwapEmptyLhsEmptyRhs,
    SwapEmptyLhsNonemptyRhs, SwapNonemptyLhsEmptyRhs,
    SwapNonemptyLhsNonemptyRhs);

INSTANTIATE_TYPED_TEST_SUITE_P(
    NonRvalueCallMayThrow, AnyInvTestCombinatoric,
    TestParameterListNonRvalueQualifiersCallMayThrow);
INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallMayThrow, AnyInvTestCombinatoric,
                               TestParameterListRvalueQualifiersCallMayThrow);

INSTANTIATE_TYPED_TEST_SUITE_P(RemoteMovable, AnyInvTestCombinatoric,
                               TestParameterListRemoteMovable);
INSTANTIATE_TYPED_TEST_SUITE_P(RemoteNonMovable, AnyInvTestCombinatoric,
                               TestParameterListRemoteNonMovable);

INSTANTIATE_TYPED_TEST_SUITE_P(Local, AnyInvTestCombinatoric,
                               TestParameterListLocal);

INSTANTIATE_TYPED_TEST_SUITE_P(NonRvalueCallNothrow, AnyInvTestCombinatoric,
                               TestParameterListNonRvalueQualifiersNothrowCall);
INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallNothrow, AnyInvTestCombinatoric,
                               TestParameterListRvalueQualifiersNothrowCall);

REGISTER_TYPED_TEST_SUITE_P(AnyInvTestMovable,
                            ConversionConstructionUserDefinedType,
                            ConversionConstructionVoidCovariance,
                            ConversionAssignUserDefinedTypeEmptyLhs,
                            ConversionAssignUserDefinedTypeNonemptyLhs,
                            ConversionAssignVoidCovariance);

INSTANTIATE_TYPED_TEST_SUITE_P(
    NonRvalueCallMayThrow, AnyInvTestMovable,
    TestParameterListNonRvalueQualifiersCallMayThrow);
INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallMayThrow, AnyInvTestMovable,
                               TestParameterListRvalueQualifiersCallMayThrow);

INSTANTIATE_TYPED_TEST_SUITE_P(RemoteMovable, AnyInvTestMovable,
                               TestParameterListRemoteMovable);

INSTANTIATE_TYPED_TEST_SUITE_P(Local, AnyInvTestMovable,
                               TestParameterListLocal);

INSTANTIATE_TYPED_TEST_SUITE_P(NonRvalueCallNothrow, AnyInvTestMovable,
                               TestParameterListNonRvalueQualifiersNothrowCall);
INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallNothrow, AnyInvTestMovable,
                               TestParameterListRvalueQualifiersNothrowCall);

REGISTER_TYPED_TEST_SUITE_P(AnyInvTestNoexceptFalse,
                            ConversionConstructionConstraints,
                            ConversionAssignConstraints);

INSTANTIATE_TYPED_TEST_SUITE_P(
    NonRvalueCallMayThrow, AnyInvTestNoexceptFalse,
    TestParameterListNonRvalueQualifiersCallMayThrow);
INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallMayThrow, AnyInvTestNoexceptFalse,
                               TestParameterListRvalueQualifiersCallMayThrow);

INSTANTIATE_TYPED_TEST_SUITE_P(RemoteMovable, AnyInvTestNoexceptFalse,
                               TestParameterListRemoteMovable);
INSTANTIATE_TYPED_TEST_SUITE_P(RemoteNonMovable, AnyInvTestNoexceptFalse,
                               TestParameterListRemoteNonMovable);

INSTANTIATE_TYPED_TEST_SUITE_P(Local, AnyInvTestNoexceptFalse,
                               TestParameterListLocal);

REGISTER_TYPED_TEST_SUITE_P(AnyInvTestNoexceptTrue,
                            ConversionConstructionConstraints,
                            ConversionAssignConstraints);

INSTANTIATE_TYPED_TEST_SUITE_P(NonRvalueCallNothrow, AnyInvTestNoexceptTrue,
                               TestParameterListNonRvalueQualifiersNothrowCall);
INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallNothrow, AnyInvTestNoexceptTrue,
                               TestParameterListRvalueQualifiersNothrowCall);

REGISTER_TYPED_TEST_SUITE_P(AnyInvTestNonRvalue,
                            ConversionConstructionReferenceWrapper,
                            NonMoveableResultType,
                            ConversionAssignReferenceWrapperEmptyLhs,
                            ConversionAssignReferenceWrapperNonemptyLhs);

INSTANTIATE_TYPED_TEST_SUITE_P(
    NonRvalueCallMayThrow, AnyInvTestNonRvalue,
    TestParameterListNonRvalueQualifiersCallMayThrow);

INSTANTIATE_TYPED_TEST_SUITE_P(RemoteMovable, AnyInvTestNonRvalue,
                               TestParameterListRemoteMovable);
INSTANTIATE_TYPED_TEST_SUITE_P(RemoteNonMovable, AnyInvTestNonRvalue,
                               TestParameterListRemoteNonMovable);

INSTANTIATE_TYPED_TEST_SUITE_P(Local, AnyInvTestNonRvalue,
                               TestParameterListLocal);

INSTANTIATE_TYPED_TEST_SUITE_P(NonRvalueCallNothrow, AnyInvTestNonRvalue,
                               TestParameterListNonRvalueQualifiersNothrowCall);

REGISTER_TYPED_TEST_SUITE_P(AnyInvTestRvalue,
                            ConversionConstructionReferenceWrapper,
                            NonMoveableResultType,
                            ConversionAssignReferenceWrapper,
                            NonConstCrashesOnSecondCall,
                            QualifierIndependentObjectLifetime);

INSTANTIATE_TYPED_TEST_SUITE_P(RvalueCallMayThrow, AnyInvTestRvalue,
                               TestParameterListRvalueQualifiersCallMayThrow);

INSTANTIATE_TYPED_TEST_SUITE_P(CallNothrowRvalue, AnyInvTestRvalue,
                               TestParameterListRvalueQualifiersNothrowCall);

// Minimal SFINAE testing for platforms where we can't run the tests, but we can
// build binaries for.
static_assert(
    std::is_convertible<void (*)(), absl::AnyInvocable<void() &&>>::value, "");
static_assert(!std::is_convertible<void*, absl::AnyInvocable<void() &&>>::value,
              "");

#undef ABSL_INTERNAL_NOEXCEPT_SPEC

}  // namespace
                                                                                                                                                               node-23.7.0/deps/v8/third_party/abseil-cpp/absl/functional/bind_front.h                             0000664 0000000 0000000 00000016413 14746647661 0026002 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// -----------------------------------------------------------------------------
// File: bind_front.h
// -----------------------------------------------------------------------------
//
// `absl::bind_front()` returns a functor by binding a number of arguments to
// the front of a provided (usually more generic) functor. Unlike `std::bind`,
// it does not require the use of argument placeholders. The simpler syntax of
// `absl::bind_front()` allows you to avoid known misuses with `std::bind()`.
//
// `absl::bind_front()` is meant as a drop-in replacement for C++20's upcoming
// `std::bind_front()`, which similarly resolves these issues with
// `std::bind()`. Both `bind_front()` alternatives, unlike `std::bind()`, allow
// partial function application. (See
// https://en.wikipedia.org/wiki/Partial_application).

#ifndef ABSL_FUNCTIONAL_BIND_FRONT_H_
#define ABSL_FUNCTIONAL_BIND_FRONT_H_

#if defined(__cpp_lib_bind_front) && __cpp_lib_bind_front >= 201907L
#include <functional>  // For std::bind_front.
#endif  // defined(__cpp_lib_bind_front) && __cpp_lib_bind_front >= 201907L

#include <utility>

#include "absl/functional/internal/front_binder.h"
#include "absl/utility/utility.h"

namespace absl {
ABSL_NAMESPACE_BEGIN

// bind_front()
//
// Binds the first N arguments of an invocable object and stores them by value.
//
// Like `std::bind()`, `absl::bind_front()` is implicitly convertible to
// `std::function`.  In particular, it may be used as a simpler replacement for
// `std::bind()` in most cases, as it does not require placeholders to be
// specified. More importantly, it provides more reliable correctness guarantees
// than `std::bind()`; while `std::bind()` will silently ignore passing more
// parameters than expected, for example, `absl::bind_front()` will report such
// mis-uses as errors. In C++20, `absl::bind_front` is replaced by
// `std::bind_front`.
//
// absl::bind_front(a...) can be seen as storing the results of
// std::make_tuple(a...).
//
// Example: Binding a free function.
//
//   int Minus(int a, int b) { return a - b; }
//
//   assert(absl::bind_front(Minus)(3, 2) == 3 - 2);
//   assert(absl::bind_front(Minus, 3)(2) == 3 - 2);
//   assert(absl::bind_front(Minus, 3, 2)() == 3 - 2);
//
// Example: Binding a member function.
//
//   struct Math {
//     int Double(int a) const { return 2 * a; }
//   };
//
//   Math math;
//
//   assert(absl::bind_front(&Math::Double)(&math, 3) == 2 * 3);
//   // Stores a pointer to math inside the functor.
//   assert(absl::bind_front(&Math::Double, &math)(3) == 2 * 3);
//   // Stores a copy of math inside the functor.
//   assert(absl::bind_front(&Math::Double, math)(3) == 2 * 3);
//   // Stores std::unique_ptr<Math> inside the functor.
//   assert(absl::bind_front(&Math::Double,
//                           std::unique_ptr<Math>(new Math))(3) == 2 * 3);
//
// Example: Using `absl::bind_front()`, instead of `std::bind()`, with
//          `std::function`.
//
//   class FileReader {
//    public:
//     void ReadFileAsync(const std::string& filename, std::string* content,
//                        const std::function<void()>& done) {
//       // Calls Executor::Schedule(std::function<void()>).
//       Executor::DefaultExecutor()->Schedule(
//           absl::bind_front(&FileReader::BlockingRead, this,
//                            filename, content, done));
//     }
//
//    private:
//     void BlockingRead(const std::string& filename, std::string* content,
//                       const std::function<void()>& done) {
//       CHECK_OK(file::GetContents(filename, content, {}));
//       done();
//     }
//   };
//
// `absl::bind_front()` stores bound arguments explicitly using the type passed
// rather than implicitly based on the type accepted by its functor.
//
// Example: Binding arguments explicitly.
//
//   void LogStringView(absl::string_view sv) {
//     LOG(INFO) << sv;
//   }
//
//   Executor* e = Executor::DefaultExecutor();
//   std::string s = "hello";
//   absl::string_view sv = s;
//
//   // absl::bind_front(LogStringView, arg) makes a copy of arg and stores it.
//   e->Schedule(absl::bind_front(LogStringView, sv)); // ERROR: dangling
//                                                     // string_view.
//
//   e->Schedule(absl::bind_front(LogStringView, s));  // OK: stores a copy of
//                                                     // s.
//
// To store some of the arguments passed to `absl::bind_front()` by reference,
//  use std::ref()` and `std::cref()`.
//
// Example: Storing some of the bound arguments by reference.
//
//   class Service {
//    public:
//     void Serve(const Request& req, std::function<void()>* done) {
//       // The request protocol buffer won't be deleted until done is called.
//       // It's safe to store a reference to it inside the functor.
//       Executor::DefaultExecutor()->Schedule(
//           absl::bind_front(&Service::BlockingServe, this, std::cref(req),
//           done));
//     }
//
//    private:
//     void BlockingServe(const Request& req, std::function<void()>* done);
//   };
//
// Example: Storing bound arguments by reference.
//
//   void Print(const std::string& a, const std::string& b) {
//     std::cerr << a << b;
//   }
//
//   std::string hi = "Hello, ";
//   std::vector<std::string> names = {"Chuk", "Gek"};
//   // Doesn't copy hi.
//   for_each(names.begin(), names.end(),
//            absl::bind_front(Print, std::ref(hi)));
//
//   // DO NOT DO THIS: the functor may outlive "hi", resulting in
//   // dangling references.
//   foo->DoInFuture(absl::bind_front(Print, std::ref(hi), "Guest"));  // BAD!
//   auto f = absl::bind_front(Print, std::ref(hi), "Guest"); // BAD!
//
// Example: Storing reference-like types.
//
//   void Print(absl::string_view a, const std::string& b) {
//     std::cerr << a << b;
//   }
//
//   std::string hi = "Hello, ";
//   // Copies "hi".
//   absl::bind_front(Print, hi)("Chuk");
//
//   // Compile error: std::reference_wrapper<const string> is not implicitly
//   // convertible to string_view.
//   // absl::bind_front(Print, std::cref(hi))("Chuk");
//
//   // Doesn't copy "hi".
//   absl::bind_front(Print, absl::string_view(hi))("Chuk");
//
#if defined(__cpp_lib_bind_front) && __cpp_lib_bind_front >= 201907L
using std::bind_front;
#else   // defined(__cpp_lib_bind_front) && __cpp_lib_bind_front >= 201907L
template <class F, class... BoundArgs>
constexpr functional_internal::bind_front_t<F, BoundArgs...> bind_front(
    F&& func, BoundArgs&&... args) {
  return functional_internal::bind_front_t<F, BoundArgs...>(
      absl::in_place, std::forward<F>(func), std::forward<BoundArgs>(args)...);
}
#endif  // defined(__cpp_lib_bind_front) && __cpp_lib_bind_front >= 201907L

ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_FUNCTIONAL_BIND_FRONT_H_
                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/third_party/abseil-cpp/absl/functional/bind_front_test.cc                       0000664 0000000 0000000 00000015357 14746647661 0027205 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/functional/bind_front.h"

#include <stddef.h>

#include <functional>
#include <memory>
#include <string>

#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "absl/memory/memory.h"

namespace {

char CharAt(const char* s, size_t index) { return s[index]; }

TEST(BindTest, Basics) {
  EXPECT_EQ('C', absl::bind_front(CharAt)("ABC", 2));
  EXPECT_EQ('C', absl::bind_front(CharAt, "ABC")(2));
  EXPECT_EQ('C', absl::bind_front(CharAt, "ABC", 2)());
}

TEST(BindTest, Lambda) {
  auto lambda = [](int x, int y, int z) { return x + y + z; };
  EXPECT_EQ(6, absl::bind_front(lambda)(1, 2, 3));
  EXPECT_EQ(6, absl::bind_front(lambda, 1)(2, 3));
  EXPECT_EQ(6, absl::bind_front(lambda, 1, 2)(3));
  EXPECT_EQ(6, absl::bind_front(lambda, 1, 2, 3)());
}

struct Functor {
  std::string operator()() & { return "&"; }
  std::string operator()() const& { return "const&"; }
  std::string operator()() && { return "&&"; }
  std::string operator()() const&& { return "const&&"; }
};

TEST(BindTest, PerfectForwardingOfBoundArgs) {
  auto f = absl::bind_front(Functor());
  const auto& cf = f;
  EXPECT_EQ("&", f());
  EXPECT_EQ("const&", cf());
  EXPECT_EQ("&&", std::move(f)());
  EXPECT_EQ("const&&", std::move(cf)());
}

struct ArgDescribe {
  std::string operator()(int&) const { return "&"; }             // NOLINT
  std::string operator()(const int&) const { return "const&"; }  // NOLINT
  std::string operator()(int&&) const { return "&&"; }
  std::string operator()(const int&&) const { return "const&&"; }
};

TEST(BindTest, PerfectForwardingOfFreeArgs) {
  ArgDescribe f;
  int i;
  EXPECT_EQ("&", absl::bind_front(f)(static_cast<int&>(i)));
  EXPECT_EQ("const&", absl::bind_front(f)(static_cast<const int&>(i)));
  EXPECT_EQ("&&", absl::bind_front(f)(static_cast<int&&>(i)));
  EXPECT_EQ("const&&", absl::bind_front(f)(static_cast<const int&&>(i)));
}

struct NonCopyableFunctor {
  NonCopyableFunctor() = default;
  NonCopyableFunctor(const NonCopyableFunctor&) = delete;
  NonCopyableFunctor& operator=(const NonCopyableFunctor&) = delete;
  const NonCopyableFunctor* operator()() const { return this; }
};

TEST(BindTest, RefToFunctor) {
  // It won't copy/move the functor and use the original object.
  NonCopyableFunctor ncf;
  auto bound_ncf = absl::bind_front(std::ref(ncf));
  auto bound_ncf_copy = bound_ncf;
  EXPECT_EQ(&ncf, bound_ncf_copy());
}

struct Struct {
  std::string value;
};

TEST(BindTest, StoreByCopy) {
  Struct s = {"hello"};
  auto f = absl::bind_front(&Struct::value, s);
  auto g = f;
  EXPECT_EQ("hello", f());
  EXPECT_EQ("hello", g());
  EXPECT_NE(&s.value, &f());
  EXPECT_NE(&s.value, &g());
  EXPECT_NE(&g(), &f());
}

struct NonCopyable {
  explicit NonCopyable(const std::string& s) : value(s) {}
  NonCopyable(const NonCopyable&) = delete;
  NonCopyable& operator=(const NonCopyable&) = delete;

  std::string value;
};

const std::string& GetNonCopyableValue(const NonCopyable& n) { return n.value; }

TEST(BindTest, StoreByRef) {
  NonCopyable s("hello");
  auto f = absl::bind_front(&GetNonCopyableValue, std::ref(s));
  EXPECT_EQ("hello", f());
  EXPECT_EQ(&s.value, &f());
  auto g = std::move(f);  // NOLINT
  EXPECT_EQ("hello", g());
  EXPECT_EQ(&s.value, &g());
  s.value = "goodbye";
  EXPECT_EQ("goodbye", g());
}

TEST(BindTest, StoreByCRef) {
  NonCopyable s("hello");
  auto f = absl::bind_front(&GetNonCopyableValue, std::cref(s));
  EXPECT_EQ("hello", f());
  EXPECT_EQ(&s.value, &f());
  auto g = std::move(f);  // NOLINT
  EXPECT_EQ("hello", g());
  EXPECT_EQ(&s.value, &g());
  s.value = "goodbye";
  EXPECT_EQ("goodbye", g());
}

const std::string& GetNonCopyableValueByWrapper(
    std::reference_wrapper<NonCopyable> n) {
  return n.get().value;
}

TEST(BindTest, StoreByRefInvokeByWrapper) {
  NonCopyable s("hello");
  auto f = absl::bind_front(GetNonCopyableValueByWrapper, std::ref(s));
  EXPECT_EQ("hello", f());
  EXPECT_EQ(&s.value, &f());
  auto g = std::move(f);
  EXPECT_EQ("hello", g());
  EXPECT_EQ(&s.value, &g());
  s.value = "goodbye";
  EXPECT_EQ("goodbye", g());
}

TEST(BindTest, StoreByPointer) {
  NonCopyable s("hello");
  auto f = absl::bind_front(&NonCopyable::value, &s);
  EXPECT_EQ("hello", f());
  EXPECT_EQ(&s.value, &f());
  auto g = std::move(f);
  EXPECT_EQ("hello", g());
  EXPECT_EQ(&s.value, &g());
}

int Sink(std::unique_ptr<int> p) {
  return *p;
}

std::unique_ptr<int> Factory(int n) { return absl::make_unique<int>(n); }

TEST(BindTest, NonCopyableArg) {
  EXPECT_EQ(42, absl::bind_front(Sink)(absl::make_unique<int>(42)));
  EXPECT_EQ(42, absl::bind_front(Sink, absl::make_unique<int>(42))());
}

TEST(BindTest, NonCopyableResult) {
  EXPECT_THAT(absl::bind_front(Factory)(42), ::testing::Pointee(42));
  EXPECT_THAT(absl::bind_front(Factory, 42)(), ::testing::Pointee(42));
}

// is_copy_constructible<FalseCopyable<unique_ptr<T>> is true but an attempt to
// instantiate the copy constructor leads to a compile error. This is similar
// to how standard containers behave.
template <class T>
struct FalseCopyable {
  FalseCopyable() {}
  FalseCopyable(const FalseCopyable& other) : m(other.m) {}
  FalseCopyable(FalseCopyable&& other) : m(std::move(other.m)) {}
  T m;
};

int GetMember(FalseCopyable<std::unique_ptr<int>> x) { return *x.m; }

TEST(BindTest, WrappedMoveOnly) {
  FalseCopyable<std::unique_ptr<int>> x;
  x.m = absl::make_unique<int>(42);
  auto f = absl::bind_front(&GetMember, std::move(x));
  EXPECT_EQ(42, std::move(f)());
}

int Plus(int a, int b) { return a + b; }

TEST(BindTest, ConstExpr) {
  constexpr auto f = absl::bind_front(CharAt);
  EXPECT_EQ(f("ABC", 1), 'B');
  static constexpr int five = 5;
  constexpr auto plus5 = absl::bind_front(Plus, five);
  EXPECT_EQ(plus5(1), 6);

  // There seems to be a bug in MSVC dealing constexpr construction of
  // char[]. Notice 'plus5' above; 'int' works just fine.
#if !(defined(_MSC_VER) && _MSC_VER < 1910)
  static constexpr char data[] = "DEF";
  constexpr auto g = absl::bind_front(CharAt, data);
  EXPECT_EQ(g(1), 'E');
#endif
}

struct ManglingCall {
  int operator()(int, double, std::string) const { return 0; }
};

TEST(BindTest, Mangling) {
  // We just want to generate a particular instantiation to see its mangling.
  absl::bind_front(ManglingCall{}, 1, 3.3)("A");
}

}  // namespace
                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/functional/function_ref.h                           0000664 0000000 0000000 00000013723 14746647661 0026340 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// -----------------------------------------------------------------------------
// File: function_ref.h
// -----------------------------------------------------------------------------
//
// This header file defines the `absl::FunctionRef` type for holding a
// non-owning reference to an object of any invocable type. This function
// reference is typically most useful as a type-erased argument type for
// accepting function types that neither take ownership nor copy the type; using
// the reference type in this case avoids a copy and an allocation. Best
// practices of other non-owning reference-like objects (such as
// `absl::string_view`) apply here.
//
//  An `absl::FunctionRef` is similar in usage to a `std::function` but has the
//  following differences:
//
//  * It doesn't own the underlying object.
//  * It doesn't have a null or empty state.
//  * It never performs deep copies or allocations.
//  * It's much faster and cheaper to construct.
//  * It's trivially copyable and destructable.
//
// Generally, `absl::FunctionRef` should not be used as a return value, data
// member, or to initialize a `std::function`. Such usages will often lead to
// problematic lifetime issues. Once you convert something to an
// `absl::FunctionRef` you cannot make a deep copy later.
//
// This class is suitable for use wherever a "const std::function<>&"
// would be used without making a copy. ForEach functions and other versions of
// the visitor pattern are a good example of when this class should be used.
//
// This class is trivial to copy and should be passed by value.
#ifndef ABSL_FUNCTIONAL_FUNCTION_REF_H_
#define ABSL_FUNCTIONAL_FUNCTION_REF_H_

#include <cassert>
#include <functional>
#include <type_traits>

#include "absl/base/attributes.h"
#include "absl/functional/internal/function_ref.h"
#include "absl/meta/type_traits.h"

namespace absl {
ABSL_NAMESPACE_BEGIN

// FunctionRef
//
// Dummy class declaration to allow the partial specialization based on function
// types below.
template <typename T>
class FunctionRef;

// FunctionRef
//
// An `absl::FunctionRef` is a lightweight wrapper to any invocable object with
// a compatible signature. Generally, an `absl::FunctionRef` should only be used
// as an argument type and should be preferred as an argument over a const
// reference to a `std::function`. `absl::FunctionRef` itself does not allocate,
// although the wrapped invocable may.
//
// Example:
//
//   // The following function takes a function callback by const reference
//   bool Visitor(const std::function<void(my_proto&,
//                                         absl::string_view)>& callback);
//
//   // Assuming that the function is not stored or otherwise copied, it can be
//   // replaced by an `absl::FunctionRef`:
//   bool Visitor(absl::FunctionRef<void(my_proto&, absl::string_view)>
//                  callback);
//
// Note: the assignment operator within an `absl::FunctionRef` is intentionally
// deleted to prevent misuse; because the `absl::FunctionRef` does not own the
// underlying type, assignment likely indicates misuse.
template <typename R, typename... Args>
class FunctionRef<R(Args...)> {
 private:
  // Used to disable constructors for objects that are not compatible with the
  // signature of this FunctionRef.
  template <typename F,
            typename FR = absl::base_internal::invoke_result_t<F, Args&&...>>
  using EnableIfCompatible =
      typename std::enable_if<std::is_void<R>::value ||
                              std::is_convertible<FR, R>::value>::type;

 public:
  // Constructs a FunctionRef from any invocable type.
  template <typename F, typename = EnableIfCompatible<const F&>>
  // NOLINTNEXTLINE(runtime/explicit)
  FunctionRef(const F& f ABSL_ATTRIBUTE_LIFETIME_BOUND)
      : invoker_(&absl::functional_internal::InvokeObject<F, R, Args...>) {
    absl::functional_internal::AssertNonNull(f);
    ptr_.obj = &f;
  }

  // Overload for function pointers. This eliminates a level of indirection that
  // would happen if the above overload was used (it lets us store the pointer
  // instead of a pointer to a pointer).
  //
  // This overload is also used for references to functions, since references to
  // functions can decay to function pointers implicitly.
  template <
      typename F, typename = EnableIfCompatible<F*>,
      absl::functional_internal::EnableIf<absl::is_function<F>::value> = 0>
  FunctionRef(F* f)  // NOLINT(runtime/explicit)
      : invoker_(&absl::functional_internal::InvokeFunction<F*, R, Args...>) {
    assert(f != nullptr);
    ptr_.fun = reinterpret_cast<decltype(ptr_.fun)>(f);
  }

  // To help prevent subtle lifetime bugs, FunctionRef is not assignable.
  // Typically, it should only be used as an argument type.
  FunctionRef& operator=(const FunctionRef& rhs) = delete;
  FunctionRef(const FunctionRef& rhs) = default;

  // Call the underlying object.
  R operator()(Args... args) const {
    return invoker_(ptr_, std::forward<Args>(args)...);
  }

 private:
  absl::functional_internal::VoidPtr ptr_;
  absl::functional_internal::Invoker<R, Args...> invoker_;
};

// Allow const qualified function signatures. Since FunctionRef requires
// constness anyway we can just make this a no-op.
template <typename R, typename... Args>
class FunctionRef<R(Args...) const> : public FunctionRef<R(Args...)> {
 public:
  using FunctionRef<R(Args...)>::FunctionRef;
};

ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_FUNCTIONAL_FUNCTION_REF_H_
                                             node-23.7.0/deps/v8/third_party/abseil-cpp/absl/functional/function_ref_test.cc                     0000664 0000000 0000000 00000020367 14746647661 0027537 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/functional/function_ref.h"

#include <functional>
#include <memory>

#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "absl/container/internal/test_instance_tracker.h"
#include "absl/functional/any_invocable.h"
#include "absl/memory/memory.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace {

void RunFun(FunctionRef<void()> f) { f(); }

TEST(FunctionRefTest, Lambda) {
  bool ran = false;
  RunFun([&] { ran = true; });
  EXPECT_TRUE(ran);
}

int Function() { return 1337; }

TEST(FunctionRefTest, Function1) {
  FunctionRef<int()> ref(&Function);
  EXPECT_EQ(1337, ref());
}

TEST(FunctionRefTest, Function2) {
  FunctionRef<int()> ref(Function);
  EXPECT_EQ(1337, ref());
}

TEST(FunctionRefTest, ConstFunction) {
  FunctionRef<int() const> ref(Function);
  EXPECT_EQ(1337, ref());
}

int NoExceptFunction() noexcept { return 1337; }

// TODO(jdennett): Add a test for noexcept member functions.
TEST(FunctionRefTest, NoExceptFunction) {
  FunctionRef<int()> ref(NoExceptFunction);
  EXPECT_EQ(1337, ref());
}

TEST(FunctionRefTest, ForwardsArgs) {
  auto l = [](std::unique_ptr<int> i) { return *i; };
  FunctionRef<int(std::unique_ptr<int>)> ref(l);
  EXPECT_EQ(42, ref(absl::make_unique<int>(42)));
}

TEST(FunctionRef, ReturnMoveOnly) {
  auto l = [] { return absl::make_unique<int>(29); };
  FunctionRef<std::unique_ptr<int>()> ref(l);
  EXPECT_EQ(29, *ref());
}

TEST(FunctionRef, ManyArgs) {
  auto l = [](int a, int b, int c) { return a + b + c; };
  FunctionRef<int(int, int, int)> ref(l);
  EXPECT_EQ(6, ref(1, 2, 3));
}

TEST(FunctionRef, VoidResultFromNonVoidFunctor) {
  bool ran = false;
  auto l = [&]() -> int {
    ran = true;
    return 2;
  };
  FunctionRef<void()> ref(l);
  ref();
  EXPECT_TRUE(ran);
}

TEST(FunctionRef, CastFromDerived) {
  struct Base {};
  struct Derived : public Base {};

  Derived d;
  auto l1 = [&](Base* b) { EXPECT_EQ(&d, b); };
  FunctionRef<void(Derived*)> ref1(l1);
  ref1(&d);

  auto l2 = [&]() -> Derived* { return &d; };
  FunctionRef<Base*()> ref2(l2);
  EXPECT_EQ(&d, ref2());
}

TEST(FunctionRef, VoidResultFromNonVoidFuncton) {
  FunctionRef<void()> ref(Function);
  ref();
}

TEST(FunctionRef, MemberPtr) {
  struct S {
    int i;
  };

  S s{1100111};
  auto mem_ptr = &S::i;
  FunctionRef<int(const S& s)> ref(mem_ptr);
  EXPECT_EQ(1100111, ref(s));
}

TEST(FunctionRef, MemberFun) {
  struct S {
    int i;
    int get_i() const { return i; }
  };

  S s{22};
  auto mem_fun_ptr = &S::get_i;
  FunctionRef<int(const S& s)> ref(mem_fun_ptr);
  EXPECT_EQ(22, ref(s));
}

TEST(FunctionRef, MemberFunRefqualified) {
  struct S {
    int i;
    int get_i() && { return i; }
  };
  auto mem_fun_ptr = &S::get_i;
  S s{22};
  FunctionRef<int(S && s)> ref(mem_fun_ptr);
  EXPECT_EQ(22, ref(std::move(s)));
}

#if !defined(_WIN32) && defined(GTEST_HAS_DEATH_TEST)

TEST(FunctionRef, MemberFunRefqualifiedNull) {
  struct S {
    int i;
    int get_i() && { return i; }
  };
  auto mem_fun_ptr = &S::get_i;
  mem_fun_ptr = nullptr;
  EXPECT_DEBUG_DEATH({ FunctionRef<int(S && s)> ref(mem_fun_ptr); }, "");
}

TEST(FunctionRef, NullMemberPtrAssertFails) {
  struct S {
    int i;
  };
  using MemberPtr = int S::*;
  MemberPtr mem_ptr = nullptr;
  EXPECT_DEBUG_DEATH({ FunctionRef<int(const S& s)> ref(mem_ptr); }, "");
}

TEST(FunctionRef, NullStdFunctionAssertPasses) {
  std::function<void()> function = []() {};
  FunctionRef<void()> ref(function);
}

TEST(FunctionRef, NullStdFunctionAssertFails) {
  std::function<void()> function = nullptr;
  EXPECT_DEBUG_DEATH({ FunctionRef<void()> ref(function); }, "");
}

TEST(FunctionRef, NullAnyInvocableAssertPasses) {
  AnyInvocable<void() const> invocable = []() {};
  FunctionRef<void()> ref(invocable);
}
TEST(FunctionRef, NullAnyInvocableAssertFails) {
  AnyInvocable<void() const> invocable = nullptr;
  EXPECT_DEBUG_DEATH({ FunctionRef<void()> ref(invocable); }, "");
}

#endif  // GTEST_HAS_DEATH_TEST

TEST(FunctionRef, CopiesAndMovesPerPassByValue) {
  absl::test_internal::InstanceTracker tracker;
  absl::test_internal::CopyableMovableInstance instance(0);
  auto l = [](absl::test_internal::CopyableMovableInstance) {};
  FunctionRef<void(absl::test_internal::CopyableMovableInstance)> ref(l);
  ref(instance);
  EXPECT_EQ(tracker.copies(), 1);
  EXPECT_EQ(tracker.moves(), 1);
}

TEST(FunctionRef, CopiesAndMovesPerPassByRef) {
  absl::test_internal::InstanceTracker tracker;
  absl::test_internal::CopyableMovableInstance instance(0);
  auto l = [](const absl::test_internal::CopyableMovableInstance&) {};
  FunctionRef<void(const absl::test_internal::CopyableMovableInstance&)> ref(l);
  ref(instance);
  EXPECT_EQ(tracker.copies(), 0);
  EXPECT_EQ(tracker.moves(), 0);
}

TEST(FunctionRef, CopiesAndMovesPerPassByValueCallByMove) {
  absl::test_internal::InstanceTracker tracker;
  absl::test_internal::CopyableMovableInstance instance(0);
  auto l = [](absl::test_internal::CopyableMovableInstance) {};
  FunctionRef<void(absl::test_internal::CopyableMovableInstance)> ref(l);
  ref(std::move(instance));
  EXPECT_EQ(tracker.copies(), 0);
  EXPECT_EQ(tracker.moves(), 2);
}

TEST(FunctionRef, CopiesAndMovesPerPassByValueToRef) {
  absl::test_internal::InstanceTracker tracker;
  absl::test_internal::CopyableMovableInstance instance(0);
  auto l = [](const absl::test_internal::CopyableMovableInstance&) {};
  FunctionRef<void(absl::test_internal::CopyableMovableInstance)> ref(l);
  ref(std::move(instance));
  EXPECT_EQ(tracker.copies(), 0);
  EXPECT_EQ(tracker.moves(), 1);
}

TEST(FunctionRef, PassByValueTypes) {
  using absl::functional_internal::Invoker;
  using absl::functional_internal::VoidPtr;
  using absl::test_internal::CopyableMovableInstance;
  struct Trivial {
    void* p[2];
  };
  struct LargeTrivial {
    void* p[3];
  };

  static_assert(std::is_same<Invoker<void, int>, void (*)(VoidPtr, int)>::value,
                "Scalar types should be passed by value");
  static_assert(
      std::is_same<Invoker<void, Trivial>, void (*)(VoidPtr, Trivial)>::value,
      "Small trivial types should be passed by value");
  static_assert(std::is_same<Invoker<void, LargeTrivial>,
                             void (*)(VoidPtr, LargeTrivial &&)>::value,
                "Large trivial types should be passed by rvalue reference");
  static_assert(
      std::is_same<Invoker<void, CopyableMovableInstance>,
                   void (*)(VoidPtr, CopyableMovableInstance &&)>::value,
      "Types with copy/move ctor should be passed by rvalue reference");

  // References are passed as references.
  static_assert(
      std::is_same<Invoker<void, int&>, void (*)(VoidPtr, int&)>::value,
      "Reference types should be preserved");
  static_assert(
      std::is_same<Invoker<void, CopyableMovableInstance&>,
                   void (*)(VoidPtr, CopyableMovableInstance&)>::value,
      "Reference types should be preserved");
  static_assert(
      std::is_same<Invoker<void, CopyableMovableInstance&&>,
                   void (*)(VoidPtr, CopyableMovableInstance &&)>::value,
      "Reference types should be preserved");

  // Make sure the address of an object received by reference is the same as the
  // address of the object passed by the caller.
  {
    LargeTrivial obj;
    auto test = [&obj](LargeTrivial& input) { ASSERT_EQ(&input, &obj); };
    absl::FunctionRef<void(LargeTrivial&)> ref(test);
    ref(obj);
  }

  {
    Trivial obj;
    auto test = [&obj](Trivial& input) { ASSERT_EQ(&input, &obj); };
    absl::FunctionRef<void(Trivial&)> ref(test);
    ref(obj);
  }
}

TEST(FunctionRef, ReferenceToIncompleteType) {
  struct IncompleteType;
  auto test = [](IncompleteType&) {};
  absl::FunctionRef<void(IncompleteType&)> ref(test);

  struct IncompleteType {};
  IncompleteType obj;
  ref(obj);
}

}  // namespace
ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/third_party/abseil-cpp/absl/functional/function_type_benchmark.cc               0000664 0000000 0000000 00000013046 14746647661 0030713 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <functional>
#include <memory>
#include <string>

#include "benchmark/benchmark.h"
#include "absl/base/attributes.h"
#include "absl/functional/any_invocable.h"
#include "absl/functional/function_ref.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace {

int dummy = 0;

void FreeFunction() { benchmark::DoNotOptimize(dummy); }

struct TrivialFunctor {
  void operator()() const { benchmark::DoNotOptimize(dummy); }
};

struct LargeFunctor {
  void operator()() const { benchmark::DoNotOptimize(this); }
  std::string a, b, c;
};

template <typename Function, typename... Args>
void ABSL_ATTRIBUTE_NOINLINE CallFunction(Function f, Args&&... args) {
  f(std::forward<Args>(args)...);
}

template <typename Function, typename Callable, typename... Args>
void ConstructAndCallFunctionBenchmark(benchmark::State& state,
                                       const Callable& c, Args&&... args) {
  for (auto _ : state) {
    CallFunction<Function>(c, std::forward<Args>(args)...);
  }
}

void BM_TrivialStdFunction(benchmark::State& state) {
  ConstructAndCallFunctionBenchmark<std::function<void()>>(state,
                                                           TrivialFunctor{});
}
BENCHMARK(BM_TrivialStdFunction);

void BM_TrivialFunctionRef(benchmark::State& state) {
  ConstructAndCallFunctionBenchmark<FunctionRef<void()>>(state,
                                                         TrivialFunctor{});
}
BENCHMARK(BM_TrivialFunctionRef);

void BM_TrivialAnyInvocable(benchmark::State& state) {
  ConstructAndCallFunctionBenchmark<AnyInvocable<void()>>(state,
                                                          TrivialFunctor{});
}
BENCHMARK(BM_TrivialAnyInvocable);

void BM_LargeStdFunction(benchmark::State& state) {
  ConstructAndCallFunctionBenchmark<std::function<void()>>(state,
                                                           LargeFunctor{});
}
BENCHMARK(BM_LargeStdFunction);

void BM_LargeFunctionRef(benchmark::State& state) {
  ConstructAndCallFunctionBenchmark<FunctionRef<void()>>(state, LargeFunctor{});
}
BENCHMARK(BM_LargeFunctionRef);


void BM_LargeAnyInvocable(benchmark::State& state) {
  ConstructAndCallFunctionBenchmark<AnyInvocable<void()>>(state,
                                                          LargeFunctor{});
}
BENCHMARK(BM_LargeAnyInvocable);

void BM_FunPtrStdFunction(benchmark::State& state) {
  ConstructAndCallFunctionBenchmark<std::function<void()>>(state, FreeFunction);
}
BENCHMARK(BM_FunPtrStdFunction);

void BM_FunPtrFunctionRef(benchmark::State& state) {
  ConstructAndCallFunctionBenchmark<FunctionRef<void()>>(state, FreeFunction);
}
BENCHMARK(BM_FunPtrFunctionRef);

void BM_FunPtrAnyInvocable(benchmark::State& state) {
  ConstructAndCallFunctionBenchmark<AnyInvocable<void()>>(state, FreeFunction);
}
BENCHMARK(BM_FunPtrAnyInvocable);

// Doesn't include construction or copy overhead in the loop.
template <typename Function, typename Callable, typename... Args>
void CallFunctionBenchmark(benchmark::State& state, const Callable& c,
                           Args... args) {
  Function f = c;
  for (auto _ : state) {
    benchmark::DoNotOptimize(&f);
    f(args...);
  }
}

struct FunctorWithTrivialArgs {
  void operator()(int a, int b, int c) const {
    benchmark::DoNotOptimize(a);
    benchmark::DoNotOptimize(b);
    benchmark::DoNotOptimize(c);
  }
};

void BM_TrivialArgsStdFunction(benchmark::State& state) {
  CallFunctionBenchmark<std::function<void(int, int, int)>>(
      state, FunctorWithTrivialArgs{}, 1, 2, 3);
}
BENCHMARK(BM_TrivialArgsStdFunction);

void BM_TrivialArgsFunctionRef(benchmark::State& state) {
  CallFunctionBenchmark<FunctionRef<void(int, int, int)>>(
      state, FunctorWithTrivialArgs{}, 1, 2, 3);
}
BENCHMARK(BM_TrivialArgsFunctionRef);

void BM_TrivialArgsAnyInvocable(benchmark::State& state) {
  CallFunctionBenchmark<AnyInvocable<void(int, int, int)>>(
      state, FunctorWithTrivialArgs{}, 1, 2, 3);
}
BENCHMARK(BM_TrivialArgsAnyInvocable);

struct FunctorWithNonTrivialArgs {
  void operator()(std::string a, std::string b, std::string c) const {
    benchmark::DoNotOptimize(&a);
    benchmark::DoNotOptimize(&b);
    benchmark::DoNotOptimize(&c);
  }
};

void BM_NonTrivialArgsStdFunction(benchmark::State& state) {
  std::string a, b, c;
  CallFunctionBenchmark<
      std::function<void(std::string, std::string, std::string)>>(
      state, FunctorWithNonTrivialArgs{}, a, b, c);
}
BENCHMARK(BM_NonTrivialArgsStdFunction);

void BM_NonTrivialArgsFunctionRef(benchmark::State& state) {
  std::string a, b, c;
  CallFunctionBenchmark<
      FunctionRef<void(std::string, std::string, std::string)>>(
      state, FunctorWithNonTrivialArgs{}, a, b, c);
}
BENCHMARK(BM_NonTrivialArgsFunctionRef);

void BM_NonTrivialArgsAnyInvocable(benchmark::State& state) {
  std::string a, b, c;
  CallFunctionBenchmark<
      AnyInvocable<void(std::string, std::string, std::string)>>(
      state, FunctorWithNonTrivialArgs{}, a, b, c);
}
BENCHMARK(BM_NonTrivialArgsAnyInvocable);

}  // namespace
ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/third_party/abseil-cpp/absl/functional/internal/                                0000775 0000000 0000000 00000000000 14746647661 0025314 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/third_party/abseil-cpp/absl/functional/internal/any_invocable.h                 0000664 0000000 0000000 00000116375 14746647661 0030313 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2022 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Implementation details for `absl::AnyInvocable`

#ifndef ABSL_FUNCTIONAL_INTERNAL_ANY_INVOCABLE_H_
#define ABSL_FUNCTIONAL_INTERNAL_ANY_INVOCABLE_H_

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
// This implementation chooses between local storage and remote storage for   //
// the contained target object based on the target object's size, alignment   //
// requirements, and whether or not it has a nothrow move constructor.        //
// Additional optimizations are performed when the object is a trivially      //
// copyable type [basic.types].                                               //
//                                                                            //
// There are three datamembers per `AnyInvocable` instance                    //
//                                                                            //
// 1) A union containing either                                               //
//        - A pointer to the target object referred to via a void*, or        //
//        - the target object, emplaced into a raw char buffer                //
//                                                                            //
// 2) A function pointer to a "manager" function operation that takes a       //
//    discriminator and logically branches to either perform a move operation //
//    or destroy operation based on that discriminator.                       //
//                                                                            //
// 3) A function pointer to an "invoker" function operation that invokes the  //
//    target object, directly returning the result.                           //
//                                                                            //
// When in the logically empty state, the manager function is an empty        //
// function and the invoker function is one that would be undefined behavior  //
// to call.                                                                   //
//                                                                            //
// An additional optimization is performed when converting from one           //
// AnyInvocable to another where only the noexcept specification and/or the   //
// cv/ref qualifiers of the function type differ. In these cases, the         //
// conversion works by "moving the guts", similar to if they were the same    //
// exact type, as opposed to having to perform an additional layer of         //
// wrapping through remote storage.                                           //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

// IWYU pragma: private, include "absl/functional/any_invocable.h"

#include <cassert>
#include <cstddef>
#include <cstring>
#include <exception>
#include <functional>
#include <memory>
#include <new>
#include <type_traits>
#include <utility>

#include "absl/base/attributes.h"
#include "absl/base/config.h"
#include "absl/base/internal/invoke.h"
#include "absl/base/macros.h"
#include "absl/base/optimization.h"
#include "absl/meta/type_traits.h"
#include "absl/utility/utility.h"

namespace absl {
ABSL_NAMESPACE_BEGIN

// Helper macro used to prevent spelling `noexcept` in language versions older
// than C++17, where it is not part of the type system, in order to avoid
// compilation failures and internal compiler errors.
#if ABSL_INTERNAL_CPLUSPLUS_LANG >= 201703L
#define ABSL_INTERNAL_NOEXCEPT_SPEC(noex) noexcept(noex)
#else
#define ABSL_INTERNAL_NOEXCEPT_SPEC(noex)
#endif

// Defined in functional/any_invocable.h
template <class Sig>
class AnyInvocable;

namespace internal_any_invocable {

// Constants relating to the small-object-storage for AnyInvocable
enum StorageProperty : std::size_t {
  kAlignment = alignof(std::max_align_t),  // The alignment of the storage
  kStorageSize = sizeof(void*) * 2         // The size of the storage
};

////////////////////////////////////////////////////////////////////////////////
//
// A metafunction for checking if a type is an AnyInvocable instantiation.
// This is used during conversion operations.
template <class T>
struct IsAnyInvocable : std::false_type {};

template <class Sig>
struct IsAnyInvocable<AnyInvocable<Sig>> : std::true_type {};
//
////////////////////////////////////////////////////////////////////////////////

// A type trait that tells us whether or not a target function type should be
// stored locally in the small object optimization storage
template <class T>
using IsStoredLocally = std::integral_constant<
    bool, sizeof(T) <= kStorageSize && alignof(T) <= kAlignment &&
              kAlignment % alignof(T) == 0 &&
              std::is_nothrow_move_constructible<T>::value>;

// An implementation of std::remove_cvref_t of C++20.
template <class T>
using RemoveCVRef =
    typename std::remove_cv<typename std::remove_reference<T>::type>::type;

////////////////////////////////////////////////////////////////////////////////
//
// An implementation of the C++ standard INVOKE<R> pseudo-macro, operation is
// equivalent to std::invoke except that it forces an implicit conversion to the
// specified return type. If "R" is void, the function is executed and the
// return value is simply ignored.
template <class ReturnType, class F, class... P,
          typename = absl::enable_if_t<std::is_void<ReturnType>::value>>
void InvokeR(F&& f, P&&... args) {
  absl::base_internal::invoke(std::forward<F>(f), std::forward<P>(args)...);
}

template <class ReturnType, class F, class... P,
          absl::enable_if_t<!std::is_void<ReturnType>::value, int> = 0>
ReturnType InvokeR(F&& f, P&&... args) {
  // GCC 12 has a false-positive -Wmaybe-uninitialized warning here.
#if ABSL_INTERNAL_HAVE_MIN_GNUC_VERSION(12, 0)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wmaybe-uninitialized"
#endif
  return absl::base_internal::invoke(std::forward<F>(f),
                                     std::forward<P>(args)...);
#if ABSL_INTERNAL_HAVE_MIN_GNUC_VERSION(12, 0)
#pragma GCC diagnostic pop
#endif
}

//
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
///
// A metafunction that takes a "T" corresponding to a parameter type of the
// user's specified function type, and yields the parameter type to use for the
// type-erased invoker. In order to prevent observable moves, this must be
// either a reference or, if the type is trivial, the original parameter type
// itself. Since the parameter type may be incomplete at the point that this
// metafunction is used, we can only do this optimization for scalar types
// rather than for any trivial type.
template <typename T>
T ForwardImpl(std::true_type);

template <typename T>
T&& ForwardImpl(std::false_type);

// NOTE: We deliberately use an intermediate struct instead of a direct alias,
// as a workaround for b/206991861 on MSVC versions < 1924.
template <class T>
struct ForwardedParameter {
  using type = decltype((
      ForwardImpl<T>)(std::integral_constant<bool,
                                             std::is_scalar<T>::value>()));
};

template <class T>
using ForwardedParameterType = typename ForwardedParameter<T>::type;
//
////////////////////////////////////////////////////////////////////////////////

// A discriminator when calling the "manager" function that describes operation
// type-erased operation should be invoked.
//
// "relocate_from_to" specifies that the manager should perform a move.
//
// "dispose" specifies that the manager should perform a destroy.
enum class FunctionToCall : bool { relocate_from_to, dispose };

// The portion of `AnyInvocable` state that contains either a pointer to the
// target object or the object itself in local storage
union TypeErasedState {
  struct {
    // A pointer to the type-erased object when remotely stored
    void* target;
    // The size of the object for `RemoteManagerTrivial`
    std::size_t size;
  } remote;

  // Local-storage for the type-erased object when small and trivial enough
  alignas(kAlignment) char storage[kStorageSize];
};

// A typed accessor for the object in `TypeErasedState` storage
template <class T>
T& ObjectInLocalStorage(TypeErasedState* const state) {
  // We launder here because the storage may be reused with the same type.
#if defined(__cpp_lib_launder) && __cpp_lib_launder >= 201606L
  return *std::launder(reinterpret_cast<T*>(&state->storage));
#elif ABSL_HAVE_BUILTIN(__builtin_launder)
  return *__builtin_launder(reinterpret_cast<T*>(&state->storage));
#else

  // When `std::launder` or equivalent are not available, we rely on undefined
  // behavior, which works as intended on Abseil's officially supported
  // platforms as of Q2 2022.
#if !defined(__clang__) && defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif
  return *reinterpret_cast<T*>(&state->storage);
#if !defined(__clang__) && defined(__GNUC__)
#pragma GCC diagnostic pop
#endif

#endif
}

// The type for functions issuing lifetime-related operations: move and dispose
// A pointer to such a function is contained in each `AnyInvocable` instance.
// NOTE: When specifying `FunctionToCall::`dispose, the same state must be
// passed as both "from" and "to".
using ManagerType = void(FunctionToCall /*operation*/,
                         TypeErasedState* /*from*/, TypeErasedState* /*to*/)
    ABSL_INTERNAL_NOEXCEPT_SPEC(true);

// The type for functions issuing the actual invocation of the object
// A pointer to such a function is contained in each AnyInvocable instance.
template <bool SigIsNoexcept, class ReturnType, class... P>
using InvokerType = ReturnType(TypeErasedState*, ForwardedParameterType<P>...)
    ABSL_INTERNAL_NOEXCEPT_SPEC(SigIsNoexcept);

// The manager that is used when AnyInvocable is empty
inline void EmptyManager(FunctionToCall /*operation*/,
                         TypeErasedState* /*from*/,
                         TypeErasedState* /*to*/) noexcept {}

// The manager that is used when a target function is in local storage and is
// a trivially copyable type.
inline void LocalManagerTrivial(FunctionToCall /*operation*/,
                                TypeErasedState* const from,
                                TypeErasedState* const to) noexcept {
  // This single statement without branching handles both possible operations.
  //
  // For FunctionToCall::dispose, "from" and "to" point to the same state, and
  // so this assignment logically would do nothing.
  //
  // Note: Correctness here relies on http://wg21.link/p0593, which has only
  // become standard in C++20, though implementations do not break it in
  // practice for earlier versions of C++.
  //
  // The correct way to do this without that paper is to first placement-new a
  // default-constructed T in "to->storage" prior to the memmove, but doing so
  // requires a different function to be created for each T that is stored
  // locally, which can cause unnecessary bloat and be less cache friendly.
  *to = *from;

  // Note: Because the type is trivially copyable, the destructor does not need
  // to be called ("trivially copyable" requires a trivial destructor).
}

// The manager that is used when a target function is in local storage and is
// not a trivially copyable type.
template <class T>
void LocalManagerNontrivial(FunctionToCall operation,
                            TypeErasedState* const from,
                            TypeErasedState* const to) noexcept {
  static_assert(IsStoredLocally<T>::value,
                "Local storage must only be used for supported types.");
  static_assert(!std::is_trivially_copyable<T>::value,
                "Locally stored types must be trivially copyable.");

  T& from_object = (ObjectInLocalStorage<T>)(from);

  switch (operation) {
    case FunctionToCall::relocate_from_to:
      // NOTE: Requires that the left-hand operand is already empty.
      ::new (static_cast<void*>(&to->storage)) T(std::move(from_object));
      ABSL_FALLTHROUGH_INTENDED;
    case FunctionToCall::dispose:
      from_object.~T();  // Must not throw. // NOLINT
      return;
  }
  ABSL_UNREACHABLE();
}

// The invoker that is used when a target function is in local storage
// Note: QualTRef here is the target function type along with cv and reference
// qualifiers that must be used when calling the function.
template <bool SigIsNoexcept, class ReturnType, class QualTRef, class... P>
ReturnType LocalInvoker(
    TypeErasedState* const state,
    ForwardedParameterType<P>... args) noexcept(SigIsNoexcept) {
  using RawT = RemoveCVRef<QualTRef>;
  static_assert(
      IsStoredLocally<RawT>::value,
      "Target object must be in local storage in order to be invoked from it.");

  auto& f = (ObjectInLocalStorage<RawT>)(state);
  return (InvokeR<ReturnType>)(static_cast<QualTRef>(f),
                               static_cast<ForwardedParameterType<P>>(args)...);
}

// The manager that is used when a target function is in remote storage and it
// has a trivial destructor
inline void RemoteManagerTrivial(FunctionToCall operation,
                                 TypeErasedState* const from,
                                 TypeErasedState* const to) noexcept {
  switch (operation) {
    case FunctionToCall::relocate_from_to:
      // NOTE: Requires that the left-hand operand is already empty.
      to->remote = from->remote;
      return;
    case FunctionToCall::dispose:
#if defined(__cpp_sized_deallocation)
      ::operator delete(from->remote.target, from->remote.size);
#else   // __cpp_sized_deallocation
      ::operator delete(from->remote.target);
#endif  // __cpp_sized_deallocation
      return;
  }
  ABSL_UNREACHABLE();
}

// The manager that is used when a target function is in remote storage and the
// destructor of the type is not trivial
template <class T>
void RemoteManagerNontrivial(FunctionToCall operation,
                             TypeErasedState* const from,
                             TypeErasedState* const to) noexcept {
  static_assert(!IsStoredLocally<T>::value,
                "Remote storage must only be used for types that do not "
                "qualify for local storage.");

  switch (operation) {
    case FunctionToCall::relocate_from_to:
      // NOTE: Requires that the left-hand operand is already empty.
      to->remote.target = from->remote.target;
      return;
    case FunctionToCall::dispose:
      ::delete static_cast<T*>(from->remote.target);  // Must not throw.
      return;
  }
  ABSL_UNREACHABLE();
}

// The invoker that is used when a target function is in remote storage
template <bool SigIsNoexcept, class ReturnType, class QualTRef, class... P>
ReturnType RemoteInvoker(
    TypeErasedState* const state,
    ForwardedParameterType<P>... args) noexcept(SigIsNoexcept) {
  using RawT = RemoveCVRef<QualTRef>;
  static_assert(!IsStoredLocally<RawT>::value,
                "Target object must be in remote storage in order to be "
                "invoked from it.");

  auto& f = *static_cast<RawT*>(state->remote.target);
  return (InvokeR<ReturnType>)(static_cast<QualTRef>(f),
                               static_cast<ForwardedParameterType<P>>(args)...);
}

////////////////////////////////////////////////////////////////////////////////
//
// A metafunction that checks if a type T is an instantiation of
// absl::in_place_type_t (needed for constructor constraints of AnyInvocable).
template <class T>
struct IsInPlaceType : std::false_type {};

template <class T>
struct IsInPlaceType<absl::in_place_type_t<T>> : std::true_type {};
//
////////////////////////////////////////////////////////////////////////////////

// A constructor name-tag used with CoreImpl (below) to request the
// conversion-constructor. QualDecayedTRef is the decayed-type of the object to
// wrap, along with the cv and reference qualifiers that must be applied when
// performing an invocation of the wrapped object.
template <class QualDecayedTRef>
struct TypedConversionConstruct {};

// A helper base class for all core operations of AnyInvocable. Most notably,
// this class creates the function call operator and constraint-checkers so that
// the top-level class does not have to be a series of partial specializations.
//
// Note: This definition exists (as opposed to being a declaration) so that if
// the user of the top-level template accidentally passes a template argument
// that is not a function type, they will get a static_assert in AnyInvocable's
// class body rather than an error stating that Impl is not defined.
template <class Sig>
class Impl {};  // Note: This is partially-specialized later.

// A std::unique_ptr deleter that deletes memory allocated via ::operator new.
#if defined(__cpp_sized_deallocation)
class TrivialDeleter {
 public:
  explicit TrivialDeleter(std::size_t size) : size_(size) {}

  void operator()(void* target) const {
    ::operator delete(target, size_);
  }

 private:
  std::size_t size_;
};
#else   // __cpp_sized_deallocation
class TrivialDeleter {
 public:
  explicit TrivialDeleter(std::size_t) {}

  void operator()(void* target) const { ::operator delete(target); }
};
#endif  // __cpp_sized_deallocation

template <bool SigIsNoexcept, class ReturnType, class... P>
class CoreImpl;

constexpr bool IsCompatibleConversion(void*, void*) { return false; }
template <bool NoExceptSrc, bool NoExceptDest, class... T>
constexpr bool IsCompatibleConversion(CoreImpl<NoExceptSrc, T...>*,
                                      CoreImpl<NoExceptDest, T...>*) {
  return !NoExceptDest || NoExceptSrc;
}

// A helper base class for all core operations of AnyInvocable that do not
// depend on the cv/ref qualifiers of the function type.
template <bool SigIsNoexcept, class ReturnType, class... P>
class CoreImpl {
 public:
  using result_type = ReturnType;

  CoreImpl() noexcept : manager_(EmptyManager), invoker_(nullptr) {}

  enum class TargetType {
    kPointer,
    kCompatibleAnyInvocable,
    kIncompatibleAnyInvocable,
    kOther,
  };

  // Note: QualDecayedTRef here includes the cv-ref qualifiers associated with
  // the invocation of the Invocable. The unqualified type is the target object
  // type to be stored.
  template <class QualDecayedTRef, class F>
  explicit CoreImpl(TypedConversionConstruct<QualDecayedTRef>, F&& f) {
    using DecayedT = RemoveCVRef<QualDecayedTRef>;

    constexpr TargetType kTargetType =
        (std::is_pointer<DecayedT>::value ||
         std::is_member_pointer<DecayedT>::value)
            ? TargetType::kPointer
        : IsCompatibleAnyInvocable<DecayedT>::value
            ? TargetType::kCompatibleAnyInvocable
        : IsAnyInvocable<DecayedT>::value
            ? TargetType::kIncompatibleAnyInvocable
            : TargetType::kOther;
    // NOTE: We only use integers instead of enums as template parameters in
    // order to work around a bug on C++14 under MSVC 2017.
    // See b/236131881.
    Initialize<kTargetType, QualDecayedTRef>(std::forward<F>(f));
  }

  // Note: QualTRef here includes the cv-ref qualifiers associated with the
  // invocation of the Invocable. The unqualified type is the target object
  // type to be stored.
  template <class QualTRef, class... Args>
  explicit CoreImpl(absl::in_place_type_t<QualTRef>, Args&&... args) {
    InitializeStorage<QualTRef>(std::forward<Args>(args)...);
  }

  CoreImpl(CoreImpl&& other) noexcept {
    other.manager_(FunctionToCall::relocate_from_to, &other.state_, &state_);
    manager_ = other.manager_;
    invoker_ = other.invoker_;
    other.manager_ = EmptyManager;
    other.invoker_ = nullptr;
  }

  CoreImpl& operator=(CoreImpl&& other) noexcept {
    // Put the left-hand operand in an empty state.
    //
    // Note: A full reset that leaves us with an object that has its invariants
    // intact is necessary in order to handle self-move. This is required by
    // types that are used with certain operations of the standard library, such
    // as the default definition of std::swap when both operands target the same
    // object.
    Clear();

    // Perform the actual move/destroy operation on the target function.
    other.manager_(FunctionToCall::relocate_from_to, &other.state_, &state_);
    manager_ = other.manager_;
    invoker_ = other.invoker_;
    other.manager_ = EmptyManager;
    other.invoker_ = nullptr;

    return *this;
  }

  ~CoreImpl() { manager_(FunctionToCall::dispose, &state_, &state_); }

  // Check whether or not the AnyInvocable is in the empty state.
  bool HasValue() const { return invoker_ != nullptr; }

  // Effects: Puts the object into its empty state.
  void Clear() {
    manager_(FunctionToCall::dispose, &state_, &state_);
    manager_ = EmptyManager;
    invoker_ = nullptr;
  }

  template <TargetType target_type, class QualDecayedTRef, class F,
            absl::enable_if_t<target_type == TargetType::kPointer, int> = 0>
  void Initialize(F&& f) {
// This condition handles types that decay into pointers, which includes
// function references. Since function references cannot be null, GCC warns
// against comparing their decayed form with nullptr.
// Since this is template-heavy code, we prefer to disable these warnings
// locally instead of adding yet another overload of this function.
#if !defined(__clang__) && defined(__GNUC__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wpragmas"
#pragma GCC diagnostic ignored "-Waddress"
#pragma GCC diagnostic ignored "-Wnonnull-compare"
#endif
    if (static_cast<RemoveCVRef<QualDecayedTRef>>(f) == nullptr) {
#if !defined(__clang__) && defined(__GNUC__)
#pragma GCC diagnostic pop
#endif
      manager_ = EmptyManager;
      invoker_ = nullptr;
      return;
    }
    InitializeStorage<QualDecayedTRef>(std::forward<F>(f));
  }

  template <TargetType target_type, class QualDecayedTRef, class F,
            absl::enable_if_t<
                target_type == TargetType::kCompatibleAnyInvocable, int> = 0>
  void Initialize(F&& f) {
    // In this case we can "steal the guts" of the other AnyInvocable.
    f.manager_(FunctionToCall::relocate_from_to, &f.state_, &state_);
    manager_ = f.manager_;
    invoker_ = f.invoker_;

    f.manager_ = EmptyManager;
    f.invoker_ = nullptr;
  }

  template <TargetType target_type, class QualDecayedTRef, class F,
            absl::enable_if_t<
                target_type == TargetType::kIncompatibleAnyInvocable, int> = 0>
  void Initialize(F&& f) {
    if (f.HasValue()) {
      InitializeStorage<QualDecayedTRef>(std::forward<F>(f));
    } else {
      manager_ = EmptyManager;
      invoker_ = nullptr;
    }
  }

  template <TargetType target_type, class QualDecayedTRef, class F,
            typename = absl::enable_if_t<target_type == TargetType::kOther>>
  void Initialize(F&& f) {
    InitializeStorage<QualDecayedTRef>(std::forward<F>(f));
  }

  // Use local (inline) storage for applicable target object types.
  template <class QualTRef, class... Args,
            typename = absl::enable_if_t<
                IsStoredLocally<RemoveCVRef<QualTRef>>::value>>
  void InitializeStorage(Args&&... args) {
    using RawT = RemoveCVRef<QualTRef>;
    ::new (static_cast<void*>(&state_.storage))
        RawT(std::forward<Args>(args)...);

    invoker_ = LocalInvoker<SigIsNoexcept, ReturnType, QualTRef, P...>;
    // We can simplify our manager if we know the type is trivially copyable.
    InitializeLocalManager<RawT>();
  }

  // Use remote storage for target objects that cannot be stored locally.
  template <class QualTRef, class... Args,
            absl::enable_if_t<!IsStoredLocally<RemoveCVRef<QualTRef>>::value,
                              int> = 0>
  void InitializeStorage(Args&&... args) {
    InitializeRemoteManager<RemoveCVRef<QualTRef>>(std::forward<Args>(args)...);
    // This is set after everything else in case an exception is thrown in an
    // earlier step of the initialization.
    invoker_ = RemoteInvoker<SigIsNoexcept, ReturnType, QualTRef, P...>;
  }

  template <class T,
            typename = absl::enable_if_t<std::is_trivially_copyable<T>::value>>
  void InitializeLocalManager() {
    manager_ = LocalManagerTrivial;
  }

  template <class T,
            absl::enable_if_t<!std::is_trivially_copyable<T>::value, int> = 0>
  void InitializeLocalManager() {
    manager_ = LocalManagerNontrivial<T>;
  }

  template <class T>
  using HasTrivialRemoteStorage =
      std::integral_constant<bool, std::is_trivially_destructible<T>::value &&
                                       alignof(T) <=
                                           ABSL_INTERNAL_DEFAULT_NEW_ALIGNMENT>;

  template <class T, class... Args,
            typename = absl::enable_if_t<HasTrivialRemoteStorage<T>::value>>
  void InitializeRemoteManager(Args&&... args) {
    // unique_ptr is used for exception-safety in case construction throws.
    std::unique_ptr<void, TrivialDeleter> uninitialized_target(
        ::operator new(sizeof(T)), TrivialDeleter(sizeof(T)));
    ::new (uninitialized_target.get()) T(std::forward<Args>(args)...);
    state_.remote.target = uninitialized_target.release();
    state_.remote.size = sizeof(T);
    manager_ = RemoteManagerTrivial;
  }

  template <class T, class... Args,
            absl::enable_if_t<!HasTrivialRemoteStorage<T>::value, int> = 0>
  void InitializeRemoteManager(Args&&... args) {
    state_.remote.target = ::new T(std::forward<Args>(args)...);
    manager_ = RemoteManagerNontrivial<T>;
  }

  //////////////////////////////////////////////////////////////////////////////
  //
  // Type trait to determine if the template argument is an AnyInvocable whose
  // function type is compatible enough with ours such that we can
  // "move the guts" out of it when moving, rather than having to place a new
  // object into remote storage.

  template <typename Other>
  struct IsCompatibleAnyInvocable {
    static constexpr bool value = false;
  };

  template <typename Sig>
  struct IsCompatibleAnyInvocable<AnyInvocable<Sig>> {
    static constexpr bool value =
        (IsCompatibleConversion)(static_cast<
                                     typename AnyInvocable<Sig>::CoreImpl*>(
                                     nullptr),
                                 static_cast<CoreImpl*>(nullptr));
  };

  //
  //////////////////////////////////////////////////////////////////////////////

  TypeErasedState state_;
  ManagerType* manager_;
  InvokerType<SigIsNoexcept, ReturnType, P...>* invoker_;
};

// A constructor name-tag used with Impl to request the
// conversion-constructor
struct ConversionConstruct {};

////////////////////////////////////////////////////////////////////////////////
//
// A metafunction that is normally an identity metafunction except that when
// given a std::reference_wrapper<T>, it yields T&. This is necessary because
// currently std::reference_wrapper's operator() is not conditionally noexcept,
// so when checking if such an Invocable is nothrow-invocable, we must pull out
// the underlying type.
template <class T>
struct UnwrapStdReferenceWrapperImpl {
  using type = T;
};

template <class T>
struct UnwrapStdReferenceWrapperImpl<std::reference_wrapper<T>> {
  using type = T&;
};

template <class T>
using UnwrapStdReferenceWrapper =
    typename UnwrapStdReferenceWrapperImpl<T>::type;
//
////////////////////////////////////////////////////////////////////////////////

// An alias that always yields std::true_type (used with constraints) where
// substitution failures happen when forming the template arguments.
template <class... T>
using TrueAlias =
    std::integral_constant<bool, sizeof(absl::void_t<T...>*) != 0>;

/*SFINAE constraints for the conversion-constructor.*/
template <class Sig, class F,
          class = absl::enable_if_t<
              !std::is_same<RemoveCVRef<F>, AnyInvocable<Sig>>::value>>
using CanConvert = TrueAlias<
    absl::enable_if_t<!IsInPlaceType<RemoveCVRef<F>>::value>,
    absl::enable_if_t<Impl<Sig>::template CallIsValid<F>::value>,
    absl::enable_if_t<
        Impl<Sig>::template CallIsNoexceptIfSigIsNoexcept<F>::value>,
    absl::enable_if_t<std::is_constructible<absl::decay_t<F>, F>::value>>;

/*SFINAE constraints for the std::in_place constructors.*/
template <class Sig, class F, class... Args>
using CanEmplace = TrueAlias<
    absl::enable_if_t<Impl<Sig>::template CallIsValid<F>::value>,
    absl::enable_if_t<
        Impl<Sig>::template CallIsNoexceptIfSigIsNoexcept<F>::value>,
    absl::enable_if_t<std::is_constructible<absl::decay_t<F>, Args...>::value>>;

/*SFINAE constraints for the conversion-assign operator.*/
template <class Sig, class F,
          class = absl::enable_if_t<
              !std::is_same<RemoveCVRef<F>, AnyInvocable<Sig>>::value>>
using CanAssign = TrueAlias<
    absl::enable_if_t<Impl<Sig>::template CallIsValid<F>::value>,
    absl::enable_if_t<
        Impl<Sig>::template CallIsNoexceptIfSigIsNoexcept<F>::value>,
    absl::enable_if_t<std::is_constructible<absl::decay_t<F>, F>::value>>;

/*SFINAE constraints for the reference-wrapper conversion-assign operator.*/
template <class Sig, class F>
using CanAssignReferenceWrapper = TrueAlias<
    absl::enable_if_t<
        Impl<Sig>::template CallIsValid<std::reference_wrapper<F>>::value>,
    absl::enable_if_t<Impl<Sig>::template CallIsNoexceptIfSigIsNoexcept<
        std::reference_wrapper<F>>::value>>;

////////////////////////////////////////////////////////////////////////////////
//
// The constraint for checking whether or not a call meets the noexcept
// callability requirements. This is a preprocessor macro because specifying it
// this way as opposed to a disjunction/branch can improve the user-side error
// messages and avoids an instantiation of std::is_nothrow_invocable_r in the
// cases where the user did not specify a noexcept function type.
//
#define ABSL_INTERNAL_ANY_INVOCABLE_NOEXCEPT_CONSTRAINT(inv_quals, noex) \
  ABSL_INTERNAL_ANY_INVOCABLE_NOEXCEPT_CONSTRAINT_##noex(inv_quals)

// The disjunction below is because we can't rely on std::is_nothrow_invocable_r
// to give the right result when ReturnType is non-moveable in toolchains that
// don't treat non-moveable result types correctly. For example this was the
// case in libc++ before commit c3a24882 (2022-05).
#define ABSL_INTERNAL_ANY_INVOCABLE_NOEXCEPT_CONSTRAINT_true(inv_quals)      \
  absl::enable_if_t<absl::disjunction<                                       \
      std::is_nothrow_invocable_r<                                           \
          ReturnType, UnwrapStdReferenceWrapper<absl::decay_t<F>> inv_quals, \
          P...>,                                                             \
      std::conjunction<                                                      \
          std::is_nothrow_invocable<                                         \
              UnwrapStdReferenceWrapper<absl::decay_t<F>> inv_quals, P...>,  \
          std::is_same<                                                      \
              ReturnType,                                                    \
              absl::base_internal::invoke_result_t<                          \
                  UnwrapStdReferenceWrapper<absl::decay_t<F>> inv_quals,     \
                  P...>>>>::value>

#define ABSL_INTERNAL_ANY_INVOCABLE_NOEXCEPT_CONSTRAINT_false(inv_quals)
//
////////////////////////////////////////////////////////////////////////////////

// A macro to generate partial specializations of Impl with the different
// combinations of supported cv/reference qualifiers and noexcept specifier.
//
// Here, `cv` are the cv-qualifiers if any, `ref` is the ref-qualifier if any,
// inv_quals is the reference type to be used when invoking the target, and
// noex is "true" if the function type is noexcept, or false if it is not.
//
// The CallIsValid condition is more complicated than simply using
// absl::base_internal::is_invocable_r because we can't rely on it to give the
// right result when ReturnType is non-moveable in toolchains that don't treat
// non-moveable result types correctly. For example this was the case in libc++
// before commit c3a24882 (2022-05).
#define ABSL_INTERNAL_ANY_INVOCABLE_IMPL_(cv, ref, inv_quals, noex)            \
  template <class ReturnType, class... P>                                      \
  class Impl<ReturnType(P...) cv ref ABSL_INTERNAL_NOEXCEPT_SPEC(noex)>        \
      : public CoreImpl<noex, ReturnType, P...> {                              \
   public:                                                                     \
    /*The base class, which contains the datamembers and core operations*/     \
    using Core = CoreImpl<noex, ReturnType, P...>;                             \
                                                                               \
    /*SFINAE constraint to check if F is invocable with the proper signature*/ \
    template <class F>                                                         \
    using CallIsValid = TrueAlias<absl::enable_if_t<absl::disjunction<         \
        absl::base_internal::is_invocable_r<ReturnType,                        \
                                            absl::decay_t<F> inv_quals, P...>, \
        std::is_same<ReturnType,                                               \
                     absl::base_internal::invoke_result_t<                     \
                         absl::decay_t<F> inv_quals, P...>>>::value>>;         \
                                                                               \
    /*SFINAE constraint to check if F is nothrow-invocable when necessary*/    \
    template <class F>                                                         \
    using CallIsNoexceptIfSigIsNoexcept =                                      \
        TrueAlias<ABSL_INTERNAL_ANY_INVOCABLE_NOEXCEPT_CONSTRAINT(inv_quals,   \
                                                                  noex)>;      \
                                                                               \
    /*Put the AnyInvocable into an empty state.*/                              \
    Impl() = default;                                                          \
                                                                               \
    /*The implementation of a conversion-constructor from "f*/                 \
    /*This forwards to Core, attaching inv_quals so that the base class*/      \
    /*knows how to properly type-erase the invocation.*/                       \
    template <class F>                                                         \
    explicit Impl(ConversionConstruct, F&& f)                                  \
        : Core(TypedConversionConstruct<                                       \
                   typename std::decay<F>::type inv_quals>(),                  \
               std::forward<F>(f)) {}                                          \
                                                                               \
    /*Forward along the in-place construction parameters.*/                    \
    template <class T, class... Args>                                          \
    explicit Impl(absl::in_place_type_t<T>, Args&&... args)                    \
        : Core(absl::in_place_type<absl::decay_t<T> inv_quals>,                \
               std::forward<Args>(args)...) {}                                 \
                                                                               \
    /*Raises a fatal error when the AnyInvocable is invoked after a move*/     \
    static ReturnType InvokedAfterMove(                                        \
      TypeErasedState*,                                                        \
      ForwardedParameterType<P>...) noexcept(noex) {                           \
      ABSL_HARDENING_ASSERT(false && "AnyInvocable use-after-move");           \
      std::terminate();                                                        \
    }                                                                          \
                                                                               \
    InvokerType<noex, ReturnType, P...>* ExtractInvoker() cv {                 \
      using QualifiedTestType = int cv ref;                                    \
      auto* invoker = this->invoker_;                                          \
      if (!std::is_const<QualifiedTestType>::value &&                          \
          std::is_rvalue_reference<QualifiedTestType>::value) {                \
        ABSL_ASSERT([this]() {                                                 \
          /* We checked that this isn't const above, so const_cast is safe */  \
          const_cast<Impl*>(this)->invoker_ = InvokedAfterMove;                \
          return this->HasValue();                                             \
        }());                                                                  \
      }                                                                        \
      return invoker;                                                          \
    }                                                                          \
                                                                               \
    /*The actual invocation operation with the proper signature*/              \
    ReturnType operator()(P... args) cv ref noexcept(noex) {                   \
      assert(this->invoker_ != nullptr);                                       \
      return this->ExtractInvoker()(                                           \
          const_cast<TypeErasedState*>(&this->state_),                         \
          static_cast<ForwardedParameterType<P>>(args)...);                    \
    }                                                                          \
  }

// Define the `noexcept(true)` specialization only for C++17 and beyond, when
// `noexcept` is part of the type system.
#if ABSL_INTERNAL_CPLUSPLUS_LANG >= 201703L
// A convenience macro that defines specializations for the noexcept(true) and
// noexcept(false) forms, given the other properties.
#define ABSL_INTERNAL_ANY_INVOCABLE_IMPL(cv, ref, inv_quals)    \
  ABSL_INTERNAL_ANY_INVOCABLE_IMPL_(cv, ref, inv_quals, false); \
  ABSL_INTERNAL_ANY_INVOCABLE_IMPL_(cv, ref, inv_quals, true)
#else
#define ABSL_INTERNAL_ANY_INVOCABLE_IMPL(cv, ref, inv_quals) \
  ABSL_INTERNAL_ANY_INVOCABLE_IMPL_(cv, ref, inv_quals, false)
#endif

// Non-ref-qualified partial specializations
ABSL_INTERNAL_ANY_INVOCABLE_IMPL(, , &);
ABSL_INTERNAL_ANY_INVOCABLE_IMPL(const, , const&);

// Lvalue-ref-qualified partial specializations
ABSL_INTERNAL_ANY_INVOCABLE_IMPL(, &, &);
ABSL_INTERNAL_ANY_INVOCABLE_IMPL(const, &, const&);

// Rvalue-ref-qualified partial specializations
ABSL_INTERNAL_ANY_INVOCABLE_IMPL(, &&, &&);
ABSL_INTERNAL_ANY_INVOCABLE_IMPL(const, &&, const&&);

// Undef the detail-only macros.
#undef ABSL_INTERNAL_ANY_INVOCABLE_IMPL
#undef ABSL_INTERNAL_ANY_INVOCABLE_IMPL_
#undef ABSL_INTERNAL_ANY_INVOCABLE_NOEXCEPT_CONSTRAINT_false
#undef ABSL_INTERNAL_ANY_INVOCABLE_NOEXCEPT_CONSTRAINT_true
#undef ABSL_INTERNAL_ANY_INVOCABLE_NOEXCEPT_CONSTRAINT
#undef ABSL_INTERNAL_NOEXCEPT_SPEC

}  // namespace internal_any_invocable
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_FUNCTIONAL_INTERNAL_ANY_INVOCABLE_H_
                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/third_party/abseil-cpp/absl/functional/internal/front_binder.h                  0000664 0000000 0000000 00000007134 14746647661 0030145 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Implementation details for `absl::bind_front()`.

#ifndef ABSL_FUNCTIONAL_INTERNAL_FRONT_BINDER_H_
#define ABSL_FUNCTIONAL_INTERNAL_FRONT_BINDER_H_

#include <cstddef>
#include <type_traits>
#include <utility>

#include "absl/base/internal/invoke.h"
#include "absl/container/internal/compressed_tuple.h"
#include "absl/meta/type_traits.h"
#include "absl/utility/utility.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace functional_internal {

// Invoke the method, expanding the tuple of bound arguments.
template <class R, class Tuple, size_t... Idx, class... Args>
R Apply(Tuple&& bound, absl::index_sequence<Idx...>, Args&&... free) {
  return base_internal::invoke(
      std::forward<Tuple>(bound).template get<Idx>()...,
      std::forward<Args>(free)...);
}

template <class F, class... BoundArgs>
class FrontBinder {
  using BoundArgsT = absl::container_internal::CompressedTuple<F, BoundArgs...>;
  using Idx = absl::make_index_sequence<sizeof...(BoundArgs) + 1>;

  BoundArgsT bound_args_;

 public:
  template <class... Ts>
  constexpr explicit FrontBinder(absl::in_place_t, Ts&&... ts)
      : bound_args_(std::forward<Ts>(ts)...) {}

  template <class... FreeArgs, class R = base_internal::invoke_result_t<
                                   F&, BoundArgs&..., FreeArgs&&...>>
  R operator()(FreeArgs&&... free_args) & {
    return functional_internal::Apply<R>(bound_args_, Idx(),
                                         std::forward<FreeArgs>(free_args)...);
  }

  template <class... FreeArgs,
            class R = base_internal::invoke_result_t<
                const F&, const BoundArgs&..., FreeArgs&&...>>
  R operator()(FreeArgs&&... free_args) const& {
    return functional_internal::Apply<R>(bound_args_, Idx(),
                                         std::forward<FreeArgs>(free_args)...);
  }

  template <class... FreeArgs, class R = base_internal::invoke_result_t<
                                   F&&, BoundArgs&&..., FreeArgs&&...>>
  R operator()(FreeArgs&&... free_args) && {
    // This overload is called when *this is an rvalue. If some of the bound
    // arguments are stored by value or rvalue reference, we move them.
    return functional_internal::Apply<R>(std::move(bound_args_), Idx(),
                                         std::forward<FreeArgs>(free_args)...);
  }

  template <class... FreeArgs,
            class R = base_internal::invoke_result_t<
                const F&&, const BoundArgs&&..., FreeArgs&&...>>
  R operator()(FreeArgs&&... free_args) const&& {
    // This overload is called when *this is an rvalue. If some of the bound
    // arguments are stored by value or rvalue reference, we move them.
    return functional_internal::Apply<R>(std::move(bound_args_), Idx(),
                                         std::forward<FreeArgs>(free_args)...);
  }
};

template <class F, class... BoundArgs>
using bind_front_t = FrontBinder<decay_t<F>, absl::decay_t<BoundArgs>...>;

}  // namespace functional_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_FUNCTIONAL_INTERNAL_FRONT_BINDER_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/third_party/abseil-cpp/absl/functional/internal/function_ref.h                  0000664 0000000 0000000 00000007753 14746647661 0030162 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2019 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef ABSL_FUNCTIONAL_INTERNAL_FUNCTION_REF_H_
#define ABSL_FUNCTIONAL_INTERNAL_FUNCTION_REF_H_

#include <cassert>
#include <functional>
#include <type_traits>

#include "absl/base/internal/invoke.h"
#include "absl/functional/any_invocable.h"
#include "absl/meta/type_traits.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace functional_internal {

// Like a void* that can handle function pointers as well. The standard does not
// allow function pointers to round-trip through void*, but void(*)() is fine.
//
// Note: It's important that this class remains trivial and is the same size as
// a pointer, since this allows the compiler to perform tail-call optimizations
// when the underlying function is a callable object with a matching signature.
union VoidPtr {
  const void* obj;
  void (*fun)();
};

// Chooses the best type for passing T as an argument.
// Attempt to be close to SystemV AMD64 ABI. Objects with trivial copy ctor are
// passed by value.
template <typename T,
          bool IsLValueReference = std::is_lvalue_reference<T>::value>
struct PassByValue : std::false_type {};

template <typename T>
struct PassByValue<T, /*IsLValueReference=*/false>
    : std::integral_constant<bool,
                             absl::is_trivially_copy_constructible<T>::value &&
                                 absl::is_trivially_copy_assignable<
                                     typename std::remove_cv<T>::type>::value &&
                                 std::is_trivially_destructible<T>::value &&
                                 sizeof(T) <= 2 * sizeof(void*)> {};

template <typename T>
struct ForwardT : std::conditional<PassByValue<T>::value, T, T&&> {};

// An Invoker takes a pointer to the type-erased invokable object, followed by
// the arguments that the invokable object expects.
//
// Note: The order of arguments here is an optimization, since member functions
// have an implicit "this" pointer as their first argument, putting VoidPtr
// first allows the compiler to perform tail-call optimization in many cases.
template <typename R, typename... Args>
using Invoker = R (*)(VoidPtr, typename ForwardT<Args>::type...);

//
// InvokeObject and InvokeFunction provide static "Invoke" functions that can be
// used as Invokers for objects or functions respectively.
//
// static_cast<R> handles the case the return type is void.
template <typename Obj, typename R, typename... Args>
R InvokeObject(VoidPtr ptr, typename ForwardT<Args>::type... args) {
  auto o = static_cast<const Obj*>(ptr.obj);
  return static_cast<R>(
      absl::base_internal::invoke(*o, std::forward<Args>(args)...));
}

template <typename Fun, typename R, typename... Args>
R InvokeFunction(VoidPtr ptr, typename ForwardT<Args>::type... args) {
  auto f = reinterpret_cast<Fun>(ptr.fun);
  return static_cast<R>(
      absl::base_internal::invoke(f, std::forward<Args>(args)...));
}

template <typename Sig>
void AssertNonNull(const std::function<Sig>& f) {
  assert(f != nullptr);
  (void)f;
}

template <typename Sig>
void AssertNonNull(const AnyInvocable<Sig>& f) {
  assert(f != nullptr);
  (void)f;
}

template <typename F>
void AssertNonNull(const F&) {}

template <typename F, typename C>
void AssertNonNull(F C::*f) {
  assert(f != nullptr);
  (void)f;
}

template <bool C>
using EnableIf = typename ::std::enable_if<C, int>::type;

}  // namespace functional_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_FUNCTIONAL_INTERNAL_FUNCTION_REF_H_
                     node-23.7.0/deps/v8/third_party/abseil-cpp/absl/functional/overload.h                               0000664 0000000 0000000 00000005536 14746647661 0025475 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// -----------------------------------------------------------------------------
// File: overload.h
// -----------------------------------------------------------------------------
//
// `absl::Overload` is a functor that provides overloads based on the functors
// with which it is created. This can, for example, be used to locally define an
// anonymous visitor type for `std::visit` inside a function using lambdas.
//
// Before using this function, consider whether named function overloads would
// be a better design.
//
// Note: absl::Overload requires C++17.
//
// Example:
//
//     std::variant<std::string, int32_t, int64_t> v(int32_t{1});
//     const size_t result =
//         std::visit(absl::Overload{
//                        [](const std::string& s) { return s.size(); },
//                        [](const auto& s) { return sizeof(s); },
//                    },
//                    v);
//     assert(result == 4);
//

#ifndef ABSL_FUNCTIONAL_OVERLOAD_H_
#define ABSL_FUNCTIONAL_OVERLOAD_H_

#include "absl/base/config.h"
#include "absl/meta/type_traits.h"

namespace absl {
ABSL_NAMESPACE_BEGIN

#if defined(ABSL_INTERNAL_CPLUSPLUS_LANG) && \
    ABSL_INTERNAL_CPLUSPLUS_LANG >= 201703L

template <typename... T>
struct Overload final : T... {
  using T::operator()...;

  // For historical reasons we want to support use that looks like a function
  // call:
  //
  //     absl::Overload(lambda_1, lambda_2)
  //
  // This works automatically in C++20 because we have support for parenthesized
  // aggregate initialization. Before then we must provide a constructor that
  // makes this work.
  //
  constexpr explicit Overload(T... ts) : T(std::move(ts))... {}
};

// Before C++20, which added support for CTAD for aggregate types, we must also
// teach the compiler how to deduce the template arguments for Overload.
//
template <typename... T>
Overload(T...) -> Overload<T...>;

#else

namespace functional_internal {
template <typename T>
constexpr bool kDependentFalse = false;
}

template <typename Dependent = int, typename... T>
auto Overload(T&&...) {
  static_assert(functional_internal::kDependentFalse<Dependent>,
                "Overload is only usable with C++17 or above.");
}

#endif

ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_FUNCTIONAL_OVERLOAD_H_
                                                                                                                                                                  node-23.7.0/deps/v8/third_party/abseil-cpp/absl/functional/overload_test.cc                         0000664 0000000 0000000 00000014372 14746647661 0026670 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2023 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/functional/overload.h"

#include <cstdint>
#include <string>
#include <type_traits>

#include "absl/base/config.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"
#include "absl/types/variant.h"

#if defined(ABSL_INTERNAL_CPLUSPLUS_LANG) && \
    ABSL_INTERNAL_CPLUSPLUS_LANG >= 201703L

#include "gtest/gtest.h"

namespace {

TEST(OverloadTest, DispatchConsidersTypeWithAutoFallback) {
  auto overloaded = absl::Overload{
      [](int v) { return absl::StrCat("int ", v); },
      [](double v) { return absl::StrCat("double ", v); },
      [](const char* v) { return absl::StrCat("const char* ", v); },
      [](auto v) { return absl::StrCat("auto ", v); },
  };

  EXPECT_EQ("int 1", overloaded(1));
  EXPECT_EQ("double 2.5", overloaded(2.5));
  EXPECT_EQ("const char* hello", overloaded("hello"));
  EXPECT_EQ("auto 1.5", overloaded(1.5f));
}

TEST(OverloadTest, DispatchConsidersNumberOfArguments) {
  auto overloaded = absl::Overload{
      [](int a) { return a + 1; },
      [](int a, int b) { return a * b; },
      []() -> absl::string_view { return "none"; },
  };

  EXPECT_EQ(3, overloaded(2));
  EXPECT_EQ(21, overloaded(3, 7));
  EXPECT_EQ("none", overloaded());
}

TEST(OverloadTest, SupportsConstantEvaluation) {
  auto overloaded = absl::Overload{
      [](int a) { return a + 1; },
      [](int a, int b) { return a * b; },
      []() -> absl::string_view { return "none"; },
  };

  static_assert(overloaded() == "none");
  static_assert(overloaded(2) == 3);
  static_assert(overloaded(3, 7) == 21);
}

TEST(OverloadTest, PropogatesDefaults) {
  auto overloaded = absl::Overload{
      [](int a, int b = 5) { return a * b; },
      [](double c) { return c; },
  };

  EXPECT_EQ(21, overloaded(3, 7));
  EXPECT_EQ(35, overloaded(7));
  EXPECT_EQ(2.5, overloaded(2.5));
}

TEST(OverloadTest, AmbiguousWithDefaultsNotInvocable) {
  auto overloaded = absl::Overload{
      [](int a, int b = 5) { return a * b; },
      [](int c) { return c; },
  };

  static_assert(!std::is_invocable_v<decltype(overloaded), int>);
  static_assert(std::is_invocable_v<decltype(overloaded), int, int>);
}

TEST(OverloadTest, AmbiguousDuplicatesNotInvocable) {
  auto overloaded = absl::Overload{
      [](int a) { return a; },
      [](int c) { return c; },
  };

  static_assert(!std::is_invocable_v<decltype(overloaded), int>);
}

TEST(OverloadTest, AmbiguousConversionNotInvocable) {
  auto overloaded = absl::Overload{
      [](uint16_t a) { return a; },
      [](uint64_t c) { return c; },
  };

  static_assert(!std::is_invocable_v<decltype(overloaded), int>);
}

TEST(OverloadTest, AmbiguousConversionWithAutoNotInvocable) {
  auto overloaded = absl::Overload{
      [](auto a) { return a; },
      [](auto c) { return c; },
  };

  static_assert(!std::is_invocable_v<decltype(overloaded), int>);
}

#if ABSL_INTERNAL_CPLUSPLUS_LANG >= 202002L

TEST(OverloadTest, AmbiguousConversionWithAutoAndTemplateNotInvocable) {
  auto overloaded = absl::Overload{
      [](auto a) { return a; },
      []<class T>(T c) { return c; },
  };

  static_assert(!std::is_invocable_v<decltype(overloaded), int>);
}

TEST(OverloadTest, DispatchConsidersTypeWithTemplateFallback) {
  auto overloaded = absl::Overload{
      [](int a) { return a; },
      []<class T>(T c) { return c * 2; },
  };

  EXPECT_EQ(7, overloaded(7));
  EXPECT_EQ(14.0, overloaded(7.0));
}

#endif  // ABSL_INTERNAL_CPLUSPLUS_LANG >= 202002L

TEST(OverloadTest, DispatchConsidersSfinae) {
  auto overloaded = absl::Overload{
      [](auto a) -> decltype(a + 1) { return a + 1; },
  };

  static_assert(std::is_invocable_v<decltype(overloaded), int>);
  static_assert(!std::is_invocable_v<decltype(overloaded), std::string>);
}

TEST(OverloadTest, VariantVisitDispatchesCorrectly) {
  absl::variant<int, double, std::string> v(1);
  auto overloaded = absl::Overload{
      [](int) -> absl::string_view { return "int"; },
      [](double) -> absl::string_view { return "double"; },
      [](const std::string&) -> absl::string_view { return "string"; },
  };

  EXPECT_EQ("int", absl::visit(overloaded, v));
  v = 1.1;
  EXPECT_EQ("double", absl::visit(overloaded, v));
  v = "hello";
  EXPECT_EQ("string", absl::visit(overloaded, v));
}

TEST(OverloadTest, VariantVisitWithAutoFallbackDispatchesCorrectly) {
  absl::variant<std::string, int32_t, int64_t> v(int32_t{1});
  auto overloaded = absl::Overload{
      [](const std::string& s) { return s.size(); },
      [](const auto& s) { return sizeof(s); },
  };

  EXPECT_EQ(4, absl::visit(overloaded, v));
  v = int64_t{1};
  EXPECT_EQ(8, absl::visit(overloaded, v));
  v = std::string("hello");
  EXPECT_EQ(5, absl::visit(overloaded, v));
}

// This API used to be exported as a function, so it should also work fine to
// use parantheses when initializing it.
TEST(OverloadTest, UseWithParentheses) {
  const auto overloaded =
      absl::Overload([](const std::string& s) { return s.size(); },
                     [](const auto& s) { return sizeof(s); });

  absl::variant<std::string, int32_t, int64_t> v(int32_t{1});
  EXPECT_EQ(4, absl::visit(overloaded, v));

  v = int64_t{1};
  EXPECT_EQ(8, absl::visit(overloaded, v));

  v = std::string("hello");
  EXPECT_EQ(5, absl::visit(overloaded, v));
}

TEST(OverloadTest, HasConstexprConstructor) {
  constexpr auto overloaded = absl::Overload{
      [](int v) { return absl::StrCat("int ", v); },
      [](double v) { return absl::StrCat("double ", v); },
      [](const char* v) { return absl::StrCat("const char* ", v); },
      [](auto v) { return absl::StrCat("auto ", v); },
  };

  EXPECT_EQ("int 1", overloaded(1));
  EXPECT_EQ("double 2.5", overloaded(2.5));
  EXPECT_EQ("const char* hello", overloaded("hello"));
  EXPECT_EQ("auto 1.5", overloaded(1.5f));
}

}  // namespace

#endif
                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/third_party/abseil-cpp/absl/hash/                                               0000775 0000000 0000000 00000000000 14746647661 0022261 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/third_party/abseil-cpp/absl/hash/BUILD.bazel                                    0000664 0000000 0000000 00000012574 14746647661 0024150 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #
# Copyright 2019 The Abseil Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

load(
    "//absl:copts/configure_copts.bzl",
    "ABSL_DEFAULT_COPTS",
    "ABSL_DEFAULT_LINKOPTS",
    "ABSL_TEST_COPTS",
)

package(
    default_visibility = ["//visibility:public"],
    features = [
        "header_modules",
        "layering_check",
        "parse_headers",
    ],
)

licenses(["notice"])

cc_library(
    name = "hash",
    srcs = [
        "internal/hash.cc",
        "internal/hash.h",
    ],
    hdrs = ["hash.h"],
    copts = ABSL_DEFAULT_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    deps = [
        ":city",
        ":low_level_hash",
        "//absl/base:config",
        "//absl/base:core_headers",
        "//absl/base:endian",
        "//absl/container:fixed_array",
        "//absl/functional:function_ref",
        "//absl/meta:type_traits",
        "//absl/numeric:bits",
        "//absl/numeric:int128",
        "//absl/strings",
        "//absl/types:optional",
        "//absl/types:variant",
        "//absl/utility",
    ],
)

cc_library(
    name = "hash_testing",
    testonly = True,
    hdrs = ["hash_testing.h"],
    linkopts = ABSL_DEFAULT_LINKOPTS,
    deps = [
        ":spy_hash_state",
        "//absl/meta:type_traits",
        "//absl/strings",
        "//absl/types:variant",
        "@com_google_googletest//:gtest",
    ],
)

cc_test(
    name = "hash_test",
    srcs = [
        "hash_test.cc",
        "internal/hash_test.h",
    ],
    copts = ABSL_TEST_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    deps = [
        ":hash",
        ":hash_testing",
        ":spy_hash_state",
        "//absl/base:config",
        "//absl/base:core_headers",
        "//absl/container:btree",
        "//absl/container:flat_hash_map",
        "//absl/container:flat_hash_set",
        "//absl/container:node_hash_map",
        "//absl/container:node_hash_set",
        "//absl/memory",
        "//absl/meta:type_traits",
        "//absl/numeric:int128",
        "//absl/strings:cord_test_helpers",
        "//absl/strings:string_view",
        "//absl/types:optional",
        "//absl/types:variant",
        "@com_google_googletest//:gtest",
        "@com_google_googletest//:gtest_main",
    ],
)

cc_test(
    name = "hash_instantiated_test",
    srcs = [
        "hash_instantiated_test.cc",
        "internal/hash_test.h",
    ],
    copts = ABSL_TEST_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    deps = [
        ":hash",
        ":hash_testing",
        "//absl/base:config",
        "//absl/container:btree",
        "//absl/container:flat_hash_map",
        "//absl/container:flat_hash_set",
        "//absl/container:node_hash_map",
        "//absl/container:node_hash_set",
        "@com_google_googletest//:gtest",
        "@com_google_googletest//:gtest_main",
    ],
)

cc_binary(
    name = "hash_benchmark",
    testonly = True,
    srcs = ["hash_benchmark.cc"],
    copts = ABSL_TEST_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    tags = ["benchmark"],
    visibility = ["//visibility:private"],
    deps = [
        ":hash",
        "//absl/base:core_headers",
        "//absl/container:flat_hash_set",
        "//absl/random",
        "//absl/strings",
        "//absl/strings:cord",
        "//absl/strings:cord_test_helpers",
        "@com_github_google_benchmark//:benchmark_main",
    ],
)

cc_library(
    name = "spy_hash_state",
    testonly = True,
    hdrs = ["internal/spy_hash_state.h"],
    copts = ABSL_DEFAULT_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    visibility = ["//visibility:private"],
    deps = [
        ":hash",
        "//absl/strings",
        "//absl/strings:str_format",
    ],
)

cc_library(
    name = "city",
    srcs = ["internal/city.cc"],
    hdrs = [
        "internal/city.h",
    ],
    copts = ABSL_DEFAULT_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    deps = [
        "//absl/base:config",
        "//absl/base:core_headers",
        "//absl/base:endian",
    ],
)

cc_test(
    name = "city_test",
    srcs = ["internal/city_test.cc"],
    copts = ABSL_TEST_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    deps = [
        ":city",
        "@com_google_googletest//:gtest",
        "@com_google_googletest//:gtest_main",
    ],
)

cc_library(
    name = "low_level_hash",
    srcs = ["internal/low_level_hash.cc"],
    hdrs = ["internal/low_level_hash.h"],
    copts = ABSL_DEFAULT_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    visibility = ["//visibility:private"],
    deps = [
        "//absl/base:config",
        "//absl/base:endian",
        "//absl/base:prefetch",
        "//absl/numeric:int128",
    ],
)

cc_test(
    name = "low_level_hash_test",
    srcs = ["internal/low_level_hash_test.cc"],
    copts = ABSL_TEST_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    visibility = ["//visibility:private"],
    deps = [
        ":low_level_hash",
        "//absl/strings",
        "@com_google_googletest//:gtest",
        "@com_google_googletest//:gtest_main",
    ],
)
                                                                                                                                    node-23.7.0/deps/v8/third_party/abseil-cpp/absl/hash/BUILD.gn                                       0000664 0000000 0000000 00000007447 14746647661 0023462 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2018 The Chromium Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build_overrides/build.gni")
import("//third_party/abseil-cpp/absl.gni")

absl_source_set("hash") {
  sources = [
    "internal/hash.cc",
    "internal/hash.h",
  ]
  public = [ "hash.h" ]
  deps = [
    ":city",
    ":low_level_hash",
    "//third_party/abseil-cpp/absl/base:config",
    "//third_party/abseil-cpp/absl/base:core_headers",
    "//third_party/abseil-cpp/absl/base:endian",
    "//third_party/abseil-cpp/absl/container:fixed_array",
    "//third_party/abseil-cpp/absl/functional:function_ref",
    "//third_party/abseil-cpp/absl/meta:type_traits",
    "//third_party/abseil-cpp/absl/numeric:bits",
    "//third_party/abseil-cpp/absl/numeric:int128",
    "//third_party/abseil-cpp/absl/strings:string_view",
    "//third_party/abseil-cpp/absl/types:optional",
    "//third_party/abseil-cpp/absl/types:variant",
    "//third_party/abseil-cpp/absl/utility",
  ]
}

absl_source_set("hash_testing") {
  testonly = true
  public = [ "hash_testing.h" ]
  deps = [
    ":spy_hash_state",
    "//third_party/abseil-cpp/absl/meta:type_traits",
    "//third_party/abseil-cpp/absl/strings",
    "//third_party/abseil-cpp/absl/types:variant",
    "//third_party/googletest:gtest",
  ]
}

absl_test("hash_test") {
  sources = [
    "hash_test.cc",
    "internal/hash_test.h",
  ]
  deps = [
    ":hash",
    ":hash_testing",
    ":spy_hash_state",
    "//third_party/abseil-cpp/absl/base:config",
    "//third_party/abseil-cpp/absl/base:core_headers",
    "//third_party/abseil-cpp/absl/container:btree",
    "//third_party/abseil-cpp/absl/container:flat_hash_map",
    "//third_party/abseil-cpp/absl/container:flat_hash_set",
    "//third_party/abseil-cpp/absl/container:node_hash_map",
    "//third_party/abseil-cpp/absl/container:node_hash_set",
    "//third_party/abseil-cpp/absl/memory",
    "//third_party/abseil-cpp/absl/meta:type_traits",
    "//third_party/abseil-cpp/absl/numeric:int128",
    "//third_party/abseil-cpp/absl/strings:cord_test_helpers",
    "//third_party/abseil-cpp/absl/strings:string_view",
    "//third_party/abseil-cpp/absl/types:optional",
    "//third_party/abseil-cpp/absl/types:variant",
  ]
}

absl_test("hash_instantiated_test") {
  sources = [
    "hash_instantiated_test.cc",
    "internal/hash_test.h",
  ]
  deps = [
    ":hash",
    ":hash_testing",
    "//third_party/abseil-cpp/absl/base:config",
    "//third_party/abseil-cpp/absl/container:btree",
    "//third_party/abseil-cpp/absl/container:flat_hash_map",
    "//third_party/abseil-cpp/absl/container:flat_hash_set",
    "//third_party/abseil-cpp/absl/container:node_hash_map",
    "//third_party/abseil-cpp/absl/container:node_hash_set",
  ]
}

absl_source_set("spy_hash_state") {
  testonly = true
  public = [ "internal/spy_hash_state.h" ]
  deps = [
    ":hash",
    "//third_party/abseil-cpp/absl/strings",
    "//third_party/abseil-cpp/absl/strings:str_format",
  ]
  visibility = [ "//third_party/abseil-cpp/absl/*" ]
}

absl_source_set("city") {
  public = [ "internal/city.h" ]
  sources = [ "internal/city.cc" ]
  deps = [
    "//third_party/abseil-cpp/absl/base:config",
    "//third_party/abseil-cpp/absl/base:core_headers",
    "//third_party/abseil-cpp/absl/base:endian",
  ]
}

absl_source_set("low_level_hash") {
  public = [ "internal/low_level_hash.h" ]
  sources = [ "internal/low_level_hash.cc" ]
  deps = [
    "//third_party/abseil-cpp/absl/base:config",
    "//third_party/abseil-cpp/absl/base:endian",
    "//third_party/abseil-cpp/absl/base:prefetch",
    "//third_party/abseil-cpp/absl/numeric:int128",
  ]
  visibility = [ ":*" ]
}

absl_test("low_level_hash_test") {
  sources = [ "internal/low_level_hash_test.cc" ]
  deps = [
    ":low_level_hash",
    "//third_party/abseil-cpp/absl/strings",
  ]
}
                                                                                                                                                                                                                         node-23.7.0/deps/v8/third_party/abseil-cpp/absl/hash/CMakeLists.txt                                 0000664 0000000 0000000 00000006411 14746647661 0025023 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #
# Copyright 2018 The Abseil Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

absl_cc_library(
  NAME
    hash
  HDRS
    "hash.h"
  SRCS
    "internal/hash.cc"
    "internal/hash.h"
  COPTS
    ${ABSL_DEFAULT_COPTS}
  DEPS
    absl::bits
    absl::city
    absl::config
    absl::core_headers
    absl::endian
    absl::fixed_array
    absl::function_ref
    absl::meta
    absl::int128
    absl::strings
    absl::optional
    absl::variant
    absl::utility
    absl::low_level_hash
  PUBLIC
)

absl_cc_library(
  NAME
    hash_testing
  HDRS
    "hash_testing.h"
  COPTS
    ${ABSL_TEST_COPTS}
  DEPS
    absl::spy_hash_state
    absl::meta
    absl::strings
    absl::variant
    GTest::gmock
  TESTONLY
  PUBLIC
)

absl_cc_test(
  NAME
    hash_test
  SRCS
    "hash_test.cc"
    "internal/hash_test.h"
  COPTS
    ${ABSL_TEST_COPTS}
  DEPS
    absl::btree
    absl::cord_test_helpers
    absl::core_headers
    absl::flat_hash_map
    absl::flat_hash_set
    absl::hash
    absl::hash_testing
    absl::int128
    absl::memory
    absl::meta
    absl::node_hash_map
    absl::node_hash_set
    absl::optional
    absl::spy_hash_state
    absl::string_view
    absl::variant
    GTest::gmock_main
)

absl_cc_test(
  NAME
    hash_instantiated_test
  SRCS
    "hash_instantiated_test.cc"
    "internal/hash_test.h"
  COPTS
    ${ABSL_TEST_COPTS}
  DEPS
    absl::hash
    absl::hash_testing
    absl::config
    absl::btree
    absl::flat_hash_map
    absl::flat_hash_set
    absl::node_hash_map
    absl::node_hash_set
    GTest::gmock_main
)

# Internal-only target, do not depend on directly.
#
# Note: Even though external code should not depend on this target
# directly, it must be marked PUBLIC since it is a dependency of
# hash_testing.
absl_cc_library(
  NAME
    spy_hash_state
  HDRS
    "internal/spy_hash_state.h"
  COPTS
    ${ABSL_DEFAULT_COPTS}
  DEPS
    absl::hash
    absl::strings
    absl::str_format
  TESTONLY
  PUBLIC
)

# Internal-only target, do not depend on directly.
absl_cc_library(
  NAME
    city
  HDRS
    "internal/city.h"
  SRCS
    "internal/city.cc"
  COPTS
    ${ABSL_DEFAULT_COPTS}
  DEPS
    absl::config
    absl::core_headers
    absl::endian
)

absl_cc_test(
  NAME
    city_test
  SRCS
    "internal/city_test.cc"
  COPTS
    ${ABSL_TEST_COPTS}
  DEPS
    absl::city
    GTest::gmock_main
)

# Internal-only target, do not depend on directly.
absl_cc_library(
  NAME
    low_level_hash
  HDRS
    "internal/low_level_hash.h"
  SRCS
    "internal/low_level_hash.cc"
  COPTS
    ${ABSL_DEFAULT_COPTS}
  DEPS
    absl::config
    absl::endian
    absl::int128
    absl::prefetch
)

absl_cc_test(
  NAME
    low_level_hash_test
  SRCS
    "internal/low_level_hash_test.cc"
  COPTS
    ${ABSL_TEST_COPTS}
  DEPS
    absl::low_level_hash
    absl::strings
    GTest::gmock_main
)
                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/third_party/abseil-cpp/absl/hash/hash.h                                         0000664 0000000 0000000 00000040677 14746647661 0023373 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// -----------------------------------------------------------------------------
// File: hash.h
// -----------------------------------------------------------------------------
//
// This header file defines the Abseil `hash` library and the Abseil hashing
// framework. This framework consists of the following:
//
//   * The `absl::Hash` functor, which is used to invoke the hasher within the
//     Abseil hashing framework. `absl::Hash<T>` supports most basic types and
//     a number of Abseil types out of the box.
//   * `AbslHashValue`, an extension point that allows you to extend types to
//     support Abseil hashing without requiring you to define a hashing
//     algorithm.
//   * `HashState`, a type-erased class which implements the manipulation of the
//     hash state (H) itself; contains member functions `combine()`,
//     `combine_contiguous()`, and `combine_unordered()`; and which you can use
//     to contribute to an existing hash state when hashing your types.
//
// Unlike `std::hash` or other hashing frameworks, the Abseil hashing framework
// provides most of its utility by abstracting away the hash algorithm (and its
// implementation) entirely. Instead, a type invokes the Abseil hashing
// framework by simply combining its state with the state of known, hashable
// types. Hashing of that combined state is separately done by `absl::Hash`.
//
// One should assume that a hash algorithm is chosen randomly at the start of
// each process.  E.g., `absl::Hash<int>{}(9)` in one process and
// `absl::Hash<int>{}(9)` in another process are likely to differ.
//
// `absl::Hash` may also produce different values from different dynamically
// loaded libraries. For this reason, `absl::Hash` values must never cross
// boundaries in dynamically loaded libraries (including when used in types like
// hash containers.)
//
// `absl::Hash` is intended to strongly mix input bits with a target of passing
// an [Avalanche Test](https://en.wikipedia.org/wiki/Avalanche_effect).
//
// Example:
//
//   // Suppose we have a class `Circle` for which we want to add hashing:
//   class Circle {
//    public:
//     ...
//    private:
//     std::pair<int, int> center_;
//     int radius_;
//   };
//
//   // To add hashing support to `Circle`, we simply need to add a free
//   // (non-member) function `AbslHashValue()`, and return the combined hash
//   // state of the existing hash state and the class state. You can add such a
//   // free function using a friend declaration within the body of the class:
//   class Circle {
//    public:
//     ...
//     template <typename H>
//     friend H AbslHashValue(H h, const Circle& c) {
//       return H::combine(std::move(h), c.center_, c.radius_);
//     }
//     ...
//   };
//
// For more information, see Adding Type Support to `absl::Hash` below.
//
#ifndef ABSL_HASH_HASH_H_
#define ABSL_HASH_HASH_H_

#include <tuple>
#include <utility>

#include "absl/functional/function_ref.h"
#include "absl/hash/internal/hash.h"

namespace absl {
ABSL_NAMESPACE_BEGIN

// -----------------------------------------------------------------------------
// `absl::Hash`
// -----------------------------------------------------------------------------
//
// `absl::Hash<T>` is a convenient general-purpose hash functor for any type `T`
// satisfying any of the following conditions (in order):
//
//  * T is an arithmetic or pointer type
//  * T defines an overload for `AbslHashValue(H, const T&)` for an arbitrary
//    hash state `H`.
//  - T defines a specialization of `std::hash<T>`
//
// `absl::Hash` intrinsically supports the following types:
//
//   * All integral types (including bool)
//   * All enum types
//   * All floating-point types (although hashing them is discouraged)
//   * All pointer types, including nullptr_t
//   * std::pair<T1, T2>, if T1 and T2 are hashable
//   * std::tuple<Ts...>, if all the Ts... are hashable
//   * std::unique_ptr and std::shared_ptr
//   * All string-like types including:
//     * absl::Cord
//     * std::string (as well as any instance of std::basic_string that
//       uses one of {char, wchar_t, char16_t, char32_t} and its associated
//       std::char_traits)
//     * std::string_view (as well as any instance of std::basic_string_view
//       that uses one of {char, wchar_t, char16_t, char32_t} and its associated
//       std::char_traits)
//  * All the standard sequence containers (provided the elements are hashable)
//  * All the standard associative containers (provided the elements are
//    hashable)
//  * absl types such as the following:
//    * absl::string_view
//    * absl::uint128
//    * absl::Time, absl::Duration, and absl::TimeZone
//  * absl containers (provided the elements are hashable) such as the
//    following:
//    * absl::flat_hash_set, absl::node_hash_set, absl::btree_set
//    * absl::flat_hash_map, absl::node_hash_map, absl::btree_map
//    * absl::btree_multiset, absl::btree_multimap
//    * absl::InlinedVector
//    * absl::FixedArray
//
// When absl::Hash is used to hash an unordered container with a custom hash
// functor, the elements are hashed using default absl::Hash semantics, not
// the custom hash functor.  This is consistent with the behavior of
// operator==() on unordered containers, which compares elements pairwise with
// operator==() rather than the custom equality functor.  It is usually a
// mistake to use either operator==() or absl::Hash on unordered collections
// that use functors incompatible with operator==() equality.
//
// Note: the list above is not meant to be exhaustive. Additional type support
// may be added, in which case the above list will be updated.
//
// -----------------------------------------------------------------------------
// absl::Hash Invocation Evaluation
// -----------------------------------------------------------------------------
//
// When invoked, `absl::Hash<T>` searches for supplied hash functions in the
// following order:
//
//   * Natively supported types out of the box (see above)
//   * Types for which an `AbslHashValue()` overload is provided (such as
//     user-defined types). See "Adding Type Support to `absl::Hash`" below.
//   * Types which define a `std::hash<T>` specialization
//
// The fallback to legacy hash functions exists mainly for backwards
// compatibility. If you have a choice, prefer defining an `AbslHashValue`
// overload instead of specializing any legacy hash functors.
//
// -----------------------------------------------------------------------------
// The Hash State Concept, and using `HashState` for Type Erasure
// -----------------------------------------------------------------------------
//
// The `absl::Hash` framework relies on the Concept of a "hash state." Such a
// hash state is used in several places:
//
// * Within existing implementations of `absl::Hash<T>` to store the hashed
//   state of an object. Note that it is up to the implementation how it stores
//   such state. A hash table, for example, may mix the state to produce an
//   integer value; a testing framework may simply hold a vector of that state.
// * Within implementations of `AbslHashValue()` used to extend user-defined
//   types. (See "Adding Type Support to absl::Hash" below.)
// * Inside a `HashState`, providing type erasure for the concept of a hash
//   state, which you can use to extend the `absl::Hash` framework for types
//   that are otherwise difficult to extend using `AbslHashValue()`. (See the
//   `HashState` class below.)
//
// The "hash state" concept contains three member functions for mixing hash
// state:
//
// * `H::combine(state, values...)`
//
//   Combines an arbitrary number of values into a hash state, returning the
//   updated state. Note that the existing hash state is move-only and must be
//   passed by value.
//
//   Each of the value types T must be hashable by H.
//
//   NOTE:
//
//     state = H::combine(std::move(state), value1, value2, value3);
//
//   must be guaranteed to produce the same hash expansion as
//
//     state = H::combine(std::move(state), value1);
//     state = H::combine(std::move(state), value2);
//     state = H::combine(std::move(state), value3);
//
// * `H::combine_contiguous(state, data, size)`
//
//    Combines a contiguous array of `size` elements into a hash state,
//    returning the updated state. Note that the existing hash state is
//    move-only and must be passed by value.
//
//    NOTE:
//
//      state = H::combine_contiguous(std::move(state), data, size);
//
//    need NOT be guaranteed to produce the same hash expansion as a loop
//    (it may perform internal optimizations). If you need this guarantee, use a
//    loop instead.
//
// * `H::combine_unordered(state, begin, end)`
//
//    Combines a set of elements denoted by an iterator pair into a hash
//    state, returning the updated state.  Note that the existing hash
//    state is move-only and must be passed by value.
//
//    Unlike the other two methods, the hashing is order-independent.
//    This can be used to hash unordered collections.
//
// -----------------------------------------------------------------------------
// Adding Type Support to `absl::Hash`
// -----------------------------------------------------------------------------
//
// To add support for your user-defined type, add a proper `AbslHashValue()`
// overload as a free (non-member) function. The overload will take an
// existing hash state and should combine that state with state from the type.
//
// Example:
//
//   template <typename H>
//   H AbslHashValue(H state, const MyType& v) {
//     return H::combine(std::move(state), v.field1, ..., v.fieldN);
//   }
//
// where `(field1, ..., fieldN)` are the members you would use on your
// `operator==` to define equality.
//
// Notice that `AbslHashValue` is not a class member, but an ordinary function.
// An `AbslHashValue` overload for a type should only be declared in the same
// file and namespace as said type. The proper `AbslHashValue` implementation
// for a given type will be discovered via ADL.
//
// Note: unlike `std::hash', `absl::Hash` should never be specialized. It must
// only be extended by adding `AbslHashValue()` overloads.
//
template <typename T>
using Hash = absl::hash_internal::Hash<T>;

// HashOf
//
// absl::HashOf() is a helper that generates a hash from the values of its
// arguments.  It dispatches to absl::Hash directly, as follows:
//  * HashOf(t) == absl::Hash<T>{}(t)
//  * HashOf(a, b, c) == HashOf(std::make_tuple(a, b, c))
//
// HashOf(a1, a2, ...) == HashOf(b1, b2, ...) is guaranteed when
//  * The argument lists have pairwise identical C++ types
//  * a1 == b1 && a2 == b2 && ...
//
// The requirement that the arguments match in both type and value is critical.
// It means that `a == b` does not necessarily imply `HashOf(a) == HashOf(b)` if
// `a` and `b` have different types. For example, `HashOf(2) != HashOf(2.0)`.
template <int&... ExplicitArgumentBarrier, typename... Types>
size_t HashOf(const Types&... values) {
  auto tuple = std::tie(values...);
  return absl::Hash<decltype(tuple)>{}(tuple);
}

// HashState
//
// A type erased version of the hash state concept, for use in user-defined
// `AbslHashValue` implementations that can't use templates (such as PImpl
// classes, virtual functions, etc.). The type erasure adds overhead so it
// should be avoided unless necessary.
//
// Note: This wrapper will only erase calls to
//     combine_contiguous(H, const unsigned char*, size_t)
//     RunCombineUnordered(H, CombinerF)
//
// All other calls will be handled internally and will not invoke overloads
// provided by the wrapped class.
//
// Users of this class should still define a template `AbslHashValue` function,
// but can use `absl::HashState::Create(&state)` to erase the type of the hash
// state and dispatch to their private hashing logic.
//
// This state can be used like any other hash state. In particular, you can call
// `HashState::combine()` and `HashState::combine_contiguous()` on it.
//
// Example:
//
//   class Interface {
//    public:
//     template <typename H>
//     friend H AbslHashValue(H state, const Interface& value) {
//       state = H::combine(std::move(state), std::type_index(typeid(*this)));
//       value.HashValue(absl::HashState::Create(&state));
//       return state;
//     }
//    private:
//     virtual void HashValue(absl::HashState state) const = 0;
//   };
//
//   class Impl : Interface {
//    private:
//     void HashValue(absl::HashState state) const override {
//       absl::HashState::combine(std::move(state), v1_, v2_);
//     }
//     int v1_;
//     std::string v2_;
//   };
class HashState : public hash_internal::HashStateBase<HashState> {
 public:
  // HashState::Create()
  //
  // Create a new `HashState` instance that wraps `state`. All calls to
  // `combine()` and `combine_contiguous()` on the new instance will be
  // redirected to the original `state` object. The `state` object must outlive
  // the `HashState` instance.
  template <typename T>
  static HashState Create(T* state) {
    HashState s;
    s.Init(state);
    return s;
  }

  HashState(const HashState&) = delete;
  HashState& operator=(const HashState&) = delete;
  HashState(HashState&&) = default;
  HashState& operator=(HashState&&) = default;

  // HashState::combine()
  //
  // Combines an arbitrary number of values into a hash state, returning the
  // updated state.
  using HashState::HashStateBase::combine;

  // HashState::combine_contiguous()
  //
  // Combines a contiguous array of `size` elements into a hash state, returning
  // the updated state.
  static HashState combine_contiguous(HashState hash_state,
                                      const unsigned char* first, size_t size) {
    hash_state.combine_contiguous_(hash_state.state_, first, size);
    return hash_state;
  }
  using HashState::HashStateBase::combine_contiguous;

 private:
  HashState() = default;

  friend class HashState::HashStateBase;

  template <typename T>
  static void CombineContiguousImpl(void* p, const unsigned char* first,
                                    size_t size) {
    T& state = *static_cast<T*>(p);
    state = T::combine_contiguous(std::move(state), first, size);
  }

  template <typename T>
  void Init(T* state) {
    state_ = state;
    combine_contiguous_ = &CombineContiguousImpl<T>;
    run_combine_unordered_ = &RunCombineUnorderedImpl<T>;
  }

  template <typename HS>
  struct CombineUnorderedInvoker {
    template <typename T, typename ConsumerT>
    void operator()(T inner_state, ConsumerT inner_cb) {
      f(HashState::Create(&inner_state),
        [&](HashState& inner_erased) { inner_cb(inner_erased.Real<T>()); });
    }

    absl::FunctionRef<void(HS, absl::FunctionRef<void(HS&)>)> f;
  };

  template <typename T>
  static HashState RunCombineUnorderedImpl(
      HashState state,
      absl::FunctionRef<void(HashState, absl::FunctionRef<void(HashState&)>)>
          f) {
    // Note that this implementation assumes that inner_state and outer_state
    // are the same type.  This isn't true in the SpyHash case, but SpyHash
    // types are move-convertible to each other, so this still works.
    T& real_state = state.Real<T>();
    real_state = T::RunCombineUnordered(
        std::move(real_state), CombineUnorderedInvoker<HashState>{f});
    return state;
  }

  template <typename CombinerT>
  static HashState RunCombineUnordered(HashState state, CombinerT combiner) {
    auto* run = state.run_combine_unordered_;
    return run(std::move(state), std::ref(combiner));
  }

  // Do not erase an already erased state.
  void Init(HashState* state) {
    state_ = state->state_;
    combine_contiguous_ = state->combine_contiguous_;
    run_combine_unordered_ = state->run_combine_unordered_;
  }

  template <typename T>
  T& Real() {
    return *static_cast<T*>(state_);
  }

  void* state_;
  void (*combine_contiguous_)(void*, const unsigned char*, size_t);
  HashState (*run_combine_unordered_)(
      HashState state,
      absl::FunctionRef<void(HashState, absl::FunctionRef<void(HashState&)>)>);
};

ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_HASH_HASH_H_
                                                                 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/hash/hash_benchmark.cc                              0000664 0000000 0000000 00000031300 14746647661 0025522 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <algorithm>
#include <cassert>
#include <cstddef>
#include <cstdint>
#include <cstring>
#include <string>
#include <tuple>
#include <type_traits>
#include <typeindex>
#include <utility>
#include <vector>

#include "absl/base/attributes.h"
#include "absl/container/flat_hash_set.h"
#include "absl/hash/hash.h"
#include "absl/random/random.h"
#include "absl/strings/cord.h"
#include "absl/strings/cord_test_helpers.h"
#include "absl/strings/string_view.h"
#include "benchmark/benchmark.h"

namespace {

using absl::Hash;

template <template <typename> class H, typename T>
void RunBenchmark(benchmark::State& state, T value) {
  H<T> h;
  for (auto _ : state) {
    benchmark::DoNotOptimize(value);
    benchmark::DoNotOptimize(h(value));
  }
}

}  // namespace

template <typename T>
using AbslHash = absl::Hash<T>;

class TypeErasedInterface {
 public:
  virtual ~TypeErasedInterface() = default;

  template <typename H>
  friend H AbslHashValue(H state, const TypeErasedInterface& wrapper) {
    state = H::combine(std::move(state), std::type_index(typeid(wrapper)));
    wrapper.HashValue(absl::HashState::Create(&state));
    return state;
  }

 private:
  virtual void HashValue(absl::HashState state) const = 0;
};

template <typename T>
struct TypeErasedAbslHash {
  class Wrapper : public TypeErasedInterface {
   public:
    explicit Wrapper(const T& value) : value_(value) {}

   private:
    void HashValue(absl::HashState state) const override {
      absl::HashState::combine(std::move(state), value_);
    }

    const T& value_;
  };

  size_t operator()(const T& value) {
    return absl::Hash<Wrapper>{}(Wrapper(value));
  }
};

absl::Cord FlatCord(size_t size) {
  absl::Cord result(std::string(size, 'a'));
  result.Flatten();
  return result;
}

absl::Cord FragmentedCord(size_t size) {
  const size_t orig_size = size;
  std::vector<std::string> chunks;
  size_t chunk_size = std::max<size_t>(1, size / 10);
  while (size > chunk_size) {
    chunks.push_back(std::string(chunk_size, 'a'));
    size -= chunk_size;
  }
  if (size > 0) {
    chunks.push_back(std::string(size, 'a'));
  }
  absl::Cord result = absl::MakeFragmentedCord(chunks);
  (void) orig_size;
  assert(result.size() == orig_size);
  return result;
}

template <typename T>
std::vector<T> Vector(size_t count) {
  std::vector<T> result;
  for (size_t v = 0; v < count; ++v) {
    result.push_back(v);
  }
  return result;
}

// Bogus type that replicates an unorderd_set's bit mixing, but with
// vector-speed iteration. This is intended to measure the overhead of unordered
// hashing without counting the speed of unordered_set iteration.
template <typename T>
struct FastUnorderedSet {
  explicit FastUnorderedSet(size_t count) {
    for (size_t v = 0; v < count; ++v) {
      values.push_back(v);
    }
  }
  std::vector<T> values;

  template <typename H>
  friend H AbslHashValue(H h, const FastUnorderedSet& fus) {
    return H::combine(H::combine_unordered(std::move(h), fus.values.begin(),
                                           fus.values.end()),
                      fus.values.size());
  }
};

template <typename T>
absl::flat_hash_set<T> FlatHashSet(size_t count) {
  absl::flat_hash_set<T> result;
  for (size_t v = 0; v < count; ++v) {
    result.insert(v);
  }
  return result;
}

// Generates a benchmark and a codegen method for the provided types.  The
// codegen method provides a well known entrypoint for dumping assembly.
#define MAKE_BENCHMARK(hash, name, ...)                          \
  namespace {                                                    \
  void BM_##hash##_##name(benchmark::State& state) {             \
    RunBenchmark<hash>(state, __VA_ARGS__);                      \
  }                                                              \
  BENCHMARK(BM_##hash##_##name);                                 \
  }                                                              \
  size_t Codegen##hash##name(const decltype(__VA_ARGS__)& arg);  \
  size_t Codegen##hash##name(const decltype(__VA_ARGS__)& arg) { \
    return hash<decltype(__VA_ARGS__)>{}(arg);                   \
  }                                                              \
  bool absl_hash_test_odr_use##hash##name =                      \
      (benchmark::DoNotOptimize(&Codegen##hash##name), false)

MAKE_BENCHMARK(AbslHash, Int32, int32_t{});
MAKE_BENCHMARK(AbslHash, Int64, int64_t{});
MAKE_BENCHMARK(AbslHash, Double, 1.2);
MAKE_BENCHMARK(AbslHash, DoubleZero, 0.0);
MAKE_BENCHMARK(AbslHash, PairInt32Int32, std::pair<int32_t, int32_t>{});
MAKE_BENCHMARK(AbslHash, PairInt64Int64, std::pair<int64_t, int64_t>{});
MAKE_BENCHMARK(AbslHash, TupleInt32BoolInt64,
               std::tuple<int32_t, bool, int64_t>{});
MAKE_BENCHMARK(AbslHash, String_0, std::string());
MAKE_BENCHMARK(AbslHash, String_10, std::string(10, 'a'));
MAKE_BENCHMARK(AbslHash, String_30, std::string(30, 'a'));
MAKE_BENCHMARK(AbslHash, String_90, std::string(90, 'a'));
MAKE_BENCHMARK(AbslHash, String_200, std::string(200, 'a'));
MAKE_BENCHMARK(AbslHash, String_5000, std::string(5000, 'a'));
MAKE_BENCHMARK(AbslHash, Cord_Flat_0, absl::Cord());
MAKE_BENCHMARK(AbslHash, Cord_Flat_10, FlatCord(10));
MAKE_BENCHMARK(AbslHash, Cord_Flat_30, FlatCord(30));
MAKE_BENCHMARK(AbslHash, Cord_Flat_90, FlatCord(90));
MAKE_BENCHMARK(AbslHash, Cord_Flat_200, FlatCord(200));
MAKE_BENCHMARK(AbslHash, Cord_Flat_5000, FlatCord(5000));
MAKE_BENCHMARK(AbslHash, Cord_Fragmented_200, FragmentedCord(200));
MAKE_BENCHMARK(AbslHash, Cord_Fragmented_5000, FragmentedCord(5000));
MAKE_BENCHMARK(AbslHash, VectorInt64_10, Vector<int64_t>(10));
MAKE_BENCHMARK(AbslHash, VectorInt64_100, Vector<int64_t>(100));
MAKE_BENCHMARK(AbslHash, VectorInt64_1000, Vector<int64_t>(1000));
MAKE_BENCHMARK(AbslHash, VectorDouble_10, Vector<double>(10));
MAKE_BENCHMARK(AbslHash, VectorDouble_100, Vector<double>(100));
MAKE_BENCHMARK(AbslHash, VectorDouble_1000, Vector<double>(1000));
MAKE_BENCHMARK(AbslHash, FlatHashSetInt64_10, FlatHashSet<int64_t>(10));
MAKE_BENCHMARK(AbslHash, FlatHashSetInt64_100, FlatHashSet<int64_t>(100));
MAKE_BENCHMARK(AbslHash, FlatHashSetInt64_1000, FlatHashSet<int64_t>(1000));
MAKE_BENCHMARK(AbslHash, FlatHashSetDouble_10, FlatHashSet<double>(10));
MAKE_BENCHMARK(AbslHash, FlatHashSetDouble_100, FlatHashSet<double>(100));
MAKE_BENCHMARK(AbslHash, FlatHashSetDouble_1000, FlatHashSet<double>(1000));
MAKE_BENCHMARK(AbslHash, FastUnorderedSetInt64_1000,
               FastUnorderedSet<int64_t>(1000));
MAKE_BENCHMARK(AbslHash, FastUnorderedSetDouble_1000,
               FastUnorderedSet<double>(1000));
MAKE_BENCHMARK(AbslHash, PairStringString_0,
               std::make_pair(std::string(), std::string()));
MAKE_BENCHMARK(AbslHash, PairStringString_10,
               std::make_pair(std::string(10, 'a'), std::string(10, 'b')));
MAKE_BENCHMARK(AbslHash, PairStringString_30,
               std::make_pair(std::string(30, 'a'), std::string(30, 'b')));
MAKE_BENCHMARK(AbslHash, PairStringString_90,
               std::make_pair(std::string(90, 'a'), std::string(90, 'b')));
MAKE_BENCHMARK(AbslHash, PairStringString_200,
               std::make_pair(std::string(200, 'a'), std::string(200, 'b')));
MAKE_BENCHMARK(AbslHash, PairStringString_5000,
               std::make_pair(std::string(5000, 'a'), std::string(5000, 'b')));

MAKE_BENCHMARK(TypeErasedAbslHash, Int32, int32_t{});
MAKE_BENCHMARK(TypeErasedAbslHash, Int64, int64_t{});
MAKE_BENCHMARK(TypeErasedAbslHash, PairInt32Int32,
               std::pair<int32_t, int32_t>{});
MAKE_BENCHMARK(TypeErasedAbslHash, PairInt64Int64,
               std::pair<int64_t, int64_t>{});
MAKE_BENCHMARK(TypeErasedAbslHash, TupleInt32BoolInt64,
               std::tuple<int32_t, bool, int64_t>{});
MAKE_BENCHMARK(TypeErasedAbslHash, String_0, std::string());
MAKE_BENCHMARK(TypeErasedAbslHash, String_10, std::string(10, 'a'));
MAKE_BENCHMARK(TypeErasedAbslHash, String_30, std::string(30, 'a'));
MAKE_BENCHMARK(TypeErasedAbslHash, String_90, std::string(90, 'a'));
MAKE_BENCHMARK(TypeErasedAbslHash, String_200, std::string(200, 'a'));
MAKE_BENCHMARK(TypeErasedAbslHash, String_5000, std::string(5000, 'a'));
MAKE_BENCHMARK(TypeErasedAbslHash, VectorDouble_10,
               std::vector<double>(10, 1.1));
MAKE_BENCHMARK(TypeErasedAbslHash, VectorDouble_100,
               std::vector<double>(100, 1.1));
MAKE_BENCHMARK(TypeErasedAbslHash, VectorDouble_1000,
               std::vector<double>(1000, 1.1));
MAKE_BENCHMARK(TypeErasedAbslHash, FlatHashSetInt64_10,
               FlatHashSet<int64_t>(10));
MAKE_BENCHMARK(TypeErasedAbslHash, FlatHashSetInt64_100,
               FlatHashSet<int64_t>(100));
MAKE_BENCHMARK(TypeErasedAbslHash, FlatHashSetInt64_1000,
               FlatHashSet<int64_t>(1000));
MAKE_BENCHMARK(TypeErasedAbslHash, FlatHashSetDouble_10,
               FlatHashSet<double>(10));
MAKE_BENCHMARK(TypeErasedAbslHash, FlatHashSetDouble_100,
               FlatHashSet<double>(100));
MAKE_BENCHMARK(TypeErasedAbslHash, FlatHashSetDouble_1000,
               FlatHashSet<double>(1000));
MAKE_BENCHMARK(TypeErasedAbslHash, FastUnorderedSetInt64_1000,
               FastUnorderedSet<int64_t>(1000));
MAKE_BENCHMARK(TypeErasedAbslHash, FastUnorderedSetDouble_1000,
               FastUnorderedSet<double>(1000));

// The latency benchmark attempts to model the speed of the hash function in
// production. When a hash function is used for hashtable lookups it is rarely
// used to hash N items in a tight loop nor on constant sized strings. Instead,
// after hashing there is a potential equality test plus a (usually) large
// amount of user code. To simulate this effectively we in