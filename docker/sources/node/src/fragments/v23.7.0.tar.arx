<bool> invariant_checked;

static bool GetInvariantChecked() {
  return invariant_checked.load(std::memory_order_relaxed);
}

static void SetInvariantChecked(bool new_value) {
  invariant_checked.store(new_value, std::memory_order_relaxed);
}

static void CheckSumG0G1(void *v) {
  TestContext *cxt = static_cast<TestContext *>(v);
  CHECK_EQ(cxt->g0, -cxt->g1) << "Error in CheckSumG0G1";
  SetInvariantChecked(true);
}

static void TestMu(TestContext *cxt, int c) {
  for (int i = 0; i != cxt->iterations; i++) {
    absl::MutexLock l(&cxt->mu);
    int a = cxt->g0 + 1;
    cxt->g0 = a;
    cxt->g1--;
  }
}

static void TestTry(TestContext *cxt, int c) {
  for (int i = 0; i != cxt->iterations; i++) {
    do {
      std::this_thread::yield();
    } while (!cxt->mu.TryLock());
    int a = cxt->g0 + 1;
    cxt->g0 = a;
    cxt->g1--;
    cxt->mu.Unlock();
  }
}

static void TestR20ms(TestContext *cxt, int c) {
  for (int i = 0; i != cxt->iterations; i++) {
    absl::ReaderMutexLock l(&cxt->mu);
    absl::SleepFor(absl::Milliseconds(20));
    cxt->mu.AssertReaderHeld();
  }
}

static void TestRW(TestContext *cxt, int c) {
  if ((c & 1) == 0) {
    for (int i = 0; i != cxt->iterations; i++) {
      absl::WriterMutexLock l(&cxt->mu);
      cxt->g0++;
      cxt->g1--;
      cxt->mu.AssertHeld();
      cxt->mu.AssertReaderHeld();
    }
  } else {
    for (int i = 0; i != cxt->iterations; i++) {
      absl::ReaderMutexLock l(&cxt->mu);
      CHECK_EQ(cxt->g0, -cxt->g1) << "Error in TestRW";
      cxt->mu.AssertReaderHeld();
    }
  }
}

struct MyContext {
  int target;
  TestContext *cxt;
  bool MyTurn();
};

bool MyContext::MyTurn() {
  TestContext *cxt = this->cxt;
  return cxt->g0 == this->target || cxt->g0 == cxt->iterations;
}

static void TestAwait(TestContext *cxt, int c) {
  MyContext mc;
  mc.target = c;
  mc.cxt = cxt;
  absl::MutexLock l(&cxt->mu);
  cxt->mu.AssertHeld();
  while (cxt->g0 < cxt->iterations) {
    cxt->mu.Await(absl::Condition(&mc, &MyContext::MyTurn));
    CHECK(mc.MyTurn()) << "Error in TestAwait";
    cxt->mu.AssertHeld();
    if (cxt->g0 < cxt->iterations) {
      int a = cxt->g0 + 1;
      cxt->g0 = a;
      mc.target += cxt->threads;
    }
  }
}

static void TestSignalAll(TestContext *cxt, int c) {
  int target = c;
  absl::MutexLock l(&cxt->mu);
  cxt->mu.AssertHeld();
  while (cxt->g0 < cxt->iterations) {
    while (cxt->g0 != target && cxt->g0 != cxt->iterations) {
      cxt->cv.Wait(&cxt->mu);
    }
    if (cxt->g0 < cxt->iterations) {
      int a = cxt->g0 + 1;
      cxt->g0 = a;
      cxt->cv.SignalAll();
      target += cxt->threads;
    }
  }
}

static void TestSignal(TestContext *cxt, int c) {
  CHECK_EQ(cxt->threads, 2) << "TestSignal should use 2 threads";
  int target = c;
  absl::MutexLock l(&cxt->mu);
  cxt->mu.AssertHeld();
  while (cxt->g0 < cxt->iterations) {
    while (cxt->g0 != target && cxt->g0 != cxt->iterations) {
      cxt->cv.Wait(&cxt->mu);
    }
    if (cxt->g0 < cxt->iterations) {
      int a = cxt->g0 + 1;
      cxt->g0 = a;
      cxt->cv.Signal();
      target += cxt->threads;
    }
  }
}

static void TestCVTimeout(TestContext *cxt, int c) {
  int target = c;
  absl::MutexLock l(&cxt->mu);
  cxt->mu.AssertHeld();
  while (cxt->g0 < cxt->iterations) {
    while (cxt->g0 != target && cxt->g0 != cxt->iterations) {
      cxt->cv.WaitWithTimeout(&cxt->mu, absl::Seconds(100));
    }
    if (cxt->g0 < cxt->iterations) {
      int a = cxt->g0 + 1;
      cxt->g0 = a;
      cxt->cv.SignalAll();
      target += cxt->threads;
    }
  }
}

static bool G0GE2(TestContext *cxt) { return cxt->g0 >= 2; }

static void TestTime(TestContext *cxt, int c, bool use_cv) {
  CHECK_EQ(cxt->iterations, 1) << "TestTime should only use 1 iteration";
  CHECK_GT(cxt->threads, 2) << "TestTime should use more than 2 threads";
  const bool kFalse = false;
  absl::Condition false_cond(&kFalse);
  absl::Condition g0ge2(G0GE2, cxt);
  if (c == 0) {
    absl::MutexLock l(&cxt->mu);

    absl::Time start = absl::Now();
    if (use_cv) {
      cxt->cv.WaitWithTimeout(&cxt->mu, absl::Seconds(1));
    } else {
      CHECK(!cxt->mu.AwaitWithTimeout(false_cond, absl::Seconds(1)))
          << "TestTime failed";
    }
    absl::Duration elapsed = absl::Now() - start;
    CHECK(absl::Seconds(0.9) <= elapsed && elapsed <= absl::Seconds(2.0))
        << "TestTime failed";
    CHECK_EQ(cxt->g0, 1) << "TestTime failed";

    start = absl::Now();
    if (use_cv) {
      cxt->cv.WaitWithTimeout(&cxt->mu, absl::Seconds(1));
    } else {
      CHECK(!cxt->mu.AwaitWithTimeout(false_cond, absl::Seconds(1)))
          << "TestTime failed";
    }
    elapsed = absl::Now() - start;
    CHECK(absl::Seconds(0.9) <= elapsed && elapsed <= absl::Seconds(2.0))
        << "TestTime failed";
    cxt->g0++;
    if (use_cv) {
      cxt->cv.Signal();
    }

    start = absl::Now();
    if (use_cv) {
      cxt->cv.WaitWithTimeout(&cxt->mu, absl::Seconds(4));
    } else {
      CHECK(!cxt->mu.AwaitWithTimeout(false_cond, absl::Seconds(4)))
          << "TestTime failed";
    }
    elapsed = absl::Now() - start;
    CHECK(absl::Seconds(3.9) <= elapsed && elapsed <= absl::Seconds(6.0))
        << "TestTime failed";
    CHECK_GE(cxt->g0, 3) << "TestTime failed";

    start = absl::Now();
    if (use_cv) {
      cxt->cv.WaitWithTimeout(&cxt->mu, absl::Seconds(1));
    } else {
      CHECK(!cxt->mu.AwaitWithTimeout(false_cond, absl::Seconds(1)))
          << "TestTime failed";
    }
    elapsed = absl::Now() - start;
    CHECK(absl::Seconds(0.9) <= elapsed && elapsed <= absl::Seconds(2.0))
        << "TestTime failed";
    if (use_cv) {
      cxt->cv.SignalAll();
    }

    start = absl::Now();
    if (use_cv) {
      cxt->cv.WaitWithTimeout(&cxt->mu, absl::Seconds(1));
    } else {
      CHECK(!cxt->mu.AwaitWithTimeout(false_cond, absl::Seconds(1)))
          << "TestTime failed";
    }
    elapsed = absl::Now() - start;
    CHECK(absl::Seconds(0.9) <= elapsed && elapsed <= absl::Seconds(2.0))
        << "TestTime failed";
    CHECK_EQ(cxt->g0, cxt->threads) << "TestTime failed";

  } else if (c == 1) {
    absl::MutexLock l(&cxt->mu);
    const absl::Time start = absl::Now();
    if (use_cv) {
      cxt->cv.WaitWithTimeout(&cxt->mu, absl::Milliseconds(500));
    } else {
      CHECK(!cxt->mu.AwaitWithTimeout(false_cond, absl::Milliseconds(500)))
          << "TestTime failed";
    }
    const absl::Duration elapsed = absl::Now() - start;
    CHECK(absl::Seconds(0.4) <= elapsed && elapsed <= absl::Seconds(0.9))
        << "TestTime failed";
    cxt->g0++;
  } else if (c == 2) {
    absl::MutexLock l(&cxt->mu);
    if (use_cv) {
      while (cxt->g0 < 2) {
        cxt->cv.WaitWithTimeout(&cxt->mu, absl::Seconds(100));
      }
    } else {
      CHECK(cxt->mu.AwaitWithTimeout(g0ge2, absl::Seconds(100)))
          << "TestTime failed";
    }
    cxt->g0++;
  } else {
    absl::MutexLock l(&cxt->mu);
    if (use_cv) {
      while (cxt->g0 < 2) {
        cxt->cv.Wait(&cxt->mu);
      }
    } else {
      cxt->mu.Await(g0ge2);
    }
    cxt->g0++;
  }
}

static void TestMuTime(TestContext *cxt, int c) { TestTime(cxt, c, false); }

static void TestCVTime(TestContext *cxt, int c) { TestTime(cxt, c, true); }

static void EndTest(int *c0, int *c1, absl::Mutex *mu, absl::CondVar *cv,
                    const std::function<void(int)> &cb) {
  mu->Lock();
  int c = (*c0)++;
  mu->Unlock();
  cb(c);
  absl::MutexLock l(mu);
  (*c1)++;
  cv->Signal();
}

// Code common to RunTest() and RunTestWithInvariantDebugging().
static int RunTestCommon(TestContext *cxt, void (*test)(TestContext *cxt, int),
                         int threads, int iterations, int operations) {
  absl::Mutex mu2;
  absl::CondVar cv2;
  int c0 = 0;
  int c1 = 0;
  cxt->g0 = 0;
  cxt->g1 = 0;
  cxt->iterations = iterations;
  cxt->threads = threads;
  absl::synchronization_internal::ThreadPool tp(threads);
  for (int i = 0; i != threads; i++) {
    tp.Schedule(std::bind(
        &EndTest, &c0, &c1, &mu2, &cv2,
        std::function<void(int)>(std::bind(test, cxt, std::placeholders::_1))));
  }
  mu2.Lock();
  while (c1 != threads) {
    cv2.Wait(&mu2);
  }
  mu2.Unlock();
  return cxt->g0;
}

// Basis for the parameterized tests configured below.
static int RunTest(void (*test)(TestContext *cxt, int), int threads,
                   int iterations, int operations) {
  TestContext cxt;
  return RunTestCommon(&cxt, test, threads, iterations, operations);
}

// Like RunTest(), but sets an invariant on the tested Mutex and
// verifies that the invariant check happened. The invariant function
// will be passed the TestContext* as its arg and must call
// SetInvariantChecked(true);
#if !defined(ABSL_MUTEX_ENABLE_INVARIANT_DEBUGGING_NOT_IMPLEMENTED)
static int RunTestWithInvariantDebugging(void (*test)(TestContext *cxt, int),
                                         int threads, int iterations,
                                         int operations,
                                         void (*invariant)(void *)) {
  ScopedInvariantDebugging scoped_debugging;
  SetInvariantChecked(false);
  TestContext cxt;
  cxt.mu.EnableInvariantDebugging(invariant, &cxt);
  int ret = RunTestCommon(&cxt, test, threads, iterations, operations);
  CHECK(GetInvariantChecked()) << "Invariant not checked";
  return ret;
}
#endif

// --------------------------------------------------------
// Test for fix of bug in TryRemove()
struct TimeoutBugStruct {
  absl::Mutex mu;
  bool a;
  int a_waiter_count;
};

static void WaitForA(TimeoutBugStruct *x) {
  x->mu.LockWhen(absl::Condition(&x->a));
  x->a_waiter_count--;
  x->mu.Unlock();
}

static bool NoAWaiters(TimeoutBugStruct *x) { return x->a_waiter_count == 0; }

// Test that a CondVar.Wait(&mutex) can un-block a call to mutex.Await() in
// another thread.
TEST(Mutex, CondVarWaitSignalsAwait) {
  // Use a struct so the lock annotations apply.
  struct {
    absl::Mutex barrier_mu;
    bool barrier ABSL_GUARDED_BY(barrier_mu) = false;

    absl::Mutex release_mu;
    bool release ABSL_GUARDED_BY(release_mu) = false;
    absl::CondVar released_cv;
  } state;

  auto pool = CreateDefaultPool();

  // Thread A.  Sets barrier, waits for release using Mutex::Await, then
  // signals released_cv.
  pool->Schedule([&state] {
    state.release_mu.Lock();

    state.barrier_mu.Lock();
    state.barrier = true;
    state.barrier_mu.Unlock();

    state.release_mu.Await(absl::Condition(&state.release));
    state.released_cv.Signal();
    state.release_mu.Unlock();
  });

  state.barrier_mu.LockWhen(absl::Condition(&state.barrier));
  state.barrier_mu.Unlock();
  state.release_mu.Lock();
  // Thread A is now blocked on release by way of Mutex::Await().

  // Set release.  Calling released_cv.Wait() should un-block thread A,
  // which will signal released_cv.  If not, the test will hang.
  state.release = true;
  state.released_cv.Wait(&state.release_mu);
  state.release_mu.Unlock();
}

// Test that a CondVar.WaitWithTimeout(&mutex) can un-block a call to
// mutex.Await() in another thread.
TEST(Mutex, CondVarWaitWithTimeoutSignalsAwait) {
  // Use a struct so the lock annotations apply.
  struct {
    absl::Mutex barrier_mu;
    bool barrier ABSL_GUARDED_BY(barrier_mu) = false;

    absl::Mutex release_mu;
    bool release ABSL_GUARDED_BY(release_mu) = false;
    absl::CondVar released_cv;
  } state;

  auto pool = CreateDefaultPool();

  // Thread A.  Sets barrier, waits for release using Mutex::Await, then
  // signals released_cv.
  pool->Schedule([&state] {
    state.release_mu.Lock();

    state.barrier_mu.Lock();
    state.barrier = true;
    state.barrier_mu.Unlock();

    state.release_mu.Await(absl::Condition(&state.release));
    state.released_cv.Signal();
    state.release_mu.Unlock();
  });

  state.barrier_mu.LockWhen(absl::Condition(&state.barrier));
  state.barrier_mu.Unlock();
  state.release_mu.Lock();
  // Thread A is now blocked on release by way of Mutex::Await().

  // Set release.  Calling released_cv.Wait() should un-block thread A,
  // which will signal released_cv.  If not, the test will hang.
  state.release = true;
  EXPECT_TRUE(
      !state.released_cv.WaitWithTimeout(&state.release_mu, absl::Seconds(10)))
      << "; Unrecoverable test failure: CondVar::WaitWithTimeout did not "
         "unblock the absl::Mutex::Await call in another thread.";

  state.release_mu.Unlock();
}

// Test for regression of a bug in loop of TryRemove()
TEST(Mutex, MutexTimeoutBug) {
  auto tp = CreateDefaultPool();

  TimeoutBugStruct x;
  x.a = false;
  x.a_waiter_count = 2;
  tp->Schedule(std::bind(&WaitForA, &x));
  tp->Schedule(std::bind(&WaitForA, &x));
  absl::SleepFor(absl::Seconds(1));  // Allow first two threads to hang.
  // The skip field of the second will point to the first because there are
  // only two.

  // Now cause a thread waiting on an always-false to time out
  // This would deadlock when the bug was present.
  bool always_false = false;
  x.mu.LockWhenWithTimeout(absl::Condition(&always_false),
                           absl::Milliseconds(500));

  // if we get here, the bug is not present.   Cleanup the state.

  x.a = true;                                    // wakeup the two waiters on A
  x.mu.Await(absl::Condition(&NoAWaiters, &x));  // wait for them to exit
  x.mu.Unlock();
}

struct CondVarWaitDeadlock : testing::TestWithParam<int> {
  absl::Mutex mu;
  absl::CondVar cv;
  bool cond1 = false;
  bool cond2 = false;
  bool read_lock1;
  bool read_lock2;
  bool signal_unlocked;

  CondVarWaitDeadlock() {
    read_lock1 = GetParam() & (1 << 0);
    read_lock2 = GetParam() & (1 << 1);
    signal_unlocked = GetParam() & (1 << 2);
  }

  void Waiter1() {
    if (read_lock1) {
      mu.ReaderLock();
      while (!cond1) {
        cv.Wait(&mu);
      }
      mu.ReaderUnlock();
    } else {
      mu.Lock();
      while (!cond1) {
        cv.Wait(&mu);
      }
      mu.Unlock();
    }
  }

  void Waiter2() {
    if (read_lock2) {
      mu.ReaderLockWhen(absl::Condition(&cond2));
      mu.ReaderUnlock();
    } else {
      mu.LockWhen(absl::Condition(&cond2));
      mu.Unlock();
    }
  }
};

// Test for a deadlock bug in Mutex::Fer().
// The sequence of events that lead to the deadlock is:
// 1. waiter1 blocks on cv in read mode (mu bits = 0).
// 2. waiter2 blocks on mu in either mode (mu bits = kMuWait).
// 3. main thread locks mu, sets cond1, unlocks mu (mu bits = kMuWait).
// 4. main thread signals on cv and this eventually calls Mutex::Fer().
// Currently Fer wakes waiter1 since mu bits = kMuWait (mutex is unlocked).
// Before the bug fix Fer neither woke waiter1 nor queued it on mutex,
// which resulted in deadlock.
TEST_P(CondVarWaitDeadlock, Test) {
  auto waiter1 = CreatePool(1);
  auto waiter2 = CreatePool(1);
  waiter1->Schedule([this] { this->Waiter1(); });
  waiter2->Schedule([this] { this->Waiter2(); });

  // Wait while threads block (best-effort is fine).
  absl::SleepFor(absl::Milliseconds(100));

  // Wake condwaiter.
  mu.Lock();
  cond1 = true;
  if (signal_unlocked) {
    mu.Unlock();
    cv.Signal();
  } else {
    cv.Signal();
    mu.Unlock();
  }
  waiter1.reset();  // "join" waiter1

  // Wake waiter.
  mu.Lock();
  cond2 = true;
  mu.Unlock();
  waiter2.reset();  // "join" waiter2
}

INSTANTIATE_TEST_SUITE_P(CondVarWaitDeadlockTest, CondVarWaitDeadlock,
                         ::testing::Range(0, 8),
                         ::testing::PrintToStringParamName());

// --------------------------------------------------------
// Test for fix of bug in DequeueAllWakeable()
// Bug was that if there was more than one waiting reader
// and all should be woken, the most recently blocked one
// would not be.

struct DequeueAllWakeableBugStruct {
  absl::Mutex mu;
  absl::Mutex mu2;       // protects all fields below
  int unfinished_count;  // count of unfinished readers; under mu2
  bool done1;            // unfinished_count == 0; under mu2
  int finished_count;    // count of finished readers, under mu2
  bool done2;            // finished_count == 0; under mu2
};

// Test for regression of a bug in loop of DequeueAllWakeable()
static void AcquireAsReader(DequeueAllWakeableBugStruct *x) {
  x->mu.ReaderLock();
  x->mu2.Lock();
  x->unfinished_count--;
  x->done1 = (x->unfinished_count == 0);
  x->mu2.Unlock();
  // make sure that both readers acquired mu before we release it.
  absl::SleepFor(absl::Seconds(2));
  x->mu.ReaderUnlock();

  x->mu2.Lock();
  x->finished_count--;
  x->done2 = (x->finished_count == 0);
  x->mu2.Unlock();
}

// Test for regression of a bug in loop of DequeueAllWakeable()
TEST(Mutex, MutexReaderWakeupBug) {
  auto tp = CreateDefaultPool();

  DequeueAllWakeableBugStruct x;
  x.unfinished_count = 2;
  x.done1 = false;
  x.finished_count = 2;
  x.done2 = false;
  x.mu.Lock();  // acquire mu exclusively
  // queue two thread that will block on reader locks on x.mu
  tp->Schedule(std::bind(&AcquireAsReader, &x));
  tp->Schedule(std::bind(&AcquireAsReader, &x));
  absl::SleepFor(absl::Seconds(1));  // give time for reader threads to block
  x.mu.Unlock();                     // wake them up

  // both readers should finish promptly
  EXPECT_TRUE(
      x.mu2.LockWhenWithTimeout(absl::Condition(&x.done1), absl::Seconds(10)));
  x.mu2.Unlock();

  EXPECT_TRUE(
      x.mu2.LockWhenWithTimeout(absl::Condition(&x.done2), absl::Seconds(10)));
  x.mu2.Unlock();
}

struct LockWhenTestStruct {
  absl::Mutex mu1;
  bool cond = false;

  absl::Mutex mu2;
  bool waiting = false;
};

static bool LockWhenTestIsCond(LockWhenTestStruct *s) {
  s->mu2.Lock();
  s->waiting = true;
  s->mu2.Unlock();
  return s->cond;
}

static void LockWhenTestWaitForIsCond(LockWhenTestStruct *s) {
  s->mu1.LockWhen(absl::Condition(&LockWhenTestIsCond, s));
  s->mu1.Unlock();
}

TEST(Mutex, LockWhen) {
  LockWhenTestStruct s;

  std::thread t(LockWhenTestWaitForIsCond, &s);
  s.mu2.LockWhen(absl::Condition(&s.waiting));
  s.mu2.Unlock();

  s.mu1.Lock();
  s.cond = true;
  s.mu1.Unlock();

  t.join();
}

TEST(Mutex, LockWhenGuard) {
  absl::Mutex mu;
  int n = 30;
  bool done = false;

  // We don't inline the lambda because the conversion is ambiguous in MSVC.
  bool (*cond_eq_10)(int *) = [](int *p) { return *p == 10; };
  bool (*cond_lt_10)(int *) = [](int *p) { return *p < 10; };

  std::thread t1([&mu, &n, &done, cond_eq_10]() {
    absl::ReaderMutexLock lock(&mu, absl::Condition(cond_eq_10, &n));
    done = true;
  });

  std::thread t2[10];
  for (std::thread &t : t2) {
    t = std::thread([&mu, &n, cond_lt_10]() {
      absl::WriterMutexLock lock(&mu, absl::Condition(cond_lt_10, &n));
      ++n;
    });
  }

  {
    absl::MutexLock lock(&mu);
    n = 0;
  }

  for (std::thread &t : t2) t.join();
  t1.join();

  EXPECT_TRUE(done);
  EXPECT_EQ(n, 10);
}

// --------------------------------------------------------
// The following test requires Mutex::ReaderLock to be a real shared
// lock, which is not the case in all builds.
#if !defined(ABSL_MUTEX_READER_LOCK_IS_EXCLUSIVE)

// Test for fix of bug in UnlockSlow() that incorrectly decremented the reader
// count when putting a thread to sleep waiting for a false condition when the
// lock was not held.

// For this bug to strike, we make a thread wait on a free mutex with no
// waiters by causing its wakeup condition to be false.   Then the
// next two acquirers must be readers.   The bug causes the lock
// to be released when one reader unlocks, rather than both.

struct ReaderDecrementBugStruct {
  bool cond;  // to delay first thread (under mu)
  int done;   // reference count (under mu)
  absl::Mutex mu;

  bool waiting_on_cond;   // under mu2
  bool have_reader_lock;  // under mu2
  bool complete;          // under mu2
  absl::Mutex mu2;        // > mu
};

// L >= mu, L < mu_waiting_on_cond
static bool IsCond(void *v) {
  ReaderDecrementBugStruct *x = reinterpret_cast<ReaderDecrementBugStruct *>(v);
  x->mu2.Lock();
  x->waiting_on_cond = true;
  x->mu2.Unlock();
  return x->cond;
}

// L >= mu
static bool AllDone(void *v) {
  ReaderDecrementBugStruct *x = reinterpret_cast<ReaderDecrementBugStruct *>(v);
  return x->done == 0;
}

// L={}
static void WaitForCond(ReaderDecrementBugStruct *x) {
  absl::Mutex dummy;
  absl::MutexLock l(&dummy);
  x->mu.LockWhen(absl::Condition(&IsCond, x));
  x->done--;
  x->mu.Unlock();
}

// L={}
static void GetReadLock(ReaderDecrementBugStruct *x) {
  x->mu.ReaderLock();
  x->mu2.Lock();
  x->have_reader_lock = true;
  x->mu2.Await(absl::Condition(&x->complete));
  x->mu2.Unlock();
  x->mu.ReaderUnlock();
  x->mu.Lock();
  x->done--;
  x->mu.Unlock();
}

// Test for reader counter being decremented incorrectly by waiter
// with false condition.
TEST(Mutex, MutexReaderDecrementBug) ABSL_NO_THREAD_SAFETY_ANALYSIS {
  ReaderDecrementBugStruct x;
  x.cond = false;
  x.waiting_on_cond = false;
  x.have_reader_lock = false;
  x.complete = false;
  x.done = 2;  // initial ref count

  // Run WaitForCond() and wait for it to sleep
  std::thread thread1(WaitForCond, &x);
  x.mu2.LockWhen(absl::Condition(&x.waiting_on_cond));
  x.mu2.Unlock();

  // Run GetReadLock(), and wait for it to get the read lock
  std::thread thread2(GetReadLock, &x);
  x.mu2.LockWhen(absl::Condition(&x.have_reader_lock));
  x.mu2.Unlock();

  // Get the reader lock ourselves, and release it.
  x.mu.ReaderLock();
  x.mu.ReaderUnlock();

  // The lock should be held in read mode by GetReadLock().
  // If we have the bug, the lock will be free.
  x.mu.AssertReaderHeld();

  // Wake up all the threads.
  x.mu2.Lock();
  x.complete = true;
  x.mu2.Unlock();

  // TODO(delesley): turn on analysis once lock upgrading is supported.
  // (This call upgrades the lock from shared to exclusive.)
  x.mu.Lock();
  x.cond = true;
  x.mu.Await(absl::Condition(&AllDone, &x));
  x.mu.Unlock();

  thread1.join();
  thread2.join();
}
#endif  // !ABSL_MUTEX_READER_LOCK_IS_EXCLUSIVE

// Test that we correctly handle the situation when a lock is
// held and then destroyed (w/o unlocking).
#ifdef ABSL_HAVE_THREAD_SANITIZER
// TSAN reports errors when locked Mutexes are destroyed.
TEST(Mutex, DISABLED_LockedMutexDestructionBug) ABSL_NO_THREAD_SAFETY_ANALYSIS {
#else
TEST(Mutex, LockedMutexDestructionBug) ABSL_NO_THREAD_SAFETY_ANALYSIS {
#endif
  for (int i = 0; i != 10; i++) {
    // Create, lock and destroy 10 locks.
    const int kNumLocks = 10;
    auto mu = absl::make_unique<absl::Mutex[]>(kNumLocks);
    for (int j = 0; j != kNumLocks; j++) {
      if ((j % 2) == 0) {
        mu[j].WriterLock();
      } else {
        mu[j].ReaderLock();
      }
    }
  }
}

// Some functions taking pointers to non-const.
bool Equals42(int *p) { return *p == 42; }
bool Equals43(int *p) { return *p == 43; }

// Some functions taking pointers to const.
bool ConstEquals42(const int *p) { return *p == 42; }
bool ConstEquals43(const int *p) { return *p == 43; }

// Some function templates taking pointers. Note it's possible for `T` to be
// deduced as non-const or const, which creates the potential for ambiguity,
// but which the implementation is careful to avoid.
template <typename T>
bool TemplateEquals42(T *p) {
  return *p == 42;
}
template <typename T>
bool TemplateEquals43(T *p) {
  return *p == 43;
}

TEST(Mutex, FunctionPointerCondition) {
  // Some arguments.
  int x = 42;
  const int const_x = 42;

  // Parameter non-const, argument non-const.
  EXPECT_TRUE(absl::Condition(Equals42, &x).Eval());
  EXPECT_FALSE(absl::Condition(Equals43, &x).Eval());

  // Parameter const, argument non-const.
  EXPECT_TRUE(absl::Condition(ConstEquals42, &x).Eval());
  EXPECT_FALSE(absl::Condition(ConstEquals43, &x).Eval());

  // Parameter const, argument const.
  EXPECT_TRUE(absl::Condition(ConstEquals42, &const_x).Eval());
  EXPECT_FALSE(absl::Condition(ConstEquals43, &const_x).Eval());

  // Parameter type deduced, argument non-const.
  EXPECT_TRUE(absl::Condition(TemplateEquals42, &x).Eval());
  EXPECT_FALSE(absl::Condition(TemplateEquals43, &x).Eval());

  // Parameter type deduced, argument const.
  EXPECT_TRUE(absl::Condition(TemplateEquals42, &const_x).Eval());
  EXPECT_FALSE(absl::Condition(TemplateEquals43, &const_x).Eval());

  // Parameter non-const, argument const is not well-formed.
  EXPECT_FALSE((std::is_constructible<absl::Condition, decltype(Equals42),
                                      decltype(&const_x)>::value));
  // Validate use of is_constructible by contrasting to a well-formed case.
  EXPECT_TRUE((std::is_constructible<absl::Condition, decltype(ConstEquals42),
                                     decltype(&const_x)>::value));
}

// Example base and derived class for use in predicates and test below. Not a
// particularly realistic example, but it suffices for testing purposes.
struct Base {
  explicit Base(int v) : value(v) {}
  int value;
};
struct Derived : Base {
  explicit Derived(int v) : Base(v) {}
};

// Some functions taking pointer to non-const `Base`.
bool BaseEquals42(Base *p) { return p->value == 42; }
bool BaseEquals43(Base *p) { return p->value == 43; }

// Some functions taking pointer to const `Base`.
bool ConstBaseEquals42(const Base *p) { return p->value == 42; }
bool ConstBaseEquals43(const Base *p) { return p->value == 43; }

TEST(Mutex, FunctionPointerConditionWithDerivedToBaseConversion) {
  // Some arguments.
  Derived derived(42);
  const Derived const_derived(42);

  // Parameter non-const base, argument derived non-const.
  EXPECT_TRUE(absl::Condition(BaseEquals42, &derived).Eval());
  EXPECT_FALSE(absl::Condition(BaseEquals43, &derived).Eval());

  // Parameter const base, argument derived non-const.
  EXPECT_TRUE(absl::Condition(ConstBaseEquals42, &derived).Eval());
  EXPECT_FALSE(absl::Condition(ConstBaseEquals43, &derived).Eval());

  // Parameter const base, argument derived const.
  EXPECT_TRUE(absl::Condition(ConstBaseEquals42, &const_derived).Eval());
  EXPECT_FALSE(absl::Condition(ConstBaseEquals43, &const_derived).Eval());

  // Parameter const base, argument derived const.
  EXPECT_TRUE(absl::Condition(ConstBaseEquals42, &const_derived).Eval());
  EXPECT_FALSE(absl::Condition(ConstBaseEquals43, &const_derived).Eval());

  // Parameter derived, argument base is not well-formed.
  bool (*derived_pred)(const Derived *) = [](const Derived *) { return true; };
  EXPECT_FALSE((std::is_constructible<absl::Condition, decltype(derived_pred),
                                      Base *>::value));
  EXPECT_FALSE((std::is_constructible<absl::Condition, decltype(derived_pred),
                                      const Base *>::value));
  // Validate use of is_constructible by contrasting to well-formed cases.
  EXPECT_TRUE((std::is_constructible<absl::Condition, decltype(derived_pred),
                                     Derived *>::value));
  EXPECT_TRUE((std::is_constructible<absl::Condition, decltype(derived_pred),
                                     const Derived *>::value));
}

struct Constable {
  bool WotsAllThisThen() const { return true; }
};

TEST(Mutex, FunctionPointerConditionWithConstMethod) {
  const Constable chapman;
  EXPECT_TRUE(absl::Condition(&chapman, &Constable::WotsAllThisThen).Eval());
}

struct True {
  template <class... Args>
  bool operator()(Args...) const {
    return true;
  }
};

struct DerivedTrue : True {};

TEST(Mutex, FunctorCondition) {
  {  // Variadic
    True f;
    EXPECT_TRUE(absl::Condition(&f).Eval());
  }

  {  // Inherited
    DerivedTrue g;
    EXPECT_TRUE(absl::Condition(&g).Eval());
  }

  {  // lambda
    int value = 3;
    auto is_zero = [&value] { return value == 0; };
    absl::Condition c(&is_zero);
    EXPECT_FALSE(c.Eval());
    value = 0;
    EXPECT_TRUE(c.Eval());
  }

  {  // bind
    int value = 0;
    auto is_positive = std::bind(std::less<int>(), 0, std::cref(value));
    absl::Condition c(&is_positive);
    EXPECT_FALSE(c.Eval());
    value = 1;
    EXPECT_TRUE(c.Eval());
  }

  {  // std::function
    int value = 3;
    std::function<bool()> is_zero = [&value] { return value == 0; };
    absl::Condition c(&is_zero);
    EXPECT_FALSE(c.Eval());
    value = 0;
    EXPECT_TRUE(c.Eval());
  }
}

TEST(Mutex, ConditionSwap) {
  // Ensure that Conditions can be swap'ed.
  bool b1 = true;
  absl::Condition c1(&b1);
  bool b2 = false;
  absl::Condition c2(&b2);
  EXPECT_TRUE(c1.Eval());
  EXPECT_FALSE(c2.Eval());
  std::swap(c1, c2);
  EXPECT_FALSE(c1.Eval());
  EXPECT_TRUE(c2.Eval());
}

// --------------------------------------------------------
// Test for bug with pattern of readers using a condvar.  The bug was that if a
// reader went to sleep on a condition variable while one or more other readers
// held the lock, but there were no waiters, the reader count (held in the
// mutex word) would be lost.  (This is because Enqueue() had at one time
// always placed the thread on the Mutex queue.  Later (CL 4075610), to
// tolerate re-entry into Mutex from a Condition predicate, Enqueue() was
// changed so that it could also place a thread on a condition-variable.  This
// introduced the case where Enqueue() returned with an empty queue, and this
// case was handled incorrectly in one place.)

static void ReaderForReaderOnCondVar(absl::Mutex *mu, absl::CondVar *cv,
                                     int *running) {
  std::random_device dev;
  std::mt19937 gen(dev());
  std::uniform_int_distribution<int> random_millis(0, 15);
  mu->ReaderLock();
  while (*running == 3) {
    absl::SleepFor(absl::Milliseconds(random_millis(gen)));
    cv->WaitWithTimeout(mu, absl::Milliseconds(random_millis(gen)));
  }
  mu->ReaderUnlock();
  mu->Lock();
  (*running)--;
  mu->Unlock();
}

static bool IntIsZero(int *x) { return *x == 0; }

// Test for reader waiting condition variable when there are other readers
// but no waiters.
TEST(Mutex, TestReaderOnCondVar) {
  auto tp = CreateDefaultPool();
  absl::Mutex mu;
  absl::CondVar cv;
  int running = 3;
  tp->Schedule(std::bind(&ReaderForReaderOnCondVar, &mu, &cv, &running));
  tp->Schedule(std::bind(&ReaderForReaderOnCondVar, &mu, &cv, &running));
  absl::SleepFor(absl::Seconds(2));
  mu.Lock();
  running--;
  mu.Await(absl::Condition(&IntIsZero, &running));
  mu.Unlock();
}

// --------------------------------------------------------
struct AcquireFromConditionStruct {
  absl::Mutex mu0;   // protects value, done
  int value;         // times condition function is called; under mu0,
  bool done;         // done with test?  under mu0
  absl::Mutex mu1;   // used to attempt to mess up state of mu0
  absl::CondVar cv;  // so the condition function can be invoked from
                     // CondVar::Wait().
};

static bool ConditionWithAcquire(AcquireFromConditionStruct *x) {
  x->value++;  // count times this function is called

  if (x->value == 2 || x->value == 3) {
    // On the second and third invocation of this function, sleep for 100ms,
    // but with the side-effect of altering the state of a Mutex other than
    // than one for which this is a condition.  The spec now explicitly allows
    // this side effect; previously it did not.  it was illegal.
    bool always_false = false;
    x->mu1.LockWhenWithTimeout(absl::Condition(&always_false),
                               absl::Milliseconds(100));
    x->mu1.Unlock();
  }
  CHECK_LT(x->value, 4) << "should not be invoked a fourth time";

  // We arrange for the condition to return true on only the 2nd and 3rd calls.
  return x->value == 2 || x->value == 3;
}

static void WaitForCond2(AcquireFromConditionStruct *x) {
  // wait for cond0 to become true
  x->mu0.LockWhen(absl::Condition(&ConditionWithAcquire, x));
  x->done = true;
  x->mu0.Unlock();
}

// Test for Condition whose function acquires other Mutexes
TEST(Mutex, AcquireFromCondition) {
  auto tp = CreateDefaultPool();

  AcquireFromConditionStruct x;
  x.value = 0;
  x.done = false;
  tp->Schedule(
      std::bind(&WaitForCond2, &x));  // run WaitForCond2() in a thread T
  // T will hang because the first invocation of ConditionWithAcquire() will
  // return false.
  absl::SleepFor(absl::Milliseconds(500));  // allow T time to hang

  x.mu0.Lock();
  x.cv.WaitWithTimeout(&x.mu0, absl::Milliseconds(500));  // wake T
  // T will be woken because the Wait() will call ConditionWithAcquire()
  // for the second time, and it will return true.

  x.mu0.Unlock();

  // T will then acquire the lock and recheck its own condition.
  // It will find the condition true, as this is the third invocation,
  // but the use of another Mutex by the calling function will
  // cause the old mutex implementation to think that the outer
  // LockWhen() has timed out because the inner LockWhenWithTimeout() did.
  // T will then check the condition a fourth time because it finds a
  // timeout occurred.  This should not happen in the new
  // implementation that allows the Condition function to use Mutexes.

  // It should also succeed, even though the Condition function
  // is being invoked from CondVar::Wait, and thus this thread
  // is conceptually waiting both on the condition variable, and on mu2.

  x.mu0.LockWhen(absl::Condition(&x.done));
  x.mu0.Unlock();
}

TEST(Mutex, DeadlockDetector) {
  absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kAbort);

  // check that we can call ForgetDeadlockInfo() on a lock with the lock held
  absl::Mutex m1;
  absl::Mutex m2;
  absl::Mutex m3;
  absl::Mutex m4;

  m1.Lock();  // m1 gets ID1
  m2.Lock();  // m2 gets ID2
  m3.Lock();  // m3 gets ID3
  m3.Unlock();
  m2.Unlock();
  // m1 still held
  m1.ForgetDeadlockInfo();  // m1 loses ID
  m2.Lock();                // m2 gets ID2
  m3.Lock();                // m3 gets ID3
  m4.Lock();                // m4 gets ID4
  m3.Unlock();
  m2.Unlock();
  m4.Unlock();
  m1.Unlock();
}

// Bazel has a test "warning" file that programs can write to if the
// test should pass with a warning.  This class disables the warning
// file until it goes out of scope.
class ScopedDisableBazelTestWarnings {
 public:
  ScopedDisableBazelTestWarnings() {
#ifdef _WIN32
    char file[MAX_PATH];
    if (GetEnvironmentVariableA(kVarName, file, sizeof(file)) < sizeof(file)) {
      warnings_output_file_ = file;
      SetEnvironmentVariableA(kVarName, nullptr);
    }
#else
    const char *file = getenv(kVarName);
    if (file != nullptr) {
      warnings_output_file_ = file;
      unsetenv(kVarName);
    }
#endif
  }

  ~ScopedDisableBazelTestWarnings() {
    if (!warnings_output_file_.empty()) {
#ifdef _WIN32
      SetEnvironmentVariableA(kVarName, warnings_output_file_.c_str());
#else
      setenv(kVarName, warnings_output_file_.c_str(), 0);
#endif
    }
  }

 private:
  static const char kVarName[];
  std::string warnings_output_file_;
};
const char ScopedDisableBazelTestWarnings::kVarName[] =
    "TEST_WARNINGS_OUTPUT_FILE";

#ifdef ABSL_HAVE_THREAD_SANITIZER
// This test intentionally creates deadlocks to test the deadlock detector.
TEST(Mutex, DISABLED_DeadlockDetectorBazelWarning) {
#else
TEST(Mutex, DeadlockDetectorBazelWarning) {
#endif
  absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kReport);

  // Cause deadlock detection to detect something, if it's
  // compiled in and enabled.  But turn off the bazel warning.
  ScopedDisableBazelTestWarnings disable_bazel_test_warnings;

  absl::Mutex mu0;
  absl::Mutex mu1;
  bool got_mu0 = mu0.TryLock();
  mu1.Lock();  // acquire mu1 while holding mu0
  if (got_mu0) {
    mu0.Unlock();
  }
  if (mu0.TryLock()) {  // try lock shouldn't cause deadlock detector to fire
    mu0.Unlock();
  }
  mu0.Lock();  // acquire mu0 while holding mu1; should get one deadlock
               // report here
  mu0.Unlock();
  mu1.Unlock();

  absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kAbort);
}

TEST(Mutex, DeadlockDetectorLongCycle) {
  absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kReport);

  // This test generates a warning if it passes, and crashes otherwise.
  // Cause bazel to ignore the warning.
  ScopedDisableBazelTestWarnings disable_bazel_test_warnings;

  // Check that we survive a deadlock with a lock cycle.
  std::vector<absl::Mutex> mutex(100);
  for (size_t i = 0; i != mutex.size(); i++) {
    mutex[i].Lock();
    mutex[(i + 1) % mutex.size()].Lock();
    mutex[i].Unlock();
    mutex[(i + 1) % mutex.size()].Unlock();
  }

  absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kAbort);
}

// This test is tagged with NO_THREAD_SAFETY_ANALYSIS because the
// annotation-based static thread-safety analysis is not currently
// predicate-aware and cannot tell if the two for-loops that acquire and
// release the locks have the same predicates.
TEST(Mutex, DeadlockDetectorStressTest) ABSL_NO_THREAD_SAFETY_ANALYSIS {
  // Stress test: Here we create a large number of locks and use all of them.
  // If a deadlock detector keeps a full graph of lock acquisition order,
  // it will likely be too slow for this test to pass.
  const int n_locks = 1 << 17;
  auto array_of_locks = absl::make_unique<absl::Mutex[]>(n_locks);
  for (int i = 0; i < n_locks; i++) {
    int end = std::min(n_locks, i + 5);
    // acquire and then release locks i, i+1, ..., i+4
    for (int j = i; j < end; j++) {
      array_of_locks[j].Lock();
    }
    for (int j = i; j < end; j++) {
      array_of_locks[j].Unlock();
    }
  }
}

#ifdef ABSL_HAVE_THREAD_SANITIZER
// TSAN reports errors when locked Mutexes are destroyed.
TEST(Mutex, DISABLED_DeadlockIdBug) ABSL_NO_THREAD_SAFETY_ANALYSIS {
#else
TEST(Mutex, DeadlockIdBug) ABSL_NO_THREAD_SAFETY_ANALYSIS {
#endif
  // Test a scenario where a cached deadlock graph node id in the
  // list of held locks is not invalidated when the corresponding
  // mutex is deleted.
  absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kAbort);
  // Mutex that will be destroyed while being held
  absl::Mutex *a = new absl::Mutex;
  // Other mutexes needed by test
  absl::Mutex b, c;

  // Hold mutex.
  a->Lock();

  // Force deadlock id assignment by acquiring another lock.
  b.Lock();
  b.Unlock();

  // Delete the mutex. The Mutex destructor tries to remove held locks,
  // but the attempt isn't foolproof.  It can fail if:
  //   (a) Deadlock detection is currently disabled.
  //   (b) The destruction is from another thread.
  // We exploit (a) by temporarily disabling deadlock detection.
  absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kIgnore);
  delete a;
  absl::SetMutexDeadlockDetectionMode(absl::OnDeadlockCycle::kAbort);

  // Now acquire another lock which will force a deadlock id assignment.
  // We should end up getting assigned the same deadlock id that was
  // freed up when "a" was deleted, which will cause a spurious deadlock
  // report if the held lock entry for "a" was not invalidated.
  c.Lock();
  c.Unlock();
}

// --------------------------------------------------------
// Test for timeouts/deadlines on condition waits that are specified using
// absl::Duration and absl::Time.  For each waiting function we test with
// a timeout/deadline that has already expired/passed, one that is infinite
// and so never expires/passes, and one that will expire/pass in the near
// future.

static absl::Duration TimeoutTestAllowedSchedulingDelay() {
  // Note: we use a function here because Microsoft Visual Studio fails to
  // properly initialize constexpr static absl::Duration variables.
  return absl::Milliseconds(150);
}

// Returns true if `actual_delay` is close enough to `expected_delay` to pass
// the timeouts/deadlines test.  Otherwise, logs warnings and returns false.
ABSL_MUST_USE_RESULT
static bool DelayIsWithinBounds(absl::Duration expected_delay,
                                absl::Duration actual_delay) {
  bool pass = true;
  // Do not allow the observed delay to be less than expected.  This may occur
  // in practice due to clock skew or when the synchronization primitives use a
  // different clock than absl::Now(), but these cases should be handled by the
  // the retry mechanism in each TimeoutTest.
  if (actual_delay < expected_delay) {
    LOG(WARNING) << "Actual delay " << actual_delay
                 << " was too short, expected " << expected_delay
                 << " (difference " << actual_delay - expected_delay << ")";
    pass = false;
  }
  // If the expected delay is <= zero then allow a small error tolerance, since
  // we do not expect context switches to occur during test execution.
  // Otherwise, thread scheduling delays may be substantial in rare cases, so
  // tolerate up to kTimeoutTestAllowedSchedulingDelay of error.
  absl::Duration tolerance = expected_delay <= absl::ZeroDuration()
                                 ? absl::Milliseconds(10)
                                 : TimeoutTestAllowedSchedulingDelay();
  if (actual_delay > expected_delay + tolerance) {
    LOG(WARNING) << "Actual delay " << actual_delay
                 << " was too long, expected " << expected_delay
                 << " (difference " << actual_delay - expected_delay << ")";
    pass = false;
  }
  return pass;
}

// Parameters for TimeoutTest, below.
struct TimeoutTestParam {
  // The file and line number (used for logging purposes only).
  const char *from_file;
  int from_line;

  // Should the absolute deadline API based on absl::Time be tested?  If false,
  // the relative deadline API based on absl::Duration is tested.
  bool use_absolute_deadline;

  // The deadline/timeout used when calling the API being tested
  // (e.g. Mutex::LockWhenWithDeadline).
  absl::Duration wait_timeout;

  // The delay before the condition will be set true by the test code.  If zero
  // or negative, the condition is set true immediately (before calling the API
  // being tested).  Otherwise, if infinite, the condition is never set true.
  // Otherwise a closure is scheduled for the future that sets the condition
  // true.
  absl::Duration satisfy_condition_delay;

  // The expected result of the condition after the call to the API being
  // tested. Generally `true` means the condition was true when the API returns,
  // `false` indicates an expected timeout.
  bool expected_result;

  // The expected delay before the API under test returns.  This is inherently
  // flaky, so some slop is allowed (see `DelayIsWithinBounds` above), and the
  // test keeps trying indefinitely until this constraint passes.
  absl::Duration expected_delay;
};

// Print a `TimeoutTestParam` to a debug log.
std::ostream &operator<<(std::ostream &os, const TimeoutTestParam &param) {
  return os << "from: " << param.from_file << ":" << param.from_line
            << " use_absolute_deadline: "
            << (param.use_absolute_deadline ? "true" : "false")
            << " wait_timeout: " << param.wait_timeout
            << " satisfy_condition_delay: " << param.satisfy_condition_delay
            << " expected_result: "
            << (param.expected_result ? "true" : "false")
            << " expected_delay: " << param.expected_delay;
}

// Like `thread::Executor::ScheduleAt` except:
// a) Delays zero or negative are executed immediately in the current thread.
// b) Infinite delays are never scheduled.
// c) Calls this test's `ScheduleAt` helper instead of using `pool` directly.
static void RunAfterDelay(absl::Duration delay,
                          absl::synchronization_internal::ThreadPool *pool,
                          const std::function<void()> &callback) {
  if (delay <= absl::ZeroDuration()) {
    callback();  // immediate
  } else if (delay != absl::InfiniteDuration()) {
    ScheduleAfter(pool, delay, callback);
  }
}

class TimeoutTest : public ::testing::Test,
                    public ::testing::WithParamInterface<TimeoutTestParam> {};

std::vector<TimeoutTestParam> MakeTimeoutTestParamValues() {
  // The `finite` delay is a finite, relatively short, delay.  We make it larger
  // than our allowed scheduling delay (slop factor) to avoid confusion when
  // diagnosing test failures.  The other constants here have clear meanings.
  const absl::Duration finite = 3 * TimeoutTestAllowedSchedulingDelay();
  const absl::Duration never = absl::InfiniteDuration();
  const absl::Duration negative = -absl::InfiniteDuration();
  const absl::Duration immediate = absl::ZeroDuration();

  // Every test case is run twice; once using the absolute deadline API and once
  // using the relative timeout API.
  std::vector<TimeoutTestParam> values;
  for (bool use_absolute_deadline : {false, true}) {
    // Tests with a negative timeout (deadline in the past), which should
    // immediately return current state of the condition.

    // The condition is already true:
    values.push_back(TimeoutTestParam{
        __FILE__, __LINE__, use_absolute_deadline,
        negative,   // wait_timeout
        immediate,  // satisfy_condition_delay
        true,       // expected_result
        immediate,  // expected_delay
    });

    // The condition becomes true, but the timeout has already expired:
    values.push_back(TimeoutTestParam{
        __FILE__, __LINE__, use_absolute_deadline,
        negative,  // wait_timeout
        finite,    // satisfy_condition_delay
        false,     // expected_result
        immediate  // expected_delay
    });

    // The condition never becomes true:
    values.push_back(TimeoutTestParam{
        __FILE__, __LINE__, use_absolute_deadline,
        negative,  // wait_timeout
        never,     // satisfy_condition_delay
        false,     // expected_result
        immediate  // expected_delay
    });

    // Tests with an infinite timeout (deadline in the infinite future), which
    // should only return when the condition becomes true.

    // The condition is already true:
    values.push_back(TimeoutTestParam{
        __FILE__, __LINE__, use_absolute_deadline,
        never,      // wait_timeout
        immediate,  // satisfy_condition_delay
        true,       // expected_result
        immediate   // expected_delay
    });

    // The condition becomes true before the (infinite) expiry:
    values.push_back(TimeoutTestParam{
        __FILE__, __LINE__, use_absolute_deadline,
        never,   // wait_timeout
        finite,  // satisfy_condition_delay
        true,    // expected_result
        finite,  // expected_delay
    });

    // Tests with a (small) finite timeout (deadline soon), with the condition
    // becoming true both before and after its expiry.

    // The condition is already true:
    values.push_back(TimeoutTestParam{
        __FILE__, __LINE__, use_absolute_deadline,
        never,      // wait_timeout
        immediate,  // satisfy_condition_delay
        true,       // expected_result
        immediate   // expected_delay
    });

    // The condition becomes true before the expiry:
    values.push_back(TimeoutTestParam{
        __FILE__, __LINE__, use_absolute_deadline,
        finite * 2,  // wait_timeout
        finite,      // satisfy_condition_delay
        true,        // expected_result
        finite       // expected_delay
    });

    // The condition becomes true, but the timeout has already expired:
    values.push_back(TimeoutTestParam{
        __FILE__, __LINE__, use_absolute_deadline,
        finite,      // wait_timeout
        finite * 2,  // satisfy_condition_delay
        false,       // expected_result
        finite       // expected_delay
    });

    // The condition never becomes true:
    values.push_back(TimeoutTestParam{
        __FILE__, __LINE__, use_absolute_deadline,
        finite,  // wait_timeout
        never,   // satisfy_condition_delay
        false,   // expected_result
        finite   // expected_delay
    });
  }
  return values;
}

// Instantiate `TimeoutTest` with `MakeTimeoutTestParamValues()`.
INSTANTIATE_TEST_SUITE_P(All, TimeoutTest,
                         testing::ValuesIn(MakeTimeoutTestParamValues()));

TEST_P(TimeoutTest, Await) {
  const TimeoutTestParam params = GetParam();
  LOG(INFO) << "Params: " << params;

  // Because this test asserts bounds on scheduling delays it is flaky.  To
  // compensate it loops forever until it passes.  Failures express as test
  // timeouts, in which case the test log can be used to diagnose the issue.
  for (int attempt = 1;; ++attempt) {
    LOG(INFO) << "Attempt " << attempt;

    absl::Mutex mu;
    bool value = false;  // condition value (under mu)

    std::unique_ptr<absl::synchronization_internal::ThreadPool> pool =
        CreateDefaultPool();
    RunAfterDelay(params.satisfy_condition_delay, pool.get(), [&] {
      absl::MutexLock l(&mu);
      value = true;
    });

    absl::MutexLock lock(&mu);
    absl::Time start_time = absl::Now();
    absl::Condition cond(&value);
    bool result =
        params.use_absolute_deadline
            ? mu.AwaitWithDeadline(cond, start_time + params.wait_timeout)
            : mu.AwaitWithTimeout(cond, params.wait_timeout);
    if (DelayIsWithinBounds(params.expected_delay, absl::Now() - start_time)) {
      EXPECT_EQ(params.expected_result, result);
      break;
    }
  }
}

TEST_P(TimeoutTest, LockWhen) {
  const TimeoutTestParam params = GetParam();
  LOG(INFO) << "Params: " << params;

  // Because this test asserts bounds on scheduling delays it is flaky.  To
  // compensate it loops forever until it passes.  Failures express as test
  // timeouts, in which case the test log can be used to diagnose the issue.
  for (int attempt = 1;; ++attempt) {
    LOG(INFO) << "Attempt " << attempt;

    absl::Mutex mu;
    bool value = false;  // condition value (under mu)

    std::unique_ptr<absl::synchronization_internal::ThreadPool> pool =
        CreateDefaultPool();
    RunAfterDelay(params.satisfy_condition_delay, pool.get(), [&] {
      absl::MutexLock l(&mu);
      value = true;
    });

    absl::Time start_time = absl::Now();
    absl::Condition cond(&value);
    bool result =
        params.use_absolute_deadline
            ? mu.LockWhenWithDeadline(cond, start_time + params.wait_timeout)
            : mu.LockWhenWithTimeout(cond, params.wait_timeout);
    mu.Unlock();

    if (DelayIsWithinBounds(params.expected_delay, absl::Now() - start_time)) {
      EXPECT_EQ(params.expected_result, result);
      break;
    }
  }
}

TEST_P(TimeoutTest, ReaderLockWhen) {
  const TimeoutTestParam params = GetParam();
  LOG(INFO) << "Params: " << params;

  // Because this test asserts bounds on scheduling delays it is flaky.  To
  // compensate it loops forever until it passes.  Failures express as test
  // timeouts, in which case the test log can be used to diagnose the issue.
  for (int attempt = 0;; ++attempt) {
    LOG(INFO) << "Attempt " << attempt;

    absl::Mutex mu;
    bool value = false;  // condition value (under mu)

    std::unique_ptr<absl::synchronization_internal::ThreadPool> pool =
        CreateDefaultPool();
    RunAfterDelay(params.satisfy_condition_delay, pool.get(), [&] {
      absl::MutexLock l(&mu);
      value = true;
    });

    absl::Time start_time = absl::Now();
    bool result =
        params.use_absolute_deadline
            ? mu.ReaderLockWhenWithDeadline(absl::Condition(&value),
                                            start_time + params.wait_timeout)
            : mu.ReaderLockWhenWithTimeout(absl::Condition(&value),
                                           params.wait_timeout);
    mu.ReaderUnlock();

    if (DelayIsWithinBounds(params.expected_delay, absl::Now() - start_time)) {
      EXPECT_EQ(params.expected_result, result);
      break;
    }
  }
}

TEST_P(TimeoutTest, Wait) {
  const TimeoutTestParam params = GetParam();
  LOG(INFO) << "Params: " << params;

  // Because this test asserts bounds on scheduling delays it is flaky.  To
  // compensate it loops forever until it passes.  Failures express as test
  // timeouts, in which case the test log can be used to diagnose the issue.
  for (int attempt = 0;; ++attempt) {
    LOG(INFO) << "Attempt " << attempt;

    absl::Mutex mu;
    bool value = false;  // condition value (under mu)
    absl::CondVar cv;    // signals a change of `value`

    std::unique_ptr<absl::synchronization_internal::ThreadPool> pool =
        CreateDefaultPool();
    RunAfterDelay(params.satisfy_condition_delay, pool.get(), [&] {
      absl::MutexLock l(&mu);
      value = true;
      cv.Signal();
    });

    absl::MutexLock lock(&mu);
    absl::Time start_time = absl::Now();
    absl::Duration timeout = params.wait_timeout;
    absl::Time deadline = start_time + timeout;
    while (!value) {
      if (params.use_absolute_deadline ? cv.WaitWithDeadline(&mu, deadline)
                                       : cv.WaitWithTimeout(&mu, timeout)) {
        break;  // deadline/timeout exceeded
      }
      timeout = deadline - absl::Now();  // recompute
    }
    bool result = value;  // note: `mu` is still held

    if (DelayIsWithinBounds(params.expected_delay, absl::Now() - start_time)) {
      EXPECT_EQ(params.expected_result, result);
      break;
    }
  }
}

TEST(Mutex, Logging) {
  // Allow user to look at logging output
  absl::Mutex logged_mutex;
  logged_mutex.EnableDebugLog("fido_mutex");
  absl::CondVar logged_cv;
  logged_cv.EnableDebugLog("rover_cv");
  logged_mutex.Lock();
  logged_cv.WaitWithTimeout(&logged_mutex, absl::Milliseconds(20));
  logged_mutex.Unlock();
  logged_mutex.ReaderLock();
  logged_mutex.ReaderUnlock();
  logged_mutex.Lock();
  logged_mutex.Unlock();
  logged_cv.Signal();
  logged_cv.SignalAll();
}

TEST(Mutex, LoggingAddressReuse) {
  // Repeatedly re-create a Mutex with debug logging at the same address.
  ScopedInvariantDebugging scoped_debugging;
  alignas(absl::Mutex) char storage[sizeof(absl::Mutex)];
  auto invariant =
      +[](void *alive) { EXPECT_TRUE(*static_cast<bool *>(alive)); };
  constexpr size_t kIters = 10;
  bool alive[kIters] = {};
  for (size_t i = 0; i < kIters; ++i) {
    absl::Mutex *mu = new (storage) absl::Mutex;
    alive[i] = true;
    mu->EnableDebugLog("Mutex");
    mu->EnableInvariantDebugging(invariant, &alive[i]);
    mu->Lock();
    mu->Unlock();
    mu->~Mutex();
    alive[i] = false;
  }
}

TEST(Mutex, LoggingBankrupcy) {
  // Test the case with too many live Mutexes with debug logging.
  ScopedInvariantDebugging scoped_debugging;
  std::vector<absl::Mutex> mus(1 << 20);
  for (auto &mu : mus) {
    mu.EnableDebugLog("Mutex");
  }
}

TEST(Mutex, SynchEventRace) {
  // Regression test for a false TSan race report in
  // EnableInvariantDebugging/EnableDebugLog related to SynchEvent reuse.
  ScopedInvariantDebugging scoped_debugging;
  std::vector<std::thread> threads;
  for (size_t i = 0; i < 5; i++) {
    threads.emplace_back([&] {
      for (size_t j = 0; j < (1 << 17); j++) {
        {
          absl::Mutex mu;
          mu.EnableInvariantDebugging([](void *) {}, nullptr);
          mu.Lock();
          mu.Unlock();
        }
        {
          absl::Mutex mu;
          mu.EnableDebugLog("Mutex");
        }
      }
    });
  }
  for (auto &thread : threads) {
    thread.join();
  }
}

// --------------------------------------------------------

// Generate the vector of thread counts for tests parameterized on thread count.
static std::vector<int> AllThreadCountValues() {
  if (kExtendedTest) {
    return {2, 4, 8, 10, 16, 20, 24, 30, 32};
  }
  return {2, 4, 10};
}

// A test fixture parameterized by thread count.
class MutexVariableThreadCountTest : public ::testing::TestWithParam<int> {};

// Instantiate the above with AllThreadCountOptions().
INSTANTIATE_TEST_SUITE_P(ThreadCounts, MutexVariableThreadCountTest,
                         ::testing::ValuesIn(AllThreadCountValues()),
                         ::testing::PrintToStringParamName());

// Reduces iterations by some factor for slow platforms
// (determined empirically).
static int ScaleIterations(int x) {
  // ABSL_MUTEX_READER_LOCK_IS_EXCLUSIVE is set in the implementation
  // of Mutex that uses either std::mutex or pthread_mutex_t. Use
  // these as keys to determine the slow implementation.
#if defined(ABSL_MUTEX_READER_LOCK_IS_EXCLUSIVE)
  return x / 10;
#else
  return x;
#endif
}

TEST_P(MutexVariableThreadCountTest, Mutex) {
  int threads = GetParam();
  int iterations = ScaleIterations(10000000) / threads;
  int operations = threads * iterations;
  EXPECT_EQ(RunTest(&TestMu, threads, iterations, operations), operations);
#if !defined(ABSL_MUTEX_ENABLE_INVARIANT_DEBUGGING_NOT_IMPLEMENTED)
  iterations = std::min(iterations, 10);
  operations = threads * iterations;
  EXPECT_EQ(RunTestWithInvariantDebugging(&TestMu, threads, iterations,
                                          operations, CheckSumG0G1),
            operations);
#endif
}

TEST_P(MutexVariableThreadCountTest, Try) {
  int threads = GetParam();
  int iterations = 1000000 / threads;
  int operations = iterations * threads;
  EXPECT_EQ(RunTest(&TestTry, threads, iterations, operations), operations);
#if !defined(ABSL_MUTEX_ENABLE_INVARIANT_DEBUGGING_NOT_IMPLEMENTED)
  iterations = std::min(iterations, 10);
  operations = threads * iterations;
  EXPECT_EQ(RunTestWithInvariantDebugging(&TestTry, threads, iterations,
                                          operations, CheckSumG0G1),
            operations);
#endif
}

TEST_P(MutexVariableThreadCountTest, R20ms) {
  int threads = GetParam();
  int iterations = 100;
  int operations = iterations * threads;
  EXPECT_EQ(RunTest(&TestR20ms, threads, iterations, operations), 0);
}

TEST_P(MutexVariableThreadCountTest, RW) {
  int threads = GetParam();
  int iterations = ScaleIterations(20000000) / threads;
  int operations = iterations * threads;
  EXPECT_EQ(RunTest(&TestRW, threads, iterations, operations), operations / 2);
#if !defined(ABSL_MUTEX_ENABLE_INVARIANT_DEBUGGING_NOT_IMPLEMENTED)
  iterations = std::min(iterations, 10);
  operations = threads * iterations;
  EXPECT_EQ(RunTestWithInvariantDebugging(&TestRW, threads, iterations,
                                          operations, CheckSumG0G1),
            operations / 2);
#endif
}

TEST_P(MutexVariableThreadCountTest, Await) {
  int threads = GetParam();
  int iterations = ScaleIterations(500000);
  int operations = iterations;
  EXPECT_EQ(RunTest(&TestAwait, threads, iterations, operations), operations);
}

TEST_P(MutexVariableThreadCountTest, SignalAll) {
  int threads = GetParam();
  int iterations = 200000 / threads;
  int operations = iterations;
  EXPECT_EQ(RunTest(&TestSignalAll, threads, iterations, operations),
            operations);
}

TEST(Mutex, Signal) {
  int threads = 2;  // TestSignal must use two threads
  int iterations = 200000;
  int operations = iterations;
  EXPECT_EQ(RunTest(&TestSignal, threads, iterations, operations), operations);
}

TEST(Mutex, Timed) {
  int threads = 10;  // Use a fixed thread count of 10
  int iterations = 1000;
  int operations = iterations;
  EXPECT_EQ(RunTest(&TestCVTimeout, threads, iterations, operations),
            operations);
}

TEST(Mutex, CVTime) {
  int threads = 10;  // Use a fixed thread count of 10
  int iterations = 1;
  EXPECT_EQ(RunTest(&TestCVTime, threads, iterations, 1), threads * iterations);
}

TEST(Mutex, MuTime) {
  int threads = 10;  // Use a fixed thread count of 10
  int iterations = 1;
  EXPECT_EQ(RunTest(&TestMuTime, threads, iterations, 1), threads * iterations);
}

TEST(Mutex, SignalExitedThread) {
  // The test may expose a race when Mutex::Unlock signals a thread
  // that has already exited.
#if defined(__wasm__) || defined(__asmjs__)
  constexpr int kThreads = 1;  // OOMs under WASM
#else
  constexpr int kThreads = 100;
#endif
  std::vector<std::thread> top;
  for (unsigned i = 0; i < 2 * std::thread::hardware_concurrency(); i++) {
    top.emplace_back([&]() {
      for (int i = 0; i < kThreads; i++) {
        absl::Mutex mu;
        std::thread t([&]() {
          mu.Lock();
          mu.Unlock();
        });
        mu.Lock();
        mu.Unlock();
        t.join();
      }
    });
  }
  for (auto &th : top) th.join();
}

TEST(Mutex, WriterPriority) {
  absl::Mutex mu;
  bool wrote = false;
  std::atomic<bool> saw_wrote{false};
  auto readfunc = [&]() {
    for (size_t i = 0; i < 10; ++i) {
      absl::ReaderMutexLock lock(&mu);
      if (wrote) {
        saw_wrote = true;
        break;
      }
      absl::SleepFor(absl::Seconds(1));
    }
  };
  std::thread t1(readfunc);
  absl::SleepFor(absl::Milliseconds(500));
  std::thread t2(readfunc);
  // Note: this test guards against a bug that was related to an uninit
  // PerThreadSynch::priority, so the writer intentionally runs on a new thread.
  std::thread t3([&]() {
    // The writer should be able squeeze between the two alternating readers.
    absl::MutexLock lock(&mu);
    wrote = true;
  });
  t1.join();
  t2.join();
  t3.join();
  EXPECT_TRUE(saw_wrote.load());
}

#ifdef ABSL_HAVE_PTHREAD_GETSCHEDPARAM
TEST(Mutex, CondVarPriority) {
  // A regression test for a bug in condition variable wait morphing,
  // which resulted in the waiting thread getting priority of the waking thread.
  int err = 0;
  sched_param param;
  param.sched_priority = 7;
  std::thread test([&]() {
    err = pthread_setschedparam(pthread_self(), SCHED_FIFO, &param);
  });
  test.join();
  if (err) {
    // Setting priority usually requires special privileges.
    GTEST_SKIP() << "failed to set priority: " << strerror(err);
  }
  absl::Mutex mu;
  absl::CondVar cv;
  bool locked = false;
  bool notified = false;
  bool waiting = false;
  bool morph = false;
  std::thread th([&]() {
    EXPECT_EQ(0, pthread_setschedparam(pthread_self(), SCHED_FIFO, &param));
    mu.Lock();
    locked = true;
    mu.Await(absl::Condition(&notified));
    mu.Unlock();
    EXPECT_EQ(absl::synchronization_internal::GetOrCreateCurrentThreadIdentity()
                  ->per_thread_synch.priority,
              param.sched_priority);
    mu.Lock();
    mu.Await(absl::Condition(&waiting));
    morph = true;
    absl::SleepFor(absl::Seconds(1));
    cv.Signal();
    mu.Unlock();
  });
  mu.Lock();
  mu.Await(absl::Condition(&locked));
  notified = true;
  mu.Unlock();
  mu.Lock();
  waiting = true;
  while (!morph) {
    cv.Wait(&mu);
  }
  mu.Unlock();
  th.join();
  EXPECT_NE(absl::synchronization_internal::GetOrCreateCurrentThreadIdentity()
                ->per_thread_synch.priority,
            param.sched_priority);
}
#endif

TEST(Mutex, LockWhenWithTimeoutResult) {
  // Check various corner cases for Await/LockWhen return value
  // with always true/always false conditions.
  absl::Mutex mu;
  const bool kAlwaysTrue = true, kAlwaysFalse = false;
  const absl::Condition kTrueCond(&kAlwaysTrue), kFalseCond(&kAlwaysFalse);
  EXPECT_TRUE(mu.LockWhenWithTimeout(kTrueCond, absl::Milliseconds(1)));
  mu.Unlock();
  EXPECT_FALSE(mu.LockWhenWithTimeout(kFalseCond, absl::Milliseconds(1)));
  EXPECT_TRUE(mu.AwaitWithTimeout(kTrueCond, absl::Milliseconds(1)));
  EXPECT_FALSE(mu.AwaitWithTimeout(kFalseCond, absl::Milliseconds(1)));
  std::thread th1([&]() {
    EXPECT_TRUE(mu.LockWhenWithTimeout(kTrueCond, absl::Milliseconds(1)));
    mu.Unlock();
  });
  std::thread th2([&]() {
    EXPECT_FALSE(mu.LockWhenWithTimeout(kFalseCond, absl::Milliseconds(1)));
    mu.Unlock();
  });
  absl::SleepFor(absl::Milliseconds(100));
  mu.Unlock();
  th1.join();
  th2.join();
}

}  // namespace
                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/third_party/abseil-cpp/absl/synchronization/notification.cc                     0000664 0000000 0000000 00000005332 14746647661 0027577 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/synchronization/notification.h"

#include <atomic>

#include "absl/base/internal/raw_logging.h"
#include "absl/base/internal/tracing.h"
#include "absl/synchronization/mutex.h"
#include "absl/time/time.h"

namespace absl {
ABSL_NAMESPACE_BEGIN

void Notification::Notify() {
  base_internal::TraceSignal(this, TraceObjectKind());
  MutexLock l(&this->mutex_);

#ifndef NDEBUG
  if (ABSL_PREDICT_FALSE(notified_yet_.load(std::memory_order_relaxed))) {
    ABSL_RAW_LOG(
        FATAL,
        "Notify() method called more than once for Notification object %p",
        static_cast<void *>(this));
  }
#endif

  notified_yet_.store(true, std::memory_order_release);
}

Notification::~Notification() {
  // Make sure that the thread running Notify() exits before the object is
  // destructed.
  MutexLock l(&this->mutex_);
}

void Notification::WaitForNotification() const {
  base_internal::TraceWait(this, TraceObjectKind());
  if (!HasBeenNotifiedInternal(&this->notified_yet_)) {
    this->mutex_.LockWhen(
        Condition(&HasBeenNotifiedInternal, &this->notified_yet_));
    this->mutex_.Unlock();
  }
  base_internal::TraceContinue(this, TraceObjectKind());
}

bool Notification::WaitForNotificationWithTimeout(
    absl::Duration timeout) const {
  base_internal::TraceWait(this, TraceObjectKind());
  bool notified = HasBeenNotifiedInternal(&this->notified_yet_);
  if (!notified) {
    notified = this->mutex_.LockWhenWithTimeout(
        Condition(&HasBeenNotifiedInternal, &this->notified_yet_), timeout);
    this->mutex_.Unlock();
  }
  base_internal::TraceContinue(notified ? this : nullptr, TraceObjectKind());
  return notified;
}

bool Notification::WaitForNotificationWithDeadline(absl::Time deadline) const {
  base_internal::TraceWait(this, TraceObjectKind());
  bool notified = HasBeenNotifiedInternal(&this->notified_yet_);
  if (!notified) {
    notified = this->mutex_.LockWhenWithDeadline(
        Condition(&HasBeenNotifiedInternal, &this->notified_yet_), deadline);
    this->mutex_.Unlock();
  }
  base_internal::TraceContinue(notified ? this : nullptr, TraceObjectKind());
  return notified;
}

ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/third_party/abseil-cpp/absl/synchronization/notification.h                      0000664 0000000 0000000 00000012466 14746647661 0027447 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// -----------------------------------------------------------------------------
// notification.h
// -----------------------------------------------------------------------------
//
// This header file defines a `Notification` abstraction, which allows threads
// to receive notification of a single occurrence of a single event.
//
// The `Notification` object maintains a private boolean "notified" state that
// transitions to `true` at most once. The `Notification` class provides the
// following primary member functions:
//   * `HasBeenNotified()` to query its state
//   * `WaitForNotification*()` to have threads wait until the "notified" state
//      is `true`.
//   * `Notify()` to set the notification's "notified" state to `true` and
//     notify all waiting threads that the event has occurred.
//     This method may only be called once.
//
// Note that while `Notify()` may only be called once, it is perfectly valid to
// call any of the `WaitForNotification*()` methods multiple times, from
// multiple threads -- even after the notification's "notified" state has been
// set -- in which case those methods will immediately return.
//
// Note that the lifetime of a `Notification` requires careful consideration;
// it might not be safe to destroy a notification after calling `Notify()` since
// it is still legal for other threads to call `WaitForNotification*()` methods
// on the notification. However, observers responding to a "notified" state of
// `true` can safely delete the notification without interfering with the call
// to `Notify()` in the other thread.
//
// Memory ordering: For any threads X and Y, if X calls `Notify()`, then any
// action taken by X before it calls `Notify()` is visible to thread Y after:
//  * Y returns from `WaitForNotification()`, or
//  * Y receives a `true` return value from either `HasBeenNotified()` or
//    `WaitForNotificationWithTimeout()`.

#ifndef ABSL_SYNCHRONIZATION_NOTIFICATION_H_
#define ABSL_SYNCHRONIZATION_NOTIFICATION_H_

#include <atomic>

#include "absl/base/attributes.h"
#include "absl/base/internal/tracing.h"
#include "absl/synchronization/mutex.h"
#include "absl/time/time.h"

namespace absl {
ABSL_NAMESPACE_BEGIN

// -----------------------------------------------------------------------------
// Notification
// -----------------------------------------------------------------------------
class Notification {
 public:
  // Initializes the "notified" state to unnotified.
  Notification() : notified_yet_(false) {}
  explicit Notification(bool prenotify) : notified_yet_(prenotify) {}
  Notification(const Notification&) = delete;
  Notification& operator=(const Notification&) = delete;
  ~Notification();

  // Notification::HasBeenNotified()
  //
  // Returns the value of the notification's internal "notified" state.
  ABSL_MUST_USE_RESULT bool HasBeenNotified() const {
    if (HasBeenNotifiedInternal(&this->notified_yet_)) {
      base_internal::TraceObserved(this, TraceObjectKind());
      return true;
    }
    return false;
  }

  // Notification::WaitForNotification()
  //
  // Blocks the calling thread until the notification's "notified" state is
  // `true`. Note that if `Notify()` has been previously called on this
  // notification, this function will immediately return.
  void WaitForNotification() const;

  // Notification::WaitForNotificationWithTimeout()
  //
  // Blocks until either the notification's "notified" state is `true` (which
  // may occur immediately) or the timeout has elapsed, returning the value of
  // its "notified" state in either case.
  bool WaitForNotificationWithTimeout(absl::Duration timeout) const;

  // Notification::WaitForNotificationWithDeadline()
  //
  // Blocks until either the notification's "notified" state is `true` (which
  // may occur immediately) or the deadline has expired, returning the value of
  // its "notified" state in either case.
  bool WaitForNotificationWithDeadline(absl::Time deadline) const;

  // Notification::Notify()
  //
  // Sets the "notified" state of this notification to `true` and wakes waiting
  // threads. Note: do not call `Notify()` multiple times on the same
  // `Notification`; calling `Notify()` more than once on the same notification
  // results in undefined behavior.
  void Notify();

 private:
  // Convenience helper to reduce verbosity at call sites.
  static inline constexpr base_internal::ObjectKind TraceObjectKind() {
    return base_internal::ObjectKind::kNotification;
  }

  static inline bool HasBeenNotifiedInternal(
      const std::atomic<bool>* notified_yet) {
    return notified_yet->load(std::memory_order_acquire);
  }

  mutable Mutex mutex_;
  std::atomic<bool> notified_yet_;  // written under mutex_
};

ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_SYNCHRONIZATION_NOTIFICATION_H_
                                                                                                                                                                                                          node-23.7.0/deps/v8/third_party/abseil-cpp/absl/synchronization/notification_test.cc                0000664 0000000 0000000 00000015753 14746647661 0030646 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/synchronization/notification.h"

#include <thread>  // NOLINT(build/c++11)
#include <tuple>
#include <vector>

#include "gtest/gtest.h"
#include "absl/base/attributes.h"
#include "absl/base/config.h"
#include "absl/base/internal/tracing.h"
#include "absl/synchronization/mutex.h"
#include "absl/time/time.h"

namespace absl {
ABSL_NAMESPACE_BEGIN

// A thread-safe class that holds a counter.
class ThreadSafeCounter {
 public:
  ThreadSafeCounter() : count_(0) {}

  void Increment() {
    MutexLock lock(&mutex_);
    ++count_;
  }

  int Get() const {
    MutexLock lock(&mutex_);
    return count_;
  }

  void WaitUntilGreaterOrEqual(int n) {
    MutexLock lock(&mutex_);
    auto cond = [this, n]() { return count_ >= n; };
    mutex_.Await(Condition(&cond));
  }

 private:
  mutable Mutex mutex_;
  int count_;
};

// Runs the |i|'th worker thread for the tests in BasicTests().  Increments the
// |ready_counter|, waits on the |notification|, and then increments the
// |done_counter|.
static void RunWorker(int i, ThreadSafeCounter* ready_counter,
                      Notification* notification,
                      ThreadSafeCounter* done_counter) {
  ready_counter->Increment();
  notification->WaitForNotification();
  done_counter->Increment();
}

// Tests that the |notification| properly blocks and awakens threads.  Assumes
// that the |notification| is not yet triggered.  If |notify_before_waiting| is
// true, the |notification| is triggered before any threads are created, so the
// threads never block in WaitForNotification().  Otherwise, the |notification|
// is triggered at a later point when most threads are likely to be blocking in
// WaitForNotification().
static void BasicTests(bool notify_before_waiting, Notification* notification) {
  EXPECT_FALSE(notification->HasBeenNotified());
  EXPECT_FALSE(
      notification->WaitForNotificationWithTimeout(absl::Milliseconds(0)));
  EXPECT_FALSE(notification->WaitForNotificationWithDeadline(absl::Now()));

  const absl::Duration delay = absl::Milliseconds(50);
  const absl::Time start = absl::Now();
  EXPECT_FALSE(notification->WaitForNotificationWithTimeout(delay));
  const absl::Duration elapsed = absl::Now() - start;

  // Allow for a slight early return, to account for quality of implementation
  // issues on various platforms.
  const absl::Duration slop = absl::Milliseconds(5);
  EXPECT_LE(delay - slop, elapsed)
      << "WaitForNotificationWithTimeout returned " << delay - elapsed
      << " early (with " << slop << " slop), start time was " << start;

  ThreadSafeCounter ready_counter;
  ThreadSafeCounter done_counter;

  if (notify_before_waiting) {
    notification->Notify();
  }

  // Create a bunch of threads that increment the |done_counter| after being
  // notified.
  const int kNumThreads = 10;
  std::vector<std::thread> workers;
  for (int i = 0; i < kNumThreads; ++i) {
    workers.push_back(std::thread(&RunWorker, i, &ready_counter, notification,
                                  &done_counter));
  }

  if (!notify_before_waiting) {
    ready_counter.WaitUntilGreaterOrEqual(kNumThreads);

    // Workers have not been notified yet, so the |done_counter| should be
    // unmodified.
    EXPECT_EQ(0, done_counter.Get());

    notification->Notify();
  }

  // After notifying and then joining the workers, both counters should be
  // fully incremented.
  notification->WaitForNotification();  // should exit immediately
  EXPECT_TRUE(notification->HasBeenNotified());
  EXPECT_TRUE(notification->WaitForNotificationWithTimeout(absl::Seconds(0)));
  EXPECT_TRUE(notification->WaitForNotificationWithDeadline(absl::Now()));
  for (std::thread& worker : workers) {
    worker.join();
  }
  EXPECT_EQ(kNumThreads, ready_counter.Get());
  EXPECT_EQ(kNumThreads, done_counter.Get());
}

TEST(NotificationTest, SanityTest) {
  Notification local_notification1, local_notification2;
  BasicTests(false, &local_notification1);
  BasicTests(true, &local_notification2);
}

#if ABSL_HAVE_ATTRIBUTE_WEAK

namespace base_internal {

namespace {

using TraceRecord = std::tuple<const void*, ObjectKind>;

thread_local TraceRecord tls_signal;
thread_local TraceRecord tls_wait;
thread_local TraceRecord tls_continue;
thread_local TraceRecord tls_observed;

}  // namespace

// Strong extern "C" implementation.
extern "C" {

void ABSL_INTERNAL_C_SYMBOL(AbslInternalTraceWait)(const void* object,
                                                   ObjectKind kind) {
  tls_wait = {object, kind};
}

void ABSL_INTERNAL_C_SYMBOL(AbslInternalTraceContinue)(const void* object,
                                                       ObjectKind kind) {
  tls_continue = {object, kind};
}

void ABSL_INTERNAL_C_SYMBOL(AbslInternalTraceSignal)(const void* object,
                                                     ObjectKind kind) {
  tls_signal = {object, kind};
}

void ABSL_INTERNAL_C_SYMBOL(AbslInternalTraceObserved)(const void* object,
                                                       ObjectKind kind) {
  tls_observed = {object, kind};
}

}  // extern "C"

TEST(NotificationTest, TracesNotify) {
  Notification n;
  tls_signal = {};
  n.Notify();
  EXPECT_EQ(tls_signal, TraceRecord(&n, ObjectKind::kNotification));
}

TEST(NotificationTest, TracesWaitForNotification) {
  Notification n;
  n.Notify();
  tls_wait = tls_continue = {};
  n.WaitForNotification();
  EXPECT_EQ(tls_wait, TraceRecord(&n, ObjectKind::kNotification));
  EXPECT_EQ(tls_continue, TraceRecord(&n, ObjectKind::kNotification));
}

TEST(NotificationTest, TracesWaitForNotificationWithTimeout) {
  Notification n;

  tls_wait = tls_continue = {};
  n.WaitForNotificationWithTimeout(absl::Milliseconds(1));
  EXPECT_EQ(tls_wait, TraceRecord(&n, ObjectKind::kNotification));
  EXPECT_EQ(tls_continue, TraceRecord(nullptr, ObjectKind::kNotification));

  n.Notify();
  tls_wait = tls_continue = {};
  n.WaitForNotificationWithTimeout(absl::Milliseconds(1));
  EXPECT_EQ(tls_wait, TraceRecord(&n, ObjectKind::kNotification));
  EXPECT_EQ(tls_continue, TraceRecord(&n, ObjectKind::kNotification));
}

TEST(NotificationTest, TracesHasBeenNotified) {
  Notification n;

  tls_observed = {};
  ASSERT_FALSE(n.HasBeenNotified());
  EXPECT_EQ(tls_observed, TraceRecord(nullptr, ObjectKind::kUnknown));

  n.Notify();
  tls_observed = {};
  ASSERT_TRUE(n.HasBeenNotified());
  EXPECT_EQ(tls_observed, TraceRecord(&n, ObjectKind::kNotification));
}

}  // namespace base_internal

#endif  // ABSL_HAVE_ATTRIBUTE_WEAK

ABSL_NAMESPACE_END
}  // namespace absl
                     node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/                                               0000775 0000000 0000000 00000000000 14746647661 0022274 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/BUILD.bazel                                    0000664 0000000 0000000 00000007601 14746647661 0024156 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #
# Copyright 2017 The Abseil Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

load(
    "//absl:copts/configure_copts.bzl",
    "ABSL_DEFAULT_COPTS",
    "ABSL_DEFAULT_LINKOPTS",
    "ABSL_TEST_COPTS",
)

package(
    default_visibility = ["//visibility:public"],
    features = [
        "header_modules",
        "layering_check",
        "parse_headers",
    ],
)

licenses(["notice"])

cc_library(
    name = "time",
    srcs = [
        "civil_time.cc",
        "clock.cc",
        "duration.cc",
        "format.cc",
        "internal/get_current_time_chrono.inc",
        "internal/get_current_time_posix.inc",
        "time.cc",
    ],
    hdrs = [
        "civil_time.h",
        "clock.h",
        "time.h",
    ],
    copts = ABSL_DEFAULT_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    deps = [
        "//absl/base",
        "//absl/base:config",
        "//absl/base:core_headers",
        "//absl/base:raw_logging_internal",
        "//absl/numeric:int128",
        "//absl/strings",
        "//absl/time/internal/cctz:civil_time",
        "//absl/time/internal/cctz:time_zone",
        "//absl/types:optional",
    ],
)

cc_library(
    name = "test_util",
    testonly = True,
    srcs = ["internal/test_util.cc"],
    hdrs = ["internal/test_util.h"],
    copts = ABSL_DEFAULT_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    visibility = ["//visibility:private"],
    deps = [
        ":time",
        "//absl/base:config",
        "//absl/base:raw_logging_internal",
    ],
)

cc_test(
    name = "time_test",
    srcs = [
        "civil_time_test.cc",
        "clock_test.cc",
        "duration_test.cc",
        "format_test.cc",
        "time_test.cc",
        "time_zone_test.cc",
    ],
    copts = ABSL_TEST_COPTS,
    data = ["//absl/time/internal/cctz:zoneinfo"],
    env = {"TZDIR": "absl/time/internal/cctz/testdata/zoneinfo"},
    linkopts = ABSL_DEFAULT_LINKOPTS,
    deps = [
        ":test_util",
        ":time",
        "//absl/base:config",
        "//absl/base:core_headers",
        "//absl/numeric:int128",
        "//absl/strings:str_format",
        "//absl/time/internal/cctz:time_zone",
        "@com_google_googletest//:gtest",
        "@com_google_googletest//:gtest_main",
    ],
)

cc_test(
    name = "flag_test",
    srcs = [
        "flag_test.cc",
    ],
    copts = ABSL_TEST_COPTS,
    linkopts = ABSL_DEFAULT_LINKOPTS,
    tags = [
        "no_test_android_arm",
        "no_test_android_arm64",
        "no_test_android_x86",
        "no_test_ios_x86_64",
        "no_test_lexan",
        "no_test_loonix",
        "no_test_wasm",
    ],
    deps = [
        ":time",
        "//absl/flags:flag",
        "//absl/flags:reflection",
        "@com_google_googletest//:gtest",
        "@com_google_googletest//:gtest_main",
    ],
)

cc_test(
    name = "time_benchmark",
    srcs = [
        "civil_time_benchmark.cc",
        "clock_benchmark.cc",
        "duration_benchmark.cc",
        "format_benchmark.cc",
        "time_benchmark.cc",
    ],
    copts = ABSL_TEST_COPTS,
    data = ["//absl/time/internal/cctz:zoneinfo"],
    env = {"TZDIR": "absl/time/internal/cctz/testdata/zoneinfo"},
    linkopts = ABSL_DEFAULT_LINKOPTS,
    tags = [
        "benchmark",
    ],
    deps = [
        ":test_util",
        ":time",
        "//absl/base",
        "//absl/base:core_headers",
        "//absl/flags:flag",
        "//absl/hash",
        "@com_github_google_benchmark//:benchmark_main",
    ],
)
                                                                                                                               node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/BUILD.gn                                       0000664 0000000 0000000 00000003456 14746647661 0023471 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2018 The Chromium Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//third_party/abseil-cpp/absl.gni")

absl_source_set("time") {
  sources = [
    "civil_time.cc",
    "clock.cc",
    "duration.cc",
    "format.cc",
    "internal/get_current_time_chrono.inc",
    "internal/get_current_time_posix.inc",
    "time.cc",
  ]
  public = [
    "civil_time.h",
    "clock.h",
    "time.h",
  ]
  deps = [
    "//third_party/abseil-cpp/absl/base",
    "//third_party/abseil-cpp/absl/base:config",
    "//third_party/abseil-cpp/absl/base:core_headers",
    "//third_party/abseil-cpp/absl/base:raw_logging_internal",
    "//third_party/abseil-cpp/absl/numeric:int128",
    "//third_party/abseil-cpp/absl/strings",
    "//third_party/abseil-cpp/absl/strings:string_view",
    "//third_party/abseil-cpp/absl/time/internal/cctz:civil_time",
    "//third_party/abseil-cpp/absl/time/internal/cctz:time_zone",
    "//third_party/abseil-cpp/absl/types:optional",
  ]
}

absl_source_set("test_util") {
  testonly = true
  sources = [ "internal/test_util.cc" ]
  public = [ "internal/test_util.h" ]
  deps = [
    ":time",
    "//third_party/abseil-cpp/absl/base:config",
    "//third_party/abseil-cpp/absl/base:raw_logging_internal",
  ]
  visibility = [ ":*" ]
}

absl_test("time_test") {
  sources = [
    "civil_time_test.cc",
    "clock_test.cc",
    "duration_test.cc",
    "format_test.cc",
    "time_test.cc",
    "time_zone_test.cc",
  ]
  deps = [
    ":test_util",
    ":time",
    "//third_party/abseil-cpp/absl/base:config",
    "//third_party/abseil-cpp/absl/base:core_headers",
    "//third_party/abseil-cpp/absl/numeric:int128",
    "//third_party/abseil-cpp/absl/strings:str_format",
    "//third_party/abseil-cpp/absl/time/internal/cctz:time_zone",
  ]
}
                                                                                                                                                                                                                  node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/CMakeLists.txt                                 0000664 0000000 0000000 00000006215 14746647661 0025040 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #
# Copyright 2017 The Abseil Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

absl_cc_library(
  NAME
    time
  HDRS
    "civil_time.h"
    "clock.h"
    "time.h"
  SRCS
    "civil_time.cc"
    "clock.cc"
    "duration.cc"
    "format.cc"
    "internal/get_current_time_chrono.inc"
    "internal/get_current_time_posix.inc"
    "time.cc"
  COPTS
    ${ABSL_DEFAULT_COPTS}
  DEPS
    absl::base
    absl::civil_time
    absl::core_headers
    absl::int128
    absl::raw_logging_internal
    absl::strings
    absl::time_zone
  PUBLIC
)

absl_cc_library(
  NAME
    civil_time
  HDRS
    "internal/cctz/include/cctz/civil_time.h"
    "internal/cctz/include/cctz/civil_time_detail.h"
  SRCS
  "internal/cctz/src/civil_time_detail.cc"
  COPTS
    ${ABSL_DEFAULT_COPTS}
)

absl_cc_library(
  NAME
    time_zone
  HDRS
    "internal/cctz/include/cctz/time_zone.h"
    "internal/cctz/include/cctz/zone_info_source.h"
  SRCS
    "internal/cctz/src/time_zone_fixed.cc"
    "internal/cctz/src/time_zone_fixed.h"
    "internal/cctz/src/time_zone_format.cc"
    "internal/cctz/src/time_zone_if.cc"
    "internal/cctz/src/time_zone_if.h"
    "internal/cctz/src/time_zone_impl.cc"
    "internal/cctz/src/time_zone_impl.h"
    "internal/cctz/src/time_zone_info.cc"
    "internal/cctz/src/time_zone_info.h"
    "internal/cctz/src/time_zone_libc.cc"
    "internal/cctz/src/time_zone_libc.h"
    "internal/cctz/src/time_zone_lookup.cc"
    "internal/cctz/src/time_zone_posix.cc"
    "internal/cctz/src/time_zone_posix.h"
    "internal/cctz/src/tzfile.h"
    "internal/cctz/src/zone_info_source.cc"
  COPTS
    ${ABSL_DEFAULT_COPTS}
  DEPS
    Threads::Threads
    # TODO(#1495): Use $<LINK_LIBRARY:FRAMEWORK,CoreFoundation> once our
    # minimum CMake version >= 3.24
    $<$<PLATFORM_ID:Darwin,iOS,tvOS,visionOS,watchOS>:-Wl,-framework,CoreFoundation>
)

# Internal-only target, do not depend on directly.
absl_cc_library(
  NAME
    time_internal_test_util
  HDRS
    "internal/test_util.h"
  SRCS
    "internal/test_util.cc"
  COPTS
    ${ABSL_DEFAULT_COPTS}
  DEPS
    absl::time
    absl::config
    absl::raw_logging_internal
    absl::time_zone
  TESTONLY
)

absl_cc_test(
  NAME
    time_test
  SRCS
    "civil_time_test.cc"
    "clock_test.cc"
    "duration_test.cc"
    "format_test.cc"
    "time_test.cc"
    "time_zone_test.cc"
  COPTS
    ${ABSL_TEST_COPTS}
  DEPS
    absl::time_internal_test_util
    absl::time
    absl::config
    absl::core_headers
    absl::strings
    absl::str_format
    absl::time_zone
    GTest::gmock_main
)

absl_cc_test(
  NAME
    flag_test
  SRCS
    "flag_test.cc"
  COPTS
    ${ABSL_TEST_COPTS}
  DEPS
    absl::flags
    absl::flags_reflection
    GTest::gmock_main
)
                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/civil_time.cc                                  0000664 0000000 0000000 00000015117 14746647661 0024734 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/time/civil_time.h"

#include <cstdlib>
#include <ostream>
#include <string>

#include "absl/strings/str_cat.h"
#include "absl/time/time.h"

namespace absl {
ABSL_NAMESPACE_BEGIN

namespace {

// Since a civil time has a larger year range than absl::Time (64-bit years vs
// 64-bit seconds, respectively) we normalize years to roughly +/- 400 years
// around the year 2400, which will produce an equivalent year in a range that
// absl::Time can handle.
inline civil_year_t NormalizeYear(civil_year_t year) {
  return 2400 + year % 400;
}

// Formats the given CivilSecond according to the given format.
std::string FormatYearAnd(string_view fmt, CivilSecond cs) {
  const CivilSecond ncs(NormalizeYear(cs.year()), cs.month(), cs.day(),
                        cs.hour(), cs.minute(), cs.second());
  const TimeZone utc = UTCTimeZone();
  return StrCat(cs.year(), FormatTime(fmt, FromCivil(ncs, utc), utc));
}

template <typename CivilT>
bool ParseYearAnd(string_view fmt, string_view s, CivilT* c) {
  // Civil times support a larger year range than absl::Time, so we need to
  // parse the year separately, normalize it, then use absl::ParseTime on the
  // normalized string.
  const std::string ss = std::string(s);  // TODO(absl-team): Avoid conversion.
  const char* const np = ss.c_str();
  char* endp;
  errno = 0;
  const civil_year_t y =
      std::strtoll(np, &endp, 10);  // NOLINT(runtime/deprecated_fn)
  if (endp == np || errno == ERANGE) return false;
  const std::string norm = StrCat(NormalizeYear(y), endp);

  const TimeZone utc = UTCTimeZone();
  Time t;
  if (ParseTime(StrCat("%Y", fmt), norm, utc, &t, nullptr)) {
    const auto cs = ToCivilSecond(t, utc);
    *c = CivilT(y, cs.month(), cs.day(), cs.hour(), cs.minute(), cs.second());
    return true;
  }

  return false;
}

// Tries to parse the type as a CivilT1, but then assigns the result to the
// argument of type CivilT2.
template <typename CivilT1, typename CivilT2>
bool ParseAs(string_view s, CivilT2* c) {
  CivilT1 t1;
  if (ParseCivilTime(s, &t1)) {
    *c = CivilT2(t1);
    return true;
  }
  return false;
}

template <typename CivilT>
bool ParseLenient(string_view s, CivilT* c) {
  // A fastpath for when the given string data parses exactly into the given
  // type T (e.g., s="YYYY-MM-DD" and CivilT=CivilDay).
  if (ParseCivilTime(s, c)) return true;
  // Try parsing as each of the 6 types, trying the most common types first
  // (based on csearch results).
  if (ParseAs<CivilDay>(s, c)) return true;
  if (ParseAs<CivilSecond>(s, c)) return true;
  if (ParseAs<CivilHour>(s, c)) return true;
  if (ParseAs<CivilMonth>(s, c)) return true;
  if (ParseAs<CivilMinute>(s, c)) return true;
  if (ParseAs<CivilYear>(s, c)) return true;
  return false;
}
}  // namespace

std::string FormatCivilTime(CivilSecond c) {
  return FormatYearAnd("-%m-%d%ET%H:%M:%S", c);
}
std::string FormatCivilTime(CivilMinute c) {
  return FormatYearAnd("-%m-%d%ET%H:%M", c);
}
std::string FormatCivilTime(CivilHour c) {
  return FormatYearAnd("-%m-%d%ET%H", c);
}
std::string FormatCivilTime(CivilDay c) { return FormatYearAnd("-%m-%d", c); }
std::string FormatCivilTime(CivilMonth c) { return FormatYearAnd("-%m", c); }
std::string FormatCivilTime(CivilYear c) { return FormatYearAnd("", c); }

bool ParseCivilTime(string_view s, CivilSecond* c) {
  return ParseYearAnd("-%m-%d%ET%H:%M:%S", s, c);
}
bool ParseCivilTime(string_view s, CivilMinute* c) {
  return ParseYearAnd("-%m-%d%ET%H:%M", s, c);
}
bool ParseCivilTime(string_view s, CivilHour* c) {
  return ParseYearAnd("-%m-%d%ET%H", s, c);
}
bool ParseCivilTime(string_view s, CivilDay* c) {
  return ParseYearAnd("-%m-%d", s, c);
}
bool ParseCivilTime(string_view s, CivilMonth* c) {
  return ParseYearAnd("-%m", s, c);
}
bool ParseCivilTime(string_view s, CivilYear* c) {
  return ParseYearAnd("", s, c);
}

bool ParseLenientCivilTime(string_view s, CivilSecond* c) {
  return ParseLenient(s, c);
}
bool ParseLenientCivilTime(string_view s, CivilMinute* c) {
  return ParseLenient(s, c);
}
bool ParseLenientCivilTime(string_view s, CivilHour* c) {
  return ParseLenient(s, c);
}
bool ParseLenientCivilTime(string_view s, CivilDay* c) {
  return ParseLenient(s, c);
}
bool ParseLenientCivilTime(string_view s, CivilMonth* c) {
  return ParseLenient(s, c);
}
bool ParseLenientCivilTime(string_view s, CivilYear* c) {
  return ParseLenient(s, c);
}

namespace time_internal {

std::ostream& operator<<(std::ostream& os, CivilYear y) {
  return os << FormatCivilTime(y);
}
std::ostream& operator<<(std::ostream& os, CivilMonth m) {
  return os << FormatCivilTime(m);
}
std::ostream& operator<<(std::ostream& os, CivilDay d) {
  return os << FormatCivilTime(d);
}
std::ostream& operator<<(std::ostream& os, CivilHour h) {
  return os << FormatCivilTime(h);
}
std::ostream& operator<<(std::ostream& os, CivilMinute m) {
  return os << FormatCivilTime(m);
}
std::ostream& operator<<(std::ostream& os, CivilSecond s) {
  return os << FormatCivilTime(s);
}

bool AbslParseFlag(string_view s, CivilSecond* c, std::string*) {
  return ParseLenientCivilTime(s, c);
}
bool AbslParseFlag(string_view s, CivilMinute* c, std::string*) {
  return ParseLenientCivilTime(s, c);
}
bool AbslParseFlag(string_view s, CivilHour* c, std::string*) {
  return ParseLenientCivilTime(s, c);
}
bool AbslParseFlag(string_view s, CivilDay* c, std::string*) {
  return ParseLenientCivilTime(s, c);
}
bool AbslParseFlag(string_view s, CivilMonth* c, std::string*) {
  return ParseLenientCivilTime(s, c);
}
bool AbslParseFlag(string_view s, CivilYear* c, std::string*) {
  return ParseLenientCivilTime(s, c);
}
std::string AbslUnparseFlag(CivilSecond c) { return FormatCivilTime(c); }
std::string AbslUnparseFlag(CivilMinute c) { return FormatCivilTime(c); }
std::string AbslUnparseFlag(CivilHour c) { return FormatCivilTime(c); }
std::string AbslUnparseFlag(CivilDay c) { return FormatCivilTime(c); }
std::string AbslUnparseFlag(CivilMonth c) { return FormatCivilTime(c); }
std::string AbslUnparseFlag(CivilYear c) { return FormatCivilTime(c); }

}  // namespace time_internal

ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/civil_time.h                                   0000664 0000000 0000000 00000054320 14746647661 0024575 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// -----------------------------------------------------------------------------
// File: civil_time.h
// -----------------------------------------------------------------------------
//
// This header file defines abstractions for computing with "civil time".
// The term "civil time" refers to the legally recognized human-scale time
// that is represented by the six fields `YYYY-MM-DD hh:mm:ss`. A "date"
// is perhaps the most common example of a civil time (represented here as
// an `absl::CivilDay`).
//
// Modern-day civil time follows the Gregorian Calendar and is a
// time-zone-independent concept: a civil time of "2015-06-01 12:00:00", for
// example, is not tied to a time zone. Put another way, a civil time does not
// map to a unique point in time; a civil time must be mapped to an absolute
// time *through* a time zone.
//
// Because a civil time is what most people think of as "time," it is common to
// map absolute times to civil times to present to users.
//
// Time zones define the relationship between absolute and civil times. Given an
// absolute or civil time and a time zone, you can compute the other time:
//
//   Civil Time = F(Absolute Time, Time Zone)
//   Absolute Time = G(Civil Time, Time Zone)
//
// The Abseil time library allows you to construct such civil times from
// absolute times; consult time.h for such functionality.
//
// This library provides six classes for constructing civil-time objects, and
// provides several helper functions for rounding, iterating, and performing
// arithmetic on civil-time objects, while avoiding complications like
// daylight-saving time (DST):
//
//   * `absl::CivilSecond`
//   * `absl::CivilMinute`
//   * `absl::CivilHour`
//   * `absl::CivilDay`
//   * `absl::CivilMonth`
//   * `absl::CivilYear`
//
// Example:
//
//   // Construct a civil-time object for a specific day
//   const absl::CivilDay cd(1969, 7, 20);
//
//   // Construct a civil-time object for a specific second
//   const absl::CivilSecond cd(2018, 8, 1, 12, 0, 1);
//
// Note: In C++14 and later, this library is usable in a constexpr context.
//
// Example:
//
//   // Valid in C++14
//   constexpr absl::CivilDay cd(1969, 7, 20);

#ifndef ABSL_TIME_CIVIL_TIME_H_
#define ABSL_TIME_CIVIL_TIME_H_

#include <iosfwd>
#include <string>

#include "absl/base/config.h"
#include "absl/strings/string_view.h"
#include "absl/time/internal/cctz/include/cctz/civil_time.h"

namespace absl {
ABSL_NAMESPACE_BEGIN

namespace time_internal {
struct second_tag : cctz::detail::second_tag {};
struct minute_tag : second_tag, cctz::detail::minute_tag {};
struct hour_tag : minute_tag, cctz::detail::hour_tag {};
struct day_tag : hour_tag, cctz::detail::day_tag {};
struct month_tag : day_tag, cctz::detail::month_tag {};
struct year_tag : month_tag, cctz::detail::year_tag {};
}  // namespace time_internal

// -----------------------------------------------------------------------------
// CivilSecond, CivilMinute, CivilHour, CivilDay, CivilMonth, CivilYear
// -----------------------------------------------------------------------------
//
// Each of these civil-time types is a simple value type with the same
// interface for construction and the same six accessors for each of the civil
// time fields (year, month, day, hour, minute, and second, aka YMDHMS). These
// classes differ only in their alignment, which is indicated by the type name
// and specifies the field on which arithmetic operates.
//
// CONSTRUCTION
//
// Each of the civil-time types can be constructed in two ways: by directly
// passing to the constructor up to six integers representing the YMDHMS fields,
// or by copying the YMDHMS fields from a differently aligned civil-time type.
// Omitted fields are assigned their minimum valid value. Hours, minutes, and
// seconds will be set to 0, month and day will be set to 1. Since there is no
// minimum year, the default is 1970.
//
// Examples:
//
//   absl::CivilDay default_value;               // 1970-01-01 00:00:00
//
//   absl::CivilDay a(2015, 2, 3);               // 2015-02-03 00:00:00
//   absl::CivilDay b(2015, 2, 3, 4, 5, 6);      // 2015-02-03 00:00:00
//   absl::CivilDay c(2015);                     // 2015-01-01 00:00:00
//
//   absl::CivilSecond ss(2015, 2, 3, 4, 5, 6);  // 2015-02-03 04:05:06
//   absl::CivilMinute mm(ss);                   // 2015-02-03 04:05:00
//   absl::CivilHour hh(mm);                     // 2015-02-03 04:00:00
//   absl::CivilDay d(hh);                       // 2015-02-03 00:00:00
//   absl::CivilMonth m(d);                      // 2015-02-01 00:00:00
//   absl::CivilYear y(m);                       // 2015-01-01 00:00:00
//
//   m = absl::CivilMonth(y);                    // 2015-01-01 00:00:00
//   d = absl::CivilDay(m);                      // 2015-01-01 00:00:00
//   hh = absl::CivilHour(d);                    // 2015-01-01 00:00:00
//   mm = absl::CivilMinute(hh);                 // 2015-01-01 00:00:00
//   ss = absl::CivilSecond(mm);                 // 2015-01-01 00:00:00
//
// Each civil-time class is aligned to the civil-time field indicated in the
// class's name after normalization. Alignment is performed by setting all the
// inferior fields to their minimum valid value (as described above). The
// following are examples of how each of the six types would align the fields
// representing November 22, 2015 at 12:34:56 in the afternoon. (Note: the
// string format used here is not important; it's just a shorthand way of
// showing the six YMDHMS fields.)
//
//   absl::CivilSecond   : 2015-11-22 12:34:56
//   absl::CivilMinute   : 2015-11-22 12:34:00
//   absl::CivilHour     : 2015-11-22 12:00:00
//   absl::CivilDay      : 2015-11-22 00:00:00
//   absl::CivilMonth    : 2015-11-01 00:00:00
//   absl::CivilYear     : 2015-01-01 00:00:00
//
// Each civil-time type performs arithmetic on the field to which it is
// aligned. This means that adding 1 to an absl::CivilDay increments the day
// field (normalizing as necessary), and subtracting 7 from an absl::CivilMonth
// operates on the month field (normalizing as necessary). All arithmetic
// produces a valid civil time. Difference requires two similarly aligned
// civil-time objects and returns the scalar answer in units of the objects'
// alignment. For example, the difference between two absl::CivilHour objects
// will give an answer in units of civil hours.
//
// ALIGNMENT CONVERSION
//
// The alignment of a civil-time object cannot change, but the object may be
// used to construct a new object with a different alignment. This is referred
// to as "realigning". When realigning to a type with the same or more
// precision (e.g., absl::CivilDay -> absl::CivilSecond), the conversion may be
// performed implicitly since no information is lost. However, if information
// could be discarded (e.g., CivilSecond -> CivilDay), the conversion must
// be explicit at the call site.
//
// Examples:
//
//   void UseDay(absl::CivilDay day);
//
//   absl::CivilSecond cs;
//   UseDay(cs);                  // Won't compile because data may be discarded
//   UseDay(absl::CivilDay(cs));  // OK: explicit conversion
//
//   absl::CivilDay cd;
//   UseDay(cd);                  // OK: no conversion needed
//
//   absl::CivilMonth cm;
//   UseDay(cm);                  // OK: implicit conversion to absl::CivilDay
//
// NORMALIZATION
//
// Normalization takes invalid values and adjusts them to produce valid values.
// Within the civil-time library, integer arguments passed to the Civil*
// constructors may be out-of-range, in which case they are normalized by
// carrying overflow into a field of courser granularity to produce valid
// civil-time objects. This normalization enables natural arithmetic on
// constructor arguments without worrying about the field's range.
//
// Examples:
//
//   // Out-of-range; normalized to 2016-11-01
//   absl::CivilDay d(2016, 10, 32);
//   // Out-of-range, negative: normalized to 2016-10-30T23
//   absl::CivilHour h1(2016, 10, 31, -1);
//   // Normalization is cumulative: normalized to 2016-10-30T23
//   absl::CivilHour h2(2016, 10, 32, -25);
//
// Note: If normalization is undesired, you can signal an error by comparing
// the constructor arguments to the normalized values returned by the YMDHMS
// properties.
//
// COMPARISON
//
// Comparison between civil-time objects considers all six YMDHMS fields,
// regardless of the type's alignment. Comparison between differently aligned
// civil-time types is allowed.
//
// Examples:
//
//   absl::CivilDay feb_3(2015, 2, 3);  // 2015-02-03 00:00:00
//   absl::CivilDay mar_4(2015, 3, 4);  // 2015-03-04 00:00:00
//   // feb_3 < mar_4
//   // absl::CivilYear(feb_3) == absl::CivilYear(mar_4)
//
//   absl::CivilSecond feb_3_noon(2015, 2, 3, 12, 0, 0);  // 2015-02-03 12:00:00
//   // feb_3 < feb_3_noon
//   // feb_3 == absl::CivilDay(feb_3_noon)
//
//   // Iterates all the days of February 2015.
//   for (absl::CivilDay d(2015, 2, 1); d < absl::CivilMonth(2015, 3); ++d) {
//     // ...
//   }
//
// ARITHMETIC
//
// Civil-time types support natural arithmetic operators such as addition,
// subtraction, and difference. Arithmetic operates on the civil-time field
// indicated in the type's name. Difference operators require arguments with
// the same alignment and return the answer in units of the alignment.
//
// Example:
//
//   absl::CivilDay a(2015, 2, 3);
//   ++a;                              // 2015-02-04 00:00:00
//   --a;                              // 2015-02-03 00:00:00
//   absl::CivilDay b = a + 1;         // 2015-02-04 00:00:00
//   absl::CivilDay c = 1 + b;         // 2015-02-05 00:00:00
//   int n = c - a;                    // n = 2 (civil days)
//   int m = c - absl::CivilMonth(c);  // Won't compile: different types.
//
// ACCESSORS
//
// Each civil-time type has accessors for all six of the civil-time fields:
// year, month, day, hour, minute, and second.
//
// civil_year_t year()
// int          month()
// int          day()
// int          hour()
// int          minute()
// int          second()
//
// Recall that fields inferior to the type's alignment will be set to their
// minimum valid value.
//
// Example:
//
//   absl::CivilDay d(2015, 6, 28);
//   // d.year() == 2015
//   // d.month() == 6
//   // d.day() == 28
//   // d.hour() == 0
//   // d.minute() == 0
//   // d.second() == 0
//
// CASE STUDY: Adding a month to January 31.
//
// One of the classic questions that arises when considering a civil time
// library (or a date library or a date/time library) is this:
//   "What is the result of adding a month to January 31?"
// This is an interesting question because it is unclear what is meant by a
// "month", and several different answers are possible, depending on context:
//
//   1. March 3 (or 2 if a leap year), if "add a month" means to add a month to
//      the current month, and adjust the date to overflow the extra days into
//      March. In this case the result of "February 31" would be normalized as
//      within the civil-time library.
//   2. February 28 (or 29 if a leap year), if "add a month" means to add a
//      month, and adjust the date while holding the resulting month constant.
//      In this case, the result of "February 31" would be truncated to the last
//      day in February.
//   3. An error. The caller may get some error, an exception, an invalid date
//      object, or perhaps return `false`. This may make sense because there is
//      no single unambiguously correct answer to the question.
//
// Practically speaking, any answer that is not what the programmer intended
// is the wrong answer.
//
// The Abseil time library avoids this problem by making it impossible to
// ask ambiguous questions. All civil-time objects are aligned to a particular
// civil-field boundary (such as aligned to a year, month, day, hour, minute,
// or second), and arithmetic operates on the field to which the object is
// aligned. This means that in order to "add a month" the object must first be
// aligned to a month boundary, which is equivalent to the first day of that
// month.
//
// Of course, there are ways to compute an answer the question at hand using
// this Abseil time library, but they require the programmer to be explicit
// about the answer they expect. To illustrate, let's see how to compute all
// three of the above possible answers to the question of "Jan 31 plus 1
// month":
//
// Example:
//
//   const absl::CivilDay d(2015, 1, 31);
//
//   // Answer 1:
//   // Add 1 to the month field in the constructor, and rely on normalization.
//   const auto normalized = absl::CivilDay(d.year(), d.month() + 1, d.day());
//   // normalized == 2015-03-03 (aka Feb 31)
//
//   // Answer 2:
//   // Add 1 to month field, capping to the end of next month.
//   const auto next_month = absl::CivilMonth(d) + 1;
//   const auto last_day_of_next_month = absl::CivilDay(next_month + 1) - 1;
//   const auto capped = std::min(normalized, last_day_of_next_month);
//   // capped == 2015-02-28
//
//   // Answer 3:
//   // Signal an error if the normalized answer is not in next month.
//   if (absl::CivilMonth(normalized) != next_month) {
//     // error, month overflow
//   }
//
using CivilSecond =
    time_internal::cctz::detail::civil_time<time_internal::second_tag>;
using CivilMinute =
    time_internal::cctz::detail::civil_time<time_internal::minute_tag>;
using CivilHour =
    time_internal::cctz::detail::civil_time<time_internal::hour_tag>;
using CivilDay =
    time_internal::cctz::detail::civil_time<time_internal::day_tag>;
using CivilMonth =
    time_internal::cctz::detail::civil_time<time_internal::month_tag>;
using CivilYear =
    time_internal::cctz::detail::civil_time<time_internal::year_tag>;

// civil_year_t
//
// Type alias of a civil-time year value. This type is guaranteed to (at least)
// support any year value supported by `time_t`.
//
// Example:
//
//   absl::CivilSecond cs = ...;
//   absl::civil_year_t y = cs.year();
//   cs = absl::CivilSecond(y, 1, 1, 0, 0, 0);  // CivilSecond(CivilYear(cs))
//
using civil_year_t = time_internal::cctz::year_t;

// civil_diff_t
//
// Type alias of the difference between two civil-time values.
// This type is used to indicate arguments that are not
// normalized (such as parameters to the civil-time constructors), the results
// of civil-time subtraction, or the operand to civil-time addition.
//
// Example:
//
//   absl::civil_diff_t n_sec = cs1 - cs2;             // cs1 == cs2 + n_sec;
//
using civil_diff_t = time_internal::cctz::diff_t;

// Weekday::monday, Weekday::tuesday, Weekday::wednesday, Weekday::thursday,
// Weekday::friday, Weekday::saturday, Weekday::sunday
//
// The Weekday enum class represents the civil-time concept of a "weekday" with
// members for all days of the week.
//
//   absl::Weekday wd = absl::Weekday::thursday;
//
using Weekday = time_internal::cctz::weekday;

// GetWeekday()
//
// Returns the absl::Weekday for the given (realigned) civil-time value.
//
// Example:
//
//   absl::CivilDay a(2015, 8, 13);
//   absl::Weekday wd = absl::GetWeekday(a);  // wd == absl::Weekday::thursday
//
inline Weekday GetWeekday(CivilSecond cs) {
  return time_internal::cctz::get_weekday(cs);
}

// NextWeekday()
// PrevWeekday()
//
// Returns the absl::CivilDay that strictly follows or precedes a given
// absl::CivilDay, and that falls on the given absl::Weekday.
//
// Example, given the following month:
//
//       August 2015
//   Su Mo Tu We Th Fr Sa
//                      1
//    2  3  4  5  6  7  8
//    9 10 11 12 13 14 15
//   16 17 18 19 20 21 22
//   23 24 25 26 27 28 29
//   30 31
//
//   absl::CivilDay a(2015, 8, 13);
//   // absl::GetWeekday(a) == absl::Weekday::thursday
//   absl::CivilDay b = absl::NextWeekday(a, absl::Weekday::thursday);
//   // b = 2015-08-20
//   absl::CivilDay c = absl::PrevWeekday(a, absl::Weekday::thursday);
//   // c = 2015-08-06
//
//   absl::CivilDay d = ...
//   // Gets the following Thursday if d is not already Thursday
//   absl::CivilDay thurs1 = absl::NextWeekday(d - 1, absl::Weekday::thursday);
//   // Gets the previous Thursday if d is not already Thursday
//   absl::CivilDay thurs2 = absl::PrevWeekday(d + 1, absl::Weekday::thursday);
//
inline CivilDay NextWeekday(CivilDay cd, Weekday wd) {
  return CivilDay(time_internal::cctz::next_weekday(cd, wd));
}
inline CivilDay PrevWeekday(CivilDay cd, Weekday wd) {
  return CivilDay(time_internal::cctz::prev_weekday(cd, wd));
}

// GetYearDay()
//
// Returns the day-of-year for the given (realigned) civil-time value.
//
// Example:
//
//   absl::CivilDay a(2015, 1, 1);
//   int yd_jan_1 = absl::GetYearDay(a);   // yd_jan_1 = 1
//   absl::CivilDay b(2015, 12, 31);
//   int yd_dec_31 = absl::GetYearDay(b);  // yd_dec_31 = 365
//
inline int GetYearDay(CivilSecond cs) {
  return time_internal::cctz::get_yearday(cs);
}

// FormatCivilTime()
//
// Formats the given civil-time value into a string value of the following
// format:
//
//  Type        | Format
//  ---------------------------------
//  CivilSecond | YYYY-MM-DDTHH:MM:SS
//  CivilMinute | YYYY-MM-DDTHH:MM
//  CivilHour   | YYYY-MM-DDTHH
//  CivilDay    | YYYY-MM-DD
//  CivilMonth  | YYYY-MM
//  CivilYear   | YYYY
//
// Example:
//
//   absl::CivilDay d = absl::CivilDay(1969, 7, 20);
//   std::string day_string = absl::FormatCivilTime(d);  // "1969-07-20"
//
std::string FormatCivilTime(CivilSecond c);
std::string FormatCivilTime(CivilMinute c);
std::string FormatCivilTime(CivilHour c);
std::string FormatCivilTime(CivilDay c);
std::string FormatCivilTime(CivilMonth c);
std::string FormatCivilTime(CivilYear c);

// Support for StrFormat(), StrCat(), etc
template <typename Sink>
void AbslStringify(Sink& sink, CivilSecond c) {
  sink.Append(FormatCivilTime(c));
}
template <typename Sink>
void AbslStringify(Sink& sink, CivilMinute c) {
  sink.Append(FormatCivilTime(c));
}
template <typename Sink>
void AbslStringify(Sink& sink, CivilHour c) {
  sink.Append(FormatCivilTime(c));
}
template <typename Sink>
void AbslStringify(Sink& sink, CivilDay c) {
  sink.Append(FormatCivilTime(c));
}
template <typename Sink>
void AbslStringify(Sink& sink, CivilMonth c) {
  sink.Append(FormatCivilTime(c));
}
template <typename Sink>
void AbslStringify(Sink& sink, CivilYear c) {
  sink.Append(FormatCivilTime(c));
}

// absl::ParseCivilTime()
//
// Parses a civil-time value from the specified `absl::string_view` into the
// passed output parameter. Returns `true` upon successful parsing.
//
// The expected form of the input string is as follows:
//
//  Type        | Format
//  ---------------------------------
//  CivilSecond | YYYY-MM-DDTHH:MM:SS
//  CivilMinute | YYYY-MM-DDTHH:MM
//  CivilHour   | YYYY-MM-DDTHH
//  CivilDay    | YYYY-MM-DD
//  CivilMonth  | YYYY-MM
//  CivilYear   | YYYY
//
// Example:
//
//   absl::CivilDay d;
//   bool ok = absl::ParseCivilTime("2018-01-02", &d); // OK
//
// Note that parsing will fail if the string's format does not match the
// expected type exactly. `ParseLenientCivilTime()` below is more lenient.
//
bool ParseCivilTime(absl::string_view s, CivilSecond* c);
bool ParseCivilTime(absl::string_view s, CivilMinute* c);
bool ParseCivilTime(absl::string_view s, CivilHour* c);
bool ParseCivilTime(absl::string_view s, CivilDay* c);
bool ParseCivilTime(absl::string_view s, CivilMonth* c);
bool ParseCivilTime(absl::string_view s, CivilYear* c);

// ParseLenientCivilTime()
//
// Parses any of the formats accepted by `absl::ParseCivilTime()`, but is more
// lenient if the format of the string does not exactly match the associated
// type.
//
// Example:
//
//   absl::CivilDay d;
//   bool ok = absl::ParseLenientCivilTime("1969-07-20", &d); // OK
//   ok = absl::ParseLenientCivilTime("1969-07-20T10", &d);   // OK: T10 floored
//   ok = absl::ParseLenientCivilTime("1969-07", &d);   // OK: day defaults to 1
//
bool ParseLenientCivilTime(absl::string_view s, CivilSecond* c);
bool ParseLenientCivilTime(absl::string_view s, CivilMinute* c);
bool ParseLenientCivilTime(absl::string_view s, CivilHour* c);
bool ParseLenientCivilTime(absl::string_view s, CivilDay* c);
bool ParseLenientCivilTime(absl::string_view s, CivilMonth* c);
bool ParseLenientCivilTime(absl::string_view s, CivilYear* c);

namespace time_internal {  // For functions found via ADL on civil-time tags.

// Streaming Operators
//
// Each civil-time type may be sent to an output stream using operator<<().
// The result matches the string produced by `FormatCivilTime()`.
//
// Example:
//
//   absl::CivilDay d = absl::CivilDay(1969, 7, 20);
//   std::cout << "Date is: " << d << "\n";
//
std::ostream& operator<<(std::ostream& os, CivilYear y);
std::ostream& operator<<(std::ostream& os, CivilMonth m);
std::ostream& operator<<(std::ostream& os, CivilDay d);
std::ostream& operator<<(std::ostream& os, CivilHour h);
std::ostream& operator<<(std::ostream& os, CivilMinute m);
std::ostream& operator<<(std::ostream& os, CivilSecond s);

// AbslParseFlag()
//
// Parses the command-line flag string representation `s` into a civil-time
// value. Flags must be specified in a format that is valid for
// `absl::ParseLenientCivilTime()`.
bool AbslParseFlag(absl::string_view s, CivilSecond* c, std::string* error);
bool AbslParseFlag(absl::string_view s, CivilMinute* c, std::string* error);
bool AbslParseFlag(absl::string_view s, CivilHour* c, std::string* error);
bool AbslParseFlag(absl::string_view s, CivilDay* c, std::string* error);
bool AbslParseFlag(absl::string_view s, CivilMonth* c, std::string* error);
bool AbslParseFlag(absl::string_view s, CivilYear* c, std::string* error);

// AbslUnparseFlag()
//
// Unparses a civil-time value into a command-line string representation using
// the format specified by `absl::ParseCivilTime()`.
std::string AbslUnparseFlag(CivilSecond c);
std::string AbslUnparseFlag(CivilMinute c);
std::string AbslUnparseFlag(CivilHour c);
std::string AbslUnparseFlag(CivilDay c);
std::string AbslUnparseFlag(CivilMonth c);
std::string AbslUnparseFlag(CivilYear c);

}  // namespace time_internal

ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_TIME_CIVIL_TIME_H_
                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/civil_time_benchmark.cc                        0000664 0000000 0000000 00000010376 14746647661 0026750 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/time/civil_time.h"

#include <cstddef>
#include <numeric>
#include <string>
#include <vector>

#include "absl/hash/hash.h"
#include "benchmark/benchmark.h"

namespace {

// Run on (12 X 3492 MHz CPUs); 2018-11-05T13:44:29.814239103-08:00
// CPU: Intel Haswell with HyperThreading (6 cores) dL1:32KB dL2:256KB dL3:15MB
// Benchmark                 Time(ns)        CPU(ns)     Iterations
// ----------------------------------------------------------------
// BM_Difference_Days              14.5           14.5     48531105
// BM_Step_Days                    12.6           12.6     54876006
// BM_Format                      587            587        1000000
// BM_Parse                       692            692        1000000
// BM_RoundTripFormatParse       1309           1309         532075
// BM_CivilYearAbslHash             0.710          0.710  976400000
// BM_CivilMonthAbslHash            1.13           1.13   619500000
// BM_CivilDayAbslHash              1.70           1.70   426000000
// BM_CivilHourAbslHash             2.45           2.45   287600000
// BM_CivilMinuteAbslHash           3.21           3.21   226200000
// BM_CivilSecondAbslHash           4.10           4.10   171800000

void BM_Difference_Days(benchmark::State& state) {
  const absl::CivilDay c(2014, 8, 22);
  const absl::CivilDay epoch(1970, 1, 1);
  while (state.KeepRunning()) {
    absl::civil_diff_t n = c - epoch;
    benchmark::DoNotOptimize(n);
  }
}
BENCHMARK(BM_Difference_Days);

void BM_Step_Days(benchmark::State& state) {
  const absl::CivilDay kStart(2014, 8, 22);
  absl::CivilDay c = kStart;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(++c);
  }
}
BENCHMARK(BM_Step_Days);

void BM_Format(benchmark::State& state) {
  const absl::CivilSecond c(2014, 1, 2, 3, 4, 5);
  while (state.KeepRunning()) {
    std::string s = absl::FormatCivilTime(c);
    benchmark::DoNotOptimize(s);
  }
}
BENCHMARK(BM_Format);

void BM_Parse(benchmark::State& state) {
  const std::string f = "2014-01-02T03:04:05";
  absl::CivilSecond c;
  while (state.KeepRunning()) {
    bool b = absl::ParseCivilTime(f, &c);
    benchmark::DoNotOptimize(b);
  }
}
BENCHMARK(BM_Parse);

void BM_RoundTripFormatParse(benchmark::State& state) {
  const absl::CivilSecond c(2014, 1, 2, 3, 4, 5);
  absl::CivilSecond out;
  while (state.KeepRunning()) {
    bool b = absl::ParseCivilTime(absl::FormatCivilTime(c), &out);
    benchmark::DoNotOptimize(b);
  }
}
BENCHMARK(BM_RoundTripFormatParse);

template <typename T>
void BM_CivilTimeAbslHash(benchmark::State& state) {
  const int kSize = 100000;
  std::vector<T> civil_times(kSize);
  std::iota(civil_times.begin(), civil_times.end(), T(2018));

  absl::Hash<T> absl_hasher;
  while (state.KeepRunningBatch(kSize)) {
    for (const T civil_time : civil_times) {
      size_t hash = absl_hasher(civil_time);
      benchmark::DoNotOptimize(hash);
    }
  }
}
void BM_CivilYearAbslHash(benchmark::State& state) {
  BM_CivilTimeAbslHash<absl::CivilYear>(state);
}
void BM_CivilMonthAbslHash(benchmark::State& state) {
  BM_CivilTimeAbslHash<absl::CivilMonth>(state);
}
void BM_CivilDayAbslHash(benchmark::State& state) {
  BM_CivilTimeAbslHash<absl::CivilDay>(state);
}
void BM_CivilHourAbslHash(benchmark::State& state) {
  BM_CivilTimeAbslHash<absl::CivilHour>(state);
}
void BM_CivilMinuteAbslHash(benchmark::State& state) {
  BM_CivilTimeAbslHash<absl::CivilMinute>(state);
}
void BM_CivilSecondAbslHash(benchmark::State& state) {
  BM_CivilTimeAbslHash<absl::CivilSecond>(state);
}
BENCHMARK(BM_CivilYearAbslHash);
BENCHMARK(BM_CivilMonthAbslHash);
BENCHMARK(BM_CivilDayAbslHash);
BENCHMARK(BM_CivilHourAbslHash);
BENCHMARK(BM_CivilMinuteAbslHash);
BENCHMARK(BM_CivilSecondAbslHash);

}  // namespace
                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/civil_time_test.cc                             0000664 0000000 0000000 00000136220 14746647661 0025772 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/time/civil_time.h"

#include <iomanip>
#include <limits>
#include <sstream>
#include <type_traits>

#include "gtest/gtest.h"
#include "absl/base/macros.h"
#include "absl/strings/str_format.h"

namespace {

TEST(CivilTime, DefaultConstruction) {
  absl::CivilSecond ss;
  EXPECT_EQ("1970-01-01T00:00:00", absl::FormatCivilTime(ss));

  absl::CivilMinute mm;
  EXPECT_EQ("1970-01-01T00:00", absl::FormatCivilTime(mm));

  absl::CivilHour hh;
  EXPECT_EQ("1970-01-01T00", absl::FormatCivilTime(hh));

  absl::CivilDay d;
  EXPECT_EQ("1970-01-01", absl::FormatCivilTime(d));

  absl::CivilMonth m;
  EXPECT_EQ("1970-01", absl::FormatCivilTime(m));

  absl::CivilYear y;
  EXPECT_EQ("1970", absl::FormatCivilTime(y));
}

TEST(CivilTime, StructMember) {
  struct S {
    absl::CivilDay day;
  };
  S s = {};
  EXPECT_EQ(absl::CivilDay{}, s.day);
}

TEST(CivilTime, FieldsConstruction) {
  EXPECT_EQ("2015-01-02T03:04:05",
            absl::FormatCivilTime(absl::CivilSecond(2015, 1, 2, 3, 4, 5)));
  EXPECT_EQ("2015-01-02T03:04:00",
            absl::FormatCivilTime(absl::CivilSecond(2015, 1, 2, 3, 4)));
  EXPECT_EQ("2015-01-02T03:00:00",
            absl::FormatCivilTime(absl::CivilSecond(2015, 1, 2, 3)));
  EXPECT_EQ("2015-01-02T00:00:00",
            absl::FormatCivilTime(absl::CivilSecond(2015, 1, 2)));
  EXPECT_EQ("2015-01-01T00:00:00",
            absl::FormatCivilTime(absl::CivilSecond(2015, 1)));
  EXPECT_EQ("2015-01-01T00:00:00",
            absl::FormatCivilTime(absl::CivilSecond(2015)));

  EXPECT_EQ("2015-01-02T03:04",
            absl::FormatCivilTime(absl::CivilMinute(2015, 1, 2, 3, 4, 5)));
  EXPECT_EQ("2015-01-02T03:04",
            absl::FormatCivilTime(absl::CivilMinute(2015, 1, 2, 3, 4)));
  EXPECT_EQ("2015-01-02T03:00",
            absl::FormatCivilTime(absl::CivilMinute(2015, 1, 2, 3)));
  EXPECT_EQ("2015-01-02T00:00",
            absl::FormatCivilTime(absl::CivilMinute(2015, 1, 2)));
  EXPECT_EQ("2015-01-01T00:00",
            absl::FormatCivilTime(absl::CivilMinute(2015, 1)));
  EXPECT_EQ("2015-01-01T00:00",
            absl::FormatCivilTime(absl::CivilMinute(2015)));

  EXPECT_EQ("2015-01-02T03",
            absl::FormatCivilTime(absl::CivilHour(2015, 1, 2, 3, 4, 5)));
  EXPECT_EQ("2015-01-02T03",
            absl::FormatCivilTime(absl::CivilHour(2015, 1, 2, 3, 4)));
  EXPECT_EQ("2015-01-02T03",
            absl::FormatCivilTime(absl::CivilHour(2015, 1, 2, 3)));
  EXPECT_EQ("2015-01-02T00",
            absl::FormatCivilTime(absl::CivilHour(2015, 1, 2)));
  EXPECT_EQ("2015-01-01T00",
            absl::FormatCivilTime(absl::CivilHour(2015, 1)));
  EXPECT_EQ("2015-01-01T00",
            absl::FormatCivilTime(absl::CivilHour(2015)));

  EXPECT_EQ("2015-01-02",
            absl::FormatCivilTime(absl::CivilDay(2015, 1, 2, 3, 4, 5)));
  EXPECT_EQ("2015-01-02",
            absl::FormatCivilTime(absl::CivilDay(2015, 1, 2, 3, 4)));
  EXPECT_EQ("2015-01-02",
            absl::FormatCivilTime(absl::CivilDay(2015, 1, 2, 3)));
  EXPECT_EQ("2015-01-02",
            absl::FormatCivilTime(absl::CivilDay(2015, 1, 2)));
  EXPECT_EQ("2015-01-01",
            absl::FormatCivilTime(absl::CivilDay(2015, 1)));
  EXPECT_EQ("2015-01-01",
            absl::FormatCivilTime(absl::CivilDay(2015)));

  EXPECT_EQ("2015-01",
            absl::FormatCivilTime(absl::CivilMonth(2015, 1, 2, 3, 4, 5)));
  EXPECT_EQ("2015-01",
            absl::FormatCivilTime(absl::CivilMonth(2015, 1, 2, 3, 4)));
  EXPECT_EQ("2015-01",
            absl::FormatCivilTime(absl::CivilMonth(2015, 1, 2, 3)));
  EXPECT_EQ("2015-01",
            absl::FormatCivilTime(absl::CivilMonth(2015, 1, 2)));
  EXPECT_EQ("2015-01",
            absl::FormatCivilTime(absl::CivilMonth(2015, 1)));
  EXPECT_EQ("2015-01",
            absl::FormatCivilTime(absl::CivilMonth(2015)));

  EXPECT_EQ("2015",
            absl::FormatCivilTime(absl::CivilYear(2015, 1, 2, 3, 4, 5)));
  EXPECT_EQ("2015",
            absl::FormatCivilTime(absl::CivilYear(2015, 1, 2, 3, 4)));
  EXPECT_EQ("2015",
            absl::FormatCivilTime(absl::CivilYear(2015, 1, 2, 3)));
  EXPECT_EQ("2015",
            absl::FormatCivilTime(absl::CivilYear(2015, 1, 2)));
  EXPECT_EQ("2015",
            absl::FormatCivilTime(absl::CivilYear(2015, 1)));
  EXPECT_EQ("2015",
            absl::FormatCivilTime(absl::CivilYear(2015)));
}

TEST(CivilTime, FieldsConstructionLimits) {
  const int kIntMax = std::numeric_limits<int>::max();
  EXPECT_EQ("2038-01-19T03:14:07",
            absl::FormatCivilTime(absl::CivilSecond(
                1970, 1, 1, 0, 0, kIntMax)));
  EXPECT_EQ("6121-02-11T05:21:07",
            absl::FormatCivilTime(absl::CivilSecond(
                1970, 1, 1, 0, kIntMax, kIntMax)));
  EXPECT_EQ("251104-11-20T12:21:07",
            absl::FormatCivilTime(absl::CivilSecond(
                1970, 1, 1, kIntMax, kIntMax, kIntMax)));
  EXPECT_EQ("6130715-05-30T12:21:07",
            absl::FormatCivilTime(absl::CivilSecond(
                1970, 1, kIntMax, kIntMax, kIntMax, kIntMax)));
  EXPECT_EQ("185087685-11-26T12:21:07",
            absl::FormatCivilTime(absl::CivilSecond(
                1970, kIntMax, kIntMax, kIntMax, kIntMax, kIntMax)));

  const int kIntMin = std::numeric_limits<int>::min();
  EXPECT_EQ("1901-12-13T20:45:52",
            absl::FormatCivilTime(absl::CivilSecond(
                1970, 1, 1, 0, 0, kIntMin)));
  EXPECT_EQ("-2182-11-20T18:37:52",
            absl::FormatCivilTime(absl::CivilSecond(
                1970, 1, 1, 0, kIntMin, kIntMin)));
  EXPECT_EQ("-247165-02-11T10:37:52",
            absl::FormatCivilTime(absl::CivilSecond(
                1970, 1, 1, kIntMin, kIntMin, kIntMin)));
  EXPECT_EQ("-6126776-08-01T10:37:52",
            absl::FormatCivilTime(absl::CivilSecond(
                1970, 1, kIntMin, kIntMin, kIntMin, kIntMin)));
  EXPECT_EQ("-185083747-10-31T10:37:52",
            absl::FormatCivilTime(absl::CivilSecond(
                1970, kIntMin, kIntMin, kIntMin, kIntMin, kIntMin)));
}

TEST(CivilTime, RangeLimits) {
  const absl::civil_year_t kYearMax =
      std::numeric_limits<absl::civil_year_t>::max();
  EXPECT_EQ(absl::CivilYear(kYearMax),
            absl::CivilYear::max());
  EXPECT_EQ(absl::CivilMonth(kYearMax, 12),
            absl::CivilMonth::max());
  EXPECT_EQ(absl::CivilDay(kYearMax, 12, 31),
            absl::CivilDay::max());
  EXPECT_EQ(absl::CivilHour(kYearMax, 12, 31, 23),
            absl::CivilHour::max());
  EXPECT_EQ(absl::CivilMinute(kYearMax, 12, 31, 23, 59),
            absl::CivilMinute::max());
  EXPECT_EQ(absl::CivilSecond(kYearMax, 12, 31, 23, 59, 59),
            absl::CivilSecond::max());

  const absl::civil_year_t kYearMin =
      std::numeric_limits<absl::civil_year_t>::min();
  EXPECT_EQ(absl::CivilYear(kYearMin),
            absl::CivilYear::min());
  EXPECT_EQ(absl::CivilMonth(kYearMin, 1),
            absl::CivilMonth::min());
  EXPECT_EQ(absl::CivilDay(kYearMin, 1, 1),
            absl::CivilDay::min());
  EXPECT_EQ(absl::CivilHour(kYearMin, 1, 1, 0),
            absl::CivilHour::min());
  EXPECT_EQ(absl::CivilMinute(kYearMin, 1, 1, 0, 0),
            absl::CivilMinute::min());
  EXPECT_EQ(absl::CivilSecond(kYearMin, 1, 1, 0, 0, 0),
            absl::CivilSecond::min());
}

TEST(CivilTime, ImplicitCrossAlignment) {
  absl::CivilYear year(2015);
  absl::CivilMonth month = year;
  absl::CivilDay day = month;
  absl::CivilHour hour = day;
  absl::CivilMinute minute = hour;
  absl::CivilSecond second = minute;

  second = year;
  EXPECT_EQ(second, year);
  second = month;
  EXPECT_EQ(second, month);
  second = day;
  EXPECT_EQ(second, day);
  second = hour;
  EXPECT_EQ(second, hour);
  second = minute;
  EXPECT_EQ(second, minute);

  minute = year;
  EXPECT_EQ(minute, year);
  minute = month;
  EXPECT_EQ(minute, month);
  minute = day;
  EXPECT_EQ(minute, day);
  minute = hour;
  EXPECT_EQ(minute, hour);

  hour = year;
  EXPECT_EQ(hour, year);
  hour = month;
  EXPECT_EQ(hour, month);
  hour = day;
  EXPECT_EQ(hour, day);

  day = year;
  EXPECT_EQ(day, year);
  day = month;
  EXPECT_EQ(day, month);

  month = year;
  EXPECT_EQ(month, year);

  // Ensures unsafe conversions are not allowed.
  EXPECT_FALSE(
      (std::is_convertible<absl::CivilSecond, absl::CivilMinute>::value));
  EXPECT_FALSE(
      (std::is_convertible<absl::CivilSecond, absl::CivilHour>::value));
  EXPECT_FALSE(
      (std::is_convertible<absl::CivilSecond, absl::CivilDay>::value));
  EXPECT_FALSE(
      (std::is_convertible<absl::CivilSecond, absl::CivilMonth>::value));
  EXPECT_FALSE(
      (std::is_convertible<absl::CivilSecond, absl::CivilYear>::value));

  EXPECT_FALSE(
      (std::is_convertible<absl::CivilMinute, absl::CivilHour>::value));
  EXPECT_FALSE(
      (std::is_convertible<absl::CivilMinute, absl::CivilDay>::value));
  EXPECT_FALSE(
      (std::is_convertible<absl::CivilMinute, absl::CivilMonth>::value));
  EXPECT_FALSE(
      (std::is_convertible<absl::CivilMinute, absl::CivilYear>::value));

  EXPECT_FALSE(
      (std::is_convertible<absl::CivilHour, absl::CivilDay>::value));
  EXPECT_FALSE(
      (std::is_convertible<absl::CivilHour, absl::CivilMonth>::value));
  EXPECT_FALSE(
      (std::is_convertible<absl::CivilHour, absl::CivilYear>::value));

  EXPECT_FALSE(
      (std::is_convertible<absl::CivilDay, absl::CivilMonth>::value));
  EXPECT_FALSE(
      (std::is_convertible<absl::CivilDay, absl::CivilYear>::value));

  EXPECT_FALSE(
      (std::is_convertible<absl::CivilMonth, absl::CivilYear>::value));
}

TEST(CivilTime, ExplicitCrossAlignment) {
  //
  // Assign from smaller units -> larger units
  //

  absl::CivilSecond second(2015, 1, 2, 3, 4, 5);
  EXPECT_EQ("2015-01-02T03:04:05", absl::FormatCivilTime(second));

  absl::CivilMinute minute(second);
  EXPECT_EQ("2015-01-02T03:04", absl::FormatCivilTime(minute));

  absl::CivilHour hour(minute);
  EXPECT_EQ("2015-01-02T03", absl::FormatCivilTime(hour));

  absl::CivilDay day(hour);
  EXPECT_EQ("2015-01-02", absl::FormatCivilTime(day));

  absl::CivilMonth month(day);
  EXPECT_EQ("2015-01", absl::FormatCivilTime(month));

  absl::CivilYear year(month);
  EXPECT_EQ("2015", absl::FormatCivilTime(year));

  //
  // Now assign from larger units -> smaller units
  //

  month = absl::CivilMonth(year);
  EXPECT_EQ("2015-01", absl::FormatCivilTime(month));

  day = absl::CivilDay(month);
  EXPECT_EQ("2015-01-01", absl::FormatCivilTime(day));

  hour = absl::CivilHour(day);
  EXPECT_EQ("2015-01-01T00", absl::FormatCivilTime(hour));

  minute = absl::CivilMinute(hour);
  EXPECT_EQ("2015-01-01T00:00", absl::FormatCivilTime(minute));

  second = absl::CivilSecond(minute);
  EXPECT_EQ("2015-01-01T00:00:00", absl::FormatCivilTime(second));
}

// Metafunction to test whether difference is allowed between two types.
template <typename T1, typename T2>
struct HasDiff {
  template <typename U1, typename U2>
  static std::false_type test(...);
  template <typename U1, typename U2>
  static std::true_type test(decltype(std::declval<U1>() - std::declval<U2>()));
  static constexpr bool value = decltype(test<T1, T2>(0))::value;
};

TEST(CivilTime, DisallowCrossAlignedDifference) {
  // Difference is allowed between types with the same alignment.
  static_assert(HasDiff<absl::CivilSecond, absl::CivilSecond>::value, "");
  static_assert(HasDiff<absl::CivilMinute, absl::CivilMinute>::value, "");
  static_assert(HasDiff<absl::CivilHour, absl::CivilHour>::value, "");
  static_assert(HasDiff<absl::CivilDay, absl::CivilDay>::value, "");
  static_assert(HasDiff<absl::CivilMonth, absl::CivilMonth>::value, "");
  static_assert(HasDiff<absl::CivilYear, absl::CivilYear>::value, "");

  // Difference is disallowed between types with different alignments.
  static_assert(!HasDiff<absl::CivilSecond, absl::CivilMinute>::value, "");
  static_assert(!HasDiff<absl::CivilSecond, absl::CivilHour>::value, "");
  static_assert(!HasDiff<absl::CivilSecond, absl::CivilDay>::value, "");
  static_assert(!HasDiff<absl::CivilSecond, absl::CivilMonth>::value, "");
  static_assert(!HasDiff<absl::CivilSecond, absl::CivilYear>::value, "");

  static_assert(!HasDiff<absl::CivilMinute, absl::CivilHour>::value, "");
  static_assert(!HasDiff<absl::CivilMinute, absl::CivilDay>::value, "");
  static_assert(!HasDiff<absl::CivilMinute, absl::CivilMonth>::value, "");
  static_assert(!HasDiff<absl::CivilMinute, absl::CivilYear>::value, "");

  static_assert(!HasDiff<absl::CivilHour, absl::CivilDay>::value, "");
  static_assert(!HasDiff<absl::CivilHour, absl::CivilMonth>::value, "");
  static_assert(!HasDiff<absl::CivilHour, absl::CivilYear>::value, "");

  static_assert(!HasDiff<absl::CivilDay, absl::CivilMonth>::value, "");
  static_assert(!HasDiff<absl::CivilDay, absl::CivilYear>::value, "");

  static_assert(!HasDiff<absl::CivilMonth, absl::CivilYear>::value, "");
}

TEST(CivilTime, ValueSemantics) {
  const absl::CivilHour a(2015, 1, 2, 3);
  const absl::CivilHour b = a;
  const absl::CivilHour c(b);
  absl::CivilHour d;
  d = c;
  EXPECT_EQ("2015-01-02T03", absl::FormatCivilTime(d));
}

TEST(CivilTime, Relational) {
  // Tests that the alignment unit is ignored in comparison.
  const absl::CivilYear year(2014);
  const absl::CivilMonth month(year);
  EXPECT_EQ(year, month);

#define TEST_RELATIONAL(OLDER, YOUNGER) \
  do {                                  \
    EXPECT_FALSE(OLDER < OLDER);        \
    EXPECT_FALSE(OLDER > OLDER);        \
    EXPECT_TRUE(OLDER >= OLDER);        \
    EXPECT_TRUE(OLDER <= OLDER);        \
    EXPECT_FALSE(YOUNGER < YOUNGER);    \
    EXPECT_FALSE(YOUNGER > YOUNGER);    \
    EXPECT_TRUE(YOUNGER >= YOUNGER);    \
    EXPECT_TRUE(YOUNGER <= YOUNGER);    \
    EXPECT_EQ(OLDER, OLDER);            \
    EXPECT_NE(OLDER, YOUNGER);          \
    EXPECT_LT(OLDER, YOUNGER);          \
    EXPECT_LE(OLDER, YOUNGER);          \
    EXPECT_GT(YOUNGER, OLDER);          \
    EXPECT_GE(YOUNGER, OLDER);          \
  } while (0)

  // Alignment is ignored in comparison (verified above), so CivilSecond is
  // used to test comparison in all field positions.
  TEST_RELATIONAL(absl::CivilSecond(2014, 1, 1, 0, 0, 0),
                  absl::CivilSecond(2015, 1, 1, 0, 0, 0));
  TEST_RELATIONAL(absl::CivilSecond(2014, 1, 1, 0, 0, 0),
                  absl::CivilSecond(2014, 2, 1, 0, 0, 0));
  TEST_RELATIONAL(absl::CivilSecond(2014, 1, 1, 0, 0, 0),
                  absl::CivilSecond(2014, 1, 2, 0, 0, 0));
  TEST_RELATIONAL(absl::CivilSecond(2014, 1, 1, 0, 0, 0),
                  absl::CivilSecond(2014, 1, 1, 1, 0, 0));
  TEST_RELATIONAL(absl::CivilSecond(2014, 1, 1, 1, 0, 0),
                  absl::CivilSecond(2014, 1, 1, 1, 1, 0));
  TEST_RELATIONAL(absl::CivilSecond(2014, 1, 1, 1, 1, 0),
                  absl::CivilSecond(2014, 1, 1, 1, 1, 1));

  // Tests the relational operators of two different civil-time types.
  TEST_RELATIONAL(absl::CivilDay(2014, 1, 1),
                  absl::CivilMinute(2014, 1, 1, 1, 1));
  TEST_RELATIONAL(absl::CivilDay(2014, 1, 1),
                  absl::CivilMonth(2014, 2));

#undef TEST_RELATIONAL
}

TEST(CivilTime, Arithmetic) {
  absl::CivilSecond second(2015, 1, 2, 3, 4, 5);
  EXPECT_EQ("2015-01-02T03:04:06", absl::FormatCivilTime(second += 1));
  EXPECT_EQ("2015-01-02T03:04:07", absl::FormatCivilTime(second + 1));
  EXPECT_EQ("2015-01-02T03:04:08", absl::FormatCivilTime(2 + second));
  EXPECT_EQ("2015-01-02T03:04:05", absl::FormatCivilTime(second - 1));
  EXPECT_EQ("2015-01-02T03:04:05", absl::FormatCivilTime(second -= 1));
  EXPECT_EQ("2015-01-02T03:04:05", absl::FormatCivilTime(second++));
  EXPECT_EQ("2015-01-02T03:04:07", absl::FormatCivilTime(++second));
  EXPECT_EQ("2015-01-02T03:04:07", absl::FormatCivilTime(second--));
  EXPECT_EQ("2015-01-02T03:04:05", absl::FormatCivilTime(--second));

  absl::CivilMinute minute(2015, 1, 2, 3, 4);
  EXPECT_EQ("2015-01-02T03:05", absl::FormatCivilTime(minute += 1));
  EXPECT_EQ("2015-01-02T03:06", absl::FormatCivilTime(minute + 1));
  EXPECT_EQ("2015-01-02T03:07", absl::FormatCivilTime(2 + minute));
  EXPECT_EQ("2015-01-02T03:04", absl::FormatCivilTime(minute - 1));
  EXPECT_EQ("2015-01-02T03:04", absl::FormatCivilTime(minute -= 1));
  EXPECT_EQ("2015-01-02T03:04", absl::FormatCivilTime(minute++));
  EXPECT_EQ("2015-01-02T03:06", absl::FormatCivilTime(++minute));
  EXPECT_EQ("2015-01-02T03:06", absl::FormatCivilTime(minute--));
  EXPECT_EQ("2015-01-02T03:04", absl::FormatCivilTime(--minute));

  absl::CivilHour hour(2015, 1, 2, 3);
  EXPECT_EQ("2015-01-02T04", absl::FormatCivilTime(hour += 1));
  EXPECT_EQ("2015-01-02T05", absl::FormatCivilTime(hour + 1));
  EXPECT_EQ("2015-01-02T06", absl::FormatCivilTime(2 + hour));
  EXPECT_EQ("2015-01-02T03", absl::FormatCivilTime(hour - 1));
  EXPECT_EQ("2015-01-02T03", absl::FormatCivilTime(hour -= 1));
  EXPECT_EQ("2015-01-02T03", absl::FormatCivilTime(hour++));
  EXPECT_EQ("2015-01-02T05", absl::FormatCivilTime(++hour));
  EXPECT_EQ("2015-01-02T05", absl::FormatCivilTime(hour--));
  EXPECT_EQ("2015-01-02T03", absl::FormatCivilTime(--hour));

  absl::CivilDay day(2015, 1, 2);
  EXPECT_EQ("2015-01-03", absl::FormatCivilTime(day += 1));
  EXPECT_EQ("2015-01-04", absl::FormatCivilTime(day + 1));
  EXPECT_EQ("2015-01-05", absl::FormatCivilTime(2 + day));
  EXPECT_EQ("2015-01-02", absl::FormatCivilTime(day - 1));
  EXPECT_EQ("2015-01-02", absl::FormatCivilTime(day -= 1));
  EXPECT_EQ("2015-01-02", absl::FormatCivilTime(day++));
  EXPECT_EQ("2015-01-04", absl::FormatCivilTime(++day));
  EXPECT_EQ("2015-01-04", absl::FormatCivilTime(day--));
  EXPECT_EQ("2015-01-02", absl::FormatCivilTime(--day));

  absl::CivilMonth month(2015, 1);
  EXPECT_EQ("2015-02", absl::FormatCivilTime(month += 1));
  EXPECT_EQ("2015-03", absl::FormatCivilTime(month + 1));
  EXPECT_EQ("2015-04", absl::FormatCivilTime(2 + month));
  EXPECT_EQ("2015-01", absl::FormatCivilTime(month - 1));
  EXPECT_EQ("2015-01", absl::FormatCivilTime(month -= 1));
  EXPECT_EQ("2015-01", absl::FormatCivilTime(month++));
  EXPECT_EQ("2015-03", absl::FormatCivilTime(++month));
  EXPECT_EQ("2015-03", absl::FormatCivilTime(month--));
  EXPECT_EQ("2015-01", absl::FormatCivilTime(--month));

  absl::CivilYear year(2015);
  EXPECT_EQ("2016", absl::FormatCivilTime(year += 1));
  EXPECT_EQ("2017", absl::FormatCivilTime(year + 1));
  EXPECT_EQ("2018", absl::FormatCivilTime(2 + year));
  EXPECT_EQ("2015", absl::FormatCivilTime(year - 1));
  EXPECT_EQ("2015", absl::FormatCivilTime(year -= 1));
  EXPECT_EQ("2015", absl::FormatCivilTime(year++));
  EXPECT_EQ("2017", absl::FormatCivilTime(++year));
  EXPECT_EQ("2017", absl::FormatCivilTime(year--));
  EXPECT_EQ("2015", absl::FormatCivilTime(--year));
}

TEST(CivilTime, ArithmeticLimits) {
  const int kIntMax = std::numeric_limits<int>::max();
  const int kIntMin = std::numeric_limits<int>::min();

  absl::CivilSecond second(1970, 1, 1, 0, 0, 0);
  second += kIntMax;
  EXPECT_EQ("2038-01-19T03:14:07", absl::FormatCivilTime(second));
  second -= kIntMax;
  EXPECT_EQ("1970-01-01T00:00:00", absl::FormatCivilTime(second));
  second += kIntMin;
  EXPECT_EQ("1901-12-13T20:45:52", absl::FormatCivilTime(second));
  second -= kIntMin;
  EXPECT_EQ("1970-01-01T00:00:00", absl::FormatCivilTime(second));

  absl::CivilMinute minute(1970, 1, 1, 0, 0);
  minute += kIntMax;
  EXPECT_EQ("6053-01-23T02:07", absl::FormatCivilTime(minute));
  minute -= kIntMax;
  EXPECT_EQ("1970-01-01T00:00", absl::FormatCivilTime(minute));
  minute += kIntMin;
  EXPECT_EQ("-2114-12-08T21:52", absl::FormatCivilTime(minute));
  minute -= kIntMin;
  EXPECT_EQ("1970-01-01T00:00", absl::FormatCivilTime(minute));

  absl::CivilHour hour(1970, 1, 1, 0);
  hour += kIntMax;
  EXPECT_EQ("246953-10-09T07", absl::FormatCivilTime(hour));
  hour -= kIntMax;
  EXPECT_EQ("1970-01-01T00", absl::FormatCivilTime(hour));
  hour += kIntMin;
  EXPECT_EQ("-243014-03-24T16", absl::FormatCivilTime(hour));
  hour -= kIntMin;
  EXPECT_EQ("1970-01-01T00", absl::FormatCivilTime(hour));

  absl::CivilDay day(1970, 1, 1);
  day += kIntMax;
  EXPECT_EQ("5881580-07-11", absl::FormatCivilTime(day));
  day -= kIntMax;
  EXPECT_EQ("1970-01-01", absl::FormatCivilTime(day));
  day += kIntMin;
  EXPECT_EQ("-5877641-06-23", absl::FormatCivilTime(day));
  day -= kIntMin;
  EXPECT_EQ("1970-01-01", absl::FormatCivilTime(day));

  absl::CivilMonth month(1970, 1);
  month += kIntMax;
  EXPECT_EQ("178958940-08", absl::FormatCivilTime(month));
  month -= kIntMax;
  EXPECT_EQ("1970-01", absl::FormatCivilTime(month));
  month += kIntMin;
  EXPECT_EQ("-178955001-05", absl::FormatCivilTime(month));
  month -= kIntMin;
  EXPECT_EQ("1970-01", absl::FormatCivilTime(month));

  absl::CivilYear year(0);
  year += kIntMax;
  EXPECT_EQ("2147483647", absl::FormatCivilTime(year));
  year -= kIntMax;
  EXPECT_EQ("0", absl::FormatCivilTime(year));
  year += kIntMin;
  EXPECT_EQ("-2147483648", absl::FormatCivilTime(year));
  year -= kIntMin;
  EXPECT_EQ("0", absl::FormatCivilTime(year));
}

TEST(CivilTime, Difference) {
  absl::CivilSecond second(2015, 1, 2, 3, 4, 5);
  EXPECT_EQ(0, second - second);
  EXPECT_EQ(10, (second + 10) - second);
  EXPECT_EQ(-10, (second - 10) - second);

  absl::CivilMinute minute(2015, 1, 2, 3, 4);
  EXPECT_EQ(0, minute - minute);
  EXPECT_EQ(10, (minute + 10) - minute);
  EXPECT_EQ(-10, (minute - 10) - minute);

  absl::CivilHour hour(2015, 1, 2, 3);
  EXPECT_EQ(0, hour - hour);
  EXPECT_EQ(10, (hour + 10) - hour);
  EXPECT_EQ(-10, (hour - 10) - hour);

  absl::CivilDay day(2015, 1, 2);
  EXPECT_EQ(0, day - day);
  EXPECT_EQ(10, (day + 10) - day);
  EXPECT_EQ(-10, (day - 10) - day);

  absl::CivilMonth month(2015, 1);
  EXPECT_EQ(0, month - month);
  EXPECT_EQ(10, (month + 10) - month);
  EXPECT_EQ(-10, (month - 10) - month);

  absl::CivilYear year(2015);
  EXPECT_EQ(0, year - year);
  EXPECT_EQ(10, (year + 10) - year);
  EXPECT_EQ(-10, (year - 10) - year);
}

TEST(CivilTime, DifferenceLimits) {
  const absl::civil_diff_t kDiffMax =
      std::numeric_limits<absl::civil_diff_t>::max();
  const absl::civil_diff_t kDiffMin =
      std::numeric_limits<absl::civil_diff_t>::min();

  // Check day arithmetic at the end of the year range.
  const absl::CivilDay max_day(kDiffMax, 12, 31);
  EXPECT_EQ(1, max_day - (max_day - 1));
  EXPECT_EQ(-1, (max_day - 1) - max_day);

  // Check day arithmetic at the start of the year range.
  const absl::CivilDay min_day(kDiffMin, 1, 1);
  EXPECT_EQ(1, (min_day + 1) - min_day);
  EXPECT_EQ(-1, min_day - (min_day + 1));

  // Check the limits of the return value.
  const absl::CivilDay d1(1970, 1, 1);
  const absl::CivilDay d2(25252734927768524, 7, 27);
  EXPECT_EQ(kDiffMax, d2 - d1);
  EXPECT_EQ(kDiffMin, d1 - (d2 + 1));
}

TEST(CivilTime, Properties) {
  absl::CivilSecond ss(2015, 2, 3, 4, 5, 6);
  EXPECT_EQ(2015, ss.year());
  EXPECT_EQ(2, ss.month());
  EXPECT_EQ(3, ss.day());
  EXPECT_EQ(4, ss.hour());
  EXPECT_EQ(5, ss.minute());
  EXPECT_EQ(6, ss.second());
  EXPECT_EQ(absl::Weekday::tuesday, absl::GetWeekday(ss));
  EXPECT_EQ(34, absl::GetYearDay(ss));

  absl::CivilMinute mm(2015, 2, 3, 4, 5, 6);
  EXPECT_EQ(2015, mm.year());
  EXPECT_EQ(2, mm.month());
  EXPECT_EQ(3, mm.day());
  EXPECT_EQ(4, mm.hour());
  EXPECT_EQ(5, mm.minute());
  EXPECT_EQ(0, mm.second());
  EXPECT_EQ(absl::Weekday::tuesday, absl::GetWeekday(mm));
  EXPECT_EQ(34, absl::GetYearDay(mm));

  absl::CivilHour hh(2015, 2, 3, 4, 5, 6);
  EXPECT_EQ(2015, hh.year());
  EXPECT_EQ(2, hh.month());
  EXPECT_EQ(3, hh.day());
  EXPECT_EQ(4, hh.hour());
  EXPECT_EQ(0, hh.minute());
  EXPECT_EQ(0, hh.second());
  EXPECT_EQ(absl::Weekday::tuesday, absl::GetWeekday(hh));
  EXPECT_EQ(34, absl::GetYearDay(hh));

  absl::CivilDay d(2015, 2, 3, 4, 5, 6);
  EXPECT_EQ(2015, d.year());
  EXPECT_EQ(2, d.month());
  EXPECT_EQ(3, d.day());
  EXPECT_EQ(0, d.hour());
  EXPECT_EQ(0, d.minute());
  EXPECT_EQ(0, d.second());
  EXPECT_EQ(absl::Weekday::tuesday, absl::GetWeekday(d));
  EXPECT_EQ(34, absl::GetYearDay(d));

  absl::CivilMonth m(2015, 2, 3, 4, 5, 6);
  EXPECT_EQ(2015, m.year());
  EXPECT_EQ(2, m.month());
  EXPECT_EQ(1, m.day());
  EXPECT_EQ(0, m.hour());
  EXPECT_EQ(0, m.minute());
  EXPECT_EQ(0, m.second());
  EXPECT_EQ(absl::Weekday::sunday, absl::GetWeekday(m));
  EXPECT_EQ(32, absl::GetYearDay(m));

  absl::CivilYear y(2015, 2, 3, 4, 5, 6);
  EXPECT_EQ(2015, y.year());
  EXPECT_EQ(1, y.month());
  EXPECT_EQ(1, y.day());
  EXPECT_EQ(0, y.hour());
  EXPECT_EQ(0, y.minute());
  EXPECT_EQ(0, y.second());
  EXPECT_EQ(absl::Weekday::thursday, absl::GetWeekday(y));
  EXPECT_EQ(1, absl::GetYearDay(y));
}

TEST(CivilTime, Format) {
  absl::CivilSecond ss;
  EXPECT_EQ("1970-01-01T00:00:00", absl::FormatCivilTime(ss));

  absl::CivilMinute mm;
  EXPECT_EQ("1970-01-01T00:00", absl::FormatCivilTime(mm));

  absl::CivilHour hh;
  EXPECT_EQ("1970-01-01T00", absl::FormatCivilTime(hh));

  absl::CivilDay d;
  EXPECT_EQ("1970-01-01", absl::FormatCivilTime(d));

  absl::CivilMonth m;
  EXPECT_EQ("1970-01", absl::FormatCivilTime(m));

  absl::CivilYear y;
  EXPECT_EQ("1970", absl::FormatCivilTime(y));
}

TEST(CivilTime, Parse) {
  absl::CivilSecond ss;
  absl::CivilMinute mm;
  absl::CivilHour hh;
  absl::CivilDay d;
  absl::CivilMonth m;
  absl::CivilYear y;

  // CivilSecond OK; others fail
  EXPECT_TRUE(absl::ParseCivilTime("2015-01-02T03:04:05", &ss));
  EXPECT_EQ("2015-01-02T03:04:05", absl::FormatCivilTime(ss));
  EXPECT_FALSE(absl::ParseCivilTime("2015-01-02T03:04:05", &mm));
  EXPECT_FALSE(absl::ParseCivilTime("2015-01-02T03:04:05", &hh));
  EXPECT_FALSE(absl::ParseCivilTime("2015-01-02T03:04:05", &d));
  EXPECT_FALSE(absl::ParseCivilTime("2015-01-02T03:04:05", &m));
  EXPECT_FALSE(absl::ParseCivilTime("2015-01-02T03:04:05", &y));

  // CivilMinute OK; others fail
  EXPECT_FALSE(absl::ParseCivilTime("2015-01-02T03:04", &ss));
  EXPECT_TRUE(absl::ParseCivilTime("2015-01-02T03:04", &mm));
  EXPECT_EQ("2015-01-02T03:04", absl::FormatCivilTime(mm));
  EXPECT_FALSE(absl::ParseCivilTime("2015-01-02T03:04", &hh));
  EXPECT_FALSE(absl::ParseCivilTime("2015-01-02T03:04", &d));
  EXPECT_FALSE(absl::ParseCivilTime("2015-01-02T03:04", &m));
  EXPECT_FALSE(absl::ParseCivilTime("2015-01-02T03:04", &y));

  // CivilHour OK; others fail
  EXPECT_FALSE(absl::ParseCivilTime("2015-01-02T03", &ss));
  EXPECT_FALSE(absl::ParseCivilTime("2015-01-02T03", &mm));
  EXPECT_TRUE(absl::ParseCivilTime("2015-01-02T03", &hh));
  EXPECT_EQ("2015-01-02T03", absl::FormatCivilTime(hh));
  EXPECT_FALSE(absl::ParseCivilTime("2015-01-02T03", &d));
  EXPECT_FALSE(absl::ParseCivilTime("2015-01-02T03", &m));
  EXPECT_FALSE(absl::ParseCivilTime("2015-01-02T03", &y));

  // CivilDay OK; others fail
  EXPECT_FALSE(absl::ParseCivilTime("2015-01-02", &ss));
  EXPECT_FALSE(absl::ParseCivilTime("2015-01-02", &mm));
  EXPECT_FALSE(absl::ParseCivilTime("2015-01-02", &hh));
  EXPECT_TRUE(absl::ParseCivilTime("2015-01-02", &d));
  EXPECT_EQ("2015-01-02", absl::FormatCivilTime(d));
  EXPECT_FALSE(absl::ParseCivilTime("2015-01-02", &m));
  EXPECT_FALSE(absl::ParseCivilTime("2015-01-02", &y));

  // CivilMonth OK; others fail
  EXPECT_FALSE(absl::ParseCivilTime("2015-01", &ss));
  EXPECT_FALSE(absl::ParseCivilTime("2015-01", &mm));
  EXPECT_FALSE(absl::ParseCivilTime("2015-01", &hh));
  EXPECT_FALSE(absl::ParseCivilTime("2015-01", &d));
  EXPECT_TRUE(absl::ParseCivilTime("2015-01", &m));
  EXPECT_EQ("2015-01", absl::FormatCivilTime(m));
  EXPECT_FALSE(absl::ParseCivilTime("2015-01", &y));

  // CivilYear OK; others fail
  EXPECT_FALSE(absl::ParseCivilTime("2015", &ss));
  EXPECT_FALSE(absl::ParseCivilTime("2015", &mm));
  EXPECT_FALSE(absl::ParseCivilTime("2015", &hh));
  EXPECT_FALSE(absl::ParseCivilTime("2015", &d));
  EXPECT_FALSE(absl::ParseCivilTime("2015", &m));
  EXPECT_TRUE(absl::ParseCivilTime("2015", &y));
  EXPECT_EQ("2015", absl::FormatCivilTime(y));
}

TEST(CivilTime, FormatAndParseLenient) {
  absl::CivilSecond ss;
  EXPECT_EQ("1970-01-01T00:00:00", absl::FormatCivilTime(ss));

  absl::CivilMinute mm;
  EXPECT_EQ("1970-01-01T00:00", absl::FormatCivilTime(mm));

  absl::CivilHour hh;
  EXPECT_EQ("1970-01-01T00", absl::FormatCivilTime(hh));

  absl::CivilDay d;
  EXPECT_EQ("1970-01-01", absl::FormatCivilTime(d));

  absl::CivilMonth m;
  EXPECT_EQ("1970-01", absl::FormatCivilTime(m));

  absl::CivilYear y;
  EXPECT_EQ("1970", absl::FormatCivilTime(y));

  EXPECT_TRUE(absl::ParseLenientCivilTime("2015-01-02T03:04:05", &ss));
  EXPECT_EQ("2015-01-02T03:04:05", absl::FormatCivilTime(ss));

  EXPECT_TRUE(absl::ParseLenientCivilTime("2015-01-02T03:04:05", &mm));
  EXPECT_EQ("2015-01-02T03:04", absl::FormatCivilTime(mm));

  EXPECT_TRUE(absl::ParseLenientCivilTime("2015-01-02T03:04:05", &hh));
  EXPECT_EQ("2015-01-02T03", absl::FormatCivilTime(hh));

  EXPECT_TRUE(absl::ParseLenientCivilTime("2015-01-02T03:04:05", &d));
  EXPECT_EQ("2015-01-02", absl::FormatCivilTime(d));

  EXPECT_TRUE(absl::ParseLenientCivilTime("2015-01-02T03:04:05", &m));
  EXPECT_EQ("2015-01", absl::FormatCivilTime(m));

  EXPECT_TRUE(absl::ParseLenientCivilTime("2015-01-02T03:04:05", &y));
  EXPECT_EQ("2015", absl::FormatCivilTime(y));
}

TEST(CivilTime, ParseEdgeCases) {
  absl::CivilSecond ss;
  EXPECT_TRUE(
      absl::ParseLenientCivilTime("9223372036854775807-12-31T23:59:59", &ss));
  EXPECT_EQ("9223372036854775807-12-31T23:59:59", absl::FormatCivilTime(ss));
  EXPECT_TRUE(
      absl::ParseLenientCivilTime("-9223372036854775808-01-01T00:00:00", &ss));
  EXPECT_EQ("-9223372036854775808-01-01T00:00:00", absl::FormatCivilTime(ss));

  absl::CivilMinute mm;
  EXPECT_TRUE(
      absl::ParseLenientCivilTime("9223372036854775807-12-31T23:59", &mm));
  EXPECT_EQ("9223372036854775807-12-31T23:59", absl::FormatCivilTime(mm));
  EXPECT_TRUE(
      absl::ParseLenientCivilTime("-9223372036854775808-01-01T00:00", &mm));
  EXPECT_EQ("-9223372036854775808-01-01T00:00", absl::FormatCivilTime(mm));

  absl::CivilHour hh;
  EXPECT_TRUE(
      absl::ParseLenientCivilTime("9223372036854775807-12-31T23", &hh));
  EXPECT_EQ("9223372036854775807-12-31T23", absl::FormatCivilTime(hh));
  EXPECT_TRUE(
      absl::ParseLenientCivilTime("-9223372036854775808-01-01T00", &hh));
  EXPECT_EQ("-9223372036854775808-01-01T00", absl::FormatCivilTime(hh));

  absl::CivilDay d;
  EXPECT_TRUE(absl::ParseLenientCivilTime("9223372036854775807-12-31", &d));
  EXPECT_EQ("9223372036854775807-12-31", absl::FormatCivilTime(d));
  EXPECT_TRUE(absl::ParseLenientCivilTime("-9223372036854775808-01-01", &d));
  EXPECT_EQ("-9223372036854775808-01-01", absl::FormatCivilTime(d));

  absl::CivilMonth m;
  EXPECT_TRUE(absl::ParseLenientCivilTime("9223372036854775807-12", &m));
  EXPECT_EQ("9223372036854775807-12", absl::FormatCivilTime(m));
  EXPECT_TRUE(absl::ParseLenientCivilTime("-9223372036854775808-01", &m));
  EXPECT_EQ("-9223372036854775808-01", absl::FormatCivilTime(m));

  absl::CivilYear y;
  EXPECT_TRUE(absl::ParseLenientCivilTime("9223372036854775807", &y));
  EXPECT_EQ("9223372036854775807", absl::FormatCivilTime(y));
  EXPECT_TRUE(absl::ParseLenientCivilTime("-9223372036854775808", &y));
  EXPECT_EQ("-9223372036854775808", absl::FormatCivilTime(y));

  // Tests some valid, but interesting, cases
  EXPECT_TRUE(absl::ParseLenientCivilTime("0", &ss)) << ss;
  EXPECT_EQ(absl::CivilYear(0), ss);
  EXPECT_TRUE(absl::ParseLenientCivilTime("0-1", &ss)) << ss;
  EXPECT_EQ(absl::CivilMonth(0, 1), ss);
  EXPECT_TRUE(absl::ParseLenientCivilTime(" 2015 ", &ss)) << ss;
  EXPECT_EQ(absl::CivilYear(2015), ss);
  EXPECT_TRUE(absl::ParseLenientCivilTime(" 2015-6 ", &ss)) << ss;
  EXPECT_EQ(absl::CivilMonth(2015, 6), ss);
  EXPECT_TRUE(absl::ParseLenientCivilTime("2015-6-7", &ss)) << ss;
  EXPECT_EQ(absl::CivilDay(2015, 6, 7), ss);
  EXPECT_TRUE(absl::ParseLenientCivilTime(" 2015-6-7 ", &ss)) << ss;
  EXPECT_EQ(absl::CivilDay(2015, 6, 7), ss);
  EXPECT_TRUE(absl::ParseLenientCivilTime("2015-06-07T10:11:12 ", &ss)) << ss;
  EXPECT_EQ(absl::CivilSecond(2015, 6, 7, 10, 11, 12), ss);
  EXPECT_TRUE(absl::ParseLenientCivilTime(" 2015-06-07T10:11:12 ", &ss)) << ss;
  EXPECT_EQ(absl::CivilSecond(2015, 6, 7, 10, 11, 12), ss);
  EXPECT_TRUE(absl::ParseLenientCivilTime("-01-01", &ss)) << ss;
  EXPECT_EQ(absl::CivilMonth(-1, 1), ss);

  // Tests some invalid cases
  EXPECT_FALSE(absl::ParseLenientCivilTime("01-01-2015", &ss)) << ss;
  EXPECT_FALSE(absl::ParseLenientCivilTime("2015-", &ss)) << ss;
  EXPECT_FALSE(absl::ParseLenientCivilTime("0xff-01", &ss)) << ss;
  EXPECT_FALSE(absl::ParseLenientCivilTime("2015-02-30T04:05:06", &ss)) << ss;
  EXPECT_FALSE(absl::ParseLenientCivilTime("2015-02-03T04:05:96", &ss)) << ss;
  EXPECT_FALSE(absl::ParseLenientCivilTime("X2015-02-03T04:05:06", &ss)) << ss;
  EXPECT_FALSE(absl::ParseLenientCivilTime("2015-02-03T04:05:003", &ss)) << ss;
  EXPECT_FALSE(absl::ParseLenientCivilTime("2015 -02-03T04:05:06", &ss)) << ss;
  EXPECT_FALSE(absl::ParseLenientCivilTime("2015-02-03-04:05:06", &ss)) << ss;
  EXPECT_FALSE(absl::ParseLenientCivilTime("2015:02:03T04-05-06", &ss)) << ss;
  EXPECT_FALSE(absl::ParseLenientCivilTime("9223372036854775808", &y)) << y;
}

TEST(CivilTime, AbslStringify) {
  EXPECT_EQ("2015-01-02T03:04:05",
            absl::StrFormat("%v", absl::CivilSecond(2015, 1, 2, 3, 4, 5)));

  EXPECT_EQ("2015-01-02T03:04",
            absl::StrFormat("%v", absl::CivilMinute(2015, 1, 2, 3, 4)));

  EXPECT_EQ("2015-01-02T03",
            absl::StrFormat("%v", absl::CivilHour(2015, 1, 2, 3)));

  EXPECT_EQ("2015-01-02", absl::StrFormat("%v", absl::CivilDay(2015, 1, 2)));

  EXPECT_EQ("2015-01", absl::StrFormat("%v", absl::CivilMonth(2015, 1)));

  EXPECT_EQ("2015", absl::StrFormat("%v", absl::CivilYear(2015)));
}

TEST(CivilTime, OutputStream) {
  absl::CivilSecond cs(2016, 2, 3, 4, 5, 6);
  {
    std::stringstream ss;
    ss << std::left << std::setfill('.');
    ss << std::setw(3) << 'X';
    ss << std::setw(21) << absl::CivilYear(cs);
    ss << std::setw(3) << 'X';
    EXPECT_EQ("X..2016.................X..", ss.str());
  }
  {
    std::stringstream ss;
    ss << std::left << std::setfill('.');
    ss << std::setw(3) << 'X';
    ss << std::setw(21) << absl::CivilMonth(cs);
    ss << std::setw(3) << 'X';
    EXPECT_EQ("X..2016-02..............X..", ss.str());
  }
  {
    std::stringstream ss;
    ss << std::left << std::setfill('.');
    ss << std::setw(3) << 'X';
    ss << std::setw(21) << absl::CivilDay(cs);
    ss << std::setw(3) << 'X';
    EXPECT_EQ("X..2016-02-03...........X..", ss.str());
  }
  {
    std::stringstream ss;
    ss << std::left << std::setfill('.');
    ss << std::setw(3) << 'X';
    ss << std::setw(21) << absl::CivilHour(cs);
    ss << std::setw(3) << 'X';
    EXPECT_EQ("X..2016-02-03T04........X..", ss.str());
  }
  {
    std::stringstream ss;
    ss << std::left << std::setfill('.');
    ss << std::setw(3) << 'X';
    ss << std::setw(21) << absl::CivilMinute(cs);
    ss << std::setw(3) << 'X';
    EXPECT_EQ("X..2016-02-03T04:05.....X..", ss.str());
  }
  {
    std::stringstream ss;
    ss << std::left << std::setfill('.');
    ss << std::setw(3) << 'X';
    ss << std::setw(21) << absl::CivilSecond(cs);
    ss << std::setw(3) << 'X';
    EXPECT_EQ("X..2016-02-03T04:05:06..X..", ss.str());
  }
  {
    std::stringstream ss;
    ss << std::left << std::setfill('.');
    ss << std::setw(3) << 'X';
    ss << std::setw(21) << absl::Weekday::wednesday;
    ss << std::setw(3) << 'X';
    EXPECT_EQ("X..Wednesday............X..", ss.str());
  }
}

TEST(CivilTime, Weekday) {
  absl::CivilDay d(1970, 1, 1);
  EXPECT_EQ(absl::Weekday::thursday, absl::GetWeekday(d)) << d;

  // We used to get this wrong for years < -30.
  d = absl::CivilDay(-31, 12, 24);
  EXPECT_EQ(absl::Weekday::wednesday, absl::GetWeekday(d)) << d;
}

TEST(CivilTime, NextPrevWeekday) {
  // Jan 1, 1970 was a Thursday.
  const absl::CivilDay thursday(1970, 1, 1);

  // Thursday -> Thursday
  absl::CivilDay d = absl::NextWeekday(thursday, absl::Weekday::thursday);
  EXPECT_EQ(7, d - thursday) << d;
  EXPECT_EQ(d - 14, absl::PrevWeekday(thursday, absl::Weekday::thursday));

  // Thursday -> Friday
  d = absl::NextWeekday(thursday, absl::Weekday::friday);
  EXPECT_EQ(1, d - thursday) << d;
  EXPECT_EQ(d - 7, absl::PrevWeekday(thursday, absl::Weekday::friday));

  // Thursday -> Saturday
  d = absl::NextWeekday(thursday, absl::Weekday::saturday);
  EXPECT_EQ(2, d - thursday) << d;
  EXPECT_EQ(d - 7, absl::PrevWeekday(thursday, absl::Weekday::saturday));

  // Thursday -> Sunday
  d = absl::NextWeekday(thursday, absl::Weekday::sunday);
  EXPECT_EQ(3, d - thursday) << d;
  EXPECT_EQ(d - 7, absl::PrevWeekday(thursday, absl::Weekday::sunday));

  // Thursday -> Monday
  d = absl::NextWeekday(thursday, absl::Weekday::monday);
  EXPECT_EQ(4, d - thursday) << d;
  EXPECT_EQ(d - 7, absl::PrevWeekday(thursday, absl::Weekday::monday));

  // Thursday -> Tuesday
  d = absl::NextWeekday(thursday, absl::Weekday::tuesday);
  EXPECT_EQ(5, d - thursday) << d;
  EXPECT_EQ(d - 7, absl::PrevWeekday(thursday, absl::Weekday::tuesday));

  // Thursday -> Wednesday
  d = absl::NextWeekday(thursday, absl::Weekday::wednesday);
  EXPECT_EQ(6, d - thursday) << d;
  EXPECT_EQ(d - 7, absl::PrevWeekday(thursday, absl::Weekday::wednesday));
}

// NOTE: Run this with --copt=-ftrapv to detect overflow problems.
TEST(CivilTime, DifferenceWithHugeYear) {
  absl::CivilDay d1(9223372036854775807, 1, 1);
  absl::CivilDay d2(9223372036854775807, 12, 31);
  EXPECT_EQ(364, d2 - d1);

  d1 = absl::CivilDay(-9223372036854775807 - 1, 1, 1);
  d2 = absl::CivilDay(-9223372036854775807 - 1, 12, 31);
  EXPECT_EQ(365, d2 - d1);

  // Check the limits of the return value at the end of the year range.
  d1 = absl::CivilDay(9223372036854775807, 1, 1);
  d2 = absl::CivilDay(9198119301927009252, 6, 6);
  EXPECT_EQ(9223372036854775807, d1 - d2);
  d2 = d2 - 1;
  EXPECT_EQ(-9223372036854775807 - 1, d2 - d1);

  // Check the limits of the return value at the start of the year range.
  d1 = absl::CivilDay(-9223372036854775807 - 1, 1, 1);
  d2 = absl::CivilDay(-9198119301927009254, 7, 28);
  EXPECT_EQ(9223372036854775807, d2 - d1);
  d2 = d2 + 1;
  EXPECT_EQ(-9223372036854775807 - 1, d1 - d2);

  // Check the limits of the return value from either side of year 0.
  d1 = absl::CivilDay(-12626367463883278, 9, 3);
  d2 = absl::CivilDay(12626367463883277, 3, 28);
  EXPECT_EQ(9223372036854775807, d2 - d1);
  d2 = d2 + 1;
  EXPECT_EQ(-9223372036854775807 - 1, d1 - d2);
}

// NOTE: Run this with --copt=-ftrapv to detect overflow problems.
TEST(CivilTime, DifferenceNoIntermediateOverflow) {
  // The difference up to the minute field would be below the minimum
  // int64_t, but the 52 extra seconds brings us back to the minimum.
  absl::CivilSecond s1(-292277022657, 1, 27, 8, 29 - 1, 52);
  absl::CivilSecond s2(1970, 1, 1, 0, 0 - 1, 0);
  EXPECT_EQ(-9223372036854775807 - 1, s1 - s2);

  // The difference up to the minute field would be above the maximum
  // int64_t, but the -53 extra seconds brings us back to the maximum.
  s1 = absl::CivilSecond(292277026596, 12, 4, 15, 30, 7 - 7);
  s2 = absl::CivilSecond(1970, 1, 1, 0, 0, 0 - 7);
  EXPECT_EQ(9223372036854775807, s1 - s2);
}

TEST(CivilTime, NormalizeSimpleOverflow) {
  absl::CivilSecond cs;
  cs = absl::CivilSecond(2013, 11, 15, 16, 32, 59 + 1);
  EXPECT_EQ("2013-11-15T16:33:00", absl::FormatCivilTime(cs));
  cs = absl::CivilSecond(2013, 11, 15, 16, 59 + 1, 14);
  EXPECT_EQ("2013-11-15T17:00:14", absl::FormatCivilTime(cs));
  cs = absl::CivilSecond(2013, 11, 15, 23 + 1, 32, 14);
  EXPECT_EQ("2013-11-16T00:32:14", absl::FormatCivilTime(cs));
  cs = absl::CivilSecond(2013, 11, 30 + 1, 16, 32, 14);
  EXPECT_EQ("2013-12-01T16:32:14", absl::FormatCivilTime(cs));
  cs = absl::CivilSecond(2013, 12 + 1, 15, 16, 32, 14);
  EXPECT_EQ("2014-01-15T16:32:14", absl::FormatCivilTime(cs));
}

TEST(CivilTime, NormalizeSimpleUnderflow) {
  absl::CivilSecond cs;
  cs = absl::CivilSecond(2013, 11, 15, 16, 32, 0 - 1);
  EXPECT_EQ("2013-11-15T16:31:59", absl::FormatCivilTime(cs));
  cs = absl::CivilSecond(2013, 11, 15, 16, 0 - 1, 14);
  EXPECT_EQ("2013-11-15T15:59:14", absl::FormatCivilTime(cs));
  cs = absl::CivilSecond(2013, 11, 15, 0 - 1, 32, 14);
  EXPECT_EQ("2013-11-14T23:32:14", absl::FormatCivilTime(cs));
  cs = absl::CivilSecond(2013, 11, 1 - 1, 16, 32, 14);
  EXPECT_EQ("2013-10-31T16:32:14", absl::FormatCivilTime(cs));
  cs = absl::CivilSecond(2013, 1 - 1, 15, 16, 32, 14);
  EXPECT_EQ("2012-12-15T16:32:14", absl::FormatCivilTime(cs));
}

TEST(CivilTime, NormalizeMultipleOverflow) {
  absl::CivilSecond cs(2013, 12, 31, 23, 59, 59 + 1);
  EXPECT_EQ("2014-01-01T00:00:00", absl::FormatCivilTime(cs));
}

TEST(CivilTime, NormalizeMultipleUnderflow) {
  absl::CivilSecond cs(2014, 1, 1, 0, 0, 0 - 1);
  EXPECT_EQ("2013-12-31T23:59:59", absl::FormatCivilTime(cs));
}

TEST(CivilTime, NormalizeOverflowLimits) {
  absl::CivilSecond cs;

  const int kintmax = std::numeric_limits<int>::max();
  cs = absl::CivilSecond(0, kintmax, kintmax, kintmax, kintmax, kintmax);
  EXPECT_EQ("185085715-11-27T12:21:07", absl::FormatCivilTime(cs));

  const int kintmin = std::numeric_limits<int>::min();
  cs = absl::CivilSecond(0, kintmin, kintmin, kintmin, kintmin, kintmin);
  EXPECT_EQ("-185085717-10-31T10:37:52", absl::FormatCivilTime(cs));
}

TEST(CivilTime, NormalizeComplexOverflow) {
  absl::CivilSecond cs;
  cs = absl::CivilSecond(2013, 11, 15, 16, 32, 14 + 123456789);
  EXPECT_EQ("2017-10-14T14:05:23", absl::FormatCivilTime(cs));
  cs = absl::CivilSecond(2013, 11, 15, 16, 32 + 1234567, 14);
  EXPECT_EQ("2016-03-22T00:39:14", absl::FormatCivilTime(cs));
  cs = absl::CivilSecond(2013, 11, 15, 16 + 123456, 32, 14);
  EXPECT_EQ("2027-12-16T16:32:14", absl::FormatCivilTime(cs));
  cs = absl::CivilSecond(2013, 11, 15 + 1234, 16, 32, 14);
  EXPECT_EQ("2017-04-02T16:32:14", absl::FormatCivilTime(cs));
  cs = absl::CivilSecond(2013, 11 + 123, 15, 16, 32, 14);
  EXPECT_EQ("2024-02-15T16:32:14", absl::FormatCivilTime(cs));
}

TEST(CivilTime, NormalizeComplexUnderflow) {
  absl::CivilSecond cs;
  cs = absl::CivilSecond(1999, 3, 0, 0, 0, 0);  // year 400
  EXPECT_EQ("1999-02-28T00:00:00", absl::FormatCivilTime(cs));
  cs = absl::CivilSecond(2013, 11, 15, 16, 32, 14 - 123456789);
  EXPECT_EQ("2009-12-17T18:59:05", absl::FormatCivilTime(cs));
  cs = absl::CivilSecond(2013, 11, 15, 16, 32 - 1234567, 14);
  EXPECT_EQ("2011-07-12T08:25:14", absl::FormatCivilTime(cs));
  cs = absl::CivilSecond(2013, 11, 15, 16 - 123456, 32, 14);
  EXPECT_EQ("1999-10-16T16:32:14", absl::FormatCivilTime(cs));
  cs = absl::CivilSecond(2013, 11, 15 - 1234, 16, 32, 14);
  EXPECT_EQ("2010-06-30T16:32:14", absl::FormatCivilTime(cs));
  cs = absl::CivilSecond(2013, 11 - 123, 15, 16, 32, 14);
  EXPECT_EQ("2003-08-15T16:32:14", absl::FormatCivilTime(cs));
}

TEST(CivilTime, NormalizeMishmash) {
  absl::CivilSecond cs;
  cs = absl::CivilSecond(2013, 11 - 123, 15 + 1234, 16 - 123456, 32 + 1234567,
                         14 - 123456789);
  EXPECT_EQ("1991-05-09T03:06:05", absl::FormatCivilTime(cs));
  cs = absl::CivilSecond(2013, 11 + 123, 15 - 1234, 16 + 123456, 32 - 1234567,
                         14 + 123456789);
  EXPECT_EQ("2036-05-24T05:58:23", absl::FormatCivilTime(cs));

  cs = absl::CivilSecond(2013, 11, -146097 + 1, 16, 32, 14);
  EXPECT_EQ("1613-11-01T16:32:14", absl::FormatCivilTime(cs));
  cs = absl::CivilSecond(2013, 11 + 400 * 12, -146097 + 1, 16, 32, 14);
  EXPECT_EQ("2013-11-01T16:32:14", absl::FormatCivilTime(cs));
}

// Convert all the days from 1970-1-1 to 1970-1-146097 (aka 2369-12-31)
// and check that they normalize to the expected time.  146097 days span
// the 400-year Gregorian cycle used during normalization.
TEST(CivilTime, NormalizeAllTheDays) {
  absl::CivilDay expected(1970, 1, 1);
  for (int day = 1; day <= 146097; ++day) {
    absl::CivilSecond cs(1970, 1, day, 0, 0, 0);
    EXPECT_EQ(expected, cs);
    ++expected;
  }
}

TEST(CivilTime, NormalizeWithHugeYear) {
  absl::CivilMonth c(9223372036854775807, 1);
  EXPECT_EQ("9223372036854775807-01", absl::FormatCivilTime(c));
  c = c - 1;  // Causes normalization
  EXPECT_EQ("9223372036854775806-12", absl::FormatCivilTime(c));

  c = absl::CivilMonth(-9223372036854775807 - 1, 1);
  EXPECT_EQ("-9223372036854775808-01", absl::FormatCivilTime(c));
  c = c + 12;  // Causes normalization
  EXPECT_EQ("-9223372036854775807-01", absl::FormatCivilTime(c));
}

TEST(CivilTime, LeapYears) {
  const absl::CivilSecond s1(2013, 2, 28 + 1, 0, 0, 0);
  EXPECT_EQ("2013-03-01T00:00:00", absl::FormatCivilTime(s1));

  const absl::CivilSecond s2(2012, 2, 28 + 1, 0, 0, 0);
  EXPECT_EQ("2012-02-29T00:00:00", absl::FormatCivilTime(s2));

  const absl::CivilSecond s3(1900, 2, 28 + 1, 0, 0, 0);
  EXPECT_EQ("1900-03-01T00:00:00", absl::FormatCivilTime(s3));

  const struct {
    int year;
    int days;
    struct {
      int month;
      int day;
    } leap_day;  // The date of the day after Feb 28.
  } kLeapYearTable[]{
      {1900, 365, {3, 1}},
      {1999, 365, {3, 1}},
      {2000, 366, {2, 29}},  // leap year
      {2001, 365, {3, 1}},
      {2002, 365, {3, 1}},
      {2003, 365, {3, 1}},
      {2004, 366, {2, 29}},  // leap year
      {2005, 365, {3, 1}},
      {2006, 365, {3, 1}},
      {2007, 365, {3, 1}},
      {2008, 366, {2, 29}},  // leap year
      {2009, 365, {3, 1}},
      {2100, 365, {3, 1}},
  };

  for (int i = 0; i < ABSL_ARRAYSIZE(kLeapYearTable); ++i) {
    const int y = kLeapYearTable[i].year;
    const int m = kLeapYearTable[i].leap_day.month;
    const int d = kLeapYearTable[i].leap_day.day;
    const int n = kLeapYearTable[i].days;

    // Tests incrementing through the leap day.
    const absl::CivilDay feb28(y, 2, 28);
    const absl::CivilDay next_day = feb28 + 1;
    EXPECT_EQ(m, next_day.month());
    EXPECT_EQ(d, next_day.day());

    // Tests difference in days of leap years.
    const absl::CivilYear year(feb28);
    const absl::CivilYear next_year = year + 1;
    EXPECT_EQ(n, absl::CivilDay(next_year) - absl::CivilDay(year));
  }
}

TEST(CivilTime, FirstThursdayInMonth) {
  const absl::CivilDay nov1(2014, 11, 1);
  const absl::CivilDay thursday =
      absl::NextWeekday(nov1 - 1, absl::Weekday::thursday);
  EXPECT_EQ("2014-11-06", absl::FormatCivilTime(thursday));

  // Bonus: Date of Thanksgiving in the United States
  // Rule: Fourth Thursday of November
  const absl::CivilDay thanksgiving = thursday +  7 * 3;
  EXPECT_EQ("2014-11-27", absl::FormatCivilTime(thanksgiving));
}

TEST(CivilTime, DocumentationExample) {
  absl::CivilSecond second(2015, 6, 28, 1, 2, 3);  // 2015-06-28 01:02:03
  absl::CivilMinute minute(second);                // 2015-06-28 01:02:00
  absl::CivilDay day(minute);                      // 2015-06-28 00:00:00

  second -= 1;                    // 2015-06-28 01:02:02
  --second;                       // 2015-06-28 01:02:01
  EXPECT_EQ(minute, second - 1);  // Comparison between types
  EXPECT_LT(minute, second);

  // int diff = second - minute;  // ERROR: Mixed types, won't compile

  absl::CivilDay june_1(2015, 6, 1);  // Pass fields to c'tor.
  int diff = day - june_1;            // Num days between 'day' and June 1
  EXPECT_EQ(27, diff);

  // Fields smaller than alignment are floored to their minimum value.
  absl::CivilDay day_floor(2015, 1, 2, 9, 9, 9);
  EXPECT_EQ(0, day_floor.hour());  // 09:09:09 is floored
  EXPECT_EQ(absl::CivilDay(2015, 1, 2), day_floor);

  // Unspecified fields default to their minimum value
  absl::CivilDay day_default(2015);  // Defaults to Jan 1
  EXPECT_EQ(absl::CivilDay(2015, 1, 1), day_default);

  // Iterates all the days of June.
  absl::CivilMonth june(day);  // CivilDay -> CivilMonth
  absl::CivilMonth july = june + 1;
  for (absl::CivilDay day = june_1; day < july; ++day) {
    // ...
  }
}

}  // namespace
                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/clock.cc                                       0000664 0000000 0000000 00000063715 14746647661 0023712 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/time/clock.h"

#include "absl/base/attributes.h"
#include "absl/base/optimization.h"

#ifdef _WIN32
#include <windows.h>
#endif

#include <algorithm>
#include <atomic>
#include <cerrno>
#include <cstdint>
#include <ctime>
#include <limits>

#include "absl/base/internal/spinlock.h"
#include "absl/base/internal/unscaledcycleclock.h"
#include "absl/base/macros.h"
#include "absl/base/port.h"
#include "absl/base/thread_annotations.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
Time Now() {
  // TODO(bww): Get a timespec instead so we don't have to divide.
  int64_t n = absl::GetCurrentTimeNanos();
  if (n >= 0) {
    return time_internal::FromUnixDuration(
        time_internal::MakeDuration(n / 1000000000, n % 1000000000 * 4));
  }
  return time_internal::FromUnixDuration(absl::Nanoseconds(n));
}
ABSL_NAMESPACE_END
}  // namespace absl

// Decide if we should use the fast GetCurrentTimeNanos() algorithm based on the
// cyclecounter, otherwise just get the time directly from the OS on every call.
// By default, the fast algorithm based on the cyclecount is disabled because in
// certain situations, for example, if the OS enters a "sleep" mode, it may
// produce incorrect values immediately upon waking.
// This can be chosen at compile-time via
// -DABSL_USE_CYCLECLOCK_FOR_GET_CURRENT_TIME_NANOS=[0|1]
#ifndef ABSL_USE_CYCLECLOCK_FOR_GET_CURRENT_TIME_NANOS
#define ABSL_USE_CYCLECLOCK_FOR_GET_CURRENT_TIME_NANOS 0
#endif

#if defined(__APPLE__) || defined(_WIN32)
#include "absl/time/internal/get_current_time_chrono.inc"
#else
#include "absl/time/internal/get_current_time_posix.inc"
#endif

// Allows override by test.
#ifndef GET_CURRENT_TIME_NANOS_FROM_SYSTEM
#define GET_CURRENT_TIME_NANOS_FROM_SYSTEM() \
  ::absl::time_internal::GetCurrentTimeNanosFromSystem()
#endif

#if !ABSL_USE_CYCLECLOCK_FOR_GET_CURRENT_TIME_NANOS
namespace absl {
ABSL_NAMESPACE_BEGIN
int64_t GetCurrentTimeNanos() { return GET_CURRENT_TIME_NANOS_FROM_SYSTEM(); }
ABSL_NAMESPACE_END
}  // namespace absl
#else  // Use the cyclecounter-based implementation below.

// Allows override by test.
#ifndef GET_CURRENT_TIME_NANOS_CYCLECLOCK_NOW
#define GET_CURRENT_TIME_NANOS_CYCLECLOCK_NOW() \
  ::absl::time_internal::UnscaledCycleClockWrapperForGetCurrentTime::Now()
#endif

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {

// On some processors, consecutive reads of the cycle counter may yield the
// same value (weakly-increasing). In debug mode, clear the least significant
// bits to discourage depending on a strictly-increasing Now() value.
// In x86-64's debug mode, discourage depending on a strictly-increasing Now()
// value.
#if !defined(NDEBUG) && defined(__x86_64__)
constexpr int64_t kCycleClockNowMask = ~int64_t{0xff};
#else
constexpr int64_t kCycleClockNowMask = ~int64_t{0};
#endif

// This is a friend wrapper around UnscaledCycleClock::Now()
// (needed to access UnscaledCycleClock).
class UnscaledCycleClockWrapperForGetCurrentTime {
 public:
  static int64_t Now() {
    return base_internal::UnscaledCycleClock::Now() & kCycleClockNowMask;
  }
};
}  // namespace time_internal

// uint64_t is used in this module to provide an extra bit in multiplications

// ---------------------------------------------------------------------
// An implementation of reader-write locks that use no atomic ops in the read
// case.  This is a generalization of Lamport's method for reading a multiword
// clock.  Increment a word on each write acquisition, using the low-order bit
// as a spinlock; the word is the high word of the "clock".  Readers read the
// high word, then all other data, then the high word again, and repeat the
// read if the reads of the high words yields different answers, or an odd
// value (either case suggests possible interference from a writer).
// Here we use a spinlock to ensure only one writer at a time, rather than
// spinning on the bottom bit of the word to benefit from SpinLock
// spin-delay tuning.

// Acquire seqlock (*seq) and return the value to be written to unlock.
static inline uint64_t SeqAcquire(std::atomic<uint64_t> *seq) {
  uint64_t x = seq->fetch_add(1, std::memory_order_relaxed);

  // We put a release fence between update to *seq and writes to shared data.
  // Thus all stores to shared data are effectively release operations and
  // update to *seq above cannot be re-ordered past any of them.  Note that
  // this barrier is not for the fetch_add above.  A release barrier for the
  // fetch_add would be before it, not after.
  std::atomic_thread_fence(std::memory_order_release);

  return x + 2;   // original word plus 2
}

// Release seqlock (*seq) by writing x to it---a value previously returned by
// SeqAcquire.
static inline void SeqRelease(std::atomic<uint64_t> *seq, uint64_t x) {
  // The unlock store to *seq must have release ordering so that all
  // updates to shared data must finish before this store.
  seq->store(x, std::memory_order_release);  // release lock for readers
}

// ---------------------------------------------------------------------

// "nsscaled" is unit of time equal to a (2**kScale)th of a nanosecond.
enum { kScale = 30 };

// The minimum interval between samples of the time base.
// We pick enough time to amortize the cost of the sample,
// to get a reasonably accurate cycle counter rate reading,
// and not so much that calculations will overflow 64-bits.
static const uint64_t kMinNSBetweenSamples = 2000 << 20;

// We require that kMinNSBetweenSamples shifted by kScale
// have at least a bit left over for 64-bit calculations.
static_assert(((kMinNSBetweenSamples << (kScale + 1)) >> (kScale + 1)) ==
               kMinNSBetweenSamples,
               "cannot represent kMaxBetweenSamplesNSScaled");

// data from a sample of the kernel's time value
struct TimeSampleAtomic {
  std::atomic<uint64_t> raw_ns{0};              // raw kernel time
  std::atomic<uint64_t> base_ns{0};             // our estimate of time
  std::atomic<uint64_t> base_cycles{0};         // cycle counter reading
  std::atomic<uint64_t> nsscaled_per_cycle{0};  // cycle period
  // cycles before we'll sample again (a scaled reciprocal of the period,
  // to avoid a division on the fast path).
  std::atomic<uint64_t> min_cycles_per_sample{0};
};
// Same again, but with non-atomic types
struct TimeSample {
  uint64_t raw_ns = 0;                 // raw kernel time
  uint64_t base_ns = 0;                // our estimate of time
  uint64_t base_cycles = 0;            // cycle counter reading
  uint64_t nsscaled_per_cycle = 0;     // cycle period
  uint64_t min_cycles_per_sample = 0;  // approx cycles before next sample
};

struct ABSL_CACHELINE_ALIGNED TimeState {
  std::atomic<uint64_t> seq{0};
  TimeSampleAtomic last_sample;  // the last sample; under seq

  // The following counters are used only by the test code.
  int64_t stats_initializations{0};
  int64_t stats_reinitializations{0};
  int64_t stats_calibrations{0};
  int64_t stats_slow_paths{0};
  int64_t stats_fast_slow_paths{0};

  uint64_t last_now_cycles ABSL_GUARDED_BY(lock){0};

  // Used by GetCurrentTimeNanosFromKernel().
  // We try to read clock values at about the same time as the kernel clock.
  // This value gets adjusted up or down as estimate of how long that should
  // take, so we can reject attempts that take unusually long.
  std::atomic<uint64_t> approx_syscall_time_in_cycles{10 * 1000};
  // Number of times in a row we've seen a kernel time call take substantially
  // less than approx_syscall_time_in_cycles.
  std::atomic<uint32_t> kernel_time_seen_smaller{0};

  // A reader-writer lock protecting the static locations below.
  // See SeqAcquire() and SeqRelease() above.
  absl::base_internal::SpinLock lock{absl::kConstInit,
                                     base_internal::SCHEDULE_KERNEL_ONLY};
};
ABSL_CONST_INIT static TimeState time_state;

// Return the time in ns as told by the kernel interface.  Place in *cycleclock
// the value of the cycleclock at about the time of the syscall.
// This call represents the time base that this module synchronizes to.
// Ensures that *cycleclock does not step back by up to (1 << 16) from
// last_cycleclock, to discard small backward counter steps.  (Larger steps are
// assumed to be complete resyncs, which shouldn't happen.  If they do, a full
// reinitialization of the outer algorithm should occur.)
static int64_t GetCurrentTimeNanosFromKernel(uint64_t last_cycleclock,
                                             uint64_t *cycleclock)
    ABSL_EXCLUSIVE_LOCKS_REQUIRED(time_state.lock) {
  uint64_t local_approx_syscall_time_in_cycles =  // local copy
      time_state.approx_syscall_time_in_cycles.load(std::memory_order_relaxed);

  int64_t current_time_nanos_from_system;
  uint64_t before_cycles;
  uint64_t after_cycles;
  uint64_t elapsed_cycles;
  int loops = 0;
  do {
    before_cycles =
        static_cast<uint64_t>(GET_CURRENT_TIME_NANOS_CYCLECLOCK_NOW());
    current_time_nanos_from_system = GET_CURRENT_TIME_NANOS_FROM_SYSTEM();
    after_cycles =
        static_cast<uint64_t>(GET_CURRENT_TIME_NANOS_CYCLECLOCK_NOW());
    // elapsed_cycles is unsigned, so is large on overflow
    elapsed_cycles = after_cycles - before_cycles;
    if (elapsed_cycles >= local_approx_syscall_time_in_cycles &&
        ++loops == 20) {  // clock changed frequencies?  Back off.
      loops = 0;
      if (local_approx_syscall_time_in_cycles < 1000 * 1000) {
        local_approx_syscall_time_in_cycles =
            (local_approx_syscall_time_in_cycles + 1) << 1;
      }
      time_state.approx_syscall_time_in_cycles.store(
          local_approx_syscall_time_in_cycles, std::memory_order_relaxed);
    }
  } while (elapsed_cycles >= local_approx_syscall_time_in_cycles ||
           last_cycleclock - after_cycles < (static_cast<uint64_t>(1) << 16));

  // Adjust approx_syscall_time_in_cycles to be within a factor of 2
  // of the typical time to execute one iteration of the loop above.
  if ((local_approx_syscall_time_in_cycles >> 1) < elapsed_cycles) {
    // measured time is no smaller than half current approximation
    time_state.kernel_time_seen_smaller.store(0, std::memory_order_relaxed);
  } else if (time_state.kernel_time_seen_smaller.fetch_add(
                 1, std::memory_order_relaxed) >= 3) {
    // smaller delays several times in a row; reduce approximation by 12.5%
    const uint64_t new_approximation =
        local_approx_syscall_time_in_cycles -
        (local_approx_syscall_time_in_cycles >> 3);
    time_state.approx_syscall_time_in_cycles.store(new_approximation,
                                                   std::memory_order_relaxed);
    time_state.kernel_time_seen_smaller.store(0, std::memory_order_relaxed);
  }

  *cycleclock = after_cycles;
  return current_time_nanos_from_system;
}

static int64_t GetCurrentTimeNanosSlowPath() ABSL_ATTRIBUTE_COLD;

// Read the contents of *atomic into *sample.
// Each field is read atomically, but to maintain atomicity between fields,
// the access must be done under a lock.
static void ReadTimeSampleAtomic(const struct TimeSampleAtomic *atomic,
                                 struct TimeSample *sample) {
  sample->base_ns = atomic->base_ns.load(std::memory_order_relaxed);
  sample->base_cycles = atomic->base_cycles.load(std::memory_order_relaxed);
  sample->nsscaled_per_cycle =
      atomic->nsscaled_per_cycle.load(std::memory_order_relaxed);
  sample->min_cycles_per_sample =
      atomic->min_cycles_per_sample.load(std::memory_order_relaxed);
  sample->raw_ns = atomic->raw_ns.load(std::memory_order_relaxed);
}

// Public routine.
// Algorithm:  We wish to compute real time from a cycle counter.  In normal
// operation, we construct a piecewise linear approximation to the kernel time
// source, using the cycle counter value.  The start of each line segment is at
// the same point as the end of the last, but may have a different slope (that
// is, a different idea of the cycle counter frequency).  Every couple of
// seconds, the kernel time source is sampled and compared with the current
// approximation.  A new slope is chosen that, if followed for another couple
// of seconds, will correct the error at the current position.  The information
// for a sample is in the "last_sample" struct.  The linear approximation is
//   estimated_time = last_sample.base_ns +
//     last_sample.ns_per_cycle * (counter_reading - last_sample.base_cycles)
// (ns_per_cycle is actually stored in different units and scaled, to avoid
// overflow).  The base_ns of the next linear approximation is the
// estimated_time using the last approximation; the base_cycles is the cycle
// counter value at that time; the ns_per_cycle is the number of ns per cycle
// measured since the last sample, but adjusted so that most of the difference
// between the estimated_time and the kernel time will be corrected by the
// estimated time to the next sample.  In normal operation, this algorithm
// relies on:
// - the cycle counter and kernel time rates not changing a lot in a few
//   seconds.
// - the client calling into the code often compared to a couple of seconds, so
//   the time to the next correction can be estimated.
// Any time ns_per_cycle is not known, a major error is detected, or the
// assumption about frequent calls is violated, the implementation returns the
// kernel time.  It records sufficient data that a linear approximation can
// resume a little later.

int64_t GetCurrentTimeNanos() {
  // read the data from the "last_sample" struct (but don't need raw_ns yet)
  // The reads of "seq" and test of the values emulate a reader lock.
  uint64_t base_ns;
  uint64_t base_cycles;
  uint64_t nsscaled_per_cycle;
  uint64_t min_cycles_per_sample;
  uint64_t seq_read0;
  uint64_t seq_read1;

  // If we have enough information to interpolate, the value returned will be
  // derived from this cycleclock-derived time estimate.  On some platforms
  // (POWER) the function to retrieve this value has enough complexity to
  // contribute to register pressure - reading it early before initializing
  // the other pieces of the calculation minimizes spill/restore instructions,
  // minimizing icache cost.
  uint64_t now_cycles =
      static_cast<uint64_t>(GET_CURRENT_TIME_NANOS_CYCLECLOCK_NOW());

  // Acquire pairs with the barrier in SeqRelease - if this load sees that
  // store, the shared-data reads necessarily see that SeqRelease's updates
  // to the same shared data.
  seq_read0 = time_state.seq.load(std::memory_order_acquire);

  base_ns = time_state.last_sample.base_ns.load(std::memory_order_relaxed);
  base_cycles =
      time_state.last_sample.base_cycles.load(std::memory_order_relaxed);
  nsscaled_per_cycle =
      time_state.last_sample.nsscaled_per_cycle.load(std::memory_order_relaxed);
  min_cycles_per_sample = time_state.last_sample.min_cycles_per_sample.load(
      std::memory_order_relaxed);

  // This acquire fence pairs with the release fence in SeqAcquire.  Since it
  // is sequenced between reads of shared data and seq_read1, the reads of
  // shared data are effectively acquiring.
  std::atomic_thread_fence(std::memory_order_acquire);

  // The shared-data reads are effectively acquire ordered, and the
  // shared-data writes are effectively release ordered. Therefore if our
  // shared-data reads see any of a particular update's shared-data writes,
  // seq_read1 is guaranteed to see that update's SeqAcquire.
  seq_read1 = time_state.seq.load(std::memory_order_relaxed);

  // Fast path.  Return if min_cycles_per_sample has not yet elapsed since the
  // last sample, and we read a consistent sample.  The fast path activates
  // only when min_cycles_per_sample is non-zero, which happens when we get an
  // estimate for the cycle time.  The predicate will fail if now_cycles <
  // base_cycles, or if some other thread is in the slow path.
  //
  // Since we now read now_cycles before base_ns, it is possible for now_cycles
  // to be less than base_cycles (if we were interrupted between those loads and
  // last_sample was updated). This is harmless, because delta_cycles will wrap
  // and report a time much much bigger than min_cycles_per_sample. In that case
  // we will take the slow path.
  uint64_t delta_cycles;
  if (seq_read0 == seq_read1 && (seq_read0 & 1) == 0 &&
      (delta_cycles = now_cycles - base_cycles) < min_cycles_per_sample) {
    return static_cast<int64_t>(
        base_ns + ((delta_cycles * nsscaled_per_cycle) >> kScale));
  }
  return GetCurrentTimeNanosSlowPath();
}

// Return (a << kScale)/b.
// Zero is returned if b==0.   Scaling is performed internally to
// preserve precision without overflow.
static uint64_t SafeDivideAndScale(uint64_t a, uint64_t b) {
  // Find maximum safe_shift so that
  //  0 <= safe_shift <= kScale  and  (a << safe_shift) does not overflow.
  int safe_shift = kScale;
  while (((a << safe_shift) >> safe_shift) != a) {
    safe_shift--;
  }
  uint64_t scaled_b = b >> (kScale - safe_shift);
  uint64_t quotient = 0;
  if (scaled_b != 0) {
    quotient = (a << safe_shift) / scaled_b;
  }
  return quotient;
}

static uint64_t UpdateLastSample(
    uint64_t now_cycles, uint64_t now_ns, uint64_t delta_cycles,
    const struct TimeSample *sample) ABSL_ATTRIBUTE_COLD;

// The slow path of GetCurrentTimeNanos().  This is taken while gathering
// initial samples, when enough time has elapsed since the last sample, and if
// any other thread is writing to last_sample.
//
// Manually mark this 'noinline' to minimize stack frame size of the fast
// path.  Without this, sometimes a compiler may inline this big block of code
// into the fast path.  That causes lots of register spills and reloads that
// are unnecessary unless the slow path is taken.
//
// TODO(absl-team): Remove this attribute when our compiler is smart enough
// to do the right thing.
ABSL_ATTRIBUTE_NOINLINE
static int64_t GetCurrentTimeNanosSlowPath()
    ABSL_LOCKS_EXCLUDED(time_state.lock) {
  // Serialize access to slow-path.  Fast-path readers are not blocked yet, and
  // code below must not modify last_sample until the seqlock is acquired.
  time_state.lock.Lock();

  // Sample the kernel time base.  This is the definition of
  // "now" if we take the slow path.
  uint64_t now_cycles;
  uint64_t now_ns = static_cast<uint64_t>(
      GetCurrentTimeNanosFromKernel(time_state.last_now_cycles, &now_cycles));
  time_state.last_now_cycles = now_cycles;

  uint64_t estimated_base_ns;

  // ----------
  // Read the "last_sample" values again; this time holding the write lock.
  struct TimeSample sample;
  ReadTimeSampleAtomic(&time_state.last_sample, &sample);

  // ----------
  // Try running the fast path again; another thread may have updated the
  // sample between our run of the fast path and the sample we just read.
  uint64_t delta_cycles = now_cycles - sample.base_cycles;
  if (delta_cycles < sample.min_cycles_per_sample) {
    // Another thread updated the sample.  This path does not take the seqlock
    // so that blocked readers can make progress without blocking new readers.
    estimated_base_ns = sample.base_ns +
        ((delta_cycles * sample.nsscaled_per_cycle) >> kScale);
    time_state.stats_fast_slow_paths++;
  } else {
    estimated_base_ns =
        UpdateLastSample(now_cycles, now_ns, delta_cycles, &sample);
  }

  time_state.lock.Unlock();

  return static_cast<int64_t>(estimated_base_ns);
}

// Main part of the algorithm.  Locks out readers, updates the approximation
// using the new sample from the kernel, and stores the result in last_sample
// for readers.  Returns the new estimated time.
static uint64_t UpdateLastSample(uint64_t now_cycles, uint64_t now_ns,
                                 uint64_t delta_cycles,
                                 const struct TimeSample *sample)
    ABSL_EXCLUSIVE_LOCKS_REQUIRED(time_state.lock) {
  uint64_t estimated_base_ns = now_ns;
  uint64_t lock_value =
      SeqAcquire(&time_state.seq);  // acquire seqlock to block readers

  // The 5s in the next if-statement limits the time for which we will trust
  // the cycle counter and our last sample to give a reasonable result.
  // Errors in the rate of the source clock can be multiplied by the ratio
  // between this limit and kMinNSBetweenSamples.
  if (sample->raw_ns == 0 ||  // no recent sample, or clock went backwards
      sample->raw_ns + static_cast<uint64_t>(5) * 1000 * 1000 * 1000 < now_ns ||
      now_ns < sample->raw_ns || now_cycles < sample->base_cycles) {
    // record this sample, and forget any previously known slope.
    time_state.last_sample.raw_ns.store(now_ns, std::memory_order_relaxed);
    time_state.last_sample.base_ns.store(estimated_base_ns,
                                         std::memory_order_relaxed);
    time_state.last_sample.base_cycles.store(now_cycles,
                                             std::memory_order_relaxed);
    time_state.last_sample.nsscaled_per_cycle.store(0,
                                                    std::memory_order_relaxed);
    time_state.last_sample.min_cycles_per_sample.store(
        0, std::memory_order_relaxed);
    time_state.stats_initializations++;
  } else if (sample->raw_ns + 500 * 1000 * 1000 < now_ns &&
             sample->base_cycles + 50 < now_cycles) {
    // Enough time has passed to compute the cycle time.
    if (sample->nsscaled_per_cycle != 0) {  // Have a cycle time estimate.
      // Compute time from counter reading, but avoiding overflow
      // delta_cycles may be larger than on the fast path.
      uint64_t estimated_scaled_ns;
      int s = -1;
      do {
        s++;
        estimated_scaled_ns = (delta_cycles >> s) * sample->nsscaled_per_cycle;
      } while (estimated_scaled_ns / sample->nsscaled_per_cycle !=
               (delta_cycles >> s));
      estimated_base_ns = sample->base_ns +
                          (estimated_scaled_ns >> (kScale - s));
    }

    // Compute the assumed cycle time kMinNSBetweenSamples ns into the future
    // assuming the cycle counter rate stays the same as the last interval.
    uint64_t ns = now_ns - sample->raw_ns;
    uint64_t measured_nsscaled_per_cycle = SafeDivideAndScale(ns, delta_cycles);

    uint64_t assumed_next_sample_delta_cycles =
        SafeDivideAndScale(kMinNSBetweenSamples, measured_nsscaled_per_cycle);

    // Estimate low by this much.
    int64_t diff_ns = static_cast<int64_t>(now_ns - estimated_base_ns);

    // We want to set nsscaled_per_cycle so that our estimate of the ns time
    // at the assumed cycle time is the assumed ns time.
    // That is, we want to set nsscaled_per_cycle so:
    //  kMinNSBetweenSamples + diff_ns  ==
    //  (assumed_next_sample_delta_cycles * nsscaled_per_cycle) >> kScale
    // But we wish to damp oscillations, so instead correct only most
    // of our current error, by solving:
    //  kMinNSBetweenSamples + diff_ns - (diff_ns / 16) ==
    //  (assumed_next_sample_delta_cycles * nsscaled_per_cycle) >> kScale
    ns = static_cast<uint64_t>(static_cast<int64_t>(kMinNSBetweenSamples) +
                               diff_ns - (diff_ns / 16));
    uint64_t new_nsscaled_per_cycle =
        SafeDivideAndScale(ns, assumed_next_sample_delta_cycles);
    if (new_nsscaled_per_cycle != 0 &&
        diff_ns < 100 * 1000 * 1000 && -diff_ns < 100 * 1000 * 1000) {
      // record the cycle time measurement
      time_state.last_sample.nsscaled_per_cycle.store(
          new_nsscaled_per_cycle, std::memory_order_relaxed);
      uint64_t new_min_cycles_per_sample =
          SafeDivideAndScale(kMinNSBetweenSamples, new_nsscaled_per_cycle);
      time_state.last_sample.min_cycles_per_sample.store(
          new_min_cycles_per_sample, std::memory_order_relaxed);
      time_state.stats_calibrations++;
    } else {  // something went wrong; forget the slope
      time_state.last_sample.nsscaled_per_cycle.store(
          0, std::memory_order_relaxed);
      time_state.last_sample.min_cycles_per_sample.store(
          0, std::memory_order_relaxed);
      estimated_base_ns = now_ns;
      time_state.stats_reinitializations++;
    }
    time_state.last_sample.raw_ns.store(now_ns, std::memory_order_relaxed);
    time_state.last_sample.base_ns.store(estimated_base_ns,
                                         std::memory_order_relaxed);
    time_state.last_sample.base_cycles.store(now_cycles,
                                             std::memory_order_relaxed);
  } else {
    // have a sample, but no slope; waiting for enough time for a calibration
    time_state.stats_slow_paths++;
  }

  SeqRelease(&time_state.seq, lock_value);  // release the readers

  return estimated_base_ns;
}
ABSL_NAMESPACE_END
}  // namespace absl
#endif  // ABSL_USE_CYCLECLOCK_FOR_GET_CURRENT_TIME_NANOS

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace {

// Returns the maximum duration that SleepOnce() can sleep for.
constexpr absl::Duration MaxSleep() {
#ifdef _WIN32
  // Windows Sleep() takes unsigned long argument in milliseconds.
  return absl::Milliseconds(
      std::numeric_limits<unsigned long>::max());  // NOLINT(runtime/int)
#else
  return absl::Seconds(std::numeric_limits<time_t>::max());
#endif
}

// Sleeps for the given duration.
// REQUIRES: to_sleep <= MaxSleep().
void SleepOnce(absl::Duration to_sleep) {
#ifdef _WIN32
  Sleep(static_cast<DWORD>(to_sleep / absl::Milliseconds(1)));
#else
  struct timespec sleep_time = absl::ToTimespec(to_sleep);
  while (nanosleep(&sleep_time, &sleep_time) != 0 && errno == EINTR) {
    // Ignore signals and wait for the full interval to elapse.
  }
#endif
}

}  // namespace
ABSL_NAMESPACE_END
}  // namespace absl

extern "C" {

ABSL_ATTRIBUTE_WEAK void ABSL_INTERNAL_C_SYMBOL(AbslInternalSleepFor)(
    absl::Duration duration) {
  while (duration > absl::ZeroDuration()) {
    absl::Duration to_sleep = std::min(duration, absl::MaxSleep());
    absl::SleepOnce(to_sleep);
    duration -= to_sleep;
  }
}

}  // extern "C"
                                                   node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/clock.h                                        0000664 0000000 0000000 00000005332 14746647661 0023543 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// -----------------------------------------------------------------------------
// File: clock.h
// -----------------------------------------------------------------------------
//
// This header file contains utility functions for working with the system-wide
// realtime clock. For descriptions of the main time abstractions used within
// this header file, consult the time.h header file.
#ifndef ABSL_TIME_CLOCK_H_
#define ABSL_TIME_CLOCK_H_

#include <cstdint>

#include "absl/base/config.h"
#include "absl/base/macros.h"
#include "absl/time/time.h"

namespace absl {
ABSL_NAMESPACE_BEGIN

// Now()
//
// Returns the current time, expressed as an `absl::Time` absolute time value.
absl::Time Now();

// GetCurrentTimeNanos()
//
// Returns the current time, expressed as a count of nanoseconds since the Unix
// Epoch (https://en.wikipedia.org/wiki/Unix_time). Prefer `absl::Now()` instead
// for all but the most performance-sensitive cases (i.e. when you are calling
// this function hundreds of thousands of times per second).
int64_t GetCurrentTimeNanos();

// SleepFor()
//
// Sleeps for the specified duration, expressed as an `absl::Duration`.
//
// Notes:
// * Signal interruptions will not reduce the sleep duration.
// * Returns immediately when passed a nonpositive duration.
void SleepFor(absl::Duration duration);

ABSL_NAMESPACE_END
}  // namespace absl

// -----------------------------------------------------------------------------
// Implementation Details
// -----------------------------------------------------------------------------

// In some build configurations we pass --detect-odr-violations to the
// gold linker.  This causes it to flag weak symbol overrides as ODR
// violations.  Because ODR only applies to C++ and not C,
// --detect-odr-violations ignores symbols not mangled with C++ names.
// By changing our extension points to be extern "C", we dodge this
// check.
extern "C" {
ABSL_DLL void ABSL_INTERNAL_C_SYMBOL(AbslInternalSleepFor)(
    absl::Duration duration);
}  // extern "C"

inline void absl::SleepFor(absl::Duration duration) {
  ABSL_INTERNAL_C_SYMBOL(AbslInternalSleepFor)(duration);
}

#endif  // ABSL_TIME_CLOCK_H_
                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/clock_benchmark.cc                             0000664 0000000 0000000 00000004114 14746647661 0025710 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 The Abseil Authors.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/time/clock.h"

#if !defined(_WIN32)
#include <sys/time.h>
#else
#include <winsock2.h>
#endif  // _WIN32
#include <cstdio>

#include "absl/base/internal/cycleclock.h"
#include "benchmark/benchmark.h"

namespace {

void BM_Clock_Now_AbslTime(benchmark::State& state) {
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::Now());
  }
}
BENCHMARK(BM_Clock_Now_AbslTime);

void BM_Clock_Now_GetCurrentTimeNanos(benchmark::State& state) {
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::GetCurrentTimeNanos());
  }
}
BENCHMARK(BM_Clock_Now_GetCurrentTimeNanos);

void BM_Clock_Now_AbslTime_ToUnixNanos(benchmark::State& state) {
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::ToUnixNanos(absl::Now()));
  }
}
BENCHMARK(BM_Clock_Now_AbslTime_ToUnixNanos);

void BM_Clock_Now_CycleClock(benchmark::State& state) {
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::base_internal::CycleClock::Now());
  }
}
BENCHMARK(BM_Clock_Now_CycleClock);

#if !defined(_WIN32)
static void BM_Clock_Now_gettimeofday(benchmark::State& state) {
  struct timeval tv;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(gettimeofday(&tv, nullptr));
  }
}
BENCHMARK(BM_Clock_Now_gettimeofday);

static void BM_Clock_Now_clock_gettime(benchmark::State& state) {
  struct timespec ts;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(clock_gettime(CLOCK_REALTIME, &ts));
  }
}
BENCHMARK(BM_Clock_Now_clock_gettime);
#endif  // _WIN32

}  // namespace
                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/clock_test.cc                                  0000664 0000000 0000000 00000010322 14746647661 0024733 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/time/clock.h"

#include "absl/base/config.h"
#if defined(ABSL_HAVE_ALARM)
#include <signal.h>
#include <unistd.h>
#ifdef _AIX
// sig_t is not defined in AIX.
typedef void (*sig_t)(int);
#endif
#elif defined(__linux__) || defined(__APPLE__)
#error all known Linux and Apple targets have alarm
#endif

#include "gtest/gtest.h"
#include "absl/time/time.h"

namespace {

TEST(Time, Now) {
  const absl::Time before = absl::FromUnixNanos(absl::GetCurrentTimeNanos());
  const absl::Time now = absl::Now();
  const absl::Time after = absl::FromUnixNanos(absl::GetCurrentTimeNanos());
  EXPECT_GE(now, before);
  EXPECT_GE(after, now);
}

enum class AlarmPolicy { kWithoutAlarm, kWithAlarm };

#if defined(ABSL_HAVE_ALARM)
bool alarm_handler_invoked = false;

void AlarmHandler(int signo) {
  ASSERT_EQ(signo, SIGALRM);
  alarm_handler_invoked = true;
}
#endif

// Does SleepFor(d) take between lower_bound and upper_bound at least
// once between now and (now + timeout)?  If requested (and supported),
// add an alarm for the middle of the sleep period and expect it to fire.
bool SleepForBounded(absl::Duration d, absl::Duration lower_bound,
                     absl::Duration upper_bound, absl::Duration timeout,
                     AlarmPolicy alarm_policy, int* attempts) {
  const absl::Time deadline = absl::Now() + timeout;
  while (absl::Now() < deadline) {
#if defined(ABSL_HAVE_ALARM)
    sig_t old_alarm = SIG_DFL;
    if (alarm_policy == AlarmPolicy::kWithAlarm) {
      alarm_handler_invoked = false;
      old_alarm = signal(SIGALRM, AlarmHandler);
      alarm(absl::ToInt64Seconds(d / 2));
    }
#else
    EXPECT_EQ(alarm_policy, AlarmPolicy::kWithoutAlarm);
#endif
    ++*attempts;
    absl::Time start = absl::Now();
    absl::SleepFor(d);
    absl::Duration actual = absl::Now() - start;
#if defined(ABSL_HAVE_ALARM)
    if (alarm_policy == AlarmPolicy::kWithAlarm) {
      signal(SIGALRM, old_alarm);
      if (!alarm_handler_invoked) continue;
    }
#endif
    if (lower_bound <= actual && actual <= upper_bound) {
      return true;  // yes, the SleepFor() was correctly bounded
    }
  }
  return false;
}

testing::AssertionResult AssertSleepForBounded(absl::Duration d,
                                               absl::Duration early,
                                               absl::Duration late,
                                               absl::Duration timeout,
                                               AlarmPolicy alarm_policy) {
  const absl::Duration lower_bound = d - early;
  const absl::Duration upper_bound = d + late;
  int attempts = 0;
  if (SleepForBounded(d, lower_bound, upper_bound, timeout, alarm_policy,
                      &attempts)) {
    return testing::AssertionSuccess();
  }
  return testing::AssertionFailure()
         << "SleepFor(" << d << ") did not return within [" << lower_bound
         << ":" << upper_bound << "] in " << attempts << " attempt"
         << (attempts == 1 ? "" : "s") << " over " << timeout
         << (alarm_policy == AlarmPolicy::kWithAlarm ? " with" : " without")
         << " an alarm";
}

// Tests that SleepFor() returns neither too early nor too late.
TEST(SleepFor, Bounded) {
  const absl::Duration d = absl::Milliseconds(2500);
  const absl::Duration early = absl::Milliseconds(100);
  const absl::Duration late = absl::Milliseconds(300);
  const absl::Duration timeout = 48 * d;
  EXPECT_TRUE(AssertSleepForBounded(d, early, late, timeout,
                                    AlarmPolicy::kWithoutAlarm));
#if defined(ABSL_HAVE_ALARM)
  EXPECT_TRUE(AssertSleepForBounded(d, early, late, timeout,
                                    AlarmPolicy::kWithAlarm));
#endif
}

}  // namespace
                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/duration.cc                                    0000664 0000000 0000000 00000077436 14746647661 0024451 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// The implementation of the absl::Duration class, which is declared in
// //absl/time.h.  This class behaves like a numeric type; it has no public
// methods and is used only through the operators defined here.
//
// Implementation notes:
//
// An absl::Duration is represented as
//
//   rep_hi_ : (int64_t)  Whole seconds
//   rep_lo_ : (uint32_t) Fractions of a second
//
// The seconds value (rep_hi_) may be positive or negative as appropriate.
// The fractional seconds (rep_lo_) is always a positive offset from rep_hi_.
// The API for Duration guarantees at least nanosecond resolution, which
// means rep_lo_ could have a max value of 1B - 1 if it stored nanoseconds.
// However, to utilize more of the available 32 bits of space in rep_lo_,
// we instead store quarters of a nanosecond in rep_lo_ resulting in a max
// value of 4B - 1.  This allows us to correctly handle calculations like
// 0.5 nanos + 0.5 nanos = 1 nano.  The following example shows the actual
// Duration rep using quarters of a nanosecond.
//
//    2.5 sec = {rep_hi_=2,  rep_lo_=2000000000}  // lo = 4 * 500000000
//   -2.5 sec = {rep_hi_=-3, rep_lo_=2000000000}
//
// Infinite durations are represented as Durations with the rep_lo_ field set
// to all 1s.
//
//   +InfiniteDuration:
//     rep_hi_ : kint64max
//     rep_lo_ : ~0U
//
//   -InfiniteDuration:
//     rep_hi_ : kint64min
//     rep_lo_ : ~0U
//
// Arithmetic overflows/underflows to +/- infinity and saturates.

#if defined(_MSC_VER)
#include <winsock2.h>  // for timeval
#endif

#include <algorithm>
#include <cassert>
#include <chrono>  // NOLINT(build/c++11)
#include <cmath>
#include <cstdint>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <functional>
#include <limits>
#include <string>

#include "absl/base/attributes.h"
#include "absl/base/casts.h"
#include "absl/base/config.h"
#include "absl/numeric/int128.h"
#include "absl/strings/string_view.h"
#include "absl/strings/strip.h"
#include "absl/time/time.h"

namespace absl {
ABSL_NAMESPACE_BEGIN

namespace {

using time_internal::kTicksPerNanosecond;
using time_internal::kTicksPerSecond;

constexpr int64_t kint64max = std::numeric_limits<int64_t>::max();
constexpr int64_t kint64min = std::numeric_limits<int64_t>::min();

// Can't use std::isinfinite() because it doesn't exist on windows.
inline bool IsFinite(double d) {
  if (std::isnan(d)) return false;
  return d != std::numeric_limits<double>::infinity() &&
         d != -std::numeric_limits<double>::infinity();
}

inline bool IsValidDivisor(double d) {
  if (std::isnan(d)) return false;
  return d != 0.0;
}

// *sec may be positive or negative.  *ticks must be in the range
// -kTicksPerSecond < *ticks < kTicksPerSecond.  If *ticks is negative it
// will be normalized to a positive value by adjusting *sec accordingly.
inline void NormalizeTicks(int64_t* sec, int64_t* ticks) {
  if (*ticks < 0) {
    --*sec;
    *ticks += kTicksPerSecond;
  }
}

// Makes a uint128 from the absolute value of the given scalar.
inline uint128 MakeU128(int64_t a) {
  uint128 u128 = 0;
  if (a < 0) {
    ++u128;
    ++a;  // Makes it safe to negate 'a'
    a = -a;
  }
  u128 += static_cast<uint64_t>(a);
  return u128;
}

// Makes a uint128 count of ticks out of the absolute value of the Duration.
inline uint128 MakeU128Ticks(Duration d) {
  int64_t rep_hi = time_internal::GetRepHi(d);
  uint32_t rep_lo = time_internal::GetRepLo(d);
  if (rep_hi < 0) {
    ++rep_hi;
    rep_hi = -rep_hi;
    rep_lo = kTicksPerSecond - rep_lo;
  }
  uint128 u128 = static_cast<uint64_t>(rep_hi);
  u128 *= static_cast<uint64_t>(kTicksPerSecond);
  u128 += rep_lo;
  return u128;
}

// Breaks a uint128 of ticks into a Duration.
inline Duration MakeDurationFromU128(uint128 u128, bool is_neg) {
  int64_t rep_hi;
  uint32_t rep_lo;
  const uint64_t h64 = Uint128High64(u128);
  const uint64_t l64 = Uint128Low64(u128);
  if (h64 == 0) {  // fastpath
    const uint64_t hi = l64 / kTicksPerSecond;
    rep_hi = static_cast<int64_t>(hi);
    rep_lo = static_cast<uint32_t>(l64 - hi * kTicksPerSecond);
  } else {
    // kMaxRepHi64 is the high 64 bits of (2^63 * kTicksPerSecond).
    // Any positive tick count whose high 64 bits are >= kMaxRepHi64
    // is not representable as a Duration.  A negative tick count can
    // have its high 64 bits == kMaxRepHi64 but only when the low 64
    // bits are all zero, otherwise it is not representable either.
    const uint64_t kMaxRepHi64 = 0x77359400UL;
    if (h64 >= kMaxRepHi64) {
      if (is_neg && h64 == kMaxRepHi64 && l64 == 0) {
        // Avoid trying to represent -kint64min below.
        return time_internal::MakeDuration(kint64min);
      }
      return is_neg ? -InfiniteDuration() : InfiniteDuration();
    }
    const uint128 kTicksPerSecond128 = static_cast<uint64_t>(kTicksPerSecond);
    const uint128 hi = u128 / kTicksPerSecond128;
    rep_hi = static_cast<int64_t>(Uint128Low64(hi));
    rep_lo =
        static_cast<uint32_t>(Uint128Low64(u128 - hi * kTicksPerSecond128));
  }
  if (is_neg) {
    rep_hi = -rep_hi;
    if (rep_lo != 0) {
      --rep_hi;
      rep_lo = kTicksPerSecond - rep_lo;
    }
  }
  return time_internal::MakeDuration(rep_hi, rep_lo);
}

// Convert between int64_t and uint64_t, preserving representation. This
// allows us to do arithmetic in the unsigned domain, where overflow has
// well-defined behavior. See operator+=() and operator-=().
//
// C99 7.20.1.1.1, as referenced by C++11 18.4.1.2, says, "The typedef
// name intN_t designates a signed integer type with width N, no padding
// bits, and a two's complement representation." So, we can convert to
// and from the corresponding uint64_t value using a bit cast.
inline uint64_t EncodeTwosComp(int64_t v) {
  return absl::bit_cast<uint64_t>(v);
}
inline int64_t DecodeTwosComp(uint64_t v) { return absl::bit_cast<int64_t>(v); }

// Note: The overflow detection in this function is done using greater/less *or
// equal* because kint64max/min is too large to be represented exactly in a
// double (which only has 53 bits of precision). In order to avoid assigning to
// rep->hi a double value that is too large for an int64_t (and therefore is
// undefined), we must consider computations that equal kint64max/min as a
// double as overflow cases.
inline bool SafeAddRepHi(double a_hi, double b_hi, Duration* d) {
  double c = a_hi + b_hi;
  if (c >= static_cast<double>(kint64max)) {
    *d = InfiniteDuration();
    return false;
  }
  if (c <= static_cast<double>(kint64min)) {
    *d = -InfiniteDuration();
    return false;
  }
  *d = time_internal::MakeDuration(c, time_internal::GetRepLo(*d));
  return true;
}

// A functor that's similar to std::multiplies<T>, except this returns the max
// T value instead of overflowing. This is only defined for uint128.
template <typename Ignored>
struct SafeMultiply {
  uint128 operator()(uint128 a, uint128 b) const {
    // b hi is always zero because it originated as an int64_t.
    assert(Uint128High64(b) == 0);
    // Fastpath to avoid the expensive overflow check with division.
    if (Uint128High64(a) == 0) {
      return (((Uint128Low64(a) | Uint128Low64(b)) >> 32) == 0)
                 ? static_cast<uint128>(Uint128Low64(a) * Uint128Low64(b))
                 : a * b;
    }
    return b == 0 ? b : (a > Uint128Max() / b) ? Uint128Max() : a * b;
  }
};

// Scales (i.e., multiplies or divides, depending on the Operation template)
// the Duration d by the int64_t r.
template <template <typename> class Operation>
inline Duration ScaleFixed(Duration d, int64_t r) {
  const uint128 a = MakeU128Ticks(d);
  const uint128 b = MakeU128(r);
  const uint128 q = Operation<uint128>()(a, b);
  const bool is_neg = (time_internal::GetRepHi(d) < 0) != (r < 0);
  return MakeDurationFromU128(q, is_neg);
}

// Scales (i.e., multiplies or divides, depending on the Operation template)
// the Duration d by the double r.
template <template <typename> class Operation>
inline Duration ScaleDouble(Duration d, double r) {
  Operation<double> op;
  double hi_doub = op(time_internal::GetRepHi(d), r);
  double lo_doub = op(time_internal::GetRepLo(d), r);

  double hi_int = 0;
  double hi_frac = std::modf(hi_doub, &hi_int);

  // Moves hi's fractional bits to lo.
  lo_doub /= kTicksPerSecond;
  lo_doub += hi_frac;

  double lo_int = 0;
  double lo_frac = std::modf(lo_doub, &lo_int);

  // Rolls lo into hi if necessary.
  int64_t lo64 = std::round(lo_frac * kTicksPerSecond);

  Duration ans;
  if (!SafeAddRepHi(hi_int, lo_int, &ans)) return ans;
  int64_t hi64 = time_internal::GetRepHi(ans);
  if (!SafeAddRepHi(hi64, lo64 / kTicksPerSecond, &ans)) return ans;
  hi64 = time_internal::GetRepHi(ans);
  lo64 %= kTicksPerSecond;
  NormalizeTicks(&hi64, &lo64);
  return time_internal::MakeDuration(hi64, lo64);
}

// Tries to divide num by den as fast as possible by looking for common, easy
// cases. If the division was done, the quotient is in *q and the remainder is
// in *rem and true will be returned.
inline bool IDivFastPath(const Duration num, const Duration den, int64_t* q,
                         Duration* rem) {
  // Bail if num or den is an infinity.
  if (time_internal::IsInfiniteDuration(num) ||
      time_internal::IsInfiniteDuration(den))
    return false;

  int64_t num_hi = time_internal::GetRepHi(num);
  uint32_t num_lo = time_internal::GetRepLo(num);
  int64_t den_hi = time_internal::GetRepHi(den);
  uint32_t den_lo = time_internal::GetRepLo(den);

  if (den_hi == 0) {
    if (den_lo == kTicksPerNanosecond) {
      // Dividing by 1ns
      if (num_hi >= 0 && num_hi < (kint64max - kTicksPerSecond) / 1000000000) {
        *q = num_hi * 1000000000 + num_lo / kTicksPerNanosecond;
        *rem = time_internal::MakeDuration(0, num_lo % den_lo);
        return true;
      }
    } else if (den_lo == 100 * kTicksPerNanosecond) {
      // Dividing by 100ns (common when converting to Universal time)
      if (num_hi >= 0 && num_hi < (kint64max - kTicksPerSecond) / 10000000) {
        *q = num_hi * 10000000 + num_lo / (100 * kTicksPerNanosecond);
        *rem = time_internal::MakeDuration(0, num_lo % den_lo);
        return true;
      }
    } else if (den_lo == 1000 * kTicksPerNanosecond) {
      // Dividing by 1us
      if (num_hi >= 0 && num_hi < (kint64max - kTicksPerSecond) / 1000000) {
        *q = num_hi * 1000000 + num_lo / (1000 * kTicksPerNanosecond);
        *rem = time_internal::MakeDuration(0, num_lo % den_lo);
        return true;
      }
    } else if (den_lo == 1000000 * kTicksPerNanosecond) {
      // Dividing by 1ms
      if (num_hi >= 0 && num_hi < (kint64max - kTicksPerSecond) / 1000) {
        *q = num_hi * 1000 + num_lo / (1000000 * kTicksPerNanosecond);
        *rem = time_internal::MakeDuration(0, num_lo % den_lo);
        return true;
      }
    }
  } else if (den_hi > 0 && den_lo == 0) {
    // Dividing by positive multiple of 1s
    if (num_hi >= 0) {
      if (den_hi == 1) {
        *q = num_hi;
        *rem = time_internal::MakeDuration(0, num_lo);
        return true;
      }
      *q = num_hi / den_hi;
      *rem = time_internal::MakeDuration(num_hi % den_hi, num_lo);
      return true;
    }
    if (num_lo != 0) {
      num_hi += 1;
    }
    int64_t quotient = num_hi / den_hi;
    int64_t rem_sec = num_hi % den_hi;
    if (rem_sec > 0) {
      rem_sec -= den_hi;
      quotient += 1;
    }
    if (num_lo != 0) {
      rem_sec -= 1;
    }
    *q = quotient;
    *rem = time_internal::MakeDuration(rem_sec, num_lo);
    return true;
  }

  return false;
}

}  // namespace

namespace {

int64_t IDivSlowPath(bool satq, const Duration num, const Duration den,
                     Duration* rem) {
  const bool num_neg = num < ZeroDuration();
  const bool den_neg = den < ZeroDuration();
  const bool quotient_neg = num_neg != den_neg;

  if (time_internal::IsInfiniteDuration(num) || den == ZeroDuration()) {
    *rem = num_neg ? -InfiniteDuration() : InfiniteDuration();
    return quotient_neg ? kint64min : kint64max;
  }
  if (time_internal::IsInfiniteDuration(den)) {
    *rem = num;
    return 0;
  }

  const uint128 a = MakeU128Ticks(num);
  const uint128 b = MakeU128Ticks(den);
  uint128 quotient128 = a / b;

  if (satq) {
    // Limits the quotient to the range of int64_t.
    if (quotient128 > uint128(static_cast<uint64_t>(kint64max))) {
      quotient128 = quotient_neg ? uint128(static_cast<uint64_t>(kint64min))
                                 : uint128(static_cast<uint64_t>(kint64max));
    }
  }

  const uint128 remainder128 = a - quotient128 * b;
  *rem = MakeDurationFromU128(remainder128, num_neg);

  if (!quotient_neg || quotient128 == 0) {
    return Uint128Low64(quotient128) & kint64max;
  }
  // The quotient needs to be negated, but we need to carefully handle
  // quotient128s with the top bit on.
  return -static_cast<int64_t>(Uint128Low64(quotient128 - 1) & kint64max) - 1;
}

// The 'satq' argument indicates whether the quotient should saturate at the
// bounds of int64_t.  If it does saturate, the difference will spill over to
// the remainder.  If it does not saturate, the remainder remain accurate,
// but the returned quotient will over/underflow int64_t and should not be used.
ABSL_ATTRIBUTE_ALWAYS_INLINE inline int64_t IDivDurationImpl(bool satq,
                                                             const Duration num,
                                                             const Duration den,
                                                             Duration* rem) {
  int64_t q = 0;
  if (IDivFastPath(num, den, &q, rem)) {
    return q;
  }
  return IDivSlowPath(satq, num, den, rem);
}

}  // namespace

int64_t IDivDuration(Duration num, Duration den, Duration* rem) {
  return IDivDurationImpl(true, num, den,
                          rem);  // trunc towards zero
}

//
// Additive operators.
//

Duration& Duration::operator+=(Duration rhs) {
  if (time_internal::IsInfiniteDuration(*this)) return *this;
  if (time_internal::IsInfiniteDuration(rhs)) return *this = rhs;
  const int64_t orig_rep_hi = rep_hi_.Get();
  rep_hi_ = DecodeTwosComp(EncodeTwosComp(rep_hi_.Get()) +
                           EncodeTwosComp(rhs.rep_hi_.Get()));
  if (rep_lo_ >= kTicksPerSecond - rhs.rep_lo_) {
    rep_hi_ = DecodeTwosComp(EncodeTwosComp(rep_hi_.Get()) + 1);
    rep_lo_ -= kTicksPerSecond;
  }
  rep_lo_ += rhs.rep_lo_;
  if (rhs.rep_hi_.Get() < 0 ? rep_hi_.Get() > orig_rep_hi
                            : rep_hi_.Get() < orig_rep_hi) {
    return *this =
               rhs.rep_hi_.Get() < 0 ? -InfiniteDuration() : InfiniteDuration();
  }
  return *this;
}

Duration& Duration::operator-=(Duration rhs) {
  if (time_internal::IsInfiniteDuration(*this)) return *this;
  if (time_internal::IsInfiniteDuration(rhs)) {
    return *this = rhs.rep_hi_.Get() >= 0 ? -InfiniteDuration()
                                          : InfiniteDuration();
  }
  const int64_t orig_rep_hi = rep_hi_.Get();
  rep_hi_ = DecodeTwosComp(EncodeTwosComp(rep_hi_.Get()) -
                           EncodeTwosComp(rhs.rep_hi_.Get()));
  if (rep_lo_ < rhs.rep_lo_) {
    rep_hi_ = DecodeTwosComp(EncodeTwosComp(rep_hi_.Get()) - 1);
    rep_lo_ += kTicksPerSecond;
  }
  rep_lo_ -= rhs.rep_lo_;
  if (rhs.rep_hi_.Get() < 0 ? rep_hi_.Get() < orig_rep_hi
                            : rep_hi_.Get() > orig_rep_hi) {
    return *this = rhs.rep_hi_.Get() >= 0 ? -InfiniteDuration()
                                          : InfiniteDuration();
  }
  return *this;
}

//
// Multiplicative operators.
//

Duration& Duration::operator*=(int64_t r) {
  if (time_internal::IsInfiniteDuration(*this)) {
    const bool is_neg = (r < 0) != (rep_hi_.Get() < 0);
    return *this = is_neg ? -InfiniteDuration() : InfiniteDuration();
  }
  return *this = ScaleFixed<SafeMultiply>(*this, r);
}

Duration& Duration::operator*=(double r) {
  if (time_internal::IsInfiniteDuration(*this) || !IsFinite(r)) {
    const bool is_neg = std::signbit(r) != (rep_hi_.Get() < 0);
    return *this = is_neg ? -InfiniteDuration() : InfiniteDuration();
  }
  return *this = ScaleDouble<std::multiplies>(*this, r);
}

Duration& Duration::operator/=(int64_t r) {
  if (time_internal::IsInfiniteDuration(*this) || r == 0) {
    const bool is_neg = (r < 0) != (rep_hi_.Get() < 0);
    return *this = is_neg ? -InfiniteDuration() : InfiniteDuration();
  }
  return *this = ScaleFixed<std::divides>(*this, r);
}

Duration& Duration::operator/=(double r) {
  if (time_internal::IsInfiniteDuration(*this) || !IsValidDivisor(r)) {
    const bool is_neg = std::signbit(r) != (rep_hi_.Get() < 0);
    return *this = is_neg ? -InfiniteDuration() : InfiniteDuration();
  }
  return *this = ScaleDouble<std::divides>(*this, r);
}

Duration& Duration::operator%=(Duration rhs) {
  IDivDurationImpl(false, *this, rhs, this);
  return *this;
}

double FDivDuration(Duration num, Duration den) {
  // Arithmetic with infinity is sticky.
  if (time_internal::IsInfiniteDuration(num) || den == ZeroDuration()) {
    return (num < ZeroDuration()) == (den < ZeroDuration())
               ? std::numeric_limits<double>::infinity()
               : -std::numeric_limits<double>::infinity();
  }
  if (time_internal::IsInfiniteDuration(den)) return 0.0;

  double a =
      static_cast<double>(time_internal::GetRepHi(num)) * kTicksPerSecond +
      time_internal::GetRepLo(num);
  double b =
      static_cast<double>(time_internal::GetRepHi(den)) * kTicksPerSecond +
      time_internal::GetRepLo(den);
  return a / b;
}

//
// Trunc/Floor/Ceil.
//

Duration Trunc(Duration d, Duration unit) { return d - (d % unit); }

Duration Floor(const Duration d, const Duration unit) {
  const absl::Duration td = Trunc(d, unit);
  return td <= d ? td : td - AbsDuration(unit);
}

Duration Ceil(const Duration d, const Duration unit) {
  const absl::Duration td = Trunc(d, unit);
  return td >= d ? td : td + AbsDuration(unit);
}

//
// Factory functions.
//

Duration DurationFromTimespec(timespec ts) {
  if (static_cast<uint64_t>(ts.tv_nsec) < 1000 * 1000 * 1000) {
    int64_t ticks = ts.tv_nsec * kTicksPerNanosecond;
    return time_internal::MakeDuration(ts.tv_sec, ticks);
  }
  return Seconds(ts.tv_sec) + Nanoseconds(ts.tv_nsec);
}

Duration DurationFromTimeval(timeval tv) {
  if (static_cast<uint64_t>(tv.tv_usec) < 1000 * 1000) {
    int64_t ticks = tv.tv_usec * 1000 * kTicksPerNanosecond;
    return time_internal::MakeDuration(tv.tv_sec, ticks);
  }
  return Seconds(tv.tv_sec) + Microseconds(tv.tv_usec);
}

//
// Conversion to other duration types.
//

int64_t ToInt64Nanoseconds(Duration d) {
  if (time_internal::GetRepHi(d) >= 0 &&
      time_internal::GetRepHi(d) >> 33 == 0) {
    return (time_internal::GetRepHi(d) * 1000 * 1000 * 1000) +
           (time_internal::GetRepLo(d) / kTicksPerNanosecond);
  }
  return d / Nanoseconds(1);
}
int64_t ToInt64Microseconds(Duration d) {
  if (time_internal::GetRepHi(d) >= 0 &&
      time_internal::GetRepHi(d) >> 43 == 0) {
    return (time_internal::GetRepHi(d) * 1000 * 1000) +
           (time_internal::GetRepLo(d) / (kTicksPerNanosecond * 1000));
  }
  return d / Microseconds(1);
}
int64_t ToInt64Milliseconds(Duration d) {
  if (time_internal::GetRepHi(d) >= 0 &&
      time_internal::GetRepHi(d) >> 53 == 0) {
    return (time_internal::GetRepHi(d) * 1000) +
           (time_internal::GetRepLo(d) / (kTicksPerNanosecond * 1000 * 1000));
  }
  return d / Milliseconds(1);
}
int64_t ToInt64Seconds(Duration d) {
  int64_t hi = time_internal::GetRepHi(d);
  if (time_internal::IsInfiniteDuration(d)) return hi;
  if (hi < 0 && time_internal::GetRepLo(d) != 0) ++hi;
  return hi;
}
int64_t ToInt64Minutes(Duration d) {
  int64_t hi = time_internal::GetRepHi(d);
  if (time_internal::IsInfiniteDuration(d)) return hi;
  if (hi < 0 && time_internal::GetRepLo(d) != 0) ++hi;
  return hi / 60;
}
int64_t ToInt64Hours(Duration d) {
  int64_t hi = time_internal::GetRepHi(d);
  if (time_internal::IsInfiniteDuration(d)) return hi;
  if (hi < 0 && time_internal::GetRepLo(d) != 0) ++hi;
  return hi / (60 * 60);
}

double ToDoubleNanoseconds(Duration d) {
  return FDivDuration(d, Nanoseconds(1));
}
double ToDoubleMicroseconds(Duration d) {
  return FDivDuration(d, Microseconds(1));
}
double ToDoubleMilliseconds(Duration d) {
  return FDivDuration(d, Milliseconds(1));
}
double ToDoubleSeconds(Duration d) { return FDivDuration(d, Seconds(1)); }
double ToDoubleMinutes(Duration d) { return FDivDuration(d, Minutes(1)); }
double ToDoubleHours(Duration d) { return FDivDuration(d, Hours(1)); }

timespec ToTimespec(Duration d) {
  timespec ts;
  if (!time_internal::IsInfiniteDuration(d)) {
    int64_t rep_hi = time_internal::GetRepHi(d);
    uint32_t rep_lo = time_internal::GetRepLo(d);
    if (rep_hi < 0) {
      // Tweak the fields so that unsigned division of rep_lo
      // maps to truncation (towards zero) for the timespec.
      rep_lo += kTicksPerNanosecond - 1;
      if (rep_lo >= kTicksPerSecond) {
        rep_hi += 1;
        rep_lo -= kTicksPerSecond;
      }
    }
    ts.tv_sec = static_cast<decltype(ts.tv_sec)>(rep_hi);
    if (ts.tv_sec == rep_hi) {  // no time_t narrowing
      ts.tv_nsec = rep_lo / kTicksPerNanosecond;
      return ts;
    }
  }
  if (d >= ZeroDuration()) {
    ts.tv_sec = std::numeric_limits<time_t>::max();
    ts.tv_nsec = 1000 * 1000 * 1000 - 1;
  } else {
    ts.tv_sec = std::numeric_limits<time_t>::min();
    ts.tv_nsec = 0;
  }
  return ts;
}

timeval ToTimeval(Duration d) {
  timeval tv;
  timespec ts = ToTimespec(d);
  if (ts.tv_sec < 0) {
    // Tweak the fields so that positive division of tv_nsec
    // maps to truncation (towards zero) for the timeval.
    ts.tv_nsec += 1000 - 1;
    if (ts.tv_nsec >= 1000 * 1000 * 1000) {
      ts.tv_sec += 1;
      ts.tv_nsec -= 1000 * 1000 * 1000;
    }
  }
  tv.tv_sec = static_cast<decltype(tv.tv_sec)>(ts.tv_sec);
  if (tv.tv_sec != ts.tv_sec) {  // narrowing
    if (ts.tv_sec < 0) {
      tv.tv_sec = std::numeric_limits<decltype(tv.tv_sec)>::min();
      tv.tv_usec = 0;
    } else {
      tv.tv_sec = std::numeric_limits<decltype(tv.tv_sec)>::max();
      tv.tv_usec = 1000 * 1000 - 1;
    }
    return tv;
  }
  tv.tv_usec = static_cast<int>(ts.tv_nsec / 1000);  // suseconds_t
  return tv;
}

std::chrono::nanoseconds ToChronoNanoseconds(Duration d) {
  return time_internal::ToChronoDuration<std::chrono::nanoseconds>(d);
}
std::chrono::microseconds ToChronoMicroseconds(Duration d) {
  return time_internal::ToChronoDuration<std::chrono::microseconds>(d);
}
std::chrono::milliseconds ToChronoMilliseconds(Duration d) {
  return time_internal::ToChronoDuration<std::chrono::milliseconds>(d);
}
std::chrono::seconds ToChronoSeconds(Duration d) {
  return time_internal::ToChronoDuration<std::chrono::seconds>(d);
}
std::chrono::minutes ToChronoMinutes(Duration d) {
  return time_internal::ToChronoDuration<std::chrono::minutes>(d);
}
std::chrono::hours ToChronoHours(Duration d) {
  return time_internal::ToChronoDuration<std::chrono::hours>(d);
}

//
// To/From string formatting.
//

namespace {

// Formats a positive 64-bit integer in the given field width.  Note that
// it is up to the caller of Format64() to ensure that there is sufficient
// space before ep to hold the conversion.
char* Format64(char* ep, int width, int64_t v) {
  do {
    --width;
    *--ep = static_cast<char>('0' + (v % 10));  // contiguous digits
  } while (v /= 10);
  while (--width >= 0) *--ep = '0';  // zero pad
  return ep;
}

// Helpers for FormatDuration() that format 'n' and append it to 'out'
// followed by the given 'unit'.  If 'n' formats to "0", nothing is
// appended (not even the unit).

// A type that encapsulates how to display a value of a particular unit. For
// values that are displayed with fractional parts, the precision indicates
// where to round the value. The precision varies with the display unit because
// a Duration can hold only quarters of a nanosecond, so displaying information
// beyond that is just noise.
//
// For example, a microsecond value of 42.00025xxxxx should not display beyond 5
// fractional digits, because it is in the noise of what a Duration can
// represent.
struct DisplayUnit {
  absl::string_view abbr;
  int prec;
  double pow10;
};
ABSL_CONST_INIT const DisplayUnit kDisplayNano = {"ns", 2, 1e2};
ABSL_CONST_INIT const DisplayUnit kDisplayMicro = {"us", 5, 1e5};
ABSL_CONST_INIT const DisplayUnit kDisplayMilli = {"ms", 8, 1e8};
ABSL_CONST_INIT const DisplayUnit kDisplaySec = {"s", 11, 1e11};
ABSL_CONST_INIT const DisplayUnit kDisplayMin = {"m", -1, 0.0};  // prec ignored
ABSL_CONST_INIT const DisplayUnit kDisplayHour = {"h", -1,
                                                  0.0};  // prec ignored

void AppendNumberUnit(std::string* out, int64_t n, DisplayUnit unit) {
  char buf[sizeof("2562047788015216")];  // hours in max duration
  char* const ep = buf + sizeof(buf);
  char* bp = Format64(ep, 0, n);
  if (*bp != '0' || bp + 1 != ep) {
    out->append(bp, static_cast<size_t>(ep - bp));
    out->append(unit.abbr.data(), unit.abbr.size());
  }
}

// Note: unit.prec is limited to double's digits10 value (typically 15) so it
// always fits in buf[].
void AppendNumberUnit(std::string* out, double n, DisplayUnit unit) {
  constexpr int kBufferSize = std::numeric_limits<double>::digits10;
  const int prec = std::min(kBufferSize, unit.prec);
  char buf[kBufferSize];  // also large enough to hold integer part
  char* ep = buf + sizeof(buf);
  double d = 0;
  int64_t frac_part = std::round(std::modf(n, &d) * unit.pow10);
  int64_t int_part = d;
  if (int_part != 0 || frac_part != 0) {
    char* bp = Format64(ep, 0, int_part);  // always < 1000
    out->append(bp, static_cast<size_t>(ep - bp));
    if (frac_part != 0) {
      out->push_back('.');
      bp = Format64(ep, prec, frac_part);
      while (ep[-1] == '0') --ep;
      out->append(bp, static_cast<size_t>(ep - bp));
    }
    out->append(unit.abbr.data(), unit.abbr.size());
  }
}

}  // namespace

// From Go's doc at https://golang.org/pkg/time/#Duration.String
//   [FormatDuration] returns a string representing the duration in the
//   form "72h3m0.5s". Leading zero units are omitted.  As a special
//   case, durations less than one second format use a smaller unit
//   (milli-, micro-, or nanoseconds) to ensure that the leading digit
//   is non-zero.
// Unlike Go, we format the zero duration as 0, with no unit.
std::string FormatDuration(Duration d) {
  constexpr Duration kMinDuration = Seconds(kint64min);
  std::string s;
  if (d == kMinDuration) {
    // Avoid needing to negate kint64min by directly returning what the
    // following code should produce in that case.
    s = "-2562047788015215h30m8s";
    return s;
  }
  if (d < ZeroDuration()) {
    s.append("-");
    d = -d;
  }
  if (d == InfiniteDuration()) {
    s.append("inf");
  } else if (d < Seconds(1)) {
    // Special case for durations with a magnitude < 1 second.  The duration
    // is printed as a fraction of a single unit, e.g., "1.2ms".
    if (d < Microseconds(1)) {
      AppendNumberUnit(&s, FDivDuration(d, Nanoseconds(1)), kDisplayNano);
    } else if (d < Milliseconds(1)) {
      AppendNumberUnit(&s, FDivDuration(d, Microseconds(1)), kDisplayMicro);
    } else {
      AppendNumberUnit(&s, FDivDuration(d, Milliseconds(1)), kDisplayMilli);
    }
  } else {
    AppendNumberUnit(&s, IDivDuration(d, Hours(1), &d), kDisplayHour);
    AppendNumberUnit(&s, IDivDuration(d, Minutes(1), &d), kDisplayMin);
    AppendNumberUnit(&s, FDivDuration(d, Seconds(1)), kDisplaySec);
  }
  if (s.empty() || s == "-") {
    s = "0";
  }
  return s;
}

namespace {

// A helper for ParseDuration() that parses a leading number from the given
// string and stores the result in *int_part/*frac_part/*frac_scale.  The
// given string pointer is modified to point to the first unconsumed char.
bool ConsumeDurationNumber(const char** dpp, const char* ep, int64_t* int_part,
                           int64_t* frac_part, int64_t* frac_scale) {
  *int_part = 0;
  *frac_part = 0;
  *frac_scale = 1;  // invariant: *frac_part < *frac_scale
  const char* start = *dpp;
  for (; *dpp != ep; *dpp += 1) {
    const int d = **dpp - '0';  // contiguous digits
    if (d < 0 || 10 <= d) break;

    if (*int_part > kint64max / 10) return false;
    *int_part *= 10;
    if (*int_part > kint64max - d) return false;
    *int_part += d;
  }
  const bool int_part_empty = (*dpp == start);
  if (*dpp == ep || **dpp != '.') return !int_part_empty;

  for (*dpp += 1; *dpp != ep; *dpp += 1) {
    const int d = **dpp - '0';  // contiguous digits
    if (d < 0 || 10 <= d) break;
    if (*frac_scale <= kint64max / 10) {
      *frac_part *= 10;
      *frac_part += d;
      *frac_scale *= 10;
    }
  }
  return !int_part_empty || *frac_scale != 1;
}

// A helper for ParseDuration() that parses a leading unit designator (e.g.,
// ns, us, ms, s, m, h) from the given string and stores the resulting unit
// in "*unit".  The given string pointer is modified to point to the first
// unconsumed char.
bool ConsumeDurationUnit(const char** start, const char* end, Duration* unit) {
  size_t size = static_cast<size_t>(end - *start);
  switch (size) {
    case 0:
      return false;
    default:
      switch (**start) {
        case 'n':
          if (*(*start + 1) == 's') {
            *start += 2;
            *unit = Nanoseconds(1);
            return true;
          }
          break;
        case 'u':
          if (*(*start + 1) == 's') {
            *start += 2;
            *unit = Microseconds(1);
            return true;
          }
          break;
        case 'm':
          if (*(*start + 1) == 's') {
            *start += 2;
            *unit = Milliseconds(1);
            return true;
          }
          break;
        default:
          break;
      }
      ABSL_FALLTHROUGH_INTENDED;
    case 1:
      switch (**start) {
        case 's':
          *unit = Seconds(1);
          *start += 1;
          return true;
        case 'm':
          *unit = Minutes(1);
          *start += 1;
          return true;
        case 'h':
          *unit = Hours(1);
          *start += 1;
          return true;
        default:
          return false;
      }
  }
}

}  // namespace

// From Go's doc at https://golang.org/pkg/time/#ParseDuration
//   [ParseDuration] parses a duration string. A duration string is
//   a possibly signed sequence of decimal numbers, each with optional
//   fraction and a unit suffix, such as "300ms", "-1.5h" or "2h45m".
//   Valid time units are "ns", "us" "ms", "s", "m", "h".
bool ParseDuration(absl::string_view dur_sv, Duration* d) {
  int sign = 1;
  if (absl::ConsumePrefix(&dur_sv, "-")) {
    sign = -1;
  } else {
    absl::ConsumePrefix(&dur_sv, "+");
  }
  if (dur_sv.empty()) return false;

  // Special case for a string of "0".
  if (dur_sv == "0") {
    *d = ZeroDuration();
    return true;
  }

  if (dur_sv == "inf") {
    *d = sign * InfiniteDuration();
    return true;
  }

  const char* start = dur_sv.data();
  const char* end = start + dur_sv.size();

  Duration dur;
  while (start != end) {
    int64_t int_part;
    int64_t frac_part;
    int64_t frac_scale;
    Duration unit;
    if (!ConsumeDurationNumber(&start, end, &int_part, &frac_part,
                               &frac_scale) ||
        !ConsumeDurationUnit(&start, end, &unit)) {
      return false;
    }
    if (int_part != 0) dur += sign * int_part * unit;
    if (frac_part != 0) dur += sign * frac_part * unit / frac_scale;
  }
  *d = dur;
  return true;
}

bool AbslParseFlag(absl::string_view text, Duration* dst, std::string*) {
  return ParseDuration(text, dst);
}

std::string AbslUnparseFlag(Duration d) { return FormatDuration(d); }
bool ParseFlag(const std::string& text, Duration* dst, std::string* ) {
  return ParseDuration(text, dst);
}

std::string UnparseFlag(Duration d) { return FormatDuration(d); }

ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                  node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/duration_benchmark.cc                          0000664 0000000 0000000 00000030757 14746647661 0026456 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 The Abseil Authors.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <cmath>
#include <cstddef>
#include <cstdint>
#include <ctime>
#include <string>

#include "absl/base/attributes.h"
#include "absl/flags/flag.h"
#include "absl/time/time.h"
#include "benchmark/benchmark.h"

ABSL_FLAG(absl::Duration, absl_duration_flag_for_benchmark,
          absl::Milliseconds(1),
          "Flag to use for benchmarking duration flag access speed.");

namespace {

//
// Factory functions
//

void BM_Duration_Factory_Nanoseconds(benchmark::State& state) {
  int64_t i = 0;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::Nanoseconds(i));
    i += 314159;
  }
}
BENCHMARK(BM_Duration_Factory_Nanoseconds);

void BM_Duration_Factory_Microseconds(benchmark::State& state) {
  int64_t i = 0;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::Microseconds(i));
    i += 314;
  }
}
BENCHMARK(BM_Duration_Factory_Microseconds);

void BM_Duration_Factory_Milliseconds(benchmark::State& state) {
  int64_t i = 0;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::Milliseconds(i));
    i += 1;
  }
}
BENCHMARK(BM_Duration_Factory_Milliseconds);

void BM_Duration_Factory_Seconds(benchmark::State& state) {
  int64_t i = 0;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::Seconds(i));
    i += 1;
  }
}
BENCHMARK(BM_Duration_Factory_Seconds);

void BM_Duration_Factory_Minutes(benchmark::State& state) {
  int64_t i = 0;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::Minutes(i));
    i += 1;
  }
}
BENCHMARK(BM_Duration_Factory_Minutes);

void BM_Duration_Factory_Hours(benchmark::State& state) {
  int64_t i = 0;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::Hours(i));
    i += 1;
  }
}
BENCHMARK(BM_Duration_Factory_Hours);

void BM_Duration_Factory_DoubleNanoseconds(benchmark::State& state) {
  double d = 1;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::Nanoseconds(d));
    d = d * 1.00000001 + 1;
  }
}
BENCHMARK(BM_Duration_Factory_DoubleNanoseconds);

void BM_Duration_Factory_DoubleMicroseconds(benchmark::State& state) {
  double d = 1e-3;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::Microseconds(d));
    d = d * 1.00000001 + 1e-3;
  }
}
BENCHMARK(BM_Duration_Factory_DoubleMicroseconds);

void BM_Duration_Factory_DoubleMilliseconds(benchmark::State& state) {
  double d = 1e-6;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::Milliseconds(d));
    d = d * 1.00000001 + 1e-6;
  }
}
BENCHMARK(BM_Duration_Factory_DoubleMilliseconds);

void BM_Duration_Factory_DoubleSeconds(benchmark::State& state) {
  double d = 1e-9;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::Seconds(d));
    d = d * 1.00000001 + 1e-9;
  }
}
BENCHMARK(BM_Duration_Factory_DoubleSeconds);

void BM_Duration_Factory_DoubleMinutes(benchmark::State& state) {
  double d = 1e-9;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::Minutes(d));
    d = d * 1.00000001 + 1e-9;
  }
}
BENCHMARK(BM_Duration_Factory_DoubleMinutes);

void BM_Duration_Factory_DoubleHours(benchmark::State& state) {
  double d = 1e-9;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::Hours(d));
    d = d * 1.00000001 + 1e-9;
  }
}
BENCHMARK(BM_Duration_Factory_DoubleHours);

//
// Arithmetic
//

void BM_Duration_Addition(benchmark::State& state) {
  absl::Duration d = absl::Nanoseconds(1);
  absl::Duration step = absl::Milliseconds(1);
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(d += step);
  }
}
BENCHMARK(BM_Duration_Addition);

void BM_Duration_Subtraction(benchmark::State& state) {
  absl::Duration d = absl::Seconds(std::numeric_limits<int64_t>::max());
  absl::Duration step = absl::Milliseconds(1);
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(d -= step);
  }
}
BENCHMARK(BM_Duration_Subtraction);

void BM_Duration_Multiplication_Fixed(benchmark::State& state) {
  absl::Duration d = absl::Milliseconds(1);
  absl::Duration s;
  int i = 0;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(s += d * (i + 1));
    ++i;
  }
}
BENCHMARK(BM_Duration_Multiplication_Fixed);

void BM_Duration_Multiplication_Double(benchmark::State& state) {
  absl::Duration d = absl::Milliseconds(1);
  absl::Duration s;
  int i = 0;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(s += d * (i + 1.0));
    ++i;
  }
}
BENCHMARK(BM_Duration_Multiplication_Double);

void BM_Duration_Division_Fixed(benchmark::State& state) {
  absl::Duration d = absl::Seconds(1);
  int i = 0;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(d /= i + 1);
    ++i;
  }
}
BENCHMARK(BM_Duration_Division_Fixed);

void BM_Duration_Division_Double(benchmark::State& state) {
  absl::Duration d = absl::Seconds(1);
  int i = 0;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(d /= i + 1.0);
    ++i;
  }
}
BENCHMARK(BM_Duration_Division_Double);

void BM_Duration_FDivDuration_Nanoseconds(benchmark::State& state) {
  double d = 1;
  int i = 0;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(
        d += absl::FDivDuration(absl::Milliseconds(i), absl::Nanoseconds(1)));
    ++i;
  }
}
BENCHMARK(BM_Duration_FDivDuration_Nanoseconds);

void BM_Duration_IDivDuration_Nanoseconds(benchmark::State& state) {
  int64_t a = 1;
  absl::Duration ignore;
  int i = 0;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(a +=
                             absl::IDivDuration(absl::Nanoseconds(i),
                                                absl::Nanoseconds(1), &ignore));
    ++i;
  }
}
BENCHMARK(BM_Duration_IDivDuration_Nanoseconds);

void BM_Duration_IDivDuration_Microseconds(benchmark::State& state) {
  int64_t a = 1;
  absl::Duration ignore;
  int i = 0;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(a += absl::IDivDuration(absl::Microseconds(i),
                                                     absl::Microseconds(1),
                                                     &ignore));
    ++i;
  }
}
BENCHMARK(BM_Duration_IDivDuration_Microseconds);

void BM_Duration_IDivDuration_Milliseconds(benchmark::State& state) {
  int64_t a = 1;
  absl::Duration ignore;
  int i = 0;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(a += absl::IDivDuration(absl::Milliseconds(i),
                                                     absl::Milliseconds(1),
                                                     &ignore));
    ++i;
  }
}
BENCHMARK(BM_Duration_IDivDuration_Milliseconds);

void BM_Duration_IDivDuration_Seconds(benchmark::State& state) {
  int64_t a = 1;
  absl::Duration ignore;
  int i = 0;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(
        a += absl::IDivDuration(absl::Seconds(i), absl::Seconds(1), &ignore));
    ++i;
  }
}
BENCHMARK(BM_Duration_IDivDuration_Seconds);

void BM_Duration_IDivDuration_Minutes(benchmark::State& state) {
  int64_t a = 1;
  absl::Duration ignore;
  int i = 0;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(
        a += absl::IDivDuration(absl::Minutes(i), absl::Minutes(1), &ignore));
    ++i;
  }
}
BENCHMARK(BM_Duration_IDivDuration_Minutes);

void BM_Duration_IDivDuration_Hours(benchmark::State& state) {
  int64_t a = 1;
  absl::Duration ignore;
  int i = 0;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(
        a += absl::IDivDuration(absl::Hours(i), absl::Hours(1), &ignore));
    ++i;
  }
}
BENCHMARK(BM_Duration_IDivDuration_Hours);

void BM_Duration_Modulo(benchmark::State& state) {
  int i = 0;
  while (state.KeepRunning()) {
    auto mod = absl::Seconds(i) % absl::Nanoseconds(12345);
    benchmark::DoNotOptimize(mod);
    ++i;
  }
}
BENCHMARK(BM_Duration_Modulo);

void BM_Duration_Modulo_FastPath(benchmark::State& state) {
  int i = 0;
  while (state.KeepRunning()) {
    auto mod = absl::Seconds(i) % absl::Milliseconds(1);
    benchmark::DoNotOptimize(mod);
    ++i;
  }
}
BENCHMARK(BM_Duration_Modulo_FastPath);

void BM_Duration_ToInt64Nanoseconds(benchmark::State& state) {
  absl::Duration d = absl::Seconds(100000);
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::ToInt64Nanoseconds(d));
  }
}
BENCHMARK(BM_Duration_ToInt64Nanoseconds);

void BM_Duration_ToInt64Microseconds(benchmark::State& state) {
  absl::Duration d = absl::Seconds(100000);
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::ToInt64Microseconds(d));
  }
}
BENCHMARK(BM_Duration_ToInt64Microseconds);

void BM_Duration_ToInt64Milliseconds(benchmark::State& state) {
  absl::Duration d = absl::Seconds(100000);
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::ToInt64Milliseconds(d));
  }
}
BENCHMARK(BM_Duration_ToInt64Milliseconds);

void BM_Duration_ToInt64Seconds(benchmark::State& state) {
  absl::Duration d = absl::Seconds(100000);
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::ToInt64Seconds(d));
  }
}
BENCHMARK(BM_Duration_ToInt64Seconds);

void BM_Duration_ToInt64Minutes(benchmark::State& state) {
  absl::Duration d = absl::Seconds(100000);
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::ToInt64Minutes(d));
  }
}
BENCHMARK(BM_Duration_ToInt64Minutes);

void BM_Duration_ToInt64Hours(benchmark::State& state) {
  absl::Duration d = absl::Seconds(100000);
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::ToInt64Hours(d));
  }
}
BENCHMARK(BM_Duration_ToInt64Hours);

//
// To/FromTimespec
//

void BM_Duration_ToTimespec_AbslTime(benchmark::State& state) {
  absl::Duration d = absl::Seconds(1);
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::ToTimespec(d));
  }
}
BENCHMARK(BM_Duration_ToTimespec_AbslTime);

ABSL_ATTRIBUTE_NOINLINE timespec DoubleToTimespec(double seconds) {
  timespec ts;
  ts.tv_sec = seconds;
  ts.tv_nsec = (seconds - ts.tv_sec) * (1000 * 1000 * 1000);
  return ts;
}

void BM_Duration_ToTimespec_Double(benchmark::State& state) {
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(DoubleToTimespec(1.0));
  }
}
BENCHMARK(BM_Duration_ToTimespec_Double);

void BM_Duration_FromTimespec_AbslTime(benchmark::State& state) {
  timespec ts;
  ts.tv_sec = 0;
  ts.tv_nsec = 0;
  while (state.KeepRunning()) {
    if (++ts.tv_nsec == 1000 * 1000 * 1000) {
      ++ts.tv_sec;
      ts.tv_nsec = 0;
    }
    benchmark::DoNotOptimize(absl::DurationFromTimespec(ts));
  }
}
BENCHMARK(BM_Duration_FromTimespec_AbslTime);

ABSL_ATTRIBUTE_NOINLINE double TimespecToDouble(timespec ts) {
  return ts.tv_sec + (ts.tv_nsec / (1000 * 1000 * 1000));
}

void BM_Duration_FromTimespec_Double(benchmark::State& state) {
  timespec ts;
  ts.tv_sec = 0;
  ts.tv_nsec = 0;
  while (state.KeepRunning()) {
    if (++ts.tv_nsec == 1000 * 1000 * 1000) {
      ++ts.tv_sec;
      ts.tv_nsec = 0;
    }
    benchmark::DoNotOptimize(TimespecToDouble(ts));
  }
}
BENCHMARK(BM_Duration_FromTimespec_Double);

//
// String conversions
//

const char* const kDurations[] = {
    "0",                                   // 0
    "123ns",                               // 1
    "1h2m3s",                              // 2
    "-2h3m4.005006007s",                   // 3
    "2562047788015215h30m7.99999999975s",  // 4
};
const int kNumDurations = sizeof(kDurations) / sizeof(kDurations[0]);

void BM_Duration_FormatDuration(benchmark::State& state) {
  const std::string s = kDurations[state.range(0)];
  state.SetLabel(s);
  absl::Duration d;
  absl::ParseDuration(kDurations[state.range(0)], &d);
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::FormatDuration(d));
  }
}
BENCHMARK(BM_Duration_FormatDuration)->DenseRange(0, kNumDurations - 1);

void BM_Duration_ParseDuration(benchmark::State& state) {
  const std::string s = kDurations[state.range(0)];
  state.SetLabel(s);
  absl::Duration d;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::ParseDuration(s, &d));
  }
}
BENCHMARK(BM_Duration_ParseDuration)->DenseRange(0, kNumDurations - 1);

//
// Flag access
//
void BM_Duration_GetFlag(benchmark::State& state) {
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(
        absl::GetFlag(FLAGS_absl_duration_flag_for_benchmark));
  }
}
BENCHMARK(BM_Duration_GetFlag);

}  // namespace
                 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/duration_test.cc                               0000664 0000000 0000000 00000230222 14746647661 0025470 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#if defined(_MSC_VER)
#include <winsock2.h>  // for timeval
#endif

#include <array>
#include <cfloat>
#include <chrono>  // NOLINT(build/c++11)

#ifdef __cpp_impl_three_way_comparison
#include <compare>
#endif  // __cpp_impl_three_way_comparison

#include <cmath>
#include <cstdint>
#include <ctime>
#include <iomanip>
#include <limits>
#include <random>
#include <string>

#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "absl/strings/str_format.h"
#include "absl/time/time.h"

namespace {

constexpr int64_t kint64max = std::numeric_limits<int64_t>::max();
constexpr int64_t kint64min = std::numeric_limits<int64_t>::min();

// Approximates the given number of years. This is only used to make some test
// code more readable.
absl::Duration ApproxYears(int64_t n) { return absl::Hours(n) * 365 * 24; }

// A gMock matcher to match timespec values. Use this matcher like:
// timespec ts1, ts2;
// EXPECT_THAT(ts1, TimespecMatcher(ts2));
MATCHER_P(TimespecMatcher, ts, "") {
  if (ts.tv_sec == arg.tv_sec && ts.tv_nsec == arg.tv_nsec)
    return true;
  *result_listener << "expected: {" << ts.tv_sec << ", " << ts.tv_nsec << "} ";
  *result_listener << "actual: {" << arg.tv_sec << ", " << arg.tv_nsec << "}";
  return false;
}

// A gMock matcher to match timeval values. Use this matcher like:
// timeval tv1, tv2;
// EXPECT_THAT(tv1, TimevalMatcher(tv2));
MATCHER_P(TimevalMatcher, tv, "") {
  if (tv.tv_sec == arg.tv_sec && tv.tv_usec == arg.tv_usec)
    return true;
  *result_listener << "expected: {" << tv.tv_sec << ", " << tv.tv_usec << "} ";
  *result_listener << "actual: {" << arg.tv_sec << ", " << arg.tv_usec << "}";
  return false;
}

TEST(Duration, ConstExpr) {
  constexpr absl::Duration d0 = absl::ZeroDuration();
  static_assert(d0 == absl::ZeroDuration(), "ZeroDuration()");
  constexpr absl::Duration d1 = absl::Seconds(1);
  static_assert(d1 == absl::Seconds(1), "Seconds(1)");
  static_assert(d1 != absl::ZeroDuration(), "Seconds(1)");
  constexpr absl::Duration d2 = absl::InfiniteDuration();
  static_assert(d2 == absl::InfiniteDuration(), "InfiniteDuration()");
  static_assert(d2 != absl::ZeroDuration(), "InfiniteDuration()");
}

TEST(Duration, ValueSemantics) {
  // If this compiles, the test passes.
  constexpr absl::Duration a;      // Default construction
  constexpr absl::Duration b = a;  // Copy construction
  constexpr absl::Duration c(b);   // Copy construction (again)

  absl::Duration d;
  d = c;  // Assignment
}

TEST(Duration, Factories) {
  constexpr absl::Duration zero = absl::ZeroDuration();
  constexpr absl::Duration nano = absl::Nanoseconds(1);
  constexpr absl::Duration micro = absl::Microseconds(1);
  constexpr absl::Duration milli = absl::Milliseconds(1);
  constexpr absl::Duration sec = absl::Seconds(1);
  constexpr absl::Duration min = absl::Minutes(1);
  constexpr absl::Duration hour = absl::Hours(1);

  EXPECT_EQ(zero, absl::Duration());
  EXPECT_EQ(zero, absl::Seconds(0));
  EXPECT_EQ(nano, absl::Nanoseconds(1));
  EXPECT_EQ(micro, absl::Nanoseconds(1000));
  EXPECT_EQ(milli, absl::Microseconds(1000));
  EXPECT_EQ(sec, absl::Milliseconds(1000));
  EXPECT_EQ(min, absl::Seconds(60));
  EXPECT_EQ(hour, absl::Minutes(60));

  // Tests factory limits
  const absl::Duration inf = absl::InfiniteDuration();

  EXPECT_GT(inf, absl::Seconds(kint64max));
  EXPECT_LT(-inf, absl::Seconds(kint64min));
  EXPECT_LT(-inf, absl::Seconds(-kint64max));

  EXPECT_EQ(inf, absl::Minutes(kint64max));
  EXPECT_EQ(-inf, absl::Minutes(kint64min));
  EXPECT_EQ(-inf, absl::Minutes(-kint64max));
  EXPECT_GT(inf, absl::Minutes(kint64max / 60));
  EXPECT_LT(-inf, absl::Minutes(kint64min / 60));
  EXPECT_LT(-inf, absl::Minutes(-kint64max / 60));

  EXPECT_EQ(inf, absl::Hours(kint64max));
  EXPECT_EQ(-inf, absl::Hours(kint64min));
  EXPECT_EQ(-inf, absl::Hours(-kint64max));
  EXPECT_GT(inf, absl::Hours(kint64max / 3600));
  EXPECT_LT(-inf, absl::Hours(kint64min / 3600));
  EXPECT_LT(-inf, absl::Hours(-kint64max / 3600));
}

TEST(Duration, ToConversion) {
#define TEST_DURATION_CONVERSION(UNIT)                                  \
  do {                                                                  \
    const absl::Duration d = absl::UNIT(1.5);                           \
    constexpr absl::Duration z = absl::ZeroDuration();                  \
    constexpr absl::Duration inf = absl::InfiniteDuration();            \
    constexpr double dbl_inf = std::numeric_limits<double>::infinity(); \
    EXPECT_EQ(kint64min, absl::ToInt64##UNIT(-inf));                    \
    EXPECT_EQ(-1, absl::ToInt64##UNIT(-d));                             \
    EXPECT_EQ(0, absl::ToInt64##UNIT(z));                               \
    EXPECT_EQ(1, absl::ToInt64##UNIT(d));                               \
    EXPECT_EQ(kint64max, absl::ToInt64##UNIT(inf));                     \
    EXPECT_EQ(-dbl_inf, absl::ToDouble##UNIT(-inf));                    \
    EXPECT_EQ(-1.5, absl::ToDouble##UNIT(-d));                          \
    EXPECT_EQ(0, absl::ToDouble##UNIT(z));                              \
    EXPECT_EQ(1.5, absl::ToDouble##UNIT(d));                            \
    EXPECT_EQ(dbl_inf, absl::ToDouble##UNIT(inf));                      \
  } while (0)

  TEST_DURATION_CONVERSION(Nanoseconds);
  TEST_DURATION_CONVERSION(Microseconds);
  TEST_DURATION_CONVERSION(Milliseconds);
  TEST_DURATION_CONVERSION(Seconds);
  TEST_DURATION_CONVERSION(Minutes);
  TEST_DURATION_CONVERSION(Hours);

#undef TEST_DURATION_CONVERSION
}

template <int64_t N>
void TestToConversion() {
  constexpr absl::Duration nano = absl::Nanoseconds(N);
  EXPECT_EQ(N, absl::ToInt64Nanoseconds(nano));
  EXPECT_EQ(0, absl::ToInt64Microseconds(nano));
  EXPECT_EQ(0, absl::ToInt64Milliseconds(nano));
  EXPECT_EQ(0, absl::ToInt64Seconds(nano));
  EXPECT_EQ(0, absl::ToInt64Minutes(nano));
  EXPECT_EQ(0, absl::ToInt64Hours(nano));
  const absl::Duration micro = absl::Microseconds(N);
  EXPECT_EQ(N * 1000, absl::ToInt64Nanoseconds(micro));
  EXPECT_EQ(N, absl::ToInt64Microseconds(micro));
  EXPECT_EQ(0, absl::ToInt64Milliseconds(micro));
  EXPECT_EQ(0, absl::ToInt64Seconds(micro));
  EXPECT_EQ(0, absl::ToInt64Minutes(micro));
  EXPECT_EQ(0, absl::ToInt64Hours(micro));
  const absl::Duration milli = absl::Milliseconds(N);
  EXPECT_EQ(N * 1000 * 1000, absl::ToInt64Nanoseconds(milli));
  EXPECT_EQ(N * 1000, absl::ToInt64Microseconds(milli));
  EXPECT_EQ(N, absl::ToInt64Milliseconds(milli));
  EXPECT_EQ(0, absl::ToInt64Seconds(milli));
  EXPECT_EQ(0, absl::ToInt64Minutes(milli));
  EXPECT_EQ(0, absl::ToInt64Hours(milli));
  const absl::Duration sec = absl::Seconds(N);
  EXPECT_EQ(N * 1000 * 1000 * 1000, absl::ToInt64Nanoseconds(sec));
  EXPECT_EQ(N * 1000 * 1000, absl::ToInt64Microseconds(sec));
  EXPECT_EQ(N * 1000, absl::ToInt64Milliseconds(sec));
  EXPECT_EQ(N, absl::ToInt64Seconds(sec));
  EXPECT_EQ(0, absl::ToInt64Minutes(sec));
  EXPECT_EQ(0, absl::ToInt64Hours(sec));
  const absl::Duration min = absl::Minutes(N);
  EXPECT_EQ(N * 60 * 1000 * 1000 * 1000, absl::ToInt64Nanoseconds(min));
  EXPECT_EQ(N * 60 * 1000 * 1000, absl::ToInt64Microseconds(min));
  EXPECT_EQ(N * 60 * 1000, absl::ToInt64Milliseconds(min));
  EXPECT_EQ(N * 60, absl::ToInt64Seconds(min));
  EXPECT_EQ(N, absl::ToInt64Minutes(min));
  EXPECT_EQ(0, absl::ToInt64Hours(min));
  const absl::Duration hour = absl::Hours(N);
  EXPECT_EQ(N * 60 * 60 * 1000 * 1000 * 1000, absl::ToInt64Nanoseconds(hour));
  EXPECT_EQ(N * 60 * 60 * 1000 * 1000, absl::ToInt64Microseconds(hour));
  EXPECT_EQ(N * 60 * 60 * 1000, absl::ToInt64Milliseconds(hour));
  EXPECT_EQ(N * 60 * 60, absl::ToInt64Seconds(hour));
  EXPECT_EQ(N * 60, absl::ToInt64Minutes(hour));
  EXPECT_EQ(N, absl::ToInt64Hours(hour));
}

TEST(Duration, ToConversionDeprecated) {
  TestToConversion<43>();
  TestToConversion<1>();
  TestToConversion<0>();
  TestToConversion<-1>();
  TestToConversion<-43>();
}

template <int64_t N>
void TestFromChronoBasicEquality() {
  using std::chrono::nanoseconds;
  using std::chrono::microseconds;
  using std::chrono::milliseconds;
  using std::chrono::seconds;
  using std::chrono::minutes;
  using std::chrono::hours;

  static_assert(absl::Nanoseconds(N) == absl::FromChrono(nanoseconds(N)), "");
  static_assert(absl::Microseconds(N) == absl::FromChrono(microseconds(N)), "");
  static_assert(absl::Milliseconds(N) == absl::FromChrono(milliseconds(N)), "");
  static_assert(absl::Seconds(N) == absl::FromChrono(seconds(N)), "");
  static_assert(absl::Minutes(N) == absl::FromChrono(minutes(N)), "");
  static_assert(absl::Hours(N) == absl::FromChrono(hours(N)), "");
}

TEST(Duration, FromChrono) {
  TestFromChronoBasicEquality<-123>();
  TestFromChronoBasicEquality<-1>();
  TestFromChronoBasicEquality<0>();
  TestFromChronoBasicEquality<1>();
  TestFromChronoBasicEquality<123>();

  // Minutes (might, depending on the platform) saturate at +inf.
  const auto chrono_minutes_max = std::chrono::minutes::max();
  const auto minutes_max = absl::FromChrono(chrono_minutes_max);
  const int64_t minutes_max_count = chrono_minutes_max.count();
  if (minutes_max_count > kint64max / 60) {
    EXPECT_EQ(absl::InfiniteDuration(), minutes_max);
  } else {
    EXPECT_EQ(absl::Minutes(minutes_max_count), minutes_max);
  }

  // Minutes (might, depending on the platform) saturate at -inf.
  const auto chrono_minutes_min = std::chrono::minutes::min();
  const auto minutes_min = absl::FromChrono(chrono_minutes_min);
  const int64_t minutes_min_count = chrono_minutes_min.count();
  if (minutes_min_count < kint64min / 60) {
    EXPECT_EQ(-absl::InfiniteDuration(), minutes_min);
  } else {
    EXPECT_EQ(absl::Minutes(minutes_min_count), minutes_min);
  }

  // Hours (might, depending on the platform) saturate at +inf.
  const auto chrono_hours_max = std::chrono::hours::max();
  const auto hours_max = absl::FromChrono(chrono_hours_max);
  const int64_t hours_max_count = chrono_hours_max.count();
  if (hours_max_count > kint64max / 3600) {
    EXPECT_EQ(absl::InfiniteDuration(), hours_max);
  } else {
    EXPECT_EQ(absl::Hours(hours_max_count), hours_max);
  }

  // Hours (might, depending on the platform) saturate at -inf.
  const auto chrono_hours_min = std::chrono::hours::min();
  const auto hours_min = absl::FromChrono(chrono_hours_min);
  const int64_t hours_min_count = chrono_hours_min.count();
  if (hours_min_count < kint64min / 3600) {
    EXPECT_EQ(-absl::InfiniteDuration(), hours_min);
  } else {
    EXPECT_EQ(absl::Hours(hours_min_count), hours_min);
  }
}

template <int64_t N>
void TestToChrono() {
  using std::chrono::nanoseconds;
  using std::chrono::microseconds;
  using std::chrono::milliseconds;
  using std::chrono::seconds;
  using std::chrono::minutes;
  using std::chrono::hours;

  EXPECT_EQ(nanoseconds(N), absl::ToChronoNanoseconds(absl::Nanoseconds(N)));
  EXPECT_EQ(microseconds(N), absl::ToChronoMicroseconds(absl::Microseconds(N)));
  EXPECT_EQ(milliseconds(N), absl::ToChronoMilliseconds(absl::Milliseconds(N)));
  EXPECT_EQ(seconds(N), absl::ToChronoSeconds(absl::Seconds(N)));

  constexpr auto absl_minutes = absl::Minutes(N);
  auto chrono_minutes = minutes(N);
  if (absl_minutes == -absl::InfiniteDuration()) {
    chrono_minutes = minutes::min();
  } else if (absl_minutes == absl::InfiniteDuration()) {
    chrono_minutes = minutes::max();
  }
  EXPECT_EQ(chrono_minutes, absl::ToChronoMinutes(absl_minutes));

  constexpr auto absl_hours = absl::Hours(N);
  auto chrono_hours = hours(N);
  if (absl_hours == -absl::InfiniteDuration()) {
    chrono_hours = hours::min();
  } else if (absl_hours == absl::InfiniteDuration()) {
    chrono_hours = hours::max();
  }
  EXPECT_EQ(chrono_hours, absl::ToChronoHours(absl_hours));
}

TEST(Duration, ToChrono) {
  using std::chrono::nanoseconds;
  using std::chrono::microseconds;
  using std::chrono::milliseconds;
  using std::chrono::seconds;
  using std::chrono::minutes;
  using std::chrono::hours;

  TestToChrono<kint64min>();
  TestToChrono<-1>();
  TestToChrono<0>();
  TestToChrono<1>();
  TestToChrono<kint64max>();

  // Verify truncation toward zero.
  const auto tick = absl::Nanoseconds(1) / 4;
  EXPECT_EQ(nanoseconds(0), absl::ToChronoNanoseconds(tick));
  EXPECT_EQ(nanoseconds(0), absl::ToChronoNanoseconds(-tick));
  EXPECT_EQ(microseconds(0), absl::ToChronoMicroseconds(tick));
  EXPECT_EQ(microseconds(0), absl::ToChronoMicroseconds(-tick));
  EXPECT_EQ(milliseconds(0), absl::ToChronoMilliseconds(tick));
  EXPECT_EQ(milliseconds(0), absl::ToChronoMilliseconds(-tick));
  EXPECT_EQ(seconds(0), absl::ToChronoSeconds(tick));
  EXPECT_EQ(seconds(0), absl::ToChronoSeconds(-tick));
  EXPECT_EQ(minutes(0), absl::ToChronoMinutes(tick));
  EXPECT_EQ(minutes(0), absl::ToChronoMinutes(-tick));
  EXPECT_EQ(hours(0), absl::ToChronoHours(tick));
  EXPECT_EQ(hours(0), absl::ToChronoHours(-tick));

  // Verifies +/- infinity saturation at max/min.
  constexpr auto inf = absl::InfiniteDuration();
  EXPECT_EQ(nanoseconds::min(), absl::ToChronoNanoseconds(-inf));
  EXPECT_EQ(nanoseconds::max(), absl::ToChronoNanoseconds(inf));
  EXPECT_EQ(microseconds::min(), absl::ToChronoMicroseconds(-inf));
  EXPECT_EQ(microseconds::max(), absl::ToChronoMicroseconds(inf));
  EXPECT_EQ(milliseconds::min(), absl::ToChronoMilliseconds(-inf));
  EXPECT_EQ(milliseconds::max(), absl::ToChronoMilliseconds(inf));
  EXPECT_EQ(seconds::min(), absl::ToChronoSeconds(-inf));
  EXPECT_EQ(seconds::max(), absl::ToChronoSeconds(inf));
  EXPECT_EQ(minutes::min(), absl::ToChronoMinutes(-inf));
  EXPECT_EQ(minutes::max(), absl::ToChronoMinutes(inf));
  EXPECT_EQ(hours::min(), absl::ToChronoHours(-inf));
  EXPECT_EQ(hours::max(), absl::ToChronoHours(inf));
}

TEST(Duration, FactoryOverloads) {
  enum E { kOne = 1 };
#define TEST_FACTORY_OVERLOADS(NAME)                                          \
  EXPECT_EQ(1, NAME(kOne) / NAME(kOne));                                      \
  EXPECT_EQ(1, NAME(static_cast<int8_t>(1)) / NAME(1));                       \
  EXPECT_EQ(1, NAME(static_cast<int16_t>(1)) / NAME(1));                      \
  EXPECT_EQ(1, NAME(static_cast<int32_t>(1)) / NAME(1));                      \
  EXPECT_EQ(1, NAME(static_cast<int64_t>(1)) / NAME(1));                      \
  EXPECT_EQ(1, NAME(static_cast<uint8_t>(1)) / NAME(1));                      \
  EXPECT_EQ(1, NAME(static_cast<uint16_t>(1)) / NAME(1));                     \
  EXPECT_EQ(1, NAME(static_cast<uint32_t>(1)) / NAME(1));                     \
  EXPECT_EQ(1, NAME(static_cast<uint64_t>(1)) / NAME(1));                     \
  EXPECT_EQ(NAME(1) / 2, NAME(static_cast<float>(0.5)));                      \
  EXPECT_EQ(NAME(1) / 2, NAME(static_cast<double>(0.5)));                     \
  EXPECT_EQ(1.5, absl::FDivDuration(NAME(static_cast<float>(1.5)), NAME(1))); \
  EXPECT_EQ(1.5, absl::FDivDuration(NAME(static_cast<double>(1.5)), NAME(1)));

  TEST_FACTORY_OVERLOADS(absl::Nanoseconds);
  TEST_FACTORY_OVERLOADS(absl::Microseconds);
  TEST_FACTORY_OVERLOADS(absl::Milliseconds);
  TEST_FACTORY_OVERLOADS(absl::Seconds);
  TEST_FACTORY_OVERLOADS(absl::Minutes);
  TEST_FACTORY_OVERLOADS(absl::Hours);

#undef TEST_FACTORY_OVERLOADS

  EXPECT_EQ(absl::Milliseconds(1500), absl::Seconds(1.5));
  EXPECT_LT(absl::Nanoseconds(1), absl::Nanoseconds(1.5));
  EXPECT_GT(absl::Nanoseconds(2), absl::Nanoseconds(1.5));

  const double dbl_inf = std::numeric_limits<double>::infinity();
  EXPECT_EQ(absl::InfiniteDuration(), absl::Nanoseconds(dbl_inf));
  EXPECT_EQ(absl::InfiniteDuration(), absl::Microseconds(dbl_inf));
  EXPECT_EQ(absl::InfiniteDuration(), absl::Milliseconds(dbl_inf));
  EXPECT_EQ(absl::InfiniteDuration(), absl::Seconds(dbl_inf));
  EXPECT_EQ(absl::InfiniteDuration(), absl::Minutes(dbl_inf));
  EXPECT_EQ(absl::InfiniteDuration(), absl::Hours(dbl_inf));
  EXPECT_EQ(-absl::InfiniteDuration(), absl::Nanoseconds(-dbl_inf));
  EXPECT_EQ(-absl::InfiniteDuration(), absl::Microseconds(-dbl_inf));
  EXPECT_EQ(-absl::InfiniteDuration(), absl::Milliseconds(-dbl_inf));
  EXPECT_EQ(-absl::InfiniteDuration(), absl::Seconds(-dbl_inf));
  EXPECT_EQ(-absl::InfiniteDuration(), absl::Minutes(-dbl_inf));
  EXPECT_EQ(-absl::InfiniteDuration(), absl::Hours(-dbl_inf));
}

TEST(Duration, InfinityExamples) {
  // These examples are used in the documentation in time.h. They are
  // written so that they can be copy-n-pasted easily.

  constexpr absl::Duration inf = absl::InfiniteDuration();
  constexpr absl::Duration d = absl::Seconds(1);  // Any finite duration

  EXPECT_TRUE(inf == inf + inf);
  EXPECT_TRUE(inf == inf + d);
  EXPECT_TRUE(inf == inf - inf);
  EXPECT_TRUE(-inf == d - inf);

  EXPECT_TRUE(inf == d * 1e100);
  EXPECT_TRUE(0 == d / inf);  // NOLINT(readability/check)

  // Division by zero returns infinity, or kint64min/MAX where necessary.
  EXPECT_TRUE(inf == d / 0);
  EXPECT_TRUE(kint64max == d / absl::ZeroDuration());
}

TEST(Duration, InfinityComparison) {
  const absl::Duration inf = absl::InfiniteDuration();
  const absl::Duration any_dur = absl::Seconds(1);

  // Equality
  EXPECT_EQ(inf, inf);
  EXPECT_EQ(-inf, -inf);
  EXPECT_NE(inf, -inf);
  EXPECT_NE(any_dur, inf);
  EXPECT_NE(any_dur, -inf);

  // Relational
  EXPECT_GT(inf, any_dur);
  EXPECT_LT(-inf, any_dur);
  EXPECT_LT(-inf, inf);
  EXPECT_GT(inf, -inf);

#ifdef __cpp_impl_three_way_comparison
  EXPECT_EQ(inf <=> inf, std::strong_ordering::equal);
  EXPECT_EQ(-inf <=> -inf, std::strong_ordering::equal);
  EXPECT_EQ(-inf <=> inf, std::strong_ordering::less);
  EXPECT_EQ(inf <=> -inf, std::strong_ordering::greater);
  EXPECT_EQ(any_dur <=> inf, std::strong_ordering::less);
  EXPECT_EQ(any_dur <=> -inf, std::strong_ordering::greater);
#endif  // __cpp_impl_three_way_comparison
}

TEST(Duration, InfinityAddition) {
  const absl::Duration sec_max = absl::Seconds(kint64max);
  const absl::Duration sec_min = absl::Seconds(kint64min);
  const absl::Duration any_dur = absl::Seconds(1);
  const absl::Duration inf = absl::InfiniteDuration();

  // Addition
  EXPECT_EQ(inf, inf + inf);
  EXPECT_EQ(inf, inf + -inf);
  EXPECT_EQ(-inf, -inf + inf);
  EXPECT_EQ(-inf, -inf + -inf);

  EXPECT_EQ(inf, inf + any_dur);
  EXPECT_EQ(inf, any_dur + inf);
  EXPECT_EQ(-inf, -inf + any_dur);
  EXPECT_EQ(-inf, any_dur + -inf);

  // Interesting case
  absl::Duration almost_inf = sec_max + absl::Nanoseconds(999999999);
  EXPECT_GT(inf, almost_inf);
  almost_inf += -absl::Nanoseconds(999999999);
  EXPECT_GT(inf, almost_inf);

  // Addition overflow/underflow
  EXPECT_EQ(inf, sec_max + absl::Seconds(1));
  EXPECT_EQ(inf, sec_max + sec_max);
  EXPECT_EQ(-inf, sec_min + -absl::Seconds(1));
  EXPECT_EQ(-inf, sec_min + -sec_max);

  // For reference: IEEE 754 behavior
  const double dbl_inf = std::numeric_limits<double>::infinity();
  EXPECT_TRUE(std::isinf(dbl_inf + dbl_inf));
  EXPECT_TRUE(std::isnan(dbl_inf + -dbl_inf));  // We return inf
  EXPECT_TRUE(std::isnan(-dbl_inf + dbl_inf));  // We return inf
  EXPECT_TRUE(std::isinf(-dbl_inf + -dbl_inf));
}

TEST(Duration, InfinitySubtraction) {
  const absl::Duration sec_max = absl::Seconds(kint64max);
  const absl::Duration sec_min = absl::Seconds(kint64min);
  const absl::Duration any_dur = absl::Seconds(1);
  const absl::Duration inf = absl::InfiniteDuration();

  // Subtraction
  EXPECT_EQ(inf, inf - inf);
  EXPECT_EQ(inf, inf - -inf);
  EXPECT_EQ(-inf, -inf - inf);
  EXPECT_EQ(-inf, -inf - -inf);

  EXPECT_EQ(inf, inf - any_dur);
  EXPECT_EQ(-inf, any_dur - inf);
  EXPECT_EQ(-inf, -inf - any_dur);
  EXPECT_EQ(inf, any_dur - -inf);

  // Subtraction overflow/underflow
  EXPECT_EQ(inf, sec_max - -absl::Seconds(1));
  EXPECT_EQ(inf, sec_max - -sec_max);
  EXPECT_EQ(-inf, sec_min - absl::Seconds(1));
  EXPECT_EQ(-inf, sec_min - sec_max);

  // Interesting case
  absl::Duration almost_neg_inf = sec_min;
  EXPECT_LT(-inf, almost_neg_inf);

#ifdef __cpp_impl_three_way_comparison
  EXPECT_EQ(-inf <=> almost_neg_inf, std::strong_ordering::less);
  EXPECT_EQ(almost_neg_inf <=> -inf, std::strong_ordering::greater);
#endif  // __cpp_impl_three_way_comparison

  almost_neg_inf -= -absl::Nanoseconds(1);
  EXPECT_LT(-inf, almost_neg_inf);

#ifdef __cpp_impl_three_way_comparison
  EXPECT_EQ(-inf <=> almost_neg_inf, std::strong_ordering::less);
  EXPECT_EQ(almost_neg_inf <=> -inf, std::strong_ordering::greater);
#endif  // __cpp_impl_three_way_comparison

  // For reference: IEEE 754 behavior
  const double dbl_inf = std::numeric_limits<double>::infinity();
  EXPECT_TRUE(std::isnan(dbl_inf - dbl_inf));  // We return inf
  EXPECT_TRUE(std::isinf(dbl_inf - -dbl_inf));
  EXPECT_TRUE(std::isinf(-dbl_inf - dbl_inf));
  EXPECT_TRUE(std::isnan(-dbl_inf - -dbl_inf));  // We return inf
}

TEST(Duration, InfinityMultiplication) {
  const absl::Duration sec_max = absl::Seconds(kint64max);
  const absl::Duration sec_min = absl::Seconds(kint64min);
  const absl::Duration inf = absl::InfiniteDuration();

#define TEST_INF_MUL_WITH_TYPE(T)                                     \
  EXPECT_EQ(inf, inf * static_cast<T>(2));                            \
  EXPECT_EQ(-inf, inf * static_cast<T>(-2));                          \
  EXPECT_EQ(-inf, -inf * static_cast<T>(2));                          \
  EXPECT_EQ(inf, -inf * static_cast<T>(-2));                          \
  EXPECT_EQ(inf, inf * static_cast<T>(0));                            \
  EXPECT_EQ(-inf, -inf * static_cast<T>(0));                          \
  EXPECT_EQ(inf, sec_max * static_cast<T>(2));                        \
  EXPECT_EQ(inf, sec_min * static_cast<T>(-2));                       \
  EXPECT_EQ(inf, (sec_max / static_cast<T>(2)) * static_cast<T>(3));  \
  EXPECT_EQ(-inf, sec_max * static_cast<T>(-2));                      \
  EXPECT_EQ(-inf, sec_min * static_cast<T>(2));                       \
  EXPECT_EQ(-inf, (sec_min / static_cast<T>(2)) * static_cast<T>(3));

  TEST_INF_MUL_WITH_TYPE(int64_t);  // NOLINT(readability/function)
  TEST_INF_MUL_WITH_TYPE(double);   // NOLINT(readability/function)

#undef TEST_INF_MUL_WITH_TYPE

  const double dbl_inf = std::numeric_limits<double>::infinity();
  EXPECT_EQ(inf, inf * dbl_inf);
  EXPECT_EQ(-inf, -inf * dbl_inf);
  EXPECT_EQ(-inf, inf * -dbl_inf);
  EXPECT_EQ(inf, -inf * -dbl_inf);

  const absl::Duration any_dur = absl::Seconds(1);
  EXPECT_EQ(inf, any_dur * dbl_inf);
  EXPECT_EQ(-inf, -any_dur * dbl_inf);
  EXPECT_EQ(-inf, any_dur * -dbl_inf);
  EXPECT_EQ(inf, -any_dur * -dbl_inf);

  // Fixed-point multiplication will produce a finite value, whereas floating
  // point fuzziness will overflow to inf.
  EXPECT_NE(absl::InfiniteDuration(), absl::Seconds(1) * kint64max);
  EXPECT_EQ(inf, absl::Seconds(1) * static_cast<double>(kint64max));
  EXPECT_NE(-absl::InfiniteDuration(), absl::Seconds(1) * kint64min);
  EXPECT_EQ(-inf, absl::Seconds(1) * static_cast<double>(kint64min));

  // Note that sec_max * or / by 1.0 overflows to inf due to the 53-bit
  // limitations of double.
  EXPECT_NE(inf, sec_max);
  EXPECT_NE(inf, sec_max / 1);
  EXPECT_EQ(inf, sec_max / 1.0);
  EXPECT_NE(inf, sec_max * 1);
  EXPECT_EQ(inf, sec_max * 1.0);
}

TEST(Duration, InfinityDivision) {
  const absl::Duration sec_max = absl::Seconds(kint64max);
  const absl::Duration sec_min = absl::Seconds(kint64min);
  const absl::Duration inf = absl::InfiniteDuration();

  // Division of Duration by a double
#define TEST_INF_DIV_WITH_TYPE(T)            \
  EXPECT_EQ(inf, inf / static_cast<T>(2));   \
  EXPECT_EQ(-inf, inf / static_cast<T>(-2)); \
  EXPECT_EQ(-inf, -inf / static_cast<T>(2)); \
  EXPECT_EQ(inf, -inf / static_cast<T>(-2));

  TEST_INF_DIV_WITH_TYPE(int64_t);  // NOLINT(readability/function)
  TEST_INF_DIV_WITH_TYPE(double);   // NOLINT(readability/function)

#undef TEST_INF_DIV_WITH_TYPE

  // Division of Duration by a double overflow/underflow
  EXPECT_EQ(inf, sec_max / 0.5);
  EXPECT_EQ(inf, sec_min / -0.5);
  EXPECT_EQ(inf, ((sec_max / 0.5) + absl::Seconds(1)) / 0.5);
  EXPECT_EQ(-inf, sec_max / -0.5);
  EXPECT_EQ(-inf, sec_min / 0.5);
  EXPECT_EQ(-inf, ((sec_min / 0.5) - absl::Seconds(1)) / 0.5);

  const double dbl_inf = std::numeric_limits<double>::infinity();
  EXPECT_EQ(inf, inf / dbl_inf);
  EXPECT_EQ(-inf, inf / -dbl_inf);
  EXPECT_EQ(-inf, -inf / dbl_inf);
  EXPECT_EQ(inf, -inf / -dbl_inf);

  const absl::Duration any_dur = absl::Seconds(1);
  EXPECT_EQ(absl::ZeroDuration(), any_dur / dbl_inf);
  EXPECT_EQ(absl::ZeroDuration(), any_dur / -dbl_inf);
  EXPECT_EQ(absl::ZeroDuration(), -any_dur / dbl_inf);
  EXPECT_EQ(absl::ZeroDuration(), -any_dur / -dbl_inf);
}

TEST(Duration, InfinityModulus) {
  const absl::Duration sec_max = absl::Seconds(kint64max);
  const absl::Duration any_dur = absl::Seconds(1);
  const absl::Duration inf = absl::InfiniteDuration();

  EXPECT_EQ(inf, inf % inf);
  EXPECT_EQ(inf, inf % -inf);
  EXPECT_EQ(-inf, -inf % -inf);
  EXPECT_EQ(-inf, -inf % inf);

  EXPECT_EQ(any_dur, any_dur % inf);
  EXPECT_EQ(any_dur, any_dur % -inf);
  EXPECT_EQ(-any_dur, -any_dur % inf);
  EXPECT_EQ(-any_dur, -any_dur % -inf);

  EXPECT_EQ(inf, inf % -any_dur);
  EXPECT_EQ(inf, inf % any_dur);
  EXPECT_EQ(-inf, -inf % -any_dur);
  EXPECT_EQ(-inf, -inf % any_dur);

  // Remainder isn't affected by overflow.
  EXPECT_EQ(absl::ZeroDuration(), sec_max % absl::Seconds(1));
  EXPECT_EQ(absl::ZeroDuration(), sec_max % absl::Milliseconds(1));
  EXPECT_EQ(absl::ZeroDuration(), sec_max % absl::Microseconds(1));
  EXPECT_EQ(absl::ZeroDuration(), sec_max % absl::Nanoseconds(1));
  EXPECT_EQ(absl::ZeroDuration(), sec_max % absl::Nanoseconds(1) / 4);
}

TEST(Duration, InfinityIDiv) {
  const absl::Duration sec_max = absl::Seconds(kint64max);
  const absl::Duration any_dur = absl::Seconds(1);
  const absl::Duration inf = absl::InfiniteDuration();
  const double dbl_inf = std::numeric_limits<double>::infinity();

  // IDivDuration (int64_t return value + a remainer)
  absl::Duration rem = absl::ZeroDuration();
  EXPECT_EQ(kint64max, absl::IDivDuration(inf, inf, &rem));
  EXPECT_EQ(inf, rem);

  rem = absl::ZeroDuration();
  EXPECT_EQ(kint64max, absl::IDivDuration(-inf, -inf, &rem));
  EXPECT_EQ(-inf, rem);

  rem = absl::ZeroDuration();
  EXPECT_EQ(kint64max, absl::IDivDuration(inf, any_dur, &rem));
  EXPECT_EQ(inf, rem);

  rem = absl::ZeroDuration();
  EXPECT_EQ(0, absl::IDivDuration(any_dur, inf, &rem));
  EXPECT_EQ(any_dur, rem);

  rem = absl::ZeroDuration();
  EXPECT_EQ(kint64max, absl::IDivDuration(-inf, -any_dur, &rem));
  EXPECT_EQ(-inf, rem);

  rem = absl::ZeroDuration();
  EXPECT_EQ(0, absl::IDivDuration(-any_dur, -inf, &rem));
  EXPECT_EQ(-any_dur, rem);

  rem = absl::ZeroDuration();
  EXPECT_EQ(kint64min, absl::IDivDuration(-inf, inf, &rem));
  EXPECT_EQ(-inf, rem);

  rem = absl::ZeroDuration();
  EXPECT_EQ(kint64min, absl::IDivDuration(inf, -inf, &rem));
  EXPECT_EQ(inf, rem);

  rem = absl::ZeroDuration();
  EXPECT_EQ(kint64min, absl::IDivDuration(-inf, any_dur, &rem));
  EXPECT_EQ(-inf, rem);

  rem = absl::ZeroDuration();
  EXPECT_EQ(0, absl::IDivDuration(-any_dur, inf, &rem));
  EXPECT_EQ(-any_dur, rem);

  rem = absl::ZeroDuration();
  EXPECT_EQ(kint64min, absl::IDivDuration(inf, -any_dur, &rem));
  EXPECT_EQ(inf, rem);

  rem = absl::ZeroDuration();
  EXPECT_EQ(0, absl::IDivDuration(any_dur, -inf, &rem));
  EXPECT_EQ(any_dur, rem);

  // IDivDuration overflow/underflow
  rem = any_dur;
  EXPECT_EQ(kint64max,
            absl::IDivDuration(sec_max, absl::Nanoseconds(1) / 4, &rem));
  EXPECT_EQ(sec_max - absl::Nanoseconds(kint64max) / 4, rem);

  rem = any_dur;
  EXPECT_EQ(kint64max,
            absl::IDivDuration(sec_max, absl::Milliseconds(1), &rem));
  EXPECT_EQ(sec_max - absl::Milliseconds(kint64max), rem);

  rem = any_dur;
  EXPECT_EQ(kint64max,
            absl::IDivDuration(-sec_max, -absl::Milliseconds(1), &rem));
  EXPECT_EQ(-sec_max + absl::Milliseconds(kint64max), rem);

  rem = any_dur;
  EXPECT_EQ(kint64min,
            absl::IDivDuration(-sec_max, absl::Milliseconds(1), &rem));
  EXPECT_EQ(-sec_max - absl::Milliseconds(kint64min), rem);

  rem = any_dur;
  EXPECT_EQ(kint64min,
            absl::IDivDuration(sec_max, -absl::Milliseconds(1), &rem));
  EXPECT_EQ(sec_max + absl::Milliseconds(kint64min), rem);

  //
  // operator/(Duration, Duration) is a wrapper for IDivDuration().
  //

  // IEEE 754 says inf / inf should be nan, but int64_t doesn't have
  // nan so we'll return kint64max/kint64min instead.
  EXPECT_TRUE(std::isnan(dbl_inf / dbl_inf));
  EXPECT_EQ(kint64max, inf / inf);
  EXPECT_EQ(kint64max, -inf / -inf);
  EXPECT_EQ(kint64min, -inf / inf);
  EXPECT_EQ(kint64min, inf / -inf);

  EXPECT_TRUE(std::isinf(dbl_inf / 2.0));
  EXPECT_EQ(kint64max, inf / any_dur);
  EXPECT_EQ(kint64max, -inf / -any_dur);
  EXPECT_EQ(kint64min, -inf / any_dur);
  EXPECT_EQ(kint64min, inf / -any_dur);

  EXPECT_EQ(0.0, 2.0 / dbl_inf);
  EXPECT_EQ(0, any_dur / inf);
  EXPECT_EQ(0, any_dur / -inf);
  EXPECT_EQ(0, -any_dur / inf);
  EXPECT_EQ(0, -any_dur / -inf);
  EXPECT_EQ(0, absl::ZeroDuration() / inf);

  // Division of Duration by a Duration overflow/underflow
  EXPECT_EQ(kint64max, sec_max / absl::Milliseconds(1));
  EXPECT_EQ(kint64max, -sec_max / -absl::Milliseconds(1));
  EXPECT_EQ(kint64min, -sec_max / absl::Milliseconds(1));
  EXPECT_EQ(kint64min, sec_max / -absl::Milliseconds(1));
}

TEST(Duration, InfinityFDiv) {
  const absl::Duration any_dur = absl::Seconds(1);
  const absl::Duration inf = absl::InfiniteDuration();
  const double dbl_inf = std::numeric_limits<double>::infinity();

  EXPECT_EQ(dbl_inf, absl::FDivDuration(inf, inf));
  EXPECT_EQ(dbl_inf, absl::FDivDuration(-inf, -inf));
  EXPECT_EQ(dbl_inf, absl::FDivDuration(inf, any_dur));
  EXPECT_EQ(0.0, absl::FDivDuration(any_dur, inf));
  EXPECT_EQ(dbl_inf, absl::FDivDuration(-inf, -any_dur));
  EXPECT_EQ(0.0, absl::FDivDuration(-any_dur, -inf));

  EXPECT_EQ(-dbl_inf, absl::FDivDuration(-inf, inf));
  EXPECT_EQ(-dbl_inf, absl::FDivDuration(inf, -inf));
  EXPECT_EQ(-dbl_inf, absl::FDivDuration(-inf, any_dur));
  EXPECT_EQ(0.0, absl::FDivDuration(-any_dur, inf));
  EXPECT_EQ(-dbl_inf, absl::FDivDuration(inf, -any_dur));
  EXPECT_EQ(0.0, absl::FDivDuration(any_dur, -inf));
}

TEST(Duration, DivisionByZero) {
  const absl::Duration zero = absl::ZeroDuration();
  const absl::Duration inf = absl::InfiniteDuration();
  const absl::Duration any_dur = absl::Seconds(1);
  const double dbl_inf = std::numeric_limits<double>::infinity();
  const double dbl_denorm = std::numeric_limits<double>::denorm_min();

  // Operator/(Duration, double)
  EXPECT_EQ(inf, zero / 0.0);
  EXPECT_EQ(-inf, zero / -0.0);
  EXPECT_EQ(inf, any_dur / 0.0);
  EXPECT_EQ(-inf, any_dur / -0.0);
  EXPECT_EQ(-inf, -any_dur / 0.0);
  EXPECT_EQ(inf, -any_dur / -0.0);

  // Tests dividing by a number very close to, but not quite zero.
  EXPECT_EQ(zero, zero / dbl_denorm);
  EXPECT_EQ(zero, zero / -dbl_denorm);
  EXPECT_EQ(inf, any_dur / dbl_denorm);
  EXPECT_EQ(-inf, any_dur / -dbl_denorm);
  EXPECT_EQ(-inf, -any_dur / dbl_denorm);
  EXPECT_EQ(inf, -any_dur / -dbl_denorm);

  // IDiv
  absl::Duration rem = zero;
  EXPECT_EQ(kint64max, absl::IDivDuration(zero, zero, &rem));
  EXPECT_EQ(inf, rem);

  rem = zero;
  EXPECT_EQ(kint64max, absl::IDivDuration(any_dur, zero, &rem));
  EXPECT_EQ(inf, rem);

  rem = zero;
  EXPECT_EQ(kint64min, absl::IDivDuration(-any_dur, zero, &rem));
  EXPECT_EQ(-inf, rem);

  // Operator/(Duration, Duration)
  EXPECT_EQ(kint64max, zero / zero);
  EXPECT_EQ(kint64max, any_dur / zero);
  EXPECT_EQ(kint64min, -any_dur / zero);

  // FDiv
  EXPECT_EQ(dbl_inf, absl::FDivDuration(zero, zero));
  EXPECT_EQ(dbl_inf, absl::FDivDuration(any_dur, zero));
  EXPECT_EQ(-dbl_inf, absl::FDivDuration(-any_dur, zero));
}

TEST(Duration, NaN) {
  // Note that IEEE 754 does not define the behavior of a nan's sign when it is
  // copied, so the code below allows for either + or - InfiniteDuration.
#define TEST_NAN_HANDLING(NAME, NAN)           \
  do {                                         \
    const auto inf = absl::InfiniteDuration(); \
    auto x = NAME(NAN);                        \
    EXPECT_TRUE(x == inf || x == -inf);        \
    auto y = NAME(42);                         \
    y *= NAN;                                  \
    EXPECT_TRUE(y == inf || y == -inf);        \
    auto z = NAME(42);                         \
    z /= NAN;                                  \
    EXPECT_TRUE(z == inf || z == -inf);        \
  } while (0)

  const double nan = std::numeric_limits<double>::quiet_NaN();
  TEST_NAN_HANDLING(absl::Nanoseconds, nan);
  TEST_NAN_HANDLING(absl::Microseconds, nan);
  TEST_NAN_HANDLING(absl::Milliseconds, nan);
  TEST_NAN_HANDLING(absl::Seconds, nan);
  TEST_NAN_HANDLING(absl::Minutes, nan);
  TEST_NAN_HANDLING(absl::Hours, nan);

  TEST_NAN_HANDLING(absl::Nanoseconds, -nan);
  TEST_NAN_HANDLING(absl::Microseconds, -nan);
  TEST_NAN_HANDLING(absl::Milliseconds, -nan);
  TEST_NAN_HANDLING(absl::Seconds, -nan);
  TEST_NAN_HANDLING(absl::Minutes, -nan);
  TEST_NAN_HANDLING(absl::Hours, -nan);

#undef TEST_NAN_HANDLING
}

TEST(Duration, Range) {
  const absl::Duration range = ApproxYears(100 * 1e9);
  const absl::Duration range_future = range;
  const absl::Duration range_past = -range;

  EXPECT_LT(range_future, absl::InfiniteDuration());
  EXPECT_GT(range_past, -absl::InfiniteDuration());

  const absl::Duration full_range = range_future - range_past;
  EXPECT_GT(full_range, absl::ZeroDuration());
  EXPECT_LT(full_range, absl::InfiniteDuration());

  const absl::Duration neg_full_range = range_past - range_future;
  EXPECT_LT(neg_full_range, absl::ZeroDuration());
  EXPECT_GT(neg_full_range, -absl::InfiniteDuration());

  EXPECT_LT(neg_full_range, full_range);
  EXPECT_EQ(neg_full_range, -full_range);

#ifdef __cpp_impl_three_way_comparison
  EXPECT_EQ(range_future <=> absl::InfiniteDuration(),
            std::strong_ordering::less);
  EXPECT_EQ(range_past <=> -absl::InfiniteDuration(),
            std::strong_ordering::greater);
  EXPECT_EQ(full_range <=> absl::ZeroDuration(),  //
            std::strong_ordering::greater);
  EXPECT_EQ(full_range <=> -absl::InfiniteDuration(),
            std::strong_ordering::greater);
  EXPECT_EQ(neg_full_range <=> -absl::InfiniteDuration(),
            std::strong_ordering::greater);
  EXPECT_EQ(neg_full_range <=> full_range, std::strong_ordering::less);
  EXPECT_EQ(neg_full_range <=> -full_range, std::strong_ordering::equal);
#endif  // __cpp_impl_three_way_comparison
}

TEST(Duration, RelationalOperators) {
#define TEST_REL_OPS(UNIT)               \
  static_assert(UNIT(2) == UNIT(2), ""); \
  static_assert(UNIT(1) != UNIT(2), ""); \
  static_assert(UNIT(1) < UNIT(2), "");  \
  static_assert(UNIT(3) > UNIT(2), "");  \
  static_assert(UNIT(1) <= UNIT(2), ""); \
  static_assert(UNIT(2) <= UNIT(2), ""); \
  static_assert(UNIT(3) >= UNIT(2), ""); \
  static_assert(UNIT(2) >= UNIT(2), "");

  TEST_REL_OPS(absl::Nanoseconds);
  TEST_REL_OPS(absl::Microseconds);
  TEST_REL_OPS(absl::Milliseconds);
  TEST_REL_OPS(absl::Seconds);
  TEST_REL_OPS(absl::Minutes);
  TEST_REL_OPS(absl::Hours);

#undef TEST_REL_OPS
}


#ifdef __cpp_impl_three_way_comparison

TEST(Duration, SpaceshipOperators) {
#define TEST_REL_OPS(UNIT)               \
  static_assert(UNIT(2) <=> UNIT(2) == std::strong_ordering::equal, ""); \
  static_assert(UNIT(1) <=> UNIT(2) == std::strong_ordering::less, ""); \
  static_assert(UNIT(3) <=> UNIT(2) == std::strong_ordering::greater, "");

  TEST_REL_OPS(absl::Nanoseconds);
  TEST_REL_OPS(absl::Microseconds);
  TEST_REL_OPS(absl::Milliseconds);
  TEST_REL_OPS(absl::Seconds);
  TEST_REL_OPS(absl::Minutes);
  TEST_REL_OPS(absl::Hours);

#undef TEST_REL_OPS
}

#endif  // __cpp_impl_three_way_comparison

TEST(Duration, Addition) {
#define TEST_ADD_OPS(UNIT)                  \
  do {                                      \
    EXPECT_EQ(UNIT(2), UNIT(1) + UNIT(1));  \
    EXPECT_EQ(UNIT(1), UNIT(2) - UNIT(1));  \
    EXPECT_EQ(UNIT(0), UNIT(2) - UNIT(2));  \
    EXPECT_EQ(UNIT(-1), UNIT(1) - UNIT(2)); \
    EXPECT_EQ(UNIT(-2), UNIT(0) - UNIT(2)); \
    EXPECT_EQ(UNIT(-2), UNIT(1) - UNIT(3)); \
    absl::Duration a = UNIT(1);             \
    a += UNIT(1);                           \
    EXPECT_EQ(UNIT(2), a);                  \
    a -= UNIT(1);                           \
    EXPECT_EQ(UNIT(1), a);                  \
  } while (0)

  TEST_ADD_OPS(absl::Nanoseconds);
  TEST_ADD_OPS(absl::Microseconds);
  TEST_ADD_OPS(absl::Milliseconds);
  TEST_ADD_OPS(absl::Seconds);
  TEST_ADD_OPS(absl::Minutes);
  TEST_ADD_OPS(absl::Hours);

#undef TEST_ADD_OPS

  EXPECT_EQ(absl::Seconds(2), absl::Seconds(3) - 2 * absl::Milliseconds(500));
  EXPECT_EQ(absl::Seconds(2) + absl::Milliseconds(500),
            absl::Seconds(3) - absl::Milliseconds(500));

  EXPECT_EQ(absl::Seconds(1) + absl::Milliseconds(998),
            absl::Milliseconds(999) + absl::Milliseconds(999));

  EXPECT_EQ(absl::Milliseconds(-1),
            absl::Milliseconds(998) - absl::Milliseconds(999));

  // Tests fractions of a nanoseconds. These are implementation details only.
  EXPECT_GT(absl::Nanoseconds(1), absl::Nanoseconds(1) / 2);
  EXPECT_EQ(absl::Nanoseconds(1),
            absl::Nanoseconds(1) / 2 + absl::Nanoseconds(1) / 2);
  EXPECT_GT(absl::Nanoseconds(1) / 4, absl::Nanoseconds(0));
  EXPECT_EQ(absl::Nanoseconds(1) / 8, absl::Nanoseconds(0));

  // Tests subtraction that will cause wrap around of the rep_lo_ bits.
  absl::Duration d_7_5 = absl::Seconds(7) + absl::Milliseconds(500);
  absl::Duration d_3_7 = absl::Seconds(3) + absl::Milliseconds(700);
  absl::Duration ans_3_8 = absl::Seconds(3) + absl::Milliseconds(800);
  EXPECT_EQ(ans_3_8, d_7_5 - d_3_7);

  // Subtracting min_duration
  absl::Duration min_dur = absl::Seconds(kint64min);
  EXPECT_EQ(absl::Seconds(0), min_dur - min_dur);
  EXPECT_EQ(absl::Seconds(kint64max), absl::Seconds(-1) - min_dur);
}

TEST(Duration, Negation) {
  // By storing negations of various values in constexpr variables we
  // verify that the initializers are constant expressions.
  constexpr absl::Duration negated_zero_duration = -absl::ZeroDuration();
  EXPECT_EQ(negated_zero_duration, absl::ZeroDuration());

  constexpr absl::Duration negated_infinite_duration =
      -absl::InfiniteDuration();
  EXPECT_NE(negated_infinite_duration, absl::InfiniteDuration());
  EXPECT_EQ(-negated_infinite_duration, absl::InfiniteDuration());

  // The public APIs to check if a duration is infinite depend on using
  // -InfiniteDuration(), but we're trying to test operator- here, so we
  // need to use the lower-level internal query IsInfiniteDuration.
  EXPECT_TRUE(
      absl::time_internal::IsInfiniteDuration(negated_infinite_duration));

  // The largest Duration is kint64max seconds and kTicksPerSecond - 1 ticks.
  // Using the absl::time_internal::MakeDuration API is the cleanest way to
  // construct that Duration.
  constexpr absl::Duration max_duration = absl::time_internal::MakeDuration(
      kint64max, absl::time_internal::kTicksPerSecond - 1);
  constexpr absl::Duration negated_max_duration = -max_duration;
  // The largest negatable value is one tick above the minimum representable;
  // it's the negation of max_duration.
  constexpr absl::Duration nearly_min_duration =
      absl::time_internal::MakeDuration(kint64min, int64_t{1});
  constexpr absl::Duration negated_nearly_min_duration = -nearly_min_duration;

  EXPECT_EQ(negated_max_duration, nearly_min_duration);
  EXPECT_EQ(negated_nearly_min_duration, max_duration);
  EXPECT_EQ(-(-max_duration), max_duration);

  constexpr absl::Duration min_duration =
      absl::time_internal::MakeDuration(kint64min);
  constexpr absl::Duration negated_min_duration = -min_duration;
  EXPECT_EQ(negated_min_duration, absl::InfiniteDuration());
}

TEST(Duration, AbsoluteValue) {
  EXPECT_EQ(absl::ZeroDuration(), AbsDuration(absl::ZeroDuration()));
  EXPECT_EQ(absl::Seconds(1), AbsDuration(absl::Seconds(1)));
  EXPECT_EQ(absl::Seconds(1), AbsDuration(absl::Seconds(-1)));

  EXPECT_EQ(absl::InfiniteDuration(), AbsDuration(absl::InfiniteDuration()));
  EXPECT_EQ(absl::InfiniteDuration(), AbsDuration(-absl::InfiniteDuration()));

  absl::Duration max_dur =
      absl::Seconds(kint64max) + (absl::Seconds(1) - absl::Nanoseconds(1) / 4);
  EXPECT_EQ(max_dur, AbsDuration(max_dur));

  absl::Duration min_dur = absl::Seconds(kint64min);
  EXPECT_EQ(absl::InfiniteDuration(), AbsDuration(min_dur));
  EXPECT_EQ(max_dur, AbsDuration(min_dur + absl::Nanoseconds(1) / 4));
}

TEST(Duration, Multiplication) {
#define TEST_MUL_OPS(UNIT)                                    \
  do {                                                        \
    EXPECT_EQ(UNIT(5), UNIT(2) * 2.5);                        \
    EXPECT_EQ(UNIT(2), UNIT(5) / 2.5);                        \
    EXPECT_EQ(UNIT(-5), UNIT(-2) * 2.5);                      \
    EXPECT_EQ(UNIT(-5), -UNIT(2) * 2.5);                      \
    EXPECT_EQ(UNIT(-5), UNIT(2) * -2.5);                      \
    EXPECT_EQ(UNIT(-2), UNIT(-5) / 2.5);                      \
    EXPECT_EQ(UNIT(-2), -UNIT(5) / 2.5);                      \
    EXPECT_EQ(UNIT(-2), UNIT(5) / -2.5);                      \
    EXPECT_EQ(UNIT(2), UNIT(11) % UNIT(3));                   \
    absl::Duration a = UNIT(2);                               \
    a *= 2.5;                                                 \
    EXPECT_EQ(UNIT(5), a);                                    \
    a /= 2.5;                                                 \
    EXPECT_EQ(UNIT(2), a);                                    \
    a %= UNIT(1);                                             \
    EXPECT_EQ(UNIT(0), a);                                    \
    absl::Duration big = UNIT(1000000000);                    \
    big *= 3;                                                 \
    big /= 3;                                                 \
    EXPECT_EQ(UNIT(1000000000), big);                         \
    EXPECT_EQ(-UNIT(2), -UNIT(2));                            \
    EXPECT_EQ(-UNIT(2), UNIT(2) * -1);                        \
    EXPECT_EQ(-UNIT(2), -1 * UNIT(2));                        \
    EXPECT_EQ(-UNIT(-2), UNIT(2));                            \
    EXPECT_EQ(2, UNIT(2) / UNIT(1));                          \
    absl::Duration rem;                                       \
    EXPECT_EQ(2, absl::IDivDuration(UNIT(2), UNIT(1), &rem)); \
    EXPECT_EQ(2.0, absl::FDivDuration(UNIT(2), UNIT(1)));     \
  } while (0)

  TEST_MUL_OPS(absl::Nanoseconds);
  TEST_MUL_OPS(absl::Microseconds);
  TEST_MUL_OPS(absl::Milliseconds);
  TEST_MUL_OPS(absl::Seconds);
  TEST_MUL_OPS(absl::Minutes);
  TEST_MUL_OPS(absl::Hours);

#undef TEST_MUL_OPS

  // Ensures that multiplication and division by 1 with a maxed-out durations
  // doesn't lose precision.
  absl::Duration max_dur =
      absl::Seconds(kint64max) + (absl::Seconds(1) - absl::Nanoseconds(1) / 4);
  absl::Duration min_dur = absl::Seconds(kint64min);
  EXPECT_EQ(max_dur, max_dur * 1);
  EXPECT_EQ(max_dur, max_dur / 1);
  EXPECT_EQ(min_dur, min_dur * 1);
  EXPECT_EQ(min_dur, min_dur / 1);

  // Tests division on a Duration with a large number of significant digits.
  // Tests when the digits span hi and lo as well as only in hi.
  absl::Duration sigfigs = absl::Seconds(2000000000) + absl::Nanoseconds(3);
  EXPECT_EQ(absl::Seconds(666666666) + absl::Nanoseconds(666666667) +
                absl::Nanoseconds(1) / 2,
            sigfigs / 3);
  sigfigs = absl::Seconds(int64_t{7000000000});
  EXPECT_EQ(absl::Seconds(2333333333) + absl::Nanoseconds(333333333) +
                absl::Nanoseconds(1) / 4,
            sigfigs / 3);

  EXPECT_EQ(absl::Seconds(7) + absl::Milliseconds(500), absl::Seconds(3) * 2.5);
  EXPECT_EQ(absl::Seconds(8) * -1 + absl::Milliseconds(300),
            (absl::Seconds(2) + absl::Milliseconds(200)) * -3.5);
  EXPECT_EQ(-absl::Seconds(8) + absl::Milliseconds(300),
            (absl::Seconds(2) + absl::Milliseconds(200)) * -3.5);
  EXPECT_EQ(absl::Seconds(1) + absl::Milliseconds(875),
            (absl::Seconds(7) + absl::Milliseconds(500)) / 4);
  EXPECT_EQ(absl::Seconds(30),
            (absl::Seconds(7) + absl::Milliseconds(500)) / 0.25);
  EXPECT_EQ(absl::Seconds(3),
            (absl::Seconds(7) + absl::Milliseconds(500)) / 2.5);

  // Tests division remainder.
  EXPECT_EQ(absl::Nanoseconds(0), absl::Nanoseconds(7) % absl::Nanoseconds(1));
  EXPECT_EQ(absl::Nanoseconds(0), absl::Nanoseconds(0) % absl::Nanoseconds(10));
  EXPECT_EQ(absl::Nanoseconds(2), absl::Nanoseconds(7) % absl::Nanoseconds(5));
  EXPECT_EQ(absl::Nanoseconds(2), absl::Nanoseconds(2) % absl::Nanoseconds(5));

  EXPECT_EQ(absl::Nanoseconds(1), absl::Nanoseconds(10) % absl::Nanoseconds(3));
  EXPECT_EQ(absl::Nanoseconds(1),
            absl::Nanoseconds(10) % absl::Nanoseconds(-3));
  EXPECT_EQ(absl::Nanoseconds(-1),
            absl::Nanoseconds(-10) % absl::Nanoseconds(3));
  EXPECT_EQ(absl::Nanoseconds(-1),
            absl::Nanoseconds(-10) % absl::Nanoseconds(-3));

  EXPECT_EQ(absl::Milliseconds(100),
            absl::Seconds(1) % absl::Milliseconds(300));
  EXPECT_EQ(
      absl::Milliseconds(300),
      (absl::Seconds(3) + absl::Milliseconds(800)) % absl::Milliseconds(500));

  EXPECT_EQ(absl::Nanoseconds(1), absl::Nanoseconds(1) % absl::Seconds(1));
  EXPECT_EQ(absl::Nanoseconds(-1), absl::Nanoseconds(-1) % absl::Seconds(1));
  EXPECT_EQ(0, absl::Nanoseconds(-1) / absl::Seconds(1));  // Actual -1e-9

  // Tests identity a = (a/b)*b + a%b
#define TEST_MOD_IDENTITY(a, b) \
  EXPECT_EQ((a), ((a) / (b))*(b) + ((a)%(b)))

  TEST_MOD_IDENTITY(absl::Seconds(0), absl::Seconds(2));
  TEST_MOD_IDENTITY(absl::Seconds(1), absl::Seconds(1));
  TEST_MOD_IDENTITY(absl::Seconds(1), absl::Seconds(2));
  TEST_MOD_IDENTITY(absl::Seconds(2), absl::Seconds(1));

  TEST_MOD_IDENTITY(absl::Seconds(-2), absl::Seconds(1));
  TEST_MOD_IDENTITY(absl::Seconds(2), absl::Seconds(-1));
  TEST_MOD_IDENTITY(absl::Seconds(-2), absl::Seconds(-1));

  TEST_MOD_IDENTITY(absl::Nanoseconds(0), absl::Nanoseconds(2));
  TEST_MOD_IDENTITY(absl::Nanoseconds(1), absl::Nanoseconds(1));
  TEST_MOD_IDENTITY(absl::Nanoseconds(1), absl::Nanoseconds(2));
  TEST_MOD_IDENTITY(absl::Nanoseconds(2), absl::Nanoseconds(1));

  TEST_MOD_IDENTITY(absl::Nanoseconds(-2), absl::Nanoseconds(1));
  TEST_MOD_IDENTITY(absl::Nanoseconds(2), absl::Nanoseconds(-1));
  TEST_MOD_IDENTITY(absl::Nanoseconds(-2), absl::Nanoseconds(-1));

  // Mixed seconds + subseconds
  absl::Duration mixed_a = absl::Seconds(1) + absl::Nanoseconds(2);
  absl::Duration mixed_b = absl::Seconds(1) + absl::Nanoseconds(3);

  TEST_MOD_IDENTITY(absl::Seconds(0), mixed_a);
  TEST_MOD_IDENTITY(mixed_a, mixed_a);
  TEST_MOD_IDENTITY(mixed_a, mixed_b);
  TEST_MOD_IDENTITY(mixed_b, mixed_a);

  TEST_MOD_IDENTITY(-mixed_a, mixed_b);
  TEST_MOD_IDENTITY(mixed_a, -mixed_b);
  TEST_MOD_IDENTITY(-mixed_a, -mixed_b);

#undef TEST_MOD_IDENTITY
}

TEST(Duration, Truncation) {
  const absl::Duration d = absl::Nanoseconds(1234567890);
  const absl::Duration inf = absl::InfiniteDuration();
  for (int unit_sign : {1, -1}) {  // sign shouldn't matter
    EXPECT_EQ(absl::Nanoseconds(1234567890),
              Trunc(d, unit_sign * absl::Nanoseconds(1)));
    EXPECT_EQ(absl::Microseconds(1234567),
              Trunc(d, unit_sign * absl::Microseconds(1)));
    EXPECT_EQ(absl::Milliseconds(1234),
              Trunc(d, unit_sign * absl::Milliseconds(1)));
    EXPECT_EQ(absl::Seconds(1), Trunc(d, unit_sign * absl::Seconds(1)));
    EXPECT_EQ(inf, Trunc(inf, unit_sign * absl::Seconds(1)));

    EXPECT_EQ(absl::Nanoseconds(-1234567890),
              Trunc(-d, unit_sign * absl::Nanoseconds(1)));
    EXPECT_EQ(absl::Microseconds(-1234567),
              Trunc(-d, unit_sign * absl::Microseconds(1)));
    EXPECT_EQ(absl::Milliseconds(-1234),
              Trunc(-d, unit_sign * absl::Milliseconds(1)));
    EXPECT_EQ(absl::Seconds(-1), Trunc(-d, unit_sign * absl::Seconds(1)));
    EXPECT_EQ(-inf, Trunc(-inf, unit_sign * absl::Seconds(1)));
  }
}

TEST(Duration, Flooring) {
  const absl::Duration d = absl::Nanoseconds(1234567890);
  const absl::Duration inf = absl::InfiniteDuration();
  for (int unit_sign : {1, -1}) {  // sign shouldn't matter
    EXPECT_EQ(absl::Nanoseconds(1234567890),
              absl::Floor(d, unit_sign * absl::Nanoseconds(1)));
    EXPECT_EQ(absl::Microseconds(1234567),
              absl::Floor(d, unit_sign * absl::Microseconds(1)));
    EXPECT_EQ(absl::Milliseconds(1234),
              absl::Floor(d, unit_sign * absl::Milliseconds(1)));
    EXPECT_EQ(absl::Seconds(1), absl::Floor(d, unit_sign * absl::Seconds(1)));
    EXPECT_EQ(inf, absl::Floor(inf, unit_sign * absl::Seconds(1)));

    EXPECT_EQ(absl::Nanoseconds(-1234567890),
              absl::Floor(-d, unit_sign * absl::Nanoseconds(1)));
    EXPECT_EQ(absl::Microseconds(-1234568),
              absl::Floor(-d, unit_sign * absl::Microseconds(1)));
    EXPECT_EQ(absl::Milliseconds(-1235),
              absl::Floor(-d, unit_sign * absl::Milliseconds(1)));
    EXPECT_EQ(absl::Seconds(-2), absl::Floor(-d, unit_sign * absl::Seconds(1)));
    EXPECT_EQ(-inf, absl::Floor(-inf, unit_sign * absl::Seconds(1)));
  }
}

TEST(Duration, Ceiling) {
  const absl::Duration d = absl::Nanoseconds(1234567890);
  const absl::Duration inf = absl::InfiniteDuration();
  for (int unit_sign : {1, -1}) {  // // sign shouldn't matter
    EXPECT_EQ(absl::Nanoseconds(1234567890),
              absl::Ceil(d, unit_sign * absl::Nanoseconds(1)));
    EXPECT_EQ(absl::Microseconds(1234568),
              absl::Ceil(d, unit_sign * absl::Microseconds(1)));
    EXPECT_EQ(absl::Milliseconds(1235),
              absl::Ceil(d, unit_sign * absl::Milliseconds(1)));
    EXPECT_EQ(absl::Seconds(2), absl::Ceil(d, unit_sign * absl::Seconds(1)));
    EXPECT_EQ(inf, absl::Ceil(inf, unit_sign * absl::Seconds(1)));

    EXPECT_EQ(absl::Nanoseconds(-1234567890),
              absl::Ceil(-d, unit_sign * absl::Nanoseconds(1)));
    EXPECT_EQ(absl::Microseconds(-1234567),
              absl::Ceil(-d, unit_sign * absl::Microseconds(1)));
    EXPECT_EQ(absl::Milliseconds(-1234),
              absl::Ceil(-d, unit_sign * absl::Milliseconds(1)));
    EXPECT_EQ(absl::Seconds(-1), absl::Ceil(-d, unit_sign * absl::Seconds(1)));
    EXPECT_EQ(-inf, absl::Ceil(-inf, unit_sign * absl::Seconds(1)));
  }
}

TEST(Duration, RoundTripUnits) {
  const int kRange = 100000;

#define ROUND_TRIP_UNIT(U, LOW, HIGH)          \
  do {                                         \
    for (int64_t i = LOW; i < HIGH; ++i) {     \
      absl::Duration d = absl::U(i);           \
      if (d == absl::InfiniteDuration())       \
        EXPECT_EQ(kint64max, d / absl::U(1));  \
      else if (d == -absl::InfiniteDuration()) \
        EXPECT_EQ(kint64min, d / absl::U(1));  \
      else                                     \
        EXPECT_EQ(i, absl::U(i) / absl::U(1)); \
    }                                          \
  } while (0)

  ROUND_TRIP_UNIT(Nanoseconds, kint64min, kint64min + kRange);
  ROUND_TRIP_UNIT(Nanoseconds, -kRange, kRange);
  ROUND_TRIP_UNIT(Nanoseconds, kint64max - kRange, kint64max);

  ROUND_TRIP_UNIT(Microseconds, kint64min, kint64min + kRange);
  ROUND_TRIP_UNIT(Microseconds, -kRange, kRange);
  ROUND_TRIP_UNIT(Microseconds, kint64max - kRange, kint64max);

  ROUND_TRIP_UNIT(Milliseconds, kint64min, kint64min + kRange);
  ROUND_TRIP_UNIT(Milliseconds, -kRange, kRange);
  ROUND_TRIP_UNIT(Milliseconds, kint64max - kRange, kint64max);

  ROUND_TRIP_UNIT(Seconds, kint64min, kint64min + kRange);
  ROUND_TRIP_UNIT(Seconds, -kRange, kRange);
  ROUND_TRIP_UNIT(Seconds, kint64max - kRange, kint64max);

  ROUND_TRIP_UNIT(Minutes, kint64min / 60, kint64min / 60 + kRange);
  ROUND_TRIP_UNIT(Minutes, -kRange, kRange);
  ROUND_TRIP_UNIT(Minutes, kint64max / 60 - kRange, kint64max / 60);

  ROUND_TRIP_UNIT(Hours, kint64min / 3600, kint64min / 3600 + kRange);
  ROUND_TRIP_UNIT(Hours, -kRange, kRange);
  ROUND_TRIP_UNIT(Hours, kint64max / 3600 - kRange, kint64max / 3600);

#undef ROUND_TRIP_UNIT
}

TEST(Duration, TruncConversions) {
  // Tests ToTimespec()/DurationFromTimespec()
  const struct {
    absl::Duration d;
    timespec ts;
  } to_ts[] = {
      {absl::Seconds(1) + absl::Nanoseconds(1), {1, 1}},
      {absl::Seconds(1) + absl::Nanoseconds(1) / 2, {1, 0}},
      {absl::Seconds(1) + absl::Nanoseconds(0), {1, 0}},
      {absl::Seconds(0) + absl::Nanoseconds(0), {0, 0}},
      {absl::Seconds(0) - absl::Nanoseconds(1) / 2, {0, 0}},
      {absl::Seconds(0) - absl::Nanoseconds(1), {-1, 999999999}},
      {absl::Seconds(-1) + absl::Nanoseconds(1), {-1, 1}},
      {absl::Seconds(-1) + absl::Nanoseconds(1) / 2, {-1, 1}},
      {absl::Seconds(-1) + absl::Nanoseconds(0), {-1, 0}},
      {absl::Seconds(-1) - absl::Nanoseconds(1) / 2, {-1, 0}},
  };
  for (const auto& test : to_ts) {
    EXPECT_THAT(absl::ToTimespec(test.d), TimespecMatcher(test.ts));
  }
  const struct {
    timespec ts;
    absl::Duration d;
  } from_ts[] = {
      {{1, 1}, absl::Seconds(1) + absl::Nanoseconds(1)},
      {{1, 0}, absl::Seconds(1) + absl::Nanoseconds(0)},
      {{0, 0}, absl::Seconds(0) + absl::Nanoseconds(0)},
      {{0, -1}, absl::Seconds(0) - absl::Nanoseconds(1)},
      {{-1, 999999999}, absl::Seconds(0) - absl::Nanoseconds(1)},
      {{-1, 1}, absl::Seconds(-1) + absl::Nanoseconds(1)},
      {{-1, 0}, absl::Seconds(-1) + absl::Nanoseconds(0)},
      {{-1, -1}, absl::Seconds(-1) - absl::Nanoseconds(1)},
      {{-2, 999999999}, absl::Seconds(-1) - absl::Nanoseconds(1)},
  };
  for (const auto& test : from_ts) {
    EXPECT_EQ(test.d, absl::DurationFromTimespec(test.ts));
  }

  // Tests ToTimeval()/DurationFromTimeval() (same as timespec above)
  const struct {
    absl::Duration d;
    timeval tv;
  } to_tv[] = {
      {absl::Seconds(1) + absl::Microseconds(1), {1, 1}},
      {absl::Seconds(1) + absl::Microseconds(1) / 2, {1, 0}},
      {absl::Seconds(1) + absl::Microseconds(0), {1, 0}},
      {absl::Seconds(0) + absl::Microseconds(0), {0, 0}},
      {absl::Seconds(0) - absl::Microseconds(1) / 2, {0, 0}},
      {absl::Seconds(0) - absl::Microseconds(1), {-1, 999999}},
      {absl::Seconds(-1) + absl::Microseconds(1), {-1, 1}},
      {absl::Seconds(-1) + absl::Microseconds(1) / 2, {-1, 1}},
      {absl::Seconds(-1) + absl::Microseconds(0), {-1, 0}},
      {absl::Seconds(-1) - absl::Microseconds(1) / 2, {-1, 0}},
  };
  for (const auto& test : to_tv) {
    EXPECT_THAT(absl::ToTimeval(test.d), TimevalMatcher(test.tv));
  }
  const struct {
    timeval tv;
    absl::Duration d;
  } from_tv[] = {
      {{1, 1}, absl::Seconds(1) + absl::Microseconds(1)},
      {{1, 0}, absl::Seconds(1) + absl::Microseconds(0)},
      {{0, 0}, absl::Seconds(0) + absl::Microseconds(0)},
      {{0, -1}, absl::Seconds(0) - absl::Microseconds(1)},
      {{-1, 999999}, absl::Seconds(0) - absl::Microseconds(1)},
      {{-1, 1}, absl::Seconds(-1) + absl::Microseconds(1)},
      {{-1, 0}, absl::Seconds(-1) + absl::Microseconds(0)},
      {{-1, -1}, absl::Seconds(-1) - absl::Microseconds(1)},
      {{-2, 999999}, absl::Seconds(-1) - absl::Microseconds(1)},
  };
  for (const auto& test : from_tv) {
    EXPECT_EQ(test.d, absl::DurationFromTimeval(test.tv));
  }
}

TEST(Duration, SmallConversions) {
  // Special tests for conversions of small durations.

  EXPECT_EQ(absl::ZeroDuration(), absl::Seconds(0));
  // TODO(bww): Is the next one OK?
  EXPECT_EQ(absl::ZeroDuration(), absl::Seconds(std::nextafter(0.125e-9, 0)));
  EXPECT_EQ(absl::Nanoseconds(1) / 4, absl::Seconds(0.125e-9));
  EXPECT_EQ(absl::Nanoseconds(1) / 4, absl::Seconds(0.250e-9));
  EXPECT_EQ(absl::Nanoseconds(1) / 2, absl::Seconds(0.375e-9));
  EXPECT_EQ(absl::Nanoseconds(1) / 2, absl::Seconds(0.500e-9));
  EXPECT_EQ(absl::Nanoseconds(3) / 4, absl::Seconds(0.625e-9));
  EXPECT_EQ(absl::Nanoseconds(3) / 4, absl::Seconds(0.750e-9));
  EXPECT_EQ(absl::Nanoseconds(1), absl::Seconds(0.875e-9));
  EXPECT_EQ(absl::Nanoseconds(1), absl::Seconds(1.000e-9));

  EXPECT_EQ(absl::ZeroDuration(), absl::Seconds(std::nextafter(-0.125e-9, 0)));
  EXPECT_EQ(-absl::Nanoseconds(1) / 4, absl::Seconds(-0.125e-9));
  EXPECT_EQ(-absl::Nanoseconds(1) / 4, absl::Seconds(-0.250e-9));
  EXPECT_EQ(-absl::Nanoseconds(1) / 2, absl::Seconds(-0.375e-9));
  EXPECT_EQ(-absl::Nanoseconds(1) / 2, absl::Seconds(-0.500e-9));
  EXPECT_EQ(-absl::Nanoseconds(3) / 4, absl::Seconds(-0.625e-9));
  EXPECT_EQ(-absl::Nanoseconds(3) / 4, absl::Seconds(-0.750e-9));
  EXPECT_EQ(-absl::Nanoseconds(1), absl::Seconds(-0.875e-9));
  EXPECT_EQ(-absl::Nanoseconds(1), absl::Seconds(-1.000e-9));

  timespec ts;
  ts.tv_sec = 0;
  ts.tv_nsec = 0;
  EXPECT_THAT(ToTimespec(absl::Nanoseconds(0)), TimespecMatcher(ts));
  // TODO(bww): Are the next three OK?
  EXPECT_THAT(ToTimespec(absl::Nanoseconds(1) / 4), TimespecMatcher(ts));
  EXPECT_THAT(ToTimespec(absl::Nanoseconds(2) / 4), TimespecMatcher(ts));
  EXPECT_THAT(ToTimespec(absl::Nanoseconds(3) / 4), TimespecMatcher(ts));
  ts.tv_nsec = 1;
  EXPECT_THAT(ToTimespec(absl::Nanoseconds(4) / 4), TimespecMatcher(ts));
  EXPECT_THAT(ToTimespec(absl::Nanoseconds(5) / 4), TimespecMatcher(ts));
  EXPECT_THAT(ToTimespec(absl::Nanoseconds(6) / 4), TimespecMatcher(ts));
  EXPECT_THAT(ToTimespec(absl::Nanoseconds(7) / 4), TimespecMatcher(ts));
  ts.tv_nsec = 2;
  EXPECT_THAT(ToTimespec(absl::Nanoseconds(8) / 4), TimespecMatcher(ts));

  timeval tv;
  tv.tv_sec = 0;
  tv.tv_usec = 0;
  EXPECT_THAT(ToTimeval(absl::Nanoseconds(0)), TimevalMatcher(tv));
  // TODO(bww): Is the next one OK?
  EXPECT_THAT(ToTimeval(absl::Nanoseconds(999)), TimevalMatcher(tv));
  tv.tv_usec = 1;
  EXPECT_THAT(ToTimeval(absl::Nanoseconds(1000)), TimevalMatcher(tv));
  EXPECT_THAT(ToTimeval(absl::Nanoseconds(1999)), TimevalMatcher(tv));
  tv.tv_usec = 2;
  EXPECT_THAT(ToTimeval(absl::Nanoseconds(2000)), TimevalMatcher(tv));
}

void VerifyApproxSameAsMul(double time_as_seconds, int* const misses) {
  auto direct_seconds = absl::Seconds(time_as_seconds);
  auto mul_by_one_second = time_as_seconds * absl::Seconds(1);
  // These are expected to differ by up to one tick due to fused multiply/add
  // contraction.
  if (absl::AbsDuration(direct_seconds - mul_by_one_second) >
      absl::time_internal::MakeDuration(0, 1u)) {
    if (*misses > 10) return;
    ASSERT_LE(++(*misses), 10) << "Too many errors, not reporting more.";
    EXPECT_EQ(direct_seconds, mul_by_one_second)
        << "given double time_as_seconds = " << std::setprecision(17)
        << time_as_seconds;
  }
}

// For a variety of interesting durations, we find the exact point
// where one double converts to that duration, and the very next double
// converts to the next duration.  For both of those points, verify that
// Seconds(point) returns a duration near point * Seconds(1.0). (They may
// not be exactly equal due to fused multiply/add contraction.)
TEST(Duration, ToDoubleSecondsCheckEdgeCases) {
#if (defined(__i386__) || defined(_M_IX86)) && FLT_EVAL_METHOD != 0
  // We're using an x87-compatible FPU, and intermediate operations can be
  // performed with 80-bit floats. This means the edge cases are different than
  // what we expect here, so just skip this test.
  GTEST_SKIP()
      << "Skipping the test because we detected x87 floating-point semantics";
#endif

  constexpr uint32_t kTicksPerSecond = absl::time_internal::kTicksPerSecond;
  constexpr auto duration_tick = absl::time_internal::MakeDuration(0, 1u);
  int misses = 0;
  for (int64_t seconds = 0; seconds < 99; ++seconds) {
    uint32_t tick_vals[] = {0, +999, +999999, +999999999, kTicksPerSecond - 1,
                            0, 1000, 1000000, 1000000000, kTicksPerSecond,
                            1, 1001, 1000001, 1000000001, kTicksPerSecond + 1,
                            2, 1002, 1000002, 1000000002, kTicksPerSecond + 2,
                            3, 1003, 1000003, 1000000003, kTicksPerSecond + 3,
                            4, 1004, 1000004, 1000000004, kTicksPerSecond + 4,
                            5, 6,    7,       8,          9};
    for (uint32_t ticks : tick_vals) {
      absl::Duration s_plus_t = absl::Seconds(seconds) + ticks * duration_tick;
      for (absl::Duration d : {s_plus_t, -s_plus_t}) {
        absl::Duration after_d = d + duration_tick;
        EXPECT_NE(d, after_d);
        EXPECT_EQ(after_d - d, duration_tick);

        double low_edge = ToDoubleSeconds(d);
        EXPECT_EQ(d, absl::Seconds(low_edge));

        double high_edge = ToDoubleSeconds(after_d);
        EXPECT_EQ(after_d, absl::Seconds(high_edge));

        for (;;) {
          double midpoint = low_edge + (high_edge - low_edge) / 2;
          if (midpoint == low_edge || midpoint == high_edge) break;
          absl::Duration mid_duration = absl::Seconds(midpoint);
          if (mid_duration == d) {
            low_edge = midpoint;
          } else {
            EXPECT_EQ(mid_duration, after_d);
            high_edge = midpoint;
          }
        }
        // Now low_edge is the highest double that converts to Duration d,
        // and high_edge is the lowest double that converts to Duration after_d.
        VerifyApproxSameAsMul(low_edge, &misses);
        VerifyApproxSameAsMul(high_edge, &misses);
      }
    }
  }
}

TEST(Duration, ToDoubleSecondsCheckRandom) {
  std::random_device rd;
  std::seed_seq seed({rd(), rd(), rd(), rd(), rd(), rd(), rd(), rd()});
  std::mt19937_64 gen(seed);
  // We want doubles distributed from 1/8ns up to 2^63, where
  // as many values are tested from 1ns to 2ns as from 1sec to 2sec,
  // so even distribute along a log-scale of those values, and
  // exponentiate before using them.  (9.223377e+18 is just slightly
  // out of bounds for absl::Duration.)
  std::uniform_real_distribution<double> uniform(std::log(0.125e-9),
                                                 std::log(9.223377e+18));
  int misses = 0;
  for (int i = 0; i < 1000000; ++i) {
    double d = std::exp(uniform(gen));
    VerifyApproxSameAsMul(d, &misses);
    VerifyApproxSameAsMul(-d, &misses);
  }
}

TEST(Duration, ConversionSaturation) {
  absl::Duration d;

  const auto max_timeval_sec =
      std::numeric_limits<decltype(timeval::tv_sec)>::max();
  const auto min_timeval_sec =
      std::numeric_limits<decltype(timeval::tv_sec)>::min();
  timeval tv;
  tv.tv_sec = max_timeval_sec;
  tv.tv_usec = 999998;
  d = absl::DurationFromTimeval(tv);
  tv = ToTimeval(d);
  EXPECT_EQ(max_timeval_sec, tv.tv_sec);
  EXPECT_EQ(999998, tv.tv_usec);
  d += absl::Microseconds(1);
  tv = ToTimeval(d);
  EXPECT_EQ(max_timeval_sec, tv.tv_sec);
  EXPECT_EQ(999999, tv.tv_usec);
  d += absl::Microseconds(1);  // no effect
  tv = ToTimeval(d);
  EXPECT_EQ(max_timeval_sec, tv.tv_sec);
  EXPECT_EQ(999999, tv.tv_usec);

  tv.tv_sec = min_timeval_sec;
  tv.tv_usec = 1;
  d = absl::DurationFromTimeval(tv);
  tv = ToTimeval(d);
  EXPECT_EQ(min_timeval_sec, tv.tv_sec);
  EXPECT_EQ(1, tv.tv_usec);
  d -= absl::Microseconds(1);
  tv = ToTimeval(d);
  EXPECT_EQ(min_timeval_sec, tv.tv_sec);
  EXPECT_EQ(0, tv.tv_usec);
  d -= absl::Microseconds(1);  // no effect
  tv = ToTimeval(d);
  EXPECT_EQ(min_timeval_sec, tv.tv_sec);
  EXPECT_EQ(0, tv.tv_usec);

  const auto max_timespec_sec =
      std::numeric_limits<decltype(timespec::tv_sec)>::max();
  const auto min_timespec_sec =
      std::numeric_limits<decltype(timespec::tv_sec)>::min();
  timespec ts;
  ts.tv_sec = max_timespec_sec;
  ts.tv_nsec = 999999998;
  d = absl::DurationFromTimespec(ts);
  ts = absl::ToTimespec(d);
  EXPECT_EQ(max_timespec_sec, ts.tv_sec);
  EXPECT_EQ(999999998, ts.tv_nsec);
  d += absl::Nanoseconds(1);
  ts = absl::ToTimespec(d);
  EXPECT_EQ(max_timespec_sec, ts.tv_sec);
  EXPECT_EQ(999999999, ts.tv_nsec);
  d += absl::Nanoseconds(1);  // no effect
  ts = absl::ToTimespec(d);
  EXPECT_EQ(max_timespec_sec, ts.tv_sec);
  EXPECT_EQ(999999999, ts.tv_nsec);

  ts.tv_sec = min_timespec_sec;
  ts.tv_nsec = 1;
  d = absl::DurationFromTimespec(ts);
  ts = absl::ToTimespec(d);
  EXPECT_EQ(min_timespec_sec, ts.tv_sec);
  EXPECT_EQ(1, ts.tv_nsec);
  d -= absl::Nanoseconds(1);
  ts = absl::ToTimespec(d);
  EXPECT_EQ(min_timespec_sec, ts.tv_sec);
  EXPECT_EQ(0, ts.tv_nsec);
  d -= absl::Nanoseconds(1);  // no effect
  ts = absl::ToTimespec(d);
  EXPECT_EQ(min_timespec_sec, ts.tv_sec);
  EXPECT_EQ(0, ts.tv_nsec);
}

TEST(Duration, FormatDuration) {
  // Example from Go's docs.
  EXPECT_EQ("72h3m0.5s",
            absl::FormatDuration(absl::Hours(72) + absl::Minutes(3) +
                                 absl::Milliseconds(500)));
  // Go's largest time: 2540400h10m10.000000000s
  EXPECT_EQ("2540400h10m10s",
            absl::FormatDuration(absl::Hours(2540400) + absl::Minutes(10) +
                                 absl::Seconds(10)));

  EXPECT_EQ("0", absl::FormatDuration(absl::ZeroDuration()));
  EXPECT_EQ("0", absl::FormatDuration(absl::Seconds(0)));
  EXPECT_EQ("0", absl::FormatDuration(absl::Nanoseconds(0)));

  EXPECT_EQ("1ns", absl::FormatDuration(absl::Nanoseconds(1)));
  EXPECT_EQ("1us", absl::FormatDuration(absl::Microseconds(1)));
  EXPECT_EQ("1ms", absl::FormatDuration(absl::Milliseconds(1)));
  EXPECT_EQ("1s", absl::FormatDuration(absl::Seconds(1)));
  EXPECT_EQ("1m", absl::FormatDuration(absl::Minutes(1)));
  EXPECT_EQ("1h", absl::FormatDuration(absl::Hours(1)));

  EXPECT_EQ("1h1m", absl::FormatDuration(absl::Hours(1) + absl::Minutes(1)));
  EXPECT_EQ("1h1s", absl::FormatDuration(absl::Hours(1) + absl::Seconds(1)));
  EXPECT_EQ("1m1s", absl::FormatDuration(absl::Minutes(1) + absl::Seconds(1)));

  EXPECT_EQ("1h0.25s",
            absl::FormatDuration(absl::Hours(1) + absl::Milliseconds(250)));
  EXPECT_EQ("1m0.25s",
            absl::FormatDuration(absl::Minutes(1) + absl::Milliseconds(250)));
  EXPECT_EQ("1h1m0.25s",
            absl::FormatDuration(absl::Hours(1) + absl::Minutes(1) +
                                 absl::Milliseconds(250)));
  EXPECT_EQ("1h0.0005s",
            absl::FormatDuration(absl::Hours(1) + absl::Microseconds(500)));
  EXPECT_EQ("1h0.0000005s",
            absl::FormatDuration(absl::Hours(1) + absl::Nanoseconds(500)));

  // Subsecond special case.
  EXPECT_EQ("1.5ns", absl::FormatDuration(absl::Nanoseconds(1) +
                                          absl::Nanoseconds(1) / 2));
  EXPECT_EQ("1.25ns", absl::FormatDuration(absl::Nanoseconds(1) +
                                           absl::Nanoseconds(1) / 4));
  EXPECT_EQ("1ns", absl::FormatDuration(absl::Nanoseconds(1) +
                                        absl::Nanoseconds(1) / 9));
  EXPECT_EQ("1.2us", absl::FormatDuration(absl::Microseconds(1) +
                                          absl::Nanoseconds(200)));
  EXPECT_EQ("1.2ms", absl::FormatDuration(absl::Milliseconds(1) +
                                          absl::Microseconds(200)));
  EXPECT_EQ("1.0002ms", absl::FormatDuration(absl::Milliseconds(1) +
                                             absl::Nanoseconds(200)));
  EXPECT_EQ("1.00001ms", absl::FormatDuration(absl::Milliseconds(1) +
                                              absl::Nanoseconds(10)));
  EXPECT_EQ("1.000001ms",
            absl::FormatDuration(absl::Milliseconds(1) + absl::Nanoseconds(1)));

  // Negative durations.
  EXPECT_EQ("-1ns", absl::FormatDuration(absl::Nanoseconds(-1)));
  EXPECT_EQ("-1us", absl::FormatDuration(absl::Microseconds(-1)));
  EXPECT_EQ("-1ms", absl::FormatDuration(absl::Milliseconds(-1)));
  EXPECT_EQ("-1s", absl::FormatDuration(absl::Seconds(-1)));
  EXPECT_EQ("-1m", absl::FormatDuration(absl::Minutes(-1)));
  EXPECT_EQ("-1h", absl::FormatDuration(absl::Hours(-1)));

  EXPECT_EQ("-1h1m",
            absl::FormatDuration(-(absl::Hours(1) + absl::Minutes(1))));
  EXPECT_EQ("-1h1s",
            absl::FormatDuration(-(absl::Hours(1) + absl::Seconds(1))));
  EXPECT_EQ("-1m1s",
            absl::FormatDuration(-(absl::Minutes(1) + absl::Seconds(1))));

  EXPECT_EQ("-1ns", absl::FormatDuration(absl::Nanoseconds(-1)));
  EXPECT_EQ("-1.2us", absl::FormatDuration(
                          -(absl::Microseconds(1) + absl::Nanoseconds(200))));
  EXPECT_EQ("-1.2ms", absl::FormatDuration(
                          -(absl::Milliseconds(1) + absl::Microseconds(200))));
  EXPECT_EQ("-1.0002ms", absl::FormatDuration(-(absl::Milliseconds(1) +
                                                absl::Nanoseconds(200))));
  EXPECT_EQ("-1.00001ms", absl::FormatDuration(-(absl::Milliseconds(1) +
                                                 absl::Nanoseconds(10))));
  EXPECT_EQ("-1.000001ms", absl::FormatDuration(-(absl::Milliseconds(1) +
                                                  absl::Nanoseconds(1))));

  //
  // Interesting corner cases.
  //

  const absl::Duration qns = absl::Nanoseconds(1) / 4;
  const absl::Duration max_dur =
      absl::Seconds(kint64max) + (absl::Seconds(1) - qns);
  const absl::Duration min_dur = absl::Seconds(kint64min);

  EXPECT_EQ("0.25ns", absl::FormatDuration(qns));
  EXPECT_EQ("-0.25ns", absl::FormatDuration(-qns));
  EXPECT_EQ("2562047788015215h30m7.99999999975s",
            absl::FormatDuration(max_dur));
  EXPECT_EQ("-2562047788015215h30m8s", absl::FormatDuration(min_dur));

  // Tests printing full precision from units that print using FDivDuration
  EXPECT_EQ("55.00000000025s", absl::FormatDuration(absl::Seconds(55) + qns));
  EXPECT_EQ("55.00000025ms",
            absl::FormatDuration(absl::Milliseconds(55) + qns));
  EXPECT_EQ("55.00025us", absl::FormatDuration(absl::Microseconds(55) + qns));
  EXPECT_EQ("55.25ns", absl::FormatDuration(absl::Nanoseconds(55) + qns));

  // Formatting infinity
  EXPECT_EQ("inf", absl::FormatDuration(absl::InfiniteDuration()));
  EXPECT_EQ("-inf", absl::FormatDuration(-absl::InfiniteDuration()));

  // Formatting approximately +/- 100 billion years
  const absl::Duration huge_range = ApproxYears(100000000000);
  EXPECT_EQ("876000000000000h", absl::FormatDuration(huge_range));
  EXPECT_EQ("-876000000000000h", absl::FormatDuration(-huge_range));

  EXPECT_EQ("876000000000000h0.999999999s",
            absl::FormatDuration(huge_range +
                                 (absl::Seconds(1) - absl::Nanoseconds(1))));
  EXPECT_EQ("876000000000000h0.9999999995s",
            absl::FormatDuration(
                huge_range + (absl::Seconds(1) - absl::Nanoseconds(1) / 2)));
  EXPECT_EQ("876000000000000h0.99999999975s",
            absl::FormatDuration(
                huge_range + (absl::Seconds(1) - absl::Nanoseconds(1) / 4)));

  EXPECT_EQ("-876000000000000h0.999999999s",
            absl::FormatDuration(-huge_range -
                                 (absl::Seconds(1) - absl::Nanoseconds(1))));
  EXPECT_EQ("-876000000000000h0.9999999995s",
            absl::FormatDuration(
                -huge_range - (absl::Seconds(1) - absl::Nanoseconds(1) / 2)));
  EXPECT_EQ("-876000000000000h0.99999999975s",
            absl::FormatDuration(
                -huge_range - (absl::Seconds(1) - absl::Nanoseconds(1) / 4)));
}

TEST(Duration, ParseDuration) {
  absl::Duration d;

  // No specified unit. Should only work for zero and infinity.
  EXPECT_TRUE(absl::ParseDuration("0", &d));
  EXPECT_EQ(absl::ZeroDuration(), d);
  EXPECT_TRUE(absl::ParseDuration("+0", &d));
  EXPECT_EQ(absl::ZeroDuration(), d);
  EXPECT_TRUE(absl::ParseDuration("-0", &d));
  EXPECT_EQ(absl::ZeroDuration(), d);

  EXPECT_TRUE(absl::ParseDuration("inf", &d));
  EXPECT_EQ(absl::InfiniteDuration(), d);
  EXPECT_TRUE(absl::ParseDuration("+inf", &d));
  EXPECT_EQ(absl::InfiniteDuration(), d);
  EXPECT_TRUE(absl::ParseDuration("-inf", &d));
  EXPECT_EQ(-absl::InfiniteDuration(), d);
  EXPECT_FALSE(absl::ParseDuration("infBlah", &d));

  // Illegal input forms.
  EXPECT_FALSE(absl::ParseDuration("", &d));
  EXPECT_FALSE(absl::ParseDuration("0.0", &d));
  EXPECT_FALSE(absl::ParseDuration(".0", &d));
  EXPECT_FALSE(absl::ParseDuration(".", &d));
  EXPECT_FALSE(absl::ParseDuration("01", &d));
  EXPECT_FALSE(absl::ParseDuration("1", &d));
  EXPECT_FALSE(absl::ParseDuration("-1", &d));
  EXPECT_FALSE(absl::ParseDuration("2", &d));
  EXPECT_FALSE(absl::ParseDuration("2 s", &d));
  EXPECT_FALSE(absl::ParseDuration(".s", &d));
  EXPECT_FALSE(absl::ParseDuration("-.s", &d));
  EXPECT_FALSE(absl::ParseDuration("s", &d));
  EXPECT_FALSE(absl::ParseDuration(" 2s", &d));
  EXPECT_FALSE(absl::ParseDuration("2s ", &d));
  EXPECT_FALSE(absl::ParseDuration(" 2s ", &d));
  EXPECT_FALSE(absl::ParseDuration("2mt", &d));
  EXPECT_FALSE(absl::ParseDuration("1e3s", &d));

  // One unit type.
  EXPECT_TRUE(absl::ParseDuration("1ns", &d));
  EXPECT_EQ(absl::Nanoseconds(1), d);
  EXPECT_TRUE(absl::ParseDuration("1us", &d));
  EXPECT_EQ(absl::Microseconds(1), d);
  EXPECT_TRUE(absl::ParseDuration("1ms", &d));
  EXPECT_EQ(absl::Milliseconds(1), d);
  EXPECT_TRUE(absl::ParseDuration("1s", &d));
  EXPECT_EQ(absl::Seconds(1), d);
  EXPECT_TRUE(absl::ParseDuration("2m", &d));
  EXPECT_EQ(absl::Minutes(2), d);
  EXPECT_TRUE(absl::ParseDuration("2h", &d));
  EXPECT_EQ(absl::Hours(2), d);

  // Huge counts of a unit.
  EXPECT_TRUE(absl::ParseDuration("9223372036854775807us", &d));
  EXPECT_EQ(absl::Microseconds(9223372036854775807), d);
  EXPECT_TRUE(absl::ParseDuration("-9223372036854775807us", &d));
  EXPECT_EQ(absl::Microseconds(-9223372036854775807), d);

  // Multiple units.
  EXPECT_TRUE(absl::ParseDuration("2h3m4s", &d));
  EXPECT_EQ(absl::Hours(2) + absl::Minutes(3) + absl::Seconds(4), d);
  EXPECT_TRUE(absl::ParseDuration("3m4s5us", &d));
  EXPECT_EQ(absl::Minutes(3) + absl::Seconds(4) + absl::Microseconds(5), d);
  EXPECT_TRUE(absl::ParseDuration("2h3m4s5ms6us7ns", &d));
  EXPECT_EQ(absl::Hours(2) + absl::Minutes(3) + absl::Seconds(4) +
                absl::Milliseconds(5) + absl::Microseconds(6) +
                absl::Nanoseconds(7),
            d);

  // Multiple units out of order.
  EXPECT_TRUE(absl::ParseDuration("2us3m4s5h", &d));
  EXPECT_EQ(absl::Hours(5) + absl::Minutes(3) + absl::Seconds(4) +
                absl::Microseconds(2),
            d);

  // Fractional values of units.
  EXPECT_TRUE(absl::ParseDuration("1.5ns", &d));
  EXPECT_EQ(1.5 * absl::Nanoseconds(1), d);
  EXPECT_TRUE(absl::ParseDuration("1.5us", &d));
  EXPECT_EQ(1.5 * absl::Microseconds(1), d);
  EXPECT_TRUE(absl::ParseDuration("1.5ms", &d));
  EXPECT_EQ(1.5 * absl::Milliseconds(1), d);
  EXPECT_TRUE(absl::ParseDuration("1.5s", &d));
  EXPECT_EQ(1.5 * absl::Seconds(1), d);
  EXPECT_TRUE(absl::ParseDuration("1.5m", &d));
  EXPECT_EQ(1.5 * absl::Minutes(1), d);
  EXPECT_TRUE(absl::ParseDuration("1.5h", &d));
  EXPECT_EQ(1.5 * absl::Hours(1), d);

  // Huge fractional counts of a unit.
  EXPECT_TRUE(absl::ParseDuration("0.4294967295s", &d));
  EXPECT_EQ(absl::Nanoseconds(429496729) + absl::Nanoseconds(1) / 2, d);
  EXPECT_TRUE(absl::ParseDuration("0.429496729501234567890123456789s", &d));
  EXPECT_EQ(absl::Nanoseconds(429496729) + absl::Nanoseconds(1) / 2, d);

  // Negative durations.
  EXPECT_TRUE(absl::ParseDuration("-1s", &d));
  EXPECT_EQ(absl::Seconds(-1), d);
  EXPECT_TRUE(absl::ParseDuration("-1m", &d));
  EXPECT_EQ(absl::Minutes(-1), d);
  EXPECT_TRUE(absl::ParseDuration("-1h", &d));
  EXPECT_EQ(absl::Hours(-1), d);

  EXPECT_TRUE(absl::ParseDuration("-1h2s", &d));
  EXPECT_EQ(-(absl::Hours(1) + absl::Seconds(2)), d);
  EXPECT_FALSE(absl::ParseDuration("1h-2s", &d));
  EXPECT_FALSE(absl::ParseDuration("-1h-2s", &d));
  EXPECT_FALSE(absl::ParseDuration("-1h -2s", &d));
}

TEST(Duration, FormatParseRoundTrip) {
#define TEST_PARSE_ROUNDTRIP(d)                \
  do {                                         \
    std::string s = absl::FormatDuration(d);   \
    absl::Duration dur;                        \
    EXPECT_TRUE(absl::ParseDuration(s, &dur)); \
    EXPECT_EQ(d, dur);                         \
  } while (0)

  TEST_PARSE_ROUNDTRIP(absl::Nanoseconds(1));
  TEST_PARSE_ROUNDTRIP(absl::Microseconds(1));
  TEST_PARSE_ROUNDTRIP(absl::Milliseconds(1));
  TEST_PARSE_ROUNDTRIP(absl::Seconds(1));
  TEST_PARSE_ROUNDTRIP(absl::Minutes(1));
  TEST_PARSE_ROUNDTRIP(absl::Hours(1));
  TEST_PARSE_ROUNDTRIP(absl::Hours(1) + absl::Nanoseconds(2));

  TEST_PARSE_ROUNDTRIP(absl::Nanoseconds(-1));
  TEST_PARSE_ROUNDTRIP(absl::Microseconds(-1));
  TEST_PARSE_ROUNDTRIP(absl::Milliseconds(-1));
  TEST_PARSE_ROUNDTRIP(absl::Seconds(-1));
  TEST_PARSE_ROUNDTRIP(absl::Minutes(-1));
  TEST_PARSE_ROUNDTRIP(absl::Hours(-1));

  TEST_PARSE_ROUNDTRIP(absl::Hours(-1) + absl::Nanoseconds(2));
  TEST_PARSE_ROUNDTRIP(absl::Hours(1) + absl::Nanoseconds(-2));
  TEST_PARSE_ROUNDTRIP(absl::Hours(-1) + absl::Nanoseconds(-2));

  TEST_PARSE_ROUNDTRIP(absl::Nanoseconds(1) +
                       absl::Nanoseconds(1) / 4);  // 1.25ns

  const absl::Duration huge_range = ApproxYears(100000000000);
  TEST_PARSE_ROUNDTRIP(huge_range);
  TEST_PARSE_ROUNDTRIP(huge_range + (absl::Seconds(1) - absl::Nanoseconds(1)));

#undef TEST_PARSE_ROUNDTRIP
}

TEST(Duration, AbslStringify) {
  // FormatDuration is already well tested, so just use one test case here to
  // verify that StrFormat("%v", d) works as expected.
  absl::Duration d = absl::Seconds(1);
  EXPECT_EQ(absl::StrFormat("%v", d), absl::FormatDuration(d));
}

TEST(Duration, NoPadding) {
  // Should match the size of a struct with uint32_t alignment and no padding.
  using NoPadding = std::array<uint32_t, 3>;
  EXPECT_EQ(sizeof(NoPadding), sizeof(absl::Duration));
  EXPECT_EQ(alignof(NoPadding), alignof(absl::Duration));
}

}  // namespace
                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/flag_test.cc                                   0000664 0000000 0000000 00000014526 14746647661 0024563 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "absl/flags/flag.h"

#include <string>

#include "gtest/gtest.h"
#include "absl/flags/reflection.h"
#include "absl/time/civil_time.h"
#include "absl/time/time.h"

ABSL_FLAG(absl::CivilSecond, test_flag_civil_second,
          absl::CivilSecond(2015, 1, 2, 3, 4, 5), "");
ABSL_FLAG(absl::CivilMinute, test_flag_civil_minute,
          absl::CivilMinute(2015, 1, 2, 3, 4), "");
ABSL_FLAG(absl::CivilHour, test_flag_civil_hour, absl::CivilHour(2015, 1, 2, 3),
          "");
ABSL_FLAG(absl::CivilDay, test_flag_civil_day, absl::CivilDay(2015, 1, 2), "");
ABSL_FLAG(absl::CivilMonth, test_flag_civil_month, absl::CivilMonth(2015, 1),
          "");
ABSL_FLAG(absl::CivilYear, test_flag_civil_year, absl::CivilYear(2015), "");

ABSL_FLAG(absl::Duration, test_duration_flag, absl::Seconds(5),
          "For testing support for Duration flags");
ABSL_FLAG(absl::Time, test_time_flag, absl::InfinitePast(),
          "For testing support for Time flags");

namespace {

bool SetFlagValue(absl::string_view flag_name, absl::string_view value) {
  auto* flag = absl::FindCommandLineFlag(flag_name);
  if (!flag) return false;
  std::string err;
  return flag->ParseFrom(value, &err);
}

bool GetFlagValue(absl::string_view flag_name, std::string& value) {
  auto* flag = absl::FindCommandLineFlag(flag_name);
  if (!flag) return false;
  value = flag->CurrentValue();
  return true;
}

TEST(CivilTime, FlagSupport) {
  // Tests the default setting of the flags.
  const absl::CivilSecond kDefaultSec(2015, 1, 2, 3, 4, 5);
  EXPECT_EQ(absl::CivilSecond(kDefaultSec),
            absl::GetFlag(FLAGS_test_flag_civil_second));
  EXPECT_EQ(absl::CivilMinute(kDefaultSec),
            absl::GetFlag(FLAGS_test_flag_civil_minute));
  EXPECT_EQ(absl::CivilHour(kDefaultSec),
            absl::GetFlag(FLAGS_test_flag_civil_hour));
  EXPECT_EQ(absl::CivilDay(kDefaultSec),
            absl::GetFlag(FLAGS_test_flag_civil_day));
  EXPECT_EQ(absl::CivilMonth(kDefaultSec),
            absl::GetFlag(FLAGS_test_flag_civil_month));
  EXPECT_EQ(absl::CivilYear(kDefaultSec),
            absl::GetFlag(FLAGS_test_flag_civil_year));

  // Sets flags to a new value.
  const absl::CivilSecond kNewSec(2016, 6, 7, 8, 9, 10);
  absl::SetFlag(&FLAGS_test_flag_civil_second, absl::CivilSecond(kNewSec));
  absl::SetFlag(&FLAGS_test_flag_civil_minute, absl::CivilMinute(kNewSec));
  absl::SetFlag(&FLAGS_test_flag_civil_hour, absl::CivilHour(kNewSec));
  absl::SetFlag(&FLAGS_test_flag_civil_day, absl::CivilDay(kNewSec));
  absl::SetFlag(&FLAGS_test_flag_civil_month, absl::CivilMonth(kNewSec));
  absl::SetFlag(&FLAGS_test_flag_civil_year, absl::CivilYear(kNewSec));

  EXPECT_EQ(absl::CivilSecond(kNewSec),
            absl::GetFlag(FLAGS_test_flag_civil_second));
  EXPECT_EQ(absl::CivilMinute(kNewSec),
            absl::GetFlag(FLAGS_test_flag_civil_minute));
  EXPECT_EQ(absl::CivilHour(kNewSec),
            absl::GetFlag(FLAGS_test_flag_civil_hour));
  EXPECT_EQ(absl::CivilDay(kNewSec), absl::GetFlag(FLAGS_test_flag_civil_day));
  EXPECT_EQ(absl::CivilMonth(kNewSec),
            absl::GetFlag(FLAGS_test_flag_civil_month));
  EXPECT_EQ(absl::CivilYear(kNewSec),
            absl::GetFlag(FLAGS_test_flag_civil_year));
}

TEST(Duration, FlagSupport) {
  EXPECT_EQ(absl::Seconds(5), absl::GetFlag(FLAGS_test_duration_flag));

  absl::SetFlag(&FLAGS_test_duration_flag, absl::Seconds(10));
  EXPECT_EQ(absl::Seconds(10), absl::GetFlag(FLAGS_test_duration_flag));

  EXPECT_TRUE(SetFlagValue("test_duration_flag", "20s"));
  EXPECT_EQ(absl::Seconds(20), absl::GetFlag(FLAGS_test_duration_flag));

  std::string current_flag_value;
  EXPECT_TRUE(GetFlagValue("test_duration_flag", current_flag_value));
  EXPECT_EQ("20s", current_flag_value);
}

TEST(Time, FlagSupport) {
  EXPECT_EQ(absl::InfinitePast(), absl::GetFlag(FLAGS_test_time_flag));

  const absl::Time t = absl::FromCivil(absl::CivilSecond(2016, 1, 2, 3, 4, 5),
                                       absl::UTCTimeZone());
  absl::SetFlag(&FLAGS_test_time_flag, t);
  EXPECT_EQ(t, absl::GetFlag(FLAGS_test_time_flag));

  // Successful parse
  EXPECT_TRUE(SetFlagValue("test_time_flag", "2016-01-02T03:04:06Z"));
  EXPECT_EQ(t + absl::Seconds(1), absl::GetFlag(FLAGS_test_time_flag));
  EXPECT_TRUE(SetFlagValue("test_time_flag", "2016-01-02T03:04:07.0Z"));
  EXPECT_EQ(t + absl::Seconds(2), absl::GetFlag(FLAGS_test_time_flag));
  EXPECT_TRUE(SetFlagValue("test_time_flag", "2016-01-02T03:04:08.000Z"));
  EXPECT_EQ(t + absl::Seconds(3), absl::GetFlag(FLAGS_test_time_flag));
  EXPECT_TRUE(SetFlagValue("test_time_flag", "2016-01-02T03:04:09+00:00"));
  EXPECT_EQ(t + absl::Seconds(4), absl::GetFlag(FLAGS_test_time_flag));
  EXPECT_TRUE(SetFlagValue("test_time_flag", "2016-01-02T03:04:05.123+00:00"));
  EXPECT_EQ(t + absl::Milliseconds(123), absl::GetFlag(FLAGS_test_time_flag));
  EXPECT_TRUE(SetFlagValue("test_time_flag", "2016-01-02T03:04:05.123+08:00"));
  EXPECT_EQ(t + absl::Milliseconds(123) - absl::Hours(8),
            absl::GetFlag(FLAGS_test_time_flag));
  EXPECT_TRUE(SetFlagValue("test_time_flag", "infinite-future"));
  EXPECT_EQ(absl::InfiniteFuture(), absl::GetFlag(FLAGS_test_time_flag));
  EXPECT_TRUE(SetFlagValue("test_time_flag", "infinite-past"));
  EXPECT_EQ(absl::InfinitePast(), absl::GetFlag(FLAGS_test_time_flag));

  EXPECT_FALSE(SetFlagValue("test_time_flag", "2016-01-02T03:04:06"));
  EXPECT_FALSE(SetFlagValue("test_time_flag", "2016-01-02"));
  EXPECT_FALSE(SetFlagValue("test_time_flag", "2016-01-02Z"));
  EXPECT_FALSE(SetFlagValue("test_time_flag", "2016-01-02+00:00"));
  EXPECT_FALSE(SetFlagValue("test_time_flag", "2016-99-99T03:04:06Z"));

  EXPECT_TRUE(SetFlagValue("test_time_flag", "2016-01-02T03:04:05Z"));
  std::string current_flag_value;
  EXPECT_TRUE(GetFlagValue("test_time_flag", current_flag_value));
  EXPECT_EQ("2016-01-02T03:04:05+00:00", current_flag_value);
}

}  // namespace
                                                                                                                                                                          node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/format.cc                                      0000664 0000000 0000000 00000012433 14746647661 0024076 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <string.h>

#include <cctype>
#include <cstdint>
#include <utility>

#include "absl/strings/match.h"
#include "absl/strings/string_view.h"
#include "absl/time/internal/cctz/include/cctz/time_zone.h"
#include "absl/time/time.h"

namespace cctz = absl::time_internal::cctz;

namespace absl {
ABSL_NAMESPACE_BEGIN

ABSL_DLL extern const char RFC3339_full[] = "%Y-%m-%d%ET%H:%M:%E*S%Ez";
ABSL_DLL extern const char RFC3339_sec[] = "%Y-%m-%d%ET%H:%M:%S%Ez";

ABSL_DLL extern const char RFC1123_full[] = "%a, %d %b %E4Y %H:%M:%S %z";
ABSL_DLL extern const char RFC1123_no_wday[] = "%d %b %E4Y %H:%M:%S %z";

namespace {

const char kInfiniteFutureStr[] = "infinite-future";
const char kInfinitePastStr[] = "infinite-past";

struct cctz_parts {
  cctz::time_point<cctz::seconds> sec;
  cctz::detail::femtoseconds fem;
};

inline cctz::time_point<cctz::seconds> unix_epoch() {
  return std::chrono::time_point_cast<cctz::seconds>(
      std::chrono::system_clock::from_time_t(0));
}

// Splits a Time into seconds and femtoseconds, which can be used with CCTZ.
// Requires that 't' is finite. See duration.cc for details about rep_hi and
// rep_lo.
cctz_parts Split(absl::Time t) {
  const auto d = time_internal::ToUnixDuration(t);
  const int64_t rep_hi = time_internal::GetRepHi(d);
  const int64_t rep_lo = time_internal::GetRepLo(d);
  const auto sec = unix_epoch() + cctz::seconds(rep_hi);
  const auto fem = cctz::detail::femtoseconds(rep_lo * (1000 * 1000 / 4));
  return {sec, fem};
}

// Joins the given seconds and femtoseconds into a Time. See duration.cc for
// details about rep_hi and rep_lo.
absl::Time Join(const cctz_parts& parts) {
  const int64_t rep_hi = (parts.sec - unix_epoch()).count();
  const uint32_t rep_lo =
      static_cast<uint32_t>(parts.fem.count() / (1000 * 1000 / 4));
  const auto d = time_internal::MakeDuration(rep_hi, rep_lo);
  return time_internal::FromUnixDuration(d);
}

}  // namespace

std::string FormatTime(absl::string_view format, absl::Time t,
                       absl::TimeZone tz) {
  if (t == absl::InfiniteFuture()) return std::string(kInfiniteFutureStr);
  if (t == absl::InfinitePast()) return std::string(kInfinitePastStr);
  const auto parts = Split(t);
  return cctz::detail::format(std::string(format), parts.sec, parts.fem,
                              cctz::time_zone(tz));
}

std::string FormatTime(absl::Time t, absl::TimeZone tz) {
  return FormatTime(RFC3339_full, t, tz);
}

std::string FormatTime(absl::Time t) {
  return absl::FormatTime(RFC3339_full, t, absl::LocalTimeZone());
}

bool ParseTime(absl::string_view format, absl::string_view input,
               absl::Time* time, std::string* err) {
  return absl::ParseTime(format, input, absl::UTCTimeZone(), time, err);
}

// If the input string does not contain an explicit UTC offset, interpret
// the fields with respect to the given TimeZone.
bool ParseTime(absl::string_view format, absl::string_view input,
               absl::TimeZone tz, absl::Time* time, std::string* err) {
  auto strip_leading_space = [](absl::string_view* sv) {
    while (!sv->empty()) {
      if (!std::isspace(sv->front())) return;
      sv->remove_prefix(1);
    }
  };

  // Portable toolchains means we don't get nice constexpr here.
  struct Literal {
    const char* name;
    size_t size;
    absl::Time value;
  };
  static Literal literals[] = {
      {kInfiniteFutureStr, strlen(kInfiniteFutureStr), InfiniteFuture()},
      {kInfinitePastStr, strlen(kInfinitePastStr), InfinitePast()},
  };
  strip_leading_space(&input);
  for (const auto& lit : literals) {
    if (absl::StartsWith(input, absl::string_view(lit.name, lit.size))) {
      absl::string_view tail = input;
      tail.remove_prefix(lit.size);
      strip_leading_space(&tail);
      if (tail.empty()) {
        *time = lit.value;
        return true;
      }
    }
  }

  std::string error;
  cctz_parts parts;
  const bool b =
      cctz::detail::parse(std::string(format), std::string(input),
                          cctz::time_zone(tz), &parts.sec, &parts.fem, &error);
  if (b) {
    *time = Join(parts);
  } else if (err != nullptr) {
    *err = std::move(error);
  }
  return b;
}

// Functions required to support absl::Time flags.
bool AbslParseFlag(absl::string_view text, absl::Time* t, std::string* error) {
  return absl::ParseTime(RFC3339_full, text, absl::UTCTimeZone(), t, error);
}

std::string AbslUnparseFlag(absl::Time t) {
  return absl::FormatTime(RFC3339_full, t, absl::UTCTimeZone());
}
bool ParseFlag(const std::string& text, absl::Time* t, std::string* error) {
  return absl::ParseTime(RFC3339_full, text, absl::UTCTimeZone(), t, error);
}

std::string UnparseFlag(absl::Time t) {
  return absl::FormatTime(RFC3339_full, t, absl::UTCTimeZone());
}

ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                     node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/format_benchmark.cc                            0000664 0000000 0000000 00000004233 14746647661 0026107 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2018 The Abseil Authors.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <cstddef>
#include <string>

#include "absl/time/internal/test_util.h"
#include "absl/time/time.h"
#include "benchmark/benchmark.h"

namespace {

namespace {
const char* const kFormats[] = {
    absl::RFC1123_full,     // 0
    absl::RFC1123_no_wday,  // 1
    absl::RFC3339_full,     // 2
    absl::RFC3339_sec,      // 3
    "%Y-%m-%d%ET%H:%M:%S",  // 4
    "%Y-%m-%d",             // 5
};
const int kNumFormats = sizeof(kFormats) / sizeof(kFormats[0]);
}  // namespace

void BM_Format_FormatTime(benchmark::State& state) {
  const std::string fmt = kFormats[state.range(0)];
  state.SetLabel(fmt);
  const absl::TimeZone lax =
      absl::time_internal::LoadTimeZone("America/Los_Angeles");
  const absl::Time t =
      absl::FromCivil(absl::CivilSecond(1977, 6, 28, 9, 8, 7), lax) +
      absl::Nanoseconds(1);
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::FormatTime(fmt, t, lax).length());
  }
}
BENCHMARK(BM_Format_FormatTime)->DenseRange(0, kNumFormats - 1);

void BM_Format_ParseTime(benchmark::State& state) {
  const std::string fmt = kFormats[state.range(0)];
  state.SetLabel(fmt);
  const absl::TimeZone lax =
      absl::time_internal::LoadTimeZone("America/Los_Angeles");
  absl::Time t = absl::FromCivil(absl::CivilSecond(1977, 6, 28, 9, 8, 7), lax) +
                 absl::Nanoseconds(1);
  const std::string when = absl::FormatTime(fmt, t, lax);
  std::string err;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(absl::ParseTime(fmt, when, lax, &t, &err));
  }
}
BENCHMARK(BM_Format_ParseTime)->DenseRange(0, kNumFormats - 1);

}  // namespace
                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/format_test.cc                                 0000664 0000000 0000000 00000040566 14746647661 0025145 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2017 The Abseil Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include <cstdint>
#include <limits>
#include <string>

#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "absl/time/internal/test_util.h"
#include "absl/time/time.h"

using testing::HasSubstr;

namespace {

// A helper that tests the given format specifier by itself, and with leading
// and trailing characters.  For example: TestFormatSpecifier(t, "%a", "Thu").
void TestFormatSpecifier(absl::Time t, absl::TimeZone tz,
                         const std::string& fmt, const std::string& ans) {
  EXPECT_EQ(ans, absl::FormatTime(fmt, t, tz));
  EXPECT_EQ("xxx " + ans, absl::FormatTime("xxx " + fmt, t, tz));
  EXPECT_EQ(ans + " yyy", absl::FormatTime(fmt + " yyy", t, tz));
  EXPECT_EQ("xxx " + ans + " yyy",
            absl::FormatTime("xxx " + fmt + " yyy", t, tz));
}

//
// Testing FormatTime()
//

TEST(FormatTime, Basics) {
  absl::TimeZone tz = absl::UTCTimeZone();
  absl::Time t = absl::FromTimeT(0);

  // Starts with a couple basic edge cases.
  EXPECT_EQ("", absl::FormatTime("", t, tz));
  EXPECT_EQ(" ", absl::FormatTime(" ", t, tz));
  EXPECT_EQ("  ", absl::FormatTime("  ", t, tz));
  EXPECT_EQ("xxx", absl::FormatTime("xxx", t, tz));
  std::string big(128, 'x');
  EXPECT_EQ(big, absl::FormatTime(big, t, tz));
  // Cause the 1024-byte buffer to grow.
  std::string bigger(100000, 'x');
  EXPECT_EQ(bigger, absl::FormatTime(bigger, t, tz));

  t += absl::Hours(13) + absl::Minutes(4) + absl::Seconds(5);
  t += absl::Milliseconds(6) + absl::Microseconds(7) + absl::Nanoseconds(8);
  EXPECT_EQ("1970-01-01", absl::FormatTime("%Y-%m-%d", t, tz));
  EXPECT_EQ("13:04:05", absl::FormatTime("%H:%M:%S", t, tz));
  EXPECT_EQ("13:04:05.006", absl::FormatTime("%H:%M:%E3S", t, tz));
  EXPECT_EQ("13:04:05.006007", absl::FormatTime("%H:%M:%E6S", t, tz));
  EXPECT_EQ("13:04:05.006007008", absl::FormatTime("%H:%M:%E9S", t, tz));
}

TEST(FormatTime, LocaleSpecific) {
  const absl::TimeZone tz = absl::UTCTimeZone();
  absl::Time t = absl::FromTimeT(0);

  TestFormatSpecifier(t, tz, "%a", "Thu");
  TestFormatSpecifier(t, tz, "%A", "Thursday");
  TestFormatSpecifier(t, tz, "%b", "Jan");
  TestFormatSpecifier(t, tz, "%B", "January");

  // %c should at least produce the numeric year and time-of-day.
  const std::string s =
      absl::FormatTime("%c", absl::FromTimeT(0), absl::UTCTimeZone());
  EXPECT_THAT(s, HasSubstr("1970"));
  EXPECT_THAT(s, HasSubstr("00:00:00"));

  TestFormatSpecifier(t, tz, "%p", "AM");
  TestFormatSpecifier(t, tz, "%x", "01/01/70");
  TestFormatSpecifier(t, tz, "%X", "00:00:00");
}

TEST(FormatTime, ExtendedSeconds) {
  const absl::TimeZone tz = absl::UTCTimeZone();

  // No subseconds.
  absl::Time t = absl::FromTimeT(0) + absl::Seconds(5);
  EXPECT_EQ("05", absl::FormatTime("%E*S", t, tz));
  EXPECT_EQ("05.000000000000000", absl::FormatTime("%E15S", t, tz));

  // With subseconds.
  t += absl::Milliseconds(6) + absl::Microseconds(7) + absl::Nanoseconds(8);
  EXPECT_EQ("05.006007008", absl::FormatTime("%E*S", t, tz));
  EXPECT_EQ("05", absl::FormatTime("%E0S", t, tz));
  EXPECT_EQ("05.006007008000000", absl::FormatTime("%E15S", t, tz));

  // Times before the Unix epoch.
  t = absl::FromUnixMicros(-1);
  EXPECT_EQ("1969-12-31 23:59:59.999999",
            absl::FormatTime("%Y-%m-%d %H:%M:%E*S", t, tz));

  // Here is a "%E*S" case we got wrong for a while.  While the first
  // instant below is correctly rendered as "...:07.333304", the second
  // one used to appear as "...:07.33330499999999999".
  t = absl::FromUnixMicros(1395024427333304);
  EXPECT_EQ("2014-03-17 02:47:07.333304",
            absl::FormatTime("%Y-%m-%d %H:%M:%E*S", t, tz));
  t += absl::Microseconds(1);
  EXPECT_EQ("2014-03-17 02:47:07.333305",
            absl::FormatTime("%Y-%m-%d %H:%M:%E*S", t, tz));
}

TEST(FormatTime, RFC1123FormatPadsYear) {  // locale specific
  absl::TimeZone tz = absl::UTCTimeZone();

  // A year of 77 should be padded to 0077.
  absl::Time t = absl::FromCivil(absl::CivilSecond(77, 6, 28, 9, 8, 7), tz);
  EXPECT_EQ("Mon, 28 Jun 0077 09:08:07 +0000",
            absl::FormatTime(absl::RFC1123_full, t, tz));
  EXPECT_EQ("28 Jun 0077 09:08:07 +0000",
            absl::FormatTime(absl::RFC1123_no_wday, t, tz));
}

TEST(FormatTime, InfiniteTime) {
  absl::TimeZone tz = absl::time_internal::LoadTimeZone("America/Los_Angeles");

  // The format and timezone are ignored.
  EXPECT_EQ("infinite-future",
            absl::FormatTime("%H:%M blah", absl::InfiniteFuture(), tz));
  EXPECT_EQ("infinite-past",
            absl::FormatTime("%H:%M blah", absl::InfinitePast(), tz));
}

//
// Testing ParseTime()
//

TEST(ParseTime, Basics) {
  absl::Time t = absl::FromTimeT(1234567890);
  std::string err;

  // Simple edge cases.
  EXPECT_TRUE(absl::ParseTime("", "", &t, &err)) << err;
  EXPECT_EQ(absl::UnixEpoch(), t);  // everything defaulted
  EXPECT_TRUE(absl::ParseTime(" ", " ", &t, &err)) << err;
  EXPECT_TRUE(absl::ParseTime("  ", "  ", &t, &err)) << err;
  EXPECT_TRUE(absl::ParseTime("x", "x", &t, &err)) << err;
  EXPECT_TRUE(absl::ParseTime("xxx", "xxx", &t, &err)) << err;

  EXPECT_TRUE(absl::ParseTime("%Y-%m-%d %H:%M:%S %z",
                              "2013-06-28 19:08:09 -0800", &t, &err))
      << err;
  const auto ci = absl::FixedTimeZone(-8 * 60 * 60).At(t);
  EXPECT_EQ(absl::CivilSecond(2013, 6, 28, 19, 8, 9), ci.cs);
  EXPECT_EQ(absl::ZeroDuration(), ci.subsecond);
}

TEST(ParseTime, NullErrorString) {
  absl::Time t;
  EXPECT_FALSE(absl::ParseTime("%Q", "invalid format", &t, nullptr));
  EXPECT_FALSE(absl::ParseTime("%H", "12 trailing data", &t, nullptr));
  EXPECT_FALSE(
      absl::ParseTime("%H out of range", "42 out of range", &t, nullptr));
}

TEST(ParseTime, WithTimeZone) {
  const absl::TimeZone tz =
      absl::time_internal::LoadTimeZone("America/Los_Angeles");
  absl::Time t;
  std::string e;

  // We can parse a string without a UTC offset if we supply a timezone.
  EXPECT_TRUE(
      absl::ParseTime("%Y-%m-%d %H:%M:%S", "2013-06-28 19:08:09", tz, &t, &e))
      << e;
  auto ci = tz.At(t);
  EXPECT_EQ(absl::CivilSecond(2013, 6, 28, 19, 8, 9), ci.cs);
  EXPECT_EQ(absl::ZeroDuration(), ci.subsecond);

  // But the timezone is ignored when a UTC offset is present.
  EXPECT_TRUE(absl::ParseTime("%Y-%m-%d %H:%M:%S %z",
                              "2013-06-28 19:08:09 +0800", tz, &t, &e))
      << e;
  ci = absl::FixedTimeZone(8 * 60 * 60).At(t);
  EXPECT_EQ(absl::CivilSecond(2013, 6, 28, 19, 8, 9), ci.cs);
  EXPECT_EQ(absl::ZeroDuration(), ci.subsecond);
}

TEST(ParseTime, ErrorCases) {
  absl::Time t = absl::FromTimeT(0);
  std::string err;

  EXPECT_FALSE(absl::ParseTime("%S", "123", &t, &err)) << err;
  EXPECT_THAT(err, HasSubstr("Illegal trailing data"));

  // Can't parse an illegal format specifier.
  err.clear();
  EXPECT_FALSE(absl::ParseTime("%Q", "x", &t, &err)) << err;
  // Exact contents of "err" are platform-dependent because of
  // differences in the strptime implementation between macOS and Linux.
  EXPECT_FALSE(err.empty());

  // Fails because of trailing, unparsed data "blah".
  EXPECT_FALSE(absl::ParseTime("%m-%d", "2-3 blah", &t, &err)) << err;
  EXPECT_THAT(err, HasSubstr("Illegal trailing data"));

  // Feb 31 requires normalization.
  EXPECT_FALSE(absl::ParseTime("%m-%d", "2-31", &t, &err)) << err;
  EXPECT_THAT(err, HasSubstr("Out-of-range"));

  // Check that we cannot have spaces in UTC offsets.
  EXPECT_TRUE(absl::ParseTime("%z", "-0203", &t, &err)) << err;
  EXPECT_FALSE(absl::ParseTime("%z", "- 2 3", &t, &err)) << err;
  EXPECT_THAT(err, HasSubstr("Failed to parse"));
  EXPECT_TRUE(absl::ParseTime("%Ez", "-02:03", &t, &err)) << err;
  EXPECT_FALSE(absl::ParseTime("%Ez", "- 2: 3", &t, &err)) << err;
  EXPECT_THAT(err, HasSubstr("Failed to parse"));

  // Check that we reject other malformed UTC offsets.
  EXPECT_FALSE(absl::ParseTime("%Ez", "+-08:00", &t, &err)) << err;
  EXPECT_THAT(err, HasSubstr("Failed to parse"));
  EXPECT_FALSE(absl::ParseTime("%Ez", "-+08:00", &t, &err)) << err;
  EXPECT_THAT(err, HasSubstr("Failed to parse"));

  // Check that we do not accept "-0" in fields that allow zero.
  EXPECT_FALSE(absl::ParseTime("%Y", "-0", &t, &err)) << err;
  EXPECT_THAT(err, HasSubstr("Failed to parse"));
  EXPECT_FALSE(absl::ParseTime("%E4Y", "-0", &t, &err)) << err;
  EXPECT_THAT(err, HasSubstr("Failed to parse"));
  EXPECT_FALSE(absl::ParseTime("%H", "-0", &t, &err)) << err;
  EXPECT_THAT(err, HasSubstr("Failed to parse"));
  EXPECT_FALSE(absl::ParseTime("%M", "-0", &t, &err)) << err;
  EXPECT_THAT(err, HasSubstr("Failed to parse"));
  EXPECT_FALSE(absl::ParseTime("%S", "-0", &t, &err)) << err;
  EXPECT_THAT(err, HasSubstr("Failed to parse"));
  EXPECT_FALSE(absl::ParseTime("%z", "+-000", &t, &err)) << err;
  EXPECT_THAT(err, HasSubstr("Failed to parse"));
  EXPECT_FALSE(absl::ParseTime("%Ez", "+-0:00", &t, &err)) << err;
  EXPECT_THAT(err, HasSubstr("Failed to parse"));
  EXPECT_FALSE(absl::ParseTime("%z", "-00-0", &t, &err)) << err;
  EXPECT_THAT(err, HasSubstr("Illegal trailing data"));
  EXPECT_FALSE(absl::ParseTime("%Ez", "-00:-0", &t, &err)) << err;
  EXPECT_THAT(err, HasSubstr("Illegal trailing data"));
}

TEST(ParseTime, ExtendedSeconds) {
  std::string err;
  absl::Time t;

  // Here is a "%E*S" case we got wrong for a while.  The fractional
  // part of the first instant is less than 2^31 and was correctly
  // parsed, while the second (and any subsecond field >=2^31) failed.
  t = absl::UnixEpoch();
  EXPECT_TRUE(absl::ParseTime("%E*S", "0.2147483647", &t, &err)) << err;
  EXPECT_EQ(absl::UnixEpoch() + absl::Nanoseconds(214748364) +
                absl::Nanoseconds(1) / 2,
            t);
  t = absl::UnixEpoch();
  EXPECT_TRUE(absl::ParseTime("%E*S", "0.2147483648", &t, &err)) << err;
  EXPECT_EQ(absl::UnixEpoch() + absl::Nanoseconds(214748364) +
                absl::Nanoseconds(3) / 4,
            t);

  // We should also be able to specify long strings of digits far
  // beyond the current resolution and have them convert the same way.
  t = absl::UnixEpoch();
  EXPECT_TRUE(absl::ParseTime(
      "%E*S", "0.214748364801234567890123456789012345678901234567890123456789",
      &t, &err))
      << err;
  EXPECT_EQ(absl::UnixEpoch() + absl::Nanoseconds(214748364) +
                absl::Nanoseconds(3) / 4,
            t);
}

TEST(ParseTime, ExtendedOffsetErrors) {
  std::string err;
  absl::Time t;

  // %z against +-HHMM.
  EXPECT_FALSE(absl::ParseTime("%z", "-123", &t, &err)) << err;
  EXPECT_THAT(err, HasSubstr("Illegal trailing data"));

  // %z against +-HH.
  EXPECT_FALSE(absl::ParseTime("%z", "-1", &t, &err)) << err;
  EXPECT_THAT(err, HasSubstr("Failed to parse"));

  // %Ez against +-HH:MM.
  EXPECT_FALSE(absl::ParseTime("%Ez", "-12:3", &t, &err)) << err;
  EXPECT_THAT(err, HasSubstr("Illegal trailing data"));

  // %Ez against +-HHMM.
  EXPECT_FALSE(absl::ParseTime("%Ez", "-123", &t, &err)) << err;
  EXPECT_THAT(err, HasSubstr("Illegal trailing data"));

  // %Ez against +-HH.
  EXPECT_FALSE(absl::ParseTime("%Ez", "-1", &t, &err)) << err;
  EXPECT_THAT(err, HasSubstr("Failed to parse"));
}

TEST(ParseTime, InfiniteTime) {
  absl::Time t;
  std::string err;
  EXPECT_TRUE(absl::ParseTime("%H:%M blah", "infinite-future", &t, &err));
  EXPECT_EQ(absl::InfiniteFuture(), t);

  // Surrounding whitespace.
  EXPECT_TRUE(absl::ParseTime("%H:%M blah", "  infinite-future", &t, &err));
  EXPECT_EQ(absl::InfiniteFuture(), t);
  EXPECT_TRUE(absl::ParseTime("%H:%M blah", "infinite-future  ", &t, &err));
  EXPECT_EQ(absl::InfiniteFuture(), t);
  EXPECT_TRUE(absl::ParseTime("%H:%M blah", "  infinite-future  ", &t, &err));
  EXPECT_EQ(absl::InfiniteFuture(), t);

  EXPECT_TRUE(absl::ParseTime("%H:%M blah", "infinite-past", &t, &err));
  EXPECT_EQ(absl::InfinitePast(), t);

  // Surrounding whitespace.
  EXPECT_TRUE(absl::ParseTime("%H:%M blah", "  infinite-past", &t, &err));
  EXPECT_EQ(absl::InfinitePast(), t);
  EXPECT_TRUE(absl::ParseTime("%H:%M blah", "infinite-past  ", &t, &err));
  EXPECT_EQ(absl::InfinitePast(), t);
  EXPECT_TRUE(absl::ParseTime("%H:%M blah", "  infinite-past  ", &t, &err));
  EXPECT_EQ(absl::InfinitePast(), t);

  // "infinite-future" as literal string
  absl::TimeZone tz = absl::UTCTimeZone();
  EXPECT_TRUE(absl::ParseTime("infinite-future %H:%M", "infinite-future 03:04",
                              &t, &err));
  EXPECT_NE(absl::InfiniteFuture(), t);
  EXPECT_EQ(3, tz.At(t).cs.hour());
  EXPECT_EQ(4, tz.At(t).cs.minute());

  // "infinite-past" as literal string
  EXPECT_TRUE(
      absl::ParseTime("infinite-past %H:%M", "infinite-past 03:04", &t, &err));
  EXPECT_NE(absl::InfinitePast(), t);
  EXPECT_EQ(3, tz.At(t).cs.hour());
  EXPECT_EQ(4, tz.At(t).cs.minute());

  // The input doesn't match the format.
  EXPECT_FALSE(absl::ParseTime("infinite-future %H:%M", "03:04", &t, &err));
  EXPECT_FALSE(absl::ParseTime("infinite-past %H:%M", "03:04", &t, &err));
}

TEST(ParseTime, FailsOnUnrepresentableTime) {
  const absl::TimeZone utc = absl::UTCTimeZone();
  absl::Time t;
  EXPECT_FALSE(
      absl::ParseTime("%Y-%m-%d", "-292277022657-01-27", utc, &t, nullptr));
  EXPECT_TRUE(
      absl::ParseTime("%Y-%m-%d", "-292277022657-01-28", utc, &t, nullptr));
  EXPECT_TRUE(
      absl::ParseTime("%Y-%m-%d", "292277026596-12-04", utc, &t, nullptr));
  EXPECT_FALSE(
      absl::ParseTime("%Y-%m-%d", "292277026596-12-05", utc, &t, nullptr));
}

//
// Roundtrip test for FormatTime()/ParseTime().
//

TEST(FormatParse, RoundTrip) {
  const absl::TimeZone lax =
      absl::time_internal::LoadTimeZone("America/Los_Angeles");
  const absl::Time in =
      absl::FromCivil(absl::CivilSecond(1977, 6, 28, 9, 8, 7), lax);
  const absl::Duration subseconds = absl::Nanoseconds(654321);
  std::string err;

  // RFC3339, which renders subseconds.
  {
    absl::Time out;
    const std::string s =
        absl::FormatTime(absl::RFC3339_full, in + subseconds, lax);
    EXPECT_TRUE(absl::ParseTime(absl::RFC3339_full, s, &out, &err))
        << s << ": " << err;
    EXPECT_EQ(in + subseconds, out);  // RFC3339_full includes %Ez
  }

  // RFC1123, which only does whole seconds.
  {
    absl::Time out;
    const std::string s = absl::FormatTime(absl::RFC1123_full, in, lax);
    EXPECT_TRUE(absl::ParseTime(absl::RFC1123_full, s, &out, &err))
        << s << ": " << err;
    EXPECT_EQ(in, out);  // RFC1123_full includes %z
  }

  // `absl::FormatTime()` falls back to strftime() for "%c", which appears to
  // work. On Windows, `absl::ParseTime()` falls back to std::get_time() which
  // appears to fail on "%c" (or at least on the "%c" text produced by
  // `strftime()`). This makes it fail the round-trip test.
  //
  // Under the emscripten compiler `absl::ParseTime() falls back to
  // `strptime()`, but that ends up using a different definition for "%c"
  // compared to `strftime()`, also causing the round-trip test to fail
  // (see https://github.com/kripken/emscripten/pull/7491).
#if !defined(_MSC_VER) && !defined(__EMSCRIPTEN__)
  // Even though we don't know what %c will produce, it should roundtrip,
  // but only in the 0-offset timezone.
  {
    absl::Time out;
    const std::string s = absl::FormatTime("%c", in, absl::UTCTimeZone());
    EXPECT_TRUE(absl::ParseTime("%c", s, &out, &err)) << s << ": " << err;
    EXPECT_EQ(in, out);
  }
#endif  // !_MSC_VER && !__EMSCRIPTEN__
}

TEST(FormatParse, RoundTripDistantFuture) {
  const absl::TimeZone tz = absl::UTCTimeZone();
  const absl::Time in =
      absl::FromUnixSeconds(std::numeric_limits<int64_t>::max());
  std::string err;

  absl::Time out;
  const std::string s = absl::FormatTime(absl::RFC3339_full, in, tz);
  EXPECT_TRUE(absl::ParseTime(absl::RFC3339_full, s, &out, &err))
      << s << ": " << err;
  EXPECT_EQ(in, out);
}

TEST(FormatParse, RoundTripDistantPast) {
  const absl::TimeZone tz = absl::UTCTimeZone();
  const absl::Time in =
      absl::FromUnixSeconds(std::numeric_limits<int64_t>::min());
  std::string err;

  absl::Time out;
  const std::string s = absl::FormatTime(absl::RFC3339_full, in, tz);
  EXPECT_TRUE(absl::ParseTime(absl::RFC3339_full, s, &out, &err))
      << s << ": " << err;
  EXPECT_EQ(in, out);
}

}  // namespace
                                                                                                                                          node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/                                      0000775 0000000 0000000 00000000000 14746647661 0024110 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/                                 0000775 0000000 0000000 00000000000 14746647661 0025053 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/BUILD.bazel                      0000664 0000000 0000000 00000007774 14746647661 0026750 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2016 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   https://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.

package(features = [
    "header_modules",
    "layering_check",
    "parse_headers",
])

licenses(["notice"])

### libraries

cc_library(
    name = "civil_time",
    srcs = ["src/civil_time_detail.cc"],
    hdrs = [
        "include/cctz/civil_time.h",
    ],
    textual_hdrs = ["include/cctz/civil_time_detail.h"],
    visibility = ["//visibility:public"],
    deps = ["//absl/base:config"],
)

cc_library(
    name = "time_zone",
    srcs = [
        "src/time_zone_fixed.cc",
        "src/time_zone_fixed.h",
        "src/time_zone_format.cc",
        "src/time_zone_if.cc",
        "src/time_zone_if.h",
        "src/time_zone_impl.cc",
        "src/time_zone_impl.h",
        "src/time_zone_info.cc",
        "src/time_zone_info.h",
        "src/time_zone_libc.cc",
        "src/time_zone_libc.h",
        "src/time_zone_lookup.cc",
        "src/time_zone_posix.cc",
        "src/time_zone_posix.h",
        "src/tzfile.h",
        "src/zone_info_source.cc",
    ],
    hdrs = [
        "include/cctz/time_zone.h",
        "include/cctz/zone_info_source.h",
    ],
    linkopts = select({
        "@platforms//os:osx": ["-Wl,-framework,CoreFoundation"],
        "@platforms//os:ios": ["-Wl,-framework,CoreFoundation"],
        "//conditions:default": [],
    }),
    visibility = ["//visibility:public"],
    deps = [
        ":civil_time",
        "//absl/base:config",
    ] + select(
        {
            "//conditions:default": [],
        },
    ),
)

### tests

test_suite(
    name = "all_tests",
    visibility = ["//visibility:public"],
)

cc_test(
    name = "civil_time_test",
    size = "small",
    srcs = ["src/civil_time_test.cc"],
    deps = [
        ":civil_time",
        "//absl/base:config",
        "@com_google_googletest//:gtest",
        "@com_google_googletest//:gtest_main",
    ],
)

cc_test(
    name = "time_zone_format_test",
    size = "small",
    srcs = ["src/time_zone_format_test.cc"],
    data = [":zoneinfo"],
    env = {"TZDIR": "absl/time/internal/cctz/testdata/zoneinfo"},
    tags = [
        "no_test_android_arm",
        "no_test_android_arm64",
        "no_test_android_x86",
        "no_test_wasm",
    ],
    deps = [
        ":civil_time",
        ":time_zone",
        "//absl/base:config",
        "@com_google_googletest//:gtest",
        "@com_google_googletest//:gtest_main",
    ],
)

cc_test(
    name = "time_zone_lookup_test",
    size = "small",
    timeout = "moderate",
    srcs = ["src/time_zone_lookup_test.cc"],
    data = [":zoneinfo"],
    env = {"TZDIR": "absl/time/internal/cctz/testdata/zoneinfo"},
    tags = [
        "no_test_android_arm",
        "no_test_android_arm64",
        "no_test_android_x86",
        "no_test_wasm",
    ],
    deps = [
        ":civil_time",
        ":time_zone",
        "//absl/base:config",
        "@com_google_googletest//:gtest",
        "@com_google_googletest//:gtest_main",
    ],
)

### benchmarks

cc_test(
    name = "cctz_benchmark",
    srcs = [
        "src/cctz_benchmark.cc",
        "src/time_zone_if.h",
        "src/time_zone_impl.h",
        "src/time_zone_info.h",
        "src/tzfile.h",
    ],
    linkstatic = 1,
    tags = ["benchmark"],
    deps = [
        ":civil_time",
        ":time_zone",
        "//absl/base:config",
        "@com_github_google_benchmark//:benchmark_main",
    ],
)

filegroup(
    name = "zoneinfo",
    srcs = glob(["testdata/zoneinfo/**"]),
    visibility = ["//absl/time:__subpackages__"],
)

### examples

### binaries
    node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/BUILD.gn                         0000664 0000000 0000000 00000002706 14746647661 0026245 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Copyright 2018 The Chromium Authors
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//third_party/abseil-cpp/absl.gni")

absl_source_set("civil_time") {
  sources = [ "src/civil_time_detail.cc" ]
  public = [
    "include/cctz/civil_time.h",
    "include/cctz/civil_time_detail.h",
  ]
  deps = [ "//third_party/abseil-cpp/absl/base:config" ]
}

absl_source_set("time_zone") {
  sources = [
    "src/time_zone_fixed.cc",
    "src/time_zone_fixed.h",
    "src/time_zone_format.cc",
    "src/time_zone_if.cc",
    "src/time_zone_if.h",
    "src/time_zone_impl.cc",
    "src/time_zone_impl.h",
    "src/time_zone_info.cc",
    "src/time_zone_info.h",
    "src/time_zone_libc.cc",
    "src/time_zone_libc.h",
    "src/time_zone_lookup.cc",
    "src/time_zone_posix.cc",
    "src/time_zone_posix.h",
    "src/tzfile.h",
    "src/zone_info_source.cc",
  ]
  public = [
    "include/cctz/time_zone.h",
    "include/cctz/zone_info_source.h",
  ]
  if (is_apple) {
    frameworks = [ "Foundation.framework" ]
  }
  deps = [
    ":civil_time",
    "//third_party/abseil-cpp/absl/base:config",
  ]
  if (is_fuchsia) {
    deps += [
      "//third_party/fuchsia-sdk/sdk/fidl/fuchsia.intl:fuchsia.intl_hlcpp",
      "//third_party/fuchsia-sdk/sdk/pkg/async",
      "//third_party/fuchsia-sdk/sdk/pkg/async-loop-cpp",
      "//third_party/fuchsia-sdk/sdk/pkg/sys_cpp",
      "//third_party/fuchsia-sdk/sdk/pkg/zx",
    ]
  }
}
                                                          node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/include/                         0000775 0000000 0000000 00000000000 14746647661 0026476 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/include/cctz/                    0000775 0000000 0000000 00000000000 14746647661 0027441 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/include/cctz/civil_time.h        0000664 0000000 0000000 00000032460 14746647661 0031743 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

#ifndef ABSL_TIME_INTERNAL_CCTZ_CIVIL_TIME_H_
#define ABSL_TIME_INTERNAL_CCTZ_CIVIL_TIME_H_

#include "absl/base/config.h"
#include "absl/time/internal/cctz/include/cctz/civil_time_detail.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {
namespace cctz {

// The term "civil time" refers to the legally recognized human-scale time
// that is represented by the six fields YYYY-MM-DD hh:mm:ss. Modern-day civil
// time follows the Gregorian Calendar and is a time-zone-independent concept.
// A "date" is perhaps the most common example of a civil time (represented in
// this library as cctz::civil_day). This library provides six classes and a
// handful of functions that help with rounding, iterating, and arithmetic on
// civil times while avoiding complications like daylight-saving time (DST).
//
// The following six classes form the core of this civil-time library:
//
//   * civil_second
//   * civil_minute
//   * civil_hour
//   * civil_day
//   * civil_month
//   * civil_year
//
// Each class is a simple value type with the same interface for construction
// and the same six accessors for each of the civil fields (year, month, day,
// hour, minute, and second, aka YMDHMS). These classes differ only in their
// alignment, which is indicated by the type name and specifies the field on
// which arithmetic operates.
//
// Each class can be constructed by passing up to six optional integer
// arguments representing the YMDHMS fields (in that order) to the
// constructor. Omitted fields are assigned their minimum valid value. Hours,
// minutes, and seconds will be set to 0, month and day will be set to 1, and
// since there is no minimum valid year, it will be set to 1970. So, a
// default-constructed civil-time object will have YMDHMS fields representing
// "1970-01-01 00:00:00". Fields that are out-of-range are normalized (e.g.,
// October 32 -> November 1) so that all civil-time objects represent valid
// values.
//
// Each civil-time class is aligned to the civil-time field indicated in the
// class's name after normalization. Alignment is performed by setting all the
// inferior fields to their minimum valid value (as described above). The
// following are examples of how each of the six types would align the fields
// representing November 22, 2015 at 12:34:56 in the afternoon. (Note: the
// string format used here is not important; it's just a shorthand way of
// showing the six YMDHMS fields.)
//
//   civil_second  2015-11-22 12:34:56
//   civil_minute  2015-11-22 12:34:00
//   civil_hour    2015-11-22 12:00:00
//   civil_day     2015-11-22 00:00:00
//   civil_month   2015-11-01 00:00:00
//   civil_year    2015-01-01 00:00:00
//
// Each civil-time type performs arithmetic on the field to which it is
// aligned. This means that adding 1 to a civil_day increments the day field
// (normalizing as necessary), and subtracting 7 from a civil_month operates
// on the month field (normalizing as necessary). All arithmetic produces a
// valid civil time. Difference requires two similarly aligned civil-time
// objects and returns the scalar answer in units of the objects' alignment.
// For example, the difference between two civil_hour objects will give an
// answer in units of civil hours.
//
// In addition to the six civil-time types just described, there are
// a handful of helper functions and algorithms for performing common
// calculations. These are described below.
//
// Note: In C++14 and later, this library is usable in a constexpr context.
//
// CONSTRUCTION:
//
// Each of the civil-time types can be constructed in two ways: by directly
// passing to the constructor up to six (optional) integers representing the
// YMDHMS fields, or by copying the YMDHMS fields from a differently aligned
// civil-time type.
//
//   civil_day default_value;  // 1970-01-01 00:00:00
//
//   civil_day a(2015, 2, 3);           // 2015-02-03 00:00:00
//   civil_day b(2015, 2, 3, 4, 5, 6);  // 2015-02-03 00:00:00
//   civil_day c(2015);                 // 2015-01-01 00:00:00
//
//   civil_second ss(2015, 2, 3, 4, 5, 6);  // 2015-02-03 04:05:06
//   civil_minute mm(ss);                   // 2015-02-03 04:05:00
//   civil_hour hh(mm);                     // 2015-02-03 04:00:00
//   civil_day d(hh);                       // 2015-02-03 00:00:00
//   civil_month m(d);                      // 2015-02-01 00:00:00
//   civil_year y(m);                       // 2015-01-01 00:00:00
//
//   m = civil_month(y);     // 2015-01-01 00:00:00
//   d = civil_day(m);       // 2015-01-01 00:00:00
//   hh = civil_hour(d);     // 2015-01-01 00:00:00
//   mm = civil_minute(hh);  // 2015-01-01 00:00:00
//   ss = civil_second(mm);  // 2015-01-01 00:00:00
//
// ALIGNMENT CONVERSION:
//
// The alignment of a civil-time object cannot change, but the object may be
// used to construct a new object with a different alignment. This is referred
// to as "realigning". When realigning to a type with the same or more
// precision (e.g., civil_day -> civil_second), the conversion may be
// performed implicitly since no information is lost. However, if information
// could be discarded (e.g., civil_second -> civil_day), the conversion must
// be explicit at the call site.
//
//   void fun(const civil_day& day);
//
//   civil_second cs;
//   fun(cs);  // Won't compile because data may be discarded
//   fun(civil_day(cs));  // OK: explicit conversion
//
//   civil_day cd;
//   fun(cd);  // OK: no conversion needed
//
//   civil_month cm;
//   fun(cm);  // OK: implicit conversion to civil_day
//
// NORMALIZATION:
//
// Integer arguments passed to the constructor may be out-of-range, in which
// case they are normalized to produce a valid civil-time object. This enables
// natural arithmetic on constructor arguments without worrying about the
// field's range. Normalization guarantees that there are no invalid
// civil-time objects.
//
//   civil_day d(2016, 10, 32);  // Out-of-range day; normalized to 2016-11-01
//
// Note: If normalization is undesired, you can signal an error by comparing
// the constructor arguments to the normalized values returned by the YMDHMS
// properties.
//
// PROPERTIES:
//
// All civil-time types have accessors for all six of the civil-time fields:
// year, month, day, hour, minute, and second. Recall that fields inferior to
// the type's alignment will be set to their minimum valid value.
//
//   civil_day d(2015, 6, 28);
//   // d.year() == 2015
//   // d.month() == 6
//   // d.day() == 28
//   // d.hour() == 0
//   // d.minute() == 0
//   // d.second() == 0
//
// COMPARISON:
//
// Comparison always considers all six YMDHMS fields, regardless of the type's
// alignment. Comparison between differently aligned civil-time types is
// allowed.
//
//   civil_day feb_3(2015, 2, 3);  // 2015-02-03 00:00:00
//   civil_day mar_4(2015, 3, 4);  // 2015-03-04 00:00:00
//   // feb_3 < mar_4
//   // civil_year(feb_3) == civil_year(mar_4)
//
//   civil_second feb_3_noon(2015, 2, 3, 12, 0, 0);  // 2015-02-03 12:00:00
//   // feb_3 < feb_3_noon
//   // feb_3 == civil_day(feb_3_noon)
//
//   // Iterates all the days of February 2015.
//   for (civil_day d(2015, 2, 1); d < civil_month(2015, 3); ++d) {
//     // ...
//   }
//
// STREAMING:
//
// Each civil-time type may be sent to an output stream using operator<<().
// The output format follows the pattern "YYYY-MM-DDThh:mm:ss" where fields
// inferior to the type's alignment are omitted.
//
//   civil_second cs(2015, 2, 3, 4, 5, 6);
//   std::cout << cs << "\n";  // Outputs: 2015-02-03T04:05:06
//
//   civil_day cd(cs);
//   std::cout << cd << "\n";  // Outputs: 2015-02-03
//
//   civil_year cy(cs);
//   std::cout << cy << "\n";  // Outputs: 2015
//
// ARITHMETIC:
//
// Civil-time types support natural arithmetic operators such as addition,
// subtraction, and difference. Arithmetic operates on the civil-time field
// indicated in the type's name. Difference requires arguments with the same
// alignment and returns the answer in units of the alignment.
//
//   civil_day a(2015, 2, 3);
//   ++a;                         // 2015-02-04 00:00:00
//   --a;                         // 2015-02-03 00:00:00
//   civil_day b = a + 1;         // 2015-02-04 00:00:00
//   civil_day c = 1 + b;         // 2015-02-05 00:00:00
//   int n = c - a;               // n = 2 (civil days)
//   int m = c - civil_month(c);  // Won't compile: different types.
//
// EXAMPLE: Adding a month to January 31.
//
// One of the classic questions that arises when considering a civil-time
// library (or a date library or a date/time library) is this: "What happens
// when you add a month to January 31?" This is an interesting question
// because there could be a number of possible answers:
//
//   1. March 3 (or 2 if a leap year). This may make sense if the operation
//      wants the equivalent of February 31.
//   2. February 28 (or 29 if a leap year). This may make sense if the operation
//      wants the last day of January to go to the last day of February.
//   3. Error. The caller may get some error, an exception, an invalid date
//      object, or maybe false is returned. This may make sense because there is
//      no single unambiguously correct answer to the question.
//
// Practically speaking, any answer that is not what the programmer intended
// is the wrong answer.
//
// This civil-time library avoids the problem by making it impossible to ask
// ambiguous questions. All civil-time objects are aligned to a particular
// civil-field boundary (such as aligned to a year, month, day, hour, minute,
// or second), and arithmetic operates on the field to which the object is
// aligned. This means that in order to "add a month" the object must first be
// aligned to a month boundary, which is equivalent to the first day of that
// month.
//
// Of course, there are ways to compute an answer the question at hand using
// this civil-time library, but they require the programmer to be explicit
// about the answer they expect. To illustrate, let's see how to compute all
// three of the above possible answers to the question of "Jan 31 plus 1
// month":
//
//   const civil_day d(2015, 1, 31);
//
//   // Answer 1:
//   // Add 1 to the month field in the constructor, and rely on normalization.
//   const auto ans_normalized = civil_day(d.year(), d.month() + 1, d.day());
//   // ans_normalized == 2015-03-03 (aka Feb 31)
//
//   // Answer 2:
//   // Add 1 to month field, capping to the end of next month.
//   const auto next_month = civil_month(d) + 1;
//   const auto last_day_of_next_month = civil_day(next_month + 1) - 1;
//   const auto ans_capped = std::min(ans_normalized, last_day_of_next_month);
//   // ans_capped == 2015-02-28
//
//   // Answer 3:
//   // Signal an error if the normalized answer is not in next month.
//   if (civil_month(ans_normalized) != next_month) {
//     // error, month overflow
//   }
//
using civil_year = detail::civil_year;
using civil_month = detail::civil_month;
using civil_day = detail::civil_day;
using civil_hour = detail::civil_hour;
using civil_minute = detail::civil_minute;
using civil_second = detail::civil_second;

// An enum class with members monday, tuesday, wednesday, thursday, friday,
// saturday, and sunday. These enum values may be sent to an output stream
// using operator<<(). The result is the full weekday name in English with a
// leading capital letter.
//
//   weekday wd = weekday::thursday;
//   std::cout << wd << "\n";  // Outputs: Thursday
//
using detail::weekday;

// Returns the weekday for the given civil-time value.
//
//   civil_day a(2015, 8, 13);
//   weekday wd = get_weekday(a);  // wd == weekday::thursday
//
using detail::get_weekday;

// Returns the civil_day that strictly follows or precedes the given
// civil_day, and that falls on the given weekday.
//
// For example, given:
//
//     August 2015
// Su Mo Tu We Th Fr Sa
//                    1
//  2  3  4  5  6  7  8
//  9 10 11 12 13 14 15
// 16 17 18 19 20 21 22
// 23 24 25 26 27 28 29
// 30 31
//
//   civil_day a(2015, 8, 13);  // get_weekday(a) == weekday::thursday
//   civil_day b = next_weekday(a, weekday::thursday);  // b = 2015-08-20
//   civil_day c = prev_weekday(a, weekday::thursday);  // c = 2015-08-06
//
//   civil_day d = ...
//   // Gets the following Thursday if d is not already Thursday
//   civil_day thurs1 = next_weekday(d - 1, weekday::thursday);
//   // Gets the previous Thursday if d is not already Thursday
//   civil_day thurs2 = prev_weekday(d + 1, weekday::thursday);
//
using detail::next_weekday;
using detail::prev_weekday;

// Returns the day-of-year for the given civil-time value.
//
//   civil_day a(2015, 1, 1);
//   int yd_jan_1 = get_yearday(a);   // yd_jan_1 = 1
//   civil_day b(2015, 12, 31);
//   int yd_dec_31 = get_yearday(b);  // yd_dec_31 = 365
//
using detail::get_yearday;

}  // namespace cctz
}  // namespace time_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_TIME_INTERNAL_CCTZ_CIVIL_TIME_H_
                                                                                                                                                                                                                node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/include/cctz/civil_time_detail.h 0000664 0000000 0000000 00000052277 14746647661 0033275 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

#ifndef ABSL_TIME_INTERNAL_CCTZ_CIVIL_TIME_DETAIL_H_
#define ABSL_TIME_INTERNAL_CCTZ_CIVIL_TIME_DETAIL_H_

#include <cstdint>
#include <limits>
#include <ostream>
#include <type_traits>

#include "absl/base/config.h"

// Disable constexpr support unless we are in C++14 mode.
#if __cpp_constexpr >= 201304 || (defined(_MSC_VER) && _MSC_VER >= 1910)
#define CONSTEXPR_D constexpr  // data
#define CONSTEXPR_F constexpr  // function
#define CONSTEXPR_M constexpr  // member
#else
#define CONSTEXPR_D const
#define CONSTEXPR_F inline
#define CONSTEXPR_M
#endif

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {
namespace cctz {

// Support years that at least span the range of 64-bit time_t values.
using year_t = std::int_fast64_t;

// Type alias that indicates an argument is not normalized (e.g., the
// constructor parameters and operands/results of addition/subtraction).
using diff_t = std::int_fast64_t;

namespace detail {

// Type aliases that indicate normalized argument values.
using month_t = std::int_fast8_t;   // [1:12]
using day_t = std::int_fast8_t;     // [1:31]
using hour_t = std::int_fast8_t;    // [0:23]
using minute_t = std::int_fast8_t;  // [0:59]
using second_t = std::int_fast8_t;  // [0:59]

// Normalized civil-time fields: Y-M-D HH:MM:SS.
struct fields {
  CONSTEXPR_M fields(year_t year, month_t month, day_t day, hour_t hour,
                     minute_t minute, second_t second)
      : y(year), m(month), d(day), hh(hour), mm(minute), ss(second) {}
  std::int_least64_t y;
  std::int_least8_t m;
  std::int_least8_t d;
  std::int_least8_t hh;
  std::int_least8_t mm;
  std::int_least8_t ss;
};

struct second_tag {};
struct minute_tag : second_tag {};
struct hour_tag : minute_tag {};
struct day_tag : hour_tag {};
struct month_tag : day_tag {};
struct year_tag : month_tag {};

////////////////////////////////////////////////////////////////////////

// Field normalization (without avoidable overflow).

namespace impl {

CONSTEXPR_F bool is_leap_year(year_t y) noexcept {
  return y % 4 == 0 && (y % 100 != 0 || y % 400 == 0);
}
CONSTEXPR_F int year_index(year_t y, month_t m) noexcept {
  const int yi = static_cast<int>((y + (m > 2)) % 400);
  return yi < 0 ? yi + 400 : yi;
}
CONSTEXPR_F int days_per_century(int yi) noexcept {
  return 36524 + (yi == 0 || yi > 300);
}
CONSTEXPR_F int days_per_4years(int yi) noexcept {
  return 1460 + (yi == 0 || yi > 300 || (yi - 1) % 100 < 96);
}
CONSTEXPR_F int days_per_year(year_t y, month_t m) noexcept {
  return is_leap_year(y + (m > 2)) ? 366 : 365;
}
CONSTEXPR_F int days_per_month(year_t y, month_t m) noexcept {
  CONSTEXPR_D int k_days_per_month[1 + 12] = {
      -1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31  // non leap year
  };
  return k_days_per_month[m] + (m == 2 && is_leap_year(y));
}

CONSTEXPR_F fields n_day(year_t y, month_t m, diff_t d, diff_t cd, hour_t hh,
                         minute_t mm, second_t ss) noexcept {
  year_t ey = y % 400;
  const year_t oey = ey;
  ey += (cd / 146097) * 400;
  cd %= 146097;
  if (cd < 0) {
    ey -= 400;
    cd += 146097;
  }
  ey += (d / 146097) * 400;
  d = d % 146097 + cd;
  if (d > 0) {
    if (d > 146097) {
      ey += 400;
      d -= 146097;
    }
  } else {
    if (d > -365) {
      // We often hit the previous year when stepping a civil time backwards,
      // so special case it to avoid counting up by 100/4/1-year chunks.
      ey -= 1;
      d += days_per_year(ey, m);
    } else {
      ey -= 400;
      d += 146097;
    }
  }
  if (d > 365) {
    int yi = year_index(ey, m);  // Index into Gregorian 400 year cycle.
    for (;;) {
      int n = days_per_century(yi);
      if (d <= n) break;
      d -= n;
      ey += 100;
      yi += 100;
      if (yi >= 400) yi -= 400;
    }
    for (;;) {
      int n = days_per_4years(yi);
      if (d <= n) break;
      d -= n;
      ey += 4;
      yi += 4;
      if (yi >= 400) yi -= 400;
    }
    for (;;) {
      int n = days_per_year(ey, m);
      if (d <= n) break;
      d -= n;
      ++ey;
    }
  }
  if (d > 28) {
    for (;;) {
      int n = days_per_month(ey, m);
      if (d <= n) break;
      d -= n;
      if (++m > 12) {
        ++ey;
        m = 1;
      }
    }
  }
  return fields(y + (ey - oey), m, static_cast<day_t>(d), hh, mm, ss);
}
CONSTEXPR_F fields n_mon(year_t y, diff_t m, diff_t d, diff_t cd, hour_t hh,
                         minute_t mm, second_t ss) noexcept {
  if (m != 12) {
    y += m / 12;
    m %= 12;
    if (m <= 0) {
      y -= 1;
      m += 12;
    }
  }
  return n_day(y, static_cast<month_t>(m), d, cd, hh, mm, ss);
}
CONSTEXPR_F fields n_hour(year_t y, diff_t m, diff_t d, diff_t cd, diff_t hh,
                          minute_t mm, second_t ss) noexcept {
  cd += hh / 24;
  hh %= 24;
  if (hh < 0) {
    cd -= 1;
    hh += 24;
  }
  return n_mon(y, m, d, cd, static_cast<hour_t>(hh), mm, ss);
}
CONSTEXPR_F fields n_min(year_t y, diff_t m, diff_t d, diff_t hh, diff_t ch,
                         diff_t mm, second_t ss) noexcept {
  ch += mm / 60;
  mm %= 60;
  if (mm < 0) {
    ch -= 1;
    mm += 60;
  }
  return n_hour(y, m, d, hh / 24 + ch / 24, hh % 24 + ch % 24,
                static_cast<minute_t>(mm), ss);
}
CONSTEXPR_F fields n_sec(year_t y, diff_t m, diff_t d, diff_t hh, diff_t mm,
                         diff_t ss) noexcept {
  // Optimization for when (non-constexpr) fields are already normalized.
  if (0 <= ss && ss < 60) {
    const second_t nss = static_cast<second_t>(ss);
    if (0 <= mm && mm < 60) {
      const minute_t nmm = static_cast<minute_t>(mm);
      if (0 <= hh && hh < 24) {
        const hour_t nhh = static_cast<hour_t>(hh);
        if (1 <= d && d <= 28 && 1 <= m && m <= 12) {
          const day_t nd = static_cast<day_t>(d);
          const month_t nm = static_cast<month_t>(m);
          return fields(y, nm, nd, nhh, nmm, nss);
        }
        return n_mon(y, m, d, 0, nhh, nmm, nss);
      }
      return n_hour(y, m, d, hh / 24, hh % 24, nmm, nss);
    }
    return n_min(y, m, d, hh, mm / 60, mm % 60, nss);
  }
  diff_t cm = ss / 60;
  ss %= 60;
  if (ss < 0) {
    cm -= 1;
    ss += 60;
  }
  return n_min(y, m, d, hh, mm / 60 + cm / 60, mm % 60 + cm % 60,
               static_cast<second_t>(ss));
}

}  // namespace impl

////////////////////////////////////////////////////////////////////////

// Increments the indicated (normalized) field by "n".
CONSTEXPR_F fields step(second_tag, fields f, diff_t n) noexcept {
  return impl::n_sec(f.y, f.m, f.d, f.hh, f.mm + n / 60, f.ss + n % 60);
}
CONSTEXPR_F fields step(minute_tag, fields f, diff_t n) noexcept {
  return impl::n_min(f.y, f.m, f.d, f.hh + n / 60, 0, f.mm + n % 60, f.ss);
}
CONSTEXPR_F fields step(hour_tag, fields f, diff_t n) noexcept {
  return impl::n_hour(f.y, f.m, f.d + n / 24, 0, f.hh + n % 24, f.mm, f.ss);
}
CONSTEXPR_F fields step(day_tag, fields f, diff_t n) noexcept {
  return impl::n_day(f.y, f.m, f.d, n, f.hh, f.mm, f.ss);
}
CONSTEXPR_F fields step(month_tag, fields f, diff_t n) noexcept {
  return impl::n_mon(f.y + n / 12, f.m + n % 12, f.d, 0, f.hh, f.mm, f.ss);
}
CONSTEXPR_F fields step(year_tag, fields f, diff_t n) noexcept {
  return fields(f.y + n, f.m, f.d, f.hh, f.mm, f.ss);
}

////////////////////////////////////////////////////////////////////////

namespace impl {

// Returns (v * f + a) but avoiding intermediate overflow when possible.
CONSTEXPR_F diff_t scale_add(diff_t v, diff_t f, diff_t a) noexcept {
  return (v < 0) ? ((v + 1) * f + a) - f : ((v - 1) * f + a) + f;
}

// Map a (normalized) Y/M/D to the number of days before/after 1970-01-01.
// Probably overflows for years outside [-292277022656:292277026595].
CONSTEXPR_F diff_t ymd_ord(year_t y, month_t m, day_t d) noexcept {
  const diff_t eyear = (m <= 2) ? y - 1 : y;
  const diff_t era = (eyear >= 0 ? eyear : eyear - 399) / 400;
  const diff_t yoe = eyear - era * 400;
  const diff_t doy = (153 * (m + (m > 2 ? -3 : 9)) + 2) / 5 + d - 1;
  const diff_t doe = yoe * 365 + yoe / 4 - yoe / 100 + doy;
  return era * 146097 + doe - 719468;
}

// Returns the difference in days between two normalized Y-M-D tuples.
// ymd_ord() will encounter integer overflow given extreme year values,
// yet the difference between two such extreme values may actually be
// small, so we take a little care to avoid overflow when possible by
// exploiting the 146097-day cycle.
CONSTEXPR_F diff_t day_difference(year_t y1, month_t m1, day_t d1, year_t y2,
                                  month_t m2, day_t d2) noexcept {
  const diff_t a_c4_off = y1 % 400;
  const diff_t b_c4_off = y2 % 400;
  diff_t c4_diff = (y1 - a_c4_off) - (y2 - b_c4_off);
  diff_t delta = ymd_ord(a_c4_off, m1, d1) - ymd_ord(b_c4_off, m2, d2);
  if (c4_diff > 0 && delta < 0) {
    delta += 2 * 146097;
    c4_diff -= 2 * 400;
  } else if (c4_diff < 0 && delta > 0) {
    delta -= 2 * 146097;
    c4_diff += 2 * 400;
  }
  return (c4_diff / 400 * 146097) + delta;
}

}  // namespace impl

// Returns the difference between fields structs using the indicated unit.
CONSTEXPR_F diff_t difference(year_tag, fields f1, fields f2) noexcept {
  return f1.y - f2.y;
}
CONSTEXPR_F diff_t difference(month_tag, fields f1, fields f2) noexcept {
  return impl::scale_add(difference(year_tag{}, f1, f2), 12, (f1.m - f2.m));
}
CONSTEXPR_F diff_t difference(day_tag, fields f1, fields f2) noexcept {
  return impl::day_difference(f1.y, f1.m, f1.d, f2.y, f2.m, f2.d);
}
CONSTEXPR_F diff_t difference(hour_tag, fields f1, fields f2) noexcept {
  return impl::scale_add(difference(day_tag{}, f1, f2), 24, (f1.hh - f2.hh));
}
CONSTEXPR_F diff_t difference(minute_tag, fields f1, fields f2) noexcept {
  return impl::scale_add(difference(hour_tag{}, f1, f2), 60, (f1.mm - f2.mm));
}
CONSTEXPR_F diff_t difference(second_tag, fields f1, fields f2) noexcept {
  return impl::scale_add(difference(minute_tag{}, f1, f2), 60, f1.ss - f2.ss);
}

////////////////////////////////////////////////////////////////////////

// Aligns the (normalized) fields struct to the indicated field.
CONSTEXPR_F fields align(second_tag, fields f) noexcept { return f; }
CONSTEXPR_F fields align(minute_tag, fields f) noexcept {
  return fields{f.y, f.m, f.d, f.hh, f.mm, 0};
}
CONSTEXPR_F fields align(hour_tag, fields f) noexcept {
  return fields{f.y, f.m, f.d, f.hh, 0, 0};
}
CONSTEXPR_F fields align(day_tag, fields f) noexcept {
  return fields{f.y, f.m, f.d, 0, 0, 0};
}
CONSTEXPR_F fields align(month_tag, fields f) noexcept {
  return fields{f.y, f.m, 1, 0, 0, 0};
}
CONSTEXPR_F fields align(year_tag, fields f) noexcept {
  return fields{f.y, 1, 1, 0, 0, 0};
}

////////////////////////////////////////////////////////////////////////

namespace impl {

template <typename H>
H AbslHashValueImpl(second_tag, H h, fields f) {
  return H::combine(std::move(h), f.y, f.m, f.d, f.hh, f.mm, f.ss);
}
template <typename H>
H AbslHashValueImpl(minute_tag, H h, fields f) {
  return H::combine(std::move(h), f.y, f.m, f.d, f.hh, f.mm);
}
template <typename H>
H AbslHashValueImpl(hour_tag, H h, fields f) {
  return H::combine(std::move(h), f.y, f.m, f.d, f.hh);
}
template <typename H>
H AbslHashValueImpl(day_tag, H h, fields f) {
  return H::combine(std::move(h), f.y, f.m, f.d);
}
template <typename H>
H AbslHashValueImpl(month_tag, H h, fields f) {
  return H::combine(std::move(h), f.y, f.m);
}
template <typename H>
H AbslHashValueImpl(year_tag, H h, fields f) {
  return H::combine(std::move(h), f.y);
}

}  // namespace impl

////////////////////////////////////////////////////////////////////////

template <typename T>
class civil_time {
 public:
  explicit CONSTEXPR_M civil_time(year_t y, diff_t m = 1, diff_t d = 1,
                                  diff_t hh = 0, diff_t mm = 0,
                                  diff_t ss = 0) noexcept
      : civil_time(impl::n_sec(y, m, d, hh, mm, ss)) {}

  CONSTEXPR_M civil_time() noexcept : f_{1970, 1, 1, 0, 0, 0} {}
  civil_time(const civil_time&) = default;
  civil_time& operator=(const civil_time&) = default;

  // Conversion between civil times of different alignment. Conversion to
  // a more precise alignment is allowed implicitly (e.g., day -> hour),
  // but conversion where information is discarded must be explicit
  // (e.g., second -> minute).
  template <typename U, typename S>
  using preserves_data =
      typename std::enable_if<std::is_base_of<U, S>::value>::type;
  template <typename U>
  CONSTEXPR_M civil_time(const civil_time<U>& ct,
                         preserves_data<T, U>* = nullptr) noexcept
      : civil_time(ct.f_) {}
  template <typename U>
  explicit CONSTEXPR_M civil_time(const civil_time<U>& ct,
                                  preserves_data<U, T>* = nullptr) noexcept
      : civil_time(ct.f_) {}

  // Factories for the maximum/minimum representable civil_time.
  static CONSTEXPR_F auto(max)() -> civil_time {
    const auto max_year = (std::numeric_limits<std::int_least64_t>::max)();
    return civil_time(max_year, 12, 31, 23, 59, 59);
  }
  static CONSTEXPR_F auto(min)() -> civil_time {
    const auto min_year = (std::numeric_limits<std::int_least64_t>::min)();
    return civil_time(min_year, 1, 1, 0, 0, 0);
  }

  // Field accessors.  Note: All but year() return an int.
  CONSTEXPR_M year_t year() const noexcept { return f_.y; }
  CONSTEXPR_M int month() const noexcept { return f_.m; }
  CONSTEXPR_M int day() const noexcept { return f_.d; }
  CONSTEXPR_M int hour() const noexcept { return f_.hh; }
  CONSTEXPR_M int minute() const noexcept { return f_.mm; }
  CONSTEXPR_M int second() const noexcept { return f_.ss; }

  // Assigning arithmetic.
  CONSTEXPR_M civil_time& operator+=(diff_t n) noexcept {
    return *this = *this + n;
  }
  CONSTEXPR_M civil_time& operator-=(diff_t n) noexcept {
    return *this = *this - n;
  }
  CONSTEXPR_M civil_time& operator++() noexcept { return *this += 1; }
  CONSTEXPR_M civil_time operator++(int) noexcept {
    const civil_time a = *this;
    ++*this;
    return a;
  }
  CONSTEXPR_M civil_time& operator--() noexcept { return *this -= 1; }
  CONSTEXPR_M civil_time operator--(int) noexcept {
    const civil_time a = *this;
    --*this;
    return a;
  }

  // Binary arithmetic operators.
  friend CONSTEXPR_F civil_time operator+(civil_time a, diff_t n) noexcept {
    return civil_time(step(T{}, a.f_, n));
  }
  friend CONSTEXPR_F civil_time operator+(diff_t n, civil_time a) noexcept {
    return a + n;
  }
  friend CONSTEXPR_F civil_time operator-(civil_time a, diff_t n) noexcept {
    return n != (std::numeric_limits<diff_t>::min)()
               ? civil_time(step(T{}, a.f_, -n))
               : civil_time(step(T{}, step(T{}, a.f_, -(n + 1)), 1));
  }
  friend CONSTEXPR_F diff_t operator-(civil_time lhs, civil_time rhs) noexcept {
    return difference(T{}, lhs.f_, rhs.f_);
  }

  template <typename H>
  friend H AbslHashValue(H h, civil_time a) {
    return impl::AbslHashValueImpl(T{}, std::move(h), a.f_);
  }

 private:
  // All instantiations of this template are allowed to call the following
  // private constructor and access the private fields member.
  template <typename U>
  friend class civil_time;

  // The designated constructor that all others eventually call.
  explicit CONSTEXPR_M civil_time(fields f) noexcept : f_(align(T{}, f)) {}

  fields f_;
};

// Disallows difference between differently aligned types.
// auto n = civil_day(...) - civil_hour(...);  // would be confusing.
template <typename T, typename U>
CONSTEXPR_F diff_t operator-(civil_time<T>, civil_time<U>) = delete;

using civil_year = civil_time<year_tag>;
using civil_month = civil_time<month_tag>;
using civil_day = civil_time<day_tag>;
using civil_hour = civil_time<hour_tag>;
using civil_minute = civil_time<minute_tag>;
using civil_second = civil_time<second_tag>;

////////////////////////////////////////////////////////////////////////

// Relational operators that work with differently aligned objects.
// Always compares all six fields.
template <typename T1, typename T2>
CONSTEXPR_F bool operator<(const civil_time<T1>& lhs,
                           const civil_time<T2>& rhs) noexcept {
  return (
      lhs.year() < rhs.year() ||
      (lhs.year() == rhs.year() &&
       (lhs.month() < rhs.month() ||
        (lhs.month() == rhs.month() &&
         (lhs.day() < rhs.day() || (lhs.day() == rhs.day() &&
                                    (lhs.hour() < rhs.hour() ||
                                     (lhs.hour() == rhs.hour() &&
                                      (lhs.minute() < rhs.minute() ||
                                       (lhs.minute() == rhs.minute() &&
                                        (lhs.second() < rhs.second())))))))))));
}
template <typename T1, typename T2>
CONSTEXPR_F bool operator<=(const civil_time<T1>& lhs,
                            const civil_time<T2>& rhs) noexcept {
  return !(rhs < lhs);
}
template <typename T1, typename T2>
CONSTEXPR_F bool operator>=(const civil_time<T1>& lhs,
                            const civil_time<T2>& rhs) noexcept {
  return !(lhs < rhs);
}
template <typename T1, typename T2>
CONSTEXPR_F bool operator>(const civil_time<T1>& lhs,
                           const civil_time<T2>& rhs) noexcept {
  return rhs < lhs;
}
template <typename T1, typename T2>
CONSTEXPR_F bool operator==(const civil_time<T1>& lhs,
                            const civil_time<T2>& rhs) noexcept {
  return lhs.year() == rhs.year() && lhs.month() == rhs.month() &&
         lhs.day() == rhs.day() && lhs.hour() == rhs.hour() &&
         lhs.minute() == rhs.minute() && lhs.second() == rhs.second();
}
template <typename T1, typename T2>
CONSTEXPR_F bool operator!=(const civil_time<T1>& lhs,
                            const civil_time<T2>& rhs) noexcept {
  return !(lhs == rhs);
}

////////////////////////////////////////////////////////////////////////

enum class weekday {
  monday,
  tuesday,
  wednesday,
  thursday,
  friday,
  saturday,
  sunday,
};

CONSTEXPR_F weekday get_weekday(const civil_second& cs) noexcept {
  CONSTEXPR_D weekday k_weekday_by_mon_off[13] = {
      weekday::monday,    weekday::tuesday,  weekday::wednesday,
      weekday::thursday,  weekday::friday,   weekday::saturday,
      weekday::sunday,    weekday::monday,   weekday::tuesday,
      weekday::wednesday, weekday::thursday, weekday::friday,
      weekday::saturday,
  };
  CONSTEXPR_D int k_weekday_offsets[1 + 12] = {
      -1, 0, 3, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4,
  };
  year_t wd = 2400 + (cs.year() % 400) - (cs.month() < 3);
  wd += wd / 4 - wd / 100 + wd / 400;
  wd += k_weekday_offsets[cs.month()] + cs.day();
  return k_weekday_by_mon_off[wd % 7 + 6];
}

////////////////////////////////////////////////////////////////////////

CONSTEXPR_F civil_day next_weekday(civil_day cd, weekday wd) noexcept {
  CONSTEXPR_D weekday k_weekdays_forw[14] = {
      weekday::monday,    weekday::tuesday,  weekday::wednesday,
      weekday::thursday,  weekday::friday,   weekday::saturday,
      weekday::sunday,    weekday::monday,   weekday::tuesday,
      weekday::wednesday, weekday::thursday, weekday::friday,
      weekday::saturday,  weekday::sunday,
  };
  weekday base = get_weekday(cd);
  for (int i = 0;; ++i) {
    if (base == k_weekdays_forw[i]) {
      for (int j = i + 1;; ++j) {
        if (wd == k_weekdays_forw[j]) {
          return cd + (j - i);
        }
      }
    }
  }
}

CONSTEXPR_F civil_day prev_weekday(civil_day cd, weekday wd) noexcept {
  CONSTEXPR_D weekday k_weekdays_back[14] = {
      weekday::sunday,   weekday::saturday,  weekday::friday,
      weekday::thursday, weekday::wednesday, weekday::tuesday,
      weekday::monday,   weekday::sunday,    weekday::saturday,
      weekday::friday,   weekday::thursday,  weekday::wednesday,
      weekday::tuesday,  weekday::monday,
  };
  weekday base = get_weekday(cd);
  for (int i = 0;; ++i) {
    if (base == k_weekdays_back[i]) {
      for (int j = i + 1;; ++j) {
        if (wd == k_weekdays_back[j]) {
          return cd - (j - i);
        }
      }
    }
  }
}

CONSTEXPR_F int get_yearday(const civil_second& cs) noexcept {
  CONSTEXPR_D int k_month_offsets[1 + 12] = {
      -1, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334,
  };
  const int feb29 = (cs.month() > 2 && impl::is_leap_year(cs.year()));
  return k_month_offsets[cs.month()] + feb29 + cs.day();
}

////////////////////////////////////////////////////////////////////////

std::ostream& operator<<(std::ostream& os, const civil_year& y);
std::ostream& operator<<(std::ostream& os, const civil_month& m);
std::ostream& operator<<(std::ostream& os, const civil_day& d);
std::ostream& operator<<(std::ostream& os, const civil_hour& h);
std::ostream& operator<<(std::ostream& os, const civil_minute& m);
std::ostream& operator<<(std::ostream& os, const civil_second& s);
std::ostream& operator<<(std::ostream& os, weekday wd);

}  // namespace detail
}  // namespace cctz
}  // namespace time_internal
ABSL_NAMESPACE_END
}  // namespace absl

#undef CONSTEXPR_M
#undef CONSTEXPR_F
#undef CONSTEXPR_D

#endif  // ABSL_TIME_INTERNAL_CCTZ_CIVIL_TIME_DETAIL_H_
                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/include/cctz/time_zone.h         0000664 0000000 0000000 00000046423 14746647661 0031614 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

// A library for translating between absolute times (represented by
// std::chrono::time_points of the std::chrono::system_clock) and civil
// times (represented by cctz::civil_second) using the rules defined by
// a time zone (cctz::time_zone).

#ifndef ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_H_
#define ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_H_

#include <chrono>
#include <cstdint>
#include <limits>
#include <ratio>  // NOLINT: We use std::ratio in this header
#include <string>
#include <utility>

#include "absl/base/config.h"
#include "absl/time/internal/cctz/include/cctz/civil_time.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {
namespace cctz {

// Convenience aliases. Not intended as public API points.
template <typename D>
using time_point = std::chrono::time_point<std::chrono::system_clock, D>;
using seconds = std::chrono::duration<std::int_fast64_t>;
using sys_seconds = seconds;  // Deprecated.  Use cctz::seconds instead.

namespace detail {
template <typename D>
std::pair<time_point<seconds>, D> split_seconds(const time_point<D>& tp);
std::pair<time_point<seconds>, seconds> split_seconds(
    const time_point<seconds>& tp);
}  // namespace detail

// cctz::time_zone is an opaque, small, value-type class representing a
// geo-political region within which particular rules are used for mapping
// between absolute and civil times. Time zones are named using the TZ
// identifiers from the IANA Time Zone Database, such as "America/Los_Angeles"
// or "Australia/Sydney". Time zones are created from factory functions such
// as load_time_zone(). Note: strings like "PST" and "EDT" are not valid TZ
// identifiers.
//
// Example:
//   cctz::time_zone utc = cctz::utc_time_zone();
//   cctz::time_zone pst = cctz::fixed_time_zone(std::chrono::hours(-8));
//   cctz::time_zone loc = cctz::local_time_zone();
//   cctz::time_zone lax;
//   if (!cctz::load_time_zone("America/Los_Angeles", &lax)) { ... }
//
// See also:
// - http://www.iana.org/time-zones
// - https://en.wikipedia.org/wiki/Zoneinfo
class time_zone {
 public:
  time_zone() : time_zone(nullptr) {}  // Equivalent to UTC
  time_zone(const time_zone&) = default;
  time_zone& operator=(const time_zone&) = default;

  std::string name() const;

  // An absolute_lookup represents the civil time (cctz::civil_second) within
  // this time_zone at the given absolute time (time_point). There are
  // additionally a few other fields that may be useful when working with
  // older APIs, such as std::tm.
  //
  // Example:
  //   const cctz::time_zone tz = ...
  //   const auto tp = std::chrono::system_clock::now();
  //   const cctz::time_zone::absolute_lookup al = tz.lookup(tp);
  struct absolute_lookup {
    civil_second cs;
    // Note: The following fields exist for backward compatibility with older
    // APIs. Accessing these fields directly is a sign of imprudent logic in
    // the calling code. Modern time-related code should only access this data
    // indirectly by way of cctz::format().
    int offset;        // civil seconds east of UTC
    bool is_dst;       // is offset non-standard?
    const char* abbr;  // time-zone abbreviation (e.g., "PST")
  };
  absolute_lookup lookup(const time_point<seconds>& tp) const;
  template <typename D>
  absolute_lookup lookup(const time_point<D>& tp) const {
    return lookup(detail::split_seconds(tp).first);
  }

  // A civil_lookup represents the absolute time(s) (time_point) that
  // correspond to the given civil time (cctz::civil_second) within this
  // time_zone. Usually the given civil time represents a unique instant
  // in time, in which case the conversion is unambiguous. However,
  // within this time zone, the given civil time may be skipped (e.g.,
  // during a positive UTC offset shift), or repeated (e.g., during a
  // negative UTC offset shift). To account for these possibilities,
  // civil_lookup is richer than just a single time_point.
  //
  // In all cases the civil_lookup::kind enum will indicate the nature
  // of the given civil-time argument, and the pre, trans, and post
  // members will give the absolute time answers using the pre-transition
  // offset, the transition point itself, and the post-transition offset,
  // respectively (all three times are equal if kind == UNIQUE). If any
  // of these three absolute times is outside the representable range of a
  // time_point<seconds> the field is set to its maximum/minimum value.
  //
  // Example:
  //   cctz::time_zone lax;
  //   if (!cctz::load_time_zone("America/Los_Angeles", &lax)) { ... }
  //
  //   // A unique civil time.
  //   auto jan01 = lax.lookup(cctz::civil_second(2011, 1, 1, 0, 0, 0));
  //   // jan01.kind == cctz::time_zone::civil_lookup::UNIQUE
  //   // jan01.pre    is 2011/01/01 00:00:00 -0800
  //   // jan01.trans  is 2011/01/01 00:00:00 -0800
  //   // jan01.post   is 2011/01/01 00:00:00 -0800
  //
  //   // A Spring DST transition, when there is a gap in civil time.
  //   auto mar13 = lax.lookup(cctz::civil_second(2011, 3, 13, 2, 15, 0));
  //   // mar13.kind == cctz::time_zone::civil_lookup::SKIPPED
  //   // mar13.pre   is 2011/03/13 03:15:00 -0700
  //   // mar13.trans is 2011/03/13 03:00:00 -0700
  //   // mar13.post  is 2011/03/13 01:15:00 -0800
  //
  //   // A Fall DST transition, when civil times are repeated.
  //   auto nov06 = lax.lookup(cctz::civil_second(2011, 11, 6, 1, 15, 0));
  //   // nov06.kind == cctz::time_zone::civil_lookup::REPEATED
  //   // nov06.pre   is 2011/11/06 01:15:00 -0700
  //   // nov06.trans is 2011/11/06 01:00:00 -0800
  //   // nov06.post  is 2011/11/06 01:15:00 -0800
  struct civil_lookup {
    enum civil_kind {
      UNIQUE,    // the civil time was singular (pre == trans == post)
      SKIPPED,   // the civil time did not exist (pre >= trans > post)
      REPEATED,  // the civil time was ambiguous (pre < trans <= post)
    } kind;
    time_point<seconds> pre;    // uses the pre-transition offset
    time_point<seconds> trans;  // instant of civil-offset change
    time_point<seconds> post;   // uses the post-transition offset
  };
  civil_lookup lookup(const civil_second& cs) const;

  // Finds the time of the next/previous offset change in this time zone.
  //
  // By definition, next_transition(tp, &trans) returns false when tp has
  // its maximum value, and prev_transition(tp, &trans) returns false
  // when tp has its minimum value. If the zone has no transitions, the
  // result will also be false no matter what the argument.
  //
  // Otherwise, when tp has its minimum value, next_transition(tp, &trans)
  // returns true and sets trans to the first recorded transition. Chains
  // of calls to next_transition()/prev_transition() will eventually return
  // false, but it is unspecified exactly when next_transition(tp, &trans)
  // jumps to false, or what time is set by prev_transition(tp, &trans) for
  // a very distant tp.
  //
  // Note: Enumeration of time-zone transitions is for informational purposes
  // only. Modern time-related code should not care about when offset changes
  // occur.
  //
  // Example:
  //   cctz::time_zone nyc;
  //   if (!cctz::load_time_zone("America/New_York", &nyc)) { ... }
  //   const auto now = std::chrono::system_clock::now();
  //   auto tp = cctz::time_point<cctz::seconds>::min();
  //   cctz::time_zone::civil_transition trans;
  //   while (tp <= now && nyc.next_transition(tp, &trans)) {
  //     // transition: trans.from -> trans.to
  //     tp = nyc.lookup(trans.to).trans;
  //   }
  struct civil_transition {
    civil_second from;  // the civil time we jump from
    civil_second to;    // the civil time we jump to
  };
  bool next_transition(const time_point<seconds>& tp,
                       civil_transition* trans) const;
  template <typename D>
  bool next_transition(const time_point<D>& tp, civil_transition* trans) const {
    return next_transition(detail::split_seconds(tp).first, trans);
  }
  bool prev_transition(const time_point<seconds>& tp,
                       civil_transition* trans) const;
  template <typename D>
  bool prev_transition(const time_point<D>& tp, civil_transition* trans) const {
    return prev_transition(detail::split_seconds(tp).first, trans);
  }

  // version() and description() provide additional information about the
  // time zone. The content of each of the returned strings is unspecified,
  // however, when the IANA Time Zone Database is the underlying data source
  // the version() string will be in the familar form (e.g, "2018e") or
  // empty when unavailable.
  //
  // Note: These functions are for informational or testing purposes only.
  std::string version() const;  // empty when unknown
  std::string description() const;

  // Relational operators.
  friend bool operator==(time_zone lhs, time_zone rhs) {
    return &lhs.effective_impl() == &rhs.effective_impl();
  }
  friend bool operator!=(time_zone lhs, time_zone rhs) { return !(lhs == rhs); }

  template <typename H>
  friend H AbslHashValue(H h, time_zone tz) {
    return H::combine(std::move(h), &tz.effective_impl());
  }

  class Impl;

 private:
  explicit time_zone(const Impl* impl) : impl_(impl) {}
  const Impl& effective_impl() const;  // handles implicit UTC
  const Impl* impl_;
};

// Loads the named time zone. May perform I/O on the initial load.
// If the name is invalid, or some other kind of error occurs, returns
// false and "*tz" is set to the UTC time zone.
bool load_time_zone(const std::string& name, time_zone* tz);

// Returns a time_zone representing UTC. Cannot fail.
time_zone utc_time_zone();

// Returns a time zone that is a fixed offset (seconds east) from UTC.
// Note: If the absolute value of the offset is greater than 24 hours
// you'll get UTC (i.e., zero offset) instead.
time_zone fixed_time_zone(const seconds& offset);

// Returns a time zone representing the local time zone. Falls back to UTC.
// Note: local_time_zone.name() may only be something like "localtime".
time_zone local_time_zone();

// Returns the civil time (cctz::civil_second) within the given time zone at
// the given absolute time (time_point). Since the additional fields provided
// by the time_zone::absolute_lookup struct should rarely be needed in modern
// code, this convert() function is simpler and should be preferred.
template <typename D>
inline civil_second convert(const time_point<D>& tp, const time_zone& tz) {
  return tz.lookup(tp).cs;
}

// Returns the absolute time (time_point) that corresponds to the given civil
// time within the given time zone. If the civil time is not unique (i.e., if
// it was either repeated or non-existent), then the returned time_point is
// the best estimate that preserves relative order. That is, this function
// guarantees that if cs1 < cs2, then convert(cs1, tz) <= convert(cs2, tz).
inline time_point<seconds> convert(const civil_second& cs,
                                   const time_zone& tz) {
  const time_zone::civil_lookup cl = tz.lookup(cs);
  if (cl.kind == time_zone::civil_lookup::SKIPPED) return cl.trans;
  return cl.pre;
}

namespace detail {
using femtoseconds = std::chrono::duration<std::int_fast64_t, std::femto>;
std::string format(const std::string&, const time_point<seconds>&,
                   const femtoseconds&, const time_zone&);
bool parse(const std::string&, const std::string&, const time_zone&,
           time_point<seconds>*, femtoseconds*, std::string* err = nullptr);
template <typename Rep, std::intmax_t Denom>
bool join_seconds(
    const time_point<seconds>& sec, const femtoseconds& fs,
    time_point<std::chrono::duration<Rep, std::ratio<1, Denom>>>* tpp);
template <typename Rep, std::intmax_t Num>
bool join_seconds(
    const time_point<seconds>& sec, const femtoseconds& fs,
    time_point<std::chrono::duration<Rep, std::ratio<Num, 1>>>* tpp);
template <typename Rep>
bool join_seconds(
    const time_point<seconds>& sec, const femtoseconds& fs,
    time_point<std::chrono::duration<Rep, std::ratio<1, 1>>>* tpp);
bool join_seconds(const time_point<seconds>& sec, const femtoseconds&,
                  time_point<seconds>* tpp);
}  // namespace detail

// Formats the given time_point in the given cctz::time_zone according to
// the provided format string. Uses strftime()-like formatting options,
// with the following extensions:
//
//   - %Ez  - RFC3339-compatible numeric UTC offset (+hh:mm or -hh:mm)
//   - %E*z - Full-resolution numeric UTC offset (+hh:mm:ss or -hh:mm:ss)
//   - %E#S - Seconds with # digits of fractional precision
//   - %E*S - Seconds with full fractional precision (a literal '*')
//   - %E#f - Fractional seconds with # digits of precision
//   - %E*f - Fractional seconds with full precision (a literal '*')
//   - %E4Y - Four-character years (-999 ... -001, 0000, 0001 ... 9999)
//   - %ET  - The RFC3339 "date-time" separator "T"
//
// Note that %E0S behaves like %S, and %E0f produces no characters. In
// contrast %E*f always produces at least one digit, which may be '0'.
//
// Note that %Y produces as many characters as it takes to fully render the
// year. A year outside of [-999:9999] when formatted with %E4Y will produce
// more than four characters, just like %Y.
//
// Tip: Format strings should include the UTC offset (e.g., %z, %Ez, or %E*z)
// so that the resulting string uniquely identifies an absolute time.
//
// Example:
//   cctz::time_zone lax;
//   if (!cctz::load_time_zone("America/Los_Angeles", &lax)) { ... }
//   auto tp = cctz::convert(cctz::civil_second(2013, 1, 2, 3, 4, 5), lax);
//   std::string f = cctz::format("%H:%M:%S", tp, lax);  // "03:04:05"
//   f = cctz::format("%H:%M:%E3S", tp, lax);            // "03:04:05.000"
template <typename D>
inline std::string format(const std::string& fmt, const time_point<D>& tp,
                          const time_zone& tz) {
  const auto p = detail::split_seconds(tp);
  const auto n = std::chrono::duration_cast<detail::femtoseconds>(p.second);
  return detail::format(fmt, p.first, n, tz);
}

// Parses an input string according to the provided format string and
// returns the corresponding time_point. Uses strftime()-like formatting
// options, with the same extensions as cctz::format(), but with the
// exceptions that %E#S is interpreted as %E*S, and %E#f as %E*f. %Ez
// and %E*z also accept the same inputs, which (along with %z) includes
// 'z' and 'Z' as synonyms for +00:00.  %ET accepts either 'T' or 't'.
//
// %Y consumes as many numeric characters as it can, so the matching data
// should always be terminated with a non-numeric. %E4Y always consumes
// exactly four characters, including any sign.
//
// Unspecified fields are taken from the default date and time of ...
//
//   "1970-01-01 00:00:00.0 +0000"
//
// For example, parsing a string of "15:45" (%H:%M) will return a time_point
// that represents "1970-01-01 15:45:00.0 +0000".
//
// Note that parse() returns time instants, so it makes most sense to parse
// fully-specified date/time strings that include a UTC offset (%z, %Ez, or
// %E*z).
//
// Note also that parse() only heeds the fields year, month, day, hour,
// minute, (fractional) second, and UTC offset. Other fields, like weekday (%a
// or %A), while parsed for syntactic validity, are ignored in the conversion.
//
// Date and time fields that are out-of-range will be treated as errors rather
// than normalizing them like cctz::civil_second() would do. For example, it
// is an error to parse the date "Oct 32, 2013" because 32 is out of range.
//
// A second of ":60" is normalized to ":00" of the following minute with
// fractional seconds discarded. The following table shows how the given
// seconds and subseconds will be parsed:
//
//   "59.x" -> 59.x  // exact
//   "60.x" -> 00.0  // normalized
//   "00.x" -> 00.x  // exact
//
// Errors are indicated by returning false.
//
// Example:
//   const cctz::time_zone tz = ...
//   std::chrono::system_clock::time_point tp;
//   if (cctz::parse("%Y-%m-%d", "2015-10-09", tz, &tp)) {
//     ...
//   }
template <typename D>
inline bool parse(const std::string& fmt, const std::string& input,
                  const time_zone& tz, time_point<D>* tpp) {
  time_point<seconds> sec;
  detail::femtoseconds fs;
  return detail::parse(fmt, input, tz, &sec, &fs) &&
         detail::join_seconds(sec, fs, tpp);
}

namespace detail {

// Split a time_point<D> into a time_point<seconds> and a D subseconds.
// Undefined behavior if time_point<seconds> is not of sufficient range.
// Note that this means it is UB to call cctz::time_zone::lookup(tp) or
// cctz::format(fmt, tp, tz) with a time_point that is outside the range
// of a 64-bit std::time_t.
template <typename D>
std::pair<time_point<seconds>, D> split_seconds(const time_point<D>& tp) {
  auto sec = std::chrono::time_point_cast<seconds>(tp);
  auto sub = tp - sec;
  if (sub.count() < 0) {
    sec -= seconds(1);
    sub += seconds(1);
  }
  return {sec, std::chrono::duration_cast<D>(sub)};
}

inline std::pair<time_point<seconds>, seconds> split_seconds(
    const time_point<seconds>& tp) {
  return {tp, seconds::zero()};
}

// Join a time_point<seconds> and femto subseconds into a time_point<D>.
// Floors to the resolution of time_point<D>. Returns false if time_point<D>
// is not of sufficient range.
template <typename Rep, std::intmax_t Denom>
bool join_seconds(
    const time_point<seconds>& sec, const femtoseconds& fs,
    time_point<std::chrono::duration<Rep, std::ratio<1, Denom>>>* tpp) {
  using D = std::chrono::duration<Rep, std::ratio<1, Denom>>;
  // TODO(#199): Return false if result unrepresentable as a time_point<D>.
  *tpp = std::chrono::time_point_cast<D>(sec);
  *tpp += std::chrono::duration_cast<D>(fs);
  return true;
}

template <typename Rep, std::intmax_t Num>
bool join_seconds(
    const time_point<seconds>& sec, const femtoseconds&,
    time_point<std::chrono::duration<Rep, std::ratio<Num, 1>>>* tpp) {
  using D = std::chrono::duration<Rep, std::ratio<Num, 1>>;
  auto count = sec.time_since_epoch().count();
  if (count >= 0 || count % Num == 0) {
    count /= Num;
  } else {
    count /= Num;
    count -= 1;
  }
  if (count > (std::numeric_limits<Rep>::max)()) return false;
  if (count < (std::numeric_limits<Rep>::min)()) return false;
  *tpp = time_point<D>() + D{static_cast<Rep>(count)};
  return true;
}

template <typename Rep>
bool join_seconds(
    const time_point<seconds>& sec, const femtoseconds&,
    time_point<std::chrono::duration<Rep, std::ratio<1, 1>>>* tpp) {
  using D = std::chrono::duration<Rep, std::ratio<1, 1>>;
  auto count = sec.time_since_epoch().count();
  if (count > (std::numeric_limits<Rep>::max)()) return false;
  if (count < (std::numeric_limits<Rep>::min)()) return false;
  *tpp = time_point<D>() + D{static_cast<Rep>(count)};
  return true;
}

inline bool join_seconds(const time_point<seconds>& sec, const femtoseconds&,
                         time_point<seconds>* tpp) {
  *tpp = sec;
  return true;
}

}  // namespace detail
}  // namespace cctz
}  // namespace time_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_H_
                                                                                                                                                                                                                                             node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/include/cctz/zone_info_source.h  0000664 0000000 0000000 00000007254 14746647661 0033170 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

#ifndef ABSL_TIME_INTERNAL_CCTZ_ZONE_INFO_SOURCE_H_
#define ABSL_TIME_INTERNAL_CCTZ_ZONE_INFO_SOURCE_H_

#include <cstddef>
#include <functional>
#include <memory>
#include <string>

#include "absl/base/config.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {
namespace cctz {

// A stdio-like interface for providing zoneinfo data for a particular zone.
class ZoneInfoSource {
 public:
  virtual ~ZoneInfoSource();

  virtual std::size_t Read(void* ptr, std::size_t size) = 0;  // like fread()
  virtual int Skip(std::size_t offset) = 0;                   // like fseek()

  // Until the zoneinfo data supports versioning information, we provide
  // a way for a ZoneInfoSource to indicate it out-of-band.  The default
  // implementation returns an empty string.
  virtual std::string Version() const;
};

}  // namespace cctz
}  // namespace time_internal
ABSL_NAMESPACE_END
}  // namespace absl

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {
namespace cctz_extension {

// A function-pointer type for a factory that returns a ZoneInfoSource
// given the name of a time zone and a fallback factory.  Returns null
// when the data for the named zone cannot be found.
using ZoneInfoSourceFactory =
    std::unique_ptr<absl::time_internal::cctz::ZoneInfoSource> (*)(
        const std::string&,
        const std::function<std::unique_ptr<
            absl::time_internal::cctz::ZoneInfoSource>(const std::string&)>&);

// The user can control the mapping of zone names to zoneinfo data by
// providing a definition for cctz_extension::zone_info_source_factory.
// For example, given functions my_factory() and my_other_factory() that
// can return a ZoneInfoSource for a named zone, we could inject them into
// cctz::load_time_zone() with:
//
//   namespace cctz_extension {
//   namespace {
//   std::unique_ptr<cctz::ZoneInfoSource> CustomFactory(
//       const std::string& name,
//       const std::function<std::unique_ptr<cctz::ZoneInfoSource>(
//           const std::string& name)>& fallback_factory) {
//     if (auto zip = my_factory(name)) return zip;
//     if (auto zip = fallback_factory(name)) return zip;
//     if (auto zip = my_other_factory(name)) return zip;
//     return nullptr;
//   }
//   }  // namespace
//   ZoneInfoSourceFactory zone_info_source_factory = CustomFactory;
//   }  // namespace cctz_extension
//
// This might be used, say, to use zoneinfo data embedded in the program,
// or read from a (possibly compressed) file archive, or both.
//
// cctz_extension::zone_info_source_factory() will be called:
//   (1) from the same thread as the cctz::load_time_zone() call,
//   (2) only once for any zone name, and
//   (3) serially (i.e., no concurrent execution).
//
// The fallback factory obtains zoneinfo data by reading files in ${TZDIR},
// and it is used automatically when no zone_info_source_factory definition
// is linked into the program.
extern ZoneInfoSourceFactory zone_info_source_factory;

}  // namespace cctz_extension
}  // namespace time_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_TIME_INTERNAL_CCTZ_ZONE_INFO_SOURCE_H_
                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/src/                             0000775 0000000 0000000 00000000000 14746647661 0025642 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/src/cctz_benchmark.cc            0000664 0000000 0000000 00000120322 14746647661 0031126 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

#include <algorithm>
#include <cassert>
#include <chrono>
#include <ctime>
#include <random>
#include <string>
#include <vector>

#include "benchmark/benchmark.h"
#include "absl/time/internal/cctz/include/cctz/civil_time.h"
#include "absl/time/internal/cctz/include/cctz/time_zone.h"
#include "time_zone_impl.h"

namespace {

namespace cctz = absl::time_internal::cctz;

void BM_Difference_Days(benchmark::State& state) {
  const cctz::civil_day c(2014, 8, 22);
  const cctz::civil_day epoch(1970, 1, 1);
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(c - epoch);
  }
}
BENCHMARK(BM_Difference_Days);

void BM_Step_Days(benchmark::State& state) {
  const cctz::civil_day kStart(2014, 8, 22);
  cctz::civil_day c = kStart;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(++c);
  }
}
BENCHMARK(BM_Step_Days);

void BM_GetWeekday(benchmark::State& state) {
  const cctz::civil_day c(2014, 8, 22);
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(cctz::get_weekday(c));
  }
}
BENCHMARK(BM_GetWeekday);

void BM_NextWeekday(benchmark::State& state) {
  const cctz::civil_day kStart(2014, 8, 22);
  const cctz::civil_day kDays[7] = {
      kStart + 0, kStart + 1, kStart + 2, kStart + 3,
      kStart + 4, kStart + 5, kStart + 6,
  };
  const cctz::weekday kWeekdays[7] = {
      cctz::weekday::monday,   cctz::weekday::tuesday, cctz::weekday::wednesday,
      cctz::weekday::thursday, cctz::weekday::friday,  cctz::weekday::saturday,
      cctz::weekday::sunday,
  };
  while (state.KeepRunningBatch(7 * 7)) {
    for (const auto from : kDays) {
      for (const auto to : kWeekdays) {
        benchmark::DoNotOptimize(cctz::next_weekday(from, to));
      }
    }
  }
}
BENCHMARK(BM_NextWeekday);

void BM_PrevWeekday(benchmark::State& state) {
  const cctz::civil_day kStart(2014, 8, 22);
  const cctz::civil_day kDays[7] = {
      kStart + 0, kStart + 1, kStart + 2, kStart + 3,
      kStart + 4, kStart + 5, kStart + 6,
  };
  const cctz::weekday kWeekdays[7] = {
      cctz::weekday::monday,   cctz::weekday::tuesday, cctz::weekday::wednesday,
      cctz::weekday::thursday, cctz::weekday::friday,  cctz::weekday::saturday,
      cctz::weekday::sunday,
  };
  while (state.KeepRunningBatch(7 * 7)) {
    for (const auto from : kDays) {
      for (const auto to : kWeekdays) {
        benchmark::DoNotOptimize(cctz::prev_weekday(from, to));
      }
    }
  }
}
BENCHMARK(BM_PrevWeekday);

const char RFC3339_full[] = "%Y-%m-%d%ET%H:%M:%E*S%Ez";
const char RFC3339_sec[] = "%Y-%m-%d%ET%H:%M:%S%Ez";

const char RFC1123_full[] = "%a, %d %b %Y %H:%M:%S %z";
const char RFC1123_no_wday[] = "%d %b %Y %H:%M:%S %z";

// A list of known time-zone names.
// TODO: Refactor with src/time_zone_lookup_test.cc.
const char* const kTimeZoneNames[] = {"Africa/Abidjan",
                                      "Africa/Accra",
                                      "Africa/Addis_Ababa",
                                      "Africa/Algiers",
                                      "Africa/Asmara",
                                      "Africa/Bamako",
                                      "Africa/Bangui",
                                      "Africa/Banjul",
                                      "Africa/Bissau",
                                      "Africa/Blantyre",
                                      "Africa/Brazzaville",
                                      "Africa/Bujumbura",
                                      "Africa/Cairo",
                                      "Africa/Casablanca",
                                      "Africa/Ceuta",
                                      "Africa/Conakry",
                                      "Africa/Dakar",
                                      "Africa/Dar_es_Salaam",
                                      "Africa/Djibouti",
                                      "Africa/Douala",
                                      "Africa/El_Aaiun",
                                      "Africa/Freetown",
                                      "Africa/Gaborone",
                                      "Africa/Harare",
                                      "Africa/Johannesburg",
                                      "Africa/Juba",
                                      "Africa/Kampala",
                                      "Africa/Khartoum",
                                      "Africa/Kigali",
                                      "Africa/Kinshasa",
                                      "Africa/Lagos",
                                      "Africa/Libreville",
                                      "Africa/Lome",
                                      "Africa/Luanda",
                                      "Africa/Lubumbashi",
                                      "Africa/Lusaka",
                                      "Africa/Malabo",
                                      "Africa/Maputo",
                                      "Africa/Maseru",
                                      "Africa/Mbabane",
                                      "Africa/Mogadishu",
                                      "Africa/Monrovia",
                                      "Africa/Nairobi",
                                      "Africa/Ndjamena",
                                      "Africa/Niamey",
                                      "Africa/Nouakchott",
                                      "Africa/Ouagadougou",
                                      "Africa/Porto-Novo",
                                      "Africa/Sao_Tome",
                                      "Africa/Timbuktu",
                                      "Africa/Tripoli",
                                      "Africa/Tunis",
                                      "Africa/Windhoek",
                                      "America/Adak",
                                      "America/Anchorage",
                                      "America/Anguilla",
                                      "America/Antigua",
                                      "America/Araguaina",
                                      "America/Argentina/Buenos_Aires",
                                      "America/Argentina/Catamarca",
                                      "America/Argentina/Cordoba",
                                      "America/Argentina/Jujuy",
                                      "America/Argentina/La_Rioja",
                                      "America/Argentina/Mendoza",
                                      "America/Argentina/Rio_Gallegos",
                                      "America/Argentina/Salta",
                                      "America/Argentina/San_Juan",
                                      "America/Argentina/San_Luis",
                                      "America/Argentina/Tucuman",
                                      "America/Argentina/Ushuaia",
                                      "America/Aruba",
                                      "America/Asuncion",
                                      "America/Atikokan",
                                      "America/Atka",
                                      "America/Bahia",
                                      "America/Bahia_Banderas",
                                      "America/Barbados",
                                      "America/Belem",
                                      "America/Belize",
                                      "America/Blanc-Sablon",
                                      "America/Boa_Vista",
                                      "America/Bogota",
                                      "America/Boise",
                                      "America/Cambridge_Bay",
                                      "America/Campo_Grande",
                                      "America/Cancun",
                                      "America/Caracas",
                                      "America/Cayenne",
                                      "America/Cayman",
                                      "America/Chicago",
                                      "America/Chihuahua",
                                      "America/Ciudad_Juarez",
                                      "America/Coral_Harbour",
                                      "America/Costa_Rica",
                                      "America/Creston",
                                      "America/Cuiaba",
                                      "America/Curacao",
                                      "America/Danmarkshavn",
                                      "America/Dawson",
                                      "America/Dawson_Creek",
                                      "America/Denver",
                                      "America/Detroit",
                                      "America/Dominica",
                                      "America/Edmonton",
                                      "America/Eirunepe",
                                      "America/El_Salvador",
                                      "America/Ensenada",
                                      "America/Fort_Nelson",
                                      "America/Fortaleza",
                                      "America/Glace_Bay",
                                      "America/Godthab",
                                      "America/Goose_Bay",
                                      "America/Grand_Turk",
                                      "America/Grenada",
                                      "America/Guadeloupe",
                                      "America/Guatemala",
                                      "America/Guayaquil",
                                      "America/Guyana",
                                      "America/Halifax",
                                      "America/Havana",
                                      "America/Hermosillo",
                                      "America/Indiana/Indianapolis",
                                      "America/Indiana/Knox",
                                      "America/Indiana/Marengo",
                                      "America/Indiana/Petersburg",
                                      "America/Indiana/Tell_City",
                                      "America/Indiana/Vevay",
                                      "America/Indiana/Vincennes",
                                      "America/Indiana/Winamac",
                                      "America/Inuvik",
                                      "America/Iqaluit",
                                      "America/Jamaica",
                                      "America/Juneau",
                                      "America/Kentucky/Louisville",
                                      "America/Kentucky/Monticello",
                                      "America/Kralendijk",
                                      "America/La_Paz",
                                      "America/Lima",
                                      "America/Los_Angeles",
                                      "America/Lower_Princes",
                                      "America/Maceio",
                                      "America/Managua",
                                      "America/Manaus",
                                      "America/Marigot",
                                      "America/Martinique",
                                      "America/Matamoros",
                                      "America/Mazatlan",
                                      "America/Menominee",
                                      "America/Merida",
                                      "America/Metlakatla",
                                      "America/Mexico_City",
                                      "America/Miquelon",
                                      "America/Moncton",
                                      "America/Monterrey",
                                      "America/Montevideo",
                                      "America/Montreal",
                                      "America/Montserrat",
                                      "America/Nassau",
                                      "America/New_York",
                                      "America/Nipigon",
                                      "America/Nome",
                                      "America/Noronha",
                                      "America/North_Dakota/Beulah",
                                      "America/North_Dakota/Center",
                                      "America/North_Dakota/New_Salem",
                                      "America/Nuuk",
                                      "America/Ojinaga",
                                      "America/Panama",
                                      "America/Pangnirtung",
                                      "America/Paramaribo",
                                      "America/Phoenix",
                                      "America/Port-au-Prince",
                                      "America/Port_of_Spain",
                                      "America/Porto_Acre",
                                      "America/Porto_Velho",
                                      "America/Puerto_Rico",
                                      "America/Punta_Arenas",
                                      "America/Rainy_River",
                                      "America/Rankin_Inlet",
                                      "America/Recife",
                                      "America/Regina",
                                      "America/Resolute",
                                      "America/Rio_Branco",
                                      "America/Santa_Isabel",
                                      "America/Santarem",
                                      "America/Santiago",
                                      "America/Santo_Domingo",
                                      "America/Sao_Paulo",
                                      "America/Scoresbysund",
                                      "America/Shiprock",
                                      "America/Sitka",
                                      "America/St_Barthelemy",
                                      "America/St_Johns",
                                      "America/St_Kitts",
                                      "America/St_Lucia",
                                      "America/St_Thomas",
                                      "America/St_Vincent",
                                      "America/Swift_Current",
                                      "America/Tegucigalpa",
                                      "America/Thule",
                                      "America/Thunder_Bay",
                                      "America/Tijuana",
                                      "America/Toronto",
                                      "America/Tortola",
                                      "America/Vancouver",
                                      "America/Virgin",
                                      "America/Whitehorse",
                                      "America/Winnipeg",
                                      "America/Yakutat",
                                      "America/Yellowknife",
                                      "Antarctica/Casey",
                                      "Antarctica/Davis",
                                      "Antarctica/DumontDUrville",
                                      "Antarctica/Macquarie",
                                      "Antarctica/Mawson",
                                      "Antarctica/McMurdo",
                                      "Antarctica/Palmer",
                                      "Antarctica/Rothera",
                                      "Antarctica/Syowa",
                                      "Antarctica/Troll",
                                      "Antarctica/Vostok",
                                      "Arctic/Longyearbyen",
                                      "Asia/Aden",
                                      "Asia/Almaty",
                                      "Asia/Amman",
                                      "Asia/Anadyr",
                                      "Asia/Aqtau",
                                      "Asia/Aqtobe",
                                      "Asia/Ashgabat",
                                      "Asia/Atyrau",
                                      "Asia/Baghdad",
                                      "Asia/Bahrain",
                                      "Asia/Baku",
                                      "Asia/Bangkok",
                                      "Asia/Barnaul",
                                      "Asia/Beirut",
                                      "Asia/Bishkek",
                                      "Asia/Brunei",
                                      "Asia/Chita",
                                      "Asia/Choibalsan",
                                      "Asia/Chongqing",
                                      "Asia/Colombo",
                                      "Asia/Damascus",
                                      "Asia/Dhaka",
                                      "Asia/Dili",
                                      "Asia/Dubai",
                                      "Asia/Dushanbe",
                                      "Asia/Famagusta",
                                      "Asia/Gaza",
                                      "Asia/Harbin",
                                      "Asia/Hebron",
                                      "Asia/Ho_Chi_Minh",
                                      "Asia/Hong_Kong",
                                      "Asia/Hovd",
                                      "Asia/Irkutsk",
                                      "Asia/Istanbul",
                                      "Asia/Jakarta",
                                      "Asia/Jayapura",
                                      "Asia/Jerusalem",
                                      "Asia/Kabul",
                                      "Asia/Kamchatka",
                                      "Asia/Karachi",
                                      "Asia/Kashgar",
                                      "Asia/Kathmandu",
                                      "Asia/Khandyga",
                                      "Asia/Kolkata",
                                      "Asia/Krasnoyarsk",
                                      "Asia/Kuala_Lumpur",
                                      "Asia/Kuching",
                                      "Asia/Kuwait",
                                      "Asia/Macau",
                                      "Asia/Magadan",
                                      "Asia/Makassar",
                                      "Asia/Manila",
                                      "Asia/Muscat",
                                      "Asia/Nicosia",
                                      "Asia/Novokuznetsk",
                                      "Asia/Novosibirsk",
                                      "Asia/Omsk",
                                      "Asia/Oral",
                                      "Asia/Phnom_Penh",
                                      "Asia/Pontianak",
                                      "Asia/Pyongyang",
                                      "Asia/Qatar",
                                      "Asia/Qostanay",
                                      "Asia/Qyzylorda",
                                      "Asia/Riyadh",
                                      "Asia/Sakhalin",
                                      "Asia/Samarkand",
                                      "Asia/Seoul",
                                      "Asia/Shanghai",
                                      "Asia/Singapore",
                                      "Asia/Srednekolymsk",
                                      "Asia/Taipei",
                                      "Asia/Tashkent",
                                      "Asia/Tbilisi",
                                      "Asia/Tehran",
                                      "Asia/Tel_Aviv",
                                      "Asia/Thimphu",
                                      "Asia/Tokyo",
                                      "Asia/Tomsk",
                                      "Asia/Ulaanbaatar",
                                      "Asia/Urumqi",
                                      "Asia/Ust-Nera",
                                      "Asia/Vientiane",
                                      "Asia/Vladivostok",
                                      "Asia/Yakutsk",
                                      "Asia/Yangon",
                                      "Asia/Yekaterinburg",
                                      "Asia/Yerevan",
                                      "Atlantic/Azores",
                                      "Atlantic/Bermuda",
                                      "Atlantic/Canary",
                                      "Atlantic/Cape_Verde",
                                      "Atlantic/Faroe",
                                      "Atlantic/Jan_Mayen",
                                      "Atlantic/Madeira",
                                      "Atlantic/Reykjavik",
                                      "Atlantic/South_Georgia",
                                      "Atlantic/St_Helena",
                                      "Atlantic/Stanley",
                                      "Australia/Adelaide",
                                      "Australia/Brisbane",
                                      "Australia/Broken_Hill",
                                      "Australia/Canberra",
                                      "Australia/Currie",
                                      "Australia/Darwin",
                                      "Australia/Eucla",
                                      "Australia/Hobart",
                                      "Australia/Lindeman",
                                      "Australia/Lord_Howe",
                                      "Australia/Melbourne",
                                      "Australia/Perth",
                                      "Australia/Sydney",
                                      "Australia/Yancowinna",
                                      "Etc/GMT",
                                      "Etc/GMT+0",
                                      "Etc/GMT+1",
                                      "Etc/GMT+10",
                                      "Etc/GMT+11",
                                      "Etc/GMT+12",
                                      "Etc/GMT+2",
                                      "Etc/GMT+3",
                                      "Etc/GMT+4",
                                      "Etc/GMT+5",
                                      "Etc/GMT+6",
                                      "Etc/GMT+7",
                                      "Etc/GMT+8",
                                      "Etc/GMT+9",
                                      "Etc/GMT-0",
                                      "Etc/GMT-1",
                                      "Etc/GMT-10",
                                      "Etc/GMT-11",
                                      "Etc/GMT-12",
                                      "Etc/GMT-13",
                                      "Etc/GMT-14",
                                      "Etc/GMT-2",
                                      "Etc/GMT-3",
                                      "Etc/GMT-4",
                                      "Etc/GMT-5",
                                      "Etc/GMT-6",
                                      "Etc/GMT-7",
                                      "Etc/GMT-8",
                                      "Etc/GMT-9",
                                      "Etc/GMT0",
                                      "Etc/Greenwich",
                                      "Etc/UCT",
                                      "Etc/UTC",
                                      "Etc/Universal",
                                      "Etc/Zulu",
                                      "Europe/Amsterdam",
                                      "Europe/Andorra",
                                      "Europe/Astrakhan",
                                      "Europe/Athens",
                                      "Europe/Belfast",
                                      "Europe/Belgrade",
                                      "Europe/Berlin",
                                      "Europe/Bratislava",
                                      "Europe/Brussels",
                                      "Europe/Bucharest",
                                      "Europe/Budapest",
                                      "Europe/Busingen",
                                      "Europe/Chisinau",
                                      "Europe/Copenhagen",
                                      "Europe/Dublin",
                                      "Europe/Gibraltar",
                                      "Europe/Guernsey",
                                      "Europe/Helsinki",
                                      "Europe/Isle_of_Man",
                                      "Europe/Istanbul",
                                      "Europe/Jersey",
                                      "Europe/Kaliningrad",
                                      "Europe/Kirov",
                                      "Europe/Kyiv",
                                      "Europe/Lisbon",
                                      "Europe/Ljubljana",
                                      "Europe/London",
                                      "Europe/Luxembourg",
                                      "Europe/Madrid",
                                      "Europe/Malta",
                                      "Europe/Mariehamn",
                                      "Europe/Minsk",
                                      "Europe/Monaco",
                                      "Europe/Moscow",
                                      "Europe/Nicosia",
                                      "Europe/Oslo",
                                      "Europe/Paris",
                                      "Europe/Podgorica",
                                      "Europe/Prague",
                                      "Europe/Riga",
                                      "Europe/Rome",
                                      "Europe/Samara",
                                      "Europe/San_Marino",
                                      "Europe/Sarajevo",
                                      "Europe/Saratov",
                                      "Europe/Simferopol",
                                      "Europe/Skopje",
                                      "Europe/Sofia",
                                      "Europe/Stockholm",
                                      "Europe/Tallinn",
                                      "Europe/Tirane",
                                      "Europe/Tiraspol",
                                      "Europe/Ulyanovsk",
                                      "Europe/Vaduz",
                                      "Europe/Vatican",
                                      "Europe/Vienna",
                                      "Europe/Vilnius",
                                      "Europe/Volgograd",
                                      "Europe/Warsaw",
                                      "Europe/Zagreb",
                                      "Europe/Zurich",
                                      "Factory",
                                      "Indian/Antananarivo",
                                      "Indian/Chagos",
                                      "Indian/Christmas",
                                      "Indian/Cocos",
                                      "Indian/Comoro",
                                      "Indian/Kerguelen",
                                      "Indian/Mahe",
                                      "Indian/Maldives",
                                      "Indian/Mauritius",
                                      "Indian/Mayotte",
                                      "Indian/Reunion",
                                      "Pacific/Apia",
                                      "Pacific/Auckland",
                                      "Pacific/Bougainville",
                                      "Pacific/Chatham",
                                      "Pacific/Chuuk",
                                      "Pacific/Easter",
                                      "Pacific/Efate",
                                      "Pacific/Fakaofo",
                                      "Pacific/Fiji",
                                      "Pacific/Funafuti",
                                      "Pacific/Galapagos",
                                      "Pacific/Gambier",
                                      "Pacific/Guadalcanal",
                                      "Pacific/Guam",
                                      "Pacific/Honolulu",
                                      "Pacific/Johnston",
                                      "Pacific/Kanton",
                                      "Pacific/Kiritimati",
                                      "Pacific/Kosrae",
                                      "Pacific/Kwajalein",
                                      "Pacific/Majuro",
                                      "Pacific/Marquesas",
                                      "Pacific/Midway",
                                      "Pacific/Nauru",
                                      "Pacific/Niue",
                                      "Pacific/Norfolk",
                                      "Pacific/Noumea",
                                      "Pacific/Pago_Pago",
                                      "Pacific/Palau",
                                      "Pacific/Pitcairn",
                                      "Pacific/Pohnpei",
                                      "Pacific/Port_Moresby",
                                      "Pacific/Rarotonga",
                                      "Pacific/Saipan",
                                      "Pacific/Samoa",
                                      "Pacific/Tahiti",
                                      "Pacific/Tarawa",
                                      "Pacific/Tongatapu",
                                      "Pacific/Wake",
                                      "Pacific/Wallis",
                                      "Pacific/Yap",
                                      "UTC",
                                      nullptr};

std::vector<std::string> AllTimeZoneNames() {
  std::vector<std::string> names;
  for (const char* const* namep = kTimeZoneNames; *namep != nullptr; ++namep) {
    names.push_back(std::string("file:") + *namep);
  }
  assert(!names.empty());

  std::mt19937 urbg(42);  // a UniformRandomBitGenerator with fixed seed
  std::shuffle(names.begin(), names.end(), urbg);
  return names;
}

cctz::time_zone TestTimeZone() {
  cctz::time_zone tz;
  cctz::load_time_zone("America/Los_Angeles", &tz);
  return tz;
}

void BM_Zone_LoadUTCTimeZoneFirst(benchmark::State& state) {
  cctz::time_zone tz;
  cctz::load_time_zone("UTC", &tz);  // in case we're first
  cctz::time_zone::Impl::ClearTimeZoneMapTestOnly();
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(cctz::load_time_zone("UTC", &tz));
  }
}
BENCHMARK(BM_Zone_LoadUTCTimeZoneFirst);

void BM_Zone_LoadUTCTimeZoneLast(benchmark::State& state) {
  cctz::time_zone tz;
  for (const auto& name : AllTimeZoneNames()) {
    cctz::load_time_zone(name, &tz);  // prime cache
  }
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(cctz::load_time_zone("UTC", &tz));
  }
}
BENCHMARK(BM_Zone_LoadUTCTimeZoneLast);

void BM_Zone_LoadTimeZoneFirst(benchmark::State& state) {
  cctz::time_zone tz = cctz::utc_time_zone();  // in case we're first
  const std::string name = "file:America/Los_Angeles";
  while (state.KeepRunning()) {
    state.PauseTiming();
    cctz::time_zone::Impl::ClearTimeZoneMapTestOnly();
    state.ResumeTiming();
    benchmark::DoNotOptimize(cctz::load_time_zone(name, &tz));
  }
}
BENCHMARK(BM_Zone_LoadTimeZoneFirst);

void BM_Zone_LoadTimeZoneCached(benchmark::State& state) {
  cctz::time_zone tz = cctz::utc_time_zone();  // in case we're first
  cctz::time_zone::Impl::ClearTimeZoneMapTestOnly();
  const std::string name = "file:America/Los_Angeles";
  cctz::load_time_zone(name, &tz);  // prime cache
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(cctz::load_time_zone(name, &tz));
  }
}
BENCHMARK(BM_Zone_LoadTimeZoneCached);

void BM_Zone_LoadLocalTimeZoneCached(benchmark::State& state) {
  cctz::utc_time_zone();  // in case we're first
  cctz::time_zone::Impl::ClearTimeZoneMapTestOnly();
  cctz::local_time_zone();  // prime cache
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(cctz::local_time_zone());
  }
}
BENCHMARK(BM_Zone_LoadLocalTimeZoneCached);

void BM_Zone_LoadAllTimeZonesFirst(benchmark::State& state) {
  cctz::time_zone tz;
  const std::vector<std::string> names = AllTimeZoneNames();
  for (auto index = names.size(); state.KeepRunning(); ++index) {
    if (index == names.size()) {
      index = 0;
    }
    if (index == 0) {
      state.PauseTiming();
      cctz::time_zone::Impl::ClearTimeZoneMapTestOnly();
      state.ResumeTiming();
    }
    benchmark::DoNotOptimize(cctz::load_time_zone(names[index], &tz));
  }
}
BENCHMARK(BM_Zone_LoadAllTimeZonesFirst);

void BM_Zone_LoadAllTimeZonesCached(benchmark::State& state) {
  cctz::time_zone tz;
  const std::vector<std::string> names = AllTimeZoneNames();
  for (const auto& name : names) {
    cctz::load_time_zone(name, &tz);  // prime cache
  }
  for (auto index = names.size(); state.KeepRunning(); ++index) {
    if (index == names.size()) {
      index = 0;
    }
    benchmark::DoNotOptimize(cctz::load_time_zone(names[index], &tz));
  }
}
BENCHMARK(BM_Zone_LoadAllTimeZonesCached);

void BM_Zone_TimeZoneEqualityImplicit(benchmark::State& state) {
  cctz::time_zone tz;  // implicit UTC
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(tz == tz);
  }
}
BENCHMARK(BM_Zone_TimeZoneEqualityImplicit);

void BM_Zone_TimeZoneEqualityExplicit(benchmark::State& state) {
  cctz::time_zone tz = cctz::utc_time_zone();  // explicit UTC
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(tz == tz);
  }
}
BENCHMARK(BM_Zone_TimeZoneEqualityExplicit);

void BM_Zone_UTCTimeZone(benchmark::State& state) {
  cctz::time_zone tz;
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(cctz::utc_time_zone());
  }
}
BENCHMARK(BM_Zone_UTCTimeZone);

// In each "ToCivil" benchmark we switch between two instants separated
// by at least one transition in order to defeat any internal caching of
// previous results (e.g., see local_time_hint_).
//
// The "UTC" variants use UTC instead of the Google/local time zone.

void BM_Time_ToCivil_CCTZ(benchmark::State& state) {
  const cctz::time_zone tz = TestTimeZone();
  std::chrono::system_clock::time_point tp =
      std::chrono::system_clock::from_time_t(1384569027);
  std::chrono::system_clock::time_point tp2 =
      std::chrono::system_clock::from_time_t(1418962578);
  while (state.KeepRunning()) {
    std::swap(tp, tp2);
    tp += std::chrono::seconds(1);
    benchmark::DoNotOptimize(cctz::convert(tp, tz));
  }
}
BENCHMARK(BM_Time_ToCivil_CCTZ);

void BM_Time_ToCivil_Libc(benchmark::State& state) {
  // No timezone support, so just use localtime.
  time_t t = 1384569027;
  time_t t2 = 1418962578;
  struct tm tm;
  while (state.KeepRunning()) {
    std::swap(t, t2);
    t += 1;
#if defined(_WIN32) || defined(_WIN64)
    benchmark::DoNotOptimize(localtime_s(&tm, &t));
#else
    benchmark::DoNotOptimize(localtime_r(&t, &tm));
#endif
  }
}
BENCHMARK(BM_Time_ToCivil_Libc);

void BM_Time_ToCivilUTC_CCTZ(benchmark::State& state) {
  const cctz::time_zone tz = cctz::utc_time_zone();
  std::chrono::system_clock::time_point tp =
      std::chrono::system_clock::from_time_t(1384569027);
  while (state.KeepRunning()) {
    tp += std::chrono::seconds(1);
    benchmark::DoNotOptimize(cctz::convert(tp, tz));
  }
}
BENCHMARK(BM_Time_ToCivilUTC_CCTZ);

void BM_Time_ToCivilUTC_Libc(benchmark::State& state) {
  time_t t = 1384569027;
  struct tm tm;
  while (state.KeepRunning()) {
    t += 1;
#if defined(_WIN32) || defined(_WIN64)
    benchmark::DoNotOptimize(gmtime_s(&tm, &t));
#else
    benchmark::DoNotOptimize(gmtime_r(&t, &tm));
#endif
  }
}
BENCHMARK(BM_Time_ToCivilUTC_Libc);

// In each "FromCivil" benchmark we switch between two YMDhms values
// separated by at least one transition in order to defeat any internal
// caching of previous results (e.g., see time_local_hint_).
//
// The "UTC" variants use UTC instead of the Google/local time zone.
// The "Day0" variants require normalization of the day of month.

void BM_Time_FromCivil_CCTZ(benchmark::State& state) {
  const cctz::time_zone tz = TestTimeZone();
  int i = 0;
  while (state.KeepRunning()) {
    if ((i++ & 1) == 0) {
      benchmark::DoNotOptimize(
          cctz::convert(cctz::civil_second(2014, 12, 18, 20, 16, 18), tz));
    } else {
      benchmark::DoNotOptimize(
          cctz::convert(cctz::civil_second(2013, 11, 15, 18, 30, 27), tz));
    }
  }
}
BENCHMARK(BM_Time_FromCivil_CCTZ);

void BM_Time_FromCivil_Libc(benchmark::State& state) {
  // No timezone support, so just use localtime.
  int i = 0;
  while (state.KeepRunning()) {
    struct tm tm;
    if ((i++ & 1) == 0) {
      tm.tm_year = 2014 - 1900;
      tm.tm_mon = 12 - 1;
      tm.tm_mday = 18;
      tm.tm_hour = 20;
      tm.tm_min = 16;
      tm.tm_sec = 18;
    } else {
      tm.tm_year = 2013 - 1900;
      tm.tm_mon = 11 - 1;
      tm.tm_mday = 15;
      tm.tm_hour = 18;
      tm.tm_min = 30;
      tm.tm_sec = 27;
    }
    tm.tm_isdst = -1;
    benchmark::DoNotOptimize(mktime(&tm));
  }
}
BENCHMARK(BM_Time_FromCivil_Libc);

void BM_Time_FromCivilUTC_CCTZ(benchmark::State& state) {
  const cctz::time_zone tz = cctz::utc_time_zone();
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(
        cctz::convert(cctz::civil_second(2014, 12, 18, 20, 16, 18), tz));
  }
}
BENCHMARK(BM_Time_FromCivilUTC_CCTZ);

// There is no BM_Time_FromCivilUTC_Libc.

void BM_Time_FromCivilDay0_CCTZ(benchmark::State& state) {
  const cctz::time_zone tz = TestTimeZone();
  int i = 0;
  while (state.KeepRunning()) {
    if ((i++ & 1) == 0) {
      benchmark::DoNotOptimize(
          cctz::convert(cctz::civil_second(2014, 12, 0, 20, 16, 18), tz));
    } else {
      benchmark::DoNotOptimize(
          cctz::convert(cctz::civil_second(2013, 11, 0, 18, 30, 27), tz));
    }
  }
}
BENCHMARK(BM_Time_FromCivilDay0_CCTZ);

void BM_Time_FromCivilDay0_Libc(benchmark::State& state) {
  // No timezone support, so just use localtime.
  int i = 0;
  while (state.KeepRunning()) {
    struct tm tm;
    if ((i++ & 1) == 0) {
      tm.tm_year = 2014 - 1900;
      tm.tm_mon = 12 - 1;
      tm.tm_mday = 0;
      tm.tm_hour = 20;
      tm.tm_min = 16;
      tm.tm_sec = 18;
    } else {
      tm.tm_year = 2013 - 1900;
      tm.tm_mon = 11 - 1;
      tm.tm_mday = 0;
      tm.tm_hour = 18;
      tm.tm_min = 30;
      tm.tm_sec = 27;
    }
    tm.tm_isdst = -1;
    benchmark::DoNotOptimize(mktime(&tm));
  }
}
BENCHMARK(BM_Time_FromCivilDay0_Libc);

const char* const kFormats[] = {
    RFC1123_full,           // 0
    RFC1123_no_wday,        // 1
    RFC3339_full,           // 2
    RFC3339_sec,            // 3
    "%Y-%m-%d%ET%H:%M:%S",  // 4
    "%Y-%m-%d",             // 5
};
const int kNumFormats = sizeof(kFormats) / sizeof(kFormats[0]);

void BM_Format_FormatTime(benchmark::State& state) {
  const std::string fmt = kFormats[state.range(0)];
  state.SetLabel(fmt);
  const cctz::time_zone tz = TestTimeZone();
  const std::chrono::system_clock::time_point tp =
      cctz::convert(cctz::civil_second(1977, 6, 28, 9, 8, 7), tz) +
      std::chrono::microseconds(1);
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(cctz::format(fmt, tp, tz));
  }
}
BENCHMARK(BM_Format_FormatTime)->DenseRange(0, kNumFormats - 1);

void BM_Format_ParseTime(benchmark::State& state) {
  const std::string fmt = kFormats[state.range(0)];
  state.SetLabel(fmt);
  const cctz::time_zone tz = TestTimeZone();
  std::chrono::system_clock::time_point tp =
      cctz::convert(cctz::civil_second(1977, 6, 28, 9, 8, 7), tz) +
      std::chrono::microseconds(1);
  const std::string when = cctz::format(fmt, tp, tz);
  while (state.KeepRunning()) {
    benchmark::DoNotOptimize(cctz::parse(fmt, when, tz, &tp));
  }
}
BENCHMARK(BM_Format_ParseTime)->DenseRange(0, kNumFormats - 1);

}  // namespace
                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/src/civil_time_detail.cc         0000664 0000000 0000000 00000005657 14746647661 0031634 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

#include "absl/time/internal/cctz/include/cctz/civil_time_detail.h"

#include <iomanip>
#include <ostream>
#include <sstream>

#include "absl/base/config.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {
namespace cctz {
namespace detail {

// Output stream operators output a format matching YYYY-MM-DDThh:mm:ss,
// while omitting fields inferior to the type's alignment. For example,
// civil_day is formatted only as YYYY-MM-DD.
std::ostream& operator<<(std::ostream& os, const civil_year& y) {
  std::stringstream ss;
  ss << y.year();  // No padding.
  return os << ss.str();
}
std::ostream& operator<<(std::ostream& os, const civil_month& m) {
  std::stringstream ss;
  ss << civil_year(m) << '-';
  ss << std::setfill('0') << std::setw(2) << m.month();
  return os << ss.str();
}
std::ostream& operator<<(std::ostream& os, const civil_day& d) {
  std::stringstream ss;
  ss << civil_month(d) << '-';
  ss << std::setfill('0') << std::setw(2) << d.day();
  return os << ss.str();
}
std::ostream& operator<<(std::ostream& os, const civil_hour& h) {
  std::stringstream ss;
  ss << civil_day(h) << 'T';
  ss << std::setfill('0') << std::setw(2) << h.hour();
  return os << ss.str();
}
std::ostream& operator<<(std::ostream& os, const civil_minute& m) {
  std::stringstream ss;
  ss << civil_hour(m) << ':';
  ss << std::setfill('0') << std::setw(2) << m.minute();
  return os << ss.str();
}
std::ostream& operator<<(std::ostream& os, const civil_second& s) {
  std::stringstream ss;
  ss << civil_minute(s) << ':';
  ss << std::setfill('0') << std::setw(2) << s.second();
  return os << ss.str();
}

////////////////////////////////////////////////////////////////////////

std::ostream& operator<<(std::ostream& os, weekday wd) {
  switch (wd) {
    case weekday::monday:
      return os << "Monday";
    case weekday::tuesday:
      return os << "Tuesday";
    case weekday::wednesday:
      return os << "Wednesday";
    case weekday::thursday:
      return os << "Thursday";
    case weekday::friday:
      return os << "Friday";
    case weekday::saturday:
      return os << "Saturday";
    case weekday::sunday:
      return os << "Sunday";
  }
  return os;  // Should never get here, but -Wreturn-type may warn without this.
}

}  // namespace detail
}  // namespace cctz
}  // namespace time_internal
ABSL_NAMESPACE_END
}  // namespace absl
                                                                                 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/src/civil_time_test.cc           0000664 0000000 0000000 00000112336 14746647661 0031342 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

#include "absl/time/internal/cctz/include/cctz/civil_time.h"

#include <iomanip>
#include <limits>
#include <sstream>
#include <string>
#include <type_traits>

#include "gtest/gtest.h"
#include "absl/base/config.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {
namespace cctz {

namespace {

template <typename T>
std::string Format(const T& t) {
  std::stringstream ss;
  ss << t;
  return ss.str();
}

}  // namespace

#if __cpp_constexpr >= 201304 || (defined(_MSC_VER) && _MSC_VER >= 1910)
// Construction constexpr tests

TEST(CivilTime, Normal) {
  constexpr civil_second css(2016, 1, 28, 17, 14, 12);
  static_assert(css.second() == 12, "Normal.second");
  constexpr civil_minute cmm(2016, 1, 28, 17, 14);
  static_assert(cmm.minute() == 14, "Normal.minute");
  constexpr civil_hour chh(2016, 1, 28, 17);
  static_assert(chh.hour() == 17, "Normal.hour");
  constexpr civil_day cd(2016, 1, 28);
  static_assert(cd.day() == 28, "Normal.day");
  constexpr civil_month cm(2016, 1);
  static_assert(cm.month() == 1, "Normal.month");
  constexpr civil_year cy(2016);
  static_assert(cy.year() == 2016, "Normal.year");
}

TEST(CivilTime, Conversion) {
  constexpr civil_year cy(2016);
  static_assert(cy.year() == 2016, "Conversion.year");
  constexpr civil_month cm(cy);
  static_assert(cm.month() == 1, "Conversion.month");
  constexpr civil_day cd(cm);
  static_assert(cd.day() == 1, "Conversion.day");
  constexpr civil_hour chh(cd);
  static_assert(chh.hour() == 0, "Conversion.hour");
  constexpr civil_minute cmm(chh);
  static_assert(cmm.minute() == 0, "Conversion.minute");
  constexpr civil_second css(cmm);
  static_assert(css.second() == 0, "Conversion.second");
}

// Normalization constexpr tests

TEST(CivilTime, Normalized) {
  constexpr civil_second cs(2016, 1, 28, 17, 14, 12);
  static_assert(cs.year() == 2016, "Normalized.year");
  static_assert(cs.month() == 1, "Normalized.month");
  static_assert(cs.day() == 28, "Normalized.day");
  static_assert(cs.hour() == 17, "Normalized.hour");
  static_assert(cs.minute() == 14, "Normalized.minute");
  static_assert(cs.second() == 12, "Normalized.second");
}

TEST(CivilTime, SecondOverflow) {
  constexpr civil_second cs(2016, 1, 28, 17, 14, 121);
  static_assert(cs.year() == 2016, "SecondOverflow.year");
  static_assert(cs.month() == 1, "SecondOverflow.month");
  static_assert(cs.day() == 28, "SecondOverflow.day");
  static_assert(cs.hour() == 17, "SecondOverflow.hour");
  static_assert(cs.minute() == 16, "SecondOverflow.minute");
  static_assert(cs.second() == 1, "SecondOverflow.second");
}

TEST(CivilTime, SecondUnderflow) {
  constexpr civil_second cs(2016, 1, 28, 17, 14, -121);
  static_assert(cs.year() == 2016, "SecondUnderflow.year");
  static_assert(cs.month() == 1, "SecondUnderflow.month");
  static_assert(cs.day() == 28, "SecondUnderflow.day");
  static_assert(cs.hour() == 17, "SecondUnderflow.hour");
  static_assert(cs.minute() == 11, "SecondUnderflow.minute");
  static_assert(cs.second() == 59, "SecondUnderflow.second");
}

TEST(CivilTime, MinuteOverflow) {
  constexpr civil_second cs(2016, 1, 28, 17, 121, 12);
  static_assert(cs.year() == 2016, "MinuteOverflow.year");
  static_assert(cs.month() == 1, "MinuteOverflow.month");
  static_assert(cs.day() == 28, "MinuteOverflow.day");
  static_assert(cs.hour() == 19, "MinuteOverflow.hour");
  static_assert(cs.minute() == 1, "MinuteOverflow.minute");
  static_assert(cs.second() == 12, "MinuteOverflow.second");
}

TEST(CivilTime, MinuteUnderflow) {
  constexpr civil_second cs(2016, 1, 28, 17, -121, 12);
  static_assert(cs.year() == 2016, "MinuteUnderflow.year");
  static_assert(cs.month() == 1, "MinuteUnderflow.month");
  static_assert(cs.day() == 28, "MinuteUnderflow.day");
  static_assert(cs.hour() == 14, "MinuteUnderflow.hour");
  static_assert(cs.minute() == 59, "MinuteUnderflow.minute");
  static_assert(cs.second() == 12, "MinuteUnderflow.second");
}

TEST(CivilTime, HourOverflow) {
  constexpr civil_second cs(2016, 1, 28, 49, 14, 12);
  static_assert(cs.year() == 2016, "HourOverflow.year");
  static_assert(cs.month() == 1, "HourOverflow.month");
  static_assert(cs.day() == 30, "HourOverflow.day");
  static_assert(cs.hour() == 1, "HourOverflow.hour");
  static_assert(cs.minute() == 14, "HourOverflow.minute");
  static_assert(cs.second() == 12, "HourOverflow.second");
}

TEST(CivilTime, HourUnderflow) {
  constexpr civil_second cs(2016, 1, 28, -49, 14, 12);
  static_assert(cs.year() == 2016, "HourUnderflow.year");
  static_assert(cs.month() == 1, "HourUnderflow.month");
  static_assert(cs.day() == 25, "HourUnderflow.day");
  static_assert(cs.hour() == 23, "HourUnderflow.hour");
  static_assert(cs.minute() == 14, "HourUnderflow.minute");
  static_assert(cs.second() == 12, "HourUnderflow.second");
}

TEST(CivilTime, MonthOverflow) {
  constexpr civil_second cs(2016, 25, 28, 17, 14, 12);
  static_assert(cs.year() == 2018, "MonthOverflow.year");
  static_assert(cs.month() == 1, "MonthOverflow.month");
  static_assert(cs.day() == 28, "MonthOverflow.day");
  static_assert(cs.hour() == 17, "MonthOverflow.hour");
  static_assert(cs.minute() == 14, "MonthOverflow.minute");
  static_assert(cs.second() == 12, "MonthOverflow.second");
}

TEST(CivilTime, MonthUnderflow) {
  constexpr civil_second cs(2016, -25, 28, 17, 14, 12);
  static_assert(cs.year() == 2013, "MonthUnderflow.year");
  static_assert(cs.month() == 11, "MonthUnderflow.month");
  static_assert(cs.day() == 28, "MonthUnderflow.day");
  static_assert(cs.hour() == 17, "MonthUnderflow.hour");
  static_assert(cs.minute() == 14, "MonthUnderflow.minute");
  static_assert(cs.second() == 12, "MonthUnderflow.second");
}

TEST(CivilTime, C4Overflow) {
  constexpr civil_second cs(2016, 1, 292195, 17, 14, 12);
  static_assert(cs.year() == 2816, "C4Overflow.year");
  static_assert(cs.month() == 1, "C4Overflow.month");
  static_assert(cs.day() == 1, "C4Overflow.day");
  static_assert(cs.hour() == 17, "C4Overflow.hour");
  static_assert(cs.minute() == 14, "C4Overflow.minute");
  static_assert(cs.second() == 12, "C4Overflow.second");
}

TEST(CivilTime, C4Underflow) {
  constexpr civil_second cs(2016, 1, -292195, 17, 14, 12);
  static_assert(cs.year() == 1215, "C4Underflow.year");
  static_assert(cs.month() == 12, "C4Underflow.month");
  static_assert(cs.day() == 30, "C4Underflow.day");
  static_assert(cs.hour() == 17, "C4Underflow.hour");
  static_assert(cs.minute() == 14, "C4Underflow.minute");
  static_assert(cs.second() == 12, "C4Underflow.second");
}

TEST(CivilTime, MixedNormalization) {
  constexpr civil_second cs(2016, -42, 122, 99, -147, 4949);
  static_assert(cs.year() == 2012, "MixedNormalization.year");
  static_assert(cs.month() == 10, "MixedNormalization.month");
  static_assert(cs.day() == 4, "MixedNormalization.day");
  static_assert(cs.hour() == 1, "MixedNormalization.hour");
  static_assert(cs.minute() == 55, "MixedNormalization.minute");
  static_assert(cs.second() == 29, "MixedNormalization.second");
}

// Relational constexpr tests

TEST(CivilTime, Less) {
  constexpr civil_second cs1(2016, 1, 28, 17, 14, 12);
  constexpr civil_second cs2(2016, 1, 28, 17, 14, 13);
  constexpr bool less = cs1 < cs2;
  static_assert(less, "Less");
}

// Arithmetic constexpr tests

TEST(CivilTime, Addition) {
  constexpr civil_second cs1(2016, 1, 28, 17, 14, 12);
  constexpr civil_second cs2 = cs1 + 50;
  static_assert(cs2.year() == 2016, "Addition.year");
  static_assert(cs2.month() == 1, "Addition.month");
  static_assert(cs2.day() == 28, "Addition.day");
  static_assert(cs2.hour() == 17, "Addition.hour");
  static_assert(cs2.minute() == 15, "Addition.minute");
  static_assert(cs2.second() == 2, "Addition.second");
}

TEST(CivilTime, Subtraction) {
  constexpr civil_second cs1(2016, 1, 28, 17, 14, 12);
  constexpr civil_second cs2 = cs1 - 50;
  static_assert(cs2.year() == 2016, "Subtraction.year");
  static_assert(cs2.month() == 1, "Subtraction.month");
  static_assert(cs2.day() == 28, "Subtraction.day");
  static_assert(cs2.hour() == 17, "Subtraction.hour");
  static_assert(cs2.minute() == 13, "Subtraction.minute");
  static_assert(cs2.second() == 22, "Subtraction.second");
}

TEST(CivilTime, Difference) {
  constexpr civil_day cd1(2016, 1, 28);
  constexpr civil_day cd2(2015, 1, 28);
  constexpr int diff = cd1 - cd2;
  static_assert(diff == 365, "Difference");
}

// NOTE: Run this with --copt=-ftrapv to detect overflow problems.
TEST(CivilTime, ConstructionWithHugeYear) {
  constexpr civil_hour h(-9223372036854775807, 1, 1, -1);
  static_assert(h.year() == -9223372036854775807 - 1,
                "ConstructionWithHugeYear");
  static_assert(h.month() == 12, "ConstructionWithHugeYear");
  static_assert(h.day() == 31, "ConstructionWithHugeYear");
  static_assert(h.hour() == 23, "ConstructionWithHugeYear");
}

// NOTE: Run this with --copt=-ftrapv to detect overflow problems.
TEST(CivilTime, DifferenceWithHugeYear) {
  {
    constexpr civil_day d1(9223372036854775807, 1, 1);
    constexpr civil_day d2(9223372036854775807, 12, 31);
    static_assert(d2 - d1 == 364, "DifferenceWithHugeYear");
  }
  {
    constexpr civil_day d1(-9223372036854775807 - 1, 1, 1);
    constexpr civil_day d2(-9223372036854775807 - 1, 12, 31);
    static_assert(d2 - d1 == 365, "DifferenceWithHugeYear");
  }
  {
    // Check the limits of the return value at the end of the year range.
    constexpr civil_day d1(9223372036854775807, 1, 1);
    constexpr civil_day d2(9198119301927009252, 6, 6);
    static_assert(d1 - d2 == 9223372036854775807, "DifferenceWithHugeYear");
    static_assert((d2 - 1) - d1 == -9223372036854775807 - 1,
                  "DifferenceWithHugeYear");
  }
  {
    // Check the limits of the return value at the start of the year range.
    constexpr civil_day d1(-9223372036854775807 - 1, 1, 1);
    constexpr civil_day d2(-9198119301927009254, 7, 28);
    static_assert(d2 - d1 == 9223372036854775807, "DifferenceWithHugeYear");
    static_assert(d1 - (d2 + 1) == -9223372036854775807 - 1,
                  "DifferenceWithHugeYear");
  }
  {
    // Check the limits of the return value from either side of year 0.
    constexpr civil_day d1(-12626367463883278, 9, 3);
    constexpr civil_day d2(12626367463883277, 3, 28);
    static_assert(d2 - d1 == 9223372036854775807, "DifferenceWithHugeYear");
    static_assert(d1 - (d2 + 1) == -9223372036854775807 - 1,
                  "DifferenceWithHugeYear");
  }
}

// NOTE: Run this with --copt=-ftrapv to detect overflow problems.
TEST(CivilTime, DifferenceNoIntermediateOverflow) {
  {
    // The difference up to the minute field would be below the minimum
    // diff_t, but the 52 extra seconds brings us back to the minimum.
    constexpr civil_second s1(-292277022657, 1, 27, 8, 29 - 1, 52);
    constexpr civil_second s2(1970, 1, 1, 0, 0 - 1, 0);
    static_assert(s1 - s2 == -9223372036854775807 - 1,
                  "DifferenceNoIntermediateOverflow");
  }
  {
    // The difference up to the minute field would be above the maximum
    // diff_t, but the -53 extra seconds brings us back to the maximum.
    constexpr civil_second s1(292277026596, 12, 4, 15, 30, 7 - 7);
    constexpr civil_second s2(1970, 1, 1, 0, 0, 0 - 7);
    static_assert(s1 - s2 == 9223372036854775807,
                  "DifferenceNoIntermediateOverflow");
  }
}

// Helper constexpr tests

TEST(CivilTime, WeekDay) {
  constexpr civil_day cd(2016, 1, 28);
  constexpr weekday wd = get_weekday(cd);
  static_assert(wd == weekday::thursday, "Weekday");
}

TEST(CivilTime, NextWeekDay) {
  constexpr civil_day cd(2016, 1, 28);
  constexpr civil_day next = next_weekday(cd, weekday::thursday);
  static_assert(next.year() == 2016, "NextWeekDay.year");
  static_assert(next.month() == 2, "NextWeekDay.month");
  static_assert(next.day() == 4, "NextWeekDay.day");
}

TEST(CivilTime, PrevWeekDay) {
  constexpr civil_day cd(2016, 1, 28);
  constexpr civil_day prev = prev_weekday(cd, weekday::thursday);
  static_assert(prev.year() == 2016, "PrevWeekDay.year");
  static_assert(prev.month() == 1, "PrevWeekDay.month");
  static_assert(prev.day() == 21, "PrevWeekDay.day");
}

TEST(CivilTime, YearDay) {
  constexpr civil_day cd(2016, 1, 28);
  constexpr int yd = get_yearday(cd);
  static_assert(yd == 28, "YearDay");
}
#endif  // __cpp_constexpr >= 201304 || (defined(_MSC_VER) && _MSC_VER >= 1910)

// The remaining tests do not use constexpr.

TEST(CivilTime, DefaultConstruction) {
  civil_second ss;
  EXPECT_EQ("1970-01-01T00:00:00", Format(ss));

  civil_minute mm;
  EXPECT_EQ("1970-01-01T00:00", Format(mm));

  civil_hour hh;
  EXPECT_EQ("1970-01-01T00", Format(hh));

  civil_day d;
  EXPECT_EQ("1970-01-01", Format(d));

  civil_month m;
  EXPECT_EQ("1970-01", Format(m));

  civil_year y;
  EXPECT_EQ("1970", Format(y));
}

TEST(CivilTime, StructMember) {
  struct S {
    civil_day day;
  };
  S s = {};
  EXPECT_EQ(civil_day{}, s.day);
}

TEST(CivilTime, FieldsConstruction) {
  EXPECT_EQ("2015-01-02T03:04:05", Format(civil_second(2015, 1, 2, 3, 4, 5)));
  EXPECT_EQ("2015-01-02T03:04:00", Format(civil_second(2015, 1, 2, 3, 4)));
  EXPECT_EQ("2015-01-02T03:00:00", Format(civil_second(2015, 1, 2, 3)));
  EXPECT_EQ("2015-01-02T00:00:00", Format(civil_second(2015, 1, 2)));
  EXPECT_EQ("2015-01-01T00:00:00", Format(civil_second(2015, 1)));
  EXPECT_EQ("2015-01-01T00:00:00", Format(civil_second(2015)));

  EXPECT_EQ("2015-01-02T03:04", Format(civil_minute(2015, 1, 2, 3, 4, 5)));
  EXPECT_EQ("2015-01-02T03:04", Format(civil_minute(2015, 1, 2, 3, 4)));
  EXPECT_EQ("2015-01-02T03:00", Format(civil_minute(2015, 1, 2, 3)));
  EXPECT_EQ("2015-01-02T00:00", Format(civil_minute(2015, 1, 2)));
  EXPECT_EQ("2015-01-01T00:00", Format(civil_minute(2015, 1)));
  EXPECT_EQ("2015-01-01T00:00", Format(civil_minute(2015)));

  EXPECT_EQ("2015-01-02T03", Format(civil_hour(2015, 1, 2, 3, 4, 5)));
  EXPECT_EQ("2015-01-02T03", Format(civil_hour(2015, 1, 2, 3, 4)));
  EXPECT_EQ("2015-01-02T03", Format(civil_hour(2015, 1, 2, 3)));
  EXPECT_EQ("2015-01-02T00", Format(civil_hour(2015, 1, 2)));
  EXPECT_EQ("2015-01-01T00", Format(civil_hour(2015, 1)));
  EXPECT_EQ("2015-01-01T00", Format(civil_hour(2015)));

  EXPECT_EQ("2015-01-02", Format(civil_day(2015, 1, 2, 3, 4, 5)));
  EXPECT_EQ("2015-01-02", Format(civil_day(2015, 1, 2, 3, 4)));
  EXPECT_EQ("2015-01-02", Format(civil_day(2015, 1, 2, 3)));
  EXPECT_EQ("2015-01-02", Format(civil_day(2015, 1, 2)));
  EXPECT_EQ("2015-01-01", Format(civil_day(2015, 1)));
  EXPECT_EQ("2015-01-01", Format(civil_day(2015)));

  EXPECT_EQ("2015-01", Format(civil_month(2015, 1, 2, 3, 4, 5)));
  EXPECT_EQ("2015-01", Format(civil_month(2015, 1, 2, 3, 4)));
  EXPECT_EQ("2015-01", Format(civil_month(2015, 1, 2, 3)));
  EXPECT_EQ("2015-01", Format(civil_month(2015, 1, 2)));
  EXPECT_EQ("2015-01", Format(civil_month(2015, 1)));
  EXPECT_EQ("2015-01", Format(civil_month(2015)));

  EXPECT_EQ("2015", Format(civil_year(2015, 1, 2, 3, 4, 5)));
  EXPECT_EQ("2015", Format(civil_year(2015, 1, 2, 3, 4)));
  EXPECT_EQ("2015", Format(civil_year(2015, 1, 2, 3)));
  EXPECT_EQ("2015", Format(civil_year(2015, 1, 2)));
  EXPECT_EQ("2015", Format(civil_year(2015, 1)));
  EXPECT_EQ("2015", Format(civil_year(2015)));
}

TEST(CivilTime, FieldsConstructionLimits) {
  const int kIntMax = std::numeric_limits<int>::max();
  EXPECT_EQ("2038-01-19T03:14:07",
            Format(civil_second(1970, 1, 1, 0, 0, kIntMax)));
  EXPECT_EQ("6121-02-11T05:21:07",
            Format(civil_second(1970, 1, 1, 0, kIntMax, kIntMax)));
  EXPECT_EQ("251104-11-20T12:21:07",
            Format(civil_second(1970, 1, 1, kIntMax, kIntMax, kIntMax)));
  EXPECT_EQ("6130715-05-30T12:21:07",
            Format(civil_second(1970, 1, kIntMax, kIntMax, kIntMax, kIntMax)));
  EXPECT_EQ(
      "185087685-11-26T12:21:07",
      Format(civil_second(1970, kIntMax, kIntMax, kIntMax, kIntMax, kIntMax)));

  const int kIntMin = std::numeric_limits<int>::min();
  EXPECT_EQ("1901-12-13T20:45:52",
            Format(civil_second(1970, 1, 1, 0, 0, kIntMin)));
  EXPECT_EQ("-2182-11-20T18:37:52",
            Format(civil_second(1970, 1, 1, 0, kIntMin, kIntMin)));
  EXPECT_EQ("-247165-02-11T10:37:52",
            Format(civil_second(1970, 1, 1, kIntMin, kIntMin, kIntMin)));
  EXPECT_EQ("-6126776-08-01T10:37:52",
            Format(civil_second(1970, 1, kIntMin, kIntMin, kIntMin, kIntMin)));
  EXPECT_EQ(
      "-185083747-10-31T10:37:52",
      Format(civil_second(1970, kIntMin, kIntMin, kIntMin, kIntMin, kIntMin)));
}

TEST(CivilTime, ImplicitCrossAlignment) {
  civil_year year(2015);
  civil_month month = year;
  civil_day day = month;
  civil_hour hour = day;
  civil_minute minute = hour;
  civil_second second = minute;

  second = year;
  EXPECT_EQ(second, year);
  second = month;
  EXPECT_EQ(second, month);
  second = day;
  EXPECT_EQ(second, day);
  second = hour;
  EXPECT_EQ(second, hour);
  second = minute;
  EXPECT_EQ(second, minute);

  minute = year;
  EXPECT_EQ(minute, year);
  minute = month;
  EXPECT_EQ(minute, month);
  minute = day;
  EXPECT_EQ(minute, day);
  minute = hour;
  EXPECT_EQ(minute, hour);

  hour = year;
  EXPECT_EQ(hour, year);
  hour = month;
  EXPECT_EQ(hour, month);
  hour = day;
  EXPECT_EQ(hour, day);

  day = year;
  EXPECT_EQ(day, year);
  day = month;
  EXPECT_EQ(day, month);

  month = year;
  EXPECT_EQ(month, year);

  // Ensures unsafe conversions are not allowed.
  EXPECT_FALSE((std::is_convertible<civil_second, civil_minute>::value));
  EXPECT_FALSE((std::is_convertible<civil_second, civil_hour>::value));
  EXPECT_FALSE((std::is_convertible<civil_second, civil_day>::value));
  EXPECT_FALSE((std::is_convertible<civil_second, civil_month>::value));
  EXPECT_FALSE((std::is_convertible<civil_second, civil_year>::value));

  EXPECT_FALSE((std::is_convertible<civil_minute, civil_hour>::value));
  EXPECT_FALSE((std::is_convertible<civil_minute, civil_day>::value));
  EXPECT_FALSE((std::is_convertible<civil_minute, civil_month>::value));
  EXPECT_FALSE((std::is_convertible<civil_minute, civil_year>::value));

  EXPECT_FALSE((std::is_convertible<civil_hour, civil_day>::value));
  EXPECT_FALSE((std::is_convertible<civil_hour, civil_month>::value));
  EXPECT_FALSE((std::is_convertible<civil_hour, civil_year>::value));

  EXPECT_FALSE((std::is_convertible<civil_day, civil_month>::value));
  EXPECT_FALSE((std::is_convertible<civil_day, civil_year>::value));

  EXPECT_FALSE((std::is_convertible<civil_month, civil_year>::value));
}

TEST(CivilTime, ExplicitCrossAlignment) {
  //
  // Assign from smaller units -> larger units
  //

  civil_second second(2015, 1, 2, 3, 4, 5);
  EXPECT_EQ("2015-01-02T03:04:05", Format(second));

  civil_minute minute(second);
  EXPECT_EQ("2015-01-02T03:04", Format(minute));

  civil_hour hour(minute);
  EXPECT_EQ("2015-01-02T03", Format(hour));

  civil_day day(hour);
  EXPECT_EQ("2015-01-02", Format(day));

  civil_month month(day);
  EXPECT_EQ("2015-01", Format(month));

  civil_year year(month);
  EXPECT_EQ("2015", Format(year));

  //
  // Now assign from larger units -> smaller units
  //

  month = civil_month(year);
  EXPECT_EQ("2015-01", Format(month));

  day = civil_day(month);
  EXPECT_EQ("2015-01-01", Format(day));

  hour = civil_hour(day);
  EXPECT_EQ("2015-01-01T00", Format(hour));

  minute = civil_minute(hour);
  EXPECT_EQ("2015-01-01T00:00", Format(minute));

  second = civil_second(minute);
  EXPECT_EQ("2015-01-01T00:00:00", Format(second));
}

// Metafunction to test whether difference is allowed between two types.
template <typename T1, typename T2>
struct HasDifference {
  template <typename U1, typename U2>
  static std::false_type test(...);
  template <typename U1, typename U2>
  static std::true_type test(decltype(std::declval<U1>() - std::declval<U2>()));
  static constexpr bool value = decltype(test<T1, T2>(0))::value;
};

TEST(CivilTime, DisallowCrossAlignedDifference) {
  // Difference is allowed between types with the same alignment.
  static_assert(HasDifference<civil_second, civil_second>::value, "");
  static_assert(HasDifference<civil_minute, civil_minute>::value, "");
  static_assert(HasDifference<civil_hour, civil_hour>::value, "");
  static_assert(HasDifference<civil_day, civil_day>::value, "");
  static_assert(HasDifference<civil_month, civil_month>::value, "");
  static_assert(HasDifference<civil_year, civil_year>::value, "");

  // Difference is disallowed between types with different alignments.
  static_assert(!HasDifference<civil_second, civil_minute>::value, "");
  static_assert(!HasDifference<civil_second, civil_hour>::value, "");
  static_assert(!HasDifference<civil_second, civil_day>::value, "");
  static_assert(!HasDifference<civil_second, civil_month>::value, "");
  static_assert(!HasDifference<civil_second, civil_year>::value, "");

  static_assert(!HasDifference<civil_minute, civil_hour>::value, "");
  static_assert(!HasDifference<civil_minute, civil_day>::value, "");
  static_assert(!HasDifference<civil_minute, civil_month>::value, "");
  static_assert(!HasDifference<civil_minute, civil_year>::value, "");

  static_assert(!HasDifference<civil_hour, civil_day>::value, "");
  static_assert(!HasDifference<civil_hour, civil_month>::value, "");
  static_assert(!HasDifference<civil_hour, civil_year>::value, "");

  static_assert(!HasDifference<civil_day, civil_month>::value, "");
  static_assert(!HasDifference<civil_day, civil_year>::value, "");

  static_assert(!HasDifference<civil_month, civil_year>::value, "");
}

TEST(CivilTime, ValueSemantics) {
  const civil_hour a(2015, 1, 2, 3);
  const civil_hour b = a;
  const civil_hour c(b);
  civil_hour d;
  d = c;
  EXPECT_EQ("2015-01-02T03", Format(d));
}

TEST(CivilTime, Relational) {
  // Tests that the alignment unit is ignored in comparison.
  const civil_year year(2014);
  const civil_month month(year);
  EXPECT_EQ(year, month);

#define TEST_RELATIONAL(OLDER, YOUNGER) \
  do {                                  \
    EXPECT_FALSE(OLDER < OLDER);        \
    EXPECT_FALSE(OLDER > OLDER);        \
    EXPECT_TRUE(OLDER >= OLDER);        \
    EXPECT_TRUE(OLDER <= OLDER);        \
    EXPECT_FALSE(YOUNGER < YOUNGER);    \
    EXPECT_FALSE(YOUNGER > YOUNGER);    \
    EXPECT_TRUE(YOUNGER >= YOUNGER);    \
    EXPECT_TRUE(YOUNGER <= YOUNGER);    \
    EXPECT_EQ(OLDER, OLDER);            \
    EXPECT_NE(OLDER, YOUNGER);          \
    EXPECT_LT(OLDER, YOUNGER);          \
    EXPECT_LE(OLDER, YOUNGER);          \
    EXPECT_GT(YOUNGER, OLDER);          \
    EXPECT_GE(YOUNGER, OLDER);          \
  } while (0)

  // Alignment is ignored in comparison (verified above), so kSecond is used
  // to test comparison in all field positions.
  TEST_RELATIONAL(civil_second(2014, 1, 1, 0, 0, 0),
                  civil_second(2015, 1, 1, 0, 0, 0));
  TEST_RELATIONAL(civil_second(2014, 1, 1, 0, 0, 0),
                  civil_second(2014, 2, 1, 0, 0, 0));
  TEST_RELATIONAL(civil_second(2014, 1, 1, 0, 0, 0),
                  civil_second(2014, 1, 2, 0, 0, 0));
  TEST_RELATIONAL(civil_second(2014, 1, 1, 0, 0, 0),
                  civil_second(2014, 1, 1, 1, 0, 0));
  TEST_RELATIONAL(civil_second(2014, 1, 1, 1, 0, 0),
                  civil_second(2014, 1, 1, 1, 1, 0));
  TEST_RELATIONAL(civil_second(2014, 1, 1, 1, 1, 0),
                  civil_second(2014, 1, 1, 1, 1, 1));

  // Tests the relational operators of two different civil-time types.
  TEST_RELATIONAL(civil_day(2014, 1, 1), civil_minute(2014, 1, 1, 1, 1));
  TEST_RELATIONAL(civil_day(2014, 1, 1), civil_month(2014, 2));

#undef TEST_RELATIONAL
}

TEST(CivilTime, Arithmetic) {
  civil_second second(2015, 1, 2, 3, 4, 5);
  EXPECT_EQ("2015-01-02T03:04:06", Format(second += 1));
  EXPECT_EQ("2015-01-02T03:04:07", Format(second + 1));
  EXPECT_EQ("2015-01-02T03:04:08", Format(2 + second));
  EXPECT_EQ("2015-01-02T03:04:05", Format(second - 1));
  EXPECT_EQ("2015-01-02T03:04:05", Format(second -= 1));
  EXPECT_EQ("2015-01-02T03:04:05", Format(second++));
  EXPECT_EQ("2015-01-02T03:04:07", Format(++second));
  EXPECT_EQ("2015-01-02T03:04:07", Format(second--));
  EXPECT_EQ("2015-01-02T03:04:05", Format(--second));

  civil_minute minute(2015, 1, 2, 3, 4);
  EXPECT_EQ("2015-01-02T03:05", Format(minute += 1));
  EXPECT_EQ("2015-01-02T03:06", Format(minute + 1));
  EXPECT_EQ("2015-01-02T03:07", Format(2 + minute));
  EXPECT_EQ("2015-01-02T03:04", Format(minute - 1));
  EXPECT_EQ("2015-01-02T03:04", Format(minute -= 1));
  EXPECT_EQ("2015-01-02T03:04", Format(minute++));
  EXPECT_EQ("2015-01-02T03:06", Format(++minute));
  EXPECT_EQ("2015-01-02T03:06", Format(minute--));
  EXPECT_EQ("2015-01-02T03:04", Format(--minute));

  civil_hour hour(2015, 1, 2, 3);
  EXPECT_EQ("2015-01-02T04", Format(hour += 1));
  EXPECT_EQ("2015-01-02T05", Format(hour + 1));
  EXPECT_EQ("2015-01-02T06", Format(2 + hour));
  EXPECT_EQ("2015-01-02T03", Format(hour - 1));
  EXPECT_EQ("2015-01-02T03", Format(hour -= 1));
  EXPECT_EQ("2015-01-02T03", Format(hour++));
  EXPECT_EQ("2015-01-02T05", Format(++hour));
  EXPECT_EQ("2015-01-02T05", Format(hour--));
  EXPECT_EQ("2015-01-02T03", Format(--hour));

  civil_day day(2015, 1, 2);
  EXPECT_EQ("2015-01-03", Format(day += 1));
  EXPECT_EQ("2015-01-04", Format(day + 1));
  EXPECT_EQ("2015-01-05", Format(2 + day));
  EXPECT_EQ("2015-01-02", Format(day - 1));
  EXPECT_EQ("2015-01-02", Format(day -= 1));
  EXPECT_EQ("2015-01-02", Format(day++));
  EXPECT_EQ("2015-01-04", Format(++day));
  EXPECT_EQ("2015-01-04", Format(day--));
  EXPECT_EQ("2015-01-02", Format(--day));

  civil_month month(2015, 1);
  EXPECT_EQ("2015-02", Format(month += 1));
  EXPECT_EQ("2015-03", Format(month + 1));
  EXPECT_EQ("2015-04", Format(2 + month));
  EXPECT_EQ("2015-01", Format(month - 1));
  EXPECT_EQ("2015-01", Format(month -= 1));
  EXPECT_EQ("2015-01", Format(month++));
  EXPECT_EQ("2015-03", Format(++month));
  EXPECT_EQ("2015-03", Format(month--));
  EXPECT_EQ("2015-01", Format(--month));

  civil_year year(2015);
  EXPECT_EQ("2016", Format(year += 1));
  EXPECT_EQ("2017", Format(year + 1));
  EXPECT_EQ("2018", Format(2 + year));
  EXPECT_EQ("2015", Format(year - 1));
  EXPECT_EQ("2015", Format(year -= 1));
  EXPECT_EQ("2015", Format(year++));
  EXPECT_EQ("2017", Format(++year));
  EXPECT_EQ("2017", Format(year--));
  EXPECT_EQ("2015", Format(--year));
}

TEST(CivilTime, ArithmeticLimits) {
  const int kIntMax = std::numeric_limits<int>::max();
  const int kIntMin = std::numeric_limits<int>::min();

  civil_second second(1970, 1, 1, 0, 0, 0);
  second += kIntMax;
  EXPECT_EQ("2038-01-19T03:14:07", Format(second));
  second -= kIntMax;
  EXPECT_EQ("1970-01-01T00:00:00", Format(second));
  second += kIntMin;
  EXPECT_EQ("1901-12-13T20:45:52", Format(second));
  second -= kIntMin;
  EXPECT_EQ("1970-01-01T00:00:00", Format(second));

  civil_minute minute(1970, 1, 1, 0, 0);
  minute += kIntMax;
  EXPECT_EQ("6053-01-23T02:07", Format(minute));
  minute -= kIntMax;
  EXPECT_EQ("1970-01-01T00:00", Format(minute));
  minute += kIntMin;
  EXPECT_EQ("-2114-12-08T21:52", Format(minute));
  minute -= kIntMin;
  EXPECT_EQ("1970-01-01T00:00", Format(minute));

  civil_hour hour(1970, 1, 1, 0);
  hour += kIntMax;
  EXPECT_EQ("246953-10-09T07", Format(hour));
  hour -= kIntMax;
  EXPECT_EQ("1970-01-01T00", Format(hour));
  hour += kIntMin;
  EXPECT_EQ("-243014-03-24T16", Format(hour));
  hour -= kIntMin;
  EXPECT_EQ("1970-01-01T00", Format(hour));

  civil_day day(1970, 1, 1);
  day += kIntMax;
  EXPECT_EQ("5881580-07-11", Format(day));
  day -= kIntMax;
  EXPECT_EQ("1970-01-01", Format(day));
  day += kIntMin;
  EXPECT_EQ("-5877641-06-23", Format(day));
  day -= kIntMin;
  EXPECT_EQ("1970-01-01", Format(day));

  civil_month month(1970, 1);
  month += kIntMax;
  EXPECT_EQ("178958940-08", Format(month));
  month -= kIntMax;
  EXPECT_EQ("1970-01", Format(month));
  month += kIntMin;
  EXPECT_EQ("-178955001-05", Format(month));
  month -= kIntMin;
  EXPECT_EQ("1970-01", Format(month));

  civil_year year(0);
  year += kIntMax;
  EXPECT_EQ("2147483647", Format(year));
  year -= kIntMax;
  EXPECT_EQ("0", Format(year));
  year += kIntMin;
  EXPECT_EQ("-2147483648", Format(year));
  year -= kIntMin;
  EXPECT_EQ("0", Format(year));
}

TEST(CivilTime, ArithmeticDifference) {
  civil_second second(2015, 1, 2, 3, 4, 5);
  EXPECT_EQ(0, second - second);
  EXPECT_EQ(10, (second + 10) - second);
  EXPECT_EQ(-10, (second - 10) - second);

  civil_minute minute(2015, 1, 2, 3, 4);
  EXPECT_EQ(0, minute - minute);
  EXPECT_EQ(10, (minute + 10) - minute);
  EXPECT_EQ(-10, (minute - 10) - minute);

  civil_hour hour(2015, 1, 2, 3);
  EXPECT_EQ(0, hour - hour);
  EXPECT_EQ(10, (hour + 10) - hour);
  EXPECT_EQ(-10, (hour - 10) - hour);

  civil_day day(2015, 1, 2);
  EXPECT_EQ(0, day - day);
  EXPECT_EQ(10, (day + 10) - day);
  EXPECT_EQ(-10, (day - 10) - day);

  civil_month month(2015, 1);
  EXPECT_EQ(0, month - month);
  EXPECT_EQ(10, (month + 10) - month);
  EXPECT_EQ(-10, (month - 10) - month);

  civil_year year(2015);
  EXPECT_EQ(0, year - year);
  EXPECT_EQ(10, (year + 10) - year);
  EXPECT_EQ(-10, (year - 10) - year);
}

TEST(CivilTime, DifferenceLimits) {
  const int kIntMax = std::numeric_limits<int>::max();
  const int kIntMin = std::numeric_limits<int>::min();

  // Check day arithmetic at the end of the year range.
  const civil_day max_day(kIntMax, 12, 31);
  EXPECT_EQ(1, max_day - (max_day - 1));
  EXPECT_EQ(-1, (max_day - 1) - max_day);

  // Check day arithmetic at the end of the year range.
  const civil_day min_day(kIntMin, 1, 1);
  EXPECT_EQ(1, (min_day + 1) - min_day);
  EXPECT_EQ(-1, min_day - (min_day + 1));

  // Check the limits of the return value.
  const civil_day d1(1970, 1, 1);
  const civil_day d2(5881580, 7, 11);
  EXPECT_EQ(kIntMax, d2 - d1);
  EXPECT_EQ(kIntMin, d1 - (d2 + 1));
}

TEST(CivilTime, Properties) {
  civil_second ss(2015, 2, 3, 4, 5, 6);
  EXPECT_EQ(2015, ss.year());
  EXPECT_EQ(2, ss.month());
  EXPECT_EQ(3, ss.day());
  EXPECT_EQ(4, ss.hour());
  EXPECT_EQ(5, ss.minute());
  EXPECT_EQ(6, ss.second());
  EXPECT_EQ(weekday::tuesday, get_weekday(ss));
  EXPECT_EQ(34, get_yearday(ss));

  civil_minute mm(2015, 2, 3, 4, 5, 6);
  EXPECT_EQ(2015, mm.year());
  EXPECT_EQ(2, mm.month());
  EXPECT_EQ(3, mm.day());
  EXPECT_EQ(4, mm.hour());
  EXPECT_EQ(5, mm.minute());
  EXPECT_EQ(0, mm.second());
  EXPECT_EQ(weekday::tuesday, get_weekday(mm));
  EXPECT_EQ(34, get_yearday(mm));

  civil_hour hh(2015, 2, 3, 4, 5, 6);
  EXPECT_EQ(2015, hh.year());
  EXPECT_EQ(2, hh.month());
  EXPECT_EQ(3, hh.day());
  EXPECT_EQ(4, hh.hour());
  EXPECT_EQ(0, hh.minute());
  EXPECT_EQ(0, hh.second());
  EXPECT_EQ(weekday::tuesday, get_weekday(hh));
  EXPECT_EQ(34, get_yearday(hh));

  civil_day d(2015, 2, 3, 4, 5, 6);
  EXPECT_EQ(2015, d.year());
  EXPECT_EQ(2, d.month());
  EXPECT_EQ(3, d.day());
  EXPECT_EQ(0, d.hour());
  EXPECT_EQ(0, d.minute());
  EXPECT_EQ(0, d.second());
  EXPECT_EQ(weekday::tuesday, get_weekday(d));
  EXPECT_EQ(34, get_yearday(d));

  civil_month m(2015, 2, 3, 4, 5, 6);
  EXPECT_EQ(2015, m.year());
  EXPECT_EQ(2, m.month());
  EXPECT_EQ(1, m.day());
  EXPECT_EQ(0, m.hour());
  EXPECT_EQ(0, m.minute());
  EXPECT_EQ(0, m.second());
  EXPECT_EQ(weekday::sunday, get_weekday(m));
  EXPECT_EQ(32, get_yearday(m));

  civil_year y(2015, 2, 3, 4, 5, 6);
  EXPECT_EQ(2015, y.year());
  EXPECT_EQ(1, y.month());
  EXPECT_EQ(1, y.day());
  EXPECT_EQ(0, y.hour());
  EXPECT_EQ(0, y.minute());
  EXPECT_EQ(0, y.second());
  EXPECT_EQ(weekday::thursday, get_weekday(y));
  EXPECT_EQ(1, get_yearday(y));
}

TEST(CivilTime, OutputStream) {
  // Tests formatting of civil_year, which does not pad.
  EXPECT_EQ("2016", Format(civil_year(2016)));
  EXPECT_EQ("123", Format(civil_year(123)));
  EXPECT_EQ("0", Format(civil_year(0)));
  EXPECT_EQ("-1", Format(civil_year(-1)));

  // Tests formatting of sub-year types, which pad to 2 digits
  EXPECT_EQ("2016-02", Format(civil_month(2016, 2)));
  EXPECT_EQ("2016-02-03", Format(civil_day(2016, 2, 3)));
  EXPECT_EQ("2016-02-03T04", Format(civil_hour(2016, 2, 3, 4)));
  EXPECT_EQ("2016-02-03T04:05", Format(civil_minute(2016, 2, 3, 4, 5)));
  EXPECT_EQ("2016-02-03T04:05:06", Format(civil_second(2016, 2, 3, 4, 5, 6)));

  // Tests formatting of weekday.
  EXPECT_EQ("Monday", Format(weekday::monday));
  EXPECT_EQ("Tuesday", Format(weekday::tuesday));
  EXPECT_EQ("Wednesday", Format(weekday::wednesday));
  EXPECT_EQ("Thursday", Format(weekday::thursday));
  EXPECT_EQ("Friday", Format(weekday::friday));
  EXPECT_EQ("Saturday", Format(weekday::saturday));
  EXPECT_EQ("Sunday", Format(weekday::sunday));
}

TEST(CivilTime, OutputStreamLeftFillWidth) {
  civil_second cs(2016, 2, 3, 4, 5, 6);
  {
    std::stringstream ss;
    ss << std::left << std::setfill('.');
    ss << std::setw(3) << 'X';
    ss << std::setw(21) << civil_year(cs);
    ss << std::setw(3) << 'X';
    EXPECT_EQ("X..2016.................X..", ss.str());
  }
  {
    std::stringstream ss;
    ss << std::left << std::setfill('.');
    ss << std::setw(3) << 'X';
    ss << std::setw(21) << civil_month(cs);
    ss << std::setw(3) << 'X';
    EXPECT_EQ("X..2016-02..............X..", ss.str());
  }
  {
    std::stringstream ss;
    ss << std::left << std::setfill('.');
    ss << std::setw(3) << 'X';
    ss << std::setw(21) << civil_day(cs);
    ss << std::setw(3) << 'X';
    EXPECT_EQ("X..2016-02-03...........X..", ss.str());
  }
  {
    std::stringstream ss;
    ss << std::left << std::setfill('.');
    ss << std::setw(3) << 'X';
    ss << std::setw(21) << civil_hour(cs);
    ss << std::setw(3) << 'X';
    EXPECT_EQ("X..2016-02-03T04........X..", ss.str());
  }
  {
    std::stringstream ss;
    ss << std::left << std::setfill('.');
    ss << std::setw(3) << 'X';
    ss << std::setw(21) << civil_minute(cs);
    ss << std::setw(3) << 'X';
    EXPECT_EQ("X..2016-02-03T04:05.....X..", ss.str());
  }
  {
    std::stringstream ss;
    ss << std::left << std::setfill('.');
    ss << std::setw(3) << 'X';
    ss << std::setw(21) << civil_second(cs);
    ss << std::setw(3) << 'X';
    EXPECT_EQ("X..2016-02-03T04:05:06..X..", ss.str());
  }
}

TEST(CivilTime, NextPrevWeekday) {
  // Jan 1, 1970 was a Thursday.
  const civil_day thursday(1970, 1, 1);
  EXPECT_EQ(weekday::thursday, get_weekday(thursday));

  // Thursday -> Thursday
  civil_day d = next_weekday(thursday, weekday::thursday);
  EXPECT_EQ(7, d - thursday) << Format(d);
  EXPECT_EQ(d - 14, prev_weekday(thursday, weekday::thursday));

  // Thursday -> Friday
  d = next_weekday(thursday, weekday::friday);
  EXPECT_EQ(1, d - thursday) << Format(d);
  EXPECT_EQ(d - 7, prev_weekday(thursday, weekday::friday));

  // Thursday -> Saturday
  d = next_weekday(thursday, weekday::saturday);
  EXPECT_EQ(2, d - thursday) << Format(d);
  EXPECT_EQ(d - 7, prev_weekday(thursday, weekday::saturday));

  // Thursday -> Sunday
  d = next_weekday(thursday, weekday::sunday);
  EXPECT_EQ(3, d - thursday) << Format(d);
  EXPECT_EQ(d - 7, prev_weekday(thursday, weekday::sunday));

  // Thursday -> Monday
  d = next_weekday(thursday, weekday::monday);
  EXPECT_EQ(4, d - thursday) << Format(d);
  EXPECT_EQ(d - 7, prev_weekday(thursday, weekday::monday));

  // Thursday -> Tuesday
  d = next_weekday(thursday, weekday::tuesday);
  EXPECT_EQ(5, d - thursday) << Format(d);
  EXPECT_EQ(d - 7, prev_weekday(thursday, weekday::tuesday));

  // Thursday -> Wednesday
  d = next_weekday(thursday, weekday::wednesday);
  EXPECT_EQ(6, d - thursday) << Format(d);
  EXPECT_EQ(d - 7, prev_weekday(thursday, weekday::wednesday));
}

TEST(CivilTime, NormalizeWithHugeYear) {
  civil_month c(9223372036854775807, 1);
  EXPECT_EQ("9223372036854775807-01", Format(c));
  c = c - 1;  // Causes normalization
  EXPECT_EQ("9223372036854775806-12", Format(c));

  c = civil_month(-9223372036854775807 - 1, 1);
  EXPECT_EQ("-9223372036854775808-01", Format(c));
  c = c + 12;  // Causes normalization
  EXPECT_EQ("-9223372036854775807-01", Format(c));
}

TEST(CivilTime, LeapYears) {
  // Test data for leap years.
  const struct {
    int year;
    int days;
    struct {
      int month;
      int day;
    } leap_day;  // The date of the day after Feb 28.
  } kLeapYearTable[]{
      {1900, 365, {3, 1}},  {1999, 365, {3, 1}},
      {2000, 366, {2, 29}},  // leap year
      {2001, 365, {3, 1}},  {2002, 365, {3, 1}},
      {2003, 365, {3, 1}},  {2004, 366, {2, 29}},  // leap year
      {2005, 365, {3, 1}},  {2006, 365, {3, 1}},
      {2007, 365, {3, 1}},  {2008, 366, {2, 29}},  // leap year
      {2009, 365, {3, 1}},  {2100, 365, {3, 1}},
  };

  for (const auto& e : kLeapYearTable) {
    // Tests incrementing through the leap day.
    const civil_day feb28(e.year, 2, 28);
    const civil_day next_day = feb28 + 1;
    EXPECT_EQ(e.leap_day.month, next_day.month());
    EXPECT_EQ(e.leap_day.day, next_day.day());

    // Tests difference in days of leap years.
    const civil_year year(feb28);
    const civil_year next_year = year + 1;
    EXPECT_EQ(e.days, civil_day(next_year) - civil_day(year));
  }
}

TEST(CivilTime, FirstThursdayInMonth) {
  const civil_day nov1(2014, 11, 1);
  const civil_day thursday = next_weekday(nov1 - 1, weekday::thursday);
  EXPECT_EQ("2014-11-06", Format(thursday));

  // Bonus: Date of Thanksgiving in the United States
  // Rule: Fourth Thursday of November
  const civil_day thanksgiving = thursday + 7 * 3;
  EXPECT_EQ("2014-11-27", Format(thanksgiving));
}

}  // namespace cctz
}  // namespace time_internal
ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/src/time_zone_fixed.cc           0000664 0000000 0000000 00000010466 14746647661 0031330 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

#include "time_zone_fixed.h"

#include <algorithm>
#include <cassert>
#include <chrono>
#include <cstring>
#include <string>

#include "absl/base/config.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {
namespace cctz {

namespace {

// The prefix used for the internal names of fixed-offset zones.
const char kFixedZonePrefix[] = "Fixed/UTC";

const char kDigits[] = "0123456789";

char* Format02d(char* p, int v) {
  *p++ = kDigits[(v / 10) % 10];
  *p++ = kDigits[v % 10];
  return p;
}

int Parse02d(const char* p) {
  if (const char* ap = std::strchr(kDigits, *p)) {
    int v = static_cast<int>(ap - kDigits);
    if (const char* bp = std::strchr(kDigits, *++p)) {
      return (v * 10) + static_cast<int>(bp - kDigits);
    }
  }
  return -1;
}

}  // namespace

bool FixedOffsetFromName(const std::string& name, seconds* offset) {
  if (name == "UTC" || name == "UTC0") {
    *offset = seconds::zero();
    return true;
  }

  const std::size_t prefix_len = sizeof(kFixedZonePrefix) - 1;
  const char* const ep = kFixedZonePrefix + prefix_len;
  if (name.size() != prefix_len + 9)  // <prefix>+99:99:99
    return false;
  if (!std::equal(kFixedZonePrefix, ep, name.begin())) return false;
  const char* np = name.data() + prefix_len;
  if (np[0] != '+' && np[0] != '-') return false;
  if (np[3] != ':' || np[6] != ':')  // see note below about large offsets
    return false;

  int hours = Parse02d(np + 1);
  if (hours == -1) return false;
  int mins = Parse02d(np + 4);
  if (mins == -1) return false;
  int secs = Parse02d(np + 7);
  if (secs == -1) return false;

  secs += ((hours * 60) + mins) * 60;
  if (secs > 24 * 60 * 60) return false;  // outside supported offset range
  *offset = seconds(secs * (np[0] == '-' ? -1 : 1));  // "-" means west
  return true;
}

std::string FixedOffsetToName(const seconds& offset) {
  if (offset == seconds::zero()) return "UTC";
  if (offset < std::chrono::hours(-24) || offset > std::chrono::hours(24)) {
    // We don't support fixed-offset zones more than 24 hours
    // away from UTC to avoid complications in rendering such
    // offsets and to (somewhat) limit the total number of zones.
    return "UTC";
  }
  int offset_seconds = static_cast<int>(offset.count());
  const char sign = (offset_seconds < 0 ? '-' : '+');
  int offset_minutes = offset_seconds / 60;
  offset_seconds %= 60;
  if (sign == '-') {
    if (offset_seconds > 0) {
      offset_seconds -= 60;
      offset_minutes += 1;
    }
    offset_seconds = -offset_seconds;
    offset_minutes = -offset_minutes;
  }
  int offset_hours = offset_minutes / 60;
  offset_minutes %= 60;
  const std::size_t prefix_len = sizeof(kFixedZonePrefix) - 1;
  char buf[prefix_len + sizeof("-24:00:00")];
  char* ep = std::copy_n(kFixedZonePrefix, prefix_len, buf);
  *ep++ = sign;
  ep = Format02d(ep, offset_hours);
  *ep++ = ':';
  ep = Format02d(ep, offset_minutes);
  *ep++ = ':';
  ep = Format02d(ep, offset_seconds);
  *ep++ = '\0';
  assert(ep == buf + sizeof(buf));
  return buf;
}

std::string FixedOffsetToAbbr(const seconds& offset) {
  std::string abbr = FixedOffsetToName(offset);
  const std::size_t prefix_len = sizeof(kFixedZonePrefix) - 1;
  if (abbr.size() == prefix_len + 9) {         // <prefix>+99:99:99
    abbr.erase(0, prefix_len);                 // +99:99:99
    abbr.erase(6, 1);                          // +99:9999
    abbr.erase(3, 1);                          // +999999
    if (abbr[5] == '0' && abbr[6] == '0') {    // +999900
      abbr.erase(5, 2);                        // +9999
      if (abbr[3] == '0' && abbr[4] == '0') {  // +9900
        abbr.erase(3, 2);                      // +99
      }
    }
  }
  return abbr;
}

}  // namespace cctz
}  // namespace time_internal
ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                          node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/src/time_zone_fixed.h            0000664 0000000 0000000 00000004053 14746647661 0031165 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

#ifndef ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_FIXED_H_
#define ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_FIXED_H_

#include <string>

#include "absl/base/config.h"
#include "absl/time/internal/cctz/include/cctz/time_zone.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {
namespace cctz {

// Helper functions for dealing with the names and abbreviations
// of time zones that are a fixed offset (seconds east) from UTC.
// FixedOffsetFromName() extracts the offset from a valid fixed-offset
// name, while FixedOffsetToName() and FixedOffsetToAbbr() generate
// the canonical zone name and abbreviation respectively for the given
// offset.
//
// A fixed-offset name looks like "Fixed/UTC<+-><hours>:<mins>:<secs>".
// Its abbreviation is of the form "UTC(<+->H?H(MM(SS)?)?)?" where the
// optional pieces are omitted when their values are zero.  (Note that
// the sign is the opposite of that used in a POSIX TZ specification.)
//
// Note: FixedOffsetFromName() fails on syntax errors or when the parsed
// offset exceeds 24 hours.  FixedOffsetToName() and FixedOffsetToAbbr()
// both produce "UTC" when the argument offset exceeds 24 hours.
bool FixedOffsetFromName(const std::string& name, seconds* offset);
std::string FixedOffsetToName(const seconds& offset);
std::string FixedOffsetToAbbr(const seconds& offset);

}  // namespace cctz
}  // namespace time_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_FIXED_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/src/time_zone_format.cc          0000664 0000000 0000000 00000077115 14746647661 0031525 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

#if !defined(HAS_STRPTIME)
#if !defined(_MSC_VER) && !defined(__MINGW32__) && !defined(__VXWORKS__)
#define HAS_STRPTIME 1  // Assume everyone else has strptime().
#endif
#endif

#if defined(HAS_STRPTIME) && HAS_STRPTIME
#if !defined(_XOPEN_SOURCE) && !defined(__FreeBSD__) && !defined(__OpenBSD__)
#define _XOPEN_SOURCE 500  // Exposes definitions for SUSv2 (UNIX 98).
#endif
#endif

#include "absl/base/config.h"
#include "absl/time/internal/cctz/include/cctz/time_zone.h"

// Include time.h directly since, by C++ standards, ctime doesn't have to
// declare strptime.
#include <time.h>

#include <cctype>
#include <chrono>
#include <cstddef>
#include <cstdint>
#include <cstring>
#include <ctime>
#include <limits>
#include <string>
#include <vector>
#if !HAS_STRPTIME
#include <iomanip>
#include <sstream>
#endif

#include "absl/time/internal/cctz/include/cctz/civil_time.h"
#include "time_zone_if.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {
namespace cctz {
namespace detail {

namespace {

#if !HAS_STRPTIME
// Build a strptime() using C++11's std::get_time().
char* strptime(const char* s, const char* fmt, std::tm* tm) {
  std::istringstream input(s);
  input >> std::get_time(tm, fmt);
  if (input.fail()) return nullptr;
  return const_cast<char*>(s) +
         (input.eof() ? strlen(s) : static_cast<std::size_t>(input.tellg()));
}
#endif

// Convert a cctz::weekday to a tm_wday value (0-6, Sunday = 0).
int ToTmWday(weekday wd) {
  switch (wd) {
    case weekday::sunday:
      return 0;
    case weekday::monday:
      return 1;
    case weekday::tuesday:
      return 2;
    case weekday::wednesday:
      return 3;
    case weekday::thursday:
      return 4;
    case weekday::friday:
      return 5;
    case weekday::saturday:
      return 6;
  }
  return 0; /*NOTREACHED*/
}

// Convert a tm_wday value (0-6, Sunday = 0) to a cctz::weekday.
weekday FromTmWday(int tm_wday) {
  switch (tm_wday) {
    case 0:
      return weekday::sunday;
    case 1:
      return weekday::monday;
    case 2:
      return weekday::tuesday;
    case 3:
      return weekday::wednesday;
    case 4:
      return weekday::thursday;
    case 5:
      return weekday::friday;
    case 6:
      return weekday::saturday;
  }
  return weekday::sunday; /*NOTREACHED*/
}

std::tm ToTM(const time_zone::absolute_lookup& al) {
  std::tm tm{};
  tm.tm_sec = al.cs.second();
  tm.tm_min = al.cs.minute();
  tm.tm_hour = al.cs.hour();
  tm.tm_mday = al.cs.day();
  tm.tm_mon = al.cs.month() - 1;

  // Saturate tm.tm_year is cases of over/underflow.
  if (al.cs.year() < std::numeric_limits<int>::min() + 1900) {
    tm.tm_year = std::numeric_limits<int>::min();
  } else if (al.cs.year() - 1900 > std::numeric_limits<int>::max()) {
    tm.tm_year = std::numeric_limits<int>::max();
  } else {
    tm.tm_year = static_cast<int>(al.cs.year() - 1900);
  }

  tm.tm_wday = ToTmWday(get_weekday(al.cs));
  tm.tm_yday = get_yearday(al.cs) - 1;
  tm.tm_isdst = al.is_dst ? 1 : 0;
  return tm;
}

// Returns the week of the year [0:53] given a civil day and the day on
// which weeks are defined to start.
int ToWeek(const civil_day& cd, weekday week_start) {
  const civil_day d(cd.year() % 400, cd.month(), cd.day());
  return static_cast<int>((d - prev_weekday(civil_year(d), week_start)) / 7);
}

const char kDigits[] = "0123456789";

// Formats a 64-bit integer in the given field width.  Note that it is up
// to the caller of Format64() [and Format02d()/FormatOffset()] to ensure
// that there is sufficient space before ep to hold the conversion.
char* Format64(char* ep, int width, std::int_fast64_t v) {
  bool neg = false;
  if (v < 0) {
    --width;
    neg = true;
    if (v == std::numeric_limits<std::int_fast64_t>::min()) {
      // Avoid negating minimum value.
      std::int_fast64_t last_digit = -(v % 10);
      v /= 10;
      if (last_digit < 0) {
        ++v;
        last_digit += 10;
      }
      --width;
      *--ep = kDigits[last_digit];
    }
    v = -v;
  }
  do {
    --width;
    *--ep = kDigits[v % 10];
  } while (v /= 10);
  while (--width >= 0) *--ep = '0';  // zero pad
  if (neg) *--ep = '-';
  return ep;
}

// Formats [0 .. 99] as %02d.
char* Format02d(char* ep, int v) {
  *--ep = kDigits[v % 10];
  *--ep = kDigits[(v / 10) % 10];
  return ep;
}

// Formats a UTC offset, like +00:00.
char* FormatOffset(char* ep, int offset, const char* mode) {
  // TODO: Follow the RFC3339 "Unknown Local Offset Convention" and
  // generate a "negative zero" when we're formatting a zero offset
  // as the result of a failed load_time_zone().
  char sign = '+';
  if (offset < 0) {
    offset = -offset;  // bounded by 24h so no overflow
    sign = '-';
  }
  const int seconds = offset % 60;
  const int minutes = (offset /= 60) % 60;
  const int hours = offset /= 60;
  const char sep = mode[0];
  const bool ext = (sep != '\0' && mode[1] == '*');
  const bool ccc = (ext && mode[2] == ':');
  if (ext && (!ccc || seconds != 0)) {
    ep = Format02d(ep, seconds);
    *--ep = sep;
  } else {
    // If we're not rendering seconds, sub-minute negative offsets
    // should get a positive sign (e.g., offset=-10s => "+00:00").
    if (hours == 0 && minutes == 0) sign = '+';
  }
  if (!ccc || minutes != 0 || seconds != 0) {
    ep = Format02d(ep, minutes);
    if (sep != '\0') *--ep = sep;
  }
  ep = Format02d(ep, hours);
  *--ep = sign;
  return ep;
}

// Formats a std::tm using strftime(3).
void FormatTM(std::string* out, const std::string& fmt, const std::tm& tm) {
  // strftime(3) returns the number of characters placed in the output
  // array (which may be 0 characters).  It also returns 0 to indicate
  // an error, like the array wasn't large enough.  To accommodate this,
  // the following code grows the buffer size from 2x the format string
  // length up to 32x.
  for (std::size_t i = 2; i != 32; i *= 2) {
    std::size_t buf_size = fmt.size() * i;
    std::vector<char> buf(buf_size);
    if (std::size_t len = strftime(&buf[0], buf_size, fmt.c_str(), &tm)) {
      out->append(&buf[0], len);
      return;
    }
  }
}

// Used for %E#S/%E#f specifiers and for data values in parse().
template <typename T>
const char* ParseInt(const char* dp, int width, T min, T max, T* vp) {
  if (dp != nullptr) {
    const T kmin = std::numeric_limits<T>::min();
    bool erange = false;
    bool neg = false;
    T value = 0;
    if (*dp == '-') {
      neg = true;
      if (width <= 0 || --width != 0) {
        ++dp;
      } else {
        dp = nullptr;  // width was 1
      }
    }
    if (const char* const bp = dp) {
      while (const char* cp = strchr(kDigits, *dp)) {
        int d = static_cast<int>(cp - kDigits);
        if (d >= 10) break;
        if (value < kmin / 10) {
          erange = true;
          break;
        }
        value *= 10;
        if (value < kmin + d) {
          erange = true;
          break;
        }
        value -= d;
        dp += 1;
        if (width > 0 && --width == 0) break;
      }
      if (dp != bp && !erange && (neg || value != kmin)) {
        if (!neg || value != 0) {
          if (!neg) value = -value;  // make positive
          if (min <= value && value <= max) {
            *vp = value;
          } else {
            dp = nullptr;
          }
        } else {
          dp = nullptr;
        }
      } else {
        dp = nullptr;
      }
    }
  }
  return dp;
}

// The number of base-10 digits that can be represented by a signed 64-bit
// integer.  That is, 10^kDigits10_64 <= 2^63 - 1 < 10^(kDigits10_64 + 1).
const int kDigits10_64 = 18;

// 10^n for everything that can be represented by a signed 64-bit integer.
const std::int_fast64_t kExp10[kDigits10_64 + 1] = {
    1,
    10,
    100,
    1000,
    10000,
    100000,
    1000000,
    10000000,
    100000000,
    1000000000,
    10000000000,
    100000000000,
    1000000000000,
    10000000000000,
    100000000000000,
    1000000000000000,
    10000000000000000,
    100000000000000000,
    1000000000000000000,
};

}  // namespace

// Uses strftime(3) to format the given Time.  The following extended format
// specifiers are also supported:
//
//   - %Ez  - RFC3339-compatible numeric UTC offset (+hh:mm or -hh:mm)
//   - %E*z - Full-resolution numeric UTC offset (+hh:mm:ss or -hh:mm:ss)
//   - %E#S - Seconds with # digits of fractional precision
//   - %E*S - Seconds with full fractional precision (a literal '*')
//   - %E4Y - Four-character years (-999 ... -001, 0000, 0001 ... 9999)
//   - %ET  - The RFC3339 "date-time" separator "T"
//
// The standard specifiers from RFC3339_* (%Y, %m, %d, %H, %M, and %S) are
// handled internally for performance reasons.  strftime(3) is slow due to
// a POSIX requirement to respect changes to ${TZ}.
//
// The TZ/GNU %s extension is handled internally because strftime() has
// to use mktime() to generate it, and that assumes the local time zone.
//
// We also handle the %z and %Z specifiers to accommodate platforms that do
// not support the tm_gmtoff and tm_zone extensions to std::tm.
//
// Requires that zero() <= fs < seconds(1).
std::string format(const std::string& format, const time_point<seconds>& tp,
                   const detail::femtoseconds& fs, const time_zone& tz) {
  std::string result;
  result.reserve(format.size());  // A reasonable guess for the result size.
  const time_zone::absolute_lookup al = tz.lookup(tp);
  const std::tm tm = ToTM(al);

  // Scratch buffer for internal conversions.
  char buf[3 + kDigits10_64];  // enough for longest conversion
  char* const ep = buf + sizeof(buf);
  char* bp;  // works back from ep

  // Maintain three, disjoint subsequences that span format.
  //   [format.begin() ... pending) : already formatted into result
  //   [pending ... cur) : formatting pending, but no special cases
  //   [cur ... format.end()) : unexamined
  // Initially, everything is in the unexamined part.
  const char* pending = format.c_str();  // NUL terminated
  const char* cur = pending;
  const char* end = pending + format.length();

  while (cur != end) {  // while something is unexamined
    // Moves cur to the next percent sign.
    const char* start = cur;
    while (cur != end && *cur != '%') ++cur;

    // If the new pending text is all ordinary, copy it out.
    if (cur != start && pending == start) {
      result.append(pending, static_cast<std::size_t>(cur - pending));
      pending = start = cur;
    }

    // Span the sequential percent signs.
    const char* percent = cur;
    while (cur != end && *cur == '%') ++cur;

    // If the new pending text is all percents, copy out one
    // percent for every matched pair, then skip those pairs.
    if (cur != start && pending == start) {
      std::size_t escaped = static_cast<std::size_t>(cur - pending) / 2;
      result.append(pending, escaped);
      pending += escaped * 2;
      // Also copy out a single trailing percent.
      if (pending != cur && cur == end) {
        result.push_back(*pending++);
      }
    }

    // Loop unless we have an unescaped percent.
    if (cur == end || (cur - percent) % 2 == 0) continue;

    // Simple specifiers that we handle ourselves.
    if (strchr("YmdeUuWwHMSzZs%", *cur)) {
      if (cur - 1 != pending) {
        FormatTM(&result, std::string(pending, cur - 1), tm);
      }
      switch (*cur) {
        case 'Y':
          // This avoids the tm.tm_year overflow problem for %Y, however
          // tm.tm_year will still be used by other specifiers like %D.
          bp = Format64(ep, 0, al.cs.year());
          result.append(bp, static_cast<std::size_t>(ep - bp));
          break;
        case 'm':
          bp = Format02d(ep, al.cs.month());
          result.append(bp, static_cast<std::size_t>(ep - bp));
          break;
        case 'd':
        case 'e':
          bp = Format02d(ep, al.cs.day());
          if (*cur == 'e' && *bp == '0') *bp = ' ';  // for Windows
          result.append(bp, static_cast<std::size_t>(ep - bp));
          break;
        case 'U':
          bp = Format02d(ep, ToWeek(civil_day(al.cs), weekday::sunday));
          result.append(bp, static_cast<std::size_t>(ep - bp));
          break;
        case 'u':
          bp = Format64(ep, 0, tm.tm_wday ? tm.tm_wday : 7);
          result.append(bp, static_cast<std::size_t>(ep - bp));
          break;
        case 'W':
          bp = Format02d(ep, ToWeek(civil_day(al.cs), weekday::monday));
          result.append(bp, static_cast<std::size_t>(ep - bp));
          break;
        case 'w':
          bp = Format64(ep, 0, tm.tm_wday);
          result.append(bp, static_cast<std::size_t>(ep - bp));
          break;
        case 'H':
          bp = Format02d(ep, al.cs.hour());
          result.append(bp, static_cast<std::size_t>(ep - bp));
          break;
        case 'M':
          bp = Format02d(ep, al.cs.minute());
          result.append(bp, static_cast<std::size_t>(ep - bp));
          break;
        case 'S':
          bp = Format02d(ep, al.cs.second());
          result.append(bp, static_cast<std::size_t>(ep - bp));
          break;
        case 'z':
          bp = FormatOffset(ep, al.offset, "");
          result.append(bp, static_cast<std::size_t>(ep - bp));
          break;
        case 'Z':
          result.append(al.abbr);
          break;
        case 's':
          bp = Format64(ep, 0, ToUnixSeconds(tp));
          result.append(bp, static_cast<std::size_t>(ep - bp));
          break;
        case '%':
          result.push_back('%');
          break;
      }
      pending = ++cur;
      continue;
    }

    // More complex specifiers that we handle ourselves.
    if (*cur == ':' && cur + 1 != end) {
      if (*(cur + 1) == 'z') {
        // Formats %:z.
        if (cur - 1 != pending) {
          FormatTM(&result, std::string(pending, cur - 1), tm);
        }
        bp = FormatOffset(ep, al.offset, ":");
        result.append(bp, static_cast<std::size_t>(ep - bp));
        pending = cur += 2;
        continue;
      }
      if (*(cur + 1) == ':' && cur + 2 != end) {
        if (*(cur + 2) == 'z') {
          // Formats %::z.
          if (cur - 1 != pending) {
            FormatTM(&result, std::string(pending, cur - 1), tm);
          }
          bp = FormatOffset(ep, al.offset, ":*");
          result.append(bp, static_cast<std::size_t>(ep - bp));
          pending = cur += 3;
          continue;
        }
        if (*(cur + 2) == ':' && cur + 3 != end) {
          if (*(cur + 3) == 'z') {
            // Formats %:::z.
            if (cur - 1 != pending) {
              FormatTM(&result, std::string(pending, cur - 1), tm);
            }
            bp = FormatOffset(ep, al.offset, ":*:");
            result.append(bp, static_cast<std::size_t>(ep - bp));
            pending = cur += 4;
            continue;
          }
        }
      }
    }

    // Loop if there is no E modifier.
    if (*cur != 'E' || ++cur == end) continue;

    // Format our extensions.
    if (*cur == 'T') {
      // Formats %ET.
      if (cur - 2 != pending) {
        FormatTM(&result, std::string(pending, cur - 2), tm);
      }
      result.append("T");
      pending = ++cur;
    } else if (*cur == 'z') {
      // Formats %Ez.
      if (cur - 2 != pending) {
        FormatTM(&result, std::string(pending, cur - 2), tm);
      }
      bp = FormatOffset(ep, al.offset, ":");
      result.append(bp, static_cast<std::size_t>(ep - bp));
      pending = ++cur;
    } else if (*cur == '*' && cur + 1 != end && *(cur + 1) == 'z') {
      // Formats %E*z.
      if (cur - 2 != pending) {
        FormatTM(&result, std::string(pending, cur - 2), tm);
      }
      bp = FormatOffset(ep, al.offset, ":*");
      result.append(bp, static_cast<std::size_t>(ep - bp));
      pending = cur += 2;
    } else if (*cur == '*' && cur + 1 != end &&
               (*(cur + 1) == 'S' || *(cur + 1) == 'f')) {
      // Formats %E*S or %E*F.
      if (cur - 2 != pending) {
        FormatTM(&result, std::string(pending, cur - 2), tm);
      }
      char* cp = ep;
      bp = Format64(cp, 15, fs.count());
      while (cp != bp && cp[-1] == '0') --cp;
      switch (*(cur + 1)) {
        case 'S':
          if (cp != bp) *--bp = '.';
          bp = Format02d(bp, al.cs.second());
          break;
        case 'f':
          if (cp == bp) *--bp = '0';
          break;
      }
      result.append(bp, static_cast<std::size_t>(cp - bp));
      pending = cur += 2;
    } else if (*cur == '4' && cur + 1 != end && *(cur + 1) == 'Y') {
      // Formats %E4Y.
      if (cur - 2 != pending) {
        FormatTM(&result, std::string(pending, cur - 2), tm);
      }
      bp = Format64(ep, 4, al.cs.year());
      result.append(bp, static_cast<std::size_t>(ep - bp));
      pending = cur += 2;
    } else if (std::isdigit(*cur)) {
      // Possibly found %E#S or %E#f.
      int n = 0;
      if (const char* np = ParseInt(cur, 0, 0, 1024, &n)) {
        if (*np == 'S' || *np == 'f') {
          // Formats %E#S or %E#f.
          if (cur - 2 != pending) {
            FormatTM(&result, std::string(pending, cur - 2), tm);
          }
          bp = ep;
          if (n > 0) {
            if (n > kDigits10_64) n = kDigits10_64;
            bp = Format64(bp, n,
                          (n > 15) ? fs.count() * kExp10[n - 15]
                                   : fs.count() / kExp10[15 - n]);
            if (*np == 'S') *--bp = '.';
          }
          if (*np == 'S') bp = Format02d(bp, al.cs.second());
          result.append(bp, static_cast<std::size_t>(ep - bp));
          pending = cur = ++np;
        }
      }
    }
  }

  // Formats any remaining data.
  if (end != pending) {
    FormatTM(&result, std::string(pending, end), tm);
  }

  return result;
}

namespace {

const char* ParseOffset(const char* dp, const char* mode, int* offset) {
  if (dp != nullptr) {
    const char first = *dp++;
    if (first == '+' || first == '-') {
      char sep = mode[0];
      int hours = 0;
      int minutes = 0;
      int seconds = 0;
      const char* ap = ParseInt(dp, 2, 0, 23, &hours);
      if (ap != nullptr && ap - dp == 2) {
        dp = ap;
        if (sep != '\0' && *ap == sep) ++ap;
        const char* bp = ParseInt(ap, 2, 0, 59, &minutes);
        if (bp != nullptr && bp - ap == 2) {
          dp = bp;
          if (sep != '\0' && *bp == sep) ++bp;
          const char* cp = ParseInt(bp, 2, 0, 59, &seconds);
          if (cp != nullptr && cp - bp == 2) dp = cp;
        }
        *offset = ((hours * 60 + minutes) * 60) + seconds;
        if (first == '-') *offset = -*offset;
      } else {
        dp = nullptr;
      }
    } else if (first == 'Z' || first == 'z') {  // Zulu
      *offset = 0;
    } else {
      dp = nullptr;
    }
  }
  return dp;
}

const char* ParseZone(const char* dp, std::string* zone) {
  zone->clear();
  if (dp != nullptr) {
    while (*dp != '\0' && !std::isspace(*dp)) zone->push_back(*dp++);
    if (zone->empty()) dp = nullptr;
  }
  return dp;
}

const char* ParseSubSeconds(const char* dp, detail::femtoseconds* subseconds) {
  if (dp != nullptr) {
    std::int_fast64_t v = 0;
    std::int_fast64_t exp = 0;
    const char* const bp = dp;
    while (const char* cp = strchr(kDigits, *dp)) {
      int d = static_cast<int>(cp - kDigits);
      if (d >= 10) break;
      if (exp < 15) {
        exp += 1;
        v *= 10;
        v += d;
      }
      ++dp;
    }
    if (dp != bp) {
      v *= kExp10[15 - exp];
      *subseconds = detail::femtoseconds(v);
    } else {
      dp = nullptr;
    }
  }
  return dp;
}

// Parses a string into a std::tm using strptime(3).
const char* ParseTM(const char* dp, const char* fmt, std::tm* tm) {
  if (dp != nullptr) {
    dp = strptime(dp, fmt, tm);
  }
  return dp;
}

// Sets year, tm_mon and tm_mday given the year, week_num, and tm_wday,
// and the day on which weeks are defined to start.  Returns false if year
// would need to move outside its bounds.
bool FromWeek(int week_num, weekday week_start, year_t* year, std::tm* tm) {
  const civil_year y(*year % 400);
  civil_day cd = prev_weekday(y, week_start);  // week 0
  cd = next_weekday(cd - 1, FromTmWday(tm->tm_wday)) + (week_num * 7);
  if (const year_t shift = cd.year() - y.year()) {
    if (shift > 0) {
      if (*year > std::numeric_limits<year_t>::max() - shift) return false;
    } else {
      if (*year < std::numeric_limits<year_t>::min() - shift) return false;
    }
    *year += shift;
  }
  tm->tm_mon = cd.month() - 1;
  tm->tm_mday = cd.day();
  return true;
}

}  // namespace

// Uses strptime(3) to parse the given input.  Supports the same extended
// format specifiers as format(), although %E#S and %E*S are treated
// identically (and similarly for %E#f and %E*f).  %Ez and %E*z also accept
// the same inputs. %ET accepts either 'T' or 't'.
//
// The standard specifiers from RFC3339_* (%Y, %m, %d, %H, %M, and %S) are
// handled internally so that we can normally avoid strptime() altogether
// (which is particularly helpful when the native implementation is broken).
//
// The TZ/GNU %s extension is handled internally because strptime() has to
// use localtime_r() to generate it, and that assumes the local time zone.
//
// We also handle the %z specifier to accommodate platforms that do not
// support the tm_gmtoff extension to std::tm.  %Z is parsed but ignored.
bool parse(const std::string& format, const std::string& input,
           const time_zone& tz, time_point<seconds>* sec,
           detail::femtoseconds* fs, std::string* err) {
  // The unparsed input.
  const char* data = input.c_str();  // NUL terminated

  // Skips leading whitespace.
  while (std::isspace(*data)) ++data;

  const year_t kyearmax = std::numeric_limits<year_t>::max();
  const year_t kyearmin = std::numeric_limits<year_t>::min();

  // Sets default values for unspecified fields.
  bool saw_year = false;
  year_t year = 1970;
  std::tm tm{};
  tm.tm_year = 1970 - 1900;
  tm.tm_mon = 1 - 1;  // Jan
  tm.tm_mday = 1;
  tm.tm_hour = 0;
  tm.tm_min = 0;
  tm.tm_sec = 0;
  tm.tm_wday = 4;  // Thu
  tm.tm_yday = 0;
  tm.tm_isdst = 0;
  auto subseconds = detail::femtoseconds::zero();
  bool saw_offset = false;
  int offset = 0;  // No offset from passed tz.
  std::string zone = "UTC";

  const char* fmt = format.c_str();  // NUL terminated
  bool twelve_hour = false;
  bool afternoon = false;
  int week_num = -1;
  weekday week_start = weekday::sunday;

  bool saw_percent_s = false;
  std::int_fast64_t percent_s = 0;

  // Steps through format, one specifier at a time.
  while (data != nullptr && *fmt != '\0') {
    if (std::isspace(*fmt)) {
      while (std::isspace(*data)) ++data;
      while (std::isspace(*++fmt)) continue;
      continue;
    }

    if (*fmt != '%') {
      if (*data == *fmt) {
        ++data;
        ++fmt;
      } else {
        data = nullptr;
      }
      continue;
    }

    const char* percent = fmt;
    if (*++fmt == '\0') {
      data = nullptr;
      continue;
    }
    switch (*fmt++) {
      case 'Y':
        // Symmetrically with FormatTime(), directly handing %Y avoids the
        // tm.tm_year overflow problem.  However, tm.tm_year will still be
        // used by other specifiers like %D.
        data = ParseInt(data, 0, kyearmin, kyearmax, &year);
        if (data != nullptr) saw_year = true;
        continue;
      case 'm':
        data = ParseInt(data, 2, 1, 12, &tm.tm_mon);
        if (data != nullptr) tm.tm_mon -= 1;
        week_num = -1;
        continue;
      case 'd':
      case 'e':
        data = ParseInt(data, 2, 1, 31, &tm.tm_mday);
        week_num = -1;
        continue;
      case 'U':
        data = ParseInt(data, 0, 0, 53, &week_num);
        week_start = weekday::sunday;
        continue;
      case 'W':
        data = ParseInt(data, 0, 0, 53, &week_num);
        week_start = weekday::monday;
        continue;
      case 'u':
        data = ParseInt(data, 0, 1, 7, &tm.tm_wday);
        if (data != nullptr) tm.tm_wday %= 7;
        continue;
      case 'w':
        data = ParseInt(data, 0, 0, 6, &tm.tm_wday);
        continue;
      case 'H':
        data = ParseInt(data, 2, 0, 23, &tm.tm_hour);
        twelve_hour = false;
        continue;
      case 'M':
        data = ParseInt(data, 2, 0, 59, &tm.tm_min);
        continue;
      case 'S':
        data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
        continue;
      case 'I':
      case 'l':
      case 'r':  // probably uses %I
        twelve_hour = true;
        break;
      case 'R':  // uses %H
      case 'T':  // uses %H
      case 'c':  // probably uses %H
      case 'X':  // probably uses %H
        twelve_hour = false;
        break;
      case 'z':
        data = ParseOffset(data, "", &offset);
        if (data != nullptr) saw_offset = true;
        continue;
      case 'Z':  // ignored; zone abbreviations are ambiguous
        data = ParseZone(data, &zone);
        continue;
      case 's':
        data =
            ParseInt(data, 0, std::numeric_limits<std::int_fast64_t>::min(),
                     std::numeric_limits<std::int_fast64_t>::max(), &percent_s);
        if (data != nullptr) saw_percent_s = true;
        continue;
      case ':':
        if (fmt[0] == 'z' ||
            (fmt[0] == ':' &&
             (fmt[1] == 'z' || (fmt[1] == ':' && fmt[2] == 'z')))) {
          data = ParseOffset(data, ":", &offset);
          if (data != nullptr) saw_offset = true;
          fmt += (fmt[0] == 'z') ? 1 : (fmt[1] == 'z') ? 2 : 3;
          continue;
        }
        break;
      case '%':
        data = (*data == '%' ? data + 1 : nullptr);
        continue;
      case 'E':
        if (fmt[0] == 'T') {
          if (*data == 'T' || *data == 't') {
            ++data;
            ++fmt;
          } else {
            data = nullptr;
          }
          continue;
        }
        if (fmt[0] == 'z' || (fmt[0] == '*' && fmt[1] == 'z')) {
          data = ParseOffset(data, ":", &offset);
          if (data != nullptr) saw_offset = true;
          fmt += (fmt[0] == 'z') ? 1 : 2;
          continue;
        }
        if (fmt[0] == '*' && fmt[1] == 'S') {
          data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
          if (data != nullptr && *data == '.') {
            data = ParseSubSeconds(data + 1, &subseconds);
          }
          fmt += 2;
          continue;
        }
        if (fmt[0] == '*' && fmt[1] == 'f') {
          if (data != nullptr && std::isdigit(*data)) {
            data = ParseSubSeconds(data, &subseconds);
          }
          fmt += 2;
          continue;
        }
        if (fmt[0] == '4' && fmt[1] == 'Y') {
          const char* bp = data;
          data = ParseInt(data, 4, year_t{-999}, year_t{9999}, &year);
          if (data != nullptr) {
            if (data - bp == 4) {
              saw_year = true;
            } else {
              data = nullptr;  // stopped too soon
            }
          }
          fmt += 2;
          continue;
        }
        if (std::isdigit(*fmt)) {
          int n = 0;  // value ignored
          if (const char* np = ParseInt(fmt, 0, 0, 1024, &n)) {
            if (*np == 'S') {
              data = ParseInt(data, 2, 0, 60, &tm.tm_sec);
              if (data != nullptr && *data == '.') {
                data = ParseSubSeconds(data + 1, &subseconds);
              }
              fmt = ++np;
              continue;
            }
            if (*np == 'f') {
              if (data != nullptr && std::isdigit(*data)) {
                data = ParseSubSeconds(data, &subseconds);
              }
              fmt = ++np;
              continue;
            }
          }
        }
        if (*fmt == 'c') twelve_hour = false;  // probably uses %H
        if (*fmt == 'X') twelve_hour = false;  // probably uses %H
        if (*fmt != '\0') ++fmt;
        break;
      case 'O':
        if (*fmt == 'H') twelve_hour = false;
        if (*fmt == 'I') twelve_hour = true;
        if (*fmt != '\0') ++fmt;
        break;
    }

    // Parses the current specifier.
    const char* orig_data = data;
    std::string spec(percent, static_cast<std::size_t>(fmt - percent));
    data = ParseTM(data, spec.c_str(), &tm);

    // If we successfully parsed %p we need to remember whether the result
    // was AM or PM so that we can adjust tm_hour before time_zone::lookup().
    // So reparse the input with a known AM hour, and check if it is shifted
    // to a PM hour.
    if (spec == "%p" && data != nullptr) {
      std::string test_input = "1";
      test_input.append(orig_data, static_cast<std::size_t>(data - orig_data));
      const char* test_data = test_input.c_str();
      std::tm tmp{};
      ParseTM(test_data, "%I%p", &tmp);
      afternoon = (tmp.tm_hour == 13);
    }
  }

  // Adjust a 12-hour tm_hour value if it should be in the afternoon.
  if (twelve_hour && afternoon && tm.tm_hour < 12) {
    tm.tm_hour += 12;
  }

  if (data == nullptr) {
    if (err != nullptr) *err = "Failed to parse input";
    return false;
  }

  // Skip any remaining whitespace.
  while (std::isspace(*data)) ++data;

  // parse() must consume the entire input string.
  if (*data != '\0') {
    if (err != nullptr) *err = "Illegal trailing data in input string";
    return false;
  }

  // If we saw %s then we ignore anything else and return that time.
  if (saw_percent_s) {
    *sec = FromUnixSeconds(percent_s);
    *fs = detail::femtoseconds::zero();
    return true;
  }

  // If we saw %z, %Ez, or %E*z then we want to interpret the parsed fields
  // in UTC and then shift by that offset.  Otherwise we want to interpret
  // the fields directly in the passed time_zone.
  time_zone ptz = saw_offset ? utc_time_zone() : tz;

  // Allows a leap second of 60 to normalize forward to the following ":00".
  if (tm.tm_sec == 60) {
    tm.tm_sec -= 1;
    offset -= 1;
    subseconds = detail::femtoseconds::zero();
  }

  if (!saw_year) {
    year = year_t{tm.tm_year};
    if (year > kyearmax - 1900) {
      // Platform-dependent, maybe unreachable.
      if (err != nullptr) *err = "Out-of-range year";
      return false;
    }
    year += 1900;
  }

  // Compute year, tm.tm_mon and tm.tm_mday if we parsed a week number.
  if (week_num != -1) {
    if (!FromWeek(week_num, week_start, &year, &tm)) {
      if (err != nullptr) *err = "Out-of-range field";
      return false;
    }
  }

  const int month = tm.tm_mon + 1;
  civil_second cs(year, month, tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);

  // parse() should not allow normalization. Due to the restricted field
  // ranges above (see ParseInt()), the only possibility is for days to roll
  // into months. That is, parsing "Sep 31" should not produce "Oct 1".
  if (cs.month() != month || cs.day() != tm.tm_mday) {
    if (err != nullptr) *err = "Out-of-range field";
    return false;
  }

  // Accounts for the offset adjustment before converting to absolute time.
  if ((offset < 0 && cs > civil_second::max() + offset) ||
      (offset > 0 && cs < civil_second::min() + offset)) {
    if (err != nullptr) *err = "Out-of-range field";
    return false;
  }
  cs -= offset;

  const auto tp = ptz.lookup(cs).pre;
  // Checks for overflow/underflow and returns an error as necessary.
  if (tp == time_point<seconds>::max()) {
    const auto al = ptz.lookup(time_point<seconds>::max());
    if (cs > al.cs) {
      if (err != nullptr) *err = "Out-of-range field";
      return false;
    }
  }
  if (tp == time_point<seconds>::min()) {
    const auto al = ptz.lookup(time_point<seconds>::min());
    if (cs < al.cs) {
      if (err != nullptr) *err = "Out-of-range field";
      return false;
    }
  }

  *sec = tp;
  *fs = subseconds;
  return true;
}

}  // namespace detail
}  // namespace cctz
}  // namespace time_internal
ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/src/time_zone_format_test.cc     0000664 0000000 0000000 00000213772 14746647661 0032565 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

#include <chrono>
#include <cstdint>
#include <iomanip>
#include <sstream>
#include <string>

#include "absl/base/config.h"
#include "absl/time/internal/cctz/include/cctz/time_zone.h"
#if defined(__linux__)
#include <features.h>
#endif

#include "gmock/gmock.h"
#include "gtest/gtest.h"
#include "absl/time/internal/cctz/include/cctz/civil_time.h"

namespace chrono = std::chrono;

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {
namespace cctz {

namespace {

// This helper is a macro so that failed expectations show up with the
// correct line numbers.
#define ExpectTime(tp, tz, y, m, d, hh, mm, ss, off, isdst, zone) \
  do {                                                            \
    time_zone::absolute_lookup al = tz.lookup(tp);                \
    EXPECT_EQ(y, al.cs.year());                                   \
    EXPECT_EQ(m, al.cs.month());                                  \
    EXPECT_EQ(d, al.cs.day());                                    \
    EXPECT_EQ(hh, al.cs.hour());                                  \
    EXPECT_EQ(mm, al.cs.minute());                                \
    EXPECT_EQ(ss, al.cs.second());                                \
    EXPECT_EQ(off, al.offset);                                    \
    EXPECT_TRUE(isdst == al.is_dst);                              \
    EXPECT_STREQ(zone, al.abbr);                                  \
  } while (0)

const char RFC3339_full[] = "%Y-%m-%d%ET%H:%M:%E*S%Ez";
const char RFC3339_sec[] = "%Y-%m-%d%ET%H:%M:%S%Ez";

const char RFC1123_full[] = "%a, %d %b %Y %H:%M:%S %z";
const char RFC1123_no_wday[] = "%d %b %Y %H:%M:%S %z";

// A helper that tests the given format specifier by itself, and with leading
// and trailing characters.  For example: TestFormatSpecifier(tp, "%a", "Thu").
template <typename D>
void TestFormatSpecifier(time_point<D> tp, time_zone tz, const std::string& fmt,
                         const std::string& ans) {
  EXPECT_EQ(ans, absl::time_internal::cctz::format(fmt, tp, tz)) << fmt;
  EXPECT_EQ("xxx " + ans,
            absl::time_internal::cctz::format("xxx " + fmt, tp, tz));
  EXPECT_EQ(ans + " yyy",
            absl::time_internal::cctz::format(fmt + " yyy", tp, tz));
  EXPECT_EQ("xxx " + ans + " yyy",
            absl::time_internal::cctz::format("xxx " + fmt + " yyy", tp, tz));
}

}  // namespace

//
// Testing format()
//

TEST(Format, TimePointResolution) {
  const char kFmt[] = "%H:%M:%E*S";
  const time_zone utc = utc_time_zone();
  const time_point<chrono::nanoseconds> t0 =
      chrono::system_clock::from_time_t(1420167845) +
      chrono::milliseconds(123) + chrono::microseconds(456) +
      chrono::nanoseconds(789);
  EXPECT_EQ("03:04:05.123456789",
            absl::time_internal::cctz::format(
                kFmt, chrono::time_point_cast<chrono::nanoseconds>(t0), utc));
  EXPECT_EQ("03:04:05.123456",
            absl::time_internal::cctz::format(
                kFmt, chrono::time_point_cast<chrono::microseconds>(t0), utc));
  EXPECT_EQ("03:04:05.123",
            absl::time_internal::cctz::format(
                kFmt, chrono::time_point_cast<chrono::milliseconds>(t0), utc));
  EXPECT_EQ("03:04:05",
            absl::time_internal::cctz::format(
                kFmt, chrono::time_point_cast<chrono::seconds>(t0), utc));
  EXPECT_EQ(
      "03:04:05",
      absl::time_internal::cctz::format(
          kFmt, chrono::time_point_cast<absl::time_internal::cctz::seconds>(t0),
          utc));
  EXPECT_EQ("03:04:00",
            absl::time_internal::cctz::format(
                kFmt, chrono::time_point_cast<chrono::minutes>(t0), utc));
  EXPECT_EQ("03:00:00",
            absl::time_internal::cctz::format(
                kFmt, chrono::time_point_cast<chrono::hours>(t0), utc));
}

TEST(Format, TimePointExtendedResolution) {
  const char kFmt[] = "%H:%M:%E*S";
  const time_zone utc = utc_time_zone();
  const time_point<absl::time_internal::cctz::seconds> tp =
      chrono::time_point_cast<absl::time_internal::cctz::seconds>(
          chrono::system_clock::from_time_t(0)) +
      chrono::hours(12) + chrono::minutes(34) + chrono::seconds(56);

  EXPECT_EQ(
      "12:34:56.123456789012345",
      detail::format(kFmt, tp, detail::femtoseconds(123456789012345), utc));
  EXPECT_EQ(
      "12:34:56.012345678901234",
      detail::format(kFmt, tp, detail::femtoseconds(12345678901234), utc));
  EXPECT_EQ("12:34:56.001234567890123",
            detail::format(kFmt, tp, detail::femtoseconds(1234567890123), utc));
  EXPECT_EQ("12:34:56.000123456789012",
            detail::format(kFmt, tp, detail::femtoseconds(123456789012), utc));

  EXPECT_EQ("12:34:56.000000000000123",
            detail::format(kFmt, tp, detail::femtoseconds(123), utc));
  EXPECT_EQ("12:34:56.000000000000012",
            detail::format(kFmt, tp, detail::femtoseconds(12), utc));
  EXPECT_EQ("12:34:56.000000000000001",
            detail::format(kFmt, tp, detail::femtoseconds(1), utc));
}

TEST(Format, Basics) {
  time_zone tz = utc_time_zone();
  time_point<chrono::nanoseconds> tp = chrono::system_clock::from_time_t(0);

  // Starts with a couple basic edge cases.
  EXPECT_EQ("", absl::time_internal::cctz::format("", tp, tz));
  EXPECT_EQ(" ", absl::time_internal::cctz::format(" ", tp, tz));
  EXPECT_EQ("  ", absl::time_internal::cctz::format("  ", tp, tz));
  EXPECT_EQ("xxx", absl::time_internal::cctz::format("xxx", tp, tz));
  std::string big(128, 'x');
  EXPECT_EQ(big, absl::time_internal::cctz::format(big, tp, tz));
  // Cause the 1024-byte buffer to grow.
  std::string bigger(100000, 'x');
  EXPECT_EQ(bigger, absl::time_internal::cctz::format(bigger, tp, tz));

  tp += chrono::hours(13) + chrono::minutes(4) + chrono::seconds(5);
  tp += chrono::milliseconds(6) + chrono::microseconds(7) +
        chrono::nanoseconds(8);
  EXPECT_EQ("1970-01-01",
            absl::time_internal::cctz::format("%Y-%m-%d", tp, tz));
  EXPECT_EQ("13:04:05", absl::time_internal::cctz::format("%H:%M:%S", tp, tz));
  EXPECT_EQ("13:04:05.006",
            absl::time_internal::cctz::format("%H:%M:%E3S", tp, tz));
  EXPECT_EQ("13:04:05.006007",
            absl::time_internal::cctz::format("%H:%M:%E6S", tp, tz));
  EXPECT_EQ("13:04:05.006007008",
            absl::time_internal::cctz::format("%H:%M:%E9S", tp, tz));
}

TEST(Format, PosixConversions) {
  const time_zone tz = utc_time_zone();
  auto tp = chrono::system_clock::from_time_t(0);

  TestFormatSpecifier(tp, tz, "%d", "01");
  TestFormatSpecifier(tp, tz, "%e", " 1");  // extension but internal support
  TestFormatSpecifier(tp, tz, "%H", "00");
  TestFormatSpecifier(tp, tz, "%I", "12");
  TestFormatSpecifier(tp, tz, "%j", "001");
  TestFormatSpecifier(tp, tz, "%m", "01");
  TestFormatSpecifier(tp, tz, "%M", "00");
  TestFormatSpecifier(tp, tz, "%S", "00");
  TestFormatSpecifier(tp, tz, "%U", "00");
#if !defined(__EMSCRIPTEN__)
  TestFormatSpecifier(tp, tz, "%w", "4");  // 4=Thursday
#endif
  TestFormatSpecifier(tp, tz, "%W", "00");
  TestFormatSpecifier(tp, tz, "%y", "70");
  TestFormatSpecifier(tp, tz, "%Y", "1970");
  TestFormatSpecifier(tp, tz, "%z", "+0000");
  TestFormatSpecifier(tp, tz, "%Z", "UTC");
  TestFormatSpecifier(tp, tz, "%%", "%");

#if defined(__linux__)
  // SU/C99/TZ extensions
  TestFormatSpecifier(tp, tz, "%C", "19");
  TestFormatSpecifier(tp, tz, "%D", "01/01/70");
  TestFormatSpecifier(tp, tz, "%F", "1970-01-01");
  TestFormatSpecifier(tp, tz, "%g", "70");
  TestFormatSpecifier(tp, tz, "%G", "1970");
#if defined(__GLIBC__)
  TestFormatSpecifier(tp, tz, "%k", " 0");
  TestFormatSpecifier(tp, tz, "%l", "12");
#endif
  TestFormatSpecifier(tp, tz, "%n", "\n");
  TestFormatSpecifier(tp, tz, "%R", "00:00");
  TestFormatSpecifier(tp, tz, "%t", "\t");
  TestFormatSpecifier(tp, tz, "%T", "00:00:00");
  TestFormatSpecifier(tp, tz, "%u", "4");  // 4=Thursday
  TestFormatSpecifier(tp, tz, "%V", "01");
  TestFormatSpecifier(tp, tz, "%s", "0");
#endif
}

TEST(Format, LocaleSpecific) {
  const time_zone tz = utc_time_zone();
  auto tp = chrono::system_clock::from_time_t(0);

  TestFormatSpecifier(tp, tz, "%a", "Thu");
  TestFormatSpecifier(tp, tz, "%A", "Thursday");
  TestFormatSpecifier(tp, tz, "%b", "Jan");
  TestFormatSpecifier(tp, tz, "%B", "January");

  // %c should at least produce the numeric year and time-of-day.
  const std::string s =
      absl::time_internal::cctz::format("%c", tp, utc_time_zone());
  EXPECT_THAT(s, testing::HasSubstr("1970"));
  EXPECT_THAT(s, testing::HasSubstr("00:00:00"));

  TestFormatSpecifier(tp, tz, "%p", "AM");
  TestFormatSpecifier(tp, tz, "%x", "01/01/70");
  TestFormatSpecifier(tp, tz, "%X", "00:00:00");

#if defined(__linux__)
  // SU/C99/TZ extensions
  TestFormatSpecifier(tp, tz, "%h", "Jan");  // Same as %b
#if defined(__GLIBC__)
  TestFormatSpecifier(tp, tz, "%P", "am");
#endif
  TestFormatSpecifier(tp, tz, "%r", "12:00:00 AM");

  // Modified conversion specifiers %E_
  TestFormatSpecifier(tp, tz, "%Ec", "Thu Jan  1 00:00:00 1970");
  TestFormatSpecifier(tp, tz, "%EC", "19");
  TestFormatSpecifier(tp, tz, "%Ex", "01/01/70");
  TestFormatSpecifier(tp, tz, "%EX", "00:00:00");
  TestFormatSpecifier(tp, tz, "%Ey", "70");
  TestFormatSpecifier(tp, tz, "%EY", "1970");

  // Modified conversion specifiers %O_
  TestFormatSpecifier(tp, tz, "%Od", "01");
  TestFormatSpecifier(tp, tz, "%Oe", " 1");
  TestFormatSpecifier(tp, tz, "%OH", "00");
  TestFormatSpecifier(tp, tz, "%OI", "12");
  TestFormatSpecifier(tp, tz, "%Om", "01");
  TestFormatSpecifier(tp, tz, "%OM", "00");
  TestFormatSpecifier(tp, tz, "%OS", "00");
  TestFormatSpecifier(tp, tz, "%Ou", "4");  // 4=Thursday
  TestFormatSpecifier(tp, tz, "%OU", "00");
  TestFormatSpecifier(tp, tz, "%OV", "01");
  TestFormatSpecifier(tp, tz, "%Ow", "4");  // 4=Thursday
  TestFormatSpecifier(tp, tz, "%OW", "00");
  TestFormatSpecifier(tp, tz, "%Oy", "70");
#endif
}

TEST(Format, Escaping) {
  const time_zone tz = utc_time_zone();
  auto tp = chrono::system_clock::from_time_t(0);

  TestFormatSpecifier(tp, tz, "%%", "%");
  TestFormatSpecifier(tp, tz, "%%a", "%a");
  TestFormatSpecifier(tp, tz, "%%b", "%b");
  TestFormatSpecifier(tp, tz, "%%Ea", "%Ea");
  TestFormatSpecifier(tp, tz, "%%Es", "%Es");
  TestFormatSpecifier(tp, tz, "%%E3S", "%E3S");
  TestFormatSpecifier(tp, tz, "%%OS", "%OS");
  TestFormatSpecifier(tp, tz, "%%O3S", "%O3S");

  // Multiple levels of escaping.
  TestFormatSpecifier(tp, tz, "%%%Y", "%1970");
  TestFormatSpecifier(tp, tz, "%%%E3S", "%00.000");
  TestFormatSpecifier(tp, tz, "%%%%E3S", "%%E3S");
}

TEST(Format, ExtendedSeconds) {
  const time_zone tz = utc_time_zone();

  // No subseconds.
  time_point<chrono::nanoseconds> tp = chrono::system_clock::from_time_t(0);
  tp += chrono::seconds(5);
  EXPECT_EQ("05", absl::time_internal::cctz::format("%E*S", tp, tz));
  EXPECT_EQ("05", absl::time_internal::cctz::format("%E0S", tp, tz));
  EXPECT_EQ("05.0", absl::time_internal::cctz::format("%E1S", tp, tz));
  EXPECT_EQ("05.00", absl::time_internal::cctz::format("%E2S", tp, tz));
  EXPECT_EQ("05.000", absl::time_internal::cctz::format("%E3S", tp, tz));
  EXPECT_EQ("05.0000", absl::time_internal::cctz::format("%E4S", tp, tz));
  EXPECT_EQ("05.00000", absl::time_internal::cctz::format("%E5S", tp, tz));
  EXPECT_EQ("05.000000", absl::time_internal::cctz::format("%E6S", tp, tz));
  EXPECT_EQ("05.0000000", absl::time_internal::cctz::format("%E7S", tp, tz));
  EXPECT_EQ("05.00000000", absl::time_internal::cctz::format("%E8S", tp, tz));
  EXPECT_EQ("05.000000000", absl::time_internal::cctz::format("%E9S", tp, tz));
  EXPECT_EQ("05.0000000000",
            absl::time_internal::cctz::format("%E10S", tp, tz));
  EXPECT_EQ("05.00000000000",
            absl::time_internal::cctz::format("%E11S", tp, tz));
  EXPECT_EQ("05.000000000000",
            absl::time_internal::cctz::format("%E12S", tp, tz));
  EXPECT_EQ("05.0000000000000",
            absl::time_internal::cctz::format("%E13S", tp, tz));
  EXPECT_EQ("05.00000000000000",
            absl::time_internal::cctz::format("%E14S", tp, tz));
  EXPECT_EQ("05.000000000000000",
            absl::time_internal::cctz::format("%E15S", tp, tz));

  // With subseconds.
  tp += chrono::milliseconds(6) + chrono::microseconds(7) +
        chrono::nanoseconds(8);
  EXPECT_EQ("05.006007008", absl::time_internal::cctz::format("%E*S", tp, tz));
  EXPECT_EQ("05", absl::time_internal::cctz::format("%E0S", tp, tz));
  EXPECT_EQ("05.0", absl::time_internal::cctz::format("%E1S", tp, tz));
  EXPECT_EQ("05.00", absl::time_internal::cctz::format("%E2S", tp, tz));
  EXPECT_EQ("05.006", absl::time_internal::cctz::format("%E3S", tp, tz));
  EXPECT_EQ("05.0060", absl::time_internal::cctz::format("%E4S", tp, tz));
  EXPECT_EQ("05.00600", absl::time_internal::cctz::format("%E5S", tp, tz));
  EXPECT_EQ("05.006007", absl::time_internal::cctz::format("%E6S", tp, tz));
  EXPECT_EQ("05.0060070", absl::time_internal::cctz::format("%E7S", tp, tz));
  EXPECT_EQ("05.00600700", absl::time_internal::cctz::format("%E8S", tp, tz));
  EXPECT_EQ("05.006007008", absl::time_internal::cctz::format("%E9S", tp, tz));
  EXPECT_EQ("05.0060070080",
            absl::time_internal::cctz::format("%E10S", tp, tz));
  EXPECT_EQ("05.00600700800",
            absl::time_internal::cctz::format("%E11S", tp, tz));
  EXPECT_EQ("05.006007008000",
            absl::time_internal::cctz::format("%E12S", tp, tz));
  EXPECT_EQ("05.0060070080000",
            absl::time_internal::cctz::format("%E13S", tp, tz));
  EXPECT_EQ("05.00600700800000",
            absl::time_internal::cctz::format("%E14S", tp, tz));
  EXPECT_EQ("05.006007008000000",
            absl::time_internal::cctz::format("%E15S", tp, tz));

  // Times before the Unix epoch.
  tp = chrono::system_clock::from_time_t(0) + chrono::microseconds(-1);
  EXPECT_EQ("1969-12-31 23:59:59.999999",
            absl::time_internal::cctz::format("%Y-%m-%d %H:%M:%E*S", tp, tz));

  // Here is a "%E*S" case we got wrong for a while.  While the first
  // instant below is correctly rendered as "...:07.333304", the second
  // one used to appear as "...:07.33330499999999999".
  tp = chrono::system_clock::from_time_t(0) +
       chrono::microseconds(1395024427333304);
  EXPECT_EQ("2014-03-17 02:47:07.333304",
            absl::time_internal::cctz::format("%Y-%m-%d %H:%M:%E*S", tp, tz));
  tp += chrono::microseconds(1);
  EXPECT_EQ("2014-03-17 02:47:07.333305",
            absl::time_internal::cctz::format("%Y-%m-%d %H:%M:%E*S", tp, tz));
}

TEST(Format, ExtendedSubeconds) {
  const time_zone tz = utc_time_zone();

  // No subseconds.
  time_point<chrono::nanoseconds> tp = chrono::system_clock::from_time_t(0);
  tp += chrono::seconds(5);
  EXPECT_EQ("0", absl::time_internal::cctz::format("%E*f", tp, tz));
  EXPECT_EQ("", absl::time_internal::cctz::format("%E0f", tp, tz));
  EXPECT_EQ("0", absl::time_internal::cctz::format("%E1f", tp, tz));
  EXPECT_EQ("00", absl::time_internal::cctz::format("%E2f", tp, tz));
  EXPECT_EQ("000", absl::time_internal::cctz::format("%E3f", tp, tz));
  EXPECT_EQ("0000", absl::time_internal::cctz::format("%E4f", tp, tz));
  EXPECT_EQ("00000", absl::time_internal::cctz::format("%E5f", tp, tz));
  EXPECT_EQ("000000", absl::time_internal::cctz::format("%E6f", tp, tz));
  EXPECT_EQ("0000000", absl::time_internal::cctz::format("%E7f", tp, tz));
  EXPECT_EQ("00000000", absl::time_internal::cctz::format("%E8f", tp, tz));
  EXPECT_EQ("000000000", absl::time_internal::cctz::format("%E9f", tp, tz));
  EXPECT_EQ("0000000000", absl::time_internal::cctz::format("%E10f", tp, tz));
  EXPECT_EQ("00000000000", absl::time_internal::cctz::format("%E11f", tp, tz));
  EXPECT_EQ("000000000000", absl::time_internal::cctz::format("%E12f", tp, tz));
  EXPECT_EQ("0000000000000",
            absl::time_internal::cctz::format("%E13f", tp, tz));
  EXPECT_EQ("00000000000000",
            absl::time_internal::cctz::format("%E14f", tp, tz));
  EXPECT_EQ("000000000000000",
            absl::time_internal::cctz::format("%E15f", tp, tz));

  // With subseconds.
  tp += chrono::milliseconds(6) + chrono::microseconds(7) +
        chrono::nanoseconds(8);
  EXPECT_EQ("006007008", absl::time_internal::cctz::format("%E*f", tp, tz));
  EXPECT_EQ("", absl::time_internal::cctz::format("%E0f", tp, tz));
  EXPECT_EQ("0", absl::time_internal::cctz::format("%E1f", tp, tz));
  EXPECT_EQ("00", absl::time_internal::cctz::format("%E2f", tp, tz));
  EXPECT_EQ("006", absl::time_internal::cctz::format("%E3f", tp, tz));
  EXPECT_EQ("0060", absl::time_internal::cctz::format("%E4f", tp, tz));
  EXPECT_EQ("00600", absl::time_internal::cctz::format("%E5f", tp, tz));
  EXPECT_EQ("006007", absl::time_internal::cctz::format("%E6f", tp, tz));
  EXPECT_EQ("0060070", absl::time_internal::cctz::format("%E7f", tp, tz));
  EXPECT_EQ("00600700", absl::time_internal::cctz::format("%E8f", tp, tz));
  EXPECT_EQ("006007008", absl::time_internal::cctz::format("%E9f", tp, tz));
  EXPECT_EQ("0060070080", absl::time_internal::cctz::format("%E10f", tp, tz));
  EXPECT_EQ("00600700800", absl::time_internal::cctz::format("%E11f", tp, tz));
  EXPECT_EQ("006007008000", absl::time_internal::cctz::format("%E12f", tp, tz));
  EXPECT_EQ("0060070080000",
            absl::time_internal::cctz::format("%E13f", tp, tz));
  EXPECT_EQ("00600700800000",
            absl::time_internal::cctz::format("%E14f", tp, tz));
  EXPECT_EQ("006007008000000",
            absl::time_internal::cctz::format("%E15f", tp, tz));

  // Times before the Unix epoch.
  tp = chrono::system_clock::from_time_t(0) + chrono::microseconds(-1);
  EXPECT_EQ(
      "1969-12-31 23:59:59.999999",
      absl::time_internal::cctz::format("%Y-%m-%d %H:%M:%S.%E*f", tp, tz));

  // Here is a "%E*S" case we got wrong for a while.  While the first
  // instant below is correctly rendered as "...:07.333304", the second
  // one used to appear as "...:07.33330499999999999".
  tp = chrono::system_clock::from_time_t(0) +
       chrono::microseconds(1395024427333304);
  EXPECT_EQ(
      "2014-03-17 02:47:07.333304",
      absl::time_internal::cctz::format("%Y-%m-%d %H:%M:%S.%E*f", tp, tz));
  tp += chrono::microseconds(1);
  EXPECT_EQ(
      "2014-03-17 02:47:07.333305",
      absl::time_internal::cctz::format("%Y-%m-%d %H:%M:%S.%E*f", tp, tz));
}

TEST(Format, CompareExtendSecondsVsSubseconds) {
  const time_zone tz = utc_time_zone();

  // This test case illustrates the differences/similarities between:
  //   fmt_A: %E<prec>S
  //   fmt_B: %S.%E<prec>f
  auto fmt_A = [](const std::string& prec) { return "%E" + prec + "S"; };
  auto fmt_B = [](const std::string& prec) { return "%S.%E" + prec + "f"; };

  // No subseconds:
  time_point<chrono::nanoseconds> tp = chrono::system_clock::from_time_t(0);
  tp += chrono::seconds(5);
  // ... %E*S and %S.%E*f are different.
  EXPECT_EQ("05", absl::time_internal::cctz::format(fmt_A("*"), tp, tz));
  EXPECT_EQ("05.0", absl::time_internal::cctz::format(fmt_B("*"), tp, tz));
  // ... %E0S and %S.%E0f are different.
  EXPECT_EQ("05", absl::time_internal::cctz::format(fmt_A("0"), tp, tz));
  EXPECT_EQ("05.", absl::time_internal::cctz::format(fmt_B("0"), tp, tz));
  // ... %E<prec>S and %S.%E<prec>f are the same for prec in [1:15].
  for (int prec = 1; prec <= 15; ++prec) {
    const std::string a =
        absl::time_internal::cctz::format(fmt_A(std::to_string(prec)), tp, tz);
    const std::string b =
        absl::time_internal::cctz::format(fmt_B(std::to_string(prec)), tp, tz);
    EXPECT_EQ(a, b) << "prec=" << prec;
  }

  // With subseconds:
  // ... %E*S and %S.%E*f are the same.
  tp += chrono::milliseconds(6) + chrono::microseconds(7) +
        chrono::nanoseconds(8);
  EXPECT_EQ("05.006007008",
            absl::time_internal::cctz::format(fmt_A("*"), tp, tz));
  EXPECT_EQ("05.006007008",
            absl::time_internal::cctz::format(fmt_B("*"), tp, tz));
  // ... %E0S and %S.%E0f are different.
  EXPECT_EQ("05", absl::time_internal::cctz::format(fmt_A("0"), tp, tz));
  EXPECT_EQ("05.", absl::time_internal::cctz::format(fmt_B("0"), tp, tz));
  // ... %E<prec>S and %S.%E<prec>f are the same for prec in [1:15].
  for (int prec = 1; prec <= 15; ++prec) {
    const std::string a =
        absl::time_internal::cctz::format(fmt_A(std::to_string(prec)), tp, tz);
    const std::string b =
        absl::time_internal::cctz::format(fmt_B(std::to_string(prec)), tp, tz);
    EXPECT_EQ(a, b) << "prec=" << prec;
  }
}

TEST(Format, ExtendedOffset) {
  const auto tp = chrono::system_clock::from_time_t(0);

  auto tz = fixed_time_zone(absl::time_internal::cctz::seconds::zero());
  TestFormatSpecifier(tp, tz, "%z", "+0000");
  TestFormatSpecifier(tp, tz, "%:z", "+00:00");
  TestFormatSpecifier(tp, tz, "%Ez", "+00:00");

  tz = fixed_time_zone(chrono::seconds(56));
  TestFormatSpecifier(tp, tz, "%z", "+0000");
  TestFormatSpecifier(tp, tz, "%:z", "+00:00");
  TestFormatSpecifier(tp, tz, "%Ez", "+00:00");

  tz = fixed_time_zone(-chrono::seconds(56));  // NOTE: +00:00
  TestFormatSpecifier(tp, tz, "%z", "+0000");
  TestFormatSpecifier(tp, tz, "%:z", "+00:00");
  TestFormatSpecifier(tp, tz, "%Ez", "+00:00");

  tz = fixed_time_zone(chrono::minutes(34));
  TestFormatSpecifier(tp, tz, "%z", "+0034");
  TestFormatSpecifier(tp, tz, "%:z", "+00:34");
  TestFormatSpecifier(tp, tz, "%Ez", "+00:34");

  tz = fixed_time_zone(-chrono::minutes(34));
  TestFormatSpecifier(tp, tz, "%z", "-0034");
  TestFormatSpecifier(tp, tz, "%:z", "-00:34");
  TestFormatSpecifier(tp, tz, "%Ez", "-00:34");

  tz = fixed_time_zone(chrono::minutes(34) + chrono::seconds(56));
  TestFormatSpecifier(tp, tz, "%z", "+0034");
  TestFormatSpecifier(tp, tz, "%:z", "+00:34");
  TestFormatSpecifier(tp, tz, "%Ez", "+00:34");

  tz = fixed_time_zone(-chrono::minutes(34) - chrono::seconds(56));
  TestFormatSpecifier(tp, tz, "%z", "-0034");
  TestFormatSpecifier(tp, tz, "%:z", "-00:34");
  TestFormatSpecifier(tp, tz, "%Ez", "-00:34");

  tz = fixed_time_zone(chrono::hours(12));
  TestFormatSpecifier(tp, tz, "%z", "+1200");
  TestFormatSpecifier(tp, tz, "%:z", "+12:00");
  TestFormatSpecifier(tp, tz, "%Ez", "+12:00");

  tz = fixed_time_zone(-chrono::hours(12));
  TestFormatSpecifier(tp, tz, "%z", "-1200");
  TestFormatSpecifier(tp, tz, "%:z", "-12:00");
  TestFormatSpecifier(tp, tz, "%Ez", "-12:00");

  tz = fixed_time_zone(chrono::hours(12) + chrono::seconds(56));
  TestFormatSpecifier(tp, tz, "%z", "+1200");
  TestFormatSpecifier(tp, tz, "%:z", "+12:00");
  TestFormatSpecifier(tp, tz, "%Ez", "+12:00");

  tz = fixed_time_zone(-chrono::hours(12) - chrono::seconds(56));
  TestFormatSpecifier(tp, tz, "%z", "-1200");
  TestFormatSpecifier(tp, tz, "%:z", "-12:00");
  TestFormatSpecifier(tp, tz, "%Ez", "-12:00");

  tz = fixed_time_zone(chrono::hours(12) + chrono::minutes(34));
  TestFormatSpecifier(tp, tz, "%z", "+1234");
  TestFormatSpecifier(tp, tz, "%:z", "+12:34");
  TestFormatSpecifier(tp, tz, "%Ez", "+12:34");

  tz = fixed_time_zone(-chrono::hours(12) - chrono::minutes(34));
  TestFormatSpecifier(tp, tz, "%z", "-1234");
  TestFormatSpecifier(tp, tz, "%:z", "-12:34");
  TestFormatSpecifier(tp, tz, "%Ez", "-12:34");

  tz = fixed_time_zone(chrono::hours(12) + chrono::minutes(34) +
                       chrono::seconds(56));
  TestFormatSpecifier(tp, tz, "%z", "+1234");
  TestFormatSpecifier(tp, tz, "%:z", "+12:34");
  TestFormatSpecifier(tp, tz, "%Ez", "+12:34");

  tz = fixed_time_zone(-chrono::hours(12) - chrono::minutes(34) -
                       chrono::seconds(56));
  TestFormatSpecifier(tp, tz, "%z", "-1234");
  TestFormatSpecifier(tp, tz, "%:z", "-12:34");
  TestFormatSpecifier(tp, tz, "%Ez", "-12:34");
}

TEST(Format, ExtendedSecondOffset) {
  const auto tp = chrono::system_clock::from_time_t(0);

  auto tz = fixed_time_zone(absl::time_internal::cctz::seconds::zero());
  TestFormatSpecifier(tp, tz, "%E*z", "+00:00:00");
  TestFormatSpecifier(tp, tz, "%::z", "+00:00:00");
  TestFormatSpecifier(tp, tz, "%:::z", "+00");

  tz = fixed_time_zone(chrono::seconds(56));
  TestFormatSpecifier(tp, tz, "%E*z", "+00:00:56");
  TestFormatSpecifier(tp, tz, "%::z", "+00:00:56");
  TestFormatSpecifier(tp, tz, "%:::z", "+00:00:56");

  tz = fixed_time_zone(-chrono::seconds(56));
  TestFormatSpecifier(tp, tz, "%E*z", "-00:00:56");
  TestFormatSpecifier(tp, tz, "%::z", "-00:00:56");
  TestFormatSpecifier(tp, tz, "%:::z", "-00:00:56");

  tz = fixed_time_zone(chrono::minutes(34));
  TestFormatSpecifier(tp, tz, "%E*z", "+00:34:00");
  TestFormatSpecifier(tp, tz, "%::z", "+00:34:00");
  TestFormatSpecifier(tp, tz, "%:::z", "+00:34");

  tz = fixed_time_zone(-chrono::minutes(34));
  TestFormatSpecifier(tp, tz, "%E*z", "-00:34:00");
  TestFormatSpecifier(tp, tz, "%::z", "-00:34:00");
  TestFormatSpecifier(tp, tz, "%:::z", "-00:34");

  tz = fixed_time_zone(chrono::minutes(34) + chrono::seconds(56));
  TestFormatSpecifier(tp, tz, "%E*z", "+00:34:56");
  TestFormatSpecifier(tp, tz, "%::z", "+00:34:56");
  TestFormatSpecifier(tp, tz, "%:::z", "+00:34:56");

  tz = fixed_time_zone(-chrono::minutes(34) - chrono::seconds(56));
  TestFormatSpecifier(tp, tz, "%E*z", "-00:34:56");
  TestFormatSpecifier(tp, tz, "%::z", "-00:34:56");
  TestFormatSpecifier(tp, tz, "%:::z", "-00:34:56");

  tz = fixed_time_zone(chrono::hours(12));
  TestFormatSpecifier(tp, tz, "%E*z", "+12:00:00");
  TestFormatSpecifier(tp, tz, "%::z", "+12:00:00");
  TestFormatSpecifier(tp, tz, "%:::z", "+12");

  tz = fixed_time_zone(-chrono::hours(12));
  TestFormatSpecifier(tp, tz, "%E*z", "-12:00:00");
  TestFormatSpecifier(tp, tz, "%::z", "-12:00:00");
  TestFormatSpecifier(tp, tz, "%:::z", "-12");

  tz = fixed_time_zone(chrono::hours(12) + chrono::seconds(56));
  TestFormatSpecifier(tp, tz, "%E*z", "+12:00:56");
  TestFormatSpecifier(tp, tz, "%::z", "+12:00:56");
  TestFormatSpecifier(tp, tz, "%:::z", "+12:00:56");

  tz = fixed_time_zone(-chrono::hours(12) - chrono::seconds(56));
  TestFormatSpecifier(tp, tz, "%E*z", "-12:00:56");
  TestFormatSpecifier(tp, tz, "%::z", "-12:00:56");
  TestFormatSpecifier(tp, tz, "%:::z", "-12:00:56");

  tz = fixed_time_zone(chrono::hours(12) + chrono::minutes(34));
  TestFormatSpecifier(tp, tz, "%E*z", "+12:34:00");
  TestFormatSpecifier(tp, tz, "%::z", "+12:34:00");
  TestFormatSpecifier(tp, tz, "%:::z", "+12:34");

  tz = fixed_time_zone(-chrono::hours(12) - chrono::minutes(34));
  TestFormatSpecifier(tp, tz, "%E*z", "-12:34:00");
  TestFormatSpecifier(tp, tz, "%::z", "-12:34:00");
  TestFormatSpecifier(tp, tz, "%:::z", "-12:34");

  tz = fixed_time_zone(chrono::hours(12) + chrono::minutes(34) +
                       chrono::seconds(56));
  TestFormatSpecifier(tp, tz, "%E*z", "+12:34:56");
  TestFormatSpecifier(tp, tz, "%::z", "+12:34:56");
  TestFormatSpecifier(tp, tz, "%:::z", "+12:34:56");

  tz = fixed_time_zone(-chrono::hours(12) - chrono::minutes(34) -
                       chrono::seconds(56));
  TestFormatSpecifier(tp, tz, "%E*z", "-12:34:56");
  TestFormatSpecifier(tp, tz, "%::z", "-12:34:56");
  TestFormatSpecifier(tp, tz, "%:::z", "-12:34:56");
}

TEST(Format, ExtendedYears) {
  const time_zone utc = utc_time_zone();
  const char e4y_fmt[] = "%E4Y%m%d";  // no separators

  // %E4Y zero-pads the year to produce at least 4 chars, including the sign.
  auto tp = convert(civil_second(-999, 11, 27, 0, 0, 0), utc);
  EXPECT_EQ("-9991127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
  tp = convert(civil_second(-99, 11, 27, 0, 0, 0), utc);
  EXPECT_EQ("-0991127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
  tp = convert(civil_second(-9, 11, 27, 0, 0, 0), utc);
  EXPECT_EQ("-0091127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
  tp = convert(civil_second(-1, 11, 27, 0, 0, 0), utc);
  EXPECT_EQ("-0011127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
  tp = convert(civil_second(0, 11, 27, 0, 0, 0), utc);
  EXPECT_EQ("00001127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
  tp = convert(civil_second(1, 11, 27, 0, 0, 0), utc);
  EXPECT_EQ("00011127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
  tp = convert(civil_second(9, 11, 27, 0, 0, 0), utc);
  EXPECT_EQ("00091127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
  tp = convert(civil_second(99, 11, 27, 0, 0, 0), utc);
  EXPECT_EQ("00991127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
  tp = convert(civil_second(999, 11, 27, 0, 0, 0), utc);
  EXPECT_EQ("09991127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
  tp = convert(civil_second(9999, 11, 27, 0, 0, 0), utc);
  EXPECT_EQ("99991127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));

  // When the year is outside [-999:9999], more than 4 chars are produced.
  tp = convert(civil_second(-1000, 11, 27, 0, 0, 0), utc);
  EXPECT_EQ("-10001127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
  tp = convert(civil_second(10000, 11, 27, 0, 0, 0), utc);
  EXPECT_EQ("100001127", absl::time_internal::cctz::format(e4y_fmt, tp, utc));
}

TEST(Format, RFC3339Format) {
  time_zone tz;
  EXPECT_TRUE(load_time_zone("America/Los_Angeles", &tz));

  time_point<chrono::nanoseconds> tp =
      convert(civil_second(1977, 6, 28, 9, 8, 7), tz);
  EXPECT_EQ("1977-06-28T09:08:07-07:00",
            absl::time_internal::cctz::format(RFC3339_full, tp, tz));
  EXPECT_EQ("1977-06-28T09:08:07-07:00",
            absl::time_internal::cctz::format(RFC3339_sec, tp, tz));

  tp += chrono::milliseconds(100);
  EXPECT_EQ("1977-06-28T09:08:07.1-07:00",
            absl::time_internal::cctz::format(RFC3339_full, tp, tz));
  EXPECT_EQ("1977-06-28T09:08:07-07:00",
            absl::time_internal::cctz::format(RFC3339_sec, tp, tz));

  tp += chrono::milliseconds(20);
  EXPECT_EQ("1977-06-28T09:08:07.12-07:00",
            absl::time_internal::cctz::format(RFC3339_full, tp, tz));
  EXPECT_EQ("1977-06-28T09:08:07-07:00",
            absl::time_internal::cctz::format(RFC3339_sec, tp, tz));

  tp += chrono::milliseconds(3);
  EXPECT_EQ("1977-06-28T09:08:07.123-07:00",
            absl::time_internal::cctz::format(RFC3339_full, tp, tz));
  EXPECT_EQ("1977-06-28T09:08:07-07:00",
            absl::time_internal::cctz::format(RFC3339_sec, tp, tz));

  tp += chrono::microseconds(400);
  EXPECT_EQ("1977-06-28T09:08:07.1234-07:00",
            absl::time_internal::cctz::format(RFC3339_full, tp, tz));
  EXPECT_EQ("1977-06-28T09:08:07-07:00",
            absl::time_internal::cctz::format(RFC3339_sec, tp, tz));

  tp += chrono::microseconds(50);
  EXPECT_EQ("1977-06-28T09:08:07.12345-07:00",
            absl::time_internal::cctz::format(RFC3339_full, tp, tz));
  EXPECT_EQ("1977-06-28T09:08:07-07:00",
            absl::time_internal::cctz::format(RFC3339_sec, tp, tz));

  tp += chrono::microseconds(6);
  EXPECT_EQ("1977-06-28T09:08:07.123456-07:00",
            absl::time_internal::cctz::format(RFC3339_full, tp, tz));
  EXPECT_EQ("1977-06-28T09:08:07-07:00",
            absl::time_internal::cctz::format(RFC3339_sec, tp, tz));

  tp += chrono::nanoseconds(700);
  EXPECT_EQ("1977-06-28T09:08:07.1234567-07:00",
            absl::time_internal::cctz::format(RFC3339_full, tp, tz));
  EXPECT_EQ("1977-06-28T09:08:07-07:00",
            absl::time_internal::cctz::format(RFC3339_sec, tp, tz));

  tp += chrono::nanoseconds(80);
  EXPECT_EQ("1977-06-28T09:08:07.12345678-07:00",
            absl::time_internal::cctz::format(RFC3339_full, tp, tz));
  EXPECT_EQ("1977-06-28T09:08:07-07:00",
            absl::time_internal::cctz::format(RFC3339_sec, tp, tz));

  tp += chrono::nanoseconds(9);
  EXPECT_EQ("1977-06-28T09:08:07.123456789-07:00",
            absl::time_internal::cctz::format(RFC3339_full, tp, tz));
  EXPECT_EQ("1977-06-28T09:08:07-07:00",
            absl::time_internal::cctz::format(RFC3339_sec, tp, tz));
}

TEST(Format, RFC1123Format) {  // locale specific
  time_zone tz;
  EXPECT_TRUE(load_time_zone("America/Los_Angeles", &tz));

  auto tp = convert(civil_second(1977, 6, 28, 9, 8, 7), tz);
  EXPECT_EQ("Tue, 28 Jun 1977 09:08:07 -0700",
            absl::time_internal::cctz::format(RFC1123_full, tp, tz));
  EXPECT_EQ("28 Jun 1977 09:08:07 -0700",
            absl::time_internal::cctz::format(RFC1123_no_wday, tp, tz));
}

TEST(Format, Week) {
  const time_zone utc = utc_time_zone();

  auto tp = convert(civil_second(2017, 1, 1, 0, 0, 0), utc);
  EXPECT_EQ("2017-01-7",
            absl::time_internal::cctz::format("%Y-%U-%u", tp, utc));
  EXPECT_EQ("2017-00-0",
            absl::time_internal::cctz::format("%Y-%W-%w", tp, utc));

  tp = convert(civil_second(2017, 12, 31, 0, 0, 0), utc);
  EXPECT_EQ("2017-53-7",
            absl::time_internal::cctz::format("%Y-%U-%u", tp, utc));
  EXPECT_EQ("2017-52-0",
            absl::time_internal::cctz::format("%Y-%W-%w", tp, utc));

  tp = convert(civil_second(2018, 1, 1, 0, 0, 0), utc);
  EXPECT_EQ("2018-00-1",
            absl::time_internal::cctz::format("%Y-%U-%u", tp, utc));
  EXPECT_EQ("2018-01-1",
            absl::time_internal::cctz::format("%Y-%W-%w", tp, utc));

  tp = convert(civil_second(2018, 12, 31, 0, 0, 0), utc);
  EXPECT_EQ("2018-52-1",
            absl::time_internal::cctz::format("%Y-%U-%u", tp, utc));
  EXPECT_EQ("2018-53-1",
            absl::time_internal::cctz::format("%Y-%W-%w", tp, utc));

  tp = convert(civil_second(2019, 1, 1, 0, 0, 0), utc);
  EXPECT_EQ("2019-00-2",
            absl::time_internal::cctz::format("%Y-%U-%u", tp, utc));
  EXPECT_EQ("2019-00-2",
            absl::time_internal::cctz::format("%Y-%W-%w", tp, utc));

  tp = convert(civil_second(2019, 12, 31, 0, 0, 0), utc);
  EXPECT_EQ("2019-52-2",
            absl::time_internal::cctz::format("%Y-%U-%u", tp, utc));
  EXPECT_EQ("2019-52-2",
            absl::time_internal::cctz::format("%Y-%W-%w", tp, utc));
}

//
// Testing parse()
//

TEST(Parse, TimePointResolution) {
  const char kFmt[] = "%H:%M:%E*S";
  const time_zone utc = utc_time_zone();

  time_point<chrono::nanoseconds> tp_ns;
  EXPECT_TRUE(parse(kFmt, "03:04:05.123456789", utc, &tp_ns));
  EXPECT_EQ("03:04:05.123456789",
            absl::time_internal::cctz::format(kFmt, tp_ns, utc));
  EXPECT_TRUE(parse(kFmt, "03:04:05.123456", utc, &tp_ns));
  EXPECT_EQ("03:04:05.123456",
            absl::time_internal::cctz::format(kFmt, tp_ns, utc));

  time_point<chrono::microseconds> tp_us;
  EXPECT_TRUE(parse(kFmt, "03:04:05.123456789", utc, &tp_us));
  EXPECT_EQ("03:04:05.123456",
            absl::time_internal::cctz::format(kFmt, tp_us, utc));
  EXPECT_TRUE(parse(kFmt, "03:04:05.123456", utc, &tp_us));
  EXPECT_EQ("03:04:05.123456",
            absl::time_internal::cctz::format(kFmt, tp_us, utc));
  EXPECT_TRUE(parse(kFmt, "03:04:05.123", utc, &tp_us));
  EXPECT_EQ("03:04:05.123",
            absl::time_internal::cctz::format(kFmt, tp_us, utc));

  time_point<chrono::milliseconds> tp_ms;
  EXPECT_TRUE(parse(kFmt, "03:04:05.123456", utc, &tp_ms));
  EXPECT_EQ("03:04:05.123",
            absl::time_internal::cctz::format(kFmt, tp_ms, utc));
  EXPECT_TRUE(parse(kFmt, "03:04:05.123", utc, &tp_ms));
  EXPECT_EQ("03:04:05.123",
            absl::time_internal::cctz::format(kFmt, tp_ms, utc));
  EXPECT_TRUE(parse(kFmt, "03:04:05", utc, &tp_ms));
  EXPECT_EQ("03:04:05", absl::time_internal::cctz::format(kFmt, tp_ms, utc));

  time_point<chrono::seconds> tp_s;
  EXPECT_TRUE(parse(kFmt, "03:04:05.123", utc, &tp_s));
  EXPECT_EQ("03:04:05", absl::time_internal::cctz::format(kFmt, tp_s, utc));
  EXPECT_TRUE(parse(kFmt, "03:04:05", utc, &tp_s));
  EXPECT_EQ("03:04:05", absl::time_internal::cctz::format(kFmt, tp_s, utc));

  time_point<chrono::minutes> tp_m;
  EXPECT_TRUE(parse(kFmt, "03:04:05", utc, &tp_m));
  EXPECT_EQ("03:04:00", absl::time_internal::cctz::format(kFmt, tp_m, utc));

  time_point<chrono::hours> tp_h;
  EXPECT_TRUE(parse(kFmt, "03:04:05", utc, &tp_h));
  EXPECT_EQ("03:00:00", absl::time_internal::cctz::format(kFmt, tp_h, utc));
}

TEST(Parse, TimePointExtendedResolution) {
  const char kFmt[] = "%H:%M:%E*S";
  const time_zone utc = utc_time_zone();

  time_point<absl::time_internal::cctz::seconds> tp;
  detail::femtoseconds fs;
  EXPECT_TRUE(detail::parse(kFmt, "12:34:56.123456789012345", utc, &tp, &fs));
  EXPECT_EQ("12:34:56.123456789012345", detail::format(kFmt, tp, fs, utc));
  EXPECT_TRUE(detail::parse(kFmt, "12:34:56.012345678901234", utc, &tp, &fs));
  EXPECT_EQ("12:34:56.012345678901234", detail::format(kFmt, tp, fs, utc));
  EXPECT_TRUE(detail::parse(kFmt, "12:34:56.001234567890123", utc, &tp, &fs));
  EXPECT_EQ("12:34:56.001234567890123", detail::format(kFmt, tp, fs, utc));
  EXPECT_TRUE(detail::parse(kFmt, "12:34:56.000000000000123", utc, &tp, &fs));
  EXPECT_EQ("12:34:56.000000000000123", detail::format(kFmt, tp, fs, utc));
  EXPECT_TRUE(detail::parse(kFmt, "12:34:56.000000000000012", utc, &tp, &fs));
  EXPECT_EQ("12:34:56.000000000000012", detail::format(kFmt, tp, fs, utc));
  EXPECT_TRUE(detail::parse(kFmt, "12:34:56.000000000000001", utc, &tp, &fs));
  EXPECT_EQ("12:34:56.000000000000001", detail::format(kFmt, tp, fs, utc));
}

TEST(Parse, Basics) {
  time_zone tz = utc_time_zone();
  time_point<chrono::nanoseconds> tp =
      chrono::system_clock::from_time_t(1234567890);

  // Simple edge cases.
  EXPECT_TRUE(parse("", "", tz, &tp));
  EXPECT_EQ(chrono::system_clock::from_time_t(0), tp);  // everything defaulted
  EXPECT_TRUE(parse(" ", " ", tz, &tp));
  EXPECT_TRUE(parse("  ", "  ", tz, &tp));
  EXPECT_TRUE(parse("x", "x", tz, &tp));
  EXPECT_TRUE(parse("xxx", "xxx", tz, &tp));

  EXPECT_TRUE(
      parse("%Y-%m-%d %H:%M:%S %z", "2013-06-28 19:08:09 -0800", tz, &tp));
  ExpectTime(tp, tz, 2013, 6, 29, 3, 8, 9, 0, false, "UTC");
}

TEST(Parse, WithTimeZone) {
  time_zone tz;
  EXPECT_TRUE(load_time_zone("America/Los_Angeles", &tz));
  time_point<chrono::nanoseconds> tp;

  // We can parse a string without a UTC offset if we supply a timezone.
  EXPECT_TRUE(parse("%Y-%m-%d %H:%M:%S", "2013-06-28 19:08:09", tz, &tp));
  ExpectTime(tp, tz, 2013, 6, 28, 19, 8, 9, -7 * 60 * 60, true, "PDT");

  // But the timezone is ignored when a UTC offset is present.
  EXPECT_TRUE(parse("%Y-%m-%d %H:%M:%S %z", "2013-06-28 19:08:09 +0800",
                    utc_time_zone(), &tp));
  ExpectTime(tp, tz, 2013, 6, 28, 19 - 8 - 7, 8, 9, -7 * 60 * 60, true, "PDT");

  // Check a skipped time (a Spring DST transition). parse() uses the
  // pre-transition offset.
  EXPECT_TRUE(parse("%Y-%m-%d %H:%M:%S", "2011-03-13 02:15:00", tz, &tp));
  ExpectTime(tp, tz, 2011, 3, 13, 3, 15, 0, -7 * 60 * 60, true, "PDT");

  // Check a repeated time (a Fall DST transition).  parse() uses the
  // pre-transition offset.
  EXPECT_TRUE(parse("%Y-%m-%d %H:%M:%S", "2011-11-06 01:15:00", tz, &tp));
  ExpectTime(tp, tz, 2011, 11, 6, 1, 15, 0, -7 * 60 * 60, true, "PDT");
}

TEST(Parse, LeapSecond) {
  time_zone tz;
  EXPECT_TRUE(load_time_zone("America/Los_Angeles", &tz));
  time_point<chrono::nanoseconds> tp;

  // ":59" -> ":59"
  EXPECT_TRUE(parse(RFC3339_full, "2013-06-28T07:08:59-08:00", tz, &tp));
  ExpectTime(tp, tz, 2013, 6, 28, 8, 8, 59, -7 * 60 * 60, true, "PDT");

  // ":59.5" -> ":59.5"
  EXPECT_TRUE(parse(RFC3339_full, "2013-06-28T07:08:59.5-08:00", tz, &tp));
  ExpectTime(tp, tz, 2013, 6, 28, 8, 8, 59, -7 * 60 * 60, true, "PDT");

  // ":60" -> ":00"
  EXPECT_TRUE(parse(RFC3339_full, "2013-06-28T07:08:60-08:00", tz, &tp));
  ExpectTime(tp, tz, 2013, 6, 28, 8, 9, 0, -7 * 60 * 60, true, "PDT");

  // ":60.5" -> ":00.0"
  EXPECT_TRUE(parse(RFC3339_full, "2013-06-28T07:08:60.5-08:00", tz, &tp));
  ExpectTime(tp, tz, 2013, 6, 28, 8, 9, 0, -7 * 60 * 60, true, "PDT");

  // ":61" -> error
  EXPECT_FALSE(parse(RFC3339_full, "2013-06-28T07:08:61-08:00", tz, &tp));
}

TEST(Parse, ErrorCases) {
  const time_zone tz = utc_time_zone();
  auto tp = chrono::system_clock::from_time_t(0);

  // Illegal trailing data.
  EXPECT_FALSE(parse("%S", "123", tz, &tp));

  // Can't parse an illegal format specifier.
  EXPECT_FALSE(parse("%Q", "x", tz, &tp));

  // Fails because of trailing, unparsed data "blah".
  EXPECT_FALSE(parse("%m-%d", "2-3 blah", tz, &tp));

  // Trailing whitespace is allowed.
  EXPECT_TRUE(parse("%m-%d", "2-3  ", tz, &tp));
  EXPECT_EQ(2, convert(tp, utc_time_zone()).month());
  EXPECT_EQ(3, convert(tp, utc_time_zone()).day());

  // Feb 31 requires normalization.
  EXPECT_FALSE(parse("%m-%d", "2-31", tz, &tp));

  // Check that we cannot have spaces in UTC offsets.
  EXPECT_TRUE(parse("%z", "-0203", tz, &tp));
  EXPECT_FALSE(parse("%z", "- 2 3", tz, &tp));
  EXPECT_TRUE(parse("%Ez", "-02:03", tz, &tp));
  EXPECT_FALSE(parse("%Ez", "- 2: 3", tz, &tp));

  // Check that we reject other malformed UTC offsets.
  EXPECT_FALSE(parse("%Ez", "+-08:00", tz, &tp));
  EXPECT_FALSE(parse("%Ez", "-+08:00", tz, &tp));

  // Check that we do not accept "-0" in fields that allow zero.
  EXPECT_FALSE(parse("%Y", "-0", tz, &tp));
  EXPECT_FALSE(parse("%E4Y", "-0", tz, &tp));
  EXPECT_FALSE(parse("%H", "-0", tz, &tp));
  EXPECT_FALSE(parse("%M", "-0", tz, &tp));
  EXPECT_FALSE(parse("%S", "-0", tz, &tp));
  EXPECT_FALSE(parse("%z", "+-000", tz, &tp));
  EXPECT_FALSE(parse("%Ez", "+-0:00", tz, &tp));
  EXPECT_FALSE(parse("%z", "-00-0", tz, &tp));
  EXPECT_FALSE(parse("%Ez", "-00:-0", tz, &tp));
}

TEST(Parse, PosixConversions) {
  time_zone tz = utc_time_zone();
  auto tp = chrono::system_clock::from_time_t(0);
  const auto reset = convert(civil_second(1977, 6, 28, 9, 8, 7), tz);

  tp = reset;
  EXPECT_TRUE(parse("%d", "15", tz, &tp));
  EXPECT_EQ(15, convert(tp, tz).day());

  // %e is an extension, but is supported internally.
  tp = reset;
  EXPECT_TRUE(parse("%e", "15", tz, &tp));
  EXPECT_EQ(15, convert(tp, tz).day());  // Equivalent to %d

  tp = reset;
  EXPECT_TRUE(parse("%H", "17", tz, &tp));
  EXPECT_EQ(17, convert(tp, tz).hour());

  tp = reset;
  EXPECT_TRUE(parse("%I", "5", tz, &tp));
  EXPECT_EQ(5, convert(tp, tz).hour());

  // %j is parsed but ignored.
  EXPECT_TRUE(parse("%j", "32", tz, &tp));

  tp = reset;
  EXPECT_TRUE(parse("%m", "11", tz, &tp));
  EXPECT_EQ(11, convert(tp, tz).month());

  tp = reset;
  EXPECT_TRUE(parse("%M", "33", tz, &tp));
  EXPECT_EQ(33, convert(tp, tz).minute());

  tp = reset;
  EXPECT_TRUE(parse("%S", "55", tz, &tp));
  EXPECT_EQ(55, convert(tp, tz).second());

  // %U is parsed but ignored.
  EXPECT_TRUE(parse("%U", "15", tz, &tp));

  // %w is parsed but ignored.
  EXPECT_TRUE(parse("%w", "2", tz, &tp));

  // %W is parsed but ignored.
  EXPECT_TRUE(parse("%W", "22", tz, &tp));

  tp = reset;
  EXPECT_TRUE(parse("%y", "04", tz, &tp));
  EXPECT_EQ(2004, convert(tp, tz).year());

  tp = reset;
  EXPECT_TRUE(parse("%Y", "2004", tz, &tp));
  EXPECT_EQ(2004, convert(tp, tz).year());

  EXPECT_TRUE(parse("%%", "%", tz, &tp));

#if defined(__linux__)
  // SU/C99/TZ extensions

  // Because we handle each (non-internal) specifier in a separate call
  // to strptime(), there is no way to group %C and %y together.  So we
  // just skip the %C/%y case.
#if 0
  tp = reset;
  EXPECT_TRUE(parse("%C %y", "20 04", tz, &tp));
  EXPECT_EQ(2004, convert(tp, tz).year());
#endif

  tp = reset;
  EXPECT_TRUE(parse("%D", "02/03/04", tz, &tp));
  EXPECT_EQ(2, convert(tp, tz).month());
  EXPECT_EQ(3, convert(tp, tz).day());
  EXPECT_EQ(2004, convert(tp, tz).year());

  EXPECT_TRUE(parse("%n", "\n", tz, &tp));

  tp = reset;
  EXPECT_TRUE(parse("%R", "03:44", tz, &tp));
  EXPECT_EQ(3, convert(tp, tz).hour());
  EXPECT_EQ(44, convert(tp, tz).minute());

  EXPECT_TRUE(parse("%t", "\t\v\f\n\r ", tz, &tp));

  tp = reset;
  EXPECT_TRUE(parse("%T", "03:44:55", tz, &tp));
  EXPECT_EQ(3, convert(tp, tz).hour());
  EXPECT_EQ(44, convert(tp, tz).minute());
  EXPECT_EQ(55, convert(tp, tz).second());

  tp = reset;
  EXPECT_TRUE(parse("%s", "1234567890", tz, &tp));
  EXPECT_EQ(chrono::system_clock::from_time_t(1234567890), tp);

  // %s conversion, like %z/%Ez, pays no heed to the optional zone.
  time_zone lax;
  EXPECT_TRUE(load_time_zone("America/Los_Angeles", &lax));
  tp = reset;
  EXPECT_TRUE(parse("%s", "1234567890", lax, &tp));
  EXPECT_EQ(chrono::system_clock::from_time_t(1234567890), tp);

  // This is most important when the time has the same YMDhms
  // breakdown in the zone as some other time.  For example, ...
  //  1414917000 in US/Pacific -> Sun Nov 2 01:30:00 2014 (PDT)
  //  1414920600 in US/Pacific -> Sun Nov 2 01:30:00 2014 (PST)
  tp = reset;
  EXPECT_TRUE(parse("%s", "1414917000", lax, &tp));
  EXPECT_EQ(chrono::system_clock::from_time_t(1414917000), tp);
  tp = reset;
  EXPECT_TRUE(parse("%s", "1414920600", lax, &tp));
  EXPECT_EQ(chrono::system_clock::from_time_t(1414920600), tp);
#endif
}

TEST(Parse, LocaleSpecific) {
  time_zone tz = utc_time_zone();
  auto tp = chrono::system_clock::from_time_t(0);
  const auto reset = convert(civil_second(1977, 6, 28, 9, 8, 7), tz);

  // %a is parsed but ignored.
  EXPECT_TRUE(parse("%a", "Mon", tz, &tp));

  // %A is parsed but ignored.
  EXPECT_TRUE(parse("%A", "Monday", tz, &tp));

  tp = reset;
  EXPECT_TRUE(parse("%b", "Feb", tz, &tp));
  EXPECT_EQ(2, convert(tp, tz).month());

  tp = reset;
  EXPECT_TRUE(parse("%B", "February", tz, &tp));
  EXPECT_EQ(2, convert(tp, tz).month());

  // %p is parsed but ignored if it's alone.  But it's used with %I.
  EXPECT_TRUE(parse("%p", "AM", tz, &tp));
  tp = reset;
  EXPECT_TRUE(parse("%I %p", "5 PM", tz, &tp));
  EXPECT_EQ(17, convert(tp, tz).hour());

  tp = reset;
  EXPECT_TRUE(parse("%x", "02/03/04", tz, &tp));
  if (convert(tp, tz).month() == 2) {
    EXPECT_EQ(3, convert(tp, tz).day());
  } else {
    EXPECT_EQ(2, convert(tp, tz).day());
    EXPECT_EQ(3, convert(tp, tz).month());
  }
  EXPECT_EQ(2004, convert(tp, tz).year());

  tp = reset;
  EXPECT_TRUE(parse("%X", "15:44:55", tz, &tp));
  EXPECT_EQ(15, convert(tp, tz).hour());
  EXPECT_EQ(44, convert(tp, tz).minute());
  EXPECT_EQ(55, convert(tp, tz).second());

#if defined(__linux__)
  // SU/C99/TZ extensions

  tp = reset;
  EXPECT_TRUE(parse("%h", "Feb", tz, &tp));
  EXPECT_EQ(2, convert(tp, tz).month());  // Equivalent to %b

#if defined(__GLIBC__)
  tp = reset;
  EXPECT_TRUE(parse("%l %p", "5 PM", tz, &tp));
  EXPECT_EQ(17, convert(tp, tz).hour());
#endif

  tp = reset;
  EXPECT_TRUE(parse("%r", "03:44:55 PM", tz, &tp));
  EXPECT_EQ(15, convert(tp, tz).hour());
  EXPECT_EQ(44, convert(tp, tz).minute());
  EXPECT_EQ(55, convert(tp, tz).second());

#if defined(__GLIBC__)
  tp = reset;
  EXPECT_TRUE(parse("%Ec", "Tue Nov 19 05:06:07 2013", tz, &tp));
  EXPECT_EQ(convert(civil_second(2013, 11, 19, 5, 6, 7), tz), tp);

  // Modified conversion specifiers %E_

  tp = reset;
  EXPECT_TRUE(parse("%Ex", "02/03/04", tz, &tp));
  EXPECT_EQ(2, convert(tp, tz).month());
  EXPECT_EQ(3, convert(tp, tz).day());
  EXPECT_EQ(2004, convert(tp, tz).year());

  tp = reset;
  EXPECT_TRUE(parse("%EX", "15:44:55", tz, &tp));
  EXPECT_EQ(15, convert(tp, tz).hour());
  EXPECT_EQ(44, convert(tp, tz).minute());
  EXPECT_EQ(55, convert(tp, tz).second());

  // %Ey, the year offset from %EC, doesn't really make sense alone as there
  // is no way to represent it in tm_year (%EC is not simply the century).
  // Yet, because we handle each (non-internal) specifier in a separate call
  // to strptime(), there is no way to group %EC and %Ey either.  So we just
  // skip the %EC and %Ey cases.

  tp = reset;
  EXPECT_TRUE(parse("%EY", "2004", tz, &tp));
  EXPECT_EQ(2004, convert(tp, tz).year());

  // Modified conversion specifiers %O_

  tp = reset;
  EXPECT_TRUE(parse("%Od", "15", tz, &tp));
  EXPECT_EQ(15, convert(tp, tz).day());

  tp = reset;
  EXPECT_TRUE(parse("%Oe", "15", tz, &tp));
  EXPECT_EQ(15, convert(tp, tz).day());  // Equivalent to %d

  tp = reset;
  EXPECT_TRUE(parse("%OH", "17", tz, &tp));
  EXPECT_EQ(17, convert(tp, tz).hour());

  tp = reset;
  EXPECT_TRUE(parse("%OI", "5", tz, &tp));
  EXPECT_EQ(5, convert(tp, tz).hour());

  tp = reset;
  EXPECT_TRUE(parse("%Om", "11", tz, &tp));
  EXPECT_EQ(11, convert(tp, tz).month());

  tp = reset;
  EXPECT_TRUE(parse("%OM", "33", tz, &tp));
  EXPECT_EQ(33, convert(tp, tz).minute());

  tp = reset;
  EXPECT_TRUE(parse("%OS", "55", tz, &tp));
  EXPECT_EQ(55, convert(tp, tz).second());

  // %OU is parsed but ignored.
  EXPECT_TRUE(parse("%OU", "15", tz, &tp));

  // %Ow is parsed but ignored.
  EXPECT_TRUE(parse("%Ow", "2", tz, &tp));

  // %OW is parsed but ignored.
  EXPECT_TRUE(parse("%OW", "22", tz, &tp));

  tp = reset;
  EXPECT_TRUE(parse("%Oy", "04", tz, &tp));
  EXPECT_EQ(2004, convert(tp, tz).year());
#endif
#endif
}

TEST(Parse, ExtendedSeconds) {
  const time_zone tz = utc_time_zone();
  const time_point<chrono::nanoseconds> unix_epoch =
      chrono::system_clock::from_time_t(0);

  // All %E<prec>S cases are treated the same as %E*S on input.
  auto precisions = {"*", "0", "1",  "2",  "3",  "4",  "5",  "6", "7",
                     "8", "9", "10", "11", "12", "13", "14", "15"};
  for (const std::string prec : precisions) {
    const std::string fmt = "%E" + prec + "S";
    SCOPED_TRACE(fmt);
    time_point<chrono::nanoseconds> tp = unix_epoch;
    EXPECT_TRUE(parse(fmt, "5", tz, &tp));
    EXPECT_EQ(unix_epoch + chrono::seconds(5), tp);
    tp = unix_epoch;
    EXPECT_TRUE(parse(fmt, "05", tz, &tp));
    EXPECT_EQ(unix_epoch + chrono::seconds(5), tp);
    tp = unix_epoch;
    EXPECT_TRUE(parse(fmt, "05.0", tz, &tp));
    EXPECT_EQ(unix_epoch + chrono::seconds(5), tp);
    tp = unix_epoch;
    EXPECT_TRUE(parse(fmt, "05.00", tz, &tp));
    EXPECT_EQ(unix_epoch + chrono::seconds(5), tp);
    tp = unix_epoch;
    EXPECT_TRUE(parse(fmt, "05.6", tz, &tp));
    EXPECT_EQ(unix_epoch + chrono::seconds(5) + chrono::milliseconds(600), tp);
    tp = unix_epoch;
    EXPECT_TRUE(parse(fmt, "05.60", tz, &tp));
    EXPECT_EQ(unix_epoch + chrono::seconds(5) + chrono::milliseconds(600), tp);
    tp = unix_epoch;
    EXPECT_TRUE(parse(fmt, "05.600", tz, &tp));
    EXPECT_EQ(unix_epoch + chrono::seconds(5) + chrono::milliseconds(600), tp);
    tp = unix_epoch;
    EXPECT_TRUE(parse(fmt, "05.67", tz, &tp));
    EXPECT_EQ(unix_epoch + chrono::seconds(5) + chrono::milliseconds(670), tp);
    tp = unix_epoch;
    EXPECT_TRUE(parse(fmt, "05.670", tz, &tp));
    EXPECT_EQ(unix_epoch + chrono::seconds(5) + chrono::milliseconds(670), tp);
    tp = unix_epoch;
    EXPECT_TRUE(parse(fmt, "05.678", tz, &tp));
    EXPECT_EQ(unix_epoch + chrono::seconds(5) + chrono::milliseconds(678), tp);
  }

  // Here is a "%E*S" case we got wrong for a while.  The fractional
  // part of the first instant is less than 2^31 and was correctly
  // parsed, while the second (and any subsecond field >=2^31) failed.
  time_point<chrono::nanoseconds> tp = unix_epoch;
  EXPECT_TRUE(parse("%E*S", "0.2147483647", tz, &tp));
  EXPECT_EQ(unix_epoch + chrono::nanoseconds(214748364), tp);
  tp = unix_epoch;
  EXPECT_TRUE(parse("%E*S", "0.2147483648", tz, &tp));
  EXPECT_EQ(unix_epoch + chrono::nanoseconds(214748364), tp);

  // We should also be able to specify long strings of digits far
  // beyond the current resolution and have them convert the same way.
  tp = unix_epoch;
  EXPECT_TRUE(parse(
      "%E*S", "0.214748364801234567890123456789012345678901234567890123456789",
      tz, &tp));
  EXPECT_EQ(unix_epoch + chrono::nanoseconds(214748364), tp);
}

TEST(Parse, ExtendedSecondsScan) {
  const time_zone tz = utc_time_zone();
  time_point<chrono::nanoseconds> tp;
  for (int ms = 0; ms < 1000; ms += 111) {
    for (int us = 0; us < 1000; us += 27) {
      const int micros = ms * 1000 + us;
      for (int ns = 0; ns < 1000; ns += 9) {
        const auto expected = chrono::system_clock::from_time_t(0) +
                              chrono::nanoseconds(micros * 1000 + ns);
        std::ostringstream oss;
        oss << "0." << std::setfill('0') << std::setw(3);
        oss << ms << std::setw(3) << us << std::setw(3) << ns;
        const std::string input = oss.str();
        EXPECT_TRUE(parse("%E*S", input, tz, &tp));
        EXPECT_EQ(expected, tp) << input;
      }
    }
  }
}

TEST(Parse, ExtendedSubeconds) {
  const time_zone tz = utc_time_zone();
  const time_point<chrono::nanoseconds> unix_epoch =
      chrono::system_clock::from_time_t(0);

  // All %E<prec>f cases are treated the same as %E*f on input.
  auto precisions = {"*", "0", "1",  "2",  "3",  "4",  "5",  "6", "7",
                     "8", "9", "10", "11", "12", "13", "14", "15"};
  for (const std::string prec : precisions) {
    const std::string fmt = "%E" + prec + "f";
    SCOPED_TRACE(fmt);
    time_point<chrono::nanoseconds> tp = unix_epoch - chrono::seconds(1);
    EXPECT_TRUE(parse(fmt, "", tz, &tp));
    EXPECT_EQ(unix_epoch, tp);
    tp = unix_epoch;
    EXPECT_TRUE(parse(fmt, "6", tz, &tp));
    EXPECT_EQ(unix_epoch + chrono::milliseconds(600), tp);
    tp = unix_epoch;
    EXPECT_TRUE(parse(fmt, "60", tz, &tp));
    EXPECT_EQ(unix_epoch + chrono::milliseconds(600), tp);
    tp = unix_epoch;
    EXPECT_TRUE(parse(fmt, "600", tz, &tp));
    EXPECT_EQ(unix_epoch + chrono::milliseconds(600), tp);
    tp = unix_epoch;
    EXPECT_TRUE(parse(fmt, "67", tz, &tp));
    EXPECT_EQ(unix_epoch + chrono::milliseconds(670), tp);
    tp = unix_epoch;
    EXPECT_TRUE(parse(fmt, "670", tz, &tp));
    EXPECT_EQ(unix_epoch + chrono::milliseconds(670), tp);
    tp = unix_epoch;
    EXPECT_TRUE(parse(fmt, "678", tz, &tp));
    EXPECT_EQ(unix_epoch + chrono::milliseconds(678), tp);
    tp = unix_epoch;
    EXPECT_TRUE(parse(fmt, "6789", tz, &tp));
    EXPECT_EQ(
        unix_epoch + chrono::milliseconds(678) + chrono::microseconds(900), tp);
  }

  // Here is a "%E*f" case we got wrong for a while.  The fractional
  // part of the first instant is less than 2^31 and was correctly
  // parsed, while the second (and any subsecond field >=2^31) failed.
  time_point<chrono::nanoseconds> tp = unix_epoch;
  EXPECT_TRUE(parse("%E*f", "2147483647", tz, &tp));
  EXPECT_EQ(unix_epoch + chrono::nanoseconds(214748364), tp);
  tp = unix_epoch;
  EXPECT_TRUE(parse("%E*f", "2147483648", tz, &tp));
  EXPECT_EQ(unix_epoch + chrono::nanoseconds(214748364), tp);

  // We should also be able to specify long strings of digits far
  // beyond the current resolution and have them convert the same way.
  tp = unix_epoch;
  EXPECT_TRUE(parse(
      "%E*f", "214748364801234567890123456789012345678901234567890123456789",
      tz, &tp));
  EXPECT_EQ(unix_epoch + chrono::nanoseconds(214748364), tp);
}

TEST(Parse, ExtendedSubecondsScan) {
  time_point<chrono::nanoseconds> tp;
  const time_zone tz = utc_time_zone();
  for (int ms = 0; ms < 1000; ms += 111) {
    for (int us = 0; us < 1000; us += 27) {
      const int micros = ms * 1000 + us;
      for (int ns = 0; ns < 1000; ns += 9) {
        std::ostringstream oss;
        oss << std::setfill('0') << std::setw(3) << ms;
        oss << std::setw(3) << us << std::setw(3) << ns;
        const std::string nanos = oss.str();
        const auto expected = chrono::system_clock::from_time_t(0) +
                              chrono::nanoseconds(micros * 1000 + ns);
        for (int ps = 0; ps < 1000; ps += 250) {
          std::ostringstream ps_oss;
          oss << std::setfill('0') << std::setw(3) << ps;
          const std::string input = nanos + ps_oss.str() + "999";
          EXPECT_TRUE(parse("%E*f", input, tz, &tp));
          EXPECT_EQ(expected + chrono::nanoseconds(ps) / 1000, tp) << input;
        }
      }
    }
  }
}

TEST(Parse, ExtendedOffset) {
  const time_zone utc = utc_time_zone();
  time_point<absl::time_internal::cctz::seconds> tp;

  EXPECT_TRUE(parse("%Ez", "+00:00", utc, &tp));
  EXPECT_EQ(convert(civil_second(1970, 1, 1, 0, 0, 0), utc), tp);
  EXPECT_TRUE(parse("%Ez", "-12:34", utc, &tp));
  EXPECT_EQ(convert(civil_second(1970, 1, 1, 12, 34, 0), utc), tp);
  EXPECT_TRUE(parse("%Ez", "+12:34", utc, &tp));
  EXPECT_EQ(convert(civil_second(1969, 12, 31, 11, 26, 0), utc), tp);
  EXPECT_FALSE(parse("%Ez", "-12:3", utc, &tp));

  for (auto fmt : {"%Ez", "%z"}) {
    EXPECT_TRUE(parse(fmt, "+0000", utc, &tp));
    EXPECT_EQ(convert(civil_second(1970, 1, 1, 0, 0, 0), utc), tp);
    EXPECT_TRUE(parse(fmt, "-1234", utc, &tp));
    EXPECT_EQ(convert(civil_second(1970, 1, 1, 12, 34, 0), utc), tp);
    EXPECT_TRUE(parse(fmt, "+1234", utc, &tp));
    EXPECT_EQ(convert(civil_second(1969, 12, 31, 11, 26, 0), utc), tp);
    EXPECT_FALSE(parse(fmt, "-123", utc, &tp));

    EXPECT_TRUE(parse(fmt, "+00", utc, &tp));
    EXPECT_EQ(convert(civil_second(1970, 1, 1, 0, 0, 0), utc), tp);
    EXPECT_TRUE(parse(fmt, "-12", utc, &tp));
    EXPECT_EQ(convert(civil_second(1970, 1, 1, 12, 0, 0), utc), tp);
    EXPECT_TRUE(parse(fmt, "+12", utc, &tp));
    EXPECT_EQ(convert(civil_second(1969, 12, 31, 12, 0, 0), utc), tp);
    EXPECT_FALSE(parse(fmt, "-1", utc, &tp));
  }
}

TEST(Parse, ExtendedSecondOffset) {
  const time_zone utc = utc_time_zone();
  time_point<absl::time_internal::cctz::seconds> tp;

  for (auto fmt : {"%Ez", "%E*z", "%:z", "%::z", "%:::z"}) {
    EXPECT_TRUE(parse(fmt, "+00:00:00", utc, &tp));
    EXPECT_EQ(convert(civil_second(1970, 1, 1, 0, 0, 0), utc), tp);
    EXPECT_TRUE(parse(fmt, "-12:34:56", utc, &tp));
    EXPECT_EQ(convert(civil_second(1970, 1, 1, 12, 34, 56), utc), tp);
    EXPECT_TRUE(parse(fmt, "+12:34:56", utc, &tp));
    EXPECT_EQ(convert(civil_second(1969, 12, 31, 11, 25, 4), utc), tp);
    EXPECT_FALSE(parse(fmt, "-12:34:5", utc, &tp));

    EXPECT_TRUE(parse(fmt, "+000000", utc, &tp));
    EXPECT_EQ(convert(civil_second(1970, 1, 1, 0, 0, 0), utc), tp);
    EXPECT_TRUE(parse(fmt, "-123456", utc, &tp));
    EXPECT_EQ(convert(civil_second(1970, 1, 1, 12, 34, 56), utc), tp);
    EXPECT_TRUE(parse(fmt, "+123456", utc, &tp));
    EXPECT_EQ(convert(civil_second(1969, 12, 31, 11, 25, 4), utc), tp);
    EXPECT_FALSE(parse(fmt, "-12345", utc, &tp));

    EXPECT_TRUE(parse(fmt, "+00:00", utc, &tp));
    EXPECT_EQ(convert(civil_second(1970, 1, 1, 0, 0, 0), utc), tp);
    EXPECT_TRUE(parse(fmt, "-12:34", utc, &tp));
    EXPECT_EQ(convert(civil_second(1970, 1, 1, 12, 34, 0), utc), tp);
    EXPECT_TRUE(parse(fmt, "+12:34", utc, &tp));
    EXPECT_EQ(convert(civil_second(1969, 12, 31, 11, 26, 0), utc), tp);
    EXPECT_FALSE(parse(fmt, "-12:3", utc, &tp));

    EXPECT_TRUE(parse(fmt, "+0000", utc, &tp));
    EXPECT_EQ(convert(civil_second(1970, 1, 1, 0, 0, 0), utc), tp);
    EXPECT_TRUE(parse(fmt, "-1234", utc, &tp));
    EXPECT_EQ(convert(civil_second(1970, 1, 1, 12, 34, 0), utc), tp);
    EXPECT_TRUE(parse(fmt, "+1234", utc, &tp));
    EXPECT_EQ(convert(civil_second(1969, 12, 31, 11, 26, 0), utc), tp);
    EXPECT_FALSE(parse(fmt, "-123", utc, &tp));

    EXPECT_TRUE(parse(fmt, "+00", utc, &tp));
    EXPECT_EQ(convert(civil_second(1970, 1, 1, 0, 0, 0), utc), tp);
    EXPECT_TRUE(parse(fmt, "-12", utc, &tp));
    EXPECT_EQ(convert(civil_second(1970, 1, 1, 12, 0, 0), utc), tp);
    EXPECT_TRUE(parse(fmt, "+12", utc, &tp));
    EXPECT_EQ(convert(civil_second(1969, 12, 31, 12, 0, 0), utc), tp);
    EXPECT_FALSE(parse(fmt, "-1", utc, &tp));
  }
}

TEST(Parse, ExtendedYears) {
  const time_zone utc = utc_time_zone();
  const char e4y_fmt[] = "%E4Y%m%d";  // no separators
  time_point<absl::time_internal::cctz::seconds> tp;

  // %E4Y consumes exactly four chars, including any sign.
  EXPECT_TRUE(parse(e4y_fmt, "-9991127", utc, &tp));
  EXPECT_EQ(convert(civil_second(-999, 11, 27, 0, 0, 0), utc), tp);
  EXPECT_TRUE(parse(e4y_fmt, "-0991127", utc, &tp));
  EXPECT_EQ(convert(civil_second(-99, 11, 27, 0, 0, 0), utc), tp);
  EXPECT_TRUE(parse(e4y_fmt, "-0091127", utc, &tp));
  EXPECT_EQ(convert(civil_second(-9, 11, 27, 0, 0, 0), utc), tp);
  EXPECT_TRUE(parse(e4y_fmt, "-0011127", utc, &tp));
  EXPECT_EQ(convert(civil_second(-1, 11, 27, 0, 0, 0), utc), tp);
  EXPECT_TRUE(parse(e4y_fmt, "00001127", utc, &tp));
  EXPECT_EQ(convert(civil_second(0, 11, 27, 0, 0, 0), utc), tp);
  EXPECT_TRUE(parse(e4y_fmt, "00011127", utc, &tp));
  EXPECT_EQ(convert(civil_second(1, 11, 27, 0, 0, 0), utc), tp);
  EXPECT_TRUE(parse(e4y_fmt, "00091127", utc, &tp));
  EXPECT_EQ(convert(civil_second(9, 11, 27, 0, 0, 0), utc), tp);
  EXPECT_TRUE(parse(e4y_fmt, "00991127", utc, &tp));
  EXPECT_EQ(convert(civil_second(99, 11, 27, 0, 0, 0), utc), tp);
  EXPECT_TRUE(parse(e4y_fmt, "09991127", utc, &tp));
  EXPECT_EQ(convert(civil_second(999, 11, 27, 0, 0, 0), utc), tp);
  EXPECT_TRUE(parse(e4y_fmt, "99991127", utc, &tp));
  EXPECT_EQ(convert(civil_second(9999, 11, 27, 0, 0, 0), utc), tp);

  // When the year is outside [-999:9999], the parse fails.
  EXPECT_FALSE(parse(e4y_fmt, "-10001127", utc, &tp));
  EXPECT_FALSE(parse(e4y_fmt, "100001127", utc, &tp));
}

TEST(Parse, RFC3339Format) {
  const time_zone tz = utc_time_zone();
  time_point<chrono::nanoseconds> tp;
  EXPECT_TRUE(parse(RFC3339_sec, "2014-02-12T20:21:00+00:00", tz, &tp));
  ExpectTime(tp, tz, 2014, 2, 12, 20, 21, 0, 0, false, "UTC");

  // Check that %ET also accepts "t".
  time_point<chrono::nanoseconds> tp2;
  EXPECT_TRUE(parse(RFC3339_sec, "2014-02-12t20:21:00+00:00", tz, &tp2));
  EXPECT_EQ(tp, tp2);

  // Check that %Ez also accepts "Z" as a synonym for "+00:00".
  time_point<chrono::nanoseconds> tp3;
  EXPECT_TRUE(parse(RFC3339_sec, "2014-02-12T20:21:00Z", tz, &tp3));
  EXPECT_EQ(tp, tp3);

  // Check that %Ez also accepts "z" as a synonym for "+00:00".
  time_point<chrono::nanoseconds> tp4;
  EXPECT_TRUE(parse(RFC3339_sec, "2014-02-12T20:21:00z", tz, &tp4));
  EXPECT_EQ(tp, tp4);
}

TEST(Parse, Week) {
  const time_zone utc = utc_time_zone();
  time_point<absl::time_internal::cctz::seconds> tp;

  auto exp = convert(civil_second(2017, 1, 1, 0, 0, 0), utc);
  EXPECT_TRUE(parse("%Y-%U-%u", "2017-01-7", utc, &tp));
  EXPECT_EQ(exp, tp);
  EXPECT_TRUE(parse("%Y-%W-%w", "2017-00-0", utc, &tp));
  EXPECT_EQ(exp, tp);

  exp = convert(civil_second(2017, 12, 31, 0, 0, 0), utc);
  EXPECT_TRUE(parse("%Y-%U-%u", "2017-53-7", utc, &tp));
  EXPECT_EQ(exp, tp);
  EXPECT_TRUE(parse("%Y-%W-%w", "2017-52-0", utc, &tp));
  EXPECT_EQ(exp, tp);

  exp = convert(civil_second(2018, 1, 1, 0, 0, 0), utc);
  EXPECT_TRUE(parse("%Y-%U-%u", "2018-00-1", utc, &tp));
  EXPECT_EQ(exp, tp);
  EXPECT_TRUE(parse("%Y-%W-%w", "2018-01-1", utc, &tp));
  EXPECT_EQ(exp, tp);

  exp = convert(civil_second(2018, 12, 31, 0, 0, 0), utc);
  EXPECT_TRUE(parse("%Y-%U-%u", "2018-52-1", utc, &tp));
  EXPECT_EQ(exp, tp);
  EXPECT_TRUE(parse("%Y-%W-%w", "2018-53-1", utc, &tp));
  EXPECT_EQ(exp, tp);

  exp = convert(civil_second(2019, 1, 1, 0, 0, 0), utc);
  EXPECT_TRUE(parse("%Y-%U-%u", "2019-00-2", utc, &tp));
  EXPECT_EQ(exp, tp);
  EXPECT_TRUE(parse("%Y-%W-%w", "2019-00-2", utc, &tp));
  EXPECT_EQ(exp, tp);

  exp = convert(civil_second(2019, 12, 31, 0, 0, 0), utc);
  EXPECT_TRUE(parse("%Y-%U-%u", "2019-52-2", utc, &tp));
  EXPECT_EQ(exp, tp);
  EXPECT_TRUE(parse("%Y-%W-%w", "2019-52-2", utc, &tp));
  EXPECT_EQ(exp, tp);
}

TEST(Parse, WeekYearShift) {
  // %U/%W conversions with week values in {0, 52, 53} can slip
  // into the previous/following calendar years.
  const time_zone utc = utc_time_zone();
  time_point<absl::time_internal::cctz::seconds> tp;

  auto exp = convert(civil_second(2019, 12, 31, 0, 0, 0), utc);
  EXPECT_TRUE(parse("%Y-%U-%u", "2020-00-2", utc, &tp));
  EXPECT_EQ(exp, tp);
  EXPECT_TRUE(parse("%Y-%W-%w", "2020-00-2", utc, &tp));
  EXPECT_EQ(exp, tp);

  exp = convert(civil_second(2021, 1, 1, 0, 0, 0), utc);
  EXPECT_TRUE(parse("%Y-%U-%u", "2020-52-5", utc, &tp));
  EXPECT_EQ(exp, tp);
  EXPECT_TRUE(parse("%Y-%W-%w", "2020-52-5", utc, &tp));
  EXPECT_EQ(exp, tp);

  // Slipping into the previous/following calendar years should fail when
  // we're already at the extremes.
  EXPECT_FALSE(parse("%Y-%U-%u", "-9223372036854775808-0-7", utc, &tp));
  EXPECT_FALSE(parse("%Y-%U-%u", "9223372036854775807-53-7", utc, &tp));
}

TEST(Parse, MaxRange) {
  const time_zone utc = utc_time_zone();
  time_point<absl::time_internal::cctz::seconds> tp;

  // tests the upper limit using +00:00 offset
  EXPECT_TRUE(
      parse(RFC3339_sec, "292277026596-12-04T15:30:07+00:00", utc, &tp));
  EXPECT_EQ(tp, time_point<absl::time_internal::cctz::seconds>::max());
  EXPECT_FALSE(
      parse(RFC3339_sec, "292277026596-12-04T15:30:08+00:00", utc, &tp));

  // tests the upper limit using -01:00 offset
  EXPECT_TRUE(
      parse(RFC3339_sec, "292277026596-12-04T14:30:07-01:00", utc, &tp));
  EXPECT_EQ(tp, time_point<absl::time_internal::cctz::seconds>::max());
  EXPECT_FALSE(
      parse(RFC3339_sec, "292277026596-12-04T14:30:08-01:00", utc, &tp));

  // tests the lower limit using +00:00 offset
  EXPECT_TRUE(
      parse(RFC3339_sec, "-292277022657-01-27T08:29:52+00:00", utc, &tp));
  EXPECT_EQ(tp, time_point<absl::time_internal::cctz::seconds>::min());
  EXPECT_FALSE(
      parse(RFC3339_sec, "-292277022657-01-27T08:29:51+00:00", utc, &tp));

  // tests the lower limit using +01:00 offset
  EXPECT_TRUE(
      parse(RFC3339_sec, "-292277022657-01-27T09:29:52+01:00", utc, &tp));
  EXPECT_EQ(tp, time_point<absl::time_internal::cctz::seconds>::min());
  EXPECT_FALSE(
      parse(RFC3339_sec, "-292277022657-01-27T08:29:51+01:00", utc, &tp));

  // tests max/min civil-second overflow
  EXPECT_FALSE(
      parse(RFC3339_sec, "9223372036854775807-12-31T23:59:59-00:01", utc, &tp));
  EXPECT_FALSE(parse(RFC3339_sec, "-9223372036854775808-01-01T00:00:00+00:01",
                     utc, &tp));
}

TEST(Parse, TimePointOverflow) {
  const time_zone utc = utc_time_zone();

  using D = chrono::duration<std::int64_t, std::nano>;
  time_point<D> tp;

  EXPECT_TRUE(
      parse(RFC3339_full, "2262-04-11T23:47:16.8547758079+00:00", utc, &tp));
  EXPECT_EQ(tp, time_point<D>::max());
  EXPECT_EQ("2262-04-11T23:47:16.854775807+00:00",
            absl::time_internal::cctz::format(RFC3339_full, tp, utc));
#if 0
  // TODO(#199): Will fail until cctz::parse() properly detects overflow.
  EXPECT_FALSE(
      parse(RFC3339_full, "2262-04-11T23:47:16.8547758080+00:00", utc, &tp));
  EXPECT_TRUE(
      parse(RFC3339_full, "1677-09-21T00:12:43.1452241920+00:00", utc, &tp));
  EXPECT_EQ(tp, time_point<D>::min());
  EXPECT_EQ("1677-09-21T00:12:43.145224192+00:00",
            absl::time_internal::cctz::format(RFC3339_full, tp, utc));
  EXPECT_FALSE(
      parse(RFC3339_full, "1677-09-21T00:12:43.1452241919+00:00", utc, &tp));
#endif

  using DS = chrono::duration<std::int8_t, chrono::seconds::period>;
  time_point<DS> stp;

  EXPECT_TRUE(parse(RFC3339_full, "1970-01-01T00:02:07.9+00:00", utc, &stp));
  EXPECT_EQ(stp, time_point<DS>::max());
  EXPECT_EQ("1970-01-01T00:02:07+00:00",
            absl::time_internal::cctz::format(RFC3339_full, stp, utc));
  EXPECT_FALSE(parse(RFC3339_full, "1970-01-01T00:02:08+00:00", utc, &stp));

  EXPECT_TRUE(parse(RFC3339_full, "1969-12-31T23:57:52+00:00", utc, &stp));
  EXPECT_EQ(stp, time_point<DS>::min());
  EXPECT_EQ("1969-12-31T23:57:52+00:00",
            absl::time_internal::cctz::format(RFC3339_full, stp, utc));
  EXPECT_FALSE(parse(RFC3339_full, "1969-12-31T23:57:51.9+00:00", utc, &stp));

  using DM = chrono::duration<std::int8_t, chrono::minutes::period>;
  time_point<DM> mtp;

  EXPECT_TRUE(parse(RFC3339_full, "1970-01-01T02:07:59+00:00", utc, &mtp));
  EXPECT_EQ(mtp, time_point<DM>::max());
  EXPECT_EQ("1970-01-01T02:07:00+00:00",
            absl::time_internal::cctz::format(RFC3339_full, mtp, utc));
  EXPECT_FALSE(parse(RFC3339_full, "1970-01-01T02:08:00+00:00", utc, &mtp));

  EXPECT_TRUE(parse(RFC3339_full, "1969-12-31T21:52:00+00:00", utc, &mtp));
  EXPECT_EQ(mtp, time_point<DM>::min());
  EXPECT_EQ("1969-12-31T21:52:00+00:00",
            absl::time_internal::cctz::format(RFC3339_full, mtp, utc));
  EXPECT_FALSE(parse(RFC3339_full, "1969-12-31T21:51:59+00:00", utc, &mtp));
}

TEST(Parse, TimePointOverflowFloor) {
  const time_zone utc = utc_time_zone();

  using D = chrono::duration<std::int64_t, std::micro>;
  time_point<D> tp;

  EXPECT_TRUE(
      parse(RFC3339_full, "294247-01-10T04:00:54.7758079+00:00", utc, &tp));
  EXPECT_EQ(tp, time_point<D>::max());
  EXPECT_EQ("294247-01-10T04:00:54.775807+00:00",
            absl::time_internal::cctz::format(RFC3339_full, tp, utc));
#if 0
  // TODO(#199): Will fail until cctz::parse() properly detects overflow.
  EXPECT_FALSE(
      parse(RFC3339_full, "294247-01-10T04:00:54.7758080+00:00", utc, &tp));
  EXPECT_TRUE(
      parse(RFC3339_full, "-290308-12-21T19:59:05.2241920+00:00", utc, &tp));
  EXPECT_EQ(tp, time_point<D>::min());
  EXPECT_EQ("-290308-12-21T19:59:05.224192+00:00",
            absl::time_internal::cctz::format(RFC3339_full, tp, utc));
  EXPECT_FALSE(
      parse(RFC3339_full, "-290308-12-21T19:59:05.2241919+00:00", utc, &tp));
#endif
}

//
// Roundtrip test for format()/parse().
//

TEST(FormatParse, RoundTrip) {
  time_zone lax;
  EXPECT_TRUE(load_time_zone("America/Los_Angeles", &lax));
  const auto in = convert(civil_second(1977, 6, 28, 9, 8, 7), lax);
  const auto subseconds = chrono::nanoseconds(654321);

  // RFC3339, which renders subseconds.
  {
    time_point<chrono::nanoseconds> out;
    const std::string s =
        absl::time_internal::cctz::format(RFC3339_full, in + subseconds, lax);
    EXPECT_TRUE(parse(RFC3339_full, s, lax, &out)) << s;
    EXPECT_EQ(in + subseconds, out);  // RFC3339_full includes %Ez
  }

  // RFC1123, which only does whole seconds.
  {
    time_point<chrono::nanoseconds> out;
    const std::string s =
        absl::time_internal::cctz::format(RFC1123_full, in, lax);
    EXPECT_TRUE(parse(RFC1123_full, s, lax, &out)) << s;
    EXPECT_EQ(in, out);  // RFC1123_full includes %z
  }

#if defined(_WIN32) || defined(_WIN64)
  // Initial investigations indicate the %c does not roundtrip on Windows.
  // TODO: Figure out what is going on here (perhaps a locale problem).
#elif defined(__EMSCRIPTEN__)
  // strftime() and strptime() use different defintions for "%c" under
  // emscripten (see https://github.com/kripken/emscripten/pull/7491),
  // causing its round-trip test to fail.
#else
  // Even though we don't know what %c will produce, it should roundtrip,
  // but only in the 0-offset timezone.
  {
    time_point<chrono::nanoseconds> out;
    time_zone utc = utc_time_zone();
    const std::string s = absl::time_internal::cctz::format("%c", in, utc);
    EXPECT_TRUE(parse("%c", s, utc, &out)) << s;
    EXPECT_EQ(in, out);
  }
#endif
}

TEST(FormatParse, RoundTripDistantFuture) {
  const time_zone utc = utc_time_zone();
  const time_point<absl::time_internal::cctz::seconds> in =
      time_point<absl::time_internal::cctz::seconds>::max();
  const std::string s =
      absl::time_internal::cctz::format(RFC3339_full, in, utc);
  time_point<absl::time_internal::cctz::seconds> out;
  EXPECT_TRUE(parse(RFC3339_full, s, utc, &out)) << s;
  EXPECT_EQ(in, out);
}

TEST(FormatParse, RoundTripDistantPast) {
  const time_zone utc = utc_time_zone();
  const time_point<absl::time_internal::cctz::seconds> in =
      time_point<absl::time_internal::cctz::seconds>::min();
  const std::string s =
      absl::time_internal::cctz::format(RFC3339_full, in, utc);
  time_point<absl::time_internal::cctz::seconds> out;
  EXPECT_TRUE(parse(RFC3339_full, s, utc, &out)) << s;
  EXPECT_EQ(in, out);
}

}  // namespace cctz
}  // namespace time_internal
ABSL_NAMESPACE_END
}  // namespace absl
      node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/src/time_zone_if.cc              0000664 0000000 0000000 00000003102 14746647661 0030614 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

#include "time_zone_if.h"

#include "absl/base/config.h"
#include "time_zone_info.h"
#include "time_zone_libc.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {
namespace cctz {

std::unique_ptr<TimeZoneIf> TimeZoneIf::UTC() { return TimeZoneInfo::UTC(); }

std::unique_ptr<TimeZoneIf> TimeZoneIf::Make(const std::string& name) {
  // Support "libc:localtime" and "libc:*" to access the legacy
  // localtime and UTC support respectively from the C library.
  // NOTE: The "libc:*" zones are internal, test-only interfaces, and
  // are subject to change/removal without notice. Do not use them.
  if (name.compare(0, 5, "libc:") == 0) {
    return TimeZoneLibC::Make(name.substr(5));
  }

  // Otherwise use the "zoneinfo" implementation.
  return TimeZoneInfo::Make(name);
}

// Defined out-of-line to avoid emitting a weak vtable in all TUs.
TimeZoneIf::~TimeZoneIf() {}

}  // namespace cctz
}  // namespace time_internal
ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/src/time_zone_if.h               0000664 0000000 0000000 00000005564 14746647661 0030474 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

#ifndef ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_IF_H_
#define ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_IF_H_

#include <chrono>
#include <cstdint>
#include <memory>
#include <string>

#include "absl/base/config.h"
#include "absl/time/internal/cctz/include/cctz/civil_time.h"
#include "absl/time/internal/cctz/include/cctz/time_zone.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {
namespace cctz {

// A simple interface used to hide time-zone complexities from time_zone::Impl.
// Subclasses implement the functions for civil-time conversions in the zone.
class TimeZoneIf {
 public:
  // Factory functions for TimeZoneIf implementations.
  static std::unique_ptr<TimeZoneIf> UTC();  // never fails
  static std::unique_ptr<TimeZoneIf> Make(const std::string& name);

  virtual ~TimeZoneIf();

  virtual time_zone::absolute_lookup BreakTime(
      const time_point<seconds>& tp) const = 0;
  virtual time_zone::civil_lookup MakeTime(const civil_second& cs) const = 0;

  virtual bool NextTransition(const time_point<seconds>& tp,
                              time_zone::civil_transition* trans) const = 0;
  virtual bool PrevTransition(const time_point<seconds>& tp,
                              time_zone::civil_transition* trans) const = 0;

  virtual std::string Version() const = 0;
  virtual std::string Description() const = 0;

 protected:
  TimeZoneIf() = default;
  TimeZoneIf(const TimeZoneIf&) = delete;
  TimeZoneIf& operator=(const TimeZoneIf&) = delete;
};

// Convert between time_point<seconds> and a count of seconds since the
// Unix epoch.  We assume that the std::chrono::system_clock and the
// Unix clock are second aligned, and that the results are representable.
// (That is, that they share an epoch, which is required since C++20.)
inline std::int_fast64_t ToUnixSeconds(const time_point<seconds>& tp) {
  return (tp - std::chrono::time_point_cast<seconds>(
                   std::chrono::system_clock::from_time_t(0)))
      .count();
}
inline time_point<seconds> FromUnixSeconds(std::int_fast64_t t) {
  return std::chrono::time_point_cast<seconds>(
             std::chrono::system_clock::from_time_t(0)) +
         seconds(t);
}

}  // namespace cctz
}  // namespace time_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_IF_H_
                                                                                                                                            node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/src/time_zone_impl.cc            0000664 0000000 0000000 00000007151 14746647661 0031167 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

#include "time_zone_impl.h"

#include <deque>
#include <memory>
#include <mutex>
#include <string>
#include <unordered_map>
#include <utility>

#include "absl/base/config.h"
#include "time_zone_fixed.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {
namespace cctz {

namespace {

// time_zone::Impls are linked into a map to support fast lookup by name.
using TimeZoneImplByName =
    std::unordered_map<std::string, const time_zone::Impl*>;
TimeZoneImplByName* time_zone_map = nullptr;

// Mutual exclusion for time_zone_map.
std::mutex& TimeZoneMutex() {
  // This mutex is intentionally "leaked" to avoid the static deinitialization
  // order fiasco (std::mutex's destructor is not trivial on many platforms).
  static std::mutex* time_zone_mutex = new std::mutex;
  return *time_zone_mutex;
}

}  // namespace

time_zone time_zone::Impl::UTC() { return time_zone(UTCImpl()); }

bool time_zone::Impl::LoadTimeZone(const std::string& name, time_zone* tz) {
  const Impl* const utc_impl = UTCImpl();

  // Check for UTC (which is never a key in time_zone_map).
  auto offset = seconds::zero();
  if (FixedOffsetFromName(name, &offset) && offset == seconds::zero()) {
    *tz = time_zone(utc_impl);
    return true;
  }

  // Check whether the time zone has already been loaded.
  {
    std::lock_guard<std::mutex> lock(TimeZoneMutex());
    if (time_zone_map != nullptr) {
      TimeZoneImplByName::const_iterator itr = time_zone_map->find(name);
      if (itr != time_zone_map->end()) {
        *tz = time_zone(itr->second);
        return itr->second != utc_impl;
      }
    }
  }

  // Load the new time zone (outside the lock).
  std::unique_ptr<const Impl> new_impl(new Impl(name));

  // Add the new time zone to the map.
  std::lock_guard<std::mutex> lock(TimeZoneMutex());
  if (time_zone_map == nullptr) time_zone_map = new TimeZoneImplByName;
  const Impl*& impl = (*time_zone_map)[name];
  if (impl == nullptr) {  // this thread won any load race
    impl = new_impl->zone_ ? new_impl.release() : utc_impl;
  }
  *tz = time_zone(impl);
  return impl != utc_impl;
}

void time_zone::Impl::ClearTimeZoneMapTestOnly() {
  std::lock_guard<std::mutex> lock(TimeZoneMutex());
  if (time_zone_map != nullptr) {
    // Existing time_zone::Impl* entries are in the wild, so we can't delete
    // them. Instead, we move them to a private container, where they are
    // logically unreachable but not "leaked".  Future requests will result
    // in reloading the data.
    static auto* cleared = new std::deque<const time_zone::Impl*>;
    for (const auto& element : *time_zone_map) {
      cleared->push_back(element.second);
    }
    time_zone_map->clear();
  }
}

time_zone::Impl::Impl() : name_("UTC"), zone_(TimeZoneIf::UTC()) {}

time_zone::Impl::Impl(const std::string& name)
    : name_(name), zone_(TimeZoneIf::Make(name_)) {}

const time_zone::Impl* time_zone::Impl::UTCImpl() {
  static const Impl* utc_impl = new Impl;
  return utc_impl;
}

}  // namespace cctz
}  // namespace time_internal
ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/src/time_zone_impl.h             0000664 0000000 0000000 00000006542 14746647661 0031034 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

#ifndef ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_IMPL_H_
#define ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_IMPL_H_

#include <memory>
#include <string>

#include "absl/base/config.h"
#include "absl/time/internal/cctz/include/cctz/civil_time.h"
#include "absl/time/internal/cctz/include/cctz/time_zone.h"
#include "time_zone_if.h"
#include "time_zone_info.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {
namespace cctz {

// time_zone::Impl is the internal object referenced by a cctz::time_zone.
class time_zone::Impl {
 public:
  // The UTC time zone. Also used for other time zones that fail to load.
  static time_zone UTC();

  // Load a named time zone. Returns false if the name is invalid, or if
  // some other kind of error occurs. Note that loading "UTC" never fails.
  static bool LoadTimeZone(const std::string& name, time_zone* tz);

  // Clears the map of cached time zones.  Primarily for use in benchmarks
  // that gauge the performance of loading/parsing the time-zone data.
  static void ClearTimeZoneMapTestOnly();

  // The primary key is the time-zone ID (e.g., "America/New_York").
  const std::string& Name() const {
    // TODO: It would nice if the zoneinfo data included the zone name.
    return name_;
  }

  // Breaks a time_point down to civil-time components in this time zone.
  time_zone::absolute_lookup BreakTime(const time_point<seconds>& tp) const {
    return zone_->BreakTime(tp);
  }

  // Converts the civil-time components in this time zone into a time_point.
  // That is, the opposite of BreakTime(). The requested civil time may be
  // ambiguous or illegal due to a change of UTC offset.
  time_zone::civil_lookup MakeTime(const civil_second& cs) const {
    return zone_->MakeTime(cs);
  }

  // Finds the time of the next/previous offset change in this time zone.
  bool NextTransition(const time_point<seconds>& tp,
                      time_zone::civil_transition* trans) const {
    return zone_->NextTransition(tp, trans);
  }
  bool PrevTransition(const time_point<seconds>& tp,
                      time_zone::civil_transition* trans) const {
    return zone_->PrevTransition(tp, trans);
  }

  // Returns an implementation-defined version string for this time zone.
  std::string Version() const { return zone_->Version(); }

  // Returns an implementation-defined description of this time zone.
  std::string Description() const { return zone_->Description(); }

 private:
  Impl();
  explicit Impl(const std::string& name);
  Impl(const Impl&) = delete;
  Impl& operator=(const Impl&) = delete;

  static const Impl* UTCImpl();

  const std::string name_;
  std::unique_ptr<TimeZoneIf> zone_;
};

}  // namespace cctz
}  // namespace time_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_IMPL_H_
                                                                                                                                                              node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/src/time_zone_info.cc            0000664 0000000 0000000 00000121216 14746647661 0031160 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

// This file implements the TimeZoneIf interface using the "zoneinfo"
// data provided by the IANA Time Zone Database (i.e., the only real game
// in town).
//
// TimeZoneInfo represents the history of UTC-offset changes within a time
// zone. Most changes are due to daylight-saving rules, but occasionally
// shifts are made to the time-zone's base offset. The database only attempts
// to be definitive for times since 1970, so be wary of local-time conversions
// before that. Also, rule and zone-boundary changes are made at the whim
// of governments, so the conversion of future times needs to be taken with
// a grain of salt.
//
// For more information see tzfile(5), http://www.iana.org/time-zones, or
// https://en.wikipedia.org/wiki/Zoneinfo.
//
// Note that we assume the proleptic Gregorian calendar and 60-second
// minutes throughout.

#include "time_zone_info.h"

#include <algorithm>
#include <cassert>
#include <chrono>
#include <cstdint>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <functional>
#include <memory>
#include <sstream>
#include <string>
#include <utility>
#include <vector>

#include "absl/base/config.h"
#include "absl/time/internal/cctz/include/cctz/civil_time.h"
#include "time_zone_fixed.h"
#include "time_zone_posix.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {
namespace cctz {

namespace {

inline bool IsLeap(year_t year) {
  return (year % 4) == 0 && ((year % 100) != 0 || (year % 400) == 0);
}

// The number of days in non-leap and leap years respectively.
const std::int_least32_t kDaysPerYear[2] = {365, 366};

// The day offsets of the beginning of each (1-based) month in non-leap and
// leap years respectively (e.g., 335 days before December in a leap year).
const std::int_least16_t kMonthOffsets[2][1 + 12 + 1] = {
    {-1, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},
    {-1, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366},
};

// We reject leap-second encoded zoneinfo and so assume 60-second minutes.
const std::int_least32_t kSecsPerDay = 24 * 60 * 60;

// 400-year chunks always have 146097 days (20871 weeks).
const std::int_least64_t kSecsPer400Years = 146097LL * kSecsPerDay;

// Like kDaysPerYear[] but scaled up by a factor of kSecsPerDay.
const std::int_least32_t kSecsPerYear[2] = {
    365 * kSecsPerDay,
    366 * kSecsPerDay,
};

// Convert a cctz::weekday to a POSIX TZ weekday number (0==Sun, ..., 6=Sat).
inline int ToPosixWeekday(weekday wd) {
  switch (wd) {
    case weekday::sunday:
      return 0;
    case weekday::monday:
      return 1;
    case weekday::tuesday:
      return 2;
    case weekday::wednesday:
      return 3;
    case weekday::thursday:
      return 4;
    case weekday::friday:
      return 5;
    case weekday::saturday:
      return 6;
  }
  return 0; /*NOTREACHED*/
}

// Single-byte, unsigned numeric values are encoded directly.
inline std::uint_fast8_t Decode8(const char* cp) {
  return static_cast<std::uint_fast8_t>(*cp) & 0xff;
}

// Multi-byte, numeric values are encoded using a MSB first,
// twos-complement representation. These helpers decode, from
// the given address, 4-byte and 8-byte values respectively.
// Note: If int_fastXX_t == intXX_t and this machine is not
// twos complement, then there will be at least one input value
// we cannot represent.
std::int_fast32_t Decode32(const char* cp) {
  std::uint_fast32_t v = 0;
  for (int i = 0; i != (32 / 8); ++i) v = (v << 8) | Decode8(cp++);
  const std::int_fast32_t s32max = 0x7fffffff;
  const auto s32maxU = static_cast<std::uint_fast32_t>(s32max);
  if (v <= s32maxU) return static_cast<std::int_fast32_t>(v);
  return static_cast<std::int_fast32_t>(v - s32maxU - 1) - s32max - 1;
}

std::int_fast64_t Decode64(const char* cp) {
  std::uint_fast64_t v = 0;
  for (int i = 0; i != (64 / 8); ++i) v = (v << 8) | Decode8(cp++);
  const std::int_fast64_t s64max = 0x7fffffffffffffff;
  const auto s64maxU = static_cast<std::uint_fast64_t>(s64max);
  if (v <= s64maxU) return static_cast<std::int_fast64_t>(v);
  return static_cast<std::int_fast64_t>(v - s64maxU - 1) - s64max - 1;
}

struct Header {            // counts of:
  std::size_t timecnt;     // transition times
  std::size_t typecnt;     // transition types
  std::size_t charcnt;     // zone abbreviation characters
  std::size_t leapcnt;     // leap seconds (we expect none)
  std::size_t ttisstdcnt;  // UTC/local indicators (unused)
  std::size_t ttisutcnt;   // standard/wall indicators (unused)

  bool Build(const tzhead& tzh);
  std::size_t DataLength(std::size_t time_len) const;
};

// Builds the in-memory header using the raw bytes from the file.
bool Header::Build(const tzhead& tzh) {
  std::int_fast32_t v;
  if ((v = Decode32(tzh.tzh_timecnt)) < 0) return false;
  timecnt = static_cast<std::size_t>(v);
  if ((v = Decode32(tzh.tzh_typecnt)) < 0) return false;
  typecnt = static_cast<std::size_t>(v);
  if ((v = Decode32(tzh.tzh_charcnt)) < 0) return false;
  charcnt = static_cast<std::size_t>(v);
  if ((v = Decode32(tzh.tzh_leapcnt)) < 0) return false;
  leapcnt = static_cast<std::size_t>(v);
  if ((v = Decode32(tzh.tzh_ttisstdcnt)) < 0) return false;
  ttisstdcnt = static_cast<std::size_t>(v);
  if ((v = Decode32(tzh.tzh_ttisutcnt)) < 0) return false;
  ttisutcnt = static_cast<std::size_t>(v);
  return true;
}

// How many bytes of data are associated with this header. The result
// depends upon whether this is a section with 4-byte or 8-byte times.
std::size_t Header::DataLength(std::size_t time_len) const {
  std::size_t len = 0;
  len += (time_len + 1) * timecnt;  // unix_time + type_index
  len += (4 + 1 + 1) * typecnt;     // utc_offset + is_dst + abbr_index
  len += 1 * charcnt;               // abbreviations
  len += (time_len + 4) * leapcnt;  // leap-time + TAI-UTC
  len += 1 * ttisstdcnt;            // UTC/local indicators
  len += 1 * ttisutcnt;             // standard/wall indicators
  return len;
}

// Does the rule for future transitions call for year-round daylight time?
// See tz/zic.c:stringzone() for the details on how such rules are encoded.
bool AllYearDST(const PosixTimeZone& posix) {
  if (posix.dst_start.date.fmt != PosixTransition::N) return false;
  if (posix.dst_start.date.n.day != 0) return false;
  if (posix.dst_start.time.offset != 0) return false;

  if (posix.dst_end.date.fmt != PosixTransition::J) return false;
  if (posix.dst_end.date.j.day != kDaysPerYear[0]) return false;
  const auto offset = posix.std_offset - posix.dst_offset;
  if (posix.dst_end.time.offset + offset != kSecsPerDay) return false;

  return true;
}

// Generate a year-relative offset for a PosixTransition.
std::int_fast64_t TransOffset(bool leap_year, int jan1_weekday,
                              const PosixTransition& pt) {
  std::int_fast64_t days = 0;
  switch (pt.date.fmt) {
    case PosixTransition::J: {
      days = pt.date.j.day;
      if (!leap_year || days < kMonthOffsets[1][3]) days -= 1;
      break;
    }
    case PosixTransition::N: {
      days = pt.date.n.day;
      break;
    }
    case PosixTransition::M: {
      const bool last_week = (pt.date.m.week == 5);
      days = kMonthOffsets[leap_year][pt.date.m.month + last_week];
      const std::int_fast64_t weekday = (jan1_weekday + days) % 7;
      if (last_week) {
        days -= (weekday + 7 - 1 - pt.date.m.weekday) % 7 + 1;
      } else {
        days += (pt.date.m.weekday + 7 - weekday) % 7;
        days += (pt.date.m.week - 1) * 7;
      }
      break;
    }
  }
  return (days * kSecsPerDay) + pt.time.offset;
}

inline time_zone::civil_lookup MakeUnique(const time_point<seconds>& tp) {
  time_zone::civil_lookup cl;
  cl.kind = time_zone::civil_lookup::UNIQUE;
  cl.pre = cl.trans = cl.post = tp;
  return cl;
}

inline time_zone::civil_lookup MakeUnique(std::int_fast64_t unix_time) {
  return MakeUnique(FromUnixSeconds(unix_time));
}

inline time_zone::civil_lookup MakeSkipped(const Transition& tr,
                                           const civil_second& cs) {
  time_zone::civil_lookup cl;
  cl.kind = time_zone::civil_lookup::SKIPPED;
  cl.pre = FromUnixSeconds(tr.unix_time - 1 + (cs - tr.prev_civil_sec));
  cl.trans = FromUnixSeconds(tr.unix_time);
  cl.post = FromUnixSeconds(tr.unix_time - (tr.civil_sec - cs));
  return cl;
}

inline time_zone::civil_lookup MakeRepeated(const Transition& tr,
                                            const civil_second& cs) {
  time_zone::civil_lookup cl;
  cl.kind = time_zone::civil_lookup::REPEATED;
  cl.pre = FromUnixSeconds(tr.unix_time - 1 - (tr.prev_civil_sec - cs));
  cl.trans = FromUnixSeconds(tr.unix_time);
  cl.post = FromUnixSeconds(tr.unix_time + (cs - tr.civil_sec));
  return cl;
}

inline civil_second YearShift(const civil_second& cs, year_t shift) {
  return civil_second(cs.year() + shift, cs.month(), cs.day(), cs.hour(),
                      cs.minute(), cs.second());
}

}  // namespace

// Find/make a transition type with these attributes.
bool TimeZoneInfo::GetTransitionType(std::int_fast32_t utc_offset, bool is_dst,
                                     const std::string& abbr,
                                     std::uint_least8_t* index) {
  std::size_t type_index = 0;
  std::size_t abbr_index = abbreviations_.size();
  for (; type_index != transition_types_.size(); ++type_index) {
    const TransitionType& tt(transition_types_[type_index]);
    const char* tt_abbr = &abbreviations_[tt.abbr_index];
    if (tt_abbr == abbr) abbr_index = tt.abbr_index;
    if (tt.utc_offset == utc_offset && tt.is_dst == is_dst) {
      if (abbr_index == tt.abbr_index) break;  // reuse
    }
  }
  if (type_index > 255 || abbr_index > 255) {
    // No index space (8 bits) available for a new type or abbreviation.
    return false;
  }
  if (type_index == transition_types_.size()) {
    TransitionType& tt(*transition_types_.emplace(transition_types_.end()));
    tt.utc_offset = static_cast<std::int_least32_t>(utc_offset);
    tt.is_dst = is_dst;
    if (abbr_index == abbreviations_.size()) {
      abbreviations_.append(abbr);
      abbreviations_.append(1, '\0');
    }
    tt.abbr_index = static_cast<std::uint_least8_t>(abbr_index);
  }
  *index = static_cast<std::uint_least8_t>(type_index);
  return true;
}

// zic(8) can generate no-op transitions when a zone changes rules at an
// instant when there is actually no discontinuity.  So we check whether
// two transitions have equivalent types (same offset/is_dst/abbr).
bool TimeZoneInfo::EquivTransitions(std::uint_fast8_t tt1_index,
                                    std::uint_fast8_t tt2_index) const {
  if (tt1_index == tt2_index) return true;
  const TransitionType& tt1(transition_types_[tt1_index]);
  const TransitionType& tt2(transition_types_[tt2_index]);
  if (tt1.utc_offset != tt2.utc_offset) return false;
  if (tt1.is_dst != tt2.is_dst) return false;
  if (tt1.abbr_index != tt2.abbr_index) return false;
  return true;
}

// Use the POSIX-TZ-environment-variable-style string to handle times
// in years after the last transition stored in the zoneinfo data.
bool TimeZoneInfo::ExtendTransitions() {
  extended_ = false;
  if (future_spec_.empty()) return true;  // last transition prevails

  PosixTimeZone posix;
  if (!ParsePosixSpec(future_spec_, &posix)) return false;

  // Find transition type for the future std specification.
  std::uint_least8_t std_ti;
  if (!GetTransitionType(posix.std_offset, false, posix.std_abbr, &std_ti))
    return false;

  if (posix.dst_abbr.empty()) {  // std only
    // The future specification should match the last transition, and
    // that means that handling the future will fall out naturally.
    return EquivTransitions(transitions_.back().type_index, std_ti);
  }

  // Find transition type for the future dst specification.
  std::uint_least8_t dst_ti;
  if (!GetTransitionType(posix.dst_offset, true, posix.dst_abbr, &dst_ti))
    return false;

  if (AllYearDST(posix)) {  // dst only
    // The future specification should match the last transition, and
    // that means that handling the future will fall out naturally.
    return EquivTransitions(transitions_.back().type_index, dst_ti);
  }

  // Extend the transitions for an additional 401 years using the future
  // specification. Years beyond those can be handled by mapping back to
  // a cycle-equivalent year within that range. Note that we need 401
  // (well, at least the first transition in the 401st year) so that the
  // end of the 400th year is mapped back to an extended year. And first
  // we may also need two additional transitions for the current year.
  transitions_.reserve(transitions_.size() + 2 + 401 * 2);
  extended_ = true;

  const Transition& last(transitions_.back());
  const std::int_fast64_t last_time = last.unix_time;
  const TransitionType& last_tt(transition_types_[last.type_index]);
  last_year_ = LocalTime(last_time, last_tt).cs.year();
  bool leap_year = IsLeap(last_year_);
  const civil_second jan1(last_year_);
  std::int_fast64_t jan1_time = jan1 - civil_second();
  int jan1_weekday = ToPosixWeekday(get_weekday(jan1));

  Transition dst = {0, dst_ti, civil_second(), civil_second()};
  Transition std = {0, std_ti, civil_second(), civil_second()};
  for (const year_t limit = last_year_ + 401;; ++last_year_) {
    auto dst_trans_off = TransOffset(leap_year, jan1_weekday, posix.dst_start);
    auto std_trans_off = TransOffset(leap_year, jan1_weekday, posix.dst_end);
    dst.unix_time = jan1_time + dst_trans_off - posix.std_offset;
    std.unix_time = jan1_time + std_trans_off - posix.dst_offset;
    const auto* ta = dst.unix_time < std.unix_time ? &dst : &std;
    const auto* tb = dst.unix_time < std.unix_time ? &std : &dst;
    if (last_time < tb->unix_time) {
      if (last_time < ta->unix_time) transitions_.push_back(*ta);
      transitions_.push_back(*tb);
    }
    if (last_year_ == limit) break;
    jan1_time += kSecsPerYear[leap_year];
    jan1_weekday = (jan1_weekday + kDaysPerYear[leap_year]) % 7;
    leap_year = !leap_year && IsLeap(last_year_ + 1);
  }

  return true;
}

namespace {

using FilePtr = std::unique_ptr<FILE, int (*)(FILE*)>;

// fopen(3) adaptor.
inline FilePtr FOpen(const char* path, const char* mode) {
#if defined(_MSC_VER)
  FILE* fp;
  if (fopen_s(&fp, path, mode) != 0) fp = nullptr;
  return FilePtr(fp, fclose);
#else
  // TODO: Enable the close-on-exec flag.
  return FilePtr(fopen(path, mode), fclose);
#endif
}

// A stdio(3)-backed implementation of ZoneInfoSource.
class FileZoneInfoSource : public ZoneInfoSource {
 public:
  static std::unique_ptr<ZoneInfoSource> Open(const std::string& name);

  std::size_t Read(void* ptr, std::size_t size) override {
    size = std::min(size, len_);
    std::size_t nread = fread(ptr, 1, size, fp_.get());
    len_ -= nread;
    return nread;
  }
  int Skip(std::size_t offset) override {
    offset = std::min(offset, len_);
    int rc = fseek(fp_.get(), static_cast<long>(offset), SEEK_CUR);
    if (rc == 0) len_ -= offset;
    return rc;
  }
  std::string Version() const override {
    // TODO: It would nice if the zoneinfo data included the tzdb version.
    return std::string();
  }

 protected:
  explicit FileZoneInfoSource(
      FilePtr fp, std::size_t len = std::numeric_limits<std::size_t>::max())
      : fp_(std::move(fp)), len_(len) {}

 private:
  FilePtr fp_;
  std::size_t len_;
};

std::unique_ptr<ZoneInfoSource> FileZoneInfoSource::Open(
    const std::string& name) {
  // Use of the "file:" prefix is intended for testing purposes only.
  const std::size_t pos = (name.compare(0, 5, "file:") == 0) ? 5 : 0;

  // Map the time-zone name to a path name.
  std::string path;
  if (pos == name.size() || name[pos] != '/') {
    const char* tzdir = "/usr/share/zoneinfo";
    char* tzdir_env = nullptr;
#if defined(_MSC_VER)
    _dupenv_s(&tzdir_env, nullptr, "TZDIR");
#else
    tzdir_env = std::getenv("TZDIR");
#endif
    if (tzdir_env && *tzdir_env) tzdir = tzdir_env;
    path += tzdir;
    path += '/';
#if defined(_MSC_VER)
    free(tzdir_env);
#endif
  }
  path.append(name, pos, std::string::npos);

  // Open the zoneinfo file.
  auto fp = FOpen(path.c_str(), "rb");
  if (fp == nullptr) return nullptr;
  return std::unique_ptr<ZoneInfoSource>(new FileZoneInfoSource(std::move(fp)));
}

class AndroidZoneInfoSource : public FileZoneInfoSource {
 public:
  static std::unique_ptr<ZoneInfoSource> Open(const std::string& name);
  std::string Version() const override { return version_; }

 private:
  explicit AndroidZoneInfoSource(FilePtr fp, std::size_t len,
                                 std::string version)
      : FileZoneInfoSource(std::move(fp), len), version_(std::move(version)) {}
  std::string version_;
};

std::unique_ptr<ZoneInfoSource> AndroidZoneInfoSource::Open(
    const std::string& name) {
  // Use of the "file:" prefix is intended for testing purposes only.
  const std::size_t pos = (name.compare(0, 5, "file:") == 0) ? 5 : 0;

  // See Android's libc/tzcode/bionic.cpp for additional information.
  for (const char* tzdata : {"/apex/com.android.tzdata/etc/tz/tzdata",
                             "/data/misc/zoneinfo/current/tzdata",
                             "/system/usr/share/zoneinfo/tzdata"}) {
    auto fp = FOpen(tzdata, "rb");
    if (fp == nullptr) continue;

    char hbuf[24];  // covers header.zonetab_offset too
    if (fread(hbuf, 1, sizeof(hbuf), fp.get()) != sizeof(hbuf)) continue;
    if (strncmp(hbuf, "tzdata", 6) != 0) continue;
    const char* vers = (hbuf[11] == '\0') ? hbuf + 6 : "";
    const std::int_fast32_t index_offset = Decode32(hbuf + 12);
    const std::int_fast32_t data_offset = Decode32(hbuf + 16);
    if (index_offset < 0 || data_offset < index_offset) continue;
    if (fseek(fp.get(), static_cast<long>(index_offset), SEEK_SET) != 0)
      continue;

    char ebuf[52];  // covers entry.unused too
    const std::size_t index_size =
        static_cast<std::size_t>(data_offset - index_offset);
    const std::size_t zonecnt = index_size / sizeof(ebuf);
    if (zonecnt * sizeof(ebuf) != index_size) continue;
    for (std::size_t i = 0; i != zonecnt; ++i) {
      if (fread(ebuf, 1, sizeof(ebuf), fp.get()) != sizeof(ebuf)) break;
      const std::int_fast32_t start = data_offset + Decode32(ebuf + 40);
      const std::int_fast32_t length = Decode32(ebuf + 44);
      if (start < 0 || length < 0) break;
      ebuf[40] = '\0';  // ensure zone name is NUL terminated
      if (strcmp(name.c_str() + pos, ebuf) == 0) {
        if (fseek(fp.get(), static_cast<long>(start), SEEK_SET) != 0) break;
        return std::unique_ptr<ZoneInfoSource>(new AndroidZoneInfoSource(
            std::move(fp), static_cast<std::size_t>(length), vers));
      }
    }
  }

  return nullptr;
}

// A zoneinfo source for use inside Fuchsia components. This attempts to
// read zoneinfo files from one of several known paths in a component's
// incoming namespace. [Config data][1] is preferred, but package-specific
// resources are also supported.
//
// Fuchsia's implementation supports `FileZoneInfoSource::Version()`.
//
// [1]:
// https://fuchsia.dev/fuchsia-src/development/components/data#using_config_data_in_your_component
class FuchsiaZoneInfoSource : public FileZoneInfoSource {
 public:
  static std::unique_ptr<ZoneInfoSource> Open(const std::string& name);
  std::string Version() const override { return version_; }

 private:
  explicit FuchsiaZoneInfoSource(FilePtr fp, std::string version)
      : FileZoneInfoSource(std::move(fp)), version_(std::move(version)) {}
  std::string version_;
};

std::unique_ptr<ZoneInfoSource> FuchsiaZoneInfoSource::Open(
    const std::string& name) {
  // Use of the "file:" prefix is intended for testing purposes only.
  const std::size_t pos = (name.compare(0, 5, "file:") == 0) ? 5 : 0;

  // Prefixes where a Fuchsia component might find zoneinfo files,
  // in descending order of preference.
  const auto kTzdataPrefixes = {
      // The tzdata from `config-data`.
      "/config/data/tzdata/",
      // The tzdata bundled in the component's package.
      "/pkg/data/tzdata/",
      // General data storage.
      "/data/tzdata/",
      // The recommended path for routed-in tzdata files.
      // See for details:
      // https://fuchsia.dev/fuchsia-src/concepts/process/namespaces?hl=en#typical_directory_structure
      "/config/tzdata/",
  };
  const auto kEmptyPrefix = {""};
  const bool name_absolute = (pos != name.size() && name[pos] == '/');
  const auto prefixes = name_absolute ? kEmptyPrefix : kTzdataPrefixes;

  // Fuchsia builds place zoneinfo files at "<prefix><format><name>".
  for (const std::string prefix : prefixes) {
    std::string path = prefix;
    if (!prefix.empty()) path += "zoneinfo/tzif2/";  // format
    path.append(name, pos, std::string::npos);

    auto fp = FOpen(path.c_str(), "rb");
    if (fp == nullptr) continue;

    std::string version;
    if (!prefix.empty()) {
      // Fuchsia builds place the version in "<prefix>revision.txt".
      std::ifstream version_stream(prefix + "revision.txt");
      if (version_stream.is_open()) {
        // revision.txt should contain no newlines, but to be
        // defensive we read just the first line.
        std::getline(version_stream, version);
      }
    }

    return std::unique_ptr<ZoneInfoSource>(
        new FuchsiaZoneInfoSource(std::move(fp), std::move(version)));
  }

  return nullptr;
}

}  // namespace

// What (no leap-seconds) UTC+seconds zoneinfo would look like.
bool TimeZoneInfo::ResetToBuiltinUTC(const seconds& offset) {
  transition_types_.resize(1);
  TransitionType& tt(transition_types_.back());
  tt.utc_offset = static_cast<std::int_least32_t>(offset.count());
  tt.is_dst = false;
  tt.abbr_index = 0;

  // We temporarily add some redundant, contemporary (2015 through 2025)
  // transitions for performance reasons.  See TimeZoneInfo::LocalTime().
  // TODO: Fix the performance issue and remove the extra transitions.
  transitions_.clear();
  transitions_.reserve(12);
  for (const std::int_fast64_t unix_time : {
           -(1LL << 59),  // a "first half" transition
           1420070400LL,  // 2015-01-01T00:00:00+00:00
           1451606400LL,  // 2016-01-01T00:00:00+00:00
           1483228800LL,  // 2017-01-01T00:00:00+00:00
           1514764800LL,  // 2018-01-01T00:00:00+00:00
           1546300800LL,  // 2019-01-01T00:00:00+00:00
           1577836800LL,  // 2020-01-01T00:00:00+00:00
           1609459200LL,  // 2021-01-01T00:00:00+00:00
           1640995200LL,  // 2022-01-01T00:00:00+00:00
           1672531200LL,  // 2023-01-01T00:00:00+00:00
           1704067200LL,  // 2024-01-01T00:00:00+00:00
           1735689600LL,  // 2025-01-01T00:00:00+00:00
       }) {
    Transition& tr(*transitions_.emplace(transitions_.end()));
    tr.unix_time = unix_time;
    tr.type_index = 0;
    tr.civil_sec = LocalTime(tr.unix_time, tt).cs;
    tr.prev_civil_sec = tr.civil_sec - 1;
  }

  default_transition_type_ = 0;
  abbreviations_ = FixedOffsetToAbbr(offset);
  abbreviations_.append(1, '\0');
  future_spec_.clear();  // never needed for a fixed-offset zone
  extended_ = false;

  tt.civil_max = LocalTime(seconds::max().count(), tt).cs;
  tt.civil_min = LocalTime(seconds::min().count(), tt).cs;

  transitions_.shrink_to_fit();
  return true;
}

bool TimeZoneInfo::Load(ZoneInfoSource* zip) {
  // Read and validate the header.
  tzhead tzh;
  if (zip->Read(&tzh, sizeof(tzh)) != sizeof(tzh)) return false;
  if (strncmp(tzh.tzh_magic, TZ_MAGIC, sizeof(tzh.tzh_magic)) != 0)
    return false;
  Header hdr;
  if (!hdr.Build(tzh)) return false;
  std::size_t time_len = 4;
  if (tzh.tzh_version[0] != '\0') {
    // Skip the 4-byte data.
    if (zip->Skip(hdr.DataLength(time_len)) != 0) return false;
    // Read and validate the header for the 8-byte data.
    if (zip->Read(&tzh, sizeof(tzh)) != sizeof(tzh)) return false;
    if (strncmp(tzh.tzh_magic, TZ_MAGIC, sizeof(tzh.tzh_magic)) != 0)
      return false;
    if (tzh.tzh_version[0] == '\0') return false;
    if (!hdr.Build(tzh)) return false;
    time_len = 8;
  }
  if (hdr.typecnt == 0) return false;
  if (hdr.leapcnt != 0) {
    // This code assumes 60-second minutes so we do not want
    // the leap-second encoded zoneinfo. We could reverse the
    // compensation, but the "right" encoding is rarely used
    // so currently we simply reject such data.
    return false;
  }
  if (hdr.ttisstdcnt != 0 && hdr.ttisstdcnt != hdr.typecnt) return false;
  if (hdr.ttisutcnt != 0 && hdr.ttisutcnt != hdr.typecnt) return false;

  // Read the data into a local buffer.
  std::size_t len = hdr.DataLength(time_len);
  std::vector<char> tbuf(len);
  if (zip->Read(tbuf.data(), len) != len) return false;
  const char* bp = tbuf.data();

  // Decode and validate the transitions.
  transitions_.reserve(hdr.timecnt + 2);
  transitions_.resize(hdr.timecnt);
  for (std::size_t i = 0; i != hdr.timecnt; ++i) {
    transitions_[i].unix_time = (time_len == 4) ? Decode32(bp) : Decode64(bp);
    bp += time_len;
    if (i != 0) {
      // Check that the transitions are ordered by time (as zic guarantees).
      if (!Transition::ByUnixTime()(transitions_[i - 1], transitions_[i]))
        return false;  // out of order
    }
  }
  bool seen_type_0 = false;
  for (std::size_t i = 0; i != hdr.timecnt; ++i) {
    transitions_[i].type_index = Decode8(bp++);
    if (transitions_[i].type_index >= hdr.typecnt) return false;
    if (transitions_[i].type_index == 0) seen_type_0 = true;
  }

  // Decode and validate the transition types.
  transition_types_.reserve(hdr.typecnt + 2);
  transition_types_.resize(hdr.typecnt);
  for (std::size_t i = 0; i != hdr.typecnt; ++i) {
    transition_types_[i].utc_offset =
        static_cast<std::int_least32_t>(Decode32(bp));
    if (transition_types_[i].utc_offset >= kSecsPerDay ||
        transition_types_[i].utc_offset <= -kSecsPerDay)
      return false;
    bp += 4;
    transition_types_[i].is_dst = (Decode8(bp++) != 0);
    transition_types_[i].abbr_index = Decode8(bp++);
    if (transition_types_[i].abbr_index >= hdr.charcnt) return false;
  }

  // Determine the before-first-transition type.
  default_transition_type_ = 0;
  if (seen_type_0 && hdr.timecnt != 0) {
    std::uint_fast8_t index = 0;
    if (transition_types_[0].is_dst) {
      index = transitions_[0].type_index;
      while (index != 0 && transition_types_[index].is_dst) --index;
    }
    while (index != hdr.typecnt && transition_types_[index].is_dst) ++index;
    if (index != hdr.typecnt) default_transition_type_ = index;
  }

  // Copy all the abbreviations.
  abbreviations_.reserve(hdr.charcnt + 10);
  abbreviations_.assign(bp, hdr.charcnt);
  bp += hdr.charcnt;

  // Skip the unused portions. We've already dispensed with leap-second
  // encoded zoneinfo. The ttisstd/ttisgmt indicators only apply when
  // interpreting a POSIX spec that does not include start/end rules, and
  // that isn't the case here (see "zic -p").
  bp += (time_len + 4) * hdr.leapcnt;  // leap-time + TAI-UTC
  bp += 1 * hdr.ttisstdcnt;            // UTC/local indicators
  bp += 1 * hdr.ttisutcnt;             // standard/wall indicators
  assert(bp == tbuf.data() + tbuf.size());

  future_spec_.clear();
  if (tzh.tzh_version[0] != '\0') {
    // Snarf up the NL-enclosed future POSIX spec. Note
    // that version '3' files utilize an extended format.
    auto get_char = [](ZoneInfoSource* azip) -> int {
      unsigned char ch;  // all non-EOF results are positive
      return (azip->Read(&ch, 1) == 1) ? ch : EOF;
    };
    if (get_char(zip) != '\n') return false;
    for (int c = get_char(zip); c != '\n'; c = get_char(zip)) {
      if (c == EOF) return false;
      future_spec_.push_back(static_cast<char>(c));
    }
  }

  // We don't check for EOF so that we're forwards compatible.

  // If we did not find version information during the standard loading
  // process (as of tzh_version '3' that is unsupported), then ask the
  // ZoneInfoSource for any out-of-bound version string it may be privy to.
  if (version_.empty()) {
    version_ = zip->Version();
  }

  // Ensure that there is always a transition in the first half of the
  // time line (the second half is handled below) so that the signed
  // difference between a civil_second and the civil_second of its
  // previous transition is always representable, without overflow.
  if (transitions_.empty() || transitions_.front().unix_time >= 0) {
    Transition& tr(*transitions_.emplace(transitions_.begin()));
    tr.unix_time = -(1LL << 59);  // -18267312070-10-26T17:01:52+00:00
    tr.type_index = default_transition_type_;
  }

  // Extend the transitions using the future specification.
  if (!ExtendTransitions()) return false;

  // Ensure that there is always a transition in the second half of the
  // time line (the first half is handled above) so that the signed
  // difference between a civil_second and the civil_second of its
  // previous transition is always representable, without overflow.
  const Transition& last(transitions_.back());
  if (last.unix_time < 0) {
    const std::uint_fast8_t type_index = last.type_index;
    Transition& tr(*transitions_.emplace(transitions_.end()));
    tr.unix_time = 2147483647;  // 2038-01-19T03:14:07+00:00
    tr.type_index = type_index;
  }

  // Compute the local civil time for each transition and the preceding
  // second. These will be used for reverse conversions in MakeTime().
  const TransitionType* ttp = &transition_types_[default_transition_type_];
  for (std::size_t i = 0; i != transitions_.size(); ++i) {
    Transition& tr(transitions_[i]);
    tr.prev_civil_sec = LocalTime(tr.unix_time, *ttp).cs - 1;
    ttp = &transition_types_[tr.type_index];
    tr.civil_sec = LocalTime(tr.unix_time, *ttp).cs;
    if (i != 0) {
      // Check that the transitions are ordered by civil time. Essentially
      // this means that an offset change cannot cross another such change.
      // No one does this in practice, and we depend on it in MakeTime().
      if (!Transition::ByCivilTime()(transitions_[i - 1], tr))
        return false;  // out of order
    }
  }

  // Compute the maximum/minimum civil times that can be converted to a
  // time_point<seconds> for each of the zone's transition types.
  for (auto& tt : transition_types_) {
    tt.civil_max = LocalTime(seconds::max().count(), tt).cs;
    tt.civil_min = LocalTime(seconds::min().count(), tt).cs;
  }

  transitions_.shrink_to_fit();
  return true;
}

bool TimeZoneInfo::Load(const std::string& name) {
  // We can ensure that the loading of UTC or any other fixed-offset
  // zone never fails because the simple, fixed-offset state can be
  // internally generated. Note that this depends on our choice to not
  // accept leap-second encoded ("right") zoneinfo.
  auto offset = seconds::zero();
  if (FixedOffsetFromName(name, &offset)) {
    return ResetToBuiltinUTC(offset);
  }

  // Find and use a ZoneInfoSource to load the named zone.
  auto zip = cctz_extension::zone_info_source_factory(
      name, [](const std::string& n) -> std::unique_ptr<ZoneInfoSource> {
        if (auto z = FileZoneInfoSource::Open(n)) return z;
        if (auto z = AndroidZoneInfoSource::Open(n)) return z;
        if (auto z = FuchsiaZoneInfoSource::Open(n)) return z;
        return nullptr;
      });
  return zip != nullptr && Load(zip.get());
}

std::unique_ptr<TimeZoneInfo> TimeZoneInfo::UTC() {
  auto tz = std::unique_ptr<TimeZoneInfo>(new TimeZoneInfo);
  tz->ResetToBuiltinUTC(seconds::zero());
  return tz;
}

std::unique_ptr<TimeZoneInfo> TimeZoneInfo::Make(const std::string& name) {
  auto tz = std::unique_ptr<TimeZoneInfo>(new TimeZoneInfo);
  if (!tz->Load(name)) tz.reset();  // fallback to UTC
  return tz;
}

// BreakTime() translation for a particular transition type.
time_zone::absolute_lookup TimeZoneInfo::LocalTime(
    std::int_fast64_t unix_time, const TransitionType& tt) const {
  // A civil time in "+offset" looks like (time+offset) in UTC.
  // Note: We perform two additions in the civil_second domain to
  // sidestep the chance of overflow in (unix_time + tt.utc_offset).
  return {(civil_second() + unix_time) + tt.utc_offset, tt.utc_offset,
          tt.is_dst, &abbreviations_[tt.abbr_index]};
}

// BreakTime() translation for a particular transition.
time_zone::absolute_lookup TimeZoneInfo::LocalTime(std::int_fast64_t unix_time,
                                                   const Transition& tr) const {
  const TransitionType& tt = transition_types_[tr.type_index];
  // Note: (unix_time - tr.unix_time) will never overflow as we
  // have ensured that there is always a "nearby" transition.
  return {tr.civil_sec + (unix_time - tr.unix_time),  // TODO: Optimize.
          tt.utc_offset, tt.is_dst, &abbreviations_[tt.abbr_index]};
}

// MakeTime() translation with a conversion-preserving +N * 400-year shift.
time_zone::civil_lookup TimeZoneInfo::TimeLocal(const civil_second& cs,
                                                year_t c4_shift) const {
  assert(last_year_ - 400 < cs.year() && cs.year() <= last_year_);
  time_zone::civil_lookup cl = MakeTime(cs);
  if (c4_shift > seconds::max().count() / kSecsPer400Years) {
    cl.pre = cl.trans = cl.post = time_point<seconds>::max();
  } else {
    const auto offset = seconds(c4_shift * kSecsPer400Years);
    const auto limit = time_point<seconds>::max() - offset;
    for (auto* tp : {&cl.pre, &cl.trans, &cl.post}) {
      if (*tp > limit) {
        *tp = time_point<seconds>::max();
      } else {
        *tp += offset;
      }
    }
  }
  return cl;
}

time_zone::absolute_lookup TimeZoneInfo::BreakTime(
    const time_point<seconds>& tp) const {
  std::int_fast64_t unix_time = ToUnixSeconds(tp);
  const std::size_t timecnt = transitions_.size();
  assert(timecnt != 0);  // We always add a transition.

  if (unix_time < transitions_[0].unix_time) {
    return LocalTime(unix_time, transition_types_[default_transition_type_]);
  }
  if (unix_time >= transitions_[timecnt - 1].unix_time) {
    // After the last transition. If we extended the transitions using
    // future_spec_, shift back to a supported year using the 400-year
    // cycle of calendaric equivalence and then compensate accordingly.
    if (extended_) {
      const std::int_fast64_t diff =
          unix_time - transitions_[timecnt - 1].unix_time;
      const year_t shift = diff / kSecsPer400Years + 1;
      const auto d = seconds(shift * kSecsPer400Years);
      time_zone::absolute_lookup al = BreakTime(tp - d);
      al.cs = YearShift(al.cs, shift * 400);
      return al;
    }
    return LocalTime(unix_time, transitions_[timecnt - 1]);
  }

  const std::size_t hint = local_time_hint_.load(std::memory_order_relaxed);
  if (0 < hint && hint < timecnt) {
    if (transitions_[hint - 1].unix_time <= unix_time) {
      if (unix_time < transitions_[hint].unix_time) {
        return LocalTime(unix_time, transitions_[hint - 1]);
      }
    }
  }

  const Transition target = {unix_time, 0, civil_second(), civil_second()};
  const Transition* begin = &transitions_[0];
  const Transition* tr = std::upper_bound(begin, begin + timecnt, target,
                                          Transition::ByUnixTime());
  local_time_hint_.store(static_cast<std::size_t>(tr - begin),
                         std::memory_order_relaxed);
  return LocalTime(unix_time, *--tr);
}

time_zone::civil_lookup TimeZoneInfo::MakeTime(const civil_second& cs) const {
  const std::size_t timecnt = transitions_.size();
  assert(timecnt != 0);  // We always add a transition.

  // Find the first transition after our target civil time.
  const Transition* tr = nullptr;
  const Transition* begin = &transitions_[0];
  const Transition* end = begin + timecnt;
  if (cs < begin->civil_sec) {
    tr = begin;
  } else if (cs >= transitions_[timecnt - 1].civil_sec) {
    tr = end;
  } else {
    const std::size_t hint = time_local_hint_.load(std::memory_order_relaxed);
    if (0 < hint && hint < timecnt) {
      if (transitions_[hint - 1].civil_sec <= cs) {
        if (cs < transitions_[hint].civil_sec) {
          tr = begin + hint;
        }
      }
    }
    if (tr == nullptr) {
      const Transition target = {0, 0, cs, civil_second()};
      tr = std::upper_bound(begin, end, target, Transition::ByCivilTime());
      time_local_hint_.store(static_cast<std::size_t>(tr - begin),
                             std::memory_order_relaxed);
    }
  }

  if (tr == begin) {
    if (tr->prev_civil_sec >= cs) {
      // Before first transition, so use the default offset.
      const TransitionType& tt(transition_types_[default_transition_type_]);
      if (cs < tt.civil_min) return MakeUnique(time_point<seconds>::min());
      return MakeUnique(cs - (civil_second() + tt.utc_offset));
    }
    // tr->prev_civil_sec < cs < tr->civil_sec
    return MakeSkipped(*tr, cs);
  }

  if (tr == end) {
    if (cs > (--tr)->prev_civil_sec) {
      // After the last transition. If we extended the transitions using
      // future_spec_, shift back to a supported year using the 400-year
      // cycle of calendaric equivalence and then compensate accordingly.
      if (extended_ && cs.year() > last_year_) {
        const year_t shift = (cs.year() - last_year_ - 1) / 400 + 1;
        return TimeLocal(YearShift(cs, shift * -400), shift);
      }
      const TransitionType& tt(transition_types_[tr->type_index]);
      if (cs > tt.civil_max) return MakeUnique(time_point<seconds>::max());
      return MakeUnique(tr->unix_time + (cs - tr->civil_sec));
    }
    // tr->civil_sec <= cs <= tr->prev_civil_sec
    return MakeRepeated(*tr, cs);
  }

  if (tr->prev_civil_sec < cs) {
    // tr->prev_civil_sec < cs < tr->civil_sec
    return MakeSkipped(*tr, cs);
  }

  if (cs <= (--tr)->prev_civil_sec) {
    // tr->civil_sec <= cs <= tr->prev_civil_sec
    return MakeRepeated(*tr, cs);
  }

  // In between transitions.
  return MakeUnique(tr->unix_time + (cs - tr->civil_sec));
}

std::string TimeZoneInfo::Version() const { return version_; }

std::string TimeZoneInfo::Description() const {
  std::ostringstream oss;
  oss << "#trans=" << transitions_.size();
  oss << " #types=" << transition_types_.size();
  oss << " spec='" << future_spec_ << "'";
  return oss.str();
}

bool TimeZoneInfo::NextTransition(const time_point<seconds>& tp,
                                  time_zone::civil_transition* trans) const {
  if (transitions_.empty()) return false;
  const Transition* begin = &transitions_[0];
  const Transition* end = begin + transitions_.size();
  if (begin->unix_time <= -(1LL << 59)) {
    // Do not report the BIG_BANG found in some zoneinfo data as it is
    // really a sentinel, not a transition.  See pre-2018f tz/zic.c.
    ++begin;
  }
  std::int_fast64_t unix_time = ToUnixSeconds(tp);
  const Transition target = {unix_time, 0, civil_second(), civil_second()};
  const Transition* tr =
      std::upper_bound(begin, end, target, Transition::ByUnixTime());
  for (; tr != end; ++tr) {  // skip no-op transitions
    std::uint_fast8_t prev_type_index =
        (tr == begin) ? default_transition_type_ : tr[-1].type_index;
    if (!EquivTransitions(prev_type_index, tr[0].type_index)) break;
  }
  // When tr == end we return false, ignoring future_spec_.
  if (tr == end) return false;
  trans->from = tr->prev_civil_sec + 1;
  trans->to = tr->civil_sec;
  return true;
}

bool TimeZoneInfo::PrevTransition(const time_point<seconds>& tp,
                                  time_zone::civil_transition* trans) const {
  if (transitions_.empty()) return false;
  const Transition* begin = &transitions_[0];
  const Transition* end = begin + transitions_.size();
  if (begin->unix_time <= -(1LL << 59)) {
    // Do not report the BIG_BANG found in some zoneinfo data as it is
    // really a sentinel, not a transition.  See pre-2018f tz/zic.c.
    ++begin;
  }
  std::int_fast64_t unix_time = ToUnixSeconds(tp);
  if (FromUnixSeconds(unix_time) != tp) {
    if (unix_time == std::numeric_limits<std::int_fast64_t>::max()) {
      if (end == begin) return false;  // Ignore future_spec_.
      trans->from = (--end)->prev_civil_sec + 1;
      trans->to = end->civil_sec;
      return true;
    }
    unix_time += 1;  // ceils
  }
  const Transition target = {unix_time, 0, civil_second(), civil_second()};
  const Transition* tr =
      std::lower_bound(begin, end, target, Transition::ByUnixTime());
  for (; tr != begin; --tr) {  // skip no-op transitions
    std::uint_fast8_t prev_type_index =
        (tr - 1 == begin) ? default_transition_type_ : tr[-2].type_index;
    if (!EquivTransitions(prev_type_index, tr[-1].type_index)) break;
  }
  // When tr == end we return the "last" transition, ignoring future_spec_.
  if (tr == begin) return false;
  trans->from = (--tr)->prev_civil_sec + 1;
  trans->to = tr->civil_sec;
  return true;
}

}  // namespace cctz
}  // namespace time_internal
ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/src/time_zone_info.h             0000664 0000000 0000000 00000012030 14746647661 0031013 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

#ifndef ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_INFO_H_
#define ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_INFO_H_

#include <atomic>
#include <cstddef>
#include <cstdint>
#include <memory>
#include <string>
#include <vector>

#include "absl/base/config.h"
#include "absl/time/internal/cctz/include/cctz/civil_time.h"
#include "absl/time/internal/cctz/include/cctz/time_zone.h"
#include "absl/time/internal/cctz/include/cctz/zone_info_source.h"
#include "time_zone_if.h"
#include "tzfile.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {
namespace cctz {

// A transition to a new UTC offset.
struct Transition {
  std::int_least64_t unix_time;   // the instant of this transition
  std::uint_least8_t type_index;  // index of the transition type
  civil_second civil_sec;         // local civil time of transition
  civil_second prev_civil_sec;    // local civil time one second earlier

  struct ByUnixTime {
    inline bool operator()(const Transition& lhs, const Transition& rhs) const {
      return lhs.unix_time < rhs.unix_time;
    }
  };
  struct ByCivilTime {
    inline bool operator()(const Transition& lhs, const Transition& rhs) const {
      return lhs.civil_sec < rhs.civil_sec;
    }
  };
};

// The characteristics of a particular transition.
struct TransitionType {
  std::int_least32_t utc_offset;  // the new prevailing UTC offset
  civil_second civil_max;         // max convertible civil time for offset
  civil_second civil_min;         // min convertible civil time for offset
  bool is_dst;                    // did we move into daylight-saving time
  std::uint_least8_t abbr_index;  // index of the new abbreviation
};

// A time zone backed by the IANA Time Zone Database (zoneinfo).
class TimeZoneInfo : public TimeZoneIf {
 public:
  // Factories.
  static std::unique_ptr<TimeZoneInfo> UTC();  // never fails
  static std::unique_ptr<TimeZoneInfo> Make(const std::string& name);

  // TimeZoneIf implementations.
  time_zone::absolute_lookup BreakTime(
      const time_point<seconds>& tp) const override;
  time_zone::civil_lookup MakeTime(const civil_second& cs) const override;
  bool NextTransition(const time_point<seconds>& tp,
                      time_zone::civil_transition* trans) const override;
  bool PrevTransition(const time_point<seconds>& tp,
                      time_zone::civil_transition* trans) const override;
  std::string Version() const override;
  std::string Description() const override;

 private:
  TimeZoneInfo() = default;
  TimeZoneInfo(const TimeZoneInfo&) = delete;
  TimeZoneInfo& operator=(const TimeZoneInfo&) = delete;

  bool GetTransitionType(std::int_fast32_t utc_offset, bool is_dst,
                         const std::string& abbr, std::uint_least8_t* index);
  bool EquivTransitions(std::uint_fast8_t tt1_index,
                        std::uint_fast8_t tt2_index) const;
  bool ExtendTransitions();

  bool ResetToBuiltinUTC(const seconds& offset);
  bool Load(const std::string& name);
  bool Load(ZoneInfoSource* zip);

  // Helpers for BreakTime() and MakeTime().
  time_zone::absolute_lookup LocalTime(std::int_fast64_t unix_time,
                                       const TransitionType& tt) const;
  time_zone::absolute_lookup LocalTime(std::int_fast64_t unix_time,
                                       const Transition& tr) const;
  time_zone::civil_lookup TimeLocal(const civil_second& cs,
                                    year_t c4_shift) const;

  std::vector<Transition> transitions_;  // ordered by unix_time and civil_sec
  std::vector<TransitionType> transition_types_;  // distinct transition types
  std::uint_fast8_t default_transition_type_;     // for before first transition
  std::string abbreviations_;  // all the NUL-terminated abbreviations

  std::string version_;      // the tzdata version if available
  std::string future_spec_;  // for after the last zic transition
  bool extended_;            // future_spec_ was used to generate transitions
  year_t last_year_;         // the final year of the generated transitions

  // We remember the transitions found during the last BreakTime() and
  // MakeTime() calls. If the next request is for the same transition we
  // will avoid re-searching.
  mutable std::atomic<std::size_t> local_time_hint_ = {};  // BreakTime() hint
  mutable std::atomic<std::size_t> time_local_hint_ = {};  // MakeTime() hint
};

}  // namespace cctz
}  // namespace time_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_INFO_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/src/time_zone_libc.cc            0000664 0000000 0000000 00000025406 14746647661 0031142 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

#if !defined(_CRT_SECURE_NO_WARNINGS) && defined(_WIN32)
#define _CRT_SECURE_NO_WARNINGS 1
#endif

#include "time_zone_libc.h"

#include <chrono>
#include <ctime>
#include <limits>
#include <utility>

#include "absl/base/config.h"
#include "absl/time/internal/cctz/include/cctz/civil_time.h"
#include "absl/time/internal/cctz/include/cctz/time_zone.h"

#if defined(_AIX)
extern "C" {
extern long altzone;
}
#endif

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {
namespace cctz {

namespace {

#if defined(_WIN32) || defined(_WIN64)
// Uses the globals: '_timezone', '_dstbias' and '_tzname'.
auto tm_gmtoff(const std::tm& tm) -> decltype(_timezone + _dstbias) {
  const bool is_dst = tm.tm_isdst > 0;
  return _timezone + (is_dst ? _dstbias : 0);
}
auto tm_zone(const std::tm& tm) -> decltype(_tzname[0]) {
  const bool is_dst = tm.tm_isdst > 0;
  return _tzname[is_dst];
}
#elif defined(__sun) || defined(_AIX)
// Uses the globals: 'timezone', 'altzone' and 'tzname'.
auto tm_gmtoff(const std::tm& tm) -> decltype(timezone) {
  const bool is_dst = tm.tm_isdst > 0;
  return is_dst ? altzone : timezone;
}
auto tm_zone(const std::tm& tm) -> decltype(tzname[0]) {
  const bool is_dst = tm.tm_isdst > 0;
  return tzname[is_dst];
}
#elif defined(__native_client__) || defined(__myriad2__) || \
    defined(__EMSCRIPTEN__)
// Uses the globals: '_timezone' and 'tzname'.
auto tm_gmtoff(const std::tm& tm) -> decltype(_timezone + 0) {
  const bool is_dst = tm.tm_isdst > 0;
  return _timezone + (is_dst ? 60 * 60 : 0);
}
auto tm_zone(const std::tm& tm) -> decltype(tzname[0]) {
  const bool is_dst = tm.tm_isdst > 0;
  return tzname[is_dst];
}
#elif defined(__VXWORKS__)
// Uses the globals: 'timezone' and 'tzname'.
auto tm_gmtoff(const std::tm& tm) -> decltype(timezone + 0) {
  const bool is_dst = tm.tm_isdst > 0;
  return timezone + (is_dst ? 60 * 60 : 0);
}
auto tm_zone(const std::tm& tm) -> decltype(tzname[0]) {
  const bool is_dst = tm.tm_isdst > 0;
  return tzname[is_dst];
}
#else
// Adapt to different spellings of the struct std::tm extension fields.
#if defined(tm_gmtoff)
auto tm_gmtoff(const std::tm& tm) -> decltype(tm.tm_gmtoff) {
  return tm.tm_gmtoff;
}
#elif defined(__tm_gmtoff)
auto tm_gmtoff(const std::tm& tm) -> decltype(tm.__tm_gmtoff) {
  return tm.__tm_gmtoff;
}
#else
template <typename T>
auto tm_gmtoff(const T& tm) -> decltype(tm.tm_gmtoff) {
  return tm.tm_gmtoff;
}
template <typename T>
auto tm_gmtoff(const T& tm) -> decltype(tm.__tm_gmtoff) {
  return tm.__tm_gmtoff;
}
#endif  // tm_gmtoff
#if defined(tm_zone)
auto tm_zone(const std::tm& tm) -> decltype(tm.tm_zone) { return tm.tm_zone; }
#elif defined(__tm_zone)
auto tm_zone(const std::tm& tm) -> decltype(tm.__tm_zone) {
  return tm.__tm_zone;
}
#else
template <typename T>
auto tm_zone(const T& tm) -> decltype(tm.tm_zone) {
  return tm.tm_zone;
}
template <typename T>
auto tm_zone(const T& tm) -> decltype(tm.__tm_zone) {
  return tm.__tm_zone;
}
#endif  // tm_zone
#endif
using tm_gmtoff_t = decltype(tm_gmtoff(std::tm{}));

inline std::tm* gm_time(const std::time_t* timep, std::tm* result) {
#if defined(_WIN32) || defined(_WIN64)
  return gmtime_s(result, timep) ? nullptr : result;
#else
  return gmtime_r(timep, result);
#endif
}

inline std::tm* local_time(const std::time_t* timep, std::tm* result) {
#if defined(_WIN32) || defined(_WIN64)
  return localtime_s(result, timep) ? nullptr : result;
#else
  return localtime_r(timep, result);
#endif
}

// Converts a civil second and "dst" flag into a time_t and a struct tm.
// Returns false if time_t cannot represent the requested civil second.
// Caller must have already checked that cs.year() will fit into a tm_year.
bool make_time(const civil_second& cs, int is_dst, std::time_t* t,
               std::tm* tm) {
  tm->tm_year = static_cast<int>(cs.year() - year_t{1900});
  tm->tm_mon = cs.month() - 1;
  tm->tm_mday = cs.day();
  tm->tm_hour = cs.hour();
  tm->tm_min = cs.minute();
  tm->tm_sec = cs.second();
  tm->tm_isdst = is_dst;
  *t = std::mktime(tm);
  if (*t == std::time_t{-1}) {
    std::tm tm2;
    const std::tm* tmp = local_time(t, &tm2);
    if (tmp == nullptr || tmp->tm_year != tm->tm_year ||
        tmp->tm_mon != tm->tm_mon || tmp->tm_mday != tm->tm_mday ||
        tmp->tm_hour != tm->tm_hour || tmp->tm_min != tm->tm_min ||
        tmp->tm_sec != tm->tm_sec) {
      // A true error (not just one second before the epoch).
      return false;
    }
  }
  return true;
}

// Find the least time_t in [lo:hi] where local time matches offset, given:
// (1) lo doesn't match, (2) hi does, and (3) there is only one transition.
std::time_t find_trans(std::time_t lo, std::time_t hi, tm_gmtoff_t offset) {
  std::tm tm;
  while (lo + 1 != hi) {
    const std::time_t mid = lo + (hi - lo) / 2;
    std::tm* tmp = local_time(&mid, &tm);
    if (tmp != nullptr) {
      if (tm_gmtoff(*tmp) == offset) {
        hi = mid;
      } else {
        lo = mid;
      }
    } else {
      // If std::tm cannot hold some result we resort to a linear search,
      // ignoring all failed conversions.  Slow, but never really happens.
      while (++lo != hi) {
        tmp = local_time(&lo, &tm);
        if (tmp != nullptr) {
          if (tm_gmtoff(*tmp) == offset) break;
        }
      }
      return lo;
    }
  }
  return hi;
}

}  // namespace

std::unique_ptr<TimeZoneLibC> TimeZoneLibC::Make(const std::string& name) {
  return std::unique_ptr<TimeZoneLibC>(new TimeZoneLibC(name));
}

time_zone::absolute_lookup TimeZoneLibC::BreakTime(
    const time_point<seconds>& tp) const {
  time_zone::absolute_lookup al;
  al.offset = 0;
  al.is_dst = false;
  al.abbr = "-00";

  const std::int_fast64_t s = ToUnixSeconds(tp);

  // If std::time_t cannot hold the input we saturate the output.
  if (s < std::numeric_limits<std::time_t>::min()) {
    al.cs = civil_second::min();
    return al;
  }
  if (s > std::numeric_limits<std::time_t>::max()) {
    al.cs = civil_second::max();
    return al;
  }

  const std::time_t t = static_cast<std::time_t>(s);
  std::tm tm;
  std::tm* tmp = local_ ? local_time(&t, &tm) : gm_time(&t, &tm);

  // If std::tm cannot hold the result we saturate the output.
  if (tmp == nullptr) {
    al.cs = (s < 0) ? civil_second::min() : civil_second::max();
    return al;
  }

  const year_t year = tmp->tm_year + year_t{1900};
  al.cs = civil_second(year, tmp->tm_mon + 1, tmp->tm_mday, tmp->tm_hour,
                       tmp->tm_min, tmp->tm_sec);
  al.offset = static_cast<int>(tm_gmtoff(*tmp));
  al.abbr = local_ ? tm_zone(*tmp) : "UTC";  // as expected by cctz
  al.is_dst = tmp->tm_isdst > 0;
  return al;
}

time_zone::civil_lookup TimeZoneLibC::MakeTime(const civil_second& cs) const {
  if (!local_) {
    // If time_point<seconds> cannot hold the result we saturate.
    static const civil_second min_tp_cs =
        civil_second() + ToUnixSeconds(time_point<seconds>::min());
    static const civil_second max_tp_cs =
        civil_second() + ToUnixSeconds(time_point<seconds>::max());
    const time_point<seconds> tp = (cs < min_tp_cs) ? time_point<seconds>::min()
                                   : (cs > max_tp_cs)
                                       ? time_point<seconds>::max()
                                       : FromUnixSeconds(cs - civil_second());
    return {time_zone::civil_lookup::UNIQUE, tp, tp, tp};
  }

  // If tm_year cannot hold the requested year we saturate the result.
  if (cs.year() < 0) {
    if (cs.year() < std::numeric_limits<int>::min() + year_t{1900}) {
      const time_point<seconds> tp = time_point<seconds>::min();
      return {time_zone::civil_lookup::UNIQUE, tp, tp, tp};
    }
  } else {
    if (cs.year() - year_t{1900} > std::numeric_limits<int>::max()) {
      const time_point<seconds> tp = time_point<seconds>::max();
      return {time_zone::civil_lookup::UNIQUE, tp, tp, tp};
    }
  }

  // We probe with "is_dst" values of 0 and 1 to try to distinguish unique
  // civil seconds from skipped or repeated ones.  This is not always possible
  // however, as the "dst" flag does not change over some offset transitions.
  // We are also subject to the vagaries of mktime() implementations. For
  // example, some implementations treat "tm_isdst" as a demand (useless),
  // and some as a disambiguator (useful).
  std::time_t t0, t1;
  std::tm tm0, tm1;
  if (make_time(cs, 0, &t0, &tm0) && make_time(cs, 1, &t1, &tm1)) {
    if (tm0.tm_isdst == tm1.tm_isdst) {
      // The civil time was singular (pre == trans == post).
      const time_point<seconds> tp = FromUnixSeconds(tm0.tm_isdst ? t1 : t0);
      return {time_zone::civil_lookup::UNIQUE, tp, tp, tp};
    }

    tm_gmtoff_t offset = tm_gmtoff(tm0);
    if (t0 < t1) {  // negative DST
      std::swap(t0, t1);
      offset = tm_gmtoff(tm1);
    }

    const std::time_t tt = find_trans(t1, t0, offset);
    const time_point<seconds> trans = FromUnixSeconds(tt);

    if (tm0.tm_isdst) {
      // The civil time did not exist (pre >= trans > post).
      const time_point<seconds> pre = FromUnixSeconds(t0);
      const time_point<seconds> post = FromUnixSeconds(t1);
      return {time_zone::civil_lookup::SKIPPED, pre, trans, post};
    }

    // The civil time was ambiguous (pre < trans <= post).
    const time_point<seconds> pre = FromUnixSeconds(t1);
    const time_point<seconds> post = FromUnixSeconds(t0);
    return {time_zone::civil_lookup::REPEATED, pre, trans, post};
  }

  // make_time() failed somehow so we saturate the result.
  const time_point<seconds> tp = (cs < civil_second())
                                     ? time_point<seconds>::min()
                                     : time_point<seconds>::max();
  return {time_zone::civil_lookup::UNIQUE, tp, tp, tp};
}

bool TimeZoneLibC::NextTransition(const time_point<seconds>&,
                                  time_zone::civil_transition*) const {
  return false;
}

bool TimeZoneLibC::PrevTransition(const time_point<seconds>&,
                                  time_zone::civil_transition*) const {
  return false;
}

std::string TimeZoneLibC::Version() const {
  return std::string();  // unknown
}

std::string TimeZoneLibC::Description() const {
  return local_ ? "localtime" : "UTC";
}

TimeZoneLibC::TimeZoneLibC(const std::string& name)
    : local_(name == "localtime") {}

}  // namespace cctz
}  // namespace time_internal
ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/src/time_zone_libc.h             0000664 0000000 0000000 00000004015 14746647661 0030775 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

#ifndef ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_LIBC_H_
#define ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_LIBC_H_

#include <memory>
#include <string>

#include "absl/base/config.h"
#include "time_zone_if.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {
namespace cctz {

// A time zone backed by gmtime_r(3), localtime_r(3), and mktime(3),
// and which therefore only supports UTC and the local time zone.
class TimeZoneLibC : public TimeZoneIf {
 public:
  // Factory.
  static std::unique_ptr<TimeZoneLibC> Make(const std::string& name);

  // TimeZoneIf implementations.
  time_zone::absolute_lookup BreakTime(
      const time_point<seconds>& tp) const override;
  time_zone::civil_lookup MakeTime(const civil_second& cs) const override;
  bool NextTransition(const time_point<seconds>& tp,
                      time_zone::civil_transition* trans) const override;
  bool PrevTransition(const time_point<seconds>& tp,
                      time_zone::civil_transition* trans) const override;
  std::string Version() const override;
  std::string Description() const override;

 private:
  explicit TimeZoneLibC(const std::string& name);
  TimeZoneLibC(const TimeZoneLibC&) = delete;
  TimeZoneLibC& operator=(const TimeZoneLibC&) = delete;

  const bool local_;  // localtime or UTC
};

}  // namespace cctz
}  // namespace time_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_LIBC_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/src/time_zone_lookup.cc          0000664 0000000 0000000 00000024775 14746647661 0031552 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

#include "absl/base/config.h"
#include "absl/time/internal/cctz/include/cctz/time_zone.h"

#if defined(__ANDROID__)
#include <sys/system_properties.h>
#endif

#if defined(__APPLE__)
#include <CoreFoundation/CFTimeZone.h>

#include <vector>
#endif

#if defined(__Fuchsia__)
#include <fuchsia/intl/cpp/fidl.h>
#include <lib/async-loop/cpp/loop.h>
#include <lib/fdio/directory.h>
#include <zircon/types.h>
#endif

#if defined(_WIN32)
#include <sdkddkver.h>
// Include only when the SDK is for Windows 10 (and later), and the binary is
// targeted for Windows XP and later.
// Note: The Windows SDK added windows.globalization.h file for Windows 10, but
// MinGW did not add it until NTDDI_WIN10_NI (SDK version 10.0.22621.0).
#if ((defined(_WIN32_WINNT_WIN10) && !defined(__MINGW32__)) ||        \
     (defined(NTDDI_WIN10_NI) && NTDDI_VERSION >= NTDDI_WIN10_NI)) && \
    (_WIN32_WINNT >= _WIN32_WINNT_WINXP)
#define USE_WIN32_LOCAL_TIME_ZONE
#include <roapi.h>
#include <tchar.h>
#include <wchar.h>
#include <windows.globalization.h>
#include <windows.h>
#endif
#endif

#include <cstdlib>
#include <cstring>
#include <string>

#include "time_zone_fixed.h"
#include "time_zone_impl.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {
namespace cctz {

namespace {
#if defined(USE_WIN32_LOCAL_TIME_ZONE)
// Calls the WinRT Calendar.GetTimeZone method to obtain the IANA ID of the
// local time zone. Returns an empty vector in case of an error.
std::string win32_local_time_zone(const HMODULE combase) {
  std::string result;
  const auto ro_activate_instance =
      reinterpret_cast<decltype(&RoActivateInstance)>(
          GetProcAddress(combase, "RoActivateInstance"));
  if (!ro_activate_instance) {
    return result;
  }
  const auto windows_create_string_reference =
      reinterpret_cast<decltype(&WindowsCreateStringReference)>(
          GetProcAddress(combase, "WindowsCreateStringReference"));
  if (!windows_create_string_reference) {
    return result;
  }
  const auto windows_delete_string =
      reinterpret_cast<decltype(&WindowsDeleteString)>(
          GetProcAddress(combase, "WindowsDeleteString"));
  if (!windows_delete_string) {
    return result;
  }
  const auto windows_get_string_raw_buffer =
      reinterpret_cast<decltype(&WindowsGetStringRawBuffer)>(
          GetProcAddress(combase, "WindowsGetStringRawBuffer"));
  if (!windows_get_string_raw_buffer) {
    return result;
  }

  // The string returned by WindowsCreateStringReference doesn't need to be
  // deleted.
  HSTRING calendar_class_id;
  HSTRING_HEADER calendar_class_id_header;
  HRESULT hr = windows_create_string_reference(
      RuntimeClass_Windows_Globalization_Calendar,
      sizeof(RuntimeClass_Windows_Globalization_Calendar) / sizeof(wchar_t) - 1,
      &calendar_class_id_header, &calendar_class_id);
  if (FAILED(hr)) {
    return result;
  }

  IInspectable* calendar;
  hr = ro_activate_instance(calendar_class_id, &calendar);
  if (FAILED(hr)) {
    return result;
  }

  ABI::Windows::Globalization::ITimeZoneOnCalendar* time_zone;
  hr = calendar->QueryInterface(IID_PPV_ARGS(&time_zone));
  if (FAILED(hr)) {
    calendar->Release();
    return result;
  }

  HSTRING tz_hstr;
  hr = time_zone->GetTimeZone(&tz_hstr);
  if (SUCCEEDED(hr)) {
    UINT32 wlen;
    const PCWSTR tz_wstr = windows_get_string_raw_buffer(tz_hstr, &wlen);
    if (tz_wstr) {
      const int size =
          WideCharToMultiByte(CP_UTF8, 0, tz_wstr, static_cast<int>(wlen),
                              nullptr, 0, nullptr, nullptr);
      result.resize(static_cast<size_t>(size));
      WideCharToMultiByte(CP_UTF8, 0, tz_wstr, static_cast<int>(wlen),
                          &result[0], size, nullptr, nullptr);
    }
    windows_delete_string(tz_hstr);
  }
  time_zone->Release();
  calendar->Release();
  return result;
}
#endif
}  // namespace

std::string time_zone::name() const { return effective_impl().Name(); }

time_zone::absolute_lookup time_zone::lookup(
    const time_point<seconds>& tp) const {
  return effective_impl().BreakTime(tp);
}

time_zone::civil_lookup time_zone::lookup(const civil_second& cs) const {
  return effective_impl().MakeTime(cs);
}

bool time_zone::next_transition(const time_point<seconds>& tp,
                                civil_transition* trans) const {
  return effective_impl().NextTransition(tp, trans);
}

bool time_zone::prev_transition(const time_point<seconds>& tp,
                                civil_transition* trans) const {
  return effective_impl().PrevTransition(tp, trans);
}

std::string time_zone::version() const { return effective_impl().Version(); }

std::string time_zone::description() const {
  return effective_impl().Description();
}

const time_zone::Impl& time_zone::effective_impl() const {
  if (impl_ == nullptr) {
    // Dereferencing an implicit-UTC time_zone is expected to be
    // rare, so we don't mind paying a small synchronization cost.
    return *time_zone::Impl::UTC().impl_;
  }
  return *impl_;
}

bool load_time_zone(const std::string& name, time_zone* tz) {
  return time_zone::Impl::LoadTimeZone(name, tz);
}

time_zone utc_time_zone() {
  return time_zone::Impl::UTC();  // avoid name lookup
}

time_zone fixed_time_zone(const seconds& offset) {
  time_zone tz;
  load_time_zone(FixedOffsetToName(offset), &tz);
  return tz;
}

time_zone local_time_zone() {
  const char* zone = ":localtime";
#if defined(__ANDROID__)
  char sysprop[PROP_VALUE_MAX];
  if (__system_property_get("persist.sys.timezone", sysprop) > 0) {
    zone = sysprop;
  }
#endif
#if defined(__APPLE__)
  std::vector<char> buffer;
  CFTimeZoneRef tz_default = CFTimeZoneCopyDefault();
  if (CFStringRef tz_name = CFTimeZoneGetName(tz_default)) {
    CFStringEncoding encoding = kCFStringEncodingUTF8;
    CFIndex length = CFStringGetLength(tz_name);
    CFIndex max_size = CFStringGetMaximumSizeForEncoding(length, encoding) + 1;
    buffer.resize(static_cast<size_t>(max_size));
    if (CFStringGetCString(tz_name, &buffer[0], max_size, encoding)) {
      zone = &buffer[0];
    }
  }
  CFRelease(tz_default);
#endif
#if defined(__Fuchsia__)
  std::string primary_tz;
  [&]() {
    // Note: We can't use the synchronous FIDL API here because it doesn't
    // allow timeouts; if the FIDL call failed, local_time_zone() would never
    // return.

    const zx::duration kTimeout = zx::msec(500);

    // Don't attach to the thread because otherwise the thread's dispatcher
    // would be set to null when the loop is destroyed, causing any other FIDL
    // code running on the same thread to crash.
    async::Loop loop(&kAsyncLoopConfigNeverAttachToThread);

    fuchsia::intl::PropertyProviderHandle handle;
    zx_status_t status = fdio_service_connect_by_name(
        fuchsia::intl::PropertyProvider::Name_,
        handle.NewRequest().TakeChannel().release());
    if (status != ZX_OK) {
      return;
    }

    fuchsia::intl::PropertyProviderPtr intl_provider;
    status = intl_provider.Bind(std::move(handle), loop.dispatcher());
    if (status != ZX_OK) {
      return;
    }

    intl_provider->GetProfile(
        [&loop, &primary_tz](fuchsia::intl::Profile profile) {
          if (!profile.time_zones().empty()) {
            primary_tz = profile.time_zones()[0].id;
          }
          loop.Quit();
        });
    loop.Run(zx::deadline_after(kTimeout));
  }();

  if (!primary_tz.empty()) {
    zone = primary_tz.c_str();
  }
#endif
#if defined(USE_WIN32_LOCAL_TIME_ZONE)
  // Use the WinRT Calendar class to get the local time zone. This feature is
  // available on Windows 10 and later. The library is dynamically linked to
  // maintain binary compatibility with Windows XP - Windows 7. On Windows 8,
  // The combase.dll API functions are available but the RoActivateInstance
  // call will fail for the Calendar class.
  std::string winrt_tz;
  const HMODULE combase =
      LoadLibraryEx(_T("combase.dll"), nullptr, LOAD_LIBRARY_SEARCH_SYSTEM32);
  if (combase) {
    const auto ro_initialize = reinterpret_cast<decltype(&::RoInitialize)>(
        GetProcAddress(combase, "RoInitialize"));
    const auto ro_uninitialize = reinterpret_cast<decltype(&::RoUninitialize)>(
        GetProcAddress(combase, "RoUninitialize"));
    if (ro_initialize && ro_uninitialize) {
      const HRESULT hr = ro_initialize(RO_INIT_MULTITHREADED);
      // RPC_E_CHANGED_MODE means that a previous RoInitialize call specified
      // a different concurrency model. The WinRT runtime is initialized and
      // should work for our purpose here, but we should *not* call
      // RoUninitialize because it's a failure.
      if (SUCCEEDED(hr) || hr == RPC_E_CHANGED_MODE) {
        winrt_tz = win32_local_time_zone(combase);
        if (SUCCEEDED(hr)) {
          ro_uninitialize();
        }
      }
    }
    FreeLibrary(combase);
  }
  if (!winrt_tz.empty()) {
    zone = winrt_tz.c_str();
  }
#endif

  // Allow ${TZ} to override to default zone.
  char* tz_env = nullptr;
#if defined(_MSC_VER)
  _dupenv_s(&tz_env, nullptr, "TZ");
#else
  tz_env = std::getenv("TZ");
#endif
  if (tz_env) zone = tz_env;

  // We only support the "[:]<zone-name>" form.
  if (*zone == ':') ++zone;

  // Map "localtime" to a system-specific name, but
  // allow ${LOCALTIME} to override the default name.
  char* localtime_env = nullptr;
  if (strcmp(zone, "localtime") == 0) {
#if defined(_MSC_VER)
    // System-specific default is just "localtime".
    _dupenv_s(&localtime_env, nullptr, "LOCALTIME");
#else
    zone = "/etc/localtime";  // System-specific default.
    localtime_env = std::getenv("LOCALTIME");
#endif
    if (localtime_env) zone = localtime_env;
  }

  const std::string name = zone;
#if defined(_MSC_VER)
  free(localtime_env);
  free(tz_env);
#endif

  time_zone tz;
  load_time_zone(name, &tz);  // Falls back to UTC.
  // TODO: Follow the RFC3339 "Unknown Local Offset Convention" and
  // arrange for %z to generate "-0000" when we don't know the local
  // offset because the load_time_zone() failed and we're using UTC.
  return tz;
}

}  // namespace cctz
}  // namespace time_internal
ABSL_NAMESPACE_END
}  // namespace absl
   node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/src/time_zone_lookup_test.cc     0000664 0000000 0000000 00000203376 14746647661 0032605 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

#include <chrono>
#include <cstddef>
#include <cstdlib>
#include <future>
#include <limits>
#include <string>
#include <thread>
#include <vector>

#include "absl/base/config.h"
#include "absl/time/internal/cctz/include/cctz/time_zone.h"
#if defined(__linux__)
#include <features.h>
#endif

#include "gtest/gtest.h"
#include "absl/time/internal/cctz/include/cctz/civil_time.h"

namespace chrono = std::chrono;

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {
namespace cctz {

namespace {

// A list of known time-zone names.
const char* const kTimeZoneNames[] = {"Africa/Abidjan",
                                      "Africa/Accra",
                                      "Africa/Addis_Ababa",
                                      "Africa/Algiers",
                                      "Africa/Asmara",
                                      "Africa/Bamako",
                                      "Africa/Bangui",
                                      "Africa/Banjul",
                                      "Africa/Bissau",
                                      "Africa/Blantyre",
                                      "Africa/Brazzaville",
                                      "Africa/Bujumbura",
                                      "Africa/Cairo",
                                      "Africa/Casablanca",
                                      "Africa/Ceuta",
                                      "Africa/Conakry",
                                      "Africa/Dakar",
                                      "Africa/Dar_es_Salaam",
                                      "Africa/Djibouti",
                                      "Africa/Douala",
                                      "Africa/El_Aaiun",
                                      "Africa/Freetown",
                                      "Africa/Gaborone",
                                      "Africa/Harare",
                                      "Africa/Johannesburg",
                                      "Africa/Juba",
                                      "Africa/Kampala",
                                      "Africa/Khartoum",
                                      "Africa/Kigali",
                                      "Africa/Kinshasa",
                                      "Africa/Lagos",
                                      "Africa/Libreville",
                                      "Africa/Lome",
                                      "Africa/Luanda",
                                      "Africa/Lubumbashi",
                                      "Africa/Lusaka",
                                      "Africa/Malabo",
                                      "Africa/Maputo",
                                      "Africa/Maseru",
                                      "Africa/Mbabane",
                                      "Africa/Mogadishu",
                                      "Africa/Monrovia",
                                      "Africa/Nairobi",
                                      "Africa/Ndjamena",
                                      "Africa/Niamey",
                                      "Africa/Nouakchott",
                                      "Africa/Ouagadougou",
                                      "Africa/Porto-Novo",
                                      "Africa/Sao_Tome",
                                      "Africa/Timbuktu",
                                      "Africa/Tripoli",
                                      "Africa/Tunis",
                                      "Africa/Windhoek",
                                      "America/Adak",
                                      "America/Anchorage",
                                      "America/Anguilla",
                                      "America/Antigua",
                                      "America/Araguaina",
                                      "America/Argentina/Buenos_Aires",
                                      "America/Argentina/Catamarca",
                                      "America/Argentina/Cordoba",
                                      "America/Argentina/Jujuy",
                                      "America/Argentina/La_Rioja",
                                      "America/Argentina/Mendoza",
                                      "America/Argentina/Rio_Gallegos",
                                      "America/Argentina/Salta",
                                      "America/Argentina/San_Juan",
                                      "America/Argentina/San_Luis",
                                      "America/Argentina/Tucuman",
                                      "America/Argentina/Ushuaia",
                                      "America/Aruba",
                                      "America/Asuncion",
                                      "America/Atikokan",
                                      "America/Atka",
                                      "America/Bahia",
                                      "America/Bahia_Banderas",
                                      "America/Barbados",
                                      "America/Belem",
                                      "America/Belize",
                                      "America/Blanc-Sablon",
                                      "America/Boa_Vista",
                                      "America/Bogota",
                                      "America/Boise",
                                      "America/Cambridge_Bay",
                                      "America/Campo_Grande",
                                      "America/Cancun",
                                      "America/Caracas",
                                      "America/Cayenne",
                                      "America/Cayman",
                                      "America/Chicago",
                                      "America/Chihuahua",
                                      "America/Ciudad_Juarez",
                                      "America/Coral_Harbour",
                                      "America/Costa_Rica",
                                      "America/Creston",
                                      "America/Cuiaba",
                                      "America/Curacao",
                                      "America/Danmarkshavn",
                                      "America/Dawson",
                                      "America/Dawson_Creek",
                                      "America/Denver",
                                      "America/Detroit",
                                      "America/Dominica",
                                      "America/Edmonton",
                                      "America/Eirunepe",
                                      "America/El_Salvador",
                                      "America/Ensenada",
                                      "America/Fort_Nelson",
                                      "America/Fortaleza",
                                      "America/Glace_Bay",
                                      "America/Godthab",
                                      "America/Goose_Bay",
                                      "America/Grand_Turk",
                                      "America/Grenada",
                                      "America/Guadeloupe",
                                      "America/Guatemala",
                                      "America/Guayaquil",
                                      "America/Guyana",
                                      "America/Halifax",
                                      "America/Havana",
                                      "America/Hermosillo",
                                      "America/Indiana/Indianapolis",
                                      "America/Indiana/Knox",
                                      "America/Indiana/Marengo",
                                      "America/Indiana/Petersburg",
                                      "America/Indiana/Tell_City",
                                      "America/Indiana/Vevay",
                                      "America/Indiana/Vincennes",
                                      "America/Indiana/Winamac",
                                      "America/Inuvik",
                                      "America/Iqaluit",
                                      "America/Jamaica",
                                      "America/Juneau",
                                      "America/Kentucky/Louisville",
                                      "America/Kentucky/Monticello",
                                      "America/Kralendijk",
                                      "America/La_Paz",
                                      "America/Lima",
                                      "America/Los_Angeles",
                                      "America/Lower_Princes",
                                      "America/Maceio",
                                      "America/Managua",
                                      "America/Manaus",
                                      "America/Marigot",
                                      "America/Martinique",
                                      "America/Matamoros",
                                      "America/Mazatlan",
                                      "America/Menominee",
                                      "America/Merida",
                                      "America/Metlakatla",
                                      "America/Mexico_City",
                                      "America/Miquelon",
                                      "America/Moncton",
                                      "America/Monterrey",
                                      "America/Montevideo",
                                      "America/Montreal",
                                      "America/Montserrat",
                                      "America/Nassau",
                                      "America/New_York",
                                      "America/Nipigon",
                                      "America/Nome",
                                      "America/Noronha",
                                      "America/North_Dakota/Beulah",
                                      "America/North_Dakota/Center",
                                      "America/North_Dakota/New_Salem",
                                      "America/Nuuk",
                                      "America/Ojinaga",
                                      "America/Panama",
                                      "America/Pangnirtung",
                                      "America/Paramaribo",
                                      "America/Phoenix",
                                      "America/Port-au-Prince",
                                      "America/Port_of_Spain",
                                      "America/Porto_Acre",
                                      "America/Porto_Velho",
                                      "America/Puerto_Rico",
                                      "America/Punta_Arenas",
                                      "America/Rainy_River",
                                      "America/Rankin_Inlet",
                                      "America/Recife",
                                      "America/Regina",
                                      "America/Resolute",
                                      "America/Rio_Branco",
                                      "America/Santa_Isabel",
                                      "America/Santarem",
                                      "America/Santiago",
                                      "America/Santo_Domingo",
                                      "America/Sao_Paulo",
                                      "America/Scoresbysund",
                                      "America/Shiprock",
                                      "America/Sitka",
                                      "America/St_Barthelemy",
                                      "America/St_Johns",
                                      "America/St_Kitts",
                                      "America/St_Lucia",
                                      "America/St_Thomas",
                                      "America/St_Vincent",
                                      "America/Swift_Current",
                                      "America/Tegucigalpa",
                                      "America/Thule",
                                      "America/Thunder_Bay",
                                      "America/Tijuana",
                                      "America/Toronto",
                                      "America/Tortola",
                                      "America/Vancouver",
                                      "America/Virgin",
                                      "America/Whitehorse",
                                      "America/Winnipeg",
                                      "America/Yakutat",
                                      "America/Yellowknife",
                                      "Antarctica/Casey",
                                      "Antarctica/Davis",
                                      "Antarctica/DumontDUrville",
                                      "Antarctica/Macquarie",
                                      "Antarctica/Mawson",
                                      "Antarctica/McMurdo",
                                      "Antarctica/Palmer",
                                      "Antarctica/Rothera",
                                      "Antarctica/Syowa",
                                      "Antarctica/Troll",
                                      "Antarctica/Vostok",
                                      "Arctic/Longyearbyen",
                                      "Asia/Aden",
                                      "Asia/Almaty",
                                      "Asia/Amman",
                                      "Asia/Anadyr",
                                      "Asia/Aqtau",
                                      "Asia/Aqtobe",
                                      "Asia/Ashgabat",
                                      "Asia/Atyrau",
                                      "Asia/Baghdad",
                                      "Asia/Bahrain",
                                      "Asia/Baku",
                                      "Asia/Bangkok",
                                      "Asia/Barnaul",
                                      "Asia/Beirut",
                                      "Asia/Bishkek",
                                      "Asia/Brunei",
                                      "Asia/Chita",
                                      "Asia/Choibalsan",
                                      "Asia/Chongqing",
                                      "Asia/Colombo",
                                      "Asia/Damascus",
                                      "Asia/Dhaka",
                                      "Asia/Dili",
                                      "Asia/Dubai",
                                      "Asia/Dushanbe",
                                      "Asia/Famagusta",
                                      "Asia/Gaza",
                                      "Asia/Harbin",
                                      "Asia/Hebron",
                                      "Asia/Ho_Chi_Minh",
                                      "Asia/Hong_Kong",
                                      "Asia/Hovd",
                                      "Asia/Irkutsk",
                                      "Asia/Istanbul",
                                      "Asia/Jakarta",
                                      "Asia/Jayapura",
                                      "Asia/Jerusalem",
                                      "Asia/Kabul",
                                      "Asia/Kamchatka",
                                      "Asia/Karachi",
                                      "Asia/Kashgar",
                                      "Asia/Kathmandu",
                                      "Asia/Khandyga",
                                      "Asia/Kolkata",
                                      "Asia/Krasnoyarsk",
                                      "Asia/Kuala_Lumpur",
                                      "Asia/Kuching",
                                      "Asia/Kuwait",
                                      "Asia/Macau",
                                      "Asia/Magadan",
                                      "Asia/Makassar",
                                      "Asia/Manila",
                                      "Asia/Muscat",
                                      "Asia/Nicosia",
                                      "Asia/Novokuznetsk",
                                      "Asia/Novosibirsk",
                                      "Asia/Omsk",
                                      "Asia/Oral",
                                      "Asia/Phnom_Penh",
                                      "Asia/Pontianak",
                                      "Asia/Pyongyang",
                                      "Asia/Qatar",
                                      "Asia/Qostanay",
                                      "Asia/Qyzylorda",
                                      "Asia/Riyadh",
                                      "Asia/Sakhalin",
                                      "Asia/Samarkand",
                                      "Asia/Seoul",
                                      "Asia/Shanghai",
                                      "Asia/Singapore",
                                      "Asia/Srednekolymsk",
                                      "Asia/Taipei",
                                      "Asia/Tashkent",
                                      "Asia/Tbilisi",
                                      "Asia/Tehran",
                                      "Asia/Tel_Aviv",
                                      "Asia/Thimphu",
                                      "Asia/Tokyo",
                                      "Asia/Tomsk",
                                      "Asia/Ulaanbaatar",
                                      "Asia/Urumqi",
                                      "Asia/Ust-Nera",
                                      "Asia/Vientiane",
                                      "Asia/Vladivostok",
                                      "Asia/Yakutsk",
                                      "Asia/Yangon",
                                      "Asia/Yekaterinburg",
                                      "Asia/Yerevan",
                                      "Atlantic/Azores",
                                      "Atlantic/Bermuda",
                                      "Atlantic/Canary",
                                      "Atlantic/Cape_Verde",
                                      "Atlantic/Faroe",
                                      "Atlantic/Jan_Mayen",
                                      "Atlantic/Madeira",
                                      "Atlantic/Reykjavik",
                                      "Atlantic/South_Georgia",
                                      "Atlantic/St_Helena",
                                      "Atlantic/Stanley",
                                      "Australia/Adelaide",
                                      "Australia/Brisbane",
                                      "Australia/Broken_Hill",
                                      "Australia/Canberra",
                                      "Australia/Currie",
                                      "Australia/Darwin",
                                      "Australia/Eucla",
                                      "Australia/Hobart",
                                      "Australia/Lindeman",
                                      "Australia/Lord_Howe",
                                      "Australia/Melbourne",
                                      "Australia/Perth",
                                      "Australia/Sydney",
                                      "Australia/Yancowinna",
                                      "Etc/GMT",
                                      "Etc/GMT+0",
                                      "Etc/GMT+1",
                                      "Etc/GMT+10",
                                      "Etc/GMT+11",
                                      "Etc/GMT+12",
                                      "Etc/GMT+2",
                                      "Etc/GMT+3",
                                      "Etc/GMT+4",
                                      "Etc/GMT+5",
                                      "Etc/GMT+6",
                                      "Etc/GMT+7",
                                      "Etc/GMT+8",
                                      "Etc/GMT+9",
                                      "Etc/GMT-0",
                                      "Etc/GMT-1",
                                      "Etc/GMT-10",
                                      "Etc/GMT-11",
                                      "Etc/GMT-12",
                                      "Etc/GMT-13",
                                      "Etc/GMT-14",
                                      "Etc/GMT-2",
                                      "Etc/GMT-3",
                                      "Etc/GMT-4",
                                      "Etc/GMT-5",
                                      "Etc/GMT-6",
                                      "Etc/GMT-7",
                                      "Etc/GMT-8",
                                      "Etc/GMT-9",
                                      "Etc/GMT0",
                                      "Etc/Greenwich",
                                      "Etc/UCT",
                                      "Etc/UTC",
                                      "Etc/Universal",
                                      "Etc/Zulu",
                                      "Europe/Amsterdam",
                                      "Europe/Andorra",
                                      "Europe/Astrakhan",
                                      "Europe/Athens",
                                      "Europe/Belfast",
                                      "Europe/Belgrade",
                                      "Europe/Berlin",
                                      "Europe/Bratislava",
                                      "Europe/Brussels",
                                      "Europe/Bucharest",
                                      "Europe/Budapest",
                                      "Europe/Busingen",
                                      "Europe/Chisinau",
                                      "Europe/Copenhagen",
                                      "Europe/Dublin",
                                      "Europe/Gibraltar",
                                      "Europe/Guernsey",
                                      "Europe/Helsinki",
                                      "Europe/Isle_of_Man",
                                      "Europe/Istanbul",
                                      "Europe/Jersey",
                                      "Europe/Kaliningrad",
                                      "Europe/Kirov",
                                      "Europe/Kyiv",
                                      "Europe/Lisbon",
                                      "Europe/Ljubljana",
                                      "Europe/London",
                                      "Europe/Luxembourg",
                                      "Europe/Madrid",
                                      "Europe/Malta",
                                      "Europe/Mariehamn",
                                      "Europe/Minsk",
                                      "Europe/Monaco",
                                      "Europe/Moscow",
                                      "Europe/Nicosia",
                                      "Europe/Oslo",
                                      "Europe/Paris",
                                      "Europe/Podgorica",
                                      "Europe/Prague",
                                      "Europe/Riga",
                                      "Europe/Rome",
                                      "Europe/Samara",
                                      "Europe/San_Marino",
                                      "Europe/Sarajevo",
                                      "Europe/Saratov",
                                      "Europe/Simferopol",
                                      "Europe/Skopje",
                                      "Europe/Sofia",
                                      "Europe/Stockholm",
                                      "Europe/Tallinn",
                                      "Europe/Tirane",
                                      "Europe/Tiraspol",
                                      "Europe/Ulyanovsk",
                                      "Europe/Vaduz",
                                      "Europe/Vatican",
                                      "Europe/Vienna",
                                      "Europe/Vilnius",
                                      "Europe/Volgograd",
                                      "Europe/Warsaw",
                                      "Europe/Zagreb",
                                      "Europe/Zurich",
                                      "Factory",
                                      "Indian/Antananarivo",
                                      "Indian/Chagos",
                                      "Indian/Christmas",
                                      "Indian/Cocos",
                                      "Indian/Comoro",
                                      "Indian/Kerguelen",
                                      "Indian/Mahe",
                                      "Indian/Maldives",
                                      "Indian/Mauritius",
                                      "Indian/Mayotte",
                                      "Indian/Reunion",
                                      "Pacific/Apia",
                                      "Pacific/Auckland",
                                      "Pacific/Bougainville",
                                      "Pacific/Chatham",
                                      "Pacific/Chuuk",
                                      "Pacific/Easter",
                                      "Pacific/Efate",
                                      "Pacific/Fakaofo",
                                      "Pacific/Fiji",
                                      "Pacific/Funafuti",
                                      "Pacific/Galapagos",
                                      "Pacific/Gambier",
                                      "Pacific/Guadalcanal",
                                      "Pacific/Guam",
                                      "Pacific/Honolulu",
                                      "Pacific/Johnston",
                                      "Pacific/Kanton",
                                      "Pacific/Kiritimati",
                                      "Pacific/Kosrae",
                                      "Pacific/Kwajalein",
                                      "Pacific/Majuro",
                                      "Pacific/Marquesas",
                                      "Pacific/Midway",
                                      "Pacific/Nauru",
                                      "Pacific/Niue",
                                      "Pacific/Norfolk",
                                      "Pacific/Noumea",
                                      "Pacific/Pago_Pago",
                                      "Pacific/Palau",
                                      "Pacific/Pitcairn",
                                      "Pacific/Pohnpei",
                                      "Pacific/Port_Moresby",
                                      "Pacific/Rarotonga",
                                      "Pacific/Saipan",
                                      "Pacific/Samoa",
                                      "Pacific/Tahiti",
                                      "Pacific/Tarawa",
                                      "Pacific/Tongatapu",
                                      "Pacific/Wake",
                                      "Pacific/Wallis",
                                      "Pacific/Yap",
                                      "UTC",
                                      nullptr};

// Helper to return a loaded time zone by value (UTC on error).
time_zone LoadZone(const std::string& name) {
  time_zone tz;
  load_time_zone(name, &tz);
  return tz;
}

// This helper is a macro so that failed expectations show up with the
// correct line numbers.
#define ExpectTime(tp, tz, y, m, d, hh, mm, ss, off, isdst, zone) \
  do {                                                            \
    time_zone::absolute_lookup al = tz.lookup(tp);                \
    EXPECT_EQ(y, al.cs.year());                                   \
    EXPECT_EQ(m, al.cs.month());                                  \
    EXPECT_EQ(d, al.cs.day());                                    \
    EXPECT_EQ(hh, al.cs.hour());                                  \
    EXPECT_EQ(mm, al.cs.minute());                                \
    EXPECT_EQ(ss, al.cs.second());                                \
    EXPECT_EQ(off, al.offset);                                    \
    EXPECT_TRUE(isdst == al.is_dst);                              \
    /* EXPECT_STREQ(zone, al.abbr); */                            \
  } while (0)

// These tests sometimes run on platforms that have zoneinfo data so old
// that the transition we are attempting to check does not exist, most
// notably Android emulators.  Fortunately, AndroidZoneInfoSource supports
// time_zone::version() so, in cases where we've learned that it matters,
// we can make the check conditionally.
int VersionCmp(time_zone tz, const std::string& target) {
  std::string version = tz.version();
  if (version.empty() && !target.empty()) return 1;  // unknown > known
  return version.compare(target);
}

}  // namespace

#if !defined(__EMSCRIPTEN__)
TEST(TimeZones, LoadZonesConcurrently) {
  std::promise<void> ready_promise;
  std::shared_future<void> ready_future(ready_promise.get_future());
  auto load_zones = [ready_future](std::promise<void>* started,
                                   std::set<std::string>* failures) {
    started->set_value();
    ready_future.wait();
    for (const char* const* np = kTimeZoneNames; *np != nullptr; ++np) {
      std::string zone = *np;
      time_zone tz;
      if (load_time_zone(zone, &tz)) {
        EXPECT_EQ(zone, tz.name());
      } else {
        failures->insert(zone);
      }
    }
  };

  const std::size_t n_threads = 128;
  std::vector<std::thread> threads;
  std::vector<std::set<std::string>> thread_failures(n_threads);
  for (std::size_t i = 0; i != n_threads; ++i) {
    std::promise<void> started;
    threads.emplace_back(load_zones, &started, &thread_failures[i]);
    started.get_future().wait();
  }
  ready_promise.set_value();
  for (auto& thread : threads) {
    thread.join();
  }

  // Allow a small number of failures to account for skew between
  // the contents of kTimeZoneNames and the zoneinfo data source.
#if defined(__ANDROID__)
  // Cater to the possibility of using an even older zoneinfo data
  // source when running on Android, where it is difficult to override
  // the bionic tzdata provided by the test environment.
  const std::size_t max_failures = 20;
#else
  const std::size_t max_failures = 3;
#endif
  std::set<std::string> failures;
  for (const auto& thread_failure : thread_failures) {
    failures.insert(thread_failure.begin(), thread_failure.end());
  }
  EXPECT_LE(failures.size(), max_failures) << testing::PrintToString(failures);
}
#endif

TEST(TimeZone, UTC) {
  const time_zone utc = utc_time_zone();

  time_zone loaded_utc;
  EXPECT_TRUE(load_time_zone("UTC", &loaded_utc));
  EXPECT_EQ(loaded_utc, utc);

  time_zone loaded_utc0;
  EXPECT_TRUE(load_time_zone("UTC0", &loaded_utc0));
  EXPECT_EQ(loaded_utc0, utc);

  time_zone loaded_bad;
  EXPECT_FALSE(load_time_zone("Invalid/TimeZone", &loaded_bad));
  EXPECT_EQ(loaded_bad, utc);
}

TEST(TimeZone, NamedTimeZones) {
  const time_zone utc = utc_time_zone();
  EXPECT_EQ("UTC", utc.name());
  const time_zone nyc = LoadZone("America/New_York");
  EXPECT_EQ("America/New_York", nyc.name());
  const time_zone syd = LoadZone("Australia/Sydney");
  EXPECT_EQ("Australia/Sydney", syd.name());
  const time_zone fixed0 =
      fixed_time_zone(absl::time_internal::cctz::seconds::zero());
  EXPECT_EQ("UTC", fixed0.name());
  const time_zone fixed_pos = fixed_time_zone(
      chrono::hours(3) + chrono::minutes(25) + chrono::seconds(45));
  EXPECT_EQ("Fixed/UTC+03:25:45", fixed_pos.name());
  const time_zone fixed_neg = fixed_time_zone(
      -(chrono::hours(12) + chrono::minutes(34) + chrono::seconds(56)));
  EXPECT_EQ("Fixed/UTC-12:34:56", fixed_neg.name());
}

TEST(TimeZone, Failures) {
  time_zone tz;
  EXPECT_FALSE(load_time_zone(":America/Los_Angeles", &tz));

  tz = LoadZone("America/Los_Angeles");
  EXPECT_FALSE(load_time_zone("Invalid/TimeZone", &tz));
  EXPECT_EQ(chrono::system_clock::from_time_t(0),
            convert(civil_second(1970, 1, 1, 0, 0, 0), tz));  // UTC

  // Ensures that the load still fails on a subsequent attempt.
  tz = LoadZone("America/Los_Angeles");
  EXPECT_FALSE(load_time_zone("Invalid/TimeZone", &tz));
  EXPECT_EQ(chrono::system_clock::from_time_t(0),
            convert(civil_second(1970, 1, 1, 0, 0, 0), tz));  // UTC

  // Loading an empty string timezone should fail.
  tz = LoadZone("America/Los_Angeles");
  EXPECT_FALSE(load_time_zone("", &tz));
  EXPECT_EQ(chrono::system_clock::from_time_t(0),
            convert(civil_second(1970, 1, 1, 0, 0, 0), tz));  // UTC
}

TEST(TimeZone, Equality) {
  const time_zone a;
  const time_zone b;
  EXPECT_EQ(a, b);
  EXPECT_EQ(a.name(), b.name());

  const time_zone implicit_utc;
  const time_zone explicit_utc = utc_time_zone();
  EXPECT_EQ(implicit_utc, explicit_utc);
  EXPECT_EQ(implicit_utc.name(), explicit_utc.name());

  const time_zone fixed_zero =
      fixed_time_zone(absl::time_internal::cctz::seconds::zero());
  EXPECT_EQ(fixed_zero, LoadZone(fixed_zero.name()));
  EXPECT_EQ(fixed_zero, explicit_utc);

  const time_zone fixed_utc = LoadZone("Fixed/UTC+00:00:00");
  EXPECT_EQ(fixed_utc, LoadZone(fixed_utc.name()));
  EXPECT_EQ(fixed_utc, explicit_utc);

  const time_zone fixed_pos = fixed_time_zone(
      chrono::hours(3) + chrono::minutes(25) + chrono::seconds(45));
  EXPECT_EQ(fixed_pos, LoadZone(fixed_pos.name()));
  EXPECT_NE(fixed_pos, explicit_utc);
  const time_zone fixed_neg = fixed_time_zone(
      -(chrono::hours(12) + chrono::minutes(34) + chrono::seconds(56)));
  EXPECT_EQ(fixed_neg, LoadZone(fixed_neg.name()));
  EXPECT_NE(fixed_neg, explicit_utc);

  const time_zone fixed_lim = fixed_time_zone(chrono::hours(24));
  EXPECT_EQ(fixed_lim, LoadZone(fixed_lim.name()));
  EXPECT_NE(fixed_lim, explicit_utc);
  const time_zone fixed_ovfl =
      fixed_time_zone(chrono::hours(24) + chrono::seconds(1));
  EXPECT_EQ(fixed_ovfl, LoadZone(fixed_ovfl.name()));
  EXPECT_EQ(fixed_ovfl, explicit_utc);

  EXPECT_EQ(fixed_time_zone(chrono::seconds(1)),
            fixed_time_zone(chrono::seconds(1)));

  const time_zone local = local_time_zone();
  EXPECT_EQ(local, LoadZone(local.name()));

  time_zone la = LoadZone("America/Los_Angeles");
  time_zone nyc = LoadZone("America/New_York");
  EXPECT_NE(la, nyc);
}

TEST(StdChronoTimePoint, TimeTAlignment) {
  // Ensures that the Unix epoch and the system clock epoch are an integral
  // number of seconds apart. This simplifies conversions to/from time_t.
  auto diff =
      chrono::system_clock::time_point() - chrono::system_clock::from_time_t(0);
  EXPECT_EQ(chrono::system_clock::time_point::duration::zero(),
            diff % chrono::seconds(1));
}

TEST(BreakTime, TimePointResolution) {
  const time_zone utc = utc_time_zone();
  const auto t0 = chrono::system_clock::from_time_t(0);

  ExpectTime(chrono::time_point_cast<chrono::nanoseconds>(t0), utc, 1970, 1, 1,
             0, 0, 0, 0, false, "UTC");
  ExpectTime(chrono::time_point_cast<chrono::microseconds>(t0), utc, 1970, 1, 1,
             0, 0, 0, 0, false, "UTC");
  ExpectTime(chrono::time_point_cast<chrono::milliseconds>(t0), utc, 1970, 1, 1,
             0, 0, 0, 0, false, "UTC");
  ExpectTime(chrono::time_point_cast<chrono::seconds>(t0), utc, 1970, 1, 1, 0,
             0, 0, 0, false, "UTC");
  ExpectTime(chrono::time_point_cast<absl::time_internal::cctz::seconds>(t0),
             utc, 1970, 1, 1, 0, 0, 0, 0, false, "UTC");
  ExpectTime(chrono::time_point_cast<chrono::minutes>(t0), utc, 1970, 1, 1, 0,
             0, 0, 0, false, "UTC");
  ExpectTime(chrono::time_point_cast<chrono::hours>(t0), utc, 1970, 1, 1, 0, 0,
             0, 0, false, "UTC");
}

TEST(BreakTime, LocalTimeInUTC) {
  const time_zone tz = utc_time_zone();
  const auto tp = chrono::system_clock::from_time_t(0);
  ExpectTime(tp, tz, 1970, 1, 1, 0, 0, 0, 0, false, "UTC");
  EXPECT_EQ(weekday::thursday, get_weekday(convert(tp, tz)));
}

TEST(BreakTime, LocalTimeInUTCUnaligned) {
  const time_zone tz = utc_time_zone();
  const auto tp =
      chrono::system_clock::from_time_t(0) - chrono::milliseconds(500);
  ExpectTime(tp, tz, 1969, 12, 31, 23, 59, 59, 0, false, "UTC");
  EXPECT_EQ(weekday::wednesday, get_weekday(convert(tp, tz)));
}

TEST(BreakTime, LocalTimePosix) {
  // See IEEE Std 1003.1-1988 B.2.3 General Terms, Epoch.
  const time_zone tz = utc_time_zone();
  const auto tp = chrono::system_clock::from_time_t(536457599);
  ExpectTime(tp, tz, 1986, 12, 31, 23, 59, 59, 0, false, "UTC");
  EXPECT_EQ(weekday::wednesday, get_weekday(convert(tp, tz)));
}

TEST(TimeZoneImpl, LocalTimeInFixed) {
  const absl::time_internal::cctz::seconds offset =
      -(chrono::hours(8) + chrono::minutes(33) + chrono::seconds(47));
  const time_zone tz = fixed_time_zone(offset);
  const auto tp = chrono::system_clock::from_time_t(0);
  ExpectTime(tp, tz, 1969, 12, 31, 15, 26, 13, offset.count(), false,
             "-083347");
  EXPECT_EQ(weekday::wednesday, get_weekday(convert(tp, tz)));
}

TEST(BreakTime, LocalTimeInNewYork) {
  const time_zone tz = LoadZone("America/New_York");
  const auto tp = chrono::system_clock::from_time_t(45);
  ExpectTime(tp, tz, 1969, 12, 31, 19, 0, 45, -5 * 60 * 60, false, "EST");
  EXPECT_EQ(weekday::wednesday, get_weekday(convert(tp, tz)));
}

TEST(BreakTime, LocalTimeInMTV) {
  const time_zone tz = LoadZone("America/Los_Angeles");
  const auto tp = chrono::system_clock::from_time_t(1380855729);
  ExpectTime(tp, tz, 2013, 10, 3, 20, 2, 9, -7 * 60 * 60, true, "PDT");
  EXPECT_EQ(weekday::thursday, get_weekday(convert(tp, tz)));
}

TEST(BreakTime, LocalTimeInSydney) {
  const time_zone tz = LoadZone("Australia/Sydney");
  const auto tp = chrono::system_clock::from_time_t(90);
  ExpectTime(tp, tz, 1970, 1, 1, 10, 1, 30, 10 * 60 * 60, false, "AEST");
  EXPECT_EQ(weekday::thursday, get_weekday(convert(tp, tz)));
}

TEST(MakeTime, TimePointResolution) {
  const time_zone utc = utc_time_zone();
  const time_point<chrono::nanoseconds> tp_ns =
      convert(civil_second(2015, 1, 2, 3, 4, 5), utc);
  EXPECT_EQ("04:05", absl::time_internal::cctz::format("%M:%E*S", tp_ns, utc));
  const time_point<chrono::microseconds> tp_us =
      convert(civil_second(2015, 1, 2, 3, 4, 5), utc);
  EXPECT_EQ("04:05", absl::time_internal::cctz::format("%M:%E*S", tp_us, utc));
  const time_point<chrono::milliseconds> tp_ms =
      convert(civil_second(2015, 1, 2, 3, 4, 5), utc);
  EXPECT_EQ("04:05", absl::time_internal::cctz::format("%M:%E*S", tp_ms, utc));
  const time_point<chrono::seconds> tp_s =
      convert(civil_second(2015, 1, 2, 3, 4, 5), utc);
  EXPECT_EQ("04:05", absl::time_internal::cctz::format("%M:%E*S", tp_s, utc));
  const time_point<absl::time_internal::cctz::seconds> tp_s64 =
      convert(civil_second(2015, 1, 2, 3, 4, 5), utc);
  EXPECT_EQ("04:05", absl::time_internal::cctz::format("%M:%E*S", tp_s64, utc));

  // These next two require chrono::time_point_cast because the conversion
  // from a resolution of seconds (the return value of convert()) to a
  // coarser resolution requires an explicit cast.
  const time_point<chrono::minutes> tp_m =
      chrono::time_point_cast<chrono::minutes>(
          convert(civil_second(2015, 1, 2, 3, 4, 5), utc));
  EXPECT_EQ("04:00", absl::time_internal::cctz::format("%M:%E*S", tp_m, utc));
  const time_point<chrono::hours> tp_h = chrono::time_point_cast<chrono::hours>(
      convert(civil_second(2015, 1, 2, 3, 4, 5), utc));
  EXPECT_EQ("00:00", absl::time_internal::cctz::format("%M:%E*S", tp_h, utc));
}

TEST(MakeTime, Normalization) {
  const time_zone tz = LoadZone("America/New_York");
  const auto tp = convert(civil_second(2009, 2, 13, 18, 31, 30), tz);
  EXPECT_EQ(chrono::system_clock::from_time_t(1234567890), tp);

  // Now requests for the same time_point but with out-of-range fields.
  EXPECT_EQ(tp, convert(civil_second(2008, 14, 13, 18, 31, 30), tz));  // month
  EXPECT_EQ(tp, convert(civil_second(2009, 1, 44, 18, 31, 30), tz));   // day
  EXPECT_EQ(tp, convert(civil_second(2009, 2, 12, 42, 31, 30), tz));   // hour
  EXPECT_EQ(tp, convert(civil_second(2009, 2, 13, 17, 91, 30), tz));   // minute
  EXPECT_EQ(tp, convert(civil_second(2009, 2, 13, 18, 30, 90), tz));   // second
}

// NOTE: Run this with -ftrapv to detect overflow problems.
TEST(MakeTime, SysSecondsLimits) {
  const char RFC3339[] = "%Y-%m-%d%ET%H:%M:%S%Ez";
  const time_zone utc = utc_time_zone();
  const time_zone east = fixed_time_zone(chrono::hours(14));
  const time_zone west = fixed_time_zone(-chrono::hours(14));
  time_point<absl::time_internal::cctz::seconds> tp;

  // Approach the maximal time_point<cctz::seconds> value from below.
  tp = convert(civil_second(292277026596, 12, 4, 15, 30, 6), utc);
  EXPECT_EQ("292277026596-12-04T15:30:06+00:00",
            absl::time_internal::cctz::format(RFC3339, tp, utc));
  tp = convert(civil_second(292277026596, 12, 4, 15, 30, 7), utc);
  EXPECT_EQ("292277026596-12-04T15:30:07+00:00",
            absl::time_internal::cctz::format(RFC3339, tp, utc));
  EXPECT_EQ(time_point<absl::time_internal::cctz::seconds>::max(), tp);
  tp = convert(civil_second(292277026596, 12, 4, 15, 30, 8), utc);
  EXPECT_EQ(time_point<absl::time_internal::cctz::seconds>::max(), tp);
  tp = convert(civil_second::max(), utc);
  EXPECT_EQ(time_point<absl::time_internal::cctz::seconds>::max(), tp);

  // Checks that we can also get the maximal value for a far-east zone.
  tp = convert(civil_second(292277026596, 12, 5, 5, 30, 7), east);
  EXPECT_EQ("292277026596-12-05T05:30:07+14:00",
            absl::time_internal::cctz::format(RFC3339, tp, east));
  EXPECT_EQ(time_point<absl::time_internal::cctz::seconds>::max(), tp);
  tp = convert(civil_second(292277026596, 12, 5, 5, 30, 8), east);
  EXPECT_EQ(time_point<absl::time_internal::cctz::seconds>::max(), tp);
  tp = convert(civil_second::max(), east);
  EXPECT_EQ(time_point<absl::time_internal::cctz::seconds>::max(), tp);

  // Checks that we can also get the maximal value for a far-west zone.
  tp = convert(civil_second(292277026596, 12, 4, 1, 30, 7), west);
  EXPECT_EQ("292277026596-12-04T01:30:07-14:00",
            absl::time_internal::cctz::format(RFC3339, tp, west));
  EXPECT_EQ(time_point<absl::time_internal::cctz::seconds>::max(), tp);
  tp = convert(civil_second(292277026596, 12, 4, 7, 30, 8), west);
  EXPECT_EQ(time_point<absl::time_internal::cctz::seconds>::max(), tp);
  tp = convert(civil_second::max(), west);
  EXPECT_EQ(time_point<absl::time_internal::cctz::seconds>::max(), tp);

  // Approach the minimal time_point<cctz::seconds> value from above.
  tp = convert(civil_second(-292277022657, 1, 27, 8, 29, 53), utc);
  EXPECT_EQ("-292277022657-01-27T08:29:53+00:00",
            absl::time_internal::cctz::format(RFC3339, tp, utc));
  tp = convert(civil_second(-292277022657, 1, 27, 8, 29, 52), utc);
  EXPECT_EQ("-292277022657-01-27T08:29:52+00:00",
            absl::time_internal::cctz::format(RFC3339, tp, utc));
  EXPECT_EQ(time_point<absl::time_internal::cctz::seconds>::min(), tp);
  tp = convert(civil_second(-292277022657, 1, 27, 8, 29, 51), utc);
  EXPECT_EQ(time_point<absl::time_internal::cctz::seconds>::min(), tp);
  tp = convert(civil_second::min(), utc);
  EXPECT_EQ(time_point<absl::time_internal::cctz::seconds>::min(), tp);

  // Checks that we can also get the minimal value for a far-east zone.
  tp = convert(civil_second(-292277022657, 1, 27, 22, 29, 52), east);
  EXPECT_EQ("-292277022657-01-27T22:29:52+14:00",
            absl::time_internal::cctz::format(RFC3339, tp, east));
  EXPECT_EQ(time_point<absl::time_internal::cctz::seconds>::min(), tp);
  tp = convert(civil_second(-292277022657, 1, 27, 22, 29, 51), east);
  EXPECT_EQ(time_point<absl::time_internal::cctz::seconds>::min(), tp);
  tp = convert(civil_second::min(), east);
  EXPECT_EQ(time_point<absl::time_internal::cctz::seconds>::min(), tp);

  // Checks that we can also get the minimal value for a far-west zone.
  tp = convert(civil_second(-292277022657, 1, 26, 18, 29, 52), west);
  EXPECT_EQ("-292277022657-01-26T18:29:52-14:00",
            absl::time_internal::cctz::format(RFC3339, tp, west));
  EXPECT_EQ(time_point<absl::time_internal::cctz::seconds>::min(), tp);
  tp = convert(civil_second(-292277022657, 1, 26, 18, 29, 51), west);
  EXPECT_EQ(time_point<absl::time_internal::cctz::seconds>::min(), tp);
  tp = convert(civil_second::min(), west);
  EXPECT_EQ(time_point<absl::time_internal::cctz::seconds>::min(), tp);

  // Some similar checks for the "libc" time-zone implementation.
  if (sizeof(std::time_t) >= 8) {
    // Checks that "tm_year + 1900", as used by the "libc" implementation,
    // can produce year values beyond the range on an int without overflow.
#if defined(_WIN32) || defined(_WIN64)
    // localtime_s() and gmtime_s() don't believe in years outside [1970:3000].
#else
    const time_zone cut = LoadZone("libc:UTC");
    const year_t max_tm_year = year_t{std::numeric_limits<int>::max()} + 1900;
    tp = convert(civil_second(max_tm_year, 12, 31, 23, 59, 59), cut);
#if defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__EMSCRIPTEN__)
    // Some gmtime_r() impls fail on extreme positive values.
#else
    EXPECT_EQ("2147485547-12-31T23:59:59+00:00",
              absl::time_internal::cctz::format(RFC3339, tp, cut));
#endif
    const year_t min_tm_year = year_t{std::numeric_limits<int>::min()} + 1900;
    tp = convert(civil_second(min_tm_year, 1, 1, 0, 0, 0), cut);
#if defined(__Fuchsia__) || defined(__EMSCRIPTEN__)
    // Some gmtime_r() impls fail on extreme negative values (fxbug.dev/78527).
#else
    EXPECT_EQ("-2147481748-01-01T00:00:00+00:00",
              absl::time_internal::cctz::format(RFC3339, tp, cut));
#endif
#endif
  }
}

TEST(MakeTime, LocalTimeLibC) {
  // Checks that cctz and libc agree on transition points in [1970:2037].
  //
  // We limit this test case to environments where:
  //  1) we know how to change the time zone used by localtime()/mktime(),
  //  2) cctz and localtime()/mktime() will use similar-enough tzdata, and
  //  3) we have some idea about how mktime() behaves during transitions.
#if defined(__linux__) && defined(__GLIBC__) && !defined(__ANDROID__)
  const char* const ep = getenv("TZ");
  std::string tz_name = (ep != nullptr) ? ep : "";
  for (const char* const* np = kTimeZoneNames; *np != nullptr; ++np) {
    ASSERT_EQ(0, setenv("TZ", *np, 1));  // change what "localtime" means
    const auto zi = local_time_zone();
    const auto lc = LoadZone("libc:localtime");
    time_zone::civil_transition transition;
    for (auto tp = zi.lookup(civil_second()).trans;
         zi.next_transition(tp, &transition);
         tp = zi.lookup(transition.to).trans) {
      const auto fcl = zi.lookup(transition.from);
      const auto tcl = zi.lookup(transition.to);
      civil_second cs, us;  // compare cs and us in zi and lc
      if (fcl.kind == time_zone::civil_lookup::UNIQUE) {
        if (tcl.kind == time_zone::civil_lookup::UNIQUE) {
          // Both unique; must be an is_dst or abbr change.
          ASSERT_EQ(transition.from, transition.to);
          const auto trans = fcl.trans;
          const auto tal = zi.lookup(trans);
          const auto tprev = trans - absl::time_internal::cctz::seconds(1);
          const auto pal = zi.lookup(tprev);
          if (pal.is_dst == tal.is_dst) {
            ASSERT_STRNE(pal.abbr, tal.abbr);
          }
          continue;
        }
        ASSERT_EQ(time_zone::civil_lookup::REPEATED, tcl.kind);
        cs = transition.to;
        us = transition.from;
      } else {
        ASSERT_EQ(time_zone::civil_lookup::UNIQUE, tcl.kind);
        ASSERT_EQ(time_zone::civil_lookup::SKIPPED, fcl.kind);
        cs = transition.from;
        us = transition.to;
      }
      if (us.year() > 2037) break;  // limit test time (and to 32-bit time_t)
      const auto cl_zi = zi.lookup(cs);
      if (zi.lookup(cl_zi.pre).is_dst == zi.lookup(cl_zi.post).is_dst) {
        // The "libc" implementation cannot correctly classify transitions
        // that don't change the "tm_isdst" flag.  In Europe/Volgograd, for
        // example, there is a SKIPPED transition from +03 to +04 with dst=F
        // on both sides ...
        //   1540681199 = 2018-10-28 01:59:59 +03:00:00 [dst=F off=10800]
        //   1540681200 = 2018-10-28 03:00:00 +04:00:00 [dst=F off=14400]
        // but std::mktime(2018-10-28 02:00:00, tm_isdst=0) fails, unlike,
        // say, the similar Europe/Chisinau transition from +02 to +03 ...
        //   1521935999 = 2018-03-25 01:59:59 +02:00:00 [dst=F off=7200]
        //   1521936000 = 2018-03-25 03:00:00 +03:00:00 [dst=T off=10800]
        // where std::mktime(2018-03-25 02:00:00, tm_isdst=0) succeeds and
        // returns 1521936000.
        continue;
      }
      if (cs == civil_second(2037, 10, 4, 2, 0, 0)) {
        const std::string tzname = *np;
        if (tzname == "Africa/Casablanca" || tzname == "Africa/El_Aaiun") {
          // The "libc" implementation gets this transition wrong (at least
          // until 2018g when it was removed), returning an offset of 3600
          // instead of 0.  TODO: Revert this when 2018g is ubiquitous.
          continue;
        }
      }
      const auto cl_lc = lc.lookup(cs);
      SCOPED_TRACE(testing::Message() << "For " << cs << " in " << *np);
      EXPECT_EQ(cl_zi.kind, cl_lc.kind);
      EXPECT_EQ(cl_zi.pre, cl_lc.pre);
      EXPECT_EQ(cl_zi.trans, cl_lc.trans);
      EXPECT_EQ(cl_zi.post, cl_lc.post);
      const auto ucl_zi = zi.lookup(us);
      const auto ucl_lc = lc.lookup(us);
      SCOPED_TRACE(testing::Message() << "For " << us << " in " << *np);
      EXPECT_EQ(ucl_zi.kind, ucl_lc.kind);
      EXPECT_EQ(ucl_zi.pre, ucl_lc.pre);
      EXPECT_EQ(ucl_zi.trans, ucl_lc.trans);
      EXPECT_EQ(ucl_zi.post, ucl_lc.post);
    }
  }
  if (ep == nullptr) {
    ASSERT_EQ(0, unsetenv("TZ"));
  } else {
    ASSERT_EQ(0, setenv("TZ", tz_name.c_str(), 1));
  }
#endif
}

TEST(NextTransition, UTC) {
  const auto tz = utc_time_zone();
  time_zone::civil_transition trans;

  auto tp = time_point<absl::time_internal::cctz::seconds>::min();
  EXPECT_FALSE(tz.next_transition(tp, &trans));

  tp = time_point<absl::time_internal::cctz::seconds>::max();
  EXPECT_FALSE(tz.next_transition(tp, &trans));
}

TEST(PrevTransition, UTC) {
  const auto tz = utc_time_zone();
  time_zone::civil_transition trans;

  auto tp = time_point<absl::time_internal::cctz::seconds>::max();
  EXPECT_FALSE(tz.prev_transition(tp, &trans));

  tp = time_point<absl::time_internal::cctz::seconds>::min();
  EXPECT_FALSE(tz.prev_transition(tp, &trans));
}

TEST(NextTransition, AmericaNewYork) {
  const auto tz = LoadZone("America/New_York");
  time_zone::civil_transition trans;

  auto tp = convert(civil_second(2018, 6, 30, 0, 0, 0), tz);
  EXPECT_TRUE(tz.next_transition(tp, &trans));
  EXPECT_EQ(civil_second(2018, 11, 4, 2, 0, 0), trans.from);
  EXPECT_EQ(civil_second(2018, 11, 4, 1, 0, 0), trans.to);

  tp = time_point<absl::time_internal::cctz::seconds>::max();
  EXPECT_FALSE(tz.next_transition(tp, &trans));

  tp = time_point<absl::time_internal::cctz::seconds>::min();
  EXPECT_TRUE(tz.next_transition(tp, &trans));
  if (trans.from == civil_second(1918, 3, 31, 2, 0, 0)) {
    // It looks like the tzdata is only 32 bit (probably macOS),
    // which bottoms out at 1901-12-13T20:45:52+00:00.
    EXPECT_EQ(civil_second(1918, 3, 31, 3, 0, 0), trans.to);
  } else {
    EXPECT_EQ(civil_second(1883, 11, 18, 12, 3, 58), trans.from);
    EXPECT_EQ(civil_second(1883, 11, 18, 12, 0, 0), trans.to);
  }
}

TEST(PrevTransition, AmericaNewYork) {
  const auto tz = LoadZone("America/New_York");
  time_zone::civil_transition trans;

  auto tp = convert(civil_second(2018, 6, 30, 0, 0, 0), tz);
  EXPECT_TRUE(tz.prev_transition(tp, &trans));
  EXPECT_EQ(civil_second(2018, 3, 11, 2, 0, 0), trans.from);
  EXPECT_EQ(civil_second(2018, 3, 11, 3, 0, 0), trans.to);

  tp = time_point<absl::time_internal::cctz::seconds>::min();
  EXPECT_FALSE(tz.prev_transition(tp, &trans));

  tp = time_point<absl::time_internal::cctz::seconds>::max();
  EXPECT_TRUE(tz.prev_transition(tp, &trans));
  // We have a transition but we don't know which one.
}

TEST(NextTransition, Scan) {
  for (const char* const* np = kTimeZoneNames; *np != nullptr; ++np) {
    SCOPED_TRACE(testing::Message() << "In " << *np);
    time_zone tz;
    // EXPECT_TRUE(load_time_zone(*np, &tz));
    if (!load_time_zone(*np, &tz)) {
      continue;  // tolerate kTimeZoneNames/zoneinfo skew
    }

    auto tp = time_point<absl::time_internal::cctz::seconds>::min();
    time_zone::civil_transition trans;
    while (tz.next_transition(tp, &trans)) {
      time_zone::civil_lookup from_cl = tz.lookup(trans.from);
      EXPECT_NE(from_cl.kind, time_zone::civil_lookup::REPEATED);
      time_zone::civil_lookup to_cl = tz.lookup(trans.to);
      EXPECT_NE(to_cl.kind, time_zone::civil_lookup::SKIPPED);

      auto trans_tp = to_cl.trans;
      time_zone::absolute_lookup trans_al = tz.lookup(trans_tp);
      EXPECT_EQ(trans_al.cs, trans.to);
      auto pre_trans_tp = trans_tp - absl::time_internal::cctz::seconds(1);
      time_zone::absolute_lookup pre_trans_al = tz.lookup(pre_trans_tp);
      EXPECT_EQ(pre_trans_al.cs + 1, trans.from);

      auto offset_delta = trans_al.offset - pre_trans_al.offset;
      EXPECT_EQ(offset_delta, trans.to - trans.from);
      if (offset_delta == 0) {
        // This "transition" is only an is_dst or abbr change.
        EXPECT_EQ(to_cl.kind, time_zone::civil_lookup::UNIQUE);
        if (trans_al.is_dst == pre_trans_al.is_dst) {
          EXPECT_STRNE(trans_al.abbr, pre_trans_al.abbr);
        }
      }

      tp = trans_tp;  // continue scan from transition
    }
  }
}

TEST(TimeZoneEdgeCase, AmericaNewYork) {
  const time_zone tz = LoadZone("America/New_York");

  // Spring 1:59:59 -> 3:00:00
  auto tp = convert(civil_second(2013, 3, 10, 1, 59, 59), tz);
  ExpectTime(tp, tz, 2013, 3, 10, 1, 59, 59, -5 * 3600, false, "EST");
  tp += absl::time_internal::cctz::seconds(1);
  ExpectTime(tp, tz, 2013, 3, 10, 3, 0, 0, -4 * 3600, true, "EDT");

  // Fall 1:59:59 -> 1:00:00
  tp = convert(civil_second(2013, 11, 3, 1, 59, 59), tz);
  ExpectTime(tp, tz, 2013, 11, 3, 1, 59, 59, -4 * 3600, true, "EDT");
  tp += absl::time_internal::cctz::seconds(1);
  ExpectTime(tp, tz, 2013, 11, 3, 1, 0, 0, -5 * 3600, false, "EST");
}

TEST(TimeZoneEdgeCase, AmericaLosAngeles) {
  const time_zone tz = LoadZone("America/Los_Angeles");

  // Spring 1:59:59 -> 3:00:00
  auto tp = convert(civil_second(2013, 3, 10, 1, 59, 59), tz);
  ExpectTime(tp, tz, 2013, 3, 10, 1, 59, 59, -8 * 3600, false, "PST");
  tp += absl::time_internal::cctz::seconds(1);
  ExpectTime(tp, tz, 2013, 3, 10, 3, 0, 0, -7 * 3600, true, "PDT");

  // Fall 1:59:59 -> 1:00:00
  tp = convert(civil_second(2013, 11, 3, 1, 59, 59), tz);
  ExpectTime(tp, tz, 2013, 11, 3, 1, 59, 59, -7 * 3600, true, "PDT");
  tp += absl::time_internal::cctz::seconds(1);
  ExpectTime(tp, tz, 2013, 11, 3, 1, 0, 0, -8 * 3600, false, "PST");
}

TEST(TimeZoneEdgeCase, ArizonaNoTransition) {
  const time_zone tz = LoadZone("America/Phoenix");

  // No transition in Spring.
  auto tp = convert(civil_second(2013, 3, 10, 1, 59, 59), tz);
  ExpectTime(tp, tz, 2013, 3, 10, 1, 59, 59, -7 * 3600, false, "MST");
  tp += absl::time_internal::cctz::seconds(1);
  ExpectTime(tp, tz, 2013, 3, 10, 2, 0, 0, -7 * 3600, false, "MST");

  // No transition in Fall.
  tp = convert(civil_second(2013, 11, 3, 1, 59, 59), tz);
  ExpectTime(tp, tz, 2013, 11, 3, 1, 59, 59, -7 * 3600, false, "MST");
  tp += absl::time_internal::cctz::seconds(1);
  ExpectTime(tp, tz, 2013, 11, 3, 2, 0, 0, -7 * 3600, false, "MST");
}

TEST(TimeZoneEdgeCase, AsiaKathmandu) {
  const time_zone tz = LoadZone("Asia/Kathmandu");

  // A non-DST offset change from +0530 to +0545
  //
  //   504901799 == Tue, 31 Dec 1985 23:59:59 +0530 (+0530)
  //   504901800 == Wed,  1 Jan 1986 00:15:00 +0545 (+0545)
  auto tp = convert(civil_second(1985, 12, 31, 23, 59, 59), tz);
  ExpectTime(tp, tz, 1985, 12, 31, 23, 59, 59, 5.5 * 3600, false, "+0530");
  tp += absl::time_internal::cctz::seconds(1);
  ExpectTime(tp, tz, 1986, 1, 1, 0, 15, 0, 5.75 * 3600, false, "+0545");
}

TEST(TimeZoneEdgeCase, PacificChatham) {
  const time_zone tz = LoadZone("Pacific/Chatham");

  // One-hour DST offset changes, but at atypical values
  //
  //   1365256799 == Sun,  7 Apr 2013 03:44:59 +1345 (+1345)
  //   1365256800 == Sun,  7 Apr 2013 02:45:00 +1245 (+1245)
  auto tp = convert(civil_second(2013, 4, 7, 3, 44, 59), tz);
  ExpectTime(tp, tz, 2013, 4, 7, 3, 44, 59, 13.75 * 3600, true, "+1345");
  tp += absl::time_internal::cctz::seconds(1);
  ExpectTime(tp, tz, 2013, 4, 7, 2, 45, 0, 12.75 * 3600, false, "+1245");

  //   1380376799 == Sun, 29 Sep 2013 02:44:59 +1245 (+1245)
  //   1380376800 == Sun, 29 Sep 2013 03:45:00 +1345 (+1345)
  tp = convert(civil_second(2013, 9, 29, 2, 44, 59), tz);
  ExpectTime(tp, tz, 2013, 9, 29, 2, 44, 59, 12.75 * 3600, false, "+1245");
  tp += absl::time_internal::cctz::seconds(1);
  ExpectTime(tp, tz, 2013, 9, 29, 3, 45, 0, 13.75 * 3600, true, "+1345");
}

TEST(TimeZoneEdgeCase, AustraliaLordHowe) {
  const time_zone tz = LoadZone("Australia/Lord_Howe");

  // Half-hour DST offset changes
  //
  //   1365260399 == Sun,  7 Apr 2013 01:59:59 +1100 (+11)
  //   1365260400 == Sun,  7 Apr 2013 01:30:00 +1030 (+1030)
  auto tp = convert(civil_second(2013, 4, 7, 1, 59, 59), tz);
  ExpectTime(tp, tz, 2013, 4, 7, 1, 59, 59, 11 * 3600, true, "+11");
  tp += absl::time_internal::cctz::seconds(1);
  ExpectTime(tp, tz, 2013, 4, 7, 1, 30, 0, 10.5 * 3600, false, "+1030");

  //   1380986999 == Sun,  6 Oct 2013 01:59:59 +1030 (+1030)
  //   1380987000 == Sun,  6 Oct 2013 02:30:00 +1100 (+11)
  tp = convert(civil_second(2013, 10, 6, 1, 59, 59), tz);
  ExpectTime(tp, tz, 2013, 10, 6, 1, 59, 59, 10.5 * 3600, false, "+1030");
  tp += absl::time_internal::cctz::seconds(1);
  ExpectTime(tp, tz, 2013, 10, 6, 2, 30, 0, 11 * 3600, true, "+11");
}

TEST(TimeZoneEdgeCase, PacificApia) {
  const time_zone tz = LoadZone("Pacific/Apia");

  // At the end of December 2011, Samoa jumped forward by one day,
  // skipping 30 December from the local calendar, when the nation
  // moved to the west of the International Date Line.
  //
  // A one-day, non-DST offset change
  //
  //   1325239199 == Thu, 29 Dec 2011 23:59:59 -1000 (-10)
  //   1325239200 == Sat, 31 Dec 2011 00:00:00 +1400 (+14)
  auto tp = convert(civil_second(2011, 12, 29, 23, 59, 59), tz);
  ExpectTime(tp, tz, 2011, 12, 29, 23, 59, 59, -10 * 3600, true, "-10");
  EXPECT_EQ(363, get_yearday(convert(tp, tz)));
  tp += absl::time_internal::cctz::seconds(1);
  ExpectTime(tp, tz, 2011, 12, 31, 0, 0, 0, 14 * 3600, true, "+14");
  EXPECT_EQ(365, get_yearday(convert(tp, tz)));
}

TEST(TimeZoneEdgeCase, AfricaCairo) {
  const time_zone tz = LoadZone("Africa/Cairo");

  if (VersionCmp(tz, "2014c") >= 0) {
    // An interesting case of midnight not existing.
    //
    //   1400191199 == Thu, 15 May 2014 23:59:59 +0200 (EET)
    //   1400191200 == Fri, 16 May 2014 01:00:00 +0300 (EEST)
    auto tp = convert(civil_second(2014, 5, 15, 23, 59, 59), tz);
    ExpectTime(tp, tz, 2014, 5, 15, 23, 59, 59, 2 * 3600, false, "EET");
    tp += absl::time_internal::cctz::seconds(1);
    ExpectTime(tp, tz, 2014, 5, 16, 1, 0, 0, 3 * 3600, true, "EEST");
  }
}

TEST(TimeZoneEdgeCase, AfricaMonrovia) {
  const time_zone tz = LoadZone("Africa/Monrovia");

  if (VersionCmp(tz, "2017b") >= 0) {
    // Strange offset change -00:44:30 -> +00:00:00 (non-DST)
    //
    //   63593069 == Thu,  6 Jan 1972 23:59:59 -0044 (MMT)
    //   63593070 == Fri,  7 Jan 1972 00:44:30 +0000 (GMT)
    auto tp = convert(civil_second(1972, 1, 6, 23, 59, 59), tz);
    ExpectTime(tp, tz, 1972, 1, 6, 23, 59, 59, -44.5 * 60, false, "MMT");
    tp += absl::time_internal::cctz::seconds(1);
    ExpectTime(tp, tz, 1972, 1, 7, 0, 44, 30, 0 * 60, false, "GMT");
  }
}

TEST(TimeZoneEdgeCase, AmericaJamaica) {
  // Jamaica discontinued DST transitions in 1983, and is now at a
  // constant -0500.  This makes it an interesting edge-case target.
  // Note that the 32-bit times used in a (tzh_version == 0) zoneinfo
  // file cannot represent the abbreviation-only transition of 1890,
  // so we ignore the abbreviation by expecting what we received.
  const time_zone tz = LoadZone("America/Jamaica");

  // Before the first transition.
  if (!tz.version().empty() && VersionCmp(tz, "2018d") >= 0) {
    // We avoid the expectations on the -18430 offset below unless we are
    // certain we have commit 907241e (Fix off-by-1 error for Jamaica and
    // T&C before 1913) from 2018d.  TODO: Remove the "version() not empty"
    // part when 2018d is generally available from /usr/share/zoneinfo.
    auto tp = convert(civil_second(1889, 12, 31, 0, 0, 0), tz);
    ExpectTime(tp, tz, 1889, 12, 31, 0, 0, 0, -18430, false,
               tz.lookup(tp).abbr);

    // Over the first (abbreviation-change only) transition.
    //   -2524503170 == Tue, 31 Dec 1889 23:59:59 -0507 (LMT)
    //   -2524503169 == Wed,  1 Jan 1890 00:00:00 -0507 (KMT)
    tp = convert(civil_second(1889, 12, 31, 23, 59, 59), tz);
    ExpectTime(tp, tz, 1889, 12, 31, 23, 59, 59, -18430, false,
               tz.lookup(tp).abbr);
    tp += absl::time_internal::cctz::seconds(1);
    ExpectTime(tp, tz, 1890, 1, 1, 0, 0, 0, -18430, false, "KMT");
  }

  // Over the last (DST) transition.
  //     436341599 == Sun, 30 Oct 1983 01:59:59 -0400 (EDT)
  //     436341600 == Sun, 30 Oct 1983 01:00:00 -0500 (EST)
  auto tp = convert(civil_second(1983, 10, 30, 1, 59, 59), tz);
  ExpectTime(tp, tz, 1983, 10, 30, 1, 59, 59, -4 * 3600, true, "EDT");
  tp += absl::time_internal::cctz::seconds(1);
  ExpectTime(tp, tz, 1983, 10, 30, 1, 0, 0, -5 * 3600, false, "EST");

  // After the last transition.
  tp = convert(civil_second(1983, 12, 31, 23, 59, 59), tz);
  ExpectTime(tp, tz, 1983, 12, 31, 23, 59, 59, -5 * 3600, false, "EST");
}

TEST(TimeZoneEdgeCase, WET) {
  // Cover some non-existent times within forward transitions.
  const time_zone tz = LoadZone("WET");

  // Before the first transition.
  auto tp = convert(civil_second(1977, 1, 1, 0, 0, 0), tz);
  ExpectTime(tp, tz, 1977, 1, 1, 0, 0, 0, 0, false, "WET");

  // Over the first transition.
  //     228877199 == Sun,  3 Apr 1977 00:59:59 +0000 (WET)
  //     228877200 == Sun,  3 Apr 1977 02:00:00 +0100 (WEST)
  tp = convert(civil_second(1977, 4, 3, 0, 59, 59), tz);
  ExpectTime(tp, tz, 1977, 4, 3, 0, 59, 59, 0, false, "WET");
  tp += absl::time_internal::cctz::seconds(1);
  ExpectTime(tp, tz, 1977, 4, 3, 2, 0, 0, 1 * 3600, true, "WEST");

  // A non-existent time within the first transition.
  time_zone::civil_lookup cl1 = tz.lookup(civil_second(1977, 4, 3, 1, 15, 0));
  EXPECT_EQ(time_zone::civil_lookup::SKIPPED, cl1.kind);
  ExpectTime(cl1.pre, tz, 1977, 4, 3, 2, 15, 0, 1 * 3600, true, "WEST");
  ExpectTime(cl1.trans, tz, 1977, 4, 3, 2, 0, 0, 1 * 3600, true, "WEST");
  ExpectTime(cl1.post, tz, 1977, 4, 3, 0, 15, 0, 0 * 3600, false, "WET");

  // A non-existent time within the second forward transition.
  time_zone::civil_lookup cl2 = tz.lookup(civil_second(1978, 4, 2, 1, 15, 0));
  EXPECT_EQ(time_zone::civil_lookup::SKIPPED, cl2.kind);
  ExpectTime(cl2.pre, tz, 1978, 4, 2, 2, 15, 0, 1 * 3600, true, "WEST");
  ExpectTime(cl2.trans, tz, 1978, 4, 2, 2, 0, 0, 1 * 3600, true, "WEST");
  ExpectTime(cl2.post, tz, 1978, 4, 2, 0, 15, 0, 0 * 3600, false, "WET");
}

TEST(TimeZoneEdgeCase, FixedOffsets) {
  const time_zone gmtm5 = LoadZone("Etc/GMT+5");  // -0500
  auto tp = convert(civil_second(1970, 1, 1, 0, 0, 0), gmtm5);
  ExpectTime(tp, gmtm5, 1970, 1, 1, 0, 0, 0, -5 * 3600, false, "-05");
  EXPECT_EQ(chrono::system_clock::from_time_t(5 * 3600), tp);

  const time_zone gmtp5 = LoadZone("Etc/GMT-5");  // +0500
  tp = convert(civil_second(1970, 1, 1, 0, 0, 0), gmtp5);
  ExpectTime(tp, gmtp5, 1970, 1, 1, 0, 0, 0, 5 * 3600, false, "+05");
  EXPECT_EQ(chrono::system_clock::from_time_t(-5 * 3600), tp);
}

TEST(TimeZoneEdgeCase, NegativeYear) {
  // Tests transition from year 0 (aka 1BCE) to year -1.
  const time_zone tz = utc_time_zone();
  auto tp = convert(civil_second(0, 1, 1, 0, 0, 0), tz);
  ExpectTime(tp, tz, 0, 1, 1, 0, 0, 0, 0 * 3600, false, "UTC");
  EXPECT_EQ(weekday::saturday, get_weekday(convert(tp, tz)));
  tp -= absl::time_internal::cctz::seconds(1);
  ExpectTime(tp, tz, -1, 12, 31, 23, 59, 59, 0 * 3600, false, "UTC");
  EXPECT_EQ(weekday::friday, get_weekday(convert(tp, tz)));
}

TEST(TimeZoneEdgeCase, UTC32bitLimit) {
  const time_zone tz = utc_time_zone();

  // Limits of signed 32-bit time_t
  //
  //   2147483647 == Tue, 19 Jan 2038 03:14:07 +0000 (UTC)
  //   2147483648 == Tue, 19 Jan 2038 03:14:08 +0000 (UTC)
  auto tp = convert(civil_second(2038, 1, 19, 3, 14, 7), tz);
  ExpectTime(tp, tz, 2038, 1, 19, 3, 14, 7, 0 * 3600, false, "UTC");
  tp += absl::time_internal::cctz::seconds(1);
  ExpectTime(tp, tz, 2038, 1, 19, 3, 14, 8, 0 * 3600, false, "UTC");
}

TEST(TimeZoneEdgeCase, UTC5DigitYear) {
  const time_zone tz = utc_time_zone();

  // Rollover to 5-digit year
  //
  //   253402300799 == Fri, 31 Dec 9999 23:59:59 +0000 (UTC)
  //   253402300800 == Sat,  1 Jan 1000 00:00:00 +0000 (UTC)
  auto tp = convert(civil_second(9999, 12, 31, 23, 59, 59), tz);
  ExpectTime(tp, tz, 9999, 12, 31, 23, 59, 59, 0 * 3600, false, "UTC");
  tp += absl::time_internal::cctz::seconds(1);
  ExpectTime(tp, tz, 10000, 1, 1, 0, 0, 0, 0 * 3600, false, "UTC");
}

}  // namespace cctz
}  // namespace time_internal
ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/src/time_zone_posix.cc           0000664 0000000 0000000 00000011274 14746647661 0031371 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

#include "time_zone_posix.h"

#include <cstddef>
#include <cstring>
#include <limits>
#include <string>

#include "absl/base/config.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {
namespace cctz {

namespace {

const char kDigits[] = "0123456789";

const char* ParseInt(const char* p, int min, int max, int* vp) {
  int value = 0;
  const char* op = p;
  const int kMaxInt = std::numeric_limits<int>::max();
  for (; const char* dp = strchr(kDigits, *p); ++p) {
    int d = static_cast<int>(dp - kDigits);
    if (d >= 10) break;  // '\0'
    if (value > kMaxInt / 10) return nullptr;
    value *= 10;
    if (value > kMaxInt - d) return nullptr;
    value += d;
  }
  if (p == op || value < min || value > max) return nullptr;
  *vp = value;
  return p;
}

// abbr = <.*?> | [^-+,\d]{3,}
const char* ParseAbbr(const char* p, std::string* abbr) {
  const char* op = p;
  if (*p == '<') {  // special zoneinfo <...> form
    while (*++p != '>') {
      if (*p == '\0') return nullptr;
    }
    abbr->assign(op + 1, static_cast<std::size_t>(p - op) - 1);
    return ++p;
  }
  while (*p != '\0') {
    if (strchr("-+,", *p)) break;
    if (strchr(kDigits, *p)) break;
    ++p;
  }
  if (p - op < 3) return nullptr;
  abbr->assign(op, static_cast<std::size_t>(p - op));
  return p;
}

// offset = [+|-]hh[:mm[:ss]] (aggregated into single seconds value)
const char* ParseOffset(const char* p, int min_hour, int max_hour, int sign,
                        std::int_fast32_t* offset) {
  if (p == nullptr) return nullptr;
  if (*p == '+' || *p == '-') {
    if (*p++ == '-') sign = -sign;
  }
  int hours = 0;
  int minutes = 0;
  int seconds = 0;

  p = ParseInt(p, min_hour, max_hour, &hours);
  if (p == nullptr) return nullptr;
  if (*p == ':') {
    p = ParseInt(p + 1, 0, 59, &minutes);
    if (p == nullptr) return nullptr;
    if (*p == ':') {
      p = ParseInt(p + 1, 0, 59, &seconds);
      if (p == nullptr) return nullptr;
    }
  }
  *offset = sign * ((((hours * 60) + minutes) * 60) + seconds);
  return p;
}

// datetime = ( Jn | n | Mm.w.d ) [ / offset ]
const char* ParseDateTime(const char* p, PosixTransition* res) {
  if (p != nullptr && *p == ',') {
    if (*++p == 'M') {
      int month = 0;
      if ((p = ParseInt(p + 1, 1, 12, &month)) != nullptr && *p == '.') {
        int week = 0;
        if ((p = ParseInt(p + 1, 1, 5, &week)) != nullptr && *p == '.') {
          int weekday = 0;
          if ((p = ParseInt(p + 1, 0, 6, &weekday)) != nullptr) {
            res->date.fmt = PosixTransition::M;
            res->date.m.month = static_cast<std::int_fast8_t>(month);
            res->date.m.week = static_cast<std::int_fast8_t>(week);
            res->date.m.weekday = static_cast<std::int_fast8_t>(weekday);
          }
        }
      }
    } else if (*p == 'J') {
      int day = 0;
      if ((p = ParseInt(p + 1, 1, 365, &day)) != nullptr) {
        res->date.fmt = PosixTransition::J;
        res->date.j.day = static_cast<std::int_fast16_t>(day);
      }
    } else {
      int day = 0;
      if ((p = ParseInt(p, 0, 365, &day)) != nullptr) {
        res->date.fmt = PosixTransition::N;
        res->date.n.day = static_cast<std::int_fast16_t>(day);
      }
    }
  }
  if (p != nullptr) {
    res->time.offset = 2 * 60 * 60;  // default offset is 02:00:00
    if (*p == '/') p = ParseOffset(p + 1, -167, 167, 1, &res->time.offset);
  }
  return p;
}

}  // namespace

// spec = std offset [ dst [ offset ] , datetime , datetime ]
bool ParsePosixSpec(const std::string& spec, PosixTimeZone* res) {
  const char* p = spec.c_str();
  if (*p == ':') return false;

  p = ParseAbbr(p, &res->std_abbr);
  p = ParseOffset(p, 0, 24, -1, &res->std_offset);
  if (p == nullptr) return false;
  if (*p == '\0') return true;

  p = ParseAbbr(p, &res->dst_abbr);
  if (p == nullptr) return false;
  res->dst_offset = res->std_offset + (60 * 60);  // default
  if (*p != ',') p = ParseOffset(p, 0, 24, -1, &res->dst_offset);

  p = ParseDateTime(p, &res->dst_start);
  p = ParseDateTime(p, &res->dst_end);

  return p != nullptr && *p == '\0';
}

}  // namespace cctz
}  // namespace time_internal
ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                                                                                                    node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/src/time_zone_posix.h            0000664 0000000 0000000 00000007667 14746647661 0031246 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

// Parsing of a POSIX zone spec as described in the TZ part of section 8.3 in
// http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html.
//
// The current POSIX spec for America/Los_Angeles is "PST8PDT,M3.2.0,M11.1.0",
// which would be broken down as ...
//
//   PosixTimeZone {
//     std_abbr = "PST"
//     std_offset = -28800
//     dst_abbr = "PDT"
//     dst_offset = -25200
//     dst_start = PosixTransition {
//       date {
//         m {
//           month = 3
//           week = 2
//           weekday = 0
//         }
//       }
//       time {
//         offset = 7200
//       }
//     }
//     dst_end = PosixTransition {
//       date {
//         m {
//           month = 11
//           week = 1
//           weekday = 0
//         }
//       }
//       time {
//         offset = 7200
//       }
//     }
//   }

#ifndef ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_POSIX_H_
#define ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_POSIX_H_

#include <cstdint>
#include <string>

#include "absl/base/config.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {
namespace cctz {

// The date/time of the transition. The date is specified as either:
// (J) the Nth day of the year (1 <= N <= 365), excluding leap days, or
// (N) the Nth day of the year (0 <= N <= 365), including leap days, or
// (M) the Nth weekday of a month (e.g., the 2nd Sunday in March).
// The time, specified as a day offset, identifies the particular moment
// of the transition, and may be negative or >= 24h, and in which case
// it would take us to another day, and perhaps week, or even month.
struct PosixTransition {
  enum DateFormat { J, N, M };

  struct Date {
    struct NonLeapDay {
      std::int_fast16_t day;  // day of non-leap year [1:365]
    };
    struct Day {
      std::int_fast16_t day;  // day of year [0:365]
    };
    struct MonthWeekWeekday {
      std::int_fast8_t month;    // month of year [1:12]
      std::int_fast8_t week;     // week of month [1:5] (5==last)
      std::int_fast8_t weekday;  // 0==Sun, ..., 6=Sat
    };

    DateFormat fmt;

    union {
      NonLeapDay j;
      Day n;
      MonthWeekWeekday m;
    };
  };

  struct Time {
    std::int_fast32_t offset;  // seconds before/after 00:00:00
  };

  Date date;
  Time time;
};

// The entirety of a POSIX-string specified time-zone rule. The standard
// abbreviation and offset are always given. If the time zone includes
// daylight saving, then the daylight abbreviation is non-empty and the
// remaining fields are also valid. Note that the start/end transitions
// are not ordered---in the southern hemisphere the transition to end
// daylight time occurs first in any particular year.
struct PosixTimeZone {
  std::string std_abbr;
  std::int_fast32_t std_offset;

  std::string dst_abbr;
  std::int_fast32_t dst_offset;
  PosixTransition dst_start;
  PosixTransition dst_end;
};

// Breaks down a POSIX time-zone specification into its constituent pieces,
// filling in any missing values (DST offset, or start/end transition times)
// with the standard-defined defaults. Returns false if the specification
// could not be parsed (although some fields of *res may have been altered).
bool ParsePosixSpec(const std::string& spec, PosixTimeZone* res);

}  // namespace cctz
}  // namespace time_internal
ABSL_NAMESPACE_END
}  // namespace absl

#endif  // ABSL_TIME_INTERNAL_CCTZ_TIME_ZONE_POSIX_H_
                                                                         node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/src/tzfile.h                     0000664 0000000 0000000 00000010060 14746647661 0027305 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /* Layout and location of TZif files.  */

#ifndef TZFILE_H

#define TZFILE_H

/*
** This file is in the public domain, so clarified as of
** 1996-06-05 by Arthur David Olson.
*/

/*
** This header is for use ONLY with the time conversion code.
** There is no guarantee that it will remain unchanged,
** or that it will remain at all.
** Do NOT copy it to any system include directory.
** Thank you!
*/

/*
** Information about time zone files.
*/

#ifndef TZDEFRULES
#define TZDEFRULES "posixrules"
#endif /* !defined TZDEFRULES */

/* See Internet RFC 8536 for more details about the following format.  */

/*
** Each file begins with. . .
*/

#define TZ_MAGIC "TZif"

struct tzhead {
  char tzh_magic[4];      /* TZ_MAGIC */
  char tzh_version[1];    /* '\0' or '2'-'4' as of 2021 */
  char tzh_reserved[15];  /* reserved; must be zero */
  char tzh_ttisutcnt[4];  /* coded number of trans. time flags */
  char tzh_ttisstdcnt[4]; /* coded number of trans. time flags */
  char tzh_leapcnt[4];    /* coded number of leap seconds */
  char tzh_timecnt[4];    /* coded number of transition times */
  char tzh_typecnt[4];    /* coded number of local time types */
  char tzh_charcnt[4];    /* coded number of abbr. chars */
};

/*
** . . .followed by. . .
**
**	tzh_timecnt (char [4])s		coded transition times a la time(2)
**	tzh_timecnt (unsigned char)s	types of local time starting at above
**	tzh_typecnt repetitions of
**		one (char [4])		coded UT offset in seconds
**		one (unsigned char)	used to set tm_isdst
**		one (unsigned char)	that's an abbreviation list index
**	tzh_charcnt (char)s		'\0'-terminated zone abbreviations
**	tzh_leapcnt repetitions of
**		one (char [4])		coded leap second transition times
**		one (char [4])		total correction after above
**	tzh_ttisstdcnt (char)s		indexed by type; if 1, transition
**					time is standard time, if 0,
**					transition time is local (wall clock)
**					time; if absent, transition times are
**					assumed to be local time
**	tzh_ttisutcnt (char)s		indexed by type; if 1, transition
**					time is UT, if 0, transition time is
**					local time; if absent, transition
**					times are assumed to be local time.
**					When this is 1, the corresponding
**					std/wall indicator must also be 1.
*/

/*
** If tzh_version is '2' or greater, the above is followed by a second instance
** of tzhead and a second instance of the data in which each coded transition
** time uses 8 rather than 4 chars,
** then a POSIX-TZ-environment-variable-style string for use in handling
** instants after the last transition time stored in the file
** (with nothing between the newlines if there is no POSIX.1-2017
** representation for such instants).
**
** If tz_version is '3' or greater, the above is extended as follows.
** First, the TZ string's hour offset may range from -167
** through 167 as compared to the POSIX-required 0 through 24.
** Second, its DST start time may be January 1 at 00:00 and its stop
** time December 31 at 24:00 plus the difference between DST and
** standard time, indicating DST all year.
*/

/*
** In the current implementation, "tzset()" refuses to deal with files that
** exceed any of the limits below.
*/

#ifndef TZ_MAX_TIMES
/* This must be at least 242 for Europe/London with 'zic -b fat'.  */
#define TZ_MAX_TIMES 2000
#endif /* !defined TZ_MAX_TIMES */

#ifndef TZ_MAX_TYPES
/* This must be at least 18 for Europe/Vilnius with 'zic -b fat'.  */
#define TZ_MAX_TYPES 256 /* Limited by what (unsigned char)'s can hold */
#endif                   /* !defined TZ_MAX_TYPES */

#ifndef TZ_MAX_CHARS
/* This must be at least 40 for America/Anchorage.  */
#define TZ_MAX_CHARS 50 /* Maximum number of abbreviation characters */
                        /* (limited by what unsigned chars can hold) */
#endif                  /* !defined TZ_MAX_CHARS */

#ifndef TZ_MAX_LEAPS
/* This must be at least 27 for leap seconds from 1972 through mid-2023.
   There's a plan to discontinue leap seconds by 2035.  */
#define TZ_MAX_LEAPS 50 /* Maximum number of leap second corrections */
#endif                  /* !defined TZ_MAX_LEAPS */

#endif /* !defined TZFILE_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/src/zone_info_source.cc          0000664 0000000 0000000 00000015302 14746647661 0031520 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   https://www.apache.org/licenses/LICENSE-2.0
//
//   Unless required by applicable law or agreed to in writing, software
//   distributed under the License is distributed on an "AS IS" BASIS,
//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//   See the License for the specific language governing permissions and
//   limitations under the License.

#include "absl/time/internal/cctz/include/cctz/zone_info_source.h"

#include "absl/base/config.h"

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {
namespace cctz {

// Defined out-of-line to avoid emitting a weak vtable in all TUs.
ZoneInfoSource::~ZoneInfoSource() {}
std::string ZoneInfoSource::Version() const { return std::string(); }

}  // namespace cctz
}  // namespace time_internal
ABSL_NAMESPACE_END
}  // namespace absl

namespace absl {
ABSL_NAMESPACE_BEGIN
namespace time_internal {
namespace cctz_extension {

namespace {

// A default for cctz_extension::zone_info_source_factory, which simply
// defers to the fallback factory.
std::unique_ptr<absl::time_internal::cctz::ZoneInfoSource> DefaultFactory(
    const std::string& name,
    const std::function<
        std::unique_ptr<absl::time_internal::cctz::ZoneInfoSource>(
            const std::string& name)>& fallback_factory) {
  return fallback_factory(name);
}

}  // namespace

// A "weak" definition for cctz_extension::zone_info_source_factory.
// The user may override this with their own "strong" definition (see
// zone_info_source.h).
#if !defined(__has_attribute)
#define __has_attribute(x) 0
#endif
// MinGW is GCC on Windows, so while it asserts __has_attribute(weak), the
// Windows linker cannot handle that. Nor does the MinGW compiler know how to
// pass "#pragma comment(linker, ...)" to the Windows linker.
#if (__has_attribute(weak) || defined(__GNUC__)) && !defined(__MINGW32__) && \
    !defined(__CYGWIN__)
ZoneInfoSourceFactory zone_info_source_factory __attribute__((weak)) =
    DefaultFactory;
#elif defined(_MSC_VER) && !defined(__MINGW32__) && !defined(_LIBCPP_VERSION)
extern ZoneInfoSourceFactory zone_info_source_factory;
extern ZoneInfoSourceFactory default_factory;
ZoneInfoSourceFactory default_factory = DefaultFactory;
#if defined(_M_IX86) || defined(_M_ARM)
#pragma comment(                                                                                                         \
    linker,                                                                                                              \
    "/alternatename:?zone_info_source_factory@cctz_extension@time_internal@" ABSL_INTERNAL_MANGLED_NS                    \
    "@@3P6A?AV?$unique_ptr@VZoneInfoSource@cctz@time_internal@" ABSL_INTERNAL_MANGLED_NS                                 \
    "@@U?$default_delete@VZoneInfoSource@cctz@time_internal@" ABSL_INTERNAL_MANGLED_NS                                   \
    "@@@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@" ABSL_INTERNAL_MANGLED_BACKREFERENCE      \
    "@ABV?$function@$$A6A?AV?$unique_ptr@VZoneInfoSource@cctz@time_internal@" ABSL_INTERNAL_MANGLED_NS                   \
    "@@U?$default_delete@VZoneInfoSource@cctz@time_internal@" ABSL_INTERNAL_MANGLED_NS                                   \
    "@@@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@" ABSL_INTERNAL_MANGLED_BACKREFERENCE \
    "@@ZA=?default_factory@cctz_extension@time_internal@" ABSL_INTERNAL_MANGLED_NS                                       \
    "@@3P6A?AV?$unique_ptr@VZoneInfoSource@cctz@time_internal@" ABSL_INTERNAL_MANGLED_NS                                 \
    "@@U?$default_delete@VZoneInfoSource@cctz@time_internal@" ABSL_INTERNAL_MANGLED_NS                                   \
    "@@@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@" ABSL_INTERNAL_MANGLED_BACKREFERENCE      \
    "@ABV?$function@$$A6A?AV?$unique_ptr@VZoneInfoSource@cctz@time_internal@" ABSL_INTERNAL_MANGLED_NS                   \
    "@@U?$default_delete@VZoneInfoSource@cctz@time_internal@" ABSL_INTERNAL_MANGLED_NS                                   \
    "@@@std@@@std@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@" ABSL_INTERNAL_MANGLED_BACKREFERENCE \
    "@@ZA")
#elif defined(_M_IA_64) || defined(_M_AMD64) || defined(_M_ARM64)
#pragma comment(                                                                                                          \
    linker,                                                                                                               \
    "/alternatename:?zone_info_source_factory@cctz_extension@time_internal@" ABSL_INTERNAL_MANGLED_NS                     \
    "@@3P6A?AV?$unique_ptr@VZoneInfoSource@cctz@time_internal@" ABSL_INTERNAL_MANGLED_NS                                  \
    "@@U?$default_delete@VZoneInfoSource@cctz@time_internal@" ABSL_INTERNAL_MANGLED_NS                                    \
    "@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@" ABSL_INTERNAL_MANGLED_BACKREFERENCE      \
    "@AEBV?$function@$$A6A?AV?$unique_ptr@VZoneInfoSource@cctz@time_internal@" ABSL_INTERNAL_MANGLED_NS                   \
    "@@U?$default_delete@VZoneInfoSource@cctz@time_internal@" ABSL_INTERNAL_MANGLED_NS                                    \
    "@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@" ABSL_INTERNAL_MANGLED_BACKREFERENCE \
    "@@ZEA=?default_factory@cctz_extension@time_internal@" ABSL_INTERNAL_MANGLED_NS                                       \
    "@@3P6A?AV?$unique_ptr@VZoneInfoSource@cctz@time_internal@" ABSL_INTERNAL_MANGLED_NS                                  \
    "@@U?$default_delete@VZoneInfoSource@cctz@time_internal@" ABSL_INTERNAL_MANGLED_NS                                    \
    "@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@" ABSL_INTERNAL_MANGLED_BACKREFERENCE      \
    "@AEBV?$function@$$A6A?AV?$unique_ptr@VZoneInfoSource@cctz@time_internal@" ABSL_INTERNAL_MANGLED_NS                   \
    "@@U?$default_delete@VZoneInfoSource@cctz@time_internal@" ABSL_INTERNAL_MANGLED_NS                                    \
    "@@@std@@@std@@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@" ABSL_INTERNAL_MANGLED_BACKREFERENCE \
    "@@ZEA")
#else
#error Unsupported MSVC platform
#endif  // _M_<PLATFORM>
#else
// Make it a "strong" definition if we have no other choice.
ZoneInfoSourceFactory zone_info_source_factory = DefaultFactory;
#endif

}  // namespace cctz_extension
}  // namespace time_internal
ABSL_NAMESPACE_END
}  // namespace absl
                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/                        0000775 0000000 0000000 00000000000 14746647661 0026664 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/README.zoneinfo         0000664 0000000 0000000 00000002645 14746647661 0031401 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        testdata/zoneinfo contains time-zone data files that may be used with CCTZ.
Install them in a location referenced by the ${TZDIR} environment variable.
Symbolic and hard links have been eliminated for portability.

On Linux systems the distribution's versions of these files can probably
already be found in the default ${TZDIR} location, /usr/share/zoneinfo.

New versions can be generated using the following shell script.

  #!/bin/sh -
  set -e
  DESTDIR=$(mktemp -d)
  trap "rm -fr ${DESTDIR}" 0 2 15
  (
    cd ${DESTDIR}
    git clone https://github.com/eggert/tz.git
    make --directory=tz \
        install DESTDIR=${DESTDIR} \
                DATAFORM=vanguard \
                TZDIR=/zoneinfo \
                REDO=posix_only \
                LOCALTIME=Factory \
                TZDATA_TEXT= \
                PACKRATDATA=backzone PACKRATLIST=zone.tab \
                ZONETABLES=zone1970.tab\ zonenow.tab
    tar --create --dereference --hard-dereference --file tzfile.tar \
        --directory=tz tzfile.h
    tar --create --dereference --hard-dereference --file zoneinfo.tar \
        --exclude=zoneinfo/posixrules zoneinfo \
        --directory=tz version
  )
  tar --extract --directory src --file ${DESTDIR}/tzfile.tar
  tar --extract --directory testdata --file ${DESTDIR}/zoneinfo.tar
  exit 0

To run the CCTZ tests using the testdata/zoneinfo files, execute:

  bazel test --test_env=TZDIR=${PWD}/testdata/zoneinfo ...
                                                                                           node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/version                 0000664 0000000 0000000 00000000006 14746647661 0030270 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        2024a
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/               0000775 0000000 0000000 00000000000 14746647661 0030513 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/        0000775 0000000 0000000 00000000000 14746647661 0031700 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Abidjan 0000664 0000000 0000000 00000000202 14746647661 0033145 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    H8       LMT GMT 
GMT0
                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Accra   0000664 0000000 0000000 00000001274 14746647661 0032640 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              =      44i p2 yp [p<} p^Q#@"
 p=q Cp gp)H] */pjbM.I p|N p1tp@ U:<x B#ecF '	.          
     LMT +0020 GMT +0030 
GMT0
                                                                                                                                                                                                                                                                                                                                    Addis_Ababa                                                                                         0000664 0000000 0000000 00000000227 14746647661 0033637 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa                                                                            TZif2                                            TZif2                                    C  $H    $h   *0 	LMT ADMT EAT 
EAT-3
                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Algiers 0000664 0000000 0000000 00000000726 14746647661 0033216 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              "      k$`POGx,ppHp*`.zL5ppX	4  rN$pKp \    x    C         D    xZ     hY    vCp    fB    _|    O_       1              LMT PMT WEST WET CEST CET 
CET-1
                                          node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Asmara  0000664 0000000 0000000 00000000252 14746647661 0033026 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    Ci  $t    $t   $h   *0 LMT AMT ADMT EAT 
EAT-3
                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Asmera  0000664 0000000 0000000 00000000252 14746647661 0033032 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    Ci  $t    $t   $h   *0 LMT AMT ADMT EAT 
EAT-3
                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Bamako  0000664 0000000 0000000 00000000236 14746647661 0033016 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                             LMT GMT -01 
GMT0
                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Bangui  0000664 0000000 0000000 00000000203 14746647661 0033023 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    }  l     LMT WAT 
WAT-1
                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Banjul  0000664 0000000 0000000 00000000250 14746647661 0033033 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    g~d  d       LMT BMT -01 GMT 
GMT0
                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Bissau  0000664 0000000 0000000 00000000225 14746647661 0033050 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                        	gad        LMT -01 GMT 
GMT0
                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Blantyre0000664 0000000 0000000 00000000245 14746647661 0033404 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    ,0sIt       !   !     LMT ZMT CAT 
CAT-2
                                                                                                                                                                                                                                                                                                                                                           Brazzaville                                                                                         0000664 0000000 0000000 00000000203 14746647661 0034024 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa                                                                            TZif2                                            TZif2                                    ,  T     LMT WAT 
WAT-1
                                                                                                                                                                                                                                                                                                                                                                                             Bujumbura                                                                                           0000664 0000000 0000000 00000000203 14746647661 0033473 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa                                                                            TZif2                                            TZif2                                    i        LMT CAT 
CAT-2
                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Cairo   0000664 0000000 0000000 00000002435 14746647661 0032664 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    }M{`)fy`P6c`-P``m  py%ZY sp;Up6E p 9p      %    g    Yp    I     ap    +     C        $Ep    	     
x    
<            1p         d    t(    p    U\     np    7     OP            H     p    {    <         pp    4         g     p    !a     "z\p    #D      $b'p    %%S    &<p    '     (    (    * {    *?    +p    ,s     -    .    /    0k    1    2J    3_    4*    5?    6
    7(`    7P    9`    9P    :`    ;P    <|`    =uP    >^`    ?sWP    @z    A\s    Bq\    C<U    DQ>    EP    F1     FjP    H    H    I    JP    K`    La    LX    LP    Su8    S    S`    T$P    dJ`  U    *0    	LMT EEST EET 
EET-2EEST,M4.5.5/0,M10.5.4/24
                                                                                                                                                                                                                                   Casablanca                                                                                          0000664 0000000 0000000 00000003577 14746647661 0033570 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa                                                                            TZif2                                            TZif2                                    QXp25 '%r@p    k    m         aG    ?    p    Q    'p         o    HA    H"p    J#     Jp    K    L]p    M    N4    O    P    P1     Pg    Q|    Q    R    Rls    S7z    S!    SF     TLU    U\    U|     U    V,7    V>    WS    W     XT     X     Y     YXS    Y6     Z    Z     [%    [     \C    \h     ^    ^    `rX     `|    b?     bw$     dl    dD     e     f8    g     g     i(    iM     kg     k    m5=     ml     o    o:	     pQ    q    r     r    t    t     vT    vl    x*     xX    y"     z/     {    |(    }q     }    r     =     I    w      -     NQ         $     A    f             hV          >    m"     j    C         6             &        ]         +;     b         9A                  V     |         SF     j          X     Z    %         &    o          r    ;     ?    v    +     DO             ?                 ^T          4    lZ         9         o              _         S     +     *s    X         /?              /    T     r        ID     wh        N     X    $          $    m          h    9     >     l    )     C              x              D                 LMT +01 +00 
<+01>-1
                                                                                                                                 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Ceuta   0000664 0000000 0000000 00000001062 14746647661 0032663 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              +      ~6 upn`pn 2 Op z p0%r@p    k    m         aG    ?    p    Q    'p             |     lr    !\c    "LT    #<E    $,6    %'    &    'C    '4    (%    )    *    +    ,    -    .    /t    0d    1]               LMT WET WEST CET CEST 
CET-1CEST,M3.5.0,M10.5.0/3
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Conakry 0000664 0000000 0000000 00000000236 14746647661 0033232 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    \0$        LMT GMT -01 
GMT0
                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Dakar   0000664 0000000 0000000 00000000225 14746647661 0032644 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    ;        LMT -01 GMT 
GMT0
                                                                                                                                                                                                                                                                                                                                                                           Dar_es_Salaam                                                                                       0000664 0000000 0000000 00000000241 14746647661 0034214 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa                                                                            TZif2                                            TZif2                                    f  $    *0   & LMT EAT +0245 
EAT-3
                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Djibouti0000664 0000000 0000000 00000000203 14746647661 0033367 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                      (t    *0 LMT EAT 
EAT-3
                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Douala  0000664 0000000 0000000 00000000203 14746647661 0033023 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    h  	     LMT WAT 
WAT-1
                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/El_Aaiun0000664 0000000 0000000 00000003446 14746647661 0033307 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    H             aG    ?    p    Q    'p    HA    H"p    J#     Jp    K    L]p    M    N4    O    P    P1     Pg    Q|    Q    R    Rls    S7z    S!    SF     TLU    U\    U|     U    V,7    V>    WS    W     XT     X     Y     YXS    Y6     Z    Z     [%    [     \C    \h     ^    ^    `rX     `|    b?     bw$     dl    dD     e     f8    g     g     i(    iM     kg     k    m5=     ml     o    o:	     pQ    q    r     r    t    t     vT    vl    x*     xX    y"     z/     {    |(    }q     }    r     =     I    w      -     NQ         $     A    f             hV          >    m"     j    C         6             &        ]         +;     b         9A                  V     |         SF     j          X     Z    %         &    o          r    ;     ?    v    +     DO             ?                 ^T          4    lZ         9         o              _         S     +     *s    X         /?              /    T     r        ID     wh        N     X    $          $    m          h    9     >     l    )     C              x              D                  LMT -01 +01 +00 
<+01>-1
                                                                                                                                                                                                                          node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Freetown0000664 0000000 0000000 00000000504 14746647661 0033413 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    Zzl>a`O`jM`Md.;E`nwS``4<         LMT FMT -0040 -01 GMT 
GMT0
                                                                                                                                                                                            node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Gaborone0000664 0000000 0000000 00000000264 14746647661 0033361 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    `p4Fhn~Qp  L         	  *0LMT SAST CAT CAST 
CAT-2
                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Harare  0000664 0000000 0000000 00000000203 14746647661 0033020 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    Fd        LMT CAT 
CAT-2
                                                                                                                                                                                                                                                                                                                                                                                             Johannesburg                                                                                        0000664 0000000 0000000 00000000276 14746647661 0034176 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa                                                                            TZif2                                            TZif2                                    	m{A@Fhopn~Qp  @       *0    LMT SAST 
SAST-2
                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Juba    0000664 0000000 0000000 00000000712 14746647661 0032504 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              #               z4P    }    [g    `~    =    @`     P     B    	 S    
 $    
P        P        ?    `    sP    `    g    h`    J+    H`    +_P    (`        o`    P        KP    m    ~    8E     `P      *0    	  *0 LMT CAST CAT EAT 
CAT-2
                                                      node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Kampala 0000664 0000000 0000000 00000000266 14746647661 0033175 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    GT  d    *0   #(   & LMT EAT +0230 +0245 
EAT-3
                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Khartoum0000664 0000000 0000000 00000000712 14746647661 0033415 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              #                z4P    }    [g    `~    =    @`     P     B    	 S    
 $    
P        P        ?    `    sP    `    g    h`    J+    H`    +_P    (`        o`    P        KP    m    ~    8E     YP      *0    	  *0 LMT CAST CAT EAT 
CAT-2
                                                      node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Kigali  0000664 0000000 0000000 00000000203 14746647661 0033016 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    P  0      LMT CAT 
CAT-2
                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Kinshasa0000664 0000000 0000000 00000000203 14746647661 0033357 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    xM,  X     LMT WAT 
WAT-1
                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Lagos   0000664 0000000 0000000 00000000264 14746647661 0032672 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    pP` CQx   /             LMT GMT +0030 WAT 
WAT-1
                                                                                                                                                                                                                                                                                                                                            Libreville                                                                                          0000664 0000000 0000000 00000000203 14746647661 0033630 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa                                                                            TZif2                                            TZif2                                           LMT WAT 
WAT-1
                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Lome    0000664 0000000 0000000 00000000202 14746647661 0032511 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    o+\  $       LMT GMT 
GMT0
                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Luanda  0000664 0000000 0000000 00000000222 14746647661 0033023 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    mI6p  h    4     LMT WAT 
WAT-1
                                                                                                                                                                                                                                                                                                                                                                              Lubumbashi                                                                                          0000664 0000000 0000000 00000000226 14746647661 0033637 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa                                                                            TZif2                                            TZif2                                    xM!@[           LMT WAT CAT 
CAT-2
                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Lusaka  0000664 0000000 0000000 00000000203 14746647661 0033036 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    F        LMT CAT 
CAT-2
                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Malabo  0000664 0000000 0000000 00000000226 14746647661 0033016 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    D  <          LMT GMT WAT 
WAT-1
                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Maputo  0000664 0000000 0000000 00000000203 14746647661 0033063 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    F        LMT CAT 
CAT-2
                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Maseru  0000664 0000000 0000000 00000000235 14746647661 0033057 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    	Fn~Qp          *0LMT SAST 
SAST-2
                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Mbabane 0000664 0000000 0000000 00000000205 14746647661 0033145 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    	FX  (      LMT SAST 
SAST-2
                                                                                                                                                                                                                                                                                                                                                                                           Mogadishu                                                                                           0000664 0000000 0000000 00000000241 14746647661 0033461 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa                                                                            TZif2                                            TZif2                                    pdPJ  *    *0   #( LMT EAT +0230 
EAT-3
                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Monrovia0000664 0000000 0000000 00000000244 14746647661 0033415 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    Zz_l    Zn         LMT MMT GMT 
GMT0
                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Nairobi 0000664 0000000 0000000 00000000277 14746647661 0033214 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    XXlz  "    #(   *0 
  & LMT +0230 EAT +0245 
EAT-3
                                                                                                                                                                                                                                                                                                                                 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Ndjamena0000664 0000000 0000000 00000000240 14746647661 0033334 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    d    fqp    &`          LMT WAT WAST 
WAT-1
                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Niamey  0000664 0000000 0000000 00000000251 14746647661 0033043 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    0             LMT -01 GMT WAT 
WAT-1
                                                                                                                                                                                                                                                                                                                                                       Nouakchott                                                                                          0000664 0000000 0000000 00000000236 14746647661 0033664 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa                                                                            TZif2                                            TZif2                                    t        LMT GMT -01 
GMT0
                                                                                                                                                                                                                                                                                                                                                                  Ouagadougou                                                                                         0000664 0000000 0000000 00000000202 14746647661 0034015 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa                                                                            TZif2                                            TZif2                                           LMT GMT 
GMT0
                                                                                                                                                                                                                                                                                                                                                                                              Porto-Novo                                                                                          0000664 0000000 0000000 00000000226 14746647661 0033566 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa                                                                            TZif2                                            TZif2                                      t          LMT GMT WAT 
WAT-1
                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Sao_Tome0000664 0000000 0000000 00000000255 14746647661 0033333 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    ^<0    ZI    \*  P  c          LMT GMT WAT 
GMT0
                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Timbuktu0000664 0000000 0000000 00000000236 14746647661 0033430 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                             LMT GMT -01 
GMT0
                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Tripoli 0000664 0000000 0000000 00000000657 14746647661 0033255 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                     $#`xe/?pN    B`    p    +    *    _`        `    z        p    `     pJp    !a~    "Rp    #D    $4    %%7`    &@    2N`    3D6p    45j    P     QT    Ri  \        	    LMT CEST CET EET 
EET-2
                                                                                 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Tunis   0000664 0000000 0000000 00000000701 14746647661 0032723 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              "      YF`PO:X`"TiK 5 4rN`        p    d    tp    ":    #<(    $,    %
    &<p    ''p    Bt    C<     D%    EC    F    G#    G    I  	    1       LMT PMT CEST CET 
CET-1
                                                               node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/Africa/Windhoek0000664 0000000 0000000 00000001176 14746647661 0033400 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              5      m{KxFhop    &    -`    .i    /}     0H    1g    2(    3F    4    5&    5    7    7    8    9    :o    ;    <     =qf    >n     ?Z    @oP     A:e    BO2     CG    D/     D)    F     F    G    H'    I    J	    K    L    M    Nb    Ow    PB    Q`     R"    S@     T    U {     U    W ]     Wr    X?     YT           
  *0
      LMT +0130 SAST WAT CAT 
CAT-2
                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/       0000775 0000000 0000000 00000000000 14746647661 0032054 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Adak   0000664 0000000 0000000 00000001711 14746647661 0032637 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              T   
   !?}Z^D#paP@UqPT@     SP    6@    x5P    qR    aQ    Q4    A3    1    m    	    	P    
        @        @    P    @    P    y@    iP    Y@    I~P    9a@    )`P    "}    	BP    _    +"     P    3    2                 vG@    !    "V)@    #j0    $6@    %J0    &@    '*0    '	    )
0    )    *~0    +    ,    -    .|    /~    0^    1g@    2s@    3G@    4S"    5'r@    63    7T@    8!0    86@    90    :@    ;0    <4    =0    >    ?0    @o    A    BO    Cd    D/    ED    E@																								    Zb  eP s`s`eP s`s` ps` LMT NST NWT NPT BST BDT AHST HDT 
HST10HDT,M3.2.0,M11.1.0
                                                       Anchorage                                                                                           0000664 0000000 0000000 00000001721 14746647661 0033610 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              T   
   (?}AH6#paB0Gc@F0     E@    (0    x'@    qD    aC    Q&    A%    1    _    	    	@    
        0        0    @    0    @    y0    i@    Yq0    Ip@    9S0    )R@    "o    	4@    Q    +    B    %    $                 v90    !    "V0    #j     $50    %J     &0    '*     '    )
     )    *p     +    ,    -    .n    /~    0P    1g0    2s2    3G0    4S    5'd0    62    7F0    8     8(0    9     :
0    ;     <&    =     >    ?     @o    A    BO    Cd    D/    ED{    E0																								    sx  s` pps` pp p #LMT AST AWT APT AHST AHDT YST AKDT AKST 
AKST9AKDT,M3.2.0,M11.1.0
                                               Anguilla                                                                                            0000664 0000000 0000000 00000000202 14746647661 0033446 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                                    75    LMT AST 
AST4
                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Antigua0000664 0000000 0000000 00000000225 14746647661 0033366 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    73BP    LMT EST AST 
AST4
                                                                                                                                                                                                                                                                                                                                                                           Araguaina                                                                                           0000664 0000000 0000000 00000001120 14746647661 0033602 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              3      t0I@40t 800Y 0 0T3 ^ d0Q,0 
0}    0    x    5     3    !i0    "    #X    #p     %7    %     0y0    1M    2W     3j     48T0    4     6 0    6h    7    8     90    :,    ;    <o    =0    >N    Pe0    Q 9   LMT -02 -03 
<-03>3
                                                                                                                                                                                                                                                                                                                                                                                                                                                Argentina/                                                                                          0000775 0000000 0000000 00000000000 14746647661 0033705 5                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           Buenos_Aires                                                                                        0000664 0000000 0000000 00000001304 14746647661 0036204 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Argentina                                                                 TZif2                                            TZif2                              =      rL0{R@@p0}@0x
@Z@;0~`@*0A70@MM0)5Cd=0l02@C0w@65S0R@504@    J    $o    #    $    %7    %v    '!0    'X    ) 0    ):    *0    +W     7    8*    Gw	    G     H    Ia 4     LMT CMT -04 -03 -02 
<-03>3
                                                                                                                                                                                                                                                                                                                            Catamarca                                                                                           0000664 0000000 0000000 00000001304 14746647661 0035502 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Argentina                                                                 TZif2                                            TZif2                              =      r,0{R@@p0}@0x
@Z@;0~`@*0A70@MM0)5Cd=0l02@C0w@65S0R@504@    J    $o    #    $    %7    %v    '!0    'X    ) @    ):    *0    +W     7    8*    @0    @    Gw	    G T     LMT CMT -04 -03 -02 
<-03>3
                                                                                                                                                                                                                                                                                                                            ComodRivadavia                                                                                      0000664 0000000 0000000 00000001304 14746647661 0036516 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Argentina                                                                 TZif2                                            TZif2                              =      r,0{R@@p0}@0x
@Z@;0~`@*0A70@MM0)5Cd=0l02@C0w@65S0R@504@    J    $o    #    $    %7    %v    '!0    'X    ) @    ):    *0    +W     7    8*    @0    @    Gw	    G T     LMT CMT -04 -03 -02 
<-03>3
                                                                                                                                                                                                                                                                                                                            Cordoba                                                                                             0000664 0000000 0000000 00000001304 14746647661 0035177 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Argentina                                                                 TZif2                                            TZif2                              =      r0{R@@p0}@0x
@Z@;0~`@*0A70@MM0)5Cd=0l02@C0w@65S0R@504@    J    $o    #    $    %7    %v    '!0    'X    ) @    ):    *0    +W     7    8*    Gw	    G     H    Ia      LMT CMT -04 -03 -02 
<-03>3
                                                                                                                                                                                                                                                                                                                            Jujuy                                                                                               0000664 0000000 0000000 00000001262 14746647661 0034737 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Argentina                                                                 TZif2                                            TZif2                              ;      r0{R@@p0}@0x
@Z@;0~`@*0A70@MM0)5Cd=0l02@C0w@65S0R@504@    J    $o    #    $    %7    %v    '*W    '    (@    ):    *0    +W     7    8*    Gw	    G      LMT CMT -04 -03 -02 
<-03>3
                                                                                                                                                                                                                                                                                                                                              La_Rioja                                                                                            0000664 0000000 0000000 00000001315 14746647661 0035310 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Argentina                                                                 TZif2                                            TZif2                              >      r,0{R@@p0}@0x
@Z@;0~`@*0A70@MM0)5Cd=0l02@C0w@65S0R@504@    J    $o    #    $    %7    %v    '!0    '    (&&@    ) 0    ):    *0    +W     7    8*    @0    @    Gw	    G T     LMT CMT -04 -03 -02 
<-03>3
                                                                                                                                                                                                                                                                                                                   Mendoza                                                                                             0000664 0000000 0000000 00000001304 14746647661 0035223 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Argentina                                                                 TZif2                                            TZif2                              =      r0{R@@p0}@0x
@Z@;0~`@*0A70@MM0)5Cd=0l02@C0w@65S0R@504@    J    $o    #    $    %7    %v    '4@    '    (g    )H    *@    +W     7    8*    @    AV>    Gw	    G |     LMT CMT -04 -03 -02 
<-03>3
                                                                                                                                                                                                                                                                                                                            Rio_Gallegos                                                                                        0000664 0000000 0000000 00000001304 14746647661 0036174 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Argentina                                                                 TZif2                                            TZif2                              =      rd0{R@@p0}@0x
@Z@;0~`@*0A70@MM0)5Cd=0l02@C0w@65S0R@504@    J    $o    #    $    %7    %v    '!0    'X    ) 0    ):    *0    +W     7    8*    @0    @    Gw	    G      LMT CMT -04 -03 -02 
<-03>3
                                                                                                                                                                                                                                                                                                                            Salta                                                                                               0000664 0000000 0000000 00000001262 14746647661 0034675 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Argentina                                                                 TZif2                                            TZif2                              ;      r0{R@@p0}@0x
@Z@;0~`@*0A70@MM0)5Cd=0l02@C0w@65S0R@504@    J    $o    #    $    %7    %v    '!0    'X    ) @    ):    *0    +W     7    8*    Gw	    G      LMT CMT -04 -03 -02 
<-03>3
                                                                                                                                                                                                                                                                                                                                              San_Juan                                                                                            0000664 0000000 0000000 00000001315 14746647661 0035326 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Argentina                                                                 TZif2                                            TZif2                              >      r0{R@@p0}@0x
@Z@;0~`@*0A70@MM0)5Cd=0l02@C0w@65S0R@504@    J    $o    #    $    %7    %v    '!0    '    (&&@    ) 0    ):    *0    +W     7    8*    @    A0@    Gw	    G      LMT CMT -04 -03 -02 
<-03>3
                                                                                                                                                                                                                                                                                                                   San_Luis                                                                                            0000664 0000000 0000000 00000001315 14746647661 0035345 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Argentina                                                                 TZif2                                            TZif2                              >      r0{R@@p0}@0x
@Z@;0~`@*0A70@MM0)5Cd=0l02@C0w@65S0R@504@    J    $o    #    $    %7    %    '4@    '    (G    7    8*    @    A0@    Gw	    G    GR    Hv@    I4    JX@     LMT CMT -04 -03 -02 
<-03>3
                                                                                                                                                                                                                                                                                                                   Tucuman                                                                                             0000664 0000000 0000000 00000001326 14746647661 0035246 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Argentina                                                                 TZif2                                            TZif2                              ?      r0{R@@p0}@0x
@Z@;0~`@*0A70@MM0)5Cd=0l02@C0w@65S0R@504@    J    $o    #    $    %7    %v    '!0    'X    ) @    ):    *0    +W     7    8*    @0    @@    Gw	    G     H    Ia      LMT CMT -04 -03 -02 
<-03>3
                                                                                                                                                                                                                                                                                                          Ushuaia                                                                                             0000664 0000000 0000000 00000001304 14746647661 0035225 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Argentina                                                                 TZif2                                            TZif2                              =      r0{R@@p0}@0x
@Z@;0~`@*0A70@MM0)5Cd=0l02@C0w@65S0R@504@    J    $o    #    $    %7    %v    '!0    'X    ) 0    ):    *0    +W     7    8*    @N0    @    Gw	    G      LMT CMT -04 -03 -02 
<-03>3
                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Aruba  0000664 0000000 0000000 00000000227 14746647661 0033032 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    /8HH    
LMT -0430 AST 
AST4
                                                                                                                                                                                                                                                                                                                                                                         Asuncion                                                                                            0000664 0000000 0000000 00000001564 14746647661 0033505 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              O      i    +@        
t            x0    -@    Z1    t`    dC    U@    F    8@    '0    L    	/    @    c0        0    8        l@    O0         p    !a@    "S    #DX@    $4;0    %A;@    &n    '@    '0    (@    )H    *    +	0    ,@    -p    .    /O    0n@    16h0    2W.    3    47    40    6    6    7    8    9    :    ;@    <0    =q    >0    ?Z@    @oz0    Aq@    B3    CQ@    D    E1@    Ep    G    GR    H    I4    J    K;0    L    M0    N    O0    Pp@     LMT AMT -04 -03 
<-04>4<-03>,M10.1.0/0,M3.4.0/0
                                                                                                                                            Atikokan                                                                                            0000664 0000000 0000000 00000000340 14746647661 0033456 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                                    rdpW`#pa	    LMT CDT CST CWT CPT EST 
EST5
                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Atka   0000664 0000000 0000000 00000001711 14746647661 0032657 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              T   
   !?}Z^D#paP@UqPT@     SP    6@    x5P    qR    aQ    Q4    A3    1    m    	    	P    
        @        @    P    @    P    y@    iP    Y@    I~P    9a@    )`P    "}    	BP    _    +"     P    3    2                 vG@    !    "V)@    #j0    $6@    %J0    &@    '*0    '	    )
0    )    *~0    +    ,    -    .|    /~    0^    1g@    2s@    3G@    4S"    5'r@    63    7T@    8!0    86@    90    :@    ;0    <4    =0    >    ?0    @o    A    BO    Cd    D/    ED    E@																								    Zb  eP s`s`eP s`s` ps` LMT NST NWT NPT BST BDT AHST HDT 
HST10HDT,M3.2.0,M11.1.0
                                                       node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Bahia  0000664 0000000 0000000 00000001252 14746647661 0033003 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              =      kI@40t 800Y 0 0T3 ^ d0Q,0 
0}    0    x    5     3    !i0    "    #X    #p     %7    %     '!0    '    ) 0    )     *    +k2    ,0    -f     .0    /F     0y0    1M    2W     3j     48T0    4     6 0    6h    7    8     90    :,    ;    <o    =0    >N    NH    OI    LMT -02 -03 
<-03>3
                                                                                                                                                                                                                                                                                                                                                      Bahia_Banderas                                                                                      0000664 0000000 0000000 00000001330 14746647661 0034520 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              ?      pnfV`C`6`q`      p    1g    2s    3Gf    4R    5'H    62    7*    8     8    9     :    ;     <
    =     >    ?     @o    A    BO    Cd}    D/    ED_    Ft    G$A    G    I#    Is    J    KU    L    M)     N    Ox     P    Qa'    Rl    SA	    TL    U     V,}    W     Xp    X    Y|p    Z    [^p    \     ]@p    ^     _"p    `ir     a~>    bIT     c^ T     LMT MST CST MDT PST CDT 
CST6
                                                                                                                                                                                                                                                                                                        Barbados                                                                                            0000664 0000000 0000000 00000000426 14746647661 0033437 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                                    @e"|Mej`                  tn    v    TP    _`    0>P   LMT ADT AST -0330 
AST4
                                                                                                                                                                                                                                          node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Belem  0000664 0000000 0000000 00000000612 14746647661 0033022 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    ttI@40t 800Y 0 0T3 ^ d0Q,0 
0}    0    x    5     3    !i0    "   LMT -02 -03 
<-03>3
                                                                                                                      node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Belize 0000664 0000000 0000000 00000002025 14746647661 0033210 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              b      ^;EQ.nX^PX>2X'`X`X``v`Vh`6pPf|0HX*{X]X)`?X`_!X`?Xx`(X`8`!sX@"#pqP)`J	`,`xXAXr!XRbX2DXa`wXC`YX%`u`jW`J9*c	C#XXoX`rX    b`    P    aq`    7PP   
LMT -0530 CST CWT CPT CDT 
CST6
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Blanc-Sablon                                                                                        0000664 0000000 0000000 00000000315 14746647661 0034152 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                                    ^=9`P`#p`t   LMT ADT AST AWT APT 
AST4
                                                                                                                                                                                                                                                                                                                   Boa_Vista                                                                                           0000664 0000000 0000000 00000000656 14746647661 0033576 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              !      WNB@08@@g0#@0@TA0l0r@,Q:@0
@    @    x    C     3    !w@    "    7    80    9@    9    LMT -03 -04 
<-04>4
                                                                                  node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Bogota 0000664 0000000 0000000 00000000263 14746647661 0033213 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    ^4XUp    *sP    +t@    LMT BMT -04 -05 
<-05>5
                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Boise  0000664 0000000 0000000 00000001747 14746647661 0033051 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              Z      ^H*FL #pa uX W: 9               w    q    a    P    @    0        	    	    
                                   ye     id    YG     IF    9)     )(    "E    	
    '    &    	                     v    !    "U    #j     $5    %J     &    '*     '    )
r     )    *T     +    ,p    -    .R    /~g    04    1g    2s    3Gf    4R    5'H    62    7*    8     8    9     :    ;     <
    =     >    ?     @o    A    BO    Cd}    D/    ED_    E    LMT PDT PST MWT MPT MST MDT 
MST7MDT,M3.2.0,M11.1.0
                         Buenos_Aires                                                                                        0000664 0000000 0000000 00000001304 14746647661 0034274 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              =      rL0{R@@p0}@0x
@Z@;0~`@*0A70@MM0)5Cd=0l02@C0w@65S0R@504@    J    $o    #    $    %7    %v    '!0    'X    ) 0    ):    *0    +W     7    8*    Gw	    G     H    Ia 4     LMT CMT -04 -03 -02 
<-03>3
                                                                                                                                                                                                                                                                                                                            Cambridge_Bay                                                                                       0000664 0000000 0000000 00000001563 14746647661 0034375 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              L       #pa     a    P    @    0         	    
     
                                   ye     id    YG     IF    9)     )(    "E    	
    '    &    	                     v    !    "U    #j     $5    %J     &    '*     '    )
r     )    *T     +    ,p    -    .R    /~g    04    1g    2s    3Gf    4R    5'H    62    7*    8     8     9    :P    :    ;     <
    =     >    ?     @o    A    BO    Cd}    D/    ED_    E         -00 MWT MPT MST MDT CDT CST EST 
MST7MDT,M3.2.0,M11.1.0
                                                                                                                                             Campo_Grande                                                                                        0000664 0000000 0000000 00000001670 14746647661 0034243 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              [      z4WNB@08@@g0#@0@TA0l0r@,Q:@0
@    @    x    C     3    !w@    "    #X    #~0    %8     %0    '!@    '    ) @    )0    *    +k@    ,@    -f0    .@    /F0    0@    1[    2W.    3x0    48b@    40    6 -@    6v    7    80    9@    ::    ;    <o    =@    >N    ?@    @.    A@    B0    CQ@    C0    EMa    E    G@    G0    H    I0    J    K    Lt    M`    NV    OI0    Ps@    Q G    RcU@    S )    TC7@    TF0    V#@    V(0    X@    X
0    Y@    Z0    [n    \h0   LMT -03 -04 
<-04>4
                                                                        node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Cancun 0000664 0000000 0000000 00000001021 14746647661 0033200 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              *      `    `    1gg    2r`    3GI    4R`    5'+    5 `    62p    7     8    8     9    :    ;    <    =    >    ?p    @o    Ap    BO    Cdop    D/    EDQp    Ff    G$3p    G     Ip    Ie     Jp    KG     L    M)     N    Ox     P    Qa'    Rl    SA	    TL    T     LMT CST EDT EST CDT 
EST5
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Caracas0000664 0000000 0000000 00000000276 14746647661 0033341 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    i@,<H    G[p    W%p@  D   LMT CMT -0430 -04 
<-04>4
                                                                                                                                                                                                                                                                                                                                  Catamarca                                                                                           0000664 0000000 0000000 00000001304 14746647661 0033572 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              =      r,0{R@@p0}@0x
@Z@;0~`@*0A70@MM0)5Cd=0l02@C0w@65S0R@504@    J    $o    #    $    %7    %v    '!0    'X    ) @    ):    *0    +W     7    8*    @0    @    Gw	    G T     LMT CMT -04 -03 -02 
<-03>3
                                                                                                                                                                                                                                                                                                                            node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Cayenne0000664 0000000 0000000 00000000227 14746647661 0033362 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    +5    LMT -04 -03 
<-03>3
                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Cayman 0000664 0000000 0000000 00000000225 14746647661 0033206 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    i'    LMT KMT EST 
EST5
                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Chicago0000664 0000000 0000000 00000003332 14746647661 0033335 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    ^,ppt EcS p3   wa YC ~;_gXp|AG:p\#'p<pp p  Z <p Odn /fMH-lepNGp#pa	u @U  5   spyrp[iTp~=I6p^W<G< 7'      pppo_pO?ip/h(Jgg II ++               w     qp    a    Pp    @    0p    '    	p    	     
p            u             t    t     yV    iV     Y8    I8     9    )     "7p         p        p        p        p     v     !p    "U     #j    $5     %J    &     '*    '    )
c    )    *E    +    ,bp    -w    .Dp    /~Y    0&p    1gv     2sp    3GX     4Rp    5':     62p    7     8    8     9    :     ;    <    =    >    ?p    @o    Ap    BO    Cdop    D/    EDQp    E     LMT CDT CST EST CWT CPT 
CST6CDT,M3.2.0,M11.1.0
                                                                                                                                                                                                                                                                                                      Chihuahua                                                                                           0000664 0000000 0000000 00000001263 14746647661 0033621 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              <      pnfV`C`6`    1gv     2sp    3GX     4Rp    5'H    62    7*    8     8    9     :    ;     <
    =     >    ?     @o    A    BO    Cd}    D/    ED_    Ft    G$A    G    I#    Is    J    KU    L"     M7    N     Ox    P     Qa5    Rl     SA    TL     U     V,     W     X    X    Y    Z    [l    \    ]N    ^    _0    `i    a~M     bIb    c^/     LMT MST CST MDT CDT 
CST6
                                                                                                                                                                                                                                                                                                                                             Ciudad_Juarez                                                                                       0000664 0000000 0000000 00000001316 14746647661 0034432 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              =      pnfV`C`6`    1gv     2sp    3GX     4Rp    5'H    62    7*    8     8    9     :    ;     <
    =     >    ?     @o    A    BO    Cd}    D/    ED_    Ft    G$A    G    I#    Is    J    K    L\    M|    N>    O\i    P     Q<K    Rv    S-    TU    T    V5    V,    X     X    Y     Z    [     \    ]     ^d    _k     `M    a    b-    c^/     c`,    LMT MST CST MDT CDT 
MST7MDT,M3.2.0,M11.1.0
                                                                                                                                                                                                                                                                                                                  Coral_Harbour                                                                                       0000664 0000000 0000000 00000000340 14746647661 0034437 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                                    rdpW`#pa	    LMT CDT CST CWT CPT EST 
EST5
                                                                                                                                                                                                                                                                                                node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Cordoba0000664 0000000 0000000 00000001304 14746647661 0033346 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              =      r0{R@@p0}@0x
@Z@;0~`@*0A70@MM0)5Cd=0l02@C0w@65S0R@504@    J    $o    #    $    %7    %v    '!0    'X    ) @    ):    *0    +W     7    8*    Gw	    G     H    Ia      LMT CMT -04 -03 -02 
<-03>3
                                                                                                                                                                                                                                                                                                                            Costa_Rica                                                                                          0000664 0000000 0000000 00000000350 14746647661 0033725 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              
      i*MM    6I`    nP    +`    PP    '`    (n    )w`    )3  3 	 LMT SJMT CDT CST 
CST6
                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Creston0000664 0000000 0000000 00000000236 14746647661 0033415 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    ^=pKp;     LMT MST PST 
MST7
                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Cuiaba 0000664 0000000 0000000 00000001646 14746647661 0033172 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              Y      {WNB@08@@g0#@0@TA0l0r@,Q:@0
@    @    x    C     3    !w@    "    #X    #~0    %8     %0    '!@    '    ) @    )0    *    +k@    ,@    -f0    .@    /F0    0@    1[    2W.    3x0    48b@    40    6 -@    6v    7    80    9@    ::    ;    <o    =@    >N    A@    B0    CQ@    C0    EMa    E    G@    G0    H    I0    J    K    Lt    M`    NV    OI0    Ps@    Q G    RcU@    S )    TC7@    TF0    V#@    V(0    X@    X
0    Y@    Z0    [n    \h0l   LMT -03 -04 
<-04>4
                                                                                          node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Curacao0000664 0000000 0000000 00000000227 14746647661 0033355 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    .#H]    
LMT -0430 AST 
AST4
                                                                                                                                                                                                                                                                                                                                                                         Danmarkshavn                                                                                        0000664 0000000 0000000 00000000677 14746647661 0034347 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              "      I     M|P    3    #                                            |     lr    !\c    "LT    #<E    $,6    %'    &    'C    '4    (%    )    *    +    ,    -    .    /t    0d    0N0        LMT -03 -02 GMT 
GMT0
                                                                 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Dawson 0000664 0000000 0000000 00000002005 14746647661 0033227 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              ]   	   %}#(#pa4 /v(    0    ir     YU    IT     97    )6     "S    	     5    4                         v+     !    "V     #j    $5     %J    &     '*    '    )
    )    *b    +    ,~    -    .`    /~u    0B    1g     2s$    3Gt     4S    5'V     62    78     8    8     9    :     ;    <    =    >    ?    @o    A    BO    Cd    D/    EDm    E     G-    G     Il    I     JN    K    Lj    M|    NL    O\w    P.    Q<Y    Rv    S;    TU    T    V5    V:     X    X     Y    Z     [    \     ]    ^d     _\}L  p   !LMT YDT YST YWT YPT YDDT PST PDT MST 
MST7
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           Dawson_Creek                                                                                        0000664 0000000 0000000 00000001253 14746647661 0034265 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              :      ^=t8#pa&U  5   wip~YIR^;)4GX Q': 3   qo_O?/(f fe HG *     )         x     q(    a'    H    LMT PDT PST PWT PPT MST 
MST7
                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Denver 0000664 0000000 0000000 00000002022 14746647661 0033216 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              a      ^:e E#pa /v( Xv uX W: 9               w    q    a    P    @    0    5    	    	    
                                   ye     id    YG     IF    9)     )(    "E    	
    '    &    	                     v    !    "U    #j     $5    %J     &    '*     '    )
r     )    *T     +    ,p    -    .R    /~g    04    1g    2s    3Gf    4R    5'H    62    7*    8     8    9     :    ;     <
    =     >    ?     @o    A    BO    Cd}    D/    ED_    E   LMT MDT MST MWT MPT 
MST7MDT,M3.2.0,M11.1.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Detroit0000664 0000000 0000000 00000001603 14746647661 0033411 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              P      "[< p#p`5 3;:    @p    0`    p    	`    
 p    
`    p        gp            f    e    yH    iG    Y*    I)    9    )    ")`        `    
p    `    p    `    p    `     v     !`    "U    #j    $5    %J    &    '*s    'p    )
U    )p    *7    +p    ,T`    -ip    .6`    /~Kp    0`    1gg    2r`    3GI    4R`    5'+    62`    7    8    8    9    :    ;    <p    =    >p    ?b    @op    A`    BOp    Cda`    D/vp    EDC`    E%    LMT CST EST EWT EPT EDT 
EST5EDT,M3.2.0,M11.1.0
                                                                                                                             Dominica                                                                                            0000664 0000000 0000000 00000000202 14746647661 0033435 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                                    4Lp   LMT AST 
AST4
                                                                                                                                                                                                                                                                                                                                                                                              Edmonton                                                                                            0000664 0000000 0000000 00000001712 14746647661 0033504 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              Y       j5S3 #pa U      a    P    @    0         	    
     
                                   ye     id    YG     IF    9)     )(    "E    	
    '    &    	                     v    !    "U    #j     $5    %J     &    '*     '    )
r     )    *T     +    ,p    -    .R    /~g    04    1g    2s    3Gf    4R    5'H    62    7*    8     8    9     :    ;     <
    =     >    ?     @o    A    BO    Cd}    D/    ED_    E   LMT MDT MST MWT MPT 
MST7MDT,M3.2.0,M11.1.0
                                                      Eirunepe                                                                                            0000664 0000000 0000000 00000000664 14746647661 0033502 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              !      f \PP@8PPu@1P@PTO@z@P:QHP@
"P    P    x    Q     3    !P    "    ,P    -f@    H`P    R    LMT -04 -05 
<-05>5
                                                                            El_Salvador                                                                                         0000664 0000000 0000000 00000000260 14746647661 0034111 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                                              !\P    "z    #<}P`   LMT CDT CST 
CST6
                                                                                                                                                                                                                                                                                                                                                Ensenada                                                                                            0000664 0000000 0000000 00000002001 14746647661 0033427 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              ^      pyOp|fdp 
#ppY ~KIR^-)4GJQ',3                                  ys    ir     YU    IT     97    )6     "S    	     5    4                         v+     !    "V     #j    $5     %J    &     '*    '    )
    )    *b    +    ,~    -    .`    /~u    0B    1g     2s$    3Gt     4S    5'V     62    78     8    8     9    :     ;    <    =    >    ?    @o    A    BO    Cd    D/    EDm    F    G$O    G     I1    I     J    K=L    LMT MST PST PDT PWT PPT 
PST8PDT,M3.2.0,M11.1.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Fort_Nelson                                                                                         0000664 0000000 0000000 00000002650 14746647661 0034153 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                                    ^=v#pa&U  5   wip~YIR^;)4GX Q': 3   qo_O?/(f fe HG *     )         x     q(    a'    Q
    A	    0         	    
     
                                  ys    ir     YU    IT     97    )6     "S    	     5    4                         v+     !    "V     #j    $5     %J    &     '*    '    )
    )    *b    +    ,~    -    .`    /~u    0B    1g     2s$    3Gt     4S    5'V     62    78     8    8     9    :     ;    <    =    >    ?    @o    A    BO    Cd    D/    EDm    E     G-    G     Il    I     JN    K    Lj    M|    NL    O\w    P.    Q<Y    Rv    S;    TU    T    LMT PDT PST PWT PPT MST 
MST7
                                                                                        Fort_Wayne                                                                                          0000664 0000000 0000000 00000001023 14746647661 0033771 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              &      ^,ppW"Gp#pa	u @U  5   spyrp[iTp~=I6p^               D/vp    EDC`    E:    LMT CDT CST CWT CPT EST EDT 
EST5EDT,M3.2.0,M11.1.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Fortaleza                                                                                           0000664 0000000 0000000 00000000744 14746647661 0033654 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              '      kI@40t 800Y 0 0T3 ^ d0Q,0 
0}    0    x    5     3    !i0    "    #X    #p     %7    %     7    8     90    9J     ;    <o   LMT -02 -03 
<-03>3
                            Glace_Bay                                                                                           0000664 0000000 0000000 00000001560 14746647661 0033530 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              O      4`P`#p`?`i8P    ``    PP    @`    0P     `    	P    
 `    
xP    w`        Y`    v    u    X    W    y:    i9    Y    I    8    (    "P        P    `    P    `    P    `    P     u    !P    "U    #j    $5    %J    &    '*e    '`    )
G    )`    *)    +y`    ,FP    -[`    .(P    /~=`    0
P    1gY    2rP    3G;    4RP    5'    62P    7    8    8    9    :    ;    <`    =r    >`    ?T    @o`    AqP    BO`    CdSP    D/h`    ED5P    E   LMT ADT AST AWT APT 
AST4ADT,M3.2.0,M11.1.0
                                                                                                                                                node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Godthab0000664 0000000 0000000 00000001705 14746647661 0033352 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif3                                            TZif3                              Y      h     M|P    3    #                                            |     lr    !\c    "LT    #<E    $,6    %'    &    'C    '4    (%    )    *    +    ,    -    .    /t    0d    1]    2r    3=    4R    5    62x    6    8    8a    9v    :C    ;X    <_    =:    >A    ?    @f#    A9    BF    Cd    D%    EC    F    G#    G    I    I    J    K    L    M    N    Onn    P    QW    Rle    S7l    TLG    UN    V,)    V0    XF    X    Y(    Z    [
    \    ]    ^    _    `_    a}    b?    c]    d    e=    LMT -03 -02 
<-02>2<-01>,M3.5.0/-1,M10.5.0/0
                                                           Goose_Bay                                                                                           0000664 0000000 0000000 00000003054 14746647661 0033571 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                                 
   !^=<$~|Ml18y8Yw89a@( ( #p`DJHh&)HH	H'HXtXmHVXOH8Xi1H~XIH]X(HG&HXHXHoX_dHOcX?FH/EX(bkX.`KJ-,             w    pP    ``    PP    @`    0P     `    	P    
 `    
xP    w`        Y`    v    u    X    W    y:    i9    Y    I    8    (    "P        P    `    P    `    P    `    P     u    !il    "U    #jw    $5    %Jg    &|    '*I    '|    )
+    ){|    *    +]|    ,*l    -?|    .l    /~!|    0l    1g=    2rl    3G    4Rl    5'    62l    7    8    8    9    :    ;t    <|    =V    >|    ?8    @o|    AUl    BOj|    Cd7l    D/L|    EDl    E~    G-5    G`    I    IB    J    K_|    Ll    M|A|    N`	\     LMT NST NDT NPT NWT ADT AST ADDT 
AST4ADT,M3.2.0,M11.1.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Grand_Turk                                                                                          0000664 0000000 0000000 00000001525 14746647661 0033763 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              L      i0    e    yH    iG    Y*    I)    9    )    ")`        `    
p    `    p    `    p    `     v     !`    "U    #j    $5    %J    &    '*s    'p    )
U    )p    *7    +p    ,T`    -ip    .6`    /~Kp    0`    1gg    2r`    3GI    4R`    5'+    62`    7    8    8    9    :    ;    <p    =    >p    ?b    @op    A`    BOp    Cda`    D/vp    EDC`    E    G-_    G    IA    Il    J#    Kp    L@`    M|kp    N"`    O\Mp    P`    Q</p    Ru`    Sp    TU`    Tp    ZP     LMT KMT EST EDT AST 
EST5EDT,M3.2.0,M11.1.0
                                                                                                                                                                           node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Grenada0000664 0000000 0000000 00000000202 14746647661 0033332 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    4d   LMT AST 
AST4
                                                                                                                                                                                                                                                                                                                                                                                              Guadeloupe                                                                                          0000664 0000000 0000000 00000000202 14746647661 0034004 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                                    P   LMT AST 
AST4
                                                                                                                                                                                                                                                                                                                                                                                              Guatemala                                                                                           0000664 0000000 0000000 00000000324 14746647661 0033617 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              	          U`        ,x`    P    '    (\    DTR`    EKP$   LMT CDT CST 
CST6
                                                                                                                                                                                                                                                                                                            Guayaquil                                                                                           0000664 0000000 0000000 00000000263 14746647661 0033662 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                                    i&XB    +    +q@(  h  LMT QMT -04 -05 
<-05>5
                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Guyana 0000664 0000000 0000000 00000000265 14746647661 0033226 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    {@    
    )@y   D  LMT -04 -0345 -03 
<-04>4
                                                                                                                                                                                                                                                                                                                                           node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Halifax0000664 0000000 0000000 00000003210 14746647661 0033347 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    0`P@00zV@0SR<@4@:0@0@0E@U0@Kp~@$0n`@NB@$0 ]@1@0^G0@P0mp@00r<@b06n~P``#p`u@U 5 |u{`tP]`VP?`i8P~!`IPG'`Po`_kPOj`?MP/L`(i.`KJ-,             w    pP    ``    PP    @`    0P     `    	P    
 `    
xP    w`        Y`    v    u    X    W    y:    i9    Y    I    8    (    "P        P    `    P    `    P    `    P     u    !P    "U    #j    $5    %J    &    '*e    '`    )
G    )`    *)    +y`    ,FP    -[`    .(P    /~=`    0
P    1gY    2rP    3G;    4RP    5'    62P    7    8    8    9    :    ;    <`    =r    >`    ?T    @o`    AqP    BO`    CdSP    D/h`    ED5P    E`   LMT ADT AST AWT APT 
AST4ADT,M3.2.0,M11.1.0
                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Havana 0000664 0000000 0000000 00000002135 14746647661 0033176 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              j      i(bPt]@[fQ@;Hm$ePOP;P`}@=DS;@h@              w    p@    `P    5    @P    H@     P    {    
 P    
j@    iP        KP    h    P    }@    Q    f    1    F    [    &{    ;d    ]    F    ?    (    \@    
    >@    zSP     @     Z5P    !o@    "CQ    #N@    $#3    %.@    &    '    'P    (    )P    *    +kP    ,    -MP    .x    /~/P    0wZ    1gK    2W<    3G-    4@YP    5P    62P    6P    8    8    9    :    ;    <P    =r    >P    ?T    @f[    ED5P    E    G$P    GP    IP    IP    JP    KmP    L    M    NN    Ow    PP    LMT HMT CDT CST 
CST5CDT,M3.2.0/0,M11.1.0/1
                                                                                                                                                                                                                                                                                                                                                                                                                                   Hermosillo                                                                                          0000664 0000000 0000000 00000000436 14746647661 0034040 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                                    pnfV`C`6`q`      p    1g    2s    3Gf    4R    5'H    62     LMT MST CST MDT PST 
MST7
                                                                                                                                                                                                                                  Indiana/                                                                                            0000775 0000000 0000000 00000000000 14746647661 0033340 5                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           Indianapolis                                                                                        0000664 0000000 0000000 00000001023 14746647661 0035671 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Indiana                                                                   TZif2                                            TZif2                              &      ^,ppW"Gp#pa	u @U  5   spyrp[iTp~=I6p^               D/vp    EDC`    E:    LMT CDT CST CWT CPT EST EDT 
EST5EDT,M3.2.0,M11.1.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Knox                                                                                                0000664 0000000 0000000 00000001770 14746647661 0034207 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Indiana                                                                   TZif2                                            TZif2                              ]      ^,pp#pa	U  5   spyrp[iTp~=I6p^W<G< 7'     pp_pg II ++               w     qp    a    Pp    @    0p    '    	p    	     
p            u             t    t     yV    iV     Y8    I8     9    )     "7p         p        p        p        p     v     !p    "U     #j    $5     %J    &     '*    '    )
c    D/vp    EDQp    E     LMT CDT CST CWT CPT EST 
CST6CDT,M3.2.0,M11.1.0
        Marengo                                                                                             0000664 0000000 0000000 00000001067 14746647661 0034657 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Indiana                                                                   TZif2                                            TZif2                              *      ^,pp#pa	p~=I6p^)pG< 4'                  w    p`    `p    P`    @p    0`    p    	p    	    
`    D/vp    EDC`    E    LMT CDT CST CWT CPT EST EDT 
EST5EDT,M3.2.0,M11.1.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         Petersburg                                                                                          0000664 0000000 0000000 00000001253 14746647661 0035406 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Indiana                                                                   TZif2                                            TZif2                              8      ^,pp#pa	g=)pG< 4'     ppo_pO?ip/hgg II ++               w     qp    a    Pp    @    0p    '    	p    	     
p            u        D/vp    EDQp    E     G-m-    LMT CDT CST CWT CPT EST 
EST5EDT,M3.2.0,M11.1.0
                                                                                                                                                                                                                                                                                                                                                     Tell_City                                                                                           0000664 0000000 0000000 00000001012 14746647661 0035145 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Indiana                                                                   TZif2                                            TZif2                              %      ^,pp#pa	g=)pG< 4'     ppo_pOII ++              D/vp    EDQp    E     LMT CDT CST CWT CPT EST EDT 
CST6CDT,M3.2.0,M11.1.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Vevay                                                                                               0000664 0000000 0000000 00000000561 14746647661 0034357 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Indiana                                                                   TZif2                                            TZif2                                    ^,pp#pa	~=             w    p`    `p    P`    D/vp    EDC`    E@    LMT CDT CST CWT CPT EST EDT 
EST5EDT,M3.2.0,M11.1.0
                                                                                                                                               Vincennes                                                                                           0000664 0000000 0000000 00000001056 14746647661 0035215 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Indiana                                                                   TZif2                                            TZif2                              )      ^,pp#pa	u @[iTp~=I6pg=)pG< 4'     pqpo_pO             D/vp    EDQp    E     G-m    LMT CDT CST CWT CPT EST EDT 
EST5EDT,M3.2.0,M11.1.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  Winamac                                                                                             0000664 0000000 0000000 00000001133 14746647661 0034640 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Indiana                                                                   TZif2                                            TZif2                              .      ^,pp#pa	u @U  5   spyrp[iTp~=I6p^W<G< 7'                  D/vp    EDQp    E     LMT CDT CST CWT CPT EST EDT 
EST5EDT,M3.2.0,M11.1.0
                                                                                                                                                                                                                                                                                                                                                                                                                                     Indianapolis                                                                                        0000664 0000000 0000000 00000001023 14746647661 0034326 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              &      ^,ppW"Gp#pa	u @U  5   spyrp[iTp~=I6p^               D/vp    EDC`    E:    LMT CDT CST CWT CPT EST EDT 
EST5EDT,M3.2.0,M11.1.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Inuvik 0000664 0000000 0000000 00000001461 14746647661 0033246 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              H      N    a'    Q
    A	    0         	    
     
                                  ye     id    YG     IF    9)     )(    "E    	
    '    &    	                     v    !    "U    #j     $5    %J     &    '*     '    )
r     )    *T     +    ,p    -    .R    /~g    04    1g    2s    3Gf    4R    5'H    62    7*    8     8    9     :    ;     <
    =     >    ?     @o    A    BO    Cd}    D/    ED_    E        -00 PDT PST MST MDT 
MST7MDT,M3.2.0,M11.1.0
                                                                                                                                                                                                               node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Iqaluit0000664 0000000 0000000 00000001527 14746647661 0033414 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              J      l#p`    `p    P`    @p    0`     p    	`    
 p    
`    p        gp            f    e    yH    iG    Y*    I)    9    )    ")`        `    
p    `    p    `    p    `     v     !`    "U    #j    $5    %J    &    '*s    'p    )
U    )p    *7    +p    ,T`    -ip    .6`    /~Kp    0`    1gg    2r`    3GI    4R`    5'+    62`    7    8    8     9    :    ;    <p    =    >p    ?b    @op    A`    BOp    Cda`    D/vp    EDC`    E        -00 EPT EST EDT EWT CST CDT 
EST5EDT,M3.2.0,M11.1.0
                                                                                                                                                                         node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Jamaica0000664 0000000 0000000 00000000523 14746647661 0033324 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    i#~    p    	`    	    
`    p        gp            f    e    yH    iG    Y*    I)    9    )    ")`        `    LMT KMT EST EDT 
EST5
                                                                                                                                                                             node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Jujuy  0000664 0000000 0000000 00000001262 14746647661 0033106 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              ;      r0{R@@p0}@0x
@Z@;0~`@*0A70@MM0)5Cd=0l02@C0w@65S0R@504@    J    $o    #    $    %7    %v    '*W    '    (@    ):    *0    +W     7    8*    Gw	    G      LMT CMT -04 -03 -02 
<-03>3
                                                                                                                                                                                                                                                                                                                                              node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Juneau 0000664 0000000 0000000 00000001706 14746647661 0033232 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              S   
   &?}2#pa&G *     )         x     q(    a'    Q
    A	    0    C    	    	     
                                  ys    ir     Yc     IT     97    )6     "S    	     5    +    B    %    $                 v90    !    "V0    #j     $50    %J     &0    '*     '    )
     )    *p     +    ,    -    .n    /~    0P    1g0    2s2    3G0    4S    5'd0    62    7F0    8     8(0    9     :
0    ;     <&    =     >    ?     @o    A    BO    Cd    D/    ED{    E0																								  {     p p !LMT PST PWT PPT PDT YDT YST AKDT AKST 
AKST9AKDT,M3.2.0,M11.1.0
                                                          Kentucky/                                                                                           0000775 0000000 0000000 00000000000 14746647661 0033572 5                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           Louisville                                                                                          0000664 0000000 0000000 00000002332 14746647661 0035644 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Kentucky                                                                  TZif2                                            TZif2                              u      ^,pps pNGp#pa	u	pspyrp[iTp~=I6p^)pG< 7'      pp:             w    p`    `p    P`    @p    0`    p    	p    	    
`    p        gp            f    e    yH    iG    Y*    I)    9    )    ")`        `    
p    `    p    `    p    `     v     !`    "U    #j    $5    %J    &    '*s    'p    )
U    )p    *7    +p    ,T`    -ip    .6`    /~Kp    0`    1gg    2r`    3GI    4R`    5'+    62`    7    8    8    9    :    ;    <p    =    >p    ?b    @op    A`    BOp    Cda`    D/vp    EDC`    E    LMT CDT CST CWT CPT EST EDT 
EST5EDT,M3.2.0,M11.1.0
                                                                                                                                                                                                                                                                                                      Monticello                                                                                          0000664 0000000 0000000 00000001714 14746647661 0035625 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Kentucky                                                                  TZif2                                            TZif2                              W      ^,pp#pa	I ++               w     qp    a    Pp    @    0p    '    	p    	     
p            u             t    t     yV    iV     Y8    I8     9    )     "7p         p        p        p        p     v     !p    "U     #j    $5     %J    &     '*    '    )
c    )    *E    +    ,bp    -w    .Dp    /~Y    0&p    1gv     2sp    3GX     4Rp    5':     62p    7     8    8     9    :    ;    <p    =    >p    ?b    @op    A`    BOp    Cda`    D/vp    EDC`    Et    LMT CDT CST CWT CPT EDT EST 
EST5EDT,M3.2.0,M11.1.0
                                                    node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Knox_IN0000664 0000000 0000000 00000001770 14746647661 0033311 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              ]      ^,pp#pa	U  5   spyrp[iTp~=I6p^W<G< 7'     pp_pg II ++               w     qp    a    Pp    @    0p    '    	p    	     
p            u             t    t     yV    iV     Y8    I8     9    )     "7p         p        p        p        p     v     !p    "U     #j    $5     %J    &     '*    '    )
c    D/vp    EDQp    E     LMT CDT CST CWT CPT EST 
CST6CDT,M3.2.0,M11.1.0
        Kralendijk                                                                                          0000664 0000000 0000000 00000000227 14746647661 0033777 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                                    .#H]    
LMT -0430 AST 
AST4
                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/La_Paz 0000664 0000000 0000000 00000000252 14746647661 0033144 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    id   , LMT CMT BST -04 
<-04>4
                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Lima   0000664 0000000 0000000 00000000433 14746647661 0032661 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    i#t@JPE@/J-,    P    ]@         p    %    &|    -%P    -@     LMT -04 -05 
<-05>5
                                                                                                                                                                                                                                     Los_Angeles                                                                                         0000664 0000000 0000000 00000002416 14746647661 0034116 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              }      ^H*#pa&t\iip~KIR^-)4GJQ',3qo_O?/v(X fe HG *     )         x     q(    a'    Q
    A	    0    C    	    	     
                                  ys    ir     YU    IT     97    )6     "S    	     5    4                         v+     !    "V     #j    $5     %J    &     '*    '    )
    )    *b    +    ,~    -    .`    /~u    0B    1g     2s$    3Gt     4S    5'V     62    78     8    8     9    :     ;    <    =    >    ?    @o    A    BO    Cd    D/    EDm    E &   LMT PDT PST PWT PPT 
PST8PDT,M3.2.0,M11.1.0
                                                                                                                                                                                                                                                  Louisville                                                                                          0000664 0000000 0000000 00000002332 14746647661 0034047 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              u      ^,pps pNGp#pa	u	pspyrp[iTp~=I6p^)pG< 7'      pp:             w    p`    `p    P`    @p    0`    p    	p    	    
`    p        gp            f    e    yH    iG    Y*    I)    9    )    ")`        `    
p    `    p    `    p    `     v     !`    "U    #j    $5    %J    &    '*s    'p    )
U    )p    *7    +p    ,T`    -ip    .6`    /~Kp    0`    1gg    2r`    3GI    4R`    5'+    62`    7    8    8    9    :    ;    <p    =    >p    ?b    @op    A`    BOp    Cda`    D/vp    EDC`    E    LMT CDT CST CWT CPT EST EDT 
EST5EDT,M3.2.0,M11.1.0
                                                                                                                                                                                                                                                                                                      Lower_Princes                                                                                       0000664 0000000 0000000 00000000227 14746647661 0034474 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                                    .#H]    
LMT -0430 AST 
AST4
                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Maceio 0000664 0000000 0000000 00000000766 14746647661 0033205 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              )      h|I@40t 800Y 0 0T3 ^ d0Q,0 
0}    0    x    5     3    !i0    "    #X    #p     %7    %     0y0    1M    7    8     90    9J     ;    <o   LMT -02 -03 
<-03>3
          node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Managua0000664 0000000 0000000 00000000447 14746647661 0033355 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    i,d-H    Ct`    	>P    Q    oP    1    QP    )a     *KP    +C    2P    BX    C?iP    DTn    EY`     LMT MMT CST EST CDT 
CST6
                                                                                                                                                                                                                         node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Manaus 0000664 0000000 0000000 00000000634 14746647661 0033226 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    DWNB@08@@g0#@0@TA0l0r@,Q:@0
@    @    x    C     3    !w@    "    ,@    -f0   LMT -03 -04 
<-04>4
                                                                                                    node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Marigot0000664 0000000 0000000 00000000202 14746647661 0033373 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                                    73T   LMT AST 
AST4
                                                                                                                                                                                                                                                                                                                                                                                              Martinique                                                                                          0000664 0000000 0000000 00000000262 14746647661 0034036 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                                    iD    Mn@    4    	LMT FFMT AST ADT 
AST4
                                                                                                                                                                                                                                                                                                                                              Matamoros                                                                                           0000664 0000000 0000000 00000000665 14746647661 0033671 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                                     `    "U     #j    1gv     2sp    3GX     4Rp    5':     62p    7     8    8     9    :    ;    <    =    >    ?p    @o    Ap    BO    Cdop    D/    EDQp    Ff    G$3p    G     Ip    Ie     Jp    K=`   LMT CST CDT 
CST6CDT,M3.2.0,M11.1.0
                                                                           Mazatlan                                                                                            0000664 0000000 0000000 00000001316 14746647661 0033470 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              ?      pnfV`C`6`q`      p    1g    2s    3Gf    4R    5'H    62    7*    8     8    9     :    ;     <
    =     >    ?     @o    A    BO    Cd}    D/    ED_    Ft    G$A    G    I#    Is    J    KU    L"     M7    N     Ox    P     Qa5    Rl     SA    TL     U     V,     W     X    X    Y    Z    [l    \    ]N    ^    _0    `i    a~M     bIb    c^/ <     LMT MST CST MDT PST 
MST7
                                                                                                                                                                                                                                                                                                                  node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Mendoza0000664 0000000 0000000 00000001304 14746647661 0033372 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              =      r0{R@@p0}@0x
@Z@;0~`@*0A70@MM0)5Cd=0l02@C0w@65S0R@504@    J    $o    #    $    %7    %v    '4@    '    (g    )H    *@    +W     7    8*    @    AV>    Gw	    G |     LMT CMT -04 -03 -02 
<-03>3
                                                                                                                                                                                                                                                                                                                            Menominee                                                                                           0000664 0000000 0000000 00000001625 14746647661 0033640 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              R      awIc,pp#pa	u @Jg+     @p    0p    '    	p    	     
p            u             t    t     yV    iV     Y8    I8     9    )     "7p         p        p        p        p     v     !p    "U     #j    $5     %J    &     '*    '    )
c    )    *E    +    ,bp    -w    .Dp    /~Y    0&p    1gv     2sp    3GX     4Rp    5':     62p    7     8    8     9    :     ;    <    =    >    ?p    @o    Ap    BO    Cdop    D/    EDQp    E     LMT CDT CST CWT CPT EST 
CST6CDT,M3.2.0,M11.1.0
                                                                                                           node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America/Merida 0000664 0000000 0000000 00000001216 14746647661 0033200 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        TZif2                                            TZif2                              9      `    `    LKP    1gv     2sp    3GX     4Rp    5':     62p    7     8    8     9    :    ;    <    =    >    ?p    @o    Ap    BO    Cdop    D/    EDQp    Ff    G$3p    G     Ip    Ie     Jp    KG     L    M)     N    Ox     P    Qa'    Rl    SA	    TL    U     V,}    W     Xp    X    Y|p    Z    [^p    \     ]@p    ^     _"p    `ir     a~>    bIT     c^     LMT CST EST CDT 
CST6
                                                                                                                                                                                                                                                                                                                                                                                  Metlakatla                                                                                          0000664 0000000 0000000 00000001112 14746647661 0033772 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              +      ?}0#pa&G *     )         x     q(    a'    Q
    A	    0    C    	    	     
                                  ys    ir     YU    IT     97    )6     "S    	     5    V5    VH0    X     X*0    Y     Z0    [     \DF  &     p LMT PST PWT PPT PDT AKST AKDT 
AKST9AKDT,M3.2.0,M11.1.0
                                                                                                                                                                                                                                                                                                                                                                                                                                                      Mexico_City                                                                                         0000664 0000000 0000000 00000001405 14746647661 0034134 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              D      pnfV`C`6``4PUPVPv    1gv     2sp    3GX     4Rp    5':     62p    7     8    8     9    :    ;    <    =    >    ?p    @o    Ap    BO    Cdop    D/    EDQp    Ff    G$3p    G     Ip    Ie     Jp    KG     L    M)     N    Ox     P    Qa'    Rl    SA	    TL    U     V,}    W     Xp    X    Y|p    Z    [^p    \     ]@p    ^     _"p    `ir     a~>    bIT     c^     LMT MST CST MDT CDT CWT 
CST6
                                                                                                                                                                                                                                                           Miquelon                                                                                            0000664 0000000 0000000 00000001046 14746647661 0033512 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/deps/v8/third_party/abseil-cpp/absl/time/internal/cctz/testdata/zoneinfo/America                                                                           TZif2                                            TZif2                              +      (    nc     u    !w@    "U    #j    $5    %Ju    &    '*W    'P    )
9    )P    *    +kP    ,8@    -MP    .@    /~/P    0@    1gK    2r@    3G-    4R@    5'    62@    7    8    8    9    :    ;    <P    =d    >P    ?F    @oP    Ac@    BOxP    CdE@    D/ZP    ED'@    EX    LMT AS