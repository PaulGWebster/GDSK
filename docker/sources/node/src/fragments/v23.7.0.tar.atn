m,
      v8::Local<v8::Object> req_wrap_obj);

  virtual ~StreamReq() = default;
  virtual AsyncWrap* GetAsyncWrap() = 0;
  inline v8::Local<v8::Object> object();

  // TODO(RaisinTen): Update the return type to a Maybe, so that we can indicate
  // if there is a pending exception/termination.
  void Done(int status, const char* error_str = nullptr);
  inline void Dispose();

  StreamBase* stream() const { return stream_; }

  static inline StreamReq* FromObject(v8::Local<v8::Object> req_wrap_obj);

  // Sets all internal fields of `req_wrap_obj` to `nullptr`.
  // This is what the `WriteWrap` and `ShutdownWrap` JS constructors do,
  // and what we use in C++ after creating these objects from their
  // v8::ObjectTemplates, to avoid the overhead of calling the
  // constructor explicitly.
  static inline void ResetObject(v8::Local<v8::Object> req_wrap_obj);

 protected:
  virtual void OnDone(int status) = 0;

  inline void AttachToObject(v8::Local<v8::Object> req_wrap_obj);

 private:
  StreamBase* const stream_;
};

class ShutdownWrap : public StreamReq {
 public:
  inline ShutdownWrap(
      StreamBase* stream,
      v8::Local<v8::Object> req_wrap_obj);

  static inline ShutdownWrap* FromObject(v8::Local<v8::Object> req_wrap_obj);
  template <typename T, bool kIsWeak>
  static inline ShutdownWrap* FromObject(
      const BaseObjectPtrImpl<T, kIsWeak>& base_obj);

  // Call stream()->EmitAfterShutdown() and dispose of this request wrap.
  void OnDone(int status) override;
};

class WriteWrap : public StreamReq {
 public:
  inline void SetBackingStore(std::unique_ptr<v8::BackingStore> bs);

  inline WriteWrap(
      StreamBase* stream,
      v8::Local<v8::Object> req_wrap_obj);

  static inline WriteWrap* FromObject(v8::Local<v8::Object> req_wrap_obj);
  template <typename T, bool kIsWeak>
  static inline WriteWrap* FromObject(
      const BaseObjectPtrImpl<T, kIsWeak>& base_obj);

  // Call stream()->EmitAfterWrite() and dispose of this request wrap.
  void OnDone(int status) override;

 private:
  std::unique_ptr<v8::BackingStore> backing_store_;
};


// This is the generic interface for objects that control Node.js' C++ streams.
// For example, the default `EmitToJSStreamListener` emits a stream's data
// as Buffers in JS, or `TLSWrap` reads and decrypts data from a stream.
class StreamListener {
 public:
  virtual ~StreamListener();

  // This is called when a stream wants to allocate memory before
  // reading data into the freshly allocated buffer (i.e. it is always followed
  // by a `OnStreamRead()` call).
  // This memory may be statically or dynamically allocated; for example,
  // a protocol parser may want to read data into a static buffer if it knows
  // that all data is going to be fully handled during the next
  // `OnStreamRead()` call.
  // The returned buffer does not need to contain `suggested_size` bytes.
  // The default implementation of this method returns a buffer that has exactly
  // the suggested size and is allocated using malloc().
  // It is not valid to return a zero-length buffer from this method.
  // It is not guaranteed that the corresponding `OnStreamRead()` call
  // happens in the same event loop turn as this call.
  virtual uv_buf_t OnStreamAlloc(size_t suggested_size) = 0;

  // `OnStreamRead()` is called when data is available on the socket and has
  // been read into the buffer provided by `OnStreamAlloc()`.
  // The `buf` argument is the return value of `uv_buf_t`, or may be a buffer
  // with base nullptr in case of an error.
  // `nread` is the number of read bytes (which is at most the buffer length),
  // or, if negative, a libuv error code.
  virtual void OnStreamRead(ssize_t nread,
                            const uv_buf_t& buf) = 0;

  // This is called once a write has finished. `status` may be 0 or,
  // if negative, a libuv error code.
  // By default, this is simply passed on to the previous listener
  // (and raises an assertion if there is none).
  virtual void OnStreamAfterWrite(WriteWrap* w, int status);

  // This is called once a shutdown has finished. `status` may be 0 or,
  // if negative, a libuv error code.
  // By default, this is simply passed on to the previous listener
  // (and raises an assertion if there is none).
  virtual void OnStreamAfterShutdown(ShutdownWrap* w, int status);

  // This is called by the stream if it determines that it wants more data
  // to be written to it. Not all streams support this.
  // This callback will not be called as long as there are active writes.
  // It is not supported by all streams; `stream->HasWantsWrite()` returns
  // true if it is supported by a stream.
  virtual void OnStreamWantsWrite(size_t suggested_size) {}

  // This is called immediately before the stream is destroyed.
  virtual void OnStreamDestroy() {}

  // The stream this is currently associated with, or nullptr if there is none.
  StreamResource* stream() const { return stream_; }

 protected:
  // Pass along a read error to the `StreamListener` instance that was active
  // before this one. For example, a protocol parser does not care about read
  // errors and may instead want to let the original handler
  // (e.g. the JS handler) take care of the situation.
  inline void PassReadErrorToPreviousListener(ssize_t nread);

  StreamResource* stream_ = nullptr;
  StreamListener* previous_listener_ = nullptr;

  friend class StreamResource;
};


// An (incomplete) stream listener class that calls the `.oncomplete()`
// method of the JS objects associated with the wrap objects.
class ReportWritesToJSStreamListener : public StreamListener {
 public:
  void OnStreamAfterWrite(WriteWrap* w, int status) override;
  void OnStreamAfterShutdown(ShutdownWrap* w, int status) override;

 private:
  void OnStreamAfterReqFinished(StreamReq* req_wrap, int status);
};


// A default emitter that just pushes data chunks as Buffer instances to
// JS land via the handle’s .ondata method.
class EmitToJSStreamListener : public ReportWritesToJSStreamListener {
 public:
  uv_buf_t OnStreamAlloc(size_t suggested_size) override;
  void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override;
};


// An alternative listener that uses a custom, user-provided buffer
// for reading data.
class CustomBufferJSListener : public ReportWritesToJSStreamListener {
 public:
  uv_buf_t OnStreamAlloc(size_t suggested_size) override;
  void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override;
  void OnStreamDestroy() override { delete this; }

  explicit CustomBufferJSListener(uv_buf_t buffer) : buffer_(buffer) {}

 private:
  uv_buf_t buffer_;
};


// A generic stream, comparable to JS land’s `Duplex` streams.
// A stream is always controlled through one `StreamListener` instance.
class StreamResource {
 public:
  virtual ~StreamResource();

  // These need to be implemented on the readable side of this stream:

  // Start reading from the underlying resource. This is called by the consumer
  // when more data is desired. Use `EmitAlloc()` and `EmitRead()` to
  // pass data along to the consumer.
  virtual int ReadStart() = 0;
  // Stop reading from the underlying resource. This is called by the
  // consumer when its buffers are full and no more data can be handled.
  virtual int ReadStop() = 0;

  // These need to be implemented on the writable side of this stream:
  // All of these methods may return an error code synchronously.
  // In that case, the finish callback should *not* be called.

  // Perform a shutdown operation, and either call req_wrap->Done() when
  // finished and return 0, return 1 for synchronous success, or
  // a libuv error code for synchronous failures.
  virtual int DoShutdown(ShutdownWrap* req_wrap) = 0;
  // Try to write as much data as possible synchronously, and modify
  // `*bufs` and `*count` accordingly. This is a no-op by default.
  // Return 0 for success and a libuv error code for failures.
  virtual int DoTryWrite(uv_buf_t** bufs, size_t* count);
  // Indicates whether this subclass overrides the DoTryWrite
  virtual inline bool HasDoTryWrite() const { return false; }
  // Initiate a write of data.
  // Upon an immediate failure, a libuv error code is returned,
  // w->Done() will never be called and caller should free `bufs`.
  // Otherwise, 0 is returned and w->Done(status) will be called
  // with status set to either
  //  (1) 0 after all data are written, or
  //  (2) a libuv error code when an error occurs
  // in either case, w->Done() will never be called before DoWrite() returns.
  // When 0 is returned:
  //  (1) memory specified by `bufs` and `count` must remain valid until
  //      w->Done() gets called.
  //  (2) `bufs` might or might not be changed, caller should not rely on this.
  //  (3) `bufs` should be freed after w->Done() gets called.
  virtual int DoWrite(WriteWrap* w,
                      uv_buf_t* bufs,
                      size_t count,
                      uv_stream_t* send_handle) = 0;

  // Returns true if the stream supports the `OnStreamWantsWrite()` interface.
  virtual bool HasWantsWrite() const { return false; }

  // Optionally, this may provide an error message to be used for
  // failing writes.
  virtual const char* Error() const;
  // Clear the current error (i.e. that would be returned by Error()).
  virtual void ClearError();

  // Transfer ownership of this stream to `listener`. The previous listener
  // will not receive any more callbacks while the new listener was active.
  inline void PushStreamListener(StreamListener* listener);
  // Remove a listener, and, if this was the currently active one,
  // transfer ownership back to the previous listener.
  void RemoveStreamListener(StreamListener* listener);

 protected:
  // Call the current listener's OnStreamAlloc() method.
  inline uv_buf_t EmitAlloc(size_t suggested_size);
  // Call the current listener's OnStreamRead() method and update the
  // stream's read byte counter.
  inline void EmitRead(
      ssize_t nread,
      const uv_buf_t& buf = uv_buf_init(nullptr, 0));
  // Call the current listener's OnStreamAfterWrite() method.
  inline void EmitAfterWrite(WriteWrap* w, int status);
  // Call the current listener's OnStreamAfterShutdown() method.
  inline void EmitAfterShutdown(ShutdownWrap* w, int status);
  // Call the current listener's OnStreamWantsWrite() method.
  inline void EmitWantsWrite(size_t suggested_size);

  StreamListener* listener_ = nullptr;
  uint64_t bytes_read_ = 0;
  uint64_t bytes_written_ = 0;

  friend class StreamListener;
};


class StreamBase : public StreamResource {
 public:
  // The kSlot field here mirrors that of BaseObject::InternalFields::kSlot
  // because instances deriving from StreamBase generally also derived from
  // BaseObject (it's possible for it not to, however).
  enum InternalFields {
    kSlot = BaseObject::kSlot,
    kStreamBaseField = BaseObject::kInternalFieldCount,
    kOnReadFunctionField,
    kInternalFieldCount
  };

  static void AddMethods(IsolateData* isolate_data,
                         v8::Local<v8::FunctionTemplate> target);
  static void AddMethods(Environment* env,
                         v8::Local<v8::FunctionTemplate> target);
  static void RegisterExternalReferences(ExternalReferenceRegistry* registry);
  virtual bool IsAlive() = 0;
  virtual bool IsClosing() = 0;
  virtual bool IsIPCPipe();
  virtual int GetFD();

  enum StreamBaseJSChecks { DONT_SKIP_NREAD_CHECKS, SKIP_NREAD_CHECKS };

  v8::MaybeLocal<v8::Value> CallJSOnreadMethod(
      ssize_t nread,
      v8::Local<v8::ArrayBuffer> ab,
      size_t offset = 0,
      StreamBaseJSChecks checks = DONT_SKIP_NREAD_CHECKS);

  // This is named `stream_env` to avoid name clashes, because a lot of
  // subclasses are also `BaseObject`s.
  Environment* stream_env() const { return env_; }

  // TODO(RaisinTen): Update the return type to a Maybe, so that we can indicate
  // if there is a pending exception/termination.
  // Shut down the current stream. This request can use an existing
  // ShutdownWrap object (that was created in JS), or a new one will be created.
  // Returns 1 in case of a synchronous completion, 0 in case of asynchronous
  // completion, and a libuv error case in case of synchronous failure.
  int Shutdown(v8::Local<v8::Object> req_wrap_obj = v8::Local<v8::Object>());

  // TODO(RaisinTen): Update the return type to a Maybe, so that we can indicate
  // if there is a pending exception/termination.
  // Write data to the current stream. This request can use an existing
  // WriteWrap object (that was created in JS), or a new one will be created.
  // This will first try to write synchronously using `DoTryWrite()`, then
  // asynchronously using `DoWrite()`.
  // Caller can pass `skip_try_write` as true if it has already called
  // `DoTryWrite()` and ends up with a partial write, or it knows that the
  // write is too large to finish synchronously.
  // If the return value indicates a synchronous completion, no callback will
  // be invoked.
  StreamWriteResult Write(
      uv_buf_t* bufs,
      size_t count,
      uv_stream_t* send_handle = nullptr,
      v8::Local<v8::Object> req_wrap_obj = v8::Local<v8::Object>(),
      bool skip_try_write = false);

  // These can be overridden by subclasses to get more specific wrap instances.
  // For example, a subclass Foo could create a FooWriteWrap or FooShutdownWrap
  // (inheriting from ShutdownWrap/WriteWrap) that has extra fields, like
  // an associated libuv request.
  virtual ShutdownWrap* CreateShutdownWrap(v8::Local<v8::Object> object);
  virtual WriteWrap* CreateWriteWrap(v8::Local<v8::Object> object);

  // One of these must be implemented
  virtual AsyncWrap* GetAsyncWrap() = 0;
  virtual v8::Local<v8::Object> GetObject();

  static inline StreamBase* FromObject(v8::Local<v8::Object> obj);

 protected:
  inline explicit StreamBase(Environment* env);

  // JS Methods
  int ReadStartJS(const v8::FunctionCallbackInfo<v8::Value>& args);
  int ReadStopJS(const v8::FunctionCallbackInfo<v8::Value>& args);
  int Shutdown(const v8::FunctionCallbackInfo<v8::Value>& args);
  int Writev(const v8::FunctionCallbackInfo<v8::Value>& args);
  int WriteBuffer(const v8::FunctionCallbackInfo<v8::Value>& args);
  template <enum encoding enc>
  int WriteString(const v8::FunctionCallbackInfo<v8::Value>& args);
  int UseUserBuffer(const v8::FunctionCallbackInfo<v8::Value>& args);

  static void GetFD(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void GetExternal(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void GetBytesRead(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void GetBytesWritten(const v8::FunctionCallbackInfo<v8::Value>& args);
  inline void AttachToObject(v8::Local<v8::Object> obj);

  template <int (StreamBase::*Method)(
      const v8::FunctionCallbackInfo<v8::Value>& args)>
  static void JSMethod(const v8::FunctionCallbackInfo<v8::Value>& args);

  // Internal, used only in StreamBase methods + env.cc.
  enum StreamBaseStateFields {
    kReadBytesOrError,
    kArrayBufferOffset,
    kBytesWritten,
    kLastWriteWasAsync,
    kNumStreamBaseStateFields
  };

 private:
  Environment* env_;
  EmitToJSStreamListener default_listener_;

  void SetWriteResult(const StreamWriteResult& res);
  static void AddAccessor(v8::Isolate* isolate,
                          v8::Local<v8::Signature> sig,
                          enum v8::PropertyAttribute attributes,
                          v8::Local<v8::FunctionTemplate> t,
                          JSMethodFunction* getter,
                          JSMethodFunction* setter,
                          v8::Local<v8::String> str);
  static void AddMethod(v8::Isolate* isolate,
                        v8::Local<v8::Signature> sig,
                        enum v8::PropertyAttribute attributes,
                        v8::Local<v8::FunctionTemplate> t,
                        JSMethodFunction* stream_method,
                        v8::Local<v8::String> str);

  friend class WriteWrap;
  friend class ShutdownWrap;
  friend class Environment;  // For kNumStreamBaseStateFields.
};


// These are helpers for creating `ShutdownWrap`/`WriteWrap` instances.
// `OtherBase` must have a constructor that matches the `AsyncWrap`
// constructors’s (Environment*, Local<Object>, AsyncWrap::Provider) signature
// and be a subclass of `AsyncWrap`.
template <typename OtherBase>
class SimpleShutdownWrap : public ShutdownWrap, public OtherBase {
 public:
  SimpleShutdownWrap(StreamBase* stream,
                     v8::Local<v8::Object> req_wrap_obj);

  AsyncWrap* GetAsyncWrap() override { return this; }

  SET_NO_MEMORY_INFO()
  SET_MEMORY_INFO_NAME(SimpleShutdownWrap)
  SET_SELF_SIZE(SimpleShutdownWrap)

  bool IsNotIndicativeOfMemoryLeakAtExit() const override {
    return OtherBase::IsNotIndicativeOfMemoryLeakAtExit();
  }
};

template <typename OtherBase>
class SimpleWriteWrap : public WriteWrap, public OtherBase {
 public:
  SimpleWriteWrap(StreamBase* stream,
                  v8::Local<v8::Object> req_wrap_obj);

  AsyncWrap* GetAsyncWrap() override { return this; }

  SET_NO_MEMORY_INFO()
  SET_MEMORY_INFO_NAME(SimpleWriteWrap)
  SET_SELF_SIZE(SimpleWriteWrap)

  bool IsNotIndicativeOfMemoryLeakAtExit() const override {
    return OtherBase::IsNotIndicativeOfMemoryLeakAtExit();
  }
};

}  // namespace node

#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#endif  // SRC_STREAM_BASE_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/src/stream_pipe.cc                                                                      0000664 0000000 0000000 00000025422 14746647661 0016170 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "stream_pipe.h"
#include "stream_base-inl.h"
#include "node_buffer.h"
#include "util-inl.h"

namespace node {

using v8::BackingStore;
using v8::Context;
using v8::Function;
using v8::FunctionCallbackInfo;
using v8::FunctionTemplate;
using v8::HandleScope;
using v8::Isolate;
using v8::Just;
using v8::Local;
using v8::Maybe;
using v8::Nothing;
using v8::Object;
using v8::Value;

StreamPipe::StreamPipe(StreamBase* source,
                       StreamBase* sink,
                       Local<Object> obj)
    : AsyncWrap(source->stream_env(), obj, AsyncWrap::PROVIDER_STREAMPIPE) {
  MakeWeak();

  CHECK_NOT_NULL(sink);
  CHECK_NOT_NULL(source);

  source->PushStreamListener(&readable_listener_);
  sink->PushStreamListener(&writable_listener_);

  uses_wants_write_ = sink->HasWantsWrite();
}

StreamPipe::~StreamPipe() {
  Unpipe(true);
}

StreamBase* StreamPipe::source() {
  return static_cast<StreamBase*>(readable_listener_.stream());
}

StreamBase* StreamPipe::sink() {
  return static_cast<StreamBase*>(writable_listener_.stream());
}

void StreamPipe::Unpipe(bool is_in_deletion) {
  if (is_closed_)
    return;

  // Note that we possibly cannot use virtual methods on `source` and `sink`
  // here, because this function can be called from their destructors via
  // `OnStreamDestroy()`.
  if (!source_destroyed_)
    source()->ReadStop();

  is_closed_ = true;
  is_reading_ = false;
  source()->RemoveStreamListener(&readable_listener_);
  if (pending_writes_ == 0)
    sink()->RemoveStreamListener(&writable_listener_);

  if (is_in_deletion) return;

  // Delay the JS-facing part with SetImmediate, because this might be from
  // inside the garbage collector, so we can’t run JS here.
  HandleScope handle_scope(env()->isolate());
  BaseObjectPtr<StreamPipe> strong_ref{this};
  env()->SetImmediate([this, strong_ref](Environment* env) {
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());
    Local<Object> object = this->object();

    Local<Value> onunpipe;
    if (!object->Get(env->context(), env->onunpipe_string()).ToLocal(&onunpipe))
      return;
    if (onunpipe->IsFunction() &&
        MakeCallback(onunpipe.As<Function>(), 0, nullptr).IsEmpty()) {
      return;
    }

    // Set all the links established in the constructor to `null`.
    Local<Value> null = Null(env->isolate());

    Local<Value> source_v;
    Local<Value> sink_v;
    if (!object->Get(env->context(), env->source_string()).ToLocal(&source_v) ||
        !object->Get(env->context(), env->sink_string()).ToLocal(&sink_v) ||
        !source_v->IsObject() || !sink_v->IsObject()) {
      return;
    }

    if (object->Set(env->context(), env->source_string(), null).IsNothing() ||
        object->Set(env->context(), env->sink_string(), null).IsNothing() ||
        source_v.As<Object>()
            ->Set(env->context(), env->pipe_target_string(), null)
            .IsNothing() ||
        sink_v.As<Object>()
            ->Set(env->context(), env->pipe_source_string(), null)
            .IsNothing()) {
      return;
    }
  });
}

uv_buf_t StreamPipe::ReadableListener::OnStreamAlloc(size_t suggested_size) {
  StreamPipe* pipe = ContainerOf(&StreamPipe::readable_listener_, this);
  size_t size = std::min(suggested_size, pipe->wanted_data_);
  CHECK_GT(size, 0);
  return pipe->env()->allocate_managed_buffer(size);
}

void StreamPipe::ReadableListener::OnStreamRead(ssize_t nread,
                                                const uv_buf_t& buf_) {
  StreamPipe* pipe = ContainerOf(&StreamPipe::readable_listener_, this);
  std::unique_ptr<BackingStore> bs = pipe->env()->release_managed_buffer(buf_);
  if (nread < 0) {
    // EOF or error; stop reading and pass the error to the previous listener
    // (which might end up in JS).
    pipe->is_eof_ = true;
    // Cache `sink()` here because the previous listener might do things
    // that eventually lead to an `Unpipe()` call.
    StreamBase* sink = pipe->sink();
    stream()->ReadStop();
    CHECK_NOT_NULL(previous_listener_);
    previous_listener_->OnStreamRead(nread, uv_buf_init(nullptr, 0));
    // If we’re not writing, close now. Otherwise, we’ll do that in
    // `OnStreamAfterWrite()`.
    if (pipe->pending_writes_ == 0) {
      sink->Shutdown();
      pipe->Unpipe();
    }
    return;
  }

  pipe->ProcessData(nread, std::move(bs));
}

void StreamPipe::ProcessData(size_t nread,
                             std::unique_ptr<BackingStore> bs) {
  CHECK(uses_wants_write_ || pending_writes_ == 0);
  uv_buf_t buffer = uv_buf_init(static_cast<char*>(bs->Data()), nread);
  StreamWriteResult res = sink()->Write(&buffer, 1);
  pending_writes_++;
  if (!res.async) {
    writable_listener_.OnStreamAfterWrite(nullptr, res.err);
  } else {
    is_reading_ = false;
    res.wrap->SetBackingStore(std::move(bs));
    if (source() != nullptr)
      source()->ReadStop();
  }
}

void StreamPipe::WritableListener::OnStreamAfterWrite(WriteWrap* w,
                                                      int status) {
  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);
  pipe->pending_writes_--;
  if (pipe->is_closed_) {
    if (pipe->pending_writes_ == 0) {
      Environment* env = pipe->env();
      HandleScope handle_scope(env->isolate());
      Context::Scope context_scope(env->context());
      if (pipe->MakeCallback(env->oncomplete_string(), 0, nullptr).IsEmpty())
        return;
      stream()->RemoveStreamListener(this);
    }
    return;
  }

  if (pipe->is_eof_) {
    HandleScope handle_scope(pipe->env()->isolate());
    InternalCallbackScope callback_scope(pipe,
        InternalCallbackScope::kSkipTaskQueues);
    pipe->sink()->Shutdown();
    pipe->Unpipe();
    return;
  }

  if (status != 0) {
    CHECK_NOT_NULL(previous_listener_);
    StreamListener* prev = previous_listener_;
    pipe->Unpipe();
    prev->OnStreamAfterWrite(w, status);
    return;
  }

  if (!pipe->uses_wants_write_) {
    OnStreamWantsWrite(65536);
  }
}

void StreamPipe::WritableListener::OnStreamAfterShutdown(ShutdownWrap* w,
                                                         int status) {
  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);
  CHECK_NOT_NULL(previous_listener_);
  StreamListener* prev = previous_listener_;
  pipe->Unpipe();
  prev->OnStreamAfterShutdown(w, status);
}

void StreamPipe::ReadableListener::OnStreamDestroy() {
  StreamPipe* pipe = ContainerOf(&StreamPipe::readable_listener_, this);
  pipe->source_destroyed_ = true;
  if (!pipe->is_eof_) {
    OnStreamRead(UV_EPIPE, uv_buf_init(nullptr, 0));
  }
}

void StreamPipe::WritableListener::OnStreamDestroy() {
  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);
  pipe->sink_destroyed_ = true;
  pipe->is_eof_ = true;
  pipe->pending_writes_ = 0;
  pipe->Unpipe();
}

void StreamPipe::WritableListener::OnStreamWantsWrite(size_t suggested_size) {
  StreamPipe* pipe = ContainerOf(&StreamPipe::writable_listener_, this);
  pipe->wanted_data_ = suggested_size;
  if (pipe->is_reading_ || pipe->is_closed_)
    return;
  HandleScope handle_scope(pipe->env()->isolate());
  InternalCallbackScope callback_scope(pipe,
      InternalCallbackScope::kSkipTaskQueues);
  pipe->is_reading_ = true;
  pipe->source()->ReadStart();
}

uv_buf_t StreamPipe::WritableListener::OnStreamAlloc(size_t suggested_size) {
  CHECK_NOT_NULL(previous_listener_);
  return previous_listener_->OnStreamAlloc(suggested_size);
}

void StreamPipe::WritableListener::OnStreamRead(ssize_t nread,
                                                const uv_buf_t& buf) {
  CHECK_NOT_NULL(previous_listener_);
  return previous_listener_->OnStreamRead(nread, buf);
}

Maybe<StreamPipe*> StreamPipe::New(StreamBase* source,
                                   StreamBase* sink,
                                   Local<Object> obj) {
  std::unique_ptr<StreamPipe> stream_pipe(new StreamPipe(source, sink, obj));

  // Set up links between this object and the source/sink objects.
  // In particular, this makes sure that they are garbage collected as a group,
  // if that applies to the given streams (for example, Http2Streams use
  // weak references).
  Environment* env = source->stream_env();
  if (obj->Set(env->context(), env->source_string(), source->GetObject())
          .IsNothing()) {
    return Nothing<StreamPipe*>();
  }
  if (source->GetObject()
          ->Set(env->context(), env->pipe_target_string(), obj)
          .IsNothing()) {
    return Nothing<StreamPipe*>();
  }
  if (obj->Set(env->context(), env->sink_string(), sink->GetObject())
          .IsNothing()) {
    return Nothing<StreamPipe*>();
  }
  if (sink->GetObject()
          ->Set(env->context(), env->pipe_source_string(), obj)
          .IsNothing()) {
    return Nothing<StreamPipe*>();
  }

  return Just(stream_pipe.release());
}

void StreamPipe::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsObject());
  StreamBase* source = StreamBase::FromObject(args[0].As<Object>());
  StreamBase* sink = StreamBase::FromObject(args[1].As<Object>());

  if (StreamPipe::New(source, sink, args.This()).IsNothing()) return;
}

void StreamPipe::Start(const FunctionCallbackInfo<Value>& args) {
  StreamPipe* pipe;
  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.This());
  pipe->is_closed_ = false;
  pipe->writable_listener_.OnStreamWantsWrite(65536);
}

void StreamPipe::Unpipe(const FunctionCallbackInfo<Value>& args) {
  StreamPipe* pipe;
  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.This());
  pipe->Unpipe();
}

void StreamPipe::IsClosed(const FunctionCallbackInfo<Value>& args) {
  StreamPipe* pipe;
  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.This());
  args.GetReturnValue().Set(pipe->is_closed_);
}

void StreamPipe::PendingWrites(const FunctionCallbackInfo<Value>& args) {
  StreamPipe* pipe;
  ASSIGN_OR_RETURN_UNWRAP(&pipe, args.This());
  args.GetReturnValue().Set(pipe->pending_writes_);
}

namespace {

void InitializeStreamPipe(Local<Object> target,
                          Local<Value> unused,
                          Local<Context> context,
                          void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  // Create FunctionTemplate for FileHandle::CloseReq
  Local<FunctionTemplate> pipe = NewFunctionTemplate(isolate, StreamPipe::New);
  SetProtoMethod(isolate, pipe, "unpipe", StreamPipe::Unpipe);
  SetProtoMethod(isolate, pipe, "start", StreamPipe::Start);
  SetProtoMethod(isolate, pipe, "isClosed", StreamPipe::IsClosed);
  SetProtoMethod(isolate, pipe, "pendingWrites", StreamPipe::PendingWrites);
  pipe->Inherit(AsyncWrap::GetConstructorTemplate(env));
  pipe->InstanceTemplate()->SetInternalFieldCount(
      StreamPipe::kInternalFieldCount);
  SetConstructorFunction(context, target, "StreamPipe", pipe);
}

}  // anonymous namespace

}  // namespace node

NODE_BINDING_CONTEXT_AWARE_INTERNAL(stream_pipe, node::InitializeStreamPipe)
                                                                                                                                                                                                                                              node-23.7.0/src/stream_pipe.h                                                                       0000664 0000000 0000000 00000004613 14746647661 0016031 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #ifndef SRC_STREAM_PIPE_H_
#define SRC_STREAM_PIPE_H_

#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#include "stream_base.h"

namespace node {

class StreamPipe : public AsyncWrap {
 public:
  ~StreamPipe() override;

  void Unpipe(bool is_in_deletion = false);

  static v8::Maybe<StreamPipe*> New(StreamBase* source,
                                    StreamBase* sink,
                                    v8::Local<v8::Object> obj);
  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void Start(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void Unpipe(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void IsClosed(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void PendingWrites(const v8::FunctionCallbackInfo<v8::Value>& args);

  SET_NO_MEMORY_INFO()
  SET_MEMORY_INFO_NAME(StreamPipe)
  SET_SELF_SIZE(StreamPipe)

 private:
  StreamPipe(StreamBase* source, StreamBase* sink, v8::Local<v8::Object> obj);

  inline StreamBase* source();
  inline StreamBase* sink();

  int pending_writes_ = 0;
  bool is_reading_ = false;
  bool is_eof_ = false;
  bool is_closed_ = true;
  bool sink_destroyed_ = false;
  bool source_destroyed_ = false;
  bool uses_wants_write_ = false;

  // Set a default value so that when we’re coming from Start(), we know
  // that we don’t want to read just yet.
  // This will likely need to be changed when supporting streams without
  // `OnStreamWantsWrite()` support.
  size_t wanted_data_ = 0;

  void ProcessData(size_t nread, std::unique_ptr<v8::BackingStore> bs);

  class ReadableListener : public StreamListener {
   public:
    uv_buf_t OnStreamAlloc(size_t suggested_size) override;
    void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override;
    void OnStreamDestroy() override;
  };

  class WritableListener : public StreamListener {
   public:
    uv_buf_t OnStreamAlloc(size_t suggested_size) override;
    void OnStreamRead(ssize_t nread, const uv_buf_t& buf) override;
    void OnStreamAfterWrite(WriteWrap* w, int status) override;
    void OnStreamAfterShutdown(ShutdownWrap* w, int status) override;
    void OnStreamWantsWrite(size_t suggested_size) override;
    void OnStreamDestroy() override;
  };

  ReadableListener readable_listener_;
  WritableListener writable_listener_;
};

}  // namespace node

#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#endif  // SRC_STREAM_PIPE_H_
                                                                                                                     node-23.7.0/src/stream_wrap.cc                                                                      0000664 0000000 0000000 00000031535 14746647661 0016206 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

#include "stream_wrap.h"
#include "stream_base-inl.h"

#include "env-inl.h"
#include "handle_wrap.h"
#include "node_buffer.h"
#include "node_errors.h"
#include "node_external_reference.h"
#include "pipe_wrap.h"
#include "req_wrap-inl.h"
#include "tcp_wrap.h"
#include "udp_wrap.h"
#include "util-inl.h"

#include <cstring>  // memcpy()
#include <climits>  // INT_MAX


namespace node {

using errors::TryCatchScope;
using v8::Context;
using v8::DontDelete;
using v8::EscapableHandleScope;
using v8::FunctionCallbackInfo;
using v8::FunctionTemplate;
using v8::HandleScope;
using v8::Isolate;
using v8::JustVoid;
using v8::Local;
using v8::Maybe;
using v8::MaybeLocal;
using v8::Nothing;
using v8::Object;
using v8::PropertyAttribute;
using v8::ReadOnly;
using v8::Signature;
using v8::Value;

void IsConstructCallCallback(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  StreamReq::ResetObject(args.This());
}

void LibuvStreamWrap::Initialize(Local<Object> target,
                                 Local<Value> unused,
                                 Local<Context> context,
                                 void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> sw =
      NewFunctionTemplate(isolate, IsConstructCallCallback);
  sw->InstanceTemplate()->SetInternalFieldCount(StreamReq::kInternalFieldCount);

  // we need to set handle and callback to null,
  // so that those fields are created and functions
  // do not become megamorphic
  // Fields:
  // - oncomplete
  // - callback
  // - handle
  sw->InstanceTemplate()->Set(env->oncomplete_string(), v8::Null(isolate));
  sw->InstanceTemplate()->Set(FIXED_ONE_BYTE_STRING(isolate, "callback"),
                              v8::Null(isolate));
  sw->InstanceTemplate()->Set(FIXED_ONE_BYTE_STRING(isolate, "handle"),
                              v8::Null(isolate));

  sw->Inherit(AsyncWrap::GetConstructorTemplate(env));

  SetConstructorFunction(context, target, "ShutdownWrap", sw);
  env->set_shutdown_wrap_template(sw->InstanceTemplate());

  Local<FunctionTemplate> ww =
      FunctionTemplate::New(isolate, IsConstructCallCallback);
  ww->InstanceTemplate()->SetInternalFieldCount(
      StreamReq::kInternalFieldCount);
  ww->Inherit(AsyncWrap::GetConstructorTemplate(env));
  SetConstructorFunction(context, target, "WriteWrap", ww);
  env->set_write_wrap_template(ww->InstanceTemplate());

  NODE_DEFINE_CONSTANT(target, kReadBytesOrError);
  NODE_DEFINE_CONSTANT(target, kArrayBufferOffset);
  NODE_DEFINE_CONSTANT(target, kBytesWritten);
  NODE_DEFINE_CONSTANT(target, kLastWriteWasAsync);
  target
      ->Set(context,
            FIXED_ONE_BYTE_STRING(isolate, "streamBaseState"),
            env->stream_base_state().GetJSArray())
      .Check();
}

void LibuvStreamWrap::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(IsConstructCallCallback);
  registry->Register(GetWriteQueueSize);
  registry->Register(SetBlocking);
  StreamBase::RegisterExternalReferences(registry);
}

LibuvStreamWrap::LibuvStreamWrap(Environment* env,
                                 Local<Object> object,
                                 uv_stream_t* stream,
                                 AsyncWrap::ProviderType provider)
    : HandleWrap(env,
                 object,
                 reinterpret_cast<uv_handle_t*>(stream),
                 provider),
      StreamBase(env),
      stream_(stream) {
  StreamBase::AttachToObject(object);
}


Local<FunctionTemplate> LibuvStreamWrap::GetConstructorTemplate(
    Environment* env) {
  Local<FunctionTemplate> tmpl = env->libuv_stream_wrap_ctor_template();
  if (tmpl.IsEmpty()) {
    Isolate* isolate = env->isolate();
    tmpl = NewFunctionTemplate(isolate, nullptr);
    tmpl->SetClassName(FIXED_ONE_BYTE_STRING(isolate, "LibuvStreamWrap"));
    tmpl->Inherit(HandleWrap::GetConstructorTemplate(env));
    tmpl->InstanceTemplate()->SetInternalFieldCount(
        StreamBase::kInternalFieldCount);
    Local<FunctionTemplate> get_write_queue_size =
        FunctionTemplate::New(isolate,
                              GetWriteQueueSize,
                              Local<Value>(),
                              Signature::New(isolate, tmpl));
    tmpl->PrototypeTemplate()->SetAccessorProperty(
        env->write_queue_size_string(),
        get_write_queue_size,
        Local<FunctionTemplate>(),
        static_cast<PropertyAttribute>(ReadOnly | DontDelete));
    SetProtoMethod(isolate, tmpl, "setBlocking", SetBlocking);
    StreamBase::AddMethods(env, tmpl);
    env->set_libuv_stream_wrap_ctor_template(tmpl);
  }
  return tmpl;
}


LibuvStreamWrap* LibuvStreamWrap::From(Environment* env, Local<Object> object) {
  Local<FunctionTemplate> sw = env->libuv_stream_wrap_ctor_template();
  CHECK(!sw.IsEmpty() && sw->HasInstance(object));
  return Unwrap<LibuvStreamWrap>(object);
}


int LibuvStreamWrap::GetFD() {
#ifdef _WIN32
  return fd_;
#else
  int fd = -1;
  if (stream() != nullptr)
    uv_fileno(reinterpret_cast<uv_handle_t*>(stream()), &fd);
  return fd;
#endif
}


bool LibuvStreamWrap::IsAlive() {
  return HandleWrap::IsAlive(this);
}


bool LibuvStreamWrap::IsClosing() {
  return uv_is_closing(reinterpret_cast<uv_handle_t*>(stream()));
}


AsyncWrap* LibuvStreamWrap::GetAsyncWrap() {
  return static_cast<AsyncWrap*>(this);
}


bool LibuvStreamWrap::IsIPCPipe() {
  return is_named_pipe_ipc();
}

int LibuvStreamWrap::ReadStart() {
  return uv_read_start(
      stream(),
      [](uv_handle_t* handle, size_t suggested_size, uv_buf_t* buf) {
        static_cast<LibuvStreamWrap*>(handle->data)
            ->OnUvAlloc(suggested_size, buf);
      },
      [](uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf) {
        LibuvStreamWrap* wrap = static_cast<LibuvStreamWrap*>(stream->data);
        TryCatchScope try_catch(wrap->env());
        try_catch.SetVerbose(true);
        wrap->OnUvRead(nread, buf);
      });
}


int LibuvStreamWrap::ReadStop() {
  return uv_read_stop(stream());
}


void LibuvStreamWrap::OnUvAlloc(size_t suggested_size, uv_buf_t* buf) {
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());

  *buf = EmitAlloc(suggested_size);
}

template <class WrapType>
static MaybeLocal<Object> AcceptHandle(Environment* env,
                                       LibuvStreamWrap* parent) {
  static_assert(std::is_base_of<LibuvStreamWrap, WrapType>::value ||
                std::is_base_of<UDPWrap, WrapType>::value,
                "Can only accept stream handles");

  EscapableHandleScope scope(env->isolate());
  Local<Object> wrap_obj;

  if (!WrapType::Instantiate(env, parent, WrapType::SOCKET).ToLocal(&wrap_obj))
    return Local<Object>();

  HandleWrap* wrap = BaseObject::Unwrap<HandleWrap>(wrap_obj);
  CHECK_NOT_NULL(wrap);
  uv_stream_t* stream = reinterpret_cast<uv_stream_t*>(wrap->GetHandle());
  CHECK_NOT_NULL(stream);

  if (uv_accept(parent->stream(), stream))
    ABORT();

  return scope.Escape(wrap_obj);
}

Maybe<void> LibuvStreamWrap::OnUvRead(ssize_t nread, const uv_buf_t* buf) {
  HandleScope scope(env()->isolate());
  Context::Scope context_scope(env()->context());
  uv_handle_type type = UV_UNKNOWN_HANDLE;

  if (is_named_pipe_ipc() &&
      uv_pipe_pending_count(reinterpret_cast<uv_pipe_t*>(stream())) > 0) {
    type = uv_pipe_pending_type(reinterpret_cast<uv_pipe_t*>(stream()));
  }

  // We should not be getting this callback if someone has already called
  // uv_close() on the handle.
  CHECK_EQ(persistent().IsEmpty(), false);

  if (nread > 0) {
    MaybeLocal<Object> pending_obj;

    if (type == UV_TCP) {
      pending_obj = AcceptHandle<TCPWrap>(env(), this);
    } else if (type == UV_NAMED_PIPE) {
      pending_obj = AcceptHandle<PipeWrap>(env(), this);
    } else if (type == UV_UDP) {
      pending_obj = AcceptHandle<UDPWrap>(env(), this);
    } else {
      CHECK_EQ(type, UV_UNKNOWN_HANDLE);
    }

    Local<Object> local_pending_obj;
    if (type != UV_UNKNOWN_HANDLE &&
        (!pending_obj.ToLocal(&local_pending_obj) ||
         object()
             ->Set(env()->context(),
                   env()->pending_handle_string(),
                   local_pending_obj)
             .IsNothing())) {
      return Nothing<void>();
    }
  }

  EmitRead(nread, *buf);
  return JustVoid();
}

void LibuvStreamWrap::GetWriteQueueSize(
    const FunctionCallbackInfo<Value>& info) {
  LibuvStreamWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, info.This());

  if (wrap->stream() == nullptr) {
    info.GetReturnValue().Set(0);
    return;
  }

  uint32_t write_queue_size = wrap->stream()->write_queue_size;
  info.GetReturnValue().Set(write_queue_size);
}


void LibuvStreamWrap::SetBlocking(const FunctionCallbackInfo<Value>& args) {
  LibuvStreamWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(&wrap, args.This());

  CHECK_GT(args.Length(), 0);
  if (!wrap->IsAlive())
    return args.GetReturnValue().Set(UV_EINVAL);

  bool enable = args[0]->IsTrue();
  args.GetReturnValue().Set(uv_stream_set_blocking(wrap->stream(), enable));
}

typedef SimpleShutdownWrap<ReqWrap<uv_shutdown_t>> LibuvShutdownWrap;
typedef SimpleWriteWrap<ReqWrap<uv_write_t>> LibuvWriteWrap;

ShutdownWrap* LibuvStreamWrap::CreateShutdownWrap(Local<Object> object) {
  return new LibuvShutdownWrap(this, object);
}

WriteWrap* LibuvStreamWrap::CreateWriteWrap(Local<Object> object) {
  return new LibuvWriteWrap(this, object);
}


int LibuvStreamWrap::DoShutdown(ShutdownWrap* req_wrap_) {
  LibuvShutdownWrap* req_wrap = static_cast<LibuvShutdownWrap*>(req_wrap_);
  return req_wrap->Dispatch(uv_shutdown, stream(), AfterUvShutdown);
}


void LibuvStreamWrap::AfterUvShutdown(uv_shutdown_t* req, int status) {
  LibuvShutdownWrap* req_wrap = static_cast<LibuvShutdownWrap*>(
      LibuvShutdownWrap::from_req(req));
  CHECK_NOT_NULL(req_wrap);
  HandleScope scope(req_wrap->env()->isolate());
  Context::Scope context_scope(req_wrap->env()->context());
  req_wrap->Done(status);
}


// NOTE: Call to this function could change both `buf`'s and `count`'s
// values, shifting their base and decrementing their length. This is
// required in order to skip the data that was successfully written via
// uv_try_write().
int LibuvStreamWrap::DoTryWrite(uv_buf_t** bufs, size_t* count) {
  int err;
  size_t written;
  uv_buf_t* vbufs = *bufs;
  size_t vcount = *count;

  err = uv_try_write(stream(), vbufs, vcount);
  if (err == UV_ENOSYS || err == UV_EAGAIN)
    return 0;
  if (err < 0)
    return err;

  // Slice off the buffers: skip all written buffers and slice the one that
  // was partially written.
  written = err;
  for (; vcount > 0; vbufs++, vcount--) {
    // Slice
    if (vbufs[0].len > written) {
      vbufs[0].base += written;
      vbufs[0].len -= written;
      written = 0;
      break;

    // Discard
    } else {
      written -= vbufs[0].len;
    }
  }

  *bufs = vbufs;
  *count = vcount;

  return 0;
}


int LibuvStreamWrap::DoWrite(WriteWrap* req_wrap,
                             uv_buf_t* bufs,
                             size_t count,
                             uv_stream_t* send_handle) {
  LibuvWriteWrap* w = static_cast<LibuvWriteWrap*>(req_wrap);
  return w->Dispatch(uv_write2,
                     stream(),
                     bufs,
                     count,
                     send_handle,
                     AfterUvWrite);
}



void LibuvStreamWrap::AfterUvWrite(uv_write_t* req, int status) {
  LibuvWriteWrap* req_wrap = static_cast<LibuvWriteWrap*>(
      LibuvWriteWrap::from_req(req));
  CHECK_NOT_NULL(req_wrap);
  HandleScope scope(req_wrap->env()->isolate());
  Context::Scope context_scope(req_wrap->env()->context());
  req_wrap->Done(status);
}

}  // namespace node

NODE_BINDING_CONTEXT_AWARE_INTERNAL(stream_wrap,
                                    node::LibuvStreamWrap::Initialize)
NODE_BINDING_EXTERNAL_REFERENCE(
    stream_wrap, node::LibuvStreamWrap::RegisterExternalReferences)
                                                                                                                                                                   node-23.7.0/src/stream_wrap.h                                                                       0000664 0000000 0000000 00000010325 14746647661 0016042 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

#ifndef SRC_STREAM_WRAP_H_
#define SRC_STREAM_WRAP_H_

#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#include "stream_base.h"
#include "handle_wrap.h"
#include "v8.h"

namespace node {

class Environment;
class ExternalReferenceRegistry;

class LibuvStreamWrap : public HandleWrap, public StreamBase {
 public:
  static void Initialize(v8::Local<v8::Object> target,
                         v8::Local<v8::Value> unused,
                         v8::Local<v8::Context> context,
                         void* priv);
  static void RegisterExternalReferences(ExternalReferenceRegistry* registry);
  int GetFD() override;
  bool IsAlive() override;
  bool IsClosing() override;
  bool IsIPCPipe() override;

  // JavaScript functions
  int ReadStart() override;
  int ReadStop() override;

  // Resource implementation
  int DoShutdown(ShutdownWrap* req_wrap) override;
  int DoTryWrite(uv_buf_t** bufs, size_t* count) override;
  inline bool HasDoTryWrite() const override { return true; }
  int DoWrite(WriteWrap* w,
              uv_buf_t* bufs,
              size_t count,
              uv_stream_t* send_handle) override;

  inline uv_stream_t* stream() const {
    return stream_;
  }

  inline bool is_named_pipe() const {
    return stream()->type == UV_NAMED_PIPE;
  }

  inline bool is_named_pipe_ipc() const {
    return is_named_pipe() &&
           reinterpret_cast<const uv_pipe_t*>(stream())->ipc != 0;
  }

  inline bool is_tcp() const {
    return stream()->type == UV_TCP;
  }

  ShutdownWrap* CreateShutdownWrap(v8::Local<v8::Object> object) override;
  WriteWrap* CreateWriteWrap(v8::Local<v8::Object> object) override;

  static LibuvStreamWrap* From(Environment* env, v8::Local<v8::Object> object);

 protected:
  LibuvStreamWrap(Environment* env,
                  v8::Local<v8::Object> object,
                  uv_stream_t* stream,
                  AsyncWrap::ProviderType provider);

  AsyncWrap* GetAsyncWrap() override;

  static v8::Local<v8::FunctionTemplate> GetConstructorTemplate(
      Environment* env);

 protected:
  inline void set_fd(int fd) {
#ifdef _WIN32
    fd_ = fd;
#endif
  }


 private:
  static void GetWriteQueueSize(
      const v8::FunctionCallbackInfo<v8::Value>& info);
  static void SetBlocking(const v8::FunctionCallbackInfo<v8::Value>& args);

  // Callbacks for libuv
  void OnUvAlloc(size_t suggested_size, uv_buf_t* buf);
  v8::Maybe<void> OnUvRead(ssize_t nread, const uv_buf_t* buf);

  static void AfterUvWrite(uv_write_t* req, int status);
  static void AfterUvShutdown(uv_shutdown_t* req, int status);

  uv_stream_t* const stream_;

#ifdef _WIN32
  // We don't always have an FD that we could look up on the stream_
  // object itself on Windows. However, for some cases, we open handles
  // using FDs; In that case, we can store and provide the value.
  // This became necessary because it allows to detect situations
  // where multiple handles refer to the same stdio FDs (in particular,
  // a possible IPC channel and a regular process.std??? stream).
  int fd_ = -1;
#endif
};


}  // namespace node

#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#endif  // SRC_STREAM_WRAP_H_
                                                                                                                                                                                                                                                                                                           node-23.7.0/src/string_bytes.cc                                                                     0000664 0000000 0000000 00000053240 14746647661 0016373 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

#include "string_bytes.h"

#include "env-inl.h"
#include "nbytes.h"
#include "node_buffer.h"
#include "node_errors.h"
#include "simdutf.h"
#include "util.h"

#include <climits>
#include <cstring>  // memcpy

#include <algorithm>

// When creating strings >= this length v8's gc spins up and consumes
// most of the execution time. For these cases it's more performant to
// use external string resources.
#define EXTERN_APEX 0xFBEE9

namespace node {

using v8::HandleScope;
using v8::Isolate;
using v8::Just;
using v8::Local;
using v8::Maybe;
using v8::MaybeLocal;
using v8::Nothing;
using v8::String;
using v8::Value;

namespace {

template <typename ResourceType, typename TypeName>
class ExternString: public ResourceType {
 public:
  ~ExternString() override {
    free(const_cast<TypeName*>(data_));
    isolate()->AdjustAmountOfExternalAllocatedMemory(-byte_length());
  }

  const TypeName* data() const override {
    return data_;
  }

  size_t length() const override {
    return length_;
  }

  int64_t byte_length() const {
    return length() * sizeof(*data());
  }

  static MaybeLocal<Value> NewFromCopy(Isolate* isolate,
                                       const TypeName* data,
                                       size_t length,
                                       Local<Value>* error) {
    if (length == 0)
      return String::Empty(isolate);

    if (length < EXTERN_APEX)
      return NewSimpleFromCopy(isolate, data, length, error);

    TypeName* new_data = node::UncheckedMalloc<TypeName>(length);
    if (new_data == nullptr) {
      *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return MaybeLocal<Value>();
    }
    memcpy(new_data, data, length * sizeof(*new_data));

    return ExternString<ResourceType, TypeName>::New(isolate,
                                                     new_data,
                                                     length,
                                                     error);
  }

  // uses "data" for external resource, and will be free'd on gc
  static MaybeLocal<Value> New(Isolate* isolate,
                               TypeName* data,
                               size_t length,
                               Local<Value>* error) {
    if (length == 0)
      return String::Empty(isolate);

    if (length < EXTERN_APEX) {
      MaybeLocal<Value> str = NewSimpleFromCopy(isolate, data, length, error);
      free(data);
      return str;
    }

    ExternString* h_str = new ExternString<ResourceType, TypeName>(isolate,
                                                                   data,
                                                                   length);
    MaybeLocal<Value> str = NewExternal(isolate, h_str);
    isolate->AdjustAmountOfExternalAllocatedMemory(h_str->byte_length());

    if (str.IsEmpty()) {
      delete h_str;
      *error = node::ERR_STRING_TOO_LONG(isolate);
      return MaybeLocal<Value>();
    }

    return str.ToLocalChecked();
  }

  inline Isolate* isolate() const { return isolate_; }

 private:
  ExternString(Isolate* isolate, const TypeName* data, size_t length)
    : isolate_(isolate), data_(data), length_(length) { }
  static MaybeLocal<Value> NewExternal(Isolate* isolate,
                                       ExternString* h_str);

  // This method does not actually create ExternString instances.
  static MaybeLocal<Value> NewSimpleFromCopy(Isolate* isolate,
                                             const TypeName* data,
                                             size_t length,
                                             Local<Value>* error);

  Isolate* isolate_;
  const TypeName* data_;
  size_t length_;
};


typedef ExternString<String::ExternalOneByteStringResource,
                     char> ExternOneByteString;
typedef ExternString<String::ExternalStringResource,
                     uint16_t> ExternTwoByteString;


template <>
MaybeLocal<Value> ExternOneByteString::NewExternal(
    Isolate* isolate, ExternOneByteString* h_str) {
  return String::NewExternalOneByte(isolate, h_str).FromMaybe(Local<Value>());
}


template <>
MaybeLocal<Value> ExternTwoByteString::NewExternal(
    Isolate* isolate, ExternTwoByteString* h_str) {
  return String::NewExternalTwoByte(isolate, h_str).FromMaybe(Local<Value>());
}

template <>
MaybeLocal<Value> ExternOneByteString::NewSimpleFromCopy(Isolate* isolate,
                                                         const char* data,
                                                         size_t length,
                                                         Local<Value>* error) {
  MaybeLocal<String> str =
      String::NewFromOneByte(isolate,
                             reinterpret_cast<const uint8_t*>(data),
                             v8::NewStringType::kNormal,
                             length);
  if (str.IsEmpty()) {
    *error = node::ERR_STRING_TOO_LONG(isolate);
    return MaybeLocal<Value>();
  }
  return str.ToLocalChecked();
}


template <>
MaybeLocal<Value> ExternTwoByteString::NewSimpleFromCopy(Isolate* isolate,
                                                         const uint16_t* data,
                                                         size_t length,
                                                         Local<Value>* error) {
  MaybeLocal<String> str =
      String::NewFromTwoByte(isolate,
                             data,
                             v8::NewStringType::kNormal,
                             length);
  if (str.IsEmpty()) {
    *error = node::ERR_STRING_TOO_LONG(isolate);
    return MaybeLocal<Value>();
  }
  return str.ToLocalChecked();
}

}  // anonymous namespace

size_t StringBytes::WriteUCS2(
    Isolate* isolate, char* buf, size_t buflen, Local<String> str, int flags) {
  uint16_t* const dst = reinterpret_cast<uint16_t*>(buf);

  size_t max_chars = buflen / sizeof(*dst);
  if (max_chars == 0) {
    return 0;
  }

  uint16_t* const aligned_dst = nbytes::AlignUp(dst, sizeof(*dst));
  size_t nchars;
  if (aligned_dst == dst) {
    nchars = str->Write(isolate, dst, 0, max_chars, flags);
    return nchars * sizeof(*dst);
  }

  CHECK_EQ(reinterpret_cast<uintptr_t>(aligned_dst) % sizeof(*dst), 0);

  // Write all but the last char
  max_chars = std::min(max_chars, static_cast<size_t>(str->Length()));
  if (max_chars == 0) {
    return 0;
  }
  nchars = str->Write(isolate, aligned_dst, 0, max_chars - 1, flags);
  CHECK_EQ(nchars, max_chars - 1);

  // Shift everything to unaligned-left
  memmove(dst, aligned_dst, nchars * sizeof(*dst));

  // One more char to be written
  uint16_t last;
  CHECK_EQ(str->Write(isolate, &last, nchars, 1, flags), 1);
  memcpy(buf + nchars * sizeof(*dst), &last, sizeof(last));
  nchars++;

  return nchars * sizeof(*dst);
}

size_t StringBytes::Write(Isolate* isolate,
                          char* buf,
                          size_t buflen,
                          Local<Value> val,
                          enum encoding encoding) {
  HandleScope scope(isolate);
  size_t nbytes;

  CHECK(val->IsString() == true);
  Local<String> str = val.As<String>();
  String::ValueView input_view(isolate, str);

  int flags = String::HINT_MANY_WRITES_EXPECTED |
              String::NO_NULL_TERMINATION |
              String::REPLACE_INVALID_UTF8;

  switch (encoding) {
    case ASCII:
    case LATIN1:
      if (input_view.is_one_byte()) {
        nbytes = std::min(buflen, static_cast<size_t>(input_view.length()));
        memcpy(buf, input_view.data8(), nbytes);
      } else {
        uint8_t* const dst = reinterpret_cast<uint8_t*>(buf);
        nbytes = str->WriteOneByte(isolate, dst, 0, buflen, flags);
      }
      break;

    case BUFFER:
    case UTF8:
      nbytes = str->WriteUtf8(isolate, buf, buflen, nullptr, flags);
      break;

    case UCS2: {
      nbytes = WriteUCS2(isolate, buf, buflen, str, flags);

      // Node's "ucs2" encoding wants LE character data stored in
      // the Buffer, so we need to reorder on BE platforms.  See
      // https://nodejs.org/api/buffer.html regarding Node's "ucs2"
      // encoding specification
      if constexpr (IsBigEndian()) CHECK(nbytes::SwapBytes16(buf, nbytes));

      break;
    }

    case BASE64URL:
      if (input_view.is_one_byte()) {  // 8-bit case
        size_t written_len = buflen;
        auto result = simdutf::base64_to_binary_safe(
            reinterpret_cast<const char*>(input_view.data8()),
            input_view.length(),
            buf,
            written_len,
            simdutf::base64_url);
        if (result.error == simdutf::error_code::SUCCESS) {
          nbytes = written_len;
        } else {
          // The input does not follow the WHATWG forgiving-base64 specification
          // (adapted for base64url with + and / replaced by - and _).
          // https://infra.spec.whatwg.org/#forgiving-base64-decode
          nbytes = nbytes::Base64Decode(
              buf,
              buflen,
              reinterpret_cast<const char*>(input_view.data8()),
              input_view.length());
        }
      } else {
        String::Value value(isolate, str);
        size_t written_len = buflen;
        auto result = simdutf::base64_to_binary_safe(
            reinterpret_cast<const char16_t*>(*value),
            value.length(),
            buf,
            written_len,
            simdutf::base64_url);
        if (result.error == simdutf::error_code::SUCCESS) {
          nbytes = written_len;
        } else {
          // The input does not follow the WHATWG forgiving-base64 specification
          // (adapted for base64url with + and / replaced by - and _).
          // https://infra.spec.whatwg.org/#forgiving-base64-decode
          nbytes = nbytes::Base64Decode(buf, buflen, *value, value.length());
        }
      }
      break;

    case BASE64: {
      if (input_view.is_one_byte()) {  // 8-bit case
        size_t written_len = buflen;
        auto result = simdutf::base64_to_binary_safe(
            reinterpret_cast<const char*>(input_view.data8()),
            input_view.length(),
            buf,
            written_len);
        if (result.error == simdutf::error_code::SUCCESS) {
          nbytes = written_len;
        } else {
          // The input does not follow the WHATWG forgiving-base64 specification
          // https://infra.spec.whatwg.org/#forgiving-base64-decode
          nbytes = nbytes::Base64Decode(
              buf,
              buflen,
              reinterpret_cast<const char*>(input_view.data8()),
              input_view.length());
        }
      } else {
        String::Value value(isolate, str);
        size_t written_len = buflen;
        auto result = simdutf::base64_to_binary_safe(
            reinterpret_cast<const char16_t*>(*value),
            value.length(),
            buf,
            written_len);
        if (result.error == simdutf::error_code::SUCCESS) {
          nbytes = written_len;
        } else {
          // The input does not follow the WHATWG base64 specification
          // https://infra.spec.whatwg.org/#forgiving-base64-decode
          nbytes = nbytes::Base64Decode(buf, buflen, *value, value.length());
        }
      }
      break;
    }
    case HEX:
      if (input_view.is_one_byte()) {
        nbytes =
            nbytes::HexDecode(buf,
                              buflen,
                              reinterpret_cast<const char*>(input_view.data8()),
                              input_view.length());
      } else {
        String::Value value(isolate, str);
        nbytes = nbytes::HexDecode(buf, buflen, *value, value.length());
      }
      break;

    default:
      UNREACHABLE("unknown encoding");
  }

  return nbytes;
}

// Quick and dirty size calculation
// Will always be at least big enough, but may have some extra
// UTF8 can be as much as 3x the size, Base64 can have 1-2 extra bytes
Maybe<size_t> StringBytes::StorageSize(Isolate* isolate,
                                       Local<Value> val,
                                       enum encoding encoding) {
  HandleScope scope(isolate);

  if (Buffer::HasInstance(val) && (encoding == BUFFER || encoding == LATIN1)) {
    return Just(Buffer::Length(val));
  }

  Local<String> str;
  if (!val->ToString(isolate->GetCurrentContext()).ToLocal(&str))
    return Nothing<size_t>();
  String::ValueView view(isolate, str);
  size_t data_size = 0;

  switch (encoding) {
    case ASCII:
    case LATIN1:
      data_size = view.length();
      break;

    case BUFFER:
    case UTF8:
      // A single UCS2 codepoint never takes up more than 3 utf8 bytes.
      // It is an exercise for the caller to decide when a string is
      // long enough to justify calling Size() instead of StorageSize()
      data_size = 3 * view.length();
      break;

    case UCS2:
      data_size = view.length() * sizeof(uint16_t);
      break;

    case BASE64URL:
      data_size = simdutf::base64_length_from_binary(view.length(),
                                                     simdutf::base64_url);
      break;

    case BASE64:
      data_size = simdutf::base64_length_from_binary(view.length());
      break;

    case HEX:
      CHECK(view.length() % 2 == 0 && "invalid hex string length");
      data_size = view.length() / 2;
      break;

    default:
      UNREACHABLE("unknown encoding");
  }

  return Just(data_size);
}

Maybe<size_t> StringBytes::Size(Isolate* isolate,
                                Local<Value> val,
                                enum encoding encoding) {
  HandleScope scope(isolate);

  if (Buffer::HasInstance(val) && (encoding == BUFFER || encoding == LATIN1))
    return Just(Buffer::Length(val));

  Local<String> str;
  if (!val->ToString(isolate->GetCurrentContext()).ToLocal(&str))
    return Nothing<size_t>();
  String::ValueView view(isolate, str);

  switch (encoding) {
    case ASCII:
    case LATIN1:
      return Just<size_t>(view.length());

    case BUFFER:
    case UTF8:
      if (view.is_one_byte()) {
        return Just<size_t>(simdutf::utf8_length_from_latin1(
            reinterpret_cast<const char*>(view.data8()), view.length()));
      }
      return Just<size_t>(simdutf::utf8_length_from_utf16(
          reinterpret_cast<const char16_t*>(view.data16()), view.length()));

    case UCS2:
      return Just(view.length() * sizeof(uint16_t));

    case BASE64URL: {
      return Just(simdutf::base64_length_from_binary(view.length(),
                                                     simdutf::base64_url));
    }

    case BASE64: {
      return Just(simdutf::base64_length_from_binary(view.length()));
    }

    case HEX:
      return Just<size_t>(view.length() / 2);
  }

  UNREACHABLE();
}

#define CHECK_BUFLEN_IN_RANGE(len)                                    \
  do {                                                                \
    if ((len) > Buffer::kMaxLength) {                                 \
      *error = node::ERR_BUFFER_TOO_LARGE(isolate);                   \
      return MaybeLocal<Value>();                                     \
    }                                                                 \
  } while (0)


MaybeLocal<Value> StringBytes::Encode(Isolate* isolate,
                                      const char* buf,
                                      size_t buflen,
                                      enum encoding encoding,
                                      Local<Value>* error) {
  CHECK_BUFLEN_IN_RANGE(buflen);

  if (!buflen && encoding != BUFFER) {
    return String::Empty(isolate);
  }

  MaybeLocal<String> val;

  switch (encoding) {
    case BUFFER:
      {
        auto maybe_buf = Buffer::Copy(isolate, buf, buflen);
        Local<v8::Object> buf;
        if (!maybe_buf.ToLocal(&buf)) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        }
        return buf;
      }

    case ASCII:
      if (simdutf::validate_ascii_with_errors(buf, buflen).error) {
        // The input contains non-ASCII bytes.
        char* out = node::UncheckedMalloc(buflen);
        if (out == nullptr) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }
        nbytes::ForceAscii(buf, out, buflen);
        return ExternOneByteString::New(isolate, out, buflen, error);
      } else {
        return ExternOneByteString::NewFromCopy(isolate, buf, buflen, error);
      }

    case UTF8:
      {
        val = String::NewFromUtf8(isolate,
                                  buf,
                                  v8::NewStringType::kNormal,
                                  buflen);
        Local<String> str;
        if (!val.ToLocal(&str)) {
          *error = node::ERR_STRING_TOO_LONG(isolate);
        }
        return str;
      }

    case LATIN1:
      return ExternOneByteString::NewFromCopy(isolate, buf, buflen, error);

    case BASE64: {
      size_t dlen = simdutf::base64_length_from_binary(buflen);
      char* dst = node::UncheckedMalloc(dlen);
      if (dst == nullptr) {
        *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        return MaybeLocal<Value>();
      }

      size_t written = simdutf::binary_to_base64(buf, buflen, dst);
      CHECK_EQ(written, dlen);

      return ExternOneByteString::New(isolate, dst, dlen, error);
    }

    case BASE64URL: {
      size_t dlen =
          simdutf::base64_length_from_binary(buflen, simdutf::base64_url);
      char* dst = node::UncheckedMalloc(dlen);
      if (dst == nullptr) {
        *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        return MaybeLocal<Value>();
      }

      size_t written =
          simdutf::binary_to_base64(buf, buflen, dst, simdutf::base64_url);
      CHECK_EQ(written, dlen);

      return ExternOneByteString::New(isolate, dst, dlen, error);
    }

    case HEX: {
      size_t dlen = buflen * 2;
      char* dst = node::UncheckedMalloc(dlen);
      if (dst == nullptr) {
        *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
        return MaybeLocal<Value>();
      }
      size_t written = nbytes::HexEncode(buf, buflen, dst, dlen);
      CHECK_EQ(written, dlen);

      return ExternOneByteString::New(isolate, dst, dlen, error);
    }

    case UCS2: {
      size_t str_len = buflen / 2;
      if constexpr (IsBigEndian()) {
        uint16_t* dst = node::UncheckedMalloc<uint16_t>(str_len);
        if (str_len != 0 && dst == nullptr) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }
        for (size_t i = 0, k = 0; k < str_len; i += 2, k += 1) {
          // The input is in *little endian*, because that's what Node.js
          // expects, so the high byte comes after the low byte.
          const uint8_t hi = static_cast<uint8_t>(buf[i + 1]);
          const uint8_t lo = static_cast<uint8_t>(buf[i + 0]);
          dst[k] = static_cast<uint16_t>(hi) << 8 | lo;
        }
        return ExternTwoByteString::New(isolate, dst, str_len, error);
      }
      if (reinterpret_cast<uintptr_t>(buf) % 2 != 0) {
        // Unaligned data still means we can't directly pass it to V8.
        char* dst = node::UncheckedMalloc(buflen);
        if (dst == nullptr) {
          *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
          return MaybeLocal<Value>();
        }
        memcpy(dst, buf, buflen);
        return ExternTwoByteString::New(
            isolate, reinterpret_cast<uint16_t*>(dst), str_len, error);
      }
      return ExternTwoByteString::NewFromCopy(
          isolate, reinterpret_cast<const uint16_t*>(buf), str_len, error);
    }

    default:
      UNREACHABLE("unknown encoding");
  }
}


MaybeLocal<Value> StringBytes::Encode(Isolate* isolate,
                                      const uint16_t* buf,
                                      size_t buflen,
                                      Local<Value>* error) {
  if (buflen == 0) return String::Empty(isolate);
  CHECK_BUFLEN_IN_RANGE(buflen);

  // Node's "ucs2" encoding expects LE character data inside a
  // Buffer, so we need to reorder on BE platforms.  See
  // https://nodejs.org/api/buffer.html regarding Node's "ucs2"
  // encoding specification
  if constexpr (IsBigEndian()) {
    uint16_t* dst = node::UncheckedMalloc<uint16_t>(buflen);
    if (dst == nullptr) {
      *error = node::ERR_MEMORY_ALLOCATION_FAILED(isolate);
      return MaybeLocal<Value>();
    }
    size_t nbytes = buflen * sizeof(uint16_t);
    memcpy(dst, buf, nbytes);
    CHECK(nbytes::SwapBytes16(reinterpret_cast<char*>(dst), nbytes));
    return ExternTwoByteString::New(isolate, dst, buflen, error);
  } else {
    return ExternTwoByteString::NewFromCopy(isolate, buf, buflen, error);
  }
}

MaybeLocal<Value> StringBytes::Encode(Isolate* isolate,
                                      const char* buf,
                                      enum encoding encoding,
                                      Local<Value>* error) {
  const size_t len = strlen(buf);
  return Encode(isolate, buf, len, encoding, error);
}

}  // namespace node
                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/src/string_bytes.h                                                                      0000664 0000000 0000000 00000010736 14746647661 0016240 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

#ifndef SRC_STRING_BYTES_H_
#define SRC_STRING_BYTES_H_

#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

// Decodes a v8::Local<v8::String> or Buffer to a raw char*

#include "v8.h"
#include "env-inl.h"

#include <string>

namespace node {

class StringBytes {
 public:
  class InlineDecoder : public MaybeStackBuffer<char> {
   public:
    inline v8::Maybe<void> Decode(Environment* env,
                                  v8::Local<v8::String> string,
                                  enum encoding enc) {
      size_t storage;
      if (!StringBytes::StorageSize(env->isolate(), string, enc).To(&storage))
        return v8::Nothing<void>();
      AllocateSufficientStorage(storage);
      const size_t length =
          StringBytes::Write(env->isolate(), out(), storage, string, enc);

      // No zero terminator is included when using this method.
      SetLength(length);
      return v8::JustVoid();
    }

    inline size_t size() const { return length(); }
  };

  // Fast, but can be 2 bytes oversized for Base64, and
  // as much as triple UTF-8 strings <= 65536 chars in length
  static v8::Maybe<size_t> StorageSize(v8::Isolate* isolate,
                                       v8::Local<v8::Value> val,
                                       enum encoding enc);

  // Precise byte count, but slightly slower for Base64 and
  // very much slower for UTF-8
  static v8::Maybe<size_t> Size(v8::Isolate* isolate,
                                v8::Local<v8::Value> val,
                                enum encoding enc);

  // Write the bytes from the string or buffer into the char*
  // returns the number of bytes written, which will always be
  // <= buflen.  Use StorageSize/Size first to know how much
  // memory to allocate.
  static size_t Write(v8::Isolate* isolate,
                      char* buf,
                      size_t buflen,
                      v8::Local<v8::Value> val,
                      enum encoding enc);

  // Take the bytes in the src, and turn it into a Buffer or String.
  static v8::MaybeLocal<v8::Value> Encode(v8::Isolate* isolate,
                                          const char* buf,
                                          size_t buflen,
                                          enum encoding encoding,
                                          v8::Local<v8::Value>* error);

  // Warning: This reverses endianness on BE platforms, even though the
  // signature using uint16_t implies that it should not.
  // However, the brokenness is already public API and can't therefore
  // be changed easily.
  static v8::MaybeLocal<v8::Value> Encode(v8::Isolate* isolate,
                                          const uint16_t* buf,
                                          size_t buflen,
                                          v8::Local<v8::Value>* error);

  static v8::MaybeLocal<v8::Value> Encode(v8::Isolate* isolate,
                                          const char* buf,
                                          enum encoding encoding,
                                          v8::Local<v8::Value>* error);

 private:
  static size_t WriteUCS2(v8::Isolate* isolate,
                          char* buf,
                          size_t buflen,
                          v8::Local<v8::String> str,
                          int flags);
};

}  // namespace node

#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#endif  // SRC_STRING_BYTES_H_
                                  node-23.7.0/src/string_decoder-inl.h                                                                0000664 0000000 0000000 00000001275 14746647661 0017275 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #ifndef SRC_STRING_DECODER_INL_H_
#define SRC_STRING_DECODER_INL_H_

#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#include "string_decoder.h"

namespace node {

enum encoding StringDecoder::Encoding() const {
  return static_cast<enum encoding>(state_[kEncodingField]);
}

unsigned StringDecoder::BufferedBytes() const {
  return state_[kBufferedBytes];
}

unsigned StringDecoder::MissingBytes() const {
  return state_[kMissingBytes];
}

char* StringDecoder::IncompleteCharacterBuffer() {
  return reinterpret_cast<char*>(state_ + kIncompleteCharactersStart);
}


}  // namespace node

#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#endif   // SRC_STRING_DECODER_INL_H_
                                                                                                                                                                                                                                                                                                                                   node-23.7.0/src/string_decoder.cc                                                                   0000664 0000000 0000000 00000030001 14746647661 0016640 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "string_decoder.h"  // NOLINT(build/include_inline)
#include "string_decoder-inl.h"

#include "env-inl.h"
#include "node_buffer.h"
#include "node_errors.h"
#include "node_external_reference.h"
#include "string_bytes.h"
#include "util.h"

using v8::Array;
using v8::ArrayBufferView;
using v8::Context;
using v8::FunctionCallbackInfo;
using v8::Integer;
using v8::Isolate;
using v8::Local;
using v8::MaybeLocal;
using v8::Object;
using v8::String;
using v8::Value;

namespace node {

namespace {

MaybeLocal<String> MakeString(Isolate* isolate,
                              const char* data,
                              size_t length,
                              enum encoding encoding) {
  Local<Value> error;
  MaybeLocal<Value> ret;
  if (encoding == UTF8) {
    MaybeLocal<String> utf8_string;
    if (length <= static_cast<size_t>(v8::String::kMaxLength)) {
      utf8_string = String::NewFromUtf8(
          isolate, data, v8::NewStringType::kNormal, length);
    }
    if (utf8_string.IsEmpty()) {
      isolate->ThrowException(node::ERR_STRING_TOO_LONG(isolate));
      return MaybeLocal<String>();
    } else {
      return utf8_string;
    }
  } else {
    ret = StringBytes::Encode(
        isolate,
        data,
        length,
        encoding,
        &error);
  }

  if (ret.IsEmpty()) {
    CHECK(!error.IsEmpty());
    isolate->ThrowException(error);
  }

  DCHECK(ret.IsEmpty() || ret.ToLocalChecked()->IsString());
  return ret.FromMaybe(Local<Value>()).As<String>();
}

}  // anonymous namespace


MaybeLocal<String> StringDecoder::DecodeData(Isolate* isolate,
                                             const char* data,
                                             size_t* nread_ptr) {
  Local<String> prepend, body;

  size_t nread = *nread_ptr;

  if (Encoding() == UTF8 ||
      Encoding() == UCS2 ||
      Encoding() == BASE64 ||
      Encoding() == BASE64URL) {
    // See if we want bytes to finish a character from the previous
    // chunk; if so, copy the new bytes to the missing bytes buffer
    // and create a small string from it that is to be prepended to the
    // main body.
    if (MissingBytes() > 0) {
      // There are never more bytes missing than the pre-calculated maximum.
      CHECK_LE(MissingBytes() + BufferedBytes(),
               kIncompleteCharactersEnd);
      if (Encoding() == UTF8) {
        // For UTF-8, we need special treatment to align with the V8 decoder:
        // If an incomplete character is found at a chunk boundary, we use
        // its remainder and pass it to V8 as-is.
        for (size_t i = 0; i < nread && i < MissingBytes(); ++i) {
          if ((data[i] & 0xC0) != 0x80) {
            // This byte is not a continuation byte even though it should have
            // been one. We stop decoding of the incomplete character at this
            // point (but still use the rest of the incomplete bytes from this
            // chunk) and assume that the new, unexpected byte starts a new one.
            state_[kMissingBytes] = 0;
            memcpy(IncompleteCharacterBuffer() + BufferedBytes(), data, i);
            state_[kBufferedBytes] += i;
            data += i;
            nread -= i;
            break;
          }
        }
      }

      size_t found_bytes =
          std::min(nread, static_cast<size_t>(MissingBytes()));
      memcpy(IncompleteCharacterBuffer() + BufferedBytes(),
             data,
             found_bytes);
      // Adjust the two buffers.
      data += found_bytes;
      nread -= found_bytes;

      state_[kMissingBytes] -= found_bytes;
      state_[kBufferedBytes] += found_bytes;

      if (MissingBytes() == 0) [[likely]] {
        // If no more bytes are missing, create a small string that we
        // will later prepend.
        if (!MakeString(isolate,
                        IncompleteCharacterBuffer(),
                        BufferedBytes(),
                        Encoding()).ToLocal(&prepend)) {
          return MaybeLocal<String>();
        }

        *nread_ptr += BufferedBytes();
        // No more buffered bytes.
        state_[kBufferedBytes] = 0;
      }
    }

    // It could be that trying to finish the previous chunk already
    // consumed all data that we received in this chunk.
    if (nread == 0) [[unlikely]] {
      body = !prepend.IsEmpty() ? prepend : String::Empty(isolate);
      prepend = Local<String>();
    } else {
      // If not, that means is no character left to finish at this point.
      DCHECK_EQ(MissingBytes(), 0);
      DCHECK_EQ(BufferedBytes(), 0);

      // See whether there is a character that we may have to cut off and
      // finish when receiving the next chunk.
      if (Encoding() == UTF8 && data[nread - 1] & 0x80) {
        // This is UTF-8 encoded data and we ended on a non-ASCII UTF-8 byte.
        // This means we'll need to figure out where the character to which
        // the byte belongs begins.
        for (size_t i = nread - 1; ; --i) {
          DCHECK_LT(i, nread);
          state_[kBufferedBytes]++;
          if ((data[i] & 0xC0) == 0x80) {
            // This byte does not start a character (a "trailing" byte).
            if (state_[kBufferedBytes] >= 4 || i == 0) {
              // We either have more then 4 trailing bytes (which means
              // the current character would not be inside the range for
              // valid Unicode, and in particular cannot be represented
              // through JavaScript's UTF-16-based approach to strings), or the
              // current buffer does not contain the start of an UTF-8 character
              // at all. Either way, this is invalid UTF8 and we can just
              // let the engine's decoder handle it.
              state_[kBufferedBytes] = 0;
              break;
            }
          } else {
            // Found the first byte of a UTF-8 character. By looking at the
            // upper bits we can tell how long the character *should* be.
            if ((data[i] & 0xE0) == 0xC0) {
              state_[kMissingBytes] = 2;
            } else if ((data[i] & 0xF0) == 0xE0) {
              state_[kMissingBytes] = 3;
            } else if ((data[i] & 0xF8) == 0xF0) {
              state_[kMissingBytes] = 4;
            } else {
              // This lead byte would indicate a character outside of the
              // representable range.
              state_[kBufferedBytes] = 0;
              break;
            }

            if (BufferedBytes() >= MissingBytes()) {
              // Received more or exactly as many trailing bytes than the lead
              // character would indicate. In the "==" case, we have valid
              // data and don't need to slice anything off;
              // in the ">" case, this is invalid UTF-8 anyway.
              state_[kMissingBytes] = 0;
              state_[kBufferedBytes] = 0;
            }

            state_[kMissingBytes] -= state_[kBufferedBytes];
            break;
          }
        }
      } else if (Encoding() == UCS2) {
        if ((nread % 2) == 1) {
          // We got half a codepoint, and need the second byte of it.
          state_[kBufferedBytes] = 1;
          state_[kMissingBytes] = 1;
        } else if ((data[nread - 1] & 0xFC) == 0xD8) {
          // Half a split UTF-16 character.
          state_[kBufferedBytes] = 2;
          state_[kMissingBytes] = 2;
        }
      } else if (Encoding() == BASE64 || Encoding() == BASE64URL) {
        state_[kBufferedBytes] = nread % 3;
        if (state_[kBufferedBytes] > 0)
          state_[kMissingBytes] = 3 - BufferedBytes();
      }

      if (BufferedBytes() > 0) {
        // Copy the requested number of buffered bytes from the end of the
        // input into the incomplete character buffer.
        nread -= BufferedBytes();
        *nread_ptr -= BufferedBytes();
        memcpy(IncompleteCharacterBuffer(), data + nread, BufferedBytes());
      }

      if (nread > 0) {
        if (!MakeString(isolate, data, nread, Encoding()).ToLocal(&body))
          return MaybeLocal<String>();
      } else {
        body = String::Empty(isolate);
      }
    }

    if (prepend.IsEmpty()) {
      return body;
    } else {
      return String::Concat(isolate, prepend, body);
    }
  } else {
    CHECK(Encoding() == ASCII || Encoding() == HEX || Encoding() == LATIN1);
    return MakeString(isolate, data, nread, Encoding());
  }
}

MaybeLocal<String> StringDecoder::FlushData(Isolate* isolate) {
  if (Encoding() == ASCII || Encoding() == HEX || Encoding() == LATIN1) {
    CHECK_EQ(MissingBytes(), 0);
    CHECK_EQ(BufferedBytes(), 0);
  }

  if (Encoding() == UCS2 && BufferedBytes() % 2 == 1) {
    // Ignore a single trailing byte, like the JS decoder does.
    state_[kMissingBytes]--;
    state_[kBufferedBytes]--;
  }

  if (BufferedBytes() == 0)
    return String::Empty(isolate);

  MaybeLocal<String> ret =
      MakeString(isolate,
                 IncompleteCharacterBuffer(),
                 BufferedBytes(),
                 Encoding());

  state_[kMissingBytes] = 0;
  state_[kBufferedBytes] = 0;

  return ret;
}

namespace {

void DecodeData(const FunctionCallbackInfo<Value>& args) {
  StringDecoder* decoder =
      reinterpret_cast<StringDecoder*>(Buffer::Data(args[0]));
  CHECK_NOT_NULL(decoder);

  CHECK(args[1]->IsArrayBufferView());
  ArrayBufferViewContents<char> content(args[1].As<ArrayBufferView>());
  size_t length = content.length();

  MaybeLocal<String> ret =
      decoder->DecodeData(args.GetIsolate(), content.data(), &length);
  if (!ret.IsEmpty())
    args.GetReturnValue().Set(ret.ToLocalChecked());
}

void FlushData(const FunctionCallbackInfo<Value>& args) {
  StringDecoder* decoder =
      reinterpret_cast<StringDecoder*>(Buffer::Data(args[0]));
  CHECK_NOT_NULL(decoder);
  MaybeLocal<String> ret = decoder->FlushData(args.GetIsolate());
  if (!ret.IsEmpty())
    args.GetReturnValue().Set(ret.ToLocalChecked());
}

void InitializeStringDecoder(Local<Object> target,
                             Local<Value> unused,
                             Local<Context> context,
                             void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

#define SET_DECODER_CONSTANT(name)                                            \
  target->Set(context,                                                        \
              FIXED_ONE_BYTE_STRING(isolate, #name),                          \
              Integer::New(isolate, StringDecoder::name)).FromJust()

  SET_DECODER_CONSTANT(kIncompleteCharactersStart);
  SET_DECODER_CONSTANT(kIncompleteCharactersEnd);
  SET_DECODER_CONSTANT(kMissingBytes);
  SET_DECODER_CONSTANT(kBufferedBytes);
  SET_DECODER_CONSTANT(kEncodingField);
  SET_DECODER_CONSTANT(kNumFields);

  Local<Array> encodings = Array::New(isolate);
#define ADD_TO_ENCODINGS_ARRAY(cname, jsname)                                 \
  encodings->Set(context,                                                     \
                 static_cast<int32_t>(cname),                                 \
                 FIXED_ONE_BYTE_STRING(isolate, jsname)).FromJust()
  ADD_TO_ENCODINGS_ARRAY(ASCII, "ascii");
  ADD_TO_ENCODINGS_ARRAY(UTF8, "utf8");
  ADD_TO_ENCODINGS_ARRAY(BASE64, "base64");
  ADD_TO_ENCODINGS_ARRAY(BASE64URL, "base64url");
  ADD_TO_ENCODINGS_ARRAY(UCS2, "utf16le");
  ADD_TO_ENCODINGS_ARRAY(HEX, "hex");
  ADD_TO_ENCODINGS_ARRAY(BUFFER, "buffer");
  ADD_TO_ENCODINGS_ARRAY(LATIN1, "latin1");

  target->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, "encodings"),
              encodings).Check();

  target->Set(context,
              FIXED_ONE_BYTE_STRING(isolate, "kSize"),
              Integer::New(isolate, sizeof(StringDecoder))).Check();

  SetMethod(context, target, "decode", DecodeData);
  SetMethod(context, target, "flush", FlushData);
}

}  // anonymous namespace

void RegisterStringDecoderExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(DecodeData);
  registry->Register(FlushData);
}

}  // namespace node

NODE_BINDING_CONTEXT_AWARE_INTERNAL(string_decoder,
                                    node::InitializeStringDecoder)
NODE_BINDING_EXTERNAL_REFERENCE(string_decoder,
                                node::RegisterStringDecoderExternalReferences)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/src/string_decoder.h                                                                    0000664 0000000 0000000 00000002710 14746647661 0016510 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #ifndef SRC_STRING_DECODER_H_
#define SRC_STRING_DECODER_H_

#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#include "node.h"

namespace node {

class StringDecoder {
 public:
  StringDecoder() { state_[kEncodingField] = BUFFER; }
  inline enum encoding Encoding() const;

  inline char* IncompleteCharacterBuffer();
  inline unsigned MissingBytes() const;
  inline unsigned BufferedBytes() const;

  // Decode a string from the specified encoding.
  // The value pointed to by `nread` will be modified to reflect that
  // less data may have been read because it ended on an incomplete character
  // and more data may have been read because a previously incomplete character
  // was finished.
  v8::MaybeLocal<v8::String> DecodeData(v8::Isolate* isolate,
                                        const char* data,
                                        size_t* nread);
  // Flush an incomplete character. For character encodings like UTF8 this
  // means printing replacement characters, buf for e.g. Base64 the returned
  // string contains more data.
  v8::MaybeLocal<v8::String> FlushData(v8::Isolate* isolate);

  enum Fields {
    kIncompleteCharactersStart = 0,
    kIncompleteCharactersEnd = 4,
    kMissingBytes = 4,
    kBufferedBytes = 5,
    kEncodingField = 6,
    kNumFields = 7
  };

 private:
  uint8_t state_[kNumFields] = {};
};

}  // namespace node

#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#endif   // SRC_STRING_DECODER_H_
                                                        node-23.7.0/src/tcp_wrap.cc                                                                         0000664 0000000 0000000 00000035427 14746647661 0015505 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

#include "tcp_wrap.h"

#include "connect_wrap.h"
#include "connection_wrap.h"
#include "env-inl.h"
#include "handle_wrap.h"
#include "node_buffer.h"
#include "node_external_reference.h"
#include "node_internals.h"
#include "stream_base-inl.h"
#include "stream_wrap.h"
#include "util-inl.h"

#include <cstdlib>


namespace node {

using v8::Boolean;
using v8::Context;
using v8::EscapableHandleScope;
using v8::Function;
using v8::FunctionCallbackInfo;
using v8::FunctionTemplate;
using v8::Int32;
using v8::Integer;
using v8::Isolate;
using v8::Local;
using v8::MaybeLocal;
using v8::Object;
using v8::String;
using v8::Uint32;
using v8::Value;

MaybeLocal<Object> TCPWrap::Instantiate(Environment* env,
                                        AsyncWrap* parent,
                                        TCPWrap::SocketType type) {
  EscapableHandleScope handle_scope(env->isolate());
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(parent);
  CHECK_EQ(env->tcp_constructor_template().IsEmpty(), false);
  Local<Function> constructor = env->tcp_constructor_template()
                                    ->GetFunction(env->context())
                                    .ToLocalChecked();
  CHECK_EQ(constructor.IsEmpty(), false);
  Local<Value> type_value = Int32::New(env->isolate(), type);
  return handle_scope.EscapeMaybe(
      constructor->NewInstance(env->context(), 1, &type_value));
}


void TCPWrap::Initialize(Local<Object> target,
                         Local<Value> unused,
                         Local<Context> context,
                         void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()->SetInternalFieldCount(StreamBase::kInternalFieldCount);

  // Init properties
  t->InstanceTemplate()->Set(FIXED_ONE_BYTE_STRING(env->isolate(), "reading"),
                             Boolean::New(env->isolate(), false));
  t->InstanceTemplate()->Set(env->owner_symbol(), Null(env->isolate()));
  t->InstanceTemplate()->Set(env->onconnection_string(), Null(env->isolate()));

  t->Inherit(LibuvStreamWrap::GetConstructorTemplate(env));

  SetProtoMethod(isolate, t, "open", Open);
  SetProtoMethod(isolate, t, "bind", Bind);
  SetProtoMethod(isolate, t, "listen", Listen);
  SetProtoMethod(isolate, t, "connect", Connect);
  SetProtoMethod(isolate, t, "bind6", Bind6);
  SetProtoMethod(isolate, t, "connect6", Connect6);
  SetProtoMethod(isolate,
                 t,
                 "getsockname",
                 GetSockOrPeerName<TCPWrap, uv_tcp_getsockname>);
  SetProtoMethod(isolate,
                 t,
                 "getpeername",
                 GetSockOrPeerName<TCPWrap, uv_tcp_getpeername>);
  SetProtoMethod(isolate, t, "setNoDelay", SetNoDelay);
  SetProtoMethod(isolate, t, "setKeepAlive", SetKeepAlive);
  SetProtoMethod(isolate, t, "reset", Reset);

#ifdef _WIN32
  SetProtoMethod(isolate, t, "setSimultaneousAccepts", SetSimultaneousAccepts);
#endif

  SetConstructorFunction(context, target, "TCP", t);
  env->set_tcp_constructor_template(t);

  // Create FunctionTemplate for TCPConnectWrap.
  Local<FunctionTemplate> cwt =
      BaseObject::MakeLazilyInitializedJSTemplate(env);
  cwt->Inherit(AsyncWrap::GetConstructorTemplate(env));
  SetConstructorFunction(context, target, "TCPConnectWrap", cwt);

  // Define constants
  Local<Object> constants = Object::New(env->isolate());
  NODE_DEFINE_CONSTANT(constants, SOCKET);
  NODE_DEFINE_CONSTANT(constants, SERVER);
  NODE_DEFINE_CONSTANT(constants, UV_TCP_IPV6ONLY);
  NODE_DEFINE_CONSTANT(constants, UV_TCP_REUSEPORT);
  target->Set(context,
              env->constants_string(),
              constants).Check();
}

void TCPWrap::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(Open);
  registry->Register(Bind);
  registry->Register(Listen);
  registry->Register(Connect);
  registry->Register(Bind6);
  registry->Register(Connect6);

  registry->Register(GetSockOrPeerName<TCPWrap, uv_tcp_getsockname>);
  registry->Register(GetSockOrPeerName<TCPWrap, uv_tcp_getpeername>);
  registry->Register(SetNoDelay);
  registry->Register(SetKeepAlive);
  registry->Register(Reset);
#ifdef _WIN32
  registry->Register(SetSimultaneousAccepts);
#endif
}

void TCPWrap::New(const FunctionCallbackInfo<Value>& args) {
  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());
  CHECK(args[0]->IsInt32());
  Environment* env = Environment::GetCurrent(args);

  int type_value = args[0].As<Int32>()->Value();
  TCPWrap::SocketType type = static_cast<TCPWrap::SocketType>(type_value);

  ProviderType provider;
  switch (type) {
    case SOCKET:
      provider = PROVIDER_TCPWRAP;
      break;
    case SERVER:
      provider = PROVIDER_TCPSERVERWRAP;
      break;
    default:
      UNREACHABLE();
  }

  new TCPWrap(env, args.This(), provider);
}


TCPWrap::TCPWrap(Environment* env, Local<Object> object, ProviderType provider)
    : ConnectionWrap(env, object, provider) {
  int r = uv_tcp_init(env->event_loop(), &handle_);
  CHECK_EQ(r, 0);  // How do we proxy this error up to javascript?
                   // Suggestion: uv_tcp_init() returns void.
}


void TCPWrap::SetNoDelay(const FunctionCallbackInfo<Value>& args) {
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
  int enable = static_cast<int>(args[0]->IsTrue());
  int err = uv_tcp_nodelay(&wrap->handle_, enable);
  args.GetReturnValue().Set(err);
}


void TCPWrap::SetKeepAlive(const FunctionCallbackInfo<Value>& args) {
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
  Environment* env = wrap->env();
  int enable;
  if (!args[0]->Int32Value(env->context()).To(&enable)) return;
  unsigned int delay = static_cast<unsigned int>(args[1].As<Uint32>()->Value());
  int err = uv_tcp_keepalive(&wrap->handle_, enable, delay);
  args.GetReturnValue().Set(err);
}


#ifdef _WIN32
void TCPWrap::SetSimultaneousAccepts(const FunctionCallbackInfo<Value>& args) {
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
  bool enable = args[0]->IsTrue();
  int err = uv_tcp_simultaneous_accepts(&wrap->handle_, enable);
  args.GetReturnValue().Set(err);
}
#endif


void TCPWrap::Open(const FunctionCallbackInfo<Value>& args) {
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
  int64_t val;
  if (!args[0]->IntegerValue(args.GetIsolate()->GetCurrentContext()).To(&val))
    return;
  int fd = static_cast<int>(val);
  int err = uv_tcp_open(&wrap->handle_, fd);

  if (err == 0)
    wrap->set_fd(fd);

  args.GetReturnValue().Set(err);
}

template <typename T>
void TCPWrap::Bind(
    const FunctionCallbackInfo<Value>& args,
    int family,
    std::function<int(const char* ip_address, int port, T* addr)> uv_ip_addr) {
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
  Environment* env = wrap->env();
  node::Utf8Value ip_address(env->isolate(), args[0]);
  int port;
  unsigned int flags = 0;
  if (!args[1]->Int32Value(env->context()).To(&port)) return;
  if (args.Length() >= 3 && args[2]->IsUint32()) {
    if (!args[2]->Uint32Value(env->context()).To(&flags)) return;
    // Can not set IPV6 flags on IPV4 socket
    if (family == AF_INET) {
      flags &= ~UV_TCP_IPV6ONLY;
    }
  }

  T addr;
  int err = uv_ip_addr(*ip_address, port, &addr);

  if (err == 0) {
    err = uv_tcp_bind(&wrap->handle_,
                      reinterpret_cast<const sockaddr*>(&addr),
                      flags);
  }
  args.GetReturnValue().Set(err);
}

void TCPWrap::Bind(const FunctionCallbackInfo<Value>& args) {
  Bind<sockaddr_in>(args, AF_INET, uv_ip4_addr);
}


void TCPWrap::Bind6(const FunctionCallbackInfo<Value>& args) {
  Bind<sockaddr_in6>(args, AF_INET6, uv_ip6_addr);
}


void TCPWrap::Listen(const FunctionCallbackInfo<Value>& args) {
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
  Environment* env = wrap->env();
  int backlog;
  if (!args[0]->Int32Value(env->context()).To(&backlog)) return;
  int err = uv_listen(reinterpret_cast<uv_stream_t*>(&wrap->handle_),
                      backlog,
                      OnConnection);
  args.GetReturnValue().Set(err);
}


void TCPWrap::Connect(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[2]->IsUint32());
  // explicit cast to fit to libuv's type expectation
  int port = static_cast<int>(args[2].As<Uint32>()->Value());
  Connect<sockaddr_in>(args,
                       [port](const char* ip_address, sockaddr_in* addr) {
      return uv_ip4_addr(ip_address, port, addr);
  });
}


void TCPWrap::Connect6(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  CHECK(args[2]->IsUint32());
  int port;
  if (!args[2]->Int32Value(env->context()).To(&port)) return;
  Connect<sockaddr_in6>(args,
                        [port](const char* ip_address, sockaddr_in6* addr) {
      return uv_ip6_addr(ip_address, port, addr);
  });
}

template <typename T>
void TCPWrap::Connect(const FunctionCallbackInfo<Value>& args,
    std::function<int(const char* ip_address, T* addr)> uv_ip_addr) {
  Environment* env = Environment::GetCurrent(args);

  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));

  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsString());

  Local<Object> req_wrap_obj = args[0].As<Object>();
  node::Utf8Value ip_address(env->isolate(), args[1]);

  T addr;
  int err = uv_ip_addr(*ip_address, &addr);

  if (err == 0) {
    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(wrap);
    ConnectWrap* req_wrap =
        new ConnectWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_TCPCONNECTWRAP);
    err = req_wrap->Dispatch(uv_tcp_connect,
                             &wrap->handle_,
                             reinterpret_cast<const sockaddr*>(&addr),
                             AfterConnect);
    if (err) {
      delete req_wrap;
    } else {
      CHECK(args[2]->Uint32Value(env->context()).IsJust());
      int port = args[2]->Uint32Value(env->context()).FromJust();
      TRACE_EVENT_NESTABLE_ASYNC_BEGIN2(TRACING_CATEGORY_NODE2(net, native),
                                        "connect",
                                        req_wrap,
                                        "ip",
                                        TRACE_STR_COPY(*ip_address),
                                        "port",
                                        port);
    }
  }

  args.GetReturnValue().Set(err);
}
void TCPWrap::Reset(const FunctionCallbackInfo<Value>& args) {
  TCPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));

  int err = wrap->Reset(args[0]);

  args.GetReturnValue().Set(err);
}

int TCPWrap::Reset(Local<Value> close_callback) {
  if (state_ != kInitialized) return 0;

  int err = uv_tcp_close_reset(&handle_, OnClose);
  state_ = kClosing;
  if (!err & !close_callback.IsEmpty() && close_callback->IsFunction() &&
      !persistent().IsEmpty()) {
    object()
        ->Set(env()->context(), env()->handle_onclose_symbol(), close_callback)
        .Check();
  }
  return err;
}

// also used by udp_wrap.cc
MaybeLocal<Object> AddressToJS(Environment* env,
                               const sockaddr* addr,
                               Local<Object> info) {
  EscapableHandleScope scope(env->isolate());
  char ip[INET6_ADDRSTRLEN + UV_IF_NAMESIZE];
  const sockaddr_in* a4;
  const sockaddr_in6* a6;

  int port;

  if (info.IsEmpty())
    info = Object::New(env->isolate());

  switch (addr->sa_family) {
  case AF_INET6:
    a6 = reinterpret_cast<const sockaddr_in6*>(addr);
    uv_inet_ntop(AF_INET6, &a6->sin6_addr, ip, sizeof ip);
    // Add an interface identifier to a link local address.
    if (IN6_IS_ADDR_LINKLOCAL(&a6->sin6_addr) && a6->sin6_scope_id > 0) {
      const size_t addrlen = strlen(ip);
      CHECK_LT(addrlen, sizeof(ip));
      ip[addrlen] = '%';
      size_t scopeidlen = sizeof(ip) - addrlen - 1;
      CHECK_GE(scopeidlen, UV_IF_NAMESIZE);
      const int r = uv_if_indextoiid(a6->sin6_scope_id,
                                     ip + addrlen + 1,
                                     &scopeidlen);
      if (r) {
        env->ThrowUVException(r, "uv_if_indextoiid");
        return {};
      }
    }
    port = ntohs(a6->sin6_port);
    info->Set(env->context(),
              env->address_string(),
              OneByteString(env->isolate(), ip)).Check();
    info->Set(env->context(), env->family_string(), env->ipv6_string()).Check();
    info->Set(env->context(),
              env->port_string(),
              Integer::New(env->isolate(), port)).Check();
    break;

  case AF_INET:
    a4 = reinterpret_cast<const sockaddr_in*>(addr);
    uv_inet_ntop(AF_INET, &a4->sin_addr, ip, sizeof ip);
    port = ntohs(a4->sin_port);
    info->Set(env->context(),
              env->address_string(),
              OneByteString(env->isolate(), ip)).Check();
    info->Set(env->context(), env->family_string(), env->ipv4_string()).Check();
    info->Set(env->context(),
              env->port_string(),
              Integer::New(env->isolate(), port)).Check();
    break;

  default:
    info->Set(env->context(),
              env->address_string(),
              String::Empty(env->isolate())).Check();
  }

  return scope.Escape(info);
}


}  // namespace node

NODE_BINDING_CONTEXT_AWARE_INTERNAL(tcp_wrap, node::TCPWrap::Initialize)
NODE_BINDING_EXTERNAL_REFERENCE(tcp_wrap,
                                node::TCPWrap::RegisterExternalReferences)
                                                                                                                                                                                                                                         node-23.7.0/src/tcp_wrap.h                                                                          0000664 0000000 0000000 00000007627 14746647661 0015350 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

#ifndef SRC_TCP_WRAP_H_
#define SRC_TCP_WRAP_H_

#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#include "async_wrap.h"
#include "connection_wrap.h"

namespace node {

class ExternalReferenceRegistry;
class Environment;

class TCPWrap : public ConnectionWrap<TCPWrap, uv_tcp_t> {
 public:
  enum SocketType {
    SOCKET,
    SERVER
  };

  static v8::MaybeLocal<v8::Object> Instantiate(Environment* env,
                                                AsyncWrap* parent,
                                                SocketType type);
  static void Initialize(v8::Local<v8::Object> target,
                         v8::Local<v8::Value> unused,
                         v8::Local<v8::Context> context,
                         void* priv);
  static void RegisterExternalReferences(ExternalReferenceRegistry* registry);

  SET_NO_MEMORY_INFO()
  SET_SELF_SIZE(TCPWrap)
  const char* MemoryInfoName() const override {
    switch (provider_type()) {
      case ProviderType::PROVIDER_TCPWRAP:
        return "TCPSocketWrap";
      case ProviderType::PROVIDER_TCPSERVERWRAP:
        return "TCPServerWrap";
      default:
        UNREACHABLE();
    }
  }

 private:
  typedef uv_tcp_t HandleType;

  template <typename T,
            int (*F)(const typename T::HandleType*, sockaddr*, int*)>
  friend void GetSockOrPeerName(const v8::FunctionCallbackInfo<v8::Value>&);

  TCPWrap(Environment* env, v8::Local<v8::Object> object,
          ProviderType provider);

  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void SetNoDelay(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void SetKeepAlive(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void Bind(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void Bind6(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void Listen(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void Connect(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void Connect6(const v8::FunctionCallbackInfo<v8::Value>& args);
  template <typename T>
  static void Connect(const v8::FunctionCallbackInfo<v8::Value>& args,
      std::function<int(const char* ip_address, T* addr)> uv_ip_addr);
  static void Open(const v8::FunctionCallbackInfo<v8::Value>& args);
  template <typename T>
  static void Bind(
      const v8::FunctionCallbackInfo<v8::Value>& args,
      int family,
      std::function<int(const char* ip_address, int port, T* addr)> uv_ip_addr);
  static void Reset(const v8::FunctionCallbackInfo<v8::Value>& args);
  int Reset(v8::Local<v8::Value> close_callback = v8::Local<v8::Value>());

#ifdef _WIN32
  static void SetSimultaneousAccepts(
      const v8::FunctionCallbackInfo<v8::Value>& args);
#endif
};


}  // namespace node

#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#endif  // SRC_TCP_WRAP_H_
                                                                                                         node-23.7.0/src/threadpoolwork-inl.h                                                                0000664 0000000 0000000 00000005126 14746647661 0017345 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

#ifndef SRC_THREADPOOLWORK_INL_H_
#define SRC_THREADPOOLWORK_INL_H_

#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#include "node_internals.h"
#include "tracing/trace_event.h"
#include "util-inl.h"

namespace node {

void ThreadPoolWork::ScheduleWork() {
  env_->IncreaseWaitingRequestCounter();
  TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(
      TRACING_CATEGORY_NODE2(threadpoolwork, async), type_, this);
  int status = uv_queue_work(
      env_->event_loop(),
      &work_req_,
      [](uv_work_t* req) {
        ThreadPoolWork* self = ContainerOf(&ThreadPoolWork::work_req_, req);
        TRACE_EVENT_BEGIN0(TRACING_CATEGORY_NODE2(threadpoolwork, sync),
                           self->type_);
        self->DoThreadPoolWork();
        TRACE_EVENT_END0(TRACING_CATEGORY_NODE2(threadpoolwork, sync),
                         self->type_);
      },
      [](uv_work_t* req, int status) {
        ThreadPoolWork* self = ContainerOf(&ThreadPoolWork::work_req_, req);
        self->env_->DecreaseWaitingRequestCounter();
        TRACE_EVENT_NESTABLE_ASYNC_END1(
            TRACING_CATEGORY_NODE2(threadpoolwork, async),
            self->type_,
            self,
            "result",
            status);
        self->AfterThreadPoolWork(status);
      });
  CHECK_EQ(status, 0);
}

int ThreadPoolWork::CancelWork() {
  return uv_cancel(reinterpret_cast<uv_req_t*>(&work_req_));
}

}  // namespace node

#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#endif  // SRC_THREADPOOLWORK_INL_H_
                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/src/timer_wrap-inl.h                                                                    0000664 0000000 0000000 00000001363 14746647661 0016451 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #ifndef SRC_TIMER_WRAP_INL_H_
#define SRC_TIMER_WRAP_INL_H_

#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#include "timer_wrap.h"

#include <utility>

#include "env.h"
#include "uv.h"

namespace node {

template <typename... Args>
inline TimerWrap::TimerWrap(Environment* env, Args&&... args)
    : env_(env), fn_(std::forward<Args>(args)...) {
  uv_timer_init(env->event_loop(), &timer_);
  timer_.data = this;
}

template <typename... Args>
inline TimerWrapHandle::TimerWrapHandle(Environment* env, Args&&... args) {
  timer_ = new TimerWrap(env, std::forward<Args>(args)...);
  env->AddCleanupHook(CleanupHook, this);
}

}  // namespace node

#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#endif  // SRC_TIMER_WRAP_INL_H_
                                                                                                                                                                                                                                                                             node-23.7.0/src/timer_wrap.cc                                                                       0000664 0000000 0000000 00000003546 14746647661 0016034 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "timer_wrap.h"  // NOLINT(build/include_inline)
#include "timer_wrap-inl.h"

#include "env-inl.h"
#include "memory_tracker-inl.h"
#include "uv.h"

namespace node {

void TimerWrap::Stop() {
  if (timer_.data == nullptr) return;
  uv_timer_stop(&timer_);
}

void TimerWrap::Close() {
  timer_.data = nullptr;
  env_->CloseHandle(reinterpret_cast<uv_handle_t*>(&timer_), TimerClosedCb);
}

void TimerWrap::TimerClosedCb(uv_handle_t* handle) {
  std::unique_ptr<TimerWrap> ptr(
      ContainerOf(&TimerWrap::timer_,
                  reinterpret_cast<uv_timer_t*>(handle)));
}

void TimerWrap::Update(uint64_t interval, uint64_t repeat) {
  if (timer_.data == nullptr) return;
  uv_timer_start(&timer_, OnTimeout, interval, repeat);
}

void TimerWrap::Ref() {
  if (timer_.data == nullptr) return;
  uv_ref(reinterpret_cast<uv_handle_t*>(&timer_));
}

void TimerWrap::Unref() {
  if (timer_.data == nullptr) return;
  uv_unref(reinterpret_cast<uv_handle_t*>(&timer_));
}

void TimerWrap::OnTimeout(uv_timer_t* timer) {
  TimerWrap* t = ContainerOf(&TimerWrap::timer_, timer);
  t->fn_();
}

void TimerWrapHandle::Stop() {
  if (timer_ != nullptr)
    return timer_->Stop();
}

void TimerWrapHandle::Close() {
  if (timer_ != nullptr) {
    timer_->env()->RemoveCleanupHook(CleanupHook, this);
    timer_->Close();
  }
  timer_ = nullptr;
}

void TimerWrapHandle::Ref() {
  if (timer_ != nullptr)
    timer_->Ref();
}

void TimerWrapHandle::Unref() {
  if (timer_ != nullptr)
    timer_->Unref();
}

void TimerWrapHandle::Update(uint64_t interval, uint64_t repeat) {
  if (timer_ != nullptr)
    timer_->Update(interval, repeat);
}

void TimerWrapHandle::MemoryInfo(MemoryTracker* tracker) const {
  if (timer_ != nullptr)
    tracker->TrackField("timer", *timer_);
}

void TimerWrapHandle::CleanupHook(void* data) {
  static_cast<TimerWrapHandle*>(data)->Close();
}

}  // namespace node
                                                                                                                                                          node-23.7.0/src/timer_wrap.h                                                                        0000664 0000000 0000000 00000003453 14746647661 0015673 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #ifndef SRC_TIMER_WRAP_H_
#define SRC_TIMER_WRAP_H_

#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#include "memory_tracker.h"
#include "env.h"
#include "uv.h"

#include <functional>

namespace node {

// Utility class that makes working with libuv timers a bit easier.
class TimerWrap final : public MemoryRetainer {
 public:
  using TimerCb = std::function<void()>;

  template <typename... Args>
  explicit inline TimerWrap(Environment* env, Args&&... args);

  TimerWrap(const TimerWrap&) = delete;

  inline Environment* env() const { return env_; }

  // Stop calling the timer callback.
  void Stop();
  // Render the timer unusable and delete this object.
  void Close();

  // Starts / Restarts the Timer
  void Update(uint64_t interval, uint64_t repeat = 0);

  void Ref();
  void Unref();

  SET_NO_MEMORY_INFO()
  SET_MEMORY_INFO_NAME(TimerWrap)
  SET_SELF_SIZE(TimerWrap)

 private:
  static void TimerClosedCb(uv_handle_t* handle);
  static void OnTimeout(uv_timer_t* timer);
  ~TimerWrap() = default;

  Environment* env_;
  TimerCb fn_;
  uv_timer_t timer_;

  friend std::unique_ptr<TimerWrap>::deleter_type;
};

class TimerWrapHandle : public MemoryRetainer  {
 public:
  template <typename... Args>
  explicit inline TimerWrapHandle(Environment* env, Args&&... args);

  TimerWrapHandle(const TimerWrapHandle&) = delete;

  ~TimerWrapHandle() { Close(); }

  void Update(uint64_t interval, uint64_t repeat = 0);

  void Ref();
  void Unref();

  void Stop();
  void Close();

  void MemoryInfo(node::MemoryTracker* tracker) const override;

  SET_MEMORY_INFO_NAME(TimerWrapHandle)
  SET_SELF_SIZE(TimerWrapHandle)

 private:
  static void CleanupHook(void* data);

  TimerWrap* timer_;
};

}  // namespace node

#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#endif  // SRC_TIMER_WRAP_H_
                                                                                                                                                                                                                     node-23.7.0/src/timers.cc                                                                           0000664 0000000 0000000 00000015734 14746647661 0015170 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "timers.h"
#include "env-inl.h"
#include "node_external_reference.h"
#include "util-inl.h"
#include "v8.h"

#include <cstdint>

namespace node {
namespace timers {

using v8::Context;
using v8::Function;
using v8::FunctionCallbackInfo;
using v8::Isolate;
using v8::Local;
using v8::Number;
using v8::Object;
using v8::ObjectTemplate;
using v8::Value;

void BindingData::SetupTimers(const FunctionCallbackInfo<Value>& args) {
  CHECK(args[0]->IsFunction());
  CHECK(args[1]->IsFunction());
  auto env = Environment::GetCurrent(args);

  env->set_immediate_callback_function(args[0].As<Function>());
  env->set_timers_callback_function(args[1].As<Function>());
}

void BindingData::SlowGetLibuvNow(const FunctionCallbackInfo<Value>& args) {
  double now = GetLibuvNowImpl(Realm::GetBindingData<BindingData>(args));
  args.GetReturnValue().Set(Number::New(args.GetIsolate(), now));
}

double BindingData::FastGetLibuvNow(Local<Object> unused,
                                    Local<Object> receiver) {
  return GetLibuvNowImpl(FromJSObject<BindingData>(receiver));
}

double BindingData::GetLibuvNowImpl(BindingData* data) {
  return static_cast<double>(data->env()->GetNowUint64());
}

void BindingData::SlowScheduleTimer(const FunctionCallbackInfo<Value>& args) {
  int64_t duration =
      args[0]->IntegerValue(args.GetIsolate()->GetCurrentContext()).FromJust();
  ScheduleTimerImpl(Realm::GetBindingData<BindingData>(args), duration);
}

void BindingData::FastScheduleTimer(Local<Object> unused,
                                    Local<Object> receiver,
                                    int64_t duration) {
  ScheduleTimerImpl(FromJSObject<BindingData>(receiver), duration);
}

void BindingData::ScheduleTimerImpl(BindingData* data, int64_t duration) {
  data->env()->ScheduleTimer(duration);
}

void BindingData::SlowToggleTimerRef(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  ToggleTimerRefImpl(Realm::GetBindingData<BindingData>(args),
                     args[0]->IsTrue());
}

void BindingData::FastToggleTimerRef(Local<Object> unused,
                                     Local<Object> receiver,
                                     bool ref) {
  ToggleTimerRefImpl(FromJSObject<BindingData>(receiver), ref);
}

void BindingData::ToggleTimerRefImpl(BindingData* data, bool ref) {
  data->env()->ToggleTimerRef(ref);
}

void BindingData::SlowToggleImmediateRef(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  ToggleImmediateRefImpl(Realm::GetBindingData<BindingData>(args),
                         args[0]->IsTrue());
}

void BindingData::FastToggleImmediateRef(Local<Object> unused,
                                         Local<Object> receiver,
                                         bool ref) {
  ToggleImmediateRefImpl(FromJSObject<BindingData>(receiver), ref);
}

void BindingData::ToggleImmediateRefImpl(BindingData* data, bool ref) {
  data->env()->ToggleImmediateRef(ref);
}

BindingData::BindingData(Realm* realm, Local<Object> object)
    : SnapshotableObject(realm, object, type_int) {}

bool BindingData::PrepareForSerialization(Local<Context> context,
                                          v8::SnapshotCreator* creator) {
  // Return true because we need to maintain the reference to the binding from
  // JS land.
  return true;
}

InternalFieldInfoBase* BindingData::Serialize(int index) {
  DCHECK_IS_SNAPSHOT_SLOT(index);
  InternalFieldInfo* info =
      InternalFieldInfoBase::New<InternalFieldInfo>(type());
  return info;
}

void BindingData::Deserialize(Local<Context> context,
                              Local<Object> holder,
                              int index,
                              InternalFieldInfoBase* info) {
  DCHECK_IS_SNAPSHOT_SLOT(index);
  v8::HandleScope scope(context->GetIsolate());
  Realm* realm = Realm::GetCurrent(context);
  // Recreate the buffer in the constructor.
  BindingData* binding = realm->AddBindingData<BindingData>(holder);
  CHECK_NOT_NULL(binding);
}

v8::CFunction BindingData::fast_get_libuv_now_(
    v8::CFunction::Make(FastGetLibuvNow));
v8::CFunction BindingData::fast_schedule_timers_(
    v8::CFunction::Make(FastScheduleTimer));
v8::CFunction BindingData::fast_toggle_timer_ref_(
    v8::CFunction::Make(FastToggleTimerRef));
v8::CFunction BindingData::fast_toggle_immediate_ref_(
    v8::CFunction::Make(FastToggleImmediateRef));

void BindingData::CreatePerIsolateProperties(IsolateData* isolate_data,
                                             Local<ObjectTemplate> target) {
  Isolate* isolate = isolate_data->isolate();

  SetMethod(isolate, target, "setupTimers", SetupTimers);
  SetFastMethod(
      isolate, target, "getLibuvNow", SlowGetLibuvNow, &fast_get_libuv_now_);
  SetFastMethod(isolate,
                target,
                "scheduleTimer",
                SlowScheduleTimer,
                &fast_schedule_timers_);
  SetFastMethod(isolate,
                target,
                "toggleTimerRef",
                SlowToggleTimerRef,
                &fast_toggle_timer_ref_);
  SetFastMethod(isolate,
                target,
                "toggleImmediateRef",
                SlowToggleImmediateRef,
                &fast_toggle_immediate_ref_);
}

void BindingData::CreatePerContextProperties(Local<Object> target,
                                             Local<Value> unused,
                                             Local<Context> context,
                                             void* priv) {
  Realm* realm = Realm::GetCurrent(context);
  Environment* env = realm->env();
  BindingData* const binding_data = realm->AddBindingData<BindingData>(target);
  if (binding_data == nullptr) return;

  // TODO(joyeecheung): move these into BindingData.
  target
      ->Set(context,
            FIXED_ONE_BYTE_STRING(realm->isolate(), "immediateInfo"),
            env->immediate_info()->fields().GetJSArray())
      .Check();

  target
      ->Set(context,
            FIXED_ONE_BYTE_STRING(realm->isolate(), "timeoutInfo"),
            env->timeout_info().GetJSArray())
      .Check();
}

void BindingData::RegisterTimerExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(SetupTimers);

  registry->Register(SlowGetLibuvNow);
  registry->Register(FastGetLibuvNow);
  registry->Register(fast_get_libuv_now_.GetTypeInfo());

  registry->Register(SlowScheduleTimer);
  registry->Register(FastScheduleTimer);
  registry->Register(fast_schedule_timers_.GetTypeInfo());

  registry->Register(SlowToggleTimerRef);
  registry->Register(FastToggleTimerRef);
  registry->Register(fast_toggle_timer_ref_.GetTypeInfo());

  registry->Register(SlowToggleImmediateRef);
  registry->Register(FastToggleImmediateRef);
  registry->Register(fast_toggle_immediate_ref_.GetTypeInfo());
}

}  // namespace timers

}  // namespace node

NODE_BINDING_CONTEXT_AWARE_INTERNAL(
    timers, node::timers::BindingData::CreatePerContextProperties)
NODE_BINDING_PER_ISOLATE_INIT(
    timers, node::timers::BindingData::CreatePerIsolateProperties)
NODE_BINDING_EXTERNAL_REFERENCE(
    timers, node::timers::BindingData::RegisterTimerExternalReferences)
                                    node-23.7.0/src/timers.h                                                                            0000664 0000000 0000000 00000005264 14746647661 0015027 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #ifndef SRC_TIMERS_H_
#define SRC_TIMERS_H_

#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#include <cinttypes>
#include "node_snapshotable.h"

namespace node {
class ExternalReferenceRegistry;

namespace timers {
class BindingData : public SnapshotableObject {
 public:
  BindingData(Realm* env, v8::Local<v8::Object> obj);

  using InternalFieldInfo = InternalFieldInfoBase;

  SET_BINDING_ID(timers_binding_data)
  SERIALIZABLE_OBJECT_METHODS()

  SET_NO_MEMORY_INFO()
  SET_SELF_SIZE(BindingData)
  SET_MEMORY_INFO_NAME(BindingData)

  static void SetupTimers(const v8::FunctionCallbackInfo<v8::Value>& args);

  static void SlowGetLibuvNow(const v8::FunctionCallbackInfo<v8::Value>& args);
  static double FastGetLibuvNow(v8::Local<v8::Object> unused,
                                v8::Local<v8::Object> receiver);
  static double GetLibuvNowImpl(BindingData* data);

  static void SlowScheduleTimer(
      const v8::FunctionCallbackInfo<v8::Value>& args);
  static void FastScheduleTimer(v8::Local<v8::Object> unused,
                                v8::Local<v8::Object> receiver,
                                int64_t duration);
  static void ScheduleTimerImpl(BindingData* data, int64_t duration);

  static void SlowToggleTimerRef(
      const v8::FunctionCallbackInfo<v8::Value>& args);
  static void FastToggleTimerRef(v8::Local<v8::Object> unused,
                                 v8::Local<v8::Object> receiver,
                                 bool ref);
  static void ToggleTimerRefImpl(BindingData* data, bool ref);

  static void SlowToggleImmediateRef(
      const v8::FunctionCallbackInfo<v8::Value>& args);
  static void FastToggleImmediateRef(v8::Local<v8::Object> unused,
                                     v8::Local<v8::Object> receiver,
                                     bool ref);
  static void ToggleImmediateRefImpl(BindingData* data, bool ref);

  static void CreatePerIsolateProperties(IsolateData* isolate_data,
                                         v8::Local<v8::ObjectTemplate> target);
  static void CreatePerContextProperties(v8::Local<v8::Object> target,
                                         v8::Local<v8::Value> unused,
                                         v8::Local<v8::Context> context,
                                         void* priv);
  static void RegisterTimerExternalReferences(
      ExternalReferenceRegistry* registry);

 private:
  static v8::CFunction fast_get_libuv_now_;
  static v8::CFunction fast_schedule_timers_;
  static v8::CFunction fast_toggle_timer_ref_;
  static v8::CFunction fast_toggle_immediate_ref_;
};

}  // namespace timers

}  // namespace node

#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#endif  // SRC_TIMERS_H_
                                                                                                                                                                                                                                                                                                                                            node-23.7.0/src/tracing/                                                                            0000775 0000000 0000000 00000000000 14746647661 0014773 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/src/tracing/agent.cc                                                                    0000664 0000000 0000000 00000016673 14746647661 0016415 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "tracing/agent.h"

#include <string>
#include "trace_event.h"
#include "tracing/node_trace_buffer.h"
#include "debug_utils-inl.h"
#include "env-inl.h"

namespace node {
namespace tracing {

class Agent::ScopedSuspendTracing {
 public:
  ScopedSuspendTracing(TracingController* controller, Agent* agent,
                       bool do_suspend = true)
    : controller_(controller), agent_(do_suspend ? agent : nullptr) {
    if (do_suspend) {
      CHECK(agent_->started_);
      controller->StopTracing();
    }
  }

  ~ScopedSuspendTracing() {
    if (agent_ == nullptr) return;
    TraceConfig* config = agent_->CreateTraceConfig();
    if (config != nullptr) {
      controller_->StartTracing(config);
    }
  }

 private:
  TracingController* controller_;
  Agent* agent_;
};

namespace {

std::set<std::string> flatten(
    const std::unordered_map<int, std::multiset<std::string>>& map) {
  std::set<std::string> result;
  for (const auto& id_value : map)
    result.insert(id_value.second.begin(), id_value.second.end());
  return result;
}

}  // namespace

using v8::platform::tracing::TraceConfig;
using v8::platform::tracing::TraceWriter;
using std::string;

Agent::Agent() : tracing_controller_(new TracingController()) {
  tracing_controller_->Initialize(nullptr);

  CHECK_EQ(uv_loop_init(&tracing_loop_), 0);
  CHECK_EQ(uv_async_init(&tracing_loop_,
                         &initialize_writer_async_,
                         [](uv_async_t* async) {
    Agent* agent = ContainerOf(&Agent::initialize_writer_async_, async);
    agent->InitializeWritersOnThread();
  }), 0);
  uv_unref(reinterpret_cast<uv_handle_t*>(&initialize_writer_async_));
}

void Agent::InitializeWritersOnThread() {
  Mutex::ScopedLock lock(initialize_writer_mutex_);
  while (!to_be_initialized_.empty()) {
    AsyncTraceWriter* head = *to_be_initialized_.begin();
    head->InitializeOnThread(&tracing_loop_);
    to_be_initialized_.erase(head);
  }
  initialize_writer_condvar_.Broadcast(lock);
}

Agent::~Agent() {
  categories_.clear();
  writers_.clear();

  StopTracing();

  uv_close(reinterpret_cast<uv_handle_t*>(&initialize_writer_async_), nullptr);
  uv_run(&tracing_loop_, UV_RUN_ONCE);
  CheckedUvLoopClose(&tracing_loop_);
}

void Agent::Start() {
  if (started_)
    return;

  NodeTraceBuffer* trace_buffer_ = new NodeTraceBuffer(
      NodeTraceBuffer::kBufferChunks, this, &tracing_loop_);
  tracing_controller_->Initialize(trace_buffer_);

  // This thread should be created *after* async handles are created
  // (within NodeTraceWriter and NodeTraceBuffer constructors).
  // Otherwise the thread could shut down prematurely.
  CHECK_EQ(0, uv_thread_create(&thread_, [](void* arg) {
    Agent* agent = static_cast<Agent*>(arg);
    uv_run(&agent->tracing_loop_, UV_RUN_DEFAULT);
  }, this));
  started_ = true;
}

AgentWriterHandle Agent::AddClient(
    const std::set<std::string>& categories,
    std::unique_ptr<AsyncTraceWriter> writer,
    enum UseDefaultCategoryMode mode) {
  Start();

  const std::set<std::string>* use_categories = &categories;

  std::set<std::string> categories_with_default;
  if (mode == kUseDefaultCategories) {
    categories_with_default.insert(categories.begin(), categories.end());
    categories_with_default.insert(categories_[kDefaultHandleId].begin(),
                                   categories_[kDefaultHandleId].end());
    use_categories = &categories_with_default;
  }

  ScopedSuspendTracing suspend(tracing_controller_.get(), this);
  int id = next_writer_id_++;
  AsyncTraceWriter* raw = writer.get();
  writers_[id] = std::move(writer);
  categories_[id] = { use_categories->begin(), use_categories->end() };

  {
    Mutex::ScopedLock lock(initialize_writer_mutex_);
    to_be_initialized_.insert(raw);
    uv_async_send(&initialize_writer_async_);
    while (to_be_initialized_.count(raw) > 0)
      initialize_writer_condvar_.Wait(lock);
  }

  return AgentWriterHandle(this, id);
}

AgentWriterHandle Agent::DefaultHandle() {
  return AgentWriterHandle(this, kDefaultHandleId);
}

void Agent::StopTracing() {
  if (!started_)
    return;
  // Perform final Flush on TraceBuffer. We don't want the tracing controller
  // to flush the buffer again on destruction of the V8::Platform.
  tracing_controller_->StopTracing();
  tracing_controller_->Initialize(nullptr);
  started_ = false;

  // Thread should finish when the tracing loop is stopped.
  uv_thread_join(&thread_);
}

void Agent::Disconnect(int client) {
  if (client == kDefaultHandleId) return;
  {
    Mutex::ScopedLock lock(initialize_writer_mutex_);
    to_be_initialized_.erase(writers_[client].get());
  }
  ScopedSuspendTracing suspend(tracing_controller_.get(), this);
  writers_.erase(client);
  categories_.erase(client);
}

void Agent::Enable(int id, const std::set<std::string>& categories) {
  if (categories.empty())
    return;

  ScopedSuspendTracing suspend(tracing_controller_.get(), this,
                               id != kDefaultHandleId);
  categories_[id].insert(categories.begin(), categories.end());
}

void Agent::Disable(int id, const std::set<std::string>& categories) {
  ScopedSuspendTracing suspend(tracing_controller_.get(), this,
                               id != kDefaultHandleId);
  std::multiset<std::string>& writer_categories = categories_[id];
  for (const std::string& category : categories) {
    auto it = writer_categories.find(category);
    if (it != writer_categories.end())
      writer_categories.erase(it);
  }
}

TraceConfig* Agent::CreateTraceConfig() const {
  if (categories_.empty())
    return nullptr;
  TraceConfig* trace_config = new TraceConfig();
  for (const auto& category : flatten(categories_)) {
    trace_config->AddIncludedCategory(category.c_str());
  }
  return trace_config;
}

std::string Agent::GetEnabledCategories() const {
  std::string categories;
  for (const std::string& category : flatten(categories_)) {
    if (!categories.empty())
      categories += ',';
    categories += category;
  }
  return categories;
}

void Agent::AppendTraceEvent(TraceObject* trace_event) {
  for (const auto& id_writer : writers_)
    id_writer.second->AppendTraceEvent(trace_event);
}

void Agent::AddMetadataEvent(std::unique_ptr<TraceObject> event) {
  Mutex::ScopedLock lock(metadata_events_mutex_);
  metadata_events_.push_back(std::move(event));
}

void Agent::Flush(bool blocking) {
  {
    Mutex::ScopedLock lock(metadata_events_mutex_);
    for (const auto& event : metadata_events_)
      AppendTraceEvent(event.get());
  }

  for (const auto& id_writer : writers_)
    id_writer.second->Flush(blocking);
}

void TracingController::AddMetadataEvent(
    const unsigned char* category_group_enabled,
    const char* name,
    int num_args,
    const char** arg_names,
    const unsigned char* arg_types,
    const uint64_t* arg_values,
    std::unique_ptr<v8::ConvertableToTraceFormat>* convertable_values,
    unsigned int flags) {
  std::unique_ptr<TraceObject> trace_event(new TraceObject);
  trace_event->Initialize(
      TRACE_EVENT_PHASE_METADATA, category_group_enabled, name,
      node::tracing::kGlobalScope,  // scope
      node::tracing::kNoId,         // id
      node::tracing::kNoId,         // bind_id
      num_args, arg_names, arg_types, arg_values, convertable_values,
      TRACE_EVENT_FLAG_NONE,
      CurrentTimestampMicroseconds(),
      CurrentCpuTimestampMicroseconds());
  Agent* node_agent = node::tracing::TraceEventHelper::GetAgent();
  if (node_agent != nullptr)
    node_agent->AddMetadataEvent(std::move(trace_event));
}

}  // namespace tracing
}  // namespace node
                                                                     node-23.7.0/src/tracing/agent.h                                                                     0000664 0000000 0000000 00000012532 14746647661 0016245 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #ifndef SRC_TRACING_AGENT_H_
#define SRC_TRACING_AGENT_H_

#include "libplatform/v8-tracing.h"
#include "uv.h"
#include "util.h"
#include "node_mutex.h"

#include <list>
#include <set>
#include <string>
#include <unordered_map>

namespace v8 {
class ConvertableToTraceFormat;
class TracingController;
}  // namespace v8

namespace node {
namespace tracing {

using v8::platform::tracing::TraceConfig;
using v8::platform::tracing::TraceObject;

class Agent;

class AsyncTraceWriter {
 public:
  virtual ~AsyncTraceWriter() = default;
  virtual void AppendTraceEvent(TraceObject* trace_event) = 0;
  virtual void Flush(bool blocking) = 0;
  virtual void InitializeOnThread(uv_loop_t* loop) {}
};

class TracingController : public v8::platform::tracing::TracingController {
 public:
  TracingController() : v8::platform::tracing::TracingController() {}

  int64_t CurrentTimestampMicroseconds() override {
    return uv_hrtime() / 1000;
  }
  void AddMetadataEvent(
      const unsigned char* category_group_enabled,
      const char* name,
      int num_args,
      const char** arg_names,
      const unsigned char* arg_types,
      const uint64_t* arg_values,
      std::unique_ptr<v8::ConvertableToTraceFormat>* convertable_values,
      unsigned int flags);
};

class AgentWriterHandle {
 public:
  inline AgentWriterHandle() = default;
  inline ~AgentWriterHandle() { reset(); }

  inline AgentWriterHandle(AgentWriterHandle&& other);
  inline AgentWriterHandle& operator=(AgentWriterHandle&& other);
  inline bool empty() const { return agent_ == nullptr; }
  inline void reset();

  inline void Enable(const std::set<std::string>& categories);
  inline void Disable(const std::set<std::string>& categories);

  inline bool IsDefaultHandle();

  inline Agent* agent() { return agent_; }

  inline v8::TracingController* GetTracingController();

  AgentWriterHandle(const AgentWriterHandle& other) = delete;
  AgentWriterHandle& operator=(const AgentWriterHandle& other) = delete;

 private:
  inline AgentWriterHandle(Agent* agent, int id) : agent_(agent), id_(id) {}

  Agent* agent_ = nullptr;
  int id_ = 0;

  friend class Agent;
};

class Agent {
 public:
  Agent();
  ~Agent();

  TracingController* GetTracingController() {
    TracingController* controller = tracing_controller_.get();
    CHECK_NOT_NULL(controller);
    return controller;
  }

  enum UseDefaultCategoryMode {
    kUseDefaultCategories,
    kIgnoreDefaultCategories
  };

  // Destroying the handle disconnects the client
  AgentWriterHandle AddClient(const std::set<std::string>& categories,
                              std::unique_ptr<AsyncTraceWriter> writer,
                              enum UseDefaultCategoryMode mode);
  // A handle that is only used for managing the default categories
  // (which can then implicitly be used through using `USE_DEFAULT_CATEGORIES`
  // when adding a client later).
  AgentWriterHandle DefaultHandle();

  // Returns a comma-separated list of enabled categories.
  std::string GetEnabledCategories() const;

  // Writes to all writers registered through AddClient().
  void AppendTraceEvent(TraceObject* trace_event);

  void AddMetadataEvent(std::unique_ptr<TraceObject> event);
  // Flushes all writers registered through AddClient().
  void Flush(bool blocking);

  TraceConfig* CreateTraceConfig() const;

 private:
  friend class AgentWriterHandle;

  void InitializeWritersOnThread();

  void Start();
  void StopTracing();
  void Disconnect(int client);

  void Enable(int id, const std::set<std::string>& categories);
  void Disable(int id, const std::set<std::string>& categories);

  uv_thread_t thread_;
  uv_loop_t tracing_loop_;

  bool started_ = false;
  class ScopedSuspendTracing;

  // Each individual Writer has one id.
  int next_writer_id_ = 1;
  enum { kDefaultHandleId = -1 };
  // These maps store the original arguments to AddClient(), by id.
  std::unordered_map<int, std::multiset<std::string>> categories_;
  std::unordered_map<int, std::unique_ptr<AsyncTraceWriter>> writers_;
  std::unique_ptr<TracingController> tracing_controller_;

  // Variables related to initializing per-event-loop properties of individual
  // writers, such as libuv handles.
  Mutex initialize_writer_mutex_;
  ConditionVariable initialize_writer_condvar_;
  uv_async_t initialize_writer_async_;
  std::set<AsyncTraceWriter*> to_be_initialized_;

  Mutex metadata_events_mutex_;
  std::list<std::unique_ptr<TraceObject>> metadata_events_;
};

void AgentWriterHandle::reset() {
  if (agent_ != nullptr)
    agent_->Disconnect(id_);
  agent_ = nullptr;
}

AgentWriterHandle& AgentWriterHandle::operator=(AgentWriterHandle&& other) {
  reset();
  agent_ = other.agent_;
  id_ = other.id_;
  other.agent_ = nullptr;
  return *this;
}

AgentWriterHandle::AgentWriterHandle(AgentWriterHandle&& other) {
  *this = std::move(other);
}

void AgentWriterHandle::Enable(const std::set<std::string>& categories) {
  if (agent_ != nullptr) agent_->Enable(id_, categories);
}

void AgentWriterHandle::Disable(const std::set<std::string>& categories) {
  if (agent_ != nullptr) agent_->Disable(id_, categories);
}

bool AgentWriterHandle::IsDefaultHandle() {
  return agent_ != nullptr && id_ == Agent::kDefaultHandleId;
}

inline v8::TracingController* AgentWriterHandle::GetTracingController() {
  return agent_ != nullptr ? agent_->GetTracingController() : nullptr;
}

}  // namespace tracing
}  // namespace node

#endif  // SRC_TRACING_AGENT_H_
                                                                                                                                                                      node-23.7.0/src/tracing/node_trace_buffer.cc                                                        0000664 0000000 0000000 00000014716 14746647661 0020747 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "tracing/node_trace_buffer.h"

#include <memory>
#include "util-inl.h"

namespace node {
namespace tracing {

InternalTraceBuffer::InternalTraceBuffer(size_t max_chunks, uint32_t id,
                                         Agent* agent)
    : flushing_(false), max_chunks_(max_chunks),
      agent_(agent), id_(id) {
  chunks_.resize(max_chunks);
}

TraceObject* InternalTraceBuffer::AddTraceEvent(uint64_t* handle) {
  Mutex::ScopedLock scoped_lock(mutex_);
  // Create new chunk if last chunk is full or there is no chunk.
  if (total_chunks_ == 0 || chunks_[total_chunks_ - 1]->IsFull()) {
    auto& chunk = chunks_[total_chunks_++];
    if (chunk) {
      chunk->Reset(current_chunk_seq_++);
    } else {
      chunk = std::make_unique<TraceBufferChunk>(current_chunk_seq_++);
    }
  }
  auto& chunk = chunks_[total_chunks_ - 1];
  size_t event_index;
  TraceObject* trace_object = chunk->AddTraceEvent(&event_index);
  *handle = MakeHandle(total_chunks_ - 1, chunk->seq(), event_index);
  return trace_object;
}

TraceObject* InternalTraceBuffer::GetEventByHandle(uint64_t handle) {
  Mutex::ScopedLock scoped_lock(mutex_);
  if (handle == 0) {
    // A handle value of zero never has a trace event associated with it.
    return nullptr;
  }
  size_t chunk_index, event_index;
  uint32_t buffer_id, chunk_seq;
  ExtractHandle(handle, &buffer_id, &chunk_index, &chunk_seq, &event_index);
  if (buffer_id != id_ || chunk_index >= total_chunks_) {
    // Either the chunk belongs to the other buffer, or is outside the current
    // range of chunks loaded in memory (the latter being true suggests that
    // the chunk has already been flushed and is no longer in memory.)
    return nullptr;
  }
  auto& chunk = chunks_[chunk_index];
  if (chunk->seq() != chunk_seq) {
    // Chunk is no longer in memory.
    return nullptr;
  }
  return chunk->GetEventAt(event_index);
}

void InternalTraceBuffer::Flush(bool blocking) {
  {
    Mutex::ScopedLock scoped_lock(mutex_);
    if (total_chunks_ > 0) {
      flushing_ = true;
      for (size_t i = 0; i < total_chunks_; ++i) {
        auto& chunk = chunks_[i];
        for (size_t j = 0; j < chunk->size(); ++j) {
          TraceObject* trace_event = chunk->GetEventAt(j);
          // Another thread may have added a trace that is yet to be
          // initialized. Skip such traces.
          // https://github.com/nodejs/node/issues/21038.
          if (trace_event->name()) {
            agent_->AppendTraceEvent(trace_event);
          }
        }
      }
      total_chunks_ = 0;
      flushing_ = false;
    }
  }
  agent_->Flush(blocking);
}

uint64_t InternalTraceBuffer::MakeHandle(
    size_t chunk_index, uint32_t chunk_seq, size_t event_index) const {
  return ((static_cast<uint64_t>(chunk_seq) * Capacity() +
          chunk_index * TraceBufferChunk::kChunkSize + event_index) << 1) + id_;
}

void InternalTraceBuffer::ExtractHandle(
    uint64_t handle, uint32_t* buffer_id, size_t* chunk_index,
    uint32_t* chunk_seq, size_t* event_index) const {
  *buffer_id = static_cast<uint32_t>(handle & 0x1);
  handle >>= 1;
  *chunk_seq = static_cast<uint32_t>(handle / Capacity());
  size_t indices = handle % Capacity();
  *chunk_index = indices / TraceBufferChunk::kChunkSize;
  *event_index = indices % TraceBufferChunk::kChunkSize;
}

NodeTraceBuffer::NodeTraceBuffer(size_t max_chunks,
    Agent* agent, uv_loop_t* tracing_loop)
    : tracing_loop_(tracing_loop),
      buffer1_(max_chunks, 0, agent),
      buffer2_(max_chunks, 1, agent) {
  current_buf_.store(&buffer1_);

  flush_signal_.data = this;
  int err = uv_async_init(tracing_loop_, &flush_signal_,
                          NonBlockingFlushSignalCb);
  CHECK_EQ(err, 0);

  exit_signal_.data = this;
  err = uv_async_init(tracing_loop_, &exit_signal_, ExitSignalCb);
  CHECK_EQ(err, 0);
}

NodeTraceBuffer::~NodeTraceBuffer() {
  uv_async_send(&exit_signal_);
  Mutex::ScopedLock scoped_lock(exit_mutex_);
  while (!exited_) {
    exit_cond_.Wait(scoped_lock);
  }
}

TraceObject* NodeTraceBuffer::AddTraceEvent(uint64_t* handle) {
  // If the buffer is full, attempt to perform a flush.
  if (!TryLoadAvailableBuffer()) {
    // Assign a value of zero as the trace event handle.
    // This is equivalent to calling InternalTraceBuffer::MakeHandle(0, 0, 0),
    // and will cause GetEventByHandle to return NULL if passed as an argument.
    *handle = 0;
    return nullptr;
  }
  return current_buf_.load()->AddTraceEvent(handle);
}

TraceObject* NodeTraceBuffer::GetEventByHandle(uint64_t handle) {
  return current_buf_.load()->GetEventByHandle(handle);
}

bool NodeTraceBuffer::Flush() {
  buffer1_.Flush(true);
  buffer2_.Flush(true);
  return true;
}

// Attempts to set current_buf_ such that it references a buffer that can
// write at least one trace event. If both buffers are unavailable this
// method returns false; otherwise it returns true.
bool NodeTraceBuffer::TryLoadAvailableBuffer() {
  InternalTraceBuffer* prev_buf = current_buf_.load();
  if (prev_buf->IsFull()) {
    uv_async_send(&flush_signal_);  // trigger flush on a separate thread
    InternalTraceBuffer* other_buf = prev_buf == &buffer1_ ?
      &buffer2_ : &buffer1_;
    if (!other_buf->IsFull()) {
      current_buf_.store(other_buf);
    } else {
      return false;
    }
  }
  return true;
}

// static
void NodeTraceBuffer::NonBlockingFlushSignalCb(uv_async_t* signal) {
  NodeTraceBuffer* buffer = static_cast<NodeTraceBuffer*>(signal->data);
  if (buffer->buffer1_.IsFull() && !buffer->buffer1_.IsFlushing()) {
    buffer->buffer1_.Flush(false);
  }
  if (buffer->buffer2_.IsFull() && !buffer->buffer2_.IsFlushing()) {
    buffer->buffer2_.Flush(false);
  }
}

// static
void NodeTraceBuffer::ExitSignalCb(uv_async_t* signal) {
  NodeTraceBuffer* buffer =
      ContainerOf(&NodeTraceBuffer::exit_signal_, signal);

  // Close both flush_signal_ and exit_signal_.
  uv_close(reinterpret_cast<uv_handle_t*>(&buffer->flush_signal_),
           [](uv_handle_t* signal) {
    NodeTraceBuffer* buffer =
        ContainerOf(&NodeTraceBuffer::flush_signal_,
                    reinterpret_cast<uv_async_t*>(signal));

    uv_close(reinterpret_cast<uv_handle_t*>(&buffer->exit_signal_),
             [](uv_handle_t* signal) {
      NodeTraceBuffer* buffer =
          ContainerOf(&NodeTraceBuffer::exit_signal_,
                      reinterpret_cast<uv_async_t*>(signal));
        Mutex::ScopedLock scoped_lock(buffer->exit_mutex_);
        buffer->exited_ = true;
        buffer->exit_cond_.Signal(scoped_lock);
    });
  });
}

}  // namespace tracing
}  // namespace node
                                                  node-23.7.0/src/tracing/node_trace_buffer.h                                                         0000664 0000000 0000000 00000004440 14746647661 0020602 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #ifndef SRC_TRACING_NODE_TRACE_BUFFER_H_
#define SRC_TRACING_NODE_TRACE_BUFFER_H_

#include "tracing/agent.h"
#include "node_mutex.h"
#include "libplatform/v8-tracing.h"

#include <atomic>

namespace node {
namespace tracing {

using v8::platform::tracing::TraceBuffer;
using v8::platform::tracing::TraceBufferChunk;
using v8::platform::tracing::TraceObject;

// forward declaration
class NodeTraceBuffer;

class InternalTraceBuffer {
 public:
  InternalTraceBuffer(size_t max_chunks, uint32_t id, Agent* agent);

  TraceObject* AddTraceEvent(uint64_t* handle);
  TraceObject* GetEventByHandle(uint64_t handle);
  void Flush(bool blocking);
  bool IsFull() const {
    return total_chunks_ == max_chunks_ && chunks_[total_chunks_ - 1]->IsFull();
  }
  bool IsFlushing() const {
    return flushing_;
  }

 private:
  uint64_t MakeHandle(size_t chunk_index, uint32_t chunk_seq,
                      size_t event_index) const;
  void ExtractHandle(uint64_t handle, uint32_t* buffer_id, size_t* chunk_index,
                     uint32_t* chunk_seq, size_t* event_index) const;
  size_t Capacity() const { return max_chunks_ * TraceBufferChunk::kChunkSize; }

  Mutex mutex_;
  bool flushing_;
  size_t max_chunks_;
  Agent* agent_;
  std::vector<std::unique_ptr<TraceBufferChunk>> chunks_;
  size_t total_chunks_ = 0;
  uint32_t current_chunk_seq_ = 1;
  uint32_t id_;
};

class NodeTraceBuffer : public TraceBuffer {
 public:
  NodeTraceBuffer(size_t max_chunks, Agent* agent, uv_loop_t* tracing_loop);
  ~NodeTraceBuffer() override;

  TraceObject* AddTraceEvent(uint64_t* handle) override;
  TraceObject* GetEventByHandle(uint64_t handle) override;
  bool Flush() override;

  static const size_t kBufferChunks = 1024;

 private:
  bool TryLoadAvailableBuffer();
  static void NonBlockingFlushSignalCb(uv_async_t* signal);
  static void ExitSignalCb(uv_async_t* signal);

  uv_loop_t* tracing_loop_;
  uv_async_t flush_signal_;
  uv_async_t exit_signal_;
  bool exited_ = false;
  // Used exclusively for exit logic.
  Mutex exit_mutex_;
  // Used to wait until async handles have been closed.
  ConditionVariable exit_cond_;
  std::atomic<InternalTraceBuffer*> current_buf_;
  InternalTraceBuffer buffer1_;
  InternalTraceBuffer buffer2_;
};

}  // namespace tracing
}  // namespace node

#endif  // SRC_TRACING_NODE_TRACE_BUFFER_H_
                                                                                                                                                                                                                                node-23.7.0/src/tracing/node_trace_writer.cc                                                        0000664 0000000 0000000 00000016776 14746647661 0021022 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "tracing/node_trace_writer.h"

#include "util-inl.h"

#include <fcntl.h>
#include <cstring>

namespace node {
namespace tracing {

NodeTraceWriter::NodeTraceWriter(const std::string& log_file_pattern)
    : log_file_pattern_(log_file_pattern) {}

void NodeTraceWriter::InitializeOnThread(uv_loop_t* loop) {
  CHECK_NULL(tracing_loop_);
  tracing_loop_ = loop;

  flush_signal_.data = this;
  int err = uv_async_init(tracing_loop_, &flush_signal_,
                          [](uv_async_t* signal) {
    NodeTraceWriter* trace_writer =
        ContainerOf(&NodeTraceWriter::flush_signal_, signal);
    trace_writer->FlushPrivate();
  });
  CHECK_EQ(err, 0);

  exit_signal_.data = this;
  err = uv_async_init(tracing_loop_, &exit_signal_, ExitSignalCb);
  CHECK_EQ(err, 0);
}

void NodeTraceWriter::WriteSuffix() {
  // If our final log file has traces, then end the file appropriately.
  // This means that if no trace events are recorded, then no trace file is
  // produced.
  bool should_flush = false;
  {
    Mutex::ScopedLock scoped_lock(stream_mutex_);
    if (total_traces_ > 0) {
      total_traces_ = kTracesPerFile;  // Act as if we reached the file limit.
      should_flush = true;
    }
  }
  if (should_flush) {
    Flush(true);
  }
}

NodeTraceWriter::~NodeTraceWriter() {
  WriteSuffix();
  uv_fs_t req;
  if (fd_ != -1) {
    CHECK_EQ(0, uv_fs_close(nullptr, &req, fd_, nullptr));
    uv_fs_req_cleanup(&req);
  }
  uv_async_send(&exit_signal_);
  Mutex::ScopedLock scoped_lock(request_mutex_);
  while (!exited_) {
    exit_cond_.Wait(scoped_lock);
  }
}

void replace_substring(std::string* target,
                       const std::string& search,
                       const std::string& insert) {
  size_t pos = target->find(search);
  for (; pos != std::string::npos; pos = target->find(search, pos)) {
    target->replace(pos, search.size(), insert);
    pos += insert.size();
  }
}

void NodeTraceWriter::OpenNewFileForStreaming() {
  ++file_num_;
  uv_fs_t req;

  // Evaluate a JS-style template string, it accepts the values ${pid} and
  // ${rotation}
  std::string filepath(log_file_pattern_);
  replace_substring(&filepath, "${pid}", std::to_string(uv_os_getpid()));
  replace_substring(&filepath, "${rotation}", std::to_string(file_num_));

  if (fd_ != -1) {
    CHECK_EQ(uv_fs_close(nullptr, &req, fd_, nullptr), 0);
    uv_fs_req_cleanup(&req);
  }

  fd_ = uv_fs_open(nullptr, &req, filepath.c_str(),
      O_CREAT | O_WRONLY | O_TRUNC, 0644, nullptr);
  uv_fs_req_cleanup(&req);
  if (fd_ < 0) {
    fprintf(stderr, "Could not open trace file %s: %s\n",
                    filepath.c_str(),
                    uv_strerror(fd_));
    fd_ = -1;
  }
}

void NodeTraceWriter::AppendTraceEvent(TraceObject* trace_event) {
  Mutex::ScopedLock scoped_lock(stream_mutex_);
  // If this is the first trace event, open a new file for streaming.
  if (total_traces_ == 0) {
    OpenNewFileForStreaming();
    // Constructing a new JSONTraceWriter object appends "{\"traceEvents\":["
    // to stream_.
    // In other words, the constructor initializes the serialization stream
    // to a state where we can start writing trace events to it.
    // Repeatedly constructing and destroying json_trace_writer_ allows
    // us to use V8's JSON writer instead of implementing our own.
    json_trace_writer_.reset(TraceWriter::CreateJSONTraceWriter(stream_));
  }
  ++total_traces_;
  json_trace_writer_->AppendTraceEvent(trace_event);
}

void NodeTraceWriter::FlushPrivate() {
  std::string str;
  int highest_request_id;
  {
    Mutex::ScopedLock stream_scoped_lock(stream_mutex_);
    if (total_traces_ >= kTracesPerFile) {
      total_traces_ = 0;
      // Destroying the member JSONTraceWriter object appends "]}" to
      // stream_ - in other words, ending a JSON file.
      json_trace_writer_.reset();
    }
    // str() makes a copy of the contents of the stream.
    str = stream_.str();
    stream_.str("");
    stream_.clear();
  }
  {
    Mutex::ScopedLock request_scoped_lock(request_mutex_);
    highest_request_id = num_write_requests_;
  }
  WriteToFile(std::move(str), highest_request_id);
}

void NodeTraceWriter::Flush(bool blocking) {
  Mutex::ScopedLock scoped_lock(request_mutex_);
  {
    // We need to lock the mutexes here in a nested fashion; stream_mutex_
    // protects json_trace_writer_, and without request_mutex_ there might be
    // a time window in which the stream state changes?
    Mutex::ScopedLock stream_mutex_lock(stream_mutex_);
    if (!json_trace_writer_)
      return;
  }
  int request_id = ++num_write_requests_;
  int err = uv_async_send(&flush_signal_);
  CHECK_EQ(err, 0);
  if (blocking) {
    // Wait until data associated with this request id has been written to disk.
    // This guarantees that data from all earlier requests have also been
    // written.
    while (request_id > highest_request_id_completed_) {
      request_cond_.Wait(scoped_lock);
    }
  }
}

void NodeTraceWriter::WriteToFile(std::string&& str, int highest_request_id) {
  if (fd_ == -1) return;

  uv_buf_t buf = uv_buf_init(nullptr, 0);
  {
    Mutex::ScopedLock lock(request_mutex_);
    write_req_queue_.emplace(WriteRequest {
      std::move(str), highest_request_id
    });
    if (write_req_queue_.size() == 1) {
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }
  }
  // Only one write request for the same file descriptor should be active at
  // a time.
  if (buf.base != nullptr && fd_ != -1) {
    StartWrite(buf);
  }
}

void NodeTraceWriter::StartWrite(uv_buf_t buf) {
  int err = uv_fs_write(
      tracing_loop_, &write_req_, fd_, &buf, 1, -1,
      [](uv_fs_t* req) {
        NodeTraceWriter* writer =
            ContainerOf(&NodeTraceWriter::write_req_, req);
        writer->AfterWrite();
      });
  CHECK_EQ(err, 0);
}

void NodeTraceWriter::AfterWrite() {
  CHECK_GE(write_req_.result, 0);
  uv_fs_req_cleanup(&write_req_);

  uv_buf_t buf = uv_buf_init(nullptr, 0);
  {
    Mutex::ScopedLock scoped_lock(request_mutex_);
    int highest_request_id = write_req_queue_.front().highest_request_id;
    write_req_queue_.pop();
    highest_request_id_completed_ = highest_request_id;
    request_cond_.Broadcast(scoped_lock);
    if (!write_req_queue_.empty()) {
      buf = uv_buf_init(
          const_cast<char*>(write_req_queue_.front().str.c_str()),
          write_req_queue_.front().str.length());
    }
  }
  if (buf.base != nullptr && fd_ != -1) {
    StartWrite(buf);
  }
}

// static
void NodeTraceWriter::ExitSignalCb(uv_async_t* signal) {
  NodeTraceWriter* trace_writer =
      ContainerOf(&NodeTraceWriter::exit_signal_, signal);
  // Close both flush_signal_ and exit_signal_.
  uv_close(reinterpret_cast<uv_handle_t*>(&trace_writer->flush_signal_),
           [](uv_handle_t* signal) {
             NodeTraceWriter* trace_writer =
                 ContainerOf(&NodeTraceWriter::flush_signal_,
                             reinterpret_cast<uv_async_t*>(signal));
             uv_close(
                 reinterpret_cast<uv_handle_t*>(&trace_writer->exit_signal_),
                 [](uv_handle_t* signal) {
                   NodeTraceWriter* trace_writer =
                       ContainerOf(&NodeTraceWriter::exit_signal_,
                                   reinterpret_cast<uv_async_t*>(signal));
                   Mutex::ScopedLock scoped_lock(trace_writer->request_mutex_);
                   trace_writer->exited_ = true;
                   trace_writer->exit_cond_.Signal(scoped_lock);
                 });
           });
}
}  // namespace tracing
}  // namespace node
  node-23.7.0/src/tracing/node_trace_writer.h                                                         0000664 0000000 0000000 00000004342 14746647661 0020646 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #ifndef SRC_TRACING_NODE_TRACE_WRITER_H_
#define SRC_TRACING_NODE_TRACE_WRITER_H_

#include <sstream>
#include <queue>

#include "libplatform/v8-tracing.h"
#include "tracing/agent.h"
#include "uv.h"

namespace node {
namespace tracing {

using v8::platform::tracing::TraceObject;
using v8::platform::tracing::TraceWriter;

class NodeTraceWriter : public AsyncTraceWriter {
 public:
  explicit NodeTraceWriter(const std::string& log_file_pattern);
  ~NodeTraceWriter() override;

  void InitializeOnThread(uv_loop_t* loop) override;
  void AppendTraceEvent(TraceObject* trace_event) override;
  void Flush(bool blocking) override;

  static const int kTracesPerFile = 1 << 19;

 private:
  struct WriteRequest {
    std::string str;
    int highest_request_id;
  };

  void AfterWrite();
  void StartWrite(uv_buf_t buf);
  void OpenNewFileForStreaming();
  void WriteToFile(std::string&& str, int highest_request_id);
  void WriteSuffix();
  void FlushPrivate();
  static void ExitSignalCb(uv_async_t* signal);

  uv_loop_t* tracing_loop_ = nullptr;
  // Triggers callback to initiate writing the contents of stream_ to disk.
  uv_async_t flush_signal_;
  // Triggers callback to close async objects, ending the tracing thread.
  uv_async_t exit_signal_;
  // Prevents concurrent R/W on state related to serialized trace data
  // before it's written to disk, namely stream_ and total_traces_
  // as well as json_trace_writer_.
  Mutex stream_mutex_;
  // Prevents concurrent R/W on state related to write requests.
  // If both mutexes are locked, request_mutex_ has to be locked first.
  Mutex request_mutex_;
  // Allows blocking calls to Flush() to wait on a condition for
  // trace events to be written to disk.
  ConditionVariable request_cond_;
  // Used to wait until async handles have been closed.
  ConditionVariable exit_cond_;
  int fd_ = -1;
  uv_fs_t write_req_;
  std::queue<WriteRequest> write_req_queue_;
  int num_write_requests_ = 0;
  int highest_request_id_completed_ = 0;
  int total_traces_ = 0;
  int file_num_ = 0;
  std::string log_file_pattern_;
  std::ostringstream stream_;
  std::unique_ptr<TraceWriter> json_trace_writer_;
  bool exited_ = false;
};

}  // namespace tracing
}  // namespace node

#endif  // SRC_TRACING_NODE_TRACE_WRITER_H_
                                                                                                                                                                                                                                                                                              node-23.7.0/src/tracing/trace_event.cc                                                              0000664 0000000 0000000 00000001625 14746647661 0017605 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "tracing/trace_event.h"
#include "node.h"

namespace node {
namespace tracing {

Agent* g_agent = nullptr;
v8::TracingController* g_controller = nullptr;

void TraceEventHelper::SetAgent(Agent* agent) {
  if (agent) {
    g_agent = agent;
    g_controller = agent->GetTracingController();
  } else {
    g_agent = nullptr;
    g_controller = nullptr;
  }
}

Agent* TraceEventHelper::GetAgent() {
  return g_agent;
}

v8::TracingController* TraceEventHelper::GetTracingController() {
  return g_controller;
}

void TraceEventHelper::SetTracingController(v8::TracingController* controller) {
  g_controller = controller;
}

}  // namespace tracing

v8::TracingController* GetTracingController() {
  return tracing::TraceEventHelper::GetTracingController();
}

void SetTracingController(v8::TracingController* controller) {
  tracing::TraceEventHelper::SetTracingController(controller);
}

}  // namespace node
                                                                                                           node-23.7.0/src/tracing/trace_event.h                                                               0000664 0000000 0000000 00000103167 14746647661 0017453 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SRC_TRACING_TRACE_EVENT_H_
#define SRC_TRACING_TRACE_EVENT_H_

#include "v8-platform.h"
#include "tracing/agent.h"
#include "trace_event_common.h"
#include <atomic>

// This header file defines implementation details of how the trace macros in
// trace_event_common.h collect and store trace events. Anything not
// implementation-specific should go in trace_macros_common.h instead of here.


// The pointer returned from GetCategoryGroupEnabled() points to a
// value with zero or more of the following bits. Used in this class only.
// The TRACE_EVENT macros should only use the value as a bool.
// These values must be in sync with macro values in trace_log.h in
// chromium.
enum CategoryGroupEnabledFlags {
  // Category group enabled for the recording mode.
  kEnabledForRecording_CategoryGroupEnabledFlags = 1 << 0,
  // Category group enabled by SetEventCallbackEnabled().
  kEnabledForEventCallback_CategoryGroupEnabledFlags = 1 << 2,
  // Category group enabled to export events to ETW.
  kEnabledForETWExport_CategoryGroupEnabledFlags = 1 << 3,
};

// By default, const char* argument values are assumed to have long-lived scope
// and will not be copied. Use this macro to force a const char* to be copied.
#define TRACE_STR_COPY(str) node::tracing::TraceStringWithCopy(str)

// By default, uint64 ID argument values are not mangled with the Process ID in
// TRACE_EVENT_ASYNC macros. Use this macro to force Process ID mangling.
#define TRACE_ID_MANGLE(id) node::tracing::TraceID::ForceMangle(id)

// By default, pointers are mangled with the Process ID in TRACE_EVENT_ASYNC
// macros. Use this macro to prevent Process ID mangling.
#define TRACE_ID_DONT_MANGLE(id) node::tracing::TraceID::DontMangle(id)

// By default, trace IDs are eventually converted to a single 64-bit number. Use
// this macro to add a scope string.
#define TRACE_ID_WITH_SCOPE(scope, id) \
  trace_event_internal::TraceID::WithScope(scope, id)

#define INTERNAL_TRACE_EVENT_CATEGORY_GROUP_ENABLED_FOR_RECORDING_MODE() \
  *INTERNAL_TRACE_EVENT_UID(category_group_enabled) &                    \
      (kEnabledForRecording_CategoryGroupEnabledFlags |                  \
       kEnabledForEventCallback_CategoryGroupEnabledFlags)

// The following macro has no implementation, but it needs to exist since
// it gets called from scoped trace events. It cannot call UNIMPLEMENTED()
// since an empty implementation is a valid one.
#define INTERNAL_TRACE_MEMORY(category, name)

////////////////////////////////////////////////////////////////////////////////
// Implementation specific tracing API definitions.

// Get a pointer to the enabled state of the given trace category. Only
// long-lived literal strings should be given as the category group. The
// returned pointer can be held permanently in a local static for example. If
// the unsigned char is non-zero, tracing is enabled. If tracing is enabled,
// TRACE_EVENT_API_ADD_TRACE_EVENT can be called. It's OK if tracing is disabled
// between the load of the tracing state and the call to
// TRACE_EVENT_API_ADD_TRACE_EVENT, because this flag only provides an early out
// for best performance when tracing is disabled.
// const uint8_t*
//     TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(const char* category_group)
#define TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED              \
  node::tracing::TraceEventHelper::GetCategoryGroupEnabled

// Get the number of times traces have been recorded. This is used to implement
// the TRACE_EVENT_IS_NEW_TRACE facility.
// unsigned int TRACE_EVENT_API_GET_NUM_TRACES_RECORDED()
#define TRACE_EVENT_API_GET_NUM_TRACES_RECORDED UNIMPLEMENTED()

// Add a trace event to the platform tracing system.
// uint64_t TRACE_EVENT_API_ADD_TRACE_EVENT(
//                    char phase,
//                    const uint8_t* category_group_enabled,
//                    const char* name,
//                    const char* scope,
//                    uint64_t id,
//                    uint64_t bind_id,
//                    int num_args,
//                    const char** arg_names,
//                    const uint8_t* arg_types,
//                    const uint64_t* arg_values,
//                    unsigned int flags)
#define TRACE_EVENT_API_ADD_TRACE_EVENT node::tracing::AddTraceEventImpl

// Add a trace event to the platform tracing system.
// uint64_t TRACE_EVENT_API_ADD_TRACE_EVENT_WITH_TIMESTAMP(
//                    char phase,
//                    const uint8_t* category_group_enabled,
//                    const char* name,
//                    const char* scope,
//                    uint64_t id,
//                    uint64_t bind_id,
//                    int num_args,
//                    const char** arg_names,
//                    const uint8_t* arg_types,
//                    const uint64_t* arg_values,
//                    unsigned int flags,
//                    int64_t timestamp)
#define TRACE_EVENT_API_ADD_TRACE_EVENT_WITH_TIMESTAMP \
  node::tracing::AddTraceEventWithTimestampImpl

// Set the duration field of a COMPLETE trace event.
// void TRACE_EVENT_API_UPDATE_TRACE_EVENT_DURATION(
//     const uint8_t* category_group_enabled,
//     const char* name,
//     uint64_t id)
#define TRACE_EVENT_API_UPDATE_TRACE_EVENT_DURATION                           \
  if (auto controller =                                                       \
         node::tracing::TraceEventHelper::GetTracingController())             \
      controller->UpdateTraceEventDuration

// Adds a metadata event to the trace log. The |AppendValueAsTraceFormat| method
// on the convertable value will be called at flush time.
// TRACE_EVENT_API_ADD_METADATA_EVENT(
//     const unsigned char* category_group_enabled,
//     const char* event_name,
//     const char* arg_name,
//     std::unique_ptr<ConvertableToTraceFormat> arg_value)
#define TRACE_EVENT_API_ADD_METADATA_EVENT node::tracing::AddMetadataEvent

// Defines atomic operations used internally by the tracing system.
#define TRACE_EVENT_API_ATOMIC_WORD std::atomic<intptr_t>
#define TRACE_EVENT_API_ATOMIC_WORD_VALUE intptr_t
#define TRACE_EVENT_API_ATOMIC_LOAD(var) (var).load()
#define TRACE_EVENT_API_ATOMIC_STORE(var, value) (var).store(value)

////////////////////////////////////////////////////////////////////////////////

// Implementation detail: trace event macros create temporary variables
// to keep instrumentation overhead low. These macros give each temporary
// variable a unique name based on the line number to prevent name collisions.
#define INTERNAL_TRACE_EVENT_UID3(a, b) trace_event_unique_##a##b
#define INTERNAL_TRACE_EVENT_UID2(a, b) INTERNAL_TRACE_EVENT_UID3(a, b)
#define INTERNAL_TRACE_EVENT_UID(name_prefix) \
  INTERNAL_TRACE_EVENT_UID2(name_prefix, __LINE__)

// Implementation detail: internal macro to create static category.
// No barriers are needed, because this code is designed to operate safely
// even when the unsigned char* points to garbage data (which may be the case
// on processors without cache coherency).
// TODO(fmeawad): This implementation contradicts that we can have a different
// configuration for each isolate,
// https://code.google.com/p/v8/issues/detail?id=4563
#define INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO_CUSTOM_VARIABLES(             \
    category_group, atomic, category_group_enabled)                          \
  category_group_enabled =                                                   \
      reinterpret_cast<const uint8_t*>(TRACE_EVENT_API_ATOMIC_LOAD(atomic)); \
  if (!category_group_enabled) {                                             \
    category_group_enabled =                                                 \
        TRACE_EVENT_API_GET_CATEGORY_GROUP_ENABLED(category_group);          \
    TRACE_EVENT_API_ATOMIC_STORE(                                            \
        atomic, reinterpret_cast<TRACE_EVENT_API_ATOMIC_WORD_VALUE>(         \
                    category_group_enabled));                                \
  }

#define INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO(category_group)             \
  static TRACE_EVENT_API_ATOMIC_WORD INTERNAL_TRACE_EVENT_UID(atomic) {0}; \
  const uint8_t* INTERNAL_TRACE_EVENT_UID(category_group_enabled);         \
  INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO_CUSTOM_VARIABLES(                 \
      category_group, INTERNAL_TRACE_EVENT_UID(atomic),                    \
      INTERNAL_TRACE_EVENT_UID(category_group_enabled));

// Implementation detail: internal macro to create static category and add
// event if the category is enabled.
#define INTERNAL_TRACE_EVENT_ADD(phase, category_group, name, flags, ...)    \
  do {                                                                       \
    INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO(category_group);                  \
    if (INTERNAL_TRACE_EVENT_CATEGORY_GROUP_ENABLED_FOR_RECORDING_MODE()) {  \
      node::tracing::AddTraceEvent(                                          \
          phase, INTERNAL_TRACE_EVENT_UID(category_group_enabled), name,     \
          node::tracing::kGlobalScope, node::tracing::kNoId,                 \
          node::tracing::kNoId, flags, ##__VA_ARGS__);                       \
    }                                                                        \
  } while (0)

// Implementation detail: internal macro to create static category and add begin
// event if the category is enabled. Also adds the end event when the scope
// ends.
#define INTERNAL_TRACE_EVENT_ADD_SCOPED(category_group, name, ...)           \
  INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO(category_group);                    \
  node::tracing::ScopedTracer INTERNAL_TRACE_EVENT_UID(tracer);              \
  if (INTERNAL_TRACE_EVENT_CATEGORY_GROUP_ENABLED_FOR_RECORDING_MODE()) {    \
    uint64_t h = node::tracing::AddTraceEvent(                               \
        TRACE_EVENT_PHASE_COMPLETE,                                          \
        INTERNAL_TRACE_EVENT_UID(category_group_enabled), name,              \
        node::tracing::kGlobalScope, node::tracing::kNoId,                   \
        node::tracing::kNoId, TRACE_EVENT_FLAG_NONE, ##__VA_ARGS__);         \
    INTERNAL_TRACE_EVENT_UID(tracer)                                         \
        .Initialize(INTERNAL_TRACE_EVENT_UID(category_group_enabled), name,  \
                    h);                                                      \
  }

#define INTERNAL_TRACE_EVENT_ADD_SCOPED_WITH_FLOW(category_group, name,     \
                                                  bind_id, flow_flags, ...) \
  INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO(category_group);                   \
  node::tracing::ScopedTracer INTERNAL_TRACE_EVENT_UID(tracer);             \
  if (INTERNAL_TRACE_EVENT_CATEGORY_GROUP_ENABLED_FOR_RECORDING_MODE()) {   \
    unsigned int trace_event_flags = flow_flags;                            \
    node::tracing::TraceID trace_event_bind_id(bind_id,                     \
                                               &trace_event_flags);         \
    uint64_t h = node::tracing::AddTraceEvent(                              \
        TRACE_EVENT_PHASE_COMPLETE,                                         \
        INTERNAL_TRACE_EVENT_UID(category_group_enabled), name,             \
        node::tracing::kGlobalScope, node::tracing::kNoId,                  \
        trace_event_bind_id.raw_id(), trace_event_flags, ##__VA_ARGS__);    \
    INTERNAL_TRACE_EVENT_UID(tracer)                                        \
        .Initialize(INTERNAL_TRACE_EVENT_UID(category_group_enabled), name, \
                    h);                                                     \
  }

// Implementation detail: internal macro to create static category and add
// event if the category is enabled.
#define INTERNAL_TRACE_EVENT_ADD_WITH_ID(phase, category_group, name, id,      \
                                         flags, ...)                           \
  do {                                                                         \
    INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO(category_group);                    \
    if (INTERNAL_TRACE_EVENT_CATEGORY_GROUP_ENABLED_FOR_RECORDING_MODE()) {    \
      unsigned int trace_event_flags = flags | TRACE_EVENT_FLAG_HAS_ID;        \
      node::tracing::TraceID trace_event_trace_id(id,                          \
                                                  &trace_event_flags);         \
      node::tracing::AddTraceEvent(                                            \
          phase, INTERNAL_TRACE_EVENT_UID(category_group_enabled), name,       \
          trace_event_trace_id.scope(), trace_event_trace_id.raw_id(),         \
          node::tracing::kNoId, trace_event_flags, ##__VA_ARGS__);             \
    }                                                                          \
  } while (0)

// Adds a trace event with a given timestamp.
#define INTERNAL_TRACE_EVENT_ADD_WITH_TIMESTAMP(phase, category_group, name, \
                                                timestamp, flags, ...)       \
  do {                                                                       \
    INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO(category_group);                  \
    if (INTERNAL_TRACE_EVENT_CATEGORY_GROUP_ENABLED_FOR_RECORDING_MODE()) {  \
      node::tracing::AddTraceEventWithTimestamp(                     \
          phase, INTERNAL_TRACE_EVENT_UID(category_group_enabled), name,     \
          node::tracing::kGlobalScope, node::tracing::kNoId, \
          node::tracing::kNoId, flags, timestamp, ##__VA_ARGS__);    \
    }                                                                        \
  } while (0)

// Adds a trace event with a given id and timestamp. Not Implemented.
#define INTERNAL_TRACE_EVENT_ADD_WITH_ID_AND_TIMESTAMP(     \
    phase, category_group, name, id, timestamp, flags, ...) \
  UNIMPLEMENTED()

// Adds a trace event with a given id, thread_id, and timestamp. Not
// Implemented.
#define INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                  \
    phase, category_group, name, id, thread_id, timestamp, flags, ...)       \
  do {                                                                       \
    INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO(category_group);                  \
    if (INTERNAL_TRACE_EVENT_CATEGORY_GROUP_ENABLED_FOR_RECORDING_MODE()) {  \
      unsigned int trace_event_flags = flags | TRACE_EVENT_FLAG_HAS_ID;      \
      node::tracing::TraceID trace_event_trace_id(id,                        \
                                                  &trace_event_flags);       \
      node::tracing::AddTraceEventWithTimestamp(                             \
          phase, INTERNAL_TRACE_EVENT_UID(category_group_enabled), name,     \
          trace_event_trace_id.scope(), trace_event_trace_id.raw_id(),       \
          node::tracing::kNoId, trace_event_flags, timestamp, ##__VA_ARGS__);\
    }                                                                        \
  } while (0)

#define INTERNAL_TRACE_EVENT_METADATA_ADD(category_group, name, ...)  \
  do { \
    INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO(category_group); \
    if (INTERNAL_TRACE_EVENT_CATEGORY_GROUP_ENABLED_FOR_RECORDING_MODE()) { \
      TRACE_EVENT_API_ADD_METADATA_EVENT( \
          INTERNAL_TRACE_EVENT_UID(category_group_enabled), name, \
          ##__VA_ARGS__); \
    } \
  } while(0)

// Enter and leave a context based on the current scope.
#define INTERNAL_TRACE_EVENT_SCOPED_CONTEXT(category_group, name, context) \
  struct INTERNAL_TRACE_EVENT_UID(ScopedContext) {                         \
   public:                                                                 \
    INTERNAL_TRACE_EVENT_UID(ScopedContext)(uint64_t cid) : cid_(cid) {    \
      TRACE_EVENT_ENTER_CONTEXT(category_group, name, cid_);               \
    }                                                                      \
    ~INTERNAL_TRACE_EVENT_UID(ScopedContext)() {                           \
      TRACE_EVENT_LEAVE_CONTEXT(category_group, name, cid_);               \
    }                                                                      \
                                                                           \
   private:                                                                \
    /* Local class friendly DISALLOW_COPY_AND_ASSIGN */                    \
    INTERNAL_TRACE_EVENT_UID(ScopedContext)                                \
    (const INTERNAL_TRACE_EVENT_UID(ScopedContext)&) {}                    \
    void operator=(const INTERNAL_TRACE_EVENT_UID(ScopedContext)&) {}      \
    uint64_t cid_;                                                         \
  };                                                                       \
  INTERNAL_TRACE_EVENT_UID(ScopedContext)                                  \
  INTERNAL_TRACE_EVENT_UID(scoped_context)(context);

namespace node {
namespace tracing {

// Specify these values when the corresponding argument of AddTraceEvent is not
// used.
const int kZeroNumArgs = 0;
const decltype(nullptr) kGlobalScope = nullptr;
const uint64_t kNoId = 0;

class TraceEventHelper {
 public:
  static v8::TracingController* GetTracingController();
  static void SetTracingController(v8::TracingController* controller);

  static Agent* GetAgent();
  static void SetAgent(Agent* agent);

  static inline const uint8_t* GetCategoryGroupEnabled(const char* group) {
    v8::TracingController* controller = GetTracingController();
    static const uint8_t disabled = 0;
    if (controller == nullptr) [[unlikely]] {
      return &disabled;
    }
    return controller->GetCategoryGroupEnabled(group);
  }
};

// TraceID encapsulates an ID that can either be an integer or pointer. Pointers
// are by default mangled with the Process ID so that they are unlikely to
// collide when the same pointer is used on different processes.
class TraceID {
 public:
  class WithScope {
   public:
    WithScope(const char* scope, uint64_t raw_id)
        : scope_(scope), raw_id_(raw_id) {}
    uint64_t raw_id() const { return raw_id_; }
    const char* scope() const { return scope_; }

   private:
    const char* scope_ = nullptr;
    uint64_t raw_id_;
  };

  class DontMangle {
   public:
    explicit DontMangle(const void* raw_id)
        : raw_id_(static_cast<uint64_t>(reinterpret_cast<uintptr_t>(raw_id))) {}
    explicit DontMangle(uint64_t raw_id) : raw_id_(raw_id) {}
    explicit DontMangle(unsigned int raw_id) : raw_id_(raw_id) {}
    explicit DontMangle(uint16_t raw_id) : raw_id_(raw_id) {}
    explicit DontMangle(unsigned char raw_id) : raw_id_(raw_id) {}
    explicit DontMangle(int64_t raw_id)
        : raw_id_(static_cast<uint64_t>(raw_id)) {}
    explicit DontMangle(int raw_id) : raw_id_(static_cast<uint64_t>(raw_id)) {}
    explicit DontMangle(int16_t raw_id)
        : raw_id_(static_cast<uint64_t>(raw_id)) {}
    explicit DontMangle(signed char raw_id)
        : raw_id_(static_cast<uint64_t>(raw_id)) {}
    explicit DontMangle(WithScope scoped_id)
        : scope_(scoped_id.scope()), raw_id_(scoped_id.raw_id()) {}
    const char* scope() const { return scope_; }
    uint64_t raw_id() const { return raw_id_; }

   private:
    const char* scope_ = nullptr;
    uint64_t raw_id_;
  };

  class ForceMangle {
   public:
    explicit ForceMangle(uint64_t raw_id) : raw_id_(raw_id) {}
    explicit ForceMangle(unsigned int raw_id) : raw_id_(raw_id) {}
    explicit ForceMangle(uint16_t raw_id) : raw_id_(raw_id) {}
    explicit ForceMangle(unsigned char raw_id) : raw_id_(raw_id) {}
    explicit ForceMangle(int64_t raw_id)
        : raw_id_(static_cast<uint64_t>(raw_id)) {}
    explicit ForceMangle(int raw_id) : raw_id_(static_cast<uint64_t>(raw_id)) {}
    explicit ForceMangle(int16_t raw_id)
        : raw_id_(static_cast<uint64_t>(raw_id)) {}
    explicit ForceMangle(signed char raw_id)
        : raw_id_(static_cast<uint64_t>(raw_id)) {}
    uint64_t raw_id() const { return raw_id_; }

   private:
    uint64_t raw_id_;
  };

  TraceID(const void* raw_id, unsigned int* flags)
      : raw_id_(static_cast<uint64_t>(reinterpret_cast<uintptr_t>(raw_id))) {
    *flags |= TRACE_EVENT_FLAG_MANGLE_ID;
  }
  TraceID(ForceMangle raw_id, unsigned int* flags) : raw_id_(raw_id.raw_id()) {
    *flags |= TRACE_EVENT_FLAG_MANGLE_ID;
  }
  TraceID(DontMangle maybe_scoped_id, unsigned int* flags)
      : scope_(maybe_scoped_id.scope()), raw_id_(maybe_scoped_id.raw_id()) {}
  TraceID(uint64_t raw_id, unsigned int* flags) : raw_id_(raw_id) {
    (void)flags;
  }
  TraceID(unsigned int raw_id, unsigned int* flags) : raw_id_(raw_id) {
    (void)flags;
  }
  TraceID(uint16_t raw_id, unsigned int* flags) : raw_id_(raw_id) {
    (void)flags;
  }
  TraceID(unsigned char raw_id, unsigned int* flags) : raw_id_(raw_id) {
    (void)flags;
  }
  TraceID(int64_t raw_id, unsigned int* flags)
      : raw_id_(static_cast<uint64_t>(raw_id)) {
    (void)flags;
  }
  TraceID(int raw_id, unsigned int* flags)
      : raw_id_(static_cast<uint64_t>(raw_id)) {
    (void)flags;
  }
  TraceID(int16_t raw_id, unsigned int* flags)
      : raw_id_(static_cast<uint64_t>(raw_id)) {
    (void)flags;
  }
  TraceID(signed char raw_id, unsigned int* flags)
      : raw_id_(static_cast<uint64_t>(raw_id)) {
    (void)flags;
  }
  TraceID(WithScope scoped_id, unsigned int* flags)
      : scope_(scoped_id.scope()), raw_id_(scoped_id.raw_id()) {}

  uint64_t raw_id() const { return raw_id_; }
  const char* scope() const { return scope_; }

 private:
  const char* scope_ = nullptr;
  uint64_t raw_id_;
};

// Simple union to store various types as uint64_t.
union TraceValueUnion {
  bool as_bool;
  uint64_t as_uint;
  int64_t as_int;
  double as_double;
  const void* as_pointer;
  const char* as_string;
};

// Simple container for const char* that should be copied instead of retained.
class TraceStringWithCopy {
 public:
  explicit TraceStringWithCopy(const char* str) : str_(str) {}
  operator const char*() const { return str_; }

 private:
  const char* str_;
};

static inline uint64_t AddTraceEventImpl(
    char phase, const uint8_t* category_group_enabled, const char* name,
    const char* scope, uint64_t id, uint64_t bind_id, int32_t num_args,
    const char** arg_names, const uint8_t* arg_types,
    const uint64_t* arg_values, unsigned int flags) {
  std::unique_ptr<v8::ConvertableToTraceFormat> arg_convertibles[2];
  if (num_args > 0 && arg_types[0] == TRACE_VALUE_TYPE_CONVERTABLE) {
    arg_convertibles[0].reset(reinterpret_cast<v8::ConvertableToTraceFormat*>(
        static_cast<intptr_t>(arg_values[0])));
  }
  if (num_args > 1 && arg_types[1] == TRACE_VALUE_TYPE_CONVERTABLE) {
    arg_convertibles[1].reset(reinterpret_cast<v8::ConvertableToTraceFormat*>(
        static_cast<intptr_t>(arg_values[1])));
  }
  // DCHECK(num_args, 2);
  v8::TracingController* controller =
      node::tracing::TraceEventHelper::GetTracingController();
  if (controller == nullptr) return 0;
  return controller->AddTraceEvent(phase, category_group_enabled, name, scope, id,
                                   bind_id, num_args, arg_names, arg_types,
                                   arg_values, arg_convertibles, flags);
}

static V8_INLINE uint64_t AddTraceEventWithTimestampImpl(
    char phase, const uint8_t* category_group_enabled, const char* name,
    const char* scope, uint64_t id, uint64_t bind_id, int32_t num_args,
    const char** arg_names, const uint8_t* arg_types,
    const uint64_t* arg_values, unsigned int flags, int64_t timestamp) {
  std::unique_ptr<v8::ConvertableToTraceFormat> arg_convertibles[2];
  if (num_args > 0 && arg_types[0] == TRACE_VALUE_TYPE_CONVERTABLE) {
    arg_convertibles[0].reset(reinterpret_cast<v8::ConvertableToTraceFormat*>(
        static_cast<intptr_t>(arg_values[0])));
  }
  if (num_args > 1 && arg_types[1] == TRACE_VALUE_TYPE_CONVERTABLE) {
    arg_convertibles[1].reset(reinterpret_cast<v8::ConvertableToTraceFormat*>(
        static_cast<intptr_t>(arg_values[1])));
  }
  // DCHECK_LE(num_args, 2);
  v8::TracingController* controller =
      node::tracing::TraceEventHelper::GetTracingController();
  if (controller == nullptr) return 0;
  return controller->AddTraceEventWithTimestamp(
      phase, category_group_enabled, name, scope, id, bind_id, num_args,
      arg_names, arg_types, arg_values, arg_convertibles, flags, timestamp);
}

static V8_INLINE void AddMetadataEventImpl(
    const uint8_t* category_group_enabled, const char* name, int32_t num_args,
    const char** arg_names, const uint8_t* arg_types,
    const uint64_t* arg_values, unsigned int flags) {
  std::unique_ptr<v8::ConvertableToTraceFormat> arg_convertibles[2];
  if (num_args > 0 && arg_types[0] == TRACE_VALUE_TYPE_CONVERTABLE) {
    arg_convertibles[0].reset(reinterpret_cast<v8::ConvertableToTraceFormat*>(
        static_cast<intptr_t>(arg_values[0])));
  }
  if (num_args > 1 && arg_types[1] == TRACE_VALUE_TYPE_CONVERTABLE) {
    arg_convertibles[1].reset(reinterpret_cast<v8::ConvertableToTraceFormat*>(
        static_cast<intptr_t>(arg_values[1])));
  }
  node::tracing::Agent* agent =
      node::tracing::TraceEventHelper::GetAgent();
  if (agent == nullptr) return;
  return agent->GetTracingController()->AddMetadataEvent(
      category_group_enabled, name, num_args, arg_names, arg_types, arg_values,
      arg_convertibles, flags);
}

// Define SetTraceValue for each allowed type. It stores the type and
// value in the return arguments. This allows this API to avoid declaring any
// structures so that it is portable to third_party libraries.
#define INTERNAL_DECLARE_SET_TRACE_VALUE(actual_type, union_member,         \
                                         value_type_id)                     \
  static inline void SetTraceValue(actual_type arg, unsigned char* type,    \
                                   uint64_t* value) {                       \
    TraceValueUnion type_value;                                             \
    type_value.union_member = arg;                                          \
    *type = value_type_id;                                                  \
    *value = type_value.as_uint;                                            \
  }
// Simpler form for int types that can be safely casted.
#define INTERNAL_DECLARE_SET_TRACE_VALUE_INT(actual_type, value_type_id)    \
  static inline void SetTraceValue(actual_type arg, unsigned char* type,    \
                                   uint64_t* value) {                       \
    *type = value_type_id;                                                  \
    *value = static_cast<uint64_t>(arg);                                    \
  }

INTERNAL_DECLARE_SET_TRACE_VALUE_INT(uint64_t, TRACE_VALUE_TYPE_UINT)
INTERNAL_DECLARE_SET_TRACE_VALUE_INT(unsigned int, TRACE_VALUE_TYPE_UINT)
INTERNAL_DECLARE_SET_TRACE_VALUE_INT(uint16_t, TRACE_VALUE_TYPE_UINT)
INTERNAL_DECLARE_SET_TRACE_VALUE_INT(unsigned char, TRACE_VALUE_TYPE_UINT)
INTERNAL_DECLARE_SET_TRACE_VALUE_INT(int64_t, TRACE_VALUE_TYPE_INT)
INTERNAL_DECLARE_SET_TRACE_VALUE_INT(int, TRACE_VALUE_TYPE_INT)
INTERNAL_DECLARE_SET_TRACE_VALUE_INT(int16_t, TRACE_VALUE_TYPE_INT)
INTERNAL_DECLARE_SET_TRACE_VALUE_INT(signed char, TRACE_VALUE_TYPE_INT)
INTERNAL_DECLARE_SET_TRACE_VALUE(bool, as_bool, TRACE_VALUE_TYPE_BOOL)
INTERNAL_DECLARE_SET_TRACE_VALUE(double, as_double, TRACE_VALUE_TYPE_DOUBLE)
INTERNAL_DECLARE_SET_TRACE_VALUE(const void*, as_pointer,
                                 TRACE_VALUE_TYPE_POINTER)
INTERNAL_DECLARE_SET_TRACE_VALUE(const char*, as_string,
                                 TRACE_VALUE_TYPE_STRING)
INTERNAL_DECLARE_SET_TRACE_VALUE(const TraceStringWithCopy&, as_string,
                                 TRACE_VALUE_TYPE_COPY_STRING)

#undef INTERNAL_DECLARE_SET_TRACE_VALUE
#undef INTERNAL_DECLARE_SET_TRACE_VALUE_INT

static inline void SetTraceValue(v8::ConvertableToTraceFormat* convertable_value,
                                    unsigned char* type, uint64_t* value) {
  *type = TRACE_VALUE_TYPE_CONVERTABLE;
  *value = static_cast<uint64_t>(reinterpret_cast<intptr_t>(convertable_value));
}

template <typename T>
static inline typename std::enable_if<
    std::is_convertible<T*, v8::ConvertableToTraceFormat*>::value>::type
SetTraceValue(std::unique_ptr<T> ptr, unsigned char* type, uint64_t* value) {
  SetTraceValue(ptr.release(), type, value);
}

// These AddTraceEvent template
// function is defined here instead of in the macro, because the arg_values
// could be temporary objects, such as std::string. In order to store
// pointers to the internal c_str and pass through to the tracing API,
// the arg_values must live throughout these procedures.

static inline uint64_t AddTraceEvent(char phase,
                                        const uint8_t* category_group_enabled,
                                        const char* name, const char* scope,
                                        uint64_t id, uint64_t bind_id,
                                        unsigned int flags) {
  return TRACE_EVENT_API_ADD_TRACE_EVENT(phase, category_group_enabled, name,
                                         scope, id, bind_id, kZeroNumArgs,
                                         nullptr, nullptr, nullptr, flags);
}

template <class ARG1_TYPE>
static inline uint64_t AddTraceEvent(
    char phase, const uint8_t* category_group_enabled, const char* name,
    const char* scope, uint64_t id, uint64_t bind_id, unsigned int flags,
    const char* arg1_name, ARG1_TYPE&& arg1_val) {
  const int num_args = 1;
  uint8_t arg_type;
  uint64_t arg_value;
  SetTraceValue(std::forward<ARG1_TYPE>(arg1_val), &arg_type, &arg_value);
  return TRACE_EVENT_API_ADD_TRACE_EVENT(
      phase, category_group_enabled, name, scope, id, bind_id, num_args,
      &arg1_name, &arg_type, &arg_value, flags);
}

template <class ARG1_TYPE, class ARG2_TYPE>
static inline uint64_t AddTraceEvent(
    char phase, const uint8_t* category_group_enabled, const char* name,
    const char* scope, uint64_t id, uint64_t bind_id, unsigned int flags,
    const char* arg1_name, ARG1_TYPE&& arg1_val, const char* arg2_name,
    ARG2_TYPE&& arg2_val) {
  const int num_args = 2;
  const char* arg_names[2] = {arg1_name, arg2_name};
  unsigned char arg_types[2];
  uint64_t arg_values[2];
  SetTraceValue(std::forward<ARG1_TYPE>(arg1_val), &arg_types[0],
                &arg_values[0]);
  SetTraceValue(std::forward<ARG2_TYPE>(arg2_val), &arg_types[1],
                &arg_values[1]);
  return TRACE_EVENT_API_ADD_TRACE_EVENT(
      phase, category_group_enabled, name, scope, id, bind_id, num_args,
      arg_names, arg_types, arg_values, flags);
}

static V8_INLINE uint64_t AddTraceEventWithTimestamp(
    char phase, const uint8_t* category_group_enabled, const char* name,
    const char* scope, uint64_t id, uint64_t bind_id, unsigned int flags,
    int64_t timestamp) {
  return TRACE_EVENT_API_ADD_TRACE_EVENT_WITH_TIMESTAMP(
      phase, category_group_enabled, name, scope, id, bind_id, kZeroNumArgs,
      nullptr, nullptr, nullptr, flags, timestamp);
}

template <class ARG1_TYPE>
static V8_INLINE uint64_t AddTraceEventWithTimestamp(
    char phase, const uint8_t* category_group_enabled, const char* name,
    const char* scope, uint64_t id, uint64_t bind_id, unsigned int flags,
    int64_t timestamp, const char* arg1_name, ARG1_TYPE&& arg1_val) {
  const int num_args = 1;
  uint8_t arg_type;
  uint64_t arg_value;
  SetTraceValue(std::forward<ARG1_TYPE>(arg1_val), &arg_type, &arg_value);
  return TRACE_EVENT_API_ADD_TRACE_EVENT_WITH_TIMESTAMP(
      phase, category_group_enabled, name, scope, id, bind_id, num_args,
      &arg1_name, &arg_type, &arg_value, flags, timestamp);
}

template <class ARG1_TYPE, class ARG2_TYPE>
static V8_INLINE uint64_t AddTraceEventWithTimestamp(
    char phase, const uint8_t* category_group_enabled, const char* name,
    const char* scope, uint64_t id, uint64_t bind_id, unsigned int flags,
    int64_t timestamp, const char* arg1_name, ARG1_TYPE&& arg1_val,
    const char* arg2_name, ARG2_TYPE&& arg2_val) {
  const int num_args = 2;
  const char* arg_names[2] = {arg1_name, arg2_name};
  unsigned char arg_types[2];
  uint64_t arg_values[2];
  SetTraceValue(std::forward<ARG1_TYPE>(arg1_val), &arg_types[0],
                &arg_values[0]);
  SetTraceValue(std::forward<ARG2_TYPE>(arg2_val), &arg_types[1],
                &arg_values[1]);
  return TRACE_EVENT_API_ADD_TRACE_EVENT_WITH_TIMESTAMP(
      phase, category_group_enabled, name, scope, id, bind_id, num_args,
      arg_names, arg_types, arg_values, flags, timestamp);
}

template <class ARG1_TYPE>
static V8_INLINE void AddMetadataEvent(
    const uint8_t* category_group_enabled, const char* name,
    const char* arg1_name, ARG1_TYPE&& arg1_val) {
  const int num_args = 1;
  uint8_t arg_type;
  uint64_t arg_value;
  SetTraceValue(std::forward<ARG1_TYPE>(arg1_val), &arg_type, &arg_value);
  AddMetadataEventImpl(
      category_group_enabled, name, num_args, &arg1_name, &arg_type, &arg_value,
      TRACE_EVENT_FLAG_NONE);
}

// Used by TRACE_EVENTx macros. Do not use directly.
class ScopedTracer {
 public:
  // Note: members of data_ intentionally left uninitialized. See Initialize.
  ScopedTracer() : p_data_(nullptr) {}

  ~ScopedTracer() {
    if (p_data_ && *data_.category_group_enabled)
      TRACE_EVENT_API_UPDATE_TRACE_EVENT_DURATION(
          data_.category_group_enabled, data_.name, data_.event_handle);
  }

  void Initialize(const uint8_t* category_group_enabled, const char* name,
                  uint64_t event_handle) {
    data_.category_group_enabled = category_group_enabled;
    data_.name = name;
    data_.event_handle = event_handle;
    p_data_ = &data_;
  }

 private:
  // This Data struct workaround is to avoid initializing all the members
  // in Data during construction of this object, since this object is always
  // constructed, even when tracing is disabled. If the members of Data were
  // members of this class instead, compiler warnings occur about potential
  // uninitialized accesses.
  struct Data {
    const uint8_t* category_group_enabled;
    const char* name;
    uint64_t event_handle;
  };
  Data* p_data_;
  Data data_;
};

}  // namespace tracing
}  // namespace node

#endif  // SRC_TRACING_TRACE_EVENT_H_
                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/src/tracing/trace_event_common.h                                                        0000664 0000000 0000000 00000204026 14746647661 0021017 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2015 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SRC_TRACE_EVENT_COMMON_H
#define SRC_TRACE_EVENT_COMMON_H

// This header file defines the set of trace_event macros without specifying
// how the events actually get collected and stored. If you need to expose trace
// events to some other universe, you can copy-and-paste this file as well as
// trace_event.h, modifying the macros contained there as necessary for the
// target platform. The end result is that multiple libraries can funnel events
// through to a shared trace event collector.

// IMPORTANT: To avoid conflicts, if you need to modify this file for a library,
// land your change in base/ first, and then copy-and-paste it.

// Trace events are for tracking application performance and resource usage.
// Macros are provided to track:
//    Begin and end of function calls
//    Counters
//
// Events are issued against categories. Whereas LOG's
// categories are statically defined, TRACE categories are created
// implicitly with a string. For example:
//   TRACE_EVENT_INSTANT0("MY_SUBSYSTEM", "SomeImportantEvent",
//                        TRACE_EVENT_SCOPE_THREAD)
//
// It is often the case that one trace may belong in multiple categories at the
// same time. The first argument to the trace can be a comma-separated list of
// categories, forming a category group, like:
//
// TRACE_EVENT_INSTANT0("input,views", "OnMouseOver", TRACE_EVENT_SCOPE_THREAD)
//
// We can enable/disable tracing of OnMouseOver by enabling/disabling either
// category.
//
// Events can be INSTANT, or can be pairs of BEGIN and END in the same scope:
//   TRACE_EVENT_BEGIN0("MY_SUBSYSTEM", "SomethingCostly")
//   doSomethingCostly()
//   TRACE_EVENT_END0("MY_SUBSYSTEM", "SomethingCostly")
// Note: our tools can't always determine the correct BEGIN/END pairs unless
// these are used in the same scope. Use ASYNC_BEGIN/ASYNC_END macros if you
// need them to be in separate scopes.
//
// A common use case is to trace entire function scopes. This
// issues a trace BEGIN and END automatically:
//   void doSomethingCostly() {
//     TRACE_EVENT0("MY_SUBSYSTEM", "doSomethingCostly");
//     ...
//   }
//
// Additional parameters can be associated with an event:
//   void doSomethingCostly2(int howMuch) {
//     TRACE_EVENT1("MY_SUBSYSTEM", "doSomethingCostly",
//         "howMuch", howMuch);
//     ...
//   }
//
// The trace system will automatically add to this information the
// current process id, thread id, and a timestamp in microseconds.
//
// To trace an asynchronous procedure such as an IPC send/receive, use
// ASYNC_BEGIN and ASYNC_END:
//   [single threaded sender code]
//     static int send_count = 0;
//     ++send_count;
//     TRACE_EVENT_ASYNC_BEGIN0("ipc", "message", send_count);
//     Send(new MyMessage(send_count));
//   [receive code]
//     void OnMyMessage(send_count) {
//       TRACE_EVENT_ASYNC_END0("ipc", "message", send_count);
//     }
// The third parameter is a unique ID to match ASYNC_BEGIN/ASYNC_END pairs.
// ASYNC_BEGIN and ASYNC_END can occur on any thread of any traced process.
// Pointers can be used for the ID parameter, and they will be mangled
// internally so that the same pointer on two different processes will not
// match. For example:
//   class MyTracedClass {
//    public:
//     MyTracedClass() {
//       TRACE_EVENT_ASYNC_BEGIN0("category", "MyTracedClass", this);
//     }
//     ~MyTracedClass() {
//       TRACE_EVENT_ASYNC_END0("category", "MyTracedClass", this);
//     }
//   }
//
// Trace event also supports counters, which is a way to track a quantity
// as it varies over time. Counters are created with the following macro:
//   TRACE_COUNTER1("MY_SUBSYSTEM", "myCounter", g_myCounterValue);
//
// Counters are process-specific. The macro itself can be issued from any
// thread, however.
//
// Sometimes, you want to track two counters at once. You can do this with two
// counter macros:
//   TRACE_COUNTER1("MY_SUBSYSTEM", "myCounter0", g_myCounterValue[0]);
//   TRACE_COUNTER1("MY_SUBSYSTEM", "myCounter1", g_myCounterValue[1]);
// Or you can do it with a combined macro:
//   TRACE_COUNTER2("MY_SUBSYSTEM", "myCounter",
//       "bytesPinned", g_myCounterValue[0],
//       "bytesAllocated", g_myCounterValue[1]);
// This indicates to the tracing UI that these counters should be displayed
// in a single graph, as a summed area chart.
//
// Since counters are in a global namespace, you may want to disambiguate with a
// unique ID, by using the TRACE_COUNTER_ID* variations.
//
// By default, trace collection is compiled in, but turned off at runtime.
// Collecting trace data is the responsibility of the embedding
// application. In Chrome's case, navigating to about:tracing will turn on
// tracing and display data collected across all active processes.
//
//
// Memory scoping note:
// Tracing copies the pointers, not the string content, of the strings passed
// in for category_group, name, and arg_names.  Thus, the following code will
// cause problems:
//     char* str = strdup("importantName");
//     TRACE_EVENT_INSTANT0("SUBSYSTEM", str);  // BAD!
//     free(str);                   // Trace system now has dangling pointer
//
// To avoid this issue with the |name| and |arg_name| parameters, use the
// TRACE_EVENT_COPY_XXX overloads of the macros at additional runtime overhead.
// Notes: The category must always be in a long-lived char* (i.e. static const).
//        The |arg_values|, when used, are always deep copied with the _COPY
//        macros.
//
// When are string argument values copied:
// const char* arg_values are only referenced by default:
//     TRACE_EVENT1("category", "name",
//                  "arg1", "literal string is only referenced");
// Use TRACE_STR_COPY to force copying of a const char*:
//     TRACE_EVENT1("category", "name",
//                  "arg1", TRACE_STR_COPY("string will be copied"));
// std::string arg_values are always copied:
//     TRACE_EVENT1("category", "name",
//                  "arg1", std::string("string will be copied"));
//
//
// Convertable notes:
// Converting a large data type to a string can be costly. To help with this,
// the trace framework provides an interface ConvertableToTraceFormat. If you
// inherit from it and implement the AppendAsTraceFormat method the trace
// framework will call back to your object to convert a trace output time. This
// means, if the category for the event is disabled, the conversion will not
// happen.
//
//   class MyData : public base::trace_event::ConvertableToTraceFormat {
//    public:
//     MyData() {}
//     void AppendAsTraceFormat(std::string* out) const override {
//       out->append("{\"foo\":1}");
//     }
//     MyData(const MyData&) = delete;
//     MyData& operator=(const MyData&) = delete;
//
//    private:
//     ~MyData() override {}
//   };
//
//   TRACE_EVENT1("foo", "bar", "data",
//                std::unique_ptr<ConvertableToTraceFormat>(new MyData()));
//
// The trace framework will take ownership if the passed pointer and it will
// be free'd when the trace buffer is flushed.
//
// Note, we only do the conversion when the buffer is flushed, so the provided
// data object should not be modified after it's passed to the trace framework.
//
//
// Thread Safety:
// A thread safe singleton and mutex are used for thread safety. Category
// enabled flags are used to limit the performance impact when the system
// is not enabled.
//
// TRACE_EVENT macros first cache a pointer to a category. The categories are
// statically allocated and safe at all times, even after exit. Fetching a
// category is protected by the TraceLog::lock_. Multiple threads initializing
// the static variable is safe, as they will be serialized by the lock and
// multiple calls will return the same pointer to the category.
//
// Then the category_group_enabled flag is checked. This is a unsigned char, and
// not intended to be multithread safe. It optimizes access to AddTraceEvent
// which is threadsafe internally via TraceLog::lock_. The enabled flag may
// cause some threads to incorrectly call or skip calling AddTraceEvent near
// the time of the system being enabled or disabled. This is acceptable as
// we tolerate some data loss while the system is being enabled/disabled and
// because AddTraceEvent is threadsafe internally and checks the enabled state
// again under lock.
//
// Without the use of these static category pointers and enabled flags all
// trace points would carry a significant performance cost of acquiring a lock
// and resolving the category.

// Check that nobody includes this file directly.  Clients are supposed to
// include the surrounding "trace_event.h" of their project instead.
#if defined(TRACE_EVENT0)
#error "Another copy of this file has already been included."
#endif

// This will mark the trace event as disabled by default. The user will need
// to explicitly enable the event.
#define TRACE_DISABLED_BY_DEFAULT(name) "disabled-by-default-" name

// Records a pair of begin and end events called "name" for the current
// scope, with 0, 1 or 2 associated arguments. If the category is not
// enabled, then this does nothing.
// - category and name strings must have application lifetime (statics or
//   literals). They may not include " chars.
#define TRACE_EVENT0(category_group, name)    \
  INTERNAL_TRACE_EVENT_ADD_SCOPED(category_group, name)
#define TRACE_EVENT_WITH_FLOW0(category_group, name, bind_id, flow_flags)  \
  INTERNAL_TRACE_EVENT_ADD_SCOPED_WITH_FLOW(category_group, name, bind_id, \
                                            flow_flags)
#define TRACE_EVENT1(category_group, name, arg1_name, arg1_val) \
  INTERNAL_TRACE_EVENT_ADD_SCOPED(category_group, name, arg1_name, arg1_val)
#define TRACE_EVENT_WITH_FLOW1(category_group, name, bind_id, flow_flags,  \
                               arg1_name, arg1_val)                        \
  INTERNAL_TRACE_EVENT_ADD_SCOPED_WITH_FLOW(category_group, name, bind_id, \
                                            flow_flags, arg1_name, arg1_val)
#define TRACE_EVENT2(category_group, name, arg1_name, arg1_val, arg2_name,   \
                     arg2_val)                                               \
  INTERNAL_TRACE_EVENT_ADD_SCOPED(category_group, name, arg1_name, arg1_val, \
                                  arg2_name, arg2_val)
#define TRACE_EVENT_WITH_FLOW2(category_group, name, bind_id, flow_flags,    \
                               arg1_name, arg1_val, arg2_name, arg2_val)     \
  INTERNAL_TRACE_EVENT_ADD_SCOPED_WITH_FLOW(category_group, name, bind_id,   \
                                            flow_flags, arg1_name, arg1_val, \
                                            arg2_name, arg2_val)

// Records a single event called "name" immediately, with 0, 1 or 2
// associated arguments. If the category is not enabled, then this
// does nothing.
// - category and name strings must have application lifetime (statics or
//   literals). They may not include " chars.
#define TRACE_EVENT_INSTANT0(category_group, name, scope)                   \
  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_INSTANT, category_group, name, \
                           TRACE_EVENT_FLAG_NONE | scope)
#define TRACE_EVENT_INSTANT1(category_group, name, scope, arg1_name, arg1_val) \
  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_INSTANT, category_group, name,    \
                           TRACE_EVENT_FLAG_NONE | scope, arg1_name, arg1_val)
#define TRACE_EVENT_INSTANT2(category_group, name, scope, arg1_name, arg1_val, \
                             arg2_name, arg2_val)                              \
  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_INSTANT, category_group, name,    \
                           TRACE_EVENT_FLAG_NONE | scope, arg1_name, arg1_val, \
                           arg2_name, arg2_val)
#define TRACE_EVENT_COPY_INSTANT0(category_group, name, scope)              \
  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_INSTANT, category_group, name, \
                           TRACE_EVENT_FLAG_COPY | scope)
#define TRACE_EVENT_COPY_INSTANT1(category_group, name, scope, arg1_name,   \
                                  arg1_val)                                 \
  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_INSTANT, category_group, name, \
                           TRACE_EVENT_FLAG_COPY | scope, arg1_name, arg1_val)
#define TRACE_EVENT_COPY_INSTANT2(category_group, name, scope, arg1_name,      \
                                  arg1_val, arg2_name, arg2_val)               \
  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_INSTANT, category_group, name,    \
                           TRACE_EVENT_FLAG_COPY | scope, arg1_name, arg1_val, \
                           arg2_name, arg2_val)

#define TRACE_EVENT_INSTANT_WITH_TIMESTAMP0(category_group, name, scope, \
                                            timestamp)                   \
  INTERNAL_TRACE_EVENT_ADD_WITH_TIMESTAMP(                               \
      TRACE_EVENT_PHASE_INSTANT, category_group, name, timestamp,        \
      TRACE_EVENT_FLAG_NONE | scope)

#define TRACE_EVENT_INSTANT_WITH_TIMESTAMP1(category_group, name, scope,  \
                                            timestamp, arg_name, arg_val) \
  INTERNAL_TRACE_EVENT_ADD_WITH_TIMESTAMP(                                \
      TRACE_EVENT_PHASE_INSTANT, category_group, name, timestamp,         \
      TRACE_EVENT_FLAG_NONE | scope, arg_name, arg_val)

// Records a single BEGIN event called "name" immediately, with 0, 1 or 2
// associated arguments. If the category is not enabled, then this
// does nothing.
// - category and name strings must have application lifetime (statics or
//   literals). They may not include " chars.
#define TRACE_EVENT_BEGIN(category_group, name, ...)                  \
  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_BEGIN, category_group, name, \
                           TRACE_EVENT_FLAG_NONE, ##__VA_ARGS__)
#define TRACE_EVENT_BEGIN0(category_group, name)                          \
  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_BEGIN, category_group, name, \
                           TRACE_EVENT_FLAG_NONE)
#define TRACE_EVENT_BEGIN1(category_group, name, arg1_name, arg1_val)     \
  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_BEGIN, category_group, name, \
                           TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val)
#define TRACE_EVENT_BEGIN2(category_group, name, arg1_name, arg1_val,     \
                           arg2_name, arg2_val)                           \
  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_BEGIN, category_group, name, \
                           TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val,    \
                           arg2_name, arg2_val)
#define TRACE_EVENT_COPY_BEGIN0(category_group, name)                     \
  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_BEGIN, category_group, name, \
                           TRACE_EVENT_FLAG_COPY)
#define TRACE_EVENT_COPY_BEGIN1(category_group, name, arg1_name, arg1_val) \
  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_BEGIN, category_group, name,  \
                           TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val)
#define TRACE_EVENT_COPY_BEGIN2(category_group, name, arg1_name, arg1_val, \
                                arg2_name, arg2_val)                       \
  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_BEGIN, category_group, name,  \
                           TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val,     \
                           arg2_name, arg2_val)

// Similar to TRACE_EVENT_BEGINx but with a custom |at| timestamp provided.
// - |id| is used to match the _BEGIN event with the _END event.
//   Events are considered to match if their category_group, name and id values
//   all match. |id| must either be a pointer or an integer value up to 64 bits.
//   If it's a pointer, the bits will be xored with a hash of the process ID so
//   that the same pointer on two different processes will not collide.
#define TRACE_EVENT_BEGIN_WITH_ID_TID_AND_TIMESTAMP0(category_group, name, id, \
                                                     thread_id, timestamp)     \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                          \
      TRACE_EVENT_PHASE_ASYNC_BEGIN, category_group, name, id, thread_id,      \
      timestamp, TRACE_EVENT_FLAG_NONE)
#define TRACE_EVENT_COPY_BEGIN_WITH_ID_TID_AND_TIMESTAMP0(                \
    category_group, name, id, thread_id, timestamp)                       \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                     \
      TRACE_EVENT_PHASE_ASYNC_BEGIN, category_group, name, id, thread_id, \
      timestamp, TRACE_EVENT_FLAG_COPY)
#define TRACE_EVENT_COPY_BEGIN_WITH_ID_TID_AND_TIMESTAMP1(                \
    category_group, name, id, thread_id, timestamp, arg1_name, arg1_val)  \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                     \
      TRACE_EVENT_PHASE_ASYNC_BEGIN, category_group, name, id, thread_id, \
      timestamp, TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val)
#define TRACE_EVENT_COPY_BEGIN_WITH_ID_TID_AND_TIMESTAMP2(                \
    category_group, name, id, thread_id, timestamp, arg1_name, arg1_val,  \
    arg2_name, arg2_val)                                                  \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                     \
      TRACE_EVENT_PHASE_ASYNC_BEGIN, category_group, name, id, thread_id, \
      timestamp, TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val, arg2_name,   \
      arg2_val)

// Records a single END event for "name" immediately. If the category
// is not enabled, then this does nothing.
// - category and name strings must have application lifetime (statics or
//   literals). They may not include " chars.
#define TRACE_EVENT_END(category_group, name, ...)                      \
  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_END, category_group, name, \
                           TRACE_EVENT_FLAG_NONE, ##__VA_ARGS__)
#define TRACE_EVENT_END0(category_group, name)                          \
  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_END, category_group, name, \
                           TRACE_EVENT_FLAG_NONE)
#define TRACE_EVENT_END1(category_group, name, arg1_name, arg1_val)     \
  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_END, category_group, name, \
                           TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val)
#define TRACE_EVENT_END2(category_group, name, arg1_name, arg1_val, arg2_name, \
                         arg2_val)                                             \
  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_END, category_group, name,        \
                           TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val,         \
                           arg2_name, arg2_val)
#define TRACE_EVENT_COPY_END0(category_group, name)                     \
  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_END, category_group, name, \
                           TRACE_EVENT_FLAG_COPY)
#define TRACE_EVENT_COPY_END1(category_group, name, arg1_name, arg1_val) \
  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_END, category_group, name,  \
                           TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val)
#define TRACE_EVENT_COPY_END2(category_group, name, arg1_name, arg1_val, \
                              arg2_name, arg2_val)                       \
  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_END, category_group, name,  \
                           TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val,   \
                           arg2_name, arg2_val)

#define TRACE_EVENT_MARK_WITH_TIMESTAMP0(category_group, name, timestamp) \
  INTERNAL_TRACE_EVENT_ADD_WITH_TIMESTAMP(                                \
      TRACE_EVENT_PHASE_MARK, category_group, name, timestamp,            \
      TRACE_EVENT_FLAG_NONE)

#define TRACE_EVENT_MARK_WITH_TIMESTAMP1(category_group, name, timestamp, \
                                         arg1_name, arg1_val)             \
  INTERNAL_TRACE_EVENT_ADD_WITH_TIMESTAMP(                                \
      TRACE_EVENT_PHASE_MARK, category_group, name, timestamp,            \
      TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val)

#define TRACE_EVENT_MARK_WITH_TIMESTAMP2(                                      \
    category_group, name, timestamp, arg1_name, arg1_val, arg2_name, arg2_val) \
  INTERNAL_TRACE_EVENT_ADD_WITH_TIMESTAMP(                                     \
      TRACE_EVENT_PHASE_MARK, category_group, name, timestamp,                 \
      TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val, arg2_name, arg2_val)

#define TRACE_EVENT_COPY_MARK(category_group, name)                      \
  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_MARK, category_group, name, \
                           TRACE_EVENT_FLAG_COPY)

#define TRACE_EVENT_COPY_MARK_WITH_TIMESTAMP(category_group, name, timestamp) \
  INTERNAL_TRACE_EVENT_ADD_WITH_TIMESTAMP(                                    \
      TRACE_EVENT_PHASE_MARK, category_group, name, timestamp,                \
      TRACE_EVENT_FLAG_COPY)

// Similar to TRACE_EVENT_ENDx but with a custom |at| timestamp provided.
// - |id| is used to match the _BEGIN event with the _END event.
//   Events are considered to match if their category_group, name and id values
//   all match. |id| must either be a pointer or an integer value up to 64 bits.
//   If it's a pointer, the bits will be xored with a hash of the process ID so
//   that the same pointer on two different processes will not collide.
#define TRACE_EVENT_END_WITH_ID_TID_AND_TIMESTAMP0(category_group, name, id, \
                                                   thread_id, timestamp)     \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                        \
      TRACE_EVENT_PHASE_ASYNC_END, category_group, name, id, thread_id,      \
      timestamp, TRACE_EVENT_FLAG_NONE)
#define TRACE_EVENT_COPY_END_WITH_ID_TID_AND_TIMESTAMP0(                \
    category_group, name, id, thread_id, timestamp)                     \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                   \
      TRACE_EVENT_PHASE_ASYNC_END, category_group, name, id, thread_id, \
      timestamp, TRACE_EVENT_FLAG_COPY)
#define TRACE_EVENT_COPY_END_WITH_ID_TID_AND_TIMESTAMP1(                 \
    category_group, name, id, thread_id, timestamp, arg1_name, arg1_val) \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                    \
      TRACE_EVENT_PHASE_ASYNC_END, category_group, name, id, thread_id,  \
      timestamp, TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val)
#define TRACE_EVENT_COPY_END_WITH_ID_TID_AND_TIMESTAMP2(                 \
    category_group, name, id, thread_id, timestamp, arg1_name, arg1_val, \
    arg2_name, arg2_val)                                                 \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                    \
      TRACE_EVENT_PHASE_ASYNC_END, category_group, name, id, thread_id,  \
      timestamp, TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val, arg2_name,  \
      arg2_val)

// Records the value of a counter called "name" immediately. Value
// must be representable as a 32 bit integer.
// - category and name strings must have application lifetime (statics or
//   literals). They may not include " chars.
#define TRACE_COUNTER1(category_group, name, value)                         \
  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_COUNTER, category_group, name, \
                           TRACE_EVENT_FLAG_NONE, "value",                  \
                           static_cast<int>(value))
#define TRACE_COPY_COUNTER1(category_group, name, value)                    \
  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_COUNTER, category_group, name, \
                           TRACE_EVENT_FLAG_COPY, "value",                  \
                           static_cast<int>(value))

// Records the values of a multi-parted counter called "name" immediately.
// The UI will treat value1 and value2 as parts of a whole, displaying their
// values as a stacked-bar chart.
// - category and name strings must have application lifetime (statics or
//   literals). They may not include " chars.
#define TRACE_COUNTER2(category_group, name, value1_name, value1_val,       \
                       value2_name, value2_val)                             \
  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_COUNTER, category_group, name, \
                           TRACE_EVENT_FLAG_NONE, value1_name,              \
                           static_cast<int>(value1_val), value2_name,       \
                           static_cast<int>(value2_val))
#define TRACE_COPY_COUNTER2(category_group, name, value1_name, value1_val,  \
                            value2_name, value2_val)                        \
  INTERNAL_TRACE_EVENT_ADD(TRACE_EVENT_PHASE_COUNTER, category_group, name, \
                           TRACE_EVENT_FLAG_COPY, value1_name,              \
                           static_cast<int>(value1_val), value2_name,       \
                           static_cast<int>(value2_val))

// Similar to TRACE_COUNTERx, but with a custom |timestamp| provided.
#define TRACE_COUNTER_WITH_TIMESTAMP1(category_group, name, timestamp, value) \
  INTERNAL_TRACE_EVENT_ADD_WITH_TIMESTAMP(                                    \
      TRACE_EVENT_PHASE_COUNTER, category_group, name, timestamp,             \
      TRACE_EVENT_FLAG_NONE, "value", static_cast<int>(value))

#define TRACE_COUNTER_WITH_TIMESTAMP2(category_group, name, timestamp,      \
                                      value1_name, value1_val, value2_name, \
                                      value2_val)                           \
  INTERNAL_TRACE_EVENT_ADD_WITH_TIMESTAMP(                                  \
      TRACE_EVENT_PHASE_COUNTER, category_group, name, timestamp,           \
      TRACE_EVENT_FLAG_NONE, value1_name, static_cast<int>(value1_val),     \
      value2_name, static_cast<int>(value2_val))

// Records the value of a counter called "name" immediately. Value
// must be representable as a 32 bit integer.
// - category and name strings must have application lifetime (statics or
//   literals). They may not include " chars.
// - |id| is used to disambiguate counters with the same name. It must either
//   be a pointer or an integer value up to 64 bits. If it's a pointer, the bits
//   will be xored with a hash of the process ID so that the same pointer on
//   two different processes will not collide.
#define TRACE_COUNTER_ID1(category_group, name, id, value)                    \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_COUNTER, category_group, \
                                   name, id, TRACE_EVENT_FLAG_NONE, "value",  \
                                   static_cast<int>(value))
#define TRACE_COPY_COUNTER_ID1(category_group, name, id, value)               \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_COUNTER, category_group, \
                                   name, id, TRACE_EVENT_FLAG_COPY, "value",  \
                                   static_cast<int>(value))

// Records the values of a multi-parted counter called "name" immediately.
// The UI will treat value1 and value2 as parts of a whole, displaying their
// values as a stacked-bar chart.
// - category and name strings must have application lifetime (statics or
//   literals). They may not include " chars.
// - |id| is used to disambiguate counters with the same name. It must either
//   be a pointer or an integer value up to 64 bits. If it's a pointer, the bits
//   will be xored with a hash of the process ID so that the same pointer on
//   two different processes will not collide.
#define TRACE_COUNTER_ID2(category_group, name, id, value1_name, value1_val,  \
                          value2_name, value2_val)                            \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_COUNTER, category_group, \
                                   name, id, TRACE_EVENT_FLAG_NONE,           \
                                   value1_name, static_cast<int>(value1_val), \
                                   value2_name, static_cast<int>(value2_val))
#define TRACE_COPY_COUNTER_ID2(category_group, name, id, value1_name,         \
                               value1_val, value2_name, value2_val)           \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_COUNTER, category_group, \
                                   name, id, TRACE_EVENT_FLAG_COPY,           \
                                   value1_name, static_cast<int>(value1_val), \
                                   value2_name, static_cast<int>(value2_val))

// TRACE_EVENT_SAMPLE_* events are injected by the sampling profiler.
#define TRACE_EVENT_SAMPLE_WITH_TID_AND_TIMESTAMP0(category_group, name,       \
                                                   thread_id, timestamp)       \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                          \
      TRACE_EVENT_PHASE_SAMPLE, category_group, name, 0, thread_id, timestamp, \
      TRACE_EVENT_FLAG_NONE)

#define TRACE_EVENT_SAMPLE_WITH_TID_AND_TIMESTAMP1(                            \
    category_group, name, thread_id, timestamp, arg1_name, arg1_val)           \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                          \
      TRACE_EVENT_PHASE_SAMPLE, category_group, name, 0, thread_id, timestamp, \
      TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val)

#define TRACE_EVENT_SAMPLE_WITH_TID_AND_TIMESTAMP2(category_group, name,       \
                                                   thread_id, timestamp,       \
                                                   arg1_name, arg1_val,        \
                                                   arg2_name, arg2_val)        \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                          \
      TRACE_EVENT_PHASE_SAMPLE, category_group, name, 0, thread_id, timestamp, \
      TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val, arg2_name, arg2_val)

#define TRACE_EVENT_SAMPLE_WITH_ID1(category_group, name, id, arg1_name,       \
                                    arg1_val)                                  \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_SAMPLE, category_group,   \
                                   name, id, TRACE_EVENT_FLAG_NONE, arg1_name, \
                                   arg1_val)

// ASYNC_STEP_* APIs should be only used by legacy code. New code should
// consider using NESTABLE_ASYNC_* APIs to describe substeps within an async
// event.
// Records a single ASYNC_BEGIN event called "name" immediately, with 0, 1 or 2
// associated arguments. If the category is not enabled, then this
// does nothing.
// - category and name strings must have application lifetime (statics or
//   literals). They may not include " chars.
// - |id| is used to match the ASYNC_BEGIN event with the ASYNC_END event. ASYNC
//   events are considered to match if their category_group, name and id values
//   all match. |id| must either be a pointer or an integer value up to 64 bits.
//   If it's a pointer, the bits will be xored with a hash of the process ID so
//   that the same pointer on two different processes will not collide.
//
// An asynchronous operation can consist of multiple phases. The first phase is
// defined by the ASYNC_BEGIN calls. Additional phases can be defined using the
// ASYNC_STEP_INTO or ASYNC_STEP_PAST macros. The ASYNC_STEP_INTO macro will
// annotate the block following the call. The ASYNC_STEP_PAST macro will
// annotate the block prior to the call. Note that any particular event must use
// only STEP_INTO or STEP_PAST macros; they can not mix and match. When the
// operation completes, call ASYNC_END.
//
// An ASYNC trace typically occurs on a single thread (if not, they will only be
// drawn on the thread defined in the ASYNC_BEGIN event), but all events in that
// operation must use the same |name| and |id|. Each step can have its own
// args.
#define TRACE_EVENT_ASYNC_BEGIN0(category_group, name, id)        \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_ASYNC_BEGIN, \
                                   category_group, name, id,      \
                                   TRACE_EVENT_FLAG_NONE)
#define TRACE_EVENT_ASYNC_BEGIN1(category_group, name, id, arg1_name, \
                                 arg1_val)                            \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_ASYNC_BEGIN,     \
                                   category_group, name, id,          \
                                   TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val)
#define TRACE_EVENT_ASYNC_BEGIN2(category_group, name, id, arg1_name, \
                                 arg1_val, arg2_name, arg2_val)       \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                   \
      TRACE_EVENT_PHASE_ASYNC_BEGIN, category_group, name, id,        \
      TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val, arg2_name, arg2_val)
#define TRACE_EVENT_COPY_ASYNC_BEGIN0(category_group, name, id)   \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_ASYNC_BEGIN, \
                                   category_group, name, id,      \
                                   TRACE_EVENT_FLAG_COPY)
#define TRACE_EVENT_COPY_ASYNC_BEGIN1(category_group, name, id, arg1_name, \
                                      arg1_val)                            \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_ASYNC_BEGIN,          \
                                   category_group, name, id,               \
                                   TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val)
#define TRACE_EVENT_COPY_ASYNC_BEGIN2(category_group, name, id, arg1_name, \
                                      arg1_val, arg2_name, arg2_val)       \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                        \
      TRACE_EVENT_PHASE_ASYNC_BEGIN, category_group, name, id,             \
      TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val, arg2_name, arg2_val)

// Similar to TRACE_EVENT_ASYNC_BEGINx but with a custom |at| timestamp
// provided.
#define TRACE_EVENT_ASYNC_BEGIN_WITH_TIMESTAMP0(category_group, name, id, \
                                                timestamp)                \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                     \
      TRACE_EVENT_PHASE_ASYNC_BEGIN, category_group, name, id,            \
      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_NONE)
#define TRACE_EVENT_ASYNC_BEGIN_WITH_TIMESTAMP1(                           \
    category_group, name, id, timestamp, arg1_name, arg1_val)              \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                      \
      TRACE_EVENT_PHASE_ASYNC_BEGIN, category_group, name, id,             \
      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_NONE, \
      arg1_name, arg1_val)
#define TRACE_EVENT_ASYNC_BEGIN_WITH_TIMESTAMP2(category_group, name, id,      \
                                                timestamp, arg1_name,          \
                                                arg1_val, arg2_name, arg2_val) \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                          \
      TRACE_EVENT_PHASE_ASYNC_BEGIN, category_group, name, id,                 \
      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_NONE,     \
      arg1_name, arg1_val, arg2_name, arg2_val)
#define TRACE_EVENT_COPY_ASYNC_BEGIN_WITH_TIMESTAMP0(category_group, name, id, \
                                                     timestamp)                \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                          \
      TRACE_EVENT_PHASE_ASYNC_BEGIN, category_group, name, id,                 \
      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_COPY)

// Records a single ASYNC_STEP_INTO event for |step| immediately. If the
// category is not enabled, then this does nothing. The |name| and |id| must
// match the ASYNC_BEGIN event above. The |step| param identifies this step
// within the async event. This should be called at the beginning of the next
// phase of an asynchronous operation. The ASYNC_BEGIN event must not have any
// ASYNC_STEP_PAST events.
#define TRACE_EVENT_ASYNC_STEP_INTO0(category_group, name, id, step)  \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_ASYNC_STEP_INTO, \
                                   category_group, name, id,          \
                                   TRACE_EVENT_FLAG_NONE, "step", step)
#define TRACE_EVENT_ASYNC_STEP_INTO1(category_group, name, id, step, \
                                     arg1_name, arg1_val)            \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                  \
      TRACE_EVENT_PHASE_ASYNC_STEP_INTO, category_group, name, id,   \
      TRACE_EVENT_FLAG_NONE, "step", step, arg1_name, arg1_val)

// Similar to TRACE_EVENT_ASYNC_STEP_INTOx but with a custom |at| timestamp
// provided.
#define TRACE_EVENT_ASYNC_STEP_INTO_WITH_TIMESTAMP0(category_group, name, id, \
                                                    step, timestamp)          \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                         \
      TRACE_EVENT_PHASE_ASYNC_STEP_INTO, category_group, name, id,            \
      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_NONE,    \
      "step", step)

// Records a single ASYNC_STEP_PAST event for |step| immediately. If the
// category is not enabled, then this does nothing. The |name| and |id| must
// match the ASYNC_BEGIN event above. The |step| param identifies this step
// within the async event. This should be called at the beginning of the next
// phase of an asynchronous operation. The ASYNC_BEGIN event must not have any
// ASYNC_STEP_INTO events.
#define TRACE_EVENT_ASYNC_STEP_PAST0(category_group, name, id, step)  \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_ASYNC_STEP_PAST, \
                                   category_group, name, id,          \
                                   TRACE_EVENT_FLAG_NONE, "step", step)
#define TRACE_EVENT_ASYNC_STEP_PAST1(category_group, name, id, step, \
                                     arg1_name, arg1_val)            \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                  \
      TRACE_EVENT_PHASE_ASYNC_STEP_PAST, category_group, name, id,   \
      TRACE_EVENT_FLAG_NONE, "step", step, arg1_name, arg1_val)

// Records a single ASYNC_END event for "name" immediately. If the category
// is not enabled, then this does nothing.
#define TRACE_EVENT_ASYNC_END0(category_group, name, id)        \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_ASYNC_END, \
                                   category_group, name, id,    \
                                   TRACE_EVENT_FLAG_NONE)
#define TRACE_EVENT_ASYNC_END1(category_group, name, id, arg1_name, arg1_val) \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_ASYNC_END,               \
                                   category_group, name, id,                  \
                                   TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val)
#define TRACE_EVENT_ASYNC_END2(category_group, name, id, arg1_name, arg1_val, \
                               arg2_name, arg2_val)                           \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                           \
      TRACE_EVENT_PHASE_ASYNC_END, category_group, name, id,                  \
      TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val, arg2_name, arg2_val)
#define TRACE_EVENT_COPY_ASYNC_END0(category_group, name, id)   \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_ASYNC_END, \
                                   category_group, name, id,    \
                                   TRACE_EVENT_FLAG_COPY)
#define TRACE_EVENT_COPY_ASYNC_END1(category_group, name, id, arg1_name, \
                                    arg1_val)                            \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_ASYNC_END,          \
                                   category_group, name, id,             \
                                   TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val)
#define TRACE_EVENT_COPY_ASYNC_END2(category_group, name, id, arg1_name, \
                                    arg1_val, arg2_name, arg2_val)       \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                      \
      TRACE_EVENT_PHASE_ASYNC_END, category_group, name, id,             \
      TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val, arg2_name, arg2_val)

// Similar to TRACE_EVENT_ASYNC_ENDx but with a custom |at| timestamp provided.
#define TRACE_EVENT_ASYNC_END_WITH_TIMESTAMP0(category_group, name, id, \
                                              timestamp)                \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                   \
      TRACE_EVENT_PHASE_ASYNC_END, category_group, name, id,            \
      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_NONE)
#define TRACE_EVENT_ASYNC_END_WITH_TIMESTAMP1(category_group, name, id,       \
                                              timestamp, arg1_name, arg1_val) \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                         \
      TRACE_EVENT_PHASE_ASYNC_END, category_group, name, id,                  \
      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_NONE,    \
      arg1_name, arg1_val)
#define TRACE_EVENT_ASYNC_END_WITH_TIMESTAMP2(category_group, name, id,       \
                                              timestamp, arg1_name, arg1_val, \
                                              arg2_name, arg2_val)            \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                         \
      TRACE_EVENT_PHASE_ASYNC_END, category_group, name, id,                  \
      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_NONE,    \
      arg1_name, arg1_val, arg2_name, arg2_val)

// NESTABLE_ASYNC_* APIs are used to describe an async operation, which can
// be nested within a NESTABLE_ASYNC event and/or have inner NESTABLE_ASYNC
// events.
// - category and name strings must have application lifetime (statics or
//   literals). They may not include " chars.
// - A pair of NESTABLE_ASYNC_BEGIN event and NESTABLE_ASYNC_END event is
//   considered as a match if their category_group, name and id all match.
// - |id| must either be a pointer or an integer value up to 64 bits.
//   If it's a pointer, the bits will be xored with a hash of the process ID so
//   that the same pointer on two different processes will not collide.
// - |id| is used to match a child NESTABLE_ASYNC event with its parent
//   NESTABLE_ASYNC event. Therefore, events in the same nested event tree must
//   be logged using the same id and category_group.
//
// Unmatched NESTABLE_ASYNC_END event will be parsed as an event that starts
// at the first NESTABLE_ASYNC event of that id, and unmatched
// NESTABLE_ASYNC_BEGIN event will be parsed as an event that ends at the last
// NESTABLE_ASYNC event of that id. Corresponding warning messages for
// unmatched events will be shown in the analysis view.

// Records a single NESTABLE_ASYNC_BEGIN event called "name" immediately, with
// 0, 1 or 2 associated arguments. If the category is not enabled, then this
// does nothing.
#define TRACE_EVENT_NESTABLE_ASYNC_BEGIN0(category_group, name, id)        \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN, \
                                   category_group, name, id,               \
                                   TRACE_EVENT_FLAG_NONE)
#define TRACE_EVENT_NESTABLE_ASYNC_BEGIN1(category_group, name, id, arg1_name, \
                                          arg1_val)                            \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN,     \
                                   category_group, name, id,                   \
                                   TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val)
#define TRACE_EVENT_NESTABLE_ASYNC_BEGIN2(category_group, name, id, arg1_name, \
                                          arg1_val, arg2_name, arg2_val)       \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                            \
      TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN, category_group, name, id,        \
      TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val, arg2_name, arg2_val)
// Records a single NESTABLE_ASYNC_END event called "name" immediately, with 0
// or 2 associated arguments. If the category is not enabled, then this does
// nothing.
#define TRACE_EVENT_NESTABLE_ASYNC_END0(category_group, name, id)        \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_NESTABLE_ASYNC_END, \
                                   category_group, name, id,             \
                                   TRACE_EVENT_FLAG_NONE)
// Records a single NESTABLE_ASYNC_END event called "name" immediately, with 1
// associated argument. If the category is not enabled, then this does nothing.
#define TRACE_EVENT_NESTABLE_ASYNC_END1(category_group, name, id, arg1_name, \
                                        arg1_val)                            \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_NESTABLE_ASYNC_END,     \
                                   category_group, name, id,                 \
                                   TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val)
#define TRACE_EVENT_NESTABLE_ASYNC_END2(category_group, name, id, arg1_name, \
                                        arg1_val, arg2_name, arg2_val)       \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                          \
      TRACE_EVENT_PHASE_NESTABLE_ASYNC_END, category_group, name, id,        \
      TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val, arg2_name, arg2_val)

// Records a single NESTABLE_ASYNC_INSTANT event called "name" immediately,
// with none, one or two associated argument. If the category is not enabled,
// then this does nothing.
#define TRACE_EVENT_NESTABLE_ASYNC_INSTANT0(category_group, name, id)        \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT, \
                                   category_group, name, id,                 \
                                   TRACE_EVENT_FLAG_NONE)

#define TRACE_EVENT_NESTABLE_ASYNC_INSTANT1(category_group, name, id,        \
                                            arg1_name, arg1_val)             \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT, \
                                   category_group, name, id,                 \
                                   TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val)

#define TRACE_EVENT_NESTABLE_ASYNC_INSTANT2(                              \
    category_group, name, id, arg1_name, arg1_val, arg2_name, arg2_val)   \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                       \
      TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT, category_group, name, id, \
      TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val, arg2_name, arg2_val)

#define TRACE_EVENT_COPY_NESTABLE_ASYNC_BEGIN_WITH_TTS2(                       \
    category_group, name, id, arg1_name, arg1_val, arg2_name, arg2_val)        \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                            \
      TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN, category_group, name, id,        \
      TRACE_EVENT_FLAG_ASYNC_TTS | TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val, \
      arg2_name, arg2_val)
#define TRACE_EVENT_COPY_NESTABLE_ASYNC_END_WITH_TTS2(                         \
    category_group, name, id, arg1_name, arg1_val, arg2_name, arg2_val)        \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                            \
      TRACE_EVENT_PHASE_NESTABLE_ASYNC_END, category_group, name, id,          \
      TRACE_EVENT_FLAG_ASYNC_TTS | TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val, \
      arg2_name, arg2_val)

// Similar to TRACE_EVENT_NESTABLE_ASYNC_{BEGIN,END}x but with a custom
// |timestamp| provided.
#define TRACE_EVENT_NESTABLE_ASYNC_BEGIN_WITH_TIMESTAMP0(category_group, name, \
                                                         id, timestamp)        \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                          \
      TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN, category_group, name, id,        \
      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_NONE)
#define TRACE_EVENT_NESTABLE_ASYNC_END_WITH_TIMESTAMP0(category_group, name, \
                                                       id, timestamp)        \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                        \
      TRACE_EVENT_PHASE_NESTABLE_ASYNC_END, category_group, name, id,        \
      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_NONE)
#define TRACE_EVENT_NESTABLE_ASYNC_END_WITH_TIMESTAMP1(                    \
    category_group, name, id, timestamp, arg1_name, arg1_val)              \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                      \
      TRACE_EVENT_PHASE_NESTABLE_ASYNC_END, category_group, name, id,      \
      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_NONE, \
      arg1_name, arg1_val)
#define TRACE_EVENT_NESTABLE_ASYNC_INSTANT_WITH_TIMESTAMP0(               \
    category_group, name, id, timestamp)                                  \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                     \
      TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT, category_group, name, id, \
      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_NONE)
#define TRACE_EVENT_COPY_NESTABLE_ASYNC_BEGIN_WITH_TIMESTAMP0(          \
    category_group, name, id, timestamp)                                \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                   \
      TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN, category_group, name, id, \
      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_COPY)
#define TRACE_EVENT_COPY_NESTABLE_ASYNC_END_WITH_TIMESTAMP0(          \
    category_group, name, id, timestamp)                              \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                 \
      TRACE_EVENT_PHASE_NESTABLE_ASYNC_END, category_group, name, id, \
      TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_COPY)

// Records a single FLOW_BEGIN event called "name" immediately, with 0, 1 or 2
// associated arguments. If the category is not enabled, then this
// does nothing.
// - category and name strings must have application lifetime (statics or
//   literals). They may not include " chars.
// - |id| is used to match the FLOW_BEGIN event with the FLOW_END event. FLOW
//   events are considered to match if their category_group, name and id values
//   all match. |id| must either be a pointer or an integer value up to 64 bits.
//   If it's a pointer, the bits will be xored with a hash of the process ID so
//   that the same pointer on two different processes will not collide.
// FLOW events are different from ASYNC events in how they are drawn by the
// tracing UI. A FLOW defines asynchronous data flow, such as posting a task
// (FLOW_BEGIN) and later executing that task (FLOW_END). Expect FLOWs to be
// drawn as lines or arrows from FLOW_BEGIN scopes to FLOW_END scopes. Similar
// to ASYNC, a FLOW can consist of multiple phases. The first phase is defined
// by the FLOW_BEGIN calls. Additional phases can be defined using the FLOW_STEP
// macros. When the operation completes, call FLOW_END. An async operation can
// span threads and processes, but all events in that operation must use the
// same |name| and |id|. Each event can have its own args.
#define TRACE_EVENT_FLOW_BEGIN0(category_group, name, id)        \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_BEGIN, \
                                   category_group, name, id,     \
                                   TRACE_EVENT_FLAG_NONE)
#define TRACE_EVENT_FLOW_BEGIN1(category_group, name, id, arg1_name, arg1_val) \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_BEGIN,               \
                                   category_group, name, id,                   \
                                   TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val)
#define TRACE_EVENT_FLOW_BEGIN2(category_group, name, id, arg1_name, arg1_val, \
                                arg2_name, arg2_val)                           \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                            \
      TRACE_EVENT_PHASE_FLOW_BEGIN, category_group, name, id,                  \
      TRACE_EVENT_FLAG_NONE, arg1_name, arg1_val, arg2_name, arg2_val)
#define TRACE_EVENT_COPY_FLOW_BEGIN0(category_group, name, id)   \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_BEGIN, \
                                   category_group, name, id,     \
                                   TRACE_EVENT_FLAG_COPY)
#define TRACE_EVENT_COPY_FLOW_BEGIN1(category_group, name, id, arg1_name, \
                                     arg1_val)                            \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_BEGIN,          \
                                   category_group, name, id,              \
                                   TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val)
#define TRACE_EVENT_COPY_FLOW_BEGIN2(category_group, name, id, arg1_name, \
                                     arg1_val, arg2_name, arg2_val)       \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                       \
      TRACE_EVENT_PHASE_FLOW_BEGIN, category_group, name, id,             \
      TRACE_EVENT_FLAG_COPY, arg1_name, arg1_val, arg2_name, arg2_val)

// Records a single FLOW_STEP event for |step| immediately. If the category
// is not enabled, then this does nothing. The |name| and |id| must match the
// FLOW_BEGIN event above. The |step| param identifies this step within the
// async event. This should be called at the beginning of the next phase of an
// asynchronous operation.
#define TRACE_EVENT_FLOW_STEP0(category_group, name, id, step)  \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_STEP, \
                                   category_group, name, id,    \
                                   TRACE_EVENT_FLAG_NONE, "step", step)
#define TRACE_EVENT_FLOW_STEP1(category_group, name, id, step, arg1_name, \
                               arg1_val)                                  \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                       \
      TRACE_EVENT_PHASE_FLOW_STEP, category_group, name, id,              \
      TRACE_EVENT_FLAG_NONE, "step", step, arg1_name, arg1_val)
#define TRACE_EVENT_COPY_FLOW_STEP0(category_group, name, id, step) \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_STEP,     \
                                   category_group, name, id,        \
                                   TRACE_EVENT_FLAG_COPY, "step", step)
#define TRACE_EVENT_COPY_FLOW_STEP1(category_group, name, id, step, arg1_name, \
                                    arg1_val)                                  \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                            \
      TRACE_EVENT_PHASE_FLOW_STEP, category_group, name, id,                   \
      TRACE_EVENT_FLAG_COPY, "step", step, arg1_name, arg1_val)

// Records a single FLOW_END event for "name" immediately. If the category
// is not enabled, then this does nothing.
#define TRACE_EVENT_FLOW_END0(category_group, name, id)                        \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_END, category_group, \
                                   name, id, TRACE_EVENT_FLAG_NONE)
#define TRACE_EVENT_FLOW_END_BIND_TO_ENCLOSING0(category_group, name, id)      \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_END, category_group, \
                                   name, id,                                   \
                                   TRACE_EVENT_FLAG_BIND_TO_ENCLOSING)
#define TRACE_EVENT_FLOW_END1(category_group, name, id, arg1_name, arg1_val)   \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_END, category_group, \
                                   name, id, TRACE_EVENT_FLAG_NONE, arg1_name, \
                                   arg1_val)
#define TRACE_EVENT_FLOW_END2(category_group, name, id, arg1_name, arg1_val,   \
                              arg2_name, arg2_val)                             \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_END, category_group, \
                                   name, id, TRACE_EVENT_FLAG_NONE, arg1_name, \
                                   arg1_val, arg2_name, arg2_val)
#define TRACE_EVENT_COPY_FLOW_END0(category_group, name, id)                   \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_END, category_group, \
                                   name, id, TRACE_EVENT_FLAG_COPY)
#define TRACE_EVENT_COPY_FLOW_END1(category_group, name, id, arg1_name,        \
                                   arg1_val)                                   \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_END, category_group, \
                                   name, id, TRACE_EVENT_FLAG_COPY, arg1_name, \
                                   arg1_val)
#define TRACE_EVENT_COPY_FLOW_END2(category_group, name, id, arg1_name,        \
                                   arg1_val, arg2_name, arg2_val)              \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(TRACE_EVENT_PHASE_FLOW_END, category_group, \
                                   name, id, TRACE_EVENT_FLAG_COPY, arg1_name, \
                                   arg1_val, arg2_name, arg2_val)

// Special trace event macro to trace task execution with the location where it
// was posted from.
#define TRACE_TASK_EXECUTION(run_function, task) \
  INTERNAL_TRACE_TASK_EXECUTION(run_function, task)

// TRACE_EVENT_METADATA* events are information related to other
// injected events, not events in their own right.
#define TRACE_EVENT_METADATA1(category_group, name, arg1_name, arg1_val) \
  INTERNAL_TRACE_EVENT_METADATA_ADD(category_group, name, arg1_name, arg1_val)

// Records a clock sync event.
#define TRACE_EVENT_CLOCK_SYNC_RECEIVER(sync_id)                               \
  INTERNAL_TRACE_EVENT_ADD(                                                    \
      TRACE_EVENT_PHASE_CLOCK_SYNC, "__metadata", "clock_sync",                \
      TRACE_EVENT_FLAG_NONE, "sync_id", sync_id)
#define TRACE_EVENT_CLOCK_SYNC_ISSUER(sync_id, issue_ts, issue_end_ts)         \
  INTERNAL_TRACE_EVENT_ADD_WITH_TIMESTAMP(                                     \
      TRACE_EVENT_PHASE_CLOCK_SYNC, "__metadata", "clock_sync",                \
      issue_end_ts, TRACE_EVENT_FLAG_NONE,                                     \
      "sync_id", sync_id, "issue_ts", issue_ts)

// Macros to track the life time and value of arbitrary client objects.
// See also TraceTrackableObject.
#define TRACE_EVENT_OBJECT_CREATED_WITH_ID(category_group, name, id) \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                  \
      TRACE_EVENT_PHASE_CREATE_OBJECT, category_group, name, id,     \
      TRACE_EVENT_FLAG_NONE)

#define TRACE_EVENT_OBJECT_SNAPSHOT_WITH_ID(category_group, name, id, \
                                            snapshot)                 \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                   \
      TRACE_EVENT_PHASE_SNAPSHOT_OBJECT, category_group, name,        \
      id, TRACE_EVENT_FLAG_NONE, "snapshot", snapshot)

#define TRACE_EVENT_OBJECT_SNAPSHOT_WITH_ID_AND_TIMESTAMP(                     \
    category_group, name, id, timestamp, snapshot)                             \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID_TID_AND_TIMESTAMP(                          \
      TRACE_EVENT_PHASE_SNAPSHOT_OBJECT, category_group, name,                 \
      id, TRACE_EVENT_API_CURRENT_THREAD_ID, timestamp, TRACE_EVENT_FLAG_NONE, \
      "snapshot", snapshot)

#define TRACE_EVENT_OBJECT_DELETED_WITH_ID(category_group, name, id) \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                  \
      TRACE_EVENT_PHASE_DELETE_OBJECT, category_group, name, id,     \
      TRACE_EVENT_FLAG_NONE)

// Records entering and leaving trace event contexts. |category_group| and
// |name| specify the context category and type. |context| is a
// snapshotted context object id.
#define TRACE_EVENT_ENTER_CONTEXT(category_group, name, context)      \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                   \
      TRACE_EVENT_PHASE_ENTER_CONTEXT, category_group, name, context, \
      TRACE_EVENT_FLAG_NONE)
#define TRACE_EVENT_LEAVE_CONTEXT(category_group, name, context)      \
  INTERNAL_TRACE_EVENT_ADD_WITH_ID(                                   \
      TRACE_EVENT_PHASE_LEAVE_CONTEXT, category_group, name, context, \
      TRACE_EVENT_FLAG_NONE)
#define TRACE_EVENT_SCOPED_CONTEXT(category_group, name, context) \
  INTERNAL_TRACE_EVENT_SCOPED_CONTEXT(category_group, name, context)

// Macro to specify that two trace IDs are identical. For example,
// TRACE_LINK_IDS(
//     "category", "name",
//     TRACE_ID_WITH_SCOPE("net::URLRequest", 0x1000),
//     TRACE_ID_WITH_SCOPE("blink::ResourceFetcher::FetchRequest", 0x2000))
// tells the trace consumer that events with ID ("net::URLRequest", 0x1000) from
// the current process have the same ID as events with ID
// ("blink::ResourceFetcher::FetchRequest", 0x2000).
#define TRACE_LINK_IDS(category_group, name, id, linked_id) \
  INTERNAL_TRACE_EVENT_ADD_LINK_IDS(category_group, name, id, linked_id);

// Macro to efficiently determine if a given category group is enabled.
#define TRACE_EVENT_CATEGORY_GROUP_ENABLED(category_group, ret)             \
  do {                                                                      \
    INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO(category_group);                 \
    if (INTERNAL_TRACE_EVENT_CATEGORY_GROUP_ENABLED_FOR_RECORDING_MODE()) { \
      *ret = true;                                                          \
    } else {                                                                \
      *ret = false;                                                         \
    }                                                                       \
  } while (0)

// Macro to explicitly warm up a given category group. This could be useful in
// cases where we want to initialize a category group before any trace events
// for that category group is reported. For example, to have a category group
// always show up in the "record categories" list for manually selecting
// settings in about://tracing.
#define TRACE_EVENT_WARMUP_CATEGORY(category_group) \
  INTERNAL_TRACE_EVENT_GET_CATEGORY_INFO(category_group)

// Macro to efficiently determine, through polling, if a new trace has begun.
#define TRACE_EVENT_IS_NEW_TRACE(ret)                                      \
  do {                                                                     \
    static int INTERNAL_TRACE_EVENT_UID(lastRecordingNumber) = 0;          \
    int num_traces_recorded = TRACE_EVENT_API_GET_NUM_TRACES_RECORDED();   \
    if (num_traces_recorded != -1 &&                                       \
        num_traces_recorded !=                                             \
            INTERNAL_TRACE_EVENT_UID(lastRecordingNumber)) {               \
      INTERNAL_TRACE_EVENT_UID(lastRecordingNumber) = num_traces_recorded; \
      *ret = true;                                                         \
    } else {                                                               \
      *ret = false;                                                        \
    }                                                                      \
  } while (0)

// Notes regarding the following definitions:
// New values can be added and propagated to third party libraries, but existing
// definitions must never be changed, because third party libraries may use old
// definitions.

// Phase indicates the nature of an event entry. E.g. part of a begin/end pair.
#define TRACE_EVENT_PHASE_BEGIN ('B')
#define TRACE_EVENT_PHASE_END ('E')
#define TRACE_EVENT_PHASE_COMPLETE ('X')
#define TRACE_EVENT_PHASE_INSTANT ('I')
#define TRACE_EVENT_PHASE_ASYNC_BEGIN ('S')
#define TRACE_EVENT_PHASE_ASYNC_STEP_INTO ('T')
#define TRACE_EVENT_PHASE_ASYNC_STEP_PAST ('p')
#define TRACE_EVENT_PHASE_ASYNC_END ('F')
#define TRACE_EVENT_PHASE_NESTABLE_ASYNC_BEGIN ('b')
#define TRACE_EVENT_PHASE_NESTABLE_ASYNC_END ('e')
#define TRACE_EVENT_PHASE_NESTABLE_ASYNC_INSTANT ('n')
#define TRACE_EVENT_PHASE_FLOW_BEGIN ('s')
#define TRACE_EVENT_PHASE_FLOW_STEP ('t')
#define TRACE_EVENT_PHASE_FLOW_END ('f')
#define TRACE_EVENT_PHASE_METADATA ('M')
#define TRACE_EVENT_PHASE_COUNTER ('C')
#define TRACE_EVENT_PHASE_SAMPLE ('P')
#define TRACE_EVENT_PHASE_CREATE_OBJECT ('N')
#define TRACE_EVENT_PHASE_SNAPSHOT_OBJECT ('O')
#define TRACE_EVENT_PHASE_DELETE_OBJECT ('D')
#define TRACE_EVENT_PHASE_MEMORY_DUMP ('v')
#define TRACE_EVENT_PHASE_MARK ('R')
#define TRACE_EVENT_PHASE_CLOCK_SYNC ('c')
#define TRACE_EVENT_PHASE_ENTER_CONTEXT ('(')
#define TRACE_EVENT_PHASE_LEAVE_CONTEXT (')')
#define TRACE_EVENT_PHASE_LINK_IDS ('=')

// Flags for changing the behavior of TRACE_EVENT_API_ADD_TRACE_EVENT.
#define TRACE_EVENT_FLAG_NONE (static_cast<unsigned int>(0))
#define TRACE_EVENT_FLAG_COPY (static_cast<unsigned int>(1 << 0))
#define TRACE_EVENT_FLAG_HAS_ID (static_cast<unsigned int>(1 << 1))
// TODO(crbug.com/639003): Free this bit after ID mangling is deprecated.
#define TRACE_EVENT_FLAG_MANGLE_ID (static_cast<unsigned int>(1 << 2))
#define TRACE_EVENT_FLAG_SCOPE_OFFSET (static_cast<unsigned int>(1 << 3))
#define TRACE_EVENT_FLAG_SCOPE_EXTRA (static_cast<unsigned int>(1 << 4))
#define TRACE_EVENT_FLAG_EXPLICIT_TIMESTAMP (static_cast<unsigned int>(1 << 5))
#define TRACE_EVENT_FLAG_ASYNC_TTS (static_cast<unsigned int>(1 << 6))
#define TRACE_EVENT_FLAG_BIND_TO_ENCLOSING (static_cast<unsigned int>(1 << 7))
#define TRACE_EVENT_FLAG_FLOW_IN (static_cast<unsigned int>(1 << 8))
#define TRACE_EVENT_FLAG_FLOW_OUT (static_cast<unsigned int>(1 << 9))
#define TRACE_EVENT_FLAG_HAS_CONTEXT_ID (static_cast<unsigned int>(1 << 10))
#define TRACE_EVENT_FLAG_HAS_PROCESS_ID (static_cast<unsigned int>(1 << 11))
#define TRACE_EVENT_FLAG_HAS_LOCAL_ID (static_cast<unsigned int>(1 << 12))
#define TRACE_EVENT_FLAG_HAS_GLOBAL_ID (static_cast<unsigned int>(1 << 13))

#define TRACE_EVENT_FLAG_SCOPE_MASK                          \
  (static_cast<unsigned int>(TRACE_EVENT_FLAG_SCOPE_OFFSET | \
                             TRACE_EVENT_FLAG_SCOPE_EXTRA))

// Type values for identifying types in the TraceValue union.
#define TRACE_VALUE_TYPE_BOOL (static_cast<unsigned char>(1))
#define TRACE_VALUE_TYPE_UINT (static_cast<unsigned char>(2))
#define TRACE_VALUE_TYPE_INT (static_cast<unsigned char>(3))
#define TRACE_VALUE_TYPE_DOUBLE (static_cast<unsigned char>(4))
#define TRACE_VALUE_TYPE_POINTER (static_cast<unsigned char>(5))
#define TRACE_VALUE_TYPE_STRING (static_cast<unsigned char>(6))
#define TRACE_VALUE_TYPE_COPY_STRING (static_cast<unsigned char>(7))
#define TRACE_VALUE_TYPE_CONVERTABLE (static_cast<unsigned char>(8))

// Enum reflecting the scope of an INSTANT event. Must fit within
// TRACE_EVENT_FLAG_SCOPE_MASK.
#define TRACE_EVENT_SCOPE_GLOBAL (static_cast<unsigned char>(0 << 3))
#define TRACE_EVENT_SCOPE_PROCESS (static_cast<unsigned char>(1 << 3))
#define TRACE_EVENT_SCOPE_THREAD (static_cast<unsigned char>(2 << 3))

#define TRACE_EVENT_SCOPE_NAME_GLOBAL ('g')
#define TRACE_EVENT_SCOPE_NAME_PROCESS ('p')
#define TRACE_EVENT_SCOPE_NAME_THREAD ('t')

#endif // SRC_TRACE_EVENT_COMMON_H
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/src/tracing/traced_value.cc                                                             0000664 0000000 0000000 00000012304 14746647661 0017740 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "tracing/traced_value.h"

#if defined(NODE_HAVE_I18N_SUPPORT)
#include <unicode/utf8.h>
#include <unicode/utypes.h>
#endif

#include <cmath>
#include <cstdio>
#include <sstream>
#include <string>

#if defined(_STLP_VENDOR_CSTD)
// STLPort doesn't import fpclassify into the std namespace.
#define FPCLASSIFY_NAMESPACE
#else
#define FPCLASSIFY_NAMESPACE std
#endif

namespace node {
namespace tracing {

namespace {

std::string EscapeString(const char* value) {
  std::string result;
  result += '"';
  char number_buffer[10];
#if defined(NODE_HAVE_I18N_SUPPORT)
  int32_t len = strlen(value);
  int32_t p = 0;
  int32_t i = 0;
  for (; i < len; p = i) {
    UChar32 c;
    U8_NEXT_OR_FFFD(value, i, len, c);
    switch (c) {
      case '\b': result += "\\b"; break;
      case '\f': result += "\\f"; break;
      case '\n': result += "\\n"; break;
      case '\r': result += "\\r"; break;
      case '\t': result += "\\t"; break;
      case '\\': result += "\\\\"; break;
      case '"': result += "\\\""; break;
      default:
        if (c < 32 || c > 126) {
          snprintf(
              number_buffer, arraysize(number_buffer), "\\u%04X",
              static_cast<uint16_t>(static_cast<uint16_t>(c)));
          result += number_buffer;
        } else {
          result.append(value + p, i - p);
        }
    }
  }
#else
  // If we do not have ICU, use a modified version of the non-UTF8 aware
  // code from V8's own TracedValue implementation. Note, however, This
  // will not produce correctly serialized results for UTF8 values.
  while (*value) {
    char c = *value++;
    switch (c) {
      case '\b': result += "\\b"; break;
      case '\f': result += "\\f"; break;
      case '\n': result += "\\n"; break;
      case '\r': result += "\\r"; break;
      case '\t': result += "\\t"; break;
      case '\\': result += "\\\\"; break;
      case '"': result += "\\\""; break;
      default:
        if (c < '\x20') {
          snprintf(
              number_buffer, arraysize(number_buffer), "\\u%04X",
              static_cast<unsigned>(static_cast<unsigned char>(c)));
          result += number_buffer;
        } else {
          result += c;
        }
    }
  }
#endif  // defined(NODE_HAVE_I18N_SUPPORT)
  result += '"';
  return result;
}

std::string DoubleToCString(double v) {
  switch (FPCLASSIFY_NAMESPACE::fpclassify(v)) {
    case FP_NAN: return "\"NaN\"";
    case FP_INFINITE: return (v < 0.0 ? "\"-Infinity\"" : "\"Infinity\"");
    case FP_ZERO: return "0";
    default:
      // This is a far less sophisticated version than the one used inside v8.
      std::ostringstream stream;
      stream.imbue(std::locale::classic());  // Ignore current locale
      stream << v;
      return stream.str();
  }
}

}  // namespace

std::unique_ptr<TracedValue> TracedValue::Create() {
  return std::unique_ptr<TracedValue>(new TracedValue(false));
}

std::unique_ptr<TracedValue> TracedValue::CreateArray() {
  return std::unique_ptr<TracedValue>(new TracedValue(true));
}

TracedValue::TracedValue(bool root_is_array) :
    first_item_(true), root_is_array_(root_is_array) {}

void TracedValue::SetInteger(const char* name, int value) {
  WriteName(name);
  data_ += std::to_string(value);
}

void TracedValue::SetDouble(const char* name, double value) {
  WriteName(name);
  data_ += DoubleToCString(value);
}

void TracedValue::SetBoolean(const char* name, bool value) {
  WriteName(name);
  data_ += value ? "true" : "false";
}

void TracedValue::SetNull(const char* name) {
  WriteName(name);
  data_ += "null";
}

void TracedValue::SetString(const char* name, const char* value) {
  WriteName(name);
  data_ += EscapeString(value);
}

void TracedValue::BeginDictionary(const char* name) {
  WriteName(name);
  data_ += '{';
  first_item_ = true;
}

void TracedValue::BeginArray(const char* name) {
  WriteName(name);
  data_ += '[';
  first_item_ = true;
}

void TracedValue::AppendInteger(int value) {
  WriteComma();
  data_ += std::to_string(value);
}

void TracedValue::AppendDouble(double value) {
  WriteComma();
  data_ += DoubleToCString(value);
}

void TracedValue::AppendBoolean(bool value) {
  WriteComma();
  data_ += value ? "true" : "false";
}

void TracedValue::AppendNull() {
  WriteComma();
  data_ += "null";
}

void TracedValue::AppendString(const char* value) {
  WriteComma();
  data_ += EscapeString(value);
}

void TracedValue::BeginDictionary() {
  WriteComma();
  data_ += '{';
  first_item_ = true;
}

void TracedValue::BeginArray() {
  WriteComma();
  data_ += '[';
  first_item_ = true;
}

void TracedValue::EndDictionary() {
  data_ += '}';
  first_item_ = false;
}

void TracedValue::EndArray() {
  data_ += ']';
  first_item_ = false;
}

void TracedValue::WriteComma() {
  if (first_item_) {
    first_item_ = false;
  } else {
    data_ += ',';
  }
}

void TracedValue::WriteName(const char* name) {
  WriteComma();
  data_ += '"';
  data_ += name;
  data_ += "\":";
}

void TracedValue::AppendAsTraceFormat(std::string* out) const {
  *out += root_is_array_ ? '[' : '{';
  *out += data_;
  *out += root_is_array_ ? ']' : '}';
}

}  // namespace tracing
}  // namespace node
                                                                                                                                                                                                                                                                                                                            node-23.7.0/src/tracing/traced_value.h                                                              0000664 0000000 0000000 00000003525 14746647661 0017607 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright 2016 the V8 project authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SRC_TRACING_TRACED_VALUE_H_
#define SRC_TRACING_TRACED_VALUE_H_

#include "node.h"
#include "util.h"
#include "v8.h"

#include <cstddef>
#include <memory>
#include <string>

namespace node {
namespace tracing {

class TracedValue : public v8::ConvertableToTraceFormat {
 public:
  ~TracedValue() override = default;

  static std::unique_ptr<TracedValue> Create();
  static std::unique_ptr<TracedValue> CreateArray();

  void EndDictionary();
  void EndArray();

  // These methods assume that |name| is a long lived "quoted" string.
  void SetInteger(const char* name, int value);
  void SetDouble(const char* name, double value);
  void SetBoolean(const char* name, bool value);
  void SetNull(const char* name);
  void SetString(const char* name, const char* value);
  void SetString(const char* name, const std::string& value) {
    SetString(name, value.c_str());
  }
  void BeginDictionary(const char* name);
  void BeginArray(const char* name);

  void AppendInteger(int);
  void AppendDouble(double);
  void AppendBoolean(bool);
  void AppendNull();
  void AppendString(const char*);
  void AppendString(const std::string& value) { AppendString(value.c_str()); }
  void BeginArray();
  void BeginDictionary();

  // ConvertableToTraceFormat implementation.
  void AppendAsTraceFormat(std::string* out) const override;

  TracedValue(const TracedValue&) = delete;
  TracedValue& operator=(const TracedValue&) = delete;

 private:
  explicit TracedValue(bool root_is_array = false);

  void WriteComma();
  void WriteName(const char* name);

  std::string data_;
  bool first_item_;
  bool root_is_array_;
};

}  // namespace tracing
}  // namespace node

#endif  // SRC_TRACING_TRACED_VALUE_H_
                                                                                                                                                                           node-23.7.0/src/tty_wrap.cc                                                                         0000664 0000000 0000000 00000012017 14746647661 0015525 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

#include "tty_wrap.h"

#include "env-inl.h"
#include "handle_wrap.h"
#include "node_buffer.h"
#include "node_external_reference.h"
#include "stream_base-inl.h"
#include "stream_wrap.h"
#include "util-inl.h"

namespace node {

using v8::Array;
using v8::Context;
using v8::FunctionCallbackInfo;
using v8::FunctionTemplate;
using v8::Integer;
using v8::Isolate;
using v8::Local;
using v8::Object;
using v8::String;
using v8::Value;

void TTYWrap::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(New);
  registry->Register(GetWindowSize);
  registry->Register(SetRawMode);
  registry->Register(IsTTY);
}

void TTYWrap::Initialize(Local<Object> target,
                         Local<Value> unused,
                         Local<Context> context,
                         void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<String> ttyString = FIXED_ONE_BYTE_STRING(env->isolate(), "TTY");

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->SetClassName(ttyString);
  t->InstanceTemplate()->SetInternalFieldCount(StreamBase::kInternalFieldCount);
  t->Inherit(LibuvStreamWrap::GetConstructorTemplate(env));

  SetProtoMethodNoSideEffect(
      isolate, t, "getWindowSize", TTYWrap::GetWindowSize);
  SetProtoMethod(isolate, t, "setRawMode", SetRawMode);

  SetMethodNoSideEffect(context, target, "isTTY", IsTTY);

  Local<Value> func;
  if (t->GetFunction(context).ToLocal(&func) &&
      target->Set(context, ttyString, func).IsJust()) {
    env->set_tty_constructor_template(t);
  }
}


void TTYWrap::IsTTY(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  int fd;
  if (!args[0]->Int32Value(env->context()).To(&fd)) return;
  CHECK_GE(fd, 0);
  bool rc = uv_guess_handle(fd) == UV_TTY;
  args.GetReturnValue().Set(rc);
}


void TTYWrap::GetWindowSize(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  TTYWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
  CHECK(args[0]->IsArray());

  int width, height;
  int err = uv_tty_get_winsize(&wrap->handle_, &width, &height);

  if (err == 0) {
    Local<Array> a = args[0].As<Array>();
    a->Set(env->context(), 0, Integer::New(env->isolate(), width)).Check();
    a->Set(env->context(), 1, Integer::New(env->isolate(), height)).Check();
  }

  args.GetReturnValue().Set(err);
}


void TTYWrap::SetRawMode(const FunctionCallbackInfo<Value>& args) {
  TTYWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
  int err = uv_tty_set_mode(&wrap->handle_, args[0]->IsTrue());
  args.GetReturnValue().Set(err);
}


void TTYWrap::New(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);

  // This constructor should not be exposed to public javascript.
  // Therefore we assert that we are not trying to call this as a
  // normal function.
  CHECK(args.IsConstructCall());

  int fd;
  if (!args[0]->Int32Value(env->context()).To(&fd)) return;
  CHECK_GE(fd, 0);

  int err = 0;
  new TTYWrap(env, args.This(), fd, &err);
  if (err != 0) {
    env->CollectUVExceptionInfo(args[1], err, "uv_tty_init");
    args.GetReturnValue().SetUndefined();
  }
}


TTYWrap::TTYWrap(Environment* env,
                 Local<Object> object,
                 int fd,
                 int* init_err)
    : LibuvStreamWrap(env,
                      object,
                      reinterpret_cast<uv_stream_t*>(&handle_),
                      AsyncWrap::PROVIDER_TTYWRAP) {
  *init_err = uv_tty_init(env->event_loop(), &handle_, fd, 0);
  set_fd(fd);
  if (*init_err != 0)
    MarkAsUninitialized();
}

}  // namespace node

NODE_BINDING_CONTEXT_AWARE_INTERNAL(tty_wrap, node::TTYWrap::Initialize)
NODE_BINDING_EXTERNAL_REFERENCE(tty_wrap,
                                node::TTYWrap::RegisterExternalReferences)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/src/tty_wrap.h                                                                          0000664 0000000 0000000 00000004420 14746647661 0015366 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

#ifndef SRC_TTY_WRAP_H_
#define SRC_TTY_WRAP_H_

#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#include "uv.h"
#include "stream_wrap.h"

namespace node {

class Environment;
class ExternalReferenceRegistry;

class TTYWrap : public LibuvStreamWrap {
 public:
  static void Initialize(v8::Local<v8::Object> target,
                         v8::Local<v8::Value> unused,
                         v8::Local<v8::Context> context,
                         void* priv);
  static void RegisterExternalReferences(ExternalReferenceRegistry* registry);

  SET_NO_MEMORY_INFO()
  SET_MEMORY_INFO_NAME(TTYWrap)
  SET_SELF_SIZE(TTYWrap)

 private:
  TTYWrap(Environment* env,
          v8::Local<v8::Object> object,
          int fd,
          int* init_err);

  static void IsTTY(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void GetWindowSize(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void SetRawMode(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);

  uv_tty_t handle_;
};

}  // namespace node

#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#endif  // SRC_TTY_WRAP_H_
                                                                                                                                                                                                                                                node-23.7.0/src/udp_wrap.cc                                                                         0000664 0000000 0000000 00000062703 14746647661 0015504 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

#include "udp_wrap.h"
#include "env-inl.h"
#include "handle_wrap.h"
#include "node_buffer.h"
#include "node_errors.h"
#include "node_external_reference.h"
#include "node_sockaddr-inl.h"
#include "req_wrap-inl.h"
#include "util-inl.h"

namespace node {

using errors::TryCatchScope;
using v8::Array;
using v8::ArrayBuffer;
using v8::BackingStore;
using v8::Boolean;
using v8::Context;
using v8::DontDelete;
using v8::FunctionCallbackInfo;
using v8::FunctionTemplate;
using v8::HandleScope;
using v8::Integer;
using v8::Isolate;
using v8::Local;
using v8::MaybeLocal;
using v8::Object;
using v8::PropertyAttribute;
using v8::ReadOnly;
using v8::Signature;
using v8::Uint32;
using v8::Undefined;
using v8::Value;

namespace {
template <int (*fn)(uv_udp_t*, int)>
void SetLibuvInt32(const FunctionCallbackInfo<Value>& args) {
  UDPWrap* wrap = BaseObject::Unwrap<UDPWrap>(args.This());
  if (wrap == nullptr) {
    args.GetReturnValue().Set(UV_EBADF);
    return;
  }
  Environment* env = wrap->env();
  CHECK_EQ(args.Length(), 1);
  int flag;
  if (!args[0]->Int32Value(env->context()).To(&flag)) {
    return;
  }
  int err = fn(wrap->GetLibuvHandle(), flag);
  args.GetReturnValue().Set(err);
}
}  // namespace

class SendWrap : public ReqWrap<uv_udp_send_t> {
 public:
  SendWrap(Environment* env, Local<Object> req_wrap_obj, bool have_callback);
  inline bool have_callback() const;
  size_t msg_size;

  SET_NO_MEMORY_INFO()
  SET_MEMORY_INFO_NAME(SendWrap)
  SET_SELF_SIZE(SendWrap)

 private:
  const bool have_callback_;
};


SendWrap::SendWrap(Environment* env,
                   Local<Object> req_wrap_obj,
                   bool have_callback)
    : ReqWrap(env, req_wrap_obj, AsyncWrap::PROVIDER_UDPSENDWRAP),
      have_callback_(have_callback) {
}


bool SendWrap::have_callback() const {
  return have_callback_;
}

UDPListener::~UDPListener() {
  if (wrap_ != nullptr)
    wrap_->set_listener(nullptr);
}

UDPWrapBase::~UDPWrapBase() {
  set_listener(nullptr);
}

UDPListener* UDPWrapBase::listener() const {
  CHECK_NOT_NULL(listener_);
  return listener_;
}

void UDPWrapBase::set_listener(UDPListener* listener) {
  if (listener_ != nullptr)
    listener_->wrap_ = nullptr;
  listener_ = listener;
  if (listener_ != nullptr) {
    CHECK_NULL(listener_->wrap_);
    listener_->wrap_ = this;
  }
}

UDPWrapBase* UDPWrapBase::FromObject(Local<Object> obj) {
  CHECK_GT(obj->InternalFieldCount(), UDPWrapBase::kUDPWrapBaseField);
  return static_cast<UDPWrapBase*>(
      obj->GetAlignedPointerFromInternalField(UDPWrapBase::kUDPWrapBaseField));
}

void UDPWrapBase::AddMethods(Environment* env, Local<FunctionTemplate> t) {
  SetProtoMethod(env->isolate(), t, "recvStart", RecvStart);
  SetProtoMethod(env->isolate(), t, "recvStop", RecvStop);
}

void UDPWrapBase::RegisterExternalReferences(
    ExternalReferenceRegistry* registry) {
  registry->Register(RecvStart);
  registry->Register(RecvStop);
}

UDPWrap::UDPWrap(Environment* env, Local<Object> object)
    : HandleWrap(env,
                 object,
                 reinterpret_cast<uv_handle_t*>(&handle_),
                 AsyncWrap::PROVIDER_UDPWRAP) {
  object->SetAlignedPointerInInternalField(
      UDPWrapBase::kUDPWrapBaseField, static_cast<UDPWrapBase*>(this));

  int r = uv_udp_init(env->event_loop(), &handle_);
  CHECK_EQ(r, 0);  // can't fail anyway

  set_listener(this);
}


void UDPWrap::Initialize(Local<Object> target,
                         Local<Value> unused,
                         Local<Context> context,
                         void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();

  Local<FunctionTemplate> t = NewFunctionTemplate(isolate, New);
  t->InstanceTemplate()->SetInternalFieldCount(
      UDPWrapBase::kInternalFieldCount);

  enum PropertyAttribute attributes =
      static_cast<PropertyAttribute>(ReadOnly | DontDelete);

  Local<Signature> signature = Signature::New(isolate, t);

  Local<FunctionTemplate> get_fd_templ =
      FunctionTemplate::New(isolate, UDPWrap::GetFD, Local<Value>(), signature);

  t->PrototypeTemplate()->SetAccessorProperty(env->fd_string(),
                                              get_fd_templ,
                                              Local<FunctionTemplate>(),
                                              attributes);

  UDPWrapBase::AddMethods(env, t);
  SetProtoMethod(isolate, t, "open", Open);
  SetProtoMethod(isolate, t, "bind", Bind);
  SetProtoMethod(isolate, t, "connect", Connect);
  SetProtoMethod(isolate, t, "send", Send);
  SetProtoMethod(isolate, t, "bind6", Bind6);
  SetProtoMethod(isolate, t, "connect6", Connect6);
  SetProtoMethod(isolate, t, "send6", Send6);
  SetProtoMethod(isolate, t, "disconnect", Disconnect);
  SetProtoMethod(isolate,
                 t,
                 "getpeername",
                 GetSockOrPeerName<UDPWrap, uv_udp_getpeername>);
  SetProtoMethod(isolate,
                 t,
                 "getsockname",
                 GetSockOrPeerName<UDPWrap, uv_udp_getsockname>);
  SetProtoMethod(isolate, t, "addMembership", AddMembership);
  SetProtoMethod(isolate, t, "dropMembership", DropMembership);
  SetProtoMethod(
      isolate, t, "addSourceSpecificMembership", AddSourceSpecificMembership);
  SetProtoMethod(
      isolate, t, "dropSourceSpecificMembership", DropSourceSpecificMembership);
  SetProtoMethod(isolate, t, "setMulticastInterface", SetMulticastInterface);
  SetProtoMethod(
      isolate, t, "setMulticastTTL", SetLibuvInt32<uv_udp_set_multicast_ttl>);
  SetProtoMethod(isolate,
                 t,
                 "setMulticastLoopback",
                 SetLibuvInt32<uv_udp_set_multicast_loop>);
  SetProtoMethod(
      isolate, t, "setBroadcast", SetLibuvInt32<uv_udp_set_broadcast>);
  SetProtoMethod(isolate, t, "setTTL", SetLibuvInt32<uv_udp_set_ttl>);
  SetProtoMethod(isolate, t, "bufferSize", BufferSize);
  SetProtoMethodNoSideEffect(isolate, t, "getSendQueueSize", GetSendQueueSize);
  SetProtoMethodNoSideEffect(
      isolate, t, "getSendQueueCount", GetSendQueueCount);

  t->Inherit(HandleWrap::GetConstructorTemplate(env));

  SetConstructorFunction(context, target, "UDP", t);
  env->set_udp_constructor_function(t->GetFunction(context).ToLocalChecked());

  // Create FunctionTemplate for SendWrap
  Local<FunctionTemplate> swt =
      BaseObject::MakeLazilyInitializedJSTemplate(env);
  swt->Inherit(AsyncWrap::GetConstructorTemplate(env));
  SetConstructorFunction(context, target, "SendWrap", swt);

  Local<Object> constants = Object::New(isolate);
  NODE_DEFINE_CONSTANT(constants, UV_UDP_IPV6ONLY);
  NODE_DEFINE_CONSTANT(constants, UV_UDP_REUSEADDR);
  NODE_DEFINE_CONSTANT(constants, UV_UDP_REUSEPORT);
  target->Set(context,
              env->constants_string(),
              constants).Check();
}

void UDPWrap::RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  UDPWrapBase::RegisterExternalReferences(registry);
  registry->Register(New);
  registry->Register(GetFD);

  registry->Register(Open);
  registry->Register(Bind);
  registry->Register(Connect);
  registry->Register(Send);
  registry->Register(Bind6);
  registry->Register(Connect6);
  registry->Register(Send6);
  registry->Register(Disconnect);
  registry->Register(GetSockOrPeerName<UDPWrap, uv_udp_getpeername>);
  registry->Register(GetSockOrPeerName<UDPWrap, uv_udp_getsockname>);
  registry->Register(AddMembership);
  registry->Register(DropMembership);
  registry->Register(AddSourceSpecificMembership);
  registry->Register(DropSourceSpecificMembership);
  registry->Register(SetMulticastInterface);
  registry->Register(SetLibuvInt32<uv_udp_set_multicast_ttl>);
  registry->Register(SetLibuvInt32<uv_udp_set_multicast_loop>);
  registry->Register(SetLibuvInt32<uv_udp_set_broadcast>);
  registry->Register(SetLibuvInt32<uv_udp_set_ttl>);
  registry->Register(BufferSize);
  registry->Register(GetSendQueueSize);
  registry->Register(GetSendQueueCount);
}

void UDPWrap::New(const FunctionCallbackInfo<Value>& args) {
  CHECK(args.IsConstructCall());
  Environment* env = Environment::GetCurrent(args);
  new UDPWrap(env, args.This());
}


void UDPWrap::GetFD(const FunctionCallbackInfo<Value>& args) {
  int fd = UV_EBADF;
#if !defined(_WIN32)
  UDPWrap* wrap = Unwrap<UDPWrap>(args.This());
  if (wrap != nullptr)
    uv_fileno(reinterpret_cast<uv_handle_t*>(&wrap->handle_), &fd);
#endif
  args.GetReturnValue().Set(fd);
}

int sockaddr_for_family(int address_family,
                        const char* address,
                        const unsigned short port,
                        struct sockaddr_storage* addr) {
  switch (address_family) {
    case AF_INET:
      return uv_ip4_addr(address, port, reinterpret_cast<sockaddr_in*>(addr));
    case AF_INET6:
      return uv_ip6_addr(address, port, reinterpret_cast<sockaddr_in6*>(addr));
    default:
      UNREACHABLE("unexpected address family");
  }
}

void UDPWrap::DoBind(const FunctionCallbackInfo<Value>& args, int family) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));

  // bind(ip, port, flags)
  CHECK_EQ(args.Length(), 3);

  node::Utf8Value address(args.GetIsolate(), args[0]);
  Local<Context> ctx = args.GetIsolate()->GetCurrentContext();
  uint32_t port, flags;
  if (!args[1]->Uint32Value(ctx).To(&port) ||
      !args[2]->Uint32Value(ctx).To(&flags))
    return;
  struct sockaddr_storage addr_storage;
  int err = sockaddr_for_family(family, address.out(), port, &addr_storage);
  if (err == 0) {
    err = uv_udp_bind(&wrap->handle_,
                      reinterpret_cast<const sockaddr*>(&addr_storage),
                      flags);
  }

  if (err == 0)
    wrap->listener()->OnAfterBind();

  args.GetReturnValue().Set(err);
}


void UDPWrap::DoConnect(const FunctionCallbackInfo<Value>& args, int family) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 2);

  node::Utf8Value address(args.GetIsolate(), args[0]);
  Local<Context> ctx = args.GetIsolate()->GetCurrentContext();
  uint32_t port;
  if (!args[1]->Uint32Value(ctx).To(&port))
    return;
  struct sockaddr_storage addr_storage;
  int err = sockaddr_for_family(family, address.out(), port, &addr_storage);
  if (err == 0) {
    err = uv_udp_connect(&wrap->handle_,
                         reinterpret_cast<const sockaddr*>(&addr_storage));
  }

  args.GetReturnValue().Set(err);
}


void UDPWrap::Open(const FunctionCallbackInfo<Value>& args) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));
  CHECK(args[0]->IsNumber());
  int fd = static_cast<int>(args[0].As<Integer>()->Value());
  int err = uv_udp_open(&wrap->handle_, fd);

  args.GetReturnValue().Set(err);
}


void UDPWrap::Bind(const FunctionCallbackInfo<Value>& args) {
  DoBind(args, AF_INET);
}


void UDPWrap::Bind6(const FunctionCallbackInfo<Value>& args) {
  DoBind(args, AF_INET6);
}


void UDPWrap::BufferSize(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));

  CHECK(args[0]->IsUint32());
  CHECK(args[1]->IsBoolean());
  bool is_recv = args[1].As<Boolean>()->Value();
  const char* uv_func_name = is_recv ? "uv_recv_buffer_size" :
                                       "uv_send_buffer_size";

  if (!args[0]->IsInt32()) {
    env->CollectUVExceptionInfo(args[2], UV_EINVAL, uv_func_name);
    return args.GetReturnValue().SetUndefined();
  }

  uv_handle_t* handle = reinterpret_cast<uv_handle_t*>(&wrap->handle_);
  int size = static_cast<int>(args[0].As<Uint32>()->Value());
  int err;

  if (is_recv)
    err = uv_recv_buffer_size(handle, &size);
  else
    err = uv_send_buffer_size(handle, &size);

  if (err != 0) {
    env->CollectUVExceptionInfo(args[2], err, uv_func_name);
    return args.GetReturnValue().SetUndefined();
  }

  args.GetReturnValue().Set(size);
}


void UDPWrap::Connect(const FunctionCallbackInfo<Value>& args) {
  DoConnect(args, AF_INET);
}


void UDPWrap::Connect6(const FunctionCallbackInfo<Value>& args) {
  DoConnect(args, AF_INET6);
}


void UDPWrap::Disconnect(const FunctionCallbackInfo<Value>& args) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 0);

  int err = uv_udp_connect(&wrap->handle_, nullptr);

  args.GetReturnValue().Set(err);
}

void UDPWrap::SetMulticastInterface(const FunctionCallbackInfo<Value>& args) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 1);
  CHECK(args[0]->IsString());

  Utf8Value iface(args.GetIsolate(), args[0]);

  const char* iface_cstr = *iface;

  int err = uv_udp_set_multicast_interface(&wrap->handle_, iface_cstr);
  args.GetReturnValue().Set(err);
}

void UDPWrap::SetMembership(const FunctionCallbackInfo<Value>& args,
                            uv_membership membership) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 2);

  node::Utf8Value address(args.GetIsolate(), args[0]);
  node::Utf8Value iface(args.GetIsolate(), args[1]);

  const char* iface_cstr = *iface;
  if (args[1]->IsUndefined() || args[1]->IsNull()) {
      iface_cstr = nullptr;
  }

  int err = uv_udp_set_membership(&wrap->handle_,
                                  *address,
                                  iface_cstr,
                                  membership);
  args.GetReturnValue().Set(err);
}


void UDPWrap::AddMembership(const FunctionCallbackInfo<Value>& args) {
  SetMembership(args, UV_JOIN_GROUP);
}


void UDPWrap::DropMembership(const FunctionCallbackInfo<Value>& args) {
  SetMembership(args, UV_LEAVE_GROUP);
}

void UDPWrap::SetSourceMembership(const FunctionCallbackInfo<Value>& args,
                                  uv_membership membership) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));

  CHECK_EQ(args.Length(), 3);

  node::Utf8Value source_address(args.GetIsolate(), args[0]);
  node::Utf8Value group_address(args.GetIsolate(), args[1]);
  node::Utf8Value iface(args.GetIsolate(), args[2]);

  if (*iface == nullptr) return;
  const char* iface_cstr = *iface;
  if (args[2]->IsUndefined() || args[2]->IsNull()) {
    iface_cstr = nullptr;
  }

  int err = uv_udp_set_source_membership(&wrap->handle_,
                                         *group_address,
                                         iface_cstr,
                                         *source_address,
                                         membership);
  args.GetReturnValue().Set(err);
}

void UDPWrap::AddSourceSpecificMembership(
  const FunctionCallbackInfo<Value>& args) {
  SetSourceMembership(args, UV_JOIN_GROUP);
}


void UDPWrap::DropSourceSpecificMembership(
  const FunctionCallbackInfo<Value>& args) {
  SetSourceMembership(args, UV_LEAVE_GROUP);
}


void UDPWrap::DoSend(const FunctionCallbackInfo<Value>& args, int family) {
  Environment* env = Environment::GetCurrent(args);

  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));

  CHECK(args.Length() == 4 || args.Length() == 6);
  CHECK(args[0]->IsObject());
  CHECK(args[1]->IsArray());
  CHECK(args[2]->IsUint32());

  bool sendto = args.Length() == 6;
  if (sendto) {
    // send(req, list, list.length, port, address, hasCallback)
    CHECK(args[3]->IsUint32());
    CHECK(args[4]->IsString());
    CHECK(args[5]->IsBoolean());
  } else {
    // send(req, list, list.length, hasCallback)
    CHECK(args[3]->IsBoolean());
  }

  Local<Array> chunks = args[1].As<Array>();
  // it is faster to fetch the length of the
  // array in js-land
  size_t count = args[2].As<Uint32>()->Value();

  MaybeStackBuffer<uv_buf_t, 16> bufs(count);

  // construct uv_buf_t array
  for (size_t i = 0; i < count; i++) {
    Local<Value> chunk;
    if (!chunks->Get(env->context(), i).ToLocal(&chunk)) return;

    size_t length = Buffer::Length(chunk);

    bufs[i] = uv_buf_init(Buffer::Data(chunk), length);
  }

  int err = 0;
  struct sockaddr_storage addr_storage;
  sockaddr* addr = nullptr;
  if (sendto) {
    const unsigned short port = args[3].As<Uint32>()->Value();
    node::Utf8Value address(env->isolate(), args[4]);
    err = sockaddr_for_family(family, address.out(), port, &addr_storage);
    if (err == 0)
      addr = reinterpret_cast<sockaddr*>(&addr_storage);
  }

  if (err == 0) {
    wrap->current_send_req_wrap_ = args[0].As<Object>();
    wrap->current_send_has_callback_ =
        sendto ? args[5]->IsTrue() : args[3]->IsTrue();

    err = static_cast<int>(wrap->Send(*bufs, count, addr));

    wrap->current_send_req_wrap_.Clear();
    wrap->current_send_has_callback_ = false;
  }

  args.GetReturnValue().Set(err);
}

ssize_t UDPWrap::Send(uv_buf_t* bufs_ptr,
                      size_t count,
                      const sockaddr* addr) {
  if (IsHandleClosing()) return UV_EBADF;

  size_t msg_size = 0;
  for (size_t i = 0; i < count; i++)
    msg_size += bufs_ptr[i].len;

  int err = 0;
  if (!env()->options()->test_udp_no_try_send) [[unlikely]] {
    err = uv_udp_try_send(&handle_, bufs_ptr, count, addr);
    if (err == UV_ENOSYS || err == UV_EAGAIN) {
      err = 0;
    } else if (err >= 0) {
      size_t sent = err;
      while (count > 0 && bufs_ptr->len <= sent) {
        sent -= bufs_ptr->len;
        bufs_ptr++;
        count--;
      }
      if (count > 0) {
        CHECK_LT(sent, bufs_ptr->len);
        bufs_ptr->base += sent;
        bufs_ptr->len -= sent;
      } else {
        CHECK_EQ(static_cast<size_t>(err), msg_size);
        // + 1 so that the JS side can distinguish 0-length async sends from
        // 0-length sync sends.
        return msg_size + 1;
      }
    }
  }

  if (err == 0) {
    AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(this);
    ReqWrap<uv_udp_send_t>* req_wrap = listener()->CreateSendWrap(msg_size);
    if (req_wrap == nullptr) return UV_ENOSYS;

    err = req_wrap->Dispatch(
        uv_udp_send,
        &handle_,
        bufs_ptr,
        count,
        addr,
        uv_udp_send_cb{[](uv_udp_send_t* req, int status) {
          UDPWrap* self = ContainerOf(&UDPWrap::handle_, req->handle);
          self->listener()->OnSendDone(
              ReqWrap<uv_udp_send_t>::from_req(req), status);
        }});
    if (err)
      delete req_wrap;
  }

  return err;
}


ReqWrap<uv_udp_send_t>* UDPWrap::CreateSendWrap(size_t msg_size) {
  SendWrap* req_wrap = new SendWrap(env(),
                                    current_send_req_wrap_,
                                    current_send_has_callback_);
  req_wrap->msg_size = msg_size;
  return req_wrap;
}


void UDPWrap::Send(const FunctionCallbackInfo<Value>& args) {
  DoSend(args, AF_INET);
}


void UDPWrap::Send6(const FunctionCallbackInfo<Value>& args) {
  DoSend(args, AF_INET6);
}


AsyncWrap* UDPWrap::GetAsyncWrap() {
  return this;
}

SocketAddress UDPWrap::GetPeerName() {
  return SocketAddress::FromPeerName(handle_);
}

SocketAddress UDPWrap::GetSockName() {
  return SocketAddress::FromSockName(handle_);
}

void UDPWrapBase::RecvStart(const FunctionCallbackInfo<Value>& args) {
  UDPWrapBase* wrap = UDPWrapBase::FromObject(args.This());
  args.GetReturnValue().Set(wrap == nullptr ? UV_EBADF : wrap->RecvStart());
}

int UDPWrap::RecvStart() {
  if (IsHandleClosing()) return UV_EBADF;
  int err = uv_udp_recv_start(&handle_, OnAlloc, OnRecv);
  // UV_EALREADY means that the socket is already bound but that's okay
  if (err == UV_EALREADY)
    err = 0;
  return err;
}


void UDPWrapBase::RecvStop(const FunctionCallbackInfo<Value>& args) {
  UDPWrapBase* wrap = UDPWrapBase::FromObject(args.This());
  args.GetReturnValue().Set(wrap == nullptr ? UV_EBADF : wrap->RecvStop());
}

int UDPWrap::RecvStop() {
  if (IsHandleClosing()) return UV_EBADF;
  return uv_udp_recv_stop(&handle_);
}


void UDPWrap::OnSendDone(ReqWrap<uv_udp_send_t>* req, int status) {
  BaseObjectPtr<SendWrap> req_wrap{static_cast<SendWrap*>(req)};
  if (req_wrap->have_callback()) {
    Environment* env = req_wrap->env();
    HandleScope handle_scope(env->isolate());
    Context::Scope context_scope(env->context());
    Local<Value> arg[] = {
      Integer::New(env->isolate(), status),
      Integer::New(env->isolate(), req_wrap->msg_size),
    };
    req_wrap->MakeCallback(env->oncomplete_string(), 2, arg);
  }
}


void UDPWrap::OnAlloc(uv_handle_t* handle,
                      size_t suggested_size,
                      uv_buf_t* buf) {
  UDPWrap* wrap = ContainerOf(&UDPWrap::handle_,
                              reinterpret_cast<uv_udp_t*>(handle));
  *buf = wrap->listener()->OnAlloc(suggested_size);
}

uv_buf_t UDPWrap::OnAlloc(size_t suggested_size) {
  return env()->allocate_managed_buffer(suggested_size);
}

void UDPWrap::OnRecv(uv_udp_t* handle,
                     ssize_t nread,
                     const uv_buf_t* buf,
                     const sockaddr* addr,
                     unsigned int flags) {
  UDPWrap* wrap = ContainerOf(&UDPWrap::handle_, handle);
  wrap->listener()->OnRecv(nread, *buf, addr, flags);
}

void UDPWrap::OnRecv(ssize_t nread,
                     const uv_buf_t& buf_,
                     const sockaddr* addr,
                     unsigned int flags) {
  Environment* env = this->env();
  Isolate* isolate = env->isolate();
  std::unique_ptr<BackingStore> bs = env->release_managed_buffer(buf_);
  if (nread == 0 && addr == nullptr) {
    return;
  }

  HandleScope handle_scope(isolate);
  Context::Scope context_scope(env->context());

  Local<Value> argv[] = {
      Integer::New(isolate, static_cast<int32_t>(nread)),
      object(),
      Undefined(isolate),
      Undefined(isolate)};

  if (nread < 0) {
    MakeCallback(env->onmessage_string(), arraysize(argv), argv);
    return;
  } else if (nread == 0) {
    bs = ArrayBuffer::NewBackingStore(isolate, 0);
  } else if (static_cast<size_t>(nread) != bs->ByteLength()) {
    CHECK_LE(static_cast<size_t>(nread), bs->ByteLength());
    std::unique_ptr<BackingStore> old_bs = std::move(bs);
    bs = ArrayBuffer::NewBackingStore(isolate, nread);
    memcpy(static_cast<char*>(bs->Data()),
           static_cast<char*>(old_bs->Data()),
           nread);
  }

  Local<Object> address;
  {
    bool has_caught = false;
    {
      TryCatchScope try_catch(env);
      if (!AddressToJS(env, addr).ToLocal(&address)) {
        DCHECK(try_catch.HasCaught() && !try_catch.HasTerminated());
        argv[2] = try_catch.Exception();
        DCHECK(!argv[2].IsEmpty());
        has_caught = true;
      }
    }
    if (has_caught) {
      DCHECK(!argv[2].IsEmpty());
      MakeCallback(env->onerror_string(), arraysize(argv), argv);
      return;
    }
  }

  Local<ArrayBuffer> ab = ArrayBuffer::New(isolate, std::move(bs));
  {
    bool has_caught = false;
    {
      TryCatchScope try_catch(env);
      if (!Buffer::New(env, ab, 0, ab->ByteLength()).ToLocal(&argv[2])) {
        DCHECK(try_catch.HasCaught() && !try_catch.HasTerminated());
        argv[2] = try_catch.Exception();
        DCHECK(!argv[2].IsEmpty());
        has_caught = true;
      }
    }
    if (has_caught) {
      DCHECK(!argv[2].IsEmpty());
      MakeCallback(env->onerror_string(), arraysize(argv), argv);
      return;
    }
  }

  argv[3] = address;
  MakeCallback(env->onmessage_string(), arraysize(argv), argv);
}

MaybeLocal<Object> UDPWrap::Instantiate(Environment* env,
                                        AsyncWrap* parent,
                                        UDPWrap::SocketType type) {
  AsyncHooks::DefaultTriggerAsyncIdScope trigger_scope(parent);

  // If this assert fires then Initialize hasn't been called yet.
  CHECK_EQ(env->udp_constructor_function().IsEmpty(), false);
  return env->udp_constructor_function()->NewInstance(env->context());
}

void UDPWrap::GetSendQueueSize(const FunctionCallbackInfo<Value>& args) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));

  size_t size = uv_udp_get_send_queue_size(&wrap->handle_);
  args.GetReturnValue().Set(static_cast<double>(size));
}

void UDPWrap::GetSendQueueCount(const FunctionCallbackInfo<Value>& args) {
  UDPWrap* wrap;
  ASSIGN_OR_RETURN_UNWRAP(
      &wrap, args.This(), args.GetReturnValue().Set(UV_EBADF));

  size_t count = uv_udp_get_send_queue_count(&wrap->handle_);
  args.GetReturnValue().Set(static_cast<double>(count));
}

}  // namespace node

NODE_BINDING_CONTEXT_AWARE_INTERNAL(udp_wrap, node::UDPWrap::Initialize)
NODE_BINDING_EXTERNAL_REFERENCE(udp_wrap,
                                node::UDPWrap::RegisterExternalReferences)
                                                             node-23.7.0/src/udp_wrap.h                                                                          0000664 0000000 0000000 00000021300 14746647661 0015332 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

#ifndef SRC_UDP_WRAP_H_
#define SRC_UDP_WRAP_H_

#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#include "handle_wrap.h"
#include "req_wrap.h"
#include "node_sockaddr.h"
#include "uv.h"
#include "v8.h"

namespace node {

class ExternalReferenceRegistry;
class UDPWrapBase;

// A listener that can be attached to an `UDPWrapBase` object and generally
// manages its I/O activity. This is similar to `StreamListener`.
class UDPListener {
 public:
  virtual ~UDPListener();

  // Called right before data is received from the socket. Must return a
  // buffer suitable for reading data into, that is then passed to OnRecv.
  virtual uv_buf_t OnAlloc(size_t suggested_size) = 0;

  // Called right after data is received from the socket, and includes
  // information about the source address. If `nread` is negative, an error
  // has occurred, and it represents a libuv error code.
  virtual void OnRecv(ssize_t nread,
                      const uv_buf_t& buf,
                      const sockaddr* addr,
                      unsigned int flags) = 0;

  // Called when an asynchronous request for writing data is created.
  // The `msg_size` value contains the total size of the data to be sent,
  // but may be ignored by the implementation of this Method.
  // The return value is later passed to OnSendDone.
  virtual ReqWrap<uv_udp_send_t>* CreateSendWrap(size_t msg_size) = 0;

  // Called when an asynchronous request for writing data has finished.
  // If status is negative, an error has occurred, and it represents a libuv
  // error code.
  virtual void OnSendDone(ReqWrap<uv_udp_send_t>* wrap, int status) = 0;

  // Optional callback that is called after the socket has been bound.
  virtual void OnAfterBind() {}

  inline UDPWrapBase* udp() const { return wrap_; }

 protected:
  UDPWrapBase* wrap_ = nullptr;

  friend class UDPWrapBase;
};

class UDPWrapBase {
 public:
  // While UDPWrapBase itself does not extend from HandleWrap, classes
  // derived from it will (like UDPWrap)
  enum InternalFields {
    kUDPWrapBaseField = HandleWrap::kInternalFieldCount,
    kInternalFieldCount
  };
  virtual ~UDPWrapBase();

  // Start emitting OnAlloc() + OnRecv() events on the listener.
  virtual int RecvStart() = 0;

  // Stop emitting OnAlloc() + OnRecv() events on the listener.
  virtual int RecvStop() = 0;

  // Send a chunk of data over this socket. This may call CreateSendWrap()
  // on the listener if an async transmission is necessary.
  virtual ssize_t Send(uv_buf_t* bufs,
                       size_t nbufs,
                       const sockaddr* addr) = 0;

  virtual SocketAddress GetPeerName() = 0;
  virtual SocketAddress GetSockName() = 0;

  // Returns an AsyncWrap object with the same lifetime as this object.
  virtual AsyncWrap* GetAsyncWrap() = 0;

  void set_listener(UDPListener* listener);
  UDPListener* listener() const;

  static UDPWrapBase* FromObject(v8::Local<v8::Object> obj);

  static void RecvStart(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void RecvStop(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void AddMethods(Environment* env, v8::Local<v8::FunctionTemplate> t);
  static void RegisterExternalReferences(ExternalReferenceRegistry* registry);

 private:
  UDPListener* listener_ = nullptr;
};

class UDPWrap final : public HandleWrap,
                      public UDPWrapBase,
                      public UDPListener {
 public:
  enum SocketType {
    SOCKET
  };
  static void Initialize(v8::Local<v8::Object> target,
                         v8::Local<v8::Value> unused,
                         v8::Local<v8::Context> context,
                         void* priv);
  static void RegisterExternalReferences(ExternalReferenceRegistry* registry);
  static void GetFD(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void New(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void Open(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void Bind(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void Connect(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void Send(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void Bind6(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void Connect6(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void Send6(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void Disconnect(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void AddMembership(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void DropMembership(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void AddSourceSpecificMembership(
      const v8::FunctionCallbackInfo<v8::Value>& args);
  static void DropSourceSpecificMembership(
      const v8::FunctionCallbackInfo<v8::Value>& args);
  static void SetMulticastInterface(
      const v8::FunctionCallbackInfo<v8::Value>& args);
  static void BufferSize(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void GetSendQueueSize(const v8::FunctionCallbackInfo<v8::Value>& args);
  static void GetSendQueueCount(
      const v8::FunctionCallbackInfo<v8::Value>& args);

  // UDPListener implementation
  uv_buf_t OnAlloc(size_t suggested_size) override;
  void OnRecv(ssize_t nread,
              const uv_buf_t& buf,
              const sockaddr* addr,
              unsigned int flags) override;
  ReqWrap<uv_udp_send_t>* CreateSendWrap(size_t msg_size) override;
  void OnSendDone(ReqWrap<uv_udp_send_t>* wrap, int status) override;

  // UDPWrapBase implementation
  int RecvStart() override;
  int RecvStop() override;
  ssize_t Send(uv_buf_t* bufs,
               size_t nbufs,
               const sockaddr* addr) override;

  SocketAddress GetPeerName() override;
  SocketAddress GetSockName() override;

  AsyncWrap* GetAsyncWrap() override;

  inline uv_udp_t* GetLibuvHandle() { return &handle_; }

  static v8::MaybeLocal<v8::Object> Instantiate(Environment* env,
                                                AsyncWrap* parent,
                                                SocketType type);
  SET_NO_MEMORY_INFO()
  SET_MEMORY_INFO_NAME(UDPWrap)
  SET_SELF_SIZE(UDPWrap)

 private:
  typedef uv_udp_t HandleType;

  template <typename T,
            int (*F)(const typename T::HandleType*, sockaddr*, int*)>
  friend void GetSockOrPeerName(const v8::FunctionCallbackInfo<v8::Value>&);

  UDPWrap(Environment* env, v8::Local<v8::Object> object);

  static void DoBind(const v8::FunctionCallbackInfo<v8::Value>& args,
                     int family);
  static void DoConnect(const v8::FunctionCallbackInfo<v8::Value>& args,
                     int family);
  static void DoSend(const v8::FunctionCallbackInfo<v8::Value>& args,
                     int family);
  static void SetMembership(const v8::FunctionCallbackInfo<v8::Value>& args,
                            uv_membership membership);
  static void SetSourceMembership(
      const v8::FunctionCallbackInfo<v8::Value>& args,
      uv_membership membership);

  static void OnAlloc(uv_handle_t* handle,
                      size_t suggested_size,
                      uv_buf_t* buf);
  static void OnRecv(uv_udp_t* handle,
                     ssize_t nread,
                     const uv_buf_t* buf,
                     const struct sockaddr* addr,
                     unsigned int flags);

  uv_udp_t handle_;

  bool current_send_has_callback_;
  v8::Local<v8::Object> current_send_req_wrap_;
};

int sockaddr_for_family(int address_family,
                        const char* address,
                        const unsigned short port,
                        sockaddr_storage* addr);

}  // namespace node

#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#endif  // SRC_UDP_WRAP_H_
                                                                                                                                                                                                                                                                                                                                node-23.7.0/src/undici_version.h                                                                    0000664 0000000 0000000 00000000344 14746647661 0016536 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // This is an auto generated file, please do not edit.
// Refer to tools/dep_updaters/update-undici.sh
#ifndef SRC_UNDICI_VERSION_H_
#define SRC_UNDICI_VERSION_H_
#define UNDICI_VERSION "6.21.1"
#endif  // SRC_UNDICI_VERSION_H_
                                                                                                                                                                                                                                                                                            node-23.7.0/src/util-inl.h                                                                          0000664 0000000 0000000 00000045165 14746647661 0015265 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

#ifndef SRC_UTIL_INL_H_
#define SRC_UTIL_INL_H_

#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#include <cmath>
#include <cstring>
#include <locale>
#include <regex>  // NOLINT(build/c++11)
#include "node_revert.h"
#include "util.h"

#define CHAR_TEST(bits, name, expr)                                           \
  template <typename T>                                                       \
  bool name(const T ch) {                                                     \
    static_assert(sizeof(ch) >= (bits) / 8,                                   \
                  "Character must be wider than " #bits " bits");             \
    return (expr);                                                            \
  }

namespace node {

template <typename T>
ListNode<T>::ListNode() : prev_(this), next_(this) {}

template <typename T>
ListNode<T>::~ListNode() {
  Remove();
}

template <typename T>
void ListNode<T>::Remove() {
  prev_->next_ = next_;
  next_->prev_ = prev_;
  prev_ = this;
  next_ = this;
}

template <typename T>
bool ListNode<T>::IsEmpty() const {
  return prev_ == this;
}

template <typename T, ListNode<T> (T::*M)>
ListHead<T, M>::Iterator::Iterator(ListNode<T>* node) : node_(node) {}

template <typename T, ListNode<T> (T::*M)>
T* ListHead<T, M>::Iterator::operator*() const {
  return ContainerOf(M, node_);
}

template <typename T, ListNode<T> (T::*M)>
const typename ListHead<T, M>::Iterator&
ListHead<T, M>::Iterator::operator++() {
  node_ = node_->next_;
  return *this;
}

template <typename T, ListNode<T> (T::*M)>
bool ListHead<T, M>::Iterator::operator!=(const Iterator& that) const {
  return node_ != that.node_;
}

template <typename T, ListNode<T> (T::*M)>
ListHead<T, M>::~ListHead() {
  while (IsEmpty() == false)
    head_.next_->Remove();
}

template <typename T, ListNode<T> (T::*M)>
void ListHead<T, M>::PushBack(T* element) {
  ListNode<T>* that = &(element->*M);
  head_.prev_->next_ = that;
  that->prev_ = head_.prev_;
  that->next_ = &head_;
  head_.prev_ = that;
}

template <typename T, ListNode<T> (T::*M)>
void ListHead<T, M>::PushFront(T* element) {
  ListNode<T>* that = &(element->*M);
  head_.next_->prev_ = that;
  that->prev_ = &head_;
  that->next_ = head_.next_;
  head_.next_ = that;
}

template <typename T, ListNode<T> (T::*M)>
bool ListHead<T, M>::IsEmpty() const {
  return head_.IsEmpty();
}

template <typename T, ListNode<T> (T::*M)>
T* ListHead<T, M>::PopFront() {
  if (IsEmpty())
    return nullptr;
  ListNode<T>* node = head_.next_;
  node->Remove();
  return ContainerOf(M, node);
}

template <typename T, ListNode<T> (T::*M)>
typename ListHead<T, M>::Iterator ListHead<T, M>::begin() const {
  return Iterator(head_.next_);
}

template <typename T, ListNode<T> (T::*M)>
typename ListHead<T, M>::Iterator ListHead<T, M>::end() const {
  return Iterator(const_cast<ListNode<T>*>(&head_));
}

template <typename Inner, typename Outer>
constexpr uintptr_t OffsetOf(Inner Outer::*field) {
  return reinterpret_cast<uintptr_t>(&(static_cast<Outer*>(nullptr)->*field));
}

template <typename Inner, typename Outer>
ContainerOfHelper<Inner, Outer>::ContainerOfHelper(Inner Outer::*field,
                                                   Inner* pointer)
    : pointer_(
        reinterpret_cast<Outer*>(
            reinterpret_cast<uintptr_t>(pointer) - OffsetOf(field))) {}

template <typename Inner, typename Outer>
template <typename TypeName>
ContainerOfHelper<Inner, Outer>::operator TypeName*() const {
  return static_cast<TypeName*>(pointer_);
}

template <typename Inner, typename Outer>
constexpr ContainerOfHelper<Inner, Outer> ContainerOf(Inner Outer::*field,
                                                      Inner* pointer) {
  return ContainerOfHelper<Inner, Outer>(field, pointer);
}

inline v8::Local<v8::String> OneByteString(v8::Isolate* isolate,
                                           const char* data,
                                           int length) {
  return v8::String::NewFromOneByte(isolate,
                                    reinterpret_cast<const uint8_t*>(data),
                                    v8::NewStringType::kNormal,
                                    length).ToLocalChecked();
}

inline v8::Local<v8::String> OneByteString(v8::Isolate* isolate,
                                           const signed char* data,
                                           int length) {
  return v8::String::NewFromOneByte(isolate,
                                    reinterpret_cast<const uint8_t*>(data),
                                    v8::NewStringType::kNormal,
                                    length).ToLocalChecked();
}

inline v8::Local<v8::String> OneByteString(v8::Isolate* isolate,
                                           const unsigned char* data,
                                           int length) {
  return v8::String::NewFromOneByte(
             isolate, data, v8::NewStringType::kNormal, length)
      .ToLocalChecked();
}

inline v8::Local<v8::String> OneByteString(v8::Isolate* isolate,
                                           std::string_view str) {
  return OneByteString(isolate, str.data(), str.size());
}

char ToLower(char c) {
  return std::tolower(c, std::locale::classic());
}

std::string ToLower(const std::string& in) {
  std::string out(in.size(), 0);
  for (size_t i = 0; i < in.size(); ++i)
    out[i] = ToLower(in[i]);
  return out;
}

char ToUpper(char c) {
  return std::toupper(c, std::locale::classic());
}

std::string ToUpper(const std::string& in) {
  std::string out(in.size(), 0);
  for (size_t i = 0; i < in.size(); ++i)
    out[i] = ToUpper(in[i]);
  return out;
}

bool StringEqualNoCase(const char* a, const char* b) {
  while (ToLower(*a) == ToLower(*b++)) {
    if (*a++ == '\0')
      return true;
  }
  return false;
}

bool StringEqualNoCaseN(const char* a, const char* b, size_t length) {
  for (size_t i = 0; i < length; i++) {
    if (ToLower(a[i]) != ToLower(b[i]))
      return false;
    if (a[i] == '\0')
      return true;
  }
  return true;
}

template <typename T>
inline T MultiplyWithOverflowCheck(T a, T b) {
  auto ret = a * b;
  if (a != 0)
    CHECK_EQ(b, ret / a);

  return ret;
}

// These should be used in our code as opposed to the native
// versions as they abstract out some platform and or
// compiler version specific functionality.
// malloc(0) and realloc(ptr, 0) have implementation-defined behavior in
// that the standard allows them to either return a unique pointer or a
// nullptr for zero-sized allocation requests.  Normalize by always using
// a nullptr.
template <typename T>
T* UncheckedRealloc(T* pointer, size_t n) {
  size_t full_size = MultiplyWithOverflowCheck(sizeof(T), n);

  if (full_size == 0) {
    free(pointer);
    return nullptr;
  }

  void* allocated = realloc(pointer, full_size);

  if (allocated == nullptr) [[unlikely]] {
    // Tell V8 that memory is low and retry.
    LowMemoryNotification();
    allocated = realloc(pointer, full_size);
  }

  return static_cast<T*>(allocated);
}

// As per spec realloc behaves like malloc if passed nullptr.
template <typename T>
inline T* UncheckedMalloc(size_t n) {
  return UncheckedRealloc<T>(nullptr, n);
}

template <typename T>
inline T* UncheckedCalloc(size_t n) {
  if (MultiplyWithOverflowCheck(sizeof(T), n) == 0) return nullptr;
  return static_cast<T*>(calloc(n, sizeof(T)));
}

template <typename T>
inline T* Realloc(T* pointer, size_t n) {
  T* ret = UncheckedRealloc(pointer, n);
  CHECK_IMPLIES(n > 0, ret != nullptr);
  return ret;
}

template <typename T>
inline T* Malloc(size_t n) {
  T* ret = UncheckedMalloc<T>(n);
  CHECK_IMPLIES(n > 0, ret != nullptr);
  return ret;
}

template <typename T>
inline T* Calloc(size_t n) {
  T* ret = UncheckedCalloc<T>(n);
  CHECK_IMPLIES(n > 0, ret != nullptr);
  return ret;
}

// Shortcuts for char*.
inline char* Malloc(size_t n) { return Malloc<char>(n); }
inline char* Calloc(size_t n) { return Calloc<char>(n); }
inline char* UncheckedMalloc(size_t n) { return UncheckedMalloc<char>(n); }
inline char* UncheckedCalloc(size_t n) { return UncheckedCalloc<char>(n); }

// This is a helper in the .cc file so including util-inl.h doesn't include more
// headers than we really need to.
void ThrowErrStringTooLong(v8::Isolate* isolate);

struct ArrayIterationData {
  std::vector<v8::Global<v8::Value>>* out;
  v8::Isolate* isolate = nullptr;
};

inline v8::Array::CallbackResult PushItemToVector(uint32_t index,
                                                  v8::Local<v8::Value> element,
                                                  void* data) {
  auto vec = static_cast<ArrayIterationData*>(data)->out;
  auto isolate = static_cast<ArrayIterationData*>(data)->isolate;
  vec->push_back(v8::Global<v8::Value>(isolate, element));
  return v8::Array::CallbackResult::kContinue;
}

v8::Maybe<void> FromV8Array(v8::Local<v8::Context> context,
                            v8::Local<v8::Array> js_array,
                            std::vector<v8::Global<v8::Value>>* out) {
  uint32_t count = js_array->Length();
  out->reserve(count);
  ArrayIterationData data{out, context->GetIsolate()};
  return js_array->Iterate(context, PushItemToVector, &data);
}

v8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,
                                    std::string_view str,
                                    v8::Isolate* isolate) {
  if (isolate == nullptr) isolate = context->GetIsolate();
  if (str.size() >= static_cast<size_t>(v8::String::kMaxLength)) [[unlikely]] {
    // V8 only has a TODO comment about adding an exception when the maximum
    // string size is exceeded.
    ThrowErrStringTooLong(isolate);
    return v8::MaybeLocal<v8::Value>();
  }

  return v8::String::NewFromUtf8(
             isolate, str.data(), v8::NewStringType::kNormal, str.size())
      .FromMaybe(v8::Local<v8::String>());
}

template <typename T>
v8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,
                                    const std::vector<T>& vec,
                                    v8::Isolate* isolate) {
  if (isolate == nullptr) isolate = context->GetIsolate();
  v8::EscapableHandleScope handle_scope(isolate);

  MaybeStackBuffer<v8::Local<v8::Value>, 128> arr(vec.size());
  arr.SetLength(vec.size());
  for (size_t i = 0; i < vec.size(); ++i) {
    if (!ToV8Value(context, vec[i], isolate).ToLocal(&arr[i]))
      return v8::MaybeLocal<v8::Value>();
  }

  return handle_scope.Escape(v8::Array::New(isolate, arr.out(), arr.length()));
}

template <typename T>
v8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,
                                    const std::set<T>& set,
                                    v8::Isolate* isolate) {
  if (isolate == nullptr) isolate = context->GetIsolate();
  v8::Local<v8::Set> set_js = v8::Set::New(isolate);
  v8::HandleScope handle_scope(isolate);

  for (const T& entry : set) {
    v8::Local<v8::Value> value;
    if (!ToV8Value(context, entry, isolate).ToLocal(&value))
      return {};
    if (set_js->Add(context, value).IsEmpty())
      return {};
  }

  return set_js;
}

template <typename T, typename U>
v8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,
                                    const std::unordered_map<T, U>& map,
                                    v8::Isolate* isolate) {
  if (isolate == nullptr) isolate = context->GetIsolate();
  v8::EscapableHandleScope handle_scope(isolate);

  v8::Local<v8::Map> ret = v8::Map::New(isolate);
  for (const auto& item : map) {
    v8::Local<v8::Value> first, second;
    if (!ToV8Value(context, item.first, isolate).ToLocal(&first) ||
        !ToV8Value(context, item.second, isolate).ToLocal(&second) ||
        ret->Set(context, first, second).IsEmpty()) {
      return v8::MaybeLocal<v8::Value>();
    }
  }

  return handle_scope.Escape(ret);
}

template <typename T, typename >
v8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,
                                    const T& number,
                                    v8::Isolate* isolate) {
  if (isolate == nullptr) isolate = context->GetIsolate();

  using Limits = std::numeric_limits<T>;
  // Choose Uint32, Int32, or Double depending on range checks.
  // These checks should all collapse at compile time.
  if (static_cast<uint32_t>(Limits::max()) <=
          std::numeric_limits<uint32_t>::max() &&
      static_cast<uint32_t>(Limits::min()) >=
          std::numeric_limits<uint32_t>::min() && Limits::is_exact) {
    return v8::Integer::NewFromUnsigned(isolate, static_cast<uint32_t>(number));
  }

  if (static_cast<int32_t>(Limits::max()) <=
          std::numeric_limits<int32_t>::max() &&
      static_cast<int32_t>(Limits::min()) >=
          std::numeric_limits<int32_t>::min() && Limits::is_exact) {
    return v8::Integer::New(isolate, static_cast<int32_t>(number));
  }

  return v8::Number::New(isolate, static_cast<double>(number));
}

SlicedArguments::SlicedArguments(
    const v8::FunctionCallbackInfo<v8::Value>& args, size_t start) {
  const size_t length = static_cast<size_t>(args.Length());
  if (start >= length) return;
  const size_t size = length - start;

  AllocateSufficientStorage(size);
  for (size_t i = 0; i < size; ++i)
    (*this)[i] = args[i + start];
}

template <typename T, size_t kStackStorageSize>
void MaybeStackBuffer<T, kStackStorageSize>::AllocateSufficientStorage(
    size_t storage) {
  CHECK(!IsInvalidated());
  if (storage > capacity()) {
    bool was_allocated = IsAllocated();
    T* allocated_ptr = was_allocated ? buf_ : nullptr;
    buf_ = Realloc(allocated_ptr, storage);
    capacity_ = storage;
    if (!was_allocated && length_ > 0)
      memcpy(buf_, buf_st_, length_ * sizeof(buf_[0]));
  }

  length_ = storage;
}

template <typename T, size_t S>
ArrayBufferViewContents<T, S>::ArrayBufferViewContents(
    v8::Local<v8::Value> value) {
  DCHECK(value->IsArrayBufferView() || value->IsSharedArrayBuffer() ||
         value->IsArrayBuffer());
  ReadValue(value);
}

template <typename T, size_t S>
ArrayBufferViewContents<T, S>::ArrayBufferViewContents(
    v8::Local<v8::Object> value) {
  CHECK(value->IsArrayBufferView());
  Read(value.As<v8::ArrayBufferView>());
}

template <typename T, size_t S>
ArrayBufferViewContents<T, S>::ArrayBufferViewContents(
    v8::Local<v8::ArrayBufferView> abv) {
  Read(abv);
}

template <typename T, size_t S>
void ArrayBufferViewContents<T, S>::Read(v8::Local<v8::ArrayBufferView> abv) {
  static_assert(sizeof(T) == 1, "Only supports one-byte data at the moment");
  length_ = abv->ByteLength();
  if (length_ > sizeof(stack_storage_) || abv->HasBuffer()) {
    data_ = static_cast<T*>(abv->Buffer()->Data()) + abv->ByteOffset();
  } else {
    abv->CopyContents(stack_storage_, sizeof(stack_storage_));
    data_ = stack_storage_;
  }
}

template <typename T, size_t S>
void ArrayBufferViewContents<T, S>::ReadValue(v8::Local<v8::Value> buf) {
  static_assert(sizeof(T) == 1, "Only supports one-byte data at the moment");
  DCHECK(buf->IsArrayBufferView() || buf->IsSharedArrayBuffer() ||
         buf->IsArrayBuffer());

  if (buf->IsArrayBufferView()) {
    Read(buf.As<v8::ArrayBufferView>());
  } else if (buf->IsArrayBuffer()) {
    auto ab = buf.As<v8::ArrayBuffer>();
    length_ = ab->ByteLength();
    data_ = static_cast<T*>(ab->Data());
    was_detached_ = ab->WasDetached();
  } else {
    CHECK(buf->IsSharedArrayBuffer());
    auto sab = buf.As<v8::SharedArrayBuffer>();
    length_ = sab->ByteLength();
    data_ = static_cast<T*>(sab->Data());
  }
}

// ECMA-262, 15th edition, 21.1.2.5. Number.isSafeInteger
inline bool IsSafeJsInt(v8::Local<v8::Value> v) {
  if (!v->IsNumber()) return false;
  double v_d = v.As<v8::Number>()->Value();
  if (std::isnan(v_d)) return false;
  if (std::isinf(v_d)) return false;
  if (std::trunc(v_d) != v_d) return false;  // not int
  if (std::abs(v_d) <= static_cast<double>(kMaxSafeJsInteger)) return true;
  return false;
}

constexpr size_t FastStringKey::HashImpl(std::string_view str) {
  // Low-quality hash (djb2), but just fine for current use cases.
  size_t h = 5381;
  for (const char c : str) {
    h = h * 33 + c;
  }
  return h;
}

constexpr size_t FastStringKey::Hash::operator()(
    const FastStringKey& key) const {
  return key.cached_hash_;
}

constexpr bool FastStringKey::operator==(const FastStringKey& other) const {
  return name_ == other.name_;
}

constexpr FastStringKey::FastStringKey(std::string_view name)
    : name_(name), cached_hash_(HashImpl(name)) {}

constexpr std::string_view FastStringKey::as_string_view() const {
  return name_;
}

// Inline so the compiler can fully optimize it away on Unix platforms.
bool IsWindowsBatchFile(const char* filename) {
#ifdef _WIN32
  std::string file_with_extension = filename;
  // Regex to match the last extension part after the last dot, ignoring
  // trailing spaces and dots
  std::regex extension_regex(R"(\.([a-zA-Z0-9]+)\s*[\.\s]*$)");
  std::smatch match;
  std::string extension;

  if (std::regex_search(file_with_extension, match, extension_regex)) {
    extension = ToLower(match[1].str());
  }

  return !extension.empty() && (extension == "cmd" || extension == "bat");
#else
  return false;
#endif  // _WIN32
}

#ifdef _WIN32
inline std::wstring ConvertToWideString(const std::string& str,
                                        UINT code_page) {
  int size_needed = MultiByteToWideChar(
      code_page, 0, &str[0], static_cast<int>(str.size()), nullptr, 0);
  std::wstring wstrTo(size_needed, 0);
  MultiByteToWideChar(code_page,
                      0,
                      &str[0],
                      static_cast<int>(str.size()),
                      &wstrTo[0],
                      size_needed);
  return wstrTo;
}
#endif  // _WIN32

}  // namespace node

#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#endif  // SRC_UTIL_INL_H_
                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/src/util.cc                                                                             0000664 0000000 0000000 00000075700 14746647661 0014641 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

#include "util.h"  // NOLINT(build/include_inline)
#include <cmath>
#include <cstdint>
#include "util-inl.h"

#include "debug_utils-inl.h"
#include "env-inl.h"
#include "node_buffer.h"
#include "node_errors.h"
#include "node_internals.h"
#include "node_snapshot_builder.h"
#include "node_v8_platform-inl.h"
#include "string_bytes.h"
#include "v8-value.h"

#ifdef _WIN32
#include <io.h>  // _S_IREAD _S_IWRITE
#include <time.h>
#ifndef S_IRUSR
#define S_IRUSR _S_IREAD
#endif  // S_IRUSR
#ifndef S_IWUSR
#define S_IWUSR _S_IWRITE
#endif  // S_IWUSR
#else
#include <sys/time.h>
#include <sys/types.h>
#endif

#include <simdutf.h>

#include <atomic>
#include <cstdio>
#include <cstring>
#include <iomanip>
#include <sstream>

static std::atomic_int seq = {0};  // Sequence number for diagnostic filenames.

// F_OK etc. constants
#ifdef _WIN32
#include "uv.h"
#else
#include <unistd.h>
#endif

// The access modes can be any of F_OK, R_OK, W_OK or X_OK. Some might not be
// available on specific systems. They can be used in combination as well
// (F_OK | R_OK | W_OK | X_OK).
constexpr int kMaximumAccessMode = F_OK | W_OK | R_OK | X_OK;
constexpr int kMinimumAccessMode = std::min({F_OK, W_OK, R_OK, X_OK});

constexpr int kDefaultCopyMode = 0;
// The copy modes can be any of UV_FS_COPYFILE_EXCL, UV_FS_COPYFILE_FICLONE or
// UV_FS_COPYFILE_FICLONE_FORCE. They can be used in combination as well
// (US_FS_COPYFILE_EXCL | US_FS_COPYFILE_FICLONE |
// US_FS_COPYFILE_FICLONE_FORCE).
constexpr int kMinimumCopyMode = std::min({kDefaultCopyMode,
                                           UV_FS_COPYFILE_EXCL,
                                           UV_FS_COPYFILE_FICLONE,
                                           UV_FS_COPYFILE_FICLONE_FORCE});
constexpr int kMaximumCopyMode =
    UV_FS_COPYFILE_EXCL | UV_FS_COPYFILE_FICLONE | UV_FS_COPYFILE_FICLONE_FORCE;

namespace node {

using v8::ArrayBuffer;
using v8::ArrayBufferView;
using v8::Context;
using v8::FunctionTemplate;
using v8::Isolate;
using v8::Local;
using v8::Object;
using v8::String;
using v8::Template;
using v8::Value;

template <typename T>
static void MakeUtf8String(Isolate* isolate,
                           Local<Value> value,
                           MaybeStackBuffer<T>* target) {
  Local<String> string;
  if (!value->ToString(isolate->GetCurrentContext()).ToLocal(&string)) return;
  String::ValueView value_view(isolate, string);

  auto value_length = value_view.length();

  if (value_view.is_one_byte()) {
    auto const_char = reinterpret_cast<const char*>(value_view.data8());
    auto expected_length =
        target->capacity() < (static_cast<size_t>(value_length) * 2 + 1)
            ? simdutf::utf8_length_from_latin1(const_char, value_length)
            : value_length * 2;

    // Add +1 for null termination.
    target->AllocateSufficientStorage(expected_length + 1);
    const auto actual_length = simdutf::convert_latin1_to_utf8(
        const_char, value_length, target->out());
    target->SetLengthAndZeroTerminate(actual_length);
    return;
  }

  // Add +1 for null termination.
  size_t storage = (3 * value_length) + 1;
  target->AllocateSufficientStorage(storage);

  // TODO(@anonrig): Use simdutf to speed up non-one-byte strings once it's
  // implemented
  const int flags =
      String::NO_NULL_TERMINATION | String::REPLACE_INVALID_UTF8;
  const int length =
      string->WriteUtf8(isolate, target->out(), storage, nullptr, flags);
  target->SetLengthAndZeroTerminate(length);
}

Utf8Value::Utf8Value(Isolate* isolate, Local<Value> value) {
  if (value.IsEmpty())
    return;

  MakeUtf8String(isolate, value, this);
}


TwoByteValue::TwoByteValue(Isolate* isolate, Local<Value> value) {
  if (value.IsEmpty()) {
    return;
  }

  Local<String> string;
  if (!value->ToString(isolate->GetCurrentContext()).ToLocal(&string)) return;

  // Allocate enough space to include the null terminator
  const size_t storage = string->Length() + 1;
  AllocateSufficientStorage(storage);

  const int flags = String::NO_NULL_TERMINATION;
  const int length = string->Write(isolate, out(), 0, storage, flags);
  SetLengthAndZeroTerminate(length);
}

BufferValue::BufferValue(Isolate* isolate, Local<Value> value) {
  // Slightly different take on Utf8Value. If value is a String,
  // it will return a Utf8 encoded string. If value is a Buffer,
  // it will copy the data out of the Buffer as is.
  if (value.IsEmpty()) {
    // Dereferencing this object will return nullptr.
    Invalidate();
    return;
  }

  if (value->IsString()) {
    MakeUtf8String(isolate, value, this);
  } else if (value->IsArrayBufferView()) {
    const size_t len = value.As<ArrayBufferView>()->ByteLength();
    // Leave place for the terminating '\0' byte.
    AllocateSufficientStorage(len + 1);
    value.As<ArrayBufferView>()->CopyContents(out(), len);
    SetLengthAndZeroTerminate(len);
  } else {
    Invalidate();
  }
}

void LowMemoryNotification() {
  if (per_process::v8_initialized) {
    auto isolate = Isolate::TryGetCurrent();
    if (isolate != nullptr) {
      isolate->LowMemoryNotification();
    }
  }
}

std::string GetProcessTitle(const char* default_title) {
  std::string buf(16, '\0');

  for (;;) {
    const int rc = uv_get_process_title(buf.data(), buf.size());

    if (rc == 0)
      break;

    // If uv_setup_args() was not called, `uv_get_process_title()` will always
    // return `UV_ENOBUFS`, no matter the input size. Guard against a possible
    // infinite loop by limiting the buffer size.
    if (rc != UV_ENOBUFS || buf.size() >= 1024 * 1024)
      return default_title;

    buf.resize(2 * buf.size());
  }

  // Strip excess trailing nul bytes. Using strlen() here is safe,
  // uv_get_process_title() always zero-terminates the result.
  buf.resize(strlen(buf.data()));

  return buf;
}

std::string GetHumanReadableProcessName() {
  return SPrintF("%s[%d]", GetProcessTitle("Node.js"), uv_os_getpid());
}

std::vector<std::string_view> SplitString(const std::string_view in,
                                          const std::string_view delim) {
  std::vector<std::string_view> out;

  for (auto first = in.data(), second = in.data(), last = first + in.size();
       second != last && first != last;
       first = second + 1) {
    second =
        std::find_first_of(first, last, std::cbegin(delim), std::cend(delim));

    if (first != second) {
      out.emplace_back(first, second - first);
    }
  }

  return out;
}

void ThrowErrStringTooLong(Isolate* isolate) {
  isolate->ThrowException(ERR_STRING_TOO_LONG(isolate));
}

double GetCurrentTimeInMicroseconds() {
  constexpr double kMicrosecondsPerSecond = 1e6;
  uv_timeval64_t tv;
  CHECK_EQ(0, uv_gettimeofday(&tv));
  return kMicrosecondsPerSecond * tv.tv_sec + tv.tv_usec;
}

int WriteFileSync(const char* path, uv_buf_t buf) {
  return WriteFileSync(path, &buf, 1);
}

int WriteFileSync(const char* path, uv_buf_t* bufs, size_t buf_count) {
  uv_fs_t req;
  int fd = uv_fs_open(nullptr,
                      &req,
                      path,
                      O_WRONLY | O_CREAT | O_TRUNC,
                      S_IWUSR | S_IRUSR,
                      nullptr);
  uv_fs_req_cleanup(&req);
  if (fd < 0) {
    return fd;
  }

  int err = uv_fs_write(nullptr, &req, fd, bufs, buf_count, 0, nullptr);
  uv_fs_req_cleanup(&req);
  if (err < 0) {
    return err;
  }

  err = uv_fs_close(nullptr, &req, fd, nullptr);
  uv_fs_req_cleanup(&req);
  return err;
}

int WriteFileSync(v8::Isolate* isolate,
                  const char* path,
                  v8::Local<v8::String> string) {
  node::Utf8Value utf8(isolate, string);
  uv_buf_t buf = uv_buf_init(utf8.out(), utf8.length());
  return WriteFileSync(path, buf);
}

int ReadFileSync(std::string* result, const char* path) {
  uv_fs_t req;
  auto defer_req_cleanup = OnScopeLeave([&req]() {
    uv_fs_req_cleanup(&req);
  });

  uv_file file = uv_fs_open(nullptr, &req, path, O_RDONLY, 0, nullptr);
  if (req.result < 0) {
    // req will be cleaned up by scope leave.
    return req.result;
  }
  uv_fs_req_cleanup(&req);

  auto defer_close = OnScopeLeave([file]() {
    uv_fs_t close_req;
    CHECK_EQ(0, uv_fs_close(nullptr, &close_req, file, nullptr));
    uv_fs_req_cleanup(&close_req);
  });

  *result = std::string("");
  char buffer[4096];
  uv_buf_t buf = uv_buf_init(buffer, sizeof(buffer));

  while (true) {
    const int r =
        uv_fs_read(nullptr, &req, file, &buf, 1, result->length(), nullptr);
    if (req.result < 0) {
      // req will be cleaned up by scope leave.
      return req.result;
    }
    uv_fs_req_cleanup(&req);
    if (r <= 0) {
      break;
    }
    result->append(buf.base, r);
  }
  return 0;
}

std::vector<char> ReadFileSync(FILE* fp) {
  CHECK_EQ(ftell(fp), 0);
  int err = fseek(fp, 0, SEEK_END);
  CHECK_EQ(err, 0);
  size_t size = ftell(fp);
  CHECK_NE(size, static_cast<size_t>(-1L));
  err = fseek(fp, 0, SEEK_SET);
  CHECK_EQ(err, 0);

  std::vector<char> contents(size);
  size_t num_read = fread(contents.data(), size, 1, fp);
  CHECK_EQ(num_read, 1);
  return contents;
}

void DiagnosticFilename::LocalTime(TIME_TYPE* tm_struct) {
#ifdef _WIN32
  GetLocalTime(tm_struct);
#else  // UNIX, macOS
  struct timeval time_val;
  gettimeofday(&time_val, nullptr);
  localtime_r(&time_val.tv_sec, tm_struct);
#endif
}

// Defined in node_internals.h
std::string DiagnosticFilename::MakeFilename(
    uint64_t thread_id,
    const char* prefix,
    const char* ext) {
  std::ostringstream oss;
  TIME_TYPE tm_struct;
  LocalTime(&tm_struct);
  oss << prefix;
#ifdef _WIN32
  oss << "." << std::setfill('0') << std::setw(4) << tm_struct.wYear;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wMonth;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wDay;
  oss << "." << std::setfill('0') << std::setw(2) << tm_struct.wHour;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wMinute;
  oss << std::setfill('0') << std::setw(2) << tm_struct.wSecond;
#else  // UNIX, macOS
  oss << "."
            << std::setfill('0')
            << std::setw(4)
            << tm_struct.tm_year + 1900;
  oss << std::setfill('0')
            << std::setw(2)
            << tm_struct.tm_mon + 1;
  oss << std::setfill('0')
            << std::setw(2)
            << tm_struct.tm_mday;
  oss << "."
            << std::setfill('0')
            << std::setw(2)
            << tm_struct.tm_hour;
  oss << std::setfill('0')
            << std::setw(2)
            << tm_struct.tm_min;
  oss << std::setfill('0')
            << std::setw(2)
            << tm_struct.tm_sec;
#endif
  oss << "." << uv_os_getpid();
  oss << "." << thread_id;
  oss << "." << std::setfill('0') << std::setw(3) << ++seq;
  oss << "." << ext;
  return oss.str();
}

Local<v8::FunctionTemplate> NewFunctionTemplate(
    v8::Isolate* isolate,
    v8::FunctionCallback callback,
    Local<v8::Signature> signature,
    v8::ConstructorBehavior behavior,
    v8::SideEffectType side_effect_type,
    const v8::CFunction* c_function) {
  return v8::FunctionTemplate::New(isolate,
                                   callback,
                                   Local<v8::Value>(),
                                   signature,
                                   0,
                                   behavior,
                                   side_effect_type,
                                   c_function);
}

void SetMethod(Local<v8::Context> context,
               Local<v8::Object> that,
               const std::string_view name,
               v8::FunctionCallback callback) {
  Isolate* isolate = context->GetIsolate();
  Local<v8::Function> function =
      NewFunctionTemplate(isolate,
                          callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect)
          ->GetFunction(context)
          .ToLocalChecked();
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name.data(), type, name.size())
          .ToLocalChecked();
  that->Set(context, name_string, function).Check();
  function->SetName(name_string);  // NODE_SET_METHOD() compatibility.
}

void SetMethod(v8::Isolate* isolate,
               v8::Local<v8::Template> that,
               const std::string_view name,
               v8::FunctionCallback callback) {
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name.data(), type, name.size())
          .ToLocalChecked();
  that->Set(name_string, t);
}

void SetFastMethod(Isolate* isolate,
                   Local<Template> that,
                   const std::string_view name,
                   v8::FunctionCallback slow_callback,
                   const v8::CFunction* c_function) {
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          slow_callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect,
                          c_function);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name.data(), type, name.size())
          .ToLocalChecked();
  that->Set(name_string, t);
}

void SetFastMethod(Local<v8::Context> context,
                   Local<v8::Object> that,
                   const std::string_view name,
                   v8::FunctionCallback slow_callback,
                   const v8::CFunction* c_function) {
  Isolate* isolate = context->GetIsolate();
  Local<v8::Function> function =
      NewFunctionTemplate(isolate,
                          slow_callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect,
                          c_function)
          ->GetFunction(context)
          .ToLocalChecked();
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name.data(), type, name.size())
          .ToLocalChecked();
  that->Set(context, name_string, function).Check();
}

void SetFastMethodNoSideEffect(Local<v8::Context> context,
                               Local<v8::Object> that,
                               const std::string_view name,
                               v8::FunctionCallback slow_callback,
                               const v8::CFunction* c_function) {
  Isolate* isolate = context->GetIsolate();
  Local<v8::Function> function =
      NewFunctionTemplate(isolate,
                          slow_callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect,
                          c_function)
          ->GetFunction(context)
          .ToLocalChecked();
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name.data(), type, name.size())
          .ToLocalChecked();
  that->Set(context, name_string, function).Check();
}

void SetFastMethodNoSideEffect(Isolate* isolate,
                               Local<Template> that,
                               const std::string_view name,
                               v8::FunctionCallback slow_callback,
                               const v8::CFunction* c_function) {
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          slow_callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect,
                          c_function);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name.data(), type, name.size())
          .ToLocalChecked();
  that->Set(name_string, t);
}

void SetFastMethod(Isolate* isolate,
                   Local<Template> that,
                   const std::string_view name,
                   v8::FunctionCallback slow_callback,
                   const v8::MemorySpan<const v8::CFunction>& methods) {
  Local<v8::FunctionTemplate> t = FunctionTemplate::NewWithCFunctionOverloads(
      isolate,
      slow_callback,
      Local<Value>(),
      Local<v8::Signature>(),
      0,
      v8::ConstructorBehavior::kThrow,
      v8::SideEffectType::kHasSideEffect,
      methods);

  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name.data(), type, name.size())
          .ToLocalChecked();
  that->Set(name_string, t);
}

void SetFastMethodNoSideEffect(
    Isolate* isolate,
    Local<Template> that,
    const std::string_view name,
    v8::FunctionCallback slow_callback,
    const v8::MemorySpan<const v8::CFunction>& methods) {
  Local<v8::FunctionTemplate> t = FunctionTemplate::NewWithCFunctionOverloads(
      isolate,
      slow_callback,
      Local<Value>(),
      Local<v8::Signature>(),
      0,
      v8::ConstructorBehavior::kThrow,
      v8::SideEffectType::kHasNoSideEffect,
      methods);

  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name.data(), type, name.size())
          .ToLocalChecked();
  that->Set(name_string, t);
}

void SetMethodNoSideEffect(Local<v8::Context> context,
                           Local<v8::Object> that,
                           const std::string_view name,
                           v8::FunctionCallback callback) {
  Isolate* isolate = context->GetIsolate();
  Local<v8::Function> function =
      NewFunctionTemplate(isolate,
                          callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect)
          ->GetFunction(context)
          .ToLocalChecked();
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name.data(), type, name.size())
          .ToLocalChecked();
  that->Set(context, name_string, function).Check();
  function->SetName(name_string);  // NODE_SET_METHOD() compatibility.
}

void SetMethodNoSideEffect(Isolate* isolate,
                           Local<v8::Template> that,
                           const std::string_view name,
                           v8::FunctionCallback callback) {
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          Local<v8::Signature>(),
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name.data(), type, name.size())
          .ToLocalChecked();
  that->Set(name_string, t);
}

void SetProtoMethod(v8::Isolate* isolate,
                    Local<v8::FunctionTemplate> that,
                    const std::string_view name,
                    v8::FunctionCallback callback) {
  Local<v8::Signature> signature = v8::Signature::New(isolate, that);
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          signature,
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name.data(), type, name.size())
          .ToLocalChecked();
  that->PrototypeTemplate()->Set(name_string, t);
  t->SetClassName(name_string);  // NODE_SET_PROTOTYPE_METHOD() compatibility.
}

void SetProtoMethodNoSideEffect(v8::Isolate* isolate,
                                Local<v8::FunctionTemplate> that,
                                const std::string_view name,
                                v8::FunctionCallback callback) {
  Local<v8::Signature> signature = v8::Signature::New(isolate, that);
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          signature,
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasNoSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name.data(), type, name.size())
          .ToLocalChecked();
  that->PrototypeTemplate()->Set(name_string, t);
  t->SetClassName(name_string);  // NODE_SET_PROTOTYPE_METHOD() compatibility.
}

void SetInstanceMethod(v8::Isolate* isolate,
                       Local<v8::FunctionTemplate> that,
                       const std::string_view name,
                       v8::FunctionCallback callback) {
  Local<v8::Signature> signature = v8::Signature::New(isolate, that);
  Local<v8::FunctionTemplate> t =
      NewFunctionTemplate(isolate,
                          callback,
                          signature,
                          v8::ConstructorBehavior::kThrow,
                          v8::SideEffectType::kHasSideEffect);
  // kInternalized strings are created in the old space.
  const v8::NewStringType type = v8::NewStringType::kInternalized;
  Local<v8::String> name_string =
      v8::String::NewFromUtf8(isolate, name.data(), type, name.size())
          .ToLocalChecked();
  that->InstanceTemplate()->Set(name_string, t);
  t->SetClassName(name_string);
}

void SetConstructorFunction(Local<v8::Context> context,
                            Local<v8::Object> that,
                            const char* name,
                            Local<v8::FunctionTemplate> tmpl,
                            SetConstructorFunctionFlag flag) {
  Isolate* isolate = context->GetIsolate();
  SetConstructorFunction(
      context, that, OneByteString(isolate, name), tmpl, flag);
}

void SetConstructorFunction(Local<Context> context,
                            Local<Object> that,
                            Local<String> name,
                            Local<FunctionTemplate> tmpl,
                            SetConstructorFunctionFlag flag) {
  if (flag == SetConstructorFunctionFlag::SET_CLASS_NAME) [[likely]] {
    tmpl->SetClassName(name);
  }
  that->Set(context, name, tmpl->GetFunction(context).ToLocalChecked()).Check();
}

void SetConstructorFunction(Isolate* isolate,
                            Local<Template> that,
                            const char* name,
                            Local<FunctionTemplate> tmpl,
                            SetConstructorFunctionFlag flag) {
  SetConstructorFunction(
      isolate, that, OneByteString(isolate, name), tmpl, flag);
}

void SetConstructorFunction(Isolate* isolate,
                            Local<Template> that,
                            Local<String> name,
                            Local<FunctionTemplate> tmpl,
                            SetConstructorFunctionFlag flag) {
  if (flag == SetConstructorFunctionFlag::SET_CLASS_NAME) [[likely]] {
    tmpl->SetClassName(name);
  }
  that->Set(name, tmpl);
}

Local<String> UnionBytes::ToStringChecked(Isolate* isolate) const {
  if (is_one_byte()) {
    return String::NewExternalOneByte(isolate, one_byte_resource_)
        .ToLocalChecked();
  } else {
    return String::NewExternalTwoByte(isolate, two_byte_resource_)
        .ToLocalChecked();
  }
}

RAIIIsolateWithoutEntering::RAIIIsolateWithoutEntering(const SnapshotData* data)
    : allocator_{ArrayBuffer::Allocator::NewDefaultAllocator()} {
  isolate_ = Isolate::Allocate();
  CHECK_NOT_NULL(isolate_);
  per_process::v8_platform.Platform()->RegisterIsolate(isolate_,
                                                       uv_default_loop());
  Isolate::CreateParams params;
  if (data != nullptr) {
    SnapshotBuilder::InitializeIsolateParams(data, &params);
  }
  params.array_buffer_allocator = allocator_.get();
  Isolate::Initialize(isolate_, params);
}

RAIIIsolateWithoutEntering::~RAIIIsolateWithoutEntering() {
  per_process::v8_platform.Platform()->UnregisterIsolate(isolate_);
  isolate_->Dispose();
}

RAIIIsolate::RAIIIsolate(const SnapshotData* data)
    : isolate_{data}, isolate_scope_{isolate_.get()} {}

RAIIIsolate::~RAIIIsolate() {}

// Returns a string representation of the input value, including type.
// JavaScript implementation is available in lib/internal/errors.js
std::string DetermineSpecificErrorType(Environment* env,
                                       v8::Local<v8::Value> input) {
  if (input->IsFunction()) {
    return "function";
  } else if (input->IsString()) {
    auto value = Utf8Value(env->isolate(), input).ToString();
    if (value.size() > 28) {
      value = value.substr(0, 25) + "...";
    }
    if (value.find('\'') == std::string::npos) {
      return SPrintF("type string ('%s')", value);
    }

    // Stringify the input value.
    Local<String> stringified =
        v8::JSON::Stringify(env->context(), input).ToLocalChecked();
    Utf8Value stringified_value(env->isolate(), stringified);
    return SPrintF("type string (%s)", stringified_value.out());
  } else if (input->IsObject()) {
    v8::Local<v8::String> constructor_name =
        input.As<v8::Object>()->GetConstructorName();
    Utf8Value name(env->isolate(), constructor_name);
    return SPrintF("an instance of %s", name.out());
  } else if (input->IsSymbol()) {
    v8::MaybeLocal<v8::String> str =
        input.As<v8::Symbol>()->ToDetailString(env->context());
    v8::Local<v8::String> js_str;
    if (!str.ToLocal(&js_str)) {
      return "Symbol";
    }
    Utf8Value name(env->isolate(), js_str);
    // Symbol(xxx)
    return name.out();
  }

  Utf8Value utf8_value(env->isolate(),
                       input->ToString(env->context()).ToLocalChecked());

  if (input->IsNumber() || input->IsInt32() || input->IsUint32()) {
    auto value = input.As<v8::Number>()->Value();
    if (std::isnan(value)) {
      return "type number (NaN)";
    } else if (std::isinf(value)) {
      return "type number (Infinity)";
    }
    return SPrintF("type number (%s)", utf8_value.out());
  } else if (input->IsBigInt() || input->IsBoolean() || input->IsSymbol()) {
    Utf8Value type(env->isolate(), input->TypeOf(env->isolate()));
    return SPrintF("type %s (%s)", type.out(), utf8_value.out());
  }

  // For example: null, undefined
  return utf8_value.ToString();
}

v8::Maybe<int32_t> GetValidatedFd(Environment* env,
                                  v8::Local<v8::Value> input) {
  if (!input->IsInt32() && !input->IsNumber()) {
    std::string error_type = node::DetermineSpecificErrorType(env, input);
    THROW_ERR_INVALID_ARG_TYPE(env,
                               "The \"fd\" argument must be of type "
                               "number. Received %s",
                               error_type.c_str());
    return v8::Nothing<int32_t>();
  }

  const double fd = input.As<v8::Number>()->Value();
  const bool is_out_of_range = fd < 0 || fd > INT32_MAX;

  if (is_out_of_range || !IsSafeJsInt(input)) {
    Utf8Value utf8_value(
        env->isolate(), input->ToDetailString(env->context()).ToLocalChecked());
    if (is_out_of_range && !std::isinf(fd)) {
      THROW_ERR_OUT_OF_RANGE(env,
                             "The value of \"fd\" is out of range. "
                             "It must be >= 0 && <= %s. Received %s",
                             std::to_string(INT32_MAX),
                             utf8_value.out());
    } else {
      THROW_ERR_OUT_OF_RANGE(
          env,
          "The value of \"fd\" is out of range. It must be an integer. "
          "Received %s",
          utf8_value.out());
    }
    return v8::Nothing<int32_t>();
  }

  return v8::Just(static_cast<int32_t>(fd));
}

v8::Maybe<int> GetValidFileMode(Environment* env,
                                v8::Local<v8::Value> input,
                                uv_fs_type type) {
  // Allow only int32 or null/undefined values.
  if (input->IsNumber()) {
    // We cast the input to v8::Number to avoid overflows.
    auto num = input.As<v8::Number>()->Value();

    // Handle infinity and NaN values
    if (std::isinf(num) || std::isnan(num)) {
      THROW_ERR_OUT_OF_RANGE(env, "mode is out of range");
      return v8::Nothing<int>();
    }
  } else if (!input->IsNullOrUndefined()) {
    THROW_ERR_INVALID_ARG_TYPE(env, "mode must be int32 or null/undefined");
    return v8::Nothing<int>();
  }

  int min = kMinimumAccessMode;
  int max = kMaximumAccessMode;
  int def = F_OK;

  CHECK(type == UV_FS_ACCESS || type == UV_FS_COPYFILE);

  if (type == UV_FS_COPYFILE) {
    min = kMinimumCopyMode;
    max = kMaximumCopyMode;
    def = input->IsNullOrUndefined() ? kDefaultCopyMode
                                     : input.As<v8::Int32>()->Value();
  }

  if (input->IsNullOrUndefined()) {
    return v8::Just(def);
  }

  const int mode = input.As<v8::Int32>()->Value();
  if (mode < min || mode > max) {
    THROW_ERR_OUT_OF_RANGE(
        env, "mode is out of range: >= %d && <= %d", min, max);
    return v8::Nothing<int>();
  }

  return v8::Just(mode);
}

}  // namespace node
                                                                node-23.7.0/src/util.h                                                                              0000664 0000000 0000000 00000110621 14746647661 0014473 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

#ifndef SRC_UTIL_H_
#define SRC_UTIL_H_

#if defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#include "uv.h"
#include "v8.h"

#include "node.h"
#include "node_exit_code.h"

#include <climits>
#include <cstddef>
#include <cstdio>
#include <cstdlib>
#include <cstring>

#include <array>
#include <bit>
#include <filesystem>
#include <limits>
#include <memory>
#include <optional>
#include <set>
#include <string>
#include <string_view>
#include <type_traits>
#include <unordered_map>
#include <utility>
#include <vector>

#ifdef __GNUC__
#define MUST_USE_RESULT __attribute__((warn_unused_result))
#else
#define MUST_USE_RESULT
#endif

namespace node {

constexpr char kPathSeparator = std::filesystem::path::preferred_separator;

#ifdef _WIN32
/* MAX_PATH is in characters, not bytes. Make sure we have enough headroom. */
#define PATH_MAX_BYTES (MAX_PATH * 4)
#else
#define PATH_MAX_BYTES (PATH_MAX)
#endif

// These should be used in our code as opposed to the native
// versions as they abstract out some platform and or
// compiler version specific functionality
// malloc(0) and realloc(ptr, 0) have implementation-defined behavior in
// that the standard allows them to either return a unique pointer or a
// nullptr for zero-sized allocation requests.  Normalize by always using
// a nullptr.
template <typename T>
inline T* UncheckedRealloc(T* pointer, size_t n);
template <typename T>
inline T* UncheckedMalloc(size_t n);
template <typename T>
inline T* UncheckedCalloc(size_t n);

// Same things, but aborts immediately instead of returning nullptr when
// no memory is available.
template <typename T>
inline T* Realloc(T* pointer, size_t n);
template <typename T>
inline T* Malloc(size_t n);
template <typename T>
inline T* Calloc(size_t n);

inline char* Malloc(size_t n);
inline char* Calloc(size_t n);
inline char* UncheckedMalloc(size_t n);
inline char* UncheckedCalloc(size_t n);

template <typename T>
inline T MultiplyWithOverflowCheck(T a, T b);

namespace per_process {
// Tells whether the per-process V8::Initialize() is called and
// if it is safe to call v8::Isolate::TryGetCurrent().
extern bool v8_initialized;
}  // namespace per_process

// Used by the allocation functions when allocation fails.
// Thin wrapper around v8::Isolate::LowMemoryNotification() that checks
// whether V8 is initialized.
void LowMemoryNotification();

// The reason that Assert() takes a struct argument instead of individual
// const char*s is to ease instruction cache pressure in calls from CHECK.
struct AssertionInfo {
  const char* file_line;  // filename:line
  const char* message;
  const char* function;
};

// This indirectly calls backtrace so it can not be marked as [[noreturn]].
void NODE_EXTERN_PRIVATE Assert(const AssertionInfo& info);
void DumpNativeBacktrace(FILE* fp);
void DumpJavaScriptBacktrace(FILE* fp);

// Windows 8+ does not like abort() in Release mode
#ifdef _WIN32
#define ABORT_NO_BACKTRACE() _exit(static_cast<int>(node::ExitCode::kAbort))
#else
#define ABORT_NO_BACKTRACE() abort()
#endif

// Caller of this macro must not be marked as [[noreturn]]. Printing of
// backtraces may not work correctly in [[noreturn]] functions because
// when generating code for them the compiler can choose not to
// maintain the frame pointers or link registers that are necessary for
// correct backtracing.
// `ABORT` must be a macro and not a [[noreturn]] function to make sure the
// backtrace is correct.
#define ABORT()                                                                \
  do {                                                                         \
    node::DumpNativeBacktrace(stderr);                                         \
    node::DumpJavaScriptBacktrace(stderr);                                     \
    fflush(stderr);                                                            \
    ABORT_NO_BACKTRACE();                                                      \
  } while (0)

#define ERROR_AND_ABORT(expr)                                                  \
  do {                                                                         \
    /* Make sure that this struct does not end up in inline code, but      */  \
    /* rather in a read-only data section when modifying this code.        */  \
    static const node::AssertionInfo error_and_abort_args = {                  \
        __FILE__ ":" STRINGIFY(__LINE__), #expr, PRETTY_FUNCTION_NAME};        \
    node::Assert(error_and_abort_args);                                        \
    /* `node::Assert` doesn't return. Add an [[noreturn]] abort() here to  */  \
    /* make the compiler happy about no return value in the caller         */  \
    /* function when calling ERROR_AND_ABORT.                              */  \
    ABORT_NO_BACKTRACE();                                                      \
  } while (0)

#ifdef __GNUC__
#define PRETTY_FUNCTION_NAME __PRETTY_FUNCTION__
#else
#if defined(_MSC_VER)
#define PRETTY_FUNCTION_NAME __FUNCSIG__
#else
#define PRETTY_FUNCTION_NAME ""
#endif
#endif

#define STRINGIFY_(x) #x
#define STRINGIFY(x) STRINGIFY_(x)

#define CHECK(expr)                                                            \
  do {                                                                         \
    if (!(expr)) [[unlikely]] {                                                \
      ERROR_AND_ABORT(expr);                                                   \
    }                                                                          \
  } while (0)

#define CHECK_EQ(a, b) CHECK((a) == (b))
#define CHECK_GE(a, b) CHECK((a) >= (b))
#define CHECK_GT(a, b) CHECK((a) > (b))
#define CHECK_LE(a, b) CHECK((a) <= (b))
#define CHECK_LT(a, b) CHECK((a) < (b))
#define CHECK_NE(a, b) CHECK((a) != (b))
#define CHECK_NULL(val) CHECK((val) == nullptr)
#define CHECK_NOT_NULL(val) CHECK((val) != nullptr)
#define CHECK_IMPLIES(a, b) CHECK(!(a) || (b))

#ifdef DEBUG
  #define DCHECK(expr) CHECK(expr)
  #define DCHECK_EQ(a, b) CHECK((a) == (b))
  #define DCHECK_GE(a, b) CHECK((a) >= (b))
  #define DCHECK_GT(a, b) CHECK((a) > (b))
  #define DCHECK_LE(a, b) CHECK((a) <= (b))
  #define DCHECK_LT(a, b) CHECK((a) < (b))
  #define DCHECK_NE(a, b) CHECK((a) != (b))
  #define DCHECK_NULL(val) CHECK((val) == nullptr)
  #define DCHECK_NOT_NULL(val) CHECK((val) != nullptr)
  #define DCHECK_IMPLIES(a, b) CHECK(!(a) || (b))
#else
  #define DCHECK(expr)
  #define DCHECK_EQ(a, b)
  #define DCHECK_GE(a, b)
  #define DCHECK_GT(a, b)
  #define DCHECK_LE(a, b)
  #define DCHECK_LT(a, b)
  #define DCHECK_NE(a, b)
  #define DCHECK_NULL(val)
  #define DCHECK_NOT_NULL(val)
  #define DCHECK_IMPLIES(a, b)
#endif


#define UNREACHABLE(...)                                                      \
  ERROR_AND_ABORT("Unreachable code reached" __VA_OPT__(": ") __VA_ARGS__)

// ECMA-262, 15th edition, 21.1.2.6. Number.MAX_SAFE_INTEGER (2^53-1)
constexpr int64_t kMaxSafeJsInteger = 9007199254740991;

inline bool IsSafeJsInt(v8::Local<v8::Value> v);

// TAILQ-style intrusive list node.
template <typename T>
class ListNode;

// TAILQ-style intrusive list head.
template <typename T, ListNode<T> (T::*M)>
class ListHead;

template <typename T>
class ListNode {
 public:
  inline ListNode();
  inline ~ListNode();
  inline void Remove();
  inline bool IsEmpty() const;

  ListNode(const ListNode&) = delete;
  ListNode& operator=(const ListNode&) = delete;

 private:
  template <typename U, ListNode<U> (U::*M)> friend class ListHead;
  friend int GenDebugSymbols();
  ListNode* prev_;
  ListNode* next_;
};

template <typename T, ListNode<T> (T::*M)>
class ListHead {
 public:
  class Iterator {
   public:
    inline T* operator*() const;
    inline const Iterator& operator++();
    inline bool operator!=(const Iterator& that) const;

   private:
    friend class ListHead;
    inline explicit Iterator(ListNode<T>* node);
    ListNode<T>* node_;
  };

  inline ListHead() = default;
  inline ~ListHead();
  inline void PushBack(T* element);
  inline void PushFront(T* element);
  inline bool IsEmpty() const;
  inline T* PopFront();
  inline Iterator begin() const;
  inline Iterator end() const;

  ListHead(const ListHead&) = delete;
  ListHead& operator=(const ListHead&) = delete;

 private:
  friend int GenDebugSymbols();
  ListNode<T> head_;
};

// The helper is for doing safe downcasts from base types to derived types.
template <typename Inner, typename Outer>
class ContainerOfHelper {
 public:
  inline ContainerOfHelper(Inner Outer::*field, Inner* pointer);
  template <typename TypeName>
  inline operator TypeName*() const;
 private:
  Outer* const pointer_;
};

// Calculate the address of the outer (i.e. embedding) struct from
// the interior pointer to a data member.
template <typename Inner, typename Outer>
constexpr ContainerOfHelper<Inner, Outer> ContainerOf(Inner Outer::*field,
                                                      Inner* pointer);

class KVStore {
 public:
  KVStore() = default;
  virtual ~KVStore() = default;
  KVStore(const KVStore&) = delete;
  KVStore& operator=(const KVStore&) = delete;
  KVStore(KVStore&&) = delete;
  KVStore& operator=(KVStore&&) = delete;

  virtual v8::MaybeLocal<v8::String> Get(v8::Isolate* isolate,
                                         v8::Local<v8::String> key) const = 0;
  virtual std::optional<std::string> Get(const char* key) const = 0;
  virtual void Set(v8::Isolate* isolate,
                   v8::Local<v8::String> key,
                   v8::Local<v8::String> value) = 0;
  virtual int32_t Query(v8::Isolate* isolate,
                        v8::Local<v8::String> key) const = 0;
  virtual int32_t Query(const char* key) const = 0;
  virtual void Delete(v8::Isolate* isolate, v8::Local<v8::String> key) = 0;
  virtual v8::Local<v8::Array> Enumerate(v8::Isolate* isolate) const = 0;

  virtual std::shared_ptr<KVStore> Clone(v8::Isolate* isolate) const;
  virtual v8::Maybe<void> AssignFromObject(v8::Local<v8::Context> context,
                                           v8::Local<v8::Object> entries);
  v8::Maybe<void> AssignToObject(v8::Isolate* isolate,
                                 v8::Local<v8::Context> context,
                                 v8::Local<v8::Object> object);

  static std::shared_ptr<KVStore> CreateMapKVStore();
};

// Convenience wrapper around v8::String::NewFromOneByte().
inline v8::Local<v8::String> OneByteString(v8::Isolate* isolate,
                                           const char* data,
                                           int length = -1);

// For the people that compile with -funsigned-char.
inline v8::Local<v8::String> OneByteString(v8::Isolate* isolate,
                                           const signed char* data,
                                           int length = -1);

inline v8::Local<v8::String> OneByteString(v8::Isolate* isolate,
                                           const unsigned char* data,
                                           int length = -1);

inline v8::Local<v8::String> OneByteString(v8::Isolate* isolate,
                                           std::string_view str);

// Used to be a macro, hence the uppercase name.
template <int N>
inline v8::Local<v8::String> FIXED_ONE_BYTE_STRING(
    v8::Isolate* isolate,
    const char(&data)[N]) {
  return OneByteString(isolate, data, N - 1);
}

template <std::size_t N>
inline v8::Local<v8::String> FIXED_ONE_BYTE_STRING(
    v8::Isolate* isolate,
    const std::array<char, N>& arr) {
  return OneByteString(isolate, arr.data(), N - 1);
}

// tolower() is locale-sensitive.  Use ToLower() instead.
inline char ToLower(char c);
inline std::string ToLower(const std::string& in);

// toupper() is locale-sensitive.  Use ToUpper() instead.
inline char ToUpper(char c);
inline std::string ToUpper(const std::string& in);

// strcasecmp() is locale-sensitive.  Use StringEqualNoCase() instead.
inline bool StringEqualNoCase(const char* a, const char* b);

// strncasecmp() is locale-sensitive.  Use StringEqualNoCaseN() instead.
inline bool StringEqualNoCaseN(const char* a, const char* b, size_t length);

template <typename T, size_t N>
constexpr size_t arraysize(const T (&)[N]) {
  return N;
}

template <typename T, size_t N>
constexpr size_t strsize(const T (&)[N]) {
  return N - 1;
}

// Allocates an array of member type T. For up to kStackStorageSize items,
// the stack is used, otherwise malloc().
template <typename T, size_t kStackStorageSize = 1024>
class MaybeStackBuffer {
 public:
  const T* out() const {
    return buf_;
  }

  T* out() {
    return buf_;
  }

  // operator* for compatibility with `v8::String::(Utf8)Value`
  T* operator*() {
    return buf_;
  }

  const T* operator*() const {
    return buf_;
  }

  T& operator[](size_t index) {
    CHECK_LT(index, length());
    return buf_[index];
  }

  const T& operator[](size_t index) const {
    CHECK_LT(index, length());
    return buf_[index];
  }

  size_t length() const {
    return length_;
  }

  // Current maximum capacity of the buffer with which SetLength() can be used
  // without first calling AllocateSufficientStorage().
  size_t capacity() const {
    return capacity_;
  }

  // Make sure enough space for `storage` entries is available.
  // This method can be called multiple times throughout the lifetime of the
  // buffer, but once this has been called Invalidate() cannot be used.
  // Content of the buffer in the range [0, length()) is preserved.
  void AllocateSufficientStorage(size_t storage);

  void SetLength(size_t length) {
    // capacity() returns how much memory is actually available.
    CHECK_LE(length, capacity());
    length_ = length;
  }

  void SetLengthAndZeroTerminate(size_t length) {
    // capacity() returns how much memory is actually available.
    CHECK_LE(length + 1, capacity());
    SetLength(length);

    // T() is 0 for integer types, nullptr for pointers, etc.
    buf_[length] = T();
  }

  // Make dereferencing this object return nullptr.
  // This method can be called multiple times throughout the lifetime of the
  // buffer, but once this has been called AllocateSufficientStorage() cannot
  // be used.
  void Invalidate() {
    CHECK(!IsAllocated());
    capacity_ = 0;
    length_ = 0;
    buf_ = nullptr;
  }

  // If the buffer is stored in the heap rather than on the stack.
  bool IsAllocated() const {
    return !IsInvalidated() && buf_ != buf_st_;
  }

  // If Invalidate() has been called.
  bool IsInvalidated() const {
    return buf_ == nullptr;
  }

  // Release ownership of the malloc'd buffer.
  // Note: This does not free the buffer.
  void Release() {
    CHECK(IsAllocated());
    buf_ = buf_st_;
    length_ = 0;
    capacity_ = arraysize(buf_st_);
  }

  MaybeStackBuffer()
      : length_(0), capacity_(arraysize(buf_st_)), buf_(buf_st_) {
    // Default to a zero-length, null-terminated buffer.
    buf_[0] = T();
  }

  explicit MaybeStackBuffer(size_t storage) : MaybeStackBuffer() {
    AllocateSufficientStorage(storage);
  }

  ~MaybeStackBuffer() {
    if (IsAllocated())
      free(buf_);
  }

  inline std::basic_string<T> ToString() const { return {out(), length()}; }
  inline std::basic_string_view<T> ToStringView() const {
    return {out(), length()};
  }

 private:
  size_t length_;
  // capacity of the malloc'ed buf_
  size_t capacity_;
  T* buf_;
  T buf_st_[kStackStorageSize];
};

// Provides access to an ArrayBufferView's storage, either the original,
// or for small data, a copy of it. This object's lifetime is bound to the
// original ArrayBufferView's lifetime.
template <typename T, size_t kStackStorageSize = 64>
class ArrayBufferViewContents {
 public:
  ArrayBufferViewContents() = default;

  ArrayBufferViewContents(const ArrayBufferViewContents&) = delete;
  void operator=(const ArrayBufferViewContents&) = delete;

  explicit inline ArrayBufferViewContents(v8::Local<v8::Value> value);
  explicit inline ArrayBufferViewContents(v8::Local<v8::Object> value);
  explicit inline ArrayBufferViewContents(v8::Local<v8::ArrayBufferView> abv);
  inline void Read(v8::Local<v8::ArrayBufferView> abv);
  inline void ReadValue(v8::Local<v8::Value> buf);

  inline bool WasDetached() const { return was_detached_; }
  inline const T* data() const { return data_; }
  inline size_t length() const { return length_; }

 private:
  // Declaring operator new and delete as deleted is not spec compliant.
  // Therefore, declare them private instead to disable dynamic alloc.
  void* operator new(size_t size);
  void* operator new[](size_t size);
  void operator delete(void*, size_t);
  void operator delete[](void*, size_t);

  T stack_storage_[kStackStorageSize];
  T* data_ = nullptr;
  size_t length_ = 0;
  bool was_detached_ = false;
};

class Utf8Value : public MaybeStackBuffer<char> {
 public:
  explicit Utf8Value(v8::Isolate* isolate, v8::Local<v8::Value> value);

  inline std::string ToString() const { return std::string(out(), length()); }
  inline std::string_view ToStringView() const {
    return std::string_view(out(), length());
  }

  inline bool operator==(const char* a) const { return strcmp(out(), a) == 0; }
  inline bool operator!=(const char* a) const { return !(*this == a); }
};

class TwoByteValue : public MaybeStackBuffer<uint16_t> {
 public:
  explicit TwoByteValue(v8::Isolate* isolate, v8::Local<v8::Value> value);
};

class BufferValue : public MaybeStackBuffer<char> {
 public:
  explicit BufferValue(v8::Isolate* isolate, v8::Local<v8::Value> value);

  inline std::string ToString() const { return std::string(out(), length()); }
  inline std::string_view ToStringView() const {
    return std::string_view(out(), length());
  }
  inline std::u8string_view ToU8StringView() const {
    return std::u8string_view(reinterpret_cast<const char8_t*>(out()),
                              length());
  }
};

#define SPREAD_BUFFER_ARG(val, name)                                           \
  CHECK((val)->IsArrayBufferView());                                           \
  v8::Local<v8::ArrayBufferView> name = (val).As<v8::ArrayBufferView>();       \
  const size_t name##_offset = name->ByteOffset();                             \
  const size_t name##_length = name->ByteLength();                             \
  char* const name##_data =                                                    \
      static_cast<char*>(name->Buffer()->Data()) + name##_offset;              \
  if (name##_length > 0) CHECK_NE(name##_data, nullptr);

// Use this when a variable or parameter is unused in order to explicitly
// silence a compiler warning about that.
template <typename T> inline void USE(T&&) {}

template <typename Fn>
struct OnScopeLeaveImpl {
  Fn fn_;
  bool active_;

  explicit OnScopeLeaveImpl(Fn&& fn) : fn_(std::move(fn)), active_(true) {}
  ~OnScopeLeaveImpl() { if (active_) fn_(); }

  OnScopeLeaveImpl(const OnScopeLeaveImpl& other) = delete;
  OnScopeLeaveImpl& operator=(const OnScopeLeaveImpl& other) = delete;
  OnScopeLeaveImpl(OnScopeLeaveImpl&& other)
    : fn_(std::move(other.fn_)), active_(other.active_) {
    other.active_ = false;
  }
};

// Run a function when exiting the current scope. Used like this:
// auto on_scope_leave = OnScopeLeave([&] {
//   // ... run some code ...
// });
template <typename Fn>
inline MUST_USE_RESULT OnScopeLeaveImpl<Fn> OnScopeLeave(Fn&& fn) {
  return OnScopeLeaveImpl<Fn>{std::move(fn)};
}

// Simple RAII wrapper for contiguous data that uses malloc()/free().
template <typename T>
struct MallocedBuffer {
  T* data;
  size_t size;

  T* release() {
    T* ret = data;
    data = nullptr;
    return ret;
  }

  void Truncate(size_t new_size) {
    CHECK_LE(new_size, size);
    size = new_size;
  }

  void Realloc(size_t new_size) {
    Truncate(new_size);
    data = UncheckedRealloc(data, new_size);
  }

  bool is_empty() const { return data == nullptr; }

  MallocedBuffer() : data(nullptr), size(0) {}
  explicit MallocedBuffer(size_t size) : data(Malloc<T>(size)), size(size) {}
  MallocedBuffer(T* data, size_t size) : data(data), size(size) {}
  MallocedBuffer(MallocedBuffer&& other) : data(other.data), size(other.size) {
    other.data = nullptr;
  }
  MallocedBuffer& operator=(MallocedBuffer&& other) {
    this->~MallocedBuffer();
    return *new(this) MallocedBuffer(std::move(other));
  }
  ~MallocedBuffer() {
    free(data);
  }
  MallocedBuffer(const MallocedBuffer&) = delete;
  MallocedBuffer& operator=(const MallocedBuffer&) = delete;
};

template <typename T>
class NonCopyableMaybe {
 public:
  NonCopyableMaybe() : empty_(true) {}
  explicit NonCopyableMaybe(T&& value)
      : empty_(false),
        value_(std::move(value)) {}

  bool IsEmpty() const {
    return empty_;
  }

  const T* get() const {
    return empty_ ? nullptr : &value_;
  }

  const T* operator->() const {
    CHECK(!empty_);
    return &value_;
  }

  T&& Release() {
    CHECK_EQ(empty_, false);
    empty_ = true;
    return std::move(value_);
  }

 private:
  bool empty_;
  T value_;
};

// Test whether some value can be called with ().
template <typename T, typename = void>
struct is_callable : std::is_function<T> { };

template <typename T>
struct is_callable<T, typename std::enable_if<
    std::is_same<decltype(void(&T::operator())), void>::value
    >::type> : std::true_type { };

template <typename T, void (*function)(T*)>
struct FunctionDeleter {
  void operator()(T* pointer) const { function(pointer); }
  typedef std::unique_ptr<T, FunctionDeleter> Pointer;
};

template <typename T, void (*function)(T*)>
using DeleteFnPtr = typename FunctionDeleter<T, function>::Pointer;

// Convert a v8::Array into an std::vector using the callback-based API.
// This can be faster than calling Array::Get() repeatedly when the array
// has more than 2 entries.
// Note that iterating over an array in C++ and performing operations on each
// element in a C++ loop is still slower than iterating over the array in JS
// and calling into native in the JS loop repeatedly on each element,
// as of V8 11.9.
inline v8::Maybe<void> FromV8Array(v8::Local<v8::Context> context,
                                   v8::Local<v8::Array> js_array,
                                   std::vector<v8::Global<v8::Value>>* out);
std::vector<std::string_view> SplitString(const std::string_view in,
                                          const std::string_view delim);

inline v8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,
                                           std::string_view str,
                                           v8::Isolate* isolate = nullptr);
template <typename T, typename test_for_number =
    typename std::enable_if<std::numeric_limits<T>::is_specialized, bool>::type>
inline v8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,
                                           const T& number,
                                           v8::Isolate* isolate = nullptr);
template <typename T>
inline v8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,
                                           const std::vector<T>& vec,
                                           v8::Isolate* isolate = nullptr);
template <typename T>
inline v8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,
                                           const std::set<T>& set,
                                           v8::Isolate* isolate = nullptr);
template <typename T, typename U>
inline v8::MaybeLocal<v8::Value> ToV8Value(v8::Local<v8::Context> context,
                                           const std::unordered_map<T, U>& map,
                                           v8::Isolate* isolate = nullptr);

// These macros expects a `Isolate* isolate` and a `Local<Context> context`
// to be in the scope.
#define READONLY_PROPERTY(obj, name, value)                                    \
  do {                                                                         \
    obj->DefineOwnProperty(                                                    \
           context, FIXED_ONE_BYTE_STRING(isolate, name), value, v8::ReadOnly) \
        .Check();                                                              \
  } while (0)

#define READONLY_DONT_ENUM_PROPERTY(obj, name, var)                            \
  do {                                                                         \
    obj->DefineOwnProperty(                                                    \
           context,                                                            \
           OneByteString(isolate, name),                                       \
           var,                                                                \
           static_cast<v8::PropertyAttribute>(v8::ReadOnly | v8::DontEnum))    \
        .Check();                                                              \
  } while (0)

#define READONLY_FALSE_PROPERTY(obj, name)                                     \
  READONLY_PROPERTY(obj, name, v8::False(isolate))

#define READONLY_TRUE_PROPERTY(obj, name)                                      \
  READONLY_PROPERTY(obj, name, v8::True(isolate))

#define READONLY_STRING_PROPERTY(obj, name, str)                               \
  READONLY_PROPERTY(obj, name, ToV8Value(context, str).ToLocalChecked())

// Variation on NODE_DEFINE_CONSTANT that sets a String value.
#define NODE_DEFINE_STRING_CONSTANT(target, name, constant)                    \
  do {                                                                         \
    v8::Isolate* isolate = target->GetIsolate();                               \
    v8::Local<v8::String> constant_name =                                      \
        v8::String::NewFromUtf8(isolate, name).ToLocalChecked();               \
    v8::Local<v8::String> constant_value =                                     \
        v8::String::NewFromUtf8(isolate, constant).ToLocalChecked();           \
    v8::PropertyAttribute constant_attributes =                                \
        static_cast<v8::PropertyAttribute>(v8::ReadOnly | v8::DontDelete);     \
    target                                                                     \
        ->DefineOwnProperty(isolate->GetCurrentContext(),                      \
                            constant_name,                                     \
                            constant_value,                                    \
                            constant_attributes)                               \
        .Check();                                                              \
  } while (0)

constexpr inline bool IsLittleEndian() {
  return std::endian::native == std::endian::little;
}

constexpr inline bool IsBigEndian() {
  return std::endian::native == std::endian::big;
}

static_assert(IsLittleEndian() || IsBigEndian(),
              "Node.js does not support mixed-endian systems");

class SlicedArguments : public MaybeStackBuffer<v8::Local<v8::Value>> {
 public:
  inline explicit SlicedArguments(
      const v8::FunctionCallbackInfo<v8::Value>& args, size_t start = 0);
};

// Convert a v8::PersistentBase, e.g. v8::Global, to a Local, with an extra
// optimization for strong persistent handles.
class PersistentToLocal {
 public:
  // If persistent.IsWeak() == false, then do not call persistent.Reset()
  // while the returned Local<T> is still in scope, it will destroy the
  // reference to the object.
  template <class TypeName>
  static inline v8::Local<TypeName> Default(
      v8::Isolate* isolate,
      const v8::PersistentBase<TypeName>& persistent) {
    if (persistent.IsWeak()) {
      return PersistentToLocal::Weak(isolate, persistent);
    } else {
      return PersistentToLocal::Strong(persistent);
    }
  }

  // Unchecked conversion from a non-weak Persistent<T> to Local<T>,
  // use with care!
  //
  // Do not call persistent.Reset() while the returned Local<T> is still in
  // scope, it will destroy the reference to the object.
  template <class TypeName>
  static inline v8::Local<TypeName> Strong(
      const v8::PersistentBase<TypeName>& persistent) {
    DCHECK(!persistent.IsWeak());
    return *reinterpret_cast<v8::Local<TypeName>*>(
        const_cast<v8::PersistentBase<TypeName>*>(&persistent));
  }

  template <class TypeName>
  static inline v8::Local<TypeName> Weak(
      v8::Isolate* isolate,
      const v8::PersistentBase<TypeName>& persistent) {
    return v8::Local<TypeName>::New(isolate, persistent);
  }
};

// Can be used as a key for std::unordered_map when lookup performance is more
// important than size and the keys are statically used to avoid redundant hash
// computations.
class FastStringKey {
 public:
  constexpr explicit FastStringKey(std::string_view name);

  struct Hash {
    constexpr size_t operator()(const FastStringKey& key) const;
  };
  constexpr bool operator==(const FastStringKey& other) const;

  constexpr std::string_view as_string_view() const;

 private:
  static constexpr size_t HashImpl(std::string_view str);

  const std::string_view name_;
  const size_t cached_hash_;
};

// Like std::static_pointer_cast but for unique_ptr with the default deleter.
template <typename T, typename U>
std::unique_ptr<T> static_unique_pointer_cast(std::unique_ptr<U>&& ptr) {
  return std::unique_ptr<T>(static_cast<T*>(ptr.release()));
}

#define MAYBE_FIELD_PTR(ptr, field) ptr == nullptr ? nullptr : &(ptr->field)

// Returns a non-zero code if it fails to open or read the file,
// aborts if it fails to close the file.
int ReadFileSync(std::string* result, const char* path);
// Reads all contents of a FILE*, aborts if it fails.
std::vector<char> ReadFileSync(FILE* fp);

v8::Local<v8::FunctionTemplate> NewFunctionTemplate(
    v8::Isolate* isolate,
    v8::FunctionCallback callback,
    v8::Local<v8::Signature> signature = v8::Local<v8::Signature>(),
    v8::ConstructorBehavior behavior = v8::ConstructorBehavior::kAllow,
    v8::SideEffectType side_effect = v8::SideEffectType::kHasSideEffect,
    const v8::CFunction* c_function = nullptr);

// Convenience methods for NewFunctionTemplate().
void SetMethod(v8::Local<v8::Context> context,
               v8::Local<v8::Object> that,
               const std::string_view name,
               v8::FunctionCallback callback);
// Similar to SetProtoMethod but without receiver signature checks.
void SetMethod(v8::Isolate* isolate,
               v8::Local<v8::Template> that,
               const std::string_view name,
               v8::FunctionCallback callback);

void SetFastMethod(v8::Isolate* isolate,
                   v8::Local<v8::Template> that,
                   const std::string_view name,
                   v8::FunctionCallback slow_callback,
                   const v8::CFunction* c_function);
void SetFastMethod(v8::Local<v8::Context> context,
                   v8::Local<v8::Object> that,
                   const std::string_view name,
                   v8::FunctionCallback slow_callback,
                   const v8::CFunction* c_function);
void SetFastMethod(v8::Isolate* isolate,
                   v8::Local<v8::Template> that,
                   const std::string_view name,
                   v8::FunctionCallback slow_callback,
                   const v8::MemorySpan<const v8::CFunction>& methods);
void SetFastMethodNoSideEffect(v8::Isolate* isolate,
                               v8::Local<v8::Template> that,
                               const std::string_view name,
                               v8::FunctionCallback slow_callback,
                               const v8::CFunction* c_function);
void SetFastMethodNoSideEffect(v8::Local<v8::Context> context,
                               v8::Local<v8::Object> that,
                               const std::string_view name,
                               v8::FunctionCallback slow_callback,
                               const v8::CFunction* c_function);
void SetFastMethodNoSideEffect(
    v8::Isolate* isolate,
    v8::Local<v8::Template> that,
    const std::string_view name,
    v8::FunctionCallback slow_callback,
    const v8::MemorySpan<const v8::CFunction>& methods);
void SetProtoMethod(v8::Isolate* isolate,
                    v8::Local<v8::FunctionTemplate> that,
                    const std::string_view name,
                    v8::FunctionCallback callback);

void SetInstanceMethod(v8::Isolate* isolate,
                       v8::Local<v8::FunctionTemplate> that,
                       const std::string_view name,
                       v8::FunctionCallback callback);

// Safe variants denote the function has no side effects.
void SetMethodNoSideEffect(v8::Local<v8::Context> context,
                           v8::Local<v8::Object> that,
                           const std::string_view name,
                           v8::FunctionCallback callback);
void SetProtoMethodNoSideEffect(v8::Isolate* isolate,
                                v8::Local<v8::FunctionTemplate> that,
                                const std::string_view name,
                                v8::FunctionCallback callback);
void SetMethodNoSideEffect(v8::Isolate* isolate,
                           v8::Local<v8::Template> that,
                           const std::string_view name,
                           v8::FunctionCallback callback);

enum class SetConstructorFunctionFlag {
  NONE,
  SET_CLASS_NAME,
};

void SetConstructorFunction(v8::Local<v8::Context> context,
                            v8::Local<v8::Object> that,
                            const char* name,
                            v8::Local<v8::FunctionTemplate> tmpl,
                            SetConstructorFunctionFlag flag =
                                SetConstructorFunctionFlag::SET_CLASS_NAME);

void SetConstructorFunction(v8::Local<v8::Context> context,
                            v8::Local<v8::Object> that,
                            v8::Local<v8::String> name,
                            v8::Local<v8::FunctionTemplate> tmpl,
                            SetConstructorFunctionFlag flag =
                                SetConstructorFunctionFlag::SET_CLASS_NAME);

void SetConstructorFunction(v8::Isolate* isolate,
                            v8::Local<v8::Template> that,
                            const char* name,
                            v8::Local<v8::FunctionTemplate> tmpl,
                            SetConstructorFunctionFlag flag =
                                SetConstructorFunctionFlag::SET_CLASS_NAME);

void SetConstructorFunction(v8::Isolate* isolate,
                            v8::Local<v8::Template> that,
                            v8::Local<v8::String> name,
                            v8::Local<v8::FunctionTemplate> tmpl,
                            SetConstructorFunctionFlag flag =
                                SetConstructorFunctionFlag::SET_CLASS_NAME);

// Like RAIIIsolate, except doesn't enter the isolate while it's in scope.
class RAIIIsolateWithoutEntering {
 public:
  explicit RAIIIsolateWithoutEntering(const SnapshotData* data = nullptr);
  ~RAIIIsolateWithoutEntering();

  v8::Isolate* get() const { return isolate_; }

 private:
  std::unique_ptr<v8::ArrayBuffer::Allocator> allocator_;
  v8::Isolate* isolate_;
};

// Simple RAII class to spin up a v8::Isolate instance and enter it
// immediately.
class RAIIIsolate {
 public:
  explicit RAIIIsolate(const SnapshotData* data = nullptr);
  ~RAIIIsolate();

  v8::Isolate* get() const { return isolate_.get(); }

 private:
  RAIIIsolateWithoutEntering isolate_;
  v8::Isolate::Scope isolate_scope_;
};

std::string DetermineSpecificErrorType(Environment* env,
                                       v8::Local<v8::Value> input);

v8::Maybe<int32_t> GetValidatedFd(Environment* env, v8::Local<v8::Value> input);
v8::Maybe<int> GetValidFileMode(Environment* env,
                                v8::Local<v8::Value> input,
                                uv_fs_type type);

// Returns true if OS==Windows and filename ends in .bat or .cmd,
// case insensitive.
inline bool IsWindowsBatchFile(const char* filename);

}  // namespace node

#endif  // defined(NODE_WANT_INTERNALS) && NODE_WANT_INTERNALS

#endif  // SRC_UTIL_H_
                                                                                                               node-23.7.0/src/uv.cc                                                                               0000664 0000000 0000000 00000012204 14746647661 0014304 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

#include "uv.h"
#include "env-inl.h"
#include "node.h"
#include "node_external_reference.h"
#include "node_process-inl.h"

namespace node {

namespace per_process {
struct UVError {
  int value;
  const char* name;
  const char* message;
};

// We only expand the macro once here to reduce the amount of code
// generated.
static const struct UVError uv_errors_map[] = {
#define V(name, message) {UV_##name, #name, message},
    UV_ERRNO_MAP(V)
#undef V
};
}  // namespace per_process

namespace uv {

using v8::Array;
using v8::Context;
using v8::DontDelete;
using v8::FunctionCallbackInfo;
using v8::Integer;
using v8::Isolate;
using v8::Local;
using v8::Map;
using v8::Object;
using v8::PropertyAttribute;
using v8::ReadOnly;
using v8::String;
using v8::Value;

void GetErrMessage(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  int err = args[0].As<v8::Int32>()->Value();
  CHECK_LT(err, 0);
  char message[50];
  uv_strerror_r(err, message, sizeof(message));
  args.GetReturnValue().Set(OneByteString(env->isolate(), message));
}

void ErrName(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  if (env->options()->pending_deprecation && env->EmitErrNameWarning()) {
    if (ProcessEmitDeprecationWarning(
        env,
        "Directly calling process.binding('uv').errname(<val>) is being"
        " deprecated. "
        "Please make sure to use util.getSystemErrorName() instead.",
        "DEP0119").IsNothing())
    return;
  }
  int err = args[0].As<v8::Int32>()->Value();
  CHECK_LT(err, 0);
  char name[50];
  uv_err_name_r(err, name, sizeof(name));
  args.GetReturnValue().Set(OneByteString(env->isolate(), name));
}

void GetErrMap(const FunctionCallbackInfo<Value>& args) {
  Environment* env = Environment::GetCurrent(args);
  Isolate* isolate = env->isolate();
  Local<Context> context = env->context();

  // This can't return a SafeMap, because the uv binding can be referenced
  // by user code by using `process.binding('uv').getErrorMap()`:
  Local<Map> err_map = Map::New(isolate);

  size_t errors_len = arraysize(per_process::uv_errors_map);
  for (size_t i = 0; i < errors_len; ++i) {
    const auto& error = per_process::uv_errors_map[i];
    Local<Value> arr[] = {OneByteString(isolate, error.name),
                          OneByteString(isolate, error.message)};
    if (err_map
            ->Set(context,
                  Integer::New(isolate, error.value),
                  Array::New(isolate, arr, arraysize(arr)))
            .IsEmpty()) {
      return;
    }
  }

  args.GetReturnValue().Set(err_map);
}

void Initialize(Local<Object> target,
                Local<Value> unused,
                Local<Context> context,
                void* priv) {
  Environment* env = Environment::GetCurrent(context);
  Isolate* isolate = env->isolate();
  SetConstructorFunction(
      context, target, "errname", NewFunctionTemplate(isolate, ErrName));

  // TODO(joyeecheung): This should be deprecated in user land in favor of
  // `util.getSystemErrorName(err)`.
  PropertyAttribute attributes =
      static_cast<PropertyAttribute>(ReadOnly | DontDelete);
  size_t errors_len = arraysize(per_process::uv_errors_map);
  const std::string prefix = "UV_";
  for (size_t i = 0; i < errors_len; ++i) {
    const auto& error = per_process::uv_errors_map[i];
    const std::string prefixed_name = prefix + error.name;
    Local<String> name = OneByteString(isolate, prefixed_name);
    Local<Integer> value = Integer::New(isolate, error.value);
    target->DefineOwnProperty(context, name, value, attributes).Check();
  }

  SetMethod(context, target, "getErrorMap", GetErrMap);
  SetMethod(context, target, "getErrorMessage", GetErrMessage);
}

void RegisterExternalReferences(ExternalReferenceRegistry* registry) {
  registry->Register(ErrName);
  registry->Register(GetErrMap);
  registry->Register(GetErrMessage);
}
}  // namespace uv
}  // namespace node

NODE_BINDING_CONTEXT_AWARE_INTERNAL(uv, node::uv::Initialize)
NODE_BINDING_EXTERNAL_REFERENCE(uv, node::uv::RegisterExternalReferences)
                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/src/zlib_version.h                                                                      0000664 0000000 0000000 00000000352 14746647661 0016222 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // This is an auto generated file, please do not edit.
// Refer to tools/dep_updaters/update-zlib.sh
#ifndef SRC_ZLIB_VERSION_H_
#define SRC_ZLIB_VERSION_H_
#define ZLIB_VERSION "1.3.0.1-motley-82a5fec"
#endif  // SRC_ZLIB_VERSION_H_
                                                                                                                                                                                                                                                                                      node-23.7.0/suppressions.supp                                                                       0000664 0000000 0000000 00000000434 14746647661 0016244 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        vptr:deps/icu-small/source/common/uloc_tag.cpp
vptr:deps/icu-small/source/common/unistr.cpp
shift-base:deps/v8/src/wasm/decoder.h
vptr:deps/icu-small/source/common/sharedobject.cpp
vptr:deps/icu-small/source/i18n/coll.cpp
nonnull-attribute:deps/v8/src/snapshot/snapshot-source-sink.h
                                                                                                                                                                                                                                    node-23.7.0/test/                                                                                   0000775 0000000 0000000 00000000000 14746647661 0013534 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/README.md                                                                          0000664 0000000 0000000 00000011234 14746647661 0015014 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # Node.js Core Tests

This directory contains code and data used to test the Node.js implementation.

For a detailed guide on how to write tests in this
directory, see [the guide on writing tests](../doc/contributing/writing-tests.md).

On how to run tests in this directory, see
[the contributing guide](../doc/contributing/pull-requests.md#step-6-test).

For the tests to run on Windows, be sure to clone Node.js source code with the
`autocrlf` git config flag set to true.

## Test Directories

| Directory        | Runs on CI | Purpose                                                                                                       |
| ---------------- | ---------- | ------------------------------------------------------------------------------------------------------------- |
| `abort`          | Yes        | Tests that use `--abort-on-uncaught-exception` and other cases where we want to avoid generating a core file. |
| `addons`         | Yes        | Tests for [addon][] functionality along with some tests that require an addon.                                |
| `async-hooks`    | Yes        | Tests for [async\_hooks][async_hooks] functionality.                                                          |
| `benchmark`      | Yes        | Test minimal functionality of benchmarks.                                                                     |
| `cctest`         | Yes        | C++ tests that are run as part of the build process.                                                          |
| `code-cache`     | No         | Tests for a Node.js binary compiled with V8 code cache.                                                       |
| `common`         | _N/A_      | Common modules shared among many tests.[^1]                                                                   |
| `doctool`        | Yes        | Tests for the documentation generator.                                                                        |
| `es-module`      | Yes        | Test ESM module loading.                                                                                      |
| `fixtures`       | _N/A_      | Test fixtures used in various tests throughout the test suite.                                                |
| `internet`       | No         | Tests that make real outbound network connections.[^2]                                                        |
| `js-native-api`  | Yes        | Tests for Node.js-agnostic [Node-API][] functionality.                                                        |
| `known_issues`   | Yes        | Tests reproducing known issues within the system.[^3]                                                         |
| `message`        | Yes        | Tests for messages that are output for various conditions                                                     |
| `node-api`       | Yes        | Tests for Node.js-specific [Node-API][] functionality.                                                        |
| `parallel`       | Yes        | Various tests that are able to be run in parallel.                                                            |
| `pseudo-tty`     | Yes        | Tests that require stdin/stdout/stderr to be a TTY.                                                           |
| `pummel`         | No         | Various tests for various modules / system functionality operating under load.                                |
| `sequential`     | Yes        | Various tests that must not run in parallel.                                                                  |
| `testpy`         | _N/A_      | Test configuration utility used by various test suites.                                                       |
| `tick-processor` | No         | Tests for the V8 tick processor integration.[^4]                                                              |
| `v8-updates`     | No         | Tests for V8 performance integration.                                                                         |

[^1]: [Documentation](../test/common/README.md)

[^2]: Tests for networking related modules may also be present in other directories, but those tests do
    not make outbound connections.

[^3]: All tests inside of this directory are expected to fail. If a test doesn't fail on certain platforms,
    those should be skipped via `known_issues.status`.

[^4]: The tests are for the logic in `lib/internal/v8_prof_processor.js` and `lib/internal/v8_prof_polyfill.js`.
    The tests confirm that the profile processor packages the correct set of scripts from V8 and introduces the
    correct platform specific logic.

[Node-API]: https://nodejs.org/api/n-api.html
[addon]: https://nodejs.org/api/addons.html
[async_hooks]: https://nodejs.org/api/async_hooks.html
                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/abort/                                                                             0000775 0000000 0000000 00000000000 14746647661 0014643 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/abort/.gitignore                                                                   0000664 0000000 0000000 00000000112 14746647661 0016625 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .buildstamp
.docbuildstamp
Makefile
*.Makefile
*.mk
gyp-mac-tool
/*/build
                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/abort/abort.status                                                                 0000664 0000000 0000000 00000001352 14746647661 0017220 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        prefix abort

# To mark a test as flaky, list the test name in the appropriate section
# below, without ".js", followed by ": PASS,FLAKY". Example:
# sample-test                        : PASS,FLAKY

[true] # This section applies to all platforms

[$system==ibmi]
# https://github.com/nodejs/node/issues/34410
test-addon-register-signal-handler: PASS,FLAKY

[$system==solaris] # Also applies to SmartOS
# https://github.com/nodejs/node/issues/43457
test-abort-fatal-error: PASS, FLAKY
test-abort-uncaught-exception: PASS, FLAKY
test-addon-register-signal-handler: PASS, FLAKY
test-process-abort-exitcode: PASS, FLAKY
test-signal-handler: PASS, FLAKY
test-worker-abort-uncaught-exception: PASS, FLAKY
test-zlib-invalid-internals-usage: PASS, FLAKY
                                                                                                                                                                                                                                                                                      node-23.7.0/test/abort/test-abort-backtrace.js                                                      0000664 0000000 0000000 00000003626 14746647661 0021211 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const cp = require('child_process');

function getPrintedStackTrace(stderr) {
  const lines = stderr.split('\n');

  let state = 'initial';
  const result = {
    message: [],
    nativeStack: [],
    jsStack: [],
  };
  for (let i = 0; i < lines.length; ++i) {
    const line = lines[i].trim();
    if (line.length === 0) {
      continue;  // Skip empty lines.
    }

    switch (state) {
      case 'initial':
        result.message.push(line);
        if (line.includes('Native stack trace')) {
          state = 'native-stack';
        } else {
          result.message.push(line);
        }
        break;
      case 'native-stack':
        if (line.includes('JavaScript stack trace')) {
          state = 'js-stack';
        } else {
          result.nativeStack.push(line);
        }
        break;
      case 'js-stack':
        result.jsStack.push(line);
        break;
    }
  }
  return result;
}

if (process.argv[2] === 'child') {
  process.abort();
} else {
  const child = cp.spawnSync(`${process.execPath}`, [`${__filename}`, 'child']);
  const stderr = child.stderr.toString();

  assert.strictEqual(child.stdout.toString(), '');
  const { nativeStack, jsStack } = getPrintedStackTrace(stderr);

  if (!nativeStack.every((frame, index) => frame.startsWith(`${index + 1}:`))) {
    assert.fail(`Each frame should start with a frame number:\n${stderr}`);
  }

  // For systems that don't support backtraces, the native stack is
  // going to be empty.
  if (process.platform !== 'win32' && nativeStack.length > 0) {
    const { getBinaryPath } = require('../common/shared-lib-util');
    if (!nativeStack.some((frame) => frame.includes(`[${getBinaryPath()}]`))) {
      assert.fail(`Some native stack frame include the binary name:\n${stderr}`);
    }
  }

  if (jsStack.length > 0) {
    assert(jsStack.some((frame) => frame.includes(__filename)));
  }
}
                                                                                                          node-23.7.0/test/abort/test-abort-fatal-error.js                                                    0000664 0000000 0000000 00000003340 14746647661 0021501 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../common');
if (common.isWindows)
  common.skip('no RLIMIT_NOFILE on Windows');

const assert = require('assert');
const exec = require('child_process').exec;

const cmdline =
  common.escapePOSIXShell`ulimit -c 0; "${
    process.execPath
  }" --max-old-space-size=16 --max-semi-space-size=4 -e "a = []; for (i = 0; i < 1e9; i++) { a.push({}) }"`;

exec(...cmdline, common.mustCall((err, stdout, stderr) => {
  if (!err) {
    console.log(stdout);
    console.log(stderr);
    assert(false, 'this test should fail');
  }

  assert(common.nodeProcessAborted(err.code, err.signal));
}));
                                                                                                                                                                                                                                                                                                node-23.7.0/test/abort/test-abort-uncaught-exception.js                                             0000664 0000000 0000000 00000002140 14746647661 0023072 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const spawn = require('child_process').spawn;
const vm = require('vm');
const node = process.execPath;

if (process.argv[2] === 'child') {
  throw new Error('child error');
} else if (process.argv[2] === 'vm') {
  // Refs: https://github.com/nodejs/node/issues/13258
  // This *should* still crash.
  new vm.Script('[', {});
} else {
  run('', 'child', null);
  run('--abort-on-uncaught-exception', 'child',
      ['SIGABRT', 'SIGTRAP', 'SIGILL']);
  run('--abort-on-uncaught-exception', 'vm', ['SIGABRT', 'SIGTRAP', 'SIGILL']);
}

function run(flags, argv2, signals) {
  const args = [__filename, argv2];
  if (flags)
    args.unshift(flags);

  const child = spawn(node, args);
  child.on('exit', common.mustCall(function(code, sig) {
    if (common.isWindows) {
      if (signals)
        assert.strictEqual(code, 0x80000003);
      else
        assert.strictEqual(code, 1);
    } else if (signals) {
      assert(signals.includes(sig), `Unexpected signal ${sig}`);
    } else {
      assert.strictEqual(sig, null);
    }
  }));
}
                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/test/abort/test-addon-register-signal-handler.js                                        0000664 0000000 0000000 00000000275 14746647661 0023757 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');

// This is a sibling test to test/addons/register-signal-handler/

process.env.ALLOW_CRASHES = true;
require('../addons/register-signal-handler/test');
                                                                                                                                                                                                                                                                                                                                   node-23.7.0/test/abort/test-addon-uv-handle-leak.js                                                 0000664 0000000 0000000 00000010267 14746647661 0022044 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const fs = require('fs');
const path = require('path');
const cp = require('child_process');
const { spawnSync } = require('child_process');

// This is a sibling test to test/addons/uv-handle-leak.

const bindingPath = path.resolve(
  __dirname, '..', 'addons', 'uv-handle-leak', 'build',
  `${common.buildType}/binding.node`);

if (!fs.existsSync(bindingPath))
  common.skip('binding not built yet');

if (process.argv[2] === 'child') {

  const { Worker } = require('worker_threads');

  // The worker thread loads and then unloads `bindingPath`. Because of this the
  // symbols in `bindingPath` are lost when the worker thread quits, but the
  // number of open handles in the worker thread's event loop is assessed in the
  // main thread afterwards, and the names of the callbacks associated with the
  // open handles is retrieved at that time as well. Thus, we require
  // `bindingPath` here so that the symbols and their names survive the life
  // cycle of the worker thread.
  require(bindingPath);

  new Worker(`
  const binding = require(${JSON.stringify(bindingPath)});

  binding.leakHandle();
  binding.leakHandle(0);
  binding.leakHandle(0x42);
  `, { eval: true });
} else {
  const child = cp.spawnSync(process.execPath, [__filename, 'child']);
  const stderr = child.stderr.toString();

  assert.strictEqual(child.stdout.toString(), '');

  const lines = stderr.split('\n');

  let state = 'initial';

  // Parse output that is formatted like this:

  // uv loop at [0x559b65ed5770] has open handles:
  // [0x7f2de0018430] timer (active)
  //         Close callback: 0x7f2df31de220 CloseCallback(uv_handle_s*) [...]
  //         Data: 0x7f2df33df140 example_instance [...]
  //         (First field): 0x7f2df33dedc0 vtable for ExampleOwnerClass [...]
  // [0x7f2de000b870] timer
  //         Close callback: 0x7f2df31de220 CloseCallback(uv_handle_s*) [...]
  //         Data: (nil)
  // [0x7f2de000b910] timer
  //         Close callback: 0x7f2df31de220 CloseCallback(uv_handle_s*) [...]
  //         Data: 0x42
  // uv loop at [0x559b65ed5770] has 3 open handles in total

  function isGlibc() {
    try {
      const lddOut = spawnSync('ldd', [process.execPath]).stdout;
      const libcInfo = lddOut.toString().split('\n').map(
        (line) => line.match(/libc\.so.+=>\s*(\S+)\s/)).filter((info) => info);
      if (libcInfo.length === 0)
        return false;
      const nmOut = spawnSync('nm', ['-D', libcInfo[0][1]]).stdout;
      if (/gnu_get_libc_version/.test(nmOut))
        return true;
    } catch {
      return false;
    }
  }


  if (!(common.isFreeBSD ||
        common.isAIX ||
        common.isIBMi ||
        (common.isLinux && !isGlibc()) ||
        common.isWindows)) {
    assert(stderr.includes('ExampleOwnerClass'), stderr);
    assert(stderr.includes('CloseCallback'), stderr);
    assert(stderr.includes('example_instance'), stderr);
  }

  while (lines.length > 0) {
    const line = lines.shift().trim();
    if (line.length === 0) {
      continue;  // Skip empty lines.
    }

    switch (state) {
      case 'initial':
        assert.match(line, /^uv loop at \[.+\] has open handles:$/);
        state = 'handle-start';
        break;
      case 'handle-start':
        if (/^uv loop at \[.+\] has \d+ open handles in total$/.test(line)) {
          state = 'source-line';
          break;
        }
        assert.match(line, /^\[.+\] timer( \(active\))?$/);
        state = 'close-callback';
        break;
      case 'close-callback':
        assert.match(line, /^Close callback:/);
        state = 'data';
        break;
      case 'data':
        assert.match(line, /^Data: .+$/);
        state = 'maybe-first-field';
        break;
      case 'maybe-first-field':
        if (!/^\(First field\)/.test(line)) {
          lines.unshift(line);
        }
        state = 'handle-start';
        break;
      case 'source-line':
        assert.match(line, /CheckedUvLoopClose/);
        state = 'assertion-failure';
        break;
      case 'assertion-failure':
        assert.match(line, /Assertion failed:/);
        state = 'done';
        break;
      case 'done':
        break;
    }
  }

  assert.strictEqual(state, 'done');
}
                                                                                                                                                                                                                                                                                                                                         node-23.7.0/test/abort/test-http-parser-consume.js                                                  0000664 0000000 0000000 00000002251 14746647661 0022076 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const { createServer, get } = require('http');
const { spawn } = require('child_process');

if (process.argv[2] === 'child') {
  // sub-process
  const server = createServer(common.mustCall((_, res) => res.end('h')));
  server.listen(0, common.mustCall(() => {
    const rr = get({ port: server.address().port }, common.mustCall(() => {
      // This bad input (0) should abort the parser and the process
      rr.parser.consume(0);
      // This line should be unreachable.
      assert.fail('this should be unreachable');
    }));
  }));
} else {
  // super-process
  const child = spawn(process.execPath, [__filename, 'child']);
  child.stdout.on('data', common.mustNotCall());

  let stderr = '';
  child.stderr.on('data', common.mustCallAtLeast((data) => {
    assert(Buffer.isBuffer(data));
    stderr += data.toString('utf8');
  }, 1));
  child.on('exit', common.mustCall((code, signal) => {
    assert(stderr.includes('failed'), `stderr: ${stderr}`);
    const didAbort = common.nodeProcessAborted(code, signal);
    assert(didAbort, `process did not abort, code:${code} signal:${signal}`);
  }));
}
                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/test/abort/test-process-abort-exitcode.js                                               0000664 0000000 0000000 00000001320 14746647661 0022537 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');

// This test makes sure that an aborted node process
// exits with code 3 on Windows, and SIGABRT on POSIX.
// Spawn a child, force an abort, and then check the
// exit code in the parent.

const spawn = require('child_process').spawn;
if (process.argv[2] === 'child') {
  process.abort();
} else {
  const child = spawn(process.execPath, [__filename, 'child']);
  child.on('exit', common.mustCall((code, signal) => {
    if (common.isWindows) {
      assert.strictEqual(code, 134);
      assert.strictEqual(signal, null);
    } else {
      assert.strictEqual(code, null);
      assert.strictEqual(signal, 'SIGABRT');
    }
  }));
}
                                                                                                                                                                                                                                                                                                                node-23.7.0/test/abort/test-signal-handler.js                                                       0000664 0000000 0000000 00000001643 14746647661 0021052 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
if (common.isWindows)
  common.skip('No signals on Window');

const assert = require('assert');
const { spawnSync } = require('child_process');

// Test that a hard crash does not cause an endless loop.

if (process.argv[2] === 'child') {
  const { internalBinding } = require('internal/test/binding');
  const { causeSegfault } = internalBinding('process_methods');

  causeSegfault();
} else {
  const child = spawnSync(process.execPath,
                          ['--expose-internals', __filename, 'child'],
                          { stdio: 'inherit' });
  // FreeBSD uses SIGILL (v12.2) or SIGBUS (v12.4 and greater) for this kind of crash.
  // macOS uses SIGILL or SIGTRAP (arm64) for this kind of crash.
  const allowedSignals = ['SIGSEGV', 'SIGILL', 'SIGTRAP', 'SIGBUS'];
  assert(
    allowedSignals.includes(child.signal),
    `child.signal = ${child.signal}`,
  );
}
                                                                                             node-23.7.0/test/abort/test-worker-abort-uncaught-exception.js                                      0000664 0000000 0000000 00000001263 14746647661 0024406 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const { spawn } = require('child_process');
const { Worker } = require('worker_threads');

// Tests that --abort-on-uncaught-exception applies to workers as well.

if (process.argv[2] === 'child') {
  new Worker('throw new Error("foo");', { eval: true });
  return;
}

const child = spawn(process.execPath, [
  '--abort-on-uncaught-exception', __filename, 'child',
]);
child.on('exit', common.mustCall((code, sig) => {
  if (common.isWindows) {
    assert.strictEqual(code, 0x80000003);
  } else {
    assert(['SIGABRT', 'SIGTRAP', 'SIGILL'].includes(sig),
           `Unexpected signal ${sig}`);
  }
}));
                                                                                                                                                                                                                                                                                                                                             node-23.7.0/test/abort/test-zlib-invalid-internals-usage.js                                         0000664 0000000 0000000 00000001563 14746647661 0023646 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const os = require('os');
const cp = require('child_process');

if (process.argv[2] === 'child') {
  const { internalBinding } = require('internal/test/binding');
  // This is the heart of the test.
  new (internalBinding('zlib').Zlib)(0).init(1, 2, 3, 4, 5);
} else {
  const child = cp.spawnSync(
    `${process.execPath}`, ['--expose-internals', `${__filename}`, 'child']);

  assert.strictEqual(child.stdout.toString(), '');
  assert.ok(child.stderr.includes(
    'WARNING: You are likely using a version of node-tar or npm that ' +
    `is incompatible with this version of Node.js.${os.EOL}` +
    'Please use either the version of npm that is bundled with Node.js, or ' +
    'a version of npm (> 5.5.1 or < 5.4.0) or node-tar (> 4.0.1) that is ' +
    `compatible with Node.js 9 and above.${os.EOL}`));
}
                                                                                                                                             node-23.7.0/test/abort/testcfg.py                                                                   0000664 0000000 0000000 00000000301 14746647661 0016646 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        import sys, os
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))
import testpy

def GetConfiguration(context, root):
  return testpy.AbortTestConfiguration(context, root, 'abort')
                                                                                                                                                                                                                                                                                                                               node-23.7.0/test/addons/                                                                            0000775 0000000 0000000 00000000000 14746647661 0015004 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/.gitignore                                                                  0000664 0000000 0000000 00000000144 14746647661 0016773 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        .buildstamp
.docbuildstamp
Makefile
*.Makefile
*.mk
gyp-mac-tool
/*/build
/esm/node_modules/*/build
                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/test/addons/addons.status                                                               0000664 0000000 0000000 00000001374 14746647661 0017526 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        prefix addons

# To mark a test as flaky, list the test name in the appropriate section
# below, without ".js", followed by ": PASS,FLAKY". Example:
# sample-test                        : PASS,FLAKY

[true] # This section applies to all platforms

[$arch==arm]
# https://github.com/nodejs/node/issues/30786
openssl-binding/test: PASS,FLAKY

[$system==ibmi]
openssl-binding/test: SKIP
openssl-providers/test-default-only-config: SKIP
openssl-providers/test-legacy-provider-config: SKIP
openssl-providers/test-legacy-provider-inactive-config: SKIP
openssl-providers/test-legacy-provider-option: SKIP
openssl-providers/test-no-legacy-provider-option: SKIP
zlib-binding/test: SKIP
# https://github.com/nodejs/node/issues/34410
register-signal-handler/test: PASS,FLAKY
                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/async-cleanup-hook/                                                         0000775 0000000 0000000 00000000000 14746647661 0020504 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/async-cleanup-hook/binding.cc                                               0000664 0000000 0000000 00000003347 14746647661 0022434 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node.h>
#include <uv.h>
#include <assert.h>

void MustNotCall(void* arg, void(*cb)(void*), void* cbarg) {
  assert(0);
}

struct AsyncData {
  uv_async_t async;
  v8::Isolate* isolate;
  node::AsyncCleanupHookHandle handle;
  void (*done_cb)(void*);
  void* done_arg;
};

void AsyncCleanupHook(void* arg, void(*cb)(void*), void* cbarg) {
  AsyncData* data = static_cast<AsyncData*>(arg);
  uv_loop_t* loop = node::GetCurrentEventLoop(data->isolate);
  assert(loop != nullptr);
  int err = uv_async_init(loop, &data->async, [](uv_async_t* async) {
    AsyncData* data = static_cast<AsyncData*>(async->data);
    // Attempting to remove the cleanup hook here should be a no-op since it
    // has already been started.
    node::RemoveEnvironmentCleanupHook(std::move(data->handle));

    uv_close(reinterpret_cast<uv_handle_t*>(async), [](uv_handle_t* handle) {
      AsyncData* data = static_cast<AsyncData*>(handle->data);
      data->done_cb(data->done_arg);
      delete data;
    });
  });
  assert(err == 0);

  data->async.data = data;
  data->done_cb = cb;
  data->done_arg = cbarg;
  uv_async_send(&data->async);
}

void Initialize(v8::Local<v8::Object> exports,
                v8::Local<v8::Value> module,
                v8::Local<v8::Context> context) {
  AsyncData* data = new AsyncData();
  data->isolate = context->GetIsolate();
  auto handle = node::AddEnvironmentCleanupHook(
      context->GetIsolate(),
      AsyncCleanupHook,
      data);
  data->handle = std::move(handle);

  auto must_not_call_handle = node::AddEnvironmentCleanupHook(
      context->GetIsolate(),
      MustNotCall,
      nullptr);
  node::RemoveEnvironmentCleanupHook(std::move(must_not_call_handle));
}

NODE_MODULE_CONTEXT_AWARE(NODE_GYP_MODULE_NAME, Initialize)
                                                                                                                                                                                                                                                                                         node-23.7.0/test/addons/async-cleanup-hook/binding.gyp                                              0000664 0000000 0000000 00000000214 14746647661 0022634 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/async-cleanup-hook/test.js                                                  0000664 0000000 0000000 00000000527 14746647661 0022025 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common');
const path = require('path');
const { Worker } = require('worker_threads');
const binding = path.resolve(__dirname, `./build/${common.buildType}/binding`);

const w = new Worker(`require(${JSON.stringify(binding)})`, { eval: true });
w.on('exit', common.mustCall(() => require(binding)));
                                                                                                                                                                         node-23.7.0/test/addons/async-hello-world/                                                          0000775 0000000 0000000 00000000000 14746647661 0020347 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/async-hello-world/binding.cc                                                0000664 0000000 0000000 00000004624 14746647661 0022276 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node.h>
#include <v8.h>
#include <uv.h>

struct async_req {
  uv_work_t req;
  int input;
  int output;
  v8::Isolate* isolate;
  v8::Global<v8::Function> callback;
  node::async_context context;
};

void DoAsync(uv_work_t* r) {
  async_req* req = reinterpret_cast<async_req*>(r->data);
  // Simulate CPU intensive process...
  uv_sleep(1000);
  req->output = req->input * 2;
}

template <bool use_makecallback>
void AfterAsync(uv_work_t* r) {
  async_req* req = reinterpret_cast<async_req*>(r->data);
  v8::Isolate* isolate = req->isolate;
  v8::HandleScope scope(isolate);

  v8::Local<v8::Value> argv[2] = {
    v8::Null(isolate),
    v8::Integer::New(isolate, req->output)
  };

  v8::TryCatch try_catch(isolate);

  v8::Local<v8::Object> global = isolate->GetCurrentContext()->Global();
  v8::Local<v8::Function> callback =
      v8::Local<v8::Function>::New(isolate, req->callback);

  if (use_makecallback) {
    v8::Local<v8::Value> ret =
        node::MakeCallback(isolate, global, callback, 2, argv, req->context)
            .ToLocalChecked();
    // This should be changed to an empty handle.
    assert(!ret.IsEmpty());
  } else {
    callback->Call(isolate->GetCurrentContext(),
                   global, 2, argv).ToLocalChecked();
  }

  // None of the following operations should allocate handles into this scope.
  v8::SealHandleScope seal_handle_scope(isolate);
  // cleanup
  node::EmitAsyncDestroy(isolate, req->context);
  delete req;

  if (try_catch.HasCaught()) {
    node::FatalException(isolate, try_catch);
  }
}

template <bool use_makecallback>
void Method(const v8::FunctionCallbackInfo<v8::Value>& args) {
  v8::Isolate* isolate = args.GetIsolate();

  async_req* req = new async_req;
  req->req.data = req;

  req->input = args[0].As<v8::Integer>()->Value();
  req->output = 0;
  req->isolate = isolate;
  req->context = node::EmitAsyncInit(isolate, v8::Object::New(isolate), "test");

  v8::Local<v8::Function> callback = v8::Local<v8::Function>::Cast(args[1]);
  req->callback.Reset(isolate, callback);

  uv_queue_work(node::GetCurrentEventLoop(isolate),
                &req->req,
                DoAsync,
                (uv_after_work_cb)AfterAsync<use_makecallback>);
}

void init(v8::Local<v8::Object> exports, v8::Local<v8::Object> module) {
  NODE_SET_METHOD(exports, "runCall", Method<false>);
  NODE_SET_METHOD(exports, "runMakeCallback", Method<true>);
}

NODE_MODULE(NODE_GYP_MODULE_NAME, init)
                                                                                                            node-23.7.0/test/addons/async-hello-world/binding.gyp                                               0000664 0000000 0000000 00000000214 14746647661 0022477 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/async-hello-world/test-makecallback-uncaught.js                             0000664 0000000 0000000 00000000402 14746647661 0026064 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common');
const { runMakeCallback } = require(`./build/${common.buildType}/binding`);

process.on('uncaughtException', common.mustCall());

runMakeCallback(5, common.mustCall(() => {
  throw new Error('foo');
}));
                                                                                                                                                                                                                                                              node-23.7.0/test/addons/async-hello-world/test-makecallback.js                                      0000664 0000000 0000000 00000000504 14746647661 0024253 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common');
const assert = require('assert');
const { runMakeCallback } = require(`./build/${common.buildType}/binding`);

runMakeCallback(5, common.mustCall((err, val) => {
  assert.strictEqual(err, null);
  assert.strictEqual(val, 10);
  process.nextTick(common.mustCall());
}));
                                                                                                                                                                                            node-23.7.0/test/addons/async-hello-world/test.js                                                   0000664 0000000 0000000 00000000464 14746647661 0021670 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common');
const assert = require('assert');
const { runCall } = require(`./build/${common.buildType}/binding`);

runCall(5, common.mustCall((err, val) => {
  assert.strictEqual(err, null);
  assert.strictEqual(val, 10);
  process.nextTick(common.mustCall());
}));
                                                                                                                                                                                                            node-23.7.0/test/addons/async-hooks-id/                                                             0000775 0000000 0000000 00000000000 14746647661 0017634 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/async-hooks-id/binding.cc                                                   0000664 0000000 0000000 00000001264 14746647661 0021560 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "node.h"

namespace {

using v8::FunctionCallbackInfo;
using v8::Local;
using v8::Object;
using v8::Value;

void GetExecutionAsyncId(const FunctionCallbackInfo<Value>& args) {
  args.GetReturnValue().Set(
    node::AsyncHooksGetExecutionAsyncId(args.GetIsolate()));
}

void GetTriggerAsyncId(const FunctionCallbackInfo<Value>& args) {
  args.GetReturnValue().Set(
    node::AsyncHooksGetTriggerAsyncId(args.GetIsolate()));
}

void Initialize(Local<Object> exports) {
  NODE_SET_METHOD(exports, "getExecutionAsyncId", GetExecutionAsyncId);
  NODE_SET_METHOD(exports, "getTriggerAsyncId", GetTriggerAsyncId);
}

}  // anonymous namespace

NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)
                                                                                                                                                                                                                                                                                                                                            node-23.7.0/test/addons/async-hooks-id/binding.gyp                                                  0000664 0000000 0000000 00000000214 14746647661 0021764 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/async-hooks-id/test.js                                                      0000664 0000000 0000000 00000001145 14746647661 0021152 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
const assert = require('assert');
const binding = require(`./build/${common.buildType}/binding`);
const async_hooks = require('async_hooks');

assert.strictEqual(
  binding.getExecutionAsyncId(),
  async_hooks.executionAsyncId(),
);
assert.strictEqual(
  binding.getTriggerAsyncId(),
  async_hooks.triggerAsyncId(),
);

process.nextTick(common.mustCall(() => {
  assert.strictEqual(
    binding.getExecutionAsyncId(),
    async_hooks.executionAsyncId(),
  );
  assert.strictEqual(
    binding.getTriggerAsyncId(),
    async_hooks.triggerAsyncId(),
  );
}));
                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/test/addons/async-resource/                                                             0000775 0000000 0000000 00000000000 14746647661 0017746 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/async-resource/binding.cc                                                   0000664 0000000 0000000 00000010633 14746647661 0021672 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "node.h"

#include <assert.h>
#include <vector>

namespace {

using node::AsyncResource;
using v8::External;
using v8::Function;
using v8::FunctionCallbackInfo;
using v8::Integer;
using v8::Isolate;
using v8::Local;
using v8::MaybeLocal;
using v8::Object;
using v8::String;
using v8::Value;

int custom_async_resource_destructor_calls = 0;

class CustomAsyncResource : public AsyncResource {
 public:
  CustomAsyncResource(Isolate* isolate, Local<Object> resource)
      : AsyncResource(isolate, resource, "CustomAsyncResource") {}
  ~CustomAsyncResource() {
    custom_async_resource_destructor_calls++;
  }
};

void CreateAsyncResource(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  assert(args[0]->IsObject());
  AsyncResource* r;
  if (args[1]->IsInt32()) {
    r = new AsyncResource(isolate, args[0].As<Object>(), "foobär",
                          args[1].As<Integer>()->Value());
  } else {
    r = new AsyncResource(isolate, args[0].As<Object>(), "foobär");
  }

  args.GetReturnValue().Set(
      External::New(isolate, static_cast<void*>(r)));
}

void DestroyAsyncResource(const FunctionCallbackInfo<Value>& args) {
  assert(args[0]->IsExternal());
  auto r = static_cast<AsyncResource*>(args[0].As<External>()->Value());
  delete r;
}

void CallViaFunction(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  assert(args[0]->IsExternal());
  auto r = static_cast<AsyncResource*>(args[0].As<External>()->Value());

  Local<String> name =
      String::NewFromUtf8(isolate, "methöd").ToLocalChecked();
  Local<Value> fn =
      r->get_resource()->Get(isolate->GetCurrentContext(), name)
      .ToLocalChecked();
  assert(fn->IsFunction());

  Local<Value> arg = Integer::New(isolate, 42);
  MaybeLocal<Value> ret = r->MakeCallback(fn.As<Function>(), 1, &arg);
  args.GetReturnValue().Set(ret.FromMaybe(Local<Value>()));
}

void CallViaString(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  assert(args[0]->IsExternal());
  auto r = static_cast<AsyncResource*>(args[0].As<External>()->Value());

  Local<String> name =
      String::NewFromUtf8(isolate, "methöd").ToLocalChecked();

  Local<Value> arg = Integer::New(isolate, 42);
  MaybeLocal<Value> ret = r->MakeCallback(name, 1, &arg);
  args.GetReturnValue().Set(ret.FromMaybe(Local<Value>()));
}

void CallViaUtf8Name(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  assert(args[0]->IsExternal());
  auto r = static_cast<AsyncResource*>(args[0].As<External>()->Value());

  Local<Value> arg = Integer::New(isolate, 42);
  MaybeLocal<Value> ret = r->MakeCallback("methöd", 1, &arg);
  args.GetReturnValue().Set(ret.FromMaybe(Local<Value>()));
}

void GetAsyncId(const FunctionCallbackInfo<Value>& args) {
  assert(args[0]->IsExternal());
  auto r = static_cast<AsyncResource*>(args[0].As<External>()->Value());
  args.GetReturnValue().Set(r->get_async_id());
}

void GetTriggerAsyncId(const FunctionCallbackInfo<Value>& args) {
  assert(args[0]->IsExternal());
  auto r = static_cast<AsyncResource*>(args[0].As<External>()->Value());
  args.GetReturnValue().Set(r->get_trigger_async_id());
}

void GetResource(const FunctionCallbackInfo<Value>& args) {
  assert(args[0]->IsExternal());
  auto r = static_cast<AsyncResource*>(args[0].As<External>()->Value());
  args.GetReturnValue().Set(r->get_resource());
}

void RunSubclassTest(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  Local<Object> obj = Object::New(isolate);

  assert(custom_async_resource_destructor_calls == 0);
  CustomAsyncResource* resource = new CustomAsyncResource(isolate, obj);
  delete static_cast<AsyncResource*>(resource);
  assert(custom_async_resource_destructor_calls == 1);
}

void Initialize(Local<Object> exports) {
  NODE_SET_METHOD(exports, "createAsyncResource", CreateAsyncResource);
  NODE_SET_METHOD(exports, "destroyAsyncResource", DestroyAsyncResource);
  NODE_SET_METHOD(exports, "callViaFunction", CallViaFunction);
  NODE_SET_METHOD(exports, "callViaString", CallViaString);
  NODE_SET_METHOD(exports, "callViaUtf8Name", CallViaUtf8Name);
  NODE_SET_METHOD(exports, "getAsyncId", GetAsyncId);
  NODE_SET_METHOD(exports, "getTriggerAsyncId", GetTriggerAsyncId);
  NODE_SET_METHOD(exports, "getResource", GetResource);
  NODE_SET_METHOD(exports, "runSubclassTest", RunSubclassTest);
}

}  // anonymous namespace

NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)
                                                                                                     node-23.7.0/test/addons/async-resource/binding.gyp                                                  0000664 0000000 0000000 00000000214 14746647661 0022076 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/async-resource/test.js                                                      0000664 0000000 0000000 00000004323 14746647661 0021265 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
const assert = require('assert');
const binding = require(`./build/${common.buildType}/binding`);
const async_hooks = require('async_hooks');

binding.runSubclassTest();

const kObjectTag = Symbol('kObjectTag');
const rootAsyncId = async_hooks.executionAsyncId();

const bindingUids = [];
let expectedTriggerId;
let before = 0;
let after = 0;
let destroy = 0;

async_hooks.createHook({
  init(id, type, triggerAsyncId, resource) {
    assert.strictEqual(typeof id, 'number');
    assert.strictEqual(typeof resource, 'object');
    assert(id > 1);
    if (type === 'foobär') {
      assert.strictEqual(resource.kObjectTag, kObjectTag);
      assert.strictEqual(triggerAsyncId, expectedTriggerId);
      bindingUids.push(id);
    }
  },

  before(id) {
    if (bindingUids.includes(id)) before++;
  },

  after(id) {
    if (bindingUids.includes(id)) after++;
  },

  destroy(id) {
    if (bindingUids.includes(id)) destroy++;
  },
}).enable();

for (const call of [binding.callViaFunction,
                    binding.callViaString,
                    binding.callViaUtf8Name]) {
  for (const passedTriggerId of [undefined, 12345]) {
    let uid;
    const object = {
      methöd(arg) {
        assert.strictEqual(this, object);
        assert.strictEqual(arg, 42);
        assert.strictEqual(async_hooks.executionAsyncId(), uid);
        return 'baz';
      },
      kObjectTag,
    };

    if (passedTriggerId === undefined)
      expectedTriggerId = rootAsyncId;
    else
      expectedTriggerId = passedTriggerId;

    const resource = binding.createAsyncResource(object, passedTriggerId);
    uid = bindingUids[bindingUids.length - 1];

    const ret = call(resource);
    assert.strictEqual(ret, 'baz');
    assert.strictEqual(binding.getResource(resource), object);
    assert.strictEqual(binding.getAsyncId(resource), uid);
    assert.strictEqual(binding.getTriggerAsyncId(resource), expectedTriggerId);

    binding.destroyAsyncResource(resource);
  }
}

setImmediate(common.mustCall(() => {
  assert.strictEqual(bindingUids.length, 6);
  assert.strictEqual(before, bindingUids.length);
  assert.strictEqual(after, bindingUids.length);
  assert.strictEqual(destroy, bindingUids.length);
}));
                                                                                                                                                                                                                                                                                                             node-23.7.0/test/addons/buffer-free-callback/                                                       0000775 0000000 0000000 00000000000 14746647661 0020726 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/buffer-free-callback/binding.cc                                             0000664 0000000 0000000 00000002166 14746647661 0022654 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node.h>
#include <node_buffer.h>
#include <v8.h>

#include <assert.h>

static int alive;
static char buf[1024];

static void FreeCallback(char* data, void* hint) {
  alive--;
}

void Alloc(const v8::FunctionCallbackInfo<v8::Value>& args) {
  v8::Isolate* isolate = args.GetIsolate();
  alive++;

  uintptr_t alignment = args[1].As<v8::Integer>()->Value();
  uintptr_t offset = args[2].As<v8::Integer>()->Value();

  uintptr_t static_offset = reinterpret_cast<uintptr_t>(buf) % alignment;
  char* aligned = buf + (alignment - static_offset) + offset;

  args.GetReturnValue().Set(node::Buffer::New(
        isolate,
        aligned,
        args[0].As<v8::Integer>()->Value(),
        FreeCallback,
        nullptr).ToLocalChecked());
}

void Check(const v8::FunctionCallbackInfo<v8::Value>& args) {
  v8::Isolate* isolate = args.GetIsolate();
  isolate->RequestGarbageCollectionForTesting(
      v8::Isolate::kFullGarbageCollection);
  assert(alive > 0);
}

void init(v8::Local<v8::Object> exports) {
  NODE_SET_METHOD(exports, "alloc", Alloc);
  NODE_SET_METHOD(exports, "check", Check);
}

NODE_MODULE(NODE_GYP_MODULE_NAME, init)
                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/test/addons/buffer-free-callback/binding.gyp                                            0000664 0000000 0000000 00000000214 14746647661 0023056 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/buffer-free-callback/test.js                                                0000664 0000000 0000000 00000001531 14746647661 0022243 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// Flags: --expose-gc

const common = require('../../common');
const binding = require(`./build/${common.buildType}/binding`);

function check(size, alignment, offset) {
  let buf = binding.alloc(size, alignment, offset);
  let slice = buf.slice(size >>> 1);

  buf = null;
  binding.check(slice);
  slice = null;
  global.gc();
  global.gc();
  global.gc();
}

// NOTE: If adding more check() test cases,
// be sure to not duplicate alignment/offset.
// Refs: https://github.com/nodejs/node/issues/31061#issuecomment-568612283

check(64, 1, 0);

// Buffers can have weird sizes.
check(97, 1, 1);

// Buffers can be unaligned
check(64, 8, 0);
check(64, 16, 0);
check(64, 8, 1);
check(64, 16, 1);
check(97, 8, 3);
check(97, 16, 3);
check(97, 8, 5);
check(97, 16, 5);

// Empty ArrayBuffer does not allocate data, worth checking
check(0, 1, 2);
                                                                                                                                                                       node-23.7.0/test/addons/callback-scope/                                                             0000775 0000000 0000000 00000000000 14746647661 0017647 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/callback-scope/binding.cc                                                   0000664 0000000 0000000 00000004510 14746647661 0021570 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "node.h"
#include "v8.h"
#include "uv.h"

#include <assert.h>
#include <vector>
#include <memory>

namespace {

void RunInCallbackScope(const v8::FunctionCallbackInfo<v8::Value>& args) {
  v8::Isolate* isolate = args.GetIsolate();

  assert(args.Length() == 4);
  assert(args[0]->IsObject());
  assert(args[1]->IsNumber());
  assert(args[2]->IsNumber());
  assert(args[3]->IsFunction());

  node::async_context asyncContext = {
    args[1].As<v8::Number>()->Value(),
    args[2].As<v8::Number>()->Value()
  };

  node::CallbackScope scope(isolate, args[0].As<v8::Object>(), asyncContext);
  v8::Local<v8::Function> fn = args[3].As<v8::Function>();

  v8::MaybeLocal<v8::Value> ret =
      fn->Call(isolate->GetCurrentContext(), args[0], 0, nullptr);

  if (!ret.IsEmpty())
    args.GetReturnValue().Set(ret.ToLocalChecked());
}

static void Callback(uv_work_t* req, int ignored) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  v8::HandleScope scope(isolate);
  node::CallbackScope callback_scope(isolate, v8::Object::New(isolate),
                                     node::async_context{0, 0});
  std::unique_ptr<v8::Global<v8::Promise::Resolver>> persistent {
      static_cast<v8::Global<v8::Promise::Resolver>*>(req->data) };
  v8::Local<v8::Promise::Resolver> local = persistent->Get(isolate);
  local->Resolve(isolate->GetCurrentContext(),
                 v8::Undefined(isolate)).ToChecked();
  delete req;
}

static void TestResolveAsync(const v8::FunctionCallbackInfo<v8::Value>& args) {
  v8::Isolate* isolate = args.GetIsolate();

  v8::Global<v8::Promise::Resolver>* persistent =
      new v8::Global<v8::Promise::Resolver>(
          isolate,
          v8::Promise::Resolver::New(
              isolate->GetCurrentContext()).ToLocalChecked());

  uv_work_t* req = new uv_work_t;
  req->data = static_cast<void*>(persistent);

  uv_queue_work(node::GetCurrentEventLoop(isolate),
                req,
                [](uv_work_t*) {},
                Callback);

  v8::Local<v8::Promise::Resolver> local = persistent->Get(isolate);

  args.GetReturnValue().Set(local->GetPromise());
}

void Initialize(v8::Local<v8::Object> exports) {
  NODE_SET_METHOD(exports, "runInCallbackScope", RunInCallbackScope);
  NODE_SET_METHOD(exports, "testResolveAsync", TestResolveAsync);
}

}  // anonymous namespace

NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)
                                                                                                                                                                                        node-23.7.0/test/addons/callback-scope/binding.gyp                                                  0000664 0000000 0000000 00000000214 14746647661 0021777 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/callback-scope/test-async-hooks.js                                          0000664 0000000 0000000 00000001037 14746647661 0023421 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
const assert = require('assert');
const async_hooks = require('async_hooks');
const { runInCallbackScope } = require(`./build/${common.buildType}/binding`);

let insideHook = false;
async_hooks.createHook({
  before: common.mustCall((id) => {
    assert.strictEqual(id, 1000);
    insideHook = true;
  }),
  after: common.mustCall((id) => {
    assert.strictEqual(id, 1000);
    insideHook = false;
  }),
}).enable();

runInCallbackScope({}, 1000, 1000, () => {
  assert(insideHook);
});
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/test/addons/callback-scope/test-resolve-async.js                                        0000664 0000000 0000000 00000000527 14746647661 0023760 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
const assert = require('assert');
const { testResolveAsync } = require(`./build/${common.buildType}/binding`);

// Checks that resolving promises from C++ works.

let called = false;
testResolveAsync().then(() => { called = true; });

process.on('beforeExit', () => { assert(called); });
                                                                                                                                                                         node-23.7.0/test/addons/callback-scope/test.js                                                      0000664 0000000 0000000 00000000652 14746647661 0021167 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
const assert = require('assert');
const { runInCallbackScope } = require(`./build/${common.buildType}/binding`);

assert.strictEqual(runInCallbackScope({}, 0, 0, () => 42), 42);

{
  process.once('uncaughtException', common.mustCall((err) => {
    assert.strictEqual(err.message, 'foo');
  }));

  runInCallbackScope({}, 0, 0, () => {
    throw new Error('foo');
  });
}
                                                                                      node-23.7.0/test/addons/common.gypi                                                                 0000664 0000000 0000000 00000000312 14746647661 0017162 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'defines': [ 'V8_DEPRECATION_WARNINGS=1' ],
  'conditions': [
    [ 'OS in "linux freebsd openbsd solaris android aix os400 cloudabi"', {
      'cflags': ['-Wno-cast-function-type'],
    }],
  ],
}
                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/addons/cppgc-object/                                                               0000775 0000000 0000000 00000000000 14746647661 0017344 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/cppgc-object/binding.cc                                                     0000664 0000000 0000000 00000004475 14746647661 0021277 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <assert.h>
#include <cppgc/allocation.h>
#include <cppgc/garbage-collected.h>
#include <cppgc/heap.h>
#include <node.h>
#include <v8-cppgc.h>
#include <v8-sandbox.h>
#include <v8.h>
#include <algorithm>

class CppGCed : public cppgc::GarbageCollected<CppGCed> {
 public:
  static uint16_t states[2];
  static constexpr int kDestructCount = 0;
  static constexpr int kTraceCount = 1;

  static void New(const v8::FunctionCallbackInfo<v8::Value>& args) {
    v8::Isolate* isolate = args.GetIsolate();
    v8::Local<v8::Object> js_object = args.This();
    auto* heap = isolate->GetCppHeap();
    assert(heap != nullptr);
    CppGCed* gc_object =
        cppgc::MakeGarbageCollected<CppGCed>(heap->GetAllocationHandle());
    node::SetCppgcReference(isolate, js_object, gc_object);
    args.GetReturnValue().Set(js_object);
  }

  static v8::Local<v8::Function> GetConstructor(
      v8::Local<v8::Context> context) {
    auto ft = v8::FunctionTemplate::New(context->GetIsolate(), New);
    return ft->GetFunction(context).ToLocalChecked();
  }

  CppGCed() = default;

  ~CppGCed() { states[kDestructCount]++; }

  void Trace(cppgc::Visitor* visitor) const { states[kTraceCount]++; }
};

uint16_t CppGCed::states[] = {0, 0};

void InitModule(v8::Local<v8::Object> exports) {
  v8::Isolate* isolate = v8::Isolate::GetCurrent();
  auto context = isolate->GetCurrentContext();

  auto store = v8::ArrayBuffer::NewBackingStore(
      CppGCed::states,
      sizeof(uint16_t) * 2,
      [](void*, size_t, void*) {},
      nullptr);
  auto ab = v8::ArrayBuffer::New(isolate, std::move(store));

  exports
      ->Set(context,
            v8::String::NewFromUtf8(isolate, "CppGCed").ToLocalChecked(),
            CppGCed::GetConstructor(context))
      .FromJust();
  exports
      ->Set(context,
            v8::String::NewFromUtf8(isolate, "states").ToLocalChecked(),
            v8::Uint16Array::New(ab, 0, 2))
      .FromJust();
  exports
      ->Set(context,
            v8::String::NewFromUtf8(isolate, "kDestructCount").ToLocalChecked(),
            v8::Integer::New(isolate, CppGCed::kDestructCount))
      .FromJust();
  exports
      ->Set(context,
            v8::String::NewFromUtf8(isolate, "kTraceCount").ToLocalChecked(),
            v8::Integer::New(isolate, CppGCed::kTraceCount))
      .FromJust();
}

NODE_MODULE(NODE_GYP_MODULE_NAME, InitModule)
                                                                                                                                                                                                   node-23.7.0/test/addons/cppgc-object/binding.gyp                                                    0000664 0000000 0000000 00000000214 14746647661 0021474 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/cppgc-object/test.js                                                        0000664 0000000 0000000 00000002560 14746647661 0020664 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

// Flags: --expose-gc

const common = require('../../common');
const { gcUntil } = require('../../common/gc');
// Verify that addons can create GarbageCollected objects and
// have them traced properly.

const assert = require('assert');
const {
  CppGCed, states, kDestructCount, kTraceCount,
} = require(`./build/${common.buildType}/binding`);

assert.strictEqual(states[kDestructCount], 0);
assert.strictEqual(states[kTraceCount], 0);

let array = [];
const count = 100;
for (let i = 0; i < count; ++i) {
  array.push(new CppGCed());
}

globalThis.gc();

setTimeout(async function() {
  // GC should have invoked Trace() on at least some of the CppGCed objects,
  // but they should all be alive at this point.
  assert.strictEqual(states[kDestructCount], 0);
  assert.notStrictEqual(states[kTraceCount], 0);

  // Replace the old CppGCed objects with new ones, after GC we should have
  // destructed all the old ones and called Trace() on the
  // new ones.
  for (let i = 0; i < count; ++i) {
    array[i] = new CppGCed();
  }
  await gcUntil(
    'All old CppGCed are destroyed',
    () => states[kDestructCount] === count,
  );
  // Release all the CppGCed objects, after GC we should have destructed
  // all of them.
  array = null;
  globalThis.gc();

  await gcUntil(
    'All old CppGCed are destroyed',
    () => states[kDestructCount] === count * 2,
  );
}, 1);
                                                                                                                                                node-23.7.0/test/addons/dlopen-ping-pong/                                                           0000775 0000000 0000000 00000000000 14746647661 0020161 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/dlopen-ping-pong/binding.cc                                                 0000664 0000000 0000000 00000002225 14746647661 0022103 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node.h>
#include <v8.h>

#ifndef _WIN32

#include <dlfcn.h>

extern "C"
__attribute__((visibility("default")))
const char* dlopen_pong(void) {
  return "pong";
}

namespace {

using v8::FunctionCallbackInfo;
using v8::Isolate;
using v8::Local;
using v8::Object;
using v8::String;
using v8::Value;

typedef const char* (*ping)(void);

static ping ping_func;

void LoadLibrary(const FunctionCallbackInfo<Value>& args) {
  const String::Utf8Value filename(args.GetIsolate(), args[0]);
  void* handle = dlopen(*filename, RTLD_LAZY);
  if (handle == nullptr) fprintf(stderr, "%s\n", dlerror());
  assert(handle != nullptr);
  ping_func = reinterpret_cast<ping>(dlsym(handle, "dlopen_ping"));
  assert(ping_func != nullptr);
}

void Ping(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  assert(ping_func != nullptr);
  args.GetReturnValue().Set(String::NewFromUtf8(
        isolate, ping_func()).ToLocalChecked());
}

void init(Local<Object> exports) {
  NODE_SET_METHOD(exports, "load", LoadLibrary);
  NODE_SET_METHOD(exports, "ping", Ping);
}

NODE_MODULE(NODE_GYP_MODULE_NAME, init)

}  // anonymous namespace

#endif  // _WIN32
                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/test/addons/dlopen-ping-pong/binding.gyp                                                0000664 0000000 0000000 00000001110 14746647661 0022305 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'ping',
      'product_extension': 'so',
      'type': 'shared_library',
      'sources': [ 'ping.c' ],
      'conditions': [
        ['OS=="mac"', {
          'xcode_settings': {
            'OTHER_LDFLAGS': [ '-Wl,-undefined', '-Wl,dynamic_lookup' ]
        }}],
        # Enable the shared object to be linked by runtime linker
        ['OS in "aix os400"', {
          'ldflags': [ '-Wl,-G' ]
        }]],
    },
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/addons/dlopen-ping-pong/ping.c                                                     0000664 0000000 0000000 00000000244 14746647661 0021262 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #ifndef _WIN32

const char* dlopen_pong(void);

__attribute__((visibility("default")))
const char* dlopen_ping(void) {
  return dlopen_pong();
}

#endif  // _WIN32
                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/test/addons/dlopen-ping-pong/test-worker.js                                             0000664 0000000 0000000 00000001307 14746647661 0023006 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common');

if (common.isWindows)
  common.skip('dlopen global symbol loading is not supported on this os.');

const assert = require('assert');
const { Worker } = require('worker_threads');

// Check that modules that are not declared as context-aware cannot be re-loaded
// from workers.

const bindingPath = require.resolve(`./build/${common.buildType}/binding`);
require(bindingPath);

new Worker(`require(${JSON.stringify(bindingPath)})`, { eval: true })
  .on('error', common.mustCall((err) => {
    assert.strictEqual(err.constructor, Error);
    assert.strictEqual(err.message,
                       `Module did not self-register: '${bindingPath}'.`);
  }));
                                                                                                                                                                                                                                                                                                                         node-23.7.0/test/addons/dlopen-ping-pong/test.js                                                    0000664 0000000 0000000 00000001720 14746647661 0021476 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common');

if (common.isWindows)
  common.skip('dlopen global symbol loading is not supported on this os.');

const assert = require('assert');
const path = require('path');
const os = require('os');

const bindingPath = require.resolve(`./build/${common.buildType}/binding`);
console.log('process.dlopen:', bindingPath);
process.dlopen(module, bindingPath,
               os.constants.dlopen.RTLD_NOW | os.constants.dlopen.RTLD_GLOBAL);
console.log('module.exports.load:', `${path.dirname(bindingPath)}/ping.so`);
module.exports.load(`${path.dirname(bindingPath)}/ping.so`);
assert.strictEqual(module.exports.ping(), 'pong');

// Check that after the addon is loaded with
// process.dlopen() a require() call fails.
console.log('require:', `./build/${common.buildType}/binding`);
const re = /^Error: Module did not self-register: '.*[\\/]binding\.node'\.$/;
assert.throws(() => require(`./build/${common.buildType}/binding`), re);
                                                node-23.7.0/test/addons/errno-exception/                                                            0000775 0000000 0000000 00000000000 14746647661 0020125 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/errno-exception/binding.cc                                                  0000664 0000000 0000000 00000001134 14746647661 0022045 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node.h>
#include <v8.h>

void Method(const v8::FunctionCallbackInfo<v8::Value>& args) {
  v8::Isolate* isolate = args.GetIsolate();
  v8::HandleScope scope(isolate);
  args.GetReturnValue().Set(node::ErrnoException(isolate,
                                                10,
                                                "syscall",
                                                "some error msg",
                                                "päth"));
}

void init(v8::Local<v8::Object> exports) {
  NODE_SET_METHOD(exports, "errno", Method);
}

NODE_MODULE(NODE_GYP_MODULE_NAME, init)
                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/errno-exception/binding.gyp                                                 0000664 0000000 0000000 00000000214 14746647661 0022255 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/errno-exception/test.js                                                     0000664 0000000 0000000 00000000722 14746647661 0021443 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');

// Verify that the path argument to node::ErrnoException() can contain UTF-8
// characters.

const assert = require('assert');
const binding = require(`./build/${common.buildType}/binding`);
const err = binding.errno();

assert.strictEqual(err.syscall, 'syscall');
assert.strictEqual(err.errno, 10);
assert.strictEqual(err.path, 'päth');
assert.match(err.toString(), /^Error:\s\w+, some error msg 'päth'$/);
                                              node-23.7.0/test/addons/esm/                                                                        0000775 0000000 0000000 00000000000 14746647661 0015570 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/esm/binding-export-default.cc                                               0000664 0000000 0000000 00000001022 14746647661 0022445 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node.h>
#include <uv.h>
#include <v8.h>

static void Method(const v8::FunctionCallbackInfo<v8::Value>& args) {
  v8::Isolate* isolate = args.GetIsolate();
  args.GetReturnValue().Set(
      v8::String::NewFromUtf8(isolate, "hello world").ToLocalChecked());
}

static void InitModule(v8::Local<v8::Object> exports,
                       v8::Local<v8::Value> module,
                       v8::Local<v8::Context> context) {
  NODE_SET_METHOD(exports, "default", Method);
}

NODE_MODULE_CONTEXT_AWARE(Binding, InitModule)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/test/addons/esm/binding-export-primitive.cc                                             0000664 0000000 0000000 00000001103 14746647661 0023031 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node.h>
#include <uv.h>
#include <v8.h>

static void InitModule(v8::Local<v8::Object> exports,
                       v8::Local<v8::Value> module_val,
                       v8::Local<v8::Context> context) {
  v8::Isolate* isolate = context->GetIsolate();
  v8::Local<v8::Object> module = module_val.As<v8::Object>();
  module
      ->Set(context,
            v8::String::NewFromUtf8(isolate, "exports").ToLocalChecked(),
            v8::String::NewFromUtf8(isolate, "hello world").ToLocalChecked())
      .FromJust();
}

NODE_MODULE_CONTEXT_AWARE(Binding, InitModule)
                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/test/addons/esm/binding.cc                                                              0000664 0000000 0000000 00000001012 14746647661 0017503 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node.h>
#include <uv.h>
#include <v8.h>

static void Method(const v8::FunctionCallbackInfo<v8::Value>& args) {
  v8::Isolate* isolate = args.GetIsolate();
  args.GetReturnValue().Set(
      v8::String::NewFromUtf8(isolate, "world").ToLocalChecked());
}

static void InitModule(v8::Local<v8::Object> exports,
                       v8::Local<v8::Value> module,
                       v8::Local<v8::Context> context) {
  NODE_SET_METHOD(exports, "hello", Method);
}

NODE_MODULE_CONTEXT_AWARE(Binding, InitModule)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/addons/esm/binding.gyp                                                             0000664 0000000 0000000 00000002056 14746647661 0017726 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'variables': {
    'source_dir': '<!(<(python) -c "import os; print(os.getcwd())")',
  },
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    },
    {
      'target_name': 'binding-export-default',
      'sources': [ 'binding-export-default.cc' ],
      'includes': ['../common.gypi'],
    },
    {
      'target_name': 'binding-export-primitive',
      'sources': [ 'binding-export-primitive.cc' ],
      'includes': ['../common.gypi'],
    },
    {
      'target_name': 'node_modules',
      'type': 'none',
      'dependencies': [
        'binding',
      ],
      # The `exports` in package.json can not reference files outside the package
      # directory. Copy the `binding.node` into the package directory so that
      # it can be exported with the conditional exports.
      'copies': [
        {
          'files': [
            '<(PRODUCT_DIR)/binding.node'
          ],
          'destination': '<(source_dir)/node_modules/esm-package/build',
        },
      ],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/test/addons/esm/node_modules/                                                           0000775 0000000 0000000 00000000000 14746647661 0020245 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/esm/node_modules/esm-package/                                               0000775 0000000 0000000 00000000000 14746647661 0022422 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/esm/node_modules/esm-package/package.json                                   0000664 0000000 0000000 00000000165 14746647661 0024712 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  "name": "esm-package",
  "exports": {
    "./binding": {
      "node-addons": "./build/binding.node"
    }
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/test/addons/esm/test-esm.mjs                                                            0000664 0000000 0000000 00000004235 14746647661 0020050 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        /**
 * This file is supposed to be loaded by `test-import.js` and `test-require.js`
 * to verify that `import('*.node')` is working properly either been loaded with
 * the ESM loader or the CJS loader.
 */

import { buildType } from '../../common/index.mjs';
import assert from 'node:assert';
import { createRequire } from 'node:module';
import { pathToFileURL } from 'node:url';

const require = createRequire(import.meta.url);

export async function run() {
  // binding.node
  {
    const bindingPath = require.resolve(`./build/${buildType}/binding.node`);
    // Test with order of import+require
    const { default: binding, 'module.exports': exports } = await import(pathToFileURL(bindingPath));
    assert.strictEqual(binding, exports);
    assert.strictEqual(binding.hello(), 'world');

    const bindingRequire = require(bindingPath);
    assert.strictEqual(binding, bindingRequire);
    assert.strictEqual(binding.hello, bindingRequire.hello);

    // Test multiple loading of the same addon.
    // ESM cache can not be removed.
    delete require.cache[bindingPath];
    const { default: rebinding } = await import(pathToFileURL(bindingPath));
    assert.strictEqual(rebinding.hello(), 'world');
    assert.strictEqual(binding.hello, rebinding.hello);
  }

  // binding-export-default.node
  {
    const bindingPath = require.resolve(`./build/${buildType}/binding-export-default.node`);
    // Test with order of require+import
    const bindingRequire = require(bindingPath);
    const ns = await import(pathToFileURL(bindingPath));
    assert.strictEqual(ns.default, bindingRequire);

    // As same as ESM-import-CJS, the default export is the value of `module.exports`.
    assert.strictEqual(ns.default, ns['module.exports']);
    assert.strictEqual(ns.default.default(), 'hello world');
  }

  // binding-export-primitive.node
  {
    const bindingPath = require.resolve(`./build/${buildType}/binding-export-primitive.node`);
    const ns = await import(pathToFileURL(bindingPath));

    // As same as ESM-import-CJS, the default export is the value of `module.exports`.
    assert.strictEqual(ns.default, ns['module.exports']);
    assert.strictEqual(ns.default, 'hello world');
  }
}
                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/test/addons/esm/test-import-package.js                                                  0000664 0000000 0000000 00000000576 14746647661 0022016 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --experimental-addon-modules
'use strict';
const common = require('../../common');
const assert = require('node:assert');

/**
 * Test that the export condition `node-addons` can be used
 * with `*.node` files with the ESM loader.
 */

import('esm-package/binding')
  .then((mod) => {
    assert.strictEqual(mod.default.hello(), 'world');
  })
  .then(common.mustCall());
                                                                                                                                  node-23.7.0/test/addons/esm/test-import.js                                                          0000664 0000000 0000000 00000000257 14746647661 0020421 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --experimental-addon-modules
'use strict';
const common = require('../../common');

import('./test-esm.mjs')
  .then((mod) => mod.run())
  .then(common.mustCall());
                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/test/addons/esm/test-require-package.js                                                 0000664 0000000 0000000 00000000475 14746647661 0022156 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --experimental-addon-modules
'use strict';
require('../../common');
const assert = require('node:assert');

/**
 * Test that the export condition `node-addons` can be used
 * with `*.node` files with the CJS loader.
 */

const mod = require('esm-package/binding');
assert.strictEqual(mod.hello(), 'world');
                                                                                                                                                                                                   node-23.7.0/test/addons/esm/test-require.js                                                         0000664 0000000 0000000 00000000232 14746647661 0020554 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --experimental-addon-modules
'use strict';
const common = require('../../common');

require('./test-esm.mjs')
  .run().then(common.mustCall());
                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/addons/force-context-aware/                                                        0000775 0000000 0000000 00000000000 14746647661 0020661 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/force-context-aware/binding.cc                                              0000664 0000000 0000000 00000000170 14746647661 0022600 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node.h>
#include <v8.h>

void init(v8::Local<v8::Object> exports) {}

NODE_MODULE(NODE_GYP_MODULE_NAME, init)
                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/addons/force-context-aware/binding.gyp                                             0000664 0000000 0000000 00000000214 14746647661 0023011 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/force-context-aware/test.js                                                 0000664 0000000 0000000 00000000413 14746647661 0022174 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --force-context-aware
'use strict';
const common = require('../../common');
const assert = require('assert');

assert.throws(() => {
  require(`./build/${common.buildType}/binding`);
}, /^Error: Loading non context-aware native addons has been disabled$/);
                                                                                                                                                                                                                                                     node-23.7.0/test/addons/heap-profiler/                                                              0000775 0000000 0000000 00000000000 14746647661 0017541 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/heap-profiler/binding.cc                                                    0000664 0000000 0000000 00000002070 14746647661 0021461 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "node.h"
#include "v8.h"
#include "v8-profiler.h"

namespace {

inline void Test(const v8::FunctionCallbackInfo<v8::Value>& args) {
  v8::Isolate* const isolate = args.GetIsolate();
  const v8::HeapSnapshot* const heap_snapshot =
      isolate->GetHeapProfiler()->TakeHeapSnapshot();
  struct : public v8::OutputStream {
    WriteResult WriteAsciiChunk(char*, int) override { return kContinue; }
    void EndOfStream() override {}
  } output_stream;
  heap_snapshot->Serialize(&output_stream, v8::HeapSnapshot::kJSON);
  const_cast<v8::HeapSnapshot*>(heap_snapshot)->Delete();
}

inline void Initialize(v8::Local<v8::Object> binding) {
  v8::Isolate* const isolate = binding->GetIsolate();
  v8::Local<v8::Context> context = isolate->GetCurrentContext();
  binding->Set(context, v8::String::NewFromUtf8(
        isolate, "test").ToLocalChecked(),
               v8::FunctionTemplate::New(isolate, Test)
                   ->GetFunction(context)
                   .ToLocalChecked()).FromJust();
}

NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)

}  // anonymous namespace
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/addons/heap-profiler/binding.gyp                                                   0000664 0000000 0000000 00000000262 14746647661 0021674 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'win_delay_load_hook': 'false',
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                              node-23.7.0/test/addons/heap-profiler/test.js                                                       0000664 0000000 0000000 00000000443 14746647661 0021057 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');

const binding = require(`./build/${common.buildType}/binding`);

// Create an AsyncWrap object.
const timer = setTimeout(common.mustNotCall(), 1);
timer.unref();

// Stress-test the heap profiler.
binding.test();

clearTimeout(timer);
                                                                                                                                                                                                                             node-23.7.0/test/addons/hello-world-function-export/                                                0000775 0000000 0000000 00000000000 14746647661 0022376 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/hello-world-function-export/binding.cc                                      0000664 0000000 0000000 00000000625 14746647661 0024322 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node.h>
#include <v8.h>

void Method(const v8::FunctionCallbackInfo<v8::Value>& args) {
  v8::Isolate* isolate = args.GetIsolate();
  args.GetReturnValue().Set(v8::String::NewFromUtf8(
        isolate, "world").ToLocalChecked());
}

void init(v8::Local<v8::Object> exports, v8::Local<v8::Object> module) {
  NODE_SET_METHOD(module, "exports", Method);
}

NODE_MODULE(NODE_GYP_MODULE_NAME, init)
                                                                                                           node-23.7.0/test/addons/hello-world-function-export/binding.gyp                                     0000664 0000000 0000000 00000000214 14746647661 0024526 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/hello-world-function-export/test.js                                         0000664 0000000 0000000 00000000355 14746647661 0023716 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common');
const assert = require('assert');
const binding = require(`./build/${common.buildType}/binding`);
assert.strictEqual(binding(), 'world');
console.log('binding.hello() =', binding());
                                                                                                                                                                                                                                                                                   node-23.7.0/test/addons/hello-world/                                                                0000775 0000000 0000000 00000000000 14746647661 0017234 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/hello-world/binding.cc                                                      0000664 0000000 0000000 00000002425 14746647661 0021160 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node.h>
#include <v8.h>

static void Method(const v8::FunctionCallbackInfo<v8::Value>& args) {
  v8::Isolate* isolate = args.GetIsolate();
  args.GetReturnValue().Set(v8::String::NewFromUtf8(
        isolate, "world").ToLocalChecked());
}

// Not using the full NODE_MODULE_INIT() macro here because we want to test the
// addon loader's reaction to the FakeInit() entry point below.
extern "C" NODE_MODULE_EXPORT void
NODE_MODULE_INITIALIZER(v8::Local<v8::Object> exports,
                        v8::Local<v8::Value> module,
                        v8::Local<v8::Context> context) {
  NODE_SET_METHOD(exports, "hello", Method);
}

static void FakeInit(v8::Local<v8::Object> exports,
                     v8::Local<v8::Value> module,
                     v8::Local<v8::Context> context) {
  auto isolate = context->GetIsolate();
  auto exception = v8::Exception::Error(v8::String::NewFromUtf8(isolate,
      "FakeInit should never run!").ToLocalChecked());
  isolate->ThrowException(exception);
}

// Define a Node.js module, but with the wrong version. Node.js should still be
// able to load this module, multiple times even, because it exposes the
// specially named initializer above.
#undef NODE_MODULE_VERSION
#define NODE_MODULE_VERSION 3
NODE_MODULE(NODE_GYP_MODULE_NAME, FakeInit)
                                                                                                                                                                                                                                           node-23.7.0/test/addons/hello-world/binding.gyp                                                     0000664 0000000 0000000 00000000404 14746647661 0021365 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    },
    {
      'target_name': 'binding2',
      'sources': [ 'binding2.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                            node-23.7.0/test/addons/hello-world/binding2.cc                                                     0000664 0000000 0000000 00000001315 14746647661 0021237 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Include uv.h and v8.h ahead of node.h to verify that node.h doesn't need to
// be included first. Disable clang-format as it will sort the include lists.
// clang-format off
#include <uv.h>
#include <v8.h>
#include <node.h>
// clang-format on

static void Method(const v8::FunctionCallbackInfo<v8::Value>& args) {
  v8::Isolate* isolate = args.GetIsolate();
  args.GetReturnValue().Set(
      v8::String::NewFromUtf8(isolate, "world").ToLocalChecked());
}

static void InitModule(v8::Local<v8::Object> exports,
                       v8::Local<v8::Value> module,
                       v8::Local<v8::Context> context) {
  NODE_SET_METHOD(exports, "hello", Method);
}

NODE_MODULE(NODE_GYP_MODULE_NAME, InitModule)
                                                                                                                                                                                                                                                                                                                   node-23.7.0/test/addons/hello-world/test-worker.js                                                  0000664 0000000 0000000 00000000735 14746647661 0022065 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common');
const assert = require('assert');
const path = require('path');
const { Worker } = require('worker_threads');
const binding = path.resolve(__dirname, `./build/${common.buildType}/binding`);

const w = new Worker(`
require('worker_threads').parentPort.postMessage(
  require(${JSON.stringify(binding)}).hello());`, { eval: true });
w.on('message', common.mustCall((message) => {
  assert.strictEqual(message, 'world');
}));
                                   node-23.7.0/test/addons/hello-world/test.js                                                         0000664 0000000 0000000 00000001216 14746647661 0020551 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common');
const assert = require('assert');
const bindingPath = require.resolve(`./build/${common.buildType}/binding`);
const binding = require(bindingPath);
assert.strictEqual(binding.hello(), 'world');
console.log('binding.hello() =', binding.hello());

const binding2 = require(require.resolve(`./build/${common.buildType}/binding2`));
assert.strictEqual(binding2.hello(), 'world');

// Test multiple loading of the same module.
delete require.cache[bindingPath];
const rebinding = require(bindingPath);
assert.strictEqual(rebinding.hello(), 'world');
assert.notStrictEqual(binding.hello, rebinding.hello);
                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/test/addons/load-long-path/                                                             0000775 0000000 0000000 00000000000 14746647661 0017612 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/load-long-path/binding.cc                                                   0000664 0000000 0000000 00000000566 14746647661 0021542 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node.h>
#include <v8.h>

void Method(const v8::FunctionCallbackInfo<v8::Value>& args) {
  v8::Isolate* isolate = args.GetIsolate();
  args.GetReturnValue().Set(v8::String::NewFromUtf8(
        isolate, "world").ToLocalChecked());
}

void init(v8::Local<v8::Object> exports) {
  NODE_SET_METHOD(exports, "hello", Method);
}

NODE_MODULE(NODE_GYP_MODULE_NAME, init)
                                                                                                                                          node-23.7.0/test/addons/load-long-path/binding.gyp                                                  0000664 0000000 0000000 00000000214 14746647661 0021742 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/load-long-path/test.js                                                      0000664 0000000 0000000 00000003341 14746647661 0021130 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common');
if (common.isWindows && (process.env.PROCESSOR_ARCHITEW6432 !== undefined))
  common.skip('doesn\'t work on WOW64');

const fs = require('fs');
const path = require('path');
const assert = require('assert');
const { fork } = require('child_process');

const tmpdir = require('../../common/tmpdir');

// Make a path that is more than 260 chars long.
// Any given folder cannot have a name longer than 260 characters,
// so create 10 nested folders each with 30 character long names.
let addonDestinationDir = path.resolve(tmpdir.path);

for (let i = 0; i < 10; i++) {
  addonDestinationDir = path.join(addonDestinationDir, 'x'.repeat(30));
}

const addonPath = path.join(__dirname,
                            'build',
                            common.buildType,
                            'binding.node');
const addonDestinationPath = path.join(addonDestinationDir, 'binding.node');

// Loading an addon keeps the file open until the process terminates. Load
// the addon in a child process so that when the parent terminates the file
// is already closed and the tmpdir can be cleaned up.

// Child
if (process.argv[2] === 'child') {
  // Attempt to load at long path destination
  const addon = require(addonDestinationPath);
  assert.notStrictEqual(addon, null);
  assert.strictEqual(addon.hello(), 'world');
  return;
}

// Parent
tmpdir.refresh();

// Copy binary to long path destination
fs.mkdirSync(addonDestinationDir, { recursive: true });
const contents = fs.readFileSync(addonPath);
fs.writeFileSync(addonDestinationPath, contents);

// Run test
const child = fork(__filename, ['child'], { stdio: 'inherit' });
child.on('exit', common.mustCall((code) => {
  assert.strictEqual(code, 0);
}));
                                                                                                                                                                                                                                                                                               node-23.7.0/test/addons/make-callback-domain-warning/                                               0000775 0000000 0000000 00000000000 14746647661 0022363 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/make-callback-domain-warning/binding.cc                                     0000664 0000000 0000000 00000001330 14746647661 0024301 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "node.h"
#include "v8.h"

#include <assert.h>

using v8::Function;
using v8::FunctionCallbackInfo;
using v8::Isolate;
using v8::Local;
using v8::Object;
using v8::Value;

namespace {

void MakeCallback(const FunctionCallbackInfo<Value>& args) {
  assert(args[0]->IsObject());
  assert(args[1]->IsFunction());
  Isolate* isolate = args.GetIsolate();
  Local<Object> recv = args[0].As<Object>();
  Local<Function> method = args[1].As<Function>();

  node::MakeCallback(isolate, recv, method, 0, nullptr,
                     node::async_context{0, 0});
}

void Initialize(Local<Object> exports) {
  NODE_SET_METHOD(exports, "makeCallback", MakeCallback);
}

}  // namespace

NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)
                                                                                                                                                                                                                                                                                                        node-23.7.0/test/addons/make-callback-domain-warning/binding.gyp                                    0000664 0000000 0000000 00000000214 14746647661 0024513 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/make-callback-domain-warning/test.js                                        0000664 0000000 0000000 00000002357 14746647661 0023707 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
const assert = require('assert');
const domain = require('domain');
const binding = require(`./build/${common.buildType}/binding`);

function makeCallback(object, cb) {
  binding.makeCallback(object, function someMethod() { setImmediate(cb); });
}

let latestWarning = null;
process.on('warning', (warning) => {
  latestWarning = warning;
});

const d = domain.create();

class Resource {
  constructor(domain) {
    this.domain = domain;
  }
}

// When domain is disabled, no warning will be emitted
makeCallback(new Resource(d), common.mustCall(() => {
  assert.strictEqual(latestWarning, null);

  d.run(common.mustCall(() => {
    // No warning will be emitted when no domain property is applied
    makeCallback({}, common.mustCall(() => {
      assert.strictEqual(latestWarning, null);

      // Warning is emitted when domain property is used and domain is enabled
      makeCallback(new Resource(d), common.mustCall(() => {
        assert.match(latestWarning.message,
                     /Triggered by calling someMethod on Resource\./);
        assert.strictEqual(latestWarning.name, 'DeprecationWarning');
        assert.strictEqual(latestWarning.code, 'DEP0097');
      }));
    }));
  }));
}));
                                                                                                                                                                                                                                                                                 node-23.7.0/test/addons/make-callback-recurse/                                                      0000775 0000000 0000000 00000000000 14746647661 0021121 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/make-callback-recurse/binding.cc                                            0000664 0000000 0000000 00000001521 14746647661 0023041 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "node.h"
#include "v8.h"

#include <assert.h>

using v8::Function;
using v8::FunctionCallbackInfo;
using v8::Isolate;
using v8::Local;
using v8::Object;
using v8::TryCatch;
using v8::Value;

namespace {

void MakeCallback(const FunctionCallbackInfo<Value>& args) {
  assert(args[0]->IsObject());
  assert(args[1]->IsFunction());
  Isolate* isolate = args.GetIsolate();
  Local<Object> recv = args[0].As<Object>();
  Local<Function> method = args[1].As<Function>();

  TryCatch try_catch(isolate);
  node::MakeCallback(isolate, recv, method, 0, nullptr,
                     node::async_context{0, 0});
  if (try_catch.HasCaught()) {
    try_catch.ReThrow();
  }
}

void Initialize(Local<Object> exports) {
  NODE_SET_METHOD(exports, "makeCallback", MakeCallback);
}

}  // anonymous namespace

NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)
                                                                                                                                                                               node-23.7.0/test/addons/make-callback-recurse/binding.gyp                                           0000664 0000000 0000000 00000000214 14746647661 0023251 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/make-callback-recurse/test.js                                               0000664 0000000 0000000 00000011505 14746647661 0022440 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
const assert = require('assert');
const domain = require('domain');
const binding = require(`./build/${common.buildType}/binding`);
const makeCallback = binding.makeCallback;

// Make sure this is run in the future.
const mustCallCheckDomains = common.mustCall(checkDomains);

// Make sure that using MakeCallback allows the error to propagate.
assert.throws(() => {
  makeCallback({}, () => {
    throw new Error('hi from domain error');
  });
}, /^Error: hi from domain error$/);


// Check the execution order of the nextTickQueue and MicrotaskQueue in
// relation to running multiple MakeCallback's from bootstrap,
// node::MakeCallback() and node::AsyncWrap::MakeCallback().
// TODO(trevnorris): Is there a way to verify this is being run during
// bootstrap?
(function verifyExecutionOrder(arg) {
  const results = [];

  // Processing of the MicrotaskQueue is manually handled by node. They are not
  // processed until after the nextTickQueue has been processed.
  Promise.resolve(1).then(common.mustCall(() => {
    results.push(7);
  }));

  // The nextTick should run after all immediately invoked calls.
  process.nextTick(common.mustCall(() => {
    results.push(3);

    // Run same test again but while processing the nextTickQueue to make sure
    // the following MakeCallback call breaks in the middle of processing the
    // queue and allows the script to run normally.
    process.nextTick(common.mustCall(() => {
      results.push(6);
    }));

    makeCallback({}, common.mustCall(() => {
      results.push(4);
    }));

    results.push(5);
  }));

  results.push(0);

  // MakeCallback is calling the function immediately, but should then detect
  // that a script is already in the middle of execution and return before
  // either the nextTickQueue or MicrotaskQueue are processed.
  makeCallback({}, common.mustCall(() => {
    results.push(1);
  }));

  // This should run before either the nextTickQueue or MicrotaskQueue are
  // processed. Previously MakeCallback would not detect this circumstance
  // and process them immediately.
  results.push(2);

  setImmediate(common.mustCall(() => {
    for (let i = 0; i < results.length; i++) {
      assert.strictEqual(results[i], i,
                         `verifyExecutionOrder(${arg}) results: ${results}`);
    }
    if (arg === 1) {
      // The tests are first run on bootstrap during LoadEnvironment() in
      // src/node.cc. Now run the tests through node::MakeCallback().
      setImmediate(() => {
        makeCallback({}, common.mustCall(() => {
          verifyExecutionOrder(2);
        }));
      });
    } else if (arg === 2) {
      // Make sure there are no conflicts using node::MakeCallback()
      // within timers.
      setTimeout(common.mustCall(() => {
        verifyExecutionOrder(3);
      }), 10);
    } else if (arg === 3) {
      mustCallCheckDomains();
    } else {
      throw new Error('UNREACHABLE');
    }
  }));
}(1));


function checkDomains() {
  // Check that domains are properly entered/exited when called in multiple
  // levels from both node::MakeCallback() and AsyncWrap::MakeCallback
  setImmediate(common.mustCall(() => {
    const d1 = domain.create();
    const d2 = domain.create();
    const d3 = domain.create();

    makeCallback({ domain: d1 }, common.mustCall(() => {
      assert.strictEqual(d1, process.domain);
      makeCallback({ domain: d2 }, common.mustCall(() => {
        assert.strictEqual(d2, process.domain);
        makeCallback({ domain: d3 }, common.mustCall(() => {
          assert.strictEqual(d3, process.domain);
        }));
        assert.strictEqual(d2, process.domain);
      }));
      assert.strictEqual(d1, process.domain);
    }));
  }));

  setTimeout(common.mustCall(() => {
    const d1 = domain.create();
    const d2 = domain.create();
    const d3 = domain.create();

    makeCallback({ domain: d1 }, common.mustCall(() => {
      assert.strictEqual(d1, process.domain);
      makeCallback({ domain: d2 }, common.mustCall(() => {
        assert.strictEqual(d2, process.domain);
        makeCallback({ domain: d3 }, common.mustCall(() => {
          assert.strictEqual(d3, process.domain);
        }));
        assert.strictEqual(d2, process.domain);
      }));
      assert.strictEqual(d1, process.domain);
    }));
  }), 1);

  function testTimer(id) {
    // Make sure nextTick, setImmediate and setTimeout can all recover properly
    // after a thrown makeCallback call.
    const d = domain.create();
    d.on('error', common.mustCall((e) => {
      assert.strictEqual(e.message, `throw from domain ${id}`);
    }));
    makeCallback({ domain: d }, () => {
      throw new Error(`throw from domain ${id}`);
    });
    throw new Error('UNREACHABLE');
  }

  process.nextTick(common.mustCall(testTimer), 3);
  setImmediate(common.mustCall(testTimer), 2);
  setTimeout(common.mustCall(testTimer), 1, 1);
}
                                                                                                                                                                                           node-23.7.0/test/addons/make-callback/                                                              0000775 0000000 0000000 00000000000 14746647661 0017453 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/make-callback/binding.cc                                                    0000664 0000000 0000000 00000002335 14746647661 0021377 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "node.h"
#include "v8.h"

#include <assert.h>
#include <vector>

namespace {

void MakeCallback(const v8::FunctionCallbackInfo<v8::Value>& args) {
  assert(args[0]->IsObject());
  assert(args[1]->IsFunction() || args[1]->IsString());
  auto isolate = args.GetIsolate();
  auto recv = args[0].As<v8::Object>();
  std::vector<v8::Local<v8::Value>> argv;
  for (size_t n = 2; n < static_cast<size_t>(args.Length()); n += 1) {
    argv.push_back(args[n]);
  }
  v8::Local<v8::Value> result;
  if (args[1]->IsFunction()) {
    auto method = args[1].As<v8::Function>();
    result =
        node::MakeCallback(isolate, recv, method, argv.size(), argv.data(),
                           node::async_context{0, 0}).ToLocalChecked();
  } else if (args[1]->IsString()) {
    auto method = args[1].As<v8::String>();
    result =
        node::MakeCallback(isolate, recv, method, argv.size(), argv.data(),
                           node::async_context{0, 0}).ToLocalChecked();
  } else {
    assert(0 && "unreachable");
  }
  args.GetReturnValue().Set(result);
}

void Initialize(v8::Local<v8::Object> exports) {
  NODE_SET_METHOD(exports, "makeCallback", MakeCallback);
}

}  // anonymous namespace

NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)
                                                                                                                                                                                                                                                                                                   node-23.7.0/test/addons/make-callback/binding.gyp                                                   0000664 0000000 0000000 00000000214 14746647661 0021603 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/make-callback/test.js                                                       0000664 0000000 0000000 00000003530 14746647661 0020771 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
const assert = require('assert');
const vm = require('vm');
const binding = require(`./build/${common.buildType}/binding`);
const makeCallback = binding.makeCallback;

assert.strictEqual(makeCallback(process, common.mustCall(function() {
  assert.strictEqual(arguments.length, 0);
  assert.strictEqual(process, this);
  return 42;
})), 42);

assert.strictEqual(makeCallback(process, common.mustCall(function(x) {
  assert.strictEqual(arguments.length, 1);
  assert.strictEqual(process, this);
  assert.strictEqual(x, 1337);
  return 42;
}), 1337), 42);

const recv = {
  one: common.mustCall(function() {
    assert.strictEqual(arguments.length, 0);
    assert.strictEqual(recv, this);
    return 42;
  }),
  two: common.mustCall(function(x) {
    assert.strictEqual(arguments.length, 1);
    assert.strictEqual(recv, this);
    assert.strictEqual(x, 1337);
    return 42;
  }),
};

assert.strictEqual(makeCallback(recv, 'one'), 42);
assert.strictEqual(makeCallback(recv, 'two', 1337), 42);

// Check that callbacks on a receiver from a different context works.
const foreignObject = vm.runInNewContext('({ fortytwo() { return 42; } })');
assert.strictEqual(makeCallback(foreignObject, 'fortytwo'), 42);

// Check that the callback is made in the context of the receiver.
const target = vm.runInNewContext(`
    (function($Object) {
      if (Object === $Object)
        throw new Error('bad');
      return Object;
    })
`);
assert.notStrictEqual(makeCallback(process, target, Object), Object);

// Runs in inner context.
const forward = vm.runInNewContext(`
    (function(forward) {
      return forward(Object);
    })
`);
// Runs in outer context.
function endpoint($Object) {
  if (Object === $Object)
    throw new Error('bad');
  return Object;
}
assert.strictEqual(makeCallback(process, forward, endpoint), Object);
                                                                                                                                                                        node-23.7.0/test/addons/new-isolate-addon/                                                          0000775 0000000 0000000 00000000000 14746647661 0020316 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/new-isolate-addon/binding.cc                                                0000664 0000000 0000000 00000004457 14746647661 0022251 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <assert.h>
#include <node.h>

using node::Environment;
using node::MultiIsolatePlatform;
using v8::Context;
using v8::FunctionCallbackInfo;
using v8::HandleScope;
using v8::Isolate;
using v8::Local;
using v8::Locker;
using v8::MaybeLocal;
using v8::Object;
using v8::SharedArrayBuffer;
using v8::String;
using v8::Unlocker;
using v8::Value;

void RunInSeparateIsolate(const FunctionCallbackInfo<Value>& args) {
  Isolate* parent_isolate = args.GetIsolate();

  assert(args[0]->IsString());
  String::Utf8Value code(parent_isolate, args[0]);
  assert(*code != nullptr);
  assert(args[1]->IsSharedArrayBuffer());
  auto arg_bs = args[1].As<SharedArrayBuffer>()->GetBackingStore();

  Environment* parent_env =
      node::GetCurrentEnvironment(parent_isolate->GetCurrentContext());
  assert(parent_env != nullptr);
  MultiIsolatePlatform* platform = node::GetMultiIsolatePlatform(parent_env);
  assert(parent_env != nullptr);

  {
    Unlocker unlocker(parent_isolate);

    std::vector<std::string> errors;
    const std::vector<std::string> empty_args;
    auto setup =
        node::CommonEnvironmentSetup::Create(platform,
                                             &errors,
                                             empty_args,
                                             empty_args,
                                             node::EnvironmentFlags::kNoFlags);
    assert(setup);

    {
      Locker locker(setup->isolate());
      Isolate::Scope isolate_scope(setup->isolate());
      HandleScope handle_scope(setup->isolate());
      Context::Scope context_scope(setup->context());
      auto arg = SharedArrayBuffer::New(setup->isolate(), arg_bs);
      auto result = setup->context()->Global()->Set(
          setup->context(),
          v8::String::NewFromUtf8Literal(setup->isolate(), "arg"),
          arg);
      assert(!result.IsNothing());

      MaybeLocal<Value> loadenv_ret =
          node::LoadEnvironment(setup->env(), *code);
      assert(!loadenv_ret.IsEmpty());

      (void)node::SpinEventLoop(setup->env());

      node::Stop(setup->env());
    }
  }
}

void Initialize(Local<Object> exports,
                Local<Value> module,
                Local<Context> context) {
  NODE_SET_METHOD(exports, "runInSeparateIsolate", RunInSeparateIsolate);
}

NODE_MODULE_CONTEXT_AWARE(NODE_GYP_MODULE_NAME, Initialize)
                                                                                                                                                                                                                 node-23.7.0/test/addons/new-isolate-addon/binding.gyp                                               0000664 0000000 0000000 00000000214 14746647661 0022446 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/new-isolate-addon/test-nonodesnapshot.js                                    0000664 0000000 0000000 00000000172 14746647661 0024673 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --no-node-snapshot
'use strict';
require('../../common');

// Just re-execute the main test.
require('./test');
                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/addons/new-isolate-addon/test.js                                                   0000664 0000000 0000000 00000000532 14746647661 0021633 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common');
const binding = require(`./build/${common.buildType}/binding`);
const assert = require('assert');

const arg = new SharedArrayBuffer(1);
binding.runInSeparateIsolate('const arr = new Uint8Array(arg); arr[0] = 0x42;', arg);
assert.deepStrictEqual(new Uint8Array(arg), new Uint8Array([0x42]));
                                                                                                                                                                      node-23.7.0/test/addons/new-target/                                                                 0000775 0000000 0000000 00000000000 14746647661 0017061 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/new-target/binding.cc                                                       0000664 0000000 0000000 00000001351 14746647661 0021002 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node.h>
#include <v8.h>

namespace {

inline void NewClass(const v8::FunctionCallbackInfo<v8::Value>& args) {
  // this != new.target since we are being invoked through super().
  assert(args.IsConstructCall());
  assert(!args.This()->StrictEquals(args.NewTarget()));
}

inline void Initialize(v8::Local<v8::Object> binding) {
  auto isolate = binding->GetIsolate();
  auto context = isolate->GetCurrentContext();
  binding->Set(context, v8::String::NewFromUtf8(
        isolate, "Class").ToLocalChecked(),
               v8::FunctionTemplate::New(isolate, NewClass)
                   ->GetFunction(context)
                   .ToLocalChecked()).FromJust();
}

NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)

}  // anonymous namespace
                                                                                                                                                                                                                                                                                       node-23.7.0/test/addons/new-target/binding.gyp                                                      0000664 0000000 0000000 00000000214 14746647661 0021211 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/new-target/test.js                                                          0000664 0000000 0000000 00000000550 14746647661 0020376 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
const assert = require('assert');
const binding = require(`./build/${common.buildType}/binding`);

class Class extends binding.Class {
  constructor() {
    super();
    this.method();
  }
  method() {
    this.ok = true;
  }
}

assert.ok(new Class() instanceof binding.Class);
assert.ok(new Class().ok);
                                                                                                                                                        node-23.7.0/test/addons/no-addons/                                                                  0000775 0000000 0000000 00000000000 14746647661 0016666 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/no-addons/binding.gyp                                                       0000664 0000000 0000000 00000000233 14746647661 0021017 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ '../hello-world/binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/test/addons/no-addons/permission.js                                                     0000664 0000000 0000000 00000001374 14746647661 0021421 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --permission --allow-fs-read=*

'use strict';

const common = require('../../common');
const assert = require('assert');

const bindingPath = require.resolve(`./build/${common.buildType}/binding`);

const assertError = (error) => {
  assert(error instanceof Error);
  assert.strictEqual(error.code, 'ERR_DLOPEN_DISABLED');
  assert.strictEqual(
    error.message,
    'Cannot load native addon because loading addons is disabled.',
  );
};

{
  let threw = false;

  try {
    require(bindingPath);
  } catch (error) {
    assertError(error);
    threw = true;
  }

  assert(threw);
}

{
  let threw = false;

  try {
    process.dlopen({ exports: {} }, bindingPath);
  } catch (error) {
    assertError(error);
    threw = true;
  }

  assert(threw);
}
                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/no-addons/test-worker.js                                                    0000664 0000000 0000000 00000002513 14746647661 0021513 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --no-addons

'use strict';

const common = require('../../common');
const assert = require('assert');
const path = require('path');
const { Worker } = require('worker_threads');

const binding = path.resolve(__dirname, `./build/${common.buildType}/binding`);

const assertError = (error) => {
  assert.strictEqual(error.code, 'ERR_DLOPEN_DISABLED');
  assert.strictEqual(
    error.message,
    'Cannot load native addon because loading addons is disabled.',
  );
};

{
  // Flags should be inherited
  const worker = new Worker(`require(${JSON.stringify(binding)})`, {
    eval: true,
  });

  worker.on('error', common.mustCall(assertError));
}

{
  // Should throw when using `process.dlopen` directly
  const worker = new Worker(
    `process.dlopen({ exports: {} }, ${JSON.stringify(binding)});`,
    {
      eval: true,
    },
  );

  worker.on('error', common.mustCall(assertError));
}

{
  // Explicitly pass `--no-addons`
  const worker = new Worker(`require(${JSON.stringify(binding)})`, {
    eval: true,
    execArgv: ['--no-addons'],
  });

  worker.on('error', common.mustCall(assertError));
}

{
  // If `execArgv` is overwritten it should still fail to load addons
  const worker = new Worker(`require(${JSON.stringify(binding)})`, {
    eval: true,
    execArgv: [],
  });

  worker.on('error', common.mustCall(assertError));
}
                                                                                                                                                                                     node-23.7.0/test/addons/no-addons/test.js                                                           0000664 0000000 0000000 00000001351 14746647661 0020203 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --no-addons

'use strict';

const common = require('../../common');
const assert = require('assert');

const bindingPath = require.resolve(`./build/${common.buildType}/binding`);

const assertError = (error) => {
  assert(error instanceof Error);
  assert.strictEqual(error.code, 'ERR_DLOPEN_DISABLED');
  assert.strictEqual(
    error.message,
    'Cannot load native addon because loading addons is disabled.',
  );
};

{
  let threw = false;

  try {
    require(bindingPath);
  } catch (error) {
    assertError(error);
    threw = true;
  }

  assert(threw);
}

{
  let threw = false;

  try {
    process.dlopen({ exports: {} }, bindingPath);
  } catch (error) {
    assertError(error);
    threw = true;
  }

  assert(threw);
}
                                                                                                                                                                                                                                                                                       node-23.7.0/test/addons/node-module-version/                                                        0000775 0000000 0000000 00000000000 14746647661 0020677 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/node-module-version/binding.cc                                              0000664 0000000 0000000 00000000531 14746647661 0022617 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node_version.h>
#undef NODE_MODULE_VERSION
#define NODE_MODULE_VERSION 42
#include <node.h>

namespace {

inline void Initialize(v8::Local<v8::Object> exports,
                       v8::Local<v8::Value> module,
                       v8::Local<v8::Context> context) {
}

}

NODE_MODULE_CONTEXT_AWARE(NODE_GYP_MODULE_NAME, Initialize)
                                                                                                                                                                       node-23.7.0/test/addons/node-module-version/binding.gyp                                             0000664 0000000 0000000 00000000214 14746647661 0023027 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/node-module-version/test.js                                                 0000664 0000000 0000000 00000001034 14746647661 0022212 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
const assert = require('assert');

const re = new RegExp(
  '^Error: The module \'.+\'\n' +
  'was compiled against a different Node\\.js version using\n' +
  'NODE_MODULE_VERSION 42\\. This version of Node\\.js requires\n' +
  `NODE_MODULE_VERSION ${process.versions.modules}\\. ` +
  'Please try re-compiling or re-installing\n' +
  'the module \\(for instance, using `npm rebuild` or `npm install`\\)\\.$');

assert.throws(() => require(`./build/${common.buildType}/binding`), re);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/non-node-context/                                                           0000775 0000000 0000000 00000000000 14746647661 0020203 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/non-node-context/binding.cc                                                 0000664 0000000 0000000 00000003073 14746647661 0022127 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node.h>
#include <node_buffer.h>
#include <assert.h>

namespace {

using v8::Context;
using v8::Isolate;
using v8::Local;
using v8::MaybeLocal;
using v8::Object;
using v8::Script;
using v8::String;
using v8::Value;

inline void MakeBufferInNewContext(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  Isolate* isolate = args.GetIsolate();
  Local<Context> context = Context::New(isolate);
  Context::Scope context_scope(context);

  // This should throw an exception, rather than actually do anything.
  MaybeLocal<Object> buf = node::Buffer::Copy(isolate, "foo", 3);
  assert(buf.IsEmpty());
}

inline void RunInNewContext(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  Isolate* isolate = args.GetIsolate();
  Local<Context> context = Context::New(isolate);
  Context::Scope context_scope(context);

  context->Global()->Set(
      context,
      String::NewFromUtf8(isolate, "data").ToLocalChecked(),
      args[1]).FromJust();

  assert(args[0]->IsString());  // source code
  Local<Script> script;
  Local<Value> ret;
  if (!Script::Compile(context, args[0].As<String>()).ToLocal(&script) ||
      !script->Run(context).ToLocal(&ret)) {
    return;
  }

  args.GetReturnValue().Set(ret);
}

inline void Initialize(Local<Object> exports,
                       Local<Value> module,
                       Local<Context> context) {
  NODE_SET_METHOD(exports, "runInNewContext", RunInNewContext);
  NODE_SET_METHOD(exports, "makeBufferInNewContext", MakeBufferInNewContext);
}

}  // anonymous namespace

NODE_MODULE_CONTEXT_AWARE(NODE_GYP_MODULE_NAME, Initialize)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/test/addons/non-node-context/binding.gyp                                                0000664 0000000 0000000 00000000213 14746647661 0022332 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': ['binding.cc'],
      'includes': ['../common.gypi'],
    },
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/test/addons/non-node-context/test-make-buffer.js                                        0000664 0000000 0000000 00000001407 14746647661 0023704 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
const assert = require('assert');
const {
  makeBufferInNewContext,
} = require(`./build/${common.buildType}/binding`);

// Because the `Buffer` function and its prototype property only (currently)
// exist in a Node.js instance’s main context, trying to create buffers from
// another context throws an exception.
assert.throws(
  () => makeBufferInNewContext(),
  (exception) => {
    assert.strictEqual(exception.constructor.name, 'Error');
    assert(!(exception.constructor instanceof Error));

    assert.strictEqual(exception.code, 'ERR_BUFFER_CONTEXT_NOT_AVAILABLE');
    assert.strictEqual(exception.message,
                       'Buffer is not available for the current Context');
    return true;
  },
);
                                                                                                                                                                                                                                                         node-23.7.0/test/addons/non-node-context/test-perf-hooks-timerify.js                                0000664 0000000 0000000 00000001136 14746647661 0025422 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
const assert = require('assert');
const { runInNewContext } = require(`./build/${common.buildType}/binding`);
const { performance } = require('perf_hooks');

// Check that performance.timerify() works when called from another context,
// for a function created in another context.

const check = runInNewContext(`
const { performance, assert } = data;
const timerified = performance.timerify(function() { return []; });
assert.strictEqual(timerified().constructor, Array);
'success';
`, { performance, assert });
assert.strictEqual(check, 'success');
                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/test/addons/not-a-binding/                                                              0000775 0000000 0000000 00000000000 14746647661 0017432 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/not-a-binding/binding.gyp                                                   0000664 0000000 0000000 00000000221 14746647661 0021560 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'not_a_binding.c' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/test/addons/not-a-binding/not_a_binding.c                                               0000664 0000000 0000000 00000000036 14746647661 0022367 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        int foo(void) {
  return 0;
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/test/addons/not-a-binding/test.js                                                       0000664 0000000 0000000 00000000360 14746647661 0020746 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common');
const assert = require('assert');

const re = /^Error: Module did not self-register: '.*[\\/]binding\.node'\.$/;
assert.throws(() => require(`./build/${common.buildType}/binding`), re);
                                                                                                                                                                                                                                                                                node-23.7.0/test/addons/null-buffer-neuter/                                                         0000775 0000000 0000000 00000000000 14746647661 0020525 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/null-buffer-neuter/binding.cc                                               0000664 0000000 0000000 00000001543 14746647661 0022451 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node.h>
#include <node_buffer.h>
#include <v8.h>

#include <assert.h>

static int alive;

static void FreeCallback(char* data, void* hint) {
  assert(data == nullptr);
  alive--;
}

void IsAlive(const v8::FunctionCallbackInfo<v8::Value>& args) {
  args.GetReturnValue().Set(alive);
}

void Run(const v8::FunctionCallbackInfo<v8::Value>& args) {
  v8::Isolate* isolate = args.GetIsolate();
  alive++;

  {
    v8::HandleScope scope(isolate);
    v8::Local<v8::Object> buf = node::Buffer::New(
          isolate,
          nullptr,
          0,
          FreeCallback,
          nullptr).ToLocalChecked();

    char* data = node::Buffer::Data(buf);
    assert(data == nullptr);
  }
}

void init(v8::Local<v8::Object> exports) {
  NODE_SET_METHOD(exports, "run", Run);
  NODE_SET_METHOD(exports, "isAlive", IsAlive);
}

NODE_MODULE(NODE_GYP_MODULE_NAME, init)
                                                                                                                                                             node-23.7.0/test/addons/null-buffer-neuter/binding.gyp                                              0000664 0000000 0000000 00000000214 14746647661 0022655 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/null-buffer-neuter/test.js                                                  0000664 0000000 0000000 00000000420 14746647661 0022036 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// Flags: --expose-gc
const common = require('../../common');
const assert = require('assert');
const binding = require(`./build/${common.buildType}/binding`);

binding.run();
global.gc();
setImmediate(() => {
  assert.strictEqual(binding.isAlive(), 0);
});
                                                                                                                                                                                                                                                node-23.7.0/test/addons/openssl-binding/                                                            0000775 0000000 0000000 00000000000 14746647661 0020077 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/openssl-binding/binding.cc                                                  0000664 0000000 0000000 00000004172 14746647661 0022024 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <assert.h>
#include <node.h>
#include <openssl/md5.h>
#include <openssl/rand.h>
#include <openssl/ssl.h>

namespace {

inline void RandomBytes(const v8::FunctionCallbackInfo<v8::Value>& info) {
  assert(info[0]->IsArrayBufferView());
  auto view = info[0].As<v8::ArrayBufferView>();
  auto byte_offset = view->ByteOffset();
  auto byte_length = view->ByteLength();
  assert(view->HasBuffer());
  auto buffer = view->Buffer();
  auto contents = buffer->GetBackingStore();
  auto data = static_cast<unsigned char*>(contents->Data()) + byte_offset;
  assert(RAND_poll());
  auto rval = RAND_bytes(data, static_cast<int>(byte_length));
  info.GetReturnValue().Set(rval > 0);
}

inline void Hash(const v8::FunctionCallbackInfo<v8::Value>& info) {
  assert(info[0]->IsArrayBufferView());
  auto view = info[0].As<v8::ArrayBufferView>();
  auto byte_offset = view->ByteOffset();
  auto len = view->ByteLength();
  assert(view->HasBuffer());
  auto buffer = view->Buffer();
  auto contents = buffer->GetBackingStore();
  auto data = static_cast<unsigned char*>(contents->Data()) + byte_offset;
  unsigned char md[MD5_DIGEST_LENGTH];
  MD5_CTX c;
  auto rval = MD5_Init(&c) && MD5_Update(&c, data, len) && MD5_Final(md, &c);
  info.GetReturnValue().Set(rval > 0);
}

inline void Initialize(v8::Local<v8::Object> exports,
                       v8::Local<v8::Value> module,
                       v8::Local<v8::Context> context) {
  auto isolate = context->GetIsolate();
  auto key = v8::String::NewFromUtf8(
      isolate, "randomBytes").ToLocalChecked();
  auto value = v8::FunctionTemplate::New(isolate, RandomBytes)
                   ->GetFunction(context)
                   .ToLocalChecked();
  assert(exports->Set(context, key, value).IsJust());

  const SSL_METHOD* method = TLSv1_2_server_method();
  assert(method != nullptr);

  key = v8::String::NewFromUtf8(isolate, "hash").ToLocalChecked();
  value = v8::FunctionTemplate::New(isolate, Hash)
              ->GetFunction(context)
              .ToLocalChecked();
  assert(exports->Set(context, key, value).IsJust());
}

}  // anonymous namespace

NODE_MODULE_CONTEXT_AWARE(NODE_GYP_MODULE_NAME, Initialize)
                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/addons/openssl-binding/binding.gyp                                                 0000664 0000000 0000000 00000002064 14746647661 0022234 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'includes': ['../common.gypi'],
      'conditions': [
        ['node_use_openssl=="true"', {
          'conditions': [
            ['OS in "aix os400"', {
              'variables': {
                # Used to differentiate `AIX` and `OS400`(IBM i).
                'aix_variant_name': '<!(uname -s)',
              },
              'conditions': [
                [ '"<(aix_variant_name)"!="OS400"', { # Not `OS400`(IBM i)
                  'sources': ['binding.cc'],
                  'include_dirs': ['../../../deps/openssl/openssl/include'],
                }],
              ],
            }, {
              'sources': ['binding.cc'],
              'include_dirs': ['../../../deps/openssl/openssl/include'],
            }],
          ],
        }],
        ['OS=="mac"', {
          'xcode_settings': {
            'OTHER_CFLAGS+': [
              '-Wno-deprecated-declarations',
            ],
          },
        }, {
          'cflags': ['-Wno-deprecated-declarations'],
        }],
      ],
    },
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/test/addons/openssl-binding/test.js                                                     0000664 0000000 0000000 00000000542 14746647661 0021415 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const binding = require(`./build/${common.buildType}/binding`);
const bytes = new Uint8Array(1024);
assert(binding.randomBytes(bytes));
assert(bytes.reduce((v, a) => v + a) > 0);
assert(binding.hash(bytes));
                                                                                                                                                              node-23.7.0/test/addons/openssl-client-cert-engine/                                                 0000775 0000000 0000000 00000000000 14746647661 0022141 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/openssl-client-cert-engine/binding.gyp                                      0000664 0000000 0000000 00000001220 14746647661 0024267 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'testengine',
      'type': 'none',
      'includes': ['../common.gypi'],
      'conditions': [
        ['OS=="mac" and '
         'node_use_openssl=="true" and '
         'node_shared=="false" and '
         'node_shared_openssl=="false"', {
          'type': 'shared_library',
          'sources': [ 'testengine.cc' ],
          'product_extension': 'engine',
          'include_dirs': ['../../../deps/openssl/openssl/include'],
          'link_settings': {
            'libraries': [
              '../../../../out/<(PRODUCT_DIR)/<(openssl_product)'
            ]
          },
        }],
      ]
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/test/addons/openssl-client-cert-engine/test.js                                          0000664 0000000 0000000 00000003150 14746647661 0023455 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common');
const fixture = require('../../common/fixtures');

if (!common.hasCrypto)
  common.skip('missing crypto');

const fs = require('fs');
const path = require('path');

const engine = path.join(__dirname,
                         `/build/${common.buildType}/testengine.engine`);

if (!fs.existsSync(engine))
  common.skip('no client cert engine');

const assert = require('assert');
const https = require('https');

const agentKey = fs.readFileSync(fixture.path('/keys/agent1-key.pem'));
const agentCert = fs.readFileSync(fixture.path('/keys/agent1-cert.pem'));
const agentCa = fs.readFileSync(fixture.path('/keys/ca1-cert.pem'));

const serverOptions = {
  key: agentKey,
  cert: agentCert,
  ca: agentCa,
  requestCert: true,
  rejectUnauthorized: true,
};

const server = https.createServer(serverOptions, common.mustCall((req, res) => {
  res.writeHead(200);
  res.end('hello world');
})).listen(0, common.localhostIPv4, common.mustCall(() => {
  const clientOptions = {
    method: 'GET',
    host: common.localhostIPv4,
    port: server.address().port,
    path: '/test',
    clientCertEngine: engine,  // `engine` will provide key+cert
    rejectUnauthorized: false, // Prevent failing on self-signed certificates
    headers: {},
  };

  const req = https.request(clientOptions, common.mustCall((response) => {
    let body = '';
    response.setEncoding('utf8');
    response.on('data', (chunk) => {
      body += chunk;
    });

    response.on('end', common.mustCall(() => {
      assert.strictEqual(body, 'hello world');
      server.close();
    }));
  }));

  req.end();
}));
                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/addons/openssl-client-cert-engine/testengine.cc                                    0000664 0000000 0000000 00000005067 14746647661 0024625 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <openssl/engine.h>
#include <openssl/pem.h>

#include <assert.h>
#include <string.h>
#include <stdlib.h>

#include <fstream>
#include <iterator>
#include <string>

#ifndef ENGINE_CMD_BASE
# error did not get engine.h
#endif

#define TEST_ENGINE_ID      "testengine"
#define TEST_ENGINE_NAME    "dummy test engine"

#define AGENT_KEY           "test/fixtures/keys/agent1-key.pem"
#define AGENT_CERT          "test/fixtures/keys/agent1-cert.pem"

#ifdef _WIN32
# define DEFAULT_VISIBILITY __declspec(dllexport)
#else
# define DEFAULT_VISIBILITY __attribute__((visibility("default")))
#endif

namespace {

int EngineInit(ENGINE* engine) {
  return 1;
}

int EngineFinish(ENGINE* engine) {
  return 1;
}

int EngineDestroy(ENGINE* engine) {
  return 1;
}

std::string LoadFile(const char* filename) {
  std::ifstream file(filename);
  return std::string(std::istreambuf_iterator<char>(file),
                     std::istreambuf_iterator<char>());
}


int EngineLoadSSLClientCert(ENGINE* engine,
                            SSL* ssl,
                            STACK_OF(X509_NAME)* ca_dn,
                            X509** ppcert,
                            EVP_PKEY** ppkey,
                            STACK_OF(X509)** pother,
                            UI_METHOD* ui_method,
                            void* callback_data) {
  if (ppcert != nullptr) {
    std::string cert = LoadFile(AGENT_CERT);
    if (cert.empty()) {
      return 0;
    }

    BIO* bio = BIO_new_mem_buf(cert.data(), cert.size());
    *ppcert = PEM_read_bio_X509(bio, nullptr, nullptr, nullptr);
     BIO_vfree(bio);
     if (*ppcert == nullptr) {
       printf("Could not read certificate\n");
       return 0;
     }
  }

  if (ppkey != nullptr) {
    std::string key = LoadFile(AGENT_KEY);
    if (key.empty()) {
      return 0;
    }

    BIO* bio = BIO_new_mem_buf(key.data(), key.size());
    *ppkey = PEM_read_bio_PrivateKey(bio, nullptr, nullptr, nullptr);
    BIO_vfree(bio);
    if (*ppkey == nullptr) {
      printf("Could not read private key\n");
      return 0;
    }
  }

  return 1;
}

int bind_fn(ENGINE* engine, const char* id) {
  ENGINE_set_id(engine, TEST_ENGINE_ID);
  ENGINE_set_name(engine, TEST_ENGINE_NAME);
  ENGINE_set_init_function(engine, EngineInit);
  ENGINE_set_finish_function(engine, EngineFinish);
  ENGINE_set_destroy_function(engine, EngineDestroy);
  ENGINE_set_load_ssl_client_cert_function(engine, EngineLoadSSLClientCert);

  return 1;
}

extern "C" {
  DEFAULT_VISIBILITY IMPLEMENT_DYNAMIC_CHECK_FN();
  DEFAULT_VISIBILITY IMPLEMENT_DYNAMIC_BIND_FN(bind_fn);
}

}  // anonymous namespace
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/test/addons/openssl-key-engine/                                                         0000775 0000000 0000000 00000000000 14746647661 0020520 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/openssl-key-engine/binding.gyp                                              0000664 0000000 0000000 00000001226 14746647661 0022654 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'testkeyengine',
      'type': 'none',
      'includes': ['../common.gypi'],
      'conditions': [
        ['OS=="mac" and '
         'node_use_openssl=="true" and '
         'node_shared=="false" and '
         'node_shared_openssl=="false"', {
          'type': 'shared_library',
          'sources': [ 'testkeyengine.cc' ],
          'product_extension': 'engine',
          'include_dirs': ['../../../deps/openssl/openssl/include'],
          'link_settings': {
            'libraries': [
              '../../../../out/<(PRODUCT_DIR)/<(openssl_product)'
            ]
          },
        }],
      ]
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/test/addons/openssl-key-engine/test.js                                                  0000664 0000000 0000000 00000003203 14746647661 0022033 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common');
const fixture = require('../../common/fixtures');

if (!common.hasCrypto)
  common.skip('missing crypto');

const fs = require('fs');
const path = require('path');

const engine = path.join(__dirname,
                         `/build/${common.buildType}/testkeyengine.engine`);

if (!fs.existsSync(engine))
  common.skip('no client cert engine');

const assert = require('assert');
const https = require('https');

const agentKey = fs.readFileSync(fixture.path('/keys/agent1-key.pem'));
const agentCert = fs.readFileSync(fixture.path('/keys/agent1-cert.pem'));
const agentCa = fs.readFileSync(fixture.path('/keys/ca1-cert.pem'));

const serverOptions = {
  key: agentKey,
  cert: agentCert,
  ca: agentCa,
  requestCert: true,
  rejectUnauthorized: true,
};

const server = https.createServer(serverOptions, common.mustCall((req, res) => {
  res.writeHead(200);
  res.end('hello world');
})).listen(0, common.localhostIPv4, common.mustCall(() => {
  const clientOptions = {
    method: 'GET',
    host: common.localhostIPv4,
    port: server.address().port,
    path: '/test',
    privateKeyEngine: engine,
    privateKeyIdentifier: 'dummykey',
    cert: agentCert,
    rejectUnauthorized: false, // Prevent failing on self-signed certificates
    headers: {},
  };

  const req = https.request(clientOptions, common.mustCall((response) => {
    let body = '';
    response.setEncoding('utf8');
    response.on('data', (chunk) => {
      body += chunk;
    });

    response.on('end', common.mustCall(() => {
      assert.strictEqual(body, 'hello world');
      server.close();
    }));
  }));

  req.end();
}));
                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/test/addons/openssl-key-engine/testkeyengine.cc                                         0000664 0000000 0000000 00000003526 14746647661 0023713 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <openssl/engine.h>
#include <openssl/pem.h>

#include <assert.h>
#include <string.h>
#include <stdlib.h>

#include <fstream>
#include <iterator>
#include <string>

#ifndef ENGINE_CMD_BASE
# error did not get engine.h
#endif

#define TEST_ENGINE_ID      "testkeyengine"
#define TEST_ENGINE_NAME    "dummy test key engine"

#define PRIVATE_KEY           "test/fixtures/keys/agent1-key.pem"

#ifdef _WIN32
# define DEFAULT_VISIBILITY __declspec(dllexport)
#else
# define DEFAULT_VISIBILITY __attribute__((visibility("default")))
#endif

namespace {

int EngineInit(ENGINE* engine) {
  return 1;
}

int EngineFinish(ENGINE* engine) {
  return 1;
}

int EngineDestroy(ENGINE* engine) {
  return 1;
}

std::string LoadFile(const char* filename) {
  std::ifstream file(filename);
  return std::string(std::istreambuf_iterator<char>(file),
                     std::istreambuf_iterator<char>());
}

static EVP_PKEY* EngineLoadPrivkey(ENGINE* engine, const char* name,
                                   UI_METHOD* ui_method, void* callback_data) {
  if (strcmp(name, "dummykey") == 0) {
    std::string key = LoadFile(PRIVATE_KEY);
    BIO* bio = BIO_new_mem_buf(key.data(), key.size());
    EVP_PKEY* ret = PEM_read_bio_PrivateKey(bio, nullptr, nullptr, nullptr);

    BIO_vfree(bio);
    if (ret != nullptr) {
      return ret;
    }
  }

  return nullptr;
}

int bind_fn(ENGINE* engine, const char* id) {
  ENGINE_set_id(engine, TEST_ENGINE_ID);
  ENGINE_set_name(engine, TEST_ENGINE_NAME);
  ENGINE_set_init_function(engine, EngineInit);
  ENGINE_set_finish_function(engine, EngineFinish);
  ENGINE_set_destroy_function(engine, EngineDestroy);
  ENGINE_set_load_privkey_function(engine, EngineLoadPrivkey);

  return 1;
}

extern "C" {
  DEFAULT_VISIBILITY IMPLEMENT_DYNAMIC_CHECK_FN();
  DEFAULT_VISIBILITY IMPLEMENT_DYNAMIC_BIND_FN(bind_fn);
}

}  // anonymous namespace
                                                                                                                                                                          node-23.7.0/test/addons/openssl-providers/                                                          0000775 0000000 0000000 00000000000 14746647661 0020502 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/openssl-providers/binding.cc                                                0000664 0000000 0000000 00000002442 14746647661 0022425 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <assert.h>
#include <node.h>

#include <openssl/opensslv.h>
#if OPENSSL_VERSION_MAJOR >= 3
#include <openssl/provider.h>
#endif

namespace {

using v8::Array;
using v8::Context;
using v8::FunctionCallbackInfo;
using v8::Isolate;
using v8::Local;
using v8::Object;
using v8::String;
using v8::Value;

#if OPENSSL_VERSION_MAJOR >= 3
int collectProviders(OSSL_PROVIDER* provider, void* cbdata) {
  static_cast<std::vector<OSSL_PROVIDER*>*>(cbdata)->push_back(provider);
  return 1;
}
#endif

inline void GetProviders(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  std::vector<Local<Value>> arr = {};
#if OPENSSL_VERSION_MAJOR >= 3
  std::vector<OSSL_PROVIDER*> providers;
  OSSL_PROVIDER_do_all(nullptr, &collectProviders, &providers);
  for (auto provider : providers) {
    arr.push_back(
        String::NewFromUtf8(isolate, OSSL_PROVIDER_get0_name(provider))
            .ToLocalChecked());
  }
#endif
  args.GetReturnValue().Set(Array::New(isolate, arr.data(), arr.size()));
}

inline void Initialize(Local<Object> exports,
                       Local<Value> module,
                       Local<Context> context) {
  NODE_SET_METHOD(exports, "getProviders", GetProviders);
}

}  // anonymous namespace

NODE_MODULE_CONTEXT_AWARE(NODE_GYP_MODULE_NAME, Initialize)
                                                                                                                                                                                                                              node-23.7.0/test/addons/openssl-providers/binding.gyp                                               0000664 0000000 0000000 00000002064 14746647661 0022637 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'includes': ['../common.gypi'],
      'conditions': [
        ['node_use_openssl=="true"', {
          'conditions': [
            ['OS in "aix os400"', {
              'variables': {
                # Used to differentiate `AIX` and `OS400`(IBM i).
                'aix_variant_name': '<!(uname -s)',
              },
              'conditions': [
                [ '"<(aix_variant_name)"!="OS400"', { # Not `OS400`(IBM i)
                  'sources': ['binding.cc'],
                  'include_dirs': ['../../../deps/openssl/openssl/include'],
                }],
              ],
            }, {
              'sources': ['binding.cc'],
              'include_dirs': ['../../../deps/openssl/openssl/include'],
            }],
          ],
        }],
        ['OS=="mac"', {
          'xcode_settings': {
            'OTHER_CFLAGS+': [
              '-Wno-deprecated-declarations',
            ],
          },
        }, {
          'cflags': ['-Wno-deprecated-declarations'],
        }],
      ],
    },
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/test/addons/openssl-providers/providers.cjs                                             0000664 0000000 0000000 00000004736 14746647661 0023232 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
if (!common.hasCrypto) {
  common.skip('missing crypto');
}
const { hasOpenSSL3 } = require('../../common/crypto');

if (!hasOpenSSL3) {
  common.skip('this test requires OpenSSL 3.x');
}
const assert = require('node:assert');
const { createHash, getCiphers, getHashes } = require('node:crypto');
const { debuglog } = require('node:util');
const { getProviders } = require(`./build/${common.buildType}/binding`);

// For the providers defined here, the expectation is that the listed ciphers
// and hash algorithms are only provided by the named provider. These are for
// basic checks and are not intended to list every cipher or hash algorithm
// supported by the provider.
const providers = {
  'default': {
    ciphers: ['des3-wrap'],
    hashes: ['sha512-256'],
  },
  'legacy': {
    ciphers: ['blowfish', 'idea'],
    hashes: ['md4', 'whirlpool'],
  },
};

const debug = debuglog('test');

module.exports = {
  getCurrentProviders: getProviders,
  testProviderPresent,
  testProviderAbsent,
};

function assertArrayDoesNotInclude(array, item, desc) {
  assert(!array.includes(item),
         `${desc} [${array}] unexpectedly includes "${item}"`);
}

function assertArrayIncludes(array, item, desc) {
  assert(array.includes(item),
         `${desc} [${array}] does not include "${item}"`);
}

function testProviderPresent(provider) {
  debug(`Checking '${provider}' is present`);
  assertArrayIncludes(getProviders(), provider, 'Loaded providers');
  for (const cipher of providers[provider].ciphers || []) {
    debug(`Checking '${cipher}' cipher is available`);
    assertArrayIncludes(getCiphers(), cipher, 'Available ciphers');
  }
  for (const hash of providers[provider].hashes || []) {
    debug(`Checking '${hash}' hash is available`);
    assertArrayIncludes(getHashes(), hash, 'Available hashes');
    createHash(hash);
  }
}

function testProviderAbsent(provider) {
  debug(`Checking '${provider}' is absent`);
  assertArrayDoesNotInclude(getProviders(), provider, 'Loaded providers');
  for (const cipher of providers[provider].ciphers || []) {
    debug(`Checking '${cipher}' cipher is unavailable`);
    assertArrayDoesNotInclude(getCiphers(), cipher, 'Available ciphers');
  }
  for (const hash of providers[provider].hashes || []) {
    debug(`Checking '${hash}' hash is unavailable`);
    assertArrayDoesNotInclude(getHashes(), hash, 'Available hashes');
    assert.throws(() => { createHash(hash); }, { code: 'ERR_OSSL_EVP_UNSUPPORTED' });
  }
}
                                  node-23.7.0/test/addons/openssl-providers/test-default-only-config.js                               0000664 0000000 0000000 00000001217 14746647661 0025664 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
const { path: fixture } = require('../../common/fixtures');
const providers = require('./providers.cjs');

const assert = require('node:assert');
const { fork } = require('node:child_process');
const option = `--openssl-config=${fixture('openssl3-conf', 'default_only.cnf')}`;

if (!process.execArgv.includes(option)) {
  const cp = fork(__filename, { execArgv: [option] });
  cp.on('exit', common.mustCall((code, signal) => {
    assert.strictEqual(code, 0);
    assert.strictEqual(signal, null);
  }));
  return;
}

providers.testProviderPresent('default');
providers.testProviderAbsent('legacy');
                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/test/addons/openssl-providers/test-legacy-provider-config.js                            0000664 0000000 0000000 00000001233 14746647661 0026353 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
const { path: fixture } = require('../../common/fixtures');
const providers = require('./providers.cjs');

const assert = require('node:assert');
const { fork } = require('node:child_process');
const option = `--openssl-config=${fixture('openssl3-conf', 'legacy_provider_enabled.cnf')}`;

if (!process.execArgv.includes(option)) {
  const cp = fork(__filename, { execArgv: [option] });
  cp.on('exit', common.mustCall((code, signal) => {
    assert.strictEqual(code, 0);
    assert.strictEqual(signal, null);
  }));
  return;
}

providers.testProviderPresent('default');
providers.testProviderPresent('legacy');
                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/test/addons/openssl-providers/test-legacy-provider-inactive-config.js                   0000664 0000000 0000000 00000001233 14746647661 0030153 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
const { path: fixture } = require('../../common/fixtures');
const providers = require('./providers.cjs');

const assert = require('node:assert');
const { fork } = require('node:child_process');
const option = `--openssl-config=${fixture('openssl3-conf', 'legacy_provider_inactive.cnf')}`;

if (!process.execArgv.includes(option)) {
  const cp = fork(__filename, { execArgv: [option] });
  cp.on('exit', common.mustCall((code, signal) => {
    assert.strictEqual(code, 0);
    assert.strictEqual(signal, null);
  }));
  return;
}

providers.testProviderPresent('default');
providers.testProviderAbsent('legacy');
                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/test/addons/openssl-providers/test-legacy-provider-option.js                            0000664 0000000 0000000 00000001334 14746647661 0026420 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
const providers = require('./providers.cjs');
const assert = require('node:assert');
const { fork } = require('node:child_process');
const { getFips } = require('node:crypto');

const option = '--openssl-legacy-provider';
const execArgv = process.execArgv;
if (!execArgv.includes(option)) {
  const cp = fork(__filename, { execArgv: [ option ] });
  cp.on('exit', common.mustCall((code, signal) => {
    assert.strictEqual(code, 0);
    assert.strictEqual(signal, null);
  }));
  return;
}

// Enabling FIPS will make all legacy provider algorithms unavailable.
if (getFips()) {
  common.skip('this test cannot be run in FIPS mode');
}
providers.testProviderPresent('legacy');
                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/openssl-providers/test-no-legacy-provider-option.js                         0000664 0000000 0000000 00000001006 14746647661 0027026 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
const providers = require('./providers.cjs');
const assert = require('node:assert');
const { fork } = require('node:child_process');

const option = '--no-openssl-legacy-provider';
if (!process.execArgv.includes(option)) {
  const cp = fork(__filename, { execArgv: [ option ] });
  cp.on('exit', common.mustCall((code, signal) => {
    assert.strictEqual(code, 0);
    assert.strictEqual(signal, null);
  }));
  return;
}

providers.testProviderAbsent('legacy');
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/test/addons/openssl-test-engine/                                                        0000775 0000000 0000000 00000000000 14746647661 0020707 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/openssl-test-engine/binding.gyp                                             0000664 0000000 0000000 00000002015 14746647661 0023040 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'testsetengine',
      'type': 'none',
      'includes': ['../common.gypi'],
      'conditions': [
        ['(OS=="mac" or OS=="linux") and '
         'node_use_openssl=="true" and '
         'node_shared=="false" and '
         'node_shared_openssl=="false"', {
          'type': 'shared_library',
          'sources': [ 'testsetengine.cc' ],
          'product_extension': 'engine',
          'include_dirs': ['../../../deps/openssl/openssl/include'],
          'conditions': [
            ['OS=="mac"', {
              'xcode_settings': {
                'OTHER_CFLAGS': ['-Wno-deprecated-declarations'],
              },
              'link_settings': {
                'libraries': [
                  '../../../../out/<(PRODUCT_DIR)/<(openssl_product)'
                ]
              },
            }],
            ['OS=="linux"', {
              'cflags': [
                '-Wno-deprecated-declarations',
              ],
            }],
          ],
        }],
      ],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/test/addons/openssl-test-engine/test.js                                                 0000664 0000000 0000000 00000004302 14746647661 0022223 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common');

// This tests crypto.setEngine().

if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');

// Engine support in OpenSSL is checked later on.
let hasEngineSupport = true;

assert.throws(() => crypto.setEngine(true), /ERR_INVALID_ARG_TYPE|ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED/);
assert.throws(() => crypto.setEngine('/path/to/engine', 'notANumber'),
              /ERR_INVALID_ARG_TYPE/);

{
  const invalidEngineName = 'xxx';
  assert.throws(() => crypto.setEngine(invalidEngineName),
                /ERR_CRYPTO_ENGINE_UNKNOWN|ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED/);
  assert.throws(() => crypto.setEngine(invalidEngineName,
                                       crypto.constants.ENGINE_METHOD_RSA),
                /ERR_CRYPTO_ENGINE_UNKNOWN|ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED/);
}

try {
  crypto.setEngine('dynamic');
  crypto.setEngine('dynamic');

  crypto.setEngine('dynamic', crypto.constants.ENGINE_METHOD_RSA);
  crypto.setEngine('dynamic', crypto.constants.ENGINE_METHOD_RSA);
} catch (err) {
  assert.strictEqual(err.code, 'ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED');
  hasEngineSupport = false;
}

if (hasEngineSupport) {
  const engine = path.join(__dirname,
                           `/build/${common.buildType}/testsetengine.engine`);

  if (!fs.existsSync(engine))
    common.skip('no engine');

  {
    const engineId = path.parse(engine).name;
    const execDir = path.parse(engine).dir;

    crypto.setEngine(engine);
    // OpenSSL 3.0.1 and 1.1.1m now throw errors if an engine is loaded again
    // with a duplicate absolute path.
    // TODO(richardlau): figure out why this fails on macOS but not Linux.
    // crypto.setEngine(engine);

    // crypto.setEngine(engine, crypto.constants.ENGINE_METHOD_RSA);
    // crypto.setEngine(engine, crypto.constants.ENGINE_METHOD_RSA);

    process.env.OPENSSL_ENGINES = execDir;

    crypto.setEngine(engineId);
    crypto.setEngine(engineId);

    crypto.setEngine(engineId, crypto.constants.ENGINE_METHOD_RSA);
    crypto.setEngine(engineId, crypto.constants.ENGINE_METHOD_RSA);
  }
}
                                                                                                                                                                                                                                                                                                                              node-23.7.0/test/addons/openssl-test-engine/testsetengine.cc                                        0000664 0000000 0000000 00000001655 14746647661 0024106 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <openssl/engine.h>

#ifndef ENGINE_CMD_BASE
# error did not get engine.h
#endif

#define TEST_ENGINE_ID      "testsetengine"
#define TEST_ENGINE_NAME    "dummy test engine"

#ifdef _WIN32
# define DEFAULT_VISIBILITY __declspec(dllexport)
#else
# define DEFAULT_VISIBILITY __attribute__((visibility("default")))
#endif

namespace {

int EngineInit(ENGINE* engine) {
  return 1;
}

int EngineFinish(ENGINE* engine) {
  return 1;
}

int EngineDestroy(ENGINE* engine) {
  return 1;
}

int bind_fn(ENGINE* engine, const char* id) {
  ENGINE_set_id(engine, TEST_ENGINE_ID);
  ENGINE_set_name(engine, TEST_ENGINE_NAME);
  ENGINE_set_init_function(engine, EngineInit);
  ENGINE_set_finish_function(engine, EngineFinish);
  ENGINE_set_destroy_function(engine, EngineDestroy);
  return 1;
}

extern "C" {
  DEFAULT_VISIBILITY IMPLEMENT_DYNAMIC_CHECK_FN();
  DEFAULT_VISIBILITY IMPLEMENT_DYNAMIC_BIND_FN(bind_fn);
}

}  // anonymous namespace
                                                                                   node-23.7.0/test/addons/parse-encoding/                                                             0000775 0000000 0000000 00000000000 14746647661 0017702 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/parse-encoding/binding.cc                                                   0000664 0000000 0000000 00000002032 14746647661 0021620 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node.h>
#include <v8.h>

namespace {

#define ENCODING_MAP(V) \
  V(ASCII)              \
  V(BASE64)             \
  V(BASE64URL)          \
  V(BUFFER)             \
  V(HEX)                \
  V(LATIN1)             \
  V(UCS2)               \
  V(UTF8)               \

static_assert(node::BINARY == node::LATIN1, "BINARY == LATIN1");

void ParseEncoding(const v8::FunctionCallbackInfo<v8::Value>& args) {
  const node::encoding encoding =
      node::ParseEncoding(args.GetIsolate(), args[0],
                          static_cast<node::encoding>(-1));
  const char* encoding_name = "UNKNOWN";
#define V(name) if (encoding == node::name) encoding_name = #name;
  ENCODING_MAP(V)
#undef V
  auto encoding_string =
      v8::String::NewFromUtf8(args.GetIsolate(), encoding_name)
      .ToLocalChecked();
  args.GetReturnValue().Set(encoding_string);
}

void Initialize(v8::Local<v8::Object> exports) {
  NODE_SET_METHOD(exports, "parseEncoding", ParseEncoding);
}

}  // anonymous namespace

NODE_MODULE(NODE_GYP_MODULE_NAME, Initialize)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/addons/parse-encoding/binding.gyp                                                  0000664 0000000 0000000 00000000214 14746647661 0022032 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/parse-encoding/test.js                                                      0000664 0000000 0000000 00000003761 14746647661 0021226 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
const assert = require('assert');
const { parseEncoding } = require(`./build/${common.buildType}/binding`);


assert.strictEqual(parseEncoding('ascii'), 'ASCII');
assert.strictEqual(parseEncoding('ASCII'), 'ASCII');
assert.strictEqual(parseEncoding('base64'), 'BASE64');
assert.strictEqual(parseEncoding('BASE64'), 'BASE64');
assert.strictEqual(parseEncoding('base64url'), 'BASE64URL');
assert.strictEqual(parseEncoding('BASE64URL'), 'BASE64URL');
assert.strictEqual(parseEncoding('binary'), 'LATIN1');
assert.strictEqual(parseEncoding('BINARY'), 'LATIN1');
assert.strictEqual(parseEncoding('buffer'), 'BUFFER');
assert.strictEqual(parseEncoding('BUFFER'), 'BUFFER');
assert.strictEqual(parseEncoding('hex'), 'HEX');
assert.strictEqual(parseEncoding('HEX'), 'HEX');
assert.strictEqual(parseEncoding('latin1'), 'LATIN1');
assert.strictEqual(parseEncoding('LATIN1'), 'LATIN1');

// ucs2 variations
assert.strictEqual(parseEncoding('ucs2'), 'UCS2');
assert.strictEqual(parseEncoding('ucs-2'), 'UCS2');
assert.strictEqual(parseEncoding('UCS2'), 'UCS2');
assert.strictEqual(parseEncoding('UCS-2'), 'UCS2');

// utf8 variations
assert.strictEqual(parseEncoding('utf8'), 'UTF8');
assert.strictEqual(parseEncoding('utf-8'), 'UTF8');
assert.strictEqual(parseEncoding('UTF8'), 'UTF8');
assert.strictEqual(parseEncoding('UTF-8'), 'UTF8');

// utf16le variations
assert.strictEqual(parseEncoding('utf16le'), 'UCS2');
assert.strictEqual(parseEncoding('utf-16le'), 'UCS2');
assert.strictEqual(parseEncoding('UTF16LE'), 'UCS2');
assert.strictEqual(parseEncoding('UTF-16LE'), 'UCS2');

// unknown cases
assert.strictEqual(parseEncoding(''), 'UNKNOWN');
assert.strictEqual(parseEncoding('asCOO'), 'UNKNOWN');
assert.strictEqual(parseEncoding('hux'), 'UNKNOWN');
assert.strictEqual(parseEncoding('utf-buffer'), 'UNKNOWN');
assert.strictEqual(parseEncoding('utf-16leNOT'), 'UNKNOWN');
assert.strictEqual(parseEncoding('linary'), 'UNKNOWN');
assert.strictEqual(parseEncoding('luffer'), 'UNKNOWN');
               node-23.7.0/test/addons/register-signal-handler/                                                    0000775 0000000 0000000 00000000000 14746647661 0021516 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/register-signal-handler/binding.cc                                          0000664 0000000 0000000 00000001537 14746647661 0023445 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #ifndef _WIN32
#include <node.h>
#include <v8.h>
#include <uv.h>
#include <assert.h>
#include <unistd.h>

using v8::Boolean;
using v8::FunctionCallbackInfo;
using v8::Int32;
using v8::Value;

void Handler(int signo, siginfo_t* siginfo, void* ucontext) {
  char signo_char = signo;
  int written;
  do {
    written = write(1, &signo_char, 1);  // write() is signal-safe.
  } while (written == -1 && errno == EINTR);
  assert(written == 1);
}

void RegisterSignalHandler(const FunctionCallbackInfo<Value>& args) {
  assert(args[0]->IsInt32());
  assert(args[1]->IsBoolean());

  int32_t signo = args[0].As<Int32>()->Value();
  bool reset_handler = args[1].As<Boolean>()->Value();

  node::RegisterSignalHandler(signo, Handler, reset_handler);
}

NODE_MODULE_INIT() {
  NODE_SET_METHOD(exports, "registerSignalHandler", RegisterSignalHandler);
}

#endif  // _WIN32
                                                                                                                                                                 node-23.7.0/test/addons/register-signal-handler/binding.gyp                                         0000664 0000000 0000000 00000000214 14746647661 0023646 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/register-signal-handler/test.js                                             0000664 0000000 0000000 00000003730 14746647661 0023036 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common');
if (common.isWindows)
  common.skip('No RegisterSignalHandler() on Windows');

const assert = require('assert');
const fs = require('fs');
const path = require('path');
const { signals } = require('os').constants;
const { spawnSync } = require('child_process');

const bindingPath = path.resolve(
  __dirname, 'build', common.buildType, 'binding.node');

if (!fs.existsSync(bindingPath))
  common.skip('binding not built yet');

const binding = require(bindingPath);

if (process.argv[2] === 'child') {
  const signo = +process.argv[3];
  const reset = process.argv[4] === 'reset';
  const count = +process.argv[5];

  binding.registerSignalHandler(signo, reset);
  for (let i = 0; i < count; i++)
    process.kill(process.pid, signo);
  return;
}

for (const raiseSignal of [ 'SIGABRT', 'SIGSEGV' ]) {
  const signo = signals[raiseSignal];
  for (const { reset, count, stderr, code, signal } of [
    { reset: true, count: 1, stderr: [signo], code: 0, signal: null },
    { reset: true, count: 2, stderr: [signo], code: null, signal: raiseSignal },
    { reset: false, count: 1, stderr: [signo], code: 0, signal: null },
    { reset: false, count: 2, stderr: [signo, signo], code: 0, signal: null },
  ]) {
    // We do not want to generate core files when running this test as an
    // addon test. We require this file as an abort test as well, though,
    // with ALLOW_CRASHES set.
    if (signal !== null && !process.env.ALLOW_CRASHES)
      continue;
    // reset_handler does not work with SIGSEGV.
    if (reset && signo === signals.SIGSEGV)
      continue;

    const args = [__filename, 'child', signo, reset ? 'reset' : '', count];
    console.log(`Running: node ${args.join(' ')}`);
    const result = spawnSync(
      process.execPath, args, { stdio: ['inherit', 'pipe', 'inherit'] });
    assert.strictEqual(result.status, code);
    assert.strictEqual(result.signal, signal);
    assert.deepStrictEqual([...result.stdout], stderr);
  }
}
                                        node-23.7.0/test/addons/repl-domain-abort/                                                          0000775 0000000 0000000 00000000000 14746647661 0020320 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/repl-domain-abort/binding.cc                                                0000664 0000000 0000000 00000003533 14746647661 0022245 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

#include <node.h>
#include <v8.h>

using v8::Boolean;
using v8::Function;
using v8::FunctionCallbackInfo;
using v8::Isolate;
using v8::Local;
using v8::Object;
using v8::Value;

void Method(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  Local<Value> params[] = {
    Boolean::New(isolate, true),
    Boolean::New(isolate, false)
  };
  Local<Value> ret =
      node::MakeCallback(isolate, isolate->GetCurrentContext()->Global(),
                         args[0].As<Function>(), 2, params,
                         node::async_context{0, 0}).ToLocalChecked();
  assert(ret->IsTrue());
}

void init(Local<Object> exports) {
  NODE_SET_METHOD(exports, "method", Method);
}

NODE_MODULE(NODE_GYP_MODULE_NAME, init)
                                                                                                                                                                     node-23.7.0/test/addons/repl-domain-abort/binding.gyp                                               0000664 0000000 0000000 00000000214 14746647661 0022450 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/repl-domain-abort/test.js                                                   0000664 0000000 0000000 00000004532 14746647661 0021641 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';
const common = require('../../common');
const assert = require('assert');
const repl = require('repl');
const stream = require('stream');
const path = require('path');
let buildPath = path.join(__dirname, 'build', common.buildType, 'binding');
// On Windows, escape backslashes in the path before passing it to REPL.
if (common.isWindows)
  buildPath = buildPath.replace(/\\/g, '/');
let cb_ran = false;

process.on('exit', () => {
  assert(cb_ran);
  console.log('ok');
});

const lines = [
  // This line shouldn't cause an assertion error.
  `require(${JSON.stringify(buildPath)})` +
  // Log output to double check callback ran.
  '.method(function(v1, v2) {' +
  'console.log(\'cb_ran\'); return v1 === true && v2 === false; });',
];

const dInput = new stream.Readable();
const dOutput = new stream.Writable();

dInput._read = function _read() {
  while (lines.length > 0 && this.push(lines.shift()));
  if (lines.length === 0)
    this.push(null);
};

dOutput._write = function _write(chunk, encoding, cb) {
  if (chunk.toString().startsWith('cb_ran'))
    cb_ran = true;
  cb();
};

const options = {
  input: dInput,
  output: dOutput,
  terminal: false,
  ignoreUndefined: true,
};

// Run commands from fake REPL.
repl.start(options);
                                                                                                                                                                      node-23.7.0/test/addons/report-api/                                                                 0000775 0000000 0000000 00000000000 14746647661 0017066 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/report-api/binding.cc                                                       0000664 0000000 0000000 00000004736 14746647661 0021021 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node.h>
#include <v8.h>

using v8::Context;
using v8::FunctionCallbackInfo;
using v8::Isolate;
using v8::Local;
using v8::Object;
using v8::Value;

void TriggerReport(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();

  node::TriggerNodeReport(
      isolate, "FooMessage", "BarTrigger", std::string(), Local<Value>());
}

void TriggerReportNoIsolate(const FunctionCallbackInfo<Value>& args) {
  node::TriggerNodeReport(static_cast<Isolate*>(nullptr),
                          "FooMessage",
                          "BarTrigger",
                          std::string(),
                          Local<Value>());
}

void TriggerReportEnv(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();

  node::TriggerNodeReport(
      node::GetCurrentEnvironment(isolate->GetCurrentContext()),
      "FooMessage",
      "BarTrigger",
      std::string(),
      Local<Value>());
}

void TriggerReportNoEnv(const FunctionCallbackInfo<Value>& args) {
  node::TriggerNodeReport(static_cast<node::Environment*>(nullptr),
                          "FooMessage",
                          "BarTrigger",
                          std::string(),
                          Local<Value>());
}

void TriggerReportNoContext(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  Local<Context> context = isolate->GetCurrentContext();
  context->Exit();

  if (isolate->GetCurrentContext().IsEmpty()) {
    node::TriggerNodeReport(
        isolate, "FooMessage", "BarTrigger", std::string(), Local<Value>());
  }

  // Restore current context to avoid crashing in Context::Scope in
  // SpinEventLoop.
  context->Enter();
}

void TriggerReportNewContext(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  Local<Context> context = Context::New(isolate);
  Context::Scope context_scope(context);

  node::TriggerNodeReport(
      isolate, "FooMessage", "BarTrigger", std::string(), Local<Value>());
}

void init(Local<Object> exports) {
  NODE_SET_METHOD(exports, "triggerReport", TriggerReport);
  NODE_SET_METHOD(exports, "triggerReportNoIsolate", TriggerReportNoIsolate);
  NODE_SET_METHOD(exports, "triggerReportEnv", TriggerReportEnv);
  NODE_SET_METHOD(exports, "triggerReportNoEnv", TriggerReportNoEnv);
  NODE_SET_METHOD(exports, "triggerReportNoContext", TriggerReportNoContext);
  NODE_SET_METHOD(exports, "triggerReportNewContext", TriggerReportNewContext);
}

NODE_MODULE(NODE_GYP_MODULE_NAME, init)
                                  node-23.7.0/test/addons/report-api/binding.gyp                                                      0000664 0000000 0000000 00000000214 14746647661 0021216 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/report-api/test.js                                                          0000664 0000000 0000000 00000002754 14746647661 0020413 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
const assert = require('assert');
const path = require('path');
const helper = require('../../common/report.js');
const tmpdir = require('../../common/tmpdir');

const binding = path.resolve(__dirname, `./build/${common.buildType}/binding`);
const addon = require(binding);

function myAddonMain(method, { hasContext, hasEnv }) {
  tmpdir.refresh();
  process.report.directory = tmpdir.path;

  addon[method]();

  const reports = helper.findReports(process.pid, tmpdir.path);
  assert.strictEqual(reports.length, 1);

  const report = reports[0];
  helper.validate(report, [
    ['header.event', 'FooMessage'],
    ['header.trigger', 'BarTrigger'],
  ]);

  const content = require(report);

  // Check that the javascript stack is present.
  if (hasContext) {
    assert.strictEqual(content.javascriptStack.stack.findIndex((frame) => frame.match('myAddonMain')), 0);
  } else {
    assert.strictEqual(content.javascriptStack.message, 'No stack.');
  }

  if (hasEnv) {
    assert.strictEqual(content.header.threadId, 0);
  } else {
    assert.strictEqual(content.header.threadId, null);
  }
}

const methods = [
  ['triggerReport', true, true],
  ['triggerReportNoIsolate', false, false],
  ['triggerReportEnv', true, true],
  ['triggerReportNoEnv', false, false],
  ['triggerReportNoContext', false, false],
  ['triggerReportNewContext', true, false],
];
for (const [method, hasContext, hasEnv] of methods) {
  myAddonMain(method, { hasContext, hasEnv });
}
                    node-23.7.0/test/addons/report-fatalerror/                                                          0000775 0000000 0000000 00000000000 14746647661 0020456 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/report-fatalerror/binding.cc                                                0000664 0000000 0000000 00000000676 14746647661 0022410 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node.h>
#include <v8.h>

using v8::FunctionCallbackInfo;
using v8::Local;
using v8::MaybeLocal;
using v8::Object;
using v8::Value;

void TriggerFatalError(const FunctionCallbackInfo<Value>& args) {
  // Trigger a v8 ApiCheck failure.
  MaybeLocal<Value> value;
  value.ToLocalChecked();
}

void init(Local<Object> exports) {
  NODE_SET_METHOD(exports, "triggerFatalError", TriggerFatalError);
}

NODE_MODULE(NODE_GYP_MODULE_NAME, init)
                                                                  node-23.7.0/test/addons/report-fatalerror/binding.gyp                                               0000664 0000000 0000000 00000000214 14746647661 0022606 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/report-fatalerror/test.js                                                   0000664 0000000 0000000 00000003056 14746647661 0021777 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
const assert = require('assert');
const path = require('path');
const spawnSync = require('child_process').spawnSync;
const helper = require('../../common/report.js');
const tmpdir = require('../../common/tmpdir');

const binding = path.resolve(__dirname, `./build/${common.buildType}/binding`);

if (process.argv[2] === 'child') {
  (function childMain() {
    const addon = require(binding);
    addon.triggerFatalError();
  })();
  return;
}

const ARGS = [
  __filename,
  'child',
];

{
  // Verify that --report-on-fatalerror is respected when set.
  tmpdir.refresh();
  const args = ['--report-on-fatalerror', ...ARGS];
  const child = spawnSync(process.execPath, args, { cwd: tmpdir.path });
  assert.notStrictEqual(child.status, 0, 'Process exited unexpectedly');

  const reports = helper.findReports(child.pid, tmpdir.path);
  assert.strictEqual(reports.length, 1);

  const report = reports[0];
  helper.validate(report);

  const content = require(report);
  assert.strictEqual(content.header.trigger, 'FatalError');

  // Check that the javascript stack is present.
  assert.strictEqual(content.javascriptStack.stack.findIndex((frame) => frame.match('childMain')), 0);
}

{
  // Verify that --report-on-fatalerror is respected when not set.
  const args = ARGS;
  const child = spawnSync(process.execPath, args, { cwd: tmpdir.path });
  assert.notStrictEqual(child.status, 0, 'Process exited unexpectedly');
  const reports = helper.findReports(child.pid, tmpdir.path);
  assert.strictEqual(reports.length, 0);
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/test/addons/request-interrupt/                                                          0000775 0000000 0000000 00000000000 14746647661 0020526 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/request-interrupt/binding.cc                                                0000664 0000000 0000000 00000004210 14746647661 0022444 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node.h>
#include <v8.h>
#include <thread>  // NOLINT(build/c++11)

using node::Environment;
using v8::Context;
using v8::FunctionCallbackInfo;
using v8::HandleScope;
using v8::Isolate;
using v8::Local;
using v8::Maybe;
using v8::Object;
using v8::String;
using v8::Value;

static std::thread interrupt_thread;

void ScheduleInterrupt(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  HandleScope handle_scope(isolate);
  Environment* env = node::GetCurrentEnvironment(isolate->GetCurrentContext());

  interrupt_thread = std::thread([=]() {
    std::this_thread::sleep_for(std::chrono::seconds(1));
    node::RequestInterrupt(
        env,
        [](void* data) {
          // Interrupt is called from JS thread.
          interrupt_thread.join();
          exit(0);
        },
        nullptr);
  });
}

void ScheduleInterruptWithJS(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  HandleScope handle_scope(isolate);
  Environment* env = node::GetCurrentEnvironment(isolate->GetCurrentContext());

  interrupt_thread = std::thread([=]() {
    std::this_thread::sleep_for(std::chrono::seconds(1));
    node::RequestInterrupt(
        env,
        [](void* data) {
          // Interrupt is called from JS thread.
          interrupt_thread.join();
          Isolate* isolate = static_cast<Isolate*>(data);
          HandleScope handle_scope(isolate);
          Local<Context> ctx = isolate->GetCurrentContext();
          Local<String> str =
              String::NewFromUtf8(isolate, "interrupt").ToLocalChecked();
          // Calling into JS should abort immediately.
          Maybe<bool> result = ctx->Global()->Set(ctx, str, str);
          // Should not reach here.
          if (!result.IsNothing()) {
            // Called into JavaScript.
            exit(2);
          }
          // Maybe exception thrown.
          exit(1);
        },
        isolate);
  });
}

void init(Local<Object> exports) {
  NODE_SET_METHOD(exports, "scheduleInterrupt", ScheduleInterrupt);
  NODE_SET_METHOD(exports, "ScheduleInterruptWithJS", ScheduleInterruptWithJS);
}

NODE_MODULE(NODE_GYP_MODULE_NAME, init)
                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/addons/request-interrupt/binding.gyp                                               0000664 0000000 0000000 00000000214 14746647661 0022656 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/request-interrupt/test.js                                                   0000664 0000000 0000000 00000002355 14746647661 0022050 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
const assert = require('assert');
const path = require('path');
const spawnSync = require('child_process').spawnSync;

const binding = path.resolve(__dirname, `./build/${common.buildType}/binding`);

Object.defineProperty(globalThis, 'interrupt', {
  get: () => {
    return null;
  },
  set: () => {
    throw new Error('should not calling into js');
  },
});

if (process.argv[2] === 'child-busyloop') {
  (function childMain() {
    const addon = require(binding);
    addon[process.argv[3]]();
    while (true) {
      /** wait for interrupt */
    }
  })();
  return;
}

if (process.argv[2] === 'child-idle') {
  (function childMain() {
    const addon = require(binding);
    addon[process.argv[3]]();
    // wait for interrupt
    setTimeout(() => {}, 10_000_000);
  })();
  return;
}

for (const type of ['busyloop', 'idle']) {
  {
    const child = spawnSync(process.execPath, [ __filename, `child-${type}`, 'scheduleInterrupt' ]);
    assert.strictEqual(child.status, 0, `${type} should exit with code 0`);
  }

  {
    const child = spawnSync(process.execPath, [ __filename, `child-${type}`, 'ScheduleInterruptWithJS' ]);
    assert(common.nodeProcessAborted(child.status, child.signal));
  }
}
                                                                                                                                                                                                                                                                                   node-23.7.0/test/addons/stringbytes-external-exceed-max/                                            0000775 0000000 0000000 00000000000 14746647661 0023217 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/stringbytes-external-exceed-max/binding.cc                                  0000664 0000000 0000000 00000002743 14746647661 0025146 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node.h>
#include <v8.h>
#include <stdlib.h>

#ifdef _AIX
// AIX allows over-allocation, and will SIGKILL when the allocated pages are
// used if there is not enough VM. Check for available space until
// out-of-memory.  Don't allow more then some (large) proportion of it to be
// used for the test strings, so Node & V8 have some space for allocations.
#include <signal.h>
#include <sys/vminfo.h>

static void* Allowed(size_t size) {
  blkcnt_t allowedBlocks = psdanger(SIGKILL);

  if (allowedBlocks < 1) {
    // Already OOM
    return nullptr;
  }
  const size_t BYTES_PER_BLOCK = 512;
  size_t allowed = (allowedBlocks * BYTES_PER_BLOCK * 4) / 5;
  if (size < allowed) {
    return malloc(size);
  }
  return nullptr;
}
#else
// Other systems also allow over-allocation, but this malloc-and-free approach
// seems to be working for them.
static void* Allowed(size_t size) {
  return malloc(size);
}
#endif  // _AIX

void EnsureAllocation(const v8::FunctionCallbackInfo<v8::Value> &args) {
  v8::Isolate* isolate = args.GetIsolate();
  uintptr_t size = args[0].As<v8::Integer>()->Value();
  v8::Local<v8::Boolean> success;

  void* buffer = Allowed(size);
  if (buffer) {
    success = v8::Boolean::New(isolate, true);
    free(buffer);
  } else {
    success = v8::Boolean::New(isolate, false);
  }
  args.GetReturnValue().Set(success);
}

void init(v8::Local<v8::Object> exports) {
  NODE_SET_METHOD(exports, "ensureAllocation", EnsureAllocation);
}

NODE_MODULE(NODE_GYP_MODULE_NAME, init)
                             node-23.7.0/test/addons/stringbytes-external-exceed-max/binding.gyp                                 0000664 0000000 0000000 00000000214 14746647661 0025347 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/stringbytes-external-exceed-max/test-stringbytes-external-at-max.js         0000664 0000000 0000000 00000001703 14746647661 0032115 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
const skipMessage = 'intensive toString tests due to memory confinements';
if (!common.enoughTestMem)
  common.skip(skipMessage);

const binding = require(`./build/${common.buildType}/binding`);
const assert = require('assert');

// v8 fails silently if string length > v8::String::kMaxLength
// v8::String::kMaxLength defined in v8.h
const kStringMaxLength = require('buffer').constants.MAX_STRING_LENGTH;

let buf;
try {
  buf = Buffer.allocUnsafe(kStringMaxLength);
} catch (e) {
  // If the exception is not due to memory confinement then rethrow it.
  if (e.message !== 'Array buffer allocation failed') throw (e);
  common.skip(skipMessage);
}

// Ensure we have enough memory available for future allocations to succeed.
if (!binding.ensureAllocation(2 * kStringMaxLength))
  common.skip(skipMessage);

const maxString = buf.toString('latin1');
assert.strictEqual(maxString.length, kStringMaxLength);
                                                             test-stringbytes-external-exceed-max-by-1-ascii.js                                                  0000664 0000000 0000000 00000002145 14746647661 0034524 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/test/addons/stringbytes-external-exceed-max                                                                                                                'use strict';

const common = require('../../common');
const skipMessage = 'intensive toString tests due to memory confinements';
if (!common.enoughTestMem)
  common.skip(skipMessage);

const assert = require('assert');
const binding = require(`./build/${common.buildType}/binding`);

// v8 fails silently if string length > v8::String::kMaxLength
// v8::String::kMaxLength defined in v8.h
const kStringMaxLength = require('buffer').constants.MAX_STRING_LENGTH;

let buf;
try {
  buf = Buffer.allocUnsafe(kStringMaxLength + 1);
} catch (e) {
  // If the exception is not due to memory confinement then rethrow it.
  if (e.message !== 'Array buffer allocation failed') throw (e);
  common.skip(skipMessage);
}

// Ensure we have enough memory available for future allocations to succeed.
if (!binding.ensureAllocation(2 * kStringMaxLength))
  common.skip(skipMessage);

const stringLengthHex = kStringMaxLength.toString(16);
assert.throws(() => {
  buf.toString('ascii');
}, {
  message: `Cannot create a string longer than 0x${stringLengthHex} ` +
           'characters',
  code: 'ERR_STRING_TOO_LONG',
  name: 'Error',
});
                                                                                                                                                                                                                                                                                                                                                                                                                           test-stringbytes-external-exceed-max-by-1-base64.js                                                 0000664 0000000 0000000 00000002146 14746647661 0034521 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/test/addons/stringbytes-external-exceed-max                                                                                                                'use strict';

const common = require('../../common');
const skipMessage = 'intensive toString tests due to memory confinements';
if (!common.enoughTestMem)
  common.skip(skipMessage);

const assert = require('assert');
const binding = require(`./build/${common.buildType}/binding`);

// v8 fails silently if string length > v8::String::kMaxLength
// v8::String::kMaxLength defined in v8.h
const kStringMaxLength = require('buffer').constants.MAX_STRING_LENGTH;

let buf;
try {
  buf = Buffer.allocUnsafe(kStringMaxLength + 1);
} catch (e) {
  // If the exception is not due to memory confinement then rethrow it.
  if (e.message !== 'Array buffer allocation failed') throw (e);
  common.skip(skipMessage);
}

// Ensure we have enough memory available for future allocations to succeed.
if (!binding.ensureAllocation(2 * kStringMaxLength))
  common.skip(skipMessage);

const stringLengthHex = kStringMaxLength.toString(16);
assert.throws(() => {
  buf.toString('base64');
}, {
  message: `Cannot create a string longer than 0x${stringLengthHex} ` +
           'characters',
  code: 'ERR_STRING_TOO_LONG',
  name: 'Error',
});
                                                                                                                                                                                                                                                                                                                                                                                                                          test-stringbytes-external-exceed-max-by-1-binary.js                                                 0000664 0000000 0000000 00000003000 14746647661 0034707 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/test/addons/stringbytes-external-exceed-max                                                                                                                // Flags: --expose-gc
'use strict';

const common = require('../../common');
const skipMessage = 'intensive toString tests due to memory confinements';
if (!common.enoughTestMem)
  common.skip(skipMessage);

const binding = require(`./build/${common.buildType}/binding`);
const assert = require('assert');

// v8 fails silently if string length > v8::String::kMaxLength
// v8::String::kMaxLength defined in v8.h
const kStringMaxLength = require('buffer').constants.MAX_STRING_LENGTH;

let buf;
try {
  buf = Buffer.allocUnsafe(kStringMaxLength + 1);
} catch (e) {
  // If the exception is not due to memory confinement then rethrow it.
  if (e.message !== 'Array buffer allocation failed') throw (e);
  common.skip(skipMessage);
}

// Ensure we have enough memory available for future allocations to succeed.
if (!binding.ensureAllocation(2 * kStringMaxLength))
  common.skip(skipMessage);

const stringLengthHex = kStringMaxLength.toString(16);
assert.throws(() => {
  buf.toString('latin1');
}, {
  message: `Cannot create a string longer than 0x${stringLengthHex} ` +
           'characters',
  code: 'ERR_STRING_TOO_LONG',
  name: 'Error',
});

// FIXME: Free the memory early to avoid OOM.
// REF: https://github.com/nodejs/reliability/issues/12#issuecomment-412619655
global.gc();
let maxString = buf.toString('latin1', 1);
assert.strictEqual(maxString.length, kStringMaxLength);
maxString = undefined;
global.gc();

maxString = buf.toString('latin1', 0, kStringMaxLength);
assert.strictEqual(maxString.length, kStringMaxLength);
test-stringbytes-external-exceed-max-by-1-hex.js                                                    0000664 0000000 0000000 00000002143 14746647661 0034216 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/test/addons/stringbytes-external-exceed-max                                                                                                                'use strict';

const common = require('../../common');
const skipMessage = 'intensive toString tests due to memory confinements';
if (!common.enoughTestMem)
  common.skip(skipMessage);

const assert = require('assert');
const binding = require(`./build/${common.buildType}/binding`);

// v8 fails silently if string length > v8::String::kMaxLength
// v8::String::kMaxLength defined in v8.h
const kStringMaxLength = require('buffer').constants.MAX_STRING_LENGTH;

let buf;
try {
  buf = Buffer.allocUnsafe(kStringMaxLength + 1);
} catch (e) {
  // If the exception is not due to memory confinement then rethrow it.
  if (e.message !== 'Array buffer allocation failed') throw (e);
  common.skip(skipMessage);
}

// Ensure we have enough memory available for future allocations to succeed.
if (!binding.ensureAllocation(2 * kStringMaxLength))
  common.skip(skipMessage);

const stringLengthHex = kStringMaxLength.toString(16);
assert.throws(() => {
  buf.toString('hex');
}, {
  message: `Cannot create a string longer than 0x${stringLengthHex} ` +
           'characters',
  code: 'ERR_STRING_TOO_LONG',
  name: 'Error',
});
                                                                                                                                                                                                                                                                                                                                                                                                                             test-stringbytes-external-exceed-max-by-1-utf8.js                                                   0000664 0000000 0000000 00000002700 14746647661 0034317 0                                                                                                    ustar 00root                            root                            0000000 0000000 node-23.7.0/test/addons/stringbytes-external-exceed-max                                                                                                                'use strict';

const common = require('../../common');
const skipMessage = 'intensive toString tests due to memory confinements';
if (!common.enoughTestMem)
  common.skip(skipMessage);

const binding = require(`./build/${common.buildType}/binding`);
const assert = require('assert');

// v8 fails silently if string length > v8::String::kMaxLength
// v8::String::kMaxLength defined in v8.h
const kStringMaxLength = require('buffer').constants.MAX_STRING_LENGTH;

let buf;
try {
  buf = Buffer.allocUnsafe(kStringMaxLength + 1);
} catch (e) {
  // If the exception is not due to memory confinement then rethrow it.
  if (e.message !== 'Array buffer allocation failed') throw (e);
  common.skip(skipMessage);
}

// Ensure we have enough memory available for future allocations to succeed.
if (!binding.ensureAllocation(2 * kStringMaxLength))
  common.skip(skipMessage);

const stringLengthHex = kStringMaxLength.toString(16);

assert.throws(() => {
  buf.toString();
}, (e) => {
  if (e.message !== 'Array buffer allocation failed') {
    common.expectsError({
      message: `Cannot create a string longer than 0x${stringLengthHex} ` +
               'characters',
      code: 'ERR_STRING_TOO_LONG',
      name: 'Error',
    })(e);
    return true;
  }
  return true;
});

assert.throws(() => {
  buf.toString('utf8');
}, {
  message: `Cannot create a string longer than 0x${stringLengthHex} ` +
           'characters',
  code: 'ERR_STRING_TOO_LONG',
  name: 'Error',
});
                                                                node-23.7.0/test/addons/stringbytes-external-exceed-max/test-stringbytes-external-exceed-max-by-2.js0000664 0000000 0000000 00000001736 14746647661 0033523 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
const skipMessage = 'intensive toString tests due to memory confinements';
if (!common.enoughTestMem)
  common.skip(skipMessage);

const binding = require(`./build/${common.buildType}/binding`);
const assert = require('assert');

// v8 fails silently if string length > v8::String::kMaxLength
// v8::String::kMaxLength defined in v8.h
const kStringMaxLength = require('buffer').constants.MAX_STRING_LENGTH;

let buf;
try {
  buf = Buffer.allocUnsafe(kStringMaxLength + 2);
} catch (e) {
  // If the exception is not due to memory confinement then rethrow it.
  if (e.message !== 'Array buffer allocation failed') throw (e);
  common.skip(skipMessage);
}

// Ensure we have enough memory available for future allocations to succeed.
if (!binding.ensureAllocation(2 * kStringMaxLength))
  common.skip(skipMessage);

const maxString = buf.toString('utf16le');
assert.strictEqual(maxString.length, Math.floor((kStringMaxLength + 2) / 2));
                                  node-23.7.0/test/addons/stringbytes-external-exceed-max/test-stringbytes-external-exceed-max.js     0000664 0000000 0000000 00000002154 14746647661 0032747 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../../common');
const skipMessage = 'intensive toString tests due to memory confinements';
if (!common.enoughTestMem)
  common.skip(skipMessage);

const assert = require('assert');
const binding = require(`./build/${common.buildType}/binding`);

// v8 fails silently if string length > v8::String::kMaxLength
// v8::String::kMaxLength defined in v8.h
const kStringMaxLength = require('buffer').constants.MAX_STRING_LENGTH;

let buf;
try {
  buf = Buffer.allocUnsafe(kStringMaxLength * 2 + 2);
} catch (e) {
  // If the exception is not due to memory confinement then rethrow it.
  if (e.message !== 'Array buffer allocation failed') throw (e);
  common.skip(skipMessage);
}

// Ensure we have enough memory available for future allocations to succeed.
if (!binding.ensureAllocation(2 * kStringMaxLength))
  common.skip(skipMessage);

const stringLengthHex = kStringMaxLength.toString(16);

assert.throws(() => {
  buf.toString('utf16le');
}, {
  message: `Cannot create a string longer than 0x${stringLengthHex} ` +
           'characters',
  code: 'ERR_STRING_TOO_LONG',
  name: 'Error',
});
                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/symlinked-module/                                                           0000775 0000000 0000000 00000000000 14746647661 0020266 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/symlinked-module/binding.cc                                                 0000664 0000000 0000000 00000000566 14746647661 0022216 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node.h>
#include <v8.h>

void Method(const v8::FunctionCallbackInfo<v8::Value>& args) {
  v8::Isolate* isolate = args.GetIsolate();
  args.GetReturnValue().Set(v8::String::NewFromUtf8(
        isolate, "world").ToLocalChecked());
}

void init(v8::Local<v8::Object> exports) {
  NODE_SET_METHOD(exports, "hello", Method);
}

NODE_MODULE(NODE_GYP_MODULE_NAME, init)
                                                                                                                                          node-23.7.0/test/addons/symlinked-module/binding.gyp                                                0000664 0000000 0000000 00000000214 14746647661 0022416 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/symlinked-module/submodule.js                                               0000664 0000000 0000000 00000000612 14746647661 0022622 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../../common');
const path = require('path');
const assert = require('assert');

// This is a subtest of symlinked-module/test.js. This is not
// intended to be run directly.

module.exports.test = function test(bindingDir) {
  const mod = require(path.join(bindingDir, 'binding.node'));
  assert.notStrictEqual(mod, null);
  assert.strictEqual(mod.hello(), 'world');
};
                                                                                                                      node-23.7.0/test/addons/symlinked-module/test.js                                                    0000664 0000000 0000000 00000002245 14746647661 0021606 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common');
const fs = require('fs');
const path = require('path');
const assert = require('assert');

// This test verifies that symlinked native addons can be required multiple
// times without error. The symlinked module and the non-symlinked module
// should be the same instance. This expectation was not previously being
// tested and ended up being broken by https://github.com/nodejs/node/pull/5950.

// This test should pass in Node.js v4 and v5. This test will pass in Node.js
// with https://github.com/nodejs/node/pull/5950 reverted.

const tmpdir = require('../../common/tmpdir');
tmpdir.refresh();

const addonPath = path.join(__dirname, 'build', common.buildType);
const addonLink = tmpdir.resolve('addon');

try {
  fs.symlinkSync(addonPath, addonLink, 'dir');
} catch (err) {
  if (err.code !== 'EPERM') throw err;
  common.skip('module identity test (no privs for symlinks)');
}

const sub = require('./submodule');
[addonPath, addonLink].forEach((i) => {
  const mod = require(path.join(i, 'binding.node'));
  assert.notStrictEqual(mod, null);
  assert.strictEqual(mod.hello(), 'world');
  sub.test(i); // Should not throw.
});
                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/test/addons/testcfg.py                                                                  0000664 0000000 0000000 00000000302 14746647661 0017010 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        import sys, os
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))
import testpy

def GetConfiguration(context, root):
  return testpy.AddonTestConfiguration(context, root, 'addons')
                                                                                                                                                                                                                                                                                                                              node-23.7.0/test/addons/uv-handle-leak/                                                             0000775 0000000 0000000 00000000000 14746647661 0017601 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/uv-handle-leak/binding.cc                                                   0000664 0000000 0000000 00000003227 14746647661 0021526 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node.h>
#include <v8.h>
#include <uv.h>

using v8::Context;
using v8::FunctionCallbackInfo;
using v8::Isolate;
using v8::Local;
using v8::Value;

// Give these things names in the public namespace so that we can see
// them show up in symbol dumps.
void CloseCallback(uv_handle_t* handle) {}

class ExampleOwnerClass {
 public:
  virtual ~ExampleOwnerClass();
};

// Do not inline this into the class, because that may remove the virtual
// table when LTO is used, and with it the symbol for which we grep the process
// output in test/abort/test-addon-uv-handle-leak.
// When the destructor is not inlined, the compiler will have to assume that it,
// and the vtable, is part of what this compilation unit exports, and keep them.
ExampleOwnerClass::~ExampleOwnerClass() {}

ExampleOwnerClass example_instance;

void LeakHandle(const FunctionCallbackInfo<Value>& args) {
  Isolate* isolate = args.GetIsolate();
  Local<Context> context = isolate->GetCurrentContext();
  uv_loop_t* loop = node::GetCurrentEventLoop(isolate);
  assert(loop != nullptr);

  uv_timer_t* leaked_timer = new uv_timer_t;
  leaked_timer->close_cb = CloseCallback;

  if (args[0]->IsNumber()) {
    leaked_timer->data =
        reinterpret_cast<void*>(args[0]->IntegerValue(context).FromJust());
  } else {
    leaked_timer->data = &example_instance;
  }

  uv_timer_init(loop, leaked_timer);
  uv_timer_start(leaked_timer, [](uv_timer_t*){}, 1000, 1000);
  uv_unref(reinterpret_cast<uv_handle_t*>(leaked_timer));
}

// This module gets loaded multiple times in some tests so it must support that.
NODE_MODULE_INIT(/*exports, module, context*/) {
  NODE_SET_METHOD(exports, "leakHandle", LeakHandle);
}
                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/test/addons/uv-handle-leak/binding.gyp                                                  0000664 0000000 0000000 00000000214 14746647661 0021731 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/uv-handle-leak/test.js                                                      0000664 0000000 0000000 00000001525 14746647661 0021121 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common');
const bindingPath = require.resolve(`./build/${common.buildType}/binding`);
const binding = require(bindingPath);

// This tests checks that addons may leak libuv handles until process exit.
// It’s really not a good idea to do so, but it tests existing behaviour
// that likely can never be removed for backwards compatibility.

// This has a sibling test in test/abort/ which checks output for failures
// from workers.

try {
  // We don’t want to run this in Workers because they do actually enforce
  // a clean-exit policy.
  const { isMainThread } = require('worker_threads');
  if (!isMainThread)
    common.skip('Cannot run test in environment with clean-exit policy');
} catch {
  // Continue regardless of error.
}

binding.leakHandle();
binding.leakHandle(0);
binding.leakHandle(1);
                                                                                                                                                                           node-23.7.0/test/addons/worker-addon/                                                               0000775 0000000 0000000 00000000000 14746647661 0017400 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/worker-addon/binding.cc                                                     0000664 0000000 0000000 00000004054 14746647661 0021324 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node.h>
#include <v8.h>
#include <uv.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>

using v8::Context;
using v8::Function;
using v8::HandleScope;
using v8::Isolate;
using v8::Local;
using v8::MaybeLocal;
using v8::Object;
using v8::String;
using v8::Value;

size_t count = 0;

struct statically_allocated {
  statically_allocated() {
    assert(count == 0);
    printf("ctor ");
  }
  ~statically_allocated() {
    assert(count == 0);
    printf("dtor ");
  }
} var;

void Dummy(void*) {
  assert(0);
}

void Cleanup(void* str) {
  printf("%s ", static_cast<const char*>(str));

  // Check that calling into JS fails.
  Isolate* isolate = Isolate::GetCurrent();
  HandleScope handle_scope(isolate);
  assert(isolate->InContext());
  Local<Context> context = isolate->GetCurrentContext();
  MaybeLocal<Value> call_result =
      context->Global()->Get(
          context, String::NewFromUtf8Literal(isolate, "Object"))
              .ToLocalChecked().As<Function>()->Call(
                  context, v8::Null(isolate), 0, nullptr);
  assert(call_result.IsEmpty());
}

void Initialize(Local<Object> exports,
                Local<Value> module,
                Local<Context> context) {
  node::AddEnvironmentCleanupHook(
      context->GetIsolate(),
      Cleanup,
      const_cast<void*>(static_cast<const void*>("cleanup")));
  node::AddEnvironmentCleanupHook(context->GetIsolate(), Dummy, nullptr);
  node::RemoveEnvironmentCleanupHook(context->GetIsolate(), Dummy, nullptr);

  if (getenv("addExtraItemToEventLoop") != nullptr) {
    // Add an item to the event loop that we do not clean up in order to make
    // sure that for the main thread, this addon's memory persists even after
    // the Environment instance has been destroyed.
    static uv_async_t extra_async;
    uv_loop_t* loop = node::GetCurrentEventLoop(context->GetIsolate());
    int err = uv_async_init(loop, &extra_async, [](uv_async_t*) {});
    assert(err == 0);
    uv_unref(reinterpret_cast<uv_handle_t*>(&extra_async));
  }
}

NODE_MODULE_CONTEXT_AWARE(NODE_GYP_MODULE_NAME, Initialize)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/worker-addon/binding.gyp                                                    0000664 0000000 0000000 00000000214 14746647661 0021530 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/worker-addon/test.js                                                        0000664 0000000 0000000 00000004341 14746647661 0020717 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common');
const assert = require('assert');
const child_process = require('child_process');
const path = require('path');
const { Worker } = require('worker_threads');
const binding = path.resolve(__dirname, `./build/${common.buildType}/binding`);

switch (process.argv[2]) {
  case 'both':
    require(binding);
    // fallthrough
  case 'worker-twice':
  case 'worker': {
    const worker = new Worker(`require(${JSON.stringify(binding)});`, {
      eval: true,
    });
    if (process.argv[2] === 'worker-twice') {
      worker.on('exit', common.mustCall(() => {
        new Worker(`require(${JSON.stringify(binding)});`, {
          eval: true,
        });
      }));
    }
    return;
  }
  case 'main-thread':
    process.env.addExtraItemToEventLoop = 'yes';
    require(binding);
    return;
}

// Use process.report to figure out if we might be running under musl libc.
const glibc = process.report.getReport().header.glibcVersionRuntime;
assert(typeof glibc === 'string' || glibc === undefined, glibc);

const libcMayBeMusl = common.isLinux && glibc === undefined;

for (const { test, expected } of [
  { test: 'worker', expected: [ 'ctor cleanup dtor ' ] },
  { test: 'main-thread', expected: [ 'ctor cleanup dtor ' ] },
  // We always only have 1 instance of the shared object in memory, so
  // 1 ctor and 1 dtor call. If we attach the module to 2 Environments,
  // we expect 2 cleanup calls, otherwise one.
  { test: 'both', expected: [ 'ctor cleanup cleanup dtor ' ] },
  {
    test: 'worker-twice',
    // In this case, we load and unload an addon, then load and unload again.
    // musl doesn't support unloading, so the output may be missing
    // a dtor + ctor pair.
    expected: [
      'ctor cleanup dtor ctor cleanup dtor ',
    ].concat(libcMayBeMusl ? [
      'ctor cleanup cleanup dtor ',
    ] : []),
  },
]) {
  console.log('spawning test', test);
  const proc = child_process.spawnSync(process.execPath, [
    __filename,
    test,
  ]);
  process.stderr.write(proc.stderr.toString());
  assert.strictEqual(proc.stderr.toString(), '');
  assert(expected.includes(proc.stdout.toString()),
         `${proc.stdout.toString()} is not included in ${expected}`);
  assert.strictEqual(proc.status, 0);
}
                                                                                                                                                                                                                                                                                               node-23.7.0/test/addons/worker-buffer-callback/                                                     0000775 0000000 0000000 00000000000 14746647661 0021316 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/worker-buffer-callback/binding.cc                                           0000664 0000000 0000000 00000002075 14746647661 0023243 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node.h>
#include <node_buffer.h>
#include <v8.h>

using v8::Context;
using v8::FunctionCallbackInfo;
using v8::Isolate;
using v8::Local;
using v8::Object;
using v8::Value;

uint32_t free_call_count = 0;

void GetFreeCallCount(const FunctionCallbackInfo<Value>& args) {
  args.GetReturnValue().Set(free_call_count);
}

void Initialize(Local<Object> exports,
                Local<Value> module,
                Local<Context> context) {
  Isolate* isolate = context->GetIsolate();
  NODE_SET_METHOD(exports, "getFreeCallCount", GetFreeCallCount);

  char* data = new char;

  exports->Set(context,
               v8::String::NewFromUtf8(
                   isolate, "buffer").ToLocalChecked(),
               node::Buffer::New(
                   isolate,
                   data,
                   sizeof(char),
                   [](char* data, void* hint) {
                     delete data;
                     free_call_count++;
                   },
                   nullptr).ToLocalChecked()).Check();
}

NODE_MODULE_CONTEXT_AWARE(NODE_GYP_MODULE_NAME, Initialize)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                   node-23.7.0/test/addons/worker-buffer-callback/binding.gyp                                          0000664 0000000 0000000 00000000214 14746647661 0023446 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'sources': [ 'binding.cc' ],
      'includes': ['../common.gypi'],
    }
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/addons/worker-buffer-callback/test-free-called.js                                  0000664 0000000 0000000 00000001221 14746647661 0024770 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common');
const path = require('path');
const assert = require('assert');
const { Worker } = require('worker_threads');
const binding = path.resolve(__dirname, `./build/${common.buildType}/binding`);
const { getFreeCallCount } = require(binding);

// getFreeCallCount initial value is 0
assert.strictEqual(getFreeCallCount(), 0);

// Test that buffers allocated with a free callback through our APIs are
// released when a Worker owning it exits.

const w = new Worker(`require(${JSON.stringify(binding)})`, { eval: true });

w.on('exit', common.mustCall(() => {
  assert.strictEqual(getFreeCallCount(), 1);
}));
                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/test/addons/worker-buffer-callback/test.js                                              0000664 0000000 0000000 00000001123 14746647661 0022630 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../../common');
const assert = require('assert');
const { MessageChannel } = require('worker_threads');
const { buffer } = require(`./build/${common.buildType}/binding`);

// Test that buffers allocated with a free callback through our APIs are not
// transferred.

const { port1 } = new MessageChannel();
const origByteLength = buffer.byteLength;
assert.throws(() => port1.postMessage(buffer, [buffer.buffer]), {
  code: 25,
  name: 'DataCloneError',
});

assert.strictEqual(buffer.byteLength, origByteLength);
assert.notStrictEqual(buffer.byteLength, 0);
                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/test/addons/zlib-binding/                                                               0000775 0000000 0000000 00000000000 14746647661 0017354 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/addons/zlib-binding/binding.cc                                                     0000664 0000000 0000000 00000003431 14746647661 0021276 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include <node.h>
#include <node_buffer.h>
#include <zlib.h>
#include <assert.h>

namespace {

inline void CompressBytes(const v8::FunctionCallbackInfo<v8::Value>& info) {
  assert(info[0]->IsArrayBufferView());
  auto view = info[0].As<v8::ArrayBufferView>();
  auto byte_offset = view->ByteOffset();
  auto byte_length = view->ByteLength();
  assert(view->HasBuffer());
  auto buffer = view->Buffer();
  auto contents = buffer->GetBackingStore();
  auto data = static_cast<unsigned char*>(contents->Data()) + byte_offset;

  Bytef buf[1024];

  z_stream stream;
  stream.zalloc = nullptr;
  stream.zfree = nullptr;

  int err = deflateInit2(&stream, Z_DEFAULT_COMPRESSION, Z_DEFLATED,
                         -15, MAX_MEM_LEVEL, Z_DEFAULT_STRATEGY);
  assert(err == Z_OK);

  stream.avail_in = byte_length;
  stream.next_in = data;
  stream.avail_out = sizeof(buf);
  stream.next_out = buf;
  err = deflate(&stream, Z_FINISH);
  assert(err == Z_STREAM_END);

  auto result = node::Buffer::Copy(info.GetIsolate(),
                                   reinterpret_cast<const char*>(buf),
                                   sizeof(buf) - stream.avail_out);

  deflateEnd(&stream);

  info.GetReturnValue().Set(result.ToLocalChecked());
}

inline void Initialize(v8::Local<v8::Object> exports,
                       v8::Local<v8::Value> module,
                       v8::Local<v8::Context> context) {
  auto isolate = context->GetIsolate();
  auto key = v8::String::NewFromUtf8(
      isolate, "compressBytes").ToLocalChecked();
  auto value = v8::FunctionTemplate::New(isolate, CompressBytes)
                   ->GetFunction(context)
                   .ToLocalChecked();
  assert(exports->Set(context, key, value).IsJust());
}

}  // anonymous namespace

NODE_MODULE_CONTEXT_AWARE(NODE_GYP_MODULE_NAME, Initialize)
                                                                                                                                                                                                                                       node-23.7.0/test/addons/zlib-binding/binding.gyp                                                    0000664 0000000 0000000 00000001212 14746647661 0021503 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        {
  'targets': [
    {
      'target_name': 'binding',
      'conditions': [
        ['OS in "aix os400"', {
          'variables': {
            # Used to differentiate `AIX` and `OS400`(IBM i).
            'aix_variant_name': '<!(uname -s)',
          },
          'conditions': [
            [ '"<(aix_variant_name)"!="OS400"', { # Not `OS400`(IBM i)
              'sources': ['binding.cc'],
              'include_dirs': ['../../../deps/zlib'],
            }],
          ],
        }, {
          'sources': ['binding.cc'],
          'include_dirs': ['../../../deps/zlib'],
        }],
      ],
      'includes': ['../common.gypi'],
    },
  ]
}
                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/addons/zlib-binding/test.js                                                        0000664 0000000 0000000 00000000557 14746647661 0020700 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --force-context-aware

'use strict';

const common = require('../../common');
const assert = require('assert');
const zlib = require('zlib');
const binding = require(`./build/${common.buildType}/binding`);

const input = Buffer.from('Hello, World!');

const output = zlib.inflateRawSync(binding.compressBytes(input));
assert.deepStrictEqual(input, output);
                                                                                                                                                 node-23.7.0/test/async-hooks/                                                                       0000775 0000000 0000000 00000000000 14746647661 0015772 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/async-hooks/async-hooks.status                                                     0000664 0000000 0000000 00000000761 14746647661 0021501 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        prefix async-hooks

# To mark a test as flaky, list the test name in the appropriate section
# below, without ".js", followed by ": PASS,FLAKY". Example:
# sample-test                        : PASS,FLAKY

[true] # This section applies to all platforms

[$system==win32]

[$system==linux]

[$system==macos]

[$arch==arm || $arch==arm64]

[$system==solaris] # Also applies to SmartOS
# https://github.com/nodejs/node/issues/43457
test-callback-error: PASS, FLAKY

[$system==freebsd]

[$system==aix]
               node-23.7.0/test/async-hooks/coverage.md                                                            0000664 0000000 0000000 00000003630 14746647661 0020111 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        # AsyncHooks Coverage Overview

Showing which kind of async resource is covered by which test:

| Resource Type       | Test                                    |
| ------------------- | --------------------------------------- |
| CONNECTION          | test-connection.ssl.js                  |
| FSEVENTWRAP         | test-fseventwrap.js                     |
| FSREQCALLBACK       | test-fsreqcallback-{access,readFile}.js |
| GETADDRINFOREQWRAP  | test-getaddrinforeqwrap.js              |
| GETNAMEINFOREQWRAP  | test-getnameinforeqwrap.js              |
| HTTPINCOMINGMESSAGE | test-httpparser.request.js              |
| HTTPCLIENTREQUEST   | test-httpparser.response.js             |
| Immediate           | test-immediate.js                       |
| JSSTREAM            | TODO (crashes when accessing directly)  |
| PBKDF2REQUEST       | test-crypto-pbkdf2.js                   |
| PIPECONNECTWRAP     | test-pipeconnectwrap.js                 |
| PIPEWRAP            | test-pipewrap.js                        |
| PROCESSWRAP         | test-pipewrap.js                        |
| QUERYWRAP           | test-querywrap.js                       |
| RANDOMBYTESREQUEST  | test-crypto-randomBytes.js              |
| SHUTDOWNWRAP        | test-shutdownwrap.js                    |
| SIGNALWRAP          | test-signalwrap.js                      |
| STATWATCHER         | test-statwatcher.js                     |
| TCPCONNECTWRAP      | test-tcpwrap.js                         |
| TCPWRAP             | test-tcpwrap.js                         |
| TLSWRAP             | test-tlswrap.js                         |
| TTYWRAP             | test-ttywrap.{read,write}stream.js      |
| UDPSENDWRAP         | test-udpsendwrap.js                     |
| UDPWRAP             | test-udpwrap.js                         |
| WRITEWRAP           | test-writewrap.js                       |
| ZLIB                | test-zlib.zlib-binding.deflate.js       |
                                                                                                        node-23.7.0/test/async-hooks/hook-checks.js                                                         0000664 0000000 0000000 00000004150 14746647661 0020526 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');

/**
 * Checks the expected invocations against the invocations that actually
 * occurred.
 * @name checkInvocations
 * @function
 * @param {object} activity including timestamps for each life time event,
 *                 i.e. init, before ...
 * @param {object} hooks the expected life time event invocations with a count
 *                       indicating how often they should have been invoked,
 *                       i.e. `{ init: 1, before: 2, after: 2 }`
 * @param {string} stage the name of the stage in the test at which we are
 *                       checking the invocations
 */
exports.checkInvocations = function checkInvocations(activity, hooks, stage) {
  const stageInfo = `Checking invocations at stage "${stage}":\n   `;

  assert.ok(activity != null,
            `${stageInfo} Trying to check invocation for an activity, ` +
            'but it was empty/undefined.',
  );

  // Check that actual invocations for all hooks match the expected invocations
  [ 'init', 'before', 'after', 'destroy', 'promiseResolve' ].forEach(checkHook);

  function checkHook(k) {
    const val = hooks[k];
    // Not expected ... all good
    if (val == null) return;

    if (val === 0) {
      // Didn't expect any invocations, but it was actually invoked
      const invocations = activity[k].length;
      const msg = `${stageInfo} Called "${k}" ${invocations} time(s), ` +
                  'but expected no invocations.';
      assert(activity[k] === null && activity[k] === undefined, msg);
    } else {
      // Expected some invocations, make sure that it was invoked at all
      const msg1 = `${stageInfo} Never called "${k}", ` +
                   `but expected ${val} invocation(s).`;
      assert(activity[k] !== null && activity[k] !== undefined, msg1);

      // Now make sure that the expected count and
      // the actual invocation count match
      const msg2 = `${stageInfo}  Called "${k}" ${activity[k].length} ` +
                   `time(s), but expected ${val} invocation(s).`;
      assert.strictEqual(activity[k].length, val, msg2);
    }
  }
};
                                                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/async-hooks/init-hooks.js                                                          0000664 0000000 0000000 00000016151 14746647661 0020420 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// Flags: --expose-gc

require('../common');
const assert = require('assert');
const async_hooks = require('async_hooks');
const { isMainThread } = require('worker_threads');
const util = require('util');
const print = process._rawDebug;

if (typeof global.gc === 'function') {
  (function exity(cntr) {
    process.once('beforeExit', () => {
      global.gc();
      if (cntr < 4) setImmediate(() => exity(cntr + 1));
    });
  })(0);
}

function noop() {}

class ActivityCollector {
  constructor(start, {
    allowNoInit = false,
    oninit,
    onbefore,
    onafter,
    ondestroy,
    onpromiseResolve,
    logid = null,
    logtype = null,
  } = {}) {
    this._start = start;
    this._allowNoInit = allowNoInit;
    this._activities = new Map();
    this._logid = logid;
    this._logtype = logtype;

    // Register event handlers if provided
    this.oninit = typeof oninit === 'function' ? oninit : noop;
    this.onbefore = typeof onbefore === 'function' ? onbefore : noop;
    this.onafter = typeof onafter === 'function' ? onafter : noop;
    this.ondestroy = typeof ondestroy === 'function' ? ondestroy : noop;
    this.onpromiseResolve = typeof onpromiseResolve === 'function' ?
      onpromiseResolve : noop;

    // Create the hook with which we'll collect activity data
    this._asyncHook = async_hooks.createHook({
      init: this._init.bind(this),
      before: this._before.bind(this),
      after: this._after.bind(this),
      destroy: this._destroy.bind(this),
      promiseResolve: this._promiseResolve.bind(this),
    });
  }

  enable() {
    this._asyncHook.enable();
  }

  disable() {
    this._asyncHook.disable();
  }

  sanityCheck(types) {
    if (types != null && !Array.isArray(types)) types = [ types ];

    function activityString(a) {
      return util.inspect(a, false, 5, true);
    }

    const violations = [];
    let tempActivityString;

    function v(msg) { violations.push(msg); }
    for (const a of this._activities.values()) {
      tempActivityString = activityString(a);
      if (types != null && !types.includes(a.type)) continue;

      if (a.init && a.init.length > 1) {
        v(`Activity inited twice\n${tempActivityString}` +
          '\nExpected "init" to be called at most once');
      }
      if (a.destroy && a.destroy.length > 1) {
        v(`Activity destroyed twice\n${tempActivityString}` +
          '\nExpected "destroy" to be called at most once');
      }
      if (a.before && a.after) {
        if (a.before.length < a.after.length) {
          v('Activity called "after" without calling "before"\n' +
            `${tempActivityString}` +
            '\nExpected no "after" call without a "before"');
        }
        if (a.before.some((x, idx) => x > a.after[idx])) {
          v('Activity had an instance where "after" ' +
            'was invoked before "before"\n' +
            `${tempActivityString}` +
            '\nExpected "after" to be called after "before"');
        }
      }
      if (a.before && a.destroy) {
        if (a.before.some((x, idx) => x > a.destroy[idx])) {
          v('Activity had an instance where "destroy" ' +
            'was invoked before "before"\n' +
            `${tempActivityString}` +
            '\nExpected "destroy" to be called after "before"');
        }
      }
      if (a.after && a.destroy) {
        if (a.after.some((x, idx) => x > a.destroy[idx])) {
          v('Activity had an instance where "destroy" ' +
            'was invoked before "after"\n' +
            `${tempActivityString}` +
            '\nExpected "destroy" to be called after "after"');
        }
      }
      if (!a.handleIsObject) {
        v(`No resource object\n${tempActivityString}` +
          '\nExpected "init" to be called with a resource object');
      }
    }
    if (violations.length) {
      console.error(violations.join('\n\n') + '\n');
      assert.fail(`${violations.length} failed sanity checks`);
    }
  }

  inspect(opts = {}) {
    if (typeof opts === 'string') opts = { types: opts };
    const { types = null, depth = 5, stage = null } = opts;
    const activities = types == null ?
      Array.from(this._activities.values()) :
      this.activitiesOfTypes(types);

    if (stage != null) console.log(`\n${stage}`);
    console.log(util.inspect(activities, false, depth, true));
  }

  activitiesOfTypes(types) {
    if (!Array.isArray(types)) types = [ types ];
    return this.activities.filter((x) => types.includes(x.type));
  }

  get activities() {
    return Array.from(this._activities.values());
  }

  _stamp(h, hook) {
    if (h == null) return;
    h[hook] ??= [];
    const time = process.hrtime(this._start);
    h[hook].push((time[0] * 1e9) + time[1]);
  }

  _getActivity(uid, hook) {
    const h = this._activities.get(uid);
    if (!h) {
      // If we allowed handles without init we ignore any further life time
      // events this makes sense for a few tests in which we enable some hooks
      // later
      if (this._allowNoInit) {
        const stub = { uid, type: 'Unknown', handleIsObject: true, handle: {} };
        this._activities.set(uid, stub);
        return stub;
      } else if (!isMainThread) {
        // Worker threads start main script execution inside of an AsyncWrap
        // callback, so we don't yield errors for these.
        return null;
      }
      const err = new Error(`Found a handle whose ${hook}` +
                            ' hook was invoked but not its init hook');
      throw err;
    }
    return h;
  }

  _init(uid, type, triggerAsyncId, handle) {
    const activity = {
      uid,
      type,
      triggerAsyncId,
      // In some cases (e.g. Timeout) the handle is a function, thus the usual
      // `typeof handle === 'object' && handle !== null` check can't be used.
      handleIsObject: handle instanceof Object,
      handle,
    };
    this._stamp(activity, 'init');
    this._activities.set(uid, activity);
    this._maybeLog(uid, type, 'init');
    this.oninit(uid, type, triggerAsyncId, handle);
  }

  _before(uid) {
    const h = this._getActivity(uid, 'before');
    this._stamp(h, 'before');
    this._maybeLog(uid, h?.type, 'before');
    this.onbefore(uid);
  }

  _after(uid) {
    const h = this._getActivity(uid, 'after');
    this._stamp(h, 'after');
    this._maybeLog(uid, h?.type, 'after');
    this.onafter(uid);
  }

  _destroy(uid) {
    const h = this._getActivity(uid, 'destroy');
    this._stamp(h, 'destroy');
    this._maybeLog(uid, h?.type, 'destroy');
    this.ondestroy(uid);
  }

  _promiseResolve(uid) {
    const h = this._getActivity(uid, 'promiseResolve');
    this._stamp(h, 'promiseResolve');
    this._maybeLog(uid, h?.type, 'promiseResolve');
    this.onpromiseResolve(uid);
  }

  _maybeLog(uid, type, name) {
    if (this._logid &&
      (type == null || this._logtype == null || this._logtype === type)) {
      print(`${this._logid}.${name}.uid-${uid}`);
    }
  }
}

exports = module.exports = function initHooks({
  oninit,
  onbefore,
  onafter,
  ondestroy,
  onpromiseResolve,
  allowNoInit,
  logid,
  logtype,
} = {}) {
  return new ActivityCollector(process.hrtime(), {
    oninit,
    onbefore,
    onafter,
    ondestroy,
    onpromiseResolve,
    allowNoInit,
    logid,
    logtype,
  });
};
                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/test/async-hooks/test-async-await.js                                                    0000664 0000000 0000000 00000004705 14746647661 0021533 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');

// This test ensures async hooks are being properly called
// when using async-await mechanics. This involves:
// 1. Checking that all initialized promises are being resolved
// 2. Checking that for each 'before' corresponding hook 'after' hook is called

const assert = require('assert');
const initHooks = require('./init-hooks');

const util = require('util');

const sleep = util.promisify(setTimeout);
// Either 'inited' or 'resolved'
const promisesInitState = new Map();
// Either 'before' or 'after' AND asyncId must be present in the other map
const promisesExecutionState = new Map();

const hooks = initHooks({
  oninit,
  onbefore,
  onafter,
  ondestroy: null,  // Intentionally not tested, since it will be removed soon
  onpromiseResolve,
});
hooks.enable();

function oninit(asyncId, type) {
  if (type === 'PROMISE') {
    promisesInitState.set(asyncId, 'inited');
  }
}

function onbefore(asyncId) {
  if (!promisesInitState.has(asyncId)) {
    return;
  }
  promisesExecutionState.set(asyncId, 'before');
}

function onafter(asyncId) {
  if (!promisesInitState.has(asyncId)) {
    return;
  }

  assert.strictEqual(promisesExecutionState.get(asyncId), 'before',
                     'after hook called for promise without prior call' +
                     'to before hook');
  assert.strictEqual(promisesInitState.get(asyncId), 'resolved',
                     'after hook called for promise without prior call' +
                     'to resolve hook');
  promisesExecutionState.set(asyncId, 'after');
}

function onpromiseResolve(asyncId) {
  assert(promisesInitState.has(asyncId),
         'resolve hook called for promise without prior call to init hook');

  promisesInitState.set(asyncId, 'resolved');
}

const timeout = common.platformTimeout(10);

function checkPromisesInitState() {
  for (const initState of promisesInitState.values()) {
    // Promise should not be initialized without being resolved.
    assert.strictEqual(initState, 'resolved');
  }
}

function checkPromisesExecutionState() {
  for (const executionState of promisesExecutionState.values()) {
    // Check for mismatch between before and after hook calls.
    assert.strictEqual(executionState, 'after');
  }
}

process.on('beforeExit', common.mustCall(() => {
  hooks.disable();
  hooks.sanityCheck('PROMISE');

  checkPromisesInitState();
  checkPromisesExecutionState();
}));

async function asyncFunc() {
  await sleep(timeout);
}

asyncFunc();
                                                           node-23.7.0/test/async-hooks/test-async-exec-resource-http-32060.js                                 0000664 0000000 0000000 00000001676 14746647661 0024630 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const {
  executionAsyncResource,
  executionAsyncId,
  createHook,
} = require('async_hooks');
const http = require('http');

const hooked = {};
createHook({
  init(asyncId, type, triggerAsyncId, resource) {
    hooked[asyncId] = resource;
  },
}).enable();

const server = http.createServer((req, res) => {
  res.write('hello');
  setTimeout(() => {
    res.end(' world!');
  }, 1000);
});

server.listen(0, () => {
  assert.strictEqual(executionAsyncResource(), hooked[executionAsyncId()]);
  http.get({ port: server.address().port }, (res) => {
    assert.strictEqual(executionAsyncResource(), hooked[executionAsyncId()]);
    res.on('data', () => {
      assert.strictEqual(executionAsyncResource(), hooked[executionAsyncId()]);
    });
    res.on('end', () => {
      assert.strictEqual(executionAsyncResource(), hooked[executionAsyncId()]);
      server.close();
    });
  });
});
                                                                  node-23.7.0/test/async-hooks/test-async-exec-resource-http-agent.js                                 0000664 0000000 0000000 00000001452 14746647661 0025244 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

const assert = require('node:assert');
const {
  executionAsyncResource,
  executionAsyncId,
  createHook,
} = require('node:async_hooks');
const http = require('node:http');

const hooked = {};
createHook({
  init(asyncId, type, triggerAsyncId, resource) {
    hooked[asyncId] = resource;
  },
}).enable();

const agent = new http.Agent({
  maxSockets: 1,
});

const server = http.createServer((req, res) => {
  res.end('ok');
});

server.listen(0, common.mustCall(() => {
  assert.strictEqual(executionAsyncResource(), hooked[executionAsyncId()]);

  http.get({ agent, port: server.address().port }, common.mustCall(() => {
    assert.strictEqual(executionAsyncResource(), hooked[executionAsyncId()]);
    server.close();
    agent.destroy();
  }));
}));
                                                                                                                                                                                                                      node-23.7.0/test/async-hooks/test-async-exec-resource-http.js                                       0000664 0000000 0000000 00000001230 14746647661 0024142 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const assert = require('assert');
const {
  executionAsyncResource,
  executionAsyncId,
  createHook,
} = require('async_hooks');
const http = require('http');

const hooked = {};
createHook({
  init(asyncId, type, triggerAsyncId, resource) {
    hooked[asyncId] = resource;
  },
}).enable();

const server = http.createServer((req, res) => {
  res.end('ok');
});

server.listen(0, () => {
  assert.strictEqual(executionAsyncResource(), hooked[executionAsyncId()]);

  http.get({ port: server.address().port }, () => {
    assert.strictEqual(executionAsyncResource(), hooked[executionAsyncId()]);
    server.close();
  });
});
                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/async-hooks/test-async-exec-resource-match.js                                      0000664 0000000 0000000 00000003277 14746647661 0024274 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const { readFile } = require('fs');
const {
  createHook,
  executionAsyncResource,
  AsyncResource,
} = require('async_hooks');

// Ignore any asyncIds created before our hook is active.
let firstSeenAsyncId = -1;
const idResMap = new Map();
const numExpectedCalls = 5;

createHook({
  init: common.mustCallAtLeast(
    (asyncId, type, triggerId, resource) => {
      if (firstSeenAsyncId === -1) {
        firstSeenAsyncId = asyncId;
      }
      assert.ok(idResMap.get(asyncId) === undefined);
      idResMap.set(asyncId, resource);
    }, numExpectedCalls),
  before(asyncId) {
    if (asyncId >= firstSeenAsyncId) {
      beforeHook(asyncId);
    }
  },
  after(asyncId) {
    if (asyncId >= firstSeenAsyncId) {
      afterHook(asyncId);
    }
  },
}).enable();

const beforeHook = common.mustCallAtLeast(
  (asyncId) => {
    const res = idResMap.get(asyncId);
    assert.ok(res !== undefined);
    const execRes = executionAsyncResource();
    assert.ok(execRes === res, 'resource mismatch in before');
  }, numExpectedCalls);

const afterHook = common.mustCallAtLeast(
  (asyncId) => {
    const res = idResMap.get(asyncId);
    assert.ok(res !== undefined);
    const execRes = executionAsyncResource();
    assert.ok(execRes === res, 'resource mismatch in after');
  }, numExpectedCalls);

const res = new AsyncResource('TheResource');
const initRes = idResMap.get(res.asyncId());
assert.ok(initRes === res, 'resource mismatch in init');
res.runInAsyncScope(common.mustCall(() => {
  const execRes = executionAsyncResource();
  assert.ok(execRes === res, 'resource mismatch in cb');
}));

readFile(__filename, common.mustCall());
                                                                                                                                                                                                                                                                                                                                 node-23.7.0/test/async-hooks/test-async-local-storage-args.js                                       0000664 0000000 0000000 00000000546 14746647661 0024113 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const { AsyncLocalStorage } = require('async_hooks');

const asyncLocalStorage = new AsyncLocalStorage();

asyncLocalStorage.run({}, (runArg) => {
  assert.strictEqual(runArg, 'foo');
  asyncLocalStorage.exit((exitArg) => {
    assert.strictEqual(exitArg, 'bar');
  }, 'bar');
}, 'foo');
                                                                                                                                                          node-23.7.0/test/async-hooks/test-async-local-storage-async-await.js                                0000664 0000000 0000000 00000000761 14746647661 0025376 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const { AsyncLocalStorage } = require('async_hooks');

const asyncLocalStorage = new AsyncLocalStorage();

async function test() {
  asyncLocalStorage.getStore().set('foo', 'bar');
  await Promise.resolve();
  assert.strictEqual(asyncLocalStorage.getStore().get('foo'), 'bar');
}

async function main() {
  await asyncLocalStorage.run(new Map(), test);
  assert.strictEqual(asyncLocalStorage.getStore(), undefined);
}

main();
               node-23.7.0/test/async-hooks/test-async-local-storage-async-functions.js                            0000664 0000000 0000000 00000001361 14746647661 0026276 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const { AsyncLocalStorage } = require('async_hooks');

async function foo() {}

const asyncLocalStorage = new AsyncLocalStorage();

async function testOut() {
  await foo();
  assert.strictEqual(asyncLocalStorage.getStore(), undefined);
}

async function testAwait() {
  await foo();
  assert.notStrictEqual(asyncLocalStorage.getStore(), undefined);
  assert.strictEqual(asyncLocalStorage.getStore().get('key'), 'value');
  await asyncLocalStorage.exit(testOut);
}

asyncLocalStorage.run(new Map(), () => {
  const store = asyncLocalStorage.getStore();
  store.set('key', 'value');
  testAwait(); // should not reject
});
assert.strictEqual(asyncLocalStorage.getStore(), undefined);
                                                                                                                                                                                                                                                                               node-23.7.0/test/async-hooks/test-async-local-storage-dgram.js                                      0000664 0000000 0000000 00000001426 14746647661 0024247 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

// Regression tests for https://github.com/nodejs/node/issues/40693

const assert = require('assert');
const dgram = require('dgram');
const { AsyncLocalStorage } = require('async_hooks');

dgram.createSocket('udp4')
  .on('message', function(msg, rinfo) { this.send(msg, rinfo.port); })
  .on('listening', function() {
    const asyncLocalStorage = new AsyncLocalStorage();
    const store = { val: 'abcd' };
    asyncLocalStorage.run(store, () => {
      const client = dgram.createSocket('udp4');
      client.on('message', (msg, rinfo) => {
        assert.deepStrictEqual(asyncLocalStorage.getStore(), store);
        client.close();
        this.close();
      });
      client.send('Hello, world!', this.address().port);
    });
  })
  .bind(0);
                                                                                                                                                                                                                                          node-23.7.0/test/async-hooks/test-async-local-storage-enable-disable.js                             0000664 0000000 0000000 00000002057 14746647661 0026005 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const { AsyncLocalStorage } = require('async_hooks');

const asyncLocalStorage = new AsyncLocalStorage();

asyncLocalStorage.run(new Map(), () => {
  asyncLocalStorage.getStore().set('foo', 'bar');
  process.nextTick(() => {
    assert.strictEqual(asyncLocalStorage.getStore().get('foo'), 'bar');
    process.nextTick(() => {
      assert.strictEqual(asyncLocalStorage.getStore(), undefined);
    });

    asyncLocalStorage.disable();
    assert.strictEqual(asyncLocalStorage.getStore(), undefined);

    // Calls to exit() should not mess with enabled status
    asyncLocalStorage.exit(() => {
      assert.strictEqual(asyncLocalStorage.getStore(), undefined);
    });
    assert.strictEqual(asyncLocalStorage.getStore(), undefined);

    process.nextTick(() => {
      assert.strictEqual(asyncLocalStorage.getStore(), undefined);
      asyncLocalStorage.run(new Map().set('bar', 'foo'), () => {
        assert.strictEqual(asyncLocalStorage.getStore().get('bar'), 'foo');
      });
    });
  });
});
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/test/async-hooks/test-async-local-storage-enter-with.js                                 0000664 0000000 0000000 00000001003 14746647661 0025232 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const { AsyncLocalStorage } = require('async_hooks');

const asyncLocalStorage = new AsyncLocalStorage();

setImmediate(() => {
  const store = { foo: 'bar' };
  asyncLocalStorage.enterWith(store);

  assert.strictEqual(asyncLocalStorage.getStore(), store);
  setTimeout(() => {
    assert.strictEqual(asyncLocalStorage.getStore(), store);
  }, 10);
});

setTimeout(() => {
  assert.strictEqual(asyncLocalStorage.getStore(), undefined);
}, 10);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             node-23.7.0/test/async-hooks/test-async-local-storage-errors.js                                     0000664 0000000 0000000 00000007320 14746647661 0024470 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const { AsyncLocalStorage } = require('async_hooks');
const vm = require('vm');

// err1 is emitted sync as a control - no events
// err2 is emitted after a timeout - uncaughtExceptionMonitor
//                                 + uncaughtException
// err3 is emitted after some awaits -  unhandledRejection
// err4 is emitted during handling err3 - uncaughtExceptionMonitor
// err5 is emitted after err4 from a VM lacking hooks - unhandledRejection
//                                                    + uncaughtException

const asyncLocalStorage = new AsyncLocalStorage();
const callbackToken = { callbackToken: true };
const awaitToken = { awaitToken: true };

let i = 0;

// Redefining the uncaughtExceptionHandler is a bit odd, so we just do this
// so we can track total invocations
let underlyingExceptionHandler;
const exceptionHandler = common.mustCall(function(...args) {
  return underlyingExceptionHandler.call(this, ...args);
}, 2);
process.setUncaughtExceptionCaptureCallback(exceptionHandler);

const exceptionMonitor = common.mustCall((err, origin) => {
  if (err.message === 'err2') {
    assert.strictEqual(origin, 'uncaughtException');
    assert.strictEqual(asyncLocalStorage.getStore(), callbackToken);
  } else if (err.message === 'err4') {
    assert.strictEqual(origin, 'unhandledRejection');
    assert.strictEqual(asyncLocalStorage.getStore(), awaitToken);
  } else {
    assert.fail('unknown error ' + err);
  }
}, 2);
process.on('uncaughtExceptionMonitor', exceptionMonitor);

function fireErr1() {
  underlyingExceptionHandler = common.mustCall(function(err) {
    ++i;
    assert.strictEqual(err.message, 'err2');
    assert.strictEqual(asyncLocalStorage.getStore(), callbackToken);
  }, 1);
  try {
    asyncLocalStorage.run(callbackToken, () => {
      setTimeout(fireErr2, 0);
      throw new Error('err1');
    });
  } catch (e) {
    assert.strictEqual(e.message, 'err1');
    assert.strictEqual(asyncLocalStorage.getStore(), undefined);
  }
}

function fireErr2() {
  process.nextTick(() => {
    assert.strictEqual(i, 1);
    fireErr3();
  });
  throw new Error('err2');
}

function fireErr3() {
  assert.strictEqual(asyncLocalStorage.getStore(), callbackToken);
  const rejectionHandler3 = common.mustCall((err) => {
    assert.strictEqual(err.message, 'err3');
    assert.strictEqual(asyncLocalStorage.getStore(), awaitToken);
    process.off('unhandledRejection', rejectionHandler3);

    fireErr4();
  }, 1);
  process.on('unhandledRejection', rejectionHandler3);
  async function awaitTest() {
    await null;
    throw new Error('err3');
  }
  asyncLocalStorage.run(awaitToken, awaitTest);
}

const uncaughtExceptionHandler4 = common.mustCall(
  function(err) {
    assert.strictEqual(err.message, 'err4');
    assert.strictEqual(asyncLocalStorage.getStore(), awaitToken);
    fireErr5();
  }, 1);
function fireErr4() {
  assert.strictEqual(asyncLocalStorage.getStore(), awaitToken);
  underlyingExceptionHandler = uncaughtExceptionHandler4;
  // re-entrant check
  Promise.reject(new Error('err4'));
}

function fireErr5() {
  assert.strictEqual(asyncLocalStorage.getStore(), awaitToken);
  underlyingExceptionHandler = () => {};
  const rejectionHandler5 = common.mustCall((err) => {
    assert.strictEqual(err.message, 'err5');
    assert.strictEqual(asyncLocalStorage.getStore(), awaitToken);
    process.off('unhandledRejection', rejectionHandler5);
  }, 1);
  process.on('unhandledRejection', rejectionHandler5);
  const makeOrphan = vm.compileFunction(`(${String(() => {
    async function main() {
      await null;
      Promise.resolve().then(() => {
        throw new Error('err5');
      });
    }
    main();
  })})()`);
  makeOrphan();
}

fireErr1();
                                                                                                                                                                                                                                                                                                                node-23.7.0/test/async-hooks/test-async-local-storage-gcable.js                                     0000664 0000000 0000000 00000000777 14746647661 0024402 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// Flags: --expose_gc

// This test ensures that AsyncLocalStorage gets gced once it was disabled
// and no strong references remain in userland.

const common = require('../common');
const { AsyncLocalStorage } = require('async_hooks');
const { onGC } = require('../common/gc');

let asyncLocalStorage = new AsyncLocalStorage();

asyncLocalStorage.run({}, () => {
  asyncLocalStorage.disable();

  onGC(asyncLocalStorage, { ongc: common.mustCall() });
});

asyncLocalStorage = null;
global.gc();
 node-23.7.0/test/async-hooks/test-async-local-storage-http-agent.js                                 0000664 0000000 0000000 00000001456 14746647661 0025233 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const { AsyncLocalStorage } = require('async_hooks');
const http = require('http');

const asyncLocalStorage = new AsyncLocalStorage();

const agent = new http.Agent({
  maxSockets: 1,
});

const N = 3;
let responses = 0;

const server = http.createServer(common.mustCall((req, res) => {
  res.end('ok');
}, N));

server.listen(0, common.mustCall(() => {
  const port = server.address().port;

  for (let i = 0; i < N; i++) {
    asyncLocalStorage.run(i, () => {
      http.get({ agent, port }, common.mustCall((res) => {
        assert.strictEqual(asyncLocalStorage.getStore(), i);
        if (++responses === N) {
          server.close();
          agent.destroy();
        }
        res.resume();
      }));
    });
  }
}));
                                                                                                                                                                                                                  node-23.7.0/test/async-hooks/test-async-local-storage-http.js                                       0000664 0000000 0000000 00000001151 14746647661 0024127 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const { AsyncLocalStorage } = require('async_hooks');
const http = require('http');

const asyncLocalStorage = new AsyncLocalStorage();
const server = http.createServer((req, res) => {
  res.end('ok');
});

server.listen(0, () => {
  asyncLocalStorage.run(new Map(), () => {
    const store = asyncLocalStorage.getStore();
    store.set('hello', 'world');
    http.get({ host: 'localhost', port: server.address().port }, () => {
      assert.strictEqual(asyncLocalStorage.getStore().get('hello'), 'world');
      server.close();
    });
  });
});
                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/test/async-hooks/test-async-local-storage-misc-stores.js                                0000664 0000000 0000000 00000000662 14746647661 0025426 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const { AsyncLocalStorage } = require('async_hooks');

const asyncLocalStorage = new AsyncLocalStorage();

asyncLocalStorage.run('hello node', () => {
  assert.strictEqual(asyncLocalStorage.getStore(), 'hello node');
});

const runStore = { hello: 'node' };
asyncLocalStorage.run(runStore, () => {
  assert.strictEqual(asyncLocalStorage.getStore(), runStore);
});
                                                                              node-23.7.0/test/async-hooks/test-async-local-storage-nested.js                                     0000664 0000000 0000000 00000001332 14746647661 0024433 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const { AsyncLocalStorage } = require('async_hooks');

const asyncLocalStorage = new AsyncLocalStorage();
const outer = {};
const inner = {};

function testInner() {
  assert.strictEqual(asyncLocalStorage.getStore(), outer);

  asyncLocalStorage.run(inner, () => {
    assert.strictEqual(asyncLocalStorage.getStore(), inner);
  });
  assert.strictEqual(asyncLocalStorage.getStore(), outer);

  asyncLocalStorage.exit(() => {
    assert.strictEqual(asyncLocalStorage.getStore(), undefined);
  });
  assert.strictEqual(asyncLocalStorage.getStore(), outer);
}

asyncLocalStorage.run(outer, testInner);
assert.strictEqual(asyncLocalStorage.getStore(), undefined);
                                                                                                                                                                                                                                                                                                      node-23.7.0/test/async-hooks/test-async-local-storage-no-mix-contexts.js                            0000664 0000000 0000000 00000002525 14746647661 0026232 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const { AsyncLocalStorage } = require('async_hooks');

const asyncLocalStorage = new AsyncLocalStorage();
const asyncLocalStorage2 = new AsyncLocalStorage();

setTimeout(() => {
  asyncLocalStorage.run(new Map(), () => {
    asyncLocalStorage2.run(new Map(), () => {
      const store = asyncLocalStorage.getStore();
      const store2 = asyncLocalStorage2.getStore();
      store.set('hello', 'world');
      store2.set('hello', 'foo');
      setTimeout(() => {
        assert.strictEqual(asyncLocalStorage.getStore().get('hello'), 'world');
        assert.strictEqual(asyncLocalStorage2.getStore().get('hello'), 'foo');
        asyncLocalStorage.exit(() => {
          assert.strictEqual(asyncLocalStorage.getStore(), undefined);
          assert.strictEqual(asyncLocalStorage2.getStore().get('hello'), 'foo');
        });
        assert.strictEqual(asyncLocalStorage.getStore().get('hello'), 'world');
        assert.strictEqual(asyncLocalStorage2.getStore().get('hello'), 'foo');
      }, 200);
    });
  });
}, 100);

setTimeout(() => {
  asyncLocalStorage.run(new Map(), () => {
    const store = asyncLocalStorage.getStore();
    store.set('hello', 'earth');
    setTimeout(() => {
      assert.strictEqual(asyncLocalStorage.getStore().get('hello'), 'earth');
    }, 100);
  });
}, 100);
                                                                                                                                                                           node-23.7.0/test/async-hooks/test-async-local-storage-promises.js                                   0000664 0000000 0000000 00000001432 14746647661 0025013 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const { AsyncLocalStorage } = require('async_hooks');

async function main() {
  const asyncLocalStorage = new AsyncLocalStorage();
  const err = new Error();
  const next = () => Promise.resolve()
    .then(() => {
      assert.strictEqual(asyncLocalStorage.getStore().get('a'), 1);
      throw err;
    });
  await new Promise((resolve, reject) => {
    asyncLocalStorage.run(new Map(), () => {
      const store = asyncLocalStorage.getStore();
      store.set('a', 1);
      next().then(resolve, reject);
    });
  })
    .catch((e) => {
      assert.strictEqual(asyncLocalStorage.getStore(), undefined);
      assert.strictEqual(e, err);
    });
  assert.strictEqual(asyncLocalStorage.getStore(), undefined);
}

main();
                                                                                                                                                                                                                                      node-23.7.0/test/async-hooks/test-async-local-storage-socket.js                                     0000664 0000000 0000000 00000001312 14746647661 0024437 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

// Regression tests for https://github.com/nodejs/node/issues/40693

const assert = require('assert');
const net = require('net');
const { AsyncLocalStorage } = require('async_hooks');

net
  .createServer((socket) => {
    socket.write('Hello, world!');
    socket.pipe(socket);
  })
  .listen(0, function() {
    const asyncLocalStorage = new AsyncLocalStorage();
    const store = { val: 'abcd' };
    asyncLocalStorage.run(store, () => {
      const client = net.connect({ port: this.address().port });
      client.on('data', () => {
        assert.deepStrictEqual(asyncLocalStorage.getStore(), store);
        client.end();
        this.close();
      });
    });
  });
                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/async-hooks/test-async-local-storage-thenable.js                                   0000664 0000000 0000000 00000002306 14746647661 0024735 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

const assert = require('assert');
const { AsyncLocalStorage } = require('async_hooks');

// This test verifies that async local storage works with thenables

const store = new AsyncLocalStorage();
const data = Symbol('verifier');

const then = common.mustCall((cb) => {
  assert.strictEqual(store.getStore(), data);
  setImmediate(cb);
}, 4);

function thenable() {
  return {
    then,
  };
}

// Await a thenable
store.run(data, async () => {
  assert.strictEqual(store.getStore(), data);
  await thenable();
  assert.strictEqual(store.getStore(), data);
});

// Returning a thenable in an async function
store.run(data, async () => {
  try {
    assert.strictEqual(store.getStore(), data);
    return thenable();
  } finally {
    assert.strictEqual(store.getStore(), data);
  }
});

// Resolving a thenable
store.run(data, () => {
  assert.strictEqual(store.getStore(), data);
  Promise.resolve(thenable());
  assert.strictEqual(store.getStore(), data);
});

// Returning a thenable in a then handler
store.run(data, () => {
  assert.strictEqual(store.getStore(), data);
  Promise.resolve().then(() => thenable());
  assert.strictEqual(store.getStore(), data);
});
                                                                                                                                                                                                                                                                                                                          node-23.7.0/test/async-hooks/test-async-local-storage-tlssocket.js                                  0000664 0000000 0000000 00000001737 14746647661 0025175 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

// Regression tests for https://github.com/nodejs/node/issues/40693

const assert = require('assert');
const fixtures = require('../common/fixtures');
const tls = require('tls');
const { AsyncLocalStorage } = require('async_hooks');

const options = {
  cert: fixtures.readKey('rsa_cert.crt'),
  key: fixtures.readKey('rsa_private.pem'),
  rejectUnauthorized: false,
};

tls
  .createServer(options, (socket) => {
    socket.write('Hello, world!');
    socket.pipe(socket);
  })
  .listen(0, function() {
    const asyncLocalStorage = new AsyncLocalStorage();
    const store = { val: 'abcd' };
    asyncLocalStorage.run(store, () => {
      const client = tls.connect({ port: this.address().port, ...options });
      client.on('data', () => {
        assert.deepStrictEqual(asyncLocalStorage.getStore(), store);
        client.end();
        this.close();
      });
    });
  });
                                 node-23.7.0/test/async-hooks/test-async-wrap-providers.js                                           0000664 0000000 0000000 00000001216 14746647661 0023404 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';

const common = require('../common');
const { internalBinding } = require('internal/test/binding');
const providers = internalBinding('async_wrap').Providers;
const assert = require('assert');
const { asyncWrapProviders } = require('async_hooks');

assert.ok(typeof asyncWrapProviders === 'object');
assert.deepStrictEqual(asyncWrapProviders, { __proto__: null, ...providers });

const providerKeys = Object.keys(asyncWrapProviders);
assert.throws(() => {
  asyncWrapProviders[providerKeys[0]] = 'another value';
}, common.expectsError({
  name: 'TypeError',
}), 'should not allow modify asyncWrap providers');
                                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/test/async-hooks/test-callback-error.js                                                 0000664 0000000 0000000 00000005652 14746647661 0022200 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const { spawnSync } = require('child_process');
const async_hooks = require('async_hooks');
const initHooks = require('./init-hooks');

const arg = process.argv[2];
switch (arg) {
  case 'test_init_callback':
    initHooks({
      oninit: common.mustCall(() => { throw new Error(arg); }),
    }).enable();
    new async_hooks.AsyncResource(`${arg}_type`);
    return;

  case 'test_callback': {
    initHooks({
      onbefore: common.mustCall(() => { throw new Error(arg); }),
    }).enable();
    const resource = new async_hooks.AsyncResource(`${arg}_type`);
    resource.runInAsyncScope(() => {});
    return;
  }

  case 'test_callback_abort':
    initHooks({
      oninit: common.mustCall(() => { throw new Error(arg); }),
    }).enable();
    new async_hooks.AsyncResource(`${arg}_type`);
    return;
}

// This part should run only for the primary test
assert.ok(!arg);
{
  // console.log should stay until this test's flakiness is solved
  console.log('start case 1');
  console.time('end case 1');
  const child = spawnSync(process.execPath, [__filename, 'test_init_callback']);
  assert.ifError(child.error);
  const test_init_first_line = child.stderr.toString().split(/[\r\n]+/g)[0];
  assert.strictEqual(test_init_first_line, 'Error: test_init_callback');
  assert.strictEqual(child.status, 1);
  console.timeEnd('end case 1');
}

{
  console.log('start case 2');
  console.time('end case 2');
  const child = spawnSync(process.execPath, [__filename, 'test_callback']);
  assert.ifError(child.error);
  const test_callback_first_line = child.stderr.toString().split(/[\r\n]+/g)[0];
  assert.strictEqual(test_callback_first_line, 'Error: test_callback');
  assert.strictEqual(child.status, 1);
  console.timeEnd('end case 2');
}

{
  console.log('start case 3');
  console.time('end case 3');
  let program = process.execPath;
  let args = [
    '--abort-on-uncaught-exception', __filename, 'test_callback_abort' ];
  let options = {};
  if (!common.isWindows) {
    [program, options] = common.escapePOSIXShell`ulimit -c 0 && exec "${program}" ${args[0]} "${args[1]}" ${args[2]}`;
    args = [];
    options.shell = true;
  }

  options.encoding = 'utf8';
  const child = spawnSync(program, args, options);
  if (common.isWindows) {
    assert.strictEqual(child.status, 134);
    assert.strictEqual(child.signal, null);
  } else {
    assert.strictEqual(child.status, null);
    // Most posix systems will show 'SIGABRT', but alpine34 does not
    if (child.signal !== 'SIGABRT') {
      console.log(`primary received signal ${child.signal}\nchild's stderr:`);
      console.log(child.stderr);
      process.exit(1);
    }
    assert.strictEqual(child.signal, 'SIGABRT');
  }
  assert.strictEqual(child.stdout, '');
  const firstLineStderr = child.stderr.split(/[\r\n]+/g)[0].trim();
  assert.strictEqual(firstLineStderr, 'Error: test_callback_abort');
  console.timeEnd('end case 3');
}
                                                                                      node-23.7.0/test/async-hooks/test-crypto-pbkdf2.js                                                  0000664 0000000 0000000 00000002345 14746647661 0021777 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
if (!common.hasCrypto) {
  common.skip('missing crypto');
}
const { isMainThread } = require('worker_threads');
if (!isMainThread) {
  common.skip('Worker bootstrapping works differently -> different async IDs');
}

const assert = require('assert');
const tick = require('../common/tick');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');
const crypto = require('crypto');


const hooks = initHooks();

hooks.enable();

crypto.pbkdf2('password', 'salt', 1, 20, 'sha256', common.mustCall(onpbkdf2));

function onpbkdf2() {
  const as = hooks.activitiesOfTypes('PBKDF2REQUEST');
  const a = as[0];
  checkInvocations(a, { init: 1, before: 1 }, 'while in onpbkdf2 callback');
  tick(2);
}

process.on('exit', onexit);
function onexit() {
  hooks.disable();
  hooks.sanityCheck('PBKDF2REQUEST');

  const as = hooks.activitiesOfTypes('PBKDF2REQUEST');
  assert.strictEqual(as.length, 1);

  const a = as[0];
  assert.strictEqual(a.type, 'PBKDF2REQUEST');
  assert.strictEqual(typeof a.uid, 'number');
  assert.strictEqual(a.triggerAsyncId, 1);
  checkInvocations(a, { init: 1, before: 1, after: 1, destroy: 1 },
                   'when process exits');
}
                                                                                                                                                                                                                                                                                           node-23.7.0/test/async-hooks/test-crypto-randomBytes.js                                             0000664 0000000 0000000 00000002376 14746647661 0023122 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
if (!common.hasCrypto) {
  common.skip('missing crypto');
}
const { isMainThread } = require('worker_threads');
if (!isMainThread) {
  common.skip('Worker bootstrapping works differently -> different async IDs');
}

const assert = require('assert');
const tick = require('../common/tick');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');
const crypto = require('crypto');


const hooks = initHooks();

hooks.enable();
crypto.randomBytes(1, common.mustCall(onrandomBytes));

function onrandomBytes() {
  const as = hooks.activitiesOfTypes('RANDOMBYTESREQUEST');
  const a = as[0];
  checkInvocations(a, { init: 1, before: 1 },
                   'while in onrandomBytes callback');
  tick(2);
}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  hooks.sanityCheck('RANDOMBYTESREQUEST');

  const as = hooks.activitiesOfTypes('RANDOMBYTESREQUEST');
  assert.strictEqual(as.length, 1);

  const a = as[0];
  assert.strictEqual(a.type, 'RANDOMBYTESREQUEST');
  assert.strictEqual(typeof a.uid, 'number');
  assert.strictEqual(a.triggerAsyncId, 1);
  checkInvocations(a, { init: 1, before: 1, after: 1, destroy: 1 },
                   'when process exits');
}
                                                                                                                                                                                                                                                                  node-23.7.0/test/async-hooks/test-destroy-not-blocked.js                                            0000664 0000000 0000000 00000004722 14746647661 0023202 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// Flags: --expose_gc

const common = require('../common');
const assert = require('assert');
const tick = require('../common/tick');

const { createHook, AsyncResource } = require('async_hooks');

// Test priority of destroy hook relative to nextTick,... and
// verify a microtask is scheduled in case a lot items are queued

const resType = 'MyResource';
let activeId = -1;
createHook({
  init(id, type) {
    if (type === resType) {
      assert.strictEqual(activeId, -1);
      activeId = id;
    }
  },
  destroy(id) {
    if (activeId === id) {
      activeId = -1;
    }
  },
}).enable();

function testNextTick() {
  assert.strictEqual(activeId, -1);
  const res = new AsyncResource(resType);
  assert.strictEqual(activeId, res.asyncId());
  res.emitDestroy();
  // nextTick has higher prio than emit destroy
  process.nextTick(common.mustCall(() =>
    assert.strictEqual(activeId, res.asyncId())),
  );
}

function testQueueMicrotask() {
  assert.strictEqual(activeId, -1);
  const res = new AsyncResource(resType);
  assert.strictEqual(activeId, res.asyncId());
  res.emitDestroy();
  // queueMicrotask has higher prio than emit destroy
  queueMicrotask(common.mustCall(() =>
    assert.strictEqual(activeId, res.asyncId())),
  );
}

function testImmediate() {
  assert.strictEqual(activeId, -1);
  const res = new AsyncResource(resType);
  assert.strictEqual(activeId, res.asyncId());
  res.emitDestroy();
  setImmediate(common.mustCall(() =>
    assert.strictEqual(activeId, -1)),
  );
}

function testPromise() {
  assert.strictEqual(activeId, -1);
  const res = new AsyncResource(resType);
  assert.strictEqual(activeId, res.asyncId());
  res.emitDestroy();
  // Promise has higher prio than emit destroy
  Promise.resolve().then(common.mustCall(() =>
    assert.strictEqual(activeId, res.asyncId())),
  );
}

async function testAwait() {
  assert.strictEqual(activeId, -1);
  const res = new AsyncResource(resType);
  assert.strictEqual(activeId, res.asyncId());
  res.emitDestroy();

  for (let i = 0; i < 5000; i++) {
    await Promise.resolve();
  }
  global.gc();
  await Promise.resolve();
  // Limit to trigger a microtask not yet reached
  assert.strictEqual(activeId, res.asyncId());
  for (let i = 0; i < 5000; i++) {
    await Promise.resolve();
  }
  global.gc();
  await Promise.resolve();
  assert.strictEqual(activeId, -1);
}

testNextTick();
tick(2, testQueueMicrotask);
tick(4, testImmediate);
tick(6, testPromise);
tick(8, () => testAwait().then(common.mustCall()));
                                              node-23.7.0/test/async-hooks/test-disable-in-init.js                                                0000664 0000000 0000000 00000000744 14746647661 0022262 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const async_hooks = require('async_hooks');
const fs = require('fs');

let nestedCall = false;

async_hooks.createHook({
  init: common.mustCall(() => {
    nestedHook.disable();
    if (!nestedCall) {
      nestedCall = true;
      fs.access(__filename, common.mustCall());
    }
  }, 2),
}).enable();

const nestedHook = async_hooks.createHook({
  init: common.mustCall(2),
}).enable();

fs.access(__filename, common.mustCall());
                            node-23.7.0/test/async-hooks/test-embedder.api.async-resource-no-type.js                            0000664 0000000 0000000 00000001513 14746647661 0026156 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const async_hooks = require('async_hooks');
const { AsyncResource } = async_hooks;
const { spawn } = require('child_process');

const initHooks = require('./init-hooks');

if (process.argv[2] === 'child') {
  initHooks().enable();

  class Foo extends AsyncResource {
    constructor(type) {
      super(type, async_hooks.executionAsyncId());
    }
  }

  [null, undefined, 1, Date, {}, []].forEach((i) => {
    assert.throws(() => new Foo(i), {
      code: 'ERR_INVALID_ARG_TYPE',
      name: 'TypeError',
    });
  });

} else {
  const args = process.argv.slice(1).concat('child');
  spawn(process.execPath, args)
    .on('close', common.mustCall((code) => {
      // No error because the type was defaulted
      assert.strictEqual(code, 0);
    }));
}
                                                                                                                                                                                     node-23.7.0/test/async-hooks/test-embedder.api.async-resource.js                                    0000664 0000000 0000000 00000007051 14746647661 0024570 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const tick = require('../common/tick');
const async_hooks = require('async_hooks');
const { AsyncResource } = async_hooks;

const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');

const hooks = initHooks();
hooks.enable();

assert.throws(
  () => new AsyncResource(), {
    code: 'ERR_INVALID_ARG_TYPE',
    name: 'TypeError',
  });
assert.throws(() => {
  new AsyncResource('invalid_trigger_id', { triggerAsyncId: null });
}, {
  code: 'ERR_INVALID_ASYNC_ID',
  name: 'RangeError',
});

assert.strictEqual(
  new AsyncResource('default_trigger_id').triggerAsyncId(),
  async_hooks.executionAsyncId(),
);

// Create first custom event 'alcazares' with triggerAsyncId derived
// from async_hooks executionAsyncId
const alcaTriggerId = async_hooks.executionAsyncId();
const alcaEvent = new AsyncResource('alcazares', alcaTriggerId);
const alcazaresActivities = hooks.activitiesOfTypes([ 'alcazares' ]);

// Alcazares event was constructed and thus only has an `init` call
assert.strictEqual(alcazaresActivities.length, 1);
const alcazares = alcazaresActivities[0];
assert.strictEqual(alcazares.type, 'alcazares');
assert.strictEqual(typeof alcazares.uid, 'number');
assert.strictEqual(alcazares.triggerAsyncId, alcaTriggerId);
checkInvocations(alcazares, { init: 1 }, 'alcazares constructed');

assert.strictEqual(typeof alcaEvent.asyncId(), 'number');
assert.notStrictEqual(alcaEvent.asyncId(), alcaTriggerId);
assert.strictEqual(alcaEvent.triggerAsyncId(), alcaTriggerId);

alcaEvent.runInAsyncScope(() => {
  checkInvocations(alcazares, { init: 1, before: 1 },
                   'alcazares emitted before');
});
checkInvocations(alcazares, { init: 1, before: 1, after: 1 },
                 'alcazares emitted after');
alcaEvent.runInAsyncScope(() => {
  checkInvocations(alcazares, { init: 1, before: 2, after: 1 },
                   'alcazares emitted before again');
});
checkInvocations(alcazares, { init: 1, before: 2, after: 2 },
                 'alcazares emitted after again');
alcaEvent.emitDestroy();
tick(1, common.mustCall(tick1));

function tick1() {
  checkInvocations(alcazares, { init: 1, before: 2, after: 2, destroy: 1 },
                   'alcazares emitted destroy');

  // The below shows that we can pass any number as a trigger id
  const pobTriggerId = 111;
  const pobEvent = new AsyncResource('poblado', pobTriggerId);
  const pobladoActivities = hooks.activitiesOfTypes([ 'poblado' ]);
  const poblado = pobladoActivities[0];
  assert.strictEqual(poblado.type, 'poblado');
  assert.strictEqual(typeof poblado.uid, 'number');
  assert.strictEqual(poblado.triggerAsyncId, pobTriggerId);
  checkInvocations(poblado, { init: 1 }, 'poblado constructed');
  pobEvent.runInAsyncScope(() => {
    checkInvocations(poblado, { init: 1, before: 1 },
                     'poblado emitted before');
  });

  checkInvocations(poblado, { init: 1, before: 1, after: 1 },
                   'poblado emitted after');

  // After we disable the hooks we shouldn't receive any events anymore
  hooks.disable();
  alcaEvent.emitDestroy();
  tick(1, common.mustCall(tick2));

  function tick2() {
    checkInvocations(
      alcazares, { init: 1, before: 2, after: 2, destroy: 1 },
      'alcazares emitted destroy a second time after hooks disabled');
    pobEvent.emitDestroy();
    tick(1, common.mustCall(tick3));
  }

  function tick3() {
    checkInvocations(poblado, { init: 1, before: 1, after: 1 },
                     'poblado emitted destroy after hooks disabled');
  }
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/test/async-hooks/test-embedder.api.async-resource.runInAsyncScope.js                    0000664 0000000 0000000 00000000513 14746647661 0027646 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
require('../common');
const assert = require('assert');
const async_hooks = require('async_hooks');

// Ensure that asyncResource.makeCallback returns the callback return value.
const a = new async_hooks.AsyncResource('foobar');
const ret = a.runInAsyncScope(() => {
  return 1729;
});
assert.strictEqual(ret, 1729);
                                                                                                                                                                                     node-23.7.0/test/async-hooks/test-emit-after-on-destroyed.js                                        0000664 0000000 0000000 00000003706 14746647661 0023762 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';

const common = require('../common');
const assert = require('assert');
const internal_async_hooks = require('internal/async_hooks');
const { spawn } = require('child_process');
const corruptedMsg = /async hook stack has become corrupted/;
const heartbeatMsg = /heartbeat: still alive/;

const {
  newAsyncId, getDefaultTriggerAsyncId,
  emitInit, emitBefore, emitAfter, emitDestroy,
} = internal_async_hooks;

const initHooks = require('./init-hooks');

if (process.argv[2] === 'child') {
  const hooks = initHooks();
  hooks.enable();

  // Once 'destroy' has been emitted, we can no longer emit 'after'

  // Emitting 'before', 'after' and then 'destroy'
  {
    const asyncId = newAsyncId();
    const triggerId = getDefaultTriggerAsyncId();
    emitInit(asyncId, 'event1', triggerId, {});
    emitBefore(asyncId, triggerId);
    emitAfter(asyncId);
    emitDestroy(asyncId);
  }

  // Emitting 'after' after 'destroy'
  {
    const asyncId = newAsyncId();
    const triggerId = getDefaultTriggerAsyncId();
    emitInit(asyncId, 'event2', triggerId, {});
    emitDestroy(asyncId);

    console.log('heartbeat: still alive');
    emitAfter(asyncId);
  }
} else {
  const args = ['--expose-internals']
    .concat(process.argv.slice(1))
    .concat('child');
  let errData = Buffer.from('');
  let outData = Buffer.from('');

  const child = spawn(process.execPath, args);
  child.stderr.on('data', (d) => { errData = Buffer.concat([ errData, d ]); });
  child.stdout.on('data', (d) => { outData = Buffer.concat([ outData, d ]); });

  child.on('close', common.mustCall((code) => {
    assert.strictEqual(code, 1);
    assert.match(outData.toString(), heartbeatMsg,
                 'did not crash until we reached offending line of code ' +
                 `(found ${outData})`);
    assert.match(errData.toString(), corruptedMsg,
                 'printed error contains corrupted message ' +
                 `(found ${errData})`);
  }));
}
                                                          node-23.7.0/test/async-hooks/test-emit-before-after.js                                              0000664 0000000 0000000 00000002112 14746647661 0022576 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// Flags: --expose-internals

const common = require('../common');
const assert = require('assert');
const async_hooks = require('internal/async_hooks');
const initHooks = require('./init-hooks');

const expectedId = async_hooks.newAsyncId();
const expectedTriggerId = async_hooks.newAsyncId();
const expectedType = 'test_emit_before_after_type';

// Verify that if there is no registered hook, then nothing will happen.
async_hooks.emitBefore(expectedId, expectedTriggerId);
async_hooks.emitAfter(expectedId);

const chkBefore = common.mustCall((id) => assert.strictEqual(id, expectedId));
const chkAfter = common.mustCall((id) => assert.strictEqual(id, expectedId));

const checkOnce = (fn) => {
  let called = false;
  return (...args) => {
    if (called) return;

    called = true;
    fn(...args);
  };
};

initHooks({
  onbefore: checkOnce(chkBefore),
  onafter: checkOnce(chkAfter),
  allowNoInit: true,
}).enable();

async_hooks.emitInit(expectedId, expectedType, expectedTriggerId);
async_hooks.emitBefore(expectedId, expectedTriggerId);
async_hooks.emitAfter(expectedId);
                                                                                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/async-hooks/test-emit-before-on-destroyed.js                                       0000664 0000000 0000000 00000003724 14746647661 0024123 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';

const common = require('../common');
const assert = require('assert');
const internal_async_hooks = require('internal/async_hooks');
const { spawn } = require('child_process');
const corruptedMsg = /async hook stack has become corrupted/;
const heartbeatMsg = /heartbeat: still alive/;

const {
  newAsyncId, getDefaultTriggerAsyncId,
  emitInit, emitBefore, emitAfter, emitDestroy,
} = internal_async_hooks;

const initHooks = require('./init-hooks');

if (process.argv[2] === 'child') {
  const hooks = initHooks();
  hooks.enable();

  // Once 'destroy' has been emitted, we can no longer emit 'before'

  // Emitting 'before', 'after' and then 'destroy'
  {
    const asyncId = newAsyncId();
    const triggerId = getDefaultTriggerAsyncId();
    emitInit(asyncId, 'event1', triggerId, {});
    emitBefore(asyncId, triggerId);
    emitAfter(asyncId);
    emitDestroy(asyncId);
  }

  // Emitting 'before' after 'destroy'
  {
    const asyncId = newAsyncId();
    const triggerId = getDefaultTriggerAsyncId();
    emitInit(asyncId, 'event2', triggerId, {});
    emitDestroy(asyncId);

    console.log('heartbeat: still alive');
    emitBefore(asyncId, triggerId);
  }
} else {
  const args = ['--expose-internals']
    .concat(process.argv.slice(1))
    .concat('child');
  let errData = Buffer.from('');
  let outData = Buffer.from('');

  const child = spawn(process.execPath, args);
  child.stderr.on('data', (d) => { errData = Buffer.concat([ errData, d ]); });
  child.stdout.on('data', (d) => { outData = Buffer.concat([ outData, d ]); });

  child.on('close', common.mustCall((code) => {
    assert.strictEqual(code, 1);
    assert.match(outData.toString(), heartbeatMsg,
                 'did not crash until we reached offending line of code ' +
                 `(found ${outData})`);
    assert.match(errData.toString(), corruptedMsg,
                 'printed error contains corrupted message ' +
                 `(found ${errData})`);
  }));
}
                                            node-23.7.0/test/async-hooks/test-emit-init.js                                                      0000664 0000000 0000000 00000002336 14746647661 0021210 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// Flags: --expose-internals

const common = require('../common');
const assert = require('assert');
const async_hooks = require('internal/async_hooks');
const initHooks = require('./init-hooks');

const expectedId = async_hooks.newAsyncId();
const expectedTriggerId = async_hooks.newAsyncId();
const expectedType = 'test_emit_init_type';
const expectedResource = { key: 'test_emit_init_resource' };

const hooks1 = initHooks({
  oninit: common.mustCall((id, type, triggerAsyncId, resource) => {
    assert.strictEqual(id, expectedId);
    assert.strictEqual(type, expectedType);
    assert.strictEqual(triggerAsyncId, expectedTriggerId);
    assert.strictEqual(resource.key, expectedResource.key);
  }),
});

hooks1.enable();

async_hooks.emitInit(expectedId, expectedType, expectedTriggerId,
                     expectedResource);

hooks1.disable();

initHooks({
  oninit: common.mustCall((id, type, triggerAsyncId, resource) => {
    assert.strictEqual(id, expectedId);
    assert.strictEqual(type, expectedType);
    assert.notStrictEqual(triggerAsyncId, expectedTriggerId);
    assert.strictEqual(resource.key, expectedResource.key);
  }),
}).enable();

async_hooks.emitInit(expectedId, expectedType, null, expectedResource);
                                                                                                                                                                                                                                                                                                  node-23.7.0/test/async-hooks/test-enable-disable.js                                                 0000664 0000000 0000000 00000020737 14746647661 0022145 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        //  Test Steps Explained
//  ====================
//
//  Initializing hooks:
//
//  We initialize 3 hooks. For hook2 and hook3 we register a callback for the
//  "before" and in case of hook3 also for the "after" invocations.
//
//  Enabling hooks initially:
//
//  We only enable hook1 and hook3 initially.
//
//  Enabling hook2:
//
//  When hook3's "before" invocation occurs we enable hook2.  Since this
//  happens right before calling `onfirstImmediate` hook2 will miss all hook
//  invocations until then, including the "init" and "before" of the first
//  Immediate.
//  However afterwards it collects all invocations that follow on the first
//  Immediate as well as all invocations on the second Immediate.
//
//  This shows that a hook can enable another hook inside a life time event
//  callback.
//
//
//  Disabling hook1
//
//  Since we registered the "before" callback for hook2 it will execute it
//  right before `onsecondImmediate` is called.
//  At that point we disable hook1 which is why it will miss all invocations
//  afterwards and thus won't include the second "after" as well as the
//  "destroy" invocations
//
//  This shows that a hook can disable another hook inside a life time event
//  callback.
//
//  Disabling hook3
//
//  When the second "after" invocation occurs (after onsecondImmediate), hook3
//  disables itself.
//  As a result it will not receive the "destroy" invocation.
//
//  This shows that a hook can disable itself inside a life time event callback.
//
//  Sample Test Log
//  ===============
//
//  - setting up first Immediate
//  hook1.init.uid-5
//  hook3.init.uid-5
//  - finished setting first Immediate
//
//  hook1.before.uid-5
//  hook3.before.uid-5
//  - enabled hook2
//  - entering onfirstImmediate
//
//  - setting up second Immediate
//  hook1.init.uid-6
//  hook3.init.uid-6
//  hook2.init.uid-6
//  - finished setting second Immediate
//
//  - exiting onfirstImmediate
//  hook1.after.uid-5
//  hook3.after.uid-5
//  hook2.after.uid-5
//  hook1.destroy.uid-5
//  hook3.destroy.uid-5
//  hook2.destroy.uid-5
//  hook1.before.uid-6
//  hook3.before.uid-6
//  hook2.before.uid-6
//  - disabled hook1
//  - entering onsecondImmediate
//  - exiting onsecondImmediate
//  hook3.after.uid-6
//  - disabled hook3
//  hook2.after.uid-6
//  hook2.destroy.uid-6


'use strict';

const common = require('../common');
const assert = require('assert');
const tick = require('../common/tick');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');
const { isMainThread } = require('worker_threads');

if (!isMainThread)
  common.skip('Worker bootstrapping works differently -> different timing');

// Include "Unknown"s because hook2 will not be able to identify
// the type of the first Immediate  since it will miss its `init` invocation.
const types = [ 'Immediate', 'Unknown' ];

//
// Initializing hooks
//
const hook1 = initHooks();
const hook2 = initHooks({ onbefore: onhook2Before, allowNoInit: true });
const hook3 = initHooks({ onbefore: onhook3Before, onafter: onhook3After });

//
// Enabling hook1 and hook3 only, hook2 is still disabled
//
hook1.enable();
// Verify that the hook is enabled even if .enable() is called twice.
hook1.enable();
hook3.enable();

//
// Enabling hook2
//
let enabledHook2 = false;
function onhook3Before() {
  if (enabledHook2) return;
  hook2.enable();
  enabledHook2 = true;
}

//
// Disabling hook1
//
let disabledHook3 = false;
function onhook2Before() {
  if (disabledHook3) return;
  hook1.disable();
  // Verify that the hook is disabled even if .disable() is called twice.
  hook1.disable();
  disabledHook3 = true;
}

//
// Disabling hook3 during the second "after" invocations it sees
//
let count = 2;
function onhook3After() {
  if (!--count) {
    hook3.disable();
  }
}

setImmediate(common.mustCall(onfirstImmediate));

//
// onfirstImmediate is called after all "init" and "before" callbacks of the
// active hooks were invoked
//
function onfirstImmediate() {
  const as1 = hook1.activitiesOfTypes(types);
  const as2 = hook2.activitiesOfTypes(types);
  const as3 = hook3.activitiesOfTypes(types);
  assert.strictEqual(as1.length, 1);
  // hook2 was not enabled yet .. it is enabled after hook3's "before" completed
  assert.strictEqual(as2.length, 0);
  assert.strictEqual(as3.length, 1);

  // Check that hook1 and hook3 captured the same Immediate and that it is valid
  const firstImmediate = as1[0];
  assert.strictEqual(as3[0].uid, as1[0].uid);
  assert.strictEqual(firstImmediate.type, 'Immediate');
  assert.strictEqual(typeof firstImmediate.uid, 'number');
  assert.strictEqual(typeof firstImmediate.triggerAsyncId, 'number');
  checkInvocations(as1[0], { init: 1, before: 1 },
                   'hook1[0]: on first immediate');
  checkInvocations(as3[0], { init: 1, before: 1 },
                   'hook3[0]: on first immediate');

  // Setup the second Immediate, note that now hook2 is enabled and thus
  // will capture all lifetime events of this Immediate
  setImmediate(common.mustCall(onsecondImmediate));
}

//
// Once we exit onfirstImmediate the "after" callbacks of the active hooks are
// invoked
//

let hook1First, hook2First, hook3First;
let hook1Second, hook2Second, hook3Second;

//
// onsecondImmediate is called after all "before" callbacks of the active hooks
// are invoked again
//
function onsecondImmediate() {
  const as1 = hook1.activitiesOfTypes(types);
  const as2 = hook2.activitiesOfTypes(types);
  const as3 = hook3.activitiesOfTypes(types);
  assert.strictEqual(as1.length, 2);
  assert.strictEqual(as2.length, 2);
  assert.strictEqual(as3.length, 2);

  // Assign the info collected by each hook for each immediate for easier
  // reference.
  // hook2 saw the "init" of the second immediate before the
  // "after" of the first which is why they are ordered the opposite way
  hook1First = as1[0];
  hook1Second = as1[1];
  hook2First = as2[1];
  hook2Second = as2[0];
  hook3First = as3[0];
  hook3Second = as3[1];

  // Check that all hooks captured the same Immediate and that it is valid
  const secondImmediate = hook1Second;
  assert.strictEqual(hook2Second.uid, hook3Second.uid);
  assert.strictEqual(hook1Second.uid, hook3Second.uid);
  assert.strictEqual(secondImmediate.type, 'Immediate');
  assert.strictEqual(typeof secondImmediate.uid, 'number');
  assert.strictEqual(typeof secondImmediate.triggerAsyncId, 'number');

  checkInvocations(hook1First, { init: 1, before: 1, after: 1, destroy: 1 },
                   'hook1First: on second immediate');
  checkInvocations(hook1Second, { init: 1, before: 1 },
                   'hook1Second: on second immediate');
  // hook2 missed the "init" and "before" since it was enabled after they
  // occurred
  checkInvocations(hook2First, { after: 1, destroy: 1 },
                   'hook2First: on second immediate');
  checkInvocations(hook2Second, { init: 1, before: 1 },
                   'hook2Second: on second immediate');
  checkInvocations(hook3First, { init: 1, before: 1, after: 1, destroy: 1 },
                   'hook3First: on second immediate');
  checkInvocations(hook3Second, { init: 1, before: 1 },
                   'hook3Second: on second immediate');
  tick(1);
}

//
// Once we exit onsecondImmediate the "after" callbacks of the active hooks are
// invoked again.
// During this second "after" invocation hook3 disables itself
// (see onhook3After).
//

process.on('exit', onexit);

function onexit() {
  hook1.disable();
  hook2.disable();
  hook3.disable();
  hook1.sanityCheck();
  hook2.sanityCheck();
  hook3.sanityCheck();

  checkInvocations(hook1First, { init: 1, before: 1, after: 1, destroy: 1 },
                   'hook1First: when process exits');
  // hook1 was disabled during hook2's "before" of the second immediate
  // and thus did not see "after" and "destroy"
  checkInvocations(hook1Second, { init: 1, before: 1 },
                   'hook1Second: when process exits');
  // hook2 missed the "init" and "before" since it was enabled after they
  // occurred
  checkInvocations(hook2First, { after: 1, destroy: 1 },
                   'hook2First: when process exits');
  checkInvocations(hook2Second, { init: 1, before: 1, after: 1, destroy: 1 },
                   'hook2Second: when process exits');
  checkInvocations(hook3First, { init: 1, before: 1, after: 1, destroy: 1 },
                   'hook3First: when process exits');
  // We don't see a "destroy" invocation here since hook3 disabled itself
  // during its "after" invocation
  checkInvocations(hook3Second, { init: 1, before: 1, after: 1 },
                   'hook3Second: when process exits');
}
                                 node-23.7.0/test/async-hooks/test-enable-in-init.js                                                 0000664 0000000 0000000 00000000733 14746647661 0022103 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const async_hooks = require('async_hooks');
const fs = require('fs');

const nestedHook = async_hooks.createHook({
  init: common.mustNotCall(),
});
let nestedCall = false;

async_hooks.createHook({
  init: common.mustCall(() => {
    nestedHook.enable();
    if (!nestedCall) {
      nestedCall = true;
      fs.access(__filename, common.mustCall());
    }
  }, 2),
}).enable();

fs.access(__filename, common.mustCall());
                                     node-23.7.0/test/async-hooks/test-filehandle-no-reuse.js                                            0000664 0000000 0000000 00000003532 14746647661 0023136 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');
const fixtures = require('../common/fixtures');
if (!common.hasCrypto)
  common.skip('missing crypto');
const http2 = require('http2');
const assert = require('assert');
const fs = require('fs');

// Checks that the async resource is not reused by FileHandle.
// Test is based on parallel\test-http2-respond-file-fd.js.

const hooks = initHooks();
hooks.enable();

const {
  HTTP2_HEADER_CONTENT_TYPE,
} = http2.constants;

// Use large fixture to get several file operations.
const fname = fixtures.path('person-large.jpg');
const fd = fs.openSync(fname, 'r');

const server = http2.createServer();
server.on('stream', (stream) => {
  stream.respondWithFD(fd, {
    [HTTP2_HEADER_CONTENT_TYPE]: 'text/plain',
  });
});
server.on('close', common.mustCall(() => fs.closeSync(fd)));
server.listen(0, () => {
  const client = http2.connect(`http://localhost:${server.address().port}`);
  const req = client.request();

  req.on('response', common.mustCall());
  req.on('data', () => {});
  req.on('end', common.mustCall(() => {
    client.close();
    server.close();
  }));
  req.end();
});

process.on('exit', onExit);

function onExit() {
  hooks.disable();
  hooks.sanityCheck();
  const activities = hooks.activities;

  // Verify both invocations
  const fsReqs = activities.filter((x) => x.type === 'FSREQCALLBACK');
  assert.ok(fsReqs.length >= 2);

  checkInvocations(fsReqs[0], { init: 1, destroy: 1 }, 'when process exits');
  checkInvocations(fsReqs[1], { init: 1, destroy: 1 }, 'when process exits');

  // Verify reuse handle has been wrapped
  assert.ok(fsReqs[0].handle !== fsReqs[1].handle, 'Resource reused');
  assert.ok(fsReqs[0].handle === fsReqs[1].handle.handle,
            'Resource not wrapped correctly');
}
                                                                                                                                                                      node-23.7.0/test/async-hooks/test-fseventwrap.js                                                    0000664 0000000 0000000 00000002046 14746647661 0021653 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');

const assert = require('assert');
const initHooks = require('./init-hooks');
const tick = require('../common/tick');
const { checkInvocations } = require('./hook-checks');
const fs = require('fs');
const { isMainThread } = require('worker_threads');

if (!isMainThread) {
  common.skip('Worker bootstrapping works differently -> different async IDs');
}

if (common.isIBMi) {
  common.skip('IBMi does not support fs.watch()');
}

const hooks = initHooks();

hooks.enable();
const watcher = fs.watch(__filename, onwatcherChanged);
function onwatcherChanged() { }

watcher.close();
tick(2);

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  hooks.sanityCheck('FSEVENTWRAP');

  const as = hooks.activitiesOfTypes('FSEVENTWRAP');
  assert.strictEqual(as.length, 1);

  const a = as[0];
  assert.strictEqual(a.type, 'FSEVENTWRAP');
  assert.strictEqual(typeof a.uid, 'number');
  assert.strictEqual(a.triggerAsyncId, 1);
  checkInvocations(a, { init: 1, destroy: 1 }, 'when process exits');
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/test/async-hooks/test-fsreqcallback-access.js                                           0000664 0000000 0000000 00000001717 14746647661 0023347 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const tick = require('../common/tick');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');
const fs = require('fs');

const hooks = initHooks();

hooks.enable();
fs.access(__filename, common.mustCall(onaccess));

function onaccess() {
  const as = hooks.activitiesOfTypes('FSREQCALLBACK');
  const a = as[0];
  checkInvocations(a, { init: 1, before: 1 },
                   'while in onaccess callback');
  tick(2);
}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  hooks.sanityCheck('FSREQCALLBACK');

  const as = hooks.activitiesOfTypes('FSREQCALLBACK');
  assert.strictEqual(as.length, 1);

  const a = as[0];
  assert.strictEqual(a.type, 'FSREQCALLBACK');
  assert.strictEqual(typeof a.uid, 'number');
  checkInvocations(a, { init: 1, before: 1, after: 1, destroy: 1 },
                   'when process exits');
}
                                                 node-23.7.0/test/async-hooks/test-fsreqcallback-readFile.js                                         0000664 0000000 0000000 00000003416 14746647661 0023617 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const tick = require('../common/tick');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');
const fs = require('fs');
const { isMainThread } = require('worker_threads');

if (!isMainThread) {
  common.skip('Worker bootstrapping works differently -> different async IDs');
}

const hooks = initHooks();

hooks.enable();
fs.readFile(__filename, common.mustCall(onread));

function onread() {
  const as = hooks.activitiesOfTypes('FSREQCALLBACK');
  let lastParent = 1;
  for (let i = 0; i < as.length; i++) {
    const a = as[i];
    assert.strictEqual(a.type, 'FSREQCALLBACK');
    assert.strictEqual(typeof a.uid, 'number');
    assert.strictEqual(a.triggerAsyncId, lastParent);
    lastParent = a.uid;
  }
  checkInvocations(as[0], { init: 1, before: 1, after: 1, destroy: 1 },
                   'reqwrap[0]: while in onread callback');
  checkInvocations(as[1], { init: 1, before: 1, after: 1, destroy: 1 },
                   'reqwrap[1]: while in onread callback');
  checkInvocations(as[2], { init: 1, before: 1, after: 1, destroy: 1 },
                   'reqwrap[2]: while in onread callback');

  // This callback is called from within the last fs req callback therefore
  // the last req is still going and after/destroy haven't been called yet
  checkInvocations(as[3], { init: 1, before: 1 },
                   'reqwrap[3]: while in onread callback');
  tick(2);
}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  hooks.sanityCheck('FSREQCALLBACK');
  const as = hooks.activitiesOfTypes('FSREQCALLBACK');
  const a = as.pop();
  checkInvocations(a, { init: 1, before: 1, after: 1, destroy: 1 },
                   'when process exits');
}
                                                                                                                                                                                                                                                  node-23.7.0/test/async-hooks/test-getaddrinforeqwrap.js                                             0000664 0000000 0000000 00000002453 14746647661 0023201 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const tick = require('../common/tick');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');
const dns = require('dns');
const { isMainThread } = require('worker_threads');

if (!isMainThread) {
  common.skip('Worker bootstrapping works differently -> different async IDs');
}

const hooks = initHooks();

hooks.enable();
dns.lookup('www.google.com', 4, common.mustCall(onlookup));
function onlookup() {
  // We don't care about the error here in order to allow
  // tests to run offline (lookup will fail in that case and the err be set);

  const as = hooks.activitiesOfTypes('GETADDRINFOREQWRAP');
  assert.strictEqual(as.length, 1);

  const a = as[0];
  assert.strictEqual(a.type, 'GETADDRINFOREQWRAP');
  assert.strictEqual(typeof a.uid, 'number');
  assert.strictEqual(a.triggerAsyncId, 1);
  checkInvocations(a, { init: 1, before: 1 }, 'while in onlookup callback');
  tick(2);
}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  hooks.sanityCheck('GETADDRINFOREQWRAP');

  const as = hooks.activitiesOfTypes('GETADDRINFOREQWRAP');
  const a = as[0];
  checkInvocations(a, { init: 1, before: 1, after: 1, destroy: 1 },
                   'when process exits');
}
                                                                                                                                                                                                                     node-23.7.0/test/async-hooks/test-getnameinforeqwrap.js                                             0000664 0000000 0000000 00000002525 14746647661 0023207 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const tick = require('../common/tick');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');
const dns = require('dns');
const { isMainThread } = require('worker_threads');

if (!isMainThread) {
  common.skip('Worker bootstrapping works differently -> different async IDs');
}

const hooks = initHooks();

hooks.enable();
dns.lookupService('127.0.0.1', 80, common.mustCall(onlookupService));
function onlookupService() {
  // We don't care about the error here in order to allow
  // tests to run offline (lookup will fail in that case and the err be set)

  const as = hooks.activitiesOfTypes('GETNAMEINFOREQWRAP');
  assert.strictEqual(as.length, 1);

  const a = as[0];
  assert.strictEqual(a.type, 'GETNAMEINFOREQWRAP');
  assert.strictEqual(typeof a.uid, 'number');
  assert.strictEqual(a.triggerAsyncId, 1);
  checkInvocations(a, { init: 1, before: 1 },
                   'while in onlookupService callback');
  tick(2);
}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  hooks.sanityCheck('GETNAMEINFOREQWRAP');

  const as = hooks.activitiesOfTypes('GETNAMEINFOREQWRAP');
  const a = as[0];
  checkInvocations(a, { init: 1, before: 1, after: 1, destroy: 1 },
                   'when process exits');
}
                                                                                                                                                                           node-23.7.0/test/async-hooks/test-graph.fsreq-readFile.js                                           0000664 0000000 0000000 00000001254 14746647661 0023240 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const initHooks = require('./init-hooks');
const verifyGraph = require('./verify-graph');
const fs = require('fs');

const hooks = initHooks();

hooks.enable();
fs.readFile(__filename, common.mustCall(onread));

function onread() {}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  verifyGraph(
    hooks,
    [ { type: 'FSREQCALLBACK', id: 'fsreq:1', triggerAsyncId: null },
      { type: 'FSREQCALLBACK', id: 'fsreq:2', triggerAsyncId: 'fsreq:1' },
      { type: 'FSREQCALLBACK', id: 'fsreq:3', triggerAsyncId: 'fsreq:2' },
      { type: 'FSREQCALLBACK', id: 'fsreq:4', triggerAsyncId: 'fsreq:3' } ],
  );
}
                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/async-hooks/test-graph.http.js                                                     0000664 0000000 0000000 00000002570 14746647661 0021370 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
if (!common.hasIPv6)
  common.skip('IPv6 support required');

const initHooks = require('./init-hooks');
const verifyGraph = require('./verify-graph');
const http = require('http');

const hooks = initHooks();
hooks.enable();

const server = http.createServer(common.mustCall((req, res) => {
  res.writeHead(200, { 'Connection': 'close' });
  res.end();
  server.close(common.mustCall());
}));
server.listen(0, common.mustCall(() => {
  http.get({
    host: '::1',
    family: 6,
    port: server.address().port,
  }, common.mustCall());
}));

process.on('exit', () => {
  hooks.disable();

  verifyGraph(
    hooks,
    [ { type: 'TCPSERVERWRAP',
        id: 'tcpserver:1',
        triggerAsyncId: null },
      { type: 'TCPWRAP', id: 'tcp:1', triggerAsyncId: 'tcpserver:1' },
      { type: 'TCPCONNECTWRAP',
        id: 'tcpconnect:1',
        triggerAsyncId: 'tcp:1' },
      { type: 'HTTPCLIENTREQUEST',
        id: 'httpclientrequest:1',
        triggerAsyncId: 'tcpserver:1' },
      { type: 'TCPWRAP', id: 'tcp:2', triggerAsyncId: 'tcpserver:1' },
      { type: 'HTTPINCOMINGMESSAGE',
        id: 'httpincomingmessage:1',
        triggerAsyncId: 'tcp:2' },
      { type: 'Timeout',
        id: 'timeout:1',
        triggerAsyncId: null },
      { type: 'SHUTDOWNWRAP',
        id: 'shutdown:1',
        triggerAsyncId: 'tcp:2' } ],
  );
});
                                                                                                                                        node-23.7.0/test/async-hooks/test-graph.intervals.js                                                0000664 0000000 0000000 00000001363 14746647661 0022417 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const initHooks = require('./init-hooks');
const verifyGraph = require('./verify-graph');
const TIMEOUT = 1;

const hooks = initHooks();
hooks.enable();

let count = 0;
const iv1 = setInterval(common.mustCall(onfirstInterval, 3), TIMEOUT);
let iv2;

function onfirstInterval() {
  if (++count === 3) {
    clearInterval(iv1);
    iv2 = setInterval(common.mustCall(onsecondInterval, 1), TIMEOUT + 1);
  }
}

function onsecondInterval() {
  clearInterval(iv2);
}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  verifyGraph(
    hooks,
    [ { type: 'Timeout', id: 'timeout:1', triggerAsyncId: null },
      { type: 'Timeout', id: 'timeout:2', triggerAsyncId: 'timeout:1' }],
  );
}
                                                                                                                                                                                                                                                                             node-23.7.0/test/async-hooks/test-graph.pipe.js                                                     0000664 0000000 0000000 00000001431 14746647661 0021341 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const initHooks = require('./init-hooks');
const verifyGraph = require('./verify-graph');
const spawn = require('child_process').spawn;

const hooks = initHooks();

hooks.enable();
const sleep = spawn('sleep', [ '0.1' ]);

sleep
  .on('exit', common.mustCall(onsleepExit))
  .on('close', common.mustCall(onsleepClose));

function onsleepExit() {}

function onsleepClose() {}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  verifyGraph(
    hooks,
    [ { type: 'PROCESSWRAP', id: 'process:1', triggerAsyncId: null },
      { type: 'PIPEWRAP', id: 'pipe:1', triggerAsyncId: null },
      { type: 'PIPEWRAP', id: 'pipe:2', triggerAsyncId: null },
      { type: 'PIPEWRAP', id: 'pipe:3', triggerAsyncId: null } ],
  );
}
                                                                                                                                                                                                                                       node-23.7.0/test/async-hooks/test-graph.pipeconnect.js                                              0000664 0000000 0000000 00000001750 14746647661 0022717 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const initHooks = require('./init-hooks');
const verifyGraph = require('./verify-graph');

const net = require('net');

const tmpdir = require('../common/tmpdir');
tmpdir.refresh();

const hooks = initHooks();
hooks.enable();

const server = net.createServer((c) => {
  c.end();
  server.close();
}).listen(common.PIPE, common.mustCall(onlisten));

function onlisten() {
  net.connect(common.PIPE, common.mustCall(onconnect));
}

function onconnect() {}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  verifyGraph(
    hooks,
    [ { type: 'PIPESERVERWRAP', id: 'pipeserver:1', triggerAsyncId: null },
      { type: 'PIPEWRAP', id: 'pipe:1', triggerAsyncId: 'pipeserver:1' },
      { type: 'PIPECONNECTWRAP', id: 'pipeconnect:1',
        triggerAsyncId: 'pipe:1' },
      { type: 'PIPEWRAP', id: 'pipe:2', triggerAsyncId: 'pipeserver:1' },
      { type: 'SHUTDOWNWRAP', id: 'shutdown:1', triggerAsyncId: 'pipe:2' } ],
  );
}
                        node-23.7.0/test/async-hooks/test-graph.shutdown.js                                                 0000664 0000000 0000000 00000002251 14746647661 0022260 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
if (!common.hasIPv6)
  common.skip('IPv6 support required');

const initHooks = require('./init-hooks');
const verifyGraph = require('./verify-graph');
const net = require('net');

const hooks = initHooks();
hooks.enable();

const server = net
  .createServer(onconnection)
  .on('listening', common.mustCall(onlistening));
server.listen();
function onlistening() {
  net.connect(server.address().port, common.mustCall(onconnected));
}

function onconnection(c) {
  c.end();
  this.close(onserverClosed);
}

function onconnected() {}

function onserverClosed() {}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  verifyGraph(
    hooks,
    [ { type: 'TCPSERVERWRAP', id: 'tcpserver:1', triggerAsyncId: null },
      { type: 'TCPWRAP', id: 'tcp:1', triggerAsyncId: 'tcpserver:1' },
      { type: 'GETADDRINFOREQWRAP',
        id: 'getaddrinforeq:1', triggerAsyncId: 'tcp:1' },
      { type: 'TCPCONNECTWRAP',
        id: 'tcpconnect:1', triggerAsyncId: 'tcp:1' },
      { type: 'TCPWRAP', id: 'tcp:2', triggerAsyncId: 'tcpserver:1' },
      { type: 'SHUTDOWNWRAP', id: 'shutdown:1', triggerAsyncId: 'tcp:2' } ],
  );
}
                                                                                                                                                                                                                                                                                                                                                       node-23.7.0/test/async-hooks/test-graph.signal.js                                                   0000664 0000000 0000000 00000004431 14746647661 0021664 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
if (common.isWindows) {
  common.skip('no signals on Windows');
}
const { isMainThread } = require('worker_threads');
if (!isMainThread) {
  common.skip('No signal handling available in Workers');
}

const initHooks = require('./init-hooks');
const verifyGraph = require('./verify-graph');
const { exec } = require('child_process');

const hooks = initHooks();

hooks.enable();
const interval = setInterval(() => {}, 9999); // Keep event loop open
process.on('SIGUSR2', common.mustCall(onsigusr2, 2));

let count = 0;
exec(`kill -USR2 ${process.pid}`);

function onsigusr2() {
  count++;

  if (count === 1) {
    // Trigger same signal handler again
    exec(`kill -USR2 ${process.pid}`);
  } else {
    // Install another signal handler
    process.removeAllListeners('SIGUSR2');
    process.on('SIGUSR2', common.mustCall(onsigusr2Again));

    exec(`kill -USR2 ${process.pid}`);
  }
}

function onsigusr2Again() {
  clearInterval(interval); // Let the event loop close
}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  verifyGraph(
    hooks,
    [ { type: 'SIGNALWRAP', id: 'signal:1', triggerAsyncId: null },
      { type: 'PROCESSWRAP', id: 'process:1', triggerAsyncId: null },
      { type: 'PIPEWRAP', id: 'pipe:1', triggerAsyncId: null },
      { type: 'PIPEWRAP', id: 'pipe:2', triggerAsyncId: null },
      { type: 'PIPEWRAP', id: 'pipe:3', triggerAsyncId: null },
      { type: 'PROCESSWRAP', id: 'process:2', triggerAsyncId: 'signal:1' },
      { type: 'PIPEWRAP', id: 'pipe:4', triggerAsyncId: 'signal:1' },
      { type: 'PIPEWRAP', id: 'pipe:5', triggerAsyncId: 'signal:1' },
      { type: 'PIPEWRAP', id: 'pipe:6', triggerAsyncId: 'signal:1' },
      { type: 'SIGNALWRAP', id: 'signal:2',
        // TEST_THREAD_ID is set by tools/test.py. Adjust test results depending
        // on whether the test was invoked via test.py or from the shell
        // directly.
        triggerAsyncId: process.env.TEST_THREAD_ID ? 'signal:1' : 'pipe:2' },
      { type: 'PROCESSWRAP', id: 'process:3', triggerAsyncId: 'signal:1' },
      { type: 'PIPEWRAP', id: 'pipe:7', triggerAsyncId: 'signal:1' },
      { type: 'PIPEWRAP', id: 'pipe:8', triggerAsyncId: 'signal:1' },
      { type: 'PIPEWRAP', id: 'pipe:9', triggerAsyncId: 'signal:1' } ],
  );
}
                                                                                                                                                                                                                                       node-23.7.0/test/async-hooks/test-graph.statwatcher.js                                              0000664 0000000 0000000 00000001406 14746647661 0022737 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const commonPath = require.resolve('../common');
const initHooks = require('./init-hooks');
const verifyGraph = require('./verify-graph');
const fs = require('fs');

const hooks = initHooks();
hooks.enable();

function onchange() { }
// Install first file watcher
fs.watchFile(__filename, onchange);

// Install second file watcher
fs.watchFile(commonPath, onchange);

// Remove first file watcher
fs.unwatchFile(__filename);

// Remove second file watcher
fs.unwatchFile(commonPath);

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  verifyGraph(
    hooks,
    [ { type: 'STATWATCHER', id: 'statwatcher:1', triggerAsyncId: null },
      { type: 'STATWATCHER', id: 'statwatcher:2', triggerAsyncId: null } ],
  );
}
                                                                                                                                                                                                                                                          node-23.7.0/test/async-hooks/test-graph.tcp.js                                                      0000664 0000000 0000000 00000002210 14746647661 0021166 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
if (!common.hasIPv6)
  common.skip('IPv6 support required');

const initHooks = require('./init-hooks');
const verifyGraph = require('./verify-graph');
const net = require('net');

const hooks = initHooks();
hooks.enable();

const server = net
  .createServer(common.mustCall(onconnection))
  .on('listening', common.mustCall(onlistening));

server.listen(0);

net.connect({ port: server.address().port, host: '::1' },
            common.mustCall(onconnected));

function onlistening() {}

function onconnected() {}

function onconnection(c) {
  c.end();
  this.close(common.mustCall(onserverClosed));
}

function onserverClosed() {}

process.on('exit', onexit);

function onexit() {
  hooks.disable();

  verifyGraph(
    hooks,
    [ { type: 'TCPSERVERWRAP', id: 'tcpserver:1', triggerAsyncId: null },
      { type: 'TCPWRAP', id: 'tcp:1', triggerAsyncId: null },
      { type: 'TCPCONNECTWRAP',
        id: 'tcpconnect:1', triggerAsyncId: 'tcp:1' },
      { type: 'TCPWRAP', id: 'tcp:2', triggerAsyncId: 'tcpserver:1' },
      { type: 'SHUTDOWNWRAP', id: 'shutdown:1', triggerAsyncId: 'tcp:2' } ],
  );
}
                                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/async-hooks/test-graph.timeouts.js                                                 0000664 0000000 0000000 00000001350 14746647661 0022255 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const initHooks = require('./init-hooks');
const verifyGraph = require('./verify-graph');
const TIMEOUT = 1;

const hooks = initHooks();
hooks.enable();

setTimeout(common.mustCall(ontimeout), TIMEOUT);
function ontimeout() {
  setTimeout(onsecondTimeout, TIMEOUT + 1);
}

function onsecondTimeout() {
  setTimeout(onthirdTimeout, TIMEOUT + 2);
}

function onthirdTimeout() {}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  verifyGraph(
    hooks,
    [ { type: 'Timeout', id: 'timeout:1', triggerAsyncId: null },
      { type: 'Timeout', id: 'timeout:2', triggerAsyncId: 'timeout:1' },
      { type: 'Timeout', id: 'timeout:3', triggerAsyncId: 'timeout:2' }],
  );
}
                                                                                                                                                                                                                                                                                        node-23.7.0/test/async-hooks/test-graph.tls-write-12.js                                             0000664 0000000 0000000 00000000326 14746647661 0022560 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const tls = require('tls');

tls.DEFAULT_MAX_VERSION = 'TLSv1.2';

require('./test-graph.tls-write.js');
                                                                                                                                                                                                                                                                                                          node-23.7.0/test/async-hooks/test-graph.tls-write.js                                                0000664 0000000 0000000 00000003607 14746647661 0022345 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

if (!common.hasIPv6)
  common.skip('IPv6 support required');

const initHooks = require('./init-hooks');
const verifyGraph = require('./verify-graph');
const tls = require('tls');
const fixtures = require('../common/fixtures');

const hooks = initHooks();
hooks.enable();

//
// Creating server and listening on port
//
const server = tls
  .createServer({
    cert: fixtures.readKey('rsa_cert.crt'),
    key: fixtures.readKey('rsa_private.pem'),
  })
  .on('listening', common.mustCall(onlistening))
  .on('secureConnection', common.mustCall(onsecureConnection))
  .listen(0);

function onlistening() {
  //
  // Creating client and connecting it to server
  //
  tls
    .connect(server.address().port, { rejectUnauthorized: false })
    .on('secureConnect', common.mustCall(onsecureConnect));
}

function onsecureConnection() {}

function onsecureConnect() {
  // end() client socket, which causes slightly different hook events than
  // destroy(), but with TLS1.3 destroy() rips the connection down before the
  // server completes the handshake.
  this.end();

  // Closing server
  server.close(common.mustCall(onserverClosed));
}

function onserverClosed() {}

process.on('exit', onexit);

function onexit() {
  hooks.disable();

  verifyGraph(
    hooks,
    [ { type: 'TCPSERVERWRAP', id: 'tcpserver:1', triggerAsyncId: null },
      { type: 'TCPWRAP', id: 'tcp:1', triggerAsyncId: 'tcpserver:1' },
      { type: 'TLSWRAP', id: 'tls:1', triggerAsyncId: 'tcpserver:1' },
      { type: 'GETADDRINFOREQWRAP',
        id: 'getaddrinforeq:1', triggerAsyncId: 'tls:1' },
      { type: 'TCPCONNECTWRAP',
        id: 'tcpconnect:1', triggerAsyncId: 'tcp:1' },
      { type: 'TCPWRAP', id: 'tcp:2', triggerAsyncId: 'tcpserver:1' },
      { type: 'TLSWRAP', id: 'tls:2', triggerAsyncId: 'tcpserver:1' },
    ],
  );
}
                                                                                                                         node-23.7.0/test/async-hooks/test-http-agent-handle-reuse-parallel.js                               0000664 0000000 0000000 00000005165 14746647661 0025533 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// Flags: --expose-internals
const common = require('../common');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');
const assert = require('assert');
const { async_id_symbol } = require('internal/async_hooks').symbols;
const http = require('http');

// Checks that the async resource used in init in case of a reused handle
// is not reused. Test is based on parallel\test-async-hooks-http-agent.js.

const hooks = initHooks();
hooks.enable();

const reqAsyncIds = [];
let socket;
let responses = 0;

// Make sure a single socket is transparently reused for 2 requests.
const agent = new http.Agent({
  keepAlive: true,
  keepAliveMsecs: Infinity,
  maxSockets: 1,
});

const verifyRequest = (idx) => (res) => {
  reqAsyncIds[idx] = res.socket[async_id_symbol];
  assert.ok(reqAsyncIds[idx] > 0, `${reqAsyncIds[idx]} > 0`);
  if (socket) {
    // Check that both requests share their socket.
    assert.strictEqual(res.socket, socket);
  } else {
    socket = res.socket;
  }

  res.on('data', common.mustCallAtLeast());
  res.on('end', common.mustCall(() => {
    if (++responses === 2) {
      // Clean up to let the event loop stop.
      server.close();
      agent.destroy();
    }
  }));
};

const server = http.createServer(common.mustCall((req, res) => {
  req.once('data', common.mustCallAtLeast(() => {
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.write('foo');
  }));
  req.on('end', common.mustCall(() => {
    res.end('bar');
  }));
}, 2)).listen(0, common.mustCall(() => {
  const port = server.address().port;
  const payload = 'hello world';

  // First request.
  const r1 = http.request({
    agent, port, method: 'POST',
  }, common.mustCall(verifyRequest(0)));
  r1.end(payload);

  // Second request. Sent in parallel with the first one.
  const r2 = http.request({
    agent, port, method: 'POST',
  }, common.mustCall(verifyRequest(1)));
  r2.end(payload);
}));


process.on('exit', onExit);

function onExit() {
  hooks.disable();
  hooks.sanityCheck();
  const activities = hooks.activities;

  // Verify both invocations
  const first = activities.filter((x) => x.uid === reqAsyncIds[0])[0];
  checkInvocations(first, { init: 1, destroy: 1 }, 'when process exits');

  const second = activities.filter((x) => x.uid === reqAsyncIds[1])[0];
  checkInvocations(second, { init: 1, destroy: 1 }, 'when process exits');

  // Verify reuse handle has been wrapped
  assert.strictEqual(first.type, second.type);
  assert.ok(first.handle !== second.handle, 'Resource reused');
  assert.ok(first.handle === second.handle.handle,
            'Resource not wrapped correctly');
}
                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/test/async-hooks/test-http-agent-handle-reuse-serial.js                                 0000664 0000000 0000000 00000007254 14746647661 0025217 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// Flags: --expose-internals
const common = require('../common');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');
const assert = require('assert');
const { async_id_symbol } = require('internal/async_hooks').symbols;
const http = require('http');

// Checks that the async resource used in init in case of a reused handle
// is not reused. Test is based on parallel\test-async-hooks-http-agent.js.

const hooks = initHooks();
hooks.enable();

let asyncIdAtFirstReq;
let asyncIdAtSecondReq;

// Make sure a single socket is transparently reused for 2 requests.
const agent = new http.Agent({
  keepAlive: true,
  keepAliveMsecs: Infinity,
  maxSockets: 1,
});

const server = http.createServer(common.mustCall((req, res) => {
  req.once('data', common.mustCallAtLeast(() => {
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.write('foo');
  }));
  req.on('end', common.mustCall(() => {
    res.end('bar');
  }));
}, 2)).listen(0, common.mustCall(() => {
  const port = server.address().port;
  const payload = 'hello world';

  // First request. This is useless except for adding a socket to the
  // agent’s pool for reuse.
  const r1 = http.request({
    agent, port, method: 'POST',
  }, common.mustCall((res) => {
    // Remember which socket we used.
    const socket = res.socket;
    asyncIdAtFirstReq = socket[async_id_symbol];
    assert.ok(asyncIdAtFirstReq > 0, `${asyncIdAtFirstReq} > 0`);
    // Check that request and response share their socket.
    assert.strictEqual(r1.socket, socket);

    res.on('data', common.mustCallAtLeast());
    res.on('end', common.mustCall(() => {
      // setImmediate() to give the agent time to register the freed socket.
      setImmediate(common.mustCall(() => {
        // The socket is free for reuse now.
        assert.strictEqual(socket[async_id_symbol], -1);

        // Second request. To re-create the exact conditions from the
        // referenced issue, we use a POST request without chunked encoding
        // (hence the Content-Length header) and call .end() after the
        // response header has already been received.
        const r2 = http.request({
          agent, port, method: 'POST', headers: {
            'Content-Length': payload.length,
          },
        }, common.mustCall((res) => {
          asyncIdAtSecondReq = res.socket[async_id_symbol];
          assert.ok(asyncIdAtSecondReq > 0, `${asyncIdAtSecondReq} > 0`);
          assert.strictEqual(r2.socket, socket);

          // Empty payload, to hit the “right” code path.
          r2.end('');

          res.on('data', common.mustCallAtLeast());
          res.on('end', common.mustCall(() => {
            // Clean up to let the event loop stop.
            server.close();
            agent.destroy();
          }));
        }));

        // Schedule a payload to be written immediately, but do not end the
        // request just yet.
        r2.write(payload);
      }));
    }));
  }));
  r1.end(payload);
}));


process.on('exit', onExit);

function onExit() {
  hooks.disable();
  hooks.sanityCheck();
  const activities = hooks.activities;

  // Verify both invocations
  const first = activities.filter((x) => x.uid === asyncIdAtFirstReq)[0];
  checkInvocations(first, { init: 1, destroy: 1 }, 'when process exits');

  const second = activities.filter((x) => x.uid === asyncIdAtSecondReq)[0];
  checkInvocations(second, { init: 1, destroy: 1 }, 'when process exits');

  // Verify reuse handle has been wrapped
  assert.strictEqual(first.type, second.type);
  assert.ok(first.handle !== second.handle, 'Resource reused');
  assert.ok(first.handle === second.handle.handle,
            'Resource not wrapped correctly');
}
                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/async-hooks/test-httpparser-reuse.js                                               0000664 0000000 0000000 00000003655 14746647661 0022633 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const { createHook } = require('async_hooks');
const http = require('http');

// Verify that resource emitted for an HTTPParser is not reused.
// Verify that correct create/destroy events are emitted.

const reused = Symbol('reused');

const reusedParser = [];
const incomingMessageParser = [];
const clientRequestParser = [];
const dupDestroys = [];
const destroyed = [];

createHook({
  init(asyncId, type, triggerAsyncId, resource) {
    switch (type) {
      case 'HTTPINCOMINGMESSAGE':
        incomingMessageParser.push(asyncId);
        break;
      case 'HTTPCLIENTREQUEST':
        clientRequestParser.push(asyncId);
        break;
    }

    if (resource[reused]) {
      reusedParser.push(
        `resource reused: ${asyncId}, ${triggerAsyncId}, ${type}`,
      );
    }
    resource[reused] = true;
  },
  destroy(asyncId) {
    if (destroyed.includes(asyncId)) {
      dupDestroys.push(asyncId);
    } else {
      destroyed.push(asyncId);
    }
  },
}).enable();

const server = http.createServer((req, res) => {
  res.end();
});

server.listen(0, common.mustCall(() => {
  const PORT = server.address().port;
  const url = `http://127.0.0.1:${PORT}`;
  http.get(url, common.mustCall(() => {
    server.close(common.mustCall(() => {
      server.listen(PORT, common.mustCall(() => {
        http.get(url, common.mustCall(() => {
          server.close(common.mustCall(() => {
            setTimeout(common.mustCall(verify), 200);
          }));
        }));
      }));
    }));
  }));
}));

function verify() {
  assert.strictEqual(reusedParser.length, 0);

  assert.strictEqual(incomingMessageParser.length, 2);
  assert.strictEqual(clientRequestParser.length, 2);

  assert.strictEqual(dupDestroys.length, 0);
  incomingMessageParser.forEach((id) => assert.ok(destroyed.includes(id)));
  clientRequestParser.forEach((id) => assert.ok(destroyed.includes(id)));
}
                                                                                   node-23.7.0/test/async-hooks/test-httpparser.request.js                                             0000664 0000000 0000000 00000002634 14746647661 0023175 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const tick = require('../common/tick');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');

const hooks = initHooks();
hooks.enable();

const { HTTPParser } = require('_http_common');

const REQUEST = HTTPParser.REQUEST;

const kOnHeadersComplete = HTTPParser.kOnHeadersComplete | 0;

const request = Buffer.from(
  'GET /hello HTTP/1.1\r\n\r\n',
);

const parser = new HTTPParser();
parser.initialize(REQUEST, {});
const as = hooks.activitiesOfTypes('HTTPINCOMINGMESSAGE');
const httpparser = as[0];

assert.strictEqual(as.length, 1);
assert.strictEqual(typeof httpparser.uid, 'number');
assert.strictEqual(typeof httpparser.triggerAsyncId, 'number');
checkInvocations(httpparser, { init: 1 }, 'when created new Httphttpparser');

parser[kOnHeadersComplete] = common.mustCall(onheadersComplete);
parser.execute(request, 0, request.length);

function onheadersComplete() {
  checkInvocations(httpparser, { init: 1, before: 1 },
                   'when onheadersComplete called');
  tick(1, common.mustCall(tick1));
}

function tick1() {
  parser.close();
  tick(1);
}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  hooks.sanityCheck('HTTPINCOMINGMESSAGE');
  checkInvocations(httpparser, { init: 1, before: 1, after: 1, destroy: 1 },
                   'when process exits');
}
                                                                                                    node-23.7.0/test/async-hooks/test-httpparser.response.js                                            0000664 0000000 0000000 00000003275 14746647661 0023345 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const tick = require('../common/tick');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');

const hooks = initHooks();

hooks.enable();

const { HTTPParser } = require('_http_common');

const RESPONSE = HTTPParser.RESPONSE;
const kOnHeadersComplete = HTTPParser.kOnHeadersComplete | 0;
const kOnBody = HTTPParser.kOnBody | 0;

const request = Buffer.from(
  'HTTP/1.1 200 OK\r\n' +
  'Content-Type: text/plain\r\n' +
  'Content-Length: 4\r\n' +
  '\r\n' +
  'pong',
);

const parser = new HTTPParser();
parser.initialize(RESPONSE, {});
const as = hooks.activitiesOfTypes('HTTPCLIENTREQUEST');
const httpparser = as[0];

assert.strictEqual(as.length, 1);
assert.strictEqual(typeof httpparser.uid, 'number');
assert.strictEqual(typeof httpparser.triggerAsyncId, 'number');
checkInvocations(httpparser, { init: 1 }, 'when created new Httphttpparser');

parser[kOnHeadersComplete] = common.mustCall(onheadersComplete);
parser[kOnBody] = common.mustCall(onbody);
parser.execute(request, 0, request.length);

function onheadersComplete() {
  checkInvocations(httpparser, { init: 1, before: 1 },
                   'when onheadersComplete called');
}

function onbody() {
  checkInvocations(httpparser, { init: 1, before: 2, after: 1 },
                   'when onbody called');
  tick(1, common.mustCall(tick1));
}

function tick1() {
  parser.close();
  tick(1);
}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  hooks.sanityCheck('HTTPCLIENTREQUEST');
  checkInvocations(httpparser, { init: 1, before: 2, after: 2, destroy: 1 },
                   'when process exits');
}
                                                                                                                                                                                                                                                                                                                                   node-23.7.0/test/async-hooks/test-immediate.js                                                      0000664 0000000 0000000 00000004100 14746647661 0021236 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const tick = require('../common/tick');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');

const hooks = initHooks();
hooks.enable();

// Install first immediate
setImmediate(common.mustCall(onimmediate));

const as = hooks.activitiesOfTypes('Immediate');
assert.strictEqual(as.length, 1);
const imd1 = as[0];
assert.strictEqual(imd1.type, 'Immediate');
assert.strictEqual(typeof imd1.uid, 'number');
assert.strictEqual(typeof imd1.triggerAsyncId, 'number');
checkInvocations(imd1, { init: 1 },
                 'imd1: when first set immediate installed');

let imd2;

function onimmediate() {
  let as = hooks.activitiesOfTypes('Immediate');
  assert.strictEqual(as.length, 1);
  checkInvocations(imd1, { init: 1, before: 1 },
                   'imd1: when first set immediate triggered');

  // Install second immediate
  setImmediate(common.mustCall(onimmediateTwo));
  as = hooks.activitiesOfTypes('Immediate');
  assert.strictEqual(as.length, 2);
  imd2 = as[1];
  assert.strictEqual(imd2.type, 'Immediate');
  assert.strictEqual(typeof imd2.uid, 'number');
  assert.strictEqual(typeof imd2.triggerAsyncId, 'number');
  checkInvocations(imd1, { init: 1, before: 1 },
                   'imd1: when second set immediate installed');
  checkInvocations(imd2, { init: 1 },
                   'imd2: when second set immediate installed');
}

function onimmediateTwo() {
  checkInvocations(imd1, { init: 1, before: 1, after: 1, destroy: 1 },
                   'imd1: when second set immediate triggered');
  checkInvocations(imd2, { init: 1, before: 1 },
                   'imd2: when second set immediate triggered');
  tick(1);
}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  hooks.sanityCheck('Immediate');
  checkInvocations(imd1, { init: 1, before: 1, after: 1, destroy: 1 },
                   'imd1: when process exits');
  checkInvocations(imd2, { init: 1, before: 1, after: 1, destroy: 1 },
                   'imd2: when process exits');
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/test/async-hooks/test-improper-order.js                                                 0000664 0000000 0000000 00000003626 14746647661 0022262 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';

const common = require('../common');
const assert = require('assert');
const internal_async_hooks = require('internal/async_hooks');
const { spawn } = require('child_process');
const corruptedMsg = /async hook stack has become corrupted/;
const heartbeatMsg = /heartbeat: still alive/;

const {
  newAsyncId, getDefaultTriggerAsyncId,
  emitInit, emitBefore, emitAfter,
} = internal_async_hooks;

const initHooks = require('./init-hooks');

if (process.argv[2] === 'child') {
  const hooks = initHooks();
  hooks.enable();

  // Async hooks enforce proper order of 'before' and 'after' invocations

  // Proper ordering
  {
    const asyncId = newAsyncId();
    const triggerId = getDefaultTriggerAsyncId();
    emitInit(asyncId, 'event1', triggerId, {});
    emitBefore(asyncId, triggerId);
    emitAfter(asyncId);
  }

  // Improper ordering
  // Emitting 'after' without 'before' which is illegal
  {
    const asyncId = newAsyncId();
    const triggerId = getDefaultTriggerAsyncId();
    emitInit(asyncId, 'event2', triggerId, {});

    console.log('heartbeat: still alive');
    emitAfter(asyncId);
  }
} else {
  const args = ['--expose-internals']
    .concat(process.argv.slice(1))
    .concat('child');
  let errData = Buffer.from('');
  let outData = Buffer.from('');

  const child = spawn(process.execPath, args);
  child.stderr.on('data', (d) => { errData = Buffer.concat([ errData, d ]); });
  child.stdout.on('data', (d) => { outData = Buffer.concat([ outData, d ]); });

  child.on('close', common.mustCall((code) => {
    assert.strictEqual(code, 1);
    assert.match(outData.toString(), heartbeatMsg,
                 'did not crash until we reached offending line of code ' +
                 `(found ${outData})`);
    assert.match(errData.toString(), corruptedMsg,
                 'printed error contains corrupted message ' +
                 `(found ${errData})`);
  }));
}
                                                                                                          node-23.7.0/test/async-hooks/test-improper-unwind.js                                                0000664 0000000 0000000 00000004145 14746647661 0022450 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';

const common = require('../common');
const assert = require('assert');
const internal_async_hooks = require('internal/async_hooks');
const { spawn } = require('child_process');
const corruptedMsg = /async hook stack has become corrupted/;
const heartbeatMsg = /heartbeat: still alive/;

const {
  newAsyncId, getDefaultTriggerAsyncId,
  emitInit, emitBefore, emitAfter,
} = internal_async_hooks;

const initHooks = require('./init-hooks');

if (process.argv[2] === 'child') {
  const hooks = initHooks();
  hooks.enable();

  // In both the below two cases 'before' of event2 is nested inside 'before'
  // of event1.
  // Therefore the 'after' of event2 needs to occur before the
  // 'after' of event 1.
  // The first test of the two below follows that rule,
  // the second one doesn't.

  const eventOneId = newAsyncId();
  const eventTwoId = newAsyncId();
  const triggerId = getDefaultTriggerAsyncId();
  emitInit(eventOneId, 'event1', triggerId, {});
  emitInit(eventTwoId, 'event2', triggerId, {});

  // Proper unwind
  emitBefore(eventOneId, triggerId);
  emitBefore(eventTwoId, triggerId);
  emitAfter(eventTwoId);
  emitAfter(eventOneId);

  // Improper unwind
  emitBefore(eventOneId, triggerId);
  emitBefore(eventTwoId, triggerId);

  console.log('heartbeat: still alive');
  emitAfter(eventOneId);
} else {
  const args = ['--expose-internals']
    .concat(process.argv.slice(1))
    .concat('child');
  let errData = Buffer.from('');
  let outData = Buffer.from('');

  const child = spawn(process.execPath, args);
  child.stderr.on('data', (d) => { errData = Buffer.concat([ errData, d ]); });
  child.stdout.on('data', (d) => { outData = Buffer.concat([ outData, d ]); });

  child.on('close', common.mustCall((code) => {
    assert.strictEqual(code, 1);
    assert.match(outData.toString(), heartbeatMsg,
                 'did not crash until we reached offending line of code ' +
                 `(found ${outData})`);
    assert.match(errData.toString(), corruptedMsg,
                 'printed error contains corrupted message ' +
                 `(found ${errData})`);
  }));
}
                                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/test/async-hooks/test-late-hook-enable.js                                               0000664 0000000 0000000 00000002225 14746647661 0022415 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');
const assert = require('assert');
const async_hooks = require('async_hooks');

// Checks that enabling async hooks in a callback actually
// triggers after & destroy as expected.

const fnsToTest = [setTimeout, (cb) => {
  setImmediate(() => {
    cb();

    // We need to keep the event loop open for this to actually work
    // since destroy hooks are triggered in unrefed Immediates
    setImmediate(() => {
      hook.disable();
    });
  });
}, (cb) => {
  setImmediate(() => {
    process.nextTick(() => {
      cb();

      // We need to keep the event loop open for this to actually work
      // since destroy hooks are triggered in unrefed Immediates
      setImmediate(() => {
        hook.disable();
        assert.strictEqual(fnsToTest.length, 0);
      });
    });
  });
}];

const hook = async_hooks.createHook({
  before: common.mustNotCall(),
  after: common.mustCall(3),
  destroy: common.mustCall(() => {
    hook.disable();
    nextTest();
  }, 3),
});

nextTest();

function nextTest() {
  if (fnsToTest.length > 0) {
    fnsToTest.shift()(common.mustCall(() => {
      hook.enable();
    }));
  }
}
                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/test/async-hooks/test-net-get-connections.js                                            0000664 0000000 0000000 00000000501 14746647661 0023164 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const net = require('net');
const server = net.createServer();

// This test was based on an error raised by Haraka.
// It caused server.getConnections to raise an exception.
// Ref: https://github.com/haraka/Haraka/pull/1951

server.getConnections(common.mustCall());
                                                                                                                                                                                               node-23.7.0/test/async-hooks/test-nexttick-default-trigger.js                                       0000664 0000000 0000000 00000001360 14746647661 0024221 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');

// This tests ensures that the triggerId of the nextTick function sets the
// triggerAsyncId correctly.

const assert = require('assert');
const async_hooks = require('async_hooks');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');

const hooks = initHooks();
hooks.enable();

const rootAsyncId = async_hooks.executionAsyncId();

process.nextTick(common.mustCall(() => {
  assert.strictEqual(async_hooks.triggerAsyncId(), rootAsyncId);
}));

process.on('exit', () => {
  hooks.sanityCheck();

  const as = hooks.activitiesOfTypes('TickObject');
  checkInvocations(as[0], {
    init: 1, before: 1, after: 1, destroy: 1,
  }, 'when process exits');
});
                                                                                                                                                                                                                                                                                node-23.7.0/test/async-hooks/test-no-assert-when-disabled.js                                        0000664 0000000 0000000 00000000746 14746647661 0023733 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// Flags: --no-force-async-hooks-checks --expose-internals
const common = require('../common');
const { isMainThread } = require('worker_threads');
if (!isMainThread) {
  common.skip('Workers don\'t inherit per-env state like the check flag');
}

const async_hooks = require('internal/async_hooks');

// Negative asyncIds and invalid type name
async_hooks.emitInit(-1, null, -1, {});
async_hooks.emitBefore(-1, -1);
async_hooks.emitAfter(-1);
async_hooks.emitDestroy(-1);
                          node-23.7.0/test/async-hooks/test-pipeconnectwrap.js                                                0000664 0000000 0000000 00000006605 14746647661 0022515 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const tick = require('../common/tick');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');
const tmpdir = require('../common/tmpdir');
const net = require('net');

tmpdir.refresh();

const hooks = initHooks();
hooks.enable();
let pipe1, pipe2;
let pipeserver;
let pipeconnect;

const server = net.createServer(common.mustCall((c) => {
  c.end();
  server.close();
  process.nextTick(maybeOnconnect.bind(null, 'server'));
})).listen(common.PIPE, common.mustCall(onlisten));

function onlisten() {
  const pipeservers = hooks.activitiesOfTypes('PIPESERVERWRAP');
  let pipeconnects = hooks.activitiesOfTypes('PIPECONNECTWRAP');
  assert.strictEqual(pipeservers.length, 1);
  assert.strictEqual(pipeconnects.length, 0);

  net.connect(common.PIPE,
              common.mustCall(maybeOnconnect.bind(null, 'client')));

  const pipes = hooks.activitiesOfTypes('PIPEWRAP');
  pipeconnects = hooks.activitiesOfTypes('PIPECONNECTWRAP');
  assert.strictEqual(pipes.length, 1);
  assert.strictEqual(pipeconnects.length, 1);

  pipeserver = pipeservers[0];
  pipe1 = pipes[0];
  pipeconnect = pipeconnects[0];

  assert.strictEqual(pipeserver.type, 'PIPESERVERWRAP');
  assert.strictEqual(pipe1.type, 'PIPEWRAP');
  assert.strictEqual(pipeconnect.type, 'PIPECONNECTWRAP');
  for (const a of [ pipeserver, pipe1, pipeconnect ]) {
    assert.strictEqual(typeof a.uid, 'number');
    assert.strictEqual(typeof a.triggerAsyncId, 'number');
    checkInvocations(a, { init: 1 }, 'after net.connect');
  }
}

const awaitOnconnectCalls = new Set(['server', 'client']);
function maybeOnconnect(source) {
  // Both server and client must call onconnect. On most OS's waiting for
  // the client is sufficient, but on CentOS 5 the sever needs to respond too.
  assert.ok(awaitOnconnectCalls.size > 0);
  awaitOnconnectCalls.delete(source);
  if (awaitOnconnectCalls.size > 0) return;

  const pipes = hooks.activitiesOfTypes('PIPEWRAP');
  const pipeconnects = hooks.activitiesOfTypes('PIPECONNECTWRAP');

  assert.strictEqual(pipes.length, 2);
  assert.strictEqual(pipeconnects.length, 1);
  pipe2 = pipes[1];
  assert.strictEqual(typeof pipe2.uid, 'number');
  assert.strictEqual(typeof pipe2.triggerAsyncId, 'number');

  checkInvocations(pipeserver, { init: 1, before: 1, after: 1 },
                   'pipeserver, client connected');
  checkInvocations(pipe1, { init: 1 }, 'pipe1, client connected');
  checkInvocations(pipeconnect, { init: 1, before: 1 },
                   'pipeconnect, client connected');
  checkInvocations(pipe2, { init: 1 }, 'pipe2, client connected');
  tick(5);
}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  hooks.sanityCheck('PIPEWRAP');
  hooks.sanityCheck('PIPESERVERWRAP');
  hooks.sanityCheck('PIPECONNECTWRAP');
  // TODO(thlorenz) why have some of those 'before' and 'after' called twice
  checkInvocations(pipeserver, { init: 1, before: 1, after: 1, destroy: 1 },
                   'pipeserver, process exiting');
  checkInvocations(pipe1, { init: 1, before: 2, after: 2, destroy: 1 },
                   'pipe1, process exiting');
  checkInvocations(pipeconnect, { init: 1, before: 1, after: 1, destroy: 1 },
                   'pipeconnect, process exiting');
  checkInvocations(pipe2, { init: 1, before: 2, after: 2, destroy: 1 },
                   'pipe2, process exiting');
}
                                                                                                                           node-23.7.0/test/async-hooks/test-pipewrap.js                                                       0000664 0000000 0000000 00000005642 14746647661 0021143 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // NOTE: this also covers process wrap as one is created along with the pipes
// when we launch the sleep process
'use strict';
// Flags: --expose-gc

const common = require('../common');
const assert = require('assert');
const tick = require('../common/tick');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');
const { spawn } = require('child_process');
const { isMainThread } = require('worker_threads');

if (!isMainThread) {
  common.skip('Worker bootstrapping works differently -> different async IDs');
}

const hooks = initHooks();

hooks.enable();
const nodeVersionSpawn = spawn(process.execPath, [ '--version' ]);

nodeVersionSpawn
  .on('exit', common.mustCall(onsleepExit))
  .on('close', common.mustCall(onsleepClose));

// A process wrap and 3 pipe wraps for std{in,out,err} are initialized
// synchronously
const processes = hooks.activitiesOfTypes('PROCESSWRAP');
const pipes = hooks.activitiesOfTypes('PIPEWRAP');
assert.strictEqual(processes.length, 1);
assert.strictEqual(pipes.length, 3);

const processwrap = processes[0];
const pipe1 = pipes[0];
const pipe2 = pipes[1];
const pipe3 = pipes[2];

assert.strictEqual(processwrap.type, 'PROCESSWRAP');
assert.strictEqual(processwrap.triggerAsyncId, 1);
checkInvocations(processwrap, { init: 1 },
                 'processwrap when sleep.spawn was called');

[ pipe1, pipe2, pipe3 ].forEach((x) => {
  assert.strictEqual(x.type, 'PIPEWRAP');
  assert.strictEqual(x.triggerAsyncId, 1);
  checkInvocations(x, { init: 1 }, 'pipe wrap when sleep.spawn was called');
});

function onsleepExit() {
  checkInvocations(processwrap, { init: 1, before: 1 },
                   'processwrap while in onsleepExit callback');
}

function onsleepClose() {
  tick(1, () =>
    checkInvocations(
      processwrap,
      { init: 1, before: 1, after: 1 },
      'processwrap while in onsleepClose callback'),
  );
}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  hooks.sanityCheck('PROCESSWRAP');
  hooks.sanityCheck('PIPEWRAP');

  checkInvocations(
    processwrap,
    { init: 1, before: 1, after: 1 },
    'processwrap while in onsleepClose callback');

  [ pipe1, pipe2, pipe3 ].forEach((x) => {
    assert.strictEqual(x.type, 'PIPEWRAP');
    assert.strictEqual(x.triggerAsyncId, 1);
  });

  const ioEvents = Math.min(pipe2.before.length, pipe2.after.length);
  // 2 events without any IO and at least one more for the node version data.
  // Usually it is just one event, but it can be more.
  assert.ok(ioEvents >= 3, `at least 3 stdout io events, got ${ioEvents}`);

  checkInvocations(pipe1, { init: 1, before: 1, after: 1 },
                   'pipe wrap when sleep.spawn was called');
  checkInvocations(pipe2, { init: 1, before: ioEvents, after: ioEvents },
                   'pipe wrap when sleep.spawn was called');
  checkInvocations(pipe3, { init: 1, before: 2, after: 2 },
                   'pipe wrap when sleep.spawn was called');
}
                                                                                              node-23.7.0/test/async-hooks/test-promise.chain-promise-before-init-hooks.js                        0000664 0000000 0000000 00000002332 14746647661 0027042 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');
const { isMainThread } = require('worker_threads');

if (!isMainThread) {
  common.skip('Worker bootstrapping works differently -> different async IDs');
}

const p = new Promise(common.mustCall(function executor(resolve) {
  resolve(5);
}));

p.then(function afterResolution(val) {
  assert.strictEqual(val, 5);
  return val;
});

// Init hooks after chained promise is created
const hooks = initHooks();
hooks._allowNoInit = true;
hooks.enable();


process.on('exit', function onexit() {
  hooks.disable();
  hooks.sanityCheck('PROMISE');

  // Because the init event was never emitted the hooks listener doesn't
  // know what the type was. Thus check for Unknown rather than PROMISE.
  const as = hooks.activitiesOfTypes('PROMISE');
  const unknown = hooks.activitiesOfTypes('Unknown');
  assert.strictEqual(as.length, 0);
  assert.strictEqual(unknown.length, 1);

  const a0 = unknown[0];
  assert.strictEqual(a0.type, 'Unknown');
  assert.strictEqual(typeof a0.uid, 'number');
  checkInvocations(a0, { before: 1, after: 1 }, 'when process exits');
});
                                                                                                                                                                                                                                                                                                      node-23.7.0/test/async-hooks/test-promise.js                                                        0000664 0000000 0000000 00000003253 14746647661 0020766 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

const assert = require('assert');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');
const { isMainThread } = require('worker_threads');

if (!isMainThread) {
  common.skip('Worker bootstrapping works differently -> different async IDs');
}

const hooks = initHooks();

hooks.enable();

const p = new Promise(common.mustCall(executor));
p.then(function afterResolution(val) {
  assert.strictEqual(val, 5);
  const as = hooks.activitiesOfTypes('PROMISE');
  assert.strictEqual(as.length, 2);
  checkInvocations(as[0], { init: 1 }, 'after resolution parent promise');
  checkInvocations(as[1], { init: 1, before: 1 },
                   'after resolution child promise');
});

function executor(resolve) {
  const as = hooks.activitiesOfTypes('PROMISE');
  assert.strictEqual(as.length, 1);
  const a = as[0];
  checkInvocations(a, { init: 1 }, 'while in promise executor');
  resolve(5);
}

process.on('exit', onexit);
function onexit() {
  hooks.disable();
  hooks.sanityCheck('PROMISE');

  const as = hooks.activitiesOfTypes('PROMISE');
  assert.strictEqual(as.length, 2);

  const a0 = as[0];
  assert.strictEqual(a0.type, 'PROMISE');
  assert.strictEqual(typeof a0.uid, 'number');
  assert.strictEqual(a0.triggerAsyncId, 1);
  checkInvocations(a0, { init: 1 }, 'when process exits');

  const a1 = as[1];
  assert.strictEqual(a1.type, 'PROMISE');
  assert.strictEqual(typeof a1.uid, 'number');
  assert.strictEqual(a1.triggerAsyncId, a0.uid);
  // We expect a destroy hook as well but we cannot guarantee predictable gc.
  checkInvocations(a1, { init: 1, before: 1, after: 1 }, 'when process exits');
}
                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/test/async-hooks/test-promise.promise-before-init-hooks.js                              0000664 0000000 0000000 00000002571 14746647661 0025767 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');

const p = new Promise(common.mustCall(function executor(resolve) {
  resolve(5);
}));

// Init hooks after promise was created
const hooks = initHooks({ allowNoInit: true });
hooks.enable();

p.then(function afterResolution(val) {
  assert.strictEqual(val, 5);
  const as = hooks.activitiesOfTypes('PROMISE');
  assert.strictEqual(as.length, 1);
  checkInvocations(as[0], { init: 1, before: 1 },
                   'after resolution child promise');
  return val;
});

process.on('exit', function onexit() {
  hooks.disable();
  hooks.sanityCheck('PROMISE');

  const as = hooks.activitiesOfTypes('PROMISE');
  assert.strictEqual(as.length, 1);

  const a0 = as[0];
  assert.strictEqual(a0.type, 'PROMISE');
  assert.strictEqual(typeof a0.uid, 'number');
  // We can't get the asyncId from the parent dynamically, since init was
  // never called. However, it is known that the parent promise was created
  // immediately before the child promise, thus there should only be one
  // difference in id.
  assert.strictEqual(a0.triggerAsyncId, a0.uid - 1);
  // We expect a destroy hook as well but we cannot guarantee predictable gc.
  checkInvocations(a0, { init: 1, before: 1, after: 1 }, 'when process exits');
});
                                                                                                                                       node-23.7.0/test/async-hooks/test-querywrap.js                                                      0000664 0000000 0000000 00000002142 14746647661 0021343 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
// Flags: --expose-gc

const common = require('../common');
const assert = require('assert');
const tick = require('../common/tick');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');
const dns = require('dns');

const hooks = initHooks();

hooks.enable();
// Uses cares for queryA which in turn uses QUERYWRAP
dns.resolve('localhost', common.mustCall(onresolved));

function onresolved() {
  const as = hooks.activitiesOfTypes('QUERYWRAP');
  const a = as[0];
  assert.strictEqual(as.length, 1);
  checkInvocations(a, { init: 1, before: 1 }, 'while in onresolved callback');
  tick(1E4);
}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  hooks.sanityCheck('QUERYWRAP');

  const as = hooks.activitiesOfTypes('QUERYWRAP');
  assert.strictEqual(as.length, 1);
  const a = as[0];

  assert.strictEqual(a.type, 'QUERYWRAP');
  assert.strictEqual(typeof a.uid, 'number');
  assert.strictEqual(typeof a.triggerAsyncId, 'number');
  checkInvocations(a, { init: 1, before: 1, after: 1, destroy: 1 },
                   'when process exits');
}
                                                                                                                                                                                                                                                                                                                                                                                                                              node-23.7.0/test/async-hooks/test-queue-microtask.js                                                0000664 0000000 0000000 00000001204 14746647661 0022420 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');

const assert = require('assert');
const async_hooks = require('async_hooks');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');

const hooks = initHooks();
hooks.enable();

const rootAsyncId = async_hooks.executionAsyncId();

queueMicrotask(common.mustCall(() => {
  assert.strictEqual(async_hooks.triggerAsyncId(), rootAsyncId);
}));

process.on('exit', () => {
  hooks.sanityCheck();

  const as = hooks.activitiesOfTypes('Microtask');
  checkInvocations(as[0], {
    init: 1, before: 1, after: 1, destroy: 1,
  }, 'when process exits');
});
                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/test/async-hooks/test-shutdownwrap.js                                                   0000664 0000000 0000000 00000003534 14746647661 0022057 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');

const net = require('net');

const hooks = initHooks();
hooks.enable();

const server = net
  .createServer(onconnection)
  .on('listening', common.mustCall(onlistening));
server.listen();
function onlistening() {
  net.connect(server.address().port, common.mustCall(onconnected));
}

// It is non-deterministic in which order onconnection and onconnected fire.
// Therefore we track here if we ended the connection already or not.
let endedConnection = false;
function onconnection(c) {
  assert.strictEqual(hooks.activitiesOfTypes('SHUTDOWNWRAP').length, 0);
  c.end();
  process.nextTick(() => {
    endedConnection = true;
    const as = hooks.activitiesOfTypes('SHUTDOWNWRAP');
    assert.strictEqual(as.length, 1);
    checkInvocations(as[0], { init: 1 }, 'after ending client connection');
    this.close(onserverClosed);
  });
}

function onconnected() {
  if (endedConnection) {
    assert.strictEqual(hooks.activitiesOfTypes('SHUTDOWNWRAP').length, 1);

  } else {
    assert.strictEqual(hooks.activitiesOfTypes('SHUTDOWNWRAP').length, 0);
  }
}

function onserverClosed() {
  const as = hooks.activitiesOfTypes('SHUTDOWNWRAP');
  checkInvocations(as[0], { init: 1, before: 1, after: 1, destroy: 1 },
                   'when server closed');
}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  hooks.sanityCheck('SHUTDOWNWRAP');
  const as = hooks.activitiesOfTypes('SHUTDOWNWRAP');
  const a = as[0];
  assert.strictEqual(a.type, 'SHUTDOWNWRAP');
  assert.strictEqual(typeof a.uid, 'number');
  assert.strictEqual(typeof a.triggerAsyncId, 'number');
  checkInvocations(as[0], { init: 1, before: 1, after: 1, destroy: 1 },
                   'when process exits');
}
                                                                                                                                                                    node-23.7.0/test/async-hooks/test-signalwrap.js                                                     0000664 0000000 0000000 00000006525 14746647661 0021464 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';
const common = require('../common');

if (common.isWindows) {
  common.skip('no signals in Windows');
}
const { isMainThread } = require('worker_threads');
if (!isMainThread) {
  common.skip('No signal handling available in Workers');
}

const assert = require('assert');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');
const exec = require('child_process').exec;

const hooks = initHooks();

hooks.enable();

// Keep the event loop open so process doesn't exit before receiving signals.
const interval = setInterval(() => {}, 9999);

process.on('SIGUSR2', common.mustCall(onsigusr2, 2));

const as = hooks.activitiesOfTypes('SIGNALWRAP');
assert.strictEqual(as.length, 1);
const signal1 = as[0];
assert.strictEqual(signal1.type, 'SIGNALWRAP');
assert.strictEqual(typeof signal1.uid, 'number');
assert.strictEqual(typeof signal1.triggerAsyncId, 'number');
checkInvocations(signal1, { init: 1 }, 'when SIGUSR2 handler is set up');

let count = 0;
exec(`kill -USR2 ${process.pid}`);

let signal2;

function onsigusr2() {
  count++;

  if (count === 1) {
    // first invocation
    checkInvocations(
      signal1, { init: 1, before: 1 },
      ' signal1: when first SIGUSR2 handler is called for the first time');

    // Trigger same signal handler again
    exec(`kill -USR2 ${process.pid}`);
  } else {
    // second invocation
    checkInvocations(
      signal1, { init: 1, before: 2, after: 1 },
      'signal1: when first SIGUSR2 handler is called for the second time');

    // Install another signal handler
    process.removeAllListeners('SIGUSR2');
    process.on('SIGUSR2', common.mustCall(onsigusr2Again));

    const as = hooks.activitiesOfTypes('SIGNALWRAP');
    // The isTTY checks are needed to allow test to work whether run with
    // test.py or directly with the node executable. The third signal event
    // listener is the SIGWINCH handler that node installs when it thinks
    // process.stdout is a tty.
    const expectedLen = 2 + (!!process.stdout.isTTY || !!process.stderr.isTTY);
    assert.strictEqual(as.length, expectedLen);
    signal2 = as[expectedLen - 1]; // Last item in the array.
    assert.strictEqual(signal2.type, 'SIGNALWRAP');
    assert.strictEqual(typeof signal2.uid, 'number');
    assert.strictEqual(typeof signal2.triggerAsyncId, 'number');

    checkInvocations(
      signal1, { init: 1, before: 2, after: 1 },
      'signal1: when second SIGUSR2 handler is set up');
    checkInvocations(
      signal2, { init: 1 },
      'signal2: when second SIGUSR2 handler is setup');

    exec(`kill -USR2 ${process.pid}`);
  }
}

function onsigusr2Again() {
  clearInterval(interval);
  setImmediate(() => {
    checkInvocations(
      signal1, { init: 1, before: 2, after: 2, destroy: 1 },
      'signal1: when second SIGUSR2 handler is called');
    checkInvocations(
      signal2, { init: 1, before: 1 },
      'signal2: when second SIGUSR2 handler is called');
  });
}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  hooks.sanityCheck('SIGNALWRAP');
  checkInvocations(
    signal1, { init: 1, before: 2, after: 2, destroy: 1 },
    'signal1: when second SIGUSR2 process exits');
  // Second signal not destroyed yet since its event listener is still active
  checkInvocations(
    signal2, { init: 1, before: 1, after: 1 },
    'signal2: when second SIGUSR2 process exits');
}
                                                                                                                                                                           node-23.7.0/test/async-hooks/test-statwatcher.js                                                    0000664 0000000 0000000 00000007212 14746647661 0021640 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const tmpdir = require('../common/tmpdir');
const assert = require('assert');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');
const fs = require('fs');

const { isMainThread } = require('worker_threads');

if (!isMainThread) {
  common.skip('Worker bootstrapping works differently -> different async IDs');
}

tmpdir.refresh();

const file1 = tmpdir.resolve('file1');
const file2 = tmpdir.resolve('file2');

const onchangex = (x) => (curr, prev) => {
  console.log(`Watcher: ${x}`);
  console.log('current stat data:', curr);
  console.log('previous stat data:', prev);
};

const checkWatcherStart = (name, watcher) => {
  assert.strictEqual(watcher.type, 'STATWATCHER');
  assert.strictEqual(typeof watcher.uid, 'number');
  assert.strictEqual(watcher.triggerAsyncId, 1);
  checkInvocations(watcher, { init: 1 },
                   `${name}: when started to watch file`);
};

const hooks = initHooks();
hooks.enable();

// Install first file watcher.
const w1 = fs.watchFile(file1, { interval: 10 }, onchangex('w1'));
let as = hooks.activitiesOfTypes('STATWATCHER');
assert.strictEqual(as.length, 1);
// Count all change events to account for all of them in checkInvocations.
let w1HookCount = 0;
w1.on('change', () => w1HookCount++);

const statwatcher1 = as[0];
checkWatcherStart('watcher1', statwatcher1);

// Install second file watcher
const w2 = fs.watchFile(file2, { interval: 10 }, onchangex('w2'));
as = hooks.activitiesOfTypes('STATWATCHER');
assert.strictEqual(as.length, 2);
// Count all change events to account for all of them in checkInvocations.
let w2HookCount = 0;
w2.on('change', () => w2HookCount++);

const statwatcher2 = as[1];
checkInvocations(statwatcher1, { init: 1 },
                 'watcher1: when started to watch second file');
checkWatcherStart('watcher2', statwatcher2);

setTimeout(() => fs.writeFileSync(file1, 'foo++'),
           common.platformTimeout(100));
w1.on('change', common.mustCallAtLeast((curr, prev) => {
  console.log('w1 change to', curr, 'from', prev);
  // Wait until we get the write above.
  if (prev.size !== 0 || curr.size !== 5)
    return;

  setImmediate(() => {
    checkInvocations(statwatcher1,
                     { init: 1, before: w1HookCount, after: w1HookCount },
                     'watcher1: when unwatched first file');
    checkInvocations(statwatcher2, { init: 1 },
                     'watcher2: when unwatched first file');

    setTimeout(() => fs.writeFileSync(file2, 'bar++'),
               common.platformTimeout(100));
    w2.on('change', common.mustCallAtLeast((curr, prev) => {
      console.log('w2 change to', curr, 'from', prev);
      // Wait until we get the write above.
      if (prev.size !== 0 || curr.size !== 5)
        return;

      setImmediate(() => {
        checkInvocations(statwatcher1,
                         { init: 1, before: w1HookCount, after: w1HookCount },
                         'watcher1: when unwatched second file');
        checkInvocations(statwatcher2,
                         { init: 1, before: w2HookCount, after: w2HookCount },
                         'watcher2: when unwatched second file');
        fs.unwatchFile(file1);
        fs.unwatchFile(file2);
      });
    }));
  });
}));

process.once('exit', () => {
  hooks.disable();
  hooks.sanityCheck('STATWATCHER');
  checkInvocations(statwatcher1,
                   { init: 1, before: w1HookCount, after: w1HookCount },
                   'watcher1: when process exits');
  checkInvocations(statwatcher2,
                   { init: 1, before: w2HookCount, after: w2HookCount },
                   'watcher2: when process exits');
});
                                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/async-hooks/test-tcpwrap.js                                                        0000664 0000000 0000000 00000013537 14746647661 0020776 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Covers TCPWRAP and related TCPCONNECTWRAP
'use strict';

const common = require('../common');
if (!common.hasIPv6)
  common.skip('IPv6 support required');

const assert = require('assert');
const tick = require('../common/tick');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');
const net = require('net');

let tcp1, tcp2;
let tcpserver;
let tcpconnect;

const hooks = initHooks();
hooks.enable();

const server = net
  .createServer(common.mustCall(onconnection))
  .on('listening', common.mustCall(onlistening));

// Calling server.listen creates a TCPWRAP synchronously
{
  server.listen(0);
  const tcpsservers = hooks.activitiesOfTypes('TCPSERVERWRAP');
  const tcpconnects = hooks.activitiesOfTypes('TCPCONNECTWRAP');
  assert.strictEqual(tcpsservers.length, 1);
  assert.strictEqual(tcpconnects.length, 0);
  tcpserver = tcpsservers[0];
  assert.strictEqual(tcpserver.type, 'TCPSERVERWRAP');
  assert.strictEqual(typeof tcpserver.uid, 'number');
  assert.strictEqual(typeof tcpserver.triggerAsyncId, 'number');
  checkInvocations(tcpserver, { init: 1 }, 'when calling server.listen');
}

// Calling net.connect creates another TCPWRAP synchronously
{
  net.connect(
    { port: server.address().port, host: '::1' },
    common.mustCall(onconnected));
  const tcps = hooks.activitiesOfTypes('TCPWRAP');
  assert.strictEqual(tcps.length, 1);
  process.nextTick(() => {
    const tcpconnects = hooks.activitiesOfTypes('TCPCONNECTWRAP');
    assert.strictEqual(tcpconnects.length, 1);
  });

  tcp1 = tcps[0];
  assert.strictEqual(tcps.length, 1);
  assert.strictEqual(tcp1.type, 'TCPWRAP');
  assert.strictEqual(typeof tcp1.uid, 'number');
  assert.strictEqual(typeof tcp1.triggerAsyncId, 'number');

  checkInvocations(tcpserver, { init: 1 },
                   'tcpserver when client is connecting');
  checkInvocations(tcp1, { init: 1 }, 'tcp1 when client is connecting');
}

function onlistening() {
  assert.strictEqual(hooks.activitiesOfTypes('TCPWRAP').length, 1);
}

// Depending on timing we see client: onconnected or server: onconnection first
// Therefore we can't depend on any ordering, but when we see a connection for
// the first time we assign the tcpconnectwrap.
function ontcpConnection(serverConnection) {
  if (tcpconnect != null) {
    // When client receives connection first ('onconnected') and the server
    // second then we see an 'after' here, otherwise not
    const expected = serverConnection ?
      { init: 1, before: 1, after: 1 } :
      { init: 1, before: 1 };
    checkInvocations(
      tcpconnect, expected,
      'tcpconnect: when both client and server received connection');
    return;
  }

  // Only focusing on TCPCONNECTWRAP here
  const tcpconnects = hooks.activitiesOfTypes('TCPCONNECTWRAP');
  assert.strictEqual(tcpconnects.length, 1);
  tcpconnect = tcpconnects[0];
  assert.strictEqual(tcpconnect.type, 'TCPCONNECTWRAP');
  assert.strictEqual(typeof tcpconnect.uid, 'number');
  assert.strictEqual(typeof tcpconnect.triggerAsyncId, 'number');
  // When client receives connection first ('onconnected'), we 'before' has
  // been invoked at this point already, otherwise it only was 'init'ed
  const expected = serverConnection ? { init: 1 } : { init: 1, before: 1 };
  checkInvocations(tcpconnect, expected,
                   'tcpconnect: when tcp connection is established');
}

let serverConnected = false;
function onconnected() {
  ontcpConnection(false);
  // In the case that the client connects before the server TCPWRAP 'before'
  // and 'after' weren't invoked yet. Also @see ontcpConnection.
  const expected = serverConnected ?
    { init: 1, before: 1, after: 1 } :
    { init: 1 };
  checkInvocations(tcpserver, expected, 'tcpserver when client connects');
  checkInvocations(tcp1, { init: 1 }, 'tcp1 when client connects');
}

function onconnection(c) {
  serverConnected = true;
  ontcpConnection(true);

  const tcps = hooks.activitiesOfTypes([ 'TCPWRAP' ]);
  const tcpconnects = hooks.activitiesOfTypes('TCPCONNECTWRAP');
  assert.strictEqual(tcps.length, 2);
  assert.strictEqual(tcpconnects.length, 1);
  tcp2 = tcps[1];
  assert.strictEqual(tcp2.type, 'TCPWRAP');
  assert.strictEqual(typeof tcp2.uid, 'number');
  assert.strictEqual(typeof tcp2.triggerAsyncId, 'number');

  checkInvocations(tcpserver, { init: 1, before: 1 },
                   'tcpserver when server receives connection');
  checkInvocations(tcp1, { init: 1 }, 'tcp1 when server receives connection');
  checkInvocations(tcp2, { init: 1 }, 'tcp2 when server receives connection');

  c.end();
  this.close(common.mustCall(onserverClosed));
}

function onserverClosed() {
  setImmediate(() => {
    checkInvocations(tcpserver, { init: 1, before: 1, after: 1, destroy: 1 },
                     'tcpserver when server is closed');
    checkInvocations(tcp1, { init: 1, before: 2, after: 2, destroy: 1 },
                     'tcp1 after server is closed');
  });
  checkInvocations(tcp2, { init: 1, before: 1, after: 1 },
                   'tcp2 synchronously when server is closed');

  tick(2, () => {
    checkInvocations(tcp2, { init: 1, before: 2, after: 2, destroy: 1 },
                     'tcp2 when server is closed');
    checkInvocations(tcpconnect, { init: 1, before: 1, after: 1, destroy: 1 },
                     'tcpconnect when server is closed');
  });
}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  hooks.sanityCheck([ 'TCPWRAP', 'TCPSERVERWRAP', 'TCPCONNECTWRAP' ]);

  checkInvocations(tcpserver, { init: 1, before: 1, after: 1, destroy: 1 },
                   'tcpserver when process exits');
  checkInvocations(
    tcp1, { init: 1, before: 2, after: 2, destroy: 1 },
    'tcp1 when process exits');
  checkInvocations(
    tcp2, { init: 1, before: 2, after: 2, destroy: 1 },
    'tcp2 when process exits');
  checkInvocations(
    tcpconnect, { init: 1, before: 1, after: 1, destroy: 1 },
    'tcpconnect when process exits');
}
                                                                                                                                                                 node-23.7.0/test/async-hooks/test-timers.setInterval.js                                             0000664 0000000 0000000 00000002470 14746647661 0023112 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');
const TIMEOUT = common.platformTimeout(100);

const hooks = initHooks();
hooks.enable();

const interval = setInterval(common.mustCall(ontimeout, 2), TIMEOUT);
const as = hooks.activitiesOfTypes('Timeout');
assert.strictEqual(as.length, 1);
const t1 = as[0];
assert.strictEqual(t1.type, 'Timeout');
assert.strictEqual(typeof t1.uid, 'number');
assert.strictEqual(typeof t1.triggerAsyncId, 'number');
checkInvocations(t1, { init: 1 }, 't1: when timer installed');

let iter = 0;
function ontimeout() {
  if (iter === 0) {
    checkInvocations(t1, { init: 1, before: 1 }, 't1: when first timer fired');
  } else {
    checkInvocations(t1, { init: 1, before: 2, after: 1 },
                     't1: when first interval fired again');
    clearInterval(interval);
    return;
  }

  iter++;
  throw new Error('setInterval Error');
}

process.once('uncaughtException', common.mustCall((err) => {
  assert.strictEqual(err.message, 'setInterval Error');
}));

process.on('exit', () => {
  hooks.disable();
  hooks.sanityCheck('Timeout');

  checkInvocations(t1, { init: 1, before: 2, after: 2, destroy: 1 },
                   't1: when process exits');
});
                                                                                                                                                                                                        node-23.7.0/test/async-hooks/test-timers.setTimeout.js                                              0000664 0000000 0000000 00000003566 14746647661 0022763 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const tick = require('../common/tick');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');
const TIMEOUT = common.platformTimeout(100);

const hooks = initHooks();
hooks.enable();

// Install first timeout
setTimeout(common.mustCall(ontimeout), TIMEOUT);
const as = hooks.activitiesOfTypes('Timeout');
assert.strictEqual(as.length, 1);
const t1 = as[0];
assert.strictEqual(t1.type, 'Timeout');
assert.strictEqual(typeof t1.uid, 'number');
assert.strictEqual(typeof t1.triggerAsyncId, 'number');
checkInvocations(t1, { init: 1 }, 't1: when first timer installed');

let timer;
let t2;
function ontimeout() {
  checkInvocations(t1, { init: 1, before: 1 }, 't1: when first timer fired');

  setTimeout(onSecondTimeout, TIMEOUT).unref();
  const as = hooks.activitiesOfTypes('Timeout');
  t2 = as[1];
  assert.strictEqual(as.length, 2);
  checkInvocations(t1, { init: 1, before: 1 },
                   't1: when second timer installed');
  checkInvocations(t2, { init: 1 },
                   't2: when second timer installed');

  timer = setTimeout(common.mustNotCall(), 2 ** 31 - 1);
}

function onSecondTimeout() {
  const as = hooks.activitiesOfTypes('Timeout');
  assert.strictEqual(as.length, 3);
  checkInvocations(t1, { init: 1, before: 1, after: 1 },
                   't1: when second timer fired');
  checkInvocations(t2, { init: 1, before: 1 },
                   't2: when second timer fired');
  clearTimeout(timer);
  tick(2);
}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  hooks.sanityCheck('Timeout');

  checkInvocations(t1, { init: 1, before: 1, after: 1, destroy: 1 },
                   't1: when process exits');
  checkInvocations(t2, { init: 1, before: 1, after: 1, destroy: 1 },
                   't2: when process exits');
}
                                                                                                                                          node-23.7.0/test/async-hooks/test-tlswrap.js                                                        0000664 0000000 0000000 00000010465 14746647661 0021007 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

const assert = require('assert');
const fixtures = require('../common/fixtures');
const tls = require('tls');

const tick = require('../common/tick');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');

const hooks = initHooks();
hooks.enable();

// TODO(@sam-github) assumes server handshake completes before client, true for
// 1.2, not for 1.3. Might need a rewrite for TLS1.3.
tls.DEFAULT_MAX_VERSION = 'TLSv1.2';

//
// Creating server and listening on port
//
const server = tls
  .createServer({
    cert: fixtures.readKey('rsa_cert.crt'),
    key: fixtures.readKey('rsa_private.pem'),
  })
  .on('listening', common.mustCall(onlistening))
  .on('secureConnection', common.mustCall(onsecureConnection))
  .listen(0);

let svr, client;
function onlistening() {
  //
  // Creating client and connecting it to server
  //
  tls
    .connect(server.address().port, { rejectUnauthorized: false })
    .on('secureConnect', common.mustCall(onsecureConnect));

  const as = hooks.activitiesOfTypes('TLSWRAP');
  assert.strictEqual(as.length, 1);
  svr = as[0];

  assert.strictEqual(svr.type, 'TLSWRAP');
  assert.strictEqual(typeof svr.uid, 'number');
  assert.strictEqual(typeof svr.triggerAsyncId, 'number');
  checkInvocations(svr, { init: 1 }, 'server: when client connecting');
}

function onsecureConnection() {
  //
  // Server received client connection
  //
  const as = hooks.activitiesOfTypes('TLSWRAP');
  assert.strictEqual(as.length, 2);
  // TODO(@sam-github) This happens after onsecureConnect, with TLS1.3.
  client = as[1];
  assert.strictEqual(client.type, 'TLSWRAP');
  assert.strictEqual(typeof client.uid, 'number');
  assert.strictEqual(typeof client.triggerAsyncId, 'number');

  // TODO(thlorenz) which callback did the server wrap execute that already
  // finished as well?
  checkInvocations(svr, { init: 1, before: 1, after: 1 },
                   'server: when server has secure connection');

  checkInvocations(client, { init: 1, before: 2, after: 1 },
                   'client: when server has secure connection');
}

function onsecureConnect() {
  //
  // Client connected to server
  //
  checkInvocations(svr, { init: 1, before: 2, after: 1 },
                   'server: when client connected');
  checkInvocations(client, { init: 1, before: 2, after: 2 },
                   'client: when client connected');

  //
  // Destroying client socket
  //
  this.destroy();  // This destroys client before server handshakes, with TLS1.3
  checkInvocations(svr, { init: 1, before: 2, after: 1 },
                   'server: when destroying client');
  checkInvocations(client, { init: 1, before: 2, after: 2 },
                   'client: when destroying client');

  tick(5, tick1);
  function tick1() {
    checkInvocations(svr, { init: 1, before: 2, after: 2 },
                     'server: when client destroyed');
    // TODO: why is client not destroyed here even after 5 ticks?
    // or could it be that it isn't actually destroyed until
    // the server is closed?
    if (client.before.length < 3) {
      tick(5, tick1);
      return;
    }
    checkInvocations(client, { init: 1, before: 3, after: 3 },
                     'client: when client destroyed');
    //
    // Closing server
    //
    server.close(common.mustCall(onserverClosed));
    // No changes to invocations until server actually closed below
    checkInvocations(svr, { init: 1, before: 2, after: 2 },
                     'server: when closing server');
    checkInvocations(client, { init: 1, before: 3, after: 3 },
                     'client: when closing server');
  }
}

function onserverClosed() {
  //
  // Server closed
  //
  tick(1E4, common.mustCall(() => {
    checkInvocations(svr, { init: 1, before: 2, after: 2 },
                     'server: when server closed');
    checkInvocations(client, { init: 1, before: 3, after: 3 },
                     'client: when server closed');
  }));
}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  hooks.sanityCheck('TLSWRAP');

  checkInvocations(svr, { init: 1, before: 2, after: 2 },
                   'server: when process exits');
  checkInvocations(client, { init: 1, before: 3, after: 3 },
                   'client: when process exits');
}
                                                                                                                                                                                                           node-23.7.0/test/async-hooks/test-ttywrap.readstream.js                                             0000664 0000000 0000000 00000002552 14746647661 0023151 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');

// General hook test setup
const tick = require('../common/tick');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');

const hooks = initHooks();
hooks.enable();

if (!process.stdin.isTTY)
  return common.skip('no valid readable TTY available');

// test specific setup
const checkInitOpts = { init: 1 };
const checkEndedOpts = { init: 1, before: 1, after: 1, destroy: 1 };

// test code
//
// listen to stdin except on Windows
const activities = hooks.activitiesOfTypes('TTYWRAP');
assert.strictEqual(activities.length, 1);

const tty = activities[0];
assert.strictEqual(tty.type, 'TTYWRAP');
assert.strictEqual(typeof tty.uid, 'number');
assert.strictEqual(typeof tty.triggerAsyncId, 'number');
checkInvocations(tty, checkInitOpts, 'when tty created');

const delayedOnCloseHandler = common.mustCall(() => {
  checkInvocations(tty, checkEndedOpts, 'when tty ended');
});
process.stdin.on('error', (err) => assert.fail(err));
process.stdin.on('close', common.mustCall(() =>
  tick(2, delayedOnCloseHandler),
));
process.stdin.destroy();
checkInvocations(tty, checkInitOpts, 'when tty.end() was invoked');

process.on('exit', () => {
  hooks.disable();
  hooks.sanityCheck('TTYWRAP');
  checkInvocations(tty, checkEndedOpts, 'when process exits');
});
                                                                                                                                                      node-23.7.0/test/async-hooks/test-udpsendwrap.js                                                    0000664 0000000 0000000 00000003064 14746647661 0021644 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --test-udp-no-try-send
'use strict';

const common = require('../common');
const assert = require('assert');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');
const dgram = require('dgram');

const hooks = initHooks();

hooks.enable();
let send;

const sock = dgram
  .createSocket('udp4')
  .on('listening', common.mustCall(onlistening))
  .bind();

function onlistening() {
  sock.send(
    Buffer.alloc(2), 0, 2, sock.address().port,
    undefined, common.mustCall(onsent));

  // Init not called synchronously because dns lookup always wraps
  // callback in a next tick even if no lookup is needed
  // TODO (trevnorris) submit patch to fix creation of tick objects and instead
  // create the send wrap synchronously.
  assert.strictEqual(hooks.activitiesOfTypes('UDPSENDWRAP').length, 0);
}

function onsent() {
  const as = hooks.activitiesOfTypes('UDPSENDWRAP');
  send = as[0];

  assert.strictEqual(as.length, 1);
  assert.strictEqual(send.type, 'UDPSENDWRAP');
  assert.strictEqual(typeof send.uid, 'number');
  assert.strictEqual(typeof send.triggerAsyncId, 'number');
  checkInvocations(send, { init: 1, before: 1 }, 'when message sent');

  sock.close(common.mustCall(onsockClosed));
}

function onsockClosed() {
  checkInvocations(send, { init: 1, before: 1, after: 1 }, 'when sock closed');
}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  hooks.sanityCheck('UDPSENDWRAP');
  checkInvocations(send, { init: 1, before: 1, after: 1, destroy: 1 },
                   'when process exits');
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/test/async-hooks/test-udpwrap.js                                                        0000664 0000000 0000000 00000002001 14746647661 0020760 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const tick = require('../common/tick');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');
const dgram = require('dgram');

const hooks = initHooks();

hooks.enable();
const sock = dgram.createSocket('udp4');

const as = hooks.activitiesOfTypes('UDPWRAP');
const udpwrap = as[0];
assert.strictEqual(as.length, 1);
assert.strictEqual(udpwrap.type, 'UDPWRAP');
assert.strictEqual(typeof udpwrap.uid, 'number');
assert.strictEqual(typeof udpwrap.triggerAsyncId, 'number');
checkInvocations(udpwrap, { init: 1 }, 'after dgram.createSocket call');

sock.close(common.mustCall(onsockClosed));

function onsockClosed() {
  checkInvocations(udpwrap, { init: 1 }, 'when socket is closed');
  tick(2);
}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  hooks.sanityCheck('UDPWRAP');
  checkInvocations(udpwrap, { init: 1, destroy: 1 },
                   'when process exits');
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/test/async-hooks/test-unhandled-exception-valid-ids.js                                  0000664 0000000 0000000 00000000440 14746647661 0025113 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const initHooks = require('./init-hooks');

const hooks = initHooks();
hooks.enable();

setImmediate(() => {
  throw new Error();
});

setTimeout(() => {
  throw new Error();
}, 1);

process.on('uncaughtException', common.mustCall(2));
                                                                                                                                                                                                                                node-23.7.0/test/async-hooks/test-unhandled-rejection-context.js                                    0000664 0000000 0000000 00000001312 14746647661 0024706 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

const assert = require('assert');
const initHooks = require('./init-hooks');
const async_hooks = require('async_hooks');
const { isMainThread } = require('worker_threads');

if (!isMainThread) {
  common.skip('Worker bootstrapping works differently -> different async IDs');
}

const promiseAsyncIds = [];
const hooks = initHooks({
  oninit(asyncId, type) {
    if (type === 'PROMISE') {
      promiseAsyncIds.push(asyncId);
    }
  },
});

hooks.enable();
Promise.reject();

process.on('unhandledRejection', common.mustCall(() => {
  assert.strictEqual(promiseAsyncIds.length, 1);
  assert.strictEqual(async_hooks.executionAsyncId(), promiseAsyncIds[0]);
}));
                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/async-hooks/test-writewrap.js                                                      0000664 0000000 0000000 00000005245 14746647661 0021337 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
const assert = require('assert');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');
const net = require('net');

const hooks = initHooks();
hooks.enable();

//
// Creating server and listening on port
//
const server = net.createServer()
  .on('listening', common.mustCall(onlistening))
  .on('connection', common.mustCall(onconnection))
  .listen(0);

assert.strictEqual(hooks.activitiesOfTypes('WRITEWRAP').length, 0);

function onlistening() {
  assert.strictEqual(hooks.activitiesOfTypes('WRITEWRAP').length, 0);
  //
  // Creating client and connecting it to server
  //
  net
    .connect(server.address().port)
    .on('connect', common.mustCall(onconnect));

  assert.strictEqual(hooks.activitiesOfTypes('WRITEWRAP').length, 0);
}

function checkDestroyedWriteWraps(n, stage) {
  const as = hooks.activitiesOfTypes('WRITEWRAP');
  assert.strictEqual(as.length, n,
                     `${as.length} out of ${n} WRITEWRAPs when ${stage}`);

  function checkValidWriteWrap(w) {
    assert.strictEqual(w.type, 'WRITEWRAP');
    assert.strictEqual(typeof w.uid, 'number');
    assert.strictEqual(typeof w.triggerAsyncId, 'number');

    checkInvocations(w, { init: 1 }, `when ${stage}`);
  }
  as.forEach(checkValidWriteWrap);
}

function onconnection(conn) {
  conn.write('hi');  // Let the client know we're ready.
  conn.resume();
  //
  // Server received client connection
  //
  checkDestroyedWriteWraps(0, 'server got connection');
}

function onconnect() {
  //
  // Client connected to server
  //
  checkDestroyedWriteWraps(0, 'client connected');

  this.once('data', common.mustCall(ondata));
}

function ondata() {
  //
  // Writing data to client socket
  //
  const write = () => {
    let writeFinished = false;
    this.write('f'.repeat(1280000), () => {
      writeFinished = true;
    });
    process.nextTick(() => {
      if (writeFinished) {
        // Synchronous finish, write more data immediately.
        writeFinished = false;
        write();
      } else {
        // Asynchronous write; this is what we are here for.
        onafterwrite(this);
      }
    });
  };
  write();
}

function onafterwrite(self) {
  checkDestroyedWriteWraps(1, 'client destroyed');
  self.end();

  checkDestroyedWriteWraps(1, 'client destroyed');

  //
  // Closing server
  //
  server.close(common.mustCall(onserverClosed));
  checkDestroyedWriteWraps(1, 'server closing');
}

function onserverClosed() {
  checkDestroyedWriteWraps(1, 'server closed');
}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  hooks.sanityCheck('WRITEWRAP');
  checkDestroyedWriteWraps(1, 'process exits');
}
                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/test/async-hooks/test-zlib.zlib-binding.deflate.js                                      0000664 0000000 0000000 00000004263 14746647661 0024224 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        // Flags: --expose-internals
'use strict';

const common = require('../common');
const assert = require('assert');
const initHooks = require('./init-hooks');
const { checkInvocations } = require('./hook-checks');

const hooks = initHooks();

hooks.enable();
const { internalBinding } = require('internal/test/binding');
const { Zlib } = internalBinding('zlib');
const constants = require('zlib').constants;

const handle = new Zlib(constants.DEFLATE);

const as = hooks.activitiesOfTypes('ZLIB');
assert.strictEqual(as.length, 1);
const hdl = as[0];
assert.strictEqual(hdl.type, 'ZLIB');
assert.strictEqual(typeof hdl.uid, 'number');
assert.strictEqual(typeof hdl.triggerAsyncId, 'number');
checkInvocations(hdl, { init: 1 }, 'when created handle');

// Store all buffers together so that they do not get
// garbage collected.
const buffers = {
  writeResult: new Uint32Array(2),
  dictionary: new Uint8Array(0),
  inBuf: new Uint8Array([0x78]),
  outBuf: new Uint8Array(1),
};

handle.init(
  constants.Z_DEFAULT_WINDOWBITS,
  constants.Z_MIN_LEVEL,
  constants.Z_DEFAULT_MEMLEVEL,
  constants.Z_DEFAULT_STRATEGY,
  buffers.writeResult,
  function processCallback() { this.cb(); },
  buffers.dictionary,
);
checkInvocations(hdl, { init: 1 }, 'when initialized handle');

let count = 2;
handle.cb = common.mustCall(onwritten, 2);
handle.write(true, buffers.inBuf, 0, 1, buffers.outBuf, 0, 1);
checkInvocations(hdl, { init: 1 }, 'when invoked write() on handle');

function onwritten() {
  if (--count) {
    // first write
    checkInvocations(hdl, { init: 1, before: 1 },
                     'when wrote to handle the first time');
    handle.write(true, buffers.inBuf, 0, 1, buffers.outBuf, 0, 1);
  } else {
    // second write
    checkInvocations(hdl, { init: 1, before: 2, after: 1 },
                     'when wrote to handle the second time');
  }
}

process.on('exit', onexit);

function onexit() {
  hooks.disable();
  hooks.sanityCheck('ZLIB');
  // TODO: destroy never called here even with large amounts of ticks
  // is that correct?
  checkInvocations(hdl, { init: 1, before: 2, after: 2 }, 'when process exits');

  // Do something with `buffers` to keep them alive until here.
  buffers.buffers = buffers;
}
                                                                                                                                                                                                                                                                                                                                             node-23.7.0/test/async-hooks/testcfg.py                                                             0000664 0000000 0000000 00000000312 14746647661 0017777 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        import sys, os
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))
import testpy

def GetConfiguration(context, root):
  return testpy.ParallelTestConfiguration(context, root, 'async-hooks')
                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/async-hooks/verify-graph.js                                                        0000664 0000000 0000000 00000007146 14746647661 0020743 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const assert = require('assert');
const util = require('util');

function findInGraph(graph, type, n) {
  let found = 0;
  for (let i = 0; i < graph.length; i++) {
    const node = graph[i];
    if (node.type === type) found++;
    if (found === n) return node;
  }
}

function pruneTickObjects(activities) {
  // Remove one TickObject on each pass until none is left anymore
  // not super efficient, but simplest especially to handle
  // multiple TickObjects in a row
  const tickObject = {
    found: true,
    index: null,
    data: null,
  };

  if (!Array.isArray(activities))
    return activities;

  while (tickObject.found) {
    for (let i = 0; i < activities.length; i++) {
      if (activities[i].type === 'TickObject') {
        tickObject.index = i;
        break;
      } else if (i + 1 >= activities.length) {
        tickObject.found = false;
      }
    }

    if (tickObject.found) {
      // Point all triggerAsyncIds that point to the tickObject
      // to its triggerAsyncId and finally remove it from the activities
      tickObject.data = activities[tickObject.index];
      const triggerId = {
        new: tickObject.data.triggerAsyncId,
        old: tickObject.data.uid,
      };

      activities.forEach(function repointTriggerId(x) {
        if (x.triggerAsyncId === triggerId.old)
          x.triggerAsyncId = triggerId.new;
      });

      activities.splice(tickObject.index, 1);
    }
  }
  return activities;
}

module.exports = function verifyGraph(hooks, graph) {
  pruneTickObjects(hooks);

  // Map actual ids to standin ids defined in the graph
  const idtouid = {};
  const uidtoid = {};
  const typeSeen = {};
  const errors = [];

  const activities = pruneTickObjects(hooks.activities);
  activities.forEach(processActivity);

  function processActivity(x) {
    typeSeen[x.type] ||= 0;
    typeSeen[x.type]++;

    const node = findInGraph(graph, x.type, typeSeen[x.type]);
    if (node == null) return;

    idtouid[node.id] = x.uid;
    uidtoid[x.uid] = node.id;
    if (node.triggerAsyncId == null) return;

    const tid = idtouid[node.triggerAsyncId];
    if (x.triggerAsyncId === tid) return;

    errors.push({
      id: node.id,
      expectedTid: node.triggerAsyncId,
      actualTid: uidtoid[x.triggerAsyncId],
    });
  }

  if (errors.length) {
    errors.forEach((x) =>
      console.error(
        `'${x.id}' expected to be triggered by '${x.expectedTid}', ` +
        `but was triggered by '${x.actualTid}' instead.`,
      ),
    );
  }
  assert.strictEqual(errors.length, 0);

  // Verify that all expected types are present (but more/others are allowed)
  const expTypes = { __proto__: null };
  for (let i = 0; i < graph.length; i++) {
    expTypes[graph[i].type] ??= 0;
    expTypes[graph[i].type]++;
  }

  for (const type in expTypes) {
    assert.ok(typeSeen[type] >= expTypes[type],
              `Type '${type}': expecting: ${expTypes[type]} ` +
              `found: ${typeSeen[type]}`);
  }
};

//
// Helper to generate the input to the verifyGraph tests
//
function inspect(obj, depth) {
  console.error(util.inspect(obj, false, depth || 5, true));
}

module.exports.printGraph = function printGraph(hooks) {
  const ids = {};
  const uidtoid = {};
  const activities = pruneTickObjects(hooks.activities);
  const graph = [];
  activities.forEach(processNode);

  function processNode(x) {
    const key = x.type.replace(/WRAP/, '').toLowerCase();
    ids[key] ||= 1;
    const id = `${key}:${ids[key]++}`;
    uidtoid[x.uid] = id;
    const triggerAsyncId = uidtoid[x.triggerAsyncId] || null;
    graph.push({ type: x.type, id, triggerAsyncId });
  }
  inspect(graph);
};
                                                                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/test/benchmark/                                                                         0000775 0000000 0000000 00000000000 14746647661 0015466 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/benchmark/benchmark.status                                                         0000664 0000000 0000000 00000000742 14746647661 0020670 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        prefix benchmark

# To mark a test as flaky, list the test name in the appropriate section
# below, without ".js", followed by ": PASS,FLAKY". Example:
# sample-test                       : PASS,FLAKY

[true] # This section applies to all platforms

# https://github.com/nodejs/node/issues/52690
test-benchmark-crypto: PASS, FLAKY

[$system==win32]

[$system==linux]

[$system==macos]

[$system==solaris] # Also applies to SmartOS

[$system==freebsd]

[$system==aix]

[$arch==arm]

                              node-23.7.0/test/benchmark/test-bechmark-readline.js                                                0000664 0000000 0000000 00000000234 14746647661 0022335 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('readline', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/benchmark/test-benchmark-assert.js                                                 0000664 0000000 0000000 00000000363 14746647661 0022234 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

// Minimal test for assert benchmarks. This makes sure the benchmarks aren't
// completely broken but nothing more than that.

const runBenchmark = require('../common/benchmark');

runBenchmark('assert');
                                                                                                                                                                                                                                                                             node-23.7.0/test/benchmark/test-benchmark-async-hooks.js                                            0000664 0000000 0000000 00000000442 14746647661 0023167 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

if (!common.enoughTestMem)
  common.skip('Insufficient memory for async_hooks benchmark test');

const runBenchmark = require('../common/benchmark');

runBenchmark('async_hooks');
                                                                                                                                                                                                                              node-23.7.0/test/benchmark/test-benchmark-blob.js                                                   0000664 0000000 0000000 00000000230 14746647661 0021642 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('blob', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/benchmark/test-benchmark-buffer.js                                                 0000664 0000000 0000000 00000000233 14746647661 0022200 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('buffers', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/test/benchmark/test-benchmark-child-process.js                                          0000664 0000000 0000000 00000000241 14746647661 0023465 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('child_process', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                                                                                                                                                                                                                                                                                                               node-23.7.0/test/benchmark/test-benchmark-cluster.js                                                0000664 0000000 0000000 00000000165 14746647661 0022414 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('cluster');
                                                                                                                                                                                                                                                                                                                                                                                                           node-23.7.0/test/benchmark/test-benchmark-crypto.js                                                 0000664 0000000 0000000 00000000526 14746647661 0022254 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

const { getFips } = require('crypto');

if (getFips()) {
  common.skip('some benchmarks are FIPS-incompatible');
}

const runBenchmark = require('../common/benchmark');

runBenchmark('crypto', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                                                                                                                          node-23.7.0/test/benchmark/test-benchmark-dgram.js                                                  0000664 0000000 0000000 00000000360 14746647661 0022022 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

// Dgram benchmarks use hardcoded ports. Thus, this test can not be run in
// parallel with tests that choose random ports.

runBenchmark('dgram');
                                                                                                                                                                                                                                                                                node-23.7.0/test/benchmark/test-benchmark-dns.js                                                    0000664 0000000 0000000 00000000247 14746647661 0021520 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('dns', { ...process.env, NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/test/benchmark/test-benchmark-domain.js                                                 0000664 0000000 0000000 00000000164 14746647661 0022201 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('domain');
                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/test/benchmark/test-benchmark-es.js                                                     0000664 0000000 0000000 00000000226 14746647661 0021340 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('es', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/test/benchmark/test-benchmark-esm.js                                                    0000664 0000000 0000000 00000000227 14746647661 0021516 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('esm', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/test/benchmark/test-benchmark-events.js                                                 0000664 0000000 0000000 00000000232 14746647661 0022232 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('events', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/benchmark/test-benchmark-fs.js                                                     0000664 0000000 0000000 00000000324 14746647661 0021340 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');
const runBenchmark = require('../common/benchmark');

const tmpdir = require('../common/tmpdir');
tmpdir.refresh();

runBenchmark('fs', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                                                                                                                                                                                                                                                            node-23.7.0/test/benchmark/test-benchmark-http.js                                                   0000664 0000000 0000000 00000000677 14746647661 0021722 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (!common.enoughTestMem)
  common.skip('Insufficient memory for HTTP benchmark test');

// Because the http benchmarks use hardcoded ports, this should be in sequential
// rather than parallel to make sure it does not conflict with tests that choose
// random available ports.

const runBenchmark = require('../common/benchmark');

runBenchmark('http', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                 node-23.7.0/test/benchmark/test-benchmark-http2.js                                                  0000664 0000000 0000000 00000000772 14746647661 0022000 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
if (!common.hasCrypto)
  common.skip('missing crypto');

if (!common.enoughTestMem)
  common.skip('Insufficient memory for HTTP/2 benchmark test');

// Because the http benchmarks use hardcoded ports, this should be in sequential
// rather than parallel to make sure it does not conflict with tests that choose
// random available ports.

const runBenchmark = require('../common/benchmark');

runBenchmark('http2', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
      node-23.7.0/test/benchmark/test-benchmark-mime.js                                                   0000664 0000000 0000000 00000000230 14746647661 0021653 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('mime', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/benchmark/test-benchmark-misc.js                                                   0000664 0000000 0000000 00000000230 14746647661 0021657 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('misc', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/benchmark/test-benchmark-module.js                                                 0000664 0000000 0000000 00000000164 14746647661 0022217 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('module');
                                                                                                                                                                                                                                                                                                                                                                                                            node-23.7.0/test/benchmark/test-benchmark-napi.js                                                   0000664 0000000 0000000 00000000742 14746647661 0021663 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (common.isWindows) {
  common.skip('vcbuild.bat doesn\'t build the n-api benchmarks yet');
}

const { isMainThread } = require('worker_threads');

if (!isMainThread) {
  common.skip('addons are not supported in workers');
}

if (common.isDebug) {
  common.skip('benchmark does not work with debug build yet');
}
const runBenchmark = require('../common/benchmark');

runBenchmark('napi', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                              node-23.7.0/test/benchmark/test-benchmark-net.js                                                    0000664 0000000 0000000 00000000524 14746647661 0021520 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

// Because the net benchmarks use hardcoded ports, this should be in sequential
// rather than parallel to make sure it does not conflict with tests that choose
// random available ports.

const runBenchmark = require('../common/benchmark');

runBenchmark('net', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                                                                                                                            node-23.7.0/test/benchmark/test-benchmark-os.js                                                     0000664 0000000 0000000 00000000160 14746647661 0021347 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('os');
                                                                                                                                                                                                                                                                                                                                                                                                                node-23.7.0/test/benchmark/test-benchmark-path.js                                                   0000664 0000000 0000000 00000000230 14746647661 0021660 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('path', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/benchmark/test-benchmark-process.js                                                0000664 0000000 0000000 00000000233 14746647661 0022405 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('process', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/test/benchmark/test-benchmark-querystring.js                                            0000664 0000000 0000000 00000000237 14746647661 0023327 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('querystring', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                                                                                                                                                                                                                                                                                                                 node-23.7.0/test/benchmark/test-benchmark-streams.js                                                0000664 0000000 0000000 00000000233 14746647661 0022405 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('streams', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                                                                                                                                                                                                                                                                                                                     node-23.7.0/test/benchmark/test-benchmark-string_decoder.js                                         0000664 0000000 0000000 00000000174 14746647661 0023726 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('string_decoder');
                                                                                                                                                                                                                                                                                                                                                                                                    node-23.7.0/test/benchmark/test-benchmark-timers.js                                                 0000664 0000000 0000000 00000000232 14746647661 0022231 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('timers', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                                                                                                                                                                                                                                                                                                                      node-23.7.0/test/benchmark/test-benchmark-tls.js                                                    0000664 0000000 0000000 00000000765 14746647661 0021543 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (!common.hasCrypto)
  common.skip('missing crypto');

if (!common.enoughTestMem)
  common.skip('Insufficient memory for TLS benchmark test');

// Because the TLS benchmarks use hardcoded ports, this should be in sequential
// rather than parallel to make sure it does not conflict with tests that choose
// random available ports.

const runBenchmark = require('../common/benchmark');

runBenchmark('tls', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
           node-23.7.0/test/benchmark/test-benchmark-url.js                                                    0000664 0000000 0000000 00000000227 14746647661 0021534 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('url', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/test/benchmark/test-benchmark-util.js                                                   0000664 0000000 0000000 00000000230 14746647661 0021701 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('util', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/benchmark/test-benchmark-v8.js                                                     0000664 0000000 0000000 00000000226 14746647661 0021266 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('v8', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/test/benchmark/test-benchmark-validators.js                                             0000664 0000000 0000000 00000000366 14746647661 0023106 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

// Minimal test for assert benchmarks. This makes sure the benchmarks aren't
// completely broken but nothing more than that.
const runBenchmark = require('../common/benchmark');

runBenchmark('validators');
                                                                                                                                                                                                                                                                          node-23.7.0/test/benchmark/test-benchmark-vm.js                                                     0000664 0000000 0000000 00000000226 14746647661 0021353 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('vm', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                                                                                                                                                                                                                                                                                                                          node-23.7.0/test/benchmark/test-benchmark-websocket.js                                              0000664 0000000 0000000 00000000412 14746647661 0022714 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');
if (!common.enoughTestMem)
  common.skip('Insufficient memory for Websocket benchmark test');

const runBenchmark = require('../common/benchmark');

runBenchmark('websocket', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                                                                                                                                                                                                      node-23.7.0/test/benchmark/test-benchmark-webstreams.js                                             0000664 0000000 0000000 00000000236 14746647661 0023106 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('webstreams', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                                                                                                                                                                                                                                                                                                                  node-23.7.0/test/benchmark/test-benchmark-worker.js                                                 0000664 0000000 0000000 00000000716 14746647661 0022246 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

const common = require('../common');

if (!common.enoughTestMem)
  common.skip('Insufficient memory for Worker benchmark test');

// Because the worker benchmarks can run on different threads,
// this should be in sequential rather than parallel to make sure
// it does not conflict with tests that choose random available ports.

const runBenchmark = require('../common/benchmark');

runBenchmark('worker', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                  node-23.7.0/test/benchmark/test-benchmark-zlib.js                                                   0000664 0000000 0000000 00000000230 14746647661 0021664 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        'use strict';

require('../common');

const runBenchmark = require('../common/benchmark');

runBenchmark('zlib', { NODEJS_BENCHMARK_ZERO_ALLOWED: 1 });
                                                                                                                                                                                                                                                                                                                                                                        node-23.7.0/test/benchmark/testcfg.py                                                               0000664 0000000 0000000 00000000306 14746647661 0017476 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        import sys, os
sys.path.append(os.path.join(os.path.dirname(__file__), '..'))
import testpy

def GetConfiguration(context, root):
  return testpy.SimpleTestConfiguration(context, root, 'benchmark')
                                                                                                                                                                                                                                                                                                                          node-23.7.0/test/cctest/                                                                            0000775 0000000 0000000 00000000000 14746647661 0015021 5                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        node-23.7.0/test/cctest/node_test_fixture.cc                                                        0000664 0000000 0000000 00000003511 14746647661 0021062 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "node_test_fixture.h"
#include "cppgc/platform.h"

ArrayBufferUniquePtr NodeZeroIsolateTestFixture::allocator{nullptr, nullptr};
uv_loop_t NodeZeroIsolateTestFixture::current_loop;
NodePlatformUniquePtr NodeZeroIsolateTestFixture::platform;
TracingAgentUniquePtr NodeZeroIsolateTestFixture::tracing_agent;
bool NodeZeroIsolateTestFixture::node_initialized = false;
v8::Isolate* NodeTestFixture::isolate_ = nullptr;
node::IsolateData* EnvironmentTestFixture::isolate_data_ = nullptr;

void NodeTestEnvironment::SetUp() {
  NodeZeroIsolateTestFixture::tracing_agent =
      std::make_unique<node::tracing::Agent>();
  node::tracing::TraceEventHelper::SetAgent(
      NodeZeroIsolateTestFixture::tracing_agent.get());
  node::tracing::TracingController* tracing_controller =
      NodeZeroIsolateTestFixture::tracing_agent->GetTracingController();
  static constexpr int kV8ThreadPoolSize = 4;
  NodeZeroIsolateTestFixture::platform.reset(
      new node::NodePlatform(kV8ThreadPoolSize, tracing_controller));
  v8::V8::InitializePlatform(NodeZeroIsolateTestFixture::platform.get());
#ifdef V8_ENABLE_SANDBOX
  ASSERT_TRUE(v8::V8::InitializeSandbox());
#endif
  cppgc::InitializeProcess(
      NodeZeroIsolateTestFixture::platform->GetPageAllocator());

  // Before initializing V8, disable the --freeze-flags-after-init flag, so
  // individual tests can set their own flags.
  v8::V8::SetFlagsFromString("--no-freeze-flags-after-init");

  v8::V8::Initialize();
}

void NodeTestEnvironment::TearDown() {
  cppgc::ShutdownProcess();
  v8::V8::Dispose();
  v8::V8::DisposePlatform();
  NodeZeroIsolateTestFixture::platform->Shutdown();
  NodeZeroIsolateTestFixture::platform.reset(nullptr);
  NodeZeroIsolateTestFixture::tracing_agent.reset(nullptr);
}

::testing::Environment* const node_env =
::testing::AddGlobalTestEnvironment(new NodeTestEnvironment());
                                                                                                                                                                                       node-23.7.0/test/cctest/node_test_fixture.h                                                         0000664 0000000 0000000 00000012147 14746647661 0020731 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #ifndef TEST_CCTEST_NODE_TEST_FIXTURE_H_
#define TEST_CCTEST_NODE_TEST_FIXTURE_H_

#include <cstdlib>
#include <memory>
#include "gtest/gtest.h"
#include "node.h"
#include "node_platform.h"
#include "node_internals.h"
#include "env-inl.h"
#include "util-inl.h"
#include "v8.h"
#include "libplatform/libplatform.h"

struct Argv {
 public:
  Argv() : Argv({"node", "-p", "process.version"}) {}

  Argv(const std::initializer_list<const char*> &args) {
    nr_args_ = args.size();
    int total_len = 0;
    for (auto it = args.begin(); it != args.end(); ++it) {
      total_len += strlen(*it) + 1;
    }
    argv_ = static_cast<char**>(malloc(nr_args_ * sizeof(char*)));
    argv_[0] = static_cast<char*>(malloc(total_len));
    int i = 0;
    int offset = 0;
    for (auto it = args.begin(); it != args.end(); ++it, ++i) {
      int len = strlen(*it) + 1;
      snprintf(argv_[0] + offset, len, "%s", *it);
      // Skip argv_[0] as it points the correct location already
      if (i > 0) {
        argv_[i] = argv_[0] + offset;
      }
      offset += len;
    }
  }

  ~Argv() {
    free(argv_[0]);
    free(argv_);
  }

  int nr_args() const {
    return nr_args_;
  }

  char** operator*() const {
    return argv_;
  }

 private:
  char** argv_;
  int nr_args_;
};

using ArrayBufferUniquePtr = std::unique_ptr<node::ArrayBufferAllocator,
      decltype(&node::FreeArrayBufferAllocator)>;
using TracingAgentUniquePtr = std::unique_ptr<node::tracing::Agent>;
using NodePlatformUniquePtr = std::unique_ptr<node::NodePlatform>;

class NodeTestEnvironment final : public ::testing::Environment {
 public:
  NodeTestEnvironment()  = default;
  void SetUp() override;
  void TearDown() override;
};

class NodeTestFixture;

class NodeZeroIsolateTestFixture : public ::testing::Test {
 protected:
  static uv_loop_t current_loop;
  static bool node_initialized;
  static ArrayBufferUniquePtr allocator;
  static NodePlatformUniquePtr platform;
  static TracingAgentUniquePtr tracing_agent;

  static void SetUpTestCase() {
    if (!node_initialized) {
      node_initialized = true;
      uv_os_unsetenv("NODE_OPTIONS");
      std::vector<std::string> argv { "cctest" };
      std::vector<std::string> exec_argv;
      std::vector<std::string> errors;

      int exitcode = node::InitializeNodeWithArgs(&argv, &exec_argv, &errors);
      CHECK_EQ(exitcode, 0);
      CHECK(errors.empty());
    }
    CHECK_EQ(0, uv_loop_init(&current_loop));
  }

  static void TearDownTestCase() {
    while (uv_loop_alive(&current_loop)) {
      uv_run(&current_loop, UV_RUN_ONCE);
    }
    CHECK_EQ(0, uv_loop_close(&current_loop));
  }

  void SetUp() override {
    allocator = ArrayBufferUniquePtr(node::CreateArrayBufferAllocator(),
                                     &node::FreeArrayBufferAllocator);
  }

  friend NodeTestEnvironment;
  friend NodeTestFixture;
};


class NodeTestFixture : public NodeZeroIsolateTestFixture {
 protected:
  static v8::Isolate* isolate_;

  void SetUp() override {
    NodeZeroIsolateTestFixture::SetUp();
    isolate_ = NewIsolate(allocator.get(), &current_loop, platform.get());
    CHECK_NOT_NULL(isolate_);
    isolate_->Enter();
  }

  void TearDown() override {
    platform->DrainTasks(isolate_);
    isolate_->Exit();
    platform->UnregisterIsolate(isolate_);
    isolate_->Dispose();
    isolate_ = nullptr;
    NodeZeroIsolateTestFixture::TearDown();
  }
};


class EnvironmentTestFixture : public NodeTestFixture {
 protected:
  static node::IsolateData* isolate_data_;

  void SetUp() override {
    NodeTestFixture::SetUp();
    isolate_data_ = node::CreateIsolateData(NodeTestFixture::isolate_,
                                            &NodeTestFixture::current_loop,
                                            platform.get());
    CHECK_NE(nullptr, isolate_data_);
  }

  void TearDown() override {
    node::FreeIsolateData(isolate_data_);
    NodeTestFixture::TearDown();
  }

  class Env {
   public:
    Env(const v8::HandleScope& handle_scope,
        const Argv& argv,
        node::EnvironmentFlags::Flags flags =
            node::EnvironmentFlags::kDefaultFlags) {
      auto isolate = handle_scope.GetIsolate();
      context_ = node::NewContext(isolate);
      CHECK(!context_.IsEmpty());
      context_->Enter();

      std::vector<std::string> args(*argv, *argv + 1);
      std::vector<std::string> exec_args(*argv, *argv + 1);
      DCHECK_EQ(EnvironmentTestFixture::isolate_data_->isolate(), isolate);
      environment_ =
          node::CreateEnvironment(EnvironmentTestFixture::isolate_data_,
                                  context_,
                                  args,
                                  exec_args,
                                  flags);
      CHECK_NE(nullptr, environment_);
    }

    ~Env() {
      node::FreeEnvironment(environment_);
      context_->Exit();
    }

    node::Environment* operator*() const {
      return environment_;
    }

    v8::Local<v8::Context> context()  const {
      return context_;
    }

    Env(const Env&) = delete;
    Env& operator=(const Env&) = delete;

   private:
    v8::Local<v8::Context> context_;
    node::Environment* environment_;
  };
};

#endif  // TEST_CCTEST_NODE_TEST_FIXTURE_H_
                                                                                                                                                                                                                                                                                                                                                                                                                         node-23.7.0/test/cctest/test_aliased_buffer.cc                                                      0000664 0000000 0000000 00000016471 14746647661 0021333 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "aliased_buffer-inl.h"
#include "node_test_fixture.h"
#include "v8.h"

using node::AliasedBufferBase;

class AliasBufferTest : public NodeTestFixture {};

template <class NativeT>
void CreateOracleValues(std::vector<NativeT>* buf) {
  for (size_t i = 0, j = buf->size(); i < buf->size(); i++, j--) {
    (*buf)[i] = static_cast<NativeT>(j);
  }
}

template <class NativeT, class V8T>
void WriteViaOperator(AliasedBufferBase<NativeT, V8T>* aliasedBuffer,
                      const std::vector<NativeT>& oracle) {
  // write through the API
  for (size_t i = 0; i < oracle.size(); i++) {
    (*aliasedBuffer)[i] = oracle[i];
  }
}

template <class NativeT, class V8T>
void WriteViaSetValue(AliasedBufferBase<NativeT, V8T>* aliasedBuffer,
                      const std::vector<NativeT>& oracle) {
  // write through the API
  for (size_t i = 0; i < oracle.size(); i++) {
    aliasedBuffer->SetValue(i, oracle[i]);
  }
}

template <class NativeT, class V8T>
void ReadAndValidate(v8::Isolate* isolate,
                     v8::Local<v8::Context> context,
                     AliasedBufferBase<NativeT, V8T>* aliasedBuffer,
                     const std::vector<NativeT>& oracle) {
  // read through the API
  for (size_t i = 0; i < oracle.size(); i++) {
    NativeT v1 = (*aliasedBuffer)[i];
    NativeT v2 = aliasedBuffer->GetValue(i);
    EXPECT_TRUE(v1 == oracle[i]);
    EXPECT_TRUE(v2 == oracle[i]);
  }

  // validate size of JS Buffer
  EXPECT_TRUE(aliasedBuffer->GetJSArray()->Length() == oracle.size());
  EXPECT_TRUE(
    aliasedBuffer->GetJSArray()->ByteLength() ==
    (oracle.size() * sizeof(NativeT)));

  // validate operator * and GetBuffer are the same
  EXPECT_TRUE(aliasedBuffer->GetNativeBuffer() == *(*aliasedBuffer));

  // read through the JS API
  for (size_t i = 0; i < oracle.size(); i++) {
    v8::Local<V8T> v8TypedArray = aliasedBuffer->GetJSArray();
    v8::MaybeLocal<v8::Value> v = v8TypedArray->Get(context, i);
    EXPECT_TRUE(v.IsEmpty() == false);
    v8::Local<v8::Value> v2 = v.ToLocalChecked();
    EXPECT_TRUE(v2->IsNumber());
    v8::MaybeLocal<v8::Number> v3 = v2->ToNumber(context);
    v8::Local<v8::Number> v4 = v3.ToLocalChecked();
    NativeT actualValue = static_cast<NativeT>(v4->Value());
    EXPECT_TRUE(actualValue == oracle[i]);
  }
}

template <class NativeT, class V8T>
void ReadWriteTest(v8::Isolate* isolate) {
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> context = v8::Context::New(isolate);
  v8::Context::Scope context_scope(context);

  const size_t size = 100;
  AliasedBufferBase<NativeT, V8T> ab(isolate, size);
  std::vector<NativeT> oracle(size);
  CreateOracleValues(&oracle);
  WriteViaOperator(&ab, oracle);
  ReadAndValidate(isolate, context, &ab, oracle);

  WriteViaSetValue(&ab, oracle);

  // validate copy constructor
  {
    AliasedBufferBase<NativeT, V8T> ab2(ab);
    ReadAndValidate(isolate, context, &ab2, oracle);
  }
  ReadAndValidate(isolate, context, &ab, oracle);
}

template <
    class NativeT_A, class V8T_A,
    class NativeT_B, class V8T_B,
    class NativeT_C, class V8T_C>
void SharedBufferTest(
    v8::Isolate* isolate,
    size_t count_A,
    size_t count_B,
    size_t count_C) {
  v8::Isolate::Scope isolate_scope(isolate);
  v8::HandleScope handle_scope(isolate);
  v8::Local<v8::Context> context = v8::Context::New(isolate);
  v8::Context::Scope context_scope(context);

  size_t sizeInBytes_A = count_A * sizeof(NativeT_A);
  size_t sizeInBytes_B = count_B * sizeof(NativeT_B);
  size_t sizeInBytes_C = count_C * sizeof(NativeT_C);

  AliasedBufferBase<uint8_t, v8::Uint8Array> rootBuffer(
      isolate, sizeInBytes_A + sizeInBytes_B + sizeInBytes_C);
  AliasedBufferBase<NativeT_A, V8T_A> ab_A(isolate, 0, count_A, rootBuffer);
  AliasedBufferBase<NativeT_B, V8T_B> ab_B(
      isolate, sizeInBytes_A, count_B, rootBuffer);
  AliasedBufferBase<NativeT_C, V8T_C> ab_C(
      isolate, sizeInBytes_A + sizeInBytes_B, count_C, rootBuffer);

  std::vector<NativeT_A> oracle_A(count_A);
  std::vector<NativeT_B> oracle_B(count_B);
  std::vector<NativeT_C> oracle_C(count_C);
  CreateOracleValues(&oracle_A);
  CreateOracleValues(&oracle_B);
  CreateOracleValues(&oracle_C);

  WriteViaOperator(&ab_A, oracle_A);
  WriteViaOperator(&ab_B, oracle_B);
  WriteViaOperator(&ab_C, oracle_C);

  ReadAndValidate(isolate, context, &ab_A, oracle_A);
  ReadAndValidate(isolate, context, &ab_B, oracle_B);
  ReadAndValidate(isolate, context, &ab_C, oracle_C);

  WriteViaSetValue(&ab_A, oracle_A);
  WriteViaSetValue(&ab_B, oracle_B);
  WriteViaSetValue(&ab_C, oracle_C);

  ReadAndValidate(isolate, context, &ab_A, oracle_A);
  ReadAndValidate(isolate, context, &ab_B, oracle_B);
  ReadAndValidate(isolate, context, &ab_C, oracle_C);
}

TEST_F(AliasBufferTest, Uint8Array) {
  ReadWriteTest<uint8_t, v8::Uint8Array>(isolate_);
}

TEST_F(AliasBufferTest, Int8Array) {
  ReadWriteTest<int8_t, v8::Int8Array>(isolate_);
}

TEST_F(AliasBufferTest, Uint16Array) {
  ReadWriteTest<uint16_t, v8::Uint16Array>(isolate_);
}

TEST_F(AliasBufferTest, Int16Array) {
  ReadWriteTest<int16_t, v8::Int16Array>(isolate_);
}

TEST_F(AliasBufferTest, Uint32Array) {
  ReadWriteTest<uint32_t, v8::Uint32Array>(isolate_);
}

TEST_F(AliasBufferTest, Int32Array) {
  ReadWriteTest<int32_t, v8::Int32Array>(isolate_);
}

TEST_F(AliasBufferTest, Float32Array) {
  ReadWriteTest<float, v8::Float32Array>(isolate_);
}

TEST_F(AliasBufferTest, Float64Array) {
  ReadWriteTest<double, v8::Float64Array>(isolate_);
}

TEST_F(AliasBufferTest, SharedArrayBuffer1) {
  SharedBufferTest<
      uint32_t, v8::Uint32Array,
      double, v8::Float64Array,
      int8_t, v8::Int8Array>(isolate_, 100, 80, 8);
}

TEST_F(AliasBufferTest, SharedArrayBuffer2) {
  SharedBufferTest<
      double, v8::Float64Array,
      int8_t, v8::Int8Array,
      double, v8::Float64Array>(isolate_, 100, 8, 8);
}

TEST_F(AliasBufferTest, SharedArrayBuffer3) {
  SharedBufferTest<
      int8_t, v8::Int8Array,
      int8_t, v8::Int8Array,
      double, v8::Float64Array>(isolate_, 1, 7, 8);
}

TEST_F(AliasBufferTest, SharedArrayBuffer4) {
  SharedBufferTest<
      int8_t, v8::Int8Array,
      int8_t, v8::Int8Array,
      int32_t, v8::Int32Array>(isolate_, 1, 3, 1);
}

TEST_F(AliasBufferTest, OperatorOverloads) {
  v8::Isolate::Scope isolate_scope(isolate_);
  v8::HandleScope handle_scope(isolate_);
  v8::Local<v8::Context> context = v8::Context::New(isolate_);
  v8::Context::Scope context_scope(context);
  const size_t size = 10;
  AliasedBufferBase<uint32_t, v8::Uint32Array> ab{isolate_, size};

  EXPECT_EQ(static_cast<uint32_t>(1), ab[0] = 1);
  EXPECT_EQ(static_cast<uint32_t>(4), ab[0] += 3);
  EXPECT_EQ(static_cast<uint32_t>(2), ab[0] -= 2);
  EXPECT_EQ(static_cast<uint32_t>(-2), -ab[0]);
}

TEST_F(AliasBufferTest, OperatorOverloadsRefs) {
  v8::Isolate::Scope isolate_scope(isolate_);
  v8::HandleScope handle_scope(isolate_);
  v8::Local<v8::Context> context = v8::Context::New(isolate_);
  v8::Context::Scope context_scope(context);
  AliasedBufferBase<uint32_t, v8::Uint32Array> ab{isolate_, 2};
  using Reference = AliasedBufferBase<uint32_t, v8::Uint32Array>::Reference;
  Reference ref = ab[0];
  Reference ref_value = ab[1] = 2;

  EXPECT_EQ(static_cast<uint32_t>(2), ref = ref_value);
  EXPECT_EQ(static_cast<uint32_t>(4), ref += ref_value);
  EXPECT_EQ(static_cast<uint32_t>(2), ref -= ref_value);
  EXPECT_EQ(static_cast<uint32_t>(-2), -ref);
}
                                                                                                                                                                                                       node-23.7.0/test/cctest/test_base64.cc                                                              0000664 0000000 0000000 00000015472 14746647661 0017464 0                                                                                                    ustar 00root                            root                            0000000 0000000                                                                                                                                                                        #include "nbytes.h"
#include "simdutf.h"
#include "util-inl.h"

#include <cstddef>
#include <cstring>

#include "gtest/gtest.h"

TEST(Base64Test, Encode) {
  auto test = [](const char* string, const char* base64_string) {
    const size_t len = strlen(base64_string);
    const size_t slen = strlen(string);
    char* const buffer = new char[len + 1];
    buffer[len] = 0;
    CHECK(len >= simdutf::base64_length_from_binary(slen) &&
          "not enough space provided for base64 encode");
    simdutf::binary_to_base64(string, slen, buffer);
    EXPECT_STREQ(base64_string, buffer);
    delete[] buffer;
  };

  test("a", "YQ==");
  test("ab", "YWI=");
  test("abc", "YWJj");
  test("abcd", "YWJjZA==");
  test("abcde", "YWJjZGU=");
  test("abcdef", "YWJjZGVm");

  test("Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do "
       "eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut "
       "enim ad minim veniam, quis nostrud exercitation ullamco laboris "
       "nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in "
       "reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla "
       "pariatur. Excepteur sint occaecat cupidatat non proident, sunt in "
       "culpa qui officia deserunt mollit anim id est laborum.",

       "TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2Npbmcg"
       "ZWxpdCwgc2VkIGRvIGVpdXNtb2QgdGVtcG9yIGluY2lkaWR1bnQgdXQgbGFib3JlIGV0"
       "IGRvbG9yZSBtYWduYSBhbGlxdWEuIFV0IGVuaW0gYWQgbWluaW0gdmVuaWFtLCBxdWlz"
       "IG5vc3RydWQgZXhlcmNpdGF0aW9uIHVsbGFtY28gbGFib3JpcyBuaXNpIHV0IGFsaXF1"
       "aXAgZXggZWEgY29tbW9kbyBjb25zZXF1YXQuIER1aXMgYXV0ZSBpcnVyZSBkb2xvciBp"
       "biByZXByZWhlbmRlcml0IGluIHZvbHVwdGF0ZSB2ZWxpdCBlc3NlIGNpbGx1bSBkb2xv"
       "cmUgZXUgZnVnaWF0IG51bGxhIHBhcmlhdHVyLiBFeGNlcHRldXIgc2ludCBvY2NhZWNh"
       "dCBjdXBpZGF0YXQgbm9uIHByb2lkZW50LCBzdW50IGluIGN1bHBhIHF1aSBvZmZpY2lh"
       "IGRlc2VydW50IG1vbGxpdCBhbmltIGlkIGVzdCBsYWJvcnVtLg==");
}

TEST(Base64Test, EncodeURL) {
  auto test = [](const char* string, const char* base64_string) {
    const size_t len = strlen(base64_string);
    const size_t slen = strlen(string);
    char* const buffer = new char[len + 1];
    buffer[len] = 0;
    CHECK(len >=
              simdutf::base64_length_from_binary(slen, simdutf::base64_url) &&
          "not enough space provided for base64 encode");
    simdutf::binary_to_base64(string, slen, buffer, simdutf::base64_url);
    EXPECT_STREQ(base64_string, buffer);
    delete[] buffer;
  };

  test("\x68\xd9\x16\x25\x5c\x1e\x40\x92\x