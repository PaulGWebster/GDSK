result of getSymbolOfNode
                var symbol = getSymbolOfNode(node);
                var localSymbol = node.localSymbol || symbol;
                // Since the javascript won't do semantic analysis like typescript,
                // if the javascript file comes before the typescript file and both contain same name functions,
                // checkFunctionOrConstructorSymbol wouldn't be called if we didnt ignore javascript function.
                var firstDeclaration = (_a = localSymbol.declarations) === null || _a === void 0 ? void 0 : _a.find(
                // Get first non javascript function declaration
                function (declaration) { return declaration.kind === node.kind && !(declaration.flags & 262144 /* NodeFlags.JavaScriptFile */); });
                // Only type check the symbol once
                if (node === firstDeclaration) {
                    checkFunctionOrConstructorSymbol(localSymbol);
                }
                if (symbol.parent) {
                    // run check on export symbol to check that modifiers agree across all exported declarations
                    checkFunctionOrConstructorSymbol(symbol);
                }
            }
            var body = node.kind === 168 /* SyntaxKind.MethodSignature */ ? undefined : node.body;
            checkSourceElement(body);
            checkAllCodePathsInNonVoidFunctionReturnOrThrow(node, getReturnTypeFromAnnotation(node));
            addLazyDiagnostic(checkFunctionOrMethodDeclarationDiagnostics);
            // A js function declaration can have a @type tag instead of a return type node, but that type must have a call signature
            if (ts.isInJSFile(node)) {
                var typeTag = ts.getJSDocTypeTag(node);
                if (typeTag && typeTag.typeExpression && !getContextualCallSignature(getTypeFromTypeNode(typeTag.typeExpression), node)) {
                    error(typeTag.typeExpression.type, ts.Diagnostics.The_type_of_a_function_declaration_must_match_the_function_s_signature);
                }
            }
            function checkFunctionOrMethodDeclarationDiagnostics() {
                if (!ts.getEffectiveReturnTypeNode(node)) {
                    // Report an implicit any error if there is no body, no explicit return type, and node is not a private method
                    // in an ambient context
                    if (ts.nodeIsMissing(body) && !isPrivateWithinAmbient(node)) {
                        reportImplicitAny(node, anyType);
                    }
                    if (functionFlags & 1 /* FunctionFlags.Generator */ && ts.nodeIsPresent(body)) {
                        // A generator with a body and no type annotation can still cause errors. It can error if the
                        // yielded values have no common supertype, or it can give an implicit any error if it has no
                        // yielded values. The only way to trigger these errors is to try checking its return type.
                        getReturnTypeOfSignature(getSignatureFromDeclaration(node));
                    }
                }
            }
        }
        function registerForUnusedIdentifiersCheck(node) {
            addLazyDiagnostic(registerForUnusedIdentifiersCheckDiagnostics);
            function registerForUnusedIdentifiersCheckDiagnostics() {
                // May be in a call such as getTypeOfNode that happened to call this. But potentiallyUnusedIdentifiers is only defined in the scope of `checkSourceFile`.
                var sourceFile = ts.getSourceFileOfNode(node);
                var potentiallyUnusedIdentifiers = allPotentiallyUnusedIdentifiers.get(sourceFile.path);
                if (!potentiallyUnusedIdentifiers) {
                    potentiallyUnusedIdentifiers = [];
                    allPotentiallyUnusedIdentifiers.set(sourceFile.path, potentiallyUnusedIdentifiers);
                }
                // TODO: GH#22580
                // Debug.assert(addToSeen(seenPotentiallyUnusedIdentifiers, getNodeId(node)), "Adding potentially-unused identifier twice");
                potentiallyUnusedIdentifiers.push(node);
            }
        }
        function checkUnusedIdentifiers(potentiallyUnusedIdentifiers, addDiagnostic) {
            for (var _i = 0, potentiallyUnusedIdentifiers_1 = potentiallyUnusedIdentifiers; _i < potentiallyUnusedIdentifiers_1.length; _i++) {
                var node = potentiallyUnusedIdentifiers_1[_i];
                switch (node.kind) {
                    case 257 /* SyntaxKind.ClassDeclaration */:
                    case 226 /* SyntaxKind.ClassExpression */:
                        checkUnusedClassMembers(node, addDiagnostic);
                        checkUnusedTypeParameters(node, addDiagnostic);
                        break;
                    case 305 /* SyntaxKind.SourceFile */:
                    case 261 /* SyntaxKind.ModuleDeclaration */:
                    case 235 /* SyntaxKind.Block */:
                    case 263 /* SyntaxKind.CaseBlock */:
                    case 242 /* SyntaxKind.ForStatement */:
                    case 243 /* SyntaxKind.ForInStatement */:
                    case 244 /* SyntaxKind.ForOfStatement */:
                        checkUnusedLocalsAndParameters(node, addDiagnostic);
                        break;
                    case 171 /* SyntaxKind.Constructor */:
                    case 213 /* SyntaxKind.FunctionExpression */:
                    case 256 /* SyntaxKind.FunctionDeclaration */:
                    case 214 /* SyntaxKind.ArrowFunction */:
                    case 169 /* SyntaxKind.MethodDeclaration */:
                    case 172 /* SyntaxKind.GetAccessor */:
                    case 173 /* SyntaxKind.SetAccessor */:
                        if (node.body) { // Don't report unused parameters in overloads
                            checkUnusedLocalsAndParameters(node, addDiagnostic);
                        }
                        checkUnusedTypeParameters(node, addDiagnostic);
                        break;
                    case 168 /* SyntaxKind.MethodSignature */:
                    case 174 /* SyntaxKind.CallSignature */:
                    case 175 /* SyntaxKind.ConstructSignature */:
                    case 179 /* SyntaxKind.FunctionType */:
                    case 180 /* SyntaxKind.ConstructorType */:
                    case 259 /* SyntaxKind.TypeAliasDeclaration */:
                    case 258 /* SyntaxKind.InterfaceDeclaration */:
                        checkUnusedTypeParameters(node, addDiagnostic);
                        break;
                    case 190 /* SyntaxKind.InferType */:
                        checkUnusedInferTypeParameter(node, addDiagnostic);
                        break;
                    default:
                        ts.Debug.assertNever(node, "Node should not have been registered for unused identifiers check");
                }
            }
        }
        function errorUnusedLocal(declaration, name, addDiagnostic) {
            var node = ts.getNameOfDeclaration(declaration) || declaration;
            var message = isTypeDeclaration(declaration) ? ts.Diagnostics._0_is_declared_but_never_used : ts.Diagnostics._0_is_declared_but_its_value_is_never_read;
            addDiagnostic(declaration, 0 /* UnusedKind.Local */, ts.createDiagnosticForNode(node, message, name));
        }
        function isIdentifierThatStartsWithUnderscore(node) {
            return ts.isIdentifier(node) && ts.idText(node).charCodeAt(0) === 95 /* CharacterCodes._ */;
        }
        function checkUnusedClassMembers(node, addDiagnostic) {
            for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                var member = _a[_i];
                switch (member.kind) {
                    case 169 /* SyntaxKind.MethodDeclaration */:
                    case 167 /* SyntaxKind.PropertyDeclaration */:
                    case 172 /* SyntaxKind.GetAccessor */:
                    case 173 /* SyntaxKind.SetAccessor */:
                        if (member.kind === 173 /* SyntaxKind.SetAccessor */ && member.symbol.flags & 32768 /* SymbolFlags.GetAccessor */) {
                            // Already would have reported an error on the getter.
                            break;
                        }
                        var symbol = getSymbolOfNode(member);
                        if (!symbol.isReferenced
                            && (ts.hasEffectiveModifier(member, 8 /* ModifierFlags.Private */) || ts.isNamedDeclaration(member) && ts.isPrivateIdentifier(member.name))
                            && !(member.flags & 16777216 /* NodeFlags.Ambient */)) {
                            addDiagnostic(member, 0 /* UnusedKind.Local */, ts.createDiagnosticForNode(member.name, ts.Diagnostics._0_is_declared_but_its_value_is_never_read, symbolToString(symbol)));
                        }
                        break;
                    case 171 /* SyntaxKind.Constructor */:
                        for (var _b = 0, _c = member.parameters; _b < _c.length; _b++) {
                            var parameter = _c[_b];
                            if (!parameter.symbol.isReferenced && ts.hasSyntacticModifier(parameter, 8 /* ModifierFlags.Private */)) {
                                addDiagnostic(parameter, 0 /* UnusedKind.Local */, ts.createDiagnosticForNode(parameter.name, ts.Diagnostics.Property_0_is_declared_but_its_value_is_never_read, ts.symbolName(parameter.symbol)));
                            }
                        }
                        break;
                    case 176 /* SyntaxKind.IndexSignature */:
                    case 234 /* SyntaxKind.SemicolonClassElement */:
                    case 170 /* SyntaxKind.ClassStaticBlockDeclaration */:
                        // Can't be private
                        break;
                    default:
                        ts.Debug.fail("Unexpected class member");
                }
            }
        }
        function checkUnusedInferTypeParameter(node, addDiagnostic) {
            var typeParameter = node.typeParameter;
            if (isTypeParameterUnused(typeParameter)) {
                addDiagnostic(node, 1 /* UnusedKind.Parameter */, ts.createDiagnosticForNode(node, ts.Diagnostics._0_is_declared_but_its_value_is_never_read, ts.idText(typeParameter.name)));
            }
        }
        function checkUnusedTypeParameters(node, addDiagnostic) {
            // Only report errors on the last declaration for the type parameter container;
            // this ensures that all uses have been accounted for.
            var declarations = getSymbolOfNode(node).declarations;
            if (!declarations || ts.last(declarations) !== node)
                return;
            var typeParameters = ts.getEffectiveTypeParameterDeclarations(node);
            var seenParentsWithEveryUnused = new ts.Set();
            for (var _i = 0, typeParameters_3 = typeParameters; _i < typeParameters_3.length; _i++) {
                var typeParameter = typeParameters_3[_i];
                if (!isTypeParameterUnused(typeParameter))
                    continue;
                var name = ts.idText(typeParameter.name);
                var parent = typeParameter.parent;
                if (parent.kind !== 190 /* SyntaxKind.InferType */ && parent.typeParameters.every(isTypeParameterUnused)) {
                    if (ts.tryAddToSet(seenParentsWithEveryUnused, parent)) {
                        var sourceFile = ts.getSourceFileOfNode(parent);
                        var range = ts.isJSDocTemplateTag(parent)
                            // Whole @template tag
                            ? ts.rangeOfNode(parent)
                            // Include the `<>` in the error message
                            : ts.rangeOfTypeParameters(sourceFile, parent.typeParameters);
                        var only = parent.typeParameters.length === 1;
                        //TODO: following line is possible reason for bug #41974, unusedTypeParameters_TemplateTag
                        var message = only ? ts.Diagnostics._0_is_declared_but_its_value_is_never_read : ts.Diagnostics.All_type_parameters_are_unused;
                        var arg0 = only ? name : undefined;
                        addDiagnostic(typeParameter, 1 /* UnusedKind.Parameter */, ts.createFileDiagnostic(sourceFile, range.pos, range.end - range.pos, message, arg0));
                    }
                }
                else {
                    //TODO: following line is possible reason for bug #41974, unusedTypeParameters_TemplateTag
                    addDiagnostic(typeParameter, 1 /* UnusedKind.Parameter */, ts.createDiagnosticForNode(typeParameter, ts.Diagnostics._0_is_declared_but_its_value_is_never_read, name));
                }
            }
        }
        function isTypeParameterUnused(typeParameter) {
            return !(getMergedSymbol(typeParameter.symbol).isReferenced & 262144 /* SymbolFlags.TypeParameter */) && !isIdentifierThatStartsWithUnderscore(typeParameter.name);
        }
        function addToGroup(map, key, value, getKey) {
            var keyString = String(getKey(key));
            var group = map.get(keyString);
            if (group) {
                group[1].push(value);
            }
            else {
                map.set(keyString, [key, [value]]);
            }
        }
        function tryGetRootParameterDeclaration(node) {
            return ts.tryCast(ts.getRootDeclaration(node), ts.isParameter);
        }
        function isValidUnusedLocalDeclaration(declaration) {
            if (ts.isBindingElement(declaration)) {
                if (ts.isObjectBindingPattern(declaration.parent)) {
                    /**
                     * ignore starts with underscore names _
                     * const { a: _a } = { a: 1 }
                     */
                    return !!(declaration.propertyName && isIdentifierThatStartsWithUnderscore(declaration.name));
                }
                return isIdentifierThatStartsWithUnderscore(declaration.name);
            }
            return ts.isAmbientModule(declaration) ||
                (ts.isVariableDeclaration(declaration) && ts.isForInOrOfStatement(declaration.parent.parent) || isImportedDeclaration(declaration)) && isIdentifierThatStartsWithUnderscore(declaration.name);
        }
        function checkUnusedLocalsAndParameters(nodeWithLocals, addDiagnostic) {
            // Ideally we could use the ImportClause directly as a key, but must wait until we have full ES6 maps. So must store key along with value.
            var unusedImports = new ts.Map();
            var unusedDestructures = new ts.Map();
            var unusedVariables = new ts.Map();
            nodeWithLocals.locals.forEach(function (local) {
                // If it's purely a type parameter, ignore, will be checked in `checkUnusedTypeParameters`.
                // If it's a type parameter merged with a parameter, check if the parameter-side is used.
                if (local.flags & 262144 /* SymbolFlags.TypeParameter */ ? !(local.flags & 3 /* SymbolFlags.Variable */ && !(local.isReferenced & 3 /* SymbolFlags.Variable */)) : local.isReferenced || local.exportSymbol) {
                    return;
                }
                if (local.declarations) {
                    for (var _i = 0, _a = local.declarations; _i < _a.length; _i++) {
                        var declaration = _a[_i];
                        if (isValidUnusedLocalDeclaration(declaration)) {
                            continue;
                        }
                        if (isImportedDeclaration(declaration)) {
                            addToGroup(unusedImports, importClauseFromImported(declaration), declaration, getNodeId);
                        }
                        else if (ts.isBindingElement(declaration) && ts.isObjectBindingPattern(declaration.parent)) {
                            // In `{ a, ...b }, `a` is considered used since it removes a property from `b`. `b` may still be unused though.
                            var lastElement = ts.last(declaration.parent.elements);
                            if (declaration === lastElement || !ts.last(declaration.parent.elements).dotDotDotToken) {
                                addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId);
                            }
                        }
                        else if (ts.isVariableDeclaration(declaration)) {
                            addToGroup(unusedVariables, declaration.parent, declaration, getNodeId);
                        }
                        else {
                            var parameter = local.valueDeclaration && tryGetRootParameterDeclaration(local.valueDeclaration);
                            var name = local.valueDeclaration && ts.getNameOfDeclaration(local.valueDeclaration);
                            if (parameter && name) {
                                if (!ts.isParameterPropertyDeclaration(parameter, parameter.parent) && !ts.parameterIsThisKeyword(parameter) && !isIdentifierThatStartsWithUnderscore(name)) {
                                    if (ts.isBindingElement(declaration) && ts.isArrayBindingPattern(declaration.parent)) {
                                        addToGroup(unusedDestructures, declaration.parent, declaration, getNodeId);
                                    }
                                    else {
                                        addDiagnostic(parameter, 1 /* UnusedKind.Parameter */, ts.createDiagnosticForNode(name, ts.Diagnostics._0_is_declared_but_its_value_is_never_read, ts.symbolName(local)));
                                    }
                                }
                            }
                            else {
                                errorUnusedLocal(declaration, ts.symbolName(local), addDiagnostic);
                            }
                        }
                    }
                }
            });
            unusedImports.forEach(function (_a) {
                var importClause = _a[0], unuseds = _a[1];
                var importDecl = importClause.parent;
                var nDeclarations = (importClause.name ? 1 : 0) +
                    (importClause.namedBindings ?
                        (importClause.namedBindings.kind === 268 /* SyntaxKind.NamespaceImport */ ? 1 : importClause.namedBindings.elements.length)
                        : 0);
                if (nDeclarations === unuseds.length) {
                    addDiagnostic(importDecl, 0 /* UnusedKind.Local */, unuseds.length === 1
                        ? ts.createDiagnosticForNode(importDecl, ts.Diagnostics._0_is_declared_but_its_value_is_never_read, ts.idText(ts.first(unuseds).name))
                        : ts.createDiagnosticForNode(importDecl, ts.Diagnostics.All_imports_in_import_declaration_are_unused));
                }
                else {
                    for (var _i = 0, unuseds_1 = unuseds; _i < unuseds_1.length; _i++) {
                        var unused = unuseds_1[_i];
                        errorUnusedLocal(unused, ts.idText(unused.name), addDiagnostic);
                    }
                }
            });
            unusedDestructures.forEach(function (_a) {
                var bindingPattern = _a[0], bindingElements = _a[1];
                var kind = tryGetRootParameterDeclaration(bindingPattern.parent) ? 1 /* UnusedKind.Parameter */ : 0 /* UnusedKind.Local */;
                if (bindingPattern.elements.length === bindingElements.length) {
                    if (bindingElements.length === 1 && bindingPattern.parent.kind === 254 /* SyntaxKind.VariableDeclaration */ && bindingPattern.parent.parent.kind === 255 /* SyntaxKind.VariableDeclarationList */) {
                        addToGroup(unusedVariables, bindingPattern.parent.parent, bindingPattern.parent, getNodeId);
                    }
                    else {
                        addDiagnostic(bindingPattern, kind, bindingElements.length === 1
                            ? ts.createDiagnosticForNode(bindingPattern, ts.Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(ts.first(bindingElements).name))
                            : ts.createDiagnosticForNode(bindingPattern, ts.Diagnostics.All_destructured_elements_are_unused));
                    }
                }
                else {
                    for (var _i = 0, bindingElements_1 = bindingElements; _i < bindingElements_1.length; _i++) {
                        var e = bindingElements_1[_i];
                        addDiagnostic(e, kind, ts.createDiagnosticForNode(e, ts.Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(e.name)));
                    }
                }
            });
            unusedVariables.forEach(function (_a) {
                var declarationList = _a[0], declarations = _a[1];
                if (declarationList.declarations.length === declarations.length) {
                    addDiagnostic(declarationList, 0 /* UnusedKind.Local */, declarations.length === 1
                        ? ts.createDiagnosticForNode(ts.first(declarations).name, ts.Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(ts.first(declarations).name))
                        : ts.createDiagnosticForNode(declarationList.parent.kind === 237 /* SyntaxKind.VariableStatement */ ? declarationList.parent : declarationList, ts.Diagnostics.All_variables_are_unused));
                }
                else {
                    for (var _i = 0, declarations_6 = declarations; _i < declarations_6.length; _i++) {
                        var decl = declarations_6[_i];
                        addDiagnostic(decl, 0 /* UnusedKind.Local */, ts.createDiagnosticForNode(decl, ts.Diagnostics._0_is_declared_but_its_value_is_never_read, bindingNameText(decl.name)));
                    }
                }
            });
        }
        function bindingNameText(name) {
            switch (name.kind) {
                case 79 /* SyntaxKind.Identifier */:
                    return ts.idText(name);
                case 202 /* SyntaxKind.ArrayBindingPattern */:
                case 201 /* SyntaxKind.ObjectBindingPattern */:
                    return bindingNameText(ts.cast(ts.first(name.elements), ts.isBindingElement).name);
                default:
                    return ts.Debug.assertNever(name);
            }
        }
        function isImportedDeclaration(node) {
            return node.kind === 267 /* SyntaxKind.ImportClause */ || node.kind === 270 /* SyntaxKind.ImportSpecifier */ || node.kind === 268 /* SyntaxKind.NamespaceImport */;
        }
        function importClauseFromImported(decl) {
            return decl.kind === 267 /* SyntaxKind.ImportClause */ ? decl : decl.kind === 268 /* SyntaxKind.NamespaceImport */ ? decl.parent : decl.parent.parent;
        }
        function checkBlock(node) {
            // Grammar checking for SyntaxKind.Block
            if (node.kind === 235 /* SyntaxKind.Block */) {
                checkGrammarStatementInAmbientContext(node);
            }
            if (ts.isFunctionOrModuleBlock(node)) {
                var saveFlowAnalysisDisabled = flowAnalysisDisabled;
                ts.forEach(node.statements, checkSourceElement);
                flowAnalysisDisabled = saveFlowAnalysisDisabled;
            }
            else {
                ts.forEach(node.statements, checkSourceElement);
            }
            if (node.locals) {
                registerForUnusedIdentifiersCheck(node);
            }
        }
        function checkCollisionWithArgumentsInGeneratedCode(node) {
            // no rest parameters \ declaration context \ overload - no codegen impact
            if (languageVersion >= 2 /* ScriptTarget.ES2015 */ || !ts.hasRestParameter(node) || node.flags & 16777216 /* NodeFlags.Ambient */ || ts.nodeIsMissing(node.body)) {
                return;
            }
            ts.forEach(node.parameters, function (p) {
                if (p.name && !ts.isBindingPattern(p.name) && p.name.escapedText === argumentsSymbol.escapedName) {
                    errorSkippedOn("noEmit", p, ts.Diagnostics.Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters);
                }
            });
        }
        /**
         * Checks whether an {@link Identifier}, in the context of another {@link Node}, would collide with a runtime value
         * of {@link name} in an outer scope. This is used to check for collisions for downlevel transformations that
         * require names like `Object`, `Promise`, `Reflect`, `require`, `exports`, etc.
         */
        function needCollisionCheckForIdentifier(node, identifier, name) {
            if ((identifier === null || identifier === void 0 ? void 0 : identifier.escapedText) !== name) {
                return false;
            }
            if (node.kind === 167 /* SyntaxKind.PropertyDeclaration */ ||
                node.kind === 166 /* SyntaxKind.PropertySignature */ ||
                node.kind === 169 /* SyntaxKind.MethodDeclaration */ ||
                node.kind === 168 /* SyntaxKind.MethodSignature */ ||
                node.kind === 172 /* SyntaxKind.GetAccessor */ ||
                node.kind === 173 /* SyntaxKind.SetAccessor */ ||
                node.kind === 296 /* SyntaxKind.PropertyAssignment */) {
                // it is ok to have member named '_super', '_this', `Promise`, etc. - member access is always qualified
                return false;
            }
            if (node.flags & 16777216 /* NodeFlags.Ambient */) {
                // ambient context - no codegen impact
                return false;
            }
            if (ts.isImportClause(node) || ts.isImportEqualsDeclaration(node) || ts.isImportSpecifier(node)) {
                // type-only imports do not require collision checks against runtime values.
                if (ts.isTypeOnlyImportOrExportDeclaration(node)) {
                    return false;
                }
            }
            var root = ts.getRootDeclaration(node);
            if (ts.isParameter(root) && ts.nodeIsMissing(root.parent.body)) {
                // just an overload - no codegen impact
                return false;
            }
            return true;
        }
        // this function will run after checking the source file so 'CaptureThis' is correct for all nodes
        function checkIfThisIsCapturedInEnclosingScope(node) {
            ts.findAncestor(node, function (current) {
                if (getNodeCheckFlags(current) & 4 /* NodeCheckFlags.CaptureThis */) {
                    var isDeclaration_1 = node.kind !== 79 /* SyntaxKind.Identifier */;
                    if (isDeclaration_1) {
                        error(ts.getNameOfDeclaration(node), ts.Diagnostics.Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference);
                    }
                    else {
                        error(node, ts.Diagnostics.Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference);
                    }
                    return true;
                }
                return false;
            });
        }
        function checkIfNewTargetIsCapturedInEnclosingScope(node) {
            ts.findAncestor(node, function (current) {
                if (getNodeCheckFlags(current) & 8 /* NodeCheckFlags.CaptureNewTarget */) {
                    var isDeclaration_2 = node.kind !== 79 /* SyntaxKind.Identifier */;
                    if (isDeclaration_2) {
                        error(ts.getNameOfDeclaration(node), ts.Diagnostics.Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference);
                    }
                    else {
                        error(node, ts.Diagnostics.Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference);
                    }
                    return true;
                }
                return false;
            });
        }
        function checkCollisionWithRequireExportsInGeneratedCode(node, name) {
            // No need to check for require or exports for ES6 modules and later
            if (moduleKind >= ts.ModuleKind.ES2015 && !(moduleKind >= ts.ModuleKind.Node16 && ts.getSourceFileOfNode(node).impliedNodeFormat === ts.ModuleKind.CommonJS)) {
                return;
            }
            if (!name || !needCollisionCheckForIdentifier(node, name, "require") && !needCollisionCheckForIdentifier(node, name, "exports")) {
                return;
            }
            // Uninstantiated modules shouldnt do this check
            if (ts.isModuleDeclaration(node) && ts.getModuleInstanceState(node) !== 1 /* ModuleInstanceState.Instantiated */) {
                return;
            }
            // In case of variable declaration, node.parent is variable statement so look at the variable statement's parent
            var parent = getDeclarationContainer(node);
            if (parent.kind === 305 /* SyntaxKind.SourceFile */ && ts.isExternalOrCommonJsModule(parent)) {
                // If the declaration happens to be in external module, report error that require and exports are reserved keywords
                errorSkippedOn("noEmit", name, ts.Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module, ts.declarationNameToString(name), ts.declarationNameToString(name));
            }
        }
        function checkCollisionWithGlobalPromiseInGeneratedCode(node, name) {
            if (!name || languageVersion >= 4 /* ScriptTarget.ES2017 */ || !needCollisionCheckForIdentifier(node, name, "Promise")) {
                return;
            }
            // Uninstantiated modules shouldnt do this check
            if (ts.isModuleDeclaration(node) && ts.getModuleInstanceState(node) !== 1 /* ModuleInstanceState.Instantiated */) {
                return;
            }
            // In case of variable declaration, node.parent is variable statement so look at the variable statement's parent
            var parent = getDeclarationContainer(node);
            if (parent.kind === 305 /* SyntaxKind.SourceFile */ && ts.isExternalOrCommonJsModule(parent) && parent.flags & 2048 /* NodeFlags.HasAsyncFunctions */) {
                // If the declaration happens to be in external module, report error that Promise is a reserved identifier.
                errorSkippedOn("noEmit", name, ts.Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions, ts.declarationNameToString(name), ts.declarationNameToString(name));
            }
        }
        function recordPotentialCollisionWithWeakMapSetInGeneratedCode(node, name) {
            if (languageVersion <= 8 /* ScriptTarget.ES2021 */
                && (needCollisionCheckForIdentifier(node, name, "WeakMap") || needCollisionCheckForIdentifier(node, name, "WeakSet"))) {
                potentialWeakMapSetCollisions.push(node);
            }
        }
        function checkWeakMapSetCollision(node) {
            var enclosingBlockScope = ts.getEnclosingBlockScopeContainer(node);
            if (getNodeCheckFlags(enclosingBlockScope) & 67108864 /* NodeCheckFlags.ContainsClassWithPrivateIdentifiers */) {
                ts.Debug.assert(ts.isNamedDeclaration(node) && ts.isIdentifier(node.name) && typeof node.name.escapedText === "string", "The target of a WeakMap/WeakSet collision check should be an identifier");
                errorSkippedOn("noEmit", node, ts.Diagnostics.Compiler_reserves_name_0_when_emitting_private_identifier_downlevel, node.name.escapedText);
            }
        }
        function recordPotentialCollisionWithReflectInGeneratedCode(node, name) {
            if (name && languageVersion >= 2 /* ScriptTarget.ES2015 */ && languageVersion <= 8 /* ScriptTarget.ES2021 */
                && needCollisionCheckForIdentifier(node, name, "Reflect")) {
                potentialReflectCollisions.push(node);
            }
        }
        function checkReflectCollision(node) {
            var hasCollision = false;
            if (ts.isClassExpression(node)) {
                // ClassExpression names don't contribute to their containers, but do matter for any of their block-scoped members.
                for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                    var member = _a[_i];
                    if (getNodeCheckFlags(member) & 134217728 /* NodeCheckFlags.ContainsSuperPropertyInStaticInitializer */) {
                        hasCollision = true;
                        break;
                    }
                }
            }
            else if (ts.isFunctionExpression(node)) {
                // FunctionExpression names don't contribute to their containers, but do matter for their contents
                if (getNodeCheckFlags(node) & 134217728 /* NodeCheckFlags.ContainsSuperPropertyInStaticInitializer */) {
                    hasCollision = true;
                }
            }
            else {
                var container = ts.getEnclosingBlockScopeContainer(node);
                if (container && getNodeCheckFlags(container) & 134217728 /* NodeCheckFlags.ContainsSuperPropertyInStaticInitializer */) {
                    hasCollision = true;
                }
            }
            if (hasCollision) {
                ts.Debug.assert(ts.isNamedDeclaration(node) && ts.isIdentifier(node.name), "The target of a Reflect collision check should be an identifier");
                errorSkippedOn("noEmit", node, ts.Diagnostics.Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializers, ts.declarationNameToString(node.name), "Reflect");
            }
        }
        function checkCollisionsForDeclarationName(node, name) {
            if (!name)
                return;
            checkCollisionWithRequireExportsInGeneratedCode(node, name);
            checkCollisionWithGlobalPromiseInGeneratedCode(node, name);
            recordPotentialCollisionWithWeakMapSetInGeneratedCode(node, name);
            recordPotentialCollisionWithReflectInGeneratedCode(node, name);
            if (ts.isClassLike(node)) {
                checkTypeNameIsReserved(name, ts.Diagnostics.Class_name_cannot_be_0);
                if (!(node.flags & 16777216 /* NodeFlags.Ambient */)) {
                    checkClassNameCollisionWithObject(name);
                }
            }
            else if (ts.isEnumDeclaration(node)) {
                checkTypeNameIsReserved(name, ts.Diagnostics.Enum_name_cannot_be_0);
            }
        }
        function checkVarDeclaredNamesNotShadowed(node) {
            // - ScriptBody : StatementList
            // It is a Syntax Error if any element of the LexicallyDeclaredNames of StatementList
            // also occurs in the VarDeclaredNames of StatementList.
            // - Block : { StatementList }
            // It is a Syntax Error if any element of the LexicallyDeclaredNames of StatementList
            // also occurs in the VarDeclaredNames of StatementList.
            // Variable declarations are hoisted to the top of their function scope. They can shadow
            // block scoped declarations, which bind tighter. this will not be flagged as duplicate definition
            // by the binder as the declaration scope is different.
            // A non-initialized declaration is a no-op as the block declaration will resolve before the var
            // declaration. the problem is if the declaration has an initializer. this will act as a write to the
            // block declared value. this is fine for let, but not const.
            // Only consider declarations with initializers, uninitialized const declarations will not
            // step on a let/const variable.
            // Do not consider const and const declarations, as duplicate block-scoped declarations
            // are handled by the binder.
            // We are only looking for const declarations that step on let\const declarations from a
            // different scope. e.g.:
            //      {
            //          const x = 0; // localDeclarationSymbol obtained after name resolution will correspond to this declaration
            //          const x = 0; // symbol for this declaration will be 'symbol'
            //      }
            // skip block-scoped variables and parameters
            if ((ts.getCombinedNodeFlags(node) & 3 /* NodeFlags.BlockScoped */) !== 0 || ts.isParameterDeclaration(node)) {
                return;
            }
            // skip variable declarations that don't have initializers
            // NOTE: in ES6 spec initializer is required in variable declarations where name is binding pattern
            // so we'll always treat binding elements as initialized
            if (node.kind === 254 /* SyntaxKind.VariableDeclaration */ && !node.initializer) {
                return;
            }
            var symbol = getSymbolOfNode(node);
            if (symbol.flags & 1 /* SymbolFlags.FunctionScopedVariable */) {
                if (!ts.isIdentifier(node.name))
                    return ts.Debug.fail();
                var localDeclarationSymbol = resolveName(node, node.name.escapedText, 3 /* SymbolFlags.Variable */, /*nodeNotFoundErrorMessage*/ undefined, /*nameArg*/ undefined, /*isUse*/ false);
                if (localDeclarationSymbol &&
                    localDeclarationSymbol !== symbol &&
                    localDeclarationSymbol.flags & 2 /* SymbolFlags.BlockScopedVariable */) {
                    if (getDeclarationNodeFlagsFromSymbol(localDeclarationSymbol) & 3 /* NodeFlags.BlockScoped */) {
                        var varDeclList = ts.getAncestor(localDeclarationSymbol.valueDeclaration, 255 /* SyntaxKind.VariableDeclarationList */);
                        var container = varDeclList.parent.kind === 237 /* SyntaxKind.VariableStatement */ && varDeclList.parent.parent
                            ? varDeclList.parent.parent
                            : undefined;
                        // names of block-scoped and function scoped variables can collide only
                        // if block scoped variable is defined in the function\module\source file scope (because of variable hoisting)
                        var namesShareScope = container &&
                            (container.kind === 235 /* SyntaxKind.Block */ && ts.isFunctionLike(container.parent) ||
                                container.kind === 262 /* SyntaxKind.ModuleBlock */ ||
                                container.kind === 261 /* SyntaxKind.ModuleDeclaration */ ||
                                container.kind === 305 /* SyntaxKind.SourceFile */);
                        // here we know that function scoped variable is shadowed by block scoped one
                        // if they are defined in the same scope - binder has already reported redeclaration error
                        // otherwise if variable has an initializer - show error that initialization will fail
                        // since LHS will be block scoped name instead of function scoped
                        if (!namesShareScope) {
                            var name = symbolToString(localDeclarationSymbol);
                            error(node, ts.Diagnostics.Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1, name, name);
                        }
                    }
                }
            }
        }
        function convertAutoToAny(type) {
            return type === autoType ? anyType : type === autoArrayType ? anyArrayType : type;
        }
        // Check variable, parameter, or property declaration
        function checkVariableLikeDeclaration(node) {
            var _a;
            checkDecorators(node);
            if (!ts.isBindingElement(node)) {
                checkSourceElement(node.type);
            }
            // JSDoc `function(string, string): string` syntax results in parameters with no name
            if (!node.name) {
                return;
            }
            // For a computed property, just check the initializer and exit
            // Do not use hasDynamicName here, because that returns false for well known symbols.
            // We want to perform checkComputedPropertyName for all computed properties, including
            // well known symbols.
            if (node.name.kind === 162 /* SyntaxKind.ComputedPropertyName */) {
                checkComputedPropertyName(node.name);
                if (node.initializer) {
                    checkExpressionCached(node.initializer);
                }
            }
            if (ts.isBindingElement(node)) {
                if (ts.isObjectBindingPattern(node.parent) && node.dotDotDotToken && languageVersion < 5 /* ScriptTarget.ES2018 */) {
                    checkExternalEmitHelpers(node, 4 /* ExternalEmitHelpers.Rest */);
                }
                // check computed properties inside property names of binding elements
                if (node.propertyName && node.propertyName.kind === 162 /* SyntaxKind.ComputedPropertyName */) {
                    checkComputedPropertyName(node.propertyName);
                }
                // check private/protected variable access
                var parent = node.parent.parent;
                var parentCheckMode = node.dotDotDotToken ? 64 /* CheckMode.RestBindingElement */ : 0 /* CheckMode.Normal */;
                var parentType = getTypeForBindingElementParent(parent, parentCheckMode);
                var name = node.propertyName || node.name;
                if (parentType && !ts.isBindingPattern(name)) {
                    var exprType = getLiteralTypeFromPropertyName(name);
                    if (isTypeUsableAsPropertyName(exprType)) {
                        var nameText = getPropertyNameFromType(exprType);
                        var property = getPropertyOfType(parentType, nameText);
                        if (property) {
                            markPropertyAsReferenced(property, /*nodeForCheckWriteOnly*/ undefined, /*isSelfTypeAccess*/ false); // A destructuring is never a write-only reference.
                            checkPropertyAccessibility(node, !!parent.initializer && parent.initializer.kind === 106 /* SyntaxKind.SuperKeyword */, /*writing*/ false, parentType, property);
                        }
                    }
                }
            }
            // For a binding pattern, check contained binding elements
            if (ts.isBindingPattern(node.name)) {
                if (node.name.kind === 202 /* SyntaxKind.ArrayBindingPattern */ && languageVersion < 2 /* ScriptTarget.ES2015 */ && compilerOptions.downlevelIteration) {
                    checkExternalEmitHelpers(node, 512 /* ExternalEmitHelpers.Read */);
                }
                ts.forEach(node.name.elements, checkSourceElement);
            }
            // For a parameter declaration with an initializer, error and exit if the containing function doesn't have a body
            if (node.initializer && ts.isParameterDeclaration(node) && ts.nodeIsMissing(ts.getContainingFunction(node).body)) {
                error(node, ts.Diagnostics.A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation);
                return;
            }
            // For a binding pattern, validate the initializer and exit
            if (ts.isBindingPattern(node.name)) {
                var needCheckInitializer = node.initializer && node.parent.parent.kind !== 243 /* SyntaxKind.ForInStatement */;
                var needCheckWidenedType = node.name.elements.length === 0;
                if (needCheckInitializer || needCheckWidenedType) {
                    // Don't validate for-in initializer as it is already an error
                    var widenedType = getWidenedTypeForVariableLikeDeclaration(node);
                    if (needCheckInitializer) {
                        var initializerType = checkExpressionCached(node.initializer);
                        if (strictNullChecks && needCheckWidenedType) {
                            checkNonNullNonVoidType(initializerType, node);
                        }
                        else {
                            checkTypeAssignableToAndOptionallyElaborate(initializerType, getWidenedTypeForVariableLikeDeclaration(node), node, node.initializer);
                        }
                    }
                    // check the binding pattern with empty elements
                    if (needCheckWidenedType) {
                        if (ts.isArrayBindingPattern(node.name)) {
                            checkIteratedTypeOrElementType(65 /* IterationUse.Destructuring */, widenedType, undefinedType, node);
                        }
                        else if (strictNullChecks) {
                            checkNonNullNonVoidType(widenedType, node);
                        }
                    }
                }
                return;
            }
            // For a commonjs `const x = require`, validate the alias and exit
            var symbol = getSymbolOfNode(node);
            if (symbol.flags & 2097152 /* SymbolFlags.Alias */ && ts.isVariableDeclarationInitializedToBareOrAccessedRequire(node.kind === 203 /* SyntaxKind.BindingElement */ ? node.parent.parent : node)) {
                checkAliasSymbol(node);
                return;
            }
            var type = convertAutoToAny(getTypeOfSymbol(symbol));
            if (node === symbol.valueDeclaration) {
                // Node is the primary declaration of the symbol, just validate the initializer
                // Don't validate for-in initializer as it is already an error
                var initializer = ts.getEffectiveInitializer(node);
                if (initializer) {
                    var isJSObjectLiteralInitializer = ts.isInJSFile(node) &&
                        ts.isObjectLiteralExpression(initializer) &&
                        (initializer.properties.length === 0 || ts.isPrototypeAccess(node.name)) &&
                        !!((_a = symbol.exports) === null || _a === void 0 ? void 0 : _a.size);
                    if (!isJSObjectLiteralInitializer && node.parent.parent.kind !== 243 /* SyntaxKind.ForInStatement */) {
                        checkTypeAssignableToAndOptionallyElaborate(checkExpressionCached(initializer), type, node, initializer, /*headMessage*/ undefined);
                    }
                }
                if (symbol.declarations && symbol.declarations.length > 1) {
                    if (ts.some(symbol.declarations, function (d) { return d !== node && ts.isVariableLike(d) && !areDeclarationFlagsIdentical(d, node); })) {
                        error(node.name, ts.Diagnostics.All_declarations_of_0_must_have_identical_modifiers, ts.declarationNameToString(node.name));
                    }
                }
            }
            else {
                // Node is a secondary declaration, check that type is identical to primary declaration and check that
                // initializer is consistent with type associated with the node
                var declarationType = convertAutoToAny(getWidenedTypeForVariableLikeDeclaration(node));
                if (!isErrorType(type) && !isErrorType(declarationType) &&
                    !isTypeIdenticalTo(type, declarationType) &&
                    !(symbol.flags & 67108864 /* SymbolFlags.Assignment */)) {
                    errorNextVariableOrPropertyDeclarationMustHaveSameType(symbol.valueDeclaration, type, node, declarationType);
                }
                if (node.initializer) {
                    checkTypeAssignableToAndOptionallyElaborate(checkExpressionCached(node.initializer), declarationType, node, node.initializer, /*headMessage*/ undefined);
                }
                if (symbol.valueDeclaration && !areDeclarationFlagsIdentical(node, symbol.valueDeclaration)) {
                    error(node.name, ts.Diagnostics.All_declarations_of_0_must_have_identical_modifiers, ts.declarationNameToString(node.name));
                }
            }
            if (node.kind !== 167 /* SyntaxKind.PropertyDeclaration */ && node.kind !== 166 /* SyntaxKind.PropertySignature */) {
                // We know we don't have a binding pattern or computed name here
                checkExportsOnMergedDeclarations(node);
                if (node.kind === 254 /* SyntaxKind.VariableDeclaration */ || node.kind === 203 /* SyntaxKind.BindingElement */) {
                    checkVarDeclaredNamesNotShadowed(node);
                }
                checkCollisionsForDeclarationName(node, node.name);
            }
        }
        function errorNextVariableOrPropertyDeclarationMustHaveSameType(firstDeclaration, firstType, nextDeclaration, nextType) {
            var nextDeclarationName = ts.getNameOfDeclaration(nextDeclaration);
            var message = nextDeclaration.kind === 167 /* SyntaxKind.PropertyDeclaration */ || nextDeclaration.kind === 166 /* SyntaxKind.PropertySignature */
                ? ts.Diagnostics.Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_type_2
                : ts.Diagnostics.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2;
            var declName = ts.declarationNameToString(nextDeclarationName);
            var err = error(nextDeclarationName, message, declName, typeToString(firstType), typeToString(nextType));
            if (firstDeclaration) {
                ts.addRelatedInfo(err, ts.createDiagnosticForNode(firstDeclaration, ts.Diagnostics._0_was_also_declared_here, declName));
            }
        }
        function areDeclarationFlagsIdentical(left, right) {
            if ((left.kind === 164 /* SyntaxKind.Parameter */ && right.kind === 254 /* SyntaxKind.VariableDeclaration */) ||
                (left.kind === 254 /* SyntaxKind.VariableDeclaration */ && right.kind === 164 /* SyntaxKind.Parameter */)) {
                // Differences in optionality between parameters and variables are allowed.
                return true;
            }
            if (ts.hasQuestionToken(left) !== ts.hasQuestionToken(right)) {
                return false;
            }
            var interestingFlags = 8 /* ModifierFlags.Private */ |
                16 /* ModifierFlags.Protected */ |
                256 /* ModifierFlags.Async */ |
                128 /* ModifierFlags.Abstract */ |
                64 /* ModifierFlags.Readonly */ |
                32 /* ModifierFlags.Static */;
            return ts.getSelectedEffectiveModifierFlags(left, interestingFlags) === ts.getSelectedEffectiveModifierFlags(right, interestingFlags);
        }
        function checkVariableDeclaration(node) {
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("check" /* tracing.Phase.Check */, "checkVariableDeclaration", { kind: node.kind, pos: node.pos, end: node.end, path: node.tracingPath });
            checkGrammarVariableDeclaration(node);
            checkVariableLikeDeclaration(node);
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
        }
        function checkBindingElement(node) {
            checkGrammarBindingElement(node);
            return checkVariableLikeDeclaration(node);
        }
        function checkVariableStatement(node) {
            // Grammar checking
            if (!checkGrammarDecoratorsAndModifiers(node) && !checkGrammarVariableDeclarationList(node.declarationList))
                checkGrammarForDisallowedLetOrConstStatement(node);
            ts.forEach(node.declarationList.declarations, checkSourceElement);
        }
        function checkExpressionStatement(node) {
            // Grammar checking
            checkGrammarStatementInAmbientContext(node);
            checkExpression(node.expression);
        }
        function checkIfStatement(node) {
            // Grammar checking
            checkGrammarStatementInAmbientContext(node);
            checkTruthinessExpression(node.expression);
            checkTestingKnownTruthyCallableOrAwaitableType(node.expression, node.thenStatement);
            checkSourceElement(node.thenStatement);
            if (node.thenStatement.kind === 236 /* SyntaxKind.EmptyStatement */) {
                error(node.thenStatement, ts.Diagnostics.The_body_of_an_if_statement_cannot_be_the_empty_statement);
            }
            checkSourceElement(node.elseStatement);
        }
        function checkTestingKnownTruthyCallableOrAwaitableType(condExpr, body) {
            if (!strictNullChecks)
                return;
            helper(condExpr, body);
            while (ts.isBinaryExpression(condExpr) && condExpr.operatorToken.kind === 56 /* SyntaxKind.BarBarToken */) {
                condExpr = condExpr.left;
                helper(condExpr, body);
            }
            function helper(condExpr, body) {
                var location = ts.isBinaryExpression(condExpr) &&
                    (condExpr.operatorToken.kind === 56 /* SyntaxKind.BarBarToken */ || condExpr.operatorToken.kind === 55 /* SyntaxKind.AmpersandAmpersandToken */)
                    ? condExpr.right
                    : condExpr;
                if (ts.isModuleExportsAccessExpression(location))
                    return;
                var type = checkTruthinessExpression(location);
                var isPropertyExpressionCast = ts.isPropertyAccessExpression(location) && isTypeAssertion(location.expression);
                if (getFalsyFlags(type) || isPropertyExpressionCast)
                    return;
                // While it technically should be invalid for any known-truthy value
                // to be tested, we de-scope to functions and Promises unreferenced in
                // the block as a heuristic to identify the most common bugs. There
                // are too many false positives for values sourced from type
                // definitions without strictNullChecks otherwise.
                var callSignatures = getSignaturesOfType(type, 0 /* SignatureKind.Call */);
                var isPromise = !!getAwaitedTypeOfPromise(type);
                if (callSignatures.length === 0 && !isPromise) {
                    return;
                }
                var testedNode = ts.isIdentifier(location) ? location
                    : ts.isPropertyAccessExpression(location) ? location.name
                        : ts.isBinaryExpression(location) && ts.isIdentifier(location.right) ? location.right
                            : undefined;
                var testedSymbol = testedNode && getSymbolAtLocation(testedNode);
                if (!testedSymbol && !isPromise) {
                    return;
                }
                var isUsed = testedSymbol && ts.isBinaryExpression(condExpr.parent) && isSymbolUsedInBinaryExpressionChain(condExpr.parent, testedSymbol)
                    || testedSymbol && body && isSymbolUsedInConditionBody(condExpr, body, testedNode, testedSymbol);
                if (!isUsed) {
                    if (isPromise) {
                        errorAndMaybeSuggestAwait(location, 
                        /*maybeMissingAwait*/ true, ts.Diagnostics.This_condition_will_always_return_true_since_this_0_is_always_defined, getTypeNameForErrorDisplay(type));
                    }
                    else {
                        error(location, ts.Diagnostics.This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_instead);
                    }
                }
            }
        }
        function isSymbolUsedInConditionBody(expr, body, testedNode, testedSymbol) {
            return !!ts.forEachChild(body, function check(childNode) {
                if (ts.isIdentifier(childNode)) {
                    var childSymbol = getSymbolAtLocation(childNode);
                    if (childSymbol && childSymbol === testedSymbol) {
                        // If the test was a simple identifier, the above check is sufficient
                        if (ts.isIdentifier(expr) || ts.isIdentifier(testedNode) && ts.isBinaryExpression(testedNode.parent)) {
                            return true;
                        }
                        // Otherwise we need to ensure the symbol is called on the same target
                        var testedExpression = testedNode.parent;
                        var childExpression = childNode.parent;
                        while (testedExpression && childExpression) {
                            if (ts.isIdentifier(testedExpression) && ts.isIdentifier(childExpression) ||
                                testedExpression.kind === 108 /* SyntaxKind.ThisKeyword */ && childExpression.kind === 108 /* SyntaxKind.ThisKeyword */) {
                                return getSymbolAtLocation(testedExpression) === getSymbolAtLocation(childExpression);
                            }
                            else if (ts.isPropertyAccessExpression(testedExpression) && ts.isPropertyAccessExpression(childExpression)) {
                                if (getSymbolAtLocation(testedExpression.name) !== getSymbolAtLocation(childExpression.name)) {
                                    return false;
                                }
                                childExpression = childExpression.expression;
                                testedExpression = testedExpression.expression;
                            }
                            else if (ts.isCallExpression(testedExpression) && ts.isCallExpression(childExpression)) {
                                childExpression = childExpression.expression;
                                testedExpression = testedExpression.expression;
                            }
                            else {
                                return false;
                            }
                        }
                    }
                }
                return ts.forEachChild(childNode, check);
            });
        }
        function isSymbolUsedInBinaryExpressionChain(node, testedSymbol) {
            while (ts.isBinaryExpression(node) && node.operatorToken.kind === 55 /* SyntaxKind.AmpersandAmpersandToken */) {
                var isUsed = ts.forEachChild(node.right, function visit(child) {
                    if (ts.isIdentifier(child)) {
                        var symbol = getSymbolAtLocation(child);
                        if (symbol && symbol === testedSymbol) {
                            return true;
                        }
                    }
                    return ts.forEachChild(child, visit);
                });
                if (isUsed) {
                    return true;
                }
                node = node.parent;
            }
            return false;
        }
        function checkDoStatement(node) {
            // Grammar checking
            checkGrammarStatementInAmbientContext(node);
            checkSourceElement(node.statement);
            checkTruthinessExpression(node.expression);
        }
        function checkWhileStatement(node) {
            // Grammar checking
            checkGrammarStatementInAmbientContext(node);
            checkTruthinessExpression(node.expression);
            checkSourceElement(node.statement);
        }
        function checkTruthinessOfType(type, node) {
            if (type.flags & 16384 /* TypeFlags.Void */) {
                error(node, ts.Diagnostics.An_expression_of_type_void_cannot_be_tested_for_truthiness);
            }
            return type;
        }
        function checkTruthinessExpression(node, checkMode) {
            return checkTruthinessOfType(checkExpression(node, checkMode), node);
        }
        function checkForStatement(node) {
            // Grammar checking
            if (!checkGrammarStatementInAmbientContext(node)) {
                if (node.initializer && node.initializer.kind === 255 /* SyntaxKind.VariableDeclarationList */) {
                    checkGrammarVariableDeclarationList(node.initializer);
                }
            }
            if (node.initializer) {
                if (node.initializer.kind === 255 /* SyntaxKind.VariableDeclarationList */) {
                    ts.forEach(node.initializer.declarations, checkVariableDeclaration);
                }
                else {
                    checkExpression(node.initializer);
                }
            }
            if (node.condition)
                checkTruthinessExpression(node.condition);
            if (node.incrementor)
                checkExpression(node.incrementor);
            checkSourceElement(node.statement);
            if (node.locals) {
                registerForUnusedIdentifiersCheck(node);
            }
        }
        function checkForOfStatement(node) {
            checkGrammarForInOrForOfStatement(node);
            var container = ts.getContainingFunctionOrClassStaticBlock(node);
            if (node.awaitModifier) {
                if (container && ts.isClassStaticBlockDeclaration(container)) {
                    grammarErrorOnNode(node.awaitModifier, ts.Diagnostics.For_await_loops_cannot_be_used_inside_a_class_static_block);
                }
                else {
                    var functionFlags = ts.getFunctionFlags(container);
                    if ((functionFlags & (4 /* FunctionFlags.Invalid */ | 2 /* FunctionFlags.Async */)) === 2 /* FunctionFlags.Async */ && languageVersion < 99 /* ScriptTarget.ESNext */) {
                        // for..await..of in an async function or async generator function prior to ESNext requires the __asyncValues helper
                        checkExternalEmitHelpers(node, 16384 /* ExternalEmitHelpers.ForAwaitOfIncludes */);
                    }
                }
            }
            else if (compilerOptions.downlevelIteration && languageVersion < 2 /* ScriptTarget.ES2015 */) {
                // for..of prior to ES2015 requires the __values helper when downlevelIteration is enabled
                checkExternalEmitHelpers(node, 256 /* ExternalEmitHelpers.ForOfIncludes */);
            }
            // Check the LHS and RHS
            // If the LHS is a declaration, just check it as a variable declaration, which will in turn check the RHS
            // via checkRightHandSideOfForOf.
            // If the LHS is an expression, check the LHS, as a destructuring assignment or as a reference.
            // Then check that the RHS is assignable to it.
            if (node.initializer.kind === 255 /* SyntaxKind.VariableDeclarationList */) {
                checkForInOrForOfVariableDeclaration(node);
            }
            else {
                var varExpr = node.initializer;
                var iteratedType = checkRightHandSideOfForOf(node);
                // There may be a destructuring assignment on the left side
                if (varExpr.kind === 204 /* SyntaxKind.ArrayLiteralExpression */ || varExpr.kind === 205 /* SyntaxKind.ObjectLiteralExpression */) {
                    // iteratedType may be undefined. In this case, we still want to check the structure of
                    // varExpr, in particular making sure it's a valid LeftHandSideExpression. But we'd like
                    // to short circuit the type relation checking as much as possible, so we pass the unknownType.
                    checkDestructuringAssignment(varExpr, iteratedType || errorType);
                }
                else {
                    var leftType = checkExpression(varExpr);
                    checkReferenceExpression(varExpr, ts.Diagnostics.The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access, ts.Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access);
                    // iteratedType will be undefined if the rightType was missing properties/signatures
                    // required to get its iteratedType (like [Symbol.iterator] or next). This may be
                    // because we accessed properties from anyType, or it may have led to an error inside
                    // getElementTypeOfIterable.
                    if (iteratedType) {
                        checkTypeAssignableToAndOptionallyElaborate(iteratedType, leftType, varExpr, node.expression);
                    }
                }
            }
            checkSourceElement(node.statement);
            if (node.locals) {
                registerForUnusedIdentifiersCheck(node);
            }
        }
        function checkForInStatement(node) {
            // Grammar checking
            checkGrammarForInOrForOfStatement(node);
            var rightType = getNonNullableTypeIfNeeded(checkExpression(node.expression));
            // TypeScript 1.0 spec (April 2014): 5.4
            // In a 'for-in' statement of the form
            // for (let VarDecl in Expr) Statement
            //   VarDecl must be a variable declaration without a type annotation that declares a variable of type Any,
            //   and Expr must be an expression of type Any, an object type, or a type parameter type.
            if (node.initializer.kind === 255 /* SyntaxKind.VariableDeclarationList */) {
                var variable = node.initializer.declarations[0];
                if (variable && ts.isBindingPattern(variable.name)) {
                    error(variable.name, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern);
                }
                checkForInOrForOfVariableDeclaration(node);
            }
            else {
                // In a 'for-in' statement of the form
                // for (Var in Expr) Statement
                //   Var must be an expression classified as a reference of type Any or the String primitive type,
                //   and Expr must be an expression of type Any, an object type, or a type parameter type.
                var varExpr = node.initializer;
                var leftType = checkExpression(varExpr);
                if (varExpr.kind === 204 /* SyntaxKind.ArrayLiteralExpression */ || varExpr.kind === 205 /* SyntaxKind.ObjectLiteralExpression */) {
                    error(varExpr, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern);
                }
                else if (!isTypeAssignableTo(getIndexTypeOrString(rightType), leftType)) {
                    error(varExpr, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any);
                }
                else {
                    // run check only former check succeeded to avoid cascading errors
                    checkReferenceExpression(varExpr, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access, ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access);
                }
            }
            // unknownType is returned i.e. if node.expression is identifier whose name cannot be resolved
            // in this case error about missing name is already reported - do not report extra one
            if (rightType === neverType || !isTypeAssignableToKind(rightType, 67108864 /* TypeFlags.NonPrimitive */ | 58982400 /* TypeFlags.InstantiableNonPrimitive */)) {
                error(node.expression, ts.Diagnostics.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_here_has_type_0, typeToString(rightType));
            }
            checkSourceElement(node.statement);
            if (node.locals) {
                registerForUnusedIdentifiersCheck(node);
            }
        }
        function checkForInOrForOfVariableDeclaration(iterationStatement) {
            var variableDeclarationList = iterationStatement.initializer;
            // checkGrammarForInOrForOfStatement will check that there is exactly one declaration.
            if (variableDeclarationList.declarations.length >= 1) {
                var decl = variableDeclarationList.declarations[0];
                checkVariableDeclaration(decl);
            }
        }
        function checkRightHandSideOfForOf(statement) {
            var use = statement.awaitModifier ? 15 /* IterationUse.ForAwaitOf */ : 13 /* IterationUse.ForOf */;
            return checkIteratedTypeOrElementType(use, checkNonNullExpression(statement.expression), undefinedType, statement.expression);
        }
        function checkIteratedTypeOrElementType(use, inputType, sentType, errorNode) {
            if (isTypeAny(inputType)) {
                return inputType;
            }
            return getIteratedTypeOrElementType(use, inputType, sentType, errorNode, /*checkAssignability*/ true) || anyType;
        }
        /**
         * When consuming an iterable type in a for..of, spread, or iterator destructuring assignment
         * we want to get the iterated type of an iterable for ES2015 or later, or the iterated type
         * of a iterable (if defined globally) or element type of an array like for ES2015 or earlier.
         */
        function getIteratedTypeOrElementType(use, inputType, sentType, errorNode, checkAssignability) {
            var allowAsyncIterables = (use & 2 /* IterationUse.AllowsAsyncIterablesFlag */) !== 0;
            if (inputType === neverType) {
                reportTypeNotIterableError(errorNode, inputType, allowAsyncIterables); // TODO: GH#18217
                return undefined;
            }
            var uplevelIteration = languageVersion >= 2 /* ScriptTarget.ES2015 */;
            var downlevelIteration = !uplevelIteration && compilerOptions.downlevelIteration;
            var possibleOutOfBounds = compilerOptions.noUncheckedIndexedAccess && !!(use & 128 /* IterationUse.PossiblyOutOfBounds */);
            // Get the iterated type of an `Iterable<T>` or `IterableIterator<T>` only in ES2015
            // or higher, when inside of an async generator or for-await-if, or when
            // downlevelIteration is requested.
            if (uplevelIteration || downlevelIteration || allowAsyncIterables) {
                // We only report errors for an invalid iterable type in ES2015 or higher.
                var iterationTypes = getIterationTypesOfIterable(inputType, use, uplevelIteration ? errorNode : undefined);
                if (checkAssignability) {
                    if (iterationTypes) {
                        var diagnostic = use & 8 /* IterationUse.ForOfFlag */ ? ts.Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_send_0 :
                            use & 32 /* IterationUse.SpreadFlag */ ? ts.Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_always_send_0 :
                                use & 64 /* IterationUse.DestructuringFlag */ ? ts.Diagnostics.Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring_will_always_send_0 :
                                    use & 16 /* IterationUse.YieldStarFlag */ ? ts.Diagnostics.Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_containing_generator_will_always_send_0 :
                                        undefined;
                        if (diagnostic) {
                            checkTypeAssignableTo(sentType, iterationTypes.nextType, errorNode, diagnostic);
                        }
                    }
                }
                if (iterationTypes || uplevelIteration) {
                    return possibleOutOfBounds ? includeUndefinedInIndexSignature(iterationTypes && iterationTypes.yieldType) : (iterationTypes && iterationTypes.yieldType);
                }
            }
            var arrayType = inputType;
            var reportedError = false;
            var hasStringConstituent = false;
            // If strings are permitted, remove any string-like constituents from the array type.
            // This allows us to find other non-string element types from an array unioned with
            // a string.
            if (use & 4 /* IterationUse.AllowsStringInputFlag */) {
                if (arrayType.flags & 1048576 /* TypeFlags.Union */) {
                    // After we remove all types that are StringLike, we will know if there was a string constituent
                    // based on whether the result of filter is a new array.
                    var arrayTypes = inputType.types;
                    var filteredTypes = ts.filter(arrayTypes, function (t) { return !(t.flags & 402653316 /* TypeFlags.StringLike */); });
                    if (filteredTypes !== arrayTypes) {
                        arrayType = getUnionType(filteredTypes, 2 /* UnionReduction.Subtype */);
                    }
                }
                else if (arrayType.flags & 402653316 /* TypeFlags.StringLike */) {
                    arrayType = neverType;
                }
                hasStringConstituent = arrayType !== inputType;
                if (hasStringConstituent) {
                    if (languageVersion < 1 /* ScriptTarget.ES5 */) {
                        if (errorNode) {
                            error(errorNode, ts.Diagnostics.Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher);
                            reportedError = true;
                        }
                    }
                    // Now that we've removed all the StringLike types, if no constituents remain, then the entire
                    // arrayOrStringType was a string.
                    if (arrayType.flags & 131072 /* TypeFlags.Never */) {
                        return possibleOutOfBounds ? includeUndefinedInIndexSignature(stringType) : stringType;
                    }
                }
            }
            if (!isArrayLikeType(arrayType)) {
                if (errorNode && !reportedError) {
                    // Which error we report depends on whether we allow strings or if there was a
                    // string constituent. For example, if the input type is number | string, we
                    // want to say that number is not an array type. But if the input was just
                    // number and string input is allowed, we want to say that number is not an
                    // array type or a string type.
                    var allowsStrings = !!(use & 4 /* IterationUse.AllowsStringInputFlag */) && !hasStringConstituent;
                    var _a = getIterationDiagnosticDetails(allowsStrings, downlevelIteration), defaultDiagnostic = _a[0], maybeMissingAwait = _a[1];
                    errorAndMaybeSuggestAwait(errorNode, maybeMissingAwait && !!getAwaitedTypeOfPromise(arrayType), defaultDiagnostic, typeToString(arrayType));
                }
                return hasStringConstituent ? possibleOutOfBounds ? includeUndefinedInIndexSignature(stringType) : stringType : undefined;
            }
            var arrayElementType = getIndexTypeOfType(arrayType, numberType);
            if (hasStringConstituent && arrayElementType) {
                // This is just an optimization for the case where arrayOrStringType is string | string[]
                if (arrayElementType.flags & 402653316 /* TypeFlags.StringLike */ && !compilerOptions.noUncheckedIndexedAccess) {
                    return stringType;
                }
                return getUnionType(possibleOutOfBounds ? [arrayElementType, stringType, undefinedType] : [arrayElementType, stringType], 2 /* UnionReduction.Subtype */);
            }
            return (use & 128 /* IterationUse.PossiblyOutOfBounds */) ? includeUndefinedInIndexSignature(arrayElementType) : arrayElementType;
            function getIterationDiagnosticDetails(allowsStrings, downlevelIteration) {
                var _a;
                if (downlevelIteration) {
                    return allowsStrings
                        ? [ts.Diagnostics.Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true]
                        : [ts.Diagnostics.Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator, true];
                }
                var yieldType = getIterationTypeOfIterable(use, 0 /* IterationTypeKind.Yield */, inputType, /*errorNode*/ undefined);
                if (yieldType) {
                    return [ts.Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher, false];
                }
                if (isES2015OrLaterIterable((_a = inputType.symbol) === null || _a === void 0 ? void 0 : _a.escapedName)) {
                    return [ts.Diagnostics.Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher, true];
                }
                return allowsStrings
                    ? [ts.Diagnostics.Type_0_is_not_an_array_type_or_a_string_type, true]
                    : [ts.Diagnostics.Type_0_is_not_an_array_type, true];
            }
        }
        function isES2015OrLaterIterable(n) {
            switch (n) {
                case "Float32Array":
                case "Float64Array":
                case "Int16Array":
                case "Int32Array":
                case "Int8Array":
                case "NodeList":
                case "Uint16Array":
                case "Uint32Array":
                case "Uint8Array":
                case "Uint8ClampedArray":
                    return true;
            }
            return false;
        }
        /**
         * Gets the requested "iteration type" from an `Iterable`-like or `AsyncIterable`-like type.
         */
        function getIterationTypeOfIterable(use, typeKind, inputType, errorNode) {
            if (isTypeAny(inputType)) {
                return undefined;
            }
            var iterationTypes = getIterationTypesOfIterable(inputType, use, errorNode);
            return iterationTypes && iterationTypes[getIterationTypesKeyFromIterationTypeKind(typeKind)];
        }
        function createIterationTypes(yieldType, returnType, nextType) {
            // `yieldType` and `returnType` are defaulted to `neverType` they each will be combined
            // via `getUnionType` when merging iteration types. `nextType` is defined as `unknownType`
            // as it is combined via `getIntersectionType` when merging iteration types.
            if (yieldType === void 0) { yieldType = neverType; }
            if (returnType === void 0) { returnType = neverType; }
            if (nextType === void 0) { nextType = unknownType; }
            // Use the cache only for intrinsic types to keep it small as they are likely to be
            // more frequently created (i.e. `Iterator<number, void, unknown>`). Iteration types
            // are also cached on the type they are requested for, so we shouldn't need to maintain
            // the cache for less-frequently used types.
            if (yieldType.flags & 67359327 /* TypeFlags.Intrinsic */ &&
                returnType.flags & (1 /* TypeFlags.Any */ | 131072 /* TypeFlags.Never */ | 2 /* TypeFlags.Unknown */ | 16384 /* TypeFlags.Void */ | 32768 /* TypeFlags.Undefined */) &&
                nextType.flags & (1 /* TypeFlags.Any */ | 131072 /* TypeFlags.Never */ | 2 /* TypeFlags.Unknown */ | 16384 /* TypeFlags.Void */ | 32768 /* TypeFlags.Undefined */)) {
                var id = getTypeListId([yieldType, returnType, nextType]);
                var iterationTypes = iterationTypesCache.get(id);
                if (!iterationTypes) {
                    iterationTypes = { yieldType: yieldType, returnType: returnType, nextType: nextType };
                    iterationTypesCache.set(id, iterationTypes);
                }
                return iterationTypes;
            }
            return { yieldType: yieldType, returnType: returnType, nextType: nextType };
        }
        /**
         * Combines multiple `IterationTypes` records.
         *
         * If `array` is empty or all elements are missing or are references to `noIterationTypes`,
         * then `noIterationTypes` is returned. Otherwise, an `IterationTypes` record is returned
         * for the combined iteration types.
         */
        function combineIterationTypes(array) {
            var yieldTypes;
            var returnTypes;
            var nextTypes;
            for (var _i = 0, array_11 = array; _i < array_11.length; _i++) {
                var iterationTypes = array_11[_i];
                if (iterationTypes === undefined || iterationTypes === noIterationTypes) {
                    continue;
                }
                if (iterationTypes === anyIterationTypes) {
                    return anyIterationTypes;
                }
                yieldTypes = ts.append(yieldTypes, iterationTypes.yieldType);
                returnTypes = ts.append(returnTypes, iterationTypes.returnType);
                nextTypes = ts.append(nextTypes, iterationTypes.nextType);
            }
            if (yieldTypes || returnTypes || nextTypes) {
                return createIterationTypes(yieldTypes && getUnionType(yieldTypes), returnTypes && getUnionType(returnTypes), nextTypes && getIntersectionType(nextTypes));
            }
            return noIterationTypes;
        }
        function getCachedIterationTypes(type, cacheKey) {
            return type[cacheKey];
        }
        function setCachedIterationTypes(type, cacheKey, cachedTypes) {
            return type[cacheKey] = cachedTypes;
        }
        /**
         * Gets the *yield*, *return*, and *next* types from an `Iterable`-like or `AsyncIterable`-like type.
         *
         * At every level that involves analyzing return types of signatures, we union the return types of all the signatures.
         *
         * Another thing to note is that at any step of this process, we could run into a dead end,
         * meaning either the property is missing, or we run into the anyType. If either of these things
         * happens, we return `undefined` to signal that we could not find the iteration type. If a property
         * is missing, and the previous step did not result in `any`, then we also give an error if the
         * caller requested it. Then the caller can decide what to do in the case where there is no iterated
         * type.
         *
         * For a **for-of** statement, `yield*` (in a normal generator), spread, array
         * destructuring, or normal generator we will only ever look for a `[Symbol.iterator]()`
         * method.
         *
         * For an async generator we will only ever look at the `[Symbol.asyncIterator]()` method.
         *
         * For a **for-await-of** statement or a `yield*` in an async generator we will look for
         * the `[Symbol.asyncIterator]()` method first, and then the `[Symbol.iterator]()` method.
         */
        function getIterationTypesOfIterable(type, use, errorNode) {
            if (isTypeAny(type)) {
                return anyIterationTypes;
            }
            if (!(type.flags & 1048576 /* TypeFlags.Union */)) {
                var iterationTypes_1 = getIterationTypesOfIterableWorker(type, use, errorNode);
                if (iterationTypes_1 === noIterationTypes) {
                    if (errorNode) {
                        reportTypeNotIterableError(errorNode, type, !!(use & 2 /* IterationUse.AllowsAsyncIterablesFlag */));
                    }
                    return undefined;
                }
                return iterationTypes_1;
            }
            var cacheKey = use & 2 /* IterationUse.AllowsAsyncIterablesFlag */ ? "iterationTypesOfAsyncIterable" : "iterationTypesOfIterable";
            var cachedTypes = getCachedIterationTypes(type, cacheKey);
            if (cachedTypes)
                return cachedTypes === noIterationTypes ? undefined : cachedTypes;
            var allIterationTypes;
            for (var _i = 0, _a = type.types; _i < _a.length; _i++) {
                var constituent = _a[_i];
                var iterationTypes_2 = getIterationTypesOfIterableWorker(constituent, use, errorNode);
                if (iterationTypes_2 === noIterationTypes) {
                    if (errorNode) {
                        reportTypeNotIterableError(errorNode, type, !!(use & 2 /* IterationUse.AllowsAsyncIterablesFlag */));
                    }
                    setCachedIterationTypes(type, cacheKey, noIterationTypes);
                    return undefined;
                }
                else {
                    allIterationTypes = ts.append(allIterationTypes, iterationTypes_2);
                }
            }
            var iterationTypes = allIterationTypes ? combineIterationTypes(allIterationTypes) : noIterationTypes;
            setCachedIterationTypes(type, cacheKey, iterationTypes);
            return iterationTypes === noIterationTypes ? undefined : iterationTypes;
        }
        function getAsyncFromSyncIterationTypes(iterationTypes, errorNode) {
            if (iterationTypes === noIterationTypes)
                return noIterationTypes;
            if (iterationTypes === anyIterationTypes)
                return anyIterationTypes;
            var yieldType = iterationTypes.yieldType, returnType = iterationTypes.returnType, nextType = iterationTypes.nextType;
            // if we're requesting diagnostics, report errors for a missing `Awaited<T>`.
            if (errorNode) {
                getGlobalAwaitedSymbol(/*reportErrors*/ true);
            }
            return createIterationTypes(getAwaitedType(yieldType, errorNode) || anyType, getAwaitedType(returnType, errorNode) || anyType, nextType);
        }
        /**
         * Gets the *yield*, *return*, and *next* types from a non-union type.
         *
         * If we are unable to find the *yield*, *return*, and *next* types, `noIterationTypes` is
         * returned to indicate to the caller that it should report an error. Otherwise, an
         * `IterationTypes` record is returned.
         *
         * NOTE: You probably don't want to call this directly and should be calling
         * `getIterationTypesOfIterable` instead.
         */
        function getIterationTypesOfIterableWorker(type, use, errorNode) {
            if (isTypeAny(type)) {
                return anyIterationTypes;
            }
            if (use & 2 /* IterationUse.AllowsAsyncIterablesFlag */) {
                var iterationTypes = getIterationTypesOfIterableCached(type, asyncIterationTypesResolver) ||
                    getIterationTypesOfIterableFast(type, asyncIterationTypesResolver);
                if (iterationTypes) {
                    return use & 8 /* IterationUse.ForOfFlag */ ?
                        getAsyncFromSyncIterationTypes(iterationTypes, errorNode) :
                        iterationTypes;
                }
            }
            if (use & 1 /* IterationUse.AllowsSyncIterablesFlag */) {
                var iterationTypes = getIterationTypesOfIterableCached(type, syncIterationTypesResolver) ||
                    getIterationTypesOfIterableFast(type, syncIterationTypesResolver);
                if (iterationTypes) {
                    if (use & 2 /* IterationUse.AllowsAsyncIterablesFlag */) {
                        // for a sync iterable in an async context, only use the cached types if they are valid.
                        if (iterationTypes !== noIterationTypes) {
                            return setCachedIterationTypes(type, "iterationTypesOfAsyncIterable", getAsyncFromSyncIterationTypes(iterationTypes, errorNode));
                        }
                    }
                    else {
                        return iterationTypes;
                    }
                }
            }
            if (use & 2 /* IterationUse.AllowsAsyncIterablesFlag */) {
                var iterationTypes = getIterationTypesOfIterableSlow(type, asyncIterationTypesResolver, errorNode);
                if (iterationTypes !== noIterationTypes) {
                    return iterationTypes;
                }
            }
            if (use & 1 /* IterationUse.AllowsSyncIterablesFlag */) {
                var iterationTypes = getIterationTypesOfIterableSlow(type, syncIterationTypesResolver, errorNode);
                if (iterationTypes !== noIterationTypes) {
                    if (use & 2 /* IterationUse.AllowsAsyncIterablesFlag */) {
                        return setCachedIterationTypes(type, "iterationTypesOfAsyncIterable", iterationTypes
                            ? getAsyncFromSyncIterationTypes(iterationTypes, errorNode)
                            : noIterationTypes);
                    }
                    else {
                        return iterationTypes;
                    }
                }
            }
            return noIterationTypes;
        }
        /**
         * Gets the *yield*, *return*, and *next* types of an `Iterable`-like or
         * `AsyncIterable`-like type from the cache.
         *
         * NOTE: You probably don't want to call this directly and should be calling
         * `getIterationTypesOfIterable` instead.
         */
        function getIterationTypesOfIterableCached(type, resolver) {
            return getCachedIterationTypes(type, resolver.iterableCacheKey);
        }
        function getIterationTypesOfGlobalIterableType(globalType, resolver) {
            var globalIterationTypes = getIterationTypesOfIterableCached(globalType, resolver) ||
                getIterationTypesOfIterableSlow(globalType, resolver, /*errorNode*/ undefined);
            return globalIterationTypes === noIterationTypes ? defaultIterationTypes : globalIterationTypes;
        }
        /**
         * Gets the *yield*, *return*, and *next* types of an `Iterable`-like or `AsyncIterable`-like
         * type from from common heuristics.
         *
         * If we previously analyzed this type and found no iteration types, `noIterationTypes` is
         * returned. If we found iteration types, an `IterationTypes` record is returned.
         * Otherwise, we return `undefined` to indicate to the caller it should perform a more
         * exhaustive analysis.
         *
         * NOTE: You probably don't want to call this directly and should be calling
         * `getIterationTypesOfIterable` instead.
         */
        function getIterationTypesOfIterableFast(type, resolver) {
            // As an optimization, if the type is an instantiation of one of the following global types, then
            // just grab its related type argument:
            // - `Iterable<T>` or `AsyncIterable<T>`
            // - `IterableIterator<T>` or `AsyncIterableIterator<T>`
            var globalType;
            if (isReferenceToType(type, globalType = resolver.getGlobalIterableType(/*reportErrors*/ false)) ||
                isReferenceToType(type, globalType = resolver.getGlobalIterableIteratorType(/*reportErrors*/ false))) {
                var yieldType = getTypeArguments(type)[0];
                // The "return" and "next" types of `Iterable` and `IterableIterator` are defined by the
                // iteration types of their `[Symbol.iterator]()` method. The same is true for their async cousins.
                // While we define these as `any` and `undefined` in our libs by default, a custom lib *could* use
                // different definitions.
                var _a = getIterationTypesOfGlobalIterableType(globalType, resolver), returnType = _a.returnType, nextType = _a.nextType;
                return setCachedIterationTypes(type, resolver.iterableCacheKey, createIterationTypes(resolver.resolveIterationType(yieldType, /*errorNode*/ undefined) || yieldType, resolver.resolveIterationType(returnType, /*errorNode*/ undefined) || returnType, nextType));
            }
            // As an optimization, if the type is an instantiation of the following global type, then
            // just grab its related type arguments:
            // - `Generator<T, TReturn, TNext>` or `AsyncGenerator<T, TReturn, TNext>`
            if (isReferenceToType(type, resolver.getGlobalGeneratorType(/*reportErrors*/ false))) {
                var _b = getTypeArguments(type), yieldType = _b[0], returnType = _b[1], nextType = _b[2];
                return setCachedIterationTypes(type, resolver.iterableCacheKey, createIterationTypes(resolver.resolveIterationType(yieldType, /*errorNode*/ undefined) || yieldType, resolver.resolveIterationType(returnType, /*errorNode*/ undefined) || returnType, nextType));
            }
        }
        function getPropertyNameForKnownSymbolName(symbolName) {
            var ctorType = getGlobalESSymbolConstructorSymbol(/*reportErrors*/ false);
            var uniqueType = ctorType && getTypeOfPropertyOfType(getTypeOfSymbol(ctorType), ts.escapeLeadingUnderscores(symbolName));
            return uniqueType && isTypeUsableAsPropertyName(uniqueType) ? getPropertyNameFromType(uniqueType) : "__@".concat(symbolName);
        }
        /**
         * Gets the *yield*, *return*, and *next* types of an `Iterable`-like or `AsyncIterable`-like
         * type from its members.
         *
         * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
         * record is returned. Otherwise, `noIterationTypes` is returned.
         *
         * NOTE: You probably don't want to call this directly and should be calling
         * `getIterationTypesOfIterable` instead.
         */
        function getIterationTypesOfIterableSlow(type, resolver, errorNode) {
            var _a;
            var method = getPropertyOfType(type, getPropertyNameForKnownSymbolName(resolver.iteratorSymbolName));
            var methodType = method && !(method.flags & 16777216 /* SymbolFlags.Optional */) ? getTypeOfSymbol(method) : undefined;
            if (isTypeAny(methodType)) {
                return setCachedIterationTypes(type, resolver.iterableCacheKey, anyIterationTypes);
            }
            var signatures = methodType ? getSignaturesOfType(methodType, 0 /* SignatureKind.Call */) : undefined;
            if (!ts.some(signatures)) {
                return setCachedIterationTypes(type, resolver.iterableCacheKey, noIterationTypes);
            }
            var iteratorType = getIntersectionType(ts.map(signatures, getReturnTypeOfSignature));
            var iterationTypes = (_a = getIterationTypesOfIterator(iteratorType, resolver, errorNode)) !== null && _a !== void 0 ? _a : noIterationTypes;
            return setCachedIterationTypes(type, resolver.iterableCacheKey, iterationTypes);
        }
        function reportTypeNotIterableError(errorNode, type, allowAsyncIterables) {
            var message = allowAsyncIterables
                ? ts.Diagnostics.Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator
                : ts.Diagnostics.Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator;
            errorAndMaybeSuggestAwait(errorNode, !!getAwaitedTypeOfPromise(type), message, typeToString(type));
        }
        /**
         * Gets the *yield*, *return*, and *next* types from an `Iterator`-like or `AsyncIterator`-like type.
         *
         * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
         * record is returned. Otherwise, `undefined` is returned.
         */
        function getIterationTypesOfIterator(type, resolver, errorNode) {
            if (isTypeAny(type)) {
                return anyIterationTypes;
            }
            var iterationTypes = getIterationTypesOfIteratorCached(type, resolver) ||
                getIterationTypesOfIteratorFast(type, resolver) ||
                getIterationTypesOfIteratorSlow(type, resolver, errorNode);
            return iterationTypes === noIterationTypes ? undefined : iterationTypes;
        }
        /**
         * Gets the iteration types of an `Iterator`-like or `AsyncIterator`-like type from the
         * cache.
         *
         * NOTE: You probably don't want to call this directly and should be calling
         * `getIterationTypesOfIterator` instead.
         */
        function getIterationTypesOfIteratorCached(type, resolver) {
            return getCachedIterationTypes(type, resolver.iteratorCacheKey);
        }
        /**
         * Gets the iteration types of an `Iterator`-like or `AsyncIterator`-like type from the
         * cache or from common heuristics.
         *
         * If we previously analyzed this type and found no iteration types, `noIterationTypes` is
         * returned. If we found iteration types, an `IterationTypes` record is returned.
         * Otherwise, we return `undefined` to indicate to the caller it should perform a more
         * exhaustive analysis.
         *
         * NOTE: You probably don't want to call this directly and should be calling
         * `getIterationTypesOfIterator` instead.
         */
        function getIterationTypesOfIteratorFast(type, resolver) {
            // As an optimization, if the type is an instantiation of one of the following global types,
            // then just grab its related type argument:
            // - `IterableIterator<T>` or `AsyncIterableIterator<T>`
            // - `Iterator<T, TReturn, TNext>` or `AsyncIterator<T, TReturn, TNext>`
            // - `Generator<T, TReturn, TNext>` or `AsyncGenerator<T, TReturn, TNext>`
            var globalType = resolver.getGlobalIterableIteratorType(/*reportErrors*/ false);
            if (isReferenceToType(type, globalType)) {
                var yieldType = getTypeArguments(type)[0];
                // The "return" and "next" types of `IterableIterator` and `AsyncIterableIterator` are defined by the
                // iteration types of their `next`, `return`, and `throw` methods. While we define these as `any`
                // and `undefined` in our libs by default, a custom lib *could* use different definitions.
                var globalIterationTypes = getIterationTypesOfIteratorCached(globalType, resolver) ||
                    getIterationTypesOfIteratorSlow(globalType, resolver, /*errorNode*/ undefined);
                var _a = globalIterationTypes === noIterationTypes ? defaultIterationTypes : globalIterationTypes, returnType = _a.returnType, nextType = _a.nextType;
                return setCachedIterationTypes(type, resolver.iteratorCacheKey, createIterationTypes(yieldType, returnType, nextType));
            }
            if (isReferenceToType(type, resolver.getGlobalIteratorType(/*reportErrors*/ false)) ||
                isReferenceToType(type, resolver.getGlobalGeneratorType(/*reportErrors*/ false))) {
                var _b = getTypeArguments(type), yieldType = _b[0], returnType = _b[1], nextType = _b[2];
                return setCachedIterationTypes(type, resolver.iteratorCacheKey, createIterationTypes(yieldType, returnType, nextType));
            }
        }
        function isIteratorResult(type, kind) {
            // From https://tc39.github.io/ecma262/#sec-iteratorresult-interface:
            // > [done] is the result status of an iterator `next` method call. If the end of the iterator was reached `done` is `true`.
            // > If the end was not reached `done` is `false` and a value is available.
            // > If a `done` property (either own or inherited) does not exist, it is consider to have the value `false`.
            var doneType = getTypeOfPropertyOfType(type, "done") || falseType;
            return isTypeAssignableTo(kind === 0 /* IterationTypeKind.Yield */ ? falseType : trueType, doneType);
        }
        function isYieldIteratorResult(type) {
            return isIteratorResult(type, 0 /* IterationTypeKind.Yield */);
        }
        function isReturnIteratorResult(type) {
            return isIteratorResult(type, 1 /* IterationTypeKind.Return */);
        }
        /**
         * Gets the *yield* and *return* types of an `IteratorResult`-like type.
         *
         * If we are unable to determine a *yield* or a *return* type, `noIterationTypes` is
         * returned to indicate to the caller that it should handle the error. Otherwise, an
         * `IterationTypes` record is returned.
         */
        function getIterationTypesOfIteratorResult(type) {
            if (isTypeAny(type)) {
                return anyIterationTypes;
            }
            var cachedTypes = getCachedIterationTypes(type, "iterationTypesOfIteratorResult");
            if (cachedTypes) {
                return cachedTypes;
            }
            // As an optimization, if the type is an instantiation of one of the global `IteratorYieldResult<T>`
            // or `IteratorReturnResult<TReturn>` types, then just grab its type argument.
            if (isReferenceToType(type, getGlobalIteratorYieldResultType(/*reportErrors*/ false))) {
                var yieldType_1 = getTypeArguments(type)[0];
                return setCachedIterationTypes(type, "iterationTypesOfIteratorResult", createIterationTypes(yieldType_1, /*returnType*/ undefined, /*nextType*/ undefined));
            }
            if (isReferenceToType(type, getGlobalIteratorReturnResultType(/*reportErrors*/ false))) {
                var returnType_1 = getTypeArguments(type)[0];
                return setCachedIterationTypes(type, "iterationTypesOfIteratorResult", createIterationTypes(/*yieldType*/ undefined, returnType_1, /*nextType*/ undefined));
            }
            // Choose any constituents that can produce the requested iteration type.
            var yieldIteratorResult = filterType(type, isYieldIteratorResult);
            var yieldType = yieldIteratorResult !== neverType ? getTypeOfPropertyOfType(yieldIteratorResult, "value") : undefined;
            var returnIteratorResult = filterType(type, isReturnIteratorResult);
            var returnType = returnIteratorResult !== neverType ? getTypeOfPropertyOfType(returnIteratorResult, "value") : undefined;
            if (!yieldType && !returnType) {
                return setCachedIterationTypes(type, "iterationTypesOfIteratorResult", noIterationTypes);
            }
            // From https://tc39.github.io/ecma262/#sec-iteratorresult-interface
            // > ... If the iterator does not have a return value, `value` is `undefined`. In that case, the
            // > `value` property may be absent from the conforming object if it does not inherit an explicit
            // > `value` property.
            return setCachedIterationTypes(type, "iterationTypesOfIteratorResult", createIterationTypes(yieldType, returnType || voidType, /*nextType*/ undefined));
        }
        /**
         * Gets the *yield*, *return*, and *next* types of a the `next()`, `return()`, or
         * `throw()` method of an `Iterator`-like or `AsyncIterator`-like type.
         *
         * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
         * record is returned. Otherwise, we return `undefined`.
         */
        function getIterationTypesOfMethod(type, resolver, methodName, errorNode) {
            var _a, _b, _c, _d;
            var method = getPropertyOfType(type, methodName);
            // Ignore 'return' or 'throw' if they are missing.
            if (!method && methodName !== "next") {
                return undefined;
            }
            var methodType = method && !(methodName === "next" && (method.flags & 16777216 /* SymbolFlags.Optional */))
                ? methodName === "next" ? getTypeOfSymbol(method) : getTypeWithFacts(getTypeOfSymbol(method), 2097152 /* TypeFacts.NEUndefinedOrNull */)
                : undefined;
            if (isTypeAny(methodType)) {
                // `return()` and `throw()` don't provide a *next* type.
                return methodName === "next" ? anyIterationTypes : anyIterationTypesExceptNext;
            }
            // Both async and non-async iterators *must* have a `next` method.
            var methodSignatures = methodType ? getSignaturesOfType(methodType, 0 /* SignatureKind.Call */) : ts.emptyArray;
            if (methodSignatures.length === 0) {
                if (errorNode) {
                    var diagnostic = methodName === "next"
                        ? resolver.mustHaveANextMethodDiagnostic
                        : resolver.mustBeAMethodDiagnostic;
                    error(errorNode, diagnostic, methodName);
                }
                return methodName === "next" ? anyIterationTypes : undefined;
            }
            // If the method signature comes exclusively from the global iterator or generator type,
            // create iteration types from its type arguments like `getIterationTypesOfIteratorFast`
            // does (so as to remove `undefined` from the next and return types). We arrive here when
            // a contextual type for a generator was not a direct reference to one of those global types,
            // but looking up `methodType` referred to one of them (and nothing else). E.g., in
            // `interface SpecialIterator extends Iterator<number> {}`, `SpecialIterator` is not a
            // reference to `Iterator`, but its `next` member derives exclusively from `Iterator`.
            if ((methodType === null || methodType === void 0 ? void 0 : methodType.symbol) && methodSignatures.length === 1) {
                var globalGeneratorType = resolver.getGlobalGeneratorType(/*reportErrors*/ false);
                var globalIteratorType = resolver.getGlobalIteratorType(/*reportErrors*/ false);
                var isGeneratorMethod = ((_b = (_a = globalGeneratorType.symbol) === null || _a === void 0 ? void 0 : _a.members) === null || _b === void 0 ? void 0 : _b.get(methodName)) === methodType.symbol;
                var isIteratorMethod = !isGeneratorMethod && ((_d = (_c = globalIteratorType.symbol) === null || _c === void 0 ? void 0 : _c.members) === null || _d === void 0 ? void 0 : _d.get(methodName)) === methodType.symbol;
                if (isGeneratorMethod || isIteratorMethod) {
                    var globalType = isGeneratorMethod ? globalGeneratorType : globalIteratorType;
                    var mapper = methodType.mapper;
                    return createIterationTypes(getMappedType(globalType.typeParameters[0], mapper), getMappedType(globalType.typeParameters[1], mapper), methodName === "next" ? getMappedType(globalType.typeParameters[2], mapper) : undefined);
                }
            }
            // Extract the first parameter and return type of each signature.
            var methodParameterTypes;
            var methodReturnTypes;
            for (var _i = 0, methodSignatures_1 = methodSignatures; _i < methodSignatures_1.length; _i++) {
                var signature = methodSignatures_1[_i];
                if (methodName !== "throw" && ts.some(signature.parameters)) {
                    methodParameterTypes = ts.append(methodParameterTypes, getTypeAtPosition(signature, 0));
                }
                methodReturnTypes = ts.append(methodReturnTypes, getReturnTypeOfSignature(signature));
            }
            // Resolve the *next* or *return* type from the first parameter of a `next()` or
            // `return()` method, respectively.
            var returnTypes;
            var nextType;
            if (methodName !== "throw") {
                var methodParameterType = methodParameterTypes ? getUnionType(methodParameterTypes) : unknownType;
                if (methodName === "next") {
                    // The value of `next(value)` is *not* awaited by async generators
                    nextType = methodParameterType;
                }
                else if (methodName === "return") {
                    // The value of `return(value)` *is* awaited by async generators
                    var resolvedMethodParameterType = resolver.resolveIterationType(methodParameterType, errorNode) || anyType;
                    returnTypes = ts.append(returnTypes, resolvedMethodParameterType);
                }
            }
            // Resolve the *yield* and *return* types from the return type of the method (i.e. `IteratorResult`)
            var yieldType;
            var methodReturnType = methodReturnTypes ? getIntersectionType(methodReturnTypes) : neverType;
            var resolvedMethodReturnType = resolver.resolveIterationType(methodReturnType, errorNode) || anyType;
            var iterationTypes = getIterationTypesOfIteratorResult(resolvedMethodReturnType);
            if (iterationTypes === noIterationTypes) {
                if (errorNode) {
                    error(errorNode, resolver.mustHaveAValueDiagnostic, methodName);
                }
                yieldType = anyType;
                returnTypes = ts.append(returnTypes, anyType);
            }
            else {
                yieldType = iterationTypes.yieldType;
                returnTypes = ts.append(returnTypes, iterationTypes.returnType);
            }
            return createIterationTypes(yieldType, getUnionType(returnTypes), nextType);
        }
        /**
         * Gets the *yield*, *return*, and *next* types of an `Iterator`-like or `AsyncIterator`-like
         * type from its members.
         *
         * If we successfully found the *yield*, *return*, and *next* types, an `IterationTypes`
         * record is returned. Otherwise, `noIterationTypes` is returned.
         *
         * NOTE: You probably don't want to call this directly and should be calling
         * `getIterationTypesOfIterator` instead.
         */
        function getIterationTypesOfIteratorSlow(type, resolver, errorNode) {
            var iterationTypes = combineIterationTypes([
                getIterationTypesOfMethod(type, resolver, "next", errorNode),
                getIterationTypesOfMethod(type, resolver, "return", errorNode),
                getIterationTypesOfMethod(type, resolver, "throw", errorNode),
            ]);
            return setCachedIterationTypes(type, resolver.iteratorCacheKey, iterationTypes);
        }
        /**
         * Gets the requested "iteration type" from a type that is either `Iterable`-like, `Iterator`-like,
         * `IterableIterator`-like, or `Generator`-like (for a non-async generator); or `AsyncIterable`-like,
         * `AsyncIterator`-like, `AsyncIterableIterator`-like, or `AsyncGenerator`-like (for an async generator).
         */
        function getIterationTypeOfGeneratorFunctionReturnType(kind, returnType, isAsyncGenerator) {
            if (isTypeAny(returnType)) {
                return undefined;
            }
            var iterationTypes = getIterationTypesOfGeneratorFunctionReturnType(returnType, isAsyncGenerator);
            return iterationTypes && iterationTypes[getIterationTypesKeyFromIterationTypeKind(kind)];
        }
        function getIterationTypesOfGeneratorFunctionReturnType(type, isAsyncGenerator) {
            if (isTypeAny(type)) {
                return anyIterationTypes;
            }
            var use = isAsyncGenerator ? 2 /* IterationUse.AsyncGeneratorReturnType */ : 1 /* IterationUse.GeneratorReturnType */;
            var resolver = isAsyncGenerator ? asyncIterationTypesResolver : syncIterationTypesResolver;
            return getIterationTypesOfIterable(type, use, /*errorNode*/ undefined) ||
                getIterationTypesOfIterator(type, resolver, /*errorNode*/ undefined);
        }
        function checkBreakOrContinueStatement(node) {
            // Grammar checking
            if (!checkGrammarStatementInAmbientContext(node))
                checkGrammarBreakOrContinueStatement(node);
            // TODO: Check that target label is valid
        }
        function unwrapReturnType(returnType, functionFlags) {
            var isGenerator = !!(functionFlags & 1 /* FunctionFlags.Generator */);
            var isAsync = !!(functionFlags & 2 /* FunctionFlags.Async */);
            return isGenerator ? getIterationTypeOfGeneratorFunctionReturnType(1 /* IterationTypeKind.Return */, returnType, isAsync) || errorType :
                isAsync ? getAwaitedTypeNoAlias(returnType) || errorType :
                    returnType;
        }
        function isUnwrappedReturnTypeVoidOrAny(func, returnType) {
            var unwrappedReturnType = unwrapReturnType(returnType, ts.getFunctionFlags(func));
            return !!unwrappedReturnType && maybeTypeOfKind(unwrappedReturnType, 16384 /* TypeFlags.Void */ | 3 /* TypeFlags.AnyOrUnknown */);
        }
        function checkReturnStatement(node) {
            var _a;
            // Grammar checking
            if (checkGrammarStatementInAmbientContext(node)) {
                return;
            }
            var container = ts.getContainingFunctionOrClassStaticBlock(node);
            if (container && ts.isClassStaticBlockDeclaration(container)) {
                grammarErrorOnFirstToken(node, ts.Diagnostics.A_return_statement_cannot_be_used_inside_a_class_static_block);
                return;
            }
            if (!container) {
                grammarErrorOnFirstToken(node, ts.Diagnostics.A_return_statement_can_only_be_used_within_a_function_body);
                return;
            }
            var signature = getSignatureFromDeclaration(container);
            var returnType = getReturnTypeOfSignature(signature);
            var functionFlags = ts.getFunctionFlags(container);
            if (strictNullChecks || node.expression || returnType.flags & 131072 /* TypeFlags.Never */) {
                var exprType = node.expression ? checkExpressionCached(node.expression) : undefinedType;
                if (container.kind === 173 /* SyntaxKind.SetAccessor */) {
                    if (node.expression) {
                        error(node, ts.Diagnostics.Setters_cannot_return_a_value);
                    }
                }
                else if (container.kind === 171 /* SyntaxKind.Constructor */) {
                    if (node.expression && !checkTypeAssignableToAndOptionallyElaborate(exprType, returnType, node, node.expression)) {
                        error(node, ts.Diagnostics.Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class);
                    }
                }
                else if (getReturnTypeFromAnnotation(container)) {
                    var unwrappedReturnType = (_a = unwrapReturnType(returnType, functionFlags)) !== null && _a !== void 0 ? _a : returnType;
                    var unwrappedExprType = functionFlags & 2 /* FunctionFlags.Async */
                        ? checkAwaitedType(exprType, /*withAlias*/ false, node, ts.Diagnostics.The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member)
                        : exprType;
                    if (unwrappedReturnType) {
                        // If the function has a return type, but promisedType is
                        // undefined, an error will be reported in checkAsyncFunctionReturnType
                        // so we don't need to report one here.
                        checkTypeAssignableToAndOptionallyElaborate(unwrappedExprType, unwrappedReturnType, node, node.expression);
                    }
                }
            }
            else if (container.kind !== 171 /* SyntaxKind.Constructor */ && compilerOptions.noImplicitReturns && !isUnwrappedReturnTypeVoidOrAny(container, returnType)) {
                // The function has a return type, but the return statement doesn't have an expression.
                error(node, ts.Diagnostics.Not_all_code_paths_return_a_value);
            }
        }
        function checkWithStatement(node) {
            // Grammar checking for withStatement
            if (!checkGrammarStatementInAmbientContext(node)) {
                if (node.flags & 32768 /* NodeFlags.AwaitContext */) {
                    grammarErrorOnFirstToken(node, ts.Diagnostics.with_statements_are_not_allowed_in_an_async_function_block);
                }
            }
            checkExpression(node.expression);
            var sourceFile = ts.getSourceFileOfNode(node);
            if (!hasParseDiagnostics(sourceFile)) {
                var start = ts.getSpanOfTokenAtPosition(sourceFile, node.pos).start;
                var end = node.statement.pos;
                grammarErrorAtPos(sourceFile, start, end - start, ts.Diagnostics.The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any);
            }
        }
        function checkSwitchStatement(node) {
            // Grammar checking
            checkGrammarStatementInAmbientContext(node);
            var firstDefaultClause;
            var hasDuplicateDefaultClause = false;
            var expressionType = checkExpression(node.expression);
            var expressionIsLiteral = isLiteralType(expressionType);
            ts.forEach(node.caseBlock.clauses, function (clause) {
                // Grammar check for duplicate default clauses, skip if we already report duplicate default clause
                if (clause.kind === 290 /* SyntaxKind.DefaultClause */ && !hasDuplicateDefaultClause) {
                    if (firstDefaultClause === undefined) {
                        firstDefaultClause = clause;
                    }
                    else {
                        grammarErrorOnNode(clause, ts.Diagnostics.A_default_clause_cannot_appear_more_than_once_in_a_switch_statement);
                        hasDuplicateDefaultClause = true;
                    }
                }
                if (clause.kind === 289 /* SyntaxKind.CaseClause */) {
                    addLazyDiagnostic(createLazyCaseClauseDiagnostics(clause));
                }
                ts.forEach(clause.statements, checkSourceElement);
                if (compilerOptions.noFallthroughCasesInSwitch && clause.fallthroughFlowNode && isReachableFlowNode(clause.fallthroughFlowNode)) {
                    error(clause, ts.Diagnostics.Fallthrough_case_in_switch);
                }
                function createLazyCaseClauseDiagnostics(clause) {
                    return function () {
                        // TypeScript 1.0 spec (April 2014): 5.9
                        // In a 'switch' statement, each 'case' expression must be of a type that is comparable
                        // to or from the type of the 'switch' expression.
                        var caseType = checkExpression(clause.expression);
                        var caseIsLiteral = isLiteralType(caseType);
                        var comparedExpressionType = expressionType;
                        if (!caseIsLiteral || !expressionIsLiteral) {
                            caseType = caseIsLiteral ? getBaseTypeOfLiteralType(caseType) : caseType;
                            comparedExpressionType = getBaseTypeOfLiteralType(expressionType);
                        }
                        if (!isTypeEqualityComparableTo(comparedExpressionType, caseType)) {
                            // expressionType is not comparable to caseType, try the reversed check and report errors if it fails
                            checkTypeComparableTo(caseType, comparedExpressionType, clause.expression, /*headMessage*/ undefined);
                        }
                    };
                }
            });
            if (node.caseBlock.locals) {
                registerForUnusedIdentifiersCheck(node.caseBlock);
            }
        }
        function checkLabeledStatement(node) {
            // Grammar checking
            if (!checkGrammarStatementInAmbientContext(node)) {
                ts.findAncestor(node.parent, function (current) {
                    if (ts.isFunctionLike(current)) {
                        return "quit";
                    }
                    if (current.kind === 250 /* SyntaxKind.LabeledStatement */ && current.label.escapedText === node.label.escapedText) {
                        grammarErrorOnNode(node.label, ts.Diagnostics.Duplicate_label_0, ts.getTextOfNode(node.label));
                        return true;
                    }
                    return false;
                });
            }
            // ensure that label is unique
            checkSourceElement(node.statement);
        }
        function checkThrowStatement(node) {
            // Grammar checking
            if (!checkGrammarStatementInAmbientContext(node)) {
                if (ts.isIdentifier(node.expression) && !node.expression.escapedText) {
                    grammarErrorAfterFirstToken(node, ts.Diagnostics.Line_break_not_permitted_here);
                }
            }
            if (node.expression) {
                checkExpression(node.expression);
            }
        }
        function checkTryStatement(node) {
            // Grammar checking
            checkGrammarStatementInAmbientContext(node);
            checkBlock(node.tryBlock);
            var catchClause = node.catchClause;
            if (catchClause) {
                // Grammar checking
                if (catchClause.variableDeclaration) {
                    var declaration = catchClause.variableDeclaration;
                    var typeNode = ts.getEffectiveTypeAnnotationNode(ts.getRootDeclaration(declaration));
                    if (typeNode) {
                        var type = getTypeForVariableLikeDeclaration(declaration, /*includeOptionality*/ false, 0 /* CheckMode.Normal */);
                        if (type && !(type.flags & 3 /* TypeFlags.AnyOrUnknown */)) {
                            grammarErrorOnFirstToken(typeNode, ts.Diagnostics.Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified);
                        }
                    }
                    else if (declaration.initializer) {
                        grammarErrorOnFirstToken(declaration.initializer, ts.Diagnostics.Catch_clause_variable_cannot_have_an_initializer);
                    }
                    else {
                        var blockLocals_1 = catchClause.block.locals;
                        if (blockLocals_1) {
                            ts.forEachKey(catchClause.locals, function (caughtName) {
                                var blockLocal = blockLocals_1.get(caughtName);
                                if ((blockLocal === null || blockLocal === void 0 ? void 0 : blockLocal.valueDeclaration) && (blockLocal.flags & 2 /* SymbolFlags.BlockScopedVariable */) !== 0) {
                                    grammarErrorOnNode(blockLocal.valueDeclaration, ts.Diagnostics.Cannot_redeclare_identifier_0_in_catch_clause, caughtName);
                                }
                            });
                        }
                    }
                }
                checkBlock(catchClause.block);
            }
            if (node.finallyBlock) {
                checkBlock(node.finallyBlock);
            }
        }
        function checkIndexConstraints(type, symbol, isStaticIndex) {
            var indexInfos = getIndexInfosOfType(type);
            if (indexInfos.length === 0) {
                return;
            }
            for (var _i = 0, _a = getPropertiesOfObjectType(type); _i < _a.length; _i++) {
                var prop = _a[_i];
                if (!(isStaticIndex && prop.flags & 4194304 /* SymbolFlags.Prototype */)) {
                    checkIndexConstraintForProperty(type, prop, getLiteralTypeFromProperty(prop, 8576 /* TypeFlags.StringOrNumberLiteralOrUnique */, /*includeNonPublic*/ true), getNonMissingTypeOfSymbol(prop));
                }
            }
            var typeDeclaration = symbol.valueDeclaration;
            if (typeDeclaration && ts.isClassLike(typeDeclaration)) {
                for (var _b = 0, _c = typeDeclaration.members; _b < _c.length; _b++) {
                    var member = _c[_b];
                    // Only process instance properties with computed names here. Static properties cannot be in conflict with indexers,
                    // and properties with literal names were already checked.
                    if (!ts.isStatic(member) && !hasBindableName(member)) {
                        var symbol_3 = getSymbolOfNode(member);
                        checkIndexConstraintForProperty(type, symbol_3, getTypeOfExpression(member.name.expression), getNonMissingTypeOfSymbol(symbol_3));
                    }
                }
            }
            if (indexInfos.length > 1) {
                for (var _d = 0, indexInfos_8 = indexInfos; _d < indexInfos_8.length; _d++) {
                    var info = indexInfos_8[_d];
                    checkIndexConstraintForIndexSignature(type, info);
                }
            }
        }
        function checkIndexConstraintForProperty(type, prop, propNameType, propType) {
            var declaration = prop.valueDeclaration;
            var name = ts.getNameOfDeclaration(declaration);
            if (name && ts.isPrivateIdentifier(name)) {
                return;
            }
            var indexInfos = getApplicableIndexInfos(type, propNameType);
            var interfaceDeclaration = ts.getObjectFlags(type) & 2 /* ObjectFlags.Interface */ ? ts.getDeclarationOfKind(type.symbol, 258 /* SyntaxKind.InterfaceDeclaration */) : undefined;
            var localPropDeclaration = declaration && declaration.kind === 221 /* SyntaxKind.BinaryExpression */ ||
                name && name.kind === 162 /* SyntaxKind.ComputedPropertyName */ || getParentOfSymbol(prop) === type.symbol ? declaration : undefined;
            var _loop_28 = function (info) {
                var localIndexDeclaration = info.declaration && getParentOfSymbol(getSymbolOfNode(info.declaration)) === type.symbol ? info.declaration : undefined;
                // We check only when (a) the property is declared in the containing type, or (b) the applicable index signature is declared
                // in the containing type, or (c) the containing type is an interface and no base interface contains both the property and
                // the index signature (i.e. property and index signature are declared in separate inherited interfaces).
                var errorNode = localPropDeclaration || localIndexDeclaration ||
                    (interfaceDeclaration && !ts.some(getBaseTypes(type), function (base) { return !!getPropertyOfObjectType(base, prop.escapedName) && !!getIndexTypeOfType(base, info.keyType); }) ? interfaceDeclaration : undefined);
                if (errorNode && !isTypeAssignableTo(propType, info.type)) {
                    error(errorNode, ts.Diagnostics.Property_0_of_type_1_is_not_assignable_to_2_index_type_3, symbolToString(prop), typeToString(propType), typeToString(info.keyType), typeToString(info.type));
                }
            };
            for (var _i = 0, indexInfos_9 = indexInfos; _i < indexInfos_9.length; _i++) {
                var info = indexInfos_9[_i];
                _loop_28(info);
            }
        }
        function checkIndexConstraintForIndexSignature(type, checkInfo) {
            var declaration = checkInfo.declaration;
            var indexInfos = getApplicableIndexInfos(type, checkInfo.keyType);
            var interfaceDeclaration = ts.getObjectFlags(type) & 2 /* ObjectFlags.Interface */ ? ts.getDeclarationOfKind(type.symbol, 258 /* SyntaxKind.InterfaceDeclaration */) : undefined;
            var localCheckDeclaration = declaration && getParentOfSymbol(getSymbolOfNode(declaration)) === type.symbol ? declaration : undefined;
            var _loop_29 = function (info) {
                if (info === checkInfo)
                    return "continue";
                var localIndexDeclaration = info.declaration && getParentOfSymbol(getSymbolOfNode(info.declaration)) === type.symbol ? info.declaration : undefined;
                // We check only when (a) the check index signature is declared in the containing type, or (b) the applicable index
                // signature is declared in the containing type, or (c) the containing type is an interface and no base interface contains
                // both index signatures (i.e. the index signatures are declared in separate inherited interfaces).
                var errorNode = localCheckDeclaration || localIndexDeclaration ||
                    (interfaceDeclaration && !ts.some(getBaseTypes(type), function (base) { return !!getIndexInfoOfType(base, checkInfo.keyType) && !!getIndexTypeOfType(base, info.keyType); }) ? interfaceDeclaration : undefined);
                if (errorNode && !isTypeAssignableTo(checkInfo.type, info.type)) {
                    error(errorNode, ts.Diagnostics._0_index_type_1_is_not_assignable_to_2_index_type_3, typeToString(checkInfo.keyType), typeToString(checkInfo.type), typeToString(info.keyType), typeToString(info.type));
                }
            };
            for (var _i = 0, indexInfos_10 = indexInfos; _i < indexInfos_10.length; _i++) {
                var info = indexInfos_10[_i];
                _loop_29(info);
            }
        }
        function checkTypeNameIsReserved(name, message) {
            // TS 1.0 spec (April 2014): 3.6.1
            // The predefined type keywords are reserved and cannot be used as names of user defined types.
            switch (name.escapedText) {
                case "any":
                case "unknown":
                case "never":
                case "number":
                case "bigint":
                case "boolean":
                case "string":
                case "symbol":
                case "void":
                case "object":
                    error(name, message, name.escapedText);
            }
        }
        /**
         * The name cannot be used as 'Object' of user defined types with special target.
         */
        function checkClassNameCollisionWithObject(name) {
            if (languageVersion >= 1 /* ScriptTarget.ES5 */ && name.escapedText === "Object"
                && (moduleKind < ts.ModuleKind.ES2015 || ts.getSourceFileOfNode(name).impliedNodeFormat === ts.ModuleKind.CommonJS)) {
                error(name, ts.Diagnostics.Class_name_cannot_be_Object_when_targeting_ES5_with_module_0, ts.ModuleKind[moduleKind]); // https://github.com/Microsoft/TypeScript/issues/17494
            }
        }
        function checkUnmatchedJSDocParameters(node) {
            var jsdocParameters = ts.filter(ts.getJSDocTags(node), ts.isJSDocParameterTag);
            if (!ts.length(jsdocParameters))
                return;
            var isJs = ts.isInJSFile(node);
            var parameters = new ts.Set();
            var excludedParameters = new ts.Set();
            ts.forEach(node.parameters, function (_a, index) {
                var name = _a.name;
                if (ts.isIdentifier(name)) {
                    parameters.add(name.escapedText);
                }
                if (ts.isBindingPattern(name)) {
                    excludedParameters.add(index);
                }
            });
            var containsArguments = containsArgumentsReference(node);
            if (containsArguments) {
                var lastJSDocParam = ts.lastOrUndefined(jsdocParameters);
                if (isJs && lastJSDocParam && ts.isIdentifier(lastJSDocParam.name) && lastJSDocParam.typeExpression &&
                    lastJSDocParam.typeExpression.type && !parameters.has(lastJSDocParam.name.escapedText) && !isArrayType(getTypeFromTypeNode(lastJSDocParam.typeExpression.type))) {
                    error(lastJSDocParam.name, ts.Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_had_an_array_type, ts.idText(lastJSDocParam.name));
                }
            }
            else {
                ts.forEach(jsdocParameters, function (_a, index) {
                    var name = _a.name;
                    if (excludedParameters.has(index) || ts.isIdentifier(name) && parameters.has(name.escapedText)) {
                        return;
                    }
                    if (ts.isQualifiedName(name)) {
                        if (isJs) {
                            error(name, ts.Diagnostics.Qualified_name_0_is_not_allowed_without_a_leading_param_object_1, ts.entityNameToString(name), ts.entityNameToString(name.left));
                        }
                    }
                    else {
                        errorOrSuggestion(isJs, name, ts.Diagnostics.JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name, ts.idText(name));
                    }
                });
            }
        }
        /**
         * Check each type parameter and check that type parameters have no duplicate type parameter declarations
         */
        function checkTypeParameters(typeParameterDeclarations) {
            var seenDefault = false;
            if (typeParameterDeclarations) {
                for (var i = 0; i < typeParameterDeclarations.length; i++) {
                    var node = typeParameterDeclarations[i];
                    checkTypeParameter(node);
                    addLazyDiagnostic(createCheckTypeParameterDiagnostic(node, i));
                }
            }
            function createCheckTypeParameterDiagnostic(node, i) {
                return function () {
                    if (node.default) {
                        seenDefault = true;
                        checkTypeParametersNotReferenced(node.default, typeParameterDeclarations, i);
                    }
                    else if (seenDefault) {
                        error(node, ts.Diagnostics.Required_type_parameters_may_not_follow_optional_type_parameters);
                    }
                    for (var j = 0; j < i; j++) {
                        if (typeParameterDeclarations[j].symbol === node.symbol) {
                            error(node.name, ts.Diagnostics.Duplicate_identifier_0, ts.declarationNameToString(node.name));
                        }
                    }
                };
            }
        }
        /** Check that type parameter defaults only reference previously declared type parameters */
        function checkTypeParametersNotReferenced(root, typeParameters, index) {
            visit(root);
            function visit(node) {
                if (node.kind === 178 /* SyntaxKind.TypeReference */) {
                    var type = getTypeFromTypeReference(node);
                    if (type.flags & 262144 /* TypeFlags.TypeParameter */) {
                        for (var i = index; i < typeParameters.length; i++) {
                            if (type.symbol === getSymbolOfNode(typeParameters[i])) {
                                error(node, ts.Diagnostics.Type_parameter_defaults_can_only_reference_previously_declared_type_parameters);
                            }
                        }
                    }
                }
                ts.forEachChild(node, visit);
            }
        }
        /** Check that type parameter lists are identical across multiple declarations */
        function checkTypeParameterListsIdentical(symbol) {
            if (symbol.declarations && symbol.declarations.length === 1) {
                return;
            }
            var links = getSymbolLinks(symbol);
            if (!links.typeParametersChecked) {
                links.typeParametersChecked = true;
                var declarations = getClassOrInterfaceDeclarationsOfSymbol(symbol);
                if (!declarations || declarations.length <= 1) {
                    return;
                }
                var type = getDeclaredTypeOfSymbol(symbol);
                if (!areTypeParametersIdentical(declarations, type.localTypeParameters, ts.getEffectiveTypeParameterDeclarations)) {
                    // Report an error on every conflicting declaration.
                    var name = symbolToString(symbol);
                    for (var _i = 0, declarations_7 = declarations; _i < declarations_7.length; _i++) {
                        var declaration = declarations_7[_i];
                        error(declaration.name, ts.Diagnostics.All_declarations_of_0_must_have_identical_type_parameters, name);
                    }
                }
            }
        }
        function areTypeParametersIdentical(declarations, targetParameters, getTypeParameterDeclarations) {
            var maxTypeArgumentCount = ts.length(targetParameters);
            var minTypeArgumentCount = getMinTypeArgumentCount(targetParameters);
            for (var _i = 0, declarations_8 = declarations; _i < declarations_8.length; _i++) {
                var declaration = declarations_8[_i];
                // If this declaration has too few or too many type parameters, we report an error
                var sourceParameters = getTypeParameterDeclarations(declaration);
                var numTypeParameters = sourceParameters.length;
                if (numTypeParameters < minTypeArgumentCount || numTypeParameters > maxTypeArgumentCount) {
                    return false;
                }
                for (var i = 0; i < numTypeParameters; i++) {
                    var source = sourceParameters[i];
                    var target = targetParameters[i];
                    // If the type parameter node does not have the same as the resolved type
                    // parameter at this position, we report an error.
                    if (source.name.escapedText !== target.symbol.escapedName) {
                        return false;
                    }
                    // If the type parameter node does not have an identical constraint as the resolved
                    // type parameter at this position, we report an error.
                    var constraint = ts.getEffectiveConstraintOfTypeParameter(source);
                    var sourceConstraint = constraint && getTypeFromTypeNode(constraint);
                    var targetConstraint = getConstraintOfTypeParameter(target);
                    // relax check if later interface augmentation has no constraint, it's more broad and is OK to merge with
                    // a more constrained interface (this could be generalized to a full hierarchy check, but that's maybe overkill)
                    if (sourceConstraint && targetConstraint && !isTypeIdenticalTo(sourceConstraint, targetConstraint)) {
                        return false;
                    }
                    // If the type parameter node has a default and it is not identical to the default
                    // for the type parameter at this position, we report an error.
                    var sourceDefault = source.default && getTypeFromTypeNode(source.default);
                    var targetDefault = getDefaultFromTypeParameter(target);
                    if (sourceDefault && targetDefault && !isTypeIdenticalTo(sourceDefault, targetDefault)) {
                        return false;
                    }
                }
            }
            return true;
        }
        function checkClassExpression(node) {
            checkClassLikeDeclaration(node);
            checkNodeDeferred(node);
            return getTypeOfSymbol(getSymbolOfNode(node));
        }
        function checkClassExpressionDeferred(node) {
            ts.forEach(node.members, checkSourceElement);
            registerForUnusedIdentifiersCheck(node);
        }
        function checkClassDeclaration(node) {
            if (ts.some(node.decorators) && ts.some(node.members, function (p) { return ts.hasStaticModifier(p) && ts.isPrivateIdentifierClassElementDeclaration(p); })) {
                grammarErrorOnNode(node.decorators[0], ts.Diagnostics.Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_decorator);
            }
            if (!node.name && !ts.hasSyntacticModifier(node, 512 /* ModifierFlags.Default */)) {
                grammarErrorOnFirstToken(node, ts.Diagnostics.A_class_declaration_without_the_default_modifier_must_have_a_name);
            }
            checkClassLikeDeclaration(node);
            ts.forEach(node.members, checkSourceElement);
            registerForUnusedIdentifiersCheck(node);
        }
        function checkClassLikeDeclaration(node) {
            checkGrammarClassLikeDeclaration(node);
            checkDecorators(node);
            checkCollisionsForDeclarationName(node, node.name);
            checkTypeParameters(ts.getEffectiveTypeParameterDeclarations(node));
            checkExportsOnMergedDeclarations(node);
            var symbol = getSymbolOfNode(node);
            var type = getDeclaredTypeOfSymbol(symbol);
            var typeWithThis = getTypeWithThisArgument(type);
            var staticType = getTypeOfSymbol(symbol);
            checkTypeParameterListsIdentical(symbol);
            checkFunctionOrConstructorSymbol(symbol);
            checkClassForDuplicateDeclarations(node);
            // Only check for reserved static identifiers on non-ambient context.
            var nodeInAmbientContext = !!(node.flags & 16777216 /* NodeFlags.Ambient */);
            if (!nodeInAmbientContext) {
                checkClassForStaticPropertyNameConflicts(node);
            }
            var baseTypeNode = ts.getEffectiveBaseTypeNode(node);
            if (baseTypeNode) {
                ts.forEach(baseTypeNode.typeArguments, checkSourceElement);
                if (languageVersion < 2 /* ScriptTarget.ES2015 */) {
                    checkExternalEmitHelpers(baseTypeNode.parent, 1 /* ExternalEmitHelpers.Extends */);
                }
                // check both @extends and extends if both are specified.
                var extendsNode = ts.getClassExtendsHeritageElement(node);
                if (extendsNode && extendsNode !== baseTypeNode) {
                    checkExpression(extendsNode.expression);
                }
                var baseTypes_2 = getBaseTypes(type);
                if (baseTypes_2.length) {
                    addLazyDiagnostic(function () {
                        var baseType = baseTypes_2[0];
                        var baseConstructorType = getBaseConstructorTypeOfClass(type);
                        var staticBaseType = getApparentType(baseConstructorType);
                        checkBaseTypeAccessibility(staticBaseType, baseTypeNode);
                        checkSourceElement(baseTypeNode.expression);
                        if (ts.some(baseTypeNode.typeArguments)) {
                            ts.forEach(baseTypeNode.typeArguments, checkSourceElement);
                            for (var _i = 0, _a = getConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode); _i < _a.length; _i++) {
                                var constructor = _a[_i];
                                if (!checkTypeArgumentConstraints(baseTypeNode, constructor.typeParameters)) {
                                    break;
                                }
                            }
                        }
                        var baseWithThis = getTypeWithThisArgument(baseType, type.thisType);
                        if (!checkTypeAssignableTo(typeWithThis, baseWithThis, /*errorNode*/ undefined)) {
                            issueMemberSpecificError(node, typeWithThis, baseWithThis, ts.Diagnostics.Class_0_incorrectly_extends_base_class_1);
                        }
                        else {
                            // Report static side error only when instance type is assignable
                            checkTypeAssignableTo(staticType, getTypeWithoutSignatures(staticBaseType), node.name || node, ts.Diagnostics.Class_static_side_0_incorrectly_extends_base_class_static_side_1);
                        }
                        if (baseConstructorType.flags & 8650752 /* TypeFlags.TypeVariable */) {
                            if (!isMixinConstructorType(staticType)) {
                                error(node.name || node, ts.Diagnostics.A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any);
                            }
                            else {
                                var constructSignatures = getSignaturesOfType(baseConstructorType, 1 /* SignatureKind.Construct */);
                                if (constructSignatures.some(function (signature) { return signature.flags & 4 /* SignatureFlags.Abstract */; }) && !ts.hasSyntacticModifier(node, 128 /* ModifierFlags.Abstract */)) {
                                    error(node.name || node, ts.Diagnostics.A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_be_declared_abstract);
                                }
                            }
                        }
                        if (!(staticBaseType.symbol && staticBaseType.symbol.flags & 32 /* SymbolFlags.Class */) && !(baseConstructorType.flags & 8650752 /* TypeFlags.TypeVariable */)) {
                            // When the static base type is a "class-like" constructor function (but not actually a class), we verify
                            // that all instantiated base constructor signatures return the same type.
                            var constructors = getInstantiatedConstructorsForTypeArguments(staticBaseType, baseTypeNode.typeArguments, baseTypeNode);
                            if (ts.forEach(constructors, function (sig) { return !isJSConstructor(sig.declaration) && !isTypeIdenticalTo(getReturnTypeOfSignature(sig), baseType); })) {
                                error(baseTypeNode.expression, ts.Diagnostics.Base_constructors_must_all_have_the_same_return_type);
                            }
                        }
                        checkKindsOfPropertyMemberOverrides(type, baseType);
                    });
                }
            }
            checkMembersForOverrideModifier(node, type, typeWithThis, staticType);
            var implementedTypeNodes = ts.getEffectiveImplementsTypeNodes(node);
            if (implementedTypeNodes) {
                for (var _i = 0, implementedTypeNodes_1 = implementedTypeNodes; _i < implementedTypeNodes_1.length; _i++) {
                    var typeRefNode = implementedTypeNodes_1[_i];
                    if (!ts.isEntityNameExpression(typeRefNode.expression) || ts.isOptionalChain(typeRefNode.expression)) {
                        error(typeRefNode.expression, ts.Diagnostics.A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments);
                    }
                    checkTypeReferenceNode(typeRefNode);
                    addLazyDiagnostic(createImplementsDiagnostics(typeRefNode));
                }
            }
            addLazyDiagnostic(function () {
                checkIndexConstraints(type, symbol);
                checkIndexConstraints(staticType, symbol, /*isStaticIndex*/ true);
                checkTypeForDuplicateIndexSignatures(node);
                checkPropertyInitialization(node);
            });
            function createImplementsDiagnostics(typeRefNode) {
                return function () {
                    var t = getReducedType(getTypeFromTypeNode(typeRefNode));
                    if (!isErrorType(t)) {
                        if (isValidBaseType(t)) {
                            var genericDiag = t.symbol && t.symbol.flags & 32 /* SymbolFlags.Class */ ?
                                ts.Diagnostics.Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass :
                                ts.Diagnostics.Class_0_incorrectly_implements_interface_1;
                            var baseWithThis = getTypeWithThisArgument(t, type.thisType);
                            if (!checkTypeAssignableTo(typeWithThis, baseWithThis, /*errorNode*/ undefined)) {
                                issueMemberSpecificError(node, typeWithThis, baseWithThis, genericDiag);
                            }
                        }
                        else {
                            error(typeRefNode, ts.Diagnostics.A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_members);
                        }
                    }
                };
            }
        }
        function checkMembersForOverrideModifier(node, type, typeWithThis, staticType) {
            var baseTypeNode = ts.getEffectiveBaseTypeNode(node);
            var baseTypes = baseTypeNode && getBaseTypes(type);
            var baseWithThis = (baseTypes === null || baseTypes === void 0 ? void 0 : baseTypes.length) ? getTypeWithThisArgument(ts.first(baseTypes), type.thisType) : undefined;
            var baseStaticType = getBaseConstructorTypeOfClass(type);
            var _loop_30 = function (member) {
                if (ts.hasAmbientModifier(member)) {
                    return "continue";
                }
                if (ts.isConstructorDeclaration(member)) {
                    ts.forEach(member.parameters, function (param) {
                        if (ts.isParameterPropertyDeclaration(param, member)) {
                            checkExistingMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type, typeWithThis, param, 
                            /* memberIsParameterProperty */ true);
                        }
                    });
                }
                checkExistingMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type, typeWithThis, member, 
                /* memberIsParameterProperty */ false);
            };
            for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                var member = _a[_i];
                _loop_30(member);
            }
        }
        /**
         * @param member Existing member node to be checked.
         * Note: `member` cannot be a synthetic node.
         */
        function checkExistingMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type, typeWithThis, member, memberIsParameterProperty, reportErrors) {
            if (reportErrors === void 0) { reportErrors = true; }
            var declaredProp = member.name
                && getSymbolAtLocation(member.name)
                || getSymbolAtLocation(member);
            if (!declaredProp) {
                return 0 /* MemberOverrideStatus.Ok */;
            }
            return checkMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type, typeWithThis, ts.hasOverrideModifier(member), ts.hasAbstractModifier(member), ts.isStatic(member), memberIsParameterProperty, ts.symbolName(declaredProp), reportErrors ? member : undefined);
        }
        /**
         * Checks a class member declaration for either a missing or an invalid `override` modifier.
         * Note: this function can be used for speculative checking,
         * i.e. checking a member that does not yet exist in the program.
         * An example of that would be to call this function in a completions scenario,
         * when offering a method declaration as completion.
         * @param errorNode The node where we should report an error, or undefined if we should not report errors.
         */
        function checkMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type, typeWithThis, memberHasOverrideModifier, memberHasAbstractModifier, memberIsStatic, memberIsParameterProperty, memberName, errorNode) {
            var isJs = ts.isInJSFile(node);
            var nodeInAmbientContext = !!(node.flags & 16777216 /* NodeFlags.Ambient */);
            if (baseWithThis && (memberHasOverrideModifier || compilerOptions.noImplicitOverride)) {
                var memberEscapedName = ts.escapeLeadingUnderscores(memberName);
                var thisType = memberIsStatic ? staticType : typeWithThis;
                var baseType = memberIsStatic ? baseStaticType : baseWithThis;
                var prop = getPropertyOfType(thisType, memberEscapedName);
                var baseProp = getPropertyOfType(baseType, memberEscapedName);
                var baseClassName = typeToString(baseWithThis);
                if (prop && !baseProp && memberHasOverrideModifier) {
                    if (errorNode) {
                        var suggestion = getSuggestedSymbolForNonexistentClassMember(memberName, baseType); // Again, using symbol name: note that's different from `symbol.escapedName`
                        suggestion ?
                            error(errorNode, isJs ?
                                ts.Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1 :
                                ts.Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1, baseClassName, symbolToString(suggestion)) :
                            error(errorNode, isJs ?
                                ts.Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0 :
                                ts.Diagnostics.This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0, baseClassName);
                    }
                    return 2 /* MemberOverrideStatus.HasInvalidOverride */;
                }
                else if (prop && (baseProp === null || baseProp === void 0 ? void 0 : baseProp.declarations) && compilerOptions.noImplicitOverride && !nodeInAmbientContext) {
                    var baseHasAbstract = ts.some(baseProp.declarations, ts.hasAbstractModifier);
                    if (memberHasOverrideModifier) {
                        return 0 /* MemberOverrideStatus.Ok */;
                    }
                    if (!baseHasAbstract) {
                        if (errorNode) {
                            var diag = memberIsParameterProperty ?
                                isJs ?
                                    ts.Diagnostics.This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0 :
                                    ts.Diagnostics.This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0 :
                                isJs ?
                                    ts.Diagnostics.This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0 :
                                    ts.Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0;
                            error(errorNode, diag, baseClassName);
                        }
                        return 1 /* MemberOverrideStatus.NeedsOverride */;
                    }
                    else if (memberHasAbstractModifier && baseHasAbstract) {
                        if (errorNode) {
                            error(errorNode, ts.Diagnostics.This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0, baseClassName);
                        }
                        return 1 /* MemberOverrideStatus.NeedsOverride */;
                    }
                }
            }
            else if (memberHasOverrideModifier) {
                if (errorNode) {
                    var className = typeToString(type);
                    error(errorNode, isJs ?
                        ts.Diagnostics.This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_extend_another_class :
                        ts.Diagnostics.This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class, className);
                }
                return 2 /* MemberOverrideStatus.HasInvalidOverride */;
            }
            return 0 /* MemberOverrideStatus.Ok */;
        }
        function issueMemberSpecificError(node, typeWithThis, baseWithThis, broadDiag) {
            // iterate over all implemented properties and issue errors on each one which isn't compatible, rather than the class as a whole, if possible
            var issuedMemberError = false;
            var _loop_31 = function (member) {
                if (ts.isStatic(member)) {
                    return "continue";
                }
                var declaredProp = member.name && getSymbolAtLocation(member.name) || getSymbolAtLocation(member);
                if (declaredProp) {
                    var prop = getPropertyOfType(typeWithThis, declaredProp.escapedName);
                    var baseProp = getPropertyOfType(baseWithThis, declaredProp.escapedName);
                    if (prop && baseProp) {
                        var rootChain = function () { return ts.chainDiagnosticMessages(
                        /*details*/ undefined, ts.Diagnostics.Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2, symbolToString(declaredProp), typeToString(typeWithThis), typeToString(baseWithThis)); };
                        if (!checkTypeAssignableTo(getTypeOfSymbol(prop), getTypeOfSymbol(baseProp), member.name || member, /*message*/ undefined, rootChain)) {
                            issuedMemberError = true;
                        }
                    }
                }
            };
            for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                var member = _a[_i];
                _loop_31(member);
            }
            if (!issuedMemberError) {
                // check again with diagnostics to generate a less-specific error
                checkTypeAssignableTo(typeWithThis, baseWithThis, node.name || node, broadDiag);
            }
        }
        function checkBaseTypeAccessibility(type, node) {
            var signatures = getSignaturesOfType(type, 1 /* SignatureKind.Construct */);
            if (signatures.length) {
                var declaration = signatures[0].declaration;
                if (declaration && ts.hasEffectiveModifier(declaration, 8 /* ModifierFlags.Private */)) {
                    var typeClassDeclaration = ts.getClassLikeDeclarationOfSymbol(type.symbol);
                    if (!isNodeWithinClass(node, typeClassDeclaration)) {
                        error(node, ts.Diagnostics.Cannot_extend_a_class_0_Class_constructor_is_marked_as_private, getFullyQualifiedName(type.symbol));
                    }
                }
            }
        }
        /**
         * Checks a member declaration node to see if has a missing or invalid `override` modifier.
         * @param node Class-like node where the member is declared.
         * @param member Member declaration node.
         * Note: `member` can be a synthetic node without a parent.
         */
        function getMemberOverrideModifierStatus(node, member) {
            if (!member.name) {
                return 0 /* MemberOverrideStatus.Ok */;
            }
            var symbol = getSymbolOfNode(node);
            var type = getDeclaredTypeOfSymbol(symbol);
            var typeWithThis = getTypeWithThisArgument(type);
            var staticType = getTypeOfSymbol(symbol);
            var baseTypeNode = ts.getEffectiveBaseTypeNode(node);
            var baseTypes = baseTypeNode && getBaseTypes(type);
            var baseWithThis = (baseTypes === null || baseTypes === void 0 ? void 0 : baseTypes.length) ? getTypeWithThisArgument(ts.first(baseTypes), type.thisType) : undefined;
            var baseStaticType = getBaseConstructorTypeOfClass(type);
            var memberHasOverrideModifier = member.parent
                ? ts.hasOverrideModifier(member)
                : ts.hasSyntacticModifier(member, 16384 /* ModifierFlags.Override */);
            var memberName = ts.unescapeLeadingUnderscores(ts.getTextOfPropertyName(member.name));
            return checkMemberForOverrideModifier(node, staticType, baseStaticType, baseWithThis, type, typeWithThis, memberHasOverrideModifier, ts.hasAbstractModifier(member), ts.isStatic(member), 
            /* memberIsParameterProperty */ false, memberName);
        }
        function getTargetSymbol(s) {
            // if symbol is instantiated its flags are not copied from the 'target'
            // so we'll need to get back original 'target' symbol to work with correct set of flags
            return ts.getCheckFlags(s) & 1 /* CheckFlags.Instantiated */ ? s.target : s;
        }
        function getClassOrInterfaceDeclarationsOfSymbol(symbol) {
            return ts.filter(symbol.declarations, function (d) {
                return d.kind === 257 /* SyntaxKind.ClassDeclaration */ || d.kind === 258 /* SyntaxKind.InterfaceDeclaration */;
            });
        }
        function checkKindsOfPropertyMemberOverrides(type, baseType) {
            // TypeScript 1.0 spec (April 2014): 8.2.3
            // A derived class inherits all members from its base class it doesn't override.
            // Inheritance means that a derived class implicitly contains all non - overridden members of the base class.
            // Both public and private property members are inherited, but only public property members can be overridden.
            // A property member in a derived class is said to override a property member in a base class
            // when the derived class property member has the same name and kind(instance or static)
            // as the base class property member.
            // The type of an overriding property member must be assignable(section 3.8.4)
            // to the type of the overridden property member, or otherwise a compile - time error occurs.
            // Base class instance member functions can be overridden by derived class instance member functions,
            // but not by other kinds of members.
            // Base class instance member variables and accessors can be overridden by
            // derived class instance member variables and accessors, but not by other kinds of members.
            var _a, _b;
            // NOTE: assignability is checked in checkClassDeclaration
            var baseProperties = getPropertiesOfType(baseType);
            basePropertyCheck: for (var _i = 0, baseProperties_1 = baseProperties; _i < baseProperties_1.length; _i++) {
                var baseProperty = baseProperties_1[_i];
                var base = getTargetSymbol(baseProperty);
                if (base.flags & 4194304 /* SymbolFlags.Prototype */) {
                    continue;
                }
                var baseSymbol = getPropertyOfObjectType(type, base.escapedName);
                if (!baseSymbol) {
                    continue;
                }
                var derived = getTargetSymbol(baseSymbol);
                var baseDeclarationFlags = ts.getDeclarationModifierFlagsFromSymbol(base);
                ts.Debug.assert(!!derived, "derived should point to something, even if it is the base class' declaration.");
                // In order to resolve whether the inherited method was overridden in the base class or not,
                // we compare the Symbols obtained. Since getTargetSymbol returns the symbol on the *uninstantiated*
                // type declaration, derived and base resolve to the same symbol even in the case of generic classes.
                if (derived === base) {
                    // derived class inherits base without override/redeclaration
                    var derivedClassDecl = ts.getClassLikeDeclarationOfSymbol(type.symbol);
                    // It is an error to inherit an abstract member without implementing it or being declared abstract.
                    // If there is no declaration for the derived class (as in the case of class expressions),
                    // then the class cannot be declared abstract.
                    if (baseDeclarationFlags & 128 /* ModifierFlags.Abstract */ && (!derivedClassDecl || !ts.hasSyntacticModifier(derivedClassDecl, 128 /* ModifierFlags.Abstract */))) {
                        // Searches other base types for a declaration that would satisfy the inherited abstract member.
                        // (The class may have more than one base type via declaration merging with an interface with the
                        // same name.)
                        for (var _c = 0, _d = getBaseTypes(type); _c < _d.length; _c++) {
                            var otherBaseType = _d[_c];
                            if (otherBaseType === baseType)
                                continue;
                            var baseSymbol_1 = getPropertyOfObjectType(otherBaseType, base.escapedName);
                            var derivedElsewhere = baseSymbol_1 && getTargetSymbol(baseSymbol_1);
                            if (derivedElsewhere && derivedElsewhere !== base) {
                                continue basePropertyCheck;
                            }
                        }
                        if (derivedClassDecl.kind === 226 /* SyntaxKind.ClassExpression */) {
                            error(derivedClassDecl, ts.Diagnostics.Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1, symbolToString(baseProperty), typeToString(baseType));
                        }
                        else {
                            error(derivedClassDecl, ts.Diagnostics.Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2, typeToString(type), symbolToString(baseProperty), typeToString(baseType));
                        }
                    }
                }
                else {
                    // derived overrides base.
                    var derivedDeclarationFlags = ts.getDeclarationModifierFlagsFromSymbol(derived);
                    if (baseDeclarationFlags & 8 /* ModifierFlags.Private */ || derivedDeclarationFlags & 8 /* ModifierFlags.Private */) {
                        // either base or derived property is private - not override, skip it
                        continue;
                    }
                    var errorMessage = void 0;
                    var basePropertyFlags = base.flags & 98308 /* SymbolFlags.PropertyOrAccessor */;
                    var derivedPropertyFlags = derived.flags & 98308 /* SymbolFlags.PropertyOrAccessor */;
                    if (basePropertyFlags && derivedPropertyFlags) {
                        // property/accessor is overridden with property/accessor
                        if (baseDeclarationFlags & 128 /* ModifierFlags.Abstract */ && !(base.valueDeclaration && ts.isPropertyDeclaration(base.valueDeclaration) && base.valueDeclaration.initializer)
                            || base.valueDeclaration && base.valueDeclaration.parent.kind === 258 /* SyntaxKind.InterfaceDeclaration */
                            || derived.valueDeclaration && ts.isBinaryExpression(derived.valueDeclaration)) {
                            // when the base property is abstract or from an interface, base/derived flags don't need to match
                            // same when the derived property is from an assignment
                            continue;
                        }
                        var overriddenInstanceProperty = basePropertyFlags !== 4 /* SymbolFlags.Property */ && derivedPropertyFlags === 4 /* SymbolFlags.Property */;
                        var overriddenInstanceAccessor = basePropertyFlags === 4 /* SymbolFlags.Property */ && derivedPropertyFlags !== 4 /* SymbolFlags.Property */;
                        if (overriddenInstanceProperty || overriddenInstanceAccessor) {
                            var errorMessage_1 = overriddenInstanceProperty ?
                                ts.Diagnostics._0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property :
                                ts.Diagnostics._0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor;
                            error(ts.getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage_1, symbolToString(base), typeToString(baseType), typeToString(type));
                        }
                        else if (useDefineForClassFields) {
                            var uninitialized = (_a = derived.declarations) === null || _a === void 0 ? void 0 : _a.find(function (d) { return d.kind === 167 /* SyntaxKind.PropertyDeclaration */ && !d.initializer; });
                            if (uninitialized
                                && !(derived.flags & 33554432 /* SymbolFlags.Transient */)
                                && !(baseDeclarationFlags & 128 /* ModifierFlags.Abstract */)
                                && !(derivedDeclarationFlags & 128 /* ModifierFlags.Abstract */)
                                && !((_b = derived.declarations) === null || _b === void 0 ? void 0 : _b.some(function (d) { return !!(d.flags & 16777216 /* NodeFlags.Ambient */); }))) {
                                var constructor = findConstructorDeclaration(ts.getClassLikeDeclarationOfSymbol(type.symbol));
                                var propName = uninitialized.name;
                                if (uninitialized.exclamationToken
                                    || !constructor
                                    || !ts.isIdentifier(propName)
                                    || !strictNullChecks
                                    || !isPropertyInitializedInConstructor(propName, type, constructor)) {
                                    var errorMessage_2 = ts.Diagnostics.Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_add_a_declare_modifier_or_remove_the_redundant_declaration;
                                    error(ts.getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage_2, symbolToString(base), typeToString(baseType));
                                }
                            }
                        }
                        // correct case
                        continue;
                    }
                    else if (isPrototypeProperty(base)) {
                        if (isPrototypeProperty(derived) || derived.flags & 4 /* SymbolFlags.Property */) {
                            // method is overridden with method or property -- correct case
                            continue;
                        }
                        else {
                            ts.Debug.assert(!!(derived.flags & 98304 /* SymbolFlags.Accessor */));
                            errorMessage = ts.Diagnostics.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor;
                        }
                    }
                    else if (base.flags & 98304 /* SymbolFlags.Accessor */) {
                        errorMessage = ts.Diagnostics.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function;
                    }
                    else {
                        errorMessage = ts.Diagnostics.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function;
                    }
                    error(ts.getNameOfDeclaration(derived.valueDeclaration) || derived.valueDeclaration, errorMessage, typeToString(baseType), symbolToString(base), typeToString(type));
                }
            }
        }
        function getNonInterhitedProperties(type, baseTypes, properties) {
            if (!ts.length(baseTypes)) {
                return properties;
            }
            var seen = new ts.Map();
            ts.forEach(properties, function (p) {
                seen.set(p.escapedName, p);
            });
            for (var _i = 0, baseTypes_3 = baseTypes; _i < baseTypes_3.length; _i++) {
                var base = baseTypes_3[_i];
                var properties_5 = getPropertiesOfType(getTypeWithThisArgument(base, type.thisType));
                for (var _a = 0, properties_4 = properties_5; _a < properties_4.length; _a++) {
                    var prop = properties_4[_a];
                    var existing = seen.get(prop.escapedName);
                    if (existing && prop.parent === existing.parent) {
                        seen.delete(prop.escapedName);
                    }
                }
            }
            return ts.arrayFrom(seen.values());
        }
        function checkInheritedPropertiesAreIdentical(type, typeNode) {
            var baseTypes = getBaseTypes(type);
            if (baseTypes.length < 2) {
                return true;
            }
            var seen = new ts.Map();
            ts.forEach(resolveDeclaredMembers(type).declaredProperties, function (p) {
                seen.set(p.escapedName, { prop: p, containingType: type });
            });
            var ok = true;
            for (var _i = 0, baseTypes_4 = baseTypes; _i < baseTypes_4.length; _i++) {
                var base = baseTypes_4[_i];
                var properties = getPropertiesOfType(getTypeWithThisArgument(base, type.thisType));
                for (var _a = 0, properties_6 = properties; _a < properties_6.length; _a++) {
                    var prop = properties_6[_a];
                    var existing = seen.get(prop.escapedName);
                    if (!existing) {
                        seen.set(prop.escapedName, { prop: prop, containingType: base });
                    }
                    else {
                        var isInheritedProperty = existing.containingType !== type;
                        if (isInheritedProperty && !isPropertyIdenticalTo(existing.prop, prop)) {
                            ok = false;
                            var typeName1 = typeToString(existing.containingType);
                            var typeName2 = typeToString(base);
                            var errorInfo = ts.chainDiagnosticMessages(/*details*/ undefined, ts.Diagnostics.Named_property_0_of_types_1_and_2_are_not_identical, symbolToString(prop), typeName1, typeName2);
                            errorInfo = ts.chainDiagnosticMessages(errorInfo, ts.Diagnostics.Interface_0_cannot_simultaneously_extend_types_1_and_2, typeToString(type), typeName1, typeName2);
                            diagnostics.add(ts.createDiagnosticForNodeFromMessageChain(typeNode, errorInfo));
                        }
                    }
                }
            }
            return ok;
        }
        function checkPropertyInitialization(node) {
            if (!strictNullChecks || !strictPropertyInitialization || node.flags & 16777216 /* NodeFlags.Ambient */) {
                return;
            }
            var constructor = findConstructorDeclaration(node);
            for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                var member = _a[_i];
                if (ts.getEffectiveModifierFlags(member) & 2 /* ModifierFlags.Ambient */) {
                    continue;
                }
                if (!ts.isStatic(member) && isPropertyWithoutInitializer(member)) {
                    var propName = member.name;
                    if (ts.isIdentifier(propName) || ts.isPrivateIdentifier(propName) || ts.isComputedPropertyName(propName)) {
                        var type = getTypeOfSymbol(getSymbolOfNode(member));
                        if (!(type.flags & 3 /* TypeFlags.AnyOrUnknown */ || getFalsyFlags(type) & 32768 /* TypeFlags.Undefined */)) {
                            if (!constructor || !isPropertyInitializedInConstructor(propName, type, constructor)) {
                                error(member.name, ts.Diagnostics.Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor, ts.declarationNameToString(propName));
                            }
                        }
                    }
                }
            }
        }
        function isPropertyWithoutInitializer(node) {
            return node.kind === 167 /* SyntaxKind.PropertyDeclaration */ &&
                !ts.hasAbstractModifier(node) &&
                !node.exclamationToken &&
                !node.initializer;
        }
        function isPropertyInitializedInStaticBlocks(propName, propType, staticBlocks, startPos, endPos) {
            for (var _i = 0, staticBlocks_2 = staticBlocks; _i < staticBlocks_2.length; _i++) {
                var staticBlock = staticBlocks_2[_i];
                // static block must be within the provided range as they are evaluated in document order (unlike constructors)
                if (staticBlock.pos >= startPos && staticBlock.pos <= endPos) {
                    var reference = ts.factory.createPropertyAccessExpression(ts.factory.createThis(), propName);
                    ts.setParent(reference.expression, reference);
                    ts.setParent(reference, staticBlock);
                    reference.flowNode = staticBlock.returnFlowNode;
                    var flowType = getFlowTypeOfReference(reference, propType, getOptionalType(propType));
                    if (!(getFalsyFlags(flowType) & 32768 /* TypeFlags.Undefined */)) {
                        return true;
                    }
                }
            }
            return false;
        }
        function isPropertyInitializedInConstructor(propName, propType, constructor) {
            var reference = ts.isComputedPropertyName(propName)
                ? ts.factory.createElementAccessExpression(ts.factory.createThis(), propName.expression)
                : ts.factory.createPropertyAccessExpression(ts.factory.createThis(), propName);
            ts.setParent(reference.expression, reference);
            ts.setParent(reference, constructor);
            reference.flowNode = constructor.returnFlowNode;
            var flowType = getFlowTypeOfReference(reference, propType, getOptionalType(propType));
            return !(getFalsyFlags(flowType) & 32768 /* TypeFlags.Undefined */);
        }
        function checkInterfaceDeclaration(node) {
            // Grammar checking
            if (!checkGrammarDecoratorsAndModifiers(node))
                checkGrammarInterfaceDeclaration(node);
            checkTypeParameters(node.typeParameters);
            addLazyDiagnostic(function () {
                checkTypeNameIsReserved(node.name, ts.Diagnostics.Interface_name_cannot_be_0);
                checkExportsOnMergedDeclarations(node);
                var symbol = getSymbolOfNode(node);
                checkTypeParameterListsIdentical(symbol);
                // Only check this symbol once
                var firstInterfaceDecl = ts.getDeclarationOfKind(symbol, 258 /* SyntaxKind.InterfaceDeclaration */);
                if (node === firstInterfaceDecl) {
                    var type = getDeclaredTypeOfSymbol(symbol);
                    var typeWithThis = getTypeWithThisArgument(type);
                    // run subsequent checks only if first set succeeded
                    if (checkInheritedPropertiesAreIdentical(type, node.name)) {
                        for (var _i = 0, _a = getBaseTypes(type); _i < _a.length; _i++) {
                            var baseType = _a[_i];
                            checkTypeAssignableTo(typeWithThis, getTypeWithThisArgument(baseType, type.thisType), node.name, ts.Diagnostics.Interface_0_incorrectly_extends_interface_1);
                        }
                        checkIndexConstraints(type, symbol);
                    }
                }
                checkObjectTypeForDuplicateDeclarations(node);
            });
            ts.forEach(ts.getInterfaceBaseTypeNodes(node), function (heritageElement) {
                if (!ts.isEntityNameExpression(heritageElement.expression) || ts.isOptionalChain(heritageElement.expression)) {
                    error(heritageElement.expression, ts.Diagnostics.An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments);
                }
                checkTypeReferenceNode(heritageElement);
            });
            ts.forEach(node.members, checkSourceElement);
            addLazyDiagnostic(function () {
                checkTypeForDuplicateIndexSignatures(node);
                registerForUnusedIdentifiersCheck(node);
            });
        }
        function checkTypeAliasDeclaration(node) {
            // Grammar checking
            checkGrammarDecoratorsAndModifiers(node);
            checkTypeNameIsReserved(node.name, ts.Diagnostics.Type_alias_name_cannot_be_0);
            checkExportsOnMergedDeclarations(node);
            checkTypeParameters(node.typeParameters);
            if (node.type.kind === 138 /* SyntaxKind.IntrinsicKeyword */) {
                if (!intrinsicTypeKinds.has(node.name.escapedText) || ts.length(node.typeParameters) !== 1) {
                    error(node.type, ts.Diagnostics.The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types);
                }
            }
            else {
                checkSourceElement(node.type);
                registerForUnusedIdentifiersCheck(node);
            }
        }
        function computeEnumMemberValues(node) {
            var nodeLinks = getNodeLinks(node);
            if (!(nodeLinks.flags & 16384 /* NodeCheckFlags.EnumValuesComputed */)) {
                nodeLinks.flags |= 16384 /* NodeCheckFlags.EnumValuesComputed */;
                var autoValue = 0;
                for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                    var member = _a[_i];
                    var value = computeMemberValue(member, autoValue);
                    getNodeLinks(member).enumMemberValue = value;
                    autoValue = typeof value === "number" ? value + 1 : undefined;
                }
            }
        }
        function computeMemberValue(member, autoValue) {
            if (ts.isComputedNonLiteralName(member.name)) {
                error(member.name, ts.Diagnostics.Computed_property_names_are_not_allowed_in_enums);
            }
            else {
                var text = ts.getTextOfPropertyName(member.name);
                if (ts.isNumericLiteralName(text) && !ts.isInfinityOrNaNString(text)) {
                    error(member.name, ts.Diagnostics.An_enum_member_cannot_have_a_numeric_name);
                }
            }
            if (member.initializer) {
                return computeConstantValue(member);
            }
            // In ambient non-const numeric enum declarations, enum members without initializers are
            // considered computed members (as opposed to having auto-incremented values).
            if (member.parent.flags & 16777216 /* NodeFlags.Ambient */ && !ts.isEnumConst(member.parent) && getEnumKind(getSymbolOfNode(member.parent)) === 0 /* EnumKind.Numeric */) {
                return undefined;
            }
            // If the member declaration specifies no value, the member is considered a constant enum member.
            // If the member is the first member in the enum declaration, it is assigned the value zero.
            // Otherwise, it is assigned the value of the immediately preceding member plus one, and an error
            // occurs if the immediately preceding member is not a constant enum member.
            if (autoValue !== undefined) {
                return autoValue;
            }
            error(member.name, ts.Diagnostics.Enum_member_must_have_initializer);
            return undefined;
        }
        function computeConstantValue(member) {
            var enumKind = getEnumKind(getSymbolOfNode(member.parent));
            var isConstEnum = ts.isEnumConst(member.parent);
            var initializer = member.initializer;
            var value = enumKind === 1 /* EnumKind.Literal */ && !isLiteralEnumMember(member) ? undefined : evaluate(initializer);
            if (value !== undefined) {
                if (isConstEnum && typeof value === "number" && !isFinite(value)) {
                    error(initializer, isNaN(value) ?
                        ts.Diagnostics.const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN :
                        ts.Diagnostics.const_enum_member_initializer_was_evaluated_to_a_non_finite_value);
                }
            }
            else if (enumKind === 1 /* EnumKind.Literal */) {
                error(initializer, ts.Diagnostics.Computed_values_are_not_permitted_in_an_enum_with_string_valued_members);
                return 0;
            }
            else if (isConstEnum) {
                error(initializer, ts.Diagnostics.const_enum_member_initializers_can_only_contain_literal_values_and_other_computed_enum_values);
            }
            else if (member.parent.flags & 16777216 /* NodeFlags.Ambient */) {
                error(initializer, ts.Diagnostics.In_ambient_enum_declarations_member_initializer_must_be_constant_expression);
            }
            else {
                // Only here do we need to check that the initializer is assignable to the enum type.
                var source = checkExpression(initializer);
                if (!isTypeAssignableToKind(source, 296 /* TypeFlags.NumberLike */)) {
                    error(initializer, ts.Diagnostics.Only_numeric_enums_can_have_computed_members_but_this_expression_has_type_0_If_you_do_not_need_exhaustiveness_checks_consider_using_an_object_literal_instead, typeToString(source));
                }
                else {
                    checkTypeAssignableTo(source, getDeclaredTypeOfSymbol(getSymbolOfNode(member.parent)), initializer, /*headMessage*/ undefined);
                }
            }
            return value;
            function evaluate(expr) {
                switch (expr.kind) {
                    case 219 /* SyntaxKind.PrefixUnaryExpression */:
                        var value_2 = evaluate(expr.operand);
                        if (typeof value_2 === "number") {
                            switch (expr.operator) {
                                case 39 /* SyntaxKind.PlusToken */: return value_2;
                                case 40 /* SyntaxKind.MinusToken */: return -value_2;
                                case 54 /* SyntaxKind.TildeToken */: return ~value_2;
                            }
                        }
                        break;
                    case 221 /* SyntaxKind.BinaryExpression */:
                        var left = evaluate(expr.left);
                        var right = evaluate(expr.right);
                        if (typeof left === "number" && typeof right === "number") {
                            switch (expr.operatorToken.kind) {
                                case 51 /* SyntaxKind.BarToken */: return left | right;
                                case 50 /* SyntaxKind.AmpersandToken */: return left & right;
                                case 48 /* SyntaxKind.GreaterThanGreaterThanToken */: return left >> right;
                                case 49 /* SyntaxKind.GreaterThanGreaterThanGreaterThanToken */: return left >>> right;
                                case 47 /* SyntaxKind.LessThanLessThanToken */: return left << right;
                                case 52 /* SyntaxKind.CaretToken */: return left ^ right;
                                case 41 /* SyntaxKind.AsteriskToken */: return left * right;
                                case 43 /* SyntaxKind.SlashToken */: return left / right;
                                case 39 /* SyntaxKind.PlusToken */: return left + right;
                                case 40 /* SyntaxKind.MinusToken */: return left - right;
                                case 44 /* SyntaxKind.PercentToken */: return left % right;
                                case 42 /* SyntaxKind.AsteriskAsteriskToken */: return Math.pow(left, right);
                            }
                        }
                        else if (typeof left === "string" && typeof right === "string" && expr.operatorToken.kind === 39 /* SyntaxKind.PlusToken */) {
                            return left + right;
                        }
                        break;
                    case 10 /* SyntaxKind.StringLiteral */:
                    case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                        return expr.text;
                    case 8 /* SyntaxKind.NumericLiteral */:
                        checkGrammarNumericLiteral(expr);
                        return +expr.text;
                    case 212 /* SyntaxKind.ParenthesizedExpression */:
                        return evaluate(expr.expression);
                    case 79 /* SyntaxKind.Identifier */:
                        var identifier = expr;
                        if (ts.isInfinityOrNaNString(identifier.escapedText)) {
                            return +(identifier.escapedText);
                        }
                        return ts.nodeIsMissing(expr) ? 0 : evaluateEnumMember(expr, getSymbolOfNode(member.parent), identifier.escapedText);
                    case 207 /* SyntaxKind.ElementAccessExpression */:
                    case 206 /* SyntaxKind.PropertyAccessExpression */:
                        if (isConstantMemberAccess(expr)) {
                            var type = getTypeOfExpression(expr.expression);
                            if (type.symbol && type.symbol.flags & 384 /* SymbolFlags.Enum */) {
                                var name = void 0;
                                if (expr.kind === 206 /* SyntaxKind.PropertyAccessExpression */) {
                                    name = expr.name.escapedText;
                                }
                                else {
                                    name = ts.escapeLeadingUnderscores(ts.cast(expr.argumentExpression, ts.isLiteralExpression).text);
                                }
                                return evaluateEnumMember(expr, type.symbol, name);
                            }
                        }
                        break;
                }
                return undefined;
            }
            function evaluateEnumMember(expr, enumSymbol, name) {
                var memberSymbol = enumSymbol.exports.get(name);
                if (memberSymbol) {
                    var declaration = memberSymbol.valueDeclaration;
                    if (declaration !== member) {
                        if (declaration && isBlockScopedNameDeclaredBeforeUse(declaration, member) && ts.isEnumDeclaration(declaration.parent)) {
                            return getEnumMemberValue(declaration);
                        }
                        error(expr, ts.Diagnostics.A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums);
                        return 0;
                    }
                    else {
                        error(expr, ts.Diagnostics.Property_0_is_used_before_being_assigned, symbolToString(memberSymbol));
                    }
                }
                return undefined;
            }
        }
        function isConstantMemberAccess(node) {
            var type = getTypeOfExpression(node);
            if (type === errorType) {
                return false;
            }
            return node.kind === 79 /* SyntaxKind.Identifier */ ||
                node.kind === 206 /* SyntaxKind.PropertyAccessExpression */ && isConstantMemberAccess(node.expression) ||
                node.kind === 207 /* SyntaxKind.ElementAccessExpression */ && isConstantMemberAccess(node.expression) &&
                    ts.isStringLiteralLike(node.argumentExpression);
        }
        function checkEnumDeclaration(node) {
            addLazyDiagnostic(function () { return checkEnumDeclarationWorker(node); });
        }
        function checkEnumDeclarationWorker(node) {
            // Grammar checking
            checkGrammarDecoratorsAndModifiers(node);
            checkCollisionsForDeclarationName(node, node.name);
            checkExportsOnMergedDeclarations(node);
            node.members.forEach(checkEnumMember);
            computeEnumMemberValues(node);
            // Spec 2014 - Section 9.3:
            // It isn't possible for one enum declaration to continue the automatic numbering sequence of another,
            // and when an enum type has multiple declarations, only one declaration is permitted to omit a value
            // for the first member.
            //
            // Only perform this check once per symbol
            var enumSymbol = getSymbolOfNode(node);
            var firstDeclaration = ts.getDeclarationOfKind(enumSymbol, node.kind);
            if (node === firstDeclaration) {
                if (enumSymbol.declarations && enumSymbol.declarations.length > 1) {
                    var enumIsConst_1 = ts.isEnumConst(node);
                    // check that const is placed\omitted on all enum declarations
                    ts.forEach(enumSymbol.declarations, function (decl) {
                        if (ts.isEnumDeclaration(decl) && ts.isEnumConst(decl) !== enumIsConst_1) {
                            error(ts.getNameOfDeclaration(decl), ts.Diagnostics.Enum_declarations_must_all_be_const_or_non_const);
                        }
                    });
                }
                var seenEnumMissingInitialInitializer_1 = false;
                ts.forEach(enumSymbol.declarations, function (declaration) {
                    // return true if we hit a violation of the rule, false otherwise
                    if (declaration.kind !== 260 /* SyntaxKind.EnumDeclaration */) {
                        return false;
                    }
                    var enumDeclaration = declaration;
                    if (!enumDeclaration.members.length) {
                        return false;
                    }
                    var firstEnumMember = enumDeclaration.members[0];
                    if (!firstEnumMember.initializer) {
                        if (seenEnumMissingInitialInitializer_1) {
                            error(firstEnumMember.name, ts.Diagnostics.In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element);
                        }
                        else {
                            seenEnumMissingInitialInitializer_1 = true;
                        }
                    }
                });
            }
        }
        function checkEnumMember(node) {
            if (ts.isPrivateIdentifier(node.name)) {
                error(node, ts.Diagnostics.An_enum_member_cannot_be_named_with_a_private_identifier);
            }
        }
        function getFirstNonAmbientClassOrFunctionDeclaration(symbol) {
            var declarations = symbol.declarations;
            if (declarations) {
                for (var _i = 0, declarations_9 = declarations; _i < declarations_9.length; _i++) {
                    var declaration = declarations_9[_i];
                    if ((declaration.kind === 257 /* SyntaxKind.ClassDeclaration */ ||
                        (declaration.kind === 256 /* SyntaxKind.FunctionDeclaration */ && ts.nodeIsPresent(declaration.body))) &&
                        !(declaration.flags & 16777216 /* NodeFlags.Ambient */)) {
                        return declaration;
                    }
                }
            }
            return undefined;
        }
        function inSameLexicalScope(node1, node2) {
            var container1 = ts.getEnclosingBlockScopeContainer(node1);
            var container2 = ts.getEnclosingBlockScopeContainer(node2);
            if (isGlobalSourceFile(container1)) {
                return isGlobalSourceFile(container2);
            }
            else if (isGlobalSourceFile(container2)) {
                return false;
            }
            else {
                return container1 === container2;
            }
        }
        function checkModuleDeclaration(node) {
            if (node.body) {
                checkSourceElement(node.body);
                if (!ts.isGlobalScopeAugmentation(node)) {
                    registerForUnusedIdentifiersCheck(node);
                }
            }
            addLazyDiagnostic(checkModuleDeclarationDiagnostics);
            function checkModuleDeclarationDiagnostics() {
                // Grammar checking
                var isGlobalAugmentation = ts.isGlobalScopeAugmentation(node);
                var inAmbientContext = node.flags & 16777216 /* NodeFlags.Ambient */;
                if (isGlobalAugmentation && !inAmbientContext) {
                    error(node.name, ts.Diagnostics.Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context);
                }
                var isAmbientExternalModule = ts.isAmbientModule(node);
                var contextErrorMessage = isAmbientExternalModule
                    ? ts.Diagnostics.An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file
                    : ts.Diagnostics.A_namespace_declaration_is_only_allowed_at_the_top_level_of_a_namespace_or_module;
                if (checkGrammarModuleElementContext(node, contextErrorMessage)) {
                    // If we hit a module declaration in an illegal context, just bail out to avoid cascading errors.
                    return;
                }
                if (!checkGrammarDecoratorsAndModifiers(node)) {
                    if (!inAmbientContext && node.name.kind === 10 /* SyntaxKind.StringLiteral */) {
                        grammarErrorOnNode(node.name, ts.Diagnostics.Only_ambient_modules_can_use_quoted_names);
                    }
                }
                if (ts.isIdentifier(node.name)) {
                    checkCollisionsForDeclarationName(node, node.name);
                }
                checkExportsOnMergedDeclarations(node);
                var symbol = getSymbolOfNode(node);
                // The following checks only apply on a non-ambient instantiated module declaration.
                if (symbol.flags & 512 /* SymbolFlags.ValueModule */
                    && !inAmbientContext
                    && symbol.declarations
                    && symbol.declarations.length > 1
                    && isInstantiatedModule(node, ts.shouldPreserveConstEnums(compilerOptions))) {
                    var firstNonAmbientClassOrFunc = getFirstNonAmbientClassOrFunctionDeclaration(symbol);
                    if (firstNonAmbientClassOrFunc) {
                        if (ts.getSourceFileOfNode(node) !== ts.getSourceFileOfNode(firstNonAmbientClassOrFunc)) {
                            error(node.name, ts.Diagnostics.A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged);
                        }
                        else if (node.pos < firstNonAmbientClassOrFunc.pos) {
                            error(node.name, ts.Diagnostics.A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged);
                        }
                    }
                    // if the module merges with a class declaration in the same lexical scope,
                    // we need to track this to ensure the correct emit.
                    var mergedClass = ts.getDeclarationOfKind(symbol, 257 /* SyntaxKind.ClassDeclaration */);
                    if (mergedClass &&
                        inSameLexicalScope(node, mergedClass)) {
                        getNodeLinks(node).flags |= 32768 /* NodeCheckFlags.LexicalModuleMergesWithClass */;
                    }
                }
                if (isAmbientExternalModule) {
                    if (ts.isExternalModuleAugmentation(node)) {
                        // body of the augmentation should be checked for consistency only if augmentation was applied to its target (either global scope or module)
                        // otherwise we'll be swamped in cascading errors.
                        // We can detect if augmentation was applied using following rules:
                        // - augmentation for a global scope is always applied
                        // - augmentation for some external module is applied if symbol for augmentation is merged (it was combined with target module).
                        var checkBody = isGlobalAugmentation || (getSymbolOfNode(node).flags & 33554432 /* SymbolFlags.Transient */);
                        if (checkBody && node.body) {
                            for (var _i = 0, _a = node.body.statements; _i < _a.length; _i++) {
                                var statement = _a[_i];
                                checkModuleAugmentationElement(statement, isGlobalAugmentation);
                            }
                        }
                    }
                    else if (isGlobalSourceFile(node.parent)) {
                        if (isGlobalAugmentation) {
                            error(node.name, ts.Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations);
                        }
                        else if (ts.isExternalModuleNameRelative(ts.getTextOfIdentifierOrLiteral(node.name))) {
                            error(node.name, ts.Diagnostics.Ambient_module_declaration_cannot_specify_relative_module_name);
                        }
                    }
                    else {
                        if (isGlobalAugmentation) {
                            error(node.name, ts.Diagnostics.Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations);
                        }
                        else {
                            // Node is not an augmentation and is not located on the script level.
                            // This means that this is declaration of ambient module that is located in other module or namespace which is prohibited.
                            error(node.name, ts.Diagnostics.Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces);
                        }
                    }
                }
            }
        }
        function checkModuleAugmentationElement(node, isGlobalAugmentation) {
            var _a;
            switch (node.kind) {
                case 237 /* SyntaxKind.VariableStatement */:
                    // error each individual name in variable statement instead of marking the entire variable statement
                    for (var _i = 0, _b = node.declarationList.declarations; _i < _b.length; _i++) {
                        var decl = _b[_i];
                        checkModuleAugmentationElement(decl, isGlobalAugmentation);
                    }
                    break;
                case 271 /* SyntaxKind.ExportAssignment */:
                case 272 /* SyntaxKind.ExportDeclaration */:
                    grammarErrorOnFirstToken(node, ts.Diagnostics.Exports_and_export_assignments_are_not_permitted_in_module_augmentations);
                    break;
                case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                case 266 /* SyntaxKind.ImportDeclaration */:
                    grammarErrorOnFirstToken(node, ts.Diagnostics.Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_module);
                    break;
                case 203 /* SyntaxKind.BindingElement */:
                case 254 /* SyntaxKind.VariableDeclaration */:
                    var name = node.name;
                    if (ts.isBindingPattern(name)) {
                        for (var _c = 0, _d = name.elements; _c < _d.length; _c++) {
                            var el = _d[_c];
                            // mark individual names in binding pattern
                            checkModuleAugmentationElement(el, isGlobalAugmentation);
                        }
                        break;
                    }
                // falls through
                case 257 /* SyntaxKind.ClassDeclaration */:
                case 260 /* SyntaxKind.EnumDeclaration */:
                case 256 /* SyntaxKind.FunctionDeclaration */:
                case 258 /* SyntaxKind.InterfaceDeclaration */:
                case 261 /* SyntaxKind.ModuleDeclaration */:
                case 259 /* SyntaxKind.TypeAliasDeclaration */:
                    if (isGlobalAugmentation) {
                        return;
                    }
                    var symbol = getSymbolOfNode(node);
                    if (symbol) {
                        // module augmentations cannot introduce new names on the top level scope of the module
                        // this is done it two steps
                        // 1. quick check - if symbol for node is not merged - this is local symbol to this augmentation - report error
                        // 2. main check - report error if value declaration of the parent symbol is module augmentation)
                        var reportError = !(symbol.flags & 33554432 /* SymbolFlags.Transient */);
                        if (!reportError) {
                            // symbol should not originate in augmentation
                            reportError = !!((_a = symbol.parent) === null || _a === void 0 ? void 0 : _a.declarations) && ts.isExternalModuleAugmentation(symbol.parent.declarations[0]);
                        }
                    }
                    break;
            }
        }
        function getFirstNonModuleExportsIdentifier(node) {
            switch (node.kind) {
                case 79 /* SyntaxKind.Identifier */:
                    return node;
                case 161 /* SyntaxKind.QualifiedName */:
                    do {
                        node = node.left;
                    } while (node.kind !== 79 /* SyntaxKind.Identifier */);
                    return node;
                case 206 /* SyntaxKind.PropertyAccessExpression */:
                    do {
                        if (ts.isModuleExportsAccessExpression(node.expression) && !ts.isPrivateIdentifier(node.name)) {
                            return node.name;
                        }
                        node = node.expression;
                    } while (node.kind !== 79 /* SyntaxKind.Identifier */);
                    return node;
            }
        }
        function checkExternalImportOrExportDeclaration(node) {
            var moduleName = ts.getExternalModuleName(node);
            if (!moduleName || ts.nodeIsMissing(moduleName)) {
                // Should be a parse error.
                return false;
            }
            if (!ts.isStringLiteral(moduleName)) {
                error(moduleName, ts.Diagnostics.String_literal_expected);
                return false;
            }
            var inAmbientExternalModule = node.parent.kind === 262 /* SyntaxKind.ModuleBlock */ && ts.isAmbientModule(node.parent.parent);
            if (node.parent.kind !== 305 /* SyntaxKind.SourceFile */ && !inAmbientExternalModule) {
                error(moduleName, node.kind === 272 /* SyntaxKind.ExportDeclaration */ ?
                    ts.Diagnostics.Export_declarations_are_not_permitted_in_a_namespace :
                    ts.Diagnostics.Import_declarations_in_a_namespace_cannot_reference_a_module);
                return false;
            }
            if (inAmbientExternalModule && ts.isExternalModuleNameRelative(moduleName.text)) {
                // we have already reported errors on top level imports/exports in external module augmentations in checkModuleDeclaration
                // no need to do this again.
                if (!isTopLevelInExternalModuleAugmentation(node)) {
                    // TypeScript 1.0 spec (April 2013): 12.1.6
                    // An ExternalImportDeclaration in an AmbientExternalModuleDeclaration may reference
                    // other external modules only through top - level external module names.
                    // Relative external module names are not permitted.
                    error(node, ts.Diagnostics.Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name);
                    return false;
                }
            }
            if (!ts.isImportEqualsDeclaration(node) && node.assertClause) {
                var hasError = false;
                for (var _i = 0, _a = node.assertClause.elements; _i < _a.length; _i++) {
                    var clause = _a[_i];
                    if (!ts.isStringLiteral(clause.value)) {
                        hasError = true;
                        error(clause.value, ts.Diagnostics.Import_assertion_values_must_be_string_literal_expressions);
                    }
                }
                return !hasError;
            }
            return true;
        }
        function checkAliasSymbol(node) {
            var symbol = getSymbolOfNode(node);
            var target = resolveAlias(symbol);
            if (target !== unknownSymbol) {
                // For external modules, `symbol` represents the local symbol for an alias.
                // This local symbol will merge any other local declarations (excluding other aliases)
                // and symbol.flags will contains combined representation for all merged declaration.
                // Based on symbol.flags we can compute a set of excluded meanings (meaning that resolved alias should not have,
                // otherwise it will conflict with some local declaration). Note that in addition to normal flags we include matching SymbolFlags.Export*
                // in order to prevent collisions with declarations that were exported from the current module (they still contribute to local names).
                symbol = getMergedSymbol(symbol.exportSymbol || symbol);
                var excludedMeanings = (symbol.flags & (111551 /* SymbolFlags.Value */ | 1048576 /* SymbolFlags.ExportValue */) ? 111551 /* SymbolFlags.Value */ : 0) |
                    (symbol.flags & 788968 /* SymbolFlags.Type */ ? 788968 /* SymbolFlags.Type */ : 0) |
                    (symbol.flags & 1920 /* SymbolFlags.Namespace */ ? 1920 /* SymbolFlags.Namespace */ : 0);
                if (target.flags & excludedMeanings) {
                    var message = node.kind === 275 /* SyntaxKind.ExportSpecifier */ ?
                        ts.Diagnostics.Export_declaration_conflicts_with_exported_declaration_of_0 :
                        ts.Diagnostics.Import_declaration_conflicts_with_local_declaration_of_0;
                    error(node, message, symbolToString(symbol));
                }
                if (compilerOptions.isolatedModules
                    && !ts.isTypeOnlyImportOrExportDeclaration(node)
                    && !(node.flags & 16777216 /* NodeFlags.Ambient */)) {
                    var typeOnlyAlias = getTypeOnlyAliasDeclaration(symbol);
                    var isType = !(target.flags & 111551 /* SymbolFlags.Value */);
                    if (isType || typeOnlyAlias) {
                        switch (node.kind) {
                            case 267 /* SyntaxKind.ImportClause */:
                            case 270 /* SyntaxKind.ImportSpecifier */:
                            case 265 /* SyntaxKind.ImportEqualsDeclaration */: {
                                if (compilerOptions.preserveValueImports) {
                                    ts.Debug.assertIsDefined(node.name, "An ImportClause with a symbol should have a name");
                                    var message = isType
                                        ? ts.Diagnostics._0_is_a_type_and_must_be_imported_using_a_type_only_import_when_preserveValueImports_and_isolatedModules_are_both_enabled
                                        : ts.Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_preserveValueImports_and_isolatedModules_are_both_enabled;
                                    var name = ts.idText(node.kind === 270 /* SyntaxKind.ImportSpecifier */ ? node.propertyName || node.name : node.name);
                                    addTypeOnlyDeclarationRelatedInfo(error(node, message, name), isType ? undefined : typeOnlyAlias, name);
                                }
                                if (isType && node.kind === 265 /* SyntaxKind.ImportEqualsDeclaration */ && ts.hasEffectiveModifier(node, 1 /* ModifierFlags.Export */)) {
                                    error(node, ts.Diagnostics.Cannot_use_export_import_on_a_type_or_type_only_namespace_when_the_isolatedModules_flag_is_provided);
                                }
                                break;
                            }
                            case 275 /* SyntaxKind.ExportSpecifier */: {
                                // Don't allow re-exporting an export that will be elided when `--isolatedModules` is set.
                                // The exception is that `import type { A } from './a'; export { A }` is allowed
                                // because single-file analysis can determine that the export should be dropped.
                                if (ts.getSourceFileOfNode(typeOnlyAlias) !== ts.getSourceFileOfNode(node)) {
                                    var message = isType
                                        ? ts.Diagnostics.Re_exporting_a_type_when_the_isolatedModules_flag_is_provided_requires_using_export_type
                                        : ts.Diagnostics._0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_isolatedModules_is_enabled;
                                    var name = ts.idText(node.propertyName || node.name);
                                    addTypeOnlyDeclarationRelatedInfo(error(node, message, name), isType ? undefined : typeOnlyAlias, name);
                                    return;
                                }
                            }
                        }
                    }
                }
                if (ts.isImportSpecifier(node)) {
                    var targetSymbol = checkDeprecatedAliasedSymbol(symbol, node);
                    if (isDeprecatedAliasedSymbol(targetSymbol) && targetSymbol.declarations) {
                        addDeprecatedSuggestion(node, targetSymbol.declarations, targetSymbol.escapedName);
                    }
                }
            }
        }
        function isDeprecatedAliasedSymbol(symbol) {
            return !!symbol.declarations && ts.every(symbol.declarations, function (d) { return !!(ts.getCombinedNodeFlags(d) & 268435456 /* NodeFlags.Deprecated */); });
        }
        function checkDeprecatedAliasedSymbol(symbol, location) {
            if (!(symbol.flags & 2097152 /* SymbolFlags.Alias */))
                return symbol;
            var targetSymbol = resolveAlias(symbol);
            if (targetSymbol === unknownSymbol)
                return targetSymbol;
            while (symbol.flags & 2097152 /* SymbolFlags.Alias */) {
                var target = getImmediateAliasedSymbol(symbol);
                if (target) {
                    if (target === targetSymbol)
                        break;
                    if (target.declarations && ts.length(target.declarations)) {
                        if (isDeprecatedAliasedSymbol(target)) {
                            addDeprecatedSuggestion(location, target.declarations, target.escapedName);
                            break;
                        }
                        else {
                            if (symbol === targetSymbol)
                                break;
                            symbol = target;
                        }
                    }
                }
                else {
                    break;
                }
            }
            return targetSymbol;
        }
        function checkImportBinding(node) {
            checkCollisionsForDeclarationName(node, node.name);
            checkAliasSymbol(node);
            if (node.kind === 270 /* SyntaxKind.ImportSpecifier */ &&
                ts.idText(node.propertyName || node.name) === "default" &&
                ts.getESModuleInterop(compilerOptions) &&
                moduleKind !== ts.ModuleKind.System && (moduleKind < ts.ModuleKind.ES2015 || ts.getSourceFileOfNode(node).impliedNodeFormat === ts.ModuleKind.CommonJS)) {
                checkExternalEmitHelpers(node, 131072 /* ExternalEmitHelpers.ImportDefault */);
            }
        }
        function checkAssertClause(declaration) {
            var _a;
            if (declaration.assertClause) {
                var validForTypeAssertions = ts.isExclusivelyTypeOnlyImportOrExport(declaration);
                var override = ts.getResolutionModeOverrideForClause(declaration.assertClause, validForTypeAssertions ? grammarErrorOnNode : undefined);
                if (validForTypeAssertions && override) {
                    if (!ts.isNightly()) {
                        grammarErrorOnNode(declaration.assertClause, ts.Diagnostics.resolution_mode_assertions_are_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_with_npm_install_D_typescript_next);
                    }
                    if (ts.getEmitModuleResolutionKind(compilerOptions) !== ts.ModuleResolutionKind.Node16 && ts.getEmitModuleResolutionKind(compilerOptions) !== ts.ModuleResolutionKind.NodeNext) {
                        return grammarErrorOnNode(declaration.assertClause, ts.Diagnostics.resolution_mode_assertions_are_only_supported_when_moduleResolution_is_node16_or_nodenext);
                    }
                    return; // Other grammar checks do not apply to type-only imports with resolution mode assertions
                }
                var mode = (moduleKind === ts.ModuleKind.NodeNext) && declaration.moduleSpecifier && getUsageModeForExpression(declaration.moduleSpecifier);
                if (mode !== ts.ModuleKind.ESNext && moduleKind !== ts.ModuleKind.ESNext) {
                    return grammarErrorOnNode(declaration.assertClause, moduleKind === ts.ModuleKind.NodeNext
                        ? ts.Diagnostics.Import_assertions_are_not_allowed_on_statements_that_transpile_to_commonjs_require_calls
                        : ts.Diagnostics.Import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_or_nodenext);
                }
                if (ts.isImportDeclaration(declaration) ? (_a = declaration.importClause) === null || _a === void 0 ? void 0 : _a.isTypeOnly : declaration.isTypeOnly) {
                    return grammarErrorOnNode(declaration.assertClause, ts.Diagnostics.Import_assertions_cannot_be_used_with_type_only_imports_or_exports);
                }
                if (override) {
                    return grammarErrorOnNode(declaration.assertClause, ts.Diagnostics.resolution_mode_can_only_be_set_for_type_only_imports);
                }
            }
        }
        function checkImportDeclaration(node) {
            if (checkGrammarModuleElementContext(node, ts.isInJSFile(node) ? ts.Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_module : ts.Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module)) {
                // If we hit an import declaration in an illegal context, just bail out to avoid cascading errors.
                return;
            }
            if (!checkGrammarDecoratorsAndModifiers(node) && ts.hasEffectiveModifiers(node)) {
                grammarErrorOnFirstToken(node, ts.Diagnostics.An_import_declaration_cannot_have_modifiers);
            }
            if (checkExternalImportOrExportDeclaration(node)) {
                var importClause = node.importClause;
                if (importClause && !checkGrammarImportClause(importClause)) {
                    if (importClause.name) {
                        checkImportBinding(importClause);
                    }
                    if (importClause.namedBindings) {
                        if (importClause.namedBindings.kind === 268 /* SyntaxKind.NamespaceImport */) {
                            checkImportBinding(importClause.namedBindings);
                            if (moduleKind !== ts.ModuleKind.System && (moduleKind < ts.ModuleKind.ES2015 || ts.getSourceFileOfNode(node).impliedNodeFormat === ts.ModuleKind.CommonJS) && ts.getESModuleInterop(compilerOptions)) {
                                // import * as ns from "foo";
                                checkExternalEmitHelpers(node, 65536 /* ExternalEmitHelpers.ImportStar */);
                            }
                        }
                        else {
                            var moduleExisted = resolveExternalModuleName(node, node.moduleSpecifier);
                            if (moduleExisted) {
                                ts.forEach(importClause.namedBindings.elements, checkImportBinding);
                            }
                        }
                    }
                }
            }
            checkAssertClause(node);
        }
        function checkImportEqualsDeclaration(node) {
            if (checkGrammarModuleElementContext(node, ts.isInJSFile(node) ? ts.Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_module : ts.Diagnostics.An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module)) {
                // If we hit an import declaration in an illegal context, just bail out to avoid cascading errors.
                return;
            }
            checkGrammarDecoratorsAndModifiers(node);
            if (ts.isInternalModuleImportEqualsDeclaration(node) || checkExternalImportOrExportDeclaration(node)) {
                checkImportBinding(node);
                if (ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */)) {
                    markExportAsReferenced(node);
                }
                if (node.moduleReference.kind !== 277 /* SyntaxKind.ExternalModuleReference */) {
                    var target = resolveAlias(getSymbolOfNode(node));
                    if (target !== unknownSymbol) {
                        if (target.flags & 111551 /* SymbolFlags.Value */) {
                            // Target is a value symbol, check that it is not hidden by a local declaration with the same name
                            var moduleName = ts.getFirstIdentifier(node.moduleReference);
                            if (!(resolveEntityName(moduleName, 111551 /* SymbolFlags.Value */ | 1920 /* SymbolFlags.Namespace */).flags & 1920 /* SymbolFlags.Namespace */)) {
                                error(moduleName, ts.Diagnostics.Module_0_is_hidden_by_a_local_declaration_with_the_same_name, ts.declarationNameToString(moduleName));
                            }
                        }
                        if (target.flags & 788968 /* SymbolFlags.Type */) {
                            checkTypeNameIsReserved(node.name, ts.Diagnostics.Import_name_cannot_be_0);
                        }
                    }
                    if (node.isTypeOnly) {
                        grammarErrorOnNode(node, ts.Diagnostics.An_import_alias_cannot_use_import_type);
                    }
                }
                else {
                    if (moduleKind >= ts.ModuleKind.ES2015 && ts.getSourceFileOfNode(node).impliedNodeFormat === undefined && !node.isTypeOnly && !(node.flags & 16777216 /* NodeFlags.Ambient */)) {
                        // Import equals declaration is deprecated in es6 or above
                        grammarErrorOnNode(node, ts.Diagnostics.Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead);
                    }
                }
            }
        }
        function checkExportDeclaration(node) {
            if (checkGrammarModuleElementContext(node, ts.isInJSFile(node) ? ts.Diagnostics.An_export_declaration_can_only_be_used_at_the_top_level_of_a_module : ts.Diagnostics.An_export_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module)) {
                // If we hit an export in an illegal context, just bail out to avoid cascading errors.
                return;
            }
            if (!checkGrammarDecoratorsAndModifiers(node) && ts.hasSyntacticModifiers(node)) {
                grammarErrorOnFirstToken(node, ts.Diagnostics.An_export_declaration_cannot_have_modifiers);
            }
            if (node.moduleSpecifier && node.exportClause && ts.isNamedExports(node.exportClause) && ts.length(node.exportClause.elements) && languageVersion === 0 /* ScriptTarget.ES3 */) {
                checkExternalEmitHelpers(node, 4194304 /* ExternalEmitHelpers.CreateBinding */);
            }
            checkGrammarExportDeclaration(node);
            if (!node.moduleSpecifier || checkExternalImportOrExportDeclaration(node)) {
                if (node.exportClause && !ts.isNamespaceExport(node.exportClause)) {
                    // export { x, y }
                    // export { x, y } from "foo"
                    ts.forEach(node.exportClause.elements, checkExportSpecifier);
                    var inAmbientExternalModule = node.parent.kind === 262 /* SyntaxKind.ModuleBlock */ && ts.isAmbientModule(node.parent.parent);
                    var inAmbientNamespaceDeclaration = !inAmbientExternalModule && node.parent.kind === 262 /* SyntaxKind.ModuleBlock */ &&
                        !node.moduleSpecifier && node.flags & 16777216 /* NodeFlags.Ambient */;
                    if (node.parent.kind !== 305 /* SyntaxKind.SourceFile */ && !inAmbientExternalModule && !inAmbientNamespaceDeclaration) {
                        error(node, ts.Diagnostics.Export_declarations_are_not_permitted_in_a_namespace);
                    }
                }
                else {
                    // export * from "foo"
                    // export * as ns from "foo";
                    var moduleSymbol = resolveExternalModuleName(node, node.moduleSpecifier);
                    if (moduleSymbol && hasExportAssignmentSymbol(moduleSymbol)) {
                        error(node.moduleSpecifier, ts.Diagnostics.Module_0_uses_export_and_cannot_be_used_with_export_Asterisk, symbolToString(moduleSymbol));
                    }
                    else if (node.exportClause) {
                        checkAliasSymbol(node.exportClause);
                    }
                    if (moduleKind !== ts.ModuleKind.System && (moduleKind < ts.ModuleKind.ES2015 || ts.getSourceFileOfNode(node).impliedNodeFormat === ts.ModuleKind.CommonJS)) {
                        if (node.exportClause) {
                            // export * as ns from "foo";
                            // For ES2015 modules, we emit it as a pair of `import * as a_1 ...; export { a_1 as ns }` and don't need the helper.
                            // We only use the helper here when in esModuleInterop
                            if (ts.getESModuleInterop(compilerOptions)) {
                                checkExternalEmitHelpers(node, 65536 /* ExternalEmitHelpers.ImportStar */);
                            }
                        }
                        else {
                            // export * from "foo"
                            checkExternalEmitHelpers(node, 32768 /* ExternalEmitHelpers.ExportStar */);
                        }
                    }
                }
            }
            checkAssertClause(node);
        }
        function checkGrammarExportDeclaration(node) {
            var _a;
            if (node.isTypeOnly) {
                if (((_a = node.exportClause) === null || _a === void 0 ? void 0 : _a.kind) === 273 /* SyntaxKind.NamedExports */) {
                    return checkGrammarNamedImportsOrExports(node.exportClause);
                }
                else {
                    return grammarErrorOnNode(node, ts.Diagnostics.Only_named_exports_may_use_export_type);
                }
            }
            return false;
        }
        function checkGrammarModuleElementContext(node, errorMessage) {
            var isInAppropriateContext = node.parent.kind === 305 /* SyntaxKind.SourceFile */ || node.parent.kind === 262 /* SyntaxKind.ModuleBlock */ || node.parent.kind === 261 /* SyntaxKind.ModuleDeclaration */;
            if (!isInAppropriateContext) {
                grammarErrorOnFirstToken(node, errorMessage);
            }
            return !isInAppropriateContext;
        }
        function importClauseContainsReferencedImport(importClause) {
            return ts.forEachImportClauseDeclaration(importClause, function (declaration) {
                return !!getSymbolOfNode(declaration).isReferenced;
            });
        }
        function importClauseContainsConstEnumUsedAsValue(importClause) {
            return ts.forEachImportClauseDeclaration(importClause, function (declaration) {
                return !!getSymbolLinks(getSymbolOfNode(declaration)).constEnumReferenced;
            });
        }
        function canConvertImportDeclarationToTypeOnly(statement) {
            return ts.isImportDeclaration(statement) &&
                statement.importClause &&
                !statement.importClause.isTypeOnly &&
                importClauseContainsReferencedImport(statement.importClause) &&
                !isReferencedAliasDeclaration(statement.importClause, /*checkChildren*/ true) &&
                !importClauseContainsConstEnumUsedAsValue(statement.importClause);
        }
        function canConvertImportEqualsDeclarationToTypeOnly(statement) {
            return ts.isImportEqualsDeclaration(statement) &&
                ts.isExternalModuleReference(statement.moduleReference) &&
                !statement.isTypeOnly &&
                getSymbolOfNode(statement).isReferenced &&
                !isReferencedAliasDeclaration(statement, /*checkChildren*/ false) &&
                !getSymbolLinks(getSymbolOfNode(statement)).constEnumReferenced;
        }
        function checkImportsForTypeOnlyConversion(sourceFile) {
            for (var _i = 0, _a = sourceFile.statements; _i < _a.length; _i++) {
                var statement = _a[_i];
                if (canConvertImportDeclarationToTypeOnly(statement) || canConvertImportEqualsDeclarationToTypeOnly(statement)) {
                    error(statement, ts.Diagnostics.This_import_is_never_used_as_a_value_and_must_use_import_type_because_importsNotUsedAsValues_is_set_to_error);
                }
            }
        }
        function checkExportSpecifier(node) {
            checkAliasSymbol(node);
            if (ts.getEmitDeclarations(compilerOptions)) {
                collectLinkedAliases(node.propertyName || node.name, /*setVisibility*/ true);
            }
            if (!node.parent.parent.moduleSpecifier) {
                var exportedName = node.propertyName || node.name;
                // find immediate value referenced by exported name (SymbolFlags.Alias is set so we don't chase down aliases)
                var symbol = resolveName(exportedName, exportedName.escapedText, 111551 /* SymbolFlags.Value */ | 788968 /* SymbolFlags.Type */ | 1920 /* SymbolFlags.Namespace */ | 2097152 /* SymbolFlags.Alias */, 
                /*nameNotFoundMessage*/ undefined, /*nameArg*/ undefined, /*isUse*/ true);
                if (symbol && (symbol === undefinedSymbol || symbol === globalThisSymbol || symbol.declarations && isGlobalSourceFile(getDeclarationContainer(symbol.declarations[0])))) {
                    error(exportedName, ts.Diagnostics.Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module, ts.idText(exportedName));
                }
                else {
                    markExportAsReferenced(node);
                    var target = symbol && (symbol.flags & 2097152 /* SymbolFlags.Alias */ ? resolveAlias(symbol) : symbol);
                    if (!target || target === unknownSymbol || target.flags & 111551 /* SymbolFlags.Value */) {
                        checkExpressionCached(node.propertyName || node.name);
                    }
                }
            }
            else {
                if (ts.getESModuleInterop(compilerOptions) &&
                    moduleKind !== ts.ModuleKind.System &&
                    (moduleKind < ts.ModuleKind.ES2015 || ts.getSourceFileOfNode(node).impliedNodeFormat === ts.ModuleKind.CommonJS) &&
                    ts.idText(node.propertyName || node.name) === "default") {
                    checkExternalEmitHelpers(node, 131072 /* ExternalEmitHelpers.ImportDefault */);
                }
            }
        }
        function checkExportAssignment(node) {
            var illegalContextMessage = node.isExportEquals
                ? ts.Diagnostics.An_export_assignment_must_be_at_the_top_level_of_a_file_or_module_declaration
                : ts.Diagnostics.A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration;
            if (checkGrammarModuleElementContext(node, illegalContextMessage)) {
                // If we hit an export assignment in an illegal context, just bail out to avoid cascading errors.
                return;
            }
            var container = node.parent.kind === 305 /* SyntaxKind.SourceFile */ ? node.parent : node.parent.parent;
            if (container.kind === 261 /* SyntaxKind.ModuleDeclaration */ && !ts.isAmbientModule(container)) {
                if (node.isExportEquals) {
                    error(node, ts.Diagnostics.An_export_assignment_cannot_be_used_in_a_namespace);
                }
                else {
                    error(node, ts.Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module);
                }
                return;
            }
            // Grammar checking
            if (!checkGrammarDecoratorsAndModifiers(node) && ts.hasEffectiveModifiers(node)) {
                grammarErrorOnFirstToken(node, ts.Diagnostics.An_export_assignment_cannot_have_modifiers);
            }
            var typeAnnotationNode = ts.getEffectiveTypeAnnotationNode(node);
            if (typeAnnotationNode) {
                checkTypeAssignableTo(checkExpressionCached(node.expression), getTypeFromTypeNode(typeAnnotationNode), node.expression);
            }
            if (node.expression.kind === 79 /* SyntaxKind.Identifier */) {
                var id = node.expression;
                var sym = resolveEntityName(id, 67108863 /* SymbolFlags.All */, /*ignoreErrors*/ true, /*dontResolveAlias*/ true, node);
                if (sym) {
                    markAliasReferenced(sym, id);
                    // If not a value, we're interpreting the identifier as a type export, along the lines of (`export { Id as default }`)
                    var target = sym.flags & 2097152 /* SymbolFlags.Alias */ ? resolveAlias(sym) : sym;
                    if (target === unknownSymbol || target.flags & 111551 /* SymbolFlags.Value */) {
                        // However if it is a value, we need to check it's being used correctly
                        checkExpressionCached(node.expression);
                    }
                }
                else {
                    checkExpressionCached(node.expression); // doesn't resolve, check as expression to mark as error
                }
                if (ts.getEmitDeclarations(compilerOptions)) {
                    collectLinkedAliases(node.expression, /*setVisibility*/ true);
                }
            }
            else {
                checkExpressionCached(node.expression);
            }
            checkExternalModuleExports(container);
            if ((node.flags & 16777216 /* NodeFlags.Ambient */) && !ts.isEntityNameExpression(node.expression)) {
                grammarErrorOnNode(node.expression, ts.Diagnostics.The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context);
            }
            if (node.isExportEquals && !(node.flags & 16777216 /* NodeFlags.Ambient */)) {
                if (moduleKind >= ts.ModuleKind.ES2015 && ts.getSourceFileOfNode(node).impliedNodeFormat !== ts.ModuleKind.CommonJS) {
                    // export assignment is not supported in es6 modules
                    grammarErrorOnNode(node, ts.Diagnostics.Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or_another_module_format_instead);
                }
                else if (moduleKind === ts.ModuleKind.System) {
                    // system modules does not support export assignment
                    grammarErrorOnNode(node, ts.Diagnostics.Export_assignment_is_not_supported_when_module_flag_is_system);
                }
            }
        }
        function hasExportedMembers(moduleSymbol) {
            return ts.forEachEntry(moduleSymbol.exports, function (_, id) { return id !== "export="; });
        }
        function checkExternalModuleExports(node) {
            var moduleSymbol = getSymbolOfNode(node);
            var links = getSymbolLinks(moduleSymbol);
            if (!links.exportsChecked) {
                var exportEqualsSymbol = moduleSymbol.exports.get("export=");
                if (exportEqualsSymbol && hasExportedMembers(moduleSymbol)) {
                    var declaration = getDeclarationOfAliasSymbol(exportEqualsSymbol) || exportEqualsSymbol.valueDeclaration;
                    if (declaration && !isTopLevelInExternalModuleAugmentation(declaration) && !ts.isInJSFile(declaration)) {
                        error(declaration, ts.Diagnostics.An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements);
                    }
                }
                // Checks for export * conflicts
                var exports_3 = getExportsOfModule(moduleSymbol);
                if (exports_3) {
                    exports_3.forEach(function (_a, id) {
                        var declarations = _a.declarations, flags = _a.flags;
                        if (id === "__export") {
                            return;
                        }
                        // ECMA262: 15.2.1.1 It is a Syntax Error if the ExportedNames of ModuleItemList contains any duplicate entries.
                        // (TS Exceptions: namespaces, function overloads, enums, and interfaces)
                        if (flags & (1920 /* SymbolFlags.Namespace */ | 384 /* SymbolFlags.Enum */)) {
                            return;
                        }
                        var exportedDeclarationsCount = ts.countWhere(declarations, ts.and(isNotOverloadAndNotAccessor, ts.not(ts.isInterfaceDeclaration)));
                        if (flags & 524288 /* SymbolFlags.TypeAlias */ && exportedDeclarationsCount <= 2) {
                            // it is legal to merge type alias with other values
                            // so count should be either 1 (just type alias) or 2 (type alias + merged value)
                            return;
                        }
                        if (exportedDeclarationsCount > 1) {
                            if (!isDuplicatedCommonJSExport(declarations)) {
                                for (var _i = 0, _b = declarations; _i < _b.length; _i++) {
                                    var declaration = _b[_i];
                                    if (isNotOverload(declaration)) {
                                        diagnostics.add(ts.createDiagnosticForNode(declaration, ts.Diagnostics.Cannot_redeclare_exported_variable_0, ts.unescapeLeadingUnderscores(id)));
                                    }
                                }
                            }
                        }
                    });
                }
                links.exportsChecked = true;
            }
        }
        function isDuplicatedCommonJSExport(declarations) {
            return declarations
                && declarations.length > 1
                && declarations.every(function (d) { return ts.isInJSFile(d) && ts.isAccessExpression(d) && (ts.isExportsIdentifier(d.expression) || ts.isModuleExportsAccessExpression(d.expression)); });
        }
        function checkSourceElement(node) {
            if (node) {
                var saveCurrentNode = currentNode;
                currentNode = node;
                instantiationCount = 0;
                checkSourceElementWorker(node);
                currentNode = saveCurrentNode;
            }
        }
        function checkSourceElementWorker(node) {
            if (ts.isInJSFile(node)) {
                ts.forEach(node.jsDoc, function (_a) {
                    var tags = _a.tags;
                    return ts.forEach(tags, checkSourceElement);
                });
            }
            var kind = node.kind;
            if (cancellationToken) {
                // Only bother checking on a few construct kinds.  We don't want to be excessively
                // hitting the cancellation token on every node we check.
                switch (kind) {
                    case 261 /* SyntaxKind.ModuleDeclaration */:
                    case 257 /* SyntaxKind.ClassDeclaration */:
                    case 258 /* SyntaxKind.InterfaceDeclaration */:
                    case 256 /* SyntaxKind.FunctionDeclaration */:
                        cancellationToken.throwIfCancellationRequested();
                }
            }
            if (kind >= 237 /* SyntaxKind.FirstStatement */ && kind <= 253 /* SyntaxKind.LastStatement */ && node.flowNode && !isReachableFlowNode(node.flowNode)) {
                errorOrSuggestion(compilerOptions.allowUnreachableCode === false, node, ts.Diagnostics.Unreachable_code_detected);
            }
            switch (kind) {
                case 163 /* SyntaxKind.TypeParameter */:
                    return checkTypeParameter(node);
                case 164 /* SyntaxKind.Parameter */:
                    return checkParameter(node);
                case 167 /* SyntaxKind.PropertyDeclaration */:
                    return checkPropertyDeclaration(node);
                case 166 /* SyntaxKind.PropertySignature */:
                    return checkPropertySignature(node);
                case 180 /* SyntaxKind.ConstructorType */:
                case 179 /* SyntaxKind.FunctionType */:
                case 174 /* SyntaxKind.CallSignature */:
                case 175 /* SyntaxKind.ConstructSignature */:
                case 176 /* SyntaxKind.IndexSignature */:
                    return checkSignatureDeclaration(node);
                case 169 /* SyntaxKind.MethodDeclaration */:
                case 168 /* SyntaxKind.MethodSignature */:
                    return checkMethodDeclaration(node);
                case 170 /* SyntaxKind.ClassStaticBlockDeclaration */:
                    return checkClassStaticBlockDeclaration(node);
                case 171 /* SyntaxKind.Constructor */:
                    return checkConstructorDeclaration(node);
                case 172 /* SyntaxKind.GetAccessor */:
                case 173 /* SyntaxKind.SetAccessor */:
                    return checkAccessorDeclaration(node);
                case 178 /* SyntaxKind.TypeReference */:
                    return checkTypeReferenceNode(node);
                case 177 /* SyntaxKind.TypePredicate */:
                    return checkTypePredicate(node);
                case 181 /* SyntaxKind.TypeQuery */:
                    return checkTypeQuery(node);
                case 182 /* SyntaxKind.TypeLiteral */:
                    return checkTypeLiteral(node);
                case 183 /* SyntaxKind.ArrayType */:
                    return checkArrayType(node);
                case 184 /* SyntaxKind.TupleType */:
                    return checkTupleType(node);
                case 187 /* SyntaxKind.UnionType */:
                case 188 /* SyntaxKind.IntersectionType */:
                    return checkUnionOrIntersectionType(node);
                case 191 /* SyntaxKind.ParenthesizedType */:
                case 185 /* SyntaxKind.OptionalType */:
                case 186 /* SyntaxKind.RestType */:
                    return checkSourceElement(node.type);
                case 192 /* SyntaxKind.ThisType */:
                    return checkThisType(node);
                case 193 /* SyntaxKind.TypeOperator */:
                    return checkTypeOperator(node);
                case 189 /* SyntaxKind.ConditionalType */:
                    return checkConditionalType(node);
                case 190 /* SyntaxKind.InferType */:
                    return checkInferType(node);
                case 198 /* SyntaxKind.TemplateLiteralType */:
                    return checkTemplateLiteralType(node);
                case 200 /* SyntaxKind.ImportType */:
                    return checkImportType(node);
                case 197 /* SyntaxKind.NamedTupleMember */:
                    return checkNamedTupleMember(node);
                case 328 /* SyntaxKind.JSDocAugmentsTag */:
                    return checkJSDocAugmentsTag(node);
                case 329 /* SyntaxKind.JSDocImplementsTag */:
                    return checkJSDocImplementsTag(node);
                case 345 /* SyntaxKind.JSDocTypedefTag */:
                case 338 /* SyntaxKind.JSDocCallbackTag */:
                case 339 /* SyntaxKind.JSDocEnumTag */:
                    return checkJSDocTypeAliasTag(node);
                case 344 /* SyntaxKind.JSDocTemplateTag */:
                    return checkJSDocTemplateTag(node);
                case 343 /* SyntaxKind.JSDocTypeTag */:
                    return checkJSDocTypeTag(node);
                case 340 /* SyntaxKind.JSDocParameterTag */:
                    return checkJSDocParameterTag(node);
                case 347 /* SyntaxKind.JSDocPropertyTag */:
                    return checkJSDocPropertyTag(node);
                case 317 /* SyntaxKind.JSDocFunctionType */:
                    checkJSDocFunctionType(node);
                // falls through
                case 315 /* SyntaxKind.JSDocNonNullableType */:
                case 314 /* SyntaxKind.JSDocNullableType */:
                case 312 /* SyntaxKind.JSDocAllType */:
                case 313 /* SyntaxKind.JSDocUnknownType */:
                case 322 /* SyntaxKind.JSDocTypeLiteral */:
                    checkJSDocTypeIsInJsFile(node);
                    ts.forEachChild(node, checkSourceElement);
                    return;
                case 318 /* SyntaxKind.JSDocVariadicType */:
                    checkJSDocVariadicType(node);
                    return;
                case 309 /* SyntaxKind.JSDocTypeExpression */:
                    return checkSourceElement(node.type);
                case 333 /* SyntaxKind.JSDocPublicTag */:
                case 335 /* SyntaxKind.JSDocProtectedTag */:
                case 334 /* SyntaxKind.JSDocPrivateTag */:
                    return checkJSDocAccessibilityModifiers(node);
                case 194 /* SyntaxKind.IndexedAccessType */:
                    return checkIndexedAccessType(node);
                case 195 /* SyntaxKind.MappedType */:
                    return checkMappedType(node);
                case 256 /* SyntaxKind.FunctionDeclaration */:
                    return checkFunctionDeclaration(node);
                case 235 /* SyntaxKind.Block */:
                case 262 /* SyntaxKind.ModuleBlock */:
                    return checkBlock(node);
                case 237 /* SyntaxKind.VariableStatement */:
                    return checkVariableStatement(node);
                case 238 /* SyntaxKind.ExpressionStatement */:
                    return checkExpressionStatement(node);
                case 239 /* SyntaxKind.IfStatement */:
                    return checkIfStatement(node);
                case 240 /* SyntaxKind.DoStatement */:
                    return checkDoStatement(node);
                case 241 /* SyntaxKind.WhileStatement */:
                    return checkWhileStatement(node);
                case 242 /* SyntaxKind.ForStatement */:
                    return checkForStatement(node);
                case 243 /* SyntaxKind.ForInStatement */:
                    return checkForInStatement(node);
                case 244 /* SyntaxKind.ForOfStatement */:
                    return checkForOfStatement(node);
                case 245 /* SyntaxKind.ContinueStatement */:
                case 246 /* SyntaxKind.BreakStatement */:
                    return checkBreakOrContinueStatement(node);
                case 247 /* SyntaxKind.ReturnStatement */:
                    return checkReturnStatement(node);
                case 248 /* SyntaxKind.WithStatement */:
                    return checkWithStatement(node);
                case 249 /* SyntaxKind.SwitchStatement */:
                    return checkSwitchStatement(node);
                case 250 /* SyntaxKind.LabeledStatement */:
                    return checkLabeledStatement(node);
                case 251 /* SyntaxKind.ThrowStatement */:
                    return checkThrowStatement(node);
                case 252 /* SyntaxKind.TryStatement */:
                    return checkTryStatement(node);
                case 254 /* SyntaxKind.VariableDeclaration */:
                    return checkVariableDeclaration(node);
                case 203 /* SyntaxKind.BindingElement */:
                    return checkBindingElement(node);
                case 257 /* SyntaxKind.ClassDeclaration */:
                    return checkClassDeclaration(node);
                case 258 /* SyntaxKind.InterfaceDeclaration */:
                    return checkInterfaceDeclaration(node);
                case 259 /* SyntaxKind.TypeAliasDeclaration */:
                    return checkTypeAliasDeclaration(node);
                case 260 /* SyntaxKind.EnumDeclaration */:
                    return checkEnumDeclaration(node);
                case 261 /* SyntaxKind.ModuleDeclaration */:
                    return checkModuleDeclaration(node);
                case 266 /* SyntaxKind.ImportDeclaration */:
                    return checkImportDeclaration(node);
                case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                    return checkImportEqualsDeclaration(node);
                case 272 /* SyntaxKind.ExportDeclaration */:
                    return checkExportDeclaration(node);
                case 271 /* SyntaxKind.ExportAssignment */:
                    return checkExportAssignment(node);
                case 236 /* SyntaxKind.EmptyStatement */:
                case 253 /* SyntaxKind.DebuggerStatement */:
                    checkGrammarStatementInAmbientContext(node);
                    return;
                case 276 /* SyntaxKind.MissingDeclaration */:
                    return checkMissingDeclaration(node);
            }
        }
        function checkJSDocTypeIsInJsFile(node) {
            if (!ts.isInJSFile(node)) {
                grammarErrorOnNode(node, ts.Diagnostics.JSDoc_types_can_only_be_used_inside_documentation_comments);
            }
        }
        function checkJSDocVariadicType(node) {
            checkJSDocTypeIsInJsFile(node);
            checkSourceElement(node.type);
            // Only legal location is in the *last* parameter tag or last parameter of a JSDoc function.
            var parent = node.parent;
            if (ts.isParameter(parent) && ts.isJSDocFunctionType(parent.parent)) {
                if (ts.last(parent.parent.parameters) !== parent) {
                    error(node, ts.Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list);
                }
                return;
            }
            if (!ts.isJSDocTypeExpression(parent)) {
                error(node, ts.Diagnostics.JSDoc_may_only_appear_in_the_last_parameter_of_a_signature);
            }
            var paramTag = node.parent.parent;
            if (!ts.isJSDocParameterTag(paramTag)) {
                error(node, ts.Diagnostics.JSDoc_may_only_appear_in_the_last_parameter_of_a_signature);
                return;
            }
            var param = ts.getParameterSymbolFromJSDoc(paramTag);
            if (!param) {
                // We will error in `checkJSDocParameterTag`.
                return;
            }
            var host = ts.getHostSignatureFromJSDoc(paramTag);
            if (!host || ts.last(host.parameters).symbol !== param) {
                error(node, ts.Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list);
            }
        }
        function getTypeFromJSDocVariadicType(node) {
            var type = getTypeFromTypeNode(node.type);
            var parent = node.parent;
            var paramTag = node.parent.parent;
            if (ts.isJSDocTypeExpression(node.parent) && ts.isJSDocParameterTag(paramTag)) {
                // Else we will add a diagnostic, see `checkJSDocVariadicType`.
                var host_1 = ts.getHostSignatureFromJSDoc(paramTag);
                var isCallbackTag = ts.isJSDocCallbackTag(paramTag.parent.parent);
                if (host_1 || isCallbackTag) {
                    /*
                    Only return an array type if the corresponding parameter is marked as a rest parameter, or if there are no parameters.
                    So in the following situation we will not create an array type:
                        /** @param {...number} a * /
                        function f(a) {}
                    Because `a` will just be of type `number | undefined`. A synthetic `...args` will also be added, which *will* get an array type.
                    */
                    var lastParamDeclaration = isCallbackTag
                        ? ts.lastOrUndefined(paramTag.parent.parent.typeExpression.parameters)
                        : ts.lastOrUndefined(host_1.parameters);
                    var symbol = ts.getParameterSymbolFromJSDoc(paramTag);
                    if (!lastParamDeclaration ||
                        symbol && lastParamDeclaration.symbol === symbol && ts.isRestParameter(lastParamDeclaration)) {
                        return createArrayType(type);
                    }
                }
            }
            if (ts.isParameter(parent) && ts.isJSDocFunctionType(parent.parent)) {
                return createArrayType(type);
            }
            return addOptionality(type);
        }
        // Function and class expression bodies are checked after all statements in the enclosing body. This is
        // to ensure constructs like the following are permitted:
        //     const foo = function () {
        //        const s = foo();
        //        return "hello";
        //     }
        // Here, performing a full type check of the body of the function expression whilst in the process of
        // determining the type of foo would cause foo to be given type any because of the recursive reference.
        // Delaying the type check of the body ensures foo has been assigned a type.
        function checkNodeDeferred(node) {
            var enclosingFile = ts.getSourceFileOfNode(node);
            var links = getNodeLinks(enclosingFile);
            if (!(links.flags & 1 /* NodeCheckFlags.TypeChecked */)) {
                links.deferredNodes || (links.deferredNodes = new ts.Set());
                links.deferredNodes.add(node);
            }
        }
        function checkDeferredNodes(context) {
            var links = getNodeLinks(context);
            if (links.deferredNodes) {
                links.deferredNodes.forEach(checkDeferredNode);
            }
        }
        function checkDeferredNode(node) {
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("check" /* tracing.Phase.Check */, "checkDeferredNode", { kind: node.kind, pos: node.pos, end: node.end, path: node.tracingPath });
            var saveCurrentNode = currentNode;
            currentNode = node;
            instantiationCount = 0;
            switch (node.kind) {
                case 208 /* SyntaxKind.CallExpression */:
                case 209 /* SyntaxKind.NewExpression */:
                case 210 /* SyntaxKind.TaggedTemplateExpression */:
                case 165 /* SyntaxKind.Decorator */:
                case 280 /* SyntaxKind.JsxOpeningElement */:
                    // These node kinds are deferred checked when overload resolution fails
                    // To save on work, we ensure the arguments are checked just once, in
                    // a deferred way
                    resolveUntypedCall(node);
                    break;
                case 213 /* SyntaxKind.FunctionExpression */:
                case 214 /* SyntaxKind.ArrowFunction */:
                case 169 /* SyntaxKind.MethodDeclaration */:
                case 168 /* SyntaxKind.MethodSignature */:
                    checkFunctionExpressionOrObjectLiteralMethodDeferred(node);
                    break;
                case 172 /* SyntaxKind.GetAccessor */:
                case 173 /* SyntaxKind.SetAccessor */:
                    checkAccessorDeclaration(node);
                    break;
                case 226 /* SyntaxKind.ClassExpression */:
                    checkClassExpressionDeferred(node);
                    break;
                case 163 /* SyntaxKind.TypeParameter */:
                    checkTypeParameterDeferred(node);
                    break;
                case 279 /* SyntaxKind.JsxSelfClosingElement */:
                    checkJsxSelfClosingElementDeferred(node);
                    break;
                case 278 /* SyntaxKind.JsxElement */:
                    checkJsxElementDeferred(node);
                    break;
            }
            currentNode = saveCurrentNode;
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
        }
        function checkSourceFile(node) {
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("check" /* tracing.Phase.Check */, "checkSourceFile", { path: node.path }, /*separateBeginAndEnd*/ true);
            ts.performance.mark("beforeCheck");
            checkSourceFileWorker(node);
            ts.performance.mark("afterCheck");
            ts.performance.measure("Check", "beforeCheck", "afterCheck");
            ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
        }
        function unusedIsError(kind, isAmbient) {
            if (isAmbient) {
                return false;
            }
            switch (kind) {
                case 0 /* UnusedKind.Local */:
                    return !!compilerOptions.noUnusedLocals;
                case 1 /* UnusedKind.Parameter */:
                    return !!compilerOptions.noUnusedParameters;
                default:
                    return ts.Debug.assertNever(kind);
            }
        }
        function getPotentiallyUnusedIdentifiers(sourceFile) {
            return allPotentiallyUnusedIdentifiers.get(sourceFile.path) || ts.emptyArray;
        }
        // Fully type check a source file and collect the relevant diagnostics.
        function checkSourceFileWorker(node) {
            var links = getNodeLinks(node);
            if (!(links.flags & 1 /* NodeCheckFlags.TypeChecked */)) {
                if (ts.skipTypeChecking(node, compilerOptions, host)) {
                    return;
                }
                // Grammar checking
                checkGrammarSourceFile(node);
                ts.clear(potentialThisCollisions);
                ts.clear(potentialNewTargetCollisions);
                ts.clear(potentialWeakMapSetCollisions);
                ts.clear(potentialReflectCollisions);
                ts.forEach(node.statements, checkSourceElement);
                checkSourceElement(node.endOfFileToken);
                checkDeferredNodes(node);
                if (ts.isExternalOrCommonJsModule(node)) {
                    registerForUnusedIdentifiersCheck(node);
                }
                addLazyDiagnostic(function () {
                    // This relies on the results of other lazy diagnostics, so must be computed after them
                    if (!node.isDeclarationFile && (compilerOptions.noUnusedLocals || compilerOptions.noUnusedParameters)) {
                        checkUnusedIdentifiers(getPotentiallyUnusedIdentifiers(node), function (containingNode, kind, diag) {
                            if (!ts.containsParseError(containingNode) && unusedIsError(kind, !!(containingNode.flags & 16777216 /* NodeFlags.Ambient */))) {
                                diagnostics.add(diag);
                            }
                        });
                    }
                });
                if (compilerOptions.importsNotUsedAsValues === 2 /* ImportsNotUsedAsValues.Error */ &&
                    !node.isDeclarationFile &&
                    ts.isExternalModule(node)) {
                    checkImportsForTypeOnlyConversion(node);
                }
                if (ts.isExternalOrCommonJsModule(node)) {
                    checkExternalModuleExports(node);
                }
                if (potentialThisCollisions.length) {
                    ts.forEach(potentialThisCollisions, checkIfThisIsCapturedInEnclosingScope);
                    ts.clear(potentialThisCollisions);
                }
                if (potentialNewTargetCollisions.length) {
                    ts.forEach(potentialNewTargetCollisions, checkIfNewTargetIsCapturedInEnclosingScope);
                    ts.clear(potentialNewTargetCollisions);
                }
                if (potentialWeakMapSetCollisions.length) {
                    ts.forEach(potentialWeakMapSetCollisions, checkWeakMapSetCollision);
                    ts.clear(potentialWeakMapSetCollisions);
                }
                if (potentialReflectCollisions.length) {
                    ts.forEach(potentialReflectCollisions, checkReflectCollision);
                    ts.clear(potentialReflectCollisions);
                }
                links.flags |= 1 /* NodeCheckFlags.TypeChecked */;
            }
        }
        function getDiagnostics(sourceFile, ct) {
            try {
                // Record the cancellation token so it can be checked later on during checkSourceElement.
                // Do this in a finally block so we can ensure that it gets reset back to nothing after
                // this call is done.
                cancellationToken = ct;
                return getDiagnosticsWorker(sourceFile);
            }
            finally {
                cancellationToken = undefined;
            }
        }
        function ensurePendingDiagnosticWorkComplete() {
            // Invoke any existing lazy diagnostics to add them, clear the backlog of diagnostics
            for (var _i = 0, deferredDiagnosticsCallbacks_1 = deferredDiagnosticsCallbacks; _i < deferredDiagnosticsCallbacks_1.length; _i++) {
                var cb = deferredDiagnosticsCallbacks_1[_i];
                cb();
            }
            deferredDiagnosticsCallbacks = [];
        }
        function checkSourceFileWithEagerDiagnostics(sourceFile) {
            ensurePendingDiagnosticWorkComplete();
            // then setup diagnostics for immediate invocation (as we are about to collect them, and
            // this avoids the overhead of longer-lived callbacks we don't need to allocate)
            // This also serves to make the shift to possibly lazy diagnostics transparent to serial command-line scenarios
            // (as in those cases, all the diagnostics will still be computed as the appropriate place in the tree,
            // thus much more likely retaining the same union ordering as before we had lazy diagnostics)
            var oldAddLazyDiagnostics = addLazyDiagnostic;
            addLazyDiagnostic = function (cb) { return cb(); };
            checkSourceFile(sourceFile);
            addLazyDiagnostic = oldAddLazyDiagnostics;
        }
        function getDiagnosticsWorker(sourceFile) {
            if (sourceFile) {
                ensurePendingDiagnosticWorkComplete();
                // Some global diagnostics are deferred until they are needed and
                // may not be reported in the first call to getGlobalDiagnostics.
                // We should catch these changes and report them.
                var previousGlobalDiagnostics = diagnostics.getGlobalDiagnostics();
                var previousGlobalDiagnosticsSize = previousGlobalDiagnostics.length;
                checkSourceFileWithEagerDiagnostics(sourceFile);
                var semanticDiagnostics = diagnostics.getDiagnostics(sourceFile.fileName);
                var currentGlobalDiagnostics = diagnostics.getGlobalDiagnostics();
                if (currentGlobalDiagnostics !== previousGlobalDiagnostics) {
                    // If the arrays are not the same reference, new diagnostics were added.
                    var deferredGlobalDiagnostics = ts.relativeComplement(previousGlobalDiagnostics, currentGlobalDiagnostics, ts.compareDiagnostics);
                    return ts.concatenate(deferredGlobalDiagnostics, semanticDiagnostics);
                }
                else if (previousGlobalDiagnosticsSize === 0 && currentGlobalDiagnostics.length > 0) {
                    // If the arrays are the same reference, but the length has changed, a single
                    // new diagnostic was added as DiagnosticCollection attempts to reuse the
                    // same array.
                    return ts.concatenate(currentGlobalDiagnostics, semanticDiagnostics);
                }
                return semanticDiagnostics;
            }
            // Global diagnostics are always added when a file is not provided to
            // getDiagnostics
            ts.forEach(host.getSourceFiles(), checkSourceFileWithEagerDiagnostics);
            return diagnostics.getDiagnostics();
        }
        function getGlobalDiagnostics() {
            ensurePendingDiagnosticWorkComplete();
            return diagnostics.getGlobalDiagnostics();
        }
        // Language service support
        function getSymbolsInScope(location, meaning) {
            if (location.flags & 33554432 /* NodeFlags.InWithStatement */) {
                // We cannot answer semantic questions within a with block, do not proceed any further
                return [];
            }
            var symbols = ts.createSymbolTable();
            var isStaticSymbol = false;
            populateSymbols();
            symbols.delete("this" /* InternalSymbolName.This */); // Not a symbol, a keyword
            return symbolsToArray(symbols);
            function populateSymbols() {
                while (location) {
                    if (location.locals && !isGlobalSourceFile(location)) {
                        copySymbols(location.locals, meaning);
                    }
                    switch (location.kind) {
                        case 305 /* SyntaxKind.SourceFile */:
                            if (!ts.isExternalModule(location))
                                break;
                        // falls through
                        case 261 /* SyntaxKind.ModuleDeclaration */:
                            copyLocallyVisibleExportSymbols(getSymbolOfNode(location).exports, meaning & 2623475 /* SymbolFlags.ModuleMember */);
                            break;
                        case 260 /* SyntaxKind.EnumDeclaration */:
                            copySymbols(getSymbolOfNode(location).exports, meaning & 8 /* SymbolFlags.EnumMember */);
                            break;
                        case 226 /* SyntaxKind.ClassExpression */:
                            var className = location.name;
                            if (className) {
                                copySymbol(location.symbol, meaning);
                            }
                        // this fall-through is necessary because we would like to handle
                        // type parameter inside class expression similar to how we handle it in classDeclaration and interface Declaration.
                        // falls through
                        case 257 /* SyntaxKind.ClassDeclaration */:
                        case 258 /* SyntaxKind.InterfaceDeclaration */:
                            // If we didn't come from static member of class or interface,
                            // add the type parameters into the symbol table
                            // (type parameters of classDeclaration/classExpression and interface are in member property of the symbol.
                            // Note: that the memberFlags come from previous iteration.
                            if (!isStaticSymbol) {
                                copySymbols(getMembersOfSymbol(getSymbolOfNode(location)), meaning & 788968 /* SymbolFlags.Type */);
                            }
                            break;
                        case 213 /* SyntaxKind.FunctionExpression */:
                            var funcName = location.name;
                            if (funcName) {
                                copySymbol(location.symbol, meaning);
                            }
                            break;
                    }
                    if (ts.introducesArgumentsExoticObject(location)) {
                        copySymbol(argumentsSymbol, meaning);
                    }
                    isStaticSymbol = ts.isStatic(location);
                    location = location.parent;
                }
                copySymbols(globals, meaning);
            }
            /**
             * Copy the given symbol into symbol tables if the symbol has the given meaning
             * and it doesn't already existed in the symbol table
             * @param key a key for storing in symbol table; if undefined, use symbol.name
             * @param symbol the symbol to be added into symbol table
             * @param meaning meaning of symbol to filter by before adding to symbol table
             */
            function copySymbol(symbol, meaning) {
                if (ts.getCombinedLocalAndExportSymbolFlags(symbol) & meaning) {
                    var id = symbol.escapedName;
                    // We will copy all symbol regardless of its reserved name because
                    // symbolsToArray will check whether the key is a reserved name and
                    // it will not copy symbol with reserved name to the array
                    if (!symbols.has(id)) {
                        symbols.set(id, symbol);
                    }
                }
            }
            function copySymbols(source, meaning) {
                if (meaning) {
                    source.forEach(function (symbol) {
                        copySymbol(symbol, meaning);
                    });
                }
            }
            function copyLocallyVisibleExportSymbols(source, meaning) {
                if (meaning) {
                    source.forEach(function (symbol) {
                        // Similar condition as in `resolveNameHelper`
                        if (!ts.getDeclarationOfKind(symbol, 275 /* SyntaxKind.ExportSpecifier */) && !ts.getDeclarationOfKind(symbol, 274 /* SyntaxKind.NamespaceExport */)) {
                            copySymbol(symbol, meaning);
                        }
                    });
                }
            }
        }
        function isTypeDeclarationName(name) {
            return name.kind === 79 /* SyntaxKind.Identifier */ &&
                isTypeDeclaration(name.parent) &&
                ts.getNameOfDeclaration(name.parent) === name;
        }
        function isTypeDeclaration(node) {
            switch (node.kind) {
                case 163 /* SyntaxKind.TypeParameter */:
                case 257 /* SyntaxKind.ClassDeclaration */:
                case 258 /* SyntaxKind.InterfaceDeclaration */:
                case 259 /* SyntaxKind.TypeAliasDeclaration */:
                case 260 /* SyntaxKind.EnumDeclaration */:
                case 345 /* SyntaxKind.JSDocTypedefTag */:
                case 338 /* SyntaxKind.JSDocCallbackTag */:
                case 339 /* SyntaxKind.JSDocEnumTag */:
                    return true;
                case 267 /* SyntaxKind.ImportClause */:
                    return node.isTypeOnly;
                case 270 /* SyntaxKind.ImportSpecifier */:
                case 275 /* SyntaxKind.ExportSpecifier */:
                    return node.parent.parent.isTypeOnly;
                default:
                    return false;
            }
        }
        // True if the given identifier is part of a type reference
        function isTypeReferenceIdentifier(node) {
            while (node.parent.kind === 161 /* SyntaxKind.QualifiedName */) {
                node = node.parent;
            }
            return node.parent.kind === 178 /* SyntaxKind.TypeReference */;
        }
        function isHeritageClauseElementIdentifier(node) {
            while (node.parent.kind === 206 /* SyntaxKind.PropertyAccessExpression */) {
                node = node.parent;
            }
            return node.parent.kind === 228 /* SyntaxKind.ExpressionWithTypeArguments */;
        }
        function forEachEnclosingClass(node, callback) {
            var result;
            while (true) {
                node = ts.getContainingClass(node);
                if (!node)
                    break;
                if (result = callback(node))
                    break;
            }
            return result;
        }
        function isNodeUsedDuringClassInitialization(node) {
            return !!ts.findAncestor(node, function (element) {
                if (ts.isConstructorDeclaration(element) && ts.nodeIsPresent(element.body) || ts.isPropertyDeclaration(element)) {
                    return true;
                }
                else if (ts.isClassLike(element) || ts.isFunctionLikeDeclaration(element)) {
                    return "quit";
                }
                return false;
            });
        }
        function isNodeWithinClass(node, classDeclaration) {
            return !!forEachEnclosingClass(node, function (n) { return n === classDeclaration; });
        }
        function getLeftSideOfImportEqualsOrExportAssignment(nodeOnRightSide) {
            while (nodeOnRightSide.parent.kind === 161 /* SyntaxKind.QualifiedName */) {
                nodeOnRightSide = nodeOnRightSide.parent;
            }
            if (nodeOnRightSide.parent.kind === 265 /* SyntaxKind.ImportEqualsDeclaration */) {
                return nodeOnRightSide.parent.moduleReference === nodeOnRightSide ? nodeOnRightSide.parent : undefined;
            }
            if (nodeOnRightSide.parent.kind === 271 /* SyntaxKind.ExportAssignment */) {
                return nodeOnRightSide.parent.expression === nodeOnRightSide ? nodeOnRightSide.parent : undefined;
            }
            return undefined;
        }
        function isInRightSideOfImportOrExportAssignment(node) {
            return getLeftSideOfImportEqualsOrExportAssignment(node) !== undefined;
        }
        function getSpecialPropertyAssignmentSymbolFromEntityName(entityName) {
            var specialPropertyAssignmentKind = ts.getAssignmentDeclarationKind(entityName.parent.parent);
            switch (specialPropertyAssignmentKind) {
                case 1 /* AssignmentDeclarationKind.ExportsProperty */:
                case 3 /* AssignmentDeclarationKind.PrototypeProperty */:
                    return getSymbolOfNode(entityName.parent);
                case 4 /* AssignmentDeclarationKind.ThisProperty */:
                case 2 /* AssignmentDeclarationKind.ModuleExports */:
                case 5 /* AssignmentDeclarationKind.Property */:
                    return getSymbolOfNode(entityName.parent.parent);
            }
        }
        function isImportTypeQualifierPart(node) {
            var parent = node.parent;
            while (ts.isQualifiedName(parent)) {
                node = parent;
                parent = parent.parent;
            }
            if (parent && parent.kind === 200 /* SyntaxKind.ImportType */ && parent.qualifier === node) {
                return parent;
            }
            return undefined;
        }
        function getSymbolOfNameOrPropertyAccessExpression(name) {
            if (ts.isDeclarationName(name)) {
                return getSymbolOfNode(name.parent);
            }
            if (ts.isInJSFile(name) &&
                name.parent.kind === 206 /* SyntaxKind.PropertyAccessExpression */ &&
                name.parent === name.parent.parent.left) {
                // Check if this is a special property assignment
                if (!ts.isPrivateIdentifier(name) && !ts.isJSDocMemberName(name)) {
                    var specialPropertyAssignmentSymbol = getSpecialPropertyAssignmentSymbolFromEntityName(name);
                    if (specialPropertyAssignmentSymbol) {
                        return specialPropertyAssignmentSymbol;
                    }
                }
            }
            if (name.parent.kind === 271 /* SyntaxKind.ExportAssignment */ && ts.isEntityNameExpression(name)) {
                // Even an entity name expression that doesn't resolve as an entityname may still typecheck as a property access expression
                var success = resolveEntityName(name, 
                /*all meanings*/ 111551 /* SymbolFlags.Value */ | 788968 /* SymbolFlags.Type */ | 1920 /* SymbolFlags.Namespace */ | 2097152 /* SymbolFlags.Alias */, /*ignoreErrors*/ true);
                if (success && success !== unknownSymbol) {
                    return success;
                }
            }
            else if (ts.isEntityName(name) && isInRightSideOfImportOrExportAssignment(name)) {
                // Since we already checked for ExportAssignment, this really could only be an Import
                var importEqualsDeclaration = ts.getAncestor(name, 265 /* SyntaxKind.ImportEqualsDeclaration */);
                ts.Debug.assert(importEqualsDeclaration !== undefined);
                return getSymbolOfPartOfRightHandSideOfImportEquals(name, /*dontResolveAlias*/ true);
            }
            if (ts.isEntityName(name)) {
                var possibleImportNode = isImportTypeQualifierPart(name);
                if (possibleImportNode) {
                    getTypeFromTypeNode(possibleImportNode);
                    var sym = getNodeLinks(name).resolvedSymbol;
                    return sym === unknownSymbol ? undefined : sym;
                }
            }
            while (ts.isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName(name)) {
                name = name.parent;
            }
            if (isHeritageClauseElementIdentifier(name)) {
                var meaning = 0 /* SymbolFlags.None */;
                // In an interface or class, we're definitely interested in a type.
                if (name.parent.kind === 228 /* SyntaxKind.ExpressionWithTypeArguments */) {
                    meaning = 788968 /* SymbolFlags.Type */;
                    // In a class 'extends' clause we are also looking for a value.
                    if (ts.isExpressionWithTypeArgumentsInClassExtendsClause(name.parent)) {
                        meaning |= 111551 /* SymbolFlags.Value */;
                    }
                }
                else {
                    meaning = 1920 /* SymbolFlags.Namespace */;
                }
                meaning |= 2097152 /* SymbolFlags.Alias */;
                var entityNameSymbol = ts.isEntityNameExpression(name) ? resolveEntityName(name, meaning) : undefined;
                if (entityNameSymbol) {
                    return entityNameSymbol;
                }
            }
            if (name.parent.kind === 340 /* SyntaxKind.JSDocParameterTag */) {
                return ts.getParameterSymbolFromJSDoc(name.parent);
            }
            if (name.parent.kind === 163 /* SyntaxKind.TypeParameter */ && name.parent.parent.kind === 344 /* SyntaxKind.JSDocTemplateTag */) {
                ts.Debug.assert(!ts.isInJSFile(name)); // Otherwise `isDeclarationName` would have been true.
                var typeParameter = ts.getTypeParameterFromJsDoc(name.parent);
                return typeParameter && typeParameter.symbol;
            }
            if (ts.isExpressionNode(name)) {
                if (ts.nodeIsMissing(name)) {
                    // Missing entity name.
                    return undefined;
                }
                var isJSDoc_1 = ts.findAncestor(name, ts.or(ts.isJSDocLinkLike, ts.isJSDocNameReference, ts.isJSDocMemberName));
                var meaning = isJSDoc_1 ? 788968 /* SymbolFlags.Type */ | 1920 /* SymbolFlags.Namespace */ | 111551 /* SymbolFlags.Value */ : 111551 /* SymbolFlags.Value */;
                if (name.kind === 79 /* SyntaxKind.Identifier */) {
                    if (ts.isJSXTagName(name) && isJsxIntrinsicIdentifier(name)) {
                        var symbol = getIntrinsicTagSymbol(name.parent);
                        return symbol === unknownSymbol ? undefined : symbol;
                    }
                    var result = resolveEntityName(name, meaning, /*ignoreErrors*/ false, /* dontResolveAlias */ true, ts.getHostSignatureFromJSDoc(name));
                    if (!result && isJSDoc_1) {
                        var container = ts.findAncestor(name, ts.or(ts.isClassLike, ts.isInterfaceDeclaration));
                        if (container) {
                            return resolveJSDocMemberName(name, getSymbolOfNode(container));
                        }
                    }
                    return result;
                }
                else if (ts.isPrivateIdentifier(name)) {
                    return getSymbolForPrivateIdentifierExpression(name);
                }
                else if (name.kind === 206 /* SyntaxKind.PropertyAccessExpression */ || name.kind === 161 /* SyntaxKind.QualifiedName */) {
                    var links = getNodeLinks(name);
                    if (links.resolvedSymbol) {
                        return links.resolvedSymbol;
                    }
                    if (name.kind === 206 /* SyntaxKind.PropertyAccessExpression */) {
                        checkPropertyAccessExpression(name, 0 /* CheckMode.Normal */);
                    }
                    else {
                        checkQualifiedName(name, 0 /* CheckMode.Normal */);
                    }
                    if (!links.resolvedSymbol && isJSDoc_1 && ts.isQualifiedName(name)) {
                        return resolveJSDocMemberName(name);
                    }
                    return links.resolvedSymbol;
                }
                else if (ts.isJSDocMemberName(name)) {
                    return resolveJSDocMemberName(name);
                }
            }
            else if (isTypeReferenceIdentifier(name)) {
                var meaning = name.parent.kind === 178 /* SyntaxKind.TypeReference */ ? 788968 /* SymbolFlags.Type */ : 1920 /* SymbolFlags.Namespace */;
                var symbol = resolveEntityName(name, meaning, /*ignoreErrors*/ false, /*dontResolveAlias*/ true);
                return symbol && symbol !== unknownSymbol ? symbol : getUnresolvedSymbolForEntityName(name);
            }
            if (name.parent.kind === 177 /* SyntaxKind.TypePredicate */) {
                return resolveEntityName(name, /*meaning*/ 1 /* SymbolFlags.FunctionScopedVariable */);
            }
            return undefined;
        }
        /**
         * Recursively resolve entity names and jsdoc instance references:
         * 1. K#m as K.prototype.m for a class (or other value) K
         * 2. K.m as K.prototype.m
         * 3. I.m as I.m for a type I, or any other I.m that fails to resolve in (1) or (2)
         *
         * For unqualified names, a container K may be provided as a second argument.
         */
        function resolveJSDocMemberName(name, container) {
            if (ts.isEntityName(name)) {
                // resolve static values first
                var meaning = 788968 /* SymbolFlags.Type */ | 1920 /* SymbolFlags.Namespace */ | 111551 /* SymbolFlags.Value */;
                var symbol = resolveEntityName(name, meaning, /*ignoreErrors*/ false, /*dontResolveAlias*/ true, ts.getHostSignatureFromJSDoc(name));
                if (!symbol && ts.isIdentifier(name) && container) {
                    symbol = getMergedSymbol(getSymbol(getExportsOfSymbol(container), name.escapedText, meaning));
                }
                if (symbol) {
                    return symbol;
                }
            }
            var left = ts.isIdentifier(name) ? container : resolveJSDocMemberName(name.left);
            var right = ts.isIdentifier(name) ? name.escapedText : name.right.escapedText;
            if (left) {
                var proto = left.flags & 111551 /* SymbolFlags.Value */ && getPropertyOfType(getTypeOfSymbol(left), "prototype");
                var t = proto ? getTypeOfSymbol(proto) : getDeclaredTypeOfSymbol(left);
                return getPropertyOfType(t, right);
            }
        }
        function getSymbolAtLocation(node, ignoreErrors) {
            if (node.kind === 305 /* SyntaxKind.SourceFile */) {
                return ts.isExternalModule(node) ? getMergedSymbol(node.symbol) : undefined;
            }
            var parent = node.parent;
            var grandParent = parent.parent;
            if (node.flags & 33554432 /* NodeFlags.InWithStatement */) {
                // We cannot answer semantic questions within a with block, do not proceed any further
                return undefined;
            }
            if (isDeclarationNameOrImportPropertyName(node)) {
                // This is a declaration, call getSymbolOfNode
                var parentSymbol = getSymbolOfNode(parent);
                return ts.isImportOrExportSpecifier(node.parent) && node.parent.propertyName === node
                    ? getImmediateAliasedSymbol(parentSymbol)
                    : parentSymbol;
            }
            else if (ts.isLiteralComputedPropertyDeclarationName(node)) {
                return getSymbolOfNode(parent.parent);
            }
            if (node.kind === 79 /* SyntaxKind.Identifier */) {
                if (isInRightSideOfImportOrExportAssignment(node)) {
                    return getSymbolOfNameOrPropertyAccessExpression(node);
                }
                else if (parent.kind === 203 /* SyntaxKind.BindingElement */ &&
                    grandParent.kind === 201 /* SyntaxKind.ObjectBindingPattern */ &&
                    node === parent.propertyName) {
                    var typeOfPattern = getTypeOfNode(grandParent);
                    var propertyDeclaration = getPropertyOfType(typeOfPattern, node.escapedText);
                    if (propertyDeclaration) {
                        return propertyDeclaration;
                    }
                }
                else if (ts.isMetaProperty(parent) && parent.name === node) {
                    if (parent.keywordToken === 103 /* SyntaxKind.NewKeyword */ && ts.idText(node) === "target") {
                        // `target` in `new.target`
                        return checkNewTargetMetaProperty(parent).symbol;
                    }
                    // The `meta` in `import.meta` could be given `getTypeOfNode(parent).symbol` (the `ImportMeta` interface symbol), but
                    // we have a fake expression type made for other reasons already, whose transient `meta`
                    // member should more exactly be the kind of (declarationless) symbol we want.
                    // (See #44364 and #45031 for relevant implementation PRs)
                    if (parent.keywordToken === 100 /* SyntaxKind.ImportKeyword */ && ts.idText(node) === "meta") {
                        return getGlobalImportMetaExpressionType().members.get("meta");
                    }
                    // no other meta properties are valid syntax, thus no others should have symbols
                    return undefined;
                }
            }
            switch (node.kind) {
                case 79 /* SyntaxKind.Identifier */:
                case 80 /* SyntaxKind.PrivateIdentifier */:
                case 206 /* SyntaxKind.PropertyAccessExpression */:
                case 161 /* SyntaxKind.QualifiedName */:
                    if (!ts.isThisInTypeQuery(node)) {
                        return getSymbolOfNameOrPropertyAccessExpression(node);
                    }
                // falls through
                case 108 /* SyntaxKind.ThisKeyword */:
                    var container = ts.getThisContainer(node, /*includeArrowFunctions*/ false);
                    if (ts.isFunctionLike(container)) {
                        var sig = getSignatureFromDeclaration(container);
                        if (sig.thisParameter) {
                            return sig.thisParameter;
                        }
                    }
                    if (ts.isInExpressionContext(node)) {
                        return checkExpression(node).symbol;
                    }
                // falls through
                case 192 /* SyntaxKind.ThisType */:
                    return getTypeFromThisTypeNode(node).symbol;
                case 106 /* SyntaxKind.SuperKeyword */:
                    return checkExpression(node).symbol;
                case 134 /* SyntaxKind.ConstructorKeyword */:
                    // constructor keyword for an overload, should take us to the definition if it exist
                    var constructorDeclaration = node.parent;
                    if (constructorDeclaration && constructorDeclaration.kind === 171 /* SyntaxKind.Constructor */) {
                        return constructorDeclaration.parent.symbol;
                    }
                    return undefined;
                case 10 /* SyntaxKind.StringLiteral */:
                case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                    // 1). import x = require("./mo/*gotToDefinitionHere*/d")
                    // 2). External module name in an import declaration
                    // 3). Dynamic import call or require in javascript
                    // 4). type A = import("./f/*gotToDefinitionHere*/oo")
                    if ((ts.isExternalModuleImportEqualsDeclaration(node.parent.parent) && ts.getExternalModuleImportEqualsDeclarationExpression(node.parent.parent) === node) ||
                        ((node.parent.kind === 266 /* SyntaxKind.ImportDeclaration */ || node.parent.kind === 272 /* SyntaxKind.ExportDeclaration */) && node.parent.moduleSpecifier === node) ||
                        ((ts.isInJSFile(node) && ts.isRequireCall(node.parent, /*checkArgumentIsStringLiteralLike*/ false)) || ts.isImportCall(node.parent)) ||
                        (ts.isLiteralTypeNode(node.parent) && ts.isLiteralImportTypeNode(node.parent.parent) && node.parent.parent.argument === node.parent)) {
                        return resolveExternalModuleName(node, node, ignoreErrors);
                    }
                    if (ts.isCallExpression(parent) && ts.isBindableObjectDefinePropertyCall(parent) && parent.arguments[1] === node) {
                        return getSymbolOfNode(parent);
                    }
                // falls through
                case 8 /* SyntaxKind.NumericLiteral */:
                    // index access
                    var objectType = ts.isElementAccessExpression(parent)
                        ? parent.argumentExpression === node ? getTypeOfExpression(parent.expression) : undefined
                        : ts.isLiteralTypeNode(parent) && ts.isIndexedAccessTypeNode(grandParent)
                            ? getTypeFromTypeNode(grandParent.objectType)
                            : undefined;
                    return objectType && getPropertyOfType(objectType, ts.escapeLeadingUnderscores(node.text));
                case 88 /* SyntaxKind.DefaultKeyword */:
                case 98 /* SyntaxKind.FunctionKeyword */:
                case 38 /* SyntaxKind.EqualsGreaterThanToken */:
                case 84 /* SyntaxKind.ClassKeyword */:
                    return getSymbolOfNode(node.parent);
                case 200 /* SyntaxKind.ImportType */:
                    return ts.isLiteralImportTypeNode(node) ? getSymbolAtLocation(node.argument.literal, ignoreErrors) : undefined;
                case 93 /* SyntaxKind.ExportKeyword */:
                    return ts.isExportAssignment(node.parent) ? ts.Debug.checkDefined(node.parent.symbol) : undefined;
                case 100 /* SyntaxKind.ImportKeyword */:
                case 103 /* SyntaxKind.NewKeyword */:
                    return ts.isMetaProperty(node.parent) ? checkMetaPropertyKeyword(node.parent).symbol : undefined;
                case 231 /* SyntaxKind.MetaProperty */:
                    return checkExpression(node).symbol;
                default:
                    return undefined;
            }
        }
        function getIndexInfosAtLocation(node) {
            if (ts.isIdentifier(node) && ts.isPropertyAccessExpression(node.parent) && node.parent.name === node) {
                var keyType_1 = getLiteralTypeFromPropertyName(node);
                var objectType = getTypeOfExpression(node.parent.expression);
                var objectTypes = objectType.flags & 1048576 /* TypeFlags.Union */ ? objectType.types : [objectType];
                return ts.flatMap(objectTypes, function (t) { return ts.filter(getIndexInfosOfType(t), function (info) { return isApplicableIndexType(keyType_1, info.keyType); }); });
            }
            return undefined;
        }
        function getShorthandAssignmentValueSymbol(location) {
            if (location && location.kind === 297 /* SyntaxKind.ShorthandPropertyAssignment */) {
                return resolveEntityName(location.name, 111551 /* SymbolFlags.Value */ | 2097152 /* SymbolFlags.Alias */);
            }
            return undefined;
        }
        /** Returns the target of an export specifier without following aliases */
        function getExportSpecifierLocalTargetSymbol(node) {
            if (ts.isExportSpecifier(node)) {
                return node.parent.parent.moduleSpecifier ?
                    getExternalModuleMember(node.parent.parent, node) :
                    resolveEntityName(node.propertyName || node.name, 111551 /* SymbolFlags.Value */ | 788968 /* SymbolFlags.Type */ | 1920 /* SymbolFlags.Namespace */ | 2097152 /* SymbolFlags.Alias */);
            }
            else {
                return resolveEntityName(node, 111551 /* SymbolFlags.Value */ | 788968 /* SymbolFlags.Type */ | 1920 /* SymbolFlags.Namespace */ | 2097152 /* SymbolFlags.Alias */);
            }
        }
        function getTypeOfNode(node) {
            if (ts.isSourceFile(node) && !ts.isExternalModule(node)) {
                return errorType;
            }
            if (node.flags & 33554432 /* NodeFlags.InWithStatement */) {
                // We cannot answer semantic questions within a with block, do not proceed any further
                return errorType;
            }
            var classDecl = ts.tryGetClassImplementingOrExtendingExpressionWithTypeArguments(node);
            var classType = classDecl && getDeclaredTypeOfClassOrInterface(getSymbolOfNode(classDecl.class));
            if (ts.isPartOfTypeNode(node)) {
                var typeFromTypeNode = getTypeFromTypeNode(node);
                return classType ? getTypeWithThisArgument(typeFromTypeNode, classType.thisType) : typeFromTypeNode;
            }
            if (ts.isExpressionNode(node)) {
                return getRegularTypeOfExpression(node);
            }
            if (classType && !classDecl.isImplements) {
                // A SyntaxKind.ExpressionWithTypeArguments is considered a type node, except when it occurs in the
                // extends clause of a class. We handle that case here.
                var baseType = ts.firstOrUndefined(getBaseTypes(classType));
                return baseType ? getTypeWithThisArgument(baseType, classType.thisType) : errorType;
            }
            if (isTypeDeclaration(node)) {
                // In this case, we call getSymbolOfNode instead of getSymbolAtLocation because it is a declaration
                var symbol = getSymbolOfNode(node);
                return getDeclaredTypeOfSymbol(symbol);
            }
            if (isTypeDeclarationName(node)) {
                var symbol = getSymbolAtLocation(node);
                return symbol ? getDeclaredTypeOfSymbol(symbol) : errorType;
            }
            if (ts.isDeclaration(node)) {
                // In this case, we call getSymbolOfNode instead of getSymbolAtLocation because it is a declaration
                var symbol = getSymbolOfNode(node);
                return symbol ? getTypeOfSymbol(symbol) : errorType;
            }
            if (isDeclarationNameOrImportPropertyName(node)) {
                var symbol = getSymbolAtLocation(node);
                if (symbol) {
                    return getTypeOfSymbol(symbol);
                }
                return errorType;
            }
            if (ts.isBindingPattern(node)) {
                return getTypeForVariableLikeDeclaration(node.parent, /*includeOptionality*/ true, 0 /* CheckMode.Normal */) || errorType;
            }
            if (isInRightSideOfImportOrExportAssignment(node)) {
                var symbol = getSymbolAtLocation(node);
                if (symbol) {
                    var declaredType = getDeclaredTypeOfSymbol(symbol);
                    return !isErrorType(declaredType) ? declaredType : getTypeOfSymbol(symbol);
                }
            }
            if (ts.isMetaProperty(node.parent) && node.parent.keywordToken === node.kind) {
                return checkMetaPropertyKeyword(node.parent);
            }
            return errorType;
        }
        // Gets the type of object literal or array literal of destructuring assignment.
        // { a } from
        //     for ( { a } of elems) {
        //     }
        // [ a ] from
        //     [a] = [ some array ...]
        function getTypeOfAssignmentPattern(expr) {
            ts.Debug.assert(expr.kind === 205 /* SyntaxKind.ObjectLiteralExpression */ || expr.kind === 204 /* SyntaxKind.ArrayLiteralExpression */);
            // If this is from "for of"
            //     for ( { a } of elems) {
            //     }
            if (expr.parent.kind === 244 /* SyntaxKind.ForOfStatement */) {
                var iteratedType = checkRightHandSideOfForOf(expr.parent);
                return checkDestructuringAssignment(expr, iteratedType || errorType);
            }
            // If this is from "for" initializer
            //     for ({a } = elems[0];.....) { }
            if (expr.parent.kind === 221 /* SyntaxKind.BinaryExpression */) {
                var iteratedType = getTypeOfExpression(expr.parent.right);
                return checkDestructuringAssignment(expr, iteratedType || errorType);
            }
            // If this is from nested object binding pattern
            //     for ({ skills: { primary, secondary } } = multiRobot, i = 0; i < 1; i++) {
            if (expr.parent.kind === 296 /* SyntaxKind.PropertyAssignment */) {
                var node_3 = ts.cast(expr.parent.parent, ts.isObjectLiteralExpression);
                var typeOfParentObjectLiteral = getTypeOfAssignmentPattern(node_3) || errorType;
                var propertyIndex = ts.indexOfNode(node_3.properties, expr.parent);
                return checkObjectLiteralDestructuringPropertyAssignment(node_3, typeOfParentObjectLiteral, propertyIndex);
            }
            // Array literal assignment - array destructuring pattern
            var node = ts.cast(expr.parent, ts.isArrayLiteralExpression);
            //    [{ property1: p1, property2 }] = elems;
            var typeOfArrayLiteral = getTypeOfAssignmentPattern(node) || errorType;
            var elementType = checkIteratedTypeOrElementType(65 /* IterationUse.Destructuring */, typeOfArrayLiteral, undefinedType, expr.parent) || errorType;
            return checkArrayLiteralDestructuringElementAssignment(node, typeOfArrayLiteral, node.elements.indexOf(expr), elementType);
        }
        // Gets the property symbol corresponding to the property in destructuring assignment
        // 'property1' from
        //     for ( { property1: a } of elems) {
        //     }
        // 'property1' at location 'a' from:
        //     [a] = [ property1, property2 ]
        function getPropertySymbolOfDestructuringAssignment(location) {
            // Get the type of the object or array literal and then look for property of given name in the type
            var typeOfObjectLiteral = getTypeOfAssignmentPattern(ts.cast(location.parent.parent, ts.isAssignmentPattern));
            return typeOfObjectLiteral && getPropertyOfType(typeOfObjectLiteral, location.escapedText);
        }
        function getRegularTypeOfExpression(expr) {
            if (ts.isRightSideOfQualifiedNameOrPropertyAccess(expr)) {
                expr = expr.parent;
            }
            return getRegularTypeOfLiteralType(getTypeOfExpression(expr));
        }
        /**
         * Gets either the static or instance type of a class element, based on
         * whether the element is declared as "static".
         */
        function getParentTypeOfClassElement(node) {
            var classSymbol = getSymbolOfNode(node.parent);
            return ts.isStatic(node)
                ? getTypeOfSymbol(classSymbol)
                : getDeclaredTypeOfSymbol(classSymbol);
        }
        function getClassElementPropertyKeyType(element) {
            var name = element.name;
            switch (name.kind) {
                case 79 /* SyntaxKind.Identifier */:
                    return getStringLiteralType(ts.idText(name));
                case 8 /* SyntaxKind.NumericLiteral */:
                case 10 /* SyntaxKind.StringLiteral */:
                    return getStringLiteralType(name.text);
                case 162 /* SyntaxKind.ComputedPropertyName */:
                    var nameType = checkComputedPropertyName(name);
                    return isTypeAssignableToKind(nameType, 12288 /* TypeFlags.ESSymbolLike */) ? nameType : stringType;
                default:
                    return ts.Debug.fail("Unsupported property name.");
            }
        }
        // Return the list of properties of the given type, augmented with properties from Function
        // if the type has call or construct signatures
        function getAugmentedPropertiesOfType(type) {
            type = getApparentType(type);
            var propsByName = ts.createSymbolTable(getPropertiesOfType(type));
            var functionType = getSignaturesOfType(type, 0 /* SignatureKind.Call */).length ? globalCallableFunctionType :
                getSignaturesOfType(type, 1 /* SignatureKind.Construct */).length ? globalNewableFunctionType :
                    undefined;
            if (functionType) {
                ts.forEach(getPropertiesOfType(functionType), function (p) {
                    if (!propsByName.has(p.escapedName)) {
                        propsByName.set(p.escapedName, p);
                    }
                });
            }
            return getNamedMembers(propsByName);
        }
        function typeHasCallOrConstructSignatures(type) {
            return ts.typeHasCallOrConstructSignatures(type, checker);
        }
        function getRootSymbols(symbol) {
            var roots = getImmediateRootSymbols(symbol);
            return roots ? ts.flatMap(roots, getRootSymbols) : [symbol];
        }
        function getImmediateRootSymbols(symbol) {
            if (ts.getCheckFlags(symbol) & 6 /* CheckFlags.Synthetic */) {
                return ts.mapDefined(getSymbolLinks(symbol).containingType.types, function (type) { return getPropertyOfType(type, symbol.escapedName); });
            }
            else if (symbol.flags & 33554432 /* SymbolFlags.Transient */) {
                var _a = symbol, leftSpread = _a.leftSpread, rightSpread = _a.rightSpread, syntheticOrigin = _a.syntheticOrigin;
                return leftSpread ? [leftSpread, rightSpread]
                    : syntheticOrigin ? [syntheticOrigin]
                        : ts.singleElementArray(tryGetTarget(symbol));
            }
            return undefined;
        }
        function tryGetTarget(symbol) {
            var target;
            var next = symbol;
            while (next = getSymbolLinks(next).target) {
                target = next;
            }
            return target;
        }
        // Emitter support
        function isArgumentsLocalBinding(nodeIn) {
            // Note: does not handle isShorthandPropertyAssignment (and probably a few more)
            if (ts.isGeneratedIdentifier(nodeIn))
                return false;
            var node = ts.getParseTreeNode(nodeIn, ts.isIdentifier);
            if (!node)
                return false;
            var parent = node.parent;
            if (!parent)
                return false;
            var isPropertyName = ((ts.isPropertyAccessExpression(parent)
                || ts.isPropertyAssignment(parent))
                && parent.name === node);
            return !isPropertyName && getReferencedValueSymbol(node) === argumentsSymbol;
        }
        function moduleExportsSomeValue(moduleReferenceExpression) {
            var moduleSymbol = resolveExternalModuleName(moduleReferenceExpression.parent, moduleReferenceExpression);
            if (!moduleSymbol || ts.isShorthandAmbientModuleSymbol(moduleSymbol)) {
                // If the module is not found or is shorthand, assume that it may export a value.
                return true;
            }
            var hasExportAssignment = hasExportAssignmentSymbol(moduleSymbol);
            // if module has export assignment then 'resolveExternalModuleSymbol' will return resolved symbol for export assignment
            // otherwise it will return moduleSymbol itself
            moduleSymbol = resolveExternalModuleSymbol(moduleSymbol);
            var symbolLinks = getSymbolLinks(moduleSymbol);
            if (symbolLinks.exportsSomeValue === undefined) {
                // for export assignments - check if resolved symbol for RHS is itself a value
                // otherwise - check if at least one export is value
                symbolLinks.exportsSomeValue = hasExportAssignment
                    ? !!(moduleSymbol.flags & 111551 /* SymbolFlags.Value */)
                    : ts.forEachEntry(getExportsOfModule(moduleSymbol), isValue);
            }
            return symbolLinks.exportsSomeValue;
            function isValue(s) {
                s = resolveSymbol(s);
                return s && !!(s.flags & 111551 /* SymbolFlags.Value */);
            }
        }
        function isNameOfModuleOrEnumDeclaration(node) {
            return ts.isModuleOrEnumDeclaration(node.parent) && node === node.parent.name;
        }
        // When resolved as an expression identifier, if the given node references an exported entity, return the declaration
        // node of the exported entity's container. Otherwise, return undefined.
        function getReferencedExportContainer(nodeIn, prefixLocals) {
            var _a;
            var node = ts.getParseTreeNode(nodeIn, ts.isIdentifier);
            if (node) {
                // When resolving the export container for the name of a module or enum
                // declaration, we need to start resolution at the declaration's container.
                // Otherwise, we could incorrectly resolve the export container as the
                // declaration if it contains an exported member with the same name.
                var symbol = getReferencedValueSymbol(node, /*startInDeclarationContainer*/ isNameOfModuleOrEnumDeclaration(node));
                if (symbol) {
                    if (symbol.flags & 1048576 /* SymbolFlags.ExportValue */) {
                        // If we reference an exported entity within the same module declaration, then whether
                        // we prefix depends on the kind of entity. SymbolFlags.ExportHasLocal encompasses all the
                        // kinds that we do NOT prefix.
                        var exportSymbol = getMergedSymbol(symbol.exportSymbol);
                        if (!prefixLocals && exportSymbol.flags & 944 /* SymbolFlags.ExportHasLocal */ && !(exportSymbol.flags & 3 /* SymbolFlags.Variable */)) {
                            return undefined;
                        }
                        symbol = exportSymbol;
                    }
                    var parentSymbol_1 = getParentOfSymbol(symbol);
                    if (parentSymbol_1) {
                        if (parentSymbol_1.flags & 512 /* SymbolFlags.ValueModule */ && ((_a = parentSymbol_1.valueDeclaration) === null || _a === void 0 ? void 0 : _a.kind) === 305 /* SyntaxKind.SourceFile */) {
                            var symbolFile = parentSymbol_1.valueDeclaration;
                            var referenceFile = ts.getSourceFileOfNode(node);
                            // If `node` accesses an export and that export isn't in the same file, then symbol is a namespace export, so return undefined.
                            var symbolIsUmdExport = symbolFile !== referenceFile;
                            return symbolIsUmdExport ? undefined : symbolFile;
                        }
                        return ts.findAncestor(node.parent, function (n) { return ts.isModuleOrEnumDeclaration(n) && getSymbolOfNode(n) === parentSymbol_1; });
                    }
                }
            }
        }
        // When resolved as an expression identifier, if the given node references an import, return the declaration of
        // that import. Otherwise, return undefined.
        function getReferencedImportDeclaration(nodeIn) {
            if (nodeIn.generatedImportReference) {
                return nodeIn.generatedImportReference;
            }
            var node = ts.getParseTreeNode(nodeIn, ts.isIdentifier);
            if (node) {
                var symbol = getReferencedValueSymbol(node);
                // We should only get the declaration of an alias if there isn't a local value
                // declaration for the symbol
                if (isNonLocalAlias(symbol, /*excludes*/ 111551 /* SymbolFlags.Value */) && !getTypeOnlyAliasDeclaration(symbol)) {
                    return getDeclarationOfAliasSymbol(symbol);
                }
            }
            return undefined;
        }
        function isSymbolOfDestructuredElementOfCatchBinding(symbol) {
            return symbol.valueDeclaration
                && ts.isBindingElement(symbol.valueDeclaration)
                && ts.walkUpBindingElementsAndPatterns(symbol.valueDeclaration).parent.kind === 292 /* SyntaxKind.CatchClause */;
        }
        function isSymbolOfDeclarationWithCollidingName(symbol) {
            if (symbol.flags & 418 /* SymbolFlags.BlockScoped */ && symbol.valueDeclaration && !ts.isSourceFile(symbol.valueDeclaration)) {
                var links = getSymbolLinks(symbol);
                if (links.isDeclarationWithCollidingName === undefined) {
                    var container = ts.getEnclosingBlockScopeContainer(symbol.valueDeclaration);
                    if (ts.isStatementWithLocals(container) || isSymbolOfDestructuredElementOfCatchBinding(symbol)) {
                        var nodeLinks_1 = getNodeLinks(symbol.valueDeclaration);
                        if (resolveName(container.parent, symbol.escapedName, 111551 /* SymbolFlags.Value */, /*nameNotFoundMessage*/ undefined, /*nameArg*/ undefined, /*isUse*/ false)) {
                            // redeclaration - always should be renamed
                            links.isDeclarationWithCollidingName = true;
                        }
                        else if (nodeLinks_1.flags & 262144 /* NodeCheckFlags.CapturedBlockScopedBinding */) {
                            // binding is captured in the function
                            // should be renamed if:
                            // - binding is not top level - top level bindings never collide with anything
                            // AND
                            //   - binding is not declared in loop, should be renamed to avoid name reuse across siblings
                            //     let a, b
                            //     { let x = 1; a = () => x; }
                            //     { let x = 100; b = () => x; }
                            //     console.log(a()); // should print '1'
                            //     console.log(b()); // should print '100'
                            //     OR
                            //   - binding is declared inside loop but not in inside initializer of iteration statement or directly inside loop body
                            //     * variables from initializer are passed to rewritten loop body as parameters so they are not captured directly
                            //     * variables that are declared immediately in loop body will become top level variable after loop is rewritten and thus
                            //       they will not collide with anything
                            var isDeclaredInLoop = nodeLinks_1.flags & 524288 /* NodeCheckFlags.BlockScopedBindingInLoop */;
                            var inLoopInitializer = ts.isIterationStatement(container, /*lookInLabeledStatements*/ false);
                            var inLoopBodyBlock = container.kind === 235 /* SyntaxKind.Block */ && ts.isIterationStatement(container.parent, /*lookInLabeledStatements*/ false);
                            links.isDeclarationWithCollidingName = !ts.isBlockScopedContainerTopLevel(container) && (!isDeclaredInLoop || (!inLoopInitializer && !inLoopBodyBlock));
                        }
                        else {
                            links.isDeclarationWithCollidingName = false;
                        }
                    }
                }
                return links.isDeclarationWithCollidingName;
            }
            return false;
        }
        // When resolved as an expression identifier, if the given node references a nested block scoped entity with
        // a name that either hides an existing name or might hide it when compiled downlevel,
        // return the declaration of that entity. Otherwise, return undefined.
        function getReferencedDeclarationWithCollidingName(nodeIn) {
            if (!ts.isGeneratedIdentifier(nodeIn)) {
                var node = ts.getParseTreeNode(nodeIn, ts.isIdentifier);
                if (node) {
                    var symbol = getReferencedValueSymbol(node);
                    if (symbol && isSymbolOfDeclarationWithCollidingName(symbol)) {
                        return symbol.valueDeclaration;
                    }
                }
            }
            return undefined;
        }
        // Return true if the given node is a declaration of a nested block scoped entity with a name that either hides an
        // existing name or might hide a name when compiled downlevel
        function isDeclarationWithCollidingName(nodeIn) {
            var node = ts.getParseTreeNode(nodeIn, ts.isDeclaration);
            if (node) {
                var symbol = getSymbolOfNode(node);
                if (symbol) {
                    return isSymbolOfDeclarationWithCollidingName(symbol);
                }
            }
            return false;
        }
        function isValueAliasDeclaration(node) {
            switch (node.kind) {
                case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                    return isAliasResolvedToValue(getSymbolOfNode(node));
                case 267 /* SyntaxKind.ImportClause */:
                case 268 /* SyntaxKind.NamespaceImport */:
                case 270 /* SyntaxKind.ImportSpecifier */:
                case 275 /* SyntaxKind.ExportSpecifier */:
                    var symbol = getSymbolOfNode(node);
                    return !!symbol && isAliasResolvedToValue(symbol) && !getTypeOnlyAliasDeclaration(symbol);
                case 272 /* SyntaxKind.ExportDeclaration */:
                    var exportClause = node.exportClause;
                    return !!exportClause && (ts.isNamespaceExport(exportClause) ||
                        ts.some(exportClause.elements, isValueAliasDeclaration));
                case 271 /* SyntaxKind.ExportAssignment */:
                    return node.expression && node.expression.kind === 79 /* SyntaxKind.Identifier */ ?
                        isAliasResolvedToValue(getSymbolOfNode(node)) :
                        true;
            }
            return false;
        }
        function isTopLevelValueImportEqualsWithEntityName(nodeIn) {
            var node = ts.getParseTreeNode(nodeIn, ts.isImportEqualsDeclaration);
            if (node === undefined || node.parent.kind !== 305 /* SyntaxKind.SourceFile */ || !ts.isInternalModuleImportEqualsDeclaration(node)) {
                // parent is not source file or it is not reference to internal module
                return false;
            }
            var isValue = isAliasResolvedToValue(getSymbolOfNode(node));
            return isValue && node.moduleReference && !ts.nodeIsMissing(node.moduleReference);
        }
        function isAliasResolvedToValue(symbol) {
            if (!symbol) {
                return false;
            }
            var target = getExportSymbolOfValueSymbolIfExported(resolveAlias(symbol));
            if (target === unknownSymbol) {
                return true;
            }
            // const enums and modules that contain only const enums are not considered values from the emit perspective
            // unless 'preserveConstEnums' option is set to true
            return !!(target.flags & 111551 /* SymbolFlags.Value */) &&
                (ts.shouldPreserveConstEnums(compilerOptions) || !isConstEnumOrConstEnumOnlyModule(target));
        }
        function isConstEnumOrConstEnumOnlyModule(s) {
            return isConstEnumSymbol(s) || !!s.constEnumOnlyModule;
        }
        function isReferencedAliasDeclaration(node, checkChildren) {
            if (isAliasSymbolDeclaration(node)) {
                var symbol = getSymbolOfNode(node);
                var links = symbol && getSymbolLinks(symbol);
                if (links === null || links === void 0 ? void 0 : links.referenced) {
                    return true;
                }
                var target = getSymbolLinks(symbol).aliasTarget; // TODO: GH#18217
                if (target && ts.getEffectiveModifierFlags(node) & 1 /* ModifierFlags.Export */ &&
                    target.flags & 111551 /* SymbolFlags.Value */ &&
                    (ts.shouldPreserveConstEnums(compilerOptions) || !isConstEnumOrConstEnumOnlyModule(target))) {
                    // An `export import ... =` of a value symbol is always considered referenced
                    return true;
                }
            }
            if (checkChildren) {
                return !!ts.forEachChild(node, function (node) { return isReferencedAliasDeclaration(node, checkChildren); });
            }
            return false;
        }
        function isImplementationOfOverload(node) {
            if (ts.nodeIsPresent(node.body)) {
                if (ts.isGetAccessor(node) || ts.isSetAccessor(node))
                    return false; // Get or set accessors can never be overload implementations, but can have up to 2 signatures
                var symbol = getSymbolOfNode(node);
                var signaturesOfSymbol = getSignaturesOfSymbol(symbol);
                // If this function body corresponds to function with multiple signature, it is implementation of overload
                // e.g.: function foo(a: string): string;
                //       function foo(a: number): number;
                //       function foo(a: any) { // This is implementation of the overloads
                //           return a;
                //       }
                return signaturesOfSymbol.length > 1 ||
                    // If there is single signature for the symbol, it is overload if that signature isn't coming from the node
                    // e.g.: function foo(a: string): string;
                    //       function foo(a: any) { // This is implementation of the overloads
                    //           return a;
                    //       }
                    (signaturesOfSymbol.length === 1 && signaturesOfSymbol[0].declaration !== node);
            }
            return false;
        }
        function isRequiredInitializedParameter(parameter) {
            return !!strictNullChecks &&
                !isOptionalParameter(parameter) &&
                !ts.isJSDocParameterTag(parameter) &&
                !!parameter.initializer &&
                !ts.hasSyntacticModifier(parameter, 16476 /* ModifierFlags.ParameterPropertyModifier */);
        }
        function isOptionalUninitializedParameterProperty(parameter) {
            return strictNullChecks &&
                isOptionalParameter(parameter) &&
                !parameter.initializer &&
                ts.hasSyntacticModifier(parameter, 16476 /* ModifierFlags.ParameterPropertyModifier */);
        }
        function isExpandoFunctionDeclaration(node) {
            var declaration = ts.getParseTreeNode(node, ts.isFunctionDeclaration);
            if (!declaration) {
                return false;
            }
            var symbol = getSymbolOfNode(declaration);
            if (!symbol || !(symbol.flags & 16 /* SymbolFlags.Function */)) {
                return false;
            }
            return !!ts.forEachEntry(getExportsOfSymbol(symbol), function (p) { return p.flags & 111551 /* SymbolFlags.Value */ && p.valueDeclaration && ts.isPropertyAccessExpression(p.valueDeclaration); });
        }
        function getPropertiesOfContainerFunction(node) {
            var declaration = ts.getParseTreeNode(node, ts.isFunctionDeclaration);
            if (!declaration) {
                return ts.emptyArray;
            }
            var symbol = getSymbolOfNode(declaration);
            return symbol && getPropertiesOfType(getTypeOfSymbol(symbol)) || ts.emptyArray;
        }
        function getNodeCheckFlags(node) {
            var _a;
            var nodeId = node.id || 0;
            if (nodeId < 0 || nodeId >= nodeLinks.length)
                return 0;
            return ((_a = nodeLinks[nodeId]) === null || _a === void 0 ? void 0 : _a.flags) || 0;
        }
        function getEnumMemberValue(node) {
            computeEnumMemberValues(node.parent);
            return getNodeLinks(node).enumMemberValue;
        }
        function canHaveConstantValue(node) {
            switch (node.kind) {
                case 299 /* SyntaxKind.EnumMember */:
                case 206 /* SyntaxKind.PropertyAccessExpression */:
                case 207 /* SyntaxKind.ElementAccessExpression */:
                    return true;
            }
            return false;
        }
        function getConstantValue(node) {
            if (node.kind === 299 /* SyntaxKind.EnumMember */) {
                return getEnumMemberValue(node);
            }
            var symbol = getNodeLinks(node).resolvedSymbol;
            if (symbol && (symbol.flags & 8 /* SymbolFlags.EnumMember */)) {
                // inline property\index accesses only for const enums
                var member = symbol.valueDeclaration;
                if (ts.isEnumConst(member.parent)) {
                    return getEnumMemberValue(member);
                }
            }
            return undefined;
        }
        function isFunctionType(type) {
            return !!(type.flags & 524288 /* TypeFlags.Object */) && getSignaturesOfType(type, 0 /* SignatureKind.Call */).length > 0;
        }
        function getTypeReferenceSerializationKind(typeNameIn, location) {
            var _a, _b;
            // ensure both `typeName` and `location` are parse tree nodes.
            var typeName = ts.getParseTreeNode(typeNameIn, ts.isEntityName);
            if (!typeName)
                return ts.TypeReferenceSerializationKind.Unknown;
            if (location) {
                location = ts.getParseTreeNode(location);
                if (!location)
                    return ts.TypeReferenceSerializationKind.Unknown;
            }
            // Resolve the symbol as a value to ensure the type can be reached at runtime during emit.
            var isTypeOnly = false;
            if (ts.isQualifiedName(typeName)) {
                var rootValueSymbol = resolveEntityName(ts.getFirstIdentifier(typeName), 111551 /* SymbolFlags.Value */, /*ignoreErrors*/ true, /*dontResolveAlias*/ true, location);
                isTypeOnly = !!((_a = rootValueSymbol === null || rootValueSymbol === void 0 ? void 0 : rootValueSymbol.declarations) === null || _a === void 0 ? void 0 : _a.every(ts.isTypeOnlyImportOrExportDeclaration));
            }
            var valueSymbol = resolveEntityName(typeName, 111551 /* SymbolFlags.Value */, /*ignoreErrors*/ true, /*dontResolveAlias*/ true, location);
            var resolvedSymbol = valueSymbol && valueSymbol.flags & 2097152 /* SymbolFlags.Alias */ ? resolveAlias(valueSymbol) : valueSymbol;
            isTypeOnly || (isTypeOnly = !!((_b = valueSymbol === null || valueSymbol === void 0 ? void 0 : valueSymbol.declarations) === null || _b === void 0 ? void 0 : _b.every(ts.isTypeOnlyImportOrExportDeclaration)));
            // Resolve the symbol as a type so that we can provide a more useful hint for the type serializer.
            var typeSymbol = resolveEntityName(typeName, 788968 /* SymbolFlags.Type */, /*ignoreErrors*/ true, /*dontResolveAlias*/ false, location);
            if (resolvedSymbol && resolvedSymbol === typeSymbol) {
                var globalPromiseSymbol = getGlobalPromiseConstructorSymbol(/*reportErrors*/ false);
                if (globalPromiseSymbol && resolvedSymbol === globalPromiseSymbol) {
                    return ts.TypeReferenceSerializationKind.Promise;
                }
                var constructorType = getTypeOfSymbol(resolvedSymbol);
                if (constructorType && isConstructorType(constructorType)) {
                    return isTypeOnly ? ts.TypeReferenceSerializationKind.TypeWithCallSignature : ts.TypeReferenceSerializationKind.TypeWithConstructSignatureAndValue;
                }
            }
            // We might not be able to resolve type symbol so use unknown type in that case (eg error case)
            if (!typeSymbol) {
                return isTypeOnly ? ts.TypeReferenceSerializationKind.ObjectType : ts.TypeReferenceSerializationKind.Unknown;
            }
            var type = getDeclaredTypeOfSymbol(typeSymbol);
            if (isErrorType(type)) {
                return isTypeOnly ? ts.TypeReferenceSerializationKind.ObjectType : ts.TypeReferenceSerializationKind.Unknown;
            }
            else if (type.flags & 3 /* TypeFlags.AnyOrUnknown */) {
                return ts.TypeReferenceSerializationKind.ObjectType;
            }
            else if (isTypeAssignableToKind(type, 16384 /* TypeFlags.Void */ | 98304 /* TypeFlags.Nullable */ | 131072 /* TypeFlags.Never */)) {
                return ts.TypeReferenceSerializationKind.VoidNullableOrNeverType;
            }
            else if (isTypeAssignableToKind(type, 528 /* TypeFlags.BooleanLike */)) {
                return ts.TypeReferenceSerializationKind.BooleanType;
            }
            else if (isTypeAssignableToKind(type, 296 /* TypeFlags.NumberLike */)) {
                return ts.TypeReferenceSerializationKind.NumberLikeType;
            }
            else if (isTypeAssignableToKind(type, 2112 /* TypeFlags.BigIntLike */)) {
                return ts.TypeReferenceSerializationKind.BigIntLikeType;
            }
            else if (isTypeAssignableToKind(type, 402653316 /* TypeFlags.StringLike */)) {
                return ts.TypeReferenceSerializationKind.StringLikeType;
            }
            else if (isTupleType(type)) {
                return ts.TypeReferenceSerializationKind.ArrayLikeType;
            }
            else if (isTypeAssignableToKind(type, 12288 /* TypeFlags.ESSymbolLike */)) {
                return ts.TypeReferenceSerializationKind.ESSymbolType;
            }
            else if (isFunctionType(type)) {
                return ts.TypeReferenceSerializationKind.TypeWithCallSignature;
            }
            else if (isArrayType(type)) {
                return ts.TypeReferenceSerializationKind.ArrayLikeType;
            }
            else {
                return ts.TypeReferenceSerializationKind.ObjectType;
            }
        }
        function createTypeOfDeclaration(declarationIn, enclosingDeclaration, flags, tracker, addUndefined) {
            var declaration = ts.getParseTreeNode(declarationIn, ts.isVariableLikeOrAccessor);
            if (!declaration) {
                return ts.factory.createToken(130 /* SyntaxKind.AnyKeyword */);
            }
            // Get type of the symbol if this is the valid symbol otherwise get type at location
            var symbol = getSymbolOfNode(declaration);
            var type = symbol && !(symbol.flags & (2048 /* SymbolFlags.TypeLiteral */ | 131072 /* SymbolFlags.Signature */))
                ? getWidenedLiteralType(getTypeOfSymbol(symbol))
                : errorType;
            if (type.flags & 8192 /* TypeFlags.UniqueESSymbol */ &&
                type.symbol === symbol) {
                flags |= 1048576 /* NodeBuilderFlags.AllowUniqueESSymbolType */;
            }
            if (addUndefined) {
                type = getOptionalType(type);
            }
            return nodeBuilder.typeToTypeNode(type, enclosingDeclaration, flags | 1024 /* NodeBuilderFlags.MultilineObjectLiterals */, tracker);
        }
        function createReturnTypeOfSignatureDeclaration(signatureDeclarationIn, enclosingDeclaration, flags, tracker) {
            var signatureDeclaration = ts.getParseTreeNode(signatureDeclarationIn, ts.isFunctionLike);
            if (!signatureDeclaration) {
                return ts.factory.createToken(130 /* SyntaxKind.AnyKeyword */);
            }
            var signature = getSignatureFromDeclaration(signatureDeclaration);
            return nodeBuilder.typeToTypeNode(getReturnTypeOfSignature(signature), enclosingDeclaration, flags | 1024 /* NodeBuilderFlags.MultilineObjectLiterals */, tracker);
        }
        function createTypeOfExpression(exprIn, enclosingDeclaration, flags, tracker) {
            var expr = ts.getParseTreeNode(exprIn, ts.isExpression);
            if (!expr) {
                return ts.factory.createToken(130 /* SyntaxKind.AnyKeyword */);
            }
            var type = getWidenedType(getRegularTypeOfExpression(expr));
            return nodeBuilder.typeToTypeNode(type, enclosingDeclaration, flags | 1024 /* NodeBuilderFlags.MultilineObjectLiterals */, tracker);
        }
        function hasGlobalName(name) {
            return globals.has(ts.escapeLeadingUnderscores(name));
        }
        function getReferencedValueSymbol(reference, startInDeclarationContainer) {
            var resolvedSymbol = getNodeLinks(reference).resolvedSymbol;
            if (resolvedSymbol) {
                return resolvedSymbol;
            }
            var location = reference;
            if (startInDeclarationContainer) {
                // When resolving the name of a declaration as a value, we need to start resolution
                // at a point outside of the declaration.
                var parent = reference.parent;
                if (ts.isDeclaration(parent) && reference === parent.name) {
                    location = getDeclarationContainer(parent);
                }
            }
            return resolveName(location, reference.escapedText, 111551 /* SymbolFlags.Value */ | 1048576 /* SymbolFlags.ExportValue */ | 2097152 /* SymbolFlags.Alias */, /*nodeNotFoundMessage*/ undefined, /*nameArg*/ undefined, /*isUse*/ true);
        }
        function getReferencedValueDeclaration(referenceIn) {
            if (!ts.isGeneratedIdentifier(referenceIn)) {
                var reference = ts.getParseTreeNode(referenceIn, ts.isIdentifier);
                if (reference) {
                    var symbol = getReferencedValueSymbol(reference);
                    if (symbol) {
                        return getExportSymbolOfValueSymbolIfExported(symbol).valueDeclaration;
                    }
                }
            }
            return undefined;
        }
        function isLiteralConstDeclaration(node) {
            if (ts.isDeclarationReadonly(node) || ts.isVariableDeclaration(node) && ts.isVarConst(node)) {
                return isFreshLiteralType(getTypeOfSymbol(getSymbolOfNode(node)));
            }
            return false;
        }
        function literalTypeToNode(type, enclosing, tracker) {
            var enumResult = type.flags & 1024 /* TypeFlags.EnumLiteral */ ? nodeBuilder.symbolToExpression(type.symbol, 111551 /* SymbolFlags.Value */, enclosing, /*flags*/ undefined, tracker)
                : type === trueType ? ts.factory.createTrue() : type === falseType && ts.factory.createFalse();
            if (enumResult)
                return enumResult;
            var literalValue = type.value;
            return typeof literalValue === "object" ? ts.factory.createBigIntLiteral(literalValue) :
                typeof literalValue === "number" ? ts.factory.createNumericLiteral(literalValue) :
                    ts.factory.createStringLiteral(literalValue);
        }
        function createLiteralConstValue(node, tracker) {
            var type = getTypeOfSymbol(getSymbolOfNode(node));
            return literalTypeToNode(type, node, tracker);
        }
        function getJsxFactoryEntity(location) {
            return location ? (getJsxNamespace(location), (ts.getSourceFileOfNode(location).localJsxFactory || _jsxFactoryEntity)) : _jsxFactoryEntity;
        }
        function getJsxFragmentFactoryEntity(location) {
            if (location) {
                var file = ts.getSourceFileOfNode(location);
                if (file) {
                    if (file.localJsxFragmentFactory) {
                        return file.localJsxFragmentFactory;
                    }
                    var jsxFragPragmas = file.pragmas.get("jsxfrag");
                    var jsxFragPragma = ts.isArray(jsxFragPragmas) ? jsxFragPragmas[0] : jsxFragPragmas;
                    if (jsxFragPragma) {
                        file.localJsxFragmentFactory = ts.parseIsolatedEntityName(jsxFragPragma.arguments.factory, languageVersion);
                        return file.localJsxFragmentFactory;
                    }
                }
            }
            if (compilerOptions.jsxFragmentFactory) {
                return ts.parseIsolatedEntityName(compilerOptions.jsxFragmentFactory, languageVersion);
            }
        }
        function createResolver() {
            // this variable and functions that use it are deliberately moved here from the outer scope
            // to avoid scope pollution
            var resolvedTypeReferenceDirectives = host.getResolvedTypeReferenceDirectives();
            var fileToDirective;
            if (resolvedTypeReferenceDirectives) {
                // populate reverse mapping: file path -> type reference directive that was resolved to this file
                fileToDirective = new ts.Map();
                resolvedTypeReferenceDirectives.forEach(function (resolvedDirective, key, mode) {
                    if (!resolvedDirective || !resolvedDirective.resolvedFileName) {
                        return;
                    }
                    var file = host.getSourceFile(resolvedDirective.resolvedFileName);
                    if (file) {
                        // Add the transitive closure of path references loaded by this file (as long as they are not)
                        // part of an existing type reference.
                        addReferencedFilesToTypeDirective(file, key, mode);
                    }
                });
            }
            return {
                getReferencedExportContainer: getReferencedExportContainer,
                getReferencedImportDeclaration: getReferencedImportDeclaration,
                getReferencedDeclarationWithCollidingName: getReferencedDeclarationWithCollidingName,
                isDeclarationWithCollidingName: isDeclarationWithCollidingName,
                isValueAliasDeclaration: function (nodeIn) {
                    var node = ts.getParseTreeNode(nodeIn);
                    // Synthesized nodes are always treated like values.
                    return node ? isValueAliasDeclaration(node) : true;
                },
                hasGlobalName: hasGlobalName,
                isReferencedAliasDeclaration: function (nodeIn, checkChildren) {
                    var node = ts.getParseTreeNode(nodeIn);
                    // Synthesized nodes are always treated as referenced.
                    return node ? isReferencedAliasDeclaration(node, checkChildren) : true;
                },
                getNodeCheckFlags: function (nodeIn) {
                    var node = ts.getParseTreeNode(nodeIn);
                    return node ? getNodeCheckFlags(node) : 0;
                },
                isTopLevelValueImportEqualsWithEntityName: isTopLevelValueImportEqualsWithEntityName,
                isDeclarationVisible: isDeclarationVisible,
                isImplementationOfOverload: isImplementationOfOverload,
                isRequiredInitializedParameter: isRequiredInitializedParameter,
                isOptionalUninitializedParameterProperty: isOptionalUninitializedParameterProperty,
                isExpandoFunctionDeclaration: isExpandoFunctionDeclaration,
                getPropertiesOfContainerFunction: getPropertiesOfContainerFunction,
                createTypeOfDeclaration: createTypeOfDeclaration,
                createReturnTypeOfSignatureDeclaration: createReturnTypeOfSignatureDeclaration,
                createTypeOfExpression: createTypeOfExpression,
                createLiteralConstValue: createLiteralConstValue,
                isSymbolAccessible: isSymbolAccessible,
                isEntityNameVisible: isEntityNameVisible,
                getConstantValue: function (nodeIn) {
                    var node = ts.getParseTreeNode(nodeIn, canHaveConstantValue);
                    return node ? getConstantValue(node) : undefined;
                },
                collectLinkedAliases: collectLinkedAliases,
                getReferencedValueDeclaration: getReferencedValueDeclaration,
                getTypeReferenceSerializationKind: getTypeReferenceSerializationKind,
                isOptionalParameter: isOptionalParameter,
                moduleExportsSomeValue: moduleExportsSomeValue,
                isArgumentsLocalBinding: isArgumentsLocalBinding,
                getExternalModuleFileFromDeclaration: function (nodeIn) {
                    var node = ts.getParseTreeNode(nodeIn, ts.hasPossibleExternalModuleReference);
                    return node && getExternalModuleFileFromDeclaration(node);
                },
                getTypeReferenceDirectivesForEntityName: getTypeReferenceDirectivesForEntityName,
                getTypeReferenceDirectivesForSymbol: getTypeReferenceDirectivesForSymbol,
                isLiteralConstDeclaration: isLiteralConstDeclaration,
                isLateBound: function (nodeIn) {
                    var node = ts.getParseTreeNode(nodeIn, ts.isDeclaration);
                    var symbol = node && getSymbolOfNode(node);
                    return !!(symbol && ts.getCheckFlags(symbol) & 4096 /* CheckFlags.Late */);
                },
                getJsxFactoryEntity: getJsxFactoryEntity,
                getJsxFragmentFactoryEntity: getJsxFragmentFactoryEntity,
                getAllAccessorDeclarations: function (accessor) {
                    accessor = ts.getParseTreeNode(accessor, ts.isGetOrSetAccessorDeclaration); // TODO: GH#18217
                    var otherKind = accessor.kind === 173 /* SyntaxKind.SetAccessor */ ? 172 /* SyntaxKind.GetAccessor */ : 173 /* SyntaxKind.SetAccessor */;
                    var otherAccessor = ts.getDeclarationOfKind(getSymbolOfNode(accessor), otherKind);
                    var firstAccessor = otherAccessor && (otherAccessor.pos < accessor.pos) ? otherAccessor : accessor;
                    var secondAccessor = otherAccessor && (otherAccessor.pos < accessor.pos) ? accessor : otherAccessor;
                    var setAccessor = accessor.kind === 173 /* SyntaxKind.SetAccessor */ ? accessor : otherAccessor;
                    var getAccessor = accessor.kind === 172 /* SyntaxKind.GetAccessor */ ? accessor : otherAccessor;
                    return {
                        firstAccessor: firstAccessor,
                        secondAccessor: secondAccessor,
                        setAccessor: setAccessor,
                        getAccessor: getAccessor
                    };
                },
                getSymbolOfExternalModuleSpecifier: function (moduleName) { return resolveExternalModuleNameWorker(moduleName, moduleName, /*moduleNotFoundError*/ undefined); },
                isBindingCapturedByNode: function (node, decl) {
                    var parseNode = ts.getParseTreeNode(node);
                    var parseDecl = ts.getParseTreeNode(decl);
                    return !!parseNode && !!parseDecl && (ts.isVariableDeclaration(parseDecl) || ts.isBindingElement(parseDecl)) && isBindingCapturedByNode(parseNode, parseDecl);
                },
                getDeclarationStatementsForSourceFile: function (node, flags, tracker, bundled) {
                    var n = ts.getParseTreeNode(node);
                    ts.Debug.assert(n && n.kind === 305 /* SyntaxKind.SourceFile */, "Non-sourcefile node passed into getDeclarationsForSourceFile");
                    var sym = getSymbolOfNode(node);
                    if (!sym) {
                        return !node.locals ? [] : nodeBuilder.symbolTableToDeclarationStatements(node.locals, node, flags, tracker, bundled);
                    }
                    return !sym.exports ? [] : nodeBuilder.symbolTableToDeclarationStatements(sym.exports, node, flags, tracker, bundled);
                },
                isImportRequiredByAugmentation: isImportRequiredByAugmentation,
            };
            function isImportRequiredByAugmentation(node) {
                var file = ts.getSourceFileOfNode(node);
                if (!file.symbol)
                    return false;
                var importTarget = getExternalModuleFileFromDeclaration(node);
                if (!importTarget)
                    return false;
                if (importTarget === file)
                    return false;
                var exports = getExportsOfModule(file.symbol);
                for (var _i = 0, _a = ts.arrayFrom(exports.values()); _i < _a.length; _i++) {
                    var s = _a[_i];
                    if (s.mergeId) {
                        var merged = getMergedSymbol(s);
                        if (merged.declarations) {
                            for (var _b = 0, _c = merged.declarations; _b < _c.length; _b++) {
                                var d = _c[_b];
                                var declFile = ts.getSourceFileOfNode(d);
                                if (declFile === importTarget) {
                                    return true;
                                }
                            }
                        }
                    }
                }
                return false;
            }
            function isInHeritageClause(node) {
                return node.parent && node.parent.kind === 228 /* SyntaxKind.ExpressionWithTypeArguments */ && node.parent.parent && node.parent.parent.kind === 291 /* SyntaxKind.HeritageClause */;
            }
            // defined here to avoid outer scope pollution
            function getTypeReferenceDirectivesForEntityName(node) {
                // program does not have any files with type reference directives - bail out
                if (!fileToDirective) {
                    return undefined;
                }
                // property access can only be used as values, or types when within an expression with type arguments inside a heritage clause
                // qualified names can only be used as types\namespaces
                // identifiers are treated as values only if they appear in type queries
                var meaning = 788968 /* SymbolFlags.Type */ | 1920 /* SymbolFlags.Namespace */;
                if ((node.kind === 79 /* SyntaxKind.Identifier */ && isInTypeQuery(node)) || (node.kind === 206 /* SyntaxKind.PropertyAccessExpression */ && !isInHeritageClause(node))) {
                    meaning = 111551 /* SymbolFlags.Value */ | 1048576 /* SymbolFlags.ExportValue */;
                }
                var symbol = resolveEntityName(node, meaning, /*ignoreErrors*/ true);
                return symbol && symbol !== unknownSymbol ? getTypeReferenceDirectivesForSymbol(symbol, meaning) : undefined;
            }
            // defined here to avoid outer scope pollution
            function getTypeReferenceDirectivesForSymbol(symbol, meaning) {
                // program does not have any files with type reference directives - bail out
                if (!fileToDirective || !isSymbolFromTypeDeclarationFile(symbol)) {
                    return undefined;
                }
                // check what declarations in the symbol can contribute to the target meaning
                var typeReferenceDirectives;
                for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                    var decl = _a[_i];
                    // check meaning of the local symbol to see if declaration needs to be analyzed further
                    if (decl.symbol && decl.symbol.flags & meaning) {
                        var file = ts.getSourceFileOfNode(decl);
                        var typeReferenceDirective = fileToDirective.get(file.path);
                        if (typeReferenceDirective) {
                            (typeReferenceDirectives || (typeReferenceDirectives = [])).push(typeReferenceDirective);
                        }
                        else {
                            // found at least one entry that does not originate from type reference directive
                            return undefined;
                        }
                    }
                }
                return typeReferenceDirectives;
            }
            function isSymbolFromTypeDeclarationFile(symbol) {
                // bail out if symbol does not have associated declarations (i.e. this is transient symbol created for property in binding pattern)
                if (!symbol.declarations) {
                    return false;
                }
                // walk the parent chain for symbols to make sure that top level parent symbol is in the global scope
                // external modules cannot define or contribute to type declaration files
                var current = symbol;
                while (true) {
                    var parent = getParentOfSymbol(current);
                    if (parent) {
                        current = parent;
                    }
                    else {
                        break;
                    }
                }
                if (current.valueDeclaration && current.valueDeclaration.kind === 305 /* SyntaxKind.SourceFile */ && current.flags & 512 /* SymbolFlags.ValueModule */) {
                    return false;
                }
                // check that at least one declaration of top level symbol originates from type declaration file
                for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
                    var decl = _a[_i];
                    var file = ts.getSourceFileOfNode(decl);
                    if (fileToDirective.has(file.path)) {
                        return true;
                    }
                }
                return false;
            }
            function addReferencedFilesToTypeDirective(file, key, mode) {
                if (fileToDirective.has(file.path))
                    return;
                fileToDirective.set(file.path, [key, mode]);
                for (var _i = 0, _a = file.referencedFiles; _i < _a.length; _i++) {
                    var _b = _a[_i], fileName = _b.fileName, resolutionMode = _b.resolutionMode;
                    var resolvedFile = ts.resolveTripleslashReference(fileName, file.fileName);
                    var referencedFile = host.getSourceFile(resolvedFile);
                    if (referencedFile) {
                        addReferencedFilesToTypeDirective(referencedFile, key, resolutionMode || file.impliedNodeFormat);
                    }
                }
            }
        }
        function getExternalModuleFileFromDeclaration(declaration) {
            var specifier = declaration.kind === 261 /* SyntaxKind.ModuleDeclaration */ ? ts.tryCast(declaration.name, ts.isStringLiteral) : ts.getExternalModuleName(declaration);
            var moduleSymbol = resolveExternalModuleNameWorker(specifier, specifier, /*moduleNotFoundError*/ undefined); // TODO: GH#18217
            if (!moduleSymbol) {
                return undefined;
            }
            return ts.getDeclarationOfKind(moduleSymbol, 305 /* SyntaxKind.SourceFile */);
        }
        function initializeTypeChecker() {
            // Bind all source files and propagate errors
            for (var _i = 0, _a = host.getSourceFiles(); _i < _a.length; _i++) {
                var file = _a[_i];
                ts.bindSourceFile(file, compilerOptions);
            }
            amalgamatedDuplicates = new ts.Map();
            // Initialize global symbol table
            var augmentations;
            for (var _b = 0, _c = host.getSourceFiles(); _b < _c.length; _b++) {
                var file = _c[_b];
                if (file.redirectInfo) {
                    continue;
                }
                if (!ts.isExternalOrCommonJsModule(file)) {
                    // It is an error for a non-external-module (i.e. script) to declare its own `globalThis`.
                    // We can't use `builtinGlobals` for this due to synthetic expando-namespace generation in JS files.
                    var fileGlobalThisSymbol = file.locals.get("globalThis");
                    if (fileGlobalThisSymbol === null || fileGlobalThisSymbol === void 0 ? void 0 : fileGlobalThisSymbol.declarations) {
                        for (var _d = 0, _e = fileGlobalThisSymbol.declarations; _d < _e.length; _d++) {
                            var declaration = _e[_d];
                            diagnostics.add(ts.createDiagnosticForNode(declaration, ts.Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0, "globalThis"));
                        }
                    }
                    mergeSymbolTable(globals, file.locals);
                }
                if (file.jsGlobalAugmentations) {
                    mergeSymbolTable(globals, file.jsGlobalAugmentations);
                }
                if (file.patternAmbientModules && file.patternAmbientModules.length) {
                    patternAmbientModules = ts.concatenate(patternAmbientModules, file.patternAmbientModules);
                }
                if (file.moduleAugmentations.length) {
                    (augmentations || (augmentations = [])).push(file.moduleAugmentations);
                }
                if (file.symbol && file.symbol.globalExports) {
                    // Merge in UMD exports with first-in-wins semantics (see #9771)
                    var source = file.symbol.globalExports;
                    source.forEach(function (sourceSymbol, id) {
                        if (!globals.has(id)) {
                            globals.set(id, sourceSymbol);
                        }
                    });
                }
            }
            // We do global augmentations separately from module augmentations (and before creating global types) because they
            //  1. Affect global types. We won't have the correct global types until global augmentations are merged. Also,
            //  2. Module augmentation instantiation requires creating the type of a module, which, in turn, can require
            //       checking for an export or property on the module (if export=) which, in turn, can fall back to the
            //       apparent type of the module - either globalObjectType or globalFunctionType - which wouldn't exist if we
            //       did module augmentations prior to finalizing the global types.
            if (augmentations) {
                // merge _global_ module augmentations.
                // this needs to be done after global symbol table is initialized to make sure that all ambient modules are indexed
                for (var _f = 0, augmentations_1 = augmentations; _f < augmentations_1.length; _f++) {
                    var list = augmentations_1[_f];
                    for (var _g = 0, list_1 = list; _g < list_1.length; _g++) {
                        var augmentation = list_1[_g];
                        if (!ts.isGlobalScopeAugmentation(augmentation.parent))
                            continue;
                        mergeModuleAugmentation(augmentation);
                    }
                }
            }
            // Setup global builtins
            addToSymbolTable(globals, builtinGlobals, ts.Diagnostics.Declaration_name_conflicts_with_built_in_global_identifier_0);
            getSymbolLinks(undefinedSymbol).type = undefinedWideningType;
            getSymbolLinks(argumentsSymbol).type = getGlobalType("IArguments", /*arity*/ 0, /*reportErrors*/ true);
            getSymbolLinks(unknownSymbol).type = errorType;
            getSymbolLinks(globalThisSymbol).type = createObjectType(16 /* ObjectFlags.Anonymous */, globalThisSymbol);
            // Initialize special types
            globalArrayType = getGlobalType("Array", /*arity*/ 1, /*reportErrors*/ true);
            globalObjectType = getGlobalType("Object", /*arity*/ 0, /*reportErrors*/ true);
            globalFunctionType = getGlobalType("Function", /*arity*/ 0, /*reportErrors*/ true);
            globalCallableFunctionType = strictBindCallApply && getGlobalType("CallableFunction", /*arity*/ 0, /*reportErrors*/ true) || globalFunctionType;
            globalNewableFunctionType = strictBindCallApply && getGlobalType("NewableFunction", /*arity*/ 0, /*reportErrors*/ true) || globalFunctionType;
            globalStringType = getGlobalType("String", /*arity*/ 0, /*reportErrors*/ true);
            globalNumberType = getGlobalType("Number", /*arity*/ 0, /*reportErrors*/ true);
            globalBooleanType = getGlobalType("Boolean", /*arity*/ 0, /*reportErrors*/ true);
            globalRegExpType = getGlobalType("RegExp", /*arity*/ 0, /*reportErrors*/ true);
            anyArrayType = createArrayType(anyType);
            autoArrayType = createArrayType(autoType);
            if (autoArrayType === emptyObjectType) {
                // autoArrayType is used as a marker, so even if global Array type is not defined, it needs to be a unique type
                autoArrayType = createAnonymousType(undefined, emptySymbols, ts.emptyArray, ts.emptyArray, ts.emptyArray);
            }
            globalReadonlyArrayType = getGlobalTypeOrUndefined("ReadonlyArray", /*arity*/ 1) || globalArrayType;
            anyReadonlyArrayType = globalReadonlyArrayType ? createTypeFromGenericGlobalType(globalReadonlyArrayType, [anyType]) : anyArrayType;
            globalThisType = getGlobalTypeOrUndefined("ThisType", /*arity*/ 1);
            if (augmentations) {
                // merge _nonglobal_ module augmentations.
                // this needs to be done after global symbol table is initialized to make sure that all ambient modules are indexed
                for (var _h = 0, augmentations_2 = augmentations; _h < augmentations_2.length; _h++) {
                    var list = augmentations_2[_h];
                    for (var _j = 0, list_2 = list; _j < list_2.length; _j++) {
                        var augmentation = list_2[_j];
                        if (ts.isGlobalScopeAugmentation(augmentation.parent))
                            continue;
                        mergeModuleAugmentation(augmentation);
                    }
                }
            }
            amalgamatedDuplicates.forEach(function (_a) {
                var firstFile = _a.firstFile, secondFile = _a.secondFile, conflictingSymbols = _a.conflictingSymbols;
                // If not many things conflict, issue individual errors
                if (conflictingSymbols.size < 8) {
                    conflictingSymbols.forEach(function (_a, symbolName) {
                        var isBlockScoped = _a.isBlockScoped, firstFileLocations = _a.firstFileLocations, secondFileLocations = _a.secondFileLocations;
                        var message = isBlockScoped ? ts.Diagnostics.Cannot_redeclare_block_scoped_variable_0 : ts.Diagnostics.Duplicate_identifier_0;
                        for (var _i = 0, firstFileLocations_1 = firstFileLocations; _i < firstFileLocations_1.length; _i++) {
                            var node = firstFileLocations_1[_i];
                            addDuplicateDeclarationError(node, message, symbolName, secondFileLocations);
                        }
                        for (var _b = 0, secondFileLocations_1 = secondFileLocations; _b < secondFileLocations_1.length; _b++) {
                            var node = secondFileLocations_1[_b];
                            addDuplicateDeclarationError(node, message, symbolName, firstFileLocations);
                        }
                    });
                }
                else {
                    // Otherwise issue top-level error since the files appear very identical in terms of what they contain
                    var list = ts.arrayFrom(conflictingSymbols.keys()).join(", ");
                    diagnostics.add(ts.addRelatedInfo(ts.createDiagnosticForNode(firstFile, ts.Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list), ts.createDiagnosticForNode(secondFile, ts.Diagnostics.Conflicts_are_in_this_file)));
                    diagnostics.add(ts.addRelatedInfo(ts.createDiagnosticForNode(secondFile, ts.Diagnostics.Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0, list), ts.createDiagnosticForNode(firstFile, ts.Diagnostics.Conflicts_are_in_this_file)));
                }
            });
            amalgamatedDuplicates = undefined;
        }
        function checkExternalEmitHelpers(location, helpers) {
            if ((requestedExternalEmitHelpers & helpers) !== helpers && compilerOptions.importHelpers) {
                var sourceFile = ts.getSourceFileOfNode(location);
                if (ts.isEffectiveExternalModule(sourceFile, compilerOptions) && !(location.flags & 16777216 /* NodeFlags.Ambient */)) {
                    var helpersModule = resolveHelpersModule(sourceFile, location);
                    if (helpersModule !== unknownSymbol) {
                        var uncheckedHelpers = helpers & ~requestedExternalEmitHelpers;
                        for (var helper = 1 /* ExternalEmitHelpers.FirstEmitHelper */; helper <= 4194304 /* ExternalEmitHelpers.LastEmitHelper */; helper <<= 1) {
                            if (uncheckedHelpers & helper) {
                                var name = getHelperName(helper);
                                var symbol = getSymbol(helpersModule.exports, ts.escapeLeadingUnderscores(name), 111551 /* SymbolFlags.Value */);
                                if (!symbol) {
                                    error(location, ts.Diagnostics.This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_version_of_0, ts.externalHelpersModuleNameText, name);
                                }
                                else if (helper & 524288 /* ExternalEmitHelpers.ClassPrivateFieldGet */) {
                                    if (!ts.some(getSignaturesOfSymbol(symbol), function (signature) { return getParameterCount(signature) > 3; })) {
                                        error(location, ts.Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, ts.externalHelpersModuleNameText, name, 4);
                                    }
                                }
                                else if (helper & 1048576 /* ExternalEmitHelpers.ClassPrivateFieldSet */) {
                                    if (!ts.some(getSignaturesOfSymbol(symbol), function (signature) { return getParameterCount(signature) > 4; })) {
                                        error(location, ts.Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, ts.externalHelpersModuleNameText, name, 5);
                                    }
                                }
                                else if (helper & 1024 /* ExternalEmitHelpers.SpreadArray */) {
                                    if (!ts.some(getSignaturesOfSymbol(symbol), function (signature) { return getParameterCount(signature) > 2; })) {
                                        error(location, ts.Diagnostics.This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0, ts.externalHelpersModuleNameText, name, 3);
                                    }
                                }
                            }
                        }
                    }
                    requestedExternalEmitHelpers |= helpers;
                }
            }
        }
        function getHelperName(helper) {
            switch (helper) {
                case 1 /* ExternalEmitHelpers.Extends */: return "__extends";
                case 2 /* ExternalEmitHelpers.Assign */: return "__assign";
                case 4 /* ExternalEmitHelpers.Rest */: return "__rest";
                case 8 /* ExternalEmitHelpers.Decorate */: return "__decorate";
                case 16 /* ExternalEmitHelpers.Metadata */: return "__metadata";
                case 32 /* ExternalEmitHelpers.Param */: return "__param";
                case 64 /* ExternalEmitHelpers.Awaiter */: return "__awaiter";
                case 128 /* ExternalEmitHelpers.Generator */: return "__generator";
                case 256 /* ExternalEmitHelpers.Values */: return "__values";
                case 512 /* ExternalEmitHelpers.Read */: return "__read";
                case 1024 /* ExternalEmitHelpers.SpreadArray */: return "__spreadArray";
                case 2048 /* ExternalEmitHelpers.Await */: return "__await";
                case 4096 /* ExternalEmitHelpers.AsyncGenerator */: return "__asyncGenerator";
                case 8192 /* ExternalEmitHelpers.AsyncDelegator */: return "__asyncDelegator";
                case 16384 /* ExternalEmitHelpers.AsyncValues */: return "__asyncValues";
                case 32768 /* ExternalEmitHelpers.ExportStar */: return "__exportStar";
                case 65536 /* ExternalEmitHelpers.ImportStar */: return "__importStar";
                case 131072 /* ExternalEmitHelpers.ImportDefault */: return "__importDefault";
                case 262144 /* ExternalEmitHelpers.MakeTemplateObject */: return "__makeTemplateObject";
                case 524288 /* ExternalEmitHelpers.ClassPrivateFieldGet */: return "__classPrivateFieldGet";
                case 1048576 /* ExternalEmitHelpers.ClassPrivateFieldSet */: return "__classPrivateFieldSet";
                case 2097152 /* ExternalEmitHelpers.ClassPrivateFieldIn */: return "__classPrivateFieldIn";
                case 4194304 /* ExternalEmitHelpers.CreateBinding */: return "__createBinding";
                default: return ts.Debug.fail("Unrecognized helper");
            }
        }
        function resolveHelpersModule(node, errorNode) {
            if (!externalHelpersModule) {
                externalHelpersModule = resolveExternalModule(node, ts.externalHelpersModuleNameText, ts.Diagnostics.This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found, errorNode) || unknownSymbol;
            }
            return externalHelpersModule;
        }
        // GRAMMAR CHECKING
        function checkGrammarDecoratorsAndModifiers(node) {
            return checkGrammarDecorators(node) || checkGrammarModifiers(node);
        }
        function checkGrammarDecorators(node) {
            if (!node.decorators) {
                return false;
            }
            if (!ts.nodeCanBeDecorated(node, node.parent, node.parent.parent)) {
                if (node.kind === 169 /* SyntaxKind.MethodDeclaration */ && !ts.nodeIsPresent(node.body)) {
                    return grammarErrorOnFirstToken(node, ts.Diagnostics.A_decorator_can_only_decorate_a_method_implementation_not_an_overload);
                }
                else {
                    return grammarErrorOnFirstToken(node, ts.Diagnostics.Decorators_are_not_valid_here);
                }
            }
            else if (node.kind === 172 /* SyntaxKind.GetAccessor */ || node.kind === 173 /* SyntaxKind.SetAccessor */) {
                var accessors = ts.getAllAccessorDeclarations(node.parent.members, node);
                if (accessors.firstAccessor.decorators && node === accessors.secondAccessor) {
                    return grammarErrorOnFirstToken(node, ts.Diagnostics.Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name);
                }
            }
            return false;
        }
        function checkGrammarModifiers(node) {
            var quickResult = reportObviousModifierErrors(node);
            if (quickResult !== undefined) {
                return quickResult;
            }
            var lastStatic, lastDeclare, lastAsync, lastOverride;
            var flags = 0 /* ModifierFlags.None */;
            for (var _i = 0, _a = node.modifiers; _i < _a.length; _i++) {
                var modifier = _a[_i];
                if (modifier.kind !== 145 /* SyntaxKind.ReadonlyKeyword */) {
                    if (node.kind === 166 /* SyntaxKind.PropertySignature */ || node.kind === 168 /* SyntaxKind.MethodSignature */) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_type_member, ts.tokenToString(modifier.kind));
                    }
                    if (node.kind === 176 /* SyntaxKind.IndexSignature */ && (modifier.kind !== 124 /* SyntaxKind.StaticKeyword */ || !ts.isClassLike(node.parent))) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_an_index_signature, ts.tokenToString(modifier.kind));
                    }
                }
                if (modifier.kind !== 101 /* SyntaxKind.InKeyword */ && modifier.kind !== 144 /* SyntaxKind.OutKeyword */) {
                    if (node.kind === 163 /* SyntaxKind.TypeParameter */) {
                        return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_type_parameter, ts.tokenToString(modifier.kind));
                    }
                }
                switch (modifier.kind) {
                    case 85 /* SyntaxKind.ConstKeyword */:
                        if (node.kind !== 260 /* SyntaxKind.EnumDeclaration */) {
                            return grammarErrorOnNode(node, ts.Diagnostics.A_class_member_cannot_have_the_0_keyword, ts.tokenToString(85 /* SyntaxKind.ConstKeyword */));
                        }
                        break;
                    case 159 /* SyntaxKind.OverrideKeyword */:
                        // If node.kind === SyntaxKind.Parameter, checkParameter reports an error if it's not a parameter property.
                        if (flags & 16384 /* ModifierFlags.Override */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "override");
                        }
                        else if (flags & 2 /* ModifierFlags.Ambient */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "override", "declare");
                        }
                        else if (flags & 64 /* ModifierFlags.Readonly */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "override", "readonly");
                        }
                        else if (flags & 256 /* ModifierFlags.Async */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "override", "async");
                        }
                        flags |= 16384 /* ModifierFlags.Override */;
                        lastOverride = modifier;
                        break;
                    case 123 /* SyntaxKind.PublicKeyword */:
                    case 122 /* SyntaxKind.ProtectedKeyword */:
                    case 121 /* SyntaxKind.PrivateKeyword */:
                        var text = visibilityToString(ts.modifierToFlag(modifier.kind));
                        if (flags & 28 /* ModifierFlags.AccessibilityModifier */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics.Accessibility_modifier_already_seen);
                        }
                        else if (flags & 16384 /* ModifierFlags.Override */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, text, "override");
                        }
                        else if (flags & 32 /* ModifierFlags.Static */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, text, "static");
                        }
                        else if (flags & 64 /* ModifierFlags.Readonly */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, text, "readonly");
                        }
                        else if (flags & 256 /* ModifierFlags.Async */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, text, "async");
                        }
                        else if (node.parent.kind === 262 /* SyntaxKind.ModuleBlock */ || node.parent.kind === 305 /* SyntaxKind.SourceFile */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, text);
                        }
                        else if (flags & 128 /* ModifierFlags.Abstract */) {
                            if (modifier.kind === 121 /* SyntaxKind.PrivateKeyword */) {
                                return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_1_modifier, text, "abstract");
                            }
                            else {
                                return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, text, "abstract");
                            }
                        }
                        else if (ts.isPrivateIdentifierClassElementDeclaration(node)) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics.An_accessibility_modifier_cannot_be_used_with_a_private_identifier);
                        }
                        flags |= ts.modifierToFlag(modifier.kind);
                        break;
                    case 124 /* SyntaxKind.StaticKeyword */:
                        if (flags & 32 /* ModifierFlags.Static */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "static");
                        }
                        else if (flags & 64 /* ModifierFlags.Readonly */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "static", "readonly");
                        }
                        else if (flags & 256 /* ModifierFlags.Async */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "static", "async");
                        }
                        else if (node.parent.kind === 262 /* SyntaxKind.ModuleBlock */ || node.parent.kind === 305 /* SyntaxKind.SourceFile */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_module_or_namespace_element, "static");
                        }
                        else if (node.kind === 164 /* SyntaxKind.Parameter */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, "static");
                        }
                        else if (flags & 128 /* ModifierFlags.Abstract */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract");
                        }
                        else if (flags & 16384 /* ModifierFlags.Override */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "static", "override");
                        }
                        flags |= 32 /* ModifierFlags.Static */;
                        lastStatic = modifier;
                        break;
                    case 145 /* SyntaxKind.ReadonlyKeyword */:
                        if (flags & 64 /* ModifierFlags.Readonly */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "readonly");
                        }
                        else if (node.kind !== 167 /* SyntaxKind.PropertyDeclaration */ && node.kind !== 166 /* SyntaxKind.PropertySignature */ && node.kind !== 176 /* SyntaxKind.IndexSignature */ && node.kind !== 164 /* SyntaxKind.Parameter */) {
                            // If node.kind === SyntaxKind.Parameter, checkParameter reports an error if it's not a parameter property.
                            return grammarErrorOnNode(modifier, ts.Diagnostics.readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature);
                        }
                        flags |= 64 /* ModifierFlags.Readonly */;
                        break;
                    case 93 /* SyntaxKind.ExportKeyword */:
                        if (flags & 1 /* ModifierFlags.Export */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "export");
                        }
                        else if (flags & 2 /* ModifierFlags.Ambient */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "export", "declare");
                        }
                        else if (flags & 128 /* ModifierFlags.Abstract */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "export", "abstract");
                        }
                        else if (flags & 256 /* ModifierFlags.Async */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "export", "async");
                        }
                        else if (ts.isClassLike(node.parent)) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind, "export");
                        }
                        else if (node.kind === 164 /* SyntaxKind.Parameter */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, "export");
                        }
                        flags |= 1 /* ModifierFlags.Export */;
                        break;
                    case 88 /* SyntaxKind.DefaultKeyword */:
                        var container = node.parent.kind === 305 /* SyntaxKind.SourceFile */ ? node.parent : node.parent.parent;
                        if (container.kind === 261 /* SyntaxKind.ModuleDeclaration */ && !ts.isAmbientModule(container)) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics.A_default_export_can_only_be_used_in_an_ECMAScript_style_module);
                        }
                        else if (!(flags & 1 /* ModifierFlags.Export */)) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "export", "default");
                        }
                        flags |= 512 /* ModifierFlags.Default */;
                        break;
                    case 135 /* SyntaxKind.DeclareKeyword */:
                        if (flags & 2 /* ModifierFlags.Ambient */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "declare");
                        }
                        else if (flags & 256 /* ModifierFlags.Async */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async");
                        }
                        else if (flags & 16384 /* ModifierFlags.Override */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "override");
                        }
                        else if (ts.isClassLike(node.parent) && !ts.isPropertyDeclaration(node)) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_class_elements_of_this_kind, "declare");
                        }
                        else if (node.kind === 164 /* SyntaxKind.Parameter */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, "declare");
                        }
                        else if ((node.parent.flags & 16777216 /* NodeFlags.Ambient */) && node.parent.kind === 262 /* SyntaxKind.ModuleBlock */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics.A_declare_modifier_cannot_be_used_in_an_already_ambient_context);
                        }
                        else if (ts.isPrivateIdentifierClassElementDeclaration(node)) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_a_private_identifier, "declare");
                        }
                        flags |= 2 /* ModifierFlags.Ambient */;
                        lastDeclare = modifier;
                        break;
                    case 126 /* SyntaxKind.AbstractKeyword */:
                        if (flags & 128 /* ModifierFlags.Abstract */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "abstract");
                        }
                        if (node.kind !== 257 /* SyntaxKind.ClassDeclaration */ &&
                            node.kind !== 180 /* SyntaxKind.ConstructorType */) {
                            if (node.kind !== 169 /* SyntaxKind.MethodDeclaration */ &&
                                node.kind !== 167 /* SyntaxKind.PropertyDeclaration */ &&
                                node.kind !== 172 /* SyntaxKind.GetAccessor */ &&
                                node.kind !== 173 /* SyntaxKind.SetAccessor */) {
                                return grammarErrorOnNode(modifier, ts.Diagnostics.abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration);
                            }
                            if (!(node.parent.kind === 257 /* SyntaxKind.ClassDeclaration */ && ts.hasSyntacticModifier(node.parent, 128 /* ModifierFlags.Abstract */))) {
                                return grammarErrorOnNode(modifier, ts.Diagnostics.Abstract_methods_can_only_appear_within_an_abstract_class);
                            }
                            if (flags & 32 /* ModifierFlags.Static */) {
                                return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "static", "abstract");
                            }
                            if (flags & 8 /* ModifierFlags.Private */) {
                                return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "private", "abstract");
                            }
                            if (flags & 256 /* ModifierFlags.Async */ && lastAsync) {
                                return grammarErrorOnNode(lastAsync, ts.Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "async", "abstract");
                            }
                            if (flags & 16384 /* ModifierFlags.Override */) {
                                return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "abstract", "override");
                            }
                        }
                        if (ts.isNamedDeclaration(node) && node.name.kind === 80 /* SyntaxKind.PrivateIdentifier */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_a_private_identifier, "abstract");
                        }
                        flags |= 128 /* ModifierFlags.Abstract */;
                        break;
                    case 131 /* SyntaxKind.AsyncKeyword */:
                        if (flags & 256 /* ModifierFlags.Async */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, "async");
                        }
                        else if (flags & 2 /* ModifierFlags.Ambient */ || node.parent.flags & 16777216 /* NodeFlags.Ambient */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_in_an_ambient_context, "async");
                        }
                        else if (node.kind === 164 /* SyntaxKind.Parameter */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_appear_on_a_parameter, "async");
                        }
                        if (flags & 128 /* ModifierFlags.Abstract */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_cannot_be_used_with_1_modifier, "async", "abstract");
                        }
                        flags |= 256 /* ModifierFlags.Async */;
                        lastAsync = modifier;
                        break;
                    case 101 /* SyntaxKind.InKeyword */:
                    case 144 /* SyntaxKind.OutKeyword */:
                        var inOutFlag = modifier.kind === 101 /* SyntaxKind.InKeyword */ ? 32768 /* ModifierFlags.In */ : 65536 /* ModifierFlags.Out */;
                        var inOutText = modifier.kind === 101 /* SyntaxKind.InKeyword */ ? "in" : "out";
                        if (node.kind !== 163 /* SyntaxKind.TypeParameter */ || !(ts.isInterfaceDeclaration(node.parent) || ts.isClassLike(node.parent) || ts.isTypeAliasDeclaration(node.parent))) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_can_only_appear_on_a_type_parameter_of_a_class_interface_or_type_alias, inOutText);
                        }
                        if (flags & inOutFlag) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_already_seen, inOutText);
                        }
                        if (inOutFlag & 32768 /* ModifierFlags.In */ && flags & 65536 /* ModifierFlags.Out */) {
                            return grammarErrorOnNode(modifier, ts.Diagnostics._0_modifier_must_precede_1_modifier, "in", "out");
                        }
                        flags |= inOutFlag;
                        break;
                }
            }
            if (node.kind === 171 /* SyntaxKind.Constructor */) {
                if (flags & 32 /* ModifierFlags.Static */) {
                    return grammarErrorOnNode(lastStatic, ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "static");
                }
                if (flags & 16384 /* ModifierFlags.Override */) {
                    return grammarErrorOnNode(lastOverride, ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "override"); // TODO: GH#18217
                }
                if (flags & 256 /* ModifierFlags.Async */) {
                    return grammarErrorOnNode(lastAsync, ts.Diagnostics._0_modifier_cannot_appear_on_a_constructor_declaration, "async");
                }
                return false;
            }
            else if ((node.kind === 266 /* SyntaxKind.ImportDeclaration */ || node.kind === 265 /* SyntaxKind.ImportEqualsDeclaration */) && flags & 2 /* ModifierFlags.Ambient */) {
                return grammarErrorOnNode(lastDeclare, ts.Diagnostics.A_0_modifier_cannot_be_used_with_an_import_declaration, "declare");
            }
            else if (node.kind === 164 /* SyntaxKind.Parameter */ && (flags & 16476 /* ModifierFlags.ParameterPropertyModifier */) && ts.isBindingPattern(node.name)) {
                return grammarErrorOnNode(node, ts.Diagnostics.A_parameter_property_may_not_be_declared_using_a_binding_pattern);
            }
            else if (node.kind === 164 /* SyntaxKind.Parameter */ && (flags & 16476 /* ModifierFlags.ParameterPropertyModifier */) && node.dotDotDotToken) {
                return grammarErrorOnNode(node, ts.Diagnostics.A_parameter_property_cannot_be_declared_using_a_rest_parameter);
            }
            if (flags & 256 /* ModifierFlags.Async */) {
                return checkGrammarAsyncModifier(node, lastAsync);
            }
            return false;
        }
        /**
         * true | false: Early return this value from checkGrammarModifiers.
         * undefined: Need to do full checking on the modifiers.
         */
        function reportObviousModifierErrors(node) {
            return !node.modifiers
                ? false
                : shouldReportBadModifier(node)
                    ? grammarErrorOnFirstToken(node, ts.Diagnostics.Modifiers_cannot_appear_here)
                    : undefined;
        }
        function shouldReportBadModifier(node) {
            switch (node.kind) {
                case 172 /* SyntaxKind.GetAccessor */:
                case 173 /* SyntaxKind.SetAccessor */:
                case 171 /* SyntaxKind.Constructor */:
                case 167 /* SyntaxKind.PropertyDeclaration */:
                case 166 /* SyntaxKind.PropertySignature */:
                case 169 /* SyntaxKind.MethodDeclaration */:
                case 168 /* SyntaxKind.MethodSignature */:
                case 176 /* SyntaxKind.IndexSignature */:
                case 261 /* SyntaxKind.ModuleDeclaration */:
                case 266 /* SyntaxKind.ImportDeclaration */:
                case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                case 272 /* SyntaxKind.ExportDeclaration */:
                case 271 /* SyntaxKind.ExportAssignment */:
                case 213 /* SyntaxKind.FunctionExpression */:
                case 214 /* SyntaxKind.ArrowFunction */:
                case 164 /* SyntaxKind.Parameter */:
                case 163 /* SyntaxKind.TypeParameter */:
                    return false;
                default:
                    if (node.parent.kind === 262 /* SyntaxKind.ModuleBlock */ || node.parent.kind === 305 /* SyntaxKind.SourceFile */) {
                        return false;
                    }
                    switch (node.kind) {
                        case 256 /* SyntaxKind.FunctionDeclaration */:
                            return nodeHasAnyModifiersExcept(node, 131 /* SyntaxKind.AsyncKeyword */);
                        case 257 /* SyntaxKind.ClassDeclaration */:
                        case 180 /* SyntaxKind.ConstructorType */:
                            return nodeHasAnyModifiersExcept(node, 126 /* SyntaxKind.AbstractKeyword */);
                        case 258 /* SyntaxKind.InterfaceDeclaration */:
                        case 237 /* SyntaxKind.VariableStatement */:
                        case 259 /* SyntaxKind.TypeAliasDeclaration */:
                        case 170 /* SyntaxKind.ClassStaticBlockDeclaration */:
                            return true;
                        case 260 /* SyntaxKind.EnumDeclaration */:
                            return nodeHasAnyModifiersExcept(node, 85 /* SyntaxKind.ConstKeyword */);
                        default:
                            ts.Debug.fail();
                    }
            }
        }
        function nodeHasAnyModifiersExcept(node, allowedModifier) {
            return node.modifiers.length > 1 || node.modifiers[0].kind !== allowedModifier;
        }
        function checkGrammarAsyncModifier(node, asyncModifier) {
            switch (node.kind) {
                case 169 /* SyntaxKind.MethodDeclaration */:
                case 256 /* SyntaxKind.FunctionDeclaration */:
                case 213 /* SyntaxKind.FunctionExpression */:
                case 214 /* SyntaxKind.ArrowFunction */:
                    return false;
            }
            return grammarErrorOnNode(asyncModifier, ts.Diagnostics._0_modifier_cannot_be_used_here, "async");
        }
        function checkGrammarForDisallowedTrailingComma(list, diag) {
            if (diag === void 0) { diag = ts.Diagnostics.Trailing_comma_not_allowed; }
            if (list && list.hasTrailingComma) {
                return grammarErrorAtPos(list[0], list.end - ",".length, ",".length, diag);
            }
            return false;
        }
        function checkGrammarTypeParameterList(typeParameters, file) {
            if (typeParameters && typeParameters.length === 0) {
                var start = typeParameters.pos - "<".length;
                var end = ts.skipTrivia(file.text, typeParameters.end) + ">".length;
                return grammarErrorAtPos(file, start, end - start, ts.Diagnostics.Type_parameter_list_cannot_be_empty);
            }
            return false;
        }
        function checkGrammarParameterList(parameters) {
            var seenOptionalParameter = false;
            var parameterCount = parameters.length;
            for (var i = 0; i < parameterCount; i++) {
                var parameter = parameters[i];
                if (parameter.dotDotDotToken) {
                    if (i !== (parameterCount - 1)) {
                        return grammarErrorOnNode(parameter.dotDotDotToken, ts.Diagnostics.A_rest_parameter_must_be_last_in_a_parameter_list);
                    }
                    if (!(parameter.flags & 16777216 /* NodeFlags.Ambient */)) { // Allow `...foo,` in ambient declarations; see GH#23070
                        checkGrammarForDisallowedTrailingComma(parameters, ts.Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma);
                    }
                    if (parameter.questionToken) {
                        return grammarErrorOnNode(parameter.questionToken, ts.Diagnostics.A_rest_parameter_cannot_be_optional);
                    }
                    if (parameter.initializer) {
                        return grammarErrorOnNode(parameter.name, ts.Diagnostics.A_rest_parameter_cannot_have_an_initializer);
                    }
                }
                else if (isOptionalParameter(parameter)) {
                    seenOptionalParameter = true;
                    if (parameter.questionToken && parameter.initializer) {
                        return grammarErrorOnNode(parameter.name, ts.Diagnostics.Parameter_cannot_have_question_mark_and_initializer);
                    }
                }
                else if (seenOptionalParameter && !parameter.initializer) {
                    return grammarErrorOnNode(parameter.name, ts.Diagnostics.A_required_parameter_cannot_follow_an_optional_parameter);
                }
            }
        }
        function getNonSimpleParameters(parameters) {
            return ts.filter(parameters, function (parameter) { return !!parameter.initializer || ts.isBindingPattern(parameter.name) || ts.isRestParameter(parameter); });
        }
        function checkGrammarForUseStrictSimpleParameterList(node) {
            if (languageVersion >= 3 /* ScriptTarget.ES2016 */) {
                var useStrictDirective_1 = node.body && ts.isBlock(node.body) && ts.findUseStrictPrologue(node.body.statements);
                if (useStrictDirective_1) {
                    var nonSimpleParameters = getNonSimpleParameters(node.parameters);
                    if (ts.length(nonSimpleParameters)) {
                        ts.forEach(nonSimpleParameters, function (parameter) {
                            ts.addRelatedInfo(error(parameter, ts.Diagnostics.This_parameter_is_not_allowed_with_use_strict_directive), ts.createDiagnosticForNode(useStrictDirective_1, ts.Diagnostics.use_strict_directive_used_here));
                        });
                        var diagnostics_2 = nonSimpleParameters.map(function (parameter, index) { return (index === 0 ? ts.createDiagnosticForNode(parameter, ts.Diagnostics.Non_simple_parameter_declared_here) : ts.createDiagnosticForNode(parameter, ts.Diagnostics.and_here)); });
                        ts.addRelatedInfo.apply(void 0, __spreadArray([error(useStrictDirective_1, ts.Diagnostics.use_strict_directive_cannot_be_used_with_non_simple_parameter_list)], diagnostics_2, false));
                        return true;
                    }
                }
            }
            return false;
        }
        function checkGrammarFunctionLikeDeclaration(node) {
            // Prevent cascading error by short-circuit
            var file = ts.getSourceFileOfNode(node);
            return checkGrammarDecoratorsAndModifiers(node) ||
                checkGrammarTypeParameterList(node.typeParameters, file) ||
                checkGrammarParameterList(node.parameters) ||
                checkGrammarArrowFunction(node, file) ||
                (ts.isFunctionLikeDeclaration(node) && checkGrammarForUseStrictSimpleParameterList(node));
        }
        function checkGrammarClassLikeDeclaration(node) {
            var file = ts.getSourceFileOfNode(node);
            return checkGrammarClassDeclarationHeritageClauses(node) ||
                checkGrammarTypeParameterList(node.typeParameters, file);
        }
        function checkGrammarArrowFunction(node, file) {
            if (!ts.isArrowFunction(node)) {
                return false;
            }
            if (node.typeParameters && !(ts.length(node.typeParameters) > 1 || node.typeParameters.hasTrailingComma || node.typeParameters[0].constraint)) {
                if (file && ts.fileExtensionIsOneOf(file.fileName, [".mts" /* Extension.Mts */, ".cts" /* Extension.Cts */])) {
                    grammarErrorOnNode(node.typeParameters[0], ts.Diagnostics.This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Add_a_trailing_comma_or_explicit_constraint);
                }
            }
            var equalsGreaterThanToken = node.equalsGreaterThanToken;
            var startLine = ts.getLineAndCharacterOfPosition(file, equalsGreaterThanToken.pos).line;
            var endLine = ts.getLineAndCharacterOfPosition(file, equalsGreaterThanToken.end).line;
            return startLine !== endLine && grammarErrorOnNode(equalsGreaterThanToken, ts.Diagnostics.Line_terminator_not_permitted_before_arrow);
        }
        function checkGrammarIndexSignatureParameters(node) {
            var parameter = node.parameters[0];
            if (node.parameters.length !== 1) {
                if (parameter) {
                    return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_must_have_exactly_one_parameter);
                }
                else {
                    return grammarErrorOnNode(node, ts.Diagnostics.An_index_signature_must_have_exactly_one_parameter);
                }
            }
            checkGrammarForDisallowedTrailingComma(node.parameters, ts.Diagnostics.An_index_signature_cannot_have_a_trailing_comma);
            if (parameter.dotDotDotToken) {
                return grammarErrorOnNode(parameter.dotDotDotToken, ts.Diagnostics.An_index_signature_cannot_have_a_rest_parameter);
            }
            if (ts.hasEffectiveModifiers(parameter)) {
                return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_cannot_have_an_accessibility_modifier);
            }
            if (parameter.questionToken) {
                return grammarErrorOnNode(parameter.questionToken, ts.Diagnostics.An_index_signature_parameter_cannot_have_a_question_mark);
            }
            if (parameter.initializer) {
                return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_cannot_have_an_initializer);
            }
            if (!parameter.type) {
                return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_must_have_a_type_annotation);
            }
            var type = getTypeFromTypeNode(parameter.type);
            if (someType(type, function (t) { return !!(t.flags & 8576 /* TypeFlags.StringOrNumberLiteralOrUnique */); }) || isGenericType(type)) {
                return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_object_type_instead);
            }
            if (!everyType(type, isValidIndexKeyType)) {
                return grammarErrorOnNode(parameter.name, ts.Diagnostics.An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type);
            }
            if (!node.type) {
                return grammarErrorOnNode(node, ts.Diagnostics.An_index_signature_must_have_a_type_annotation);
            }
            return false;
        }
        function checkGrammarIndexSignature(node) {
            // Prevent cascading error by short-circuit
            return checkGrammarDecoratorsAndModifiers(node) || checkGrammarIndexSignatureParameters(node);
        }
        function checkGrammarForAtLeastOneTypeArgument(node, typeArguments) {
            if (typeArguments && typeArguments.length === 0) {
                var sourceFile = ts.getSourceFileOfNode(node);
                var start = typeArguments.pos - "<".length;
                var end = ts.skipTrivia(sourceFile.text, typeArguments.end) + ">".length;
                return grammarErrorAtPos(sourceFile, start, end - start, ts.Diagnostics.Type_argument_list_cannot_be_empty);
            }
            return false;
        }
        function checkGrammarTypeArguments(node, typeArguments) {
            return checkGrammarForDisallowedTrailingComma(typeArguments) ||
                checkGrammarForAtLeastOneTypeArgument(node, typeArguments);
        }
        function checkGrammarTaggedTemplateChain(node) {
            if (node.questionDotToken || node.flags & 32 /* NodeFlags.OptionalChain */) {
                return grammarErrorOnNode(node.template, ts.Diagnostics.Tagged_template_expressions_are_not_permitted_in_an_optional_chain);
            }
            return false;
        }
        function checkGrammarHeritageClause(node) {
            var types = node.types;
            if (checkGrammarForDisallowedTrailingComma(types)) {
                return true;
            }
            if (types && types.length === 0) {
                var listType = ts.tokenToString(node.token);
                return grammarErrorAtPos(node, types.pos, 0, ts.Diagnostics._0_list_cannot_be_empty, listType);
            }
            return ts.some(types, checkGrammarExpressionWithTypeArguments);
        }
        function checkGrammarExpressionWithTypeArguments(node) {
            if (ts.isExpressionWithTypeArguments(node) && ts.isImportKeyword(node.expression) && node.typeArguments) {
                return grammarErrorOnNode(node, ts.Diagnostics.This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments);
            }
            return checkGrammarTypeArguments(node, node.typeArguments);
        }
        function checkGrammarClassDeclarationHeritageClauses(node) {
            var seenExtendsClause = false;
            var seenImplementsClause = false;
            if (!checkGrammarDecoratorsAndModifiers(node) && node.heritageClauses) {
                for (var _i = 0, _a = node.heritageClauses; _i < _a.length; _i++) {
                    var heritageClause = _a[_i];
                    if (heritageClause.token === 94 /* SyntaxKind.ExtendsKeyword */) {
                        if (seenExtendsClause) {
                            return grammarErrorOnFirstToken(heritageClause, ts.Diagnostics.extends_clause_already_seen);
                        }
                        if (seenImplementsClause) {
                            return grammarErrorOnFirstToken(heritageClause, ts.Diagnostics.extends_clause_must_precede_implements_clause);
                        }
                        if (heritageClause.types.length > 1) {
                            return grammarErrorOnFirstToken(heritageClause.types[1], ts.Diagnostics.Classes_can_only_extend_a_single_class);
                        }
                        seenExtendsClause = true;
                    }
                    else {
                        ts.Debug.assert(heritageClause.token === 117 /* SyntaxKind.ImplementsKeyword */);
                        if (seenImplementsClause) {
                            return grammarErrorOnFirstToken(heritageClause, ts.Diagnostics.implements_clause_already_seen);
                        }
                        seenImplementsClause = true;
                    }
                    // Grammar checking heritageClause inside class declaration
                    checkGrammarHeritageClause(heritageClause);
                }
            }
        }
        function checkGrammarInterfaceDeclaration(node) {
            var seenExtendsClause = false;
            if (node.heritageClauses) {
                for (var _i = 0, _a = node.heritageClauses; _i < _a.length; _i++) {
                    var heritageClause = _a[_i];
                    if (heritageClause.token === 94 /* SyntaxKind.ExtendsKeyword */) {
                        if (seenExtendsClause) {
                            return grammarErrorOnFirstToken(heritageClause, ts.Diagnostics.extends_clause_already_seen);
                        }
                        seenExtendsClause = true;
                    }
                    else {
                        ts.Debug.assert(heritageClause.token === 117 /* SyntaxKind.ImplementsKeyword */);
                        return grammarErrorOnFirstToken(heritageClause, ts.Diagnostics.Interface_declaration_cannot_have_implements_clause);
                    }
                    // Grammar checking heritageClause inside class declaration
                    checkGrammarHeritageClause(heritageClause);
                }
            }
            return false;
        }
        function checkGrammarComputedPropertyName(node) {
            // If node is not a computedPropertyName, just skip the grammar checking
            if (node.kind !== 162 /* SyntaxKind.ComputedPropertyName */) {
                return false;
            }
            var computedPropertyName = node;
            if (computedPropertyName.expression.kind === 221 /* SyntaxKind.BinaryExpression */ && computedPropertyName.expression.operatorToken.kind === 27 /* SyntaxKind.CommaToken */) {
                return grammarErrorOnNode(computedPropertyName.expression, ts.Diagnostics.A_comma_expression_is_not_allowed_in_a_computed_property_name);
            }
            return false;
        }
        function checkGrammarForGenerator(node) {
            if (node.asteriskToken) {
                ts.Debug.assert(node.kind === 256 /* SyntaxKind.FunctionDeclaration */ ||
                    node.kind === 213 /* SyntaxKind.FunctionExpression */ ||
                    node.kind === 169 /* SyntaxKind.MethodDeclaration */);
                if (node.flags & 16777216 /* NodeFlags.Ambient */) {
                    return grammarErrorOnNode(node.asteriskToken, ts.Diagnostics.Generators_are_not_allowed_in_an_ambient_context);
                }
                if (!node.body) {
                    return grammarErrorOnNode(node.asteriskToken, ts.Diagnostics.An_overload_signature_cannot_be_declared_as_a_generator);
                }
            }
        }
        function checkGrammarForInvalidQuestionMark(questionToken, message) {
            return !!questionToken && grammarErrorOnNode(questionToken, message);
        }
        function checkGrammarForInvalidExclamationToken(exclamationToken, message) {
            return !!exclamationToken && grammarErrorOnNode(exclamationToken, message);
        }
        function checkGrammarObjectLiteralExpression(node, inDestructuring) {
            var seen = new ts.Map();
            for (var _i = 0, _a = node.properties; _i < _a.length; _i++) {
                var prop = _a[_i];
                if (prop.kind === 298 /* SyntaxKind.SpreadAssignment */) {
                    if (inDestructuring) {
                        // a rest property cannot be destructured any further
                        var expression = ts.skipParentheses(prop.expression);
                        if (ts.isArrayLiteralExpression(expression) || ts.isObjectLiteralExpression(expression)) {
                            return grammarErrorOnNode(prop.expression, ts.Diagnostics.A_rest_element_cannot_contain_a_binding_pattern);
                        }
                    }
                    continue;
                }
                var name = prop.name;
                if (name.kind === 162 /* SyntaxKind.ComputedPropertyName */) {
                    // If the name is not a ComputedPropertyName, the grammar checking will skip it
                    checkGrammarComputedPropertyName(name);
                }
                if (prop.kind === 297 /* SyntaxKind.ShorthandPropertyAssignment */ && !inDestructuring && prop.objectAssignmentInitializer) {
                    // having objectAssignmentInitializer is only valid in ObjectAssignmentPattern
                    // outside of destructuring it is a syntax error
                    grammarErrorOnNode(prop.equalsToken, ts.Diagnostics.Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_part_of_a_destructuring_pattern);
                }
                if (name.kind === 80 /* SyntaxKind.PrivateIdentifier */) {
                    grammarErrorOnNode(name, ts.Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies);
                }
                // Modifiers are never allowed on properties except for 'async' on a method declaration
                if (prop.modifiers) {
                    for (var _b = 0, _c = prop.modifiers; _b < _c.length; _b++) {
                        var mod = _c[_b];
                        if (mod.kind !== 131 /* SyntaxKind.AsyncKeyword */ || prop.kind !== 169 /* SyntaxKind.MethodDeclaration */) {
                            grammarErrorOnNode(mod, ts.Diagnostics._0_modifier_cannot_be_used_here, ts.getTextOfNode(mod));
                        }
                    }
                }
                // ECMA-262 11.1.5 Object Initializer
                // If previous is not undefined then throw a SyntaxError exception if any of the following conditions are true
                // a.This production is contained in strict code and IsDataDescriptor(previous) is true and
                // IsDataDescriptor(propId.descriptor) is true.
                //    b.IsDataDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true.
                //    c.IsAccessorDescriptor(previous) is true and IsDataDescriptor(propId.descriptor) is true.
                //    d.IsAccessorDescriptor(previous) is true and IsAccessorDescriptor(propId.descriptor) is true
                // and either both previous and propId.descriptor have[[Get]] fields or both previous and propId.descriptor have[[Set]] fields
                var currentKind = void 0;
                switch (prop.kind) {
                    case 297 /* SyntaxKind.ShorthandPropertyAssignment */:
                        checkGrammarForInvalidExclamationToken(prop.exclamationToken, ts.Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context);
                    // falls through
                    case 296 /* SyntaxKind.PropertyAssignment */:
                        // Grammar checking for computedPropertyName and shorthandPropertyAssignment
                        checkGrammarForInvalidQuestionMark(prop.questionToken, ts.Diagnostics.An_object_member_cannot_be_declared_optional);
                        if (name.kind === 8 /* SyntaxKind.NumericLiteral */) {
                            checkGrammarNumericLiteral(name);
                        }
                        currentKind = 4 /* DeclarationMeaning.PropertyAssignment */;
                        break;
                    case 169 /* SyntaxKind.MethodDeclaration */:
                        currentKind = 8 /* DeclarationMeaning.Method */;
                        break;
                    case 172 /* SyntaxKind.GetAccessor */:
                        currentKind = 1 /* DeclarationMeaning.GetAccessor */;
                        break;
                    case 173 /* SyntaxKind.SetAccessor */:
                        currentKind = 2 /* DeclarationMeaning.SetAccessor */;
                        break;
                    default:
                        throw ts.Debug.assertNever(prop, "Unexpected syntax kind:" + prop.kind);
                }
                if (!inDestructuring) {
                    var effectiveName = ts.getPropertyNameForPropertyNameNode(name);
                    if (effectiveName === undefined) {
                        continue;
                    }
                    var existingKind = seen.get(effectiveName);
                    if (!existingKind) {
                        seen.set(effectiveName, currentKind);
                    }
                    else {
                        if ((currentKind & 8 /* DeclarationMeaning.Method */) && (existingKind & 8 /* DeclarationMeaning.Method */)) {
                            grammarErrorOnNode(name, ts.Diagnostics.Duplicate_identifier_0, ts.getTextOfNode(name));
                        }
                        else if ((currentKind & 4 /* DeclarationMeaning.PropertyAssignment */) && (existingKind & 4 /* DeclarationMeaning.PropertyAssignment */)) {
                            grammarErrorOnNode(name, ts.Diagnostics.An_object_literal_cannot_have_multiple_properties_with_the_same_name, ts.getTextOfNode(name));
                        }
                        else if ((currentKind & 3 /* DeclarationMeaning.GetOrSetAccessor */) && (existingKind & 3 /* DeclarationMeaning.GetOrSetAccessor */)) {
                            if (existingKind !== 3 /* DeclarationMeaning.GetOrSetAccessor */ && currentKind !== existingKind) {
                                seen.set(effectiveName, currentKind | existingKind);
                            }
                            else {
                                return grammarErrorOnNode(name, ts.Diagnostics.An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name);
                            }
                        }
                        else {
                            return grammarErrorOnNode(name, ts.Diagnostics.An_object_literal_cannot_have_property_and_accessor_with_the_same_name);
                        }
                    }
                }
            }
        }
        function checkGrammarJsxElement(node) {
            checkGrammarJsxName(node.tagName);
            checkGrammarTypeArguments(node, node.typeArguments);
            var seen = new ts.Map();
            for (var _i = 0, _a = node.attributes.properties; _i < _a.length; _i++) {
                var attr = _a[_i];
                if (attr.kind === 287 /* SyntaxKind.JsxSpreadAttribute */) {
                    continue;
                }
                var name = attr.name, initializer = attr.initializer;
                if (!seen.get(name.escapedText)) {
                    seen.set(name.escapedText, true);
                }
                else {
                    return grammarErrorOnNode(name, ts.Diagnostics.JSX_elements_cannot_have_multiple_attributes_with_the_same_name);
                }
                if (initializer && initializer.kind === 288 /* SyntaxKind.JsxExpression */ && !initializer.expression) {
                    return grammarErrorOnNode(initializer, ts.Diagnostics.JSX_attributes_must_only_be_assigned_a_non_empty_expression);
                }
            }
        }
        function checkGrammarJsxName(node) {
            if (ts.isPropertyAccessExpression(node)) {
                var propName = node;
                do {
                    var check_1 = checkGrammarJsxNestedIdentifier(propName.name);
                    if (check_1) {
                        return check_1;
                    }
                    propName = propName.expression;
                } while (ts.isPropertyAccessExpression(propName));
                var check = checkGrammarJsxNestedIdentifier(propName);
                if (check) {
                    return check;
                }
            }
            function checkGrammarJsxNestedIdentifier(name) {
                if (ts.isIdentifier(name) && ts.idText(name).indexOf(":") !== -1) {
                    return grammarErrorOnNode(name, ts.Diagnostics.JSX_property_access_expressions_cannot_include_JSX_namespace_names);
                }
            }
        }
        function checkGrammarJsxExpression(node) {
            if (node.expression && ts.isCommaSequence(node.expression)) {
                return grammarErrorOnNode(node.expression, ts.Diagnostics.JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array);
            }
        }
        function checkGrammarForInOrForOfStatement(forInOrOfStatement) {
            if (checkGrammarStatementInAmbientContext(forInOrOfStatement)) {
                return true;
            }
            if (forInOrOfStatement.kind === 244 /* SyntaxKind.ForOfStatement */ && forInOrOfStatement.awaitModifier) {
                if (!(forInOrOfStatement.flags & 32768 /* NodeFlags.AwaitContext */)) {
                    var sourceFile = ts.getSourceFileOfNode(forInOrOfStatement);
                    if (ts.isInTopLevelContext(forInOrOfStatement)) {
                        if (!hasParseDiagnostics(sourceFile)) {
                            if (!ts.isEffectiveExternalModule(sourceFile, compilerOptions)) {
                                diagnostics.add(ts.createDiagnosticForNode(forInOrOfStatement.awaitModifier, ts.Diagnostics.for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module));
                            }
                            switch (moduleKind) {
                                case ts.ModuleKind.Node16:
                                case ts.ModuleKind.NodeNext:
                                    if (sourceFile.impliedNodeFormat === ts.ModuleKind.CommonJS) {
                                        diagnostics.add(ts.createDiagnosticForNode(forInOrOfStatement.awaitModifier, ts.Diagnostics.The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level));
                                        break;
                                    }
                                // fallthrough
                                case ts.ModuleKind.ES2022:
                                case ts.ModuleKind.ESNext:
                                case ts.ModuleKind.System:
                                    if (languageVersion >= 4 /* ScriptTarget.ES2017 */) {
                                        break;
                                    }
                                // fallthrough
                                default:
                                    diagnostics.add(ts.createDiagnosticForNode(forInOrOfStatement.awaitModifier, ts.Diagnostics.Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_or_nodenext_and_the_target_option_is_set_to_es2017_or_higher));
                                    break;
                            }
                        }
                    }
                    else {
                        // use of 'for-await-of' in non-async function
                        if (!hasParseDiagnostics(sourceFile)) {
                            var diagnostic = ts.createDiagnosticForNode(forInOrOfStatement.awaitModifier, ts.Diagnostics.for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules);
                            var func = ts.getContainingFunction(forInOrOfStatement);
                            if (func && func.kind !== 171 /* SyntaxKind.Constructor */) {
                                ts.Debug.assert((ts.getFunctionFlags(func) & 2 /* FunctionFlags.Async */) === 0, "Enclosing function should never be an async function.");
                                var relatedInfo = ts.createDiagnosticForNode(func, ts.Diagnostics.Did_you_mean_to_mark_this_function_as_async);
                                ts.addRelatedInfo(diagnostic, relatedInfo);
                            }
                            diagnostics.add(diagnostic);
                            return true;
                        }
                    }
                    return false;
                }
            }
            if (ts.isForOfStatement(forInOrOfStatement) && !(forInOrOfStatement.flags & 32768 /* NodeFlags.AwaitContext */) &&
                ts.isIdentifier(forInOrOfStatement.initializer) && forInOrOfStatement.initializer.escapedText === "async") {
                grammarErrorOnNode(forInOrOfStatement.initializer, ts.Diagnostics.The_left_hand_side_of_a_for_of_statement_may_not_be_async);
                return false;
            }
            if (forInOrOfStatement.initializer.kind === 255 /* SyntaxKind.VariableDeclarationList */) {
                var variableList = forInOrOfStatement.initializer;
                if (!checkGrammarVariableDeclarationList(variableList)) {
                    var declarations = variableList.declarations;
                    // declarations.length can be zero if there is an error in variable declaration in for-of or for-in
                    // See http://www.ecma-international.org/ecma-262/6.0/#sec-for-in-and-for-of-statements for details
                    // For example:
                    //      var let = 10;
                    //      for (let of [1,2,3]) {} // this is invalid ES6 syntax
                    //      for (let in [1,2,3]) {} // this is invalid ES6 syntax
                    // We will then want to skip on grammar checking on variableList declaration
                    if (!declarations.length) {
                        return false;
                    }
                    if (declarations.length > 1) {
                        var diagnostic = forInOrOfStatement.kind === 243 /* SyntaxKind.ForInStatement */
                            ? ts.Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement
                            : ts.Diagnostics.Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement;
                        return grammarErrorOnFirstToken(variableList.declarations[1], diagnostic);
                    }
                    var firstDeclaration = declarations[0];
                    if (firstDeclaration.initializer) {
                        var diagnostic = forInOrOfStatement.kind === 243 /* SyntaxKind.ForInStatement */
                            ? ts.Diagnostics.The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer
                            : ts.Diagnostics.The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer;
                        return grammarErrorOnNode(firstDeclaration.name, diagnostic);
                    }
                    if (firstDeclaration.type) {
                        var diagnostic = forInOrOfStatement.kind === 243 /* SyntaxKind.ForInStatement */
                            ? ts.Diagnostics.The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation
                            : ts.Diagnostics.The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation;
                        return grammarErrorOnNode(firstDeclaration, diagnostic);
                    }
                }
            }
            return false;
        }
        function checkGrammarAccessor(accessor) {
            if (!(accessor.flags & 16777216 /* NodeFlags.Ambient */) && (accessor.parent.kind !== 182 /* SyntaxKind.TypeLiteral */) && (accessor.parent.kind !== 258 /* SyntaxKind.InterfaceDeclaration */)) {
                if (languageVersion < 1 /* ScriptTarget.ES5 */) {
                    return grammarErrorOnNode(accessor.name, ts.Diagnostics.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher);
                }
                if (languageVersion < 2 /* ScriptTarget.ES2015 */ && ts.isPrivateIdentifier(accessor.name)) {
                    return grammarErrorOnNode(accessor.name, ts.Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher);
                }
                if (accessor.body === undefined && !ts.hasSyntacticModifier(accessor, 128 /* ModifierFlags.Abstract */)) {
                    return grammarErrorAtPos(accessor, accessor.end - 1, ";".length, ts.Diagnostics._0_expected, "{");
                }
            }
            if (accessor.body) {
                if (ts.hasSyntacticModifier(accessor, 128 /* ModifierFlags.Abstract */)) {
                    return grammarErrorOnNode(accessor, ts.Diagnostics.An_abstract_accessor_cannot_have_an_implementation);
                }
                if (accessor.parent.kind === 182 /* SyntaxKind.TypeLiteral */ || accessor.parent.kind === 258 /* SyntaxKind.InterfaceDeclaration */) {
                    return grammarErrorOnNode(accessor.body, ts.Diagnostics.An_implementation_cannot_be_declared_in_ambient_contexts);
                }
            }
            if (accessor.typeParameters) {
                return grammarErrorOnNode(accessor.name, ts.Diagnostics.An_accessor_cannot_have_type_parameters);
            }
            if (!doesAccessorHaveCorrectParameterCount(accessor)) {
                return grammarErrorOnNode(accessor.name, accessor.kind === 172 /* SyntaxKind.GetAccessor */ ?
                    ts.Diagnostics.A_get_accessor_cannot_have_parameters :
                    ts.Diagnostics.A_set_accessor_must_have_exactly_one_parameter);
            }
            if (accessor.kind === 173 /* SyntaxKind.SetAccessor */) {
                if (accessor.type) {
                    return grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_cannot_have_a_return_type_annotation);
                }
                var parameter = ts.Debug.checkDefined(ts.getSetAccessorValueParameter(accessor), "Return value does not match parameter count assertion.");
                if (parameter.dotDotDotToken) {
                    return grammarErrorOnNode(parameter.dotDotDotToken, ts.Diagnostics.A_set_accessor_cannot_have_rest_parameter);
                }
                if (parameter.questionToken) {
                    return grammarErrorOnNode(parameter.questionToken, ts.Diagnostics.A_set_accessor_cannot_have_an_optional_parameter);
                }
                if (parameter.initializer) {
                    return grammarErrorOnNode(accessor.name, ts.Diagnostics.A_set_accessor_parameter_cannot_have_an_initializer);
                }
            }
            return false;
        }
        /** Does the accessor have the right number of parameters?
         * A get accessor has no parameters or a single `this` parameter.
         * A set accessor has one parameter or a `this` parameter and one more parameter.
         */
        function doesAccessorHaveCorrectParameterCount(accessor) {
            return getAccessorThisParameter(accessor) || accessor.parameters.length === (accessor.kind === 172 /* SyntaxKind.GetAccessor */ ? 0 : 1);
        }
        function getAccessorThisParameter(accessor) {
            if (accessor.parameters.length === (accessor.kind === 172 /* SyntaxKind.GetAccessor */ ? 1 : 2)) {
                return ts.getThisParameter(accessor);
            }
        }
        function checkGrammarTypeOperatorNode(node) {
            if (node.operator === 154 /* SyntaxKind.UniqueKeyword */) {
                if (node.type.kind !== 151 /* SyntaxKind.SymbolKeyword */) {
                    return grammarErrorOnNode(node.type, ts.Diagnostics._0_expected, ts.tokenToString(151 /* SyntaxKind.SymbolKeyword */));
                }
                var parent = ts.walkUpParenthesizedTypes(node.parent);
                if (ts.isInJSFile(parent) && ts.isJSDocTypeExpression(parent)) {
                    var host_2 = ts.getJSDocHost(parent);
                    if (host_2) {
                        parent = ts.getSingleVariableOfVariableStatement(host_2) || host_2;
                    }
                }
                switch (parent.kind) {
                    case 254 /* SyntaxKind.VariableDeclaration */:
                        var decl = parent;
                        if (decl.name.kind !== 79 /* SyntaxKind.Identifier */) {
                            return grammarErrorOnNode(node, ts.Diagnostics.unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name);
                        }
                        if (!ts.isVariableDeclarationInVariableStatement(decl)) {
                            return grammarErrorOnNode(node, ts.Diagnostics.unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement);
                        }
                        if (!(decl.parent.flags & 2 /* NodeFlags.Const */)) {
                            return grammarErrorOnNode(parent.name, ts.Diagnostics.A_variable_whose_type_is_a_unique_symbol_type_must_be_const);
                        }
                        break;
                    case 167 /* SyntaxKind.PropertyDeclaration */:
                        if (!ts.isStatic(parent) ||
                            !ts.hasEffectiveReadonlyModifier(parent)) {
                            return grammarErrorOnNode(parent.name, ts.Diagnostics.A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly);
                        }
                        break;
                    case 166 /* SyntaxKind.PropertySignature */:
                        if (!ts.hasSyntacticModifier(parent, 64 /* ModifierFlags.Readonly */)) {
                            return grammarErrorOnNode(parent.name, ts.Diagnostics.A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly);
                        }
                        break;
                    default:
                        return grammarErrorOnNode(node, ts.Diagnostics.unique_symbol_types_are_not_allowed_here);
                }
            }
            else if (node.operator === 145 /* SyntaxKind.ReadonlyKeyword */) {
                if (node.type.kind !== 183 /* SyntaxKind.ArrayType */ && node.type.kind !== 184 /* SyntaxKind.TupleType */) {
                    return grammarErrorOnFirstToken(node, ts.Diagnostics.readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types, ts.tokenToString(151 /* SyntaxKind.SymbolKeyword */));
                }
            }
        }
        function checkGrammarForInvalidDynamicName(node, message) {
            if (isNonBindableDynamicName(node)) {
                return grammarErrorOnNode(node, message);
            }
        }
        function checkGrammarMethod(node) {
            if (checkGrammarFunctionLikeDeclaration(node)) {
                return true;
            }
            if (node.kind === 169 /* SyntaxKind.MethodDeclaration */) {
                if (node.parent.kind === 205 /* SyntaxKind.ObjectLiteralExpression */) {
                    // We only disallow modifier on a method declaration if it is a property of object-literal-expression
                    if (node.modifiers && !(node.modifiers.length === 1 && ts.first(node.modifiers).kind === 131 /* SyntaxKind.AsyncKeyword */)) {
                        return grammarErrorOnFirstToken(node, ts.Diagnostics.Modifiers_cannot_appear_here);
                    }
                    else if (checkGrammarForInvalidQuestionMark(node.questionToken, ts.Diagnostics.An_object_member_cannot_be_declared_optional)) {
                        return true;
                    }
                    else if (checkGrammarForInvalidExclamationToken(node.exclamationToken, ts.Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context)) {
                        return true;
                    }
                    else if (node.body === undefined) {
                        return grammarErrorAtPos(node, node.end - 1, ";".length, ts.Diagnostics._0_expected, "{");
                    }
                }
                if (checkGrammarForGenerator(node)) {
                    return true;
                }
            }
            if (ts.isClassLike(node.parent)) {
                if (languageVersion < 2 /* ScriptTarget.ES2015 */ && ts.isPrivateIdentifier(node.name)) {
                    return grammarErrorOnNode(node.name, ts.Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher);
                }
                // Technically, computed properties in ambient contexts is disallowed
                // for property declarations and accessors too, not just methods.
                // However, property declarations disallow computed names in general,
                // and accessors are not allowed in ambient contexts in general,
                // so this error only really matters for methods.
                if (node.flags & 16777216 /* NodeFlags.Ambient */) {
                    return checkGrammarForInvalidDynamicName(node.name, ts.Diagnostics.A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type);
                }
                else if (node.kind === 169 /* SyntaxKind.MethodDeclaration */ && !node.body) {
                    return checkGrammarForInvalidDynamicName(node.name, ts.Diagnostics.A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type);
                }
            }
            else if (node.parent.kind === 258 /* SyntaxKind.InterfaceDeclaration */) {
                return checkGrammarForInvalidDynamicName(node.name, ts.Diagnostics.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type);
            }
            else if (node.parent.kind === 182 /* SyntaxKind.TypeLiteral */) {
                return checkGrammarForInvalidDynamicName(node.name, ts.Diagnostics.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type);
            }
        }
        function checkGrammarBreakOrContinueStatement(node) {
            var current = node;
            while (current) {
                if (ts.isFunctionLikeOrClassStaticBlockDeclaration(current)) {
                    return grammarErrorOnNode(node, ts.Diagnostics.Jump_target_cannot_cross_function_boundary);
                }
                switch (current.kind) {
                    case 250 /* SyntaxKind.LabeledStatement */:
                        if (node.label && current.label.escapedText === node.label.escapedText) {
                            // found matching label - verify that label usage is correct
                            // continue can only target labels that are on iteration statements
                            var isMisplacedContinueLabel = node.kind === 245 /* SyntaxKind.ContinueStatement */
                                && !ts.isIterationStatement(current.statement, /*lookInLabeledStatement*/ true);
                            if (isMisplacedContinueLabel) {
                                return grammarErrorOnNode(node, ts.Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement);
                            }
                            return false;
                        }
                        break;
                    case 249 /* SyntaxKind.SwitchStatement */:
                        if (node.kind === 246 /* SyntaxKind.BreakStatement */ && !node.label) {
                            // unlabeled break within switch statement - ok
                            return false;
                        }
                        break;
                    default:
                        if (ts.isIterationStatement(current, /*lookInLabeledStatement*/ false) && !node.label) {
                            // unlabeled break or continue within iteration statement - ok
                            return false;
                        }
                        break;
                }
                current = current.parent;
            }
            if (node.label) {
                var message = node.kind === 246 /* SyntaxKind.BreakStatement */
                    ? ts.Diagnostics.A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement
                    : ts.Diagnostics.A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement;
                return grammarErrorOnNode(node, message);
            }
            else {
                var message = node.kind === 246 /* SyntaxKind.BreakStatement */
                    ? ts.Diagnostics.A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement
                    : ts.Diagnostics.A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement;
                return grammarErrorOnNode(node, message);
            }
        }
        function checkGrammarBindingElement(node) {
            if (node.dotDotDotToken) {
                var elements = node.parent.elements;
                if (node !== ts.last(elements)) {
                    return grammarErrorOnNode(node, ts.Diagnostics.A_rest_element_must_be_last_in_a_destructuring_pattern);
                }
                checkGrammarForDisallowedTrailingComma(elements, ts.Diagnostics.A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma);
                if (node.propertyName) {
                    return grammarErrorOnNode(node.name, ts.Diagnostics.A_rest_element_cannot_have_a_property_name);
                }
            }
            if (node.dotDotDotToken && node.initializer) {
                // Error on equals token which immediately precedes the initializer
                return grammarErrorAtPos(node, node.initializer.pos - 1, 1, ts.Diagnostics.A_rest_element_cannot_have_an_initializer);
            }
        }
        function isStringOrNumberLiteralExpression(expr) {
            return ts.isStringOrNumericLiteralLike(expr) ||
                expr.kind === 219 /* SyntaxKind.PrefixUnaryExpression */ && expr.operator === 40 /* SyntaxKind.MinusToken */ &&
                    expr.operand.kind === 8 /* SyntaxKind.NumericLiteral */;
        }
        function isBigIntLiteralExpression(expr) {
            return expr.kind === 9 /* SyntaxKind.BigIntLiteral */ ||
                expr.kind === 219 /* SyntaxKind.PrefixUnaryExpression */ && expr.operator === 40 /* SyntaxKind.MinusToken */ &&
                    expr.operand.kind === 9 /* SyntaxKind.BigIntLiteral */;
        }
        function isSimpleLiteralEnumReference(expr) {
            if ((ts.isPropertyAccessExpression(expr) || (ts.isElementAccessExpression(expr) && isStringOrNumberLiteralExpression(expr.argumentExpression))) &&
                ts.isEntityNameExpression(expr.expression)) {
                return !!(checkExpressionCached(expr).flags & 1024 /* TypeFlags.EnumLiteral */);
            }
        }
        function checkAmbientInitializer(node) {
            var initializer = node.initializer;
            if (initializer) {
                var isInvalidInitializer = !(isStringOrNumberLiteralExpression(initializer) ||
                    isSimpleLiteralEnumReference(initializer) ||
                    initializer.kind === 110 /* SyntaxKind.TrueKeyword */ || initializer.kind === 95 /* SyntaxKind.FalseKeyword */ ||
                    isBigIntLiteralExpression(initializer));
                var isConstOrReadonly = ts.isDeclarationReadonly(node) || ts.isVariableDeclaration(node) && ts.isVarConst(node);
                if (isConstOrReadonly && !node.type) {
                    if (isInvalidInitializer) {
                        return grammarErrorOnNode(initializer, ts.Diagnostics.A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_reference);
                    }
                }
                else {
                    return grammarErrorOnNode(initializer, ts.Diagnostics.Initializers_are_not_allowed_in_ambient_contexts);
                }
                if (!isConstOrReadonly || isInvalidInitializer) {
                    return grammarErrorOnNode(initializer, ts.Diagnostics.Initializers_are_not_allowed_in_ambient_contexts);
                }
            }
        }
        function checkGrammarVariableDeclaration(node) {
            if (node.parent.parent.kind !== 243 /* SyntaxKind.ForInStatement */ && node.parent.parent.kind !== 244 /* SyntaxKind.ForOfStatement */) {
                if (node.flags & 16777216 /* NodeFlags.Ambient */) {
                    checkAmbientInitializer(node);
                }
                else if (!node.initializer) {
                    if (ts.isBindingPattern(node.name) && !ts.isBindingPattern(node.parent)) {
                        return grammarErrorOnNode(node, ts.Diagnostics.A_destructuring_declaration_must_have_an_initializer);
                    }
                    if (ts.isVarConst(node)) {
                        return grammarErrorOnNode(node, ts.Diagnostics.const_declarations_must_be_initialized);
                    }
                }
            }
            if (node.exclamationToken && (node.parent.parent.kind !== 237 /* SyntaxKind.VariableStatement */ || !node.type || node.initializer || node.flags & 16777216 /* NodeFlags.Ambient */)) {
                var message = node.initializer
                    ? ts.Diagnostics.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions
                    : !node.type
                        ? ts.Diagnostics.Declarations_with_definite_assignment_assertions_must_also_have_type_annotations
                        : ts.Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context;
                return grammarErrorOnNode(node.exclamationToken, message);
            }
            if ((moduleKind < ts.ModuleKind.ES2015 || ts.getSourceFileOfNode(node).impliedNodeFormat === ts.ModuleKind.CommonJS) && moduleKind !== ts.ModuleKind.System &&
                !(node.parent.parent.flags & 16777216 /* NodeFlags.Ambient */) && ts.hasSyntacticModifier(node.parent.parent, 1 /* ModifierFlags.Export */)) {
                checkESModuleMarker(node.name);
            }
            var checkLetConstNames = (ts.isLet(node) || ts.isVarConst(node));
            // 1. LexicalDeclaration : LetOrConst BindingList ;
            // It is a Syntax Error if the BoundNames of BindingList contains "let".
            // 2. ForDeclaration: ForDeclaration : LetOrConst ForBinding
            // It is a Syntax Error if the BoundNames of ForDeclaration contains "let".
            // It is a SyntaxError if a VariableDeclaration or VariableDeclarationNoIn occurs within strict code
            // and its Identifier is eval or arguments
            return checkLetConstNames && checkGrammarNameInLetOrConstDeclarations(node.name);
        }
        function checkESModuleMarker(name) {
            if (name.kind === 79 /* SyntaxKind.Identifier */) {
                if (ts.idText(name) === "__esModule") {
                    return grammarErrorOnNodeSkippedOn("noEmit", name, ts.Diagnostics.Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules);
                }
            }
            else {
                var elements = name.elements;
                for (var _i = 0, elements_2 = elements; _i < elements_2.length; _i++) {
                    var element = elements_2[_i];
                    if (!ts.isOmittedExpression(element)) {
                        return checkESModuleMarker(element.name);
                    }
                }
            }
            return false;
        }
        function checkGrammarNameInLetOrConstDeclarations(name) {
            if (name.kind === 79 /* SyntaxKind.Identifier */) {
                if (name.originalKeywordKind === 119 /* SyntaxKind.LetKeyword */) {
                    return grammarErrorOnNode(name, ts.Diagnostics.let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations);
                }
            }
            else {
                var elements = name.elements;
                for (var _i = 0, elements_3 = elements; _i < elements_3.length; _i++) {
                    var element = elements_3[_i];
                    if (!ts.isOmittedExpression(element)) {
                        checkGrammarNameInLetOrConstDeclarations(element.name);
                    }
                }
            }
            return false;
        }
        function checkGrammarVariableDeclarationList(declarationList) {
            var declarations = declarationList.declarations;
            if (checkGrammarForDisallowedTrailingComma(declarationList.declarations)) {
                return true;
            }
            if (!declarationList.declarations.length) {
                return grammarErrorAtPos(declarationList, declarations.pos, declarations.end - declarations.pos, ts.Diagnostics.Variable_declaration_list_cannot_be_empty);
            }
            return false;
        }
        function allowLetAndConstDeclarations(parent) {
            switch (parent.kind) {
                case 239 /* SyntaxKind.IfStatement */:
                case 240 /* SyntaxKind.DoStatement */:
                case 241 /* SyntaxKind.WhileStatement */:
                case 248 /* SyntaxKind.WithStatement */:
                case 242 /* SyntaxKind.ForStatement */:
                case 243 /* SyntaxKind.ForInStatement */:
                case 244 /* SyntaxKind.ForOfStatement */:
                    return false;
                case 250 /* SyntaxKind.LabeledStatement */:
                    return allowLetAndConstDeclarations(parent.parent);
            }
            return true;
        }
        function checkGrammarForDisallowedLetOrConstStatement(node) {
            if (!allowLetAndConstDeclarations(node.parent)) {
                if (ts.isLet(node.declarationList)) {
                    return grammarErrorOnNode(node, ts.Diagnostics.let_declarations_can_only_be_declared_inside_a_block);
                }
                else if (ts.isVarConst(node.declarationList)) {
                    return grammarErrorOnNode(node, ts.Diagnostics.const_declarations_can_only_be_declared_inside_a_block);
                }
            }
        }
        function checkGrammarMetaProperty(node) {
            var escapedText = node.name.escapedText;
            switch (node.keywordToken) {
                case 103 /* SyntaxKind.NewKeyword */:
                    if (escapedText !== "target") {
                        return grammarErrorOnNode(node.name, ts.Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2, node.name.escapedText, ts.tokenToString(node.keywordToken), "target");
                    }
                    break;
                case 100 /* SyntaxKind.ImportKeyword */:
                    if (escapedText !== "meta") {
                        return grammarErrorOnNode(node.name, ts.Diagnostics._0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2, node.name.escapedText, ts.tokenToString(node.keywordToken), "meta");
                    }
                    break;
            }
        }
        function hasParseDiagnostics(sourceFile) {
            return sourceFile.parseDiagnostics.length > 0;
        }
        function grammarErrorOnFirstToken(node, message, arg0, arg1, arg2) {
            var sourceFile = ts.getSourceFileOfNode(node);
            if (!hasParseDiagnostics(sourceFile)) {
                var span = ts.getSpanOfTokenAtPosition(sourceFile, node.pos);
                diagnostics.add(ts.createFileDiagnostic(sourceFile, span.start, span.length, message, arg0, arg1, arg2));
                return true;
            }
            return false;
        }
        function grammarErrorAtPos(nodeForSourceFile, start, length, message, arg0, arg1, arg2) {
            var sourceFile = ts.getSourceFileOfNode(nodeForSourceFile);
            if (!hasParseDiagnostics(sourceFile)) {
                diagnostics.add(ts.createFileDiagnostic(sourceFile, start, length, message, arg0, arg1, arg2));
                return true;
            }
            return false;
        }
        function grammarErrorOnNodeSkippedOn(key, node, message, arg0, arg1, arg2) {
            var sourceFile = ts.getSourceFileOfNode(node);
            if (!hasParseDiagnostics(sourceFile)) {
                errorSkippedOn(key, node, message, arg0, arg1, arg2);
                return true;
            }
            return false;
        }
        function grammarErrorOnNode(node, message, arg0, arg1, arg2) {
            var sourceFile = ts.getSourceFileOfNode(node);
            if (!hasParseDiagnostics(sourceFile)) {
                diagnostics.add(ts.createDiagnosticForNode(node, message, arg0, arg1, arg2));
                return true;
            }
            return false;
        }
        function checkGrammarConstructorTypeParameters(node) {
            var jsdocTypeParameters = ts.isInJSFile(node) ? ts.getJSDocTypeParameterDeclarations(node) : undefined;
            var range = node.typeParameters || jsdocTypeParameters && ts.firstOrUndefined(jsdocTypeParameters);
            if (range) {
                var pos = range.pos === range.end ? range.pos : ts.skipTrivia(ts.getSourceFileOfNode(node).text, range.pos);
                return grammarErrorAtPos(node, pos, range.end - pos, ts.Diagnostics.Type_parameters_cannot_appear_on_a_constructor_declaration);
            }
        }
        function checkGrammarConstructorTypeAnnotation(node) {
            var type = ts.getEffectiveReturnTypeNode(node);
            if (type) {
                return grammarErrorOnNode(type, ts.Diagnostics.Type_annotation_cannot_appear_on_a_constructor_declaration);
            }
        }
        function checkGrammarProperty(node) {
            if (ts.isComputedPropertyName(node.name) && ts.isBinaryExpression(node.name.expression) && node.name.expression.operatorToken.kind === 101 /* SyntaxKind.InKeyword */) {
                return grammarErrorOnNode(node.parent.members[0], ts.Diagnostics.A_mapped_type_may_not_declare_properties_or_methods);
            }
            if (ts.isClassLike(node.parent)) {
                if (ts.isStringLiteral(node.name) && node.name.text === "constructor") {
                    return grammarErrorOnNode(node.name, ts.Diagnostics.Classes_may_not_have_a_field_named_constructor);
                }
                if (checkGrammarForInvalidDynamicName(node.name, ts.Diagnostics.A_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_symbol_type)) {
                    return true;
                }
                if (languageVersion < 2 /* ScriptTarget.ES2015 */ && ts.isPrivateIdentifier(node.name)) {
                    return grammarErrorOnNode(node.name, ts.Diagnostics.Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher);
                }
            }
            else if (node.parent.kind === 258 /* SyntaxKind.InterfaceDeclaration */) {
                if (checkGrammarForInvalidDynamicName(node.name, ts.Diagnostics.A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)) {
                    return true;
                }
                if (node.initializer) {
                    return grammarErrorOnNode(node.initializer, ts.Diagnostics.An_interface_property_cannot_have_an_initializer);
                }
            }
            else if (ts.isTypeLiteralNode(node.parent)) {
                if (checkGrammarForInvalidDynamicName(node.name, ts.Diagnostics.A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type)) {
                    return true;
                }
                if (node.initializer) {
                    return grammarErrorOnNode(node.initializer, ts.Diagnostics.A_type_literal_property_cannot_have_an_initializer);
                }
            }
            if (node.flags & 16777216 /* NodeFlags.Ambient */) {
                checkAmbientInitializer(node);
            }
            if (ts.isPropertyDeclaration(node) && node.exclamationToken && (!ts.isClassLike(node.parent) || !node.type || node.initializer ||
                node.flags & 16777216 /* NodeFlags.Ambient */ || ts.isStatic(node) || ts.hasAbstractModifier(node))) {
                var message = node.initializer
                    ? ts.Diagnostics.Declarations_with_initializers_cannot_also_have_definite_assignment_assertions
                    : !node.type
                        ? ts.Diagnostics.Declarations_with_definite_assignment_assertions_must_also_have_type_annotations
                        : ts.Diagnostics.A_definite_assignment_assertion_is_not_permitted_in_this_context;
                return grammarErrorOnNode(node.exclamationToken, message);
            }
        }
        function checkGrammarTopLevelElementForRequiredDeclareModifier(node) {
            // A declare modifier is required for any top level .d.ts declaration except export=, export default, export as namespace
            // interfaces and imports categories:
            //
            //  DeclarationElement:
            //     ExportAssignment
            //     export_opt   InterfaceDeclaration
            //     export_opt   TypeAliasDeclaration
            //     export_opt   ImportDeclaration
            //     export_opt   ExternalImportDeclaration
            //     export_opt   AmbientDeclaration
            //
            // TODO: The spec needs to be amended to reflect this grammar.
            if (node.kind === 258 /* SyntaxKind.InterfaceDeclaration */ ||
                node.kind === 259 /* SyntaxKind.TypeAliasDeclaration */ ||
                node.kind === 266 /* SyntaxKind.ImportDeclaration */ ||
                node.kind === 265 /* SyntaxKind.ImportEqualsDeclaration */ ||
                node.kind === 272 /* SyntaxKind.ExportDeclaration */ ||
                node.kind === 271 /* SyntaxKind.ExportAssignment */ ||
                node.kind === 264 /* SyntaxKind.NamespaceExportDeclaration */ ||
                ts.hasSyntacticModifier(node, 2 /* ModifierFlags.Ambient */ | 1 /* ModifierFlags.Export */ | 512 /* ModifierFlags.Default */)) {
                return false;
            }
            return grammarErrorOnFirstToken(node, ts.Diagnostics.Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier);
        }
        function checkGrammarTopLevelElementsForRequiredDeclareModifier(file) {
            for (var _i = 0, _a = file.statements; _i < _a.length; _i++) {
                var decl = _a[_i];
                if (ts.isDeclaration(decl) || decl.kind === 237 /* SyntaxKind.VariableStatement */) {
                    if (checkGrammarTopLevelElementForRequiredDeclareModifier(decl)) {
                        return true;
                    }
                }
            }
            return false;
        }
        function checkGrammarSourceFile(node) {
            return !!(node.flags & 16777216 /* NodeFlags.Ambient */) && checkGrammarTopLevelElementsForRequiredDeclareModifier(node);
        }
        function checkGrammarStatementInAmbientContext(node) {
            if (node.flags & 16777216 /* NodeFlags.Ambient */) {
                // Find containing block which is either Block, ModuleBlock, SourceFile
                var links = getNodeLinks(node);
                if (!links.hasReportedStatementInAmbientContext && (ts.isFunctionLike(node.parent) || ts.isAccessor(node.parent))) {
                    return getNodeLinks(node).hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(node, ts.Diagnostics.An_implementation_cannot_be_declared_in_ambient_contexts);
                }
                // We are either parented by another statement, or some sort of block.
                // If we're in a block, we only want to really report an error once
                // to prevent noisiness.  So use a bit on the block to indicate if
                // this has already been reported, and don't report if it has.
                //
                if (node.parent.kind === 235 /* SyntaxKind.Block */ || node.parent.kind === 262 /* SyntaxKind.ModuleBlock */ || node.parent.kind === 305 /* SyntaxKind.SourceFile */) {
                    var links_2 = getNodeLinks(node.parent);
                    // Check if the containing block ever report this error
                    if (!links_2.hasReportedStatementInAmbientContext) {
                        return links_2.hasReportedStatementInAmbientContext = grammarErrorOnFirstToken(node, ts.Diagnostics.Statements_are_not_allowed_in_ambient_contexts);
                    }
                }
                else {
                    // We must be parented by a statement.  If so, there's no need
                    // to report the error as our parent will have already done it.
                    // Debug.assert(isStatement(node.parent));
                }
            }
            return false;
        }
        function checkGrammarNumericLiteral(node) {
            // Grammar checking
            if (node.numericLiteralFlags & 32 /* TokenFlags.Octal */) {
                var diagnosticMessage = void 0;
                if (languageVersion >= 1 /* ScriptTarget.ES5 */) {
                    diagnosticMessage = ts.Diagnostics.Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher_Use_the_syntax_0;
                }
                else if (ts.isChildOfNodeWithKind(node, 196 /* SyntaxKind.LiteralType */)) {
                    diagnosticMessage = ts.Diagnostics.Octal_literal_types_must_use_ES2015_syntax_Use_the_syntax_0;
                }
                else if (ts.isChildOfNodeWithKind(node, 299 /* SyntaxKind.EnumMember */)) {
                    diagnosticMessage = ts.Diagnostics.Octal_literals_are_not_allowed_in_enums_members_initializer_Use_the_syntax_0;
                }
                if (diagnosticMessage) {
                    var withMinus = ts.isPrefixUnaryExpression(node.parent) && node.parent.operator === 40 /* SyntaxKind.MinusToken */;
                    var literal = (withMinus ? "-" : "") + "0o" + node.text;
                    return grammarErrorOnNode(withMinus ? node.parent : node, diagnosticMessage, literal);
                }
            }
            // Realism (size) checking
            checkNumericLiteralValueSize(node);
            return false;
        }
        function checkNumericLiteralValueSize(node) {
            // We should test against `getTextOfNode(node)` rather than `node.text`, because `node.text` for large numeric literals can contain "."
            // e.g. `node.text` for numeric literal `1100000000000000000000` is `1.1e21`.
            var isFractional = ts.getTextOfNode(node).indexOf(".") !== -1;
            var isScientific = node.numericLiteralFlags & 16 /* TokenFlags.Scientific */;
            // Scientific notation (e.g. 2e54 and 1e00000000010) can't be converted to bigint
            // Fractional numbers (e.g. 9000000000000000.001) are inherently imprecise anyway
            if (isFractional || isScientific) {
                return;
            }
            // Here `node` is guaranteed to be a numeric literal representing an integer.
            // We need to judge whether the integer `node` represents is <= 2 ** 53 - 1, which can be accomplished by comparing to `value` defined below because:
            // 1) when `node` represents an integer <= 2 ** 53 - 1, `node.text` is its exact string representation and thus `value` precisely represents the integer.
            // 2) otherwise, although `node.text` may be imprecise string representation, its mathematical value and consequently `value` cannot be less than 2 ** 53,
            //    thus the result of the predicate won't be affected.
            var value = +node.text;
            if (value <= Math.pow(2, 53) - 1) {
                return;
            }
            addErrorOrSuggestion(/*isError*/ false, ts.createDiagnosticForNode(node, ts.Diagnostics.Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accurately_as_integers));
        }
        function checkGrammarBigIntLiteral(node) {
            var literalType = ts.isLiteralTypeNode(node.parent) ||
                ts.isPrefixUnaryExpression(node.parent) && ts.isLiteralTypeNode(node.parent.parent);
            if (!literalType) {
                if (languageVersion < 7 /* ScriptTarget.ES2020 */) {
                    if (grammarErrorOnNode(node, ts.Diagnostics.BigInt_literals_are_not_available_when_targeting_lower_than_ES2020)) {
                        return true;
                    }
                }
            }
            return false;
        }
        function grammarErrorAfterFirstToken(node, message, arg0, arg1, arg2) {
            var sourceFile = ts.getSourceFileOfNode(node);
            if (!hasParseDiagnostics(sourceFile)) {
                var span = ts.getSpanOfTokenAtPosition(sourceFile, node.pos);
                diagnostics.add(ts.createFileDiagnostic(sourceFile, ts.textSpanEnd(span), /*length*/ 0, message, arg0, arg1, arg2));
                return true;
            }
            return false;
        }
        function getAmbientModules() {
            if (!ambientModulesCache) {
                ambientModulesCache = [];
                globals.forEach(function (global, sym) {
                    // No need to `unescapeLeadingUnderscores`, an escaped symbol is never an ambient module.
                    if (ambientModuleSymbolRegex.test(sym)) {
                        ambientModulesCache.push(global);
                    }
                });
            }
            return ambientModulesCache;
        }
        function checkGrammarImportClause(node) {
            var _a;
            if (node.isTypeOnly && node.name && node.namedBindings) {
                return grammarErrorOnNode(node, ts.Diagnostics.A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both);
            }
            if (node.isTypeOnly && ((_a = node.namedBindings) === null || _a === void 0 ? void 0 : _a.kind) === 269 /* SyntaxKind.NamedImports */) {
                return checkGrammarNamedImportsOrExports(node.namedBindings);
            }
            return false;
        }
        function checkGrammarNamedImportsOrExports(namedBindings) {
            return !!ts.forEach(namedBindings.elements, function (specifier) {
                if (specifier.isTypeOnly) {
                    return grammarErrorOnFirstToken(specifier, specifier.kind === 270 /* SyntaxKind.ImportSpecifier */
                        ? ts.Diagnostics.The_type_modifier_cannot_be_used_on_a_named_import_when_import_type_is_used_on_its_import_statement
                        : ts.Diagnostics.The_type_modifier_cannot_be_used_on_a_named_export_when_export_type_is_used_on_its_export_statement);
                }
            });
        }
        function checkGrammarImportCallExpression(node) {
            if (moduleKind === ts.ModuleKind.ES2015) {
                return grammarErrorOnNode(node, ts.Diagnostics.Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_es2022_esnext_commonjs_amd_system_umd_node16_or_nodenext);
            }
            if (node.typeArguments) {
                return grammarErrorOnNode(node, ts.Diagnostics.This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments);
            }
            var nodeArguments = node.arguments;
            if (moduleKind !== ts.ModuleKind.ESNext && moduleKind !== ts.ModuleKind.NodeNext) {
                // We are allowed trailing comma after proposal-import-assertions.
                checkGrammarForDisallowedTrailingComma(nodeArguments);
                if (nodeArguments.length > 1) {
                    var assertionArgument = nodeArguments[1];
                    return grammarErrorOnNode(assertionArgument, ts.Diagnostics.Dynamic_imports_only_support_a_second_argument_when_the_module_option_is_set_to_esnext_node16_or_nodenext);
                }
            }
            if (nodeArguments.length === 0 || nodeArguments.length > 2) {
                return grammarErrorOnNode(node, ts.Diagnostics.Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_assertion_as_arguments);
            }
            // see: parseArgumentOrArrayLiteralElement...we use this function which parse arguments of callExpression to parse specifier for dynamic import.
            // parseArgumentOrArrayLiteralElement allows spread element to be in an argument list which is not allowed as specifier in dynamic import.
            var spreadElement = ts.find(nodeArguments, ts.isSpreadElement);
            if (spreadElement) {
                return grammarErrorOnNode(spreadElement, ts.Diagnostics.Argument_of_dynamic_import_cannot_be_spread_element);
            }
            return false;
        }
        function findMatchingTypeReferenceOrTypeAliasReference(source, unionTarget) {
            var sourceObjectFlags = ts.getObjectFlags(source);
            if (sourceObjectFlags & (4 /* ObjectFlags.Reference */ | 16 /* ObjectFlags.Anonymous */) && unionTarget.flags & 1048576 /* TypeFlags.Union */) {
                return ts.find(unionTarget.types, function (target) {
                    if (target.flags & 524288 /* TypeFlags.Object */) {
                        var overlapObjFlags = sourceObjectFlags & ts.getObjectFlags(target);
                        if (overlapObjFlags & 4 /* ObjectFlags.Reference */) {
                            return source.target === target.target;
                        }
                        if (overlapObjFlags & 16 /* ObjectFlags.Anonymous */) {
                            return !!source.aliasSymbol && source.aliasSymbol === target.aliasSymbol;
                        }
                    }
                    return false;
                });
            }
        }
        function findBestTypeForObjectLiteral(source, unionTarget) {
            if (ts.getObjectFlags(source) & 128 /* ObjectFlags.ObjectLiteral */ && someType(unionTarget, isArrayLikeType)) {
                return ts.find(unionTarget.types, function (t) { return !isArrayLikeType(t); });
            }
        }
        function findBestTypeForInvokable(source, unionTarget) {
            var signatureKind = 0 /* SignatureKind.Call */;
            var hasSignatures = getSignaturesOfType(source, signatureKind).length > 0 ||
                (signatureKind = 1 /* SignatureKind.Construct */, getSignaturesOfType(source, signatureKind).length > 0);
            if (hasSignatures) {
                return ts.find(unionTarget.types, function (t) { return getSignaturesOfType(t, signatureKind).length > 0; });
            }
        }
        function findMostOverlappyType(source, unionTarget) {
            var bestMatch;
            if (!(source.flags & (131068 /* TypeFlags.Primitive */ | 406847488 /* TypeFlags.InstantiablePrimitive */))) {
                var matchingCount = 0;
                for (var _i = 0, _a = unionTarget.types; _i < _a.length; _i++) {
                    var target = _a[_i];
                    if (!(target.flags & (131068 /* TypeFlags.Primitive */ | 406847488 /* TypeFlags.InstantiablePrimitive */))) {
                        var overlap = getIntersectionType([getIndexType(source), getIndexType(target)]);
                        if (overlap.flags & 4194304 /* TypeFlags.Index */) {
                            // perfect overlap of keys
                            return target;
                        }
                        else if (isUnitType(overlap) || overlap.flags & 1048576 /* TypeFlags.Union */) {
                            // We only want to account for literal types otherwise.
                            // If we have a union of index types, it seems likely that we
                            // needed to elaborate between two generic mapped types anyway.
                            var len = overlap.flags & 1048576 /* TypeFlags.Union */ ? ts.countWhere(overlap.types, isUnitType) : 1;
                            if (len >= matchingCount) {
                                bestMatch = target;
                                matchingCount = len;
                            }
                        }
                    }
                }
            }
            return bestMatch;
        }
        function filterPrimitivesIfContainsNonPrimitive(type) {
            if (maybeTypeOfKind(type, 67108864 /* TypeFlags.NonPrimitive */)) {
                var result = filterType(type, function (t) { return !(t.flags & 131068 /* TypeFlags.Primitive */); });
                if (!(result.flags & 131072 /* TypeFlags.Never */)) {
                    return result;
                }
            }
            return type;
        }
        // Keep this up-to-date with the same logic within `getApparentTypeOfContextualType`, since they should behave similarly
        function findMatchingDiscriminantType(source, target, isRelatedTo, skipPartial) {
            if (target.flags & 1048576 /* TypeFlags.Union */ && source.flags & (2097152 /* TypeFlags.Intersection */ | 524288 /* TypeFlags.Object */)) {
                var match = getMatchingUnionConstituentForType(target, source);
                if (match) {
                    return match;
                }
                var sourceProperties = getPropertiesOfType(source);
                if (sourceProperties) {
                    var sourcePropertiesFiltered = findDiscriminantProperties(sourceProperties, target);
                    if (sourcePropertiesFiltered) {
                        return discriminateTypeByDiscriminableItems(target, ts.map(sourcePropertiesFiltered, function (p) { return [function () { return getTypeOfSymbol(p); }, p.escapedName]; }), isRelatedTo, /*defaultValue*/ undefined, skipPartial);
                    }
                }
            }
            return undefined;
        }
    }
    ts.createTypeChecker = createTypeChecker;
    function isNotAccessor(declaration) {
        // Accessors check for their own matching duplicates, and in contexts where they are valid, there are already duplicate identifier checks
        return !ts.isAccessor(declaration);
    }
    function isNotOverload(declaration) {
        return (declaration.kind !== 256 /* SyntaxKind.FunctionDeclaration */ && declaration.kind !== 169 /* SyntaxKind.MethodDeclaration */) ||
            !!declaration.body;
    }
    /** Like 'isDeclarationName', but returns true for LHS of `import { x as y }` or `export { x as y }`. */
    function isDeclarationNameOrImportPropertyName(name) {
        switch (name.parent.kind) {
            case 270 /* SyntaxKind.ImportSpecifier */:
            case 275 /* SyntaxKind.ExportSpecifier */:
                return ts.isIdentifier(name);
            default:
                return ts.isDeclarationName(name);
        }
    }
    var JsxNames;
    (function (JsxNames) {
        JsxNames.JSX = "JSX";
        JsxNames.IntrinsicElements = "IntrinsicElements";
        JsxNames.ElementClass = "ElementClass";
        JsxNames.ElementAttributesPropertyNameContainer = "ElementAttributesProperty"; // TODO: Deprecate and remove support
        JsxNames.ElementChildrenAttributeNameContainer = "ElementChildrenAttribute";
        JsxNames.Element = "Element";
        JsxNames.IntrinsicAttributes = "IntrinsicAttributes";
        JsxNames.IntrinsicClassAttributes = "IntrinsicClassAttributes";
        JsxNames.LibraryManagedAttributes = "LibraryManagedAttributes";
    })(JsxNames || (JsxNames = {}));
    function getIterationTypesKeyFromIterationTypeKind(typeKind) {
        switch (typeKind) {
            case 0 /* IterationTypeKind.Yield */: return "yieldType";
            case 1 /* IterationTypeKind.Return */: return "returnType";
            case 2 /* IterationTypeKind.Next */: return "nextType";
        }
    }
    function signatureHasRestParameter(s) {
        return !!(s.flags & 1 /* SignatureFlags.HasRestParameter */);
    }
    ts.signatureHasRestParameter = signatureHasRestParameter;
    function signatureHasLiteralTypes(s) {
        return !!(s.flags & 2 /* SignatureFlags.HasLiteralTypes */);
    }
    ts.signatureHasLiteralTypes = signatureHasLiteralTypes;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function visitNode(node, visitor, test, lift) {
        if (node === undefined || visitor === undefined) {
            return node;
        }
        var visited = visitor(node);
        if (visited === node) {
            return node;
        }
        var visitedNode;
        if (visited === undefined) {
            return undefined;
        }
        else if (ts.isArray(visited)) {
            visitedNode = (lift || extractSingleNode)(visited);
        }
        else {
            visitedNode = visited;
        }
        ts.Debug.assertNode(visitedNode, test);
        return visitedNode;
    }
    ts.visitNode = visitNode;
    /**
     * Visits a NodeArray using the supplied visitor, possibly returning a new NodeArray in its place.
     *
     * @param nodes The NodeArray to visit.
     * @param visitor The callback used to visit a Node.
     * @param test A node test to execute for each node.
     * @param start An optional value indicating the starting offset at which to start visiting.
     * @param count An optional value indicating the maximum number of nodes to visit.
     */
    function visitNodes(nodes, visitor, test, start, count) {
        if (nodes === undefined || visitor === undefined) {
            return nodes;
        }
        var updated;
        // Ensure start and count have valid values
        var length = nodes.length;
        if (start === undefined || start < 0) {
            start = 0;
        }
        if (count === undefined || count > length - start) {
            count = length - start;
        }
        var hasTrailingComma;
        var pos = -1;
        var end = -1;
        if (start > 0 || count < length) {
            // If we are not visiting all of the original nodes, we must always create a new array.
            // Since this is a fragment of a node array, we do not copy over the previous location
            // and will only copy over `hasTrailingComma` if we are including the last element.
            updated = [];
            hasTrailingComma = nodes.hasTrailingComma && start + count === length;
        }
        // Visit each original node.
        for (var i = 0; i < count; i++) {
            var node = nodes[i + start];
            var visited = node !== undefined ? visitor(node) : undefined;
            if (updated !== undefined || visited === undefined || visited !== node) {
                if (updated === undefined) {
                    // Ensure we have a copy of `nodes`, up to the current index.
                    updated = nodes.slice(0, i);
                    hasTrailingComma = nodes.hasTrailingComma;
                    pos = nodes.pos;
                    end = nodes.end;
                }
                if (visited) {
                    if (ts.isArray(visited)) {
                        for (var _i = 0, visited_1 = visited; _i < visited_1.length; _i++) {
                            var visitedNode = visited_1[_i];
                            void ts.Debug.assertNode(visitedNode, test);
                            updated.push(visitedNode);
                        }
                    }
                    else {
                        void ts.Debug.assertNode(visited, test);
                        updated.push(visited);
                    }
                }
            }
        }
        if (updated) {
            // TODO(rbuckton): Remove dependency on `ts.factory` in favor of a provided factory.
            var updatedArray = ts.factory.createNodeArray(updated, hasTrailingComma);
            ts.setTextRangePosEnd(updatedArray, pos, end);
            return updatedArray;
        }
        return nodes;
    }
    ts.visitNodes = visitNodes;
    /**
     * Starts a new lexical environment and visits a statement list, ending the lexical environment
     * and merging hoisted declarations upon completion.
     */
    function visitLexicalEnvironment(statements, visitor, context, start, ensureUseStrict, nodesVisitor) {
        if (nodesVisitor === void 0) { nodesVisitor = visitNodes; }
        context.startLexicalEnvironment();
        statements = nodesVisitor(statements, visitor, ts.isStatement, start);
        if (ensureUseStrict)
            statements = context.factory.ensureUseStrict(statements);
        return ts.factory.mergeLexicalEnvironment(statements, context.endLexicalEnvironment());
    }
    ts.visitLexicalEnvironment = visitLexicalEnvironment;
    function visitParameterList(nodes, visitor, context, nodesVisitor) {
        if (nodesVisitor === void 0) { nodesVisitor = visitNodes; }
        var updated;
        context.startLexicalEnvironment();
        if (nodes) {
            context.setLexicalEnvironmentFlags(1 /* LexicalEnvironmentFlags.InParameters */, true);
            updated = nodesVisitor(nodes, visitor, ts.isParameterDeclaration);
            // As of ES2015, any runtime execution of that occurs in for a parameter (such as evaluating an
            // initializer or a binding pattern), occurs in its own lexical scope. As a result, any expression
            // that we might transform that introduces a temporary variable would fail as the temporary variable
            // exists in a different lexical scope. To address this, we move any binding patterns and initializers
            // in a parameter list to the body if we detect a variable being hoisted while visiting a parameter list
            // when the emit target is greater than ES2015.
            if (context.getLexicalEnvironmentFlags() & 2 /* LexicalEnvironmentFlags.VariablesHoistedInParameters */ &&
                ts.getEmitScriptTarget(context.getCompilerOptions()) >= 2 /* ScriptTarget.ES2015 */) {
                updated = addDefaultValueAssignmentsIfNeeded(updated, context);
            }
            context.setLexicalEnvironmentFlags(1 /* LexicalEnvironmentFlags.InParameters */, false);
        }
        context.suspendLexicalEnvironment();
        return updated;
    }
    ts.visitParameterList = visitParameterList;
    function addDefaultValueAssignmentsIfNeeded(parameters, context) {
        var result;
        for (var i = 0; i < parameters.length; i++) {
            var parameter = parameters[i];
            var updated = addDefaultValueAssignmentIfNeeded(parameter, context);
            if (result || updated !== parameter) {
                if (!result)
                    result = parameters.slice(0, i);
                result[i] = updated;
            }
        }
        if (result) {
            return ts.setTextRange(context.factory.createNodeArray(result, parameters.hasTrailingComma), parameters);
        }
        return parameters;
    }
    function addDefaultValueAssignmentIfNeeded(parameter, context) {
        // A rest parameter cannot have a binding pattern or an initializer,
        // so let's just ignore it.
        return parameter.dotDotDotToken ? parameter :
            ts.isBindingPattern(parameter.name) ? addDefaultValueAssignmentForBindingPattern(parameter, context) :
                parameter.initializer ? addDefaultValueAssignmentForInitializer(parameter, parameter.name, parameter.initializer, context) :
                    parameter;
    }
    function addDefaultValueAssignmentForBindingPattern(parameter, context) {
        var factory = context.factory;
        context.addInitializationStatement(factory.createVariableStatement(
        /*modifiers*/ undefined, factory.createVariableDeclarationList([
            factory.createVariableDeclaration(parameter.name, 
            /*exclamationToken*/ undefined, parameter.type, parameter.initializer ?
                factory.createConditionalExpression(factory.createStrictEquality(factory.getGeneratedNameForNode(parameter), factory.createVoidZero()), 
                /*questionToken*/ undefined, parameter.initializer, 
                /*colonToken*/ undefined, factory.getGeneratedNameForNode(parameter)) :
                factory.getGeneratedNameForNode(parameter)),
        ])));
        return factory.updateParameterDeclaration(parameter, parameter.decorators, parameter.modifiers, parameter.dotDotDotToken, factory.getGeneratedNameForNode(parameter), parameter.questionToken, parameter.type, 
        /*initializer*/ undefined);
    }
    function addDefaultValueAssignmentForInitializer(parameter, name, initializer, context) {
        var factory = context.factory;
        context.addInitializationStatement(factory.createIfStatement(factory.createTypeCheck(factory.cloneNode(name), "undefined"), ts.setEmitFlags(ts.setTextRange(factory.createBlock([
            factory.createExpressionStatement(ts.setEmitFlags(ts.setTextRange(factory.createAssignment(ts.setEmitFlags(factory.cloneNode(name), 48 /* EmitFlags.NoSourceMap */), ts.setEmitFlags(initializer, 48 /* EmitFlags.NoSourceMap */ | ts.getEmitFlags(initializer) | 1536 /* EmitFlags.NoComments */)), parameter), 1536 /* EmitFlags.NoComments */))
        ]), parameter), 1 /* EmitFlags.SingleLine */ | 32 /* EmitFlags.NoTrailingSourceMap */ | 384 /* EmitFlags.NoTokenSourceMaps */ | 1536 /* EmitFlags.NoComments */)));
        return factory.updateParameterDeclaration(parameter, parameter.decorators, parameter.modifiers, parameter.dotDotDotToken, parameter.name, parameter.questionToken, parameter.type, 
        /*initializer*/ undefined);
    }
    function visitFunctionBody(node, visitor, context, nodeVisitor) {
        if (nodeVisitor === void 0) { nodeVisitor = visitNode; }
        context.resumeLexicalEnvironment();
        var updated = nodeVisitor(node, visitor, ts.isConciseBody);
        var declarations = context.endLexicalEnvironment();
        if (ts.some(declarations)) {
            if (!updated) {
                return context.factory.createBlock(declarations);
            }
            var block = context.factory.converters.convertToFunctionBlock(updated);
            var statements = ts.factory.mergeLexicalEnvironment(block.statements, declarations);
            return context.factory.updateBlock(block, statements);
        }
        return updated;
    }
    ts.visitFunctionBody = visitFunctionBody;
    /**
     * Visits an iteration body, adding any block-scoped variables required by the transformation.
     */
    function visitIterationBody(body, visitor, context) {
        context.startBlockScope();
        var updated = visitNode(body, visitor, ts.isStatement, context.factory.liftToBlock);
        var declarations = context.endBlockScope();
        if (ts.some(declarations)) {
            if (ts.isBlock(updated)) {
                declarations.push.apply(declarations, updated.statements);
                return context.factory.updateBlock(updated, declarations);
            }
            declarations.push(updated);
            return context.factory.createBlock(declarations);
        }
        return updated;
    }
    ts.visitIterationBody = visitIterationBody;
    function visitEachChild(node, visitor, context, nodesVisitor, tokenVisitor, nodeVisitor) {
        if (nodesVisitor === void 0) { nodesVisitor = visitNodes; }
        if (nodeVisitor === void 0) { nodeVisitor = visitNode; }
        if (node === undefined) {
            return undefined;
        }
        var kind = node.kind;
        // No need to visit nodes with no children.
        if ((kind > 0 /* SyntaxKind.FirstToken */ && kind <= 160 /* SyntaxKind.LastToken */) || kind === 192 /* SyntaxKind.ThisType */) {
            return node;
        }
        var factory = context.factory;
        switch (kind) {
            // Names
            case 79 /* SyntaxKind.Identifier */:
                ts.Debug.type(node);
                return factory.updateIdentifier(node, nodesVisitor(node.typeArguments, visitor, ts.isTypeNodeOrTypeParameterDeclaration));
            case 161 /* SyntaxKind.QualifiedName */:
                ts.Debug.type(node);
                return factory.updateQualifiedName(node, nodeVisitor(node.left, visitor, ts.isEntityName), nodeVisitor(node.right, visitor, ts.isIdentifier));
            case 162 /* SyntaxKind.ComputedPropertyName */:
                ts.Debug.type(node);
                return factory.updateComputedPropertyName(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            // Signature elements
            case 163 /* SyntaxKind.TypeParameter */:
                ts.Debug.type(node);
                return factory.updateTypeParameterDeclaration(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.name, visitor, ts.isIdentifier), nodeVisitor(node.constraint, visitor, ts.isTypeNode), nodeVisitor(node.default, visitor, ts.isTypeNode));
            case 164 /* SyntaxKind.Parameter */:
                ts.Debug.type(node);
                return factory.updateParameterDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.dotDotDotToken, tokenVisitor, ts.isDotDotDotToken), nodeVisitor(node.name, visitor, ts.isBindingName), nodeVisitor(node.questionToken, tokenVisitor, ts.isQuestionToken), nodeVisitor(node.type, visitor, ts.isTypeNode), nodeVisitor(node.initializer, visitor, ts.isExpression));
            case 165 /* SyntaxKind.Decorator */:
                ts.Debug.type(node);
                return factory.updateDecorator(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            // Type elements
            case 166 /* SyntaxKind.PropertySignature */:
                ts.Debug.type(node);
                return factory.updatePropertySignature(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.name, visitor, ts.isPropertyName), nodeVisitor(node.questionToken, tokenVisitor, ts.isToken), nodeVisitor(node.type, visitor, ts.isTypeNode));
            case 167 /* SyntaxKind.PropertyDeclaration */:
                ts.Debug.type(node);
                return factory.updatePropertyDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.name, visitor, ts.isPropertyName), 
                // QuestionToken and ExclamationToken is uniqued in Property Declaration and the signature of 'updateProperty' is that too
                nodeVisitor(node.questionToken || node.exclamationToken, tokenVisitor, ts.isQuestionOrExclamationToken), nodeVisitor(node.type, visitor, ts.isTypeNode), nodeVisitor(node.initializer, visitor, ts.isExpression));
            case 168 /* SyntaxKind.MethodSignature */:
                ts.Debug.type(node);
                return factory.updateMethodSignature(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.name, visitor, ts.isPropertyName), nodeVisitor(node.questionToken, tokenVisitor, ts.isQuestionToken), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), nodesVisitor(node.parameters, visitor, ts.isParameterDeclaration), nodeVisitor(node.type, visitor, ts.isTypeNode));
            case 169 /* SyntaxKind.MethodDeclaration */:
                ts.Debug.type(node);
                return factory.updateMethodDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.asteriskToken, tokenVisitor, ts.isAsteriskToken), nodeVisitor(node.name, visitor, ts.isPropertyName), nodeVisitor(node.questionToken, tokenVisitor, ts.isQuestionToken), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), visitParameterList(node.parameters, visitor, context, nodesVisitor), nodeVisitor(node.type, visitor, ts.isTypeNode), visitFunctionBody(node.body, visitor, context, nodeVisitor));
            case 171 /* SyntaxKind.Constructor */:
                ts.Debug.type(node);
                return factory.updateConstructorDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), visitParameterList(node.parameters, visitor, context, nodesVisitor), visitFunctionBody(node.body, visitor, context, nodeVisitor));
            case 172 /* SyntaxKind.GetAccessor */:
                ts.Debug.type(node);
                return factory.updateGetAccessorDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.name, visitor, ts.isPropertyName), visitParameterList(node.parameters, visitor, context, nodesVisitor), nodeVisitor(node.type, visitor, ts.isTypeNode), visitFunctionBody(node.body, visitor, context, nodeVisitor));
            case 173 /* SyntaxKind.SetAccessor */:
                ts.Debug.type(node);
                return factory.updateSetAccessorDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.name, visitor, ts.isPropertyName), visitParameterList(node.parameters, visitor, context, nodesVisitor), visitFunctionBody(node.body, visitor, context, nodeVisitor));
            case 170 /* SyntaxKind.ClassStaticBlockDeclaration */:
                ts.Debug.type(node);
                context.startLexicalEnvironment();
                context.suspendLexicalEnvironment();
                return factory.updateClassStaticBlockDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), visitFunctionBody(node.body, visitor, context, nodeVisitor));
            case 174 /* SyntaxKind.CallSignature */:
                ts.Debug.type(node);
                return factory.updateCallSignature(node, nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), nodesVisitor(node.parameters, visitor, ts.isParameterDeclaration), nodeVisitor(node.type, visitor, ts.isTypeNode));
            case 175 /* SyntaxKind.ConstructSignature */:
                ts.Debug.type(node);
                return factory.updateConstructSignature(node, nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), nodesVisitor(node.parameters, visitor, ts.isParameterDeclaration), nodeVisitor(node.type, visitor, ts.isTypeNode));
            case 176 /* SyntaxKind.IndexSignature */:
                ts.Debug.type(node);
                return factory.updateIndexSignature(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), nodesVisitor(node.parameters, visitor, ts.isParameterDeclaration), nodeVisitor(node.type, visitor, ts.isTypeNode));
            // Types
            case 177 /* SyntaxKind.TypePredicate */:
                ts.Debug.type(node);
                return factory.updateTypePredicateNode(node, nodeVisitor(node.assertsModifier, visitor, ts.isAssertsKeyword), nodeVisitor(node.parameterName, visitor, ts.isIdentifierOrThisTypeNode), nodeVisitor(node.type, visitor, ts.isTypeNode));
            case 178 /* SyntaxKind.TypeReference */:
                ts.Debug.type(node);
                return factory.updateTypeReferenceNode(node, nodeVisitor(node.typeName, visitor, ts.isEntityName), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode));
            case 179 /* SyntaxKind.FunctionType */:
                ts.Debug.type(node);
                return factory.updateFunctionTypeNode(node, nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), nodesVisitor(node.parameters, visitor, ts.isParameterDeclaration), nodeVisitor(node.type, visitor, ts.isTypeNode));
            case 180 /* SyntaxKind.ConstructorType */:
                ts.Debug.type(node);
                return factory.updateConstructorTypeNode(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), nodesVisitor(node.parameters, visitor, ts.isParameterDeclaration), nodeVisitor(node.type, visitor, ts.isTypeNode));
            case 181 /* SyntaxKind.TypeQuery */:
                ts.Debug.type(node);
                return factory.updateTypeQueryNode(node, nodeVisitor(node.exprName, visitor, ts.isEntityName), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode));
            case 182 /* SyntaxKind.TypeLiteral */:
                ts.Debug.type(node);
                return factory.updateTypeLiteralNode(node, nodesVisitor(node.members, visitor, ts.isTypeElement));
            case 183 /* SyntaxKind.ArrayType */:
                ts.Debug.type(node);
                return factory.updateArrayTypeNode(node, nodeVisitor(node.elementType, visitor, ts.isTypeNode));
            case 184 /* SyntaxKind.TupleType */:
                ts.Debug.type(node);
                return factory.updateTupleTypeNode(node, nodesVisitor(node.elements, visitor, ts.isTypeNode));
            case 185 /* SyntaxKind.OptionalType */:
                ts.Debug.type(node);
                return factory.updateOptionalTypeNode(node, nodeVisitor(node.type, visitor, ts.isTypeNode));
            case 186 /* SyntaxKind.RestType */:
                ts.Debug.type(node);
                return factory.updateRestTypeNode(node, nodeVisitor(node.type, visitor, ts.isTypeNode));
            case 187 /* SyntaxKind.UnionType */:
                ts.Debug.type(node);
                return factory.updateUnionTypeNode(node, nodesVisitor(node.types, visitor, ts.isTypeNode));
            case 188 /* SyntaxKind.IntersectionType */:
                ts.Debug.type(node);
                return factory.updateIntersectionTypeNode(node, nodesVisitor(node.types, visitor, ts.isTypeNode));
            case 189 /* SyntaxKind.ConditionalType */:
                ts.Debug.type(node);
                return factory.updateConditionalTypeNode(node, nodeVisitor(node.checkType, visitor, ts.isTypeNode), nodeVisitor(node.extendsType, visitor, ts.isTypeNode), nodeVisitor(node.trueType, visitor, ts.isTypeNode), nodeVisitor(node.falseType, visitor, ts.isTypeNode));
            case 190 /* SyntaxKind.InferType */:
                ts.Debug.type(node);
                return factory.updateInferTypeNode(node, nodeVisitor(node.typeParameter, visitor, ts.isTypeParameterDeclaration));
            case 200 /* SyntaxKind.ImportType */:
                ts.Debug.type(node);
                return factory.updateImportTypeNode(node, nodeVisitor(node.argument, visitor, ts.isTypeNode), nodeVisitor(node.assertions, visitor, ts.isNode), nodeVisitor(node.qualifier, visitor, ts.isEntityName), visitNodes(node.typeArguments, visitor, ts.isTypeNode), node.isTypeOf);
            case 295 /* SyntaxKind.ImportTypeAssertionContainer */:
                ts.Debug.type(node);
                return factory.updateImportTypeAssertionContainer(node, nodeVisitor(node.assertClause, visitor, ts.isNode), node.multiLine);
            case 197 /* SyntaxKind.NamedTupleMember */:
                ts.Debug.type(node);
                return factory.updateNamedTupleMember(node, visitNode(node.dotDotDotToken, visitor, ts.isDotDotDotToken), visitNode(node.name, visitor, ts.isIdentifier), visitNode(node.questionToken, visitor, ts.isQuestionToken), visitNode(node.type, visitor, ts.isTypeNode));
            case 191 /* SyntaxKind.ParenthesizedType */:
                ts.Debug.type(node);
                return factory.updateParenthesizedType(node, nodeVisitor(node.type, visitor, ts.isTypeNode));
            case 193 /* SyntaxKind.TypeOperator */:
                ts.Debug.type(node);
                return factory.updateTypeOperatorNode(node, nodeVisitor(node.type, visitor, ts.isTypeNode));
            case 194 /* SyntaxKind.IndexedAccessType */:
                ts.Debug.type(node);
                return factory.updateIndexedAccessTypeNode(node, nodeVisitor(node.objectType, visitor, ts.isTypeNode), nodeVisitor(node.indexType, visitor, ts.isTypeNode));
            case 195 /* SyntaxKind.MappedType */:
                ts.Debug.type(node);
                return factory.updateMappedTypeNode(node, nodeVisitor(node.readonlyToken, tokenVisitor, ts.isReadonlyKeywordOrPlusOrMinusToken), nodeVisitor(node.typeParameter, visitor, ts.isTypeParameterDeclaration), nodeVisitor(node.nameType, visitor, ts.isTypeNode), nodeVisitor(node.questionToken, tokenVisitor, ts.isQuestionOrPlusOrMinusToken), nodeVisitor(node.type, visitor, ts.isTypeNode), nodesVisitor(node.members, visitor, ts.isTypeElement));
            case 196 /* SyntaxKind.LiteralType */:
                ts.Debug.type(node);
                return factory.updateLiteralTypeNode(node, nodeVisitor(node.literal, visitor, ts.isExpression));
            case 198 /* SyntaxKind.TemplateLiteralType */:
                ts.Debug.type(node);
                return factory.updateTemplateLiteralType(node, nodeVisitor(node.head, visitor, ts.isTemplateHead), nodesVisitor(node.templateSpans, visitor, ts.isTemplateLiteralTypeSpan));
            case 199 /* SyntaxKind.TemplateLiteralTypeSpan */:
                ts.Debug.type(node);
                return factory.updateTemplateLiteralTypeSpan(node, nodeVisitor(node.type, visitor, ts.isTypeNode), nodeVisitor(node.literal, visitor, ts.isTemplateMiddleOrTemplateTail));
            // Binding patterns
            case 201 /* SyntaxKind.ObjectBindingPattern */:
                ts.Debug.type(node);
                return factory.updateObjectBindingPattern(node, nodesVisitor(node.elements, visitor, ts.isBindingElement));
            case 202 /* SyntaxKind.ArrayBindingPattern */:
                ts.Debug.type(node);
                return factory.updateArrayBindingPattern(node, nodesVisitor(node.elements, visitor, ts.isArrayBindingElement));
            case 203 /* SyntaxKind.BindingElement */:
                ts.Debug.type(node);
                return factory.updateBindingElement(node, nodeVisitor(node.dotDotDotToken, tokenVisitor, ts.isDotDotDotToken), nodeVisitor(node.propertyName, visitor, ts.isPropertyName), nodeVisitor(node.name, visitor, ts.isBindingName), nodeVisitor(node.initializer, visitor, ts.isExpression));
            // Expression
            case 204 /* SyntaxKind.ArrayLiteralExpression */:
                ts.Debug.type(node);
                return factory.updateArrayLiteralExpression(node, nodesVisitor(node.elements, visitor, ts.isExpression));
            case 205 /* SyntaxKind.ObjectLiteralExpression */:
                ts.Debug.type(node);
                return factory.updateObjectLiteralExpression(node, nodesVisitor(node.properties, visitor, ts.isObjectLiteralElementLike));
            case 206 /* SyntaxKind.PropertyAccessExpression */:
                if (node.flags & 32 /* NodeFlags.OptionalChain */) {
                    ts.Debug.type(node);
                    return factory.updatePropertyAccessChain(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.questionDotToken, tokenVisitor, ts.isQuestionDotToken), nodeVisitor(node.name, visitor, ts.isMemberName));
                }
                ts.Debug.type(node);
                return factory.updatePropertyAccessExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.name, visitor, ts.isMemberName));
            case 207 /* SyntaxKind.ElementAccessExpression */:
                if (node.flags & 32 /* NodeFlags.OptionalChain */) {
                    ts.Debug.type(node);
                    return factory.updateElementAccessChain(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.questionDotToken, tokenVisitor, ts.isQuestionDotToken), nodeVisitor(node.argumentExpression, visitor, ts.isExpression));
                }
                ts.Debug.type(node);
                return factory.updateElementAccessExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.argumentExpression, visitor, ts.isExpression));
            case 208 /* SyntaxKind.CallExpression */:
                if (node.flags & 32 /* NodeFlags.OptionalChain */) {
                    ts.Debug.type(node);
                    return factory.updateCallChain(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.questionDotToken, tokenVisitor, ts.isQuestionDotToken), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode), nodesVisitor(node.arguments, visitor, ts.isExpression));
                }
                ts.Debug.type(node);
                return factory.updateCallExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode), nodesVisitor(node.arguments, visitor, ts.isExpression));
            case 209 /* SyntaxKind.NewExpression */:
                ts.Debug.type(node);
                return factory.updateNewExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode), nodesVisitor(node.arguments, visitor, ts.isExpression));
            case 210 /* SyntaxKind.TaggedTemplateExpression */:
                ts.Debug.type(node);
                return factory.updateTaggedTemplateExpression(node, nodeVisitor(node.tag, visitor, ts.isExpression), visitNodes(node.typeArguments, visitor, ts.isTypeNode), nodeVisitor(node.template, visitor, ts.isTemplateLiteral));
            case 211 /* SyntaxKind.TypeAssertionExpression */:
                ts.Debug.type(node);
                return factory.updateTypeAssertion(node, nodeVisitor(node.type, visitor, ts.isTypeNode), nodeVisitor(node.expression, visitor, ts.isExpression));
            case 212 /* SyntaxKind.ParenthesizedExpression */:
                ts.Debug.type(node);
                return factory.updateParenthesizedExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            case 213 /* SyntaxKind.FunctionExpression */:
                ts.Debug.type(node);
                return factory.updateFunctionExpression(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.asteriskToken, tokenVisitor, ts.isAsteriskToken), nodeVisitor(node.name, visitor, ts.isIdentifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), visitParameterList(node.parameters, visitor, context, nodesVisitor), nodeVisitor(node.type, visitor, ts.isTypeNode), visitFunctionBody(node.body, visitor, context, nodeVisitor));
            case 214 /* SyntaxKind.ArrowFunction */:
                ts.Debug.type(node);
                return factory.updateArrowFunction(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), visitParameterList(node.parameters, visitor, context, nodesVisitor), nodeVisitor(node.type, visitor, ts.isTypeNode), nodeVisitor(node.equalsGreaterThanToken, tokenVisitor, ts.isEqualsGreaterThanToken), visitFunctionBody(node.body, visitor, context, nodeVisitor));
            case 215 /* SyntaxKind.DeleteExpression */:
                ts.Debug.type(node);
                return factory.updateDeleteExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            case 216 /* SyntaxKind.TypeOfExpression */:
                ts.Debug.type(node);
                return factory.updateTypeOfExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            case 217 /* SyntaxKind.VoidExpression */:
                ts.Debug.type(node);
                return factory.updateVoidExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            case 218 /* SyntaxKind.AwaitExpression */:
                ts.Debug.type(node);
                return factory.updateAwaitExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            case 219 /* SyntaxKind.PrefixUnaryExpression */:
                ts.Debug.type(node);
                return factory.updatePrefixUnaryExpression(node, nodeVisitor(node.operand, visitor, ts.isExpression));
            case 220 /* SyntaxKind.PostfixUnaryExpression */:
                ts.Debug.type(node);
                return factory.updatePostfixUnaryExpression(node, nodeVisitor(node.operand, visitor, ts.isExpression));
            case 221 /* SyntaxKind.BinaryExpression */:
                ts.Debug.type(node);
                return factory.updateBinaryExpression(node, nodeVisitor(node.left, visitor, ts.isExpression), nodeVisitor(node.operatorToken, tokenVisitor, ts.isBinaryOperatorToken), nodeVisitor(node.right, visitor, ts.isExpression));
            case 222 /* SyntaxKind.ConditionalExpression */:
                ts.Debug.type(node);
                return factory.updateConditionalExpression(node, nodeVisitor(node.condition, visitor, ts.isExpression), nodeVisitor(node.questionToken, tokenVisitor, ts.isQuestionToken), nodeVisitor(node.whenTrue, visitor, ts.isExpression), nodeVisitor(node.colonToken, tokenVisitor, ts.isColonToken), nodeVisitor(node.whenFalse, visitor, ts.isExpression));
            case 223 /* SyntaxKind.TemplateExpression */:
                ts.Debug.type(node);
                return factory.updateTemplateExpression(node, nodeVisitor(node.head, visitor, ts.isTemplateHead), nodesVisitor(node.templateSpans, visitor, ts.isTemplateSpan));
            case 224 /* SyntaxKind.YieldExpression */:
                ts.Debug.type(node);
                return factory.updateYieldExpression(node, nodeVisitor(node.asteriskToken, tokenVisitor, ts.isAsteriskToken), nodeVisitor(node.expression, visitor, ts.isExpression));
            case 225 /* SyntaxKind.SpreadElement */:
                ts.Debug.type(node);
                return factory.updateSpreadElement(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            case 226 /* SyntaxKind.ClassExpression */:
                ts.Debug.type(node);
                return factory.updateClassExpression(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.name, visitor, ts.isIdentifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), nodesVisitor(node.heritageClauses, visitor, ts.isHeritageClause), nodesVisitor(node.members, visitor, ts.isClassElement));
            case 228 /* SyntaxKind.ExpressionWithTypeArguments */:
                ts.Debug.type(node);
                return factory.updateExpressionWithTypeArguments(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode));
            case 229 /* SyntaxKind.AsExpression */:
                ts.Debug.type(node);
                return factory.updateAsExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.type, visitor, ts.isTypeNode));
            case 230 /* SyntaxKind.NonNullExpression */:
                if (node.flags & 32 /* NodeFlags.OptionalChain */) {
                    ts.Debug.type(node);
                    return factory.updateNonNullChain(node, nodeVisitor(node.expression, visitor, ts.isExpression));
                }
                ts.Debug.type(node);
                return factory.updateNonNullExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            case 231 /* SyntaxKind.MetaProperty */:
                ts.Debug.type(node);
                return factory.updateMetaProperty(node, nodeVisitor(node.name, visitor, ts.isIdentifier));
            // Misc
            case 233 /* SyntaxKind.TemplateSpan */:
                ts.Debug.type(node);
                return factory.updateTemplateSpan(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.literal, visitor, ts.isTemplateMiddleOrTemplateTail));
            // Element
            case 235 /* SyntaxKind.Block */:
                ts.Debug.type(node);
                return factory.updateBlock(node, nodesVisitor(node.statements, visitor, ts.isStatement));
            case 237 /* SyntaxKind.VariableStatement */:
                ts.Debug.type(node);
                return factory.updateVariableStatement(node, nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.declarationList, visitor, ts.isVariableDeclarationList));
            case 238 /* SyntaxKind.ExpressionStatement */:
                ts.Debug.type(node);
                return factory.updateExpressionStatement(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            case 239 /* SyntaxKind.IfStatement */:
                ts.Debug.type(node);
                return factory.updateIfStatement(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.thenStatement, visitor, ts.isStatement, factory.liftToBlock), nodeVisitor(node.elseStatement, visitor, ts.isStatement, factory.liftToBlock));
            case 240 /* SyntaxKind.DoStatement */:
                ts.Debug.type(node);
                return factory.updateDoStatement(node, visitIterationBody(node.statement, visitor, context), nodeVisitor(node.expression, visitor, ts.isExpression));
            case 241 /* SyntaxKind.WhileStatement */:
                ts.Debug.type(node);
                return factory.updateWhileStatement(node, nodeVisitor(node.expression, visitor, ts.isExpression), visitIterationBody(node.statement, visitor, context));
            case 242 /* SyntaxKind.ForStatement */:
                ts.Debug.type(node);
                return factory.updateForStatement(node, nodeVisitor(node.initializer, visitor, ts.isForInitializer), nodeVisitor(node.condition, visitor, ts.isExpression), nodeVisitor(node.incrementor, visitor, ts.isExpression), visitIterationBody(node.statement, visitor, context));
            case 243 /* SyntaxKind.ForInStatement */:
                ts.Debug.type(node);
                return factory.updateForInStatement(node, nodeVisitor(node.initializer, visitor, ts.isForInitializer), nodeVisitor(node.expression, visitor, ts.isExpression), visitIterationBody(node.statement, visitor, context));
            case 244 /* SyntaxKind.ForOfStatement */:
                ts.Debug.type(node);
                return factory.updateForOfStatement(node, nodeVisitor(node.awaitModifier, tokenVisitor, ts.isAwaitKeyword), nodeVisitor(node.initializer, visitor, ts.isForInitializer), nodeVisitor(node.expression, visitor, ts.isExpression), visitIterationBody(node.statement, visitor, context));
            case 245 /* SyntaxKind.ContinueStatement */:
                ts.Debug.type(node);
                return factory.updateContinueStatement(node, nodeVisitor(node.label, visitor, ts.isIdentifier));
            case 246 /* SyntaxKind.BreakStatement */:
                ts.Debug.type(node);
                return factory.updateBreakStatement(node, nodeVisitor(node.label, visitor, ts.isIdentifier));
            case 247 /* SyntaxKind.ReturnStatement */:
                ts.Debug.type(node);
                return factory.updateReturnStatement(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            case 248 /* SyntaxKind.WithStatement */:
                ts.Debug.type(node);
                return factory.updateWithStatement(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.statement, visitor, ts.isStatement, factory.liftToBlock));
            case 249 /* SyntaxKind.SwitchStatement */:
                ts.Debug.type(node);
                return factory.updateSwitchStatement(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodeVisitor(node.caseBlock, visitor, ts.isCaseBlock));
            case 250 /* SyntaxKind.LabeledStatement */:
                ts.Debug.type(node);
                return factory.updateLabeledStatement(node, nodeVisitor(node.label, visitor, ts.isIdentifier), nodeVisitor(node.statement, visitor, ts.isStatement, factory.liftToBlock));
            case 251 /* SyntaxKind.ThrowStatement */:
                ts.Debug.type(node);
                return factory.updateThrowStatement(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            case 252 /* SyntaxKind.TryStatement */:
                ts.Debug.type(node);
                return factory.updateTryStatement(node, nodeVisitor(node.tryBlock, visitor, ts.isBlock), nodeVisitor(node.catchClause, visitor, ts.isCatchClause), nodeVisitor(node.finallyBlock, visitor, ts.isBlock));
            case 254 /* SyntaxKind.VariableDeclaration */:
                ts.Debug.type(node);
                return factory.updateVariableDeclaration(node, nodeVisitor(node.name, visitor, ts.isBindingName), nodeVisitor(node.exclamationToken, tokenVisitor, ts.isExclamationToken), nodeVisitor(node.type, visitor, ts.isTypeNode), nodeVisitor(node.initializer, visitor, ts.isExpression));
            case 255 /* SyntaxKind.VariableDeclarationList */:
                ts.Debug.type(node);
                return factory.updateVariableDeclarationList(node, nodesVisitor(node.declarations, visitor, ts.isVariableDeclaration));
            case 256 /* SyntaxKind.FunctionDeclaration */:
                ts.Debug.type(node);
                return factory.updateFunctionDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.asteriskToken, tokenVisitor, ts.isAsteriskToken), nodeVisitor(node.name, visitor, ts.isIdentifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), visitParameterList(node.parameters, visitor, context, nodesVisitor), nodeVisitor(node.type, visitor, ts.isTypeNode), visitFunctionBody(node.body, visitor, context, nodeVisitor));
            case 257 /* SyntaxKind.ClassDeclaration */:
                ts.Debug.type(node);
                return factory.updateClassDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.name, visitor, ts.isIdentifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), nodesVisitor(node.heritageClauses, visitor, ts.isHeritageClause), nodesVisitor(node.members, visitor, ts.isClassElement));
            case 258 /* SyntaxKind.InterfaceDeclaration */:
                ts.Debug.type(node);
                return factory.updateInterfaceDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.name, visitor, ts.isIdentifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), nodesVisitor(node.heritageClauses, visitor, ts.isHeritageClause), nodesVisitor(node.members, visitor, ts.isTypeElement));
            case 259 /* SyntaxKind.TypeAliasDeclaration */:
                ts.Debug.type(node);
                return factory.updateTypeAliasDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.name, visitor, ts.isIdentifier), nodesVisitor(node.typeParameters, visitor, ts.isTypeParameterDeclaration), nodeVisitor(node.type, visitor, ts.isTypeNode));
            case 260 /* SyntaxKind.EnumDeclaration */:
                ts.Debug.type(node);
                return factory.updateEnumDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.name, visitor, ts.isIdentifier), nodesVisitor(node.members, visitor, ts.isEnumMember));
            case 261 /* SyntaxKind.ModuleDeclaration */:
                ts.Debug.type(node);
                return factory.updateModuleDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.name, visitor, ts.isModuleName), nodeVisitor(node.body, visitor, ts.isModuleBody));
            case 262 /* SyntaxKind.ModuleBlock */:
                ts.Debug.type(node);
                return factory.updateModuleBlock(node, nodesVisitor(node.statements, visitor, ts.isStatement));
            case 263 /* SyntaxKind.CaseBlock */:
                ts.Debug.type(node);
                return factory.updateCaseBlock(node, nodesVisitor(node.clauses, visitor, ts.isCaseOrDefaultClause));
            case 264 /* SyntaxKind.NamespaceExportDeclaration */:
                ts.Debug.type(node);
                return factory.updateNamespaceExportDeclaration(node, nodeVisitor(node.name, visitor, ts.isIdentifier));
            case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                ts.Debug.type(node);
                return factory.updateImportEqualsDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), node.isTypeOnly, nodeVisitor(node.name, visitor, ts.isIdentifier), nodeVisitor(node.moduleReference, visitor, ts.isModuleReference));
            case 266 /* SyntaxKind.ImportDeclaration */:
                ts.Debug.type(node);
                return factory.updateImportDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.importClause, visitor, ts.isImportClause), nodeVisitor(node.moduleSpecifier, visitor, ts.isExpression), nodeVisitor(node.assertClause, visitor, ts.isAssertClause));
            case 293 /* SyntaxKind.AssertClause */:
                ts.Debug.type(node);
                return factory.updateAssertClause(node, nodesVisitor(node.elements, visitor, ts.isAssertEntry), node.multiLine);
            case 294 /* SyntaxKind.AssertEntry */:
                ts.Debug.type(node);
                return factory.updateAssertEntry(node, nodeVisitor(node.name, visitor, ts.isAssertionKey), nodeVisitor(node.value, visitor, ts.isExpressionNode));
            case 267 /* SyntaxKind.ImportClause */:
                ts.Debug.type(node);
                return factory.updateImportClause(node, node.isTypeOnly, nodeVisitor(node.name, visitor, ts.isIdentifier), nodeVisitor(node.namedBindings, visitor, ts.isNamedImportBindings));
            case 268 /* SyntaxKind.NamespaceImport */:
                ts.Debug.type(node);
                return factory.updateNamespaceImport(node, nodeVisitor(node.name, visitor, ts.isIdentifier));
            case 274 /* SyntaxKind.NamespaceExport */:
                ts.Debug.type(node);
                return factory.updateNamespaceExport(node, nodeVisitor(node.name, visitor, ts.isIdentifier));
            case 269 /* SyntaxKind.NamedImports */:
                ts.Debug.type(node);
                return factory.updateNamedImports(node, nodesVisitor(node.elements, visitor, ts.isImportSpecifier));
            case 270 /* SyntaxKind.ImportSpecifier */:
                ts.Debug.type(node);
                return factory.updateImportSpecifier(node, node.isTypeOnly, nodeVisitor(node.propertyName, visitor, ts.isIdentifier), nodeVisitor(node.name, visitor, ts.isIdentifier));
            case 271 /* SyntaxKind.ExportAssignment */:
                ts.Debug.type(node);
                return factory.updateExportAssignment(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), nodeVisitor(node.expression, visitor, ts.isExpression));
            case 272 /* SyntaxKind.ExportDeclaration */:
                ts.Debug.type(node);
                return factory.updateExportDeclaration(node, nodesVisitor(node.decorators, visitor, ts.isDecorator), nodesVisitor(node.modifiers, visitor, ts.isModifier), node.isTypeOnly, nodeVisitor(node.exportClause, visitor, ts.isNamedExportBindings), nodeVisitor(node.moduleSpecifier, visitor, ts.isExpression), nodeVisitor(node.assertClause, visitor, ts.isAssertClause));
            case 273 /* SyntaxKind.NamedExports */:
                ts.Debug.type(node);
                return factory.updateNamedExports(node, nodesVisitor(node.elements, visitor, ts.isExportSpecifier));
            case 275 /* SyntaxKind.ExportSpecifier */:
                ts.Debug.type(node);
                return factory.updateExportSpecifier(node, node.isTypeOnly, nodeVisitor(node.propertyName, visitor, ts.isIdentifier), nodeVisitor(node.name, visitor, ts.isIdentifier));
            // Module references
            case 277 /* SyntaxKind.ExternalModuleReference */:
                ts.Debug.type(node);
                return factory.updateExternalModuleReference(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            // JSX
            case 278 /* SyntaxKind.JsxElement */:
                ts.Debug.type(node);
                return factory.updateJsxElement(node, nodeVisitor(node.openingElement, visitor, ts.isJsxOpeningElement), nodesVisitor(node.children, visitor, ts.isJsxChild), nodeVisitor(node.closingElement, visitor, ts.isJsxClosingElement));
            case 279 /* SyntaxKind.JsxSelfClosingElement */:
                ts.Debug.type(node);
                return factory.updateJsxSelfClosingElement(node, nodeVisitor(node.tagName, visitor, ts.isJsxTagNameExpression), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode), nodeVisitor(node.attributes, visitor, ts.isJsxAttributes));
            case 280 /* SyntaxKind.JsxOpeningElement */:
                ts.Debug.type(node);
                return factory.updateJsxOpeningElement(node, nodeVisitor(node.tagName, visitor, ts.isJsxTagNameExpression), nodesVisitor(node.typeArguments, visitor, ts.isTypeNode), nodeVisitor(node.attributes, visitor, ts.isJsxAttributes));
            case 281 /* SyntaxKind.JsxClosingElement */:
                ts.Debug.type(node);
                return factory.updateJsxClosingElement(node, nodeVisitor(node.tagName, visitor, ts.isJsxTagNameExpression));
            case 282 /* SyntaxKind.JsxFragment */:
                ts.Debug.type(node);
                return factory.updateJsxFragment(node, nodeVisitor(node.openingFragment, visitor, ts.isJsxOpeningFragment), nodesVisitor(node.children, visitor, ts.isJsxChild), nodeVisitor(node.closingFragment, visitor, ts.isJsxClosingFragment));
            case 285 /* SyntaxKind.JsxAttribute */:
                ts.Debug.type(node);
                return factory.updateJsxAttribute(node, nodeVisitor(node.name, visitor, ts.isIdentifier), nodeVisitor(node.initializer, visitor, ts.isStringLiteralOrJsxExpression));
            case 286 /* SyntaxKind.JsxAttributes */:
                ts.Debug.type(node);
                return factory.updateJsxAttributes(node, nodesVisitor(node.properties, visitor, ts.isJsxAttributeLike));
            case 287 /* SyntaxKind.JsxSpreadAttribute */:
                ts.Debug.type(node);
                return factory.updateJsxSpreadAttribute(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            case 288 /* SyntaxKind.JsxExpression */:
                ts.Debug.type(node);
                return factory.updateJsxExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            // Clauses
            case 289 /* SyntaxKind.CaseClause */:
                ts.Debug.type(node);
                return factory.updateCaseClause(node, nodeVisitor(node.expression, visitor, ts.isExpression), nodesVisitor(node.statements, visitor, ts.isStatement));
            case 290 /* SyntaxKind.DefaultClause */:
                ts.Debug.type(node);
                return factory.updateDefaultClause(node, nodesVisitor(node.statements, visitor, ts.isStatement));
            case 291 /* SyntaxKind.HeritageClause */:
                ts.Debug.type(node);
                return factory.updateHeritageClause(node, nodesVisitor(node.types, visitor, ts.isExpressionWithTypeArguments));
            case 292 /* SyntaxKind.CatchClause */:
                ts.Debug.type(node);
                return factory.updateCatchClause(node, nodeVisitor(node.variableDeclaration, visitor, ts.isVariableDeclaration), nodeVisitor(node.block, visitor, ts.isBlock));
            // Property assignments
            case 296 /* SyntaxKind.PropertyAssignment */:
                ts.Debug.type(node);
                return factory.updatePropertyAssignment(node, nodeVisitor(node.name, visitor, ts.isPropertyName), nodeVisitor(node.initializer, visitor, ts.isExpression));
            case 297 /* SyntaxKind.ShorthandPropertyAssignment */:
                ts.Debug.type(node);
                return factory.updateShorthandPropertyAssignment(node, nodeVisitor(node.name, visitor, ts.isIdentifier), nodeVisitor(node.objectAssignmentInitializer, visitor, ts.isExpression));
            case 298 /* SyntaxKind.SpreadAssignment */:
                ts.Debug.type(node);
                return factory.updateSpreadAssignment(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            // Enum
            case 299 /* SyntaxKind.EnumMember */:
                ts.Debug.type(node);
                return factory.updateEnumMember(node, nodeVisitor(node.name, visitor, ts.isPropertyName), nodeVisitor(node.initializer, visitor, ts.isExpression));
            // Top-level nodes
            case 305 /* SyntaxKind.SourceFile */:
                ts.Debug.type(node);
                return factory.updateSourceFile(node, visitLexicalEnvironment(node.statements, visitor, context));
            // Transformation nodes
            case 350 /* SyntaxKind.PartiallyEmittedExpression */:
                ts.Debug.type(node);
                return factory.updatePartiallyEmittedExpression(node, nodeVisitor(node.expression, visitor, ts.isExpression));
            case 351 /* SyntaxKind.CommaListExpression */:
                ts.Debug.type(node);
                return factory.updateCommaListExpression(node, nodesVisitor(node.elements, visitor, ts.isExpression));
            default:
                // No need to visit nodes with no children.
                return node;
        }
    }
    ts.visitEachChild = visitEachChild;
    /**
     * Extracts the single node from a NodeArray.
     *
     * @param nodes The NodeArray.
     */
    function extractSingleNode(nodes) {
        ts.Debug.assert(nodes.length <= 1, "Too many nodes written to output.");
        return ts.singleOrUndefined(nodes);
    }
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    function createSourceMapGenerator(host, file, sourceRoot, sourcesDirectoryPath, generatorOptions) {
        var _a = generatorOptions.extendedDiagnostics
            ? ts.performance.createTimer("Source Map", "beforeSourcemap", "afterSourcemap")
            : ts.performance.nullTimer, enter = _a.enter, exit = _a.exit;
        // Current source map file and its index in the sources list
        var rawSources = [];
        var sources = [];
        var sourceToSourceIndexMap = new ts.Map();
        var sourcesContent;
        var names = [];
        var nameToNameIndexMap;
        var mappingCharCodes = [];
        var mappings = "";
        // Last recorded and encoded mappings
        var lastGeneratedLine = 0;
        var lastGeneratedCharacter = 0;
        var lastSourceIndex = 0;
        var lastSourceLine = 0;
        var lastSourceCharacter = 0;
        var lastNameIndex = 0;
        var hasLast = false;
        var pendingGeneratedLine = 0;
        var pendingGeneratedCharacter = 0;
        var pendingSourceIndex = 0;
        var pendingSourceLine = 0;
        var pendingSourceCharacter = 0;
        var pendingNameIndex = 0;
        var hasPending = false;
        var hasPendingSource = false;
        var hasPendingName = false;
        return {
            getSources: function () { return rawSources; },
            addSource: addSource,
            setSourceContent: setSourceContent,
            addName: addName,
            addMapping: addMapping,
            appendSourceMap: appendSourceMap,
            toJSON: toJSON,
            toString: function () { return JSON.stringify(toJSON()); }
        };
        function addSource(fileName) {
            enter();
            var source = ts.getRelativePathToDirectoryOrUrl(sourcesDirectoryPath, fileName, host.getCurrentDirectory(), host.getCanonicalFileName, 
            /*isAbsolutePathAnUrl*/ true);
            var sourceIndex = sourceToSourceIndexMap.get(source);
            if (sourceIndex === undefined) {
                sourceIndex = sources.length;
                sources.push(source);
                rawSources.push(fileName);
                sourceToSourceIndexMap.set(source, sourceIndex);
            }
            exit();
            return sourceIndex;
        }
        /* eslint-disable boolean-trivia, no-null/no-null */
        function setSourceContent(sourceIndex, content) {
            enter();
            if (content !== null) {
                if (!sourcesContent)
                    sourcesContent = [];
                while (sourcesContent.length < sourceIndex) {
                    sourcesContent.push(null);
                }
                sourcesContent[sourceIndex] = content;
            }
            exit();
        }
        /* eslint-enable boolean-trivia, no-null/no-null */
        function addName(name) {
            enter();
            if (!nameToNameIndexMap)
                nameToNameIndexMap = new ts.Map();
            var nameIndex = nameToNameIndexMap.get(name);
            if (nameIndex === undefined) {
                nameIndex = names.length;
                names.push(name);
                nameToNameIndexMap.set(name, nameIndex);
            }
            exit();
            return nameIndex;
        }
        function isNewGeneratedPosition(generatedLine, generatedCharacter) {
            return !hasPending
                || pendingGeneratedLine !== generatedLine
                || pendingGeneratedCharacter !== generatedCharacter;
        }
        function isBacktrackingSourcePosition(sourceIndex, sourceLine, sourceCharacter) {
            return sourceIndex !== undefined
                && sourceLine !== undefined
                && sourceCharacter !== undefined
                && pendingSourceIndex === sourceIndex
                && (pendingSourceLine > sourceLine
                    || pendingSourceLine === sourceLine && pendingSourceCharacter > sourceCharacter);
        }
        function addMapping(generatedLine, generatedCharacter, sourceIndex, sourceLine, sourceCharacter, nameIndex) {
            ts.Debug.assert(generatedLine >= pendingGeneratedLine, "generatedLine cannot backtrack");
            ts.Debug.assert(generatedCharacter >= 0, "generatedCharacter cannot be negative");
            ts.Debug.assert(sourceIndex === undefined || sourceIndex >= 0, "sourceIndex cannot be negative");
            ts.Debug.assert(sourceLine === undefined || sourceLine >= 0, "sourceLine cannot be negative");
            ts.Debug.assert(sourceCharacter === undefined || sourceCharacter >= 0, "sourceCharacter cannot be negative");
            enter();
            // If this location wasn't recorded or the location in source is going backwards, record the mapping
            if (isNewGeneratedPosition(generatedLine, generatedCharacter) ||
                isBacktrackingSourcePosition(sourceIndex, sourceLine, sourceCharacter)) {
                commitPendingMapping();
                pendingGeneratedLine = generatedLine;
                pendingGeneratedCharacter = generatedCharacter;
                hasPendingSource = false;
                hasPendingName = false;
                hasPending = true;
            }
            if (sourceIndex !== undefined && sourceLine !== undefined && sourceCharacter !== undefined) {
                pendingSourceIndex = sourceIndex;
                pendingSourceLine = sourceLine;
                pendingSourceCharacter = sourceCharacter;
                hasPendingSource = true;
                if (nameIndex !== undefined) {
                    pendingNameIndex = nameIndex;
                    hasPendingName = true;
                }
            }
            exit();
        }
        function appendSourceMap(generatedLine, generatedCharacter, map, sourceMapPath, start, end) {
            ts.Debug.assert(generatedLine >= pendingGeneratedLine, "generatedLine cannot backtrack");
            ts.Debug.assert(generatedCharacter >= 0, "generatedCharacter cannot be negative");
            enter();
            // First, decode the old component sourcemap
            var sourceIndexToNewSourceIndexMap = [];
            var nameIndexToNewNameIndexMap;
            var mappingIterator = decodeMappings(map.mappings);
            for (var iterResult = mappingIterator.next(); !iterResult.done; iterResult = mappingIterator.next()) {
                var raw = iterResult.value;
                if (end && (raw.generatedLine > end.line ||
                    (raw.generatedLine === end.line && raw.generatedCharacter > end.character))) {
                    break;
                }
                if (start && (raw.generatedLine < start.line ||
                    (start.line === raw.generatedLine && raw.generatedCharacter < start.character))) {
                    continue;
                }
                // Then reencode all the updated mappings into the overall map
                var newSourceIndex = void 0;
                var newSourceLine = void 0;
                var newSourceCharacter = void 0;
                var newNameIndex = void 0;
                if (raw.sourceIndex !== undefined) {
                    newSourceIndex = sourceIndexToNewSourceIndexMap[raw.sourceIndex];
                    if (newSourceIndex === undefined) {
                        // Apply offsets to each position and fixup source entries
                        var rawPath = map.sources[raw.sourceIndex];
                        var relativePath = map.sourceRoot ? ts.combinePaths(map.sourceRoot, rawPath) : rawPath;
                        var combinedPath = ts.combinePaths(ts.getDirectoryPath(sourceMapPath), relativePath);
                        sourceIndexToNewSourceIndexMap[raw.sourceIndex] = newSourceIndex = addSource(combinedPath);
                        if (map.sourcesContent && typeof map.sourcesContent[raw.sourceIndex] === "string") {
                            setSourceContent(newSourceIndex, map.sourcesContent[raw.sourceIndex]);
                        }
                    }
                    newSourceLine = raw.sourceLine;
                    newSourceCharacter = raw.sourceCharacter;
                    if (map.names && raw.nameIndex !== undefined) {
                        if (!nameIndexToNewNameIndexMap)
                            nameIndexToNewNameIndexMap = [];
                        newNameIndex = nameIndexToNewNameIndexMap[raw.nameIndex];
                        if (newNameIndex === undefined) {
                            nameIndexToNewNameIndexMap[raw.nameIndex] = newNameIndex = addName(map.names[raw.nameIndex]);
                        }
                    }
                }
                var rawGeneratedLine = raw.generatedLine - (start ? start.line : 0);
                var newGeneratedLine = rawGeneratedLine + generatedLine;
                var rawGeneratedCharacter = start && start.line === raw.generatedLine ? raw.generatedCharacter - start.character : raw.generatedCharacter;
                var newGeneratedCharacter = rawGeneratedLine === 0 ? rawGeneratedCharacter + generatedCharacter : rawGeneratedCharacter;
                addMapping(newGeneratedLine, newGeneratedCharacter, newSourceIndex, newSourceLine, newSourceCharacter, newNameIndex);
            }
            exit();
        }
        function shouldCommitMapping() {
            return !hasLast
                || lastGeneratedLine !== pendingGeneratedLine
                || lastGeneratedCharacter !== pendingGeneratedCharacter
                || lastSourceIndex !== pendingSourceIndex
                || lastSourceLine !== pendingSourceLine
                || lastSourceCharacter !== pendingSourceCharacter
                || lastNameIndex !== pendingNameIndex;
        }
        function appendMappingCharCode(charCode) {
            mappingCharCodes.push(charCode);
            // String.fromCharCode accepts its arguments on the stack, so we have to chunk the input,
            // otherwise we can get stack overflows for large source maps
            if (mappingCharCodes.length >= 1024) {
                flushMappingBuffer();
            }
        }
        function commitPendingMapping() {
            if (!hasPending || !shouldCommitMapping()) {
                return;
            }
            enter();
            // Line/Comma delimiters
            if (lastGeneratedLine < pendingGeneratedLine) {
                // Emit line delimiters
                do {
                    appendMappingCharCode(59 /* CharacterCodes.semicolon */);
                    lastGeneratedLine++;
                } while (lastGeneratedLine < pendingGeneratedLine);
                // Only need to set this once
                lastGeneratedCharacter = 0;
            }
            else {
                ts.Debug.assertEqual(lastGeneratedLine, pendingGeneratedLine, "generatedLine cannot backtrack");
                // Emit comma to separate the entry
                if (hasLast) {
                    appendMappingCharCode(44 /* CharacterCodes.comma */);
                }
            }
            // 1. Relative generated character
            appendBase64VLQ(pendingGeneratedCharacter - lastGeneratedCharacter);
            lastGeneratedCharacter = pendingGeneratedCharacter;
            if (hasPendingSource) {
                // 2. Relative sourceIndex
                appendBase64VLQ(pendingSourceIndex - lastSourceIndex);
                lastSourceIndex = pendingSourceIndex;
                // 3. Relative source line
                appendBase64VLQ(pendingSourceLine - lastSourceLine);
                lastSourceLine = pendingSourceLine;
                // 4. Relative source character
                appendBase64VLQ(pendingSourceCharacter - lastSourceCharacter);
                lastSourceCharacter = pendingSourceCharacter;
                if (hasPendingName) {
                    // 5. Relative nameIndex
                    appendBase64VLQ(pendingNameIndex - lastNameIndex);
                    lastNameIndex = pendingNameIndex;
                }
            }
            hasLast = true;
            exit();
        }
        function flushMappingBuffer() {
            if (mappingCharCodes.length > 0) {
                mappings += String.fromCharCode.apply(undefined, mappingCharCodes);
                mappingCharCodes.length = 0;
            }
        }
        function toJSON() {
            commitPendingMapping();
            flushMappingBuffer();
            return {
                version: 3,
                file: file,
                sourceRoot: sourceRoot,
                sources: sources,
                names: names,
                mappings: mappings,
                sourcesContent: sourcesContent,
            };
        }
        function appendBase64VLQ(inValue) {
            // Add a new least significant bit that has the sign of the value.
            // if negative number the least significant bit that gets added to the number has value 1
            // else least significant bit value that gets added is 0
            // eg. -1 changes to binary : 01 [1] => 3
            //     +1 changes to binary : 01 [0] => 2
            if (inValue < 0) {
                inValue = ((-inValue) << 1) + 1;
            }
            else {
                inValue = inValue << 1;
            }
            // Encode 5 bits at a time starting from least significant bits
            do {
                var currentDigit = inValue & 31; // 11111
                inValue = inValue >> 5;
                if (inValue > 0) {
                    // There are still more digits to decode, set the msb (6th bit)
                    currentDigit = currentDigit | 32;
                }
                appendMappingCharCode(base64FormatEncode(currentDigit));
            } while (inValue > 0);
        }
    }
    ts.createSourceMapGenerator = createSourceMapGenerator;
    // Sometimes tools can see the following line as a source mapping url comment, so we mangle it a bit (the [M])
    var sourceMapCommentRegExp = /^\/\/[@#] source[M]appingURL=(.+)\r?\n?$/;
    var whitespaceOrMapCommentRegExp = /^\s*(\/\/[@#] .*)?$/;
    function getLineInfo(text, lineStarts) {
        return {
            getLineCount: function () { return lineStarts.length; },
            getLineText: function (line) { return text.substring(lineStarts[line], lineStarts[line + 1]); }
        };
    }
    ts.getLineInfo = getLineInfo;
    /**
     * Tries to find the sourceMappingURL comment at the end of a file.
     */
    function tryGetSourceMappingURL(lineInfo) {
        for (var index = lineInfo.getLineCount() - 1; index >= 0; index--) {
            var line = lineInfo.getLineText(index);
            var comment = sourceMapCommentRegExp.exec(line);
            if (comment) {
                return ts.trimStringEnd(comment[1]);
            }
            // If we see a non-whitespace/map comment-like line, break, to avoid scanning up the entire file
            else if (!line.match(whitespaceOrMapCommentRegExp)) {
                break;
            }
        }
    }
    ts.tryGetSourceMappingURL = tryGetSourceMappingURL;
    /* eslint-disable no-null/no-null */
    function isStringOrNull(x) {
        return typeof x === "string" || x === null;
    }
    function isRawSourceMap(x) {
        return x !== null
            && typeof x === "object"
            && x.version === 3
            && typeof x.file === "string"
            && typeof x.mappings === "string"
            && ts.isArray(x.sources) && ts.every(x.sources, ts.isString)
            && (x.sourceRoot === undefined || x.sourceRoot === null || typeof x.sourceRoot === "string")
            && (x.sourcesContent === undefined || x.sourcesContent === null || ts.isArray(x.sourcesContent) && ts.every(x.sourcesContent, isStringOrNull))
            && (x.names === undefined || x.names === null || ts.isArray(x.names) && ts.every(x.names, ts.isString));
    }
    ts.isRawSourceMap = isRawSourceMap;
    /* eslint-enable no-null/no-null */
    function tryParseRawSourceMap(text) {
        try {
            var parsed = JSON.parse(text);
            if (isRawSourceMap(parsed)) {
                return parsed;
            }
        }
        catch (_a) {
            // empty
        }
        return undefined;
    }
    ts.tryParseRawSourceMap = tryParseRawSourceMap;
    function decodeMappings(mappings) {
        var done = false;
        var pos = 0;
        var generatedLine = 0;
        var generatedCharacter = 0;
        var sourceIndex = 0;
        var sourceLine = 0;
        var sourceCharacter = 0;
        var nameIndex = 0;
        var error;
        return {
            get pos() { return pos; },
            get error() { return error; },
            get state() { return captureMapping(/*hasSource*/ true, /*hasName*/ true); },
            next: function () {
                while (!done && pos < mappings.length) {
                    var ch = mappings.charCodeAt(pos);
                    if (ch === 59 /* CharacterCodes.semicolon */) {
                        // new line
                        generatedLine++;
                        generatedCharacter = 0;
                        pos++;
                        continue;
                    }
                    if (ch === 44 /* CharacterCodes.comma */) {
                        // Next entry is on same line - no action needed
                        pos++;
                        continue;
                    }
                    var hasSource = false;
                    var hasName = false;
                    generatedCharacter += base64VLQFormatDecode();
                    if (hasReportedError())
                        return stopIterating();
                    if (generatedCharacter < 0)
                        return setErrorAndStopIterating("Invalid generatedCharacter found");
                    if (!isSourceMappingSegmentEnd()) {
                        hasSource = true;
                        sourceIndex += base64VLQFormatDecode();
                        if (hasReportedError())
                            return stopIterating();
                        if (sourceIndex < 0)
                            return setErrorAndStopIterating("Invalid sourceIndex found");
                        if (isSourceMappingSegmentEnd())
                            return setErrorAndStopIterating("Unsupported Format: No entries after sourceIndex");
                        sourceLine += base64VLQFormatDecode();
                        if (hasReportedError())
                            return stopIterating();
                        if (sourceLine < 0)
                            return setErrorAndStopIterating("Invalid sourceLine found");
                        if (isSourceMappingSegmentEnd())
                            return setErrorAndStopIterating("Unsupported Format: No entries after sourceLine");
                        sourceCharacter += base64VLQFormatDecode();
                        if (hasReportedError())
                            return stopIterating();
                        if (sourceCharacter < 0)
                            return setErrorAndStopIterating("Invalid sourceCharacter found");
                        if (!isSourceMappingSegmentEnd()) {
                            hasName = true;
                            nameIndex += base64VLQFormatDecode();
                            if (hasReportedError())
                                return stopIterating();
                            if (nameIndex < 0)
                                return setErrorAndStopIterating("Invalid nameIndex found");
                            if (!isSourceMappingSegmentEnd())
                                return setErrorAndStopIterating("Unsupported Error Format: Entries after nameIndex");
                        }
                    }
                    return { value: captureMapping(hasSource, hasName), done: done };
                }
                return stopIterating();
            }
        };
        function captureMapping(hasSource, hasName) {
            return {
                generatedLine: generatedLine,
                generatedCharacter: generatedCharacter,
                sourceIndex: hasSource ? sourceIndex : undefined,
                sourceLine: hasSource ? sourceLine : undefined,
                sourceCharacter: hasSource ? sourceCharacter : undefined,
                nameIndex: hasName ? nameIndex : undefined
            };
        }
        function stopIterating() {
            done = true;
            return { value: undefined, done: true };
        }
        function setError(message) {
            if (error === undefined) {
                error = message;
            }
        }
        function setErrorAndStopIterating(message) {
            setError(message);
            return stopIterating();
        }
        function hasReportedError() {
            return error !== undefined;
        }
        function isSourceMappingSegmentEnd() {
            return (pos === mappings.length ||
                mappings.charCodeAt(pos) === 44 /* CharacterCodes.comma */ ||
                mappings.charCodeAt(pos) === 59 /* CharacterCodes.semicolon */);
        }
        function base64VLQFormatDecode() {
            var moreDigits = true;
            var shiftCount = 0;
            var value = 0;
            for (; moreDigits; pos++) {
                if (pos >= mappings.length)
                    return setError("Error in decoding base64VLQFormatDecode, past the mapping string"), -1;
                // 6 digit number
                var currentByte = base64FormatDecode(mappings.charCodeAt(pos));
                if (currentByte === -1)
                    return setError("Invalid character in VLQ"), -1;
                // If msb is set, we still have more bits to continue
                moreDigits = (currentByte & 32) !== 0;
                // least significant 5 bits are the next msbs in the final value.
                value = value | ((currentByte & 31) << shiftCount);
                shiftCount += 5;
            }
            // Least significant bit if 1 represents negative and rest of the msb is actual absolute value
            if ((value & 1) === 0) {
                // + number
                value = value >> 1;
            }
            else {
                // - number
                value = value >> 1;
                value = -value;
            }
            return value;
        }
    }
    ts.decodeMappings = decodeMappings;
    function sameMapping(left, right) {
        return left === right
            || left.generatedLine === right.generatedLine
                && left.generatedCharacter === right.generatedCharacter
                && left.sourceIndex === right.sourceIndex
                && left.sourceLine === right.sourceLine
                && left.sourceCharacter === right.sourceCharacter
                && left.nameIndex === right.nameIndex;
    }
    ts.sameMapping = sameMapping;
    function isSourceMapping(mapping) {
        return mapping.sourceIndex !== undefined
            && mapping.sourceLine !== undefined
            && mapping.sourceCharacter !== undefined;
    }
    ts.isSourceMapping = isSourceMapping;
    function base64FormatEncode(value) {
        return value >= 0 && value < 26 ? 65 /* CharacterCodes.A */ + value :
            value >= 26 && value < 52 ? 97 /* CharacterCodes.a */ + value - 26 :
                value >= 52 && value < 62 ? 48 /* CharacterCodes._0 */ + value - 52 :
                    value === 62 ? 43 /* CharacterCodes.plus */ :
                        value === 63 ? 47 /* CharacterCodes.slash */ :
                            ts.Debug.fail("".concat(value, ": not a base64 value"));
    }
    function base64FormatDecode(ch) {
        return ch >= 65 /* CharacterCodes.A */ && ch <= 90 /* CharacterCodes.Z */ ? ch - 65 /* CharacterCodes.A */ :
            ch >= 97 /* CharacterCodes.a */ && ch <= 122 /* CharacterCodes.z */ ? ch - 97 /* CharacterCodes.a */ + 26 :
                ch >= 48 /* CharacterCodes._0 */ && ch <= 57 /* CharacterCodes._9 */ ? ch - 48 /* CharacterCodes._0 */ + 52 :
                    ch === 43 /* CharacterCodes.plus */ ? 62 :
                        ch === 47 /* CharacterCodes.slash */ ? 63 :
                            -1;
    }
    function isSourceMappedPosition(value) {
        return value.sourceIndex !== undefined
            && value.sourcePosition !== undefined;
    }
    function sameMappedPosition(left, right) {
        return left.generatedPosition === right.generatedPosition
            && left.sourceIndex === right.sourceIndex
            && left.sourcePosition === right.sourcePosition;
    }
    function compareSourcePositions(left, right) {
        // Compares sourcePosition without comparing sourceIndex
        // since the mappings are grouped by sourceIndex
        ts.Debug.assert(left.sourceIndex === right.sourceIndex);
        return ts.compareValues(left.sourcePosition, right.sourcePosition);
    }
    function compareGeneratedPositions(left, right) {
        return ts.compareValues(left.generatedPosition, right.generatedPosition);
    }
    function getSourcePositionOfMapping(value) {
        return value.sourcePosition;
    }
    function getGeneratedPositionOfMapping(value) {
        return value.generatedPosition;
    }
    function createDocumentPositionMapper(host, map, mapPath) {
        var mapDirectory = ts.getDirectoryPath(mapPath);
        var sourceRoot = map.sourceRoot ? ts.getNormalizedAbsolutePath(map.sourceRoot, mapDirectory) : mapDirectory;
        var generatedAbsoluteFilePath = ts.getNormalizedAbsolutePath(map.file, mapDirectory);
        var generatedFile = host.getSourceFileLike(generatedAbsoluteFilePath);
        var sourceFileAbsolutePaths = map.sources.map(function (source) { return ts.getNormalizedAbsolutePath(source, sourceRoot); });
        var sourceToSourceIndexMap = new ts.Map(sourceFileAbsolutePaths.map(function (source, i) { return [host.getCanonicalFileName(source), i]; }));
        var decodedMappings;
        var generatedMappings;
        var sourceMappings;
        return {
            getSourcePosition: getSourcePosition,
            getGeneratedPosition: getGeneratedPosition
        };
        function processMapping(mapping) {
            var generatedPosition = generatedFile !== undefined
                ? ts.getPositionOfLineAndCharacter(generatedFile, mapping.generatedLine, mapping.generatedCharacter, /*allowEdits*/ true)
                : -1;
            var source;
            var sourcePosition;
            if (isSourceMapping(mapping)) {
                var sourceFile = host.getSourceFileLike(sourceFileAbsolutePaths[mapping.sourceIndex]);
                source = map.sources[mapping.sourceIndex];
                sourcePosition = sourceFile !== undefined
                    ? ts.getPositionOfLineAndCharacter(sourceFile, mapping.sourceLine, mapping.sourceCharacter, /*allowEdits*/ true)
                    : -1;
            }
            return {
                generatedPosition: generatedPosition,
                source: source,
                sourceIndex: mapping.sourceIndex,
                sourcePosition: sourcePosition,
                nameIndex: mapping.nameIndex
            };
        }
        function getDecodedMappings() {
            if (decodedMappings === undefined) {
                var decoder = decodeMappings(map.mappings);
                var mappings = ts.arrayFrom(decoder, processMapping);
                if (decoder.error !== undefined) {
                    if (host.log) {
                        host.log("Encountered error while decoding sourcemap: ".concat(decoder.error));
                    }
                    decodedMappings = ts.emptyArray;
                }
                else {
                    decodedMappings = mappings;
                }
            }
            return decodedMappings;
        }
        function getSourceMappings(sourceIndex) {
            if (sourceMappings === undefined) {
                var lists = [];
                for (var _i = 0, _a = getDecodedMappings(); _i < _a.length; _i++) {
                    var mapping = _a[_i];
                    if (!isSourceMappedPosition(mapping))
                        continue;
                    var list = lists[mapping.sourceIndex];
                    if (!list)
                        lists[mapping.sourceIndex] = list = [];
                    list.push(mapping);
                }
                sourceMappings = lists.map(function (list) { return ts.sortAndDeduplicate(list, compareSourcePositions, sameMappedPosition); });
            }
            return sourceMappings[sourceIndex];
        }
        function getGeneratedMappings() {
            if (generatedMappings === undefined) {
                var list = [];
                for (var _i = 0, _a = getDecodedMappings(); _i < _a.length; _i++) {
                    var mapping = _a[_i];
                    list.push(mapping);
                }
                generatedMappings = ts.sortAndDeduplicate(list, compareGeneratedPositions, sameMappedPosition);
            }
            return generatedMappings;
        }
        function getGeneratedPosition(loc) {
            var sourceIndex = sourceToSourceIndexMap.get(host.getCanonicalFileName(loc.fileName));
            if (sourceIndex === undefined)
                return loc;
            var sourceMappings = getSourceMappings(sourceIndex);
            if (!ts.some(sourceMappings))
                return loc;
            var targetIndex = ts.binarySearchKey(sourceMappings, loc.pos, getSourcePositionOfMapping, ts.compareValues);
            if (targetIndex < 0) {
                // if no exact match, closest is 2's complement of result
                targetIndex = ~targetIndex;
            }
            var mapping = sourceMappings[targetIndex];
            if (mapping === undefined || mapping.sourceIndex !== sourceIndex) {
                return loc;
            }
            return { fileName: generatedAbsoluteFilePath, pos: mapping.generatedPosition }; // Closest pos
        }
        function getSourcePosition(loc) {
            var generatedMappings = getGeneratedMappings();
            if (!ts.some(generatedMappings))
                return loc;
            var targetIndex = ts.binarySearchKey(generatedMappings, loc.pos, getGeneratedPositionOfMapping, ts.compareValues);
            if (targetIndex < 0) {
                // if no exact match, closest is 2's complement of result
                targetIndex = ~targetIndex;
            }
            var mapping = generatedMappings[targetIndex];
            if (mapping === undefined || !isSourceMappedPosition(mapping)) {
                return loc;
            }
            return { fileName: sourceFileAbsolutePaths[mapping.sourceIndex], pos: mapping.sourcePosition }; // Closest pos
        }
    }
    ts.createDocumentPositionMapper = createDocumentPositionMapper;
    ts.identitySourceMapConsumer = {
        getSourcePosition: ts.identity,
        getGeneratedPosition: ts.identity
    };
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    function getOriginalNodeId(node) {
        node = ts.getOriginalNode(node);
        return node ? ts.getNodeId(node) : 0;
    }
    ts.getOriginalNodeId = getOriginalNodeId;
    function containsDefaultReference(node) {
        if (!node)
            return false;
        if (!ts.isNamedImports(node))
            return false;
        return ts.some(node.elements, isNamedDefaultReference);
    }
    function isNamedDefaultReference(e) {
        return e.propertyName !== undefined && e.propertyName.escapedText === "default" /* InternalSymbolName.Default */;
    }
    function chainBundle(context, transformSourceFile) {
        return transformSourceFileOrBundle;
        function transformSourceFileOrBundle(node) {
            return node.kind === 305 /* SyntaxKind.SourceFile */ ? transformSourceFile(node) : transformBundle(node);
        }
        function transformBundle(node) {
            return context.factory.createBundle(ts.map(node.sourceFiles, transformSourceFile), node.prepends);
        }
    }
    ts.chainBundle = chainBundle;
    function getExportNeedsImportStarHelper(node) {
        return !!ts.getNamespaceDeclarationNode(node);
    }
    ts.getExportNeedsImportStarHelper = getExportNeedsImportStarHelper;
    function getImportNeedsImportStarHelper(node) {
        if (!!ts.getNamespaceDeclarationNode(node)) {
            return true;
        }
        var bindings = node.importClause && node.importClause.namedBindings;
        if (!bindings) {
            return false;
        }
        if (!ts.isNamedImports(bindings))
            return false;
        var defaultRefCount = 0;
        for (var _i = 0, _a = bindings.elements; _i < _a.length; _i++) {
            var binding = _a[_i];
            if (isNamedDefaultReference(binding)) {
                defaultRefCount++;
            }
        }
        // Import star is required if there's default named refs mixed with non-default refs, or if theres non-default refs and it has a default import
        return (defaultRefCount > 0 && defaultRefCount !== bindings.elements.length) || (!!(bindings.elements.length - defaultRefCount) && ts.isDefaultImport(node));
    }
    ts.getImportNeedsImportStarHelper = getImportNeedsImportStarHelper;
    function getImportNeedsImportDefaultHelper(node) {
        // Import default is needed if there's a default import or a default ref and no other refs (meaning an import star helper wasn't requested)
        return !getImportNeedsImportStarHelper(node) && (ts.isDefaultImport(node) || (!!node.importClause && ts.isNamedImports(node.importClause.namedBindings) && containsDefaultReference(node.importClause.namedBindings))); // TODO: GH#18217
    }
    ts.getImportNeedsImportDefaultHelper = getImportNeedsImportDefaultHelper;
    function collectExternalModuleInfo(context, sourceFile, resolver, compilerOptions) {
        var externalImports = [];
        var exportSpecifiers = ts.createMultiMap();
        var exportedBindings = [];
        var uniqueExports = new ts.Map();
        var exportedNames;
        var hasExportDefault = false;
        var exportEquals;
        var hasExportStarsToExportValues = false;
        var hasImportStar = false;
        var hasImportDefault = false;
        for (var _i = 0, _a = sourceFile.statements; _i < _a.length; _i++) {
            var node = _a[_i];
            switch (node.kind) {
                case 266 /* SyntaxKind.ImportDeclaration */:
                    // import "mod"
                    // import x from "mod"
                    // import * as x from "mod"
                    // import { x, y } from "mod"
                    externalImports.push(node);
                    if (!hasImportStar && getImportNeedsImportStarHelper(node)) {
                        hasImportStar = true;
                    }
                    if (!hasImportDefault && getImportNeedsImportDefaultHelper(node)) {
                        hasImportDefault = true;
                    }
                    break;
                case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                    if (node.moduleReference.kind === 277 /* SyntaxKind.ExternalModuleReference */) {
                        // import x = require("mod")
                        externalImports.push(node);
                    }
                    break;
                case 272 /* SyntaxKind.ExportDeclaration */:
                    if (node.moduleSpecifier) {
                        if (!node.exportClause) {
                            // export * from "mod"
                            externalImports.push(node);
                            hasExportStarsToExportValues = true;
                        }
                        else {
                            // export * as ns from "mod"
                            // export { x, y } from "mod"
                            externalImports.push(node);
                            if (ts.isNamedExports(node.exportClause)) {
                                addExportedNamesForExportDeclaration(node);
                            }
                            else {
                                var name = node.exportClause.name;
                                if (!uniqueExports.get(ts.idText(name))) {
                                    multiMapSparseArrayAdd(exportedBindings, getOriginalNodeId(node), name);
                                    uniqueExports.set(ts.idText(name), true);
                                    exportedNames = ts.append(exportedNames, name);
                                }
                                // we use the same helpers for `export * as ns` as we do for `import * as ns`
                                hasImportStar = true;
                            }
                        }
                    }
                    else {
                        // export { x, y }
                        addExportedNamesForExportDeclaration(node);
                    }
                    break;
                case 271 /* SyntaxKind.ExportAssignment */:
                    if (node.isExportEquals && !exportEquals) {
                        // export = x
                        exportEquals = node;
                    }
                    break;
                case 237 /* SyntaxKind.VariableStatement */:
                    if (ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */)) {
                        for (var _b = 0, _c = node.declarationList.declarations; _b < _c.length; _b++) {
                            var decl = _c[_b];
                            exportedNames = collectExportedVariableInfo(decl, uniqueExports, exportedNames);
                        }
                    }
                    break;
                case 256 /* SyntaxKind.FunctionDeclaration */:
                    if (ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */)) {
                        if (ts.hasSyntacticModifier(node, 512 /* ModifierFlags.Default */)) {
                            // export default function() { }
                            if (!hasExportDefault) {
                                multiMapSparseArrayAdd(exportedBindings, getOriginalNodeId(node), context.factory.getDeclarationName(node));
                                hasExportDefault = true;
                            }
                        }
                        else {
                            // export function x() { }
                            var name = node.name;
                            if (!uniqueExports.get(ts.idText(name))) {
                                multiMapSparseArrayAdd(exportedBindings, getOriginalNodeId(node), name);
                                uniqueExports.set(ts.idText(name), true);
                                exportedNames = ts.append(exportedNames, name);
                            }
                        }
                    }
                    break;
                case 257 /* SyntaxKind.ClassDeclaration */:
                    if (ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */)) {
                        if (ts.hasSyntacticModifier(node, 512 /* ModifierFlags.Default */)) {
                            // export default class { }
                            if (!hasExportDefault) {
                                multiMapSparseArrayAdd(exportedBindings, getOriginalNodeId(node), context.factory.getDeclarationName(node));
                                hasExportDefault = true;
                            }
                        }
                        else {
                            // export class x { }
                            var name = node.name;
                            if (name && !uniqueExports.get(ts.idText(name))) {
                                multiMapSparseArrayAdd(exportedBindings, getOriginalNodeId(node), name);
                                uniqueExports.set(ts.idText(name), true);
                                exportedNames = ts.append(exportedNames, name);
                            }
                        }
                    }
                    break;
            }
        }
        var externalHelpersImportDeclaration = ts.createExternalHelpersImportDeclarationIfNeeded(context.factory, context.getEmitHelperFactory(), sourceFile, compilerOptions, hasExportStarsToExportValues, hasImportStar, hasImportDefault);
        if (externalHelpersImportDeclaration) {
            externalImports.unshift(externalHelpersImportDeclaration);
        }
        return { externalImports: externalImports, exportSpecifiers: exportSpecifiers, exportEquals: exportEquals, hasExportStarsToExportValues: hasExportStarsToExportValues, exportedBindings: exportedBindings, exportedNames: exportedNames, externalHelpersImportDeclaration: externalHelpersImportDeclaration };
        function addExportedNamesForExportDeclaration(node) {
            for (var _i = 0, _a = ts.cast(node.exportClause, ts.isNamedExports).elements; _i < _a.length; _i++) {
                var specifier = _a[_i];
                if (!uniqueExports.get(ts.idText(specifier.name))) {
                    var name = specifier.propertyName || specifier.name;
                    if (!node.moduleSpecifier) {
                        exportSpecifiers.add(ts.idText(name), specifier);
                    }
                    var decl = resolver.getReferencedImportDeclaration(name)
                        || resolver.getReferencedValueDeclaration(name);
                    if (decl) {
                        multiMapSparseArrayAdd(exportedBindings, getOriginalNodeId(decl), specifier.name);
                    }
                    uniqueExports.set(ts.idText(specifier.name), true);
                    exportedNames = ts.append(exportedNames, specifier.name);
                }
            }
        }
    }
    ts.collectExternalModuleInfo = collectExternalModuleInfo;
    function collectExportedVariableInfo(decl, uniqueExports, exportedNames) {
        if (ts.isBindingPattern(decl.name)) {
            for (var _i = 0, _a = decl.name.elements; _i < _a.length; _i++) {
                var element = _a[_i];
                if (!ts.isOmittedExpression(element)) {
                    exportedNames = collectExportedVariableInfo(element, uniqueExports, exportedNames);
                }
            }
        }
        else if (!ts.isGeneratedIdentifier(decl.name)) {
            var text = ts.idText(decl.name);
            if (!uniqueExports.get(text)) {
                uniqueExports.set(text, true);
                exportedNames = ts.append(exportedNames, decl.name);
            }
        }
        return exportedNames;
    }
    /** Use a sparse array as a multi-map. */
    function multiMapSparseArrayAdd(map, key, value) {
        var values = map[key];
        if (values) {
            values.push(value);
        }
        else {
            map[key] = values = [value];
        }
        return values;
    }
    /**
     * Used in the module transformer to check if an expression is reasonably without sideeffect,
     *  and thus better to copy into multiple places rather than to cache in a temporary variable
     *  - this is mostly subjective beyond the requirement that the expression not be sideeffecting
     */
    function isSimpleCopiableExpression(expression) {
        return ts.isStringLiteralLike(expression) ||
            expression.kind === 8 /* SyntaxKind.NumericLiteral */ ||
            ts.isKeyword(expression.kind) ||
            ts.isIdentifier(expression);
    }
    ts.isSimpleCopiableExpression = isSimpleCopiableExpression;
    /**
     * A simple inlinable expression is an expression which can be copied into multiple locations
     * without risk of repeating any sideeffects and whose value could not possibly change between
     * any such locations
     */
    function isSimpleInlineableExpression(expression) {
        return !ts.isIdentifier(expression) && isSimpleCopiableExpression(expression);
    }
    ts.isSimpleInlineableExpression = isSimpleInlineableExpression;
    function isCompoundAssignment(kind) {
        return kind >= 64 /* SyntaxKind.FirstCompoundAssignment */
            && kind <= 78 /* SyntaxKind.LastCompoundAssignment */;
    }
    ts.isCompoundAssignment = isCompoundAssignment;
    function getNonAssignmentOperatorForCompoundAssignment(kind) {
        switch (kind) {
            case 64 /* SyntaxKind.PlusEqualsToken */: return 39 /* SyntaxKind.PlusToken */;
            case 65 /* SyntaxKind.MinusEqualsToken */: return 40 /* SyntaxKind.MinusToken */;
            case 66 /* SyntaxKind.AsteriskEqualsToken */: return 41 /* SyntaxKind.AsteriskToken */;
            case 67 /* SyntaxKind.AsteriskAsteriskEqualsToken */: return 42 /* SyntaxKind.AsteriskAsteriskToken */;
            case 68 /* SyntaxKind.SlashEqualsToken */: return 43 /* SyntaxKind.SlashToken */;
            case 69 /* SyntaxKind.PercentEqualsToken */: return 44 /* SyntaxKind.PercentToken */;
            case 70 /* SyntaxKind.LessThanLessThanEqualsToken */: return 47 /* SyntaxKind.LessThanLessThanToken */;
            case 71 /* SyntaxKind.GreaterThanGreaterThanEqualsToken */: return 48 /* SyntaxKind.GreaterThanGreaterThanToken */;
            case 72 /* SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken */: return 49 /* SyntaxKind.GreaterThanGreaterThanGreaterThanToken */;
            case 73 /* SyntaxKind.AmpersandEqualsToken */: return 50 /* SyntaxKind.AmpersandToken */;
            case 74 /* SyntaxKind.BarEqualsToken */: return 51 /* SyntaxKind.BarToken */;
            case 78 /* SyntaxKind.CaretEqualsToken */: return 52 /* SyntaxKind.CaretToken */;
            case 75 /* SyntaxKind.BarBarEqualsToken */: return 56 /* SyntaxKind.BarBarToken */;
            case 76 /* SyntaxKind.AmpersandAmpersandEqualsToken */: return 55 /* SyntaxKind.AmpersandAmpersandToken */;
            case 77 /* SyntaxKind.QuestionQuestionEqualsToken */: return 60 /* SyntaxKind.QuestionQuestionToken */;
        }
    }
    ts.getNonAssignmentOperatorForCompoundAssignment = getNonAssignmentOperatorForCompoundAssignment;
    /**
     * @returns Contained super() call from descending into the statement ignoring parentheses, if that call exists.
     */
    function getSuperCallFromStatement(statement) {
        if (!ts.isExpressionStatement(statement)) {
            return undefined;
        }
        var expression = ts.skipParentheses(statement.expression);
        return ts.isSuperCall(expression)
            ? expression
            : undefined;
    }
    ts.getSuperCallFromStatement = getSuperCallFromStatement;
    /**
     * @returns The index (after prologue statements) of a super call, or -1 if not found.
     */
    function findSuperStatementIndex(statements, indexAfterLastPrologueStatement) {
        for (var i = indexAfterLastPrologueStatement; i < statements.length; i += 1) {
            var statement = statements[i];
            if (getSuperCallFromStatement(statement)) {
                return i;
            }
        }
        return -1;
    }
    ts.findSuperStatementIndex = findSuperStatementIndex;
    function getProperties(node, requireInitializer, isStatic) {
        return ts.filter(node.members, function (m) { return isInitializedOrStaticProperty(m, requireInitializer, isStatic); });
    }
    ts.getProperties = getProperties;
    function isStaticPropertyDeclarationOrClassStaticBlockDeclaration(element) {
        return isStaticPropertyDeclaration(element) || ts.isClassStaticBlockDeclaration(element);
    }
    function getStaticPropertiesAndClassStaticBlock(node) {
        return ts.filter(node.members, isStaticPropertyDeclarationOrClassStaticBlockDeclaration);
    }
    ts.getStaticPropertiesAndClassStaticBlock = getStaticPropertiesAndClassStaticBlock;
    /**
     * Is a class element either a static or an instance property declaration with an initializer?
     *
     * @param member The class element node.
     * @param isStatic A value indicating whether the member should be a static or instance member.
     */
    function isInitializedOrStaticProperty(member, requireInitializer, isStatic) {
        return ts.isPropertyDeclaration(member)
            && (!!member.initializer || !requireInitializer)
            && ts.hasStaticModifier(member) === isStatic;
    }
    function isStaticPropertyDeclaration(member) {
        return ts.isPropertyDeclaration(member) && ts.hasStaticModifier(member);
    }
    /**
     * Gets a value indicating whether a class element is either a static or an instance property declaration with an initializer.
     *
     * @param member The class element node.
     * @param isStatic A value indicating whether the member should be a static or instance member.
     */
    function isInitializedProperty(member) {
        return member.kind === 167 /* SyntaxKind.PropertyDeclaration */
            && member.initializer !== undefined;
    }
    ts.isInitializedProperty = isInitializedProperty;
    /**
     * Gets a value indicating whether a class element is a private instance method or accessor.
     *
     * @param member The class element node.
     */
    function isNonStaticMethodOrAccessorWithPrivateName(member) {
        return !ts.isStatic(member) && ts.isMethodOrAccessor(member) && ts.isPrivateIdentifier(member.name);
    }
    ts.isNonStaticMethodOrAccessorWithPrivateName = isNonStaticMethodOrAccessorWithPrivateName;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var FlattenLevel;
    (function (FlattenLevel) {
        FlattenLevel[FlattenLevel["All"] = 0] = "All";
        FlattenLevel[FlattenLevel["ObjectRest"] = 1] = "ObjectRest";
    })(FlattenLevel = ts.FlattenLevel || (ts.FlattenLevel = {}));
    /**
     * Flattens a DestructuringAssignment or a VariableDeclaration to an expression.
     *
     * @param node The node to flatten.
     * @param visitor An optional visitor used to visit initializers.
     * @param context The transformation context.
     * @param level Indicates the extent to which flattening should occur.
     * @param needsValue An optional value indicating whether the value from the right-hand-side of
     * the destructuring assignment is needed as part of a larger expression.
     * @param createAssignmentCallback An optional callback used to create the assignment expression.
     */
    function flattenDestructuringAssignment(node, visitor, context, level, needsValue, createAssignmentCallback) {
        var location = node;
        var value;
        if (ts.isDestructuringAssignment(node)) {
            value = node.right;
            while (ts.isEmptyArrayLiteral(node.left) || ts.isEmptyObjectLiteral(node.left)) {
                if (ts.isDestructuringAssignment(value)) {
                    location = node = value;
                    value = node.right;
                }
                else {
                    return ts.visitNode(value, visitor, ts.isExpression);
                }
            }
        }
        var expressions;
        var flattenContext = {
            context: context,
            level: level,
            downlevelIteration: !!context.getCompilerOptions().downlevelIteration,
            hoistTempVariables: true,
            emitExpression: emitExpression,
            emitBindingOrAssignment: emitBindingOrAssignment,
            createArrayBindingOrAssignmentPattern: function (elements) { return makeArrayAssignmentPattern(context.factory, elements); },
            createObjectBindingOrAssignmentPattern: function (elements) { return makeObjectAssignmentPattern(context.factory, elements); },
            createArrayBindingOrAssignmentElement: makeAssignmentElement,
            visitor: visitor
        };
        if (value) {
            value = ts.visitNode(value, visitor, ts.isExpression);
            if (ts.isIdentifier(value) && bindingOrAssignmentElementAssignsToName(node, value.escapedText) ||
                bindingOrAssignmentElementContainsNonLiteralComputedName(node)) {
                // If the right-hand value of the assignment is also an assignment target then
                // we need to cache the right-hand value.
                value = ensureIdentifier(flattenContext, value, /*reuseIdentifierExpressions*/ false, location);
            }
            else if (needsValue) {
                // If the right-hand value of the destructuring assignment needs to be preserved (as
                // is the case when the destructuring assignment is part of a larger expression),
                // then we need to cache the right-hand value.
                //
                // The source map location for the assignment should point to the entire binary
                // expression.
                value = ensureIdentifier(flattenContext, value, /*reuseIdentifierExpressions*/ true, location);
            }
            else if (ts.nodeIsSynthesized(node)) {
                // Generally, the source map location for a destructuring assignment is the root
                // expression.
                //
                // However, if the root expression is synthesized (as in the case
                // of the initializer when transforming a ForOfStatement), then the source map
                // location should point to the right-hand value of the expression.
                location = value;
            }
        }
        flattenBindingOrAssignmentElement(flattenContext, node, value, location, /*skipInitializer*/ ts.isDestructuringAssignment(node));
        if (value && needsValue) {
            if (!ts.some(expressions)) {
                return value;
            }
            expressions.push(value);
        }
        return context.factory.inlineExpressions(expressions) || context.factory.createOmittedExpression();
        function emitExpression(expression) {
            expressions = ts.append(expressions, expression);
        }
        function emitBindingOrAssignment(target, value, location, original) {
            ts.Debug.assertNode(target, createAssignmentCallback ? ts.isIdentifier : ts.isExpression);
            var expression = createAssignmentCallback
                ? createAssignmentCallback(target, value, location)
                : ts.setTextRange(context.factory.createAssignment(ts.visitNode(target, visitor, ts.isExpression), value), location);
            expression.original = original;
            emitExpression(expression);
        }
    }
    ts.flattenDestructuringAssignment = flattenDestructuringAssignment;
    function bindingOrAssignmentElementAssignsToName(element, escapedName) {
        var target = ts.getTargetOfBindingOrAssignmentElement(element); // TODO: GH#18217
        if (ts.isBindingOrAssignmentPattern(target)) {
            return bindingOrAssignmentPatternAssignsToName(target, escapedName);
        }
        else if (ts.isIdentifier(target)) {
            return target.escapedText === escapedName;
        }
        return false;
    }
    function bindingOrAssignmentPatternAssignsToName(pattern, escapedName) {
        var elements = ts.getElementsOfBindingOrAssignmentPattern(pattern);
        for (var _i = 0, elements_4 = elements; _i < elements_4.length; _i++) {
            var element = elements_4[_i];
            if (bindingOrAssignmentElementAssignsToName(element, escapedName)) {
                return true;
            }
        }
        return false;
    }
    function bindingOrAssignmentElementContainsNonLiteralComputedName(element) {
        var propertyName = ts.tryGetPropertyNameOfBindingOrAssignmentElement(element);
        if (propertyName && ts.isComputedPropertyName(propertyName) && !ts.isLiteralExpression(propertyName.expression)) {
            return true;
        }
        var target = ts.getTargetOfBindingOrAssignmentElement(element);
        return !!target && ts.isBindingOrAssignmentPattern(target) && bindingOrAssignmentPatternContainsNonLiteralComputedName(target);
    }
    function bindingOrAssignmentPatternContainsNonLiteralComputedName(pattern) {
        return !!ts.forEach(ts.getElementsOfBindingOrAssignmentPattern(pattern), bindingOrAssignmentElementContainsNonLiteralComputedName);
    }
    /**
     * Flattens a VariableDeclaration or ParameterDeclaration to one or more variable declarations.
     *
     * @param node The node to flatten.
     * @param visitor An optional visitor used to visit initializers.
     * @param context The transformation context.
     * @param boundValue The value bound to the declaration.
     * @param skipInitializer A value indicating whether to ignore the initializer of `node`.
     * @param hoistTempVariables Indicates whether temporary variables should not be recorded in-line.
     * @param level Indicates the extent to which flattening should occur.
     */
    function flattenDestructuringBinding(node, visitor, context, level, rval, hoistTempVariables, skipInitializer) {
        if (hoistTempVariables === void 0) { hoistTempVariables = false; }
        var pendingExpressions;
        var pendingDeclarations = [];
        var declarations = [];
        var flattenContext = {
            context: context,
            level: level,
            downlevelIteration: !!context.getCompilerOptions().downlevelIteration,
            hoistTempVariables: hoistTempVariables,
            emitExpression: emitExpression,
            emitBindingOrAssignment: emitBindingOrAssignment,
            createArrayBindingOrAssignmentPattern: function (elements) { return makeArrayBindingPattern(context.factory, elements); },
            createObjectBindingOrAssignmentPattern: function (elements) { return makeObjectBindingPattern(context.factory, elements); },
            createArrayBindingOrAssignmentElement: function (name) { return makeBindingElement(context.factory, name); },
            visitor: visitor
        };
        if (ts.isVariableDeclaration(node)) {
            var initializer = ts.getInitializerOfBindingOrAssignmentElement(node);
            if (initializer && (ts.isIdentifier(initializer) && bindingOrAssignmentElementAssignsToName(node, initializer.escapedText) ||
                bindingOrAssignmentElementContainsNonLiteralComputedName(node))) {
                // If the right-hand value of the assignment is also an assignment target then
                // we need to cache the right-hand value.
                initializer = ensureIdentifier(flattenContext, ts.visitNode(initializer, flattenContext.visitor), /*reuseIdentifierExpressions*/ false, initializer);
                node = context.factory.updateVariableDeclaration(node, node.name, /*exclamationToken*/ undefined, /*type*/ undefined, initializer);
            }
        }
        flattenBindingOrAssignmentElement(flattenContext, node, rval, node, skipInitializer);
        if (pendingExpressions) {
            var temp = context.factory.createTempVariable(/*recordTempVariable*/ undefined);
            if (hoistTempVariables) {
                var value = context.factory.inlineExpressions(pendingExpressions);
                pendingExpressions = undefined;
                emitBindingOrAssignment(temp, value, /*location*/ undefined, /*original*/ undefined);
            }
            else {
                context.hoistVariableDeclaration(temp);
                var pendingDeclaration = ts.last(pendingDeclarations);
                pendingDeclaration.pendingExpressions = ts.append(pendingDeclaration.pendingExpressions, context.factory.createAssignment(temp, pendingDeclaration.value));
                ts.addRange(pendingDeclaration.pendingExpressions, pendingExpressions);
                pendingDeclaration.value = temp;
            }
        }
        for (var _i = 0, pendingDeclarations_1 = pendingDeclarations; _i < pendingDeclarations_1.length; _i++) {
            var _a = pendingDeclarations_1[_i], pendingExpressions_1 = _a.pendingExpressions, name = _a.name, value = _a.value, location = _a.location, original = _a.original;
            var variable = context.factory.createVariableDeclaration(name, 
            /*exclamationToken*/ undefined, 
            /*type*/ undefined, pendingExpressions_1 ? context.factory.inlineExpressions(ts.append(pendingExpressions_1, value)) : value);
            variable.original = original;
            ts.setTextRange(variable, location);
            declarations.push(variable);
        }
        return declarations;
        function emitExpression(value) {
            pendingExpressions = ts.append(pendingExpressions, value);
        }
        function emitBindingOrAssignment(target, value, location, original) {
            ts.Debug.assertNode(target, ts.isBindingName);
            if (pendingExpressions) {
                value = context.factory.inlineExpressions(ts.append(pendingExpressions, value));
                pendingExpressions = undefined;
            }
            pendingDeclarations.push({ pendingExpressions: pendingExpressions, name: target, value: value, location: location, original: original });
        }
    }
    ts.flattenDestructuringBinding = flattenDestructuringBinding;
    /**
     * Flattens a BindingOrAssignmentElement into zero or more bindings or assignments.
     *
     * @param flattenContext Options used to control flattening.
     * @param element The element to flatten.
     * @param value The current RHS value to assign to the element.
     * @param location The location to use for source maps and comments.
     * @param skipInitializer An optional value indicating whether to include the initializer
     * for the element.
     */
    function flattenBindingOrAssignmentElement(flattenContext, element, value, location, skipInitializer) {
        var bindingTarget = ts.getTargetOfBindingOrAssignmentElement(element); // TODO: GH#18217
        if (!skipInitializer) {
            var initializer = ts.visitNode(ts.getInitializerOfBindingOrAssignmentElement(element), flattenContext.visitor, ts.isExpression);
            if (initializer) {
                // Combine value and initializer
                if (value) {
                    value = createDefaultValueCheck(flattenContext, value, initializer, location);
                    // If 'value' is not a simple expression, it could contain side-effecting code that should evaluate before an object or array binding pattern.
                    if (!ts.isSimpleInlineableExpression(initializer) && ts.isBindingOrAssignmentPattern(bindingTarget)) {
                        value = ensureIdentifier(flattenContext, value, /*reuseIdentifierExpressions*/ true, location);
                    }
                }
                else {
                    value = initializer;
                }
            }
            else if (!value) {
                // Use 'void 0' in absence of value and initializer
                value = flattenContext.context.factory.createVoidZero();
            }
        }
        if (ts.isObjectBindingOrAssignmentPattern(bindingTarget)) {
            flattenObjectBindingOrAssignmentPattern(flattenContext, element, bindingTarget, value, location);
        }
        else if (ts.isArrayBindingOrAssignmentPattern(bindingTarget)) {
            flattenArrayBindingOrAssignmentPattern(flattenContext, element, bindingTarget, value, location);
        }
        else {
            flattenContext.emitBindingOrAssignment(bindingTarget, value, location, /*original*/ element); // TODO: GH#18217
        }
    }
    /**
     * Flattens an ObjectBindingOrAssignmentPattern into zero or more bindings or assignments.
     *
     * @param flattenContext Options used to control flattening.
     * @param parent The parent element of the pattern.
     * @param pattern The ObjectBindingOrAssignmentPattern to flatten.
     * @param value The current RHS value to assign to the element.
     * @param location The location to use for source maps and comments.
     */
    function flattenObjectBindingOrAssignmentPattern(flattenContext, parent, pattern, value, location) {
        var elements = ts.getElementsOfBindingOrAssignmentPattern(pattern);
        var numElements = elements.length;
        if (numElements !== 1) {
            // For anything other than a single-element destructuring we need to generate a temporary
            // to ensure value is evaluated exactly once. Additionally, if we have zero elements
            // we need to emit *something* to ensure that in case a 'var' keyword was already emitted,
            // so in that case, we'll intentionally create that temporary.
            var reuseIdentifierExpressions = !ts.isDeclarationBindingElement(parent) || numElements !== 0;
            value = ensureIdentifier(flattenContext, value, reuseIdentifierExpressions, location);
        }
        var bindingElements;
        var computedTempVariables;
        for (var i = 0; i < numElements; i++) {
            var element = elements[i];
            if (!ts.getRestIndicatorOfBindingOrAssignmentElement(element)) {
                var propertyName = ts.getPropertyNameOfBindingOrAssignmentElement(element);
                if (flattenContext.level >= 1 /* FlattenLevel.ObjectRest */
                    && !(element.transformFlags & (16384 /* TransformFlags.ContainsRestOrSpread */ | 32768 /* TransformFlags.ContainsObjectRestOrSpread */))
                    && !(ts.getTargetOfBindingOrAssignmentElement(element).transformFlags & (16384 /* TransformFlags.ContainsRestOrSpread */ | 32768 /* TransformFlags.ContainsObjectRestOrSpread */))
                    && !ts.isComputedPropertyName(propertyName)) {
                    bindingElements = ts.append(bindingElements, ts.visitNode(element, flattenContext.visitor));
                }
                else {
                    if (bindingElements) {
                        flattenContext.emitBindingOrAssignment(flattenContext.createObjectBindingOrAssignmentPattern(bindingElements), value, location, pattern);
                        bindingElements = undefined;
                    }
                    var rhsValue = createDestructuringPropertyAccess(flattenContext, value, propertyName);
                    if (ts.isComputedPropertyName(propertyName)) {
                        computedTempVariables = ts.append(computedTempVariables, rhsValue.argumentExpression);
                    }
                    flattenBindingOrAssignmentElement(flattenContext, element, rhsValue, /*location*/ element);
                }
            }
            else if (i === numElements - 1) {
                if (bindingElements) {
                    flattenContext.emitBindingOrAssignment(flattenContext.createObjectBindingOrAssignmentPattern(bindingElements), value, location, pattern);
                    bindingElements = undefined;
                }
                var rhsValue = flattenContext.context.getEmitHelperFactory().createRestHelper(value, elements, computedTempVariables, pattern);
                flattenBindingOrAssignmentElement(flattenContext, element, rhsValue, element);
            }
        }
        if (bindingElements) {
            flattenContext.emitBindingOrAssignment(flattenContext.createObjectBindingOrAssignmentPattern(bindingElements), value, location, pattern);
        }
    }
    /**
     * Flattens an ArrayBindingOrAssignmentPattern into zero or more bindings or assignments.
     *
     * @param flattenContext Options used to control flattening.
     * @param parent The parent element of the pattern.
     * @param pattern The ArrayBindingOrAssignmentPattern to flatten.
     * @param value The current RHS value to assign to the element.
     * @param location The location to use for source maps and comments.
     */
    function flattenArrayBindingOrAssignmentPattern(flattenContext, parent, pattern, value, location) {
        var elements = ts.getElementsOfBindingOrAssignmentPattern(pattern);
        var numElements = elements.length;
        if (flattenContext.level < 1 /* FlattenLevel.ObjectRest */ && flattenContext.downlevelIteration) {
            // Read the elements of the iterable into an array
            value = ensureIdentifier(flattenContext, ts.setTextRange(flattenContext.context.getEmitHelperFactory().createReadHelper(value, numElements > 0 && ts.getRestIndicatorOfBindingOrAssignmentElement(elements[numElements - 1])
                ? undefined
                : numElements), location), 
            /*reuseIdentifierExpressions*/ false, location);
        }
        else if (numElements !== 1 && (flattenContext.level < 1 /* FlattenLevel.ObjectRest */ || numElements === 0)
            || ts.every(elements, ts.isOmittedExpression)) {
            // For anything other than a single-element destructuring we need to generate a temporary
            // to ensure value is evaluated exactly once. Additionally, if we have zero elements
            // we need to emit *something* to ensure that in case a 'var' keyword was already emitted,
            // so in that case, we'll intentionally create that temporary.
            // Or all the elements of the binding pattern are omitted expression such as "var [,] = [1,2]",
            // then we will create temporary variable.
            var reuseIdentifierExpressions = !ts.isDeclarationBindingElement(parent) || numElements !== 0;
            value = ensureIdentifier(flattenContext, value, reuseIdentifierExpressions, location);
        }
        var bindingElements;
        var restContainingElements;
        for (var i = 0; i < numElements; i++) {
            var element = elements[i];
            if (flattenContext.level >= 1 /* FlattenLevel.ObjectRest */) {
                // If an array pattern contains an ObjectRest, we must cache the result so that we
                // can perform the ObjectRest destructuring in a different declaration
                if (element.transformFlags & 32768 /* TransformFlags.ContainsObjectRestOrSpread */ || flattenContext.hasTransformedPriorElement && !isSimpleBindingOrAssignmentElement(element)) {
                    flattenContext.hasTransformedPriorElement = true;
                    var temp = flattenContext.context.factory.createTempVariable(/*recordTempVariable*/ undefined);
                    if (flattenContext.hoistTempVariables) {
                        flattenContext.context.hoistVariableDeclaration(temp);
                    }
                    restContainingElements = ts.append(restContainingElements, [temp, element]);
                    bindingElements = ts.append(bindingElements, flattenContext.createArrayBindingOrAssignmentElement(temp));
                }
                else {
                    bindingElements = ts.append(bindingElements, element);
                }
            }
            else if (ts.isOmittedExpression(element)) {
                continue;
            }
            else if (!ts.getRestIndicatorOfBindingOrAssignmentElement(element)) {
                var rhsValue = flattenContext.context.factory.createElementAccessExpression(value, i);
                flattenBindingOrAssignmentElement(flattenContext, element, rhsValue, /*location*/ element);
            }
            else if (i === numElements - 1) {
                var rhsValue = flattenContext.context.factory.createArraySliceCall(value, i);
                flattenBindingOrAssignmentElement(flattenContext, element, rhsValue, /*location*/ element);
            }
        }
        if (bindingElements) {
            flattenContext.emitBindingOrAssignment(flattenContext.createArrayBindingOrAssignmentPattern(bindingElements), value, location, pattern);
        }
        if (restContainingElements) {
            for (var _i = 0, restContainingElements_1 = restContainingElements; _i < restContainingElements_1.length; _i++) {
                var _a = restContainingElements_1[_i], id = _a[0], element = _a[1];
                flattenBindingOrAssignmentElement(flattenContext, element, id, element);
            }
        }
    }
    function isSimpleBindingOrAssignmentElement(element) {
        var target = ts.getTargetOfBindingOrAssignmentElement(element);
        if (!target || ts.isOmittedExpression(target))
            return true;
        var propertyName = ts.tryGetPropertyNameOfBindingOrAssignmentElement(element);
        if (propertyName && !ts.isPropertyNameLiteral(propertyName))
            return false;
        var initializer = ts.getInitializerOfBindingOrAssignmentElement(element);
        if (initializer && !ts.isSimpleInlineableExpression(initializer))
            return false;
        if (ts.isBindingOrAssignmentPattern(target))
            return ts.every(ts.getElementsOfBindingOrAssignmentPattern(target), isSimpleBindingOrAssignmentElement);
        return ts.isIdentifier(target);
    }
    /**
     * Creates an expression used to provide a default value if a value is `undefined` at runtime.
     *
     * @param flattenContext Options used to control flattening.
     * @param value The RHS value to test.
     * @param defaultValue The default value to use if `value` is `undefined` at runtime.
     * @param location The location to use for source maps and comments.
     */
    function createDefaultValueCheck(flattenContext, value, defaultValue, location) {
        value = ensureIdentifier(flattenContext, value, /*reuseIdentifierExpressions*/ true, location);
        return flattenContext.context.factory.createConditionalExpression(flattenContext.context.factory.createTypeCheck(value, "undefined"), /*questionToken*/ undefined, defaultValue, /*colonToken*/ undefined, value);
    }
    /**
     * Creates either a PropertyAccessExpression or an ElementAccessExpression for the
     * right-hand side of a transformed destructuring assignment.
     *
     * @link https://tc39.github.io/ecma262/#sec-runtime-semantics-keyeddestructuringassignmentevaluation
     *
     * @param flattenContext Options used to control flattening.
     * @param value The RHS value that is the source of the property.
     * @param propertyName The destructuring property name.
     */
    function createDestructuringPropertyAccess(flattenContext, value, propertyName) {
        if (ts.isComputedPropertyName(propertyName)) {
            var argumentExpression = ensureIdentifier(flattenContext, ts.visitNode(propertyName.expression, flattenContext.visitor), /*reuseIdentifierExpressions*/ false, /*location*/ propertyName);
            return flattenContext.context.factory.createElementAccessExpression(value, argumentExpression);
        }
        else if (ts.isStringOrNumericLiteralLike(propertyName)) {
            var argumentExpression = ts.factory.cloneNode(propertyName);
            return flattenContext.context.factory.createElementAccessExpression(value, argumentExpression);
        }
        else {
            var name = flattenContext.context.factory.createIdentifier(ts.idText(propertyName));
            return flattenContext.context.factory.createPropertyAccessExpression(value, name);
        }
    }
    /**
     * Ensures that there exists a declared identifier whose value holds the given expression.
     * This function is useful to ensure that the expression's value can be read from in subsequent expressions.
     * Unless 'reuseIdentifierExpressions' is false, 'value' will be returned if it is just an identifier.
     *
     * @param flattenContext Options used to control flattening.
     * @param value the expression whose value needs to be bound.
     * @param reuseIdentifierExpressions true if identifier expressions can simply be returned;
     * false if it is necessary to always emit an identifier.
     * @param location The location to use for source maps and comments.
     */
    function ensureIdentifier(flattenContext, value, reuseIdentifierExpressions, location) {
        if (ts.isIdentifier(value) && reuseIdentifierExpressions) {
            return value;
        }
        else {
            var temp = flattenContext.context.factory.createTempVariable(/*recordTempVariable*/ undefined);
            if (flattenContext.hoistTempVariables) {
                flattenContext.context.hoistVariableDeclaration(temp);
                flattenContext.emitExpression(ts.setTextRange(flattenContext.context.factory.createAssignment(temp, value), location));
            }
            else {
                flattenContext.emitBindingOrAssignment(temp, value, location, /*original*/ undefined);
            }
            return temp;
        }
    }
    function makeArrayBindingPattern(factory, elements) {
        ts.Debug.assertEachNode(elements, ts.isArrayBindingElement);
        return factory.createArrayBindingPattern(elements);
    }
    function makeArrayAssignmentPattern(factory, elements) {
        return factory.createArrayLiteralExpression(ts.map(elements, factory.converters.convertToArrayAssignmentElement));
    }
    function makeObjectBindingPattern(factory, elements) {
        ts.Debug.assertEachNode(elements, ts.isBindingElement);
        return factory.createObjectBindingPattern(elements);
    }
    function makeObjectAssignmentPattern(factory, elements) {
        return factory.createObjectLiteralExpression(ts.map(elements, factory.converters.convertToObjectAssignmentElement));
    }
    function makeBindingElement(factory, name) {
        return factory.createBindingElement(/*dotDotDotToken*/ undefined, /*propertyName*/ undefined, name);
    }
    function makeAssignmentElement(name) {
        return name;
    }
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var ProcessLevel;
    (function (ProcessLevel) {
        ProcessLevel[ProcessLevel["LiftRestriction"] = 0] = "LiftRestriction";
        ProcessLevel[ProcessLevel["All"] = 1] = "All";
    })(ProcessLevel = ts.ProcessLevel || (ts.ProcessLevel = {}));
    function processTaggedTemplateExpression(context, node, visitor, currentSourceFile, recordTaggedTemplateString, level) {
        // Visit the tag expression
        var tag = ts.visitNode(node.tag, visitor, ts.isExpression);
        // Build up the template arguments and the raw and cooked strings for the template.
        // We start out with 'undefined' for the first argument and revisit later
        // to avoid walking over the template string twice and shifting all our arguments over after the fact.
        var templateArguments = [undefined];
        var cookedStrings = [];
        var rawStrings = [];
        var template = node.template;
        if (level === ProcessLevel.LiftRestriction && !ts.hasInvalidEscape(template)) {
            return ts.visitEachChild(node, visitor, context);
        }
        if (ts.isNoSubstitutionTemplateLiteral(template)) {
            cookedStrings.push(createTemplateCooked(template));
            rawStrings.push(getRawLiteral(template, currentSourceFile));
        }
        else {
            cookedStrings.push(createTemplateCooked(template.head));
            rawStrings.push(getRawLiteral(template.head, currentSourceFile));
            for (var _i = 0, _a = template.templateSpans; _i < _a.length; _i++) {
                var templateSpan = _a[_i];
                cookedStrings.push(createTemplateCooked(templateSpan.literal));
                rawStrings.push(getRawLiteral(templateSpan.literal, currentSourceFile));
                templateArguments.push(ts.visitNode(templateSpan.expression, visitor, ts.isExpression));
            }
        }
        var helperCall = context.getEmitHelperFactory().createTemplateObjectHelper(ts.factory.createArrayLiteralExpression(cookedStrings), ts.factory.createArrayLiteralExpression(rawStrings));
        // Create a variable to cache the template object if we're in a module.
        // Do not do this in the global scope, as any variable we currently generate could conflict with
        // variables from outside of the current compilation. In the future, we can revisit this behavior.
        if (ts.isExternalModule(currentSourceFile)) {
            var tempVar = ts.factory.createUniqueName("templateObject");
            recordTaggedTemplateString(tempVar);
            templateArguments[0] = ts.factory.createLogicalOr(tempVar, ts.factory.createAssignment(tempVar, helperCall));
        }
        else {
            templateArguments[0] = helperCall;
        }
        return ts.factory.createCallExpression(tag, /*typeArguments*/ undefined, templateArguments);
    }
    ts.processTaggedTemplateExpression = processTaggedTemplateExpression;
    function createTemplateCooked(template) {
        return template.templateFlags ? ts.factory.createVoidZero() : ts.factory.createStringLiteral(template.text);
    }
    /**
     * Creates an ES5 compatible literal from an ES6 template literal.
     *
     * @param node The ES6 template literal.
     */
    function getRawLiteral(node, currentSourceFile) {
        // Find original source text, since we need to emit the raw strings of the tagged template.
        // The raw strings contain the (escaped) strings of what the user wrote.
        // Examples: `\n` is converted to "\\n", a template string with a newline to "\n".
        var text = node.rawText;
        if (text === undefined) {
            ts.Debug.assertIsDefined(currentSourceFile, "Template literal node is missing 'rawText' and does not have a source file. Possibly bad transform.");
            text = ts.getSourceTextOfNodeFromSourceFile(currentSourceFile, node);
            // text contains the original source, it will also contain quotes ("`"), dolar signs and braces ("${" and "}"),
            // thus we need to remove those characters.
            // First template piece starts with "`", others with "}"
            // Last template piece ends with "`", others with "${"
            var isLast = node.kind === 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */ || node.kind === 17 /* SyntaxKind.TemplateTail */;
            text = text.substring(1, text.length - (isLast ? 1 : 2));
        }
        // Newline normalization:
        // ES6 Spec 11.8.6.1 - Static Semantics of TV's and TRV's
        // <CR><LF> and <CR> LineTerminatorSequences are normalized to <LF> for both TV and TRV.
        text = text.replace(/\r\n?/g, "\n");
        return ts.setTextRange(ts.factory.createStringLiteral(text), node);
    }
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    /**
     * Indicates whether to emit type metadata in the new format.
     */
    var USE_NEW_TYPE_METADATA_FORMAT = false;
    var TypeScriptSubstitutionFlags;
    (function (TypeScriptSubstitutionFlags) {
        /** Enables substitutions for decorated classes. */
        TypeScriptSubstitutionFlags[TypeScriptSubstitutionFlags["ClassAliases"] = 1] = "ClassAliases";
        /** Enables substitutions for namespace exports. */
        TypeScriptSubstitutionFlags[TypeScriptSubstitutionFlags["NamespaceExports"] = 2] = "NamespaceExports";
        /* Enables substitutions for unqualified enum members */
        TypeScriptSubstitutionFlags[TypeScriptSubstitutionFlags["NonQualifiedEnumMembers"] = 8] = "NonQualifiedEnumMembers";
    })(TypeScriptSubstitutionFlags || (TypeScriptSubstitutionFlags = {}));
    var ClassFacts;
    (function (ClassFacts) {
        ClassFacts[ClassFacts["None"] = 0] = "None";
        ClassFacts[ClassFacts["HasStaticInitializedProperties"] = 1] = "HasStaticInitializedProperties";
        ClassFacts[ClassFacts["HasConstructorDecorators"] = 2] = "HasConstructorDecorators";
        ClassFacts[ClassFacts["HasMemberDecorators"] = 4] = "HasMemberDecorators";
        ClassFacts[ClassFacts["IsExportOfNamespace"] = 8] = "IsExportOfNamespace";
        ClassFacts[ClassFacts["IsNamedExternalExport"] = 16] = "IsNamedExternalExport";
        ClassFacts[ClassFacts["IsDefaultExternalExport"] = 32] = "IsDefaultExternalExport";
        ClassFacts[ClassFacts["IsDerivedClass"] = 64] = "IsDerivedClass";
        ClassFacts[ClassFacts["UseImmediatelyInvokedFunctionExpression"] = 128] = "UseImmediatelyInvokedFunctionExpression";
        ClassFacts[ClassFacts["HasAnyDecorators"] = 6] = "HasAnyDecorators";
        ClassFacts[ClassFacts["NeedsName"] = 5] = "NeedsName";
        ClassFacts[ClassFacts["MayNeedImmediatelyInvokedFunctionExpression"] = 7] = "MayNeedImmediatelyInvokedFunctionExpression";
        ClassFacts[ClassFacts["IsExported"] = 56] = "IsExported";
    })(ClassFacts || (ClassFacts = {}));
    function transformTypeScript(context) {
        var factory = context.factory, emitHelpers = context.getEmitHelperFactory, startLexicalEnvironment = context.startLexicalEnvironment, resumeLexicalEnvironment = context.resumeLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment, hoistVariableDeclaration = context.hoistVariableDeclaration;
        var resolver = context.getEmitResolver();
        var compilerOptions = context.getCompilerOptions();
        var strictNullChecks = ts.getStrictOptionValue(compilerOptions, "strictNullChecks");
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var moduleKind = ts.getEmitModuleKind(compilerOptions);
        // Save the previous transformation hooks.
        var previousOnEmitNode = context.onEmitNode;
        var previousOnSubstituteNode = context.onSubstituteNode;
        // Set new transformation hooks.
        context.onEmitNode = onEmitNode;
        context.onSubstituteNode = onSubstituteNode;
        // Enable substitution for property/element access to emit const enum values.
        context.enableSubstitution(206 /* SyntaxKind.PropertyAccessExpression */);
        context.enableSubstitution(207 /* SyntaxKind.ElementAccessExpression */);
        // These variables contain state that changes as we descend into the tree.
        var currentSourceFile;
        var currentNamespace;
        var currentNamespaceContainerName;
        var currentLexicalScope;
        var currentNameScope;
        var currentScopeFirstDeclarationsOfName;
        var currentClassHasParameterProperties;
        /**
         * Keeps track of whether expression substitution has been enabled for specific edge cases.
         * They are persisted between each SourceFile transformation and should not be reset.
         */
        var enabledSubstitutions;
        /**
         * A map that keeps track of aliases created for classes with decorators to avoid issues
         * with the double-binding behavior of classes.
         */
        var classAliases;
        /**
         * Keeps track of whether we are within any containing namespaces when performing
         * just-in-time substitution while printing an expression identifier.
         */
        var applicableSubstitutions;
        return transformSourceFileOrBundle;
        function transformSourceFileOrBundle(node) {
            if (node.kind === 306 /* SyntaxKind.Bundle */) {
                return transformBundle(node);
            }
            return transformSourceFile(node);
        }
        function transformBundle(node) {
            return factory.createBundle(node.sourceFiles.map(transformSourceFile), ts.mapDefined(node.prepends, function (prepend) {
                if (prepend.kind === 308 /* SyntaxKind.InputFiles */) {
                    return ts.createUnparsedSourceFile(prepend, "js");
                }
                return prepend;
            }));
        }
        /**
         * Transform TypeScript-specific syntax in a SourceFile.
         *
         * @param node A SourceFile node.
         */
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            currentSourceFile = node;
            var visited = saveStateAndInvoke(node, visitSourceFile);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            currentSourceFile = undefined;
            return visited;
        }
        /**
         * Visits a node, saving and restoring state variables on the stack.
         *
         * @param node The node to visit.
         */
        function saveStateAndInvoke(node, f) {
            // Save state
            var savedCurrentScope = currentLexicalScope;
            var savedCurrentNameScope = currentNameScope;
            var savedCurrentScopeFirstDeclarationsOfName = currentScopeFirstDeclarationsOfName;
            var savedCurrentClassHasParameterProperties = currentClassHasParameterProperties;
            // Handle state changes before visiting a node.
            onBeforeVisitNode(node);
            var visited = f(node);
            // Restore state
            if (currentLexicalScope !== savedCurrentScope) {
                currentScopeFirstDeclarationsOfName = savedCurrentScopeFirstDeclarationsOfName;
            }
            currentLexicalScope = savedCurrentScope;
            currentNameScope = savedCurrentNameScope;
            currentClassHasParameterProperties = savedCurrentClassHasParameterProperties;
            return visited;
        }
        /**
         * Performs actions that should always occur immediately before visiting a node.
         *
         * @param node The node to visit.
         */
        function onBeforeVisitNode(node) {
            switch (node.kind) {
                case 305 /* SyntaxKind.SourceFile */:
                case 263 /* SyntaxKind.CaseBlock */:
                case 262 /* SyntaxKind.ModuleBlock */:
                case 235 /* SyntaxKind.Block */:
                    currentLexicalScope = node;
                    currentNameScope = undefined;
                    currentScopeFirstDeclarationsOfName = undefined;
                    break;
                case 257 /* SyntaxKind.ClassDeclaration */:
                case 256 /* SyntaxKind.FunctionDeclaration */:
                    if (ts.hasSyntacticModifier(node, 2 /* ModifierFlags.Ambient */)) {
                        break;
                    }
                    // Record these declarations provided that they have a name.
                    if (node.name) {
                        recordEmittedDeclarationInScope(node);
                    }
                    else {
                        // These nodes should always have names unless they are default-exports;
                        // however, class declaration parsing allows for undefined names, so syntactically invalid
                        // programs may also have an undefined name.
                        ts.Debug.assert(node.kind === 257 /* SyntaxKind.ClassDeclaration */ || ts.hasSyntacticModifier(node, 512 /* ModifierFlags.Default */));
                    }
                    if (ts.isClassDeclaration(node)) {
                        // XXX: should probably also cover interfaces and type aliases that can have type variables?
                        currentNameScope = node;
                    }
                    break;
            }
        }
        /**
         * General-purpose node visitor.
         *
         * @param node The node to visit.
         */
        function visitor(node) {
            return saveStateAndInvoke(node, visitorWorker);
        }
        /**
         * Visits and possibly transforms any node.
         *
         * @param node The node to visit.
         */
        function visitorWorker(node) {
            if (node.transformFlags & 1 /* TransformFlags.ContainsTypeScript */) {
                return visitTypeScript(node);
            }
            return node;
        }
        /**
         * Specialized visitor that visits the immediate children of a SourceFile.
         *
         * @param node The node to visit.
         */
        function sourceElementVisitor(node) {
            return saveStateAndInvoke(node, sourceElementVisitorWorker);
        }
        /**
         * Specialized visitor that visits the immediate children of a SourceFile.
         *
         * @param node The node to visit.
         */
        function sourceElementVisitorWorker(node) {
            switch (node.kind) {
                case 266 /* SyntaxKind.ImportDeclaration */:
                case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                case 271 /* SyntaxKind.ExportAssignment */:
                case 272 /* SyntaxKind.ExportDeclaration */:
                    return visitElidableStatement(node);
                default:
                    return visitorWorker(node);
            }
        }
        function visitElidableStatement(node) {
            var parsed = ts.getParseTreeNode(node);
            if (parsed !== node) {
                // If the node has been transformed by a `before` transformer, perform no ellision on it
                // As the type information we would attempt to lookup to perform ellision is potentially unavailable for the synthesized nodes
                // We do not reuse `visitorWorker`, as the ellidable statement syntax kinds are technically unrecognized by the switch-case in `visitTypeScript`,
                // and will trigger debug failures when debug verbosity is turned up
                if (node.transformFlags & 1 /* TransformFlags.ContainsTypeScript */) {
                    // This node contains TypeScript, so we should visit its children.
                    return ts.visitEachChild(node, visitor, context);
                }
                // Otherwise, we can just return the node
                return node;
            }
            switch (node.kind) {
                case 266 /* SyntaxKind.ImportDeclaration */:
                    return visitImportDeclaration(node);
                case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                    return visitImportEqualsDeclaration(node);
                case 271 /* SyntaxKind.ExportAssignment */:
                    return visitExportAssignment(node);
                case 272 /* SyntaxKind.ExportDeclaration */:
                    return visitExportDeclaration(node);
                default:
                    ts.Debug.fail("Unhandled ellided statement");
            }
        }
        /**
         * Specialized visitor that visits the immediate children of a namespace.
         *
         * @param node The node to visit.
         */
        function namespaceElementVisitor(node) {
            return saveStateAndInvoke(node, namespaceElementVisitorWorker);
        }
        /**
         * Specialized visitor that visits the immediate children of a namespace.
         *
         * @param node The node to visit.
         */
        function namespaceElementVisitorWorker(node) {
            if (node.kind === 272 /* SyntaxKind.ExportDeclaration */ ||
                node.kind === 266 /* SyntaxKind.ImportDeclaration */ ||
                node.kind === 267 /* SyntaxKind.ImportClause */ ||
                (node.kind === 265 /* SyntaxKind.ImportEqualsDeclaration */ &&
                    node.moduleReference.kind === 277 /* SyntaxKind.ExternalModuleReference */)) {
                // do not emit ES6 imports and exports since they are illegal inside a namespace
                return undefined;
            }
            else if (node.transformFlags & 1 /* TransformFlags.ContainsTypeScript */ || ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */)) {
                return visitTypeScript(node);
            }
            return node;
        }
        /**
         * Specialized visitor that visits the immediate children of a class with TypeScript syntax.
         *
         * @param node The node to visit.
         */
        function classElementVisitor(node) {
            return saveStateAndInvoke(node, classElementVisitorWorker);
        }
        /**
         * Specialized visitor that visits the immediate children of a class with TypeScript syntax.
         *
         * @param node The node to visit.
         */
        function classElementVisitorWorker(node) {
            switch (node.kind) {
                case 171 /* SyntaxKind.Constructor */:
                    return visitConstructor(node);
                case 167 /* SyntaxKind.PropertyDeclaration */:
                    // Property declarations are not TypeScript syntax, but they must be visited
                    // for the decorator transformation.
                    return visitPropertyDeclaration(node);
                case 176 /* SyntaxKind.IndexSignature */:
                case 172 /* SyntaxKind.GetAccessor */:
                case 173 /* SyntaxKind.SetAccessor */:
                case 169 /* SyntaxKind.MethodDeclaration */:
                case 170 /* SyntaxKind.ClassStaticBlockDeclaration */:
                    // Fallback to the default visit behavior.
                    return visitorWorker(node);
                case 234 /* SyntaxKind.SemicolonClassElement */:
                    return node;
                default:
                    return ts.Debug.failBadSyntaxKind(node);
            }
        }
        function modifierVisitor(node) {
            if (ts.modifierToFlag(node.kind) & 116958 /* ModifierFlags.TypeScriptModifier */) {
                return undefined;
            }
            else if (currentNamespace && node.kind === 93 /* SyntaxKind.ExportKeyword */) {
                return undefined;
            }
            return node;
        }
        /**
         * Branching visitor, visits a TypeScript syntax node.
         *
         * @param node The node to visit.
         */
        function visitTypeScript(node) {
            if (ts.isStatement(node) && ts.hasSyntacticModifier(node, 2 /* ModifierFlags.Ambient */)) {
                // TypeScript ambient declarations are elided, but some comments may be preserved.
                // See the implementation of `getLeadingComments` in comments.ts for more details.
                return factory.createNotEmittedStatement(node);
            }
            switch (node.kind) {
                case 93 /* SyntaxKind.ExportKeyword */:
                case 88 /* SyntaxKind.DefaultKeyword */:
                    // ES6 export and default modifiers are elided when inside a namespace.
                    return currentNamespace ? undefined : node;
                case 123 /* SyntaxKind.PublicKeyword */:
                case 121 /* SyntaxKind.PrivateKeyword */:
                case 122 /* SyntaxKind.ProtectedKeyword */:
                case 126 /* SyntaxKind.AbstractKeyword */:
                case 159 /* SyntaxKind.OverrideKeyword */:
                case 85 /* SyntaxKind.ConstKeyword */:
                case 135 /* SyntaxKind.DeclareKeyword */:
                case 145 /* SyntaxKind.ReadonlyKeyword */:
                case 101 /* SyntaxKind.InKeyword */:
                case 144 /* SyntaxKind.OutKeyword */:
                // TypeScript accessibility and readonly modifiers are elided
                // falls through
                case 183 /* SyntaxKind.ArrayType */:
                case 184 /* SyntaxKind.TupleType */:
                case 185 /* SyntaxKind.OptionalType */:
                case 186 /* SyntaxKind.RestType */:
                case 182 /* SyntaxKind.TypeLiteral */:
                case 177 /* SyntaxKind.TypePredicate */:
                case 163 /* SyntaxKind.TypeParameter */:
                case 130 /* SyntaxKind.AnyKeyword */:
                case 155 /* SyntaxKind.UnknownKeyword */:
                case 133 /* SyntaxKind.BooleanKeyword */:
                case 150 /* SyntaxKind.StringKeyword */:
                case 147 /* SyntaxKind.NumberKeyword */:
                case 143 /* SyntaxKind.NeverKeyword */:
                case 114 /* SyntaxKind.VoidKeyword */:
                case 151 /* SyntaxKind.SymbolKeyword */:
                case 180 /* SyntaxKind.ConstructorType */:
                case 179 /* SyntaxKind.FunctionType */:
                case 181 /* SyntaxKind.TypeQuery */:
                case 178 /* SyntaxKind.TypeReference */:
                case 187 /* SyntaxKind.UnionType */:
                case 188 /* SyntaxKind.IntersectionType */:
                case 189 /* SyntaxKind.ConditionalType */:
                case 191 /* SyntaxKind.ParenthesizedType */:
                case 192 /* SyntaxKind.ThisType */:
                case 193 /* SyntaxKind.TypeOperator */:
                case 194 /* SyntaxKind.IndexedAccessType */:
                case 195 /* SyntaxKind.MappedType */:
                case 196 /* SyntaxKind.LiteralType */:
                // TypeScript type nodes are elided.
                // falls through
                case 176 /* SyntaxKind.IndexSignature */:
                // TypeScript index signatures are elided.
                // falls through
                case 165 /* SyntaxKind.Decorator */:
                    // TypeScript decorators are elided. They will be emitted as part of visitClassDeclaration.
                    return undefined;
                case 259 /* SyntaxKind.TypeAliasDeclaration */:
                    // TypeScript type-only declarations are elided.
                    return factory.createNotEmittedStatement(node);
                case 167 /* SyntaxKind.PropertyDeclaration */:
                    // TypeScript property declarations are elided. However their names are still visited, and can potentially be retained if they could have sideeffects
                    return visitPropertyDeclaration(node);
                case 264 /* SyntaxKind.NamespaceExportDeclaration */:
                    // TypeScript namespace export declarations are elided.
                    return undefined;
                case 171 /* SyntaxKind.Constructor */:
                    return visitConstructor(node);
                case 258 /* SyntaxKind.InterfaceDeclaration */:
                    // TypeScript interfaces are elided, but some comments may be preserved.
                    // See the implementation of `getLeadingComments` in comments.ts for more details.
                    return factory.createNotEmittedStatement(node);
                case 257 /* SyntaxKind.ClassDeclaration */:
                    // This may be a class declaration with TypeScript syntax extensions.
                    //
                    // TypeScript class syntax extensions include:
                    // - decorators
                    // - optional `implements` heritage clause
                    // - parameter property assignments in the constructor
                    // - index signatures
                    // - method overload signatures
                    return visitClassDeclaration(node);
                case 226 /* SyntaxKind.ClassExpression */:
                    // This may be a class expression with TypeScript syntax extensions.
                    //
                    // TypeScript class syntax extensions include:
                    // - decorators
                    // - optional `implements` heritage clause
                    // - parameter property assignments in the constructor
                    // - index signatures
                    // - method overload signatures
                    return visitClassExpression(node);
                case 291 /* SyntaxKind.HeritageClause */:
                    // This may be a heritage clause with TypeScript syntax extensions.
                    //
                    // TypeScript heritage clause extensions include:
                    // - `implements` clause
                    return visitHeritageClause(node);
                case 228 /* SyntaxKind.ExpressionWithTypeArguments */:
                    // TypeScript supports type arguments on an expression in an `extends` heritage clause.
                    return visitExpressionWithTypeArguments(node);
                case 169 /* SyntaxKind.MethodDeclaration */:
                    // TypeScript method declarations may have decorators, modifiers
                    // or type annotations.
                    return visitMethodDeclaration(node);
                case 172 /* SyntaxKind.GetAccessor */:
                    // Get Accessors can have TypeScript modifiers, decorators, and type annotations.
                    return visitGetAccessor(node);
                case 173 /* SyntaxKind.SetAccessor */:
                    // Set Accessors can have TypeScript modifiers and type annotations.
                    return visitSetAccessor(node);
                case 256 /* SyntaxKind.FunctionDeclaration */:
                    // Typescript function declarations can have modifiers, decorators, and type annotations.
                    return visitFunctionDeclaration(node);
                case 213 /* SyntaxKind.FunctionExpression */:
                    // TypeScript function expressions can have modifiers and type annotations.
                    return visitFunctionExpression(node);
                case 214 /* SyntaxKind.ArrowFunction */:
                    // TypeScript arrow functions can have modifiers and type annotations.
                    return visitArrowFunction(node);
                case 164 /* SyntaxKind.Parameter */:
                    // This may be a parameter declaration with TypeScript syntax extensions.
                    //
                    // TypeScript parameter declaration syntax extensions include:
                    // - decorators
                    // - accessibility modifiers
                    // - the question mark (?) token for optional parameters
                    // - type annotations
                    // - this parameters
                    return visitParameter(node);
                case 212 /* SyntaxKind.ParenthesizedExpression */:
                    // ParenthesizedExpressions are TypeScript if their expression is a
                    // TypeAssertion or AsExpression
                    return visitParenthesizedExpression(node);
                case 211 /* SyntaxKind.TypeAssertionExpression */:
                case 229 /* SyntaxKind.AsExpression */:
                    // TypeScript type assertions are removed, but their subtrees are preserved.
                    return visitAssertionExpression(node);
                case 208 /* SyntaxKind.CallExpression */:
                    return visitCallExpression(node);
                case 209 /* SyntaxKind.NewExpression */:
                    return visitNewExpression(node);
                case 210 /* SyntaxKind.TaggedTemplateExpression */:
                    return visitTaggedTemplateExpression(node);
                case 230 /* SyntaxKind.NonNullExpression */:
                    // TypeScript non-null expressions are removed, but their subtrees are preserved.
                    return visitNonNullExpression(node);
                case 260 /* SyntaxKind.EnumDeclaration */:
                    // TypeScript enum declarations do not exist in ES6 and must be rewritten.
                    return visitEnumDeclaration(node);
                case 237 /* SyntaxKind.VariableStatement */:
                    // TypeScript namespace exports for variable statements must be transformed.
                    return visitVariableStatement(node);
                case 254 /* SyntaxKind.VariableDeclaration */:
                    return visitVariableDeclaration(node);
                case 261 /* SyntaxKind.ModuleDeclaration */:
                    // TypeScript namespace declarations must be transformed.
                    return visitModuleDeclaration(node);
                case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                    // TypeScript namespace or external module import.
                    return visitImportEqualsDeclaration(node);
                case 279 /* SyntaxKind.JsxSelfClosingElement */:
                    return visitJsxSelfClosingElement(node);
                case 280 /* SyntaxKind.JsxOpeningElement */:
                    return visitJsxJsxOpeningElement(node);
                default:
                    // node contains some other TypeScript syntax
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitSourceFile(node) {
            var alwaysStrict = ts.getStrictOptionValue(compilerOptions, "alwaysStrict") &&
                !(ts.isExternalModule(node) && moduleKind >= ts.ModuleKind.ES2015) &&
                !ts.isJsonSourceFile(node);
            return factory.updateSourceFile(node, ts.visitLexicalEnvironment(node.statements, sourceElementVisitor, context, /*start*/ 0, alwaysStrict));
        }
        function getClassFacts(node, staticProperties) {
            var facts = 0 /* ClassFacts.None */;
            if (ts.some(staticProperties))
                facts |= 1 /* ClassFacts.HasStaticInitializedProperties */;
            var extendsClauseElement = ts.getEffectiveBaseTypeNode(node);
            if (extendsClauseElement && ts.skipOuterExpressions(extendsClauseElement.expression).kind !== 104 /* SyntaxKind.NullKeyword */)
                facts |= 64 /* ClassFacts.IsDerivedClass */;
            if (ts.classOrConstructorParameterIsDecorated(node))
                facts |= 2 /* ClassFacts.HasConstructorDecorators */;
            if (ts.childIsDecorated(node))
                facts |= 4 /* ClassFacts.HasMemberDecorators */;
            if (isExportOfNamespace(node))
                facts |= 8 /* ClassFacts.IsExportOfNamespace */;
            else if (isDefaultExternalModuleExport(node))
                facts |= 32 /* ClassFacts.IsDefaultExternalExport */;
            else if (isNamedExternalModuleExport(node))
                facts |= 16 /* ClassFacts.IsNamedExternalExport */;
            if (languageVersion <= 1 /* ScriptTarget.ES5 */ && (facts & 7 /* ClassFacts.MayNeedImmediatelyInvokedFunctionExpression */))
                facts |= 128 /* ClassFacts.UseImmediatelyInvokedFunctionExpression */;
            return facts;
        }
        function hasTypeScriptClassSyntax(node) {
            return !!(node.transformFlags & 4096 /* TransformFlags.ContainsTypeScriptClassSyntax */);
        }
        function isClassLikeDeclarationWithTypeScriptSyntax(node) {
            return ts.some(node.decorators)
                || ts.some(node.typeParameters)
                || ts.some(node.heritageClauses, hasTypeScriptClassSyntax)
                || ts.some(node.members, hasTypeScriptClassSyntax);
        }
        function visitClassDeclaration(node) {
            if (!isClassLikeDeclarationWithTypeScriptSyntax(node) && !(currentNamespace && ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */))) {
                return ts.visitEachChild(node, visitor, context);
            }
            var staticProperties = ts.getProperties(node, /*requireInitializer*/ true, /*isStatic*/ true);
            var facts = getClassFacts(node, staticProperties);
            if (facts & 128 /* ClassFacts.UseImmediatelyInvokedFunctionExpression */) {
                context.startLexicalEnvironment();
            }
            var name = node.name || (facts & 5 /* ClassFacts.NeedsName */ ? factory.getGeneratedNameForNode(node) : undefined);
            var classStatement = facts & 2 /* ClassFacts.HasConstructorDecorators */
                ? createClassDeclarationHeadWithDecorators(node, name)
                : createClassDeclarationHeadWithoutDecorators(node, name, facts);
            var statements = [classStatement];
            // Write any decorators of the node.
            addClassElementDecorationStatements(statements, node, /*isStatic*/ false);
            addClassElementDecorationStatements(statements, node, /*isStatic*/ true);
            addConstructorDecorationStatement(statements, node);
            if (facts & 128 /* ClassFacts.UseImmediatelyInvokedFunctionExpression */) {
                // When we emit a TypeScript class down to ES5, we must wrap it in an IIFE so that the
                // 'es2015' transformer can properly nest static initializers and decorators. The result
                // looks something like:
                //
                //  var C = function () {
                //      class C {
                //      }
                //      C.static_prop = 1;
                //      return C;
                //  }();
                //
                var closingBraceLocation = ts.createTokenRange(ts.skipTrivia(currentSourceFile.text, node.members.end), 19 /* SyntaxKind.CloseBraceToken */);
                var localName = factory.getInternalName(node);
                // The following partially-emitted expression exists purely to align our sourcemap
                // emit with the original emitter.
                var outer = factory.createPartiallyEmittedExpression(localName);
                ts.setTextRangeEnd(outer, closingBraceLocation.end);
                ts.setEmitFlags(outer, 1536 /* EmitFlags.NoComments */);
                var statement = factory.createReturnStatement(outer);
                ts.setTextRangePos(statement, closingBraceLocation.pos);
                ts.setEmitFlags(statement, 1536 /* EmitFlags.NoComments */ | 384 /* EmitFlags.NoTokenSourceMaps */);
                statements.push(statement);
                ts.insertStatementsAfterStandardPrologue(statements, context.endLexicalEnvironment());
                var iife = factory.createImmediatelyInvokedArrowFunction(statements);
                ts.setEmitFlags(iife, 33554432 /* EmitFlags.TypeScriptClassWrapper */);
                var varStatement = factory.createVariableStatement(
                /*modifiers*/ undefined, factory.createVariableDeclarationList([
                    factory.createVariableDeclaration(factory.getLocalName(node, /*allowComments*/ false, /*allowSourceMaps*/ false), 
                    /*exclamationToken*/ undefined, 
                    /*type*/ undefined, iife)
                ]));
                ts.setOriginalNode(varStatement, node);
                ts.setCommentRange(varStatement, node);
                ts.setSourceMapRange(varStatement, ts.moveRangePastDecorators(node));
                ts.startOnNewLine(varStatement);
                statements = [varStatement];
            }
            // If the class is exported as part of a TypeScript namespace, emit the namespace export.
            // Otherwise, if the class was exported at the top level and was decorated, emit an export
            // declaration or export default for the class.
            if (facts & 8 /* ClassFacts.IsExportOfNamespace */) {
                addExportMemberAssignment(statements, node);
            }
            else if (facts & 128 /* ClassFacts.UseImmediatelyInvokedFunctionExpression */ || facts & 2 /* ClassFacts.HasConstructorDecorators */) {
                if (facts & 32 /* ClassFacts.IsDefaultExternalExport */) {
                    statements.push(factory.createExportDefault(factory.getLocalName(node, /*allowComments*/ false, /*allowSourceMaps*/ true)));
                }
                else if (facts & 16 /* ClassFacts.IsNamedExternalExport */) {
                    statements.push(factory.createExternalModuleExport(factory.getLocalName(node, /*allowComments*/ false, /*allowSourceMaps*/ true)));
                }
            }
            if (statements.length > 1) {
                // Add a DeclarationMarker as a marker for the end of the declaration
                statements.push(factory.createEndOfDeclarationMarker(node));
                ts.setEmitFlags(classStatement, ts.getEmitFlags(classStatement) | 4194304 /* EmitFlags.HasEndOfDeclarationMarker */);
            }
            return ts.singleOrMany(statements);
        }
        /**
         * Transforms a non-decorated class declaration and appends the resulting statements.
         *
         * @param node A ClassDeclaration node.
         * @param name The name of the class.
         * @param facts Precomputed facts about the class.
         */
        function createClassDeclarationHeadWithoutDecorators(node, name, facts) {
            //  ${modifiers} class ${name} ${heritageClauses} {
            //      ${members}
            //  }
            // we do not emit modifiers on the declaration if we are emitting an IIFE
            var modifiers = !(facts & 128 /* ClassFacts.UseImmediatelyInvokedFunctionExpression */)
                ? ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier)
                : undefined;
            var classDeclaration = factory.createClassDeclaration(
            /*decorators*/ undefined, modifiers, name, 
            /*typeParameters*/ undefined, ts.visitNodes(node.heritageClauses, visitor, ts.isHeritageClause), transformClassMembers(node));
            // To better align with the old emitter, we should not emit a trailing source map
            // entry if the class has static properties.
            var emitFlags = ts.getEmitFlags(node);
            if (facts & 1 /* ClassFacts.HasStaticInitializedProperties */) {
                emitFlags |= 32 /* EmitFlags.NoTrailingSourceMap */;
            }
            ts.setTextRange(classDeclaration, node);
            ts.setOriginalNode(classDeclaration, node);
            ts.setEmitFlags(classDeclaration, emitFlags);
            return classDeclaration;
        }
        /**
         * Transforms a decorated class declaration and appends the resulting statements. If
         * the class requires an alias to avoid issues with double-binding, the alias is returned.
         */
        function createClassDeclarationHeadWithDecorators(node, name) {
            // When we emit an ES6 class that has a class decorator, we must tailor the
            // emit to certain specific cases.
            //
            // In the simplest case, we emit the class declaration as a let declaration, and
            // evaluate decorators after the close of the class body:
            //
            //  [Example 1]
            //  ---------------------------------------------------------------------
            //  TypeScript                      | Javascript
            //  ---------------------------------------------------------------------
            //  @dec                            | let C = class C {
            //  class C {                       | }
            //  }                               | C = __decorate([dec], C);
            //  ---------------------------------------------------------------------
            //  @dec                            | let C = class C {
            //  export class C {                | }
            //  }                               | C = __decorate([dec], C);
            //                                  | export { C };
            //  ---------------------------------------------------------------------
            //
            // If a class declaration contains a reference to itself *inside* of the class body,
            // this introduces two bindings to the class: One outside of the class body, and one
            // inside of the class body. If we apply decorators as in [Example 1] above, there
            // is the possibility that the decorator `dec` will return a new value for the
            // constructor, which would result in the binding inside of the class no longer
            // pointing to the same reference as the binding outside of the class.
            //
            // As a result, we must instead rewrite all references to the class *inside* of the
            // class body to instead point to a local temporary alias for the class:
            //
            //  [Example 2]
            //  ---------------------------------------------------------------------
            //  TypeScript                      | Javascript
            //  ---------------------------------------------------------------------
            //  @dec                            | let C = C_1 = class C {
            //  class C {                       |   static x() { return C_1.y; }
            //    static x() { return C.y; }    | }
            //    static y = 1;                 | C.y = 1;
            //  }                               | C = C_1 = __decorate([dec], C);
            //                                  | var C_1;
            //  ---------------------------------------------------------------------
            //  @dec                            | let C = class C {
            //  export class C {                |   static x() { return C_1.y; }
            //    static x() { return C.y; }    | }
            //    static y = 1;                 | C.y = 1;
            //  }                               | C = C_1 = __decorate([dec], C);
            //                                  | export { C };
            //                                  | var C_1;
            //  ---------------------------------------------------------------------
            //
            // If a class declaration is the default export of a module, we instead emit
            // the export after the decorated declaration:
            //
            //  [Example 3]
            //  ---------------------------------------------------------------------
            //  TypeScript                      | Javascript
            //  ---------------------------------------------------------------------
            //  @dec                            | let default_1 = class {
            //  export default class {          | }
            //  }                               | default_1 = __decorate([dec], default_1);
            //                                  | export default default_1;
            //  ---------------------------------------------------------------------
            //  @dec                            | let C = class C {
            //  export default class C {        | }
            //  }                               | C = __decorate([dec], C);
            //                                  | export default C;
            //  ---------------------------------------------------------------------
            //
            // If the class declaration is the default export and a reference to itself
            // inside of the class body, we must emit both an alias for the class *and*
            // move the export after the declaration:
            //
            //  [Example 4]
            //  ---------------------------------------------------------------------
            //  TypeScript                      | Javascript
            //  ---------------------------------------------------------------------
            //  @dec                            | let C = class C {
            //  export default class C {        |   static x() { return C_1.y; }
            //    static x() { return C.y; }    | }
            //    static y = 1;                 | C.y = 1;
            //  }                               | C = C_1 = __decorate([dec], C);
            //                                  | export default C;
            //                                  | var C_1;
            //  ---------------------------------------------------------------------
            //
            var location = ts.moveRangePastDecorators(node);
            var classAlias = getClassAliasIfNeeded(node);
            // When we transform to ES5/3 this will be moved inside an IIFE and should reference the name
            // without any block-scoped variable collision handling
            var declName = languageVersion <= 2 /* ScriptTarget.ES2015 */ ?
                factory.getInternalName(node, /*allowComments*/ false, /*allowSourceMaps*/ true) :
                factory.getLocalName(node, /*allowComments*/ false, /*allowSourceMaps*/ true);
            //  ... = class ${name} ${heritageClauses} {
            //      ${members}
            //  }
            var heritageClauses = ts.visitNodes(node.heritageClauses, visitor, ts.isHeritageClause);
            var members = transformClassMembers(node);
            var classExpression = factory.createClassExpression(/*decorators*/ undefined, /*modifiers*/ undefined, name, /*typeParameters*/ undefined, heritageClauses, members);
            ts.setOriginalNode(classExpression, node);
            ts.setTextRange(classExpression, location);
            //  let ${name} = ${classExpression} where name is either declaredName if the class doesn't contain self-reference
            //                                         or decoratedClassAlias if the class contain self-reference.
            var statement = factory.createVariableStatement(
            /*modifiers*/ undefined, factory.createVariableDeclarationList([
                factory.createVariableDeclaration(declName, 
                /*exclamationToken*/ undefined, 
                /*type*/ undefined, classAlias ? factory.createAssignment(classAlias, classExpression) : classExpression)
            ], 1 /* NodeFlags.Let */));
            ts.setOriginalNode(statement, node);
            ts.setTextRange(statement, location);
            ts.setCommentRange(statement, node);
            return statement;
        }
        function visitClassExpression(node) {
            if (!isClassLikeDeclarationWithTypeScriptSyntax(node)) {
                return ts.visitEachChild(node, visitor, context);
            }
            var classExpression = factory.createClassExpression(
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, node.name, 
            /*typeParameters*/ undefined, ts.visitNodes(node.heritageClauses, visitor, ts.isHeritageClause), transformClassMembers(node));
            ts.setOriginalNode(classExpression, node);
            ts.setTextRange(classExpression, node);
            return classExpression;
        }
        /**
         * Transforms the members of a class.
         *
         * @param node The current class.
         */
        function transformClassMembers(node) {
            var members = [];
            var constructor = ts.getFirstConstructorWithBody(node);
            var parametersWithPropertyAssignments = constructor &&
                ts.filter(constructor.parameters, function (p) { return ts.isParameterPropertyDeclaration(p, constructor); });
            if (parametersWithPropertyAssignments) {
                for (var _i = 0, parametersWithPropertyAssignments_1 = parametersWithPropertyAssignments; _i < parametersWithPropertyAssignments_1.length; _i++) {
                    var parameter = parametersWithPropertyAssignments_1[_i];
                    if (ts.isIdentifier(parameter.name)) {
                        members.push(ts.setOriginalNode(factory.createPropertyDeclaration(
                        /*decorators*/ undefined, 
                        /*modifiers*/ undefined, parameter.name, 
                        /*questionOrExclamationToken*/ undefined, 
                        /*type*/ undefined, 
                        /*initializer*/ undefined), parameter));
                    }
                }
            }
            ts.addRange(members, ts.visitNodes(node.members, classElementVisitor, ts.isClassElement));
            return ts.setTextRange(factory.createNodeArray(members), /*location*/ node.members);
        }
        /**
         * Gets either the static or instance members of a class that are decorated, or have
         * parameters that are decorated.
         *
         * @param node The class containing the member.
         * @param isStatic A value indicating whether to retrieve static or instance members of
         *                 the class.
         */
        function getDecoratedClassElements(node, isStatic) {
            return ts.filter(node.members, isStatic ? function (m) { return isStaticDecoratedClassElement(m, node); } : function (m) { return isInstanceDecoratedClassElement(m, node); });
        }
        /**
         * Determines whether a class member is a static member of a class that is decorated, or
         * has parameters that are decorated.
         *
         * @param member The class member.
         */
        function isStaticDecoratedClassElement(member, parent) {
            return isDecoratedClassElement(member, /*isStaticElement*/ true, parent);
        }
        /**
         * Determines whether a class member is an instance member of a class that is decorated,
         * or has parameters that are decorated.
         *
         * @param member The class member.
         */
        function isInstanceDecoratedClassElement(member, parent) {
            return isDecoratedClassElement(member, /*isStaticElement*/ false, parent);
        }
        /**
         * Determines whether a class member is either a static or an instance member of a class
         * that is decorated, or has parameters that are decorated.
         *
         * @param member The class member.
         */
        function isDecoratedClassElement(member, isStaticElement, parent) {
            return ts.nodeOrChildIsDecorated(member, parent)
                && isStaticElement === ts.isStatic(member);
        }
        /**
         * Gets an array of arrays of decorators for the parameters of a function-like node.
         * The offset into the result array should correspond to the offset of the parameter.
         *
         * @param node The function-like node.
         */
        function getDecoratorsOfParameters(node) {
            var decorators;
            if (node) {
                var parameters = node.parameters;
                var firstParameterIsThis = parameters.length > 0 && ts.parameterIsThisKeyword(parameters[0]);
                var firstParameterOffset = firstParameterIsThis ? 1 : 0;
                var numParameters = firstParameterIsThis ? parameters.length - 1 : parameters.length;
                for (var i = 0; i < numParameters; i++) {
                    var parameter = parameters[i + firstParameterOffset];
                    if (decorators || parameter.decorators) {
                        if (!decorators) {
                            decorators = new Array(numParameters);
                        }
                        decorators[i] = parameter.decorators;
                    }
                }
            }
            return decorators;
        }
        /**
         * Gets an AllDecorators object containing the decorators for the class and the decorators for the
         * parameters of the constructor of the class.
         *
         * @param node The class node.
         */
        function getAllDecoratorsOfConstructor(node) {
            var decorators = node.decorators;
            var parameters = getDecoratorsOfParameters(ts.getFirstConstructorWithBody(node));
            if (!decorators && !parameters) {
                return undefined;
            }
            return {
                decorators: decorators,
                parameters: parameters
            };
        }
        /**
         * Gets an AllDecorators object containing the decorators for the member and its parameters.
         *
         * @param node The class node that contains the member.
         * @param member The class member.
         */
        function getAllDecoratorsOfClassElement(node, member) {
            switch (member.kind) {
                case 172 /* SyntaxKind.GetAccessor */:
                case 173 /* SyntaxKind.SetAccessor */:
                    return getAllDecoratorsOfAccessors(node, member);
                case 169 /* SyntaxKind.MethodDeclaration */:
                    return getAllDecoratorsOfMethod(member);
                case 167 /* SyntaxKind.PropertyDeclaration */:
                    return getAllDecoratorsOfProperty(member);
                default:
                    return undefined;
            }
        }
        /**
         * Gets an AllDecorators object containing the decorators for the accessor and its parameters.
         *
         * @param node The class node that contains the accessor.
         * @param accessor The class accessor member.
         */
        function getAllDecoratorsOfAccessors(node, accessor) {
            if (!accessor.body) {
                return undefined;
            }
            var _a = ts.getAllAccessorDeclarations(node.members, accessor), firstAccessor = _a.firstAccessor, secondAccessor = _a.secondAccessor, setAccessor = _a.setAccessor;
            var firstAccessorWithDecorators = firstAccessor.decorators ? firstAccessor : secondAccessor && secondAccessor.decorators ? secondAccessor : undefined;
            if (!firstAccessorWithDecorators || accessor !== firstAccessorWithDecorators) {
                return undefined;
            }
            var decorators = firstAccessorWithDecorators.decorators;
            var parameters = getDecoratorsOfParameters(setAccessor);
            if (!decorators && !parameters) {
                return undefined;
            }
            return { decorators: decorators, parameters: parameters };
        }
        /**
         * Gets an AllDecorators object containing the decorators for the method and its parameters.
         *
         * @param method The class method member.
         */
        function getAllDecoratorsOfMethod(method) {
            if (!method.body) {
                return undefined;
            }
            var decorators = method.decorators;
            var parameters = getDecoratorsOfParameters(method);
            if (!decorators && !parameters) {
                return undefined;
            }
            return { decorators: decorators, parameters: parameters };
        }
        /**
         * Gets an AllDecorators object containing the decorators for the property.
         *
         * @param property The class property member.
         */
        function getAllDecoratorsOfProperty(property) {
            var decorators = property.decorators;
            if (!decorators) {
                return undefined;
            }
            return { decorators: decorators };
        }
        /**
         * Transforms all of the decorators for a declaration into an array of expressions.
         *
         * @param node The declaration node.
         * @param allDecorators An object containing all of the decorators for the declaration.
         */
        function transformAllDecoratorsOfDeclaration(node, container, allDecorators) {
            if (!allDecorators) {
                return undefined;
            }
            var decoratorExpressions = [];
            ts.addRange(decoratorExpressions, ts.map(allDecorators.decorators, transformDecorator));
            ts.addRange(decoratorExpressions, ts.flatMap(allDecorators.parameters, transformDecoratorsOfParameter));
            addTypeMetadata(node, container, decoratorExpressions);
            return decoratorExpressions;
        }
        /**
         * Generates statements used to apply decorators to either the static or instance members
         * of a class.
         *
         * @param node The class node.
         * @param isStatic A value indicating whether to generate statements for static or
         *                 instance members.
         */
        function addClassElementDecorationStatements(statements, node, isStatic) {
            ts.addRange(statements, ts.map(generateClassElementDecorationExpressions(node, isStatic), expressionToStatement));
        }
        /**
         * Generates expressions used to apply decorators to either the static or instance members
         * of a class.
         *
         * @param node The class node.
         * @param isStatic A value indicating whether to generate expressions for static or
         *                 instance members.
         */
        function generateClassElementDecorationExpressions(node, isStatic) {
            var members = getDecoratedClassElements(node, isStatic);
            var expressions;
            for (var _i = 0, members_8 = members; _i < members_8.length; _i++) {
                var member = members_8[_i];
                var expression = generateClassElementDecorationExpression(node, member);
                if (expression) {
                    if (!expressions) {
                        expressions = [expression];
                    }
                    else {
                        expressions.push(expression);
                    }
                }
            }
            return expressions;
        }
        /**
         * Generates an expression used to evaluate class element decorators at runtime.
         *
         * @param node The class node that contains the member.
         * @param member The class member.
         */
        function generateClassElementDecorationExpression(node, member) {
            var allDecorators = getAllDecoratorsOfClassElement(node, member);
            var decoratorExpressions = transformAllDecoratorsOfDeclaration(member, node, allDecorators);
            if (!decoratorExpressions) {
                return undefined;
            }
            // Emit the call to __decorate. Given the following:
            //
            //   class C {
            //     @dec method(@dec2 x) {}
            //     @dec get accessor() {}
            //     @dec prop;
            //   }
            //
            // The emit for a method is:
            //
            //   __decorate([
            //       dec,
            //       __param(0, dec2),
            //       __metadata("design:type", Function),
            //       __metadata("design:paramtypes", [Object]),
            //       __metadata("design:returntype", void 0)
            //   ], C.prototype, "method", null);
            //
            // The emit for an accessor is:
            //
            //   __decorate([
            //       dec
            //   ], C.prototype, "accessor", null);
            //
            // The emit for a property is:
            //
            //   __decorate([
            //       dec
            //   ], C.prototype, "prop");
            //
            var prefix = getClassMemberPrefix(node, member);
            var memberName = getExpressionForPropertyName(member, /*generateNameForComputedPropertyName*/ !ts.hasSyntacticModifier(member, 2 /* ModifierFlags.Ambient */));
            var descriptor = languageVersion > 0 /* ScriptTarget.ES3 */
                ? member.kind === 167 /* SyntaxKind.PropertyDeclaration */
                    // We emit `void 0` here to indicate to `__decorate` that it can invoke `Object.defineProperty` directly, but that it
                    // should not invoke `Object.getOwnPropertyDescriptor`.
                    ? factory.createVoidZero()
                    // We emit `null` here to indicate to `__decorate` that it can invoke `Object.getOwnPropertyDescriptor` directly.
                    // We have this extra argument here so that we can inject an explicit property descriptor at a later date.
                    : factory.createNull()
                : undefined;
            var helper = emitHelpers().createDecorateHelper(decoratorExpressions, prefix, memberName, descriptor);
            ts.setTextRange(helper, ts.moveRangePastDecorators(member));
            ts.setEmitFlags(helper, 1536 /* EmitFlags.NoComments */);
            return helper;
        }
        /**
         * Generates a __decorate helper call for a class constructor.
         *
         * @param node The class node.
         */
        function addConstructorDecorationStatement(statements, node) {
            var expression = generateConstructorDecorationExpression(node);
            if (expression) {
                statements.push(ts.setOriginalNode(factory.createExpressionStatement(expression), node));
            }
        }
        /**
         * Generates a __decorate helper call for a class constructor.
         *
         * @param node The class node.
         */
        function generateConstructorDecorationExpression(node) {
            var allDecorators = getAllDecoratorsOfConstructor(node);
            var decoratorExpressions = transformAllDecoratorsOfDeclaration(node, node, allDecorators);
            if (!decoratorExpressions) {
                return undefined;
            }
            var classAlias = classAliases && classAliases[ts.getOriginalNodeId(node)];
            // When we transform to ES5/3 this will be moved inside an IIFE and should reference the name
            // without any block-scoped variable collision handling
            var localName = languageVersion <= 2 /* ScriptTarget.ES2015 */ ?
                factory.getInternalName(node, /*allowComments*/ false, /*allowSourceMaps*/ true) :
                factory.getLocalName(node, /*allowComments*/ false, /*allowSourceMaps*/ true);
            var decorate = emitHelpers().createDecorateHelper(decoratorExpressions, localName);
            var expression = factory.createAssignment(localName, classAlias ? factory.createAssignment(classAlias, decorate) : decorate);
            ts.setEmitFlags(expression, 1536 /* EmitFlags.NoComments */);
            ts.setSourceMapRange(expression, ts.moveRangePastDecorators(node));
            return expression;
        }
        /**
         * Transforms a decorator into an expression.
         *
         * @param decorator The decorator node.
         */
        function transformDecorator(decorator) {
            return ts.visitNode(decorator.expression, visitor, ts.isExpression);
        }
        /**
         * Transforms the decorators of a parameter.
         *
         * @param decorators The decorators for the parameter at the provided offset.
         * @param parameterOffset The offset of the parameter.
         */
        function transformDecoratorsOfParameter(decorators, parameterOffset) {
            var expressions;
            if (decorators) {
                expressions = [];
                for (var _i = 0, decorators_1 = decorators; _i < decorators_1.length; _i++) {
                    var decorator = decorators_1[_i];
                    var helper = emitHelpers().createParamHelper(transformDecorator(decorator), parameterOffset);
                    ts.setTextRange(helper, decorator.expression);
                    ts.setEmitFlags(helper, 1536 /* EmitFlags.NoComments */);
                    expressions.push(helper);
                }
            }
            return expressions;
        }
        /**
         * Adds optional type metadata for a declaration.
         *
         * @param node The declaration node.
         * @param decoratorExpressions The destination array to which to add new decorator expressions.
         */
        function addTypeMetadata(node, container, decoratorExpressions) {
            if (USE_NEW_TYPE_METADATA_FORMAT) {
                addNewTypeMetadata(node, container, decoratorExpressions);
            }
            else {
                addOldTypeMetadata(node, container, decoratorExpressions);
            }
        }
        function addOldTypeMetadata(node, container, decoratorExpressions) {
            if (compilerOptions.emitDecoratorMetadata) {
                if (shouldAddTypeMetadata(node)) {
                    decoratorExpressions.push(emitHelpers().createMetadataHelper("design:type", serializeTypeOfNode(node)));
                }
                if (shouldAddParamTypesMetadata(node)) {
                    decoratorExpressions.push(emitHelpers().createMetadataHelper("design:paramtypes", serializeParameterTypesOfNode(node, container)));
                }
                if (shouldAddReturnTypeMetadata(node)) {
                    decoratorExpressions.push(emitHelpers().createMetadataHelper("design:returntype", serializeReturnTypeOfNode(node)));
                }
            }
        }
        function addNewTypeMetadata(node, container, decoratorExpressions) {
            if (compilerOptions.emitDecoratorMetadata) {
                var properties = void 0;
                if (shouldAddTypeMetadata(node)) {
                    (properties || (properties = [])).push(factory.createPropertyAssignment("type", factory.createArrowFunction(/*modifiers*/ undefined, /*typeParameters*/ undefined, [], /*type*/ undefined, factory.createToken(38 /* SyntaxKind.EqualsGreaterThanToken */), serializeTypeOfNode(node))));
                }
                if (shouldAddParamTypesMetadata(node)) {
                    (properties || (properties = [])).push(factory.createPropertyAssignment("paramTypes", factory.createArrowFunction(/*modifiers*/ undefined, /*typeParameters*/ undefined, [], /*type*/ undefined, factory.createToken(38 /* SyntaxKind.EqualsGreaterThanToken */), serializeParameterTypesOfNode(node, container))));
                }
                if (shouldAddReturnTypeMetadata(node)) {
                    (properties || (properties = [])).push(factory.createPropertyAssignment("returnType", factory.createArrowFunction(/*modifiers*/ undefined, /*typeParameters*/ undefined, [], /*type*/ undefined, factory.createToken(38 /* SyntaxKind.EqualsGreaterThanToken */), serializeReturnTypeOfNode(node))));
                }
                if (properties) {
                    decoratorExpressions.push(emitHelpers().createMetadataHelper("design:typeinfo", factory.createObjectLiteralExpression(properties, /*multiLine*/ true)));
                }
            }
        }
        /**
         * Determines whether to emit the "design:type" metadata based on the node's kind.
         * The caller should have already tested whether the node has decorators and whether the
         * emitDecoratorMetadata compiler option is set.
         *
         * @param node The node to test.
         */
        function shouldAddTypeMetadata(node) {
            var kind = node.kind;
            return kind === 169 /* SyntaxKind.MethodDeclaration */
                || kind === 172 /* SyntaxKind.GetAccessor */
                || kind === 173 /* SyntaxKind.SetAccessor */
                || kind === 167 /* SyntaxKind.PropertyDeclaration */;
        }
        /**
         * Determines whether to emit the "design:returntype" metadata based on the node's kind.
         * The caller should have already tested whether the node has decorators and whether the
         * emitDecoratorMetadata compiler option is set.
         *
         * @param node The node to test.
         */
        function shouldAddReturnTypeMetadata(node) {
            return node.kind === 169 /* SyntaxKind.MethodDeclaration */;
        }
        /**
         * Determines whether to emit the "design:paramtypes" metadata based on the node's kind.
         * The caller should have already tested whether the node has decorators and whether the
         * emitDecoratorMetadata compiler option is set.
         *
         * @param node The node to test.
         */
        function shouldAddParamTypesMetadata(node) {
            switch (node.kind) {
                case 257 /* SyntaxKind.ClassDeclaration */:
                case 226 /* SyntaxKind.ClassExpression */:
                    return ts.getFirstConstructorWithBody(node) !== undefined;
                case 169 /* SyntaxKind.MethodDeclaration */:
                case 172 /* SyntaxKind.GetAccessor */:
                case 173 /* SyntaxKind.SetAccessor */:
                    return true;
            }
            return false;
        }
        function getAccessorTypeNode(node) {
            var accessors = resolver.getAllAccessorDeclarations(node);
            return accessors.setAccessor && ts.getSetAccessorTypeAnnotationNode(accessors.setAccessor)
                || accessors.getAccessor && ts.getEffectiveReturnTypeNode(accessors.getAccessor);
        }
        /**
         * Serializes the type of a node for use with decorator type metadata.
         *
         * @param node The node that should have its type serialized.
         */
        function serializeTypeOfNode(node) {
            switch (node.kind) {
                case 167 /* SyntaxKind.PropertyDeclaration */:
                case 164 /* SyntaxKind.Parameter */:
                    return serializeTypeNode(node.type);
                case 173 /* SyntaxKind.SetAccessor */:
                case 172 /* SyntaxKind.GetAccessor */:
                    return serializeTypeNode(getAccessorTypeNode(node));
                case 257 /* SyntaxKind.ClassDeclaration */:
                case 226 /* SyntaxKind.ClassExpression */:
                case 169 /* SyntaxKind.MethodDeclaration */:
                    return factory.createIdentifier("Function");
                default:
                    return factory.createVoidZero();
            }
        }
        /**
         * Serializes the types of the parameters of a node for use with decorator type metadata.
         *
         * @param node The node that should have its parameter types serialized.
         */
        function serializeParameterTypesOfNode(node, container) {
            var valueDeclaration = ts.isClassLike(node)
                ? ts.getFirstConstructorWithBody(node)
                : ts.isFunctionLike(node) && ts.nodeIsPresent(node.body)
                    ? node
                    : undefined;
            var expressions = [];
            if (valueDeclaration) {
                var parameters = getParametersOfDecoratedDeclaration(valueDeclaration, container);
                var numParameters = parameters.length;
                for (var i = 0; i < numParameters; i++) {
                    var parameter = parameters[i];
                    if (i === 0 && ts.isIdentifier(parameter.name) && parameter.name.escapedText === "this") {
                        continue;
                    }
                    if (parameter.dotDotDotToken) {
                        expressions.push(serializeTypeNode(ts.getRestParameterElementType(parameter.type)));
                    }
                    else {
                        expressions.push(serializeTypeOfNode(parameter));
                    }
                }
            }
            return factory.createArrayLiteralExpression(expressions);
        }
        function getParametersOfDecoratedDeclaration(node, container) {
            if (container && node.kind === 172 /* SyntaxKind.GetAccessor */) {
                var setAccessor = ts.getAllAccessorDeclarations(container.members, node).setAccessor;
                if (setAccessor) {
                    return setAccessor.parameters;
                }
            }
            return node.parameters;
        }
        /**
         * Serializes the return type of a node for use with decorator type metadata.
         *
         * @param node The node that should have its return type serialized.
         */
        function serializeReturnTypeOfNode(node) {
            if (ts.isFunctionLike(node) && node.type) {
                return serializeTypeNode(node.type);
            }
            else if (ts.isAsyncFunction(node)) {
                return factory.createIdentifier("Promise");
            }
            return factory.createVoidZero();
        }
        /**
         * Serializes a type node for use with decorator type metadata.
         *
         * Types are serialized in the following fashion:
         * - Void types point to "undefined" (e.g. "void 0")
         * - Function and Constructor types point to the global "Function" constructor.
         * - Interface types with a call or construct signature types point to the global
         *   "Function" constructor.
         * - Array and Tuple types point to the global "Array" constructor.
         * - Type predicates and booleans point to the global "Boolean" constructor.
         * - String literal types and strings point to the global "String" constructor.
         * - Enum and number types point to the global "Number" constructor.
         * - Symbol types point to the global "Symbol" constructor.
         * - Type references to classes (or class-like variables) point to the constructor for the class.
         * - Anything else points to the global "Object" constructor.
         *
         * @param node The type node to serialize.
         */
        function serializeTypeNode(node) {
            if (node === undefined) {
                return factory.createIdentifier("Object");
            }
            switch (node.kind) {
                case 114 /* SyntaxKind.VoidKeyword */:
                case 153 /* SyntaxKind.UndefinedKeyword */:
                case 143 /* SyntaxKind.NeverKeyword */:
                    return factory.createVoidZero();
                case 191 /* SyntaxKind.ParenthesizedType */:
                    return serializeTypeNode(node.type);
                case 179 /* SyntaxKind.FunctionType */:
                case 180 /* SyntaxKind.ConstructorType */:
                    return factory.createIdentifier("Function");
                case 183 /* SyntaxKind.ArrayType */:
                case 184 /* SyntaxKind.TupleType */:
                    return factory.createIdentifier("Array");
                case 177 /* SyntaxKind.TypePredicate */:
                case 133 /* SyntaxKind.BooleanKeyword */:
                    return factory.createIdentifier("Boolean");
                case 198 /* SyntaxKind.TemplateLiteralType */:
                case 150 /* SyntaxKind.StringKeyword */:
                    return factory.createIdentifier("String");
                case 148 /* SyntaxKind.ObjectKeyword */:
                    return factory.createIdentifier("Object");
                case 196 /* SyntaxKind.LiteralType */:
                    switch (node.literal.kind) {
                        case 10 /* SyntaxKind.StringLiteral */:
                        case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                            return factory.createIdentifier("String");
                        case 219 /* SyntaxKind.PrefixUnaryExpression */:
                        case 8 /* SyntaxKind.NumericLiteral */:
                            return factory.createIdentifier("Number");
                        case 9 /* SyntaxKind.BigIntLiteral */:
                            return getGlobalBigIntNameWithFallback();
                        case 110 /* SyntaxKind.TrueKeyword */:
                        case 95 /* SyntaxKind.FalseKeyword */:
                            return factory.createIdentifier("Boolean");
                        case 104 /* SyntaxKind.NullKeyword */:
                            return factory.createVoidZero();
                        default:
                            return ts.Debug.failBadSyntaxKind(node.literal);
                    }
                case 147 /* SyntaxKind.NumberKeyword */:
                    return factory.createIdentifier("Number");
                case 158 /* SyntaxKind.BigIntKeyword */:
                    return getGlobalBigIntNameWithFallback();
                case 151 /* SyntaxKind.SymbolKeyword */:
                    return languageVersion < 2 /* ScriptTarget.ES2015 */
                        ? getGlobalSymbolNameWithFallback()
                        : factory.createIdentifier("Symbol");
                case 178 /* SyntaxKind.TypeReference */:
                    return serializeTypeReferenceNode(node);
                case 188 /* SyntaxKind.IntersectionType */:
                case 187 /* SyntaxKind.UnionType */:
                    return serializeTypeList(node.types);
                case 189 /* SyntaxKind.ConditionalType */:
                    return serializeTypeList([node.trueType, node.falseType]);
                case 193 /* SyntaxKind.TypeOperator */:
                    if (node.operator === 145 /* SyntaxKind.ReadonlyKeyword */) {
                        return serializeTypeNode(node.type);
                    }
                    break;
                case 181 /* SyntaxKind.TypeQuery */:
                case 194 /* SyntaxKind.IndexedAccessType */:
                case 195 /* SyntaxKind.MappedType */:
                case 182 /* SyntaxKind.TypeLiteral */:
                case 130 /* SyntaxKind.AnyKeyword */:
                case 155 /* SyntaxKind.UnknownKeyword */:
                case 192 /* SyntaxKind.ThisType */:
                case 200 /* SyntaxKind.ImportType */:
                    break;
                // handle JSDoc types from an invalid parse
                case 312 /* SyntaxKind.JSDocAllType */:
                case 313 /* SyntaxKind.JSDocUnknownType */:
                case 317 /* SyntaxKind.JSDocFunctionType */:
                case 318 /* SyntaxKind.JSDocVariadicType */:
                case 319 /* SyntaxKind.JSDocNamepathType */:
                    break;
                case 314 /* SyntaxKind.JSDocNullableType */:
                case 315 /* SyntaxKind.JSDocNonNullableType */:
                case 316 /* SyntaxKind.JSDocOptionalType */:
                    return serializeTypeNode(node.type);
                default:
                    return ts.Debug.failBadSyntaxKind(node);
            }
            return factory.createIdentifier("Object");
        }
        function serializeTypeList(types) {
            // Note when updating logic here also update getEntityNameForDecoratorMetadata
            // so that aliases can be marked as referenced
            var serializedUnion;
            for (var _i = 0, types_23 = types; _i < types_23.length; _i++) {
                var typeNode = types_23[_i];
                while (typeNode.kind === 191 /* SyntaxKind.ParenthesizedType */) {
                    typeNode = typeNode.type; // Skip parens if need be
                }
                if (typeNode.kind === 143 /* SyntaxKind.NeverKeyword */) {
                    continue; // Always elide `never` from the union/intersection if possible
                }
                if (!strictNullChecks && (typeNode.kind === 196 /* SyntaxKind.LiteralType */ && typeNode.literal.kind === 104 /* SyntaxKind.NullKeyword */ || typeNode.kind === 153 /* SyntaxKind.UndefinedKeyword */)) {
                    continue; // Elide null and undefined from unions for metadata, just like what we did prior to the implementation of strict null checks
                }
                var serializedIndividual = serializeTypeNode(typeNode);
                if (ts.isIdentifier(serializedIndividual) && serializedIndividual.escapedText === "Object") {
                    // One of the individual is global object, return immediately
                    return serializedIndividual;
                }
                // If there exists union that is not void 0 expression, check if the the common type is identifier.
                // anything more complex and we will just default to Object
                else if (serializedUnion) {
                    // Different types
                    if (!ts.isIdentifier(serializedUnion) ||
                        !ts.isIdentifier(serializedIndividual) ||
                        serializedUnion.escapedText !== serializedIndividual.escapedText) {
                        return factory.createIdentifier("Object");
                    }
                }
                else {
                    // Initialize the union type
                    serializedUnion = serializedIndividual;
                }
            }
            // If we were able to find common type, use it
            return serializedUnion || factory.createVoidZero(); // Fallback is only hit if all union constituients are null/undefined/never
        }
        /**
         * Serializes a TypeReferenceNode to an appropriate JS constructor value for use with
         * decorator type metadata.
         *
         * @param node The type reference node.
         */
        function serializeTypeReferenceNode(node) {
            var kind = resolver.getTypeReferenceSerializationKind(node.typeName, currentNameScope || currentLexicalScope);
            switch (kind) {
                case ts.TypeReferenceSerializationKind.Unknown:
                    // From conditional type type reference that cannot be resolved is Similar to any or unknown
                    if (ts.findAncestor(node, function (n) { return n.parent && ts.isConditionalTypeNode(n.parent) && (n.parent.trueType === n || n.parent.falseType === n); })) {
                        return factory.createIdentifier("Object");
                    }
                    var serialized = serializeEntityNameAsExpressionFallback(node.typeName);
                    var temp = factory.createTempVariable(hoistVariableDeclaration);
                    return factory.createConditionalExpression(factory.createTypeCheck(factory.createAssignment(temp, serialized), "function"), 
                    /*questionToken*/ undefined, temp, 
                    /*colonToken*/ undefined, factory.createIdentifier("Object"));
                case ts.TypeReferenceSerializationKind.TypeWithConstructSignatureAndValue:
                    return serializeEntityNameAsExpression(node.typeName);
                case ts.TypeReferenceSerializationKind.VoidNullableOrNeverType:
                    return factory.createVoidZero();
                case ts.TypeReferenceSerializationKind.BigIntLikeType:
                    return getGlobalBigIntNameWithFallback();
                case ts.TypeReferenceSerializationKind.BooleanType:
                    return factory.createIdentifier("Boolean");
                case ts.TypeReferenceSerializationKind.NumberLikeType:
                    return factory.createIdentifier("Number");
                case ts.TypeReferenceSerializationKind.StringLikeType:
                    return factory.createIdentifier("String");
                case ts.TypeReferenceSerializationKind.ArrayLikeType:
                    return factory.createIdentifier("Array");
                case ts.TypeReferenceSerializationKind.ESSymbolType:
                    return languageVersion < 2 /* ScriptTarget.ES2015 */
                        ? getGlobalSymbolNameWithFallback()
                        : factory.createIdentifier("Symbol");
                case ts.TypeReferenceSerializationKind.TypeWithCallSignature:
                    return factory.createIdentifier("Function");
                case ts.TypeReferenceSerializationKind.Promise:
                    return factory.createIdentifier("Promise");
                case ts.TypeReferenceSerializationKind.ObjectType:
                    return factory.createIdentifier("Object");
                default:
                    return ts.Debug.assertNever(kind);
            }
        }
        function createCheckedValue(left, right) {
            return factory.createLogicalAnd(factory.createStrictInequality(factory.createTypeOfExpression(left), factory.createStringLiteral("undefined")), right);
        }
        /**
         * Serializes an entity name which may not exist at runtime, but whose access shouldn't throw
         *
         * @param node The entity name to serialize.
         */
        function serializeEntityNameAsExpressionFallback(node) {
            if (node.kind === 79 /* SyntaxKind.Identifier */) {
                // A -> typeof A !== undefined && A
                var copied = serializeEntityNameAsExpression(node);
                return createCheckedValue(copied, copied);
            }
            if (node.left.kind === 79 /* SyntaxKind.Identifier */) {
                // A.B -> typeof A !== undefined && A.B
                return createCheckedValue(serializeEntityNameAsExpression(node.left), serializeEntityNameAsExpression(node));
            }
            // A.B.C -> typeof A !== undefined && (_a = A.B) !== void 0 && _a.C
            var left = serializeEntityNameAsExpressionFallback(node.left);
            var temp = factory.createTempVariable(hoistVariableDeclaration);
            return factory.createLogicalAnd(factory.createLogicalAnd(left.left, factory.createStrictInequality(factory.createAssignment(temp, left.right), factory.createVoidZero())), factory.createPropertyAccessExpression(temp, node.right));
        }
        /**
         * Serializes an entity name as an expression for decorator type metadata.
         *
         * @param node The entity name to serialize.
         */
        function serializeEntityNameAsExpression(node) {
            switch (node.kind) {
                case 79 /* SyntaxKind.Identifier */:
                    // Create a clone of the name with a new parent, and treat it as if it were
                    // a source tree node for the purposes of the checker.
                    var name = ts.setParent(ts.setTextRange(ts.parseNodeFactory.cloneNode(node), node), node.parent);
                    name.original = undefined;
                    ts.setParent(name, ts.getParseTreeNode(currentLexicalScope)); // ensure the parent is set to a parse tree node.
                    return name;
                case 161 /* SyntaxKind.QualifiedName */:
                    return serializeQualifiedNameAsExpression(node);
            }
        }
        /**
         * Serializes an qualified name as an expression for decorator type metadata.
         *
         * @param node The qualified name to serialize.
         * @param useFallback A value indicating whether to use logical operators to test for the
         *                    qualified name at runtime.
         */
        function serializeQualifiedNameAsExpression(node) {
            return factory.createPropertyAccessExpression(serializeEntityNameAsExpression(node.left), node.right);
        }
        /**
         * Gets an expression that points to the global "Symbol" constructor at runtime if it is
         * available.
         */
        function getGlobalSymbolNameWithFallback() {
            return factory.createConditionalExpression(factory.createTypeCheck(factory.createIdentifier("Symbol"), "function"), 
            /*questionToken*/ undefined, factory.createIdentifier("Symbol"), 
            /*colonToken*/ undefined, factory.createIdentifier("Object"));
        }
        /**
         * Gets an expression that points to the global "BigInt" constructor at runtime if it is
         * available.
         */
        function getGlobalBigIntNameWithFallback() {
            return languageVersion < 99 /* ScriptTarget.ESNext */
                ? factory.createConditionalExpression(factory.createTypeCheck(factory.createIdentifier("BigInt"), "function"), 
                /*questionToken*/ undefined, factory.createIdentifier("BigInt"), 
                /*colonToken*/ undefined, factory.createIdentifier("Object"))
                : factory.createIdentifier("BigInt");
        }
        /**
         * Gets an expression that represents a property name (for decorated properties or enums).
         * For a computed property, a name is generated for the node.
         *
         * @param member The member whose name should be converted into an expression.
         */
        function getExpressionForPropertyName(member, generateNameForComputedPropertyName) {
            var name = member.name;
            if (ts.isPrivateIdentifier(name)) {
                return factory.createIdentifier("");
            }
            else if (ts.isComputedPropertyName(name)) {
                return generateNameForComputedPropertyName && !ts.isSimpleInlineableExpression(name.expression)
                    ? factory.getGeneratedNameForNode(name)
                    : name.expression;
            }
            else if (ts.isIdentifier(name)) {
                return factory.createStringLiteral(ts.idText(name));
            }
            else {
                return factory.cloneNode(name);
            }
        }
        /**
         * Visits the property name of a class element, for use when emitting property
         * initializers. For a computed property on a node with decorators, a temporary
         * value is stored for later use.
         *
         * @param member The member whose name should be visited.
         */
        function visitPropertyNameOfClassElement(member) {
            var name = member.name;
            // Computed property names need to be transformed into a hoisted variable when they are used more than once.
            // The names are used more than once when:
            //   - the property is non-static and its initializer is moved to the constructor (when there are parameter property assignments).
            //   - the property has a decorator.
            if (ts.isComputedPropertyName(name) && ((!ts.hasStaticModifier(member) && currentClassHasParameterProperties) || ts.some(member.decorators))) {
                var expression = ts.visitNode(name.expression, visitor, ts.isExpression);
                var innerExpression = ts.skipPartiallyEmittedExpressions(expression);
                if (!ts.isSimpleInlineableExpression(innerExpression)) {
                    var generatedName = factory.getGeneratedNameForNode(name);
                    hoistVariableDeclaration(generatedName);
                    return factory.updateComputedPropertyName(name, factory.createAssignment(generatedName, expression));
                }
            }
            return ts.visitNode(name, visitor, ts.isPropertyName);
        }
        /**
         * Transforms a HeritageClause with TypeScript syntax.
         *
         * This function will only be called when one of the following conditions are met:
         * - The node is a non-`extends` heritage clause that should be elided.
         * - The node is an `extends` heritage clause that should be visited, but only allow a single type.
         *
         * @param node The HeritageClause to transform.
         */
        function visitHeritageClause(node) {
            if (node.token === 117 /* SyntaxKind.ImplementsKeyword */) {
                // implements clauses are elided
                return undefined;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        /**
         * Transforms an ExpressionWithTypeArguments with TypeScript syntax.
         *
         * This function will only be called when one of the following conditions are met:
         * - The node contains type arguments that should be elided.
         *
         * @param node The ExpressionWithTypeArguments to transform.
         */
        function visitExpressionWithTypeArguments(node) {
            return factory.updateExpressionWithTypeArguments(node, ts.visitNode(node.expression, visitor, ts.isLeftHandSideExpression), 
            /*typeArguments*/ undefined);
        }
        /**
         * Determines whether to emit a function-like declaration. We should not emit the
         * declaration if it does not have a body.
         *
         * @param node The declaration node.
         */
        function shouldEmitFunctionLikeDeclaration(node) {
            return !ts.nodeIsMissing(node.body);
        }
        function visitPropertyDeclaration(node) {
            if (node.flags & 16777216 /* NodeFlags.Ambient */ || ts.hasSyntacticModifier(node, 128 /* ModifierFlags.Abstract */)) {
                return undefined;
            }
            var updated = factory.updatePropertyDeclaration(node, 
            /*decorators*/ undefined, ts.visitNodes(node.modifiers, visitor, ts.isModifier), visitPropertyNameOfClassElement(node), 
            /*questionOrExclamationToken*/ undefined, 
            /*type*/ undefined, ts.visitNode(node.initializer, visitor));
            if (updated !== node) {
                // While we emit the source map for the node after skipping decorators and modifiers,
                // we need to emit the comments for the original range.
                ts.setCommentRange(updated, node);
                ts.setSourceMapRange(updated, ts.moveRangePastDecorators(node));
            }
            return updated;
        }
        function visitConstructor(node) {
            if (!shouldEmitFunctionLikeDeclaration(node)) {
                return undefined;
            }
            return factory.updateConstructorDeclaration(node, 
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, ts.visitParameterList(node.parameters, visitor, context), transformConstructorBody(node.body, node));
        }
        function transformConstructorBody(body, constructor) {
            var parametersWithPropertyAssignments = constructor &&
                ts.filter(constructor.parameters, function (p) { return ts.isParameterPropertyDeclaration(p, constructor); });
            if (!ts.some(parametersWithPropertyAssignments)) {
                return ts.visitFunctionBody(body, visitor, context);
            }
            var statements = [];
            resumeLexicalEnvironment();
            var prologueStatementCount = factory.copyPrologue(body.statements, statements, /*ensureUseStrict*/ false, visitor);
            var superStatementIndex = ts.findSuperStatementIndex(body.statements, prologueStatementCount);
            // If there was a super call, visit existing statements up to and including it
            if (superStatementIndex >= 0) {
                ts.addRange(statements, ts.visitNodes(body.statements, visitor, ts.isStatement, prologueStatementCount, superStatementIndex + 1 - prologueStatementCount));
            }
            // Transform parameters into property assignments. Transforms this:
            //
            //  constructor (public x, public y) {
            //  }
            //
            // Into this:
            //
            //  constructor (x, y) {
            //      this.x = x;
            //      this.y = y;
            //  }
            //
            var parameterPropertyAssignments = ts.mapDefined(parametersWithPropertyAssignments, transformParameterWithPropertyAssignment);
            // If there is a super() call, the parameter properties go immediately after it
            if (superStatementIndex >= 0) {
                ts.addRange(statements, parameterPropertyAssignments);
            }
            // Since there was no super() call, parameter properties are the first statements in the constructor after any prologue statements
            else {
                statements = __spreadArray(__spreadArray(__spreadArray([], statements.slice(0, prologueStatementCount), true), parameterPropertyAssignments, true), statements.slice(prologueStatementCount), true);
            }
            // Add remaining statements from the body, skipping the super() call if it was found and any (already added) prologue statements
            ts.addRange(statements, ts.visitNodes(body.statements, visitor, ts.isStatement, superStatementIndex + 1 + prologueStatementCount));
            // End the lexical environment.
            statements = factory.mergeLexicalEnvironment(statements, endLexicalEnvironment());
            var block = factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), body.statements), /*multiLine*/ true);
            ts.setTextRange(block, /*location*/ body);
            ts.setOriginalNode(block, body);
            return block;
        }
        /**
         * Transforms a parameter into a property assignment statement.
         *
         * @param node The parameter declaration.
         */
        function transformParameterWithPropertyAssignment(node) {
            var name = node.name;
            if (!ts.isIdentifier(name)) {
                return undefined;
            }
            // TODO(rbuckton): Does this need to be parented?
            var propertyName = ts.setParent(ts.setTextRange(factory.cloneNode(name), name), name.parent);
            ts.setEmitFlags(propertyName, 1536 /* EmitFlags.NoComments */ | 48 /* EmitFlags.NoSourceMap */);
            // TODO(rbuckton): Does this need to be parented?
            var localName = ts.setParent(ts.setTextRange(factory.cloneNode(name), name), name.parent);
            ts.setEmitFlags(localName, 1536 /* EmitFlags.NoComments */);
            return ts.startOnNewLine(ts.removeAllComments(ts.setTextRange(ts.setOriginalNode(factory.createExpressionStatement(factory.createAssignment(ts.setTextRange(factory.createPropertyAccessExpression(factory.createThis(), propertyName), node.name), localName)), node), ts.moveRangePos(node, -1))));
        }
        function visitMethodDeclaration(node) {
            if (!shouldEmitFunctionLikeDeclaration(node)) {
                return undefined;
            }
            var updated = factory.updateMethodDeclaration(node, 
            /*decorators*/ undefined, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), node.asteriskToken, visitPropertyNameOfClassElement(node), 
            /*questionToken*/ undefined, 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, ts.visitFunctionBody(node.body, visitor, context));
            if (updated !== node) {
                // While we emit the source map for the node after skipping decorators and modifiers,
                // we need to emit the comments for the original range.
                ts.setCommentRange(updated, node);
                ts.setSourceMapRange(updated, ts.moveRangePastDecorators(node));
            }
            return updated;
        }
        /**
         * Determines whether to emit an accessor declaration. We should not emit the
         * declaration if it does not have a body and is abstract.
         *
         * @param node The declaration node.
         */
        function shouldEmitAccessorDeclaration(node) {
            return !(ts.nodeIsMissing(node.body) && ts.hasSyntacticModifier(node, 128 /* ModifierFlags.Abstract */));
        }
        function visitGetAccessor(node) {
            if (!shouldEmitAccessorDeclaration(node)) {
                return undefined;
            }
            var updated = factory.updateGetAccessorDeclaration(node, 
            /*decorators*/ undefined, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), visitPropertyNameOfClassElement(node), ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, ts.visitFunctionBody(node.body, visitor, context) || factory.createBlock([]));
            if (updated !== node) {
                // While we emit the source map for the node after skipping decorators and modifiers,
                // we need to emit the comments for the original range.
                ts.setCommentRange(updated, node);
                ts.setSourceMapRange(updated, ts.moveRangePastDecorators(node));
            }
            return updated;
        }
        function visitSetAccessor(node) {
            if (!shouldEmitAccessorDeclaration(node)) {
                return undefined;
            }
            var updated = factory.updateSetAccessorDeclaration(node, 
            /*decorators*/ undefined, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), visitPropertyNameOfClassElement(node), ts.visitParameterList(node.parameters, visitor, context), ts.visitFunctionBody(node.body, visitor, context) || factory.createBlock([]));
            if (updated !== node) {
                // While we emit the source map for the node after skipping decorators and modifiers,
                // we need to emit the comments for the original range.
                ts.setCommentRange(updated, node);
                ts.setSourceMapRange(updated, ts.moveRangePastDecorators(node));
            }
            return updated;
        }
        function visitFunctionDeclaration(node) {
            if (!shouldEmitFunctionLikeDeclaration(node)) {
                return factory.createNotEmittedStatement(node);
            }
            var updated = factory.updateFunctionDeclaration(node, 
            /*decorators*/ undefined, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), node.asteriskToken, node.name, 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, ts.visitFunctionBody(node.body, visitor, context) || factory.createBlock([]));
            if (isExportOfNamespace(node)) {
                var statements = [updated];
                addExportMemberAssignment(statements, node);
                return statements;
            }
            return updated;
        }
        function visitFunctionExpression(node) {
            if (!shouldEmitFunctionLikeDeclaration(node)) {
                return factory.createOmittedExpression();
            }
            var updated = factory.updateFunctionExpression(node, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), node.asteriskToken, node.name, 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, ts.visitFunctionBody(node.body, visitor, context) || factory.createBlock([]));
            return updated;
        }
        function visitArrowFunction(node) {
            var updated = factory.updateArrowFunction(node, ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, node.equalsGreaterThanToken, ts.visitFunctionBody(node.body, visitor, context));
            return updated;
        }
        function visitParameter(node) {
            if (ts.parameterIsThisKeyword(node)) {
                return undefined;
            }
            var updated = factory.updateParameterDeclaration(node, 
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, node.dotDotDotToken, ts.visitNode(node.name, visitor, ts.isBindingName), 
            /*questionToken*/ undefined, 
            /*type*/ undefined, ts.visitNode(node.initializer, visitor, ts.isExpression));
            if (updated !== node) {
                // While we emit the source map for the node after skipping decorators and modifiers,
                // we need to emit the comments for the original range.
                ts.setCommentRange(updated, node);
                ts.setTextRange(updated, ts.moveRangePastModifiers(node));
                ts.setSourceMapRange(updated, ts.moveRangePastModifiers(node));
                ts.setEmitFlags(updated.name, 32 /* EmitFlags.NoTrailingSourceMap */);
            }
            return updated;
        }
        function visitVariableStatement(node) {
            if (isExportOfNamespace(node)) {
                var variables = ts.getInitializedVariables(node.declarationList);
                if (variables.length === 0) {
                    // elide statement if there are no initialized variables.
                    return undefined;
                }
                return ts.setTextRange(factory.createExpressionStatement(factory.inlineExpressions(ts.map(variables, transformInitializedVariable))), node);
            }
            else {
                return ts.visitEachChild(node, visitor, context);
            }
        }
        function transformInitializedVariable(node) {
            var name = node.name;
            if (ts.isBindingPattern(name)) {
                return ts.flattenDestructuringAssignment(node, visitor, context, 0 /* FlattenLevel.All */, 
                /*needsValue*/ false, createNamespaceExportExpression);
            }
            else {
                return ts.setTextRange(factory.createAssignment(getNamespaceMemberNameWithSourceMapsAndWithoutComments(name), ts.visitNode(node.initializer, visitor, ts.isExpression)), 
                /*location*/ node);
            }
        }
        function visitVariableDeclaration(node) {
            var updated = factory.updateVariableDeclaration(node, ts.visitNode(node.name, visitor, ts.isBindingName), 
            /*exclamationToken*/ undefined, 
            /*type*/ undefined, ts.visitNode(node.initializer, visitor, ts.isExpression));
            if (node.type) {
                ts.setTypeNode(updated.name, node.type);
            }
            return updated;
        }
        function visitParenthesizedExpression(node) {
            var innerExpression = ts.skipOuterExpressions(node.expression, ~6 /* OuterExpressionKinds.Assertions */);
            if (ts.isAssertionExpression(innerExpression)) {
                // Make sure we consider all nested cast expressions, e.g.:
                // (<any><number><any>-A).x;
                var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
                // We have an expression of the form: (<Type>SubExpr). Emitting this as (SubExpr)
                // is really not desirable. We would like to emit the subexpression as-is. Omitting
                // the parentheses, however, could cause change in the semantics of the generated
                // code if the casted expression has a lower precedence than the rest of the
                // expression.
                //
                // To preserve comments, we return a "PartiallyEmittedExpression" here which will
                // preserve the position information of the original expression.
                //
                // Due to the auto-parenthesization rules used by the visitor and factory functions
                // we can safely elide the parentheses here, as a new synthetic
                // ParenthesizedExpression will be inserted if we remove parentheses too
                // aggressively.
                //
                // If there are leading comments on the expression itself, the emitter will handle ASI
                // for return, throw, and yield by re-introducing parenthesis during emit on an as-need
                // basis.
                return factory.createPartiallyEmittedExpression(expression, node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitAssertionExpression(node) {
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            return factory.createPartiallyEmittedExpression(expression, node);
        }
        function visitNonNullExpression(node) {
            var expression = ts.visitNode(node.expression, visitor, ts.isLeftHandSideExpression);
            return factory.createPartiallyEmittedExpression(expression, node);
        }
        function visitCallExpression(node) {
            return factory.updateCallExpression(node, ts.visitNode(node.expression, visitor, ts.isExpression), 
            /*typeArguments*/ undefined, ts.visitNodes(node.arguments, visitor, ts.isExpression));
        }
        function visitNewExpression(node) {
            return factory.updateNewExpression(node, ts.visitNode(node.expression, visitor, ts.isExpression), 
            /*typeArguments*/ undefined, ts.visitNodes(node.arguments, visitor, ts.isExpression));
        }
        function visitTaggedTemplateExpression(node) {
            return factory.updateTaggedTemplateExpression(node, ts.visitNode(node.tag, visitor, ts.isExpression), 
            /*typeArguments*/ undefined, ts.visitNode(node.template, visitor, ts.isExpression));
        }
        function visitJsxSelfClosingElement(node) {
            return factory.updateJsxSelfClosingElement(node, ts.visitNode(node.tagName, visitor, ts.isJsxTagNameExpression), 
            /*typeArguments*/ undefined, ts.visitNode(node.attributes, visitor, ts.isJsxAttributes));
        }
        function visitJsxJsxOpeningElement(node) {
            return factory.updateJsxOpeningElement(node, ts.visitNode(node.tagName, visitor, ts.isJsxTagNameExpression), 
            /*typeArguments*/ undefined, ts.visitNode(node.attributes, visitor, ts.isJsxAttributes));
        }
        /**
         * Determines whether to emit an enum declaration.
         *
         * @param node The enum declaration node.
         */
        function shouldEmitEnumDeclaration(node) {
            return !ts.isEnumConst(node)
                || ts.shouldPreserveConstEnums(compilerOptions);
        }
        /**
         * Visits an enum declaration.
         *
         * This function will be called any time a TypeScript enum is encountered.
         *
         * @param node The enum declaration node.
         */
        function visitEnumDeclaration(node) {
            if (!shouldEmitEnumDeclaration(node)) {
                return factory.createNotEmittedStatement(node);
            }
            var statements = [];
            // We request to be advised when the printer is about to print this node. This allows
            // us to set up the correct state for later substitutions.
            var emitFlags = 2 /* EmitFlags.AdviseOnEmitNode */;
            // If needed, we should emit a variable declaration for the enum. If we emit
            // a leading variable declaration, we should not emit leading comments for the
            // enum body.
            var varAdded = addVarForEnumOrModuleDeclaration(statements, node);
            if (varAdded) {
                // We should still emit the comments if we are emitting a system module.
                if (moduleKind !== ts.ModuleKind.System || currentLexicalScope !== currentSourceFile) {
                    emitFlags |= 512 /* EmitFlags.NoLeadingComments */;
                }
            }
            // `parameterName` is the declaration name used inside of the enum.
            var parameterName = getNamespaceParameterName(node);
            // `containerName` is the expression used inside of the enum for assignments.
            var containerName = getNamespaceContainerName(node);
            // `exportName` is the expression used within this node's container for any exported references.
            var exportName = ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */)
                ? factory.getExternalModuleOrNamespaceExportName(currentNamespaceContainerName, node, /*allowComments*/ false, /*allowSourceMaps*/ true)
                : factory.getLocalName(node, /*allowComments*/ false, /*allowSourceMaps*/ true);
            //  x || (x = {})
            //  exports.x || (exports.x = {})
            var moduleArg = factory.createLogicalOr(exportName, factory.createAssignment(exportName, factory.createObjectLiteralExpression()));
            if (hasNamespaceQualifiedExportName(node)) {
                // `localName` is the expression used within this node's containing scope for any local references.
                var localName = factory.getLocalName(node, /*allowComments*/ false, /*allowSourceMaps*/ true);
                //  x = (exports.x || (exports.x = {}))
                moduleArg = factory.createAssignment(localName, moduleArg);
            }
            //  (function (x) {
            //      x[x["y"] = 0] = "y";
            //      ...
            //  })(x || (x = {}));
            var enumStatement = factory.createExpressionStatement(factory.createCallExpression(factory.createFunctionExpression(
            /*modifiers*/ undefined, 
            /*asteriskToken*/ undefined, 
            /*name*/ undefined, 
            /*typeParameters*/ undefined, [factory.createParameterDeclaration(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, parameterName)], 
            /*type*/ undefined, transformEnumBody(node, containerName)), 
            /*typeArguments*/ undefined, [moduleArg]));
            ts.setOriginalNode(enumStatement, node);
            if (varAdded) {
                // If a variable was added, synthetic comments are emitted on it, not on the moduleStatement.
                ts.setSyntheticLeadingComments(enumStatement, undefined);
                ts.setSyntheticTrailingComments(enumStatement, undefined);
            }
            ts.setTextRange(enumStatement, node);
            ts.addEmitFlags(enumStatement, emitFlags);
            statements.push(enumStatement);
            // Add a DeclarationMarker for the enum to preserve trailing comments and mark
            // the end of the declaration.
            statements.push(factory.createEndOfDeclarationMarker(node));
            return statements;
        }
        /**
         * Transforms the body of an enum declaration.
         *
         * @param node The enum declaration node.
         */
        function transformEnumBody(node, localName) {
            var savedCurrentNamespaceLocalName = currentNamespaceContainerName;
            currentNamespaceContainerName = localName;
            var statements = [];
            startLexicalEnvironment();
            var members = ts.map(node.members, transformEnumMember);
            ts.insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());
            ts.addRange(statements, members);
            currentNamespaceContainerName = savedCurrentNamespaceLocalName;
            return factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), /*location*/ node.members), 
            /*multiLine*/ true);
        }
        /**
         * Transforms an enum member into a statement.
         *
         * @param member The enum member node.
         */
        function transformEnumMember(member) {
            // enums don't support computed properties
            // we pass false as 'generateNameForComputedPropertyName' for a backward compatibility purposes
            // old emitter always generate 'expression' part of the name as-is.
            var name = getExpressionForPropertyName(member, /*generateNameForComputedPropertyName*/ false);
            var valueExpression = transformEnumMemberDeclarationValue(member);
            var innerAssignment = factory.createAssignment(factory.createElementAccessExpression(currentNamespaceContainerName, name), valueExpression);
            var outerAssignment = valueExpression.kind === 10 /* SyntaxKind.StringLiteral */ ?
                innerAssignment :
                factory.createAssignment(factory.createElementAccessExpression(currentNamespaceContainerName, innerAssignment), name);
            return ts.setTextRange(factory.createExpressionStatement(ts.setTextRange(outerAssignment, member)), member);
        }
        /**
         * Transforms the value of an enum member.
         *
         * @param member The enum member node.
         */
        function transformEnumMemberDeclarationValue(member) {
            var value = resolver.getConstantValue(member);
            if (value !== undefined) {
                return typeof value === "string" ? factory.createStringLiteral(value) : factory.createNumericLiteral(value);
            }
            else {
                enableSubstitutionForNonQualifiedEnumMembers();
                if (member.initializer) {
                    return ts.visitNode(member.initializer, visitor, ts.isExpression);
                }
                else {
                    return factory.createVoidZero();
                }
            }
        }
        /**
         * Determines whether to elide a module declaration.
         *
         * @param node The module declaration node.
         */
        function shouldEmitModuleDeclaration(nodeIn) {
            var node = ts.getParseTreeNode(nodeIn, ts.isModuleDeclaration);
            if (!node) {
                // If we can't find a parse tree node, assume the node is instantiated.
                return true;
            }
            return ts.isInstantiatedModule(node, ts.shouldPreserveConstEnums(compilerOptions));
        }
        /**
         * Determines whether an exported declaration will have a qualified export name (e.g. `f.x`
         * or `exports.x`).
         */
        function hasNamespaceQualifiedExportName(node) {
            return isExportOfNamespace(node)
                || (isExternalModuleExport(node)
                    && moduleKind !== ts.ModuleKind.ES2015
                    && moduleKind !== ts.ModuleKind.ES2020
                    && moduleKind !== ts.ModuleKind.ES2022
                    && moduleKind !== ts.ModuleKind.ESNext
                    && moduleKind !== ts.ModuleKind.System);
        }
        /**
         * Records that a declaration was emitted in the current scope, if it was the first
         * declaration for the provided symbol.
         */
        function recordEmittedDeclarationInScope(node) {
            if (!currentScopeFirstDeclarationsOfName) {
                currentScopeFirstDeclarationsOfName = new ts.Map();
            }
            var name = declaredNameInScope(node);
            if (!currentScopeFirstDeclarationsOfName.has(name)) {
                currentScopeFirstDeclarationsOfName.set(name, node);
            }
        }
        /**
         * Determines whether a declaration is the first declaration with
         * the same name emitted in the current scope.
         */
        function isFirstEmittedDeclarationInScope(node) {
            if (currentScopeFirstDeclarationsOfName) {
                var name = declaredNameInScope(node);
                return currentScopeFirstDeclarationsOfName.get(name) === node;
            }
            return true;
        }
        function declaredNameInScope(node) {
            ts.Debug.assertNode(node.name, ts.isIdentifier);
            return node.name.escapedText;
        }
        /**
         * Adds a leading VariableStatement for a enum or module declaration.
         */
        function addVarForEnumOrModuleDeclaration(statements, node) {
            // Emit a variable statement for the module. We emit top-level enums as a `var`
            // declaration to avoid static errors in global scripts scripts due to redeclaration.
            // enums in any other scope are emitted as a `let` declaration.
            var statement = factory.createVariableStatement(ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), factory.createVariableDeclarationList([
                factory.createVariableDeclaration(factory.getLocalName(node, /*allowComments*/ false, /*allowSourceMaps*/ true))
            ], currentLexicalScope.kind === 305 /* SyntaxKind.SourceFile */ ? 0 /* NodeFlags.None */ : 1 /* NodeFlags.Let */));
            ts.setOriginalNode(statement, node);
            recordEmittedDeclarationInScope(node);
            if (isFirstEmittedDeclarationInScope(node)) {
                // Adjust the source map emit to match the old emitter.
                if (node.kind === 260 /* SyntaxKind.EnumDeclaration */) {
                    ts.setSourceMapRange(statement.declarationList, node);
                }
                else {
                    ts.setSourceMapRange(statement, node);
                }
                // Trailing comments for module declaration should be emitted after the function closure
                // instead of the variable statement:
                //
                //     /** Module comment*/
                //     module m1 {
                //         function foo4Export() {
                //         }
                //     } // trailing comment module
                //
                // Should emit:
                //
                //     /** Module comment*/
                //     var m1;
                //     (function (m1) {
                //         function foo4Export() {
                //         }
                //     })(m1 || (m1 = {})); // trailing comment module
                //
                ts.setCommentRange(statement, node);
                ts.addEmitFlags(statement, 1024 /* EmitFlags.NoTrailingComments */ | 4194304 /* EmitFlags.HasEndOfDeclarationMarker */);
                statements.push(statement);
                return true;
            }
            else {
                // For an EnumDeclaration or ModuleDeclaration that merges with a preceeding
                // declaration we do not emit a leading variable declaration. To preserve the
                // begin/end semantics of the declararation and to properly handle exports
                // we wrap the leading variable declaration in a `MergeDeclarationMarker`.
                var mergeMarker = factory.createMergeDeclarationMarker(statement);
                ts.setEmitFlags(mergeMarker, 1536 /* EmitFlags.NoComments */ | 4194304 /* EmitFlags.HasEndOfDeclarationMarker */);
                statements.push(mergeMarker);
                return false;
            }
        }
        /**
         * Visits a module declaration node.
         *
         * This function will be called any time a TypeScript namespace (ModuleDeclaration) is encountered.
         *
         * @param node The module declaration node.
         */
        function visitModuleDeclaration(node) {
            if (!shouldEmitModuleDeclaration(node)) {
                return factory.createNotEmittedStatement(node);
            }
            ts.Debug.assertNode(node.name, ts.isIdentifier, "A TypeScript namespace should have an Identifier name.");
            enableSubstitutionForNamespaceExports();
            var statements = [];
            // We request to be advised when the printer is about to print this node. This allows
            // us to set up the correct state for later substitutions.
            var emitFlags = 2 /* EmitFlags.AdviseOnEmitNode */;
            // If needed, we should emit a variable declaration for the module. If we emit
            // a leading variable declaration, we should not emit leading comments for the
            // module body.
            var varAdded = addVarForEnumOrModuleDeclaration(statements, node);
            if (varAdded) {
                // We should still emit the comments if we are emitting a system module.
                if (moduleKind !== ts.ModuleKind.System || currentLexicalScope !== currentSourceFile) {
                    emitFlags |= 512 /* EmitFlags.NoLeadingComments */;
                }
            }
            // `parameterName` is the declaration name used inside of the namespace.
            var parameterName = getNamespaceParameterName(node);
            // `containerName` is the expression used inside of the namespace for exports.
            var containerName = getNamespaceContainerName(node);
            // `exportName` is the expression used within this node's container for any exported references.
            var exportName = ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */)
                ? factory.getExternalModuleOrNamespaceExportName(currentNamespaceContainerName, node, /*allowComments*/ false, /*allowSourceMaps*/ true)
                : factory.getLocalName(node, /*allowComments*/ false, /*allowSourceMaps*/ true);
            //  x || (x = {})
            //  exports.x || (exports.x = {})
            var moduleArg = factory.createLogicalOr(exportName, factory.createAssignment(exportName, factory.createObjectLiteralExpression()));
            if (hasNamespaceQualifiedExportName(node)) {
                // `localName` is the expression used within this node's containing scope for any local references.
                var localName = factory.getLocalName(node, /*allowComments*/ false, /*allowSourceMaps*/ true);
                //  x = (exports.x || (exports.x = {}))
                moduleArg = factory.createAssignment(localName, moduleArg);
            }
            //  (function (x_1) {
            //      x_1.y = ...;
            //  })(x || (x = {}));
            var moduleStatement = factory.createExpressionStatement(factory.createCallExpression(factory.createFunctionExpression(
            /*modifiers*/ undefined, 
            /*asteriskToken*/ undefined, 
            /*name*/ undefined, 
            /*typeParameters*/ undefined, [factory.createParameterDeclaration(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, parameterName)], 
            /*type*/ undefined, transformModuleBody(node, containerName)), 
            /*typeArguments*/ undefined, [moduleArg]));
            ts.setOriginalNode(moduleStatement, node);
            if (varAdded) {
                // If a variable was added, synthetic comments are emitted on it, not on the moduleStatement.
                ts.setSyntheticLeadingComments(moduleStatement, undefined);
                ts.setSyntheticTrailingComments(moduleStatement, undefined);
            }
            ts.setTextRange(moduleStatement, node);
            ts.addEmitFlags(moduleStatement, emitFlags);
            statements.push(moduleStatement);
            // Add a DeclarationMarker for the namespace to preserve trailing comments and mark
            // the end of the declaration.
            statements.push(factory.createEndOfDeclarationMarker(node));
            return statements;
        }
        /**
         * Transforms the body of a module declaration.
         *
         * @param node The module declaration node.
         */
        function transformModuleBody(node, namespaceLocalName) {
            var savedCurrentNamespaceContainerName = currentNamespaceContainerName;
            var savedCurrentNamespace = currentNamespace;
            var savedCurrentScopeFirstDeclarationsOfName = currentScopeFirstDeclarationsOfName;
            currentNamespaceContainerName = namespaceLocalName;
            currentNamespace = node;
            currentScopeFirstDeclarationsOfName = undefined;
            var statements = [];
            startLexicalEnvironment();
            var statementsLocation;
            var blockLocation;
            if (node.body) {
                if (node.body.kind === 262 /* SyntaxKind.ModuleBlock */) {
                    saveStateAndInvoke(node.body, function (body) { return ts.addRange(statements, ts.visitNodes(body.statements, namespaceElementVisitor, ts.isStatement)); });
                    statementsLocation = node.body.statements;
                    blockLocation = node.body;
                }
                else {
                    var result = visitModuleDeclaration(node.body);
                    if (result) {
                        if (ts.isArray(result)) {
                            ts.addRange(statements, result);
                        }
                        else {
                            statements.push(result);
                        }
                    }
                    var moduleBlock = getInnerMostModuleDeclarationFromDottedModule(node).body;
                    statementsLocation = ts.moveRangePos(moduleBlock.statements, -1);
                }
            }
            ts.insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());
            currentNamespaceContainerName = savedCurrentNamespaceContainerName;
            currentNamespace = savedCurrentNamespace;
            currentScopeFirstDeclarationsOfName = savedCurrentScopeFirstDeclarationsOfName;
            var block = factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), 
            /*location*/ statementsLocation), 
            /*multiLine*/ true);
            ts.setTextRange(block, blockLocation);
            // namespace hello.hi.world {
            //      function foo() {}
            //
            //      // TODO, blah
            // }
            //
            // should be emitted as
            //
            // var hello;
            // (function (hello) {
            //     var hi;
            //     (function (hi) {
            //         var world;
            //         (function (world) {
            //             function foo() { }
            //             // TODO, blah
            //         })(world = hi.world || (hi.world = {}));
            //     })(hi = hello.hi || (hello.hi = {}));
            // })(hello || (hello = {}));
            // We only want to emit comment on the namespace which contains block body itself, not the containing namespaces.
            if (!node.body || node.body.kind !== 262 /* SyntaxKind.ModuleBlock */) {
                ts.setEmitFlags(block, ts.getEmitFlags(block) | 1536 /* EmitFlags.NoComments */);
            }
            return block;
        }
        function getInnerMostModuleDeclarationFromDottedModule(moduleDeclaration) {
            if (moduleDeclaration.body.kind === 261 /* SyntaxKind.ModuleDeclaration */) {
                var recursiveInnerModule = getInnerMostModuleDeclarationFromDottedModule(moduleDeclaration.body);
                return recursiveInnerModule || moduleDeclaration.body;
            }
        }
        /**
         * Visits an import declaration, eliding it if it is type-only or if it has an import clause that may be elided.
         *
         * @param node The import declaration node.
         */
        function visitImportDeclaration(node) {
            if (!node.importClause) {
                // Do not elide a side-effect only import declaration.
                //  import "foo";
                return node;
            }
            if (node.importClause.isTypeOnly) {
                // Always elide type-only imports
                return undefined;
            }
            // Elide the declaration if the import clause was elided.
            var importClause = ts.visitNode(node.importClause, visitImportClause, ts.isImportClause);
            return importClause ||
                compilerOptions.importsNotUsedAsValues === 1 /* ImportsNotUsedAsValues.Preserve */ ||
                compilerOptions.importsNotUsedAsValues === 2 /* ImportsNotUsedAsValues.Error */
                ? factory.updateImportDeclaration(node, 
                /*decorators*/ undefined, 
                /*modifiers*/ undefined, importClause, node.moduleSpecifier, node.assertClause)
                : undefined;
        }
        /**
         * Visits an import clause, eliding it if its `name` and `namedBindings` may both be elided.
         *
         * @param node The import clause node.
         */
        function visitImportClause(node) {
            ts.Debug.assert(!node.isTypeOnly);
            // Elide the import clause if we elide both its name and its named bindings.
            var name = shouldEmitAliasDeclaration(node) ? node.name : undefined;
            var namedBindings = ts.visitNode(node.namedBindings, visitNamedImportBindings, ts.isNamedImportBindings);
            return (name || namedBindings) ? factory.updateImportClause(node, /*isTypeOnly*/ false, name, namedBindings) : undefined;
        }
        /**
         * Visits named import bindings, eliding them if their targets, their references, and the compilation settings allow.
         *
         * @param node The named import bindings node.
         */
        function visitNamedImportBindings(node) {
            if (node.kind === 268 /* SyntaxKind.NamespaceImport */) {
                // Elide a namespace import if it is not referenced.
                return shouldEmitAliasDeclaration(node) ? node : undefined;
            }
            else {
                // Elide named imports if all of its import specifiers are elided and settings allow.
                var allowEmpty = compilerOptions.preserveValueImports && (compilerOptions.importsNotUsedAsValues === 1 /* ImportsNotUsedAsValues.Preserve */ ||
                    compilerOptions.importsNotUsedAsValues === 2 /* ImportsNotUsedAsValues.Error */);
                var elements = ts.visitNodes(node.elements, visitImportSpecifier, ts.isImportSpecifier);
                return allowEmpty || ts.some(elements) ? factory.updateNamedImports(node, elements) : undefined;
            }
        }
        /**
         * Visits an import specifier, eliding it if its target, its references, and the compilation settings allow.
         *
         * @param node The import specifier node.
         */
        function visitImportSpecifier(node) {
            return !node.isTypeOnly && shouldEmitAliasDeclaration(node) ? node : undefined;
        }
        /**
         * Visits an export assignment, eliding it if it does not contain a clause that resolves
         * to a value.
         *
         * @param node The export assignment node.
         */
        function visitExportAssignment(node) {
            // Elide the export assignment if it does not reference a value.
            return resolver.isValueAliasDeclaration(node)
                ? ts.visitEachChild(node, visitor, context)
                : undefined;
        }
        /**
         * Visits an export declaration, eliding it if it does not contain a clause that resolves to a value.
         *
         * @param node The export declaration node.
         */
        function visitExportDeclaration(node) {
            if (node.isTypeOnly) {
                return undefined;
            }
            if (!node.exportClause || ts.isNamespaceExport(node.exportClause)) {
                // never elide `export <whatever> from <whereever>` declarations -
                // they should be kept for sideffects/untyped exports, even when the
                // type checker doesn't know about any exports
                return node;
            }
            // Elide the export declaration if all of its named exports are elided.
            var allowEmpty = !!node.moduleSpecifier && (compilerOptions.importsNotUsedAsValues === 1 /* ImportsNotUsedAsValues.Preserve */ ||
                compilerOptions.importsNotUsedAsValues === 2 /* ImportsNotUsedAsValues.Error */);
            var exportClause = ts.visitNode(node.exportClause, function (bindings) { return visitNamedExportBindings(bindings, allowEmpty); }, ts.isNamedExportBindings);
            return exportClause
                ? factory.updateExportDeclaration(node, 
                /*decorators*/ undefined, 
                /*modifiers*/ undefined, node.isTypeOnly, exportClause, node.moduleSpecifier, node.assertClause)
                : undefined;
        }
        /**
         * Visits named exports, eliding it if it does not contain an export specifier that
         * resolves to a value.
         *
         * @param node The named exports node.
         */
        function visitNamedExports(node, allowEmpty) {
            // Elide the named exports if all of its export specifiers were elided.
            var elements = ts.visitNodes(node.elements, visitExportSpecifier, ts.isExportSpecifier);
            return allowEmpty || ts.some(elements) ? factory.updateNamedExports(node, elements) : undefined;
        }
        function visitNamespaceExports(node) {
            return factory.updateNamespaceExport(node, ts.visitNode(node.name, visitor, ts.isIdentifier));
        }
        function visitNamedExportBindings(node, allowEmpty) {
            return ts.isNamespaceExport(node) ? visitNamespaceExports(node) : visitNamedExports(node, allowEmpty);
        }
        /**
         * Visits an export specifier, eliding it if it does not resolve to a value.
         *
         * @param node The export specifier node.
         */
        function visitExportSpecifier(node) {
            // Elide an export specifier if it does not reference a value.
            return !node.isTypeOnly && resolver.isValueAliasDeclaration(node) ? node : undefined;
        }
        /**
         * Determines whether to emit an import equals declaration.
         *
         * @param node The import equals declaration node.
         */
        function shouldEmitImportEqualsDeclaration(node) {
            // preserve old compiler's behavior: emit 'var' for import declaration (even if we do not consider them referenced) when
            // - current file is not external module
            // - import declaration is top level and target is value imported by entity name
            return shouldEmitAliasDeclaration(node)
                || (!ts.isExternalModule(currentSourceFile)
                    && resolver.isTopLevelValueImportEqualsWithEntityName(node));
        }
        /**
         * Visits an import equals declaration.
         *
         * @param node The import equals declaration node.
         */
        function visitImportEqualsDeclaration(node) {
            // Always elide type-only imports
            if (node.isTypeOnly) {
                return undefined;
            }
            if (ts.isExternalModuleImportEqualsDeclaration(node)) {
                var isReferenced = shouldEmitAliasDeclaration(node);
                // If the alias is unreferenced but we want to keep the import, replace with 'import "mod"'.
                if (!isReferenced && compilerOptions.importsNotUsedAsValues === 1 /* ImportsNotUsedAsValues.Preserve */) {
                    return ts.setOriginalNode(ts.setTextRange(factory.createImportDeclaration(
                    /*decorators*/ undefined, 
                    /*modifiers*/ undefined, 
                    /*importClause*/ undefined, node.moduleReference.expression, 
                    /*assertClause*/ undefined), node), node);
                }
                return isReferenced ? ts.visitEachChild(node, visitor, context) : undefined;
            }
            if (!shouldEmitImportEqualsDeclaration(node)) {
                return undefined;
            }
            var moduleReference = ts.createExpressionFromEntityName(factory, node.moduleReference);
            ts.setEmitFlags(moduleReference, 1536 /* EmitFlags.NoComments */ | 2048 /* EmitFlags.NoNestedComments */);
            if (isNamedExternalModuleExport(node) || !isExportOfNamespace(node)) {
                //  export var ${name} = ${moduleReference};
                //  var ${name} = ${moduleReference};
                return ts.setOriginalNode(ts.setTextRange(factory.createVariableStatement(ts.visitNodes(node.modifiers, modifierVisitor, ts.isModifier), factory.createVariableDeclarationList([
                    ts.setOriginalNode(factory.createVariableDeclaration(node.name, 
                    /*exclamationToken*/ undefined, 
                    /*type*/ undefined, moduleReference), node)
                ])), node), node);
            }
            else {
                // exports.${name} = ${moduleReference};
                return ts.setOriginalNode(createNamespaceExport(node.name, moduleReference, node), node);
            }
        }
        /**
         * Gets a value indicating whether the node is exported from a namespace.
         *
         * @param node The node to test.
         */
        function isExportOfNamespace(node) {
            return currentNamespace !== undefined && ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */);
        }
        /**
         * Gets a value indicating whether the node is exported from an external module.
         *
         * @param node The node to test.
         */
        function isExternalModuleExport(node) {
            return currentNamespace === undefined && ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */);
        }
        /**
         * Gets a value indicating whether the node is a named export from an external module.
         *
         * @param node The node to test.
         */
        function isNamedExternalModuleExport(node) {
            return isExternalModuleExport(node)
                && !ts.hasSyntacticModifier(node, 512 /* ModifierFlags.Default */);
        }
        /**
         * Gets a value indicating whether the node is the default export of an external module.
         *
         * @param node The node to test.
         */
        function isDefaultExternalModuleExport(node) {
            return isExternalModuleExport(node)
                && ts.hasSyntacticModifier(node, 512 /* ModifierFlags.Default */);
        }
        /**
         * Creates a statement for the provided expression. This is used in calls to `map`.
         */
        function expressionToStatement(expression) {
            return factory.createExpressionStatement(expression);
        }
        function addExportMemberAssignment(statements, node) {
            var expression = factory.createAssignment(factory.getExternalModuleOrNamespaceExportName(currentNamespaceContainerName, node, /*allowComments*/ false, /*allowSourceMaps*/ true), factory.getLocalName(node));
            ts.setSourceMapRange(expression, ts.createRange(node.name ? node.name.pos : node.pos, node.end));
            var statement = factory.createExpressionStatement(expression);
            ts.setSourceMapRange(statement, ts.createRange(-1, node.end));
            statements.push(statement);
        }
        function createNamespaceExport(exportName, exportValue, location) {
            return ts.setTextRange(factory.createExpressionStatement(factory.createAssignment(factory.getNamespaceMemberName(currentNamespaceContainerName, exportName, /*allowComments*/ false, /*allowSourceMaps*/ true), exportValue)), location);
        }
        function createNamespaceExportExpression(exportName, exportValue, location) {
            return ts.setTextRange(factory.createAssignment(getNamespaceMemberNameWithSourceMapsAndWithoutComments(exportName), exportValue), location);
        }
        function getNamespaceMemberNameWithSourceMapsAndWithoutComments(name) {
            return factory.getNamespaceMemberName(currentNamespaceContainerName, name, /*allowComments*/ false, /*allowSourceMaps*/ true);
        }
        /**
         * Gets the declaration name used inside of a namespace or enum.
         */
        function getNamespaceParameterName(node) {
            var name = factory.getGeneratedNameForNode(node);
            ts.setSourceMapRange(name, node.name);
            return name;
        }
        /**
         * Gets the expression used to refer to a namespace or enum within the body
         * of its declaration.
         */
        function getNamespaceContainerName(node) {
            return factory.getGeneratedNameForNode(node);
        }
        /**
         * Gets a local alias for a class declaration if it is a decorated class with an internal
         * reference to the static side of the class. This is necessary to avoid issues with
         * double-binding semantics for the class name.
         */
        function getClassAliasIfNeeded(node) {
            if (resolver.getNodeCheckFlags(node) & 16777216 /* NodeCheckFlags.ClassWithConstructorReference */) {
                enableSubstitutionForClassAliases();
                var classAlias = factory.createUniqueName(node.name && !ts.isGeneratedIdentifier(node.name) ? ts.idText(node.name) : "default");
                classAliases[ts.getOriginalNodeId(node)] = classAlias;
                hoistVariableDeclaration(classAlias);
                return classAlias;
            }
        }
        function getClassPrototype(node) {
            return factory.createPropertyAccessExpression(factory.getDeclarationName(node), "prototype");
        }
        function getClassMemberPrefix(node, member) {
            return ts.isStatic(member)
                ? factory.getDeclarationName(node)
                : getClassPrototype(node);
        }
        function enableSubstitutionForNonQualifiedEnumMembers() {
            if ((enabledSubstitutions & 8 /* TypeScriptSubstitutionFlags.NonQualifiedEnumMembers */) === 0) {
                enabledSubstitutions |= 8 /* TypeScriptSubstitutionFlags.NonQualifiedEnumMembers */;
                context.enableSubstitution(79 /* SyntaxKind.Identifier */);
            }
        }
        function enableSubstitutionForClassAliases() {
            if ((enabledSubstitutions & 1 /* TypeScriptSubstitutionFlags.ClassAliases */) === 0) {
                enabledSubstitutions |= 1 /* TypeScriptSubstitutionFlags.ClassAliases */;
                // We need to enable substitutions for identifiers. This allows us to
                // substitute class names inside of a class declaration.
                context.enableSubstitution(79 /* SyntaxKind.Identifier */);
                // Keep track of class aliases.
                classAliases = [];
            }
        }
        function enableSubstitutionForNamespaceExports() {
            if ((enabledSubstitutions & 2 /* TypeScriptSubstitutionFlags.NamespaceExports */) === 0) {
                enabledSubstitutions |= 2 /* TypeScriptSubstitutionFlags.NamespaceExports */;
                // We need to enable substitutions for identifiers and shorthand property assignments. This allows us to
                // substitute the names of exported members of a namespace.
                context.enableSubstitution(79 /* SyntaxKind.Identifier */);
                context.enableSubstitution(297 /* SyntaxKind.ShorthandPropertyAssignment */);
                // We need to be notified when entering and exiting namespaces.
                context.enableEmitNotification(261 /* SyntaxKind.ModuleDeclaration */);
            }
        }
        function isTransformedModuleDeclaration(node) {
            return ts.getOriginalNode(node).kind === 261 /* SyntaxKind.ModuleDeclaration */;
        }
        function isTransformedEnumDeclaration(node) {
            return ts.getOriginalNode(node).kind === 260 /* SyntaxKind.EnumDeclaration */;
        }
        /**
         * Hook for node emit.
         *
         * @param hint A hint as to the intended usage of the node.
         * @param node The node to emit.
         * @param emit A callback used to emit the node in the printer.
         */
        function onEmitNode(hint, node, emitCallback) {
            var savedApplicableSubstitutions = applicableSubstitutions;
            var savedCurrentSourceFile = currentSourceFile;
            if (ts.isSourceFile(node)) {
                currentSourceFile = node;
            }
            if (enabledSubstitutions & 2 /* TypeScriptSubstitutionFlags.NamespaceExports */ && isTransformedModuleDeclaration(node)) {
                applicableSubstitutions |= 2 /* TypeScriptSubstitutionFlags.NamespaceExports */;
            }
            if (enabledSubstitutions & 8 /* TypeScriptSubstitutionFlags.NonQualifiedEnumMembers */ && isTransformedEnumDeclaration(node)) {
                applicableSubstitutions |= 8 /* TypeScriptSubstitutionFlags.NonQualifiedEnumMembers */;
            }
            previousOnEmitNode(hint, node, emitCallback);
            applicableSubstitutions = savedApplicableSubstitutions;
            currentSourceFile = savedCurrentSourceFile;
        }
        /**
         * Hooks node substitutions.
         *
         * @param hint A hint as to the intended usage of the node.
         * @param node The node to substitute.
         */
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1 /* EmitHint.Expression */) {
                return substituteExpression(node);
            }
            else if (ts.isShorthandPropertyAssignment(node)) {
                return substituteShorthandPropertyAssignment(node);
            }
            return node;
        }
        function substituteShorthandPropertyAssignment(node) {
            if (enabledSubstitutions & 2 /* TypeScriptSubstitutionFlags.NamespaceExports */) {
                var name = node.name;
                var exportedName = trySubstituteNamespaceExportedName(name);
                if (exportedName) {
                    // A shorthand property with an assignment initializer is probably part of a
                    // destructuring assignment
                    if (node.objectAssignmentInitializer) {
                        var initializer = factory.createAssignment(exportedName, node.objectAssignmentInitializer);
                        return ts.setTextRange(factory.createPropertyAssignment(name, initializer), node);
                    }
                    return ts.setTextRange(factory.createPropertyAssignment(name, exportedName), node);
                }
            }
            return node;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 79 /* SyntaxKind.Identifier */:
                    return substituteExpressionIdentifier(node);
                case 206 /* SyntaxKind.PropertyAccessExpression */:
                    return substitutePropertyAccessExpression(node);
                case 207 /* SyntaxKind.ElementAccessExpression */:
                    return substituteElementAccessExpression(node);
            }
            return node;
        }
        function substituteExpressionIdentifier(node) {
            return trySubstituteClassAlias(node)
                || trySubstituteNamespaceExportedName(node)
                || node;
        }
        function trySubstituteClassAlias(node) {
            if (enabledSubstitutions & 1 /* TypeScriptSubstitutionFlags.ClassAliases */) {
                if (resolver.getNodeCheckFlags(node) & 33554432 /* NodeCheckFlags.ConstructorReferenceInClass */) {
                    // Due to the emit for class decorators, any reference to the class from inside of the class body
                    // must instead be rewritten to point to a temporary variable to avoid issues with the double-bind
                    // behavior of class names in ES6.
                    // Also, when emitting statics for class expressions, we must substitute a class alias for
                    // constructor references in static property initializers.
                    var declaration = resolver.getReferencedValueDeclaration(node);
                    if (declaration) {
                        var classAlias = classAliases[declaration.id]; // TODO: GH#18217
                        if (classAlias) {
                            var clone_2 = factory.cloneNode(classAlias);
                            ts.setSourceMapRange(clone_2, node);
                            ts.setCommentRange(clone_2, node);
                            return clone_2;
                        }
                    }
                }
            }
            return undefined;
        }
        function trySubstituteNamespaceExportedName(node) {
            // If this is explicitly a local name, do not substitute.
            if (enabledSubstitutions & applicableSubstitutions && !ts.isGeneratedIdentifier(node) && !ts.isLocalName(node)) {
                // If we are nested within a namespace declaration, we may need to qualifiy
                // an identifier that is exported from a merged namespace.
                var container = resolver.getReferencedExportContainer(node, /*prefixLocals*/ false);
                if (container && container.kind !== 305 /* SyntaxKind.SourceFile */) {
                    var substitute = (applicableSubstitutions & 2 /* TypeScriptSubstitutionFlags.NamespaceExports */ && container.kind === 261 /* SyntaxKind.ModuleDeclaration */) ||
                        (applicableSubstitutions & 8 /* TypeScriptSubstitutionFlags.NonQualifiedEnumMembers */ && container.kind === 260 /* SyntaxKind.EnumDeclaration */);
                    if (substitute) {
                        return ts.setTextRange(factory.createPropertyAccessExpression(factory.getGeneratedNameForNode(container), node), 
                        /*location*/ node);
                    }
                }
            }
            return undefined;
        }
        function substitutePropertyAccessExpression(node) {
            return substituteConstantValue(node);
        }
        function substituteElementAccessExpression(node) {
            return substituteConstantValue(node);
        }
        function safeMultiLineComment(value) {
            return value.replace(/\*\//g, "*_/");
        }
        function substituteConstantValue(node) {
            var constantValue = tryGetConstEnumValue(node);
            if (constantValue !== undefined) {
                // track the constant value on the node for the printer in needsDotDotForPropertyAccess
                ts.setConstantValue(node, constantValue);
                var substitute = typeof constantValue === "string" ? factory.createStringLiteral(constantValue) : factory.createNumericLiteral(constantValue);
                if (!compilerOptions.removeComments) {
                    var originalNode = ts.getOriginalNode(node, ts.isAccessExpression);
                    ts.addSyntheticTrailingComment(substitute, 3 /* SyntaxKind.MultiLineCommentTrivia */, " ".concat(safeMultiLineComment(ts.getTextOfNode(originalNode)), " "));
                }
                return substitute;
            }
            return node;
        }
        function tryGetConstEnumValue(node) {
            if (compilerOptions.isolatedModules) {
                return undefined;
            }
            return ts.isPropertyAccessExpression(node) || ts.isElementAccessExpression(node) ? resolver.getConstantValue(node) : undefined;
        }
        function shouldEmitAliasDeclaration(node) {
            return compilerOptions.preserveValueImports
                ? resolver.isValueAliasDeclaration(node)
                : resolver.isReferencedAliasDeclaration(node);
        }
    }
    ts.transformTypeScript = transformTypeScript;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var ClassPropertySubstitutionFlags;
    (function (ClassPropertySubstitutionFlags) {
        /**
         * Enables substitutions for class expressions with static fields
         * which have initializers that reference the class name.
         */
        ClassPropertySubstitutionFlags[ClassPropertySubstitutionFlags["ClassAliases"] = 1] = "ClassAliases";
        /**
         * Enables substitutions for class expressions with static fields
         * which have initializers that reference the 'this' or 'super'.
         */
        ClassPropertySubstitutionFlags[ClassPropertySubstitutionFlags["ClassStaticThisOrSuperReference"] = 2] = "ClassStaticThisOrSuperReference";
    })(ClassPropertySubstitutionFlags || (ClassPropertySubstitutionFlags = {}));
    var PrivateIdentifierKind;
    (function (PrivateIdentifierKind) {
        PrivateIdentifierKind["Field"] = "f";
        PrivateIdentifierKind["Method"] = "m";
        PrivateIdentifierKind["Accessor"] = "a";
    })(PrivateIdentifierKind = ts.PrivateIdentifierKind || (ts.PrivateIdentifierKind = {}));
    var ClassFacts;
    (function (ClassFacts) {
        ClassFacts[ClassFacts["None"] = 0] = "None";
        ClassFacts[ClassFacts["ClassWasDecorated"] = 1] = "ClassWasDecorated";
        ClassFacts[ClassFacts["NeedsClassConstructorReference"] = 2] = "NeedsClassConstructorReference";
        ClassFacts[ClassFacts["NeedsClassSuperReference"] = 4] = "NeedsClassSuperReference";
        ClassFacts[ClassFacts["NeedsSubstitutionForThisInClassStaticField"] = 8] = "NeedsSubstitutionForThisInClassStaticField";
    })(ClassFacts || (ClassFacts = {}));
    /**
     * Transforms ECMAScript Class Syntax.
     * TypeScript parameter property syntax is transformed in the TypeScript transformer.
     * For now, this transforms public field declarations using TypeScript class semantics,
     * where declarations are elided and initializers are transformed as assignments in the constructor.
     * When --useDefineForClassFields is on, this transforms to ECMAScript semantics, with Object.defineProperty.
     */
    function transformClassFields(context) {
        var factory = context.factory, hoistVariableDeclaration = context.hoistVariableDeclaration, endLexicalEnvironment = context.endLexicalEnvironment, startLexicalEnvironment = context.startLexicalEnvironment, resumeLexicalEnvironment = context.resumeLexicalEnvironment, addBlockScopedVariable = context.addBlockScopedVariable;
        var resolver = context.getEmitResolver();
        var compilerOptions = context.getCompilerOptions();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var useDefineForClassFields = ts.getUseDefineForClassFields(compilerOptions);
        var shouldTransformPrivateElementsOrClassStaticBlocks = languageVersion < 9 /* ScriptTarget.ES2022 */;
        // We need to transform `this` in a static initializer into a reference to the class
        // when targeting < ES2022 since the assignment will be moved outside of the class body.
        var shouldTransformThisInStaticInitializers = languageVersion < 9 /* ScriptTarget.ES2022 */;
        // We don't need to transform `super` property access when targeting ES5, ES3 because
        // the es2015 transformation handles those.
        var shouldTransformSuperInStaticInitializers = shouldTransformThisInStaticInitializers && languageVersion >= 2 /* ScriptTarget.ES2015 */;
        var previousOnSubstituteNode = context.onSubstituteNode;
        context.onSubstituteNode = onSubstituteNode;
        var previousOnEmitNode = context.onEmitNode;
        context.onEmitNode = onEmitNode;
        var enabledSubstitutions;
        var classAliases;
        /**
         * Tracks what computed name expressions originating from elided names must be inlined
         * at the next execution site, in document order
         */
        var pendingExpressions;
        /**
         * Tracks what computed name expression statements and static property initializers must be
         * emitted at the next execution site, in document order (for decorated classes).
         */
        var pendingStatements;
        var classLexicalEnvironmentStack = [];
        var classLexicalEnvironmentMap = new ts.Map();
        var currentClassLexicalEnvironment;
        var currentComputedPropertyNameClassLexicalEnvironment;
        var currentStaticPropertyDeclarationOrStaticBlock;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            var options = context.getCompilerOptions();
            if (node.isDeclarationFile
                || useDefineForClassFields && ts.getEmitScriptTarget(options) >= 9 /* ScriptTarget.ES2022 */) {
                return node;
            }
            var visited = ts.visitEachChild(node, visitor, context);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            return visited;
        }
        function visitorWorker(node, valueIsDiscarded) {
            if (node.transformFlags & 8388608 /* TransformFlags.ContainsClassFields */) {
                switch (node.kind) {
                    case 226 /* SyntaxKind.ClassExpression */:
                    case 257 /* SyntaxKind.ClassDeclaration */:
                        return visitClassLike(node);
                    case 167 /* SyntaxKind.PropertyDeclaration */:
                        return visitPropertyDeclaration(node);
                    case 237 /* SyntaxKind.VariableStatement */:
                        return visitVariableStatement(node);
                    case 80 /* SyntaxKind.PrivateIdentifier */:
                        return visitPrivateIdentifier(node);
                    case 170 /* SyntaxKind.ClassStaticBlockDeclaration */:
                        return visitClassStaticBlockDeclaration(node);
                }
            }
            if (node.transformFlags & 8388608 /* TransformFlags.ContainsClassFields */ ||
                node.transformFlags & 33554432 /* TransformFlags.ContainsLexicalSuper */ &&
                    shouldTransformSuperInStaticInitializers &&
                    currentStaticPropertyDeclarationOrStaticBlock &&
                    currentClassLexicalEnvironment) {
                switch (node.kind) {
                    case 219 /* SyntaxKind.PrefixUnaryExpression */:
                    case 220 /* SyntaxKind.PostfixUnaryExpression */:
                        return visitPreOrPostfixUnaryExpression(node, valueIsDiscarded);
                    case 221 /* SyntaxKind.BinaryExpression */:
                        return visitBinaryExpression(node, valueIsDiscarded);
                    case 208 /* SyntaxKind.CallExpression */:
                        return visitCallExpression(node);
                    case 210 /* SyntaxKind.TaggedTemplateExpression */:
                        return visitTaggedTemplateExpression(node);
                    case 206 /* SyntaxKind.PropertyAccessExpression */:
                        return visitPropertyAccessExpression(node);
                    case 207 /* SyntaxKind.ElementAccessExpression */:
                        return visitElementAccessExpression(node);
                    case 238 /* SyntaxKind.ExpressionStatement */:
                        return visitExpressionStatement(node);
                    case 242 /* SyntaxKind.ForStatement */:
                        return visitForStatement(node);
                    case 256 /* SyntaxKind.FunctionDeclaration */:
                    case 213 /* SyntaxKind.FunctionExpression */:
                    case 171 /* SyntaxKind.Constructor */:
                    case 169 /* SyntaxKind.MethodDeclaration */:
                    case 172 /* SyntaxKind.GetAccessor */:
                    case 173 /* SyntaxKind.SetAccessor */: {
                        var savedCurrentStaticPropertyDeclarationOrStaticBlock = currentStaticPropertyDeclarationOrStaticBlock;
                        currentStaticPropertyDeclarationOrStaticBlock = undefined;
                        var result = ts.visitEachChild(node, visitor, context);
                        currentStaticPropertyDeclarationOrStaticBlock = savedCurrentStaticPropertyDeclarationOrStaticBlock;
                        return result;
                    }
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function discardedValueVisitor(node) {
            return visitorWorker(node, /*valueIsDiscarded*/ true);
        }
        function visitor(node) {
            return visitorWorker(node, /*valueIsDiscarded*/ false);
        }
        function heritageClauseVisitor(node) {
            switch (node.kind) {
                case 291 /* SyntaxKind.HeritageClause */:
                    return ts.visitEachChild(node, heritageClauseVisitor, context);
                case 228 /* SyntaxKind.ExpressionWithTypeArguments */:
                    return visitExpressionWithTypeArguments(node);
            }
            return visitor(node);
        }
        function visitorDestructuringTarget(node) {
            switch (node.kind) {
                case 205 /* SyntaxKind.ObjectLiteralExpression */:
                case 204 /* SyntaxKind.ArrayLiteralExpression */:
                    return visitAssignmentPattern(node);
                default:
                    return visitor(node);
            }
        }
        /**
         * If we visit a private name, this means it is an undeclared private name.
         * Replace it with an empty identifier to indicate a problem with the code,
         * unless we are in a statement position - otherwise this will not trigger
         * a SyntaxError.
         */
        function visitPrivateIdentifier(node) {
            if (!shouldTransformPrivateElementsOrClassStaticBlocks) {
                return node;
            }
            if (ts.isStatement(node.parent)) {
                return node;
            }
            return ts.setOriginalNode(factory.createIdentifier(""), node);
        }
        /**
         * Visits `#id in expr`
         */
        function visitPrivateIdentifierInInExpression(node) {
            if (!shouldTransformPrivateElementsOrClassStaticBlocks) {
                return node;
            }
            var privId = node.left;
            ts.Debug.assertNode(privId, ts.isPrivateIdentifier);
            ts.Debug.assert(node.operatorToken.kind === 101 /* SyntaxKind.InKeyword */);
            var info = accessPrivateIdentifier(privId);
            if (info) {
                var receiver = ts.visitNode(node.right, visitor, ts.isExpression);
                return ts.setOriginalNode(context.getEmitHelperFactory().createClassPrivateFieldInHelper(info.brandCheckIdentifier, receiver), node);
            }
            // Private name has not been declared. Subsequent transformers will handle this error
            return ts.visitEachChild(node, visitor, context);
        }
        /**
         * Visits the members of a class that has fields.
         *
         * @param node The node to visit.
         */
        function classElementVisitor(node) {
            switch (node.kind) {
                case 171 /* SyntaxKind.Constructor */:
                    // Constructors for classes using class fields are transformed in
                    // `visitClassDeclaration` or `visitClassExpression`.
                    return undefined;
                case 172 /* SyntaxKind.GetAccessor */:
                case 173 /* SyntaxKind.SetAccessor */:
                case 169 /* SyntaxKind.MethodDeclaration */:
                    return visitMethodOrAccessorDeclaration(node);
                case 167 /* SyntaxKind.PropertyDeclaration */:
                    return visitPropertyDeclaration(node);
                case 162 /* SyntaxKind.ComputedPropertyName */:
                    return visitComputedPropertyName(node);
                case 234 /* SyntaxKind.SemicolonClassElement */:
                    return node;
                default:
                    return visitor(node);
            }
        }
        function visitVariableStatement(node) {
            var savedPendingStatements = pendingStatements;
            pendingStatements = [];
            var visitedNode = ts.visitEachChild(node, visitor, context);
            var statement = ts.some(pendingStatements) ? __spreadArray([visitedNode], pendingStatements, true) :
                visitedNode;
            pendingStatements = savedPendingStatements;
            return statement;
        }
        function visitComputedPropertyName(name) {
            var node = ts.visitEachChild(name, visitor, context);
            if (ts.some(pendingExpressions)) {
                var expressions = pendingExpressions;
                expressions.push(node.expression);
                pendingExpressions = [];
                node = factory.updateComputedPropertyName(node, factory.inlineExpressions(expressions));
            }
            return node;
        }
        function visitMethodOrAccessorDeclaration(node) {
            ts.Debug.assert(!ts.some(node.decorators));
            if (!shouldTransformPrivateElementsOrClassStaticBlocks || !ts.isPrivateIdentifier(node.name)) {
                return ts.visitEachChild(node, classElementVisitor, context);
            }
            // leave invalid code untransformed
            var info = accessPrivateIdentifier(node.name);
            ts.Debug.assert(info, "Undeclared private name for property declaration.");
            if (!info.isValid) {
                return node;
            }
            var functionName = getHoistedFunctionName(node);
            if (functionName) {
                getPendingExpressions().push(factory.createAssignment(functionName, factory.createFunctionExpression(ts.filter(node.modifiers, function (m) { return !ts.isStaticModifier(m); }), node.asteriskToken, functionName, 
                /* typeParameters */ undefined, ts.visitParameterList(node.parameters, classElementVisitor, context), 
                /* type */ undefined, ts.visitFunctionBody(node.body, classElementVisitor, context))));
            }
            // remove method declaration from class
            return undefined;
        }
        function getHoistedFunctionName(node) {
            ts.Debug.assert(ts.isPrivateIdentifier(node.name));
            var info = accessPrivateIdentifier(node.name);
            ts.Debug.assert(info, "Undeclared private name for property declaration.");
            if (info.kind === "m" /* PrivateIdentifierKind.Method */) {
                return info.methodName;
            }
            if (info.kind === "a" /* PrivateIdentifierKind.Accessor */) {
                if (ts.isGetAccessor(node)) {
                    return info.getterName;
                }
                if (ts.isSetAccessor(node)) {
                    return info.setterName;
                }
            }
        }
        function visitPropertyDeclaration(node) {
            ts.Debug.assert(!ts.some(node.decorators));
            if (ts.isPrivateIdentifier(node.name)) {
                if (!shouldTransformPrivateElementsOrClassStaticBlocks) {
                    if (ts.isStatic(node)) {
                        // static fields are left as is
                        return ts.visitEachChild(node, visitor, context);
                    }
                    // Initializer is elided as the field is initialized in transformConstructor.
                    return factory.updatePropertyDeclaration(node, 
                    /*decorators*/ undefined, ts.visitNodes(node.modifiers, visitor, ts.isModifier), node.name, 
                    /*questionOrExclamationToken*/ undefined, 
                    /*type*/ undefined, 
                    /*initializer*/ undefined);
                }
                // leave invalid code untransformed
                var info = accessPrivateIdentifier(node.name);
                ts.Debug.assert(info, "Undeclared private name for property declaration.");
                if (!info.isValid) {
                    return node;
                }
            }
            // Create a temporary variable to store a computed property name (if necessary).
            // If it's not inlineable, then we emit an expression after the class which assigns
            // the property name to the temporary variable.
            var expr = getPropertyNameExpressionIfNeeded(node.name, !!node.initializer || useDefineForClassFields);
            if (expr && !ts.isSimpleInlineableExpression(expr)) {
                getPendingExpressions().push(expr);
            }
            if (ts.isStatic(node) && !shouldTransformPrivateElementsOrClassStaticBlocks && !useDefineForClassFields) {
                var initializerStatement = transformPropertyOrClassStaticBlock(node, factory.createThis());
                if (initializerStatement) {
                    var staticBlock = factory.createClassStaticBlockDeclaration(
                    /*decorators*/ undefined, 
                    /*modifiers*/ undefined, factory.createBlock([initializerStatement]));
                    ts.setOriginalNode(staticBlock, node);
                    ts.setCommentRange(staticBlock, node);
                    // Set the comment range for the statement to an empty synthetic range
                    // and drop synthetic comments from the statement to avoid printing them twice.
                    ts.setCommentRange(initializerStatement, { pos: -1, end: -1 });
                    ts.setSyntheticLeadingComments(initializerStatement, undefined);
                    ts.setSyntheticTrailingComments(initializerStatement, undefined);
                    return staticBlock;
                }
            }
            return undefined;
        }
        function createPrivateIdentifierAccess(info, receiver) {
            return createPrivateIdentifierAccessHelper(info, ts.visitNode(receiver, visitor, ts.isExpression));
        }
        function createPrivateIdentifierAccessHelper(info, receiver) {
            ts.setCommentRange(receiver, ts.moveRangePos(receiver, -1));
            switch (info.kind) {
                case "a" /* PrivateIdentifierKind.Accessor */:
                    return context.getEmitHelperFactory().createClassPrivateFieldGetHelper(receiver, info.brandCheckIdentifier, info.kind, info.getterName);
                case "m" /* PrivateIdentifierKind.Method */:
                    return context.getEmitHelperFactory().createClassPrivateFieldGetHelper(receiver, info.brandCheckIdentifier, info.kind, info.methodName);
                case "f" /* PrivateIdentifierKind.Field */:
                    return context.getEmitHelperFactory().createClassPrivateFieldGetHelper(receiver, info.brandCheckIdentifier, info.kind, info.variableName);
                default:
                    ts.Debug.assertNever(info, "Unknown private element type");
            }
        }
        function visitPropertyAccessExpression(node) {
            if (shouldTransformPrivateElementsOrClassStaticBlocks && ts.isPrivateIdentifier(node.name)) {
                var privateIdentifierInfo = accessPrivateIdentifier(node.name);
                if (privateIdentifierInfo) {
                    return ts.setTextRange(ts.setOriginalNode(createPrivateIdentifierAccess(privateIdentifierInfo, node.expression), node), node);
                }
            }
            if (shouldTransformSuperInStaticInitializers &&
                ts.isSuperProperty(node) &&
                ts.isIdentifier(node.name) &&
                currentStaticPropertyDeclarationOrStaticBlock &&
                currentClassLexicalEnvironment) {
                var classConstructor = currentClassLexicalEnvironment.classConstructor, superClassReference = currentClassLexicalEnvironment.superClassReference, facts = currentClassLexicalEnvironment.facts;
                if (facts & 1 /* ClassFacts.ClassWasDecorated */) {
                    return visitInvalidSuperProperty(node);
                }
                if (classConstructor && superClassReference) {
                    // converts `super.x` into `Reflect.get(_baseTemp, "x", _classTemp)`
                    var superProperty = factory.createReflectGetCall(superClassReference, factory.createStringLiteralFromNode(node.name), classConstructor);
                    ts.setOriginalNode(superProperty, node.expression);
                    ts.setTextRange(superProperty, node.expression);
                    return superProperty;
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitElementAccessExpression(node) {
            if (shouldTransformSuperInStaticInitializers &&
                ts.isSuperProperty(node) &&
                currentStaticPropertyDeclarationOrStaticBlock &&
                currentClassLexicalEnvironment) {
                var classConstructor = currentClassLexicalEnvironment.classConstructor, superClassReference = currentClassLexicalEnvironment.superClassReference, facts = currentClassLexicalEnvironment.facts;
                if (facts & 1 /* ClassFacts.ClassWasDecorated */) {
                    return visitInvalidSuperProperty(node);
                }
                if (classConstructor && superClassReference) {
                    // converts `super[x]` into `Reflect.get(_baseTemp, x, _classTemp)`
                    var superProperty = factory.createReflectGetCall(superClassReference, ts.visitNode(node.argumentExpression, visitor, ts.isExpression), classConstructor);
                    ts.setOriginalNode(superProperty, node.expression);
                    ts.setTextRange(superProperty, node.expression);
                    return superProperty;
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitPreOrPostfixUnaryExpression(node, valueIsDiscarded) {
            if (node.operator === 45 /* SyntaxKind.PlusPlusToken */ || node.operator === 46 /* SyntaxKind.MinusMinusToken */) {
                if (shouldTransformPrivateElementsOrClassStaticBlocks && ts.isPrivateIdentifierPropertyAccessExpression(node.operand)) {
                    var info = void 0;
                    if (info = accessPrivateIdentifier(node.operand.name)) {
                        var receiver = ts.visitNode(node.operand.expression, visitor, ts.isExpression);
                        var _a = createCopiableReceiverExpr(receiver), readExpression = _a.readExpression, initializeExpression = _a.initializeExpression;
                        var expression = createPrivateIdentifierAccess(info, readExpression);
                        var temp = ts.isPrefixUnaryExpression(node) || valueIsDiscarded ? undefined : factory.createTempVariable(hoistVariableDeclaration);
                        expression = ts.expandPreOrPostfixIncrementOrDecrementExpression(factory, node, expression, hoistVariableDeclaration, temp);
                        expression = createPrivateIdentifierAssignment(info, initializeExpression || readExpression, expression, 63 /* SyntaxKind.EqualsToken */);
                        ts.setOriginalNode(expression, node);
                        ts.setTextRange(expression, node);
                        if (temp) {
                            expression = factory.createComma(expression, temp);
                            ts.setTextRange(expression, node);
                        }
                        return expression;
                    }
                }
                else if (shouldTransformSuperInStaticInitializers &&
                    ts.isSuperProperty(node.operand) &&
                    currentStaticPropertyDeclarationOrStaticBlock &&
                    currentClassLexicalEnvironment) {
                    // converts `++super.a` into `(Reflect.set(_baseTemp, "a", (_a = Reflect.get(_baseTemp, "a", _classTemp), _b = ++_a), _classTemp), _b)`
                    // converts `++super[f()]` into `(Reflect.set(_baseTemp, _a = f(), (_b = Reflect.get(_baseTemp, _a, _classTemp), _c = ++_b), _classTemp), _c)`
                    // converts `--super.a` into `(Reflect.set(_baseTemp, "a", (_a = Reflect.get(_baseTemp, "a", _classTemp), _b = --_a), _classTemp), _b)`
                    // converts `--super[f()]` into `(Reflect.set(_baseTemp, _a = f(), (_b = Reflect.get(_baseTemp, _a, _classTemp), _c = --_b), _classTemp), _c)`
                    // converts `super.a++` into `(Reflect.set(_baseTemp, "a", (_a = Reflect.get(_baseTemp, "a", _classTemp), _b = _a++), _classTemp), _b)`
                    // converts `super[f()]++` into `(Reflect.set(_baseTemp, _a = f(), (_b = Reflect.get(_baseTemp, _a, _classTemp), _c = _b++), _classTemp), _c)`
                    // converts `super.a--` into `(Reflect.set(_baseTemp, "a", (_a = Reflect.get(_baseTemp, "a", _classTemp), _b = _a--), _classTemp), _b)`
                    // converts `super[f()]--` into `(Reflect.set(_baseTemp, _a = f(), (_b = Reflect.get(_baseTemp, _a, _classTemp), _c = _b--), _classTemp), _c)`
                    var classConstructor = currentClassLexicalEnvironment.classConstructor, superClassReference = currentClassLexicalEnvironment.superClassReference, facts = currentClassLexicalEnvironment.facts;
                    if (facts & 1 /* ClassFacts.ClassWasDecorated */) {
                        var operand = visitInvalidSuperProperty(node.operand);
                        return ts.isPrefixUnaryExpression(node) ?
                            factory.updatePrefixUnaryExpression(node, operand) :
                            factory.updatePostfixUnaryExpression(node, operand);
                    }
                    if (classConstructor && superClassReference) {
                        var setterName = void 0;
                        var getterName = void 0;
                        if (ts.isPropertyAccessExpression(node.operand)) {
                            if (ts.isIdentifier(node.operand.name)) {
                                getterName = setterName = factory.createStringLiteralFromNode(node.operand.name);
                            }
                        }
                        else {
                            if (ts.isSimpleInlineableExpression(node.operand.argumentExpression)) {
                                getterName = setterName = node.operand.argumentExpression;
                            }
                            else {
                                getterName = factory.createTempVariable(hoistVariableDeclaration);
                                setterName = factory.createAssignment(getterName, ts.visitNode(node.operand.argumentExpression, visitor, ts.isExpression));
                            }
                        }
                        if (setterName && getterName) {
                            var expression = factory.createReflectGetCall(superClassReference, getterName, classConstructor);
                            ts.setTextRange(expression, node.operand);
                            var temp = valueIsDiscarded ? undefined : factory.createTempVariable(hoistVariableDeclaration);
                            expression = ts.expandPreOrPostfixIncrementOrDecrementExpression(factory, node, expression, hoistVariableDeclaration, temp);
                            expression = factory.createReflectSetCall(superClassReference, setterName, expression, classConstructor);
                            ts.setOriginalNode(expression, node);
                            ts.setTextRange(expression, node);
                            if (temp) {
                                expression = factory.createComma(expression, temp);
                                ts.setTextRange(expression, node);
                            }
                            return expression;
                        }
                    }
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitForStatement(node) {
            return factory.updateForStatement(node, ts.visitNode(node.initializer, discardedValueVisitor, ts.isForInitializer), ts.visitNode(node.condition, visitor, ts.isExpression), ts.visitNode(node.incrementor, discardedValueVisitor, ts.isExpression), ts.visitIterationBody(node.statement, visitor, context));
        }
        function visitExpressionStatement(node) {
            return factory.updateExpressionStatement(node, ts.visitNode(node.expression, discardedValueVisitor, ts.isExpression));
        }
        function createCopiableReceiverExpr(receiver) {
            var clone = ts.nodeIsSynthesized(receiver) ? receiver : factory.cloneNode(receiver);
            if (ts.isSimpleInlineableExpression(receiver)) {
                return { readExpression: clone, initializeExpression: undefined };
            }
            var readExpression = factory.createTempVariable(hoistVariableDeclaration);
            var initializeExpression = factory.createAssignment(readExpression, clone);
            return { readExpression: readExpression, initializeExpression: initializeExpression };
        }
        function visitCallExpression(node) {
            if (shouldTransformPrivateElementsOrClassStaticBlocks && ts.isPrivateIdentifierPropertyAccessExpression(node.expression)) {
                // Transform call expressions of private names to properly bind the `this` parameter.
                var _a = factory.createCallBinding(node.expression, hoistVariableDeclaration, languageVersion), thisArg = _a.thisArg, target = _a.target;
                if (ts.isCallChain(node)) {
                    return factory.updateCallChain(node, factory.createPropertyAccessChain(ts.visitNode(target, visitor), node.questionDotToken, "call"), 
                    /*questionDotToken*/ undefined, 
                    /*typeArguments*/ undefined, __spreadArray([ts.visitNode(thisArg, visitor, ts.isExpression)], ts.visitNodes(node.arguments, visitor, ts.isExpression), true));
                }
                return factory.updateCallExpression(node, factory.createPropertyAccessExpression(ts.visitNode(target, visitor), "call"), 
                /*typeArguments*/ undefined, __spreadArray([ts.visitNode(thisArg, visitor, ts.isExpression)], ts.visitNodes(node.arguments, visitor, ts.isExpression), true));
            }
            if (shouldTransformSuperInStaticInitializers &&
                ts.isSuperProperty(node.expression) &&
                currentStaticPropertyDeclarationOrStaticBlock &&
                (currentClassLexicalEnvironment === null || currentClassLexicalEnvironment === void 0 ? void 0 : currentClassLexicalEnvironment.classConstructor)) {
                // converts `super.f(...)` into `Reflect.get(_baseTemp, "f", _classTemp).call(_classTemp, ...)`
                var invocation = factory.createFunctionCallCall(ts.visitNode(node.expression, visitor, ts.isExpression), currentClassLexicalEnvironment.classConstructor, ts.visitNodes(node.arguments, visitor, ts.isExpression));
                ts.setOriginalNode(invocation, node);
                ts.setTextRange(invocation, node);
                return invocation;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitTaggedTemplateExpression(node) {
            if (shouldTransformPrivateElementsOrClassStaticBlocks && ts.isPrivateIdentifierPropertyAccessExpression(node.tag)) {
                // Bind the `this` correctly for tagged template literals when the tag is a private identifier property access.
                var _a = factory.createCallBinding(node.tag, hoistVariableDeclaration, languageVersion), thisArg = _a.thisArg, target = _a.target;
                return factory.updateTaggedTemplateExpression(node, factory.createCallExpression(factory.createPropertyAccessExpression(ts.visitNode(target, visitor), "bind"), 
                /*typeArguments*/ undefined, [ts.visitNode(thisArg, visitor, ts.isExpression)]), 
                /*typeArguments*/ undefined, ts.visitNode(node.template, visitor, ts.isTemplateLiteral));
            }
            if (shouldTransformSuperInStaticInitializers &&
                ts.isSuperProperty(node.tag) &&
                currentStaticPropertyDeclarationOrStaticBlock &&
                (currentClassLexicalEnvironment === null || currentClassLexicalEnvironment === void 0 ? void 0 : currentClassLexicalEnvironment.classConstructor)) {
                // converts `` super.f`x` `` into `` Reflect.get(_baseTemp, "f", _classTemp).bind(_classTemp)`x` ``
                var invocation = factory.createFunctionBindCall(ts.visitNode(node.tag, visitor, ts.isExpression), currentClassLexicalEnvironment.classConstructor, []);
                ts.setOriginalNode(invocation, node);
                ts.setTextRange(invocation, node);
                return factory.updateTaggedTemplateExpression(node, invocation, 
                /*typeArguments*/ undefined, ts.visitNode(node.template, visitor, ts.isTemplateLiteral));
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function transformClassStaticBlockDeclaration(node) {
            if (shouldTransformPrivateElementsOrClassStaticBlocks) {
                if (currentClassLexicalEnvironment) {
                    classLexicalEnvironmentMap.set(ts.getOriginalNodeId(node), currentClassLexicalEnvironment);
                }
                startLexicalEnvironment();
                var savedCurrentStaticPropertyDeclarationOrStaticBlock = currentStaticPropertyDeclarationOrStaticBlock;
                currentStaticPropertyDeclarationOrStaticBlock = node;
                var statements = ts.visitNodes(node.body.statements, visitor, ts.isStatement);
                statements = factory.mergeLexicalEnvironment(statements, endLexicalEnvironment());
                currentStaticPropertyDeclarationOrStaticBlock = savedCurrentStaticPropertyDeclarationOrStaticBlock;
                var iife = factory.createImmediatelyInvokedArrowFunction(statements);
                ts.setOriginalNode(iife, node);
                ts.setTextRange(iife, node);
                ts.addEmitFlags(iife, 2 /* EmitFlags.AdviseOnEmitNode */);
                return iife;
            }
        }
        function visitBinaryExpression(node, valueIsDiscarded) {
            if (ts.isDestructuringAssignment(node)) {
                var savedPendingExpressions = pendingExpressions;
                pendingExpressions = undefined;
                node = factory.updateBinaryExpression(node, ts.visitNode(node.left, visitorDestructuringTarget), node.operatorToken, ts.visitNode(node.right, visitor));
                var expr = ts.some(pendingExpressions) ?
                    factory.inlineExpressions(ts.compact(__spreadArray(__spreadArray([], pendingExpressions, true), [node], false))) :
                    node;
                pendingExpressions = savedPendingExpressions;
                return expr;
            }
            if (ts.isAssignmentExpression(node)) {
                if (shouldTransformPrivateElementsOrClassStaticBlocks && ts.isPrivateIdentifierPropertyAccessExpression(node.left)) {
                    var info = accessPrivateIdentifier(node.left.name);
                    if (info) {
                        return ts.setTextRange(ts.setOriginalNode(createPrivateIdentifierAssignment(info, node.left.expression, node.right, node.operatorToken.kind), node), node);
                    }
                }
                else if (shouldTransformSuperInStaticInitializers &&
                    ts.isSuperProperty(node.left) &&
                    currentStaticPropertyDeclarationOrStaticBlock &&
                    currentClassLexicalEnvironment) {
                    var classConstructor = currentClassLexicalEnvironment.classConstructor, superClassReference = currentClassLexicalEnvironment.superClassReference, facts = currentClassLexicalEnvironment.facts;
                    if (facts & 1 /* ClassFacts.ClassWasDecorated */) {
                        return factory.updateBinaryExpression(node, visitInvalidSuperProperty(node.left), node.operatorToken, ts.visitNode(node.right, visitor, ts.isExpression));
                    }
                    if (classConstructor && superClassReference) {
                        var setterName = ts.isElementAccessExpression(node.left) ? ts.visitNode(node.left.argumentExpression, visitor, ts.isExpression) :
                            ts.isIdentifier(node.left.name) ? factory.createStringLiteralFromNode(node.left.name) :
                                undefined;
                        if (setterName) {
                            // converts `super.x = 1` into `(Reflect.set(_baseTemp, "x", _a = 1, _classTemp), _a)`
                            // converts `super[f()] = 1` into `(Reflect.set(_baseTemp, f(), _a = 1, _classTemp), _a)`
                            // converts `super.x += 1` into `(Reflect.set(_baseTemp, "x", _a = Reflect.get(_baseTemp, "x", _classtemp) + 1, _classTemp), _a)`
                            // converts `super[f()] += 1` into `(Reflect.set(_baseTemp, _a = f(), _b = Reflect.get(_baseTemp, _a, _classtemp) + 1, _classTemp), _b)`
                            var expression = ts.visitNode(node.right, visitor, ts.isExpression);
                            if (ts.isCompoundAssignment(node.operatorToken.kind)) {
                                var getterName = setterName;
                                if (!ts.isSimpleInlineableExpression(setterName)) {
                                    getterName = factory.createTempVariable(hoistVariableDeclaration);
                                    setterName = factory.createAssignment(getterName, setterName);
                                }
                                var superPropertyGet = factory.createReflectGetCall(superClassReference, getterName, classConstructor);
                                ts.setOriginalNode(superPropertyGet, node.left);
                                ts.setTextRange(superPropertyGet, node.left);
                                expression = factory.createBinaryExpression(superPropertyGet, ts.getNonAssignmentOperatorForCompoundAssignment(node.operatorToken.kind), expression);
                                ts.setTextRange(expression, node);
                            }
                            var temp = valueIsDiscarded ? undefined : factory.createTempVariable(hoistVariableDeclaration);
                            if (temp) {
                                expression = factory.createAssignment(temp, expression);
                                ts.setTextRange(temp, node);
                            }
                            expression = factory.createReflectSetCall(superClassReference, setterName, expression, classConstructor);
                            ts.setOriginalNode(expression, node);
                            ts.setTextRange(expression, node);
                            if (temp) {
                                expression = factory.createComma(expression, temp);
                                ts.setTextRange(expression, node);
                            }
                            return expression;
                        }
                    }
                }
            }
            if (node.operatorToken.kind === 101 /* SyntaxKind.InKeyword */ && ts.isPrivateIdentifier(node.left)) {
                return visitPrivateIdentifierInInExpression(node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function createPrivateIdentifierAssignment(info, receiver, right, operator) {
            receiver = ts.visitNode(receiver, visitor, ts.isExpression);
            right = ts.visitNode(right, visitor, ts.isExpression);
            if (ts.isCompoundAssignment(operator)) {
                var _a = createCopiableReceiverExpr(receiver), readExpression = _a.readExpression, initializeExpression = _a.initializeExpression;
                receiver = initializeExpression || readExpression;
                right = factory.createBinaryExpression(createPrivateIdentifierAccessHelper(info, readExpression), ts.getNonAssignmentOperatorForCompoundAssignment(operator), right);
            }
            ts.setCommentRange(receiver, ts.moveRangePos(receiver, -1));
            switch (info.kind) {
                case "a" /* PrivateIdentifierKind.Accessor */:
                    return context.getEmitHelperFactory().createClassPrivateFieldSetHelper(receiver, info.brandCheckIdentifier, right, info.kind, info.setterName);
                case "m" /* PrivateIdentifierKind.Method */:
                    return context.getEmitHelperFactory().createClassPrivateFieldSetHelper(receiver, info.brandCheckIdentifier, right, info.kind, 
                    /* f */ undefined);
                case "f" /* PrivateIdentifierKind.Field */:
                    return context.getEmitHelperFactory().createClassPrivateFieldSetHelper(receiver, info.brandCheckIdentifier, right, info.kind, info.variableName);
                default:
                    ts.Debug.assertNever(info, "Unknown private element type");
            }
        }
        /**
         * Set up the environment for a class.
         */
        function visitClassLike(node) {
            if (!ts.forEach(node.members, doesClassElementNeedTransform)) {
                return ts.visitEachChild(node, visitor, context);
            }
            var savedPendingExpressions = pendingExpressions;
            pendingExpressions = undefined;
            startClassLexicalEnvironment();
            if (shouldTransformPrivateElementsOrClassStaticBlocks) {
                var name = ts.getNameOfDeclaration(node);
                if (name && ts.isIdentifier(name)) {
                    getPrivateIdentifierEnvironment().className = ts.idText(name);
                }
                var privateInstanceMethodsAndAccessors = getPrivateInstanceMethodsAndAccessors(node);
                if (ts.some(privateInstanceMethodsAndAccessors)) {
                    getPrivateIdentifierEnvironment().weakSetName = createHoistedVariableForClass("instances", privateInstanceMethodsAndAccessors[0].name);
                }
            }
            var result = ts.isClassDeclaration(node) ?
                visitClassDeclaration(node) :
                visitClassExpression(node);
            endClassLexicalEnvironment();
            pendingExpressions = savedPendingExpressions;
            return result;
        }
        function doesClassElementNeedTransform(node) {
            return ts.isPropertyDeclaration(node) || ts.isClassStaticBlockDeclaration(node) || (shouldTransformPrivateElementsOrClassStaticBlocks && node.name && ts.isPrivateIdentifier(node.name));
        }
        function getPrivateInstanceMethodsAndAccessors(node) {
            return ts.filter(node.members, ts.isNonStaticMethodOrAccessorWithPrivateName);
        }
        function getClassFacts(node) {
            var facts = 0 /* ClassFacts.None */;
            var original = ts.getOriginalNode(node);
            if (ts.isClassDeclaration(original) && ts.classOrConstructorParameterIsDecorated(original)) {
                facts |= 1 /* ClassFacts.ClassWasDecorated */;
            }
            for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                var member = _a[_i];
                if (!ts.isStatic(member))
                    continue;
                if (member.name && ts.isPrivateIdentifier(member.name) && shouldTransformPrivateElementsOrClassStaticBlocks) {
                    facts |= 2 /* ClassFacts.NeedsClassConstructorReference */;
                }
                if (ts.isPropertyDeclaration(member) || ts.isClassStaticBlockDeclaration(member)) {
                    if (shouldTransformThisInStaticInitializers && member.transformFlags & 8192 /* TransformFlags.ContainsLexicalThis */) {
                        facts |= 8 /* ClassFacts.NeedsSubstitutionForThisInClassStaticField */;
                        if (!(facts & 1 /* ClassFacts.ClassWasDecorated */)) {
                            facts |= 2 /* ClassFacts.NeedsClassConstructorReference */;
                        }
                    }
                    if (shouldTransformSuperInStaticInitializers && member.transformFlags & 33554432 /* TransformFlags.ContainsLexicalSuper */) {
                        if (!(facts & 1 /* ClassFacts.ClassWasDecorated */)) {
                            facts |= 2 /* ClassFacts.NeedsClassConstructorReference */ | 4 /* ClassFacts.NeedsClassSuperReference */;
                        }
                    }
                }
            }
            return facts;
        }
        function visitExpressionWithTypeArguments(node) {
            var facts = (currentClassLexicalEnvironment === null || currentClassLexicalEnvironment === void 0 ? void 0 : currentClassLexicalEnvironment.facts) || 0 /* ClassFacts.None */;
            if (facts & 4 /* ClassFacts.NeedsClassSuperReference */) {
                var temp = factory.createTempVariable(hoistVariableDeclaration, /*reserveInNestedScopes*/ true);
                getClassLexicalEnvironment().superClassReference = temp;
                return factory.updateExpressionWithTypeArguments(node, factory.createAssignment(temp, ts.visitNode(node.expression, visitor, ts.isExpression)), 
                /*typeArguments*/ undefined);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitClassDeclaration(node) {
            var facts = getClassFacts(node);
            if (facts) {
                getClassLexicalEnvironment().facts = facts;
            }
            if (facts & 8 /* ClassFacts.NeedsSubstitutionForThisInClassStaticField */) {
                enableSubstitutionForClassStaticThisOrSuperReference();
            }
            // If a class has private static fields, or a static field has a `this` or `super` reference,
            // then we need to allocate a temp variable to hold on to that reference.
            var pendingClassReferenceAssignment;
            if (facts & 2 /* ClassFacts.NeedsClassConstructorReference */) {
                var temp = factory.createTempVariable(hoistVariableDeclaration, /*reservedInNestedScopes*/ true);
                getClassLexicalEnvironment().classConstructor = factory.cloneNode(temp);
                pendingClassReferenceAssignment = factory.createAssignment(temp, factory.getInternalName(node));
            }
            var extendsClauseElement = ts.getEffectiveBaseTypeNode(node);
            var isDerivedClass = !!(extendsClauseElement && ts.skipOuterExpressions(extendsClauseElement.expression).kind !== 104 /* SyntaxKind.NullKeyword */);
            var statements = [
                factory.updateClassDeclaration(node, 
                /*decorators*/ undefined, node.modifiers, node.name, 
                /*typeParameters*/ undefined, ts.visitNodes(node.heritageClauses, heritageClauseVisitor, ts.isHeritageClause), transformClassMembers(node, isDerivedClass))
            ];
            if (pendingClassReferenceAssignment) {
                getPendingExpressions().unshift(pendingClassReferenceAssignment);
            }
            // Write any pending expressions from elided or moved computed property names
            if (ts.some(pendingExpressions)) {
                statements.push(factory.createExpressionStatement(factory.inlineExpressions(pendingExpressions)));
            }
            // Emit static property assignment. Because classDeclaration is lexically evaluated,
            // it is safe to emit static property assignment after classDeclaration
            // From ES6 specification:
            //      HasLexicalDeclaration (N) : Determines if the argument identifier has a binding in this environment record that was created using
            //                                  a lexical declaration such as a LexicalDeclaration or a ClassDeclaration.
            var staticProperties = ts.getStaticPropertiesAndClassStaticBlock(node);
            if (ts.some(staticProperties)) {
                addPropertyOrClassStaticBlockStatements(statements, staticProperties, factory.getInternalName(node));
            }
            return statements;
        }
        function visitClassExpression(node) {
            var facts = getClassFacts(node);
            if (facts) {
                getClassLexicalEnvironment().facts = facts;
            }
            if (facts & 8 /* ClassFacts.NeedsSubstitutionForThisInClassStaticField */) {
                enableSubstitutionForClassStaticThisOrSuperReference();
            }
            // If this class expression is a transformation of a decorated class declaration,
            // then we want to output the pendingExpressions as statements, not as inlined
            // expressions with the class statement.
            //
            // In this case, we use pendingStatements to produce the same output as the
            // class declaration transformation. The VariableStatement visitor will insert
            // these statements after the class expression variable statement.
            var isDecoratedClassDeclaration = !!(facts & 1 /* ClassFacts.ClassWasDecorated */);
            var staticPropertiesOrClassStaticBlocks = ts.getStaticPropertiesAndClassStaticBlock(node);
            var extendsClauseElement = ts.getEffectiveBaseTypeNode(node);
            var isDerivedClass = !!(extendsClauseElement && ts.skipOuterExpressions(extendsClauseElement.expression).kind !== 104 /* SyntaxKind.NullKeyword */);
            var isClassWithConstructorReference = resolver.getNodeCheckFlags(node) & 16777216 /* NodeCheckFlags.ClassWithConstructorReference */;
            var temp;
            function createClassTempVar() {
                var classCheckFlags = resolver.getNodeCheckFlags(node);
                var isClassWithConstructorReference = classCheckFlags & 16777216 /* NodeCheckFlags.ClassWithConstructorReference */;
                var requiresBlockScopedVar = classCheckFlags & 524288 /* NodeCheckFlags.BlockScopedBindingInLoop */;
                return factory.createTempVariable(requiresBlockScopedVar ? addBlockScopedVariable : hoistVariableDeclaration, !!isClassWithConstructorReference);
            }
            if (facts & 2 /* ClassFacts.NeedsClassConstructorReference */) {
                temp = createClassTempVar();
                getClassLexicalEnvironment().classConstructor = factory.cloneNode(temp);
            }
            var classExpression = factory.updateClassExpression(node, ts.visitNodes(node.decorators, visitor, ts.isDecorator), node.modifiers, node.name, 
            /*typeParameters*/ undefined, ts.visitNodes(node.heritageClauses, heritageClauseVisitor, ts.isHeritageClause), transformClassMembers(node, isDerivedClass));
            var hasTransformableStatics = shouldTransformPrivateElementsOrClassStaticBlocks && ts.some(staticPropertiesOrClassStaticBlocks, function (p) { return ts.isClassStaticBlockDeclaration(p) || !!p.initializer || ts.isPrivateIdentifier(p.name); });
            if (hasTransformableStatics || ts.some(pendingExpressions)) {
                if (isDecoratedClassDeclaration) {
                    ts.Debug.assertIsDefined(pendingStatements, "Decorated classes transformed by TypeScript are expected to be within a variable declaration.");
                    // Write any pending expressions from elided or moved computed property names
                    if (pendingStatements && pendingExpressions && ts.some(pendingExpressions)) {
                        pendingStatements.push(factory.createExpressionStatement(factory.inlineExpressions(pendingExpressions)));
                    }
                    if (pendingStatements && ts.some(staticPropertiesOrClassStaticBlocks)) {
                        addPropertyOrClassStaticBlockStatements(pendingStatements, staticPropertiesOrClassStaticBlocks, factory.getInternalName(node));
                    }
                    if (temp) {
                        return factory.inlineExpressions([factory.createAssignment(temp, classExpression), temp]);
                    }
                    return classExpression;
                }
                else {
                    var expressions = [];
                    temp || (temp = createClassTempVar());
                    if (isClassWithConstructorReference) {
                        // record an alias as the class name is not in scope for statics.
                        enableSubstitutionForClassAliases();
                        var alias = factory.cloneNode(temp);
                        alias.autoGenerateFlags &= ~8 /* GeneratedIdentifierFlags.ReservedInNestedScopes */;
                        classAliases[ts.getOriginalNodeId(node)] = alias;
                    }
                    // To preserve the behavior of the old emitter, we explicitly indent
                    // the body of a class with static initializers.
                    ts.setEmitFlags(classExpression, 65536 /* EmitFlags.Indented */ | ts.getEmitFlags(classExpression));
                    expressions.push(ts.startOnNewLine(factory.createAssignment(temp, classExpression)));
                    // Add any pending expressions leftover from elided or relocated computed property names
                    ts.addRange(expressions, ts.map(pendingExpressions, ts.startOnNewLine));
                    ts.addRange(expressions, generateInitializedPropertyExpressionsOrClassStaticBlock(staticPropertiesOrClassStaticBlocks, temp));
                    expressions.push(ts.startOnNewLine(temp));
                    return factory.inlineExpressions(expressions);
                }
            }
            return classExpression;
        }
        function visitClassStaticBlockDeclaration(node) {
            if (!shouldTransformPrivateElementsOrClassStaticBlocks) {
                return ts.visitEachChild(node, classElementVisitor, context);
            }
            // ClassStaticBlockDeclaration for classes are transformed in `visitClassDeclaration` or `visitClassExpression`.
            return undefined;
        }
        function transformClassMembers(node, isDerivedClass) {
            var members = [];
            if (shouldTransformPrivateElementsOrClassStaticBlocks) {
                // Declare private names.
                for (var _i = 0, _a = node.members; _i < _a.length; _i++) {
                    var member = _a[_i];
                    if (ts.isPrivateIdentifierClassElementDeclaration(member)) {
                        addPrivateIdentifierToEnvironment(member);
                    }
                }
                if (ts.some(getPrivateInstanceMethodsAndAccessors(node))) {
                    createBrandCheckWeakSetForPrivateMethods();
                }
            }
            var constructor = transformConstructor(node, isDerivedClass);
            var visitedMembers = ts.visitNodes(node.members, classElementVisitor, ts.isClassElement);
            if (constructor) {
                members.push(constructor);
            }
            if (!shouldTransformPrivateElementsOrClassStaticBlocks && ts.some(pendingExpressions)) {
                members.push(factory.createClassStaticBlockDeclaration(
                /*decorators*/ undefined, 
                /*modifiers*/ undefined, factory.createBlock([
                    factory.createExpressionStatement(factory.inlineExpressions(pendingExpressions))
                ])));
                pendingExpressions = undefined;
            }
            ts.addRange(members, visitedMembers);
            return ts.setTextRange(factory.createNodeArray(members), /*location*/ node.members);
        }
        function createBrandCheckWeakSetForPrivateMethods() {
            var weakSetName = getPrivateIdentifierEnvironment().weakSetName;
            ts.Debug.assert(weakSetName, "weakSetName should be set in private identifier environment");
            getPendingExpressions().push(factory.createAssignment(weakSetName, factory.createNewExpression(factory.createIdentifier("WeakSet"), 
            /*typeArguments*/ undefined, [])));
        }
        function isClassElementThatRequiresConstructorStatement(member) {
            if (ts.isStatic(member) || ts.hasSyntacticModifier(ts.getOriginalNode(member), 128 /* ModifierFlags.Abstract */)) {
                return false;
            }
            if (useDefineForClassFields) {
                // If we are using define semantics and targeting ESNext or higher,
                // then we don't need to transform any class properties.
                return languageVersion < 9 /* ScriptTarget.ES2022 */;
            }
            return ts.isInitializedProperty(member) || shouldTransformPrivateElementsOrClassStaticBlocks && ts.isPrivateIdentifierClassElementDeclaration(member);
        }
        function transformConstructor(node, isDerivedClass) {
            var constructor = ts.visitNode(ts.getFirstConstructorWithBody(node), visitor, ts.isConstructorDeclaration);
            var elements = node.members.filter(isClassElementThatRequiresConstructorStatement);
            if (!ts.some(elements)) {
                return constructor;
            }
            var parameters = ts.visitParameterList(constructor ? constructor.parameters : undefined, visitor, context);
            var body = transformConstructorBody(node, constructor, isDerivedClass);
            if (!body) {
                return undefined;
            }
            return ts.startOnNewLine(ts.setOriginalNode(ts.setTextRange(factory.createConstructorDeclaration(
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, parameters !== null && parameters !== void 0 ? parameters : [], body), constructor || node), constructor));
        }
        function transformConstructorBody(node, constructor, isDerivedClass) {
            var _a;
            var properties = ts.getProperties(node, /*requireInitializer*/ false, /*isStatic*/ false);
            if (!useDefineForClassFields) {
                properties = ts.filter(properties, function (property) { return !!property.initializer || ts.isPrivateIdentifier(property.name); });
            }
            var privateMethodsAndAccessors = getPrivateInstanceMethodsAndAccessors(node);
            var needsConstructorBody = ts.some(properties) || ts.some(privateMethodsAndAccessors);
            // Only generate synthetic constructor when there are property initializers to move.
            if (!constructor && !needsConstructorBody) {
                return ts.visitFunctionBody(/*node*/ undefined, visitor, context);
            }
            resumeLexicalEnvironment();
            var needsSyntheticConstructor = !constructor && isDerivedClass;
            var indexOfFirstStatementAfterSuperAndPrologue = 0;
            var prologueStatementCount = 0;
            var superStatementIndex = -1;
            var statements = [];
            if ((_a = constructor === null || constructor === void 0 ? void 0 : constructor.body) === null || _a === void 0 ? void 0 : _a.statements) {
                prologueStatementCount = factory.copyPrologue(constructor.body.statements, statements, /*ensureUseStrict*/ false, visitor);
                superStatementIndex = ts.findSuperStatementIndex(constructor.body.statements, prologueStatementCount);
                // If there was a super call, visit existing statements up to and including it
                if (superStatementIndex >= 0) {
                    indexOfFirstStatementAfterSuperAndPrologue = superStatementIndex + 1;
                    statements = __spreadArray(__spreadArray(__spreadArray([], statements.slice(0, prologueStatementCount), true), ts.visitNodes(constructor.body.statements, visitor, ts.isStatement, prologueStatementCount, indexOfFirstStatementAfterSuperAndPrologue - prologueStatementCount), true), statements.slice(prologueStatementCount), true);
                }
                else if (prologueStatementCount >= 0) {
                    indexOfFirstStatementAfterSuperAndPrologue = prologueStatementCount;
                }
            }
            if (needsSyntheticConstructor) {
                // Add a synthetic `super` call:
                //
                //  super(...arguments);
                //
                statements.push(factory.createExpressionStatement(factory.createCallExpression(factory.createSuper(), 
                /*typeArguments*/ undefined, [factory.createSpreadElement(factory.createIdentifier("arguments"))])));
            }
            // Add the property initializers. Transforms this:
            //
            //  public x = 1;
            //
            // Into this:
            //
            //  constructor() {
            //      this.x = 1;
            //  }
            //
            // If we do useDefineForClassFields, they'll be converted elsewhere.
            // We instead *remove* them from the transformed output at this stage.
            var parameterPropertyDeclarationCount = 0;
            if (constructor === null || constructor === void 0 ? void 0 : constructor.body) {
                if (useDefineForClassFields) {
                    statements = statements.filter(function (statement) { return !ts.isParameterPropertyDeclaration(ts.getOriginalNode(statement), constructor); });
                }
                else {
                    for (var _i = 0, _b = constructor.body.statements; _i < _b.length; _i++) {
                        var statement = _b[_i];
                        if (ts.isParameterPropertyDeclaration(ts.getOriginalNode(statement), constructor)) {
                            parameterPropertyDeclarationCount++;
                        }
                    }
                    if (parameterPropertyDeclarationCount > 0) {
                        var parameterProperties = ts.visitNodes(constructor.body.statements, visitor, ts.isStatement, indexOfFirstStatementAfterSuperAndPrologue, parameterPropertyDeclarationCount);
                        // If there was a super() call found, add parameter properties immediately after it
                        if (superStatementIndex >= 0) {
                            ts.addRange(statements, parameterProperties);
                        }
                        else {
                            // Add add parameter properties to the top of the constructor after the prologue
                            var superAndPrologueStatementCount = prologueStatementCount;
                            // If a synthetic super() call was added, need to account for that
                            if (needsSyntheticConstructor)
                                superAndPrologueStatementCount++;
                            statements = __spreadArray(__spreadArray(__spreadArray([], statements.slice(0, superAndPrologueStatementCount), true), parameterProperties, true), statements.slice(superAndPrologueStatementCount), true);
                        }
                        indexOfFirstStatementAfterSuperAndPrologue += parameterPropertyDeclarationCount;
                    }
                }
            }
            var receiver = factory.createThis();
            // private methods can be called in property initializers, they should execute first.
            addMethodStatements(statements, privateMethodsAndAccessors, receiver);
            addPropertyOrClassStaticBlockStatements(statements, properties, receiver);
            // Add existing statements after the initial prologues and super call
            if (constructor) {
                ts.addRange(statements, ts.visitNodes(constructor.body.statements, visitBodyStatement, ts.isStatement, indexOfFirstStatementAfterSuperAndPrologue));
            }
            statements = factory.mergeLexicalEnvironment(statements, endLexicalEnvironment());
            return ts.setTextRange(factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), 
            /*location*/ constructor ? constructor.body.statements : node.members), 
            /*multiLine*/ true), 
            /*location*/ constructor ? constructor.body : undefined);
            function visitBodyStatement(statement) {
                if (useDefineForClassFields && ts.isParameterPropertyDeclaration(ts.getOriginalNode(statement), constructor)) {
                    return undefined;
                }
                return visitor(statement);
            }
        }
        /**
         * Generates assignment statements for property initializers.
         *
         * @param properties An array of property declarations to transform.
         * @param receiver The receiver on which each property should be assigned.
         */
        function addPropertyOrClassStaticBlockStatements(statements, properties, receiver) {
            for (var _i = 0, properties_7 = properties; _i < properties_7.length; _i++) {
                var property = properties_7[_i];
                if (ts.isStatic(property) && !shouldTransformPrivateElementsOrClassStaticBlocks && !useDefineForClassFields) {
                    continue;
                }
                var statement = transformPropertyOrClassStaticBlock(property, receiver);
                if (!statement) {
                    continue;
                }
                statements.push(statement);
            }
        }
        function transformPropertyOrClassStaticBlock(property, receiver) {
            var expression = ts.isClassStaticBlockDeclaration(property) ?
                transformClassStaticBlockDeclaration(property) :
                transformProperty(property, receiver);
            if (!expression) {
                return undefined;
            }
            var statement = factory.createExpressionStatement(expression);
            ts.setSourceMapRange(statement, ts.moveRangePastModifiers(property));
            ts.setCommentRange(statement, property);
            ts.setOriginalNode(statement, property);
            // `setOriginalNode` *copies* the `emitNode` from `property`, so now both
            // `statement` and `expression` have a copy of the synthesized comments.
            // Drop the comments from expression to avoid printing them twice.
            ts.setSyntheticLeadingComments(expression, undefined);
            ts.setSyntheticTrailingComments(expression, undefined);
            return statement;
        }
        /**
         * Generates assignment expressions for property initializers.
         *
         * @param propertiesOrClassStaticBlocks An array of property declarations to transform.
         * @param receiver The receiver on which each property should be assigned.
         */
        function generateInitializedPropertyExpressionsOrClassStaticBlock(propertiesOrClassStaticBlocks, receiver) {
            var expressions = [];
            for (var _i = 0, propertiesOrClassStaticBlocks_1 = propertiesOrClassStaticBlocks; _i < propertiesOrClassStaticBlocks_1.length; _i++) {
                var property = propertiesOrClassStaticBlocks_1[_i];
                var expression = ts.isClassStaticBlockDeclaration(property) ? transformClassStaticBlockDeclaration(property) : transformProperty(property, receiver);
                if (!expression) {
                    continue;
                }
                ts.startOnNewLine(expression);
                ts.setSourceMapRange(expression, ts.moveRangePastModifiers(property));
                ts.setCommentRange(expression, property);
                ts.setOriginalNode(expression, property);
                expressions.push(expression);
            }
            return expressions;
        }
        /**
         * Transforms a property initializer into an assignment statement.
         *
         * @param property The property declaration.
         * @param receiver The object receiving the property assignment.
         */
        function transformProperty(property, receiver) {
            var savedCurrentStaticPropertyDeclarationOrStaticBlock = currentStaticPropertyDeclarationOrStaticBlock;
            var transformed = transformPropertyWorker(property, receiver);
            if (transformed && ts.hasStaticModifier(property) && (currentClassLexicalEnvironment === null || currentClassLexicalEnvironment === void 0 ? void 0 : currentClassLexicalEnvironment.facts)) {
                // capture the lexical environment for the member
                ts.setOriginalNode(transformed, property);
                ts.addEmitFlags(transformed, 2 /* EmitFlags.AdviseOnEmitNode */);
                classLexicalEnvironmentMap.set(ts.getOriginalNodeId(transformed), currentClassLexicalEnvironment);
            }
            currentStaticPropertyDeclarationOrStaticBlock = savedCurrentStaticPropertyDeclarationOrStaticBlock;
            return transformed;
        }
        function transformPropertyWorker(property, receiver) {
            var _a;
            // We generate a name here in order to reuse the value cached by the relocated computed name expression (which uses the same generated name)
            var emitAssignment = !useDefineForClassFields;
            var propertyName = ts.isComputedPropertyName(property.name) && !ts.isSimpleInlineableExpression(property.name.expression)
                ? factory.updateComputedPropertyName(property.name, factory.getGeneratedNameForNode(property.name))
                : property.name;
            if (ts.hasStaticModifier(property)) {
                currentStaticPropertyDeclarationOrStaticBlock = property;
            }
            if (shouldTransformPrivateElementsOrClassStaticBlocks && ts.isPrivateIdentifier(propertyName)) {
                var privateIdentifierInfo = accessPrivateIdentifier(propertyName);
                if (privateIdentifierInfo) {
                    if (privateIdentifierInfo.kind === "f" /* PrivateIdentifierKind.Field */) {
                        if (!privateIdentifierInfo.isStatic) {
                            return createPrivateInstanceFieldInitializer(receiver, ts.visitNode(property.initializer, visitor, ts.isExpression), privateIdentifierInfo.brandCheckIdentifier);
                        }
                        else {
                            return createPrivateStaticFieldInitializer(privateIdentifierInfo.variableName, ts.visitNode(property.initializer, visitor, ts.isExpression));
                        }
                    }
                    else {
                        return undefined;
                    }
                }
                else {
                    ts.Debug.fail("Undeclared private name for property declaration.");
                }
            }
            if ((ts.isPrivateIdentifier(propertyName) || ts.hasStaticModifier(property)) && !property.initializer) {
                return undefined;
            }
            var propertyOriginalNode = ts.getOriginalNode(property);
            if (ts.hasSyntacticModifier(propertyOriginalNode, 128 /* ModifierFlags.Abstract */)) {
                return undefined;
            }
            var initializer = property.initializer || emitAssignment ? (_a = ts.visitNode(property.initializer, visitor, ts.isExpression)) !== null && _a !== void 0 ? _a : factory.createVoidZero()
                : ts.isParameterPropertyDeclaration(propertyOriginalNode, propertyOriginalNode.parent) && ts.isIdentifier(propertyName) ? propertyName
                    : factory.createVoidZero();
            if (emitAssignment || ts.isPrivateIdentifier(propertyName)) {
                var memberAccess = ts.createMemberAccessForPropertyName(factory, receiver, propertyName, /*location*/ propertyName);
                return factory.createAssignment(memberAccess, initializer);
            }
            else {
                var name = ts.isComputedPropertyName(propertyName) ? propertyName.expression
                    : ts.isIdentifier(propertyName) ? factory.createStringLiteral(ts.unescapeLeadingUnderscores(propertyName.escapedText))
                        : propertyName;
                var descriptor = factory.createPropertyDescriptor({ value: initializer, configurable: true, writable: true, enumerable: true });
                return factory.createObjectDefinePropertyCall(receiver, name, descriptor);
            }
        }
        function enableSubstitutionForClassAliases() {
            if ((enabledSubstitutions & 1 /* ClassPropertySubstitutionFlags.ClassAliases */) === 0) {
                enabledSubstitutions |= 1 /* ClassPropertySubstitutionFlags.ClassAliases */;
                // We need to enable substitutions for identifiers. This allows us to
                // substitute class names inside of a class declaration.
                context.enableSubstitution(79 /* SyntaxKind.Identifier */);
                // Keep track of class aliases.
                classAliases = [];
            }
        }
        function enableSubstitutionForClassStaticThisOrSuperReference() {
            if ((enabledSubstitutions & 2 /* ClassPropertySubstitutionFlags.ClassStaticThisOrSuperReference */) === 0) {
                enabledSubstitutions |= 2 /* ClassPropertySubstitutionFlags.ClassStaticThisOrSuperReference */;
                // substitute `this` in a static field initializer
                context.enableSubstitution(108 /* SyntaxKind.ThisKeyword */);
                // these push a new lexical environment that is not the class lexical environment
                context.enableEmitNotification(256 /* SyntaxKind.FunctionDeclaration */);
                context.enableEmitNotification(213 /* SyntaxKind.FunctionExpression */);
                context.enableEmitNotification(171 /* SyntaxKind.Constructor */);
                // these push a new lexical environment that is not the class lexical environment, except
                // when they have a computed property name
                context.enableEmitNotification(172 /* SyntaxKind.GetAccessor */);
                context.enableEmitNotification(173 /* SyntaxKind.SetAccessor */);
                context.enableEmitNotification(169 /* SyntaxKind.MethodDeclaration */);
                context.enableEmitNotification(167 /* SyntaxKind.PropertyDeclaration */);
                // class lexical environments are restored when entering a computed property name
                context.enableEmitNotification(162 /* SyntaxKind.ComputedPropertyName */);
            }
        }
        /**
         * Generates brand-check initializer for private methods.
         *
         * @param statements Statement list that should be used to append new statements.
         * @param methods An array of method declarations.
         * @param receiver The receiver on which each method should be assigned.
         */
        function addMethodStatements(statements, methods, receiver) {
            if (!shouldTransformPrivateElementsOrClassStaticBlocks || !ts.some(methods)) {
                return;
            }
            var weakSetName = getPrivateIdentifierEnvironment().weakSetName;
            ts.Debug.assert(weakSetName, "weakSetName should be set in private identifier environment");
            statements.push(factory.createExpressionStatement(createPrivateInstanceMethodInitializer(receiver, weakSetName)));
        }
        function visitInvalidSuperProperty(node) {
            return ts.isPropertyAccessExpression(node) ?
                factory.updatePropertyAccessExpression(node, factory.createVoidZero(), node.name) :
                factory.updateElementAccessExpression(node, factory.createVoidZero(), ts.visitNode(node.argumentExpression, visitor, ts.isExpression));
        }
        function onEmitNode(hint, node, emitCallback) {
            var original = ts.getOriginalNode(node);
            if (original.id) {
                var classLexicalEnvironment = classLexicalEnvironmentMap.get(original.id);
                if (classLexicalEnvironment) {
                    var savedClassLexicalEnvironment = currentClassLexicalEnvironment;
                    var savedCurrentComputedPropertyNameClassLexicalEnvironment = currentComputedPropertyNameClassLexicalEnvironment;
                    currentClassLexicalEnvironment = classLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = classLexicalEnvironment;
                    previousOnEmitNode(hint, node, emitCallback);
                    currentClassLexicalEnvironment = savedClassLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = savedCurrentComputedPropertyNameClassLexicalEnvironment;
                    return;
                }
            }
            switch (node.kind) {
                case 213 /* SyntaxKind.FunctionExpression */:
                    if (ts.isArrowFunction(original) || ts.getEmitFlags(node) & 262144 /* EmitFlags.AsyncFunctionBody */) {
                        break;
                    }
                // falls through
                case 256 /* SyntaxKind.FunctionDeclaration */:
                case 171 /* SyntaxKind.Constructor */: {
                    var savedClassLexicalEnvironment = currentClassLexicalEnvironment;
                    var savedCurrentComputedPropertyNameClassLexicalEnvironment = currentComputedPropertyNameClassLexicalEnvironment;
                    currentClassLexicalEnvironment = undefined;
                    currentComputedPropertyNameClassLexicalEnvironment = undefined;
                    previousOnEmitNode(hint, node, emitCallback);
                    currentClassLexicalEnvironment = savedClassLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = savedCurrentComputedPropertyNameClassLexicalEnvironment;
                    return;
                }
                case 172 /* SyntaxKind.GetAccessor */:
                case 173 /* SyntaxKind.SetAccessor */:
                case 169 /* SyntaxKind.MethodDeclaration */:
                case 167 /* SyntaxKind.PropertyDeclaration */: {
                    var savedClassLexicalEnvironment = currentClassLexicalEnvironment;
                    var savedCurrentComputedPropertyNameClassLexicalEnvironment = currentComputedPropertyNameClassLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = currentClassLexicalEnvironment;
                    currentClassLexicalEnvironment = undefined;
                    previousOnEmitNode(hint, node, emitCallback);
                    currentClassLexicalEnvironment = savedClassLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = savedCurrentComputedPropertyNameClassLexicalEnvironment;
                    return;
                }
                case 162 /* SyntaxKind.ComputedPropertyName */: {
                    var savedClassLexicalEnvironment = currentClassLexicalEnvironment;
                    var savedCurrentComputedPropertyNameClassLexicalEnvironment = currentComputedPropertyNameClassLexicalEnvironment;
                    currentClassLexicalEnvironment = currentComputedPropertyNameClassLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = undefined;
                    previousOnEmitNode(hint, node, emitCallback);
                    currentClassLexicalEnvironment = savedClassLexicalEnvironment;
                    currentComputedPropertyNameClassLexicalEnvironment = savedCurrentComputedPropertyNameClassLexicalEnvironment;
                    return;
                }
            }
            previousOnEmitNode(hint, node, emitCallback);
        }
        /**
         * Hooks node substitutions.
         *
         * @param hint The context for the emitter.
         * @param node The node to substitute.
         */
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1 /* EmitHint.Expression */) {
                return substituteExpression(node);
            }
            return node;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 79 /* SyntaxKind.Identifier */:
                    return substituteExpressionIdentifier(node);
                case 108 /* SyntaxKind.ThisKeyword */:
                    return substituteThisExpression(node);
            }
            return node;
        }
        function substituteThisExpression(node) {
            if (enabledSubstitutions & 2 /* ClassPropertySubstitutionFlags.ClassStaticThisOrSuperReference */ && currentClassLexicalEnvironment) {
                var facts = currentClassLexicalEnvironment.facts, classConstructor = currentClassLexicalEnvironment.classConstructor;
                if (facts & 1 /* ClassFacts.ClassWasDecorated */) {
                    return factory.createParenthesizedExpression(factory.createVoidZero());
                }
                if (classConstructor) {
                    return ts.setTextRange(ts.setOriginalNode(factory.cloneNode(classConstructor), node), node);
                }
            }
            return node;
        }
        function substituteExpressionIdentifier(node) {
            return trySubstituteClassAlias(node) || node;
        }
        function trySubstituteClassAlias(node) {
            if (enabledSubstitutions & 1 /* ClassPropertySubstitutionFlags.ClassAliases */) {
                if (resolver.getNodeCheckFlags(node) & 33554432 /* NodeCheckFlags.ConstructorReferenceInClass */) {
                    // Due to the emit for class decorators, any reference to the class from inside of the class body
                    // must instead be rewritten to point to a temporary variable to avoid issues with the double-bind
                    // behavior of class names in ES6.
                    // Also, when emitting statics for class expressions, we must substitute a class alias for
                    // constructor references in static property initializers.
                    var declaration = resolver.getReferencedValueDeclaration(node);
                    if (declaration) {
                        var classAlias = classAliases[declaration.id]; // TODO: GH#18217
                        if (classAlias) {
                            var clone_3 = factory.cloneNode(classAlias);
                            ts.setSourceMapRange(clone_3, node);
                            ts.setCommentRange(clone_3, node);
                            return clone_3;
                        }
                    }
                }
            }
            return undefined;
        }
        /**
         * If the name is a computed property, this function transforms it, then either returns an expression which caches the
         * value of the result or the expression itself if the value is either unused or safe to inline into multiple locations
         * @param shouldHoist Does the expression need to be reused? (ie, for an initializer or a decorator)
         */
        function getPropertyNameExpressionIfNeeded(name, shouldHoist) {
            if (ts.isComputedPropertyName(name)) {
                var expression = ts.visitNode(name.expression, visitor, ts.isExpression);
                var innerExpression = ts.skipPartiallyEmittedExpressions(expression);
                var inlinable = ts.isSimpleInlineableExpression(innerExpression);
                var alreadyTransformed = ts.isAssignmentExpression(innerExpression) && ts.isGeneratedIdentifier(innerExpression.left);
                if (!alreadyTransformed && !inlinable && shouldHoist) {
                    var generatedName = factory.getGeneratedNameForNode(name);
                    if (resolver.getNodeCheckFlags(name) & 524288 /* NodeCheckFlags.BlockScopedBindingInLoop */) {
                        addBlockScopedVariable(generatedName);
                    }
                    else {
                        hoistVariableDeclaration(generatedName);
                    }
                    return factory.createAssignment(generatedName, expression);
                }
                return (inlinable || ts.isIdentifier(innerExpression)) ? undefined : expression;
            }
        }
        function startClassLexicalEnvironment() {
            classLexicalEnvironmentStack.push(currentClassLexicalEnvironment);
            currentClassLexicalEnvironment = undefined;
        }
        function endClassLexicalEnvironment() {
            currentClassLexicalEnvironment = classLexicalEnvironmentStack.pop();
        }
        function getClassLexicalEnvironment() {
            return currentClassLexicalEnvironment || (currentClassLexicalEnvironment = {
                facts: 0 /* ClassFacts.None */,
                classConstructor: undefined,
                superClassReference: undefined,
                privateIdentifierEnvironment: undefined,
            });
        }
        function getPrivateIdentifierEnvironment() {
            var lex = getClassLexicalEnvironment();
            lex.privateIdentifierEnvironment || (lex.privateIdentifierEnvironment = {
                className: "",
                identifiers: new ts.Map()
            });
            return lex.privateIdentifierEnvironment;
        }
        function getPendingExpressions() {
            return pendingExpressions || (pendingExpressions = []);
        }
        function addPrivateIdentifierToEnvironment(node) {
            var _a;
            var text = ts.getTextOfPropertyName(node.name);
            var lex = getClassLexicalEnvironment();
            var classConstructor = lex.classConstructor;
            var privateEnv = getPrivateIdentifierEnvironment();
            var weakSetName = privateEnv.weakSetName;
            var assignmentExpressions = [];
            var privateName = node.name.escapedText;
            var previousInfo = privateEnv.identifiers.get(privateName);
            var isValid = !isReservedPrivateName(node.name) && previousInfo === undefined;
            if (ts.hasStaticModifier(node)) {
                ts.Debug.assert(classConstructor, "weakSetName should be set in private identifier environment");
                if (ts.isPropertyDeclaration(node)) {
                    var variableName = createHoistedVariableForPrivateName(text, node);
                    privateEnv.identifiers.set(privateName, {
                        kind: "f" /* PrivateIdentifierKind.Field */,
                        variableName: variableName,
                        brandCheckIdentifier: classConstructor,
                        isStatic: true,
                        isValid: isValid,
                    });
                }
                else if (ts.isMethodDeclaration(node)) {
                    var functionName = createHoistedVariableForPrivateName(text, node);
                    privateEnv.identifiers.set(privateName, {
                        kind: "m" /* PrivateIdentifierKind.Method */,
                        methodName: functionName,
                        brandCheckIdentifier: classConstructor,
                        isStatic: true,
                        isValid: isValid,
                    });
                }
                else if (ts.isGetAccessorDeclaration(node)) {
                    var getterName = createHoistedVariableForPrivateName(text + "_get", node);
                    if ((previousInfo === null || previousInfo === void 0 ? void 0 : previousInfo.kind) === "a" /* PrivateIdentifierKind.Accessor */ && previousInfo.isStatic && !previousInfo.getterName) {
                        previousInfo.getterName = getterName;
                    }
                    else {
                        privateEnv.identifiers.set(privateName, {
                            kind: "a" /* PrivateIdentifierKind.Accessor */,
                            getterName: getterName,
                            setterName: undefined,
                            brandCheckIdentifier: classConstructor,
                            isStatic: true,
                            isValid: isValid,
                        });
                    }
                }
                else if (ts.isSetAccessorDeclaration(node)) {
                    var setterName = createHoistedVariableForPrivateName(text + "_set", node);
                    if ((previousInfo === null || previousInfo === void 0 ? void 0 : previousInfo.kind) === "a" /* PrivateIdentifierKind.Accessor */ && previousInfo.isStatic && !previousInfo.setterName) {
                        previousInfo.setterName = setterName;
                    }
                    else {
                        privateEnv.identifiers.set(privateName, {
                            kind: "a" /* PrivateIdentifierKind.Accessor */,
                            getterName: undefined,
                            setterName: setterName,
                            brandCheckIdentifier: classConstructor,
                            isStatic: true,
                            isValid: isValid,
                        });
                    }
                }
                else {
                    ts.Debug.assertNever(node, "Unknown class element type.");
                }
            }
            else if (ts.isPropertyDeclaration(node)) {
                var weakMapName = createHoistedVariableForPrivateName(text, node);
                privateEnv.identifiers.set(privateName, {
                    kind: "f" /* PrivateIdentifierKind.Field */,
                    brandCheckIdentifier: weakMapName,
                    isStatic: false,
                    variableName: undefined,
                    isValid: isValid,
                });
                assignmentExpressions.push(factory.createAssignment(weakMapName, factory.createNewExpression(factory.createIdentifier("WeakMap"), 
                /*typeArguments*/ undefined, [])));
            }
            else if (ts.isMethodDeclaration(node)) {
                ts.Debug.assert(weakSetName, "weakSetName should be set in private identifier environment");
                privateEnv.identifiers.set(privateName, {
                    kind: "m" /* PrivateIdentifierKind.Method */,
                    methodName: createHoistedVariableForPrivateName(text, node),
                    brandCheckIdentifier: weakSetName,
                    isStatic: false,
                    isValid: isValid,
                });
            }
            else if (ts.isAccessor(node)) {
                ts.Debug.assert(weakSetName, "weakSetName should be set in private identifier environment");
                if (ts.isGetAccessor(node)) {
                    var getterName = createHoistedVariableForPrivateName(text + "_get", node);
                    if ((previousInfo === null || previousInfo === void 0 ? void 0 : previousInfo.kind) === "a" /* PrivateIdentifierKind.Accessor */ && !previousInfo.isStatic && !previousInfo.getterName) {
                        previousInfo.getterName = getterName;
                    }
                    else {
                        privateEnv.identifiers.set(privateName, {
                            kind: "a" /* PrivateIdentifierKind.Accessor */,
                            getterName: getterName,
                            setterName: undefined,
                            brandCheckIdentifier: weakSetName,
                            isStatic: false,
                            isValid: isValid,
                        });
                    }
                }
                else {
                    var setterName = createHoistedVariableForPrivateName(text + "_set", node);
                    if ((previousInfo === null || previousInfo === void 0 ? void 0 : previousInfo.kind) === "a" /* PrivateIdentifierKind.Accessor */ && !previousInfo.isStatic && !previousInfo.setterName) {
                        previousInfo.setterName = setterName;
                    }
                    else {
                        privateEnv.identifiers.set(privateName, {
                            kind: "a" /* PrivateIdentifierKind.Accessor */,
                            getterName: undefined,
                            setterName: setterName,
                            brandCheckIdentifier: weakSetName,
                            isStatic: false,
                            isValid: isValid,
                        });
                    }
                }
            }
            else {
                ts.Debug.assertNever(node, "Unknown class element type.");
            }
            (_a = getPendingExpressions()).push.apply(_a, assignmentExpressions);
        }
        function createHoistedVariableForClass(name, node) {
            var className = getPrivateIdentifierEnvironment().className;
            var prefix = className ? "_".concat(className) : "";
            var identifier = factory.createUniqueName("".concat(prefix, "_").concat(name), 16 /* GeneratedIdentifierFlags.Optimistic */);
            if (resolver.getNodeCheckFlags(node) & 524288 /* NodeCheckFlags.BlockScopedBindingInLoop */) {
                addBlockScopedVariable(identifier);
            }
            else {
                hoistVariableDeclaration(identifier);
            }
            return identifier;
        }
        function createHoistedVariableForPrivateName(privateName, node) {
            return createHoistedVariableForClass(privateName.substring(1), node.name);
        }
        function accessPrivateIdentifier(name) {
            var _a;
            if (currentClassLexicalEnvironment === null || currentClassLexicalEnvironment === void 0 ? void 0 : currentClassLexicalEnvironment.privateIdentifierEnvironment) {
                var info = currentClassLexicalEnvironment.privateIdentifierEnvironment.identifiers.get(name.escapedText);
                if (info) {
                    return info;
                }
            }
            for (var i = classLexicalEnvironmentStack.length - 1; i >= 0; --i) {
                var env = classLexicalEnvironmentStack[i];
                if (!env) {
                    continue;
                }
                var info = (_a = env.privateIdentifierEnvironment) === null || _a === void 0 ? void 0 : _a.identifiers.get(name.escapedText);
                if (info) {
                    return info;
                }
            }
            return undefined;
        }
        function wrapPrivateIdentifierForDestructuringTarget(node) {
            var parameter = factory.getGeneratedNameForNode(node);
            var info = accessPrivateIdentifier(node.name);
            if (!info) {
                return ts.visitEachChild(node, visitor, context);
            }
            var receiver = node.expression;
            // We cannot copy `this` or `super` into the function because they will be bound
            // differently inside the function.
            if (ts.isThisProperty(node) || ts.isSuperProperty(node) || !ts.isSimpleCopiableExpression(node.expression)) {
                receiver = factory.createTempVariable(hoistVariableDeclaration, /*reservedInNestedScopes*/ true);
                getPendingExpressions().push(factory.createBinaryExpression(receiver, 63 /* SyntaxKind.EqualsToken */, ts.visitNode(node.expression, visitor, ts.isExpression)));
            }
            return factory.createAssignmentTargetWrapper(parameter, createPrivateIdentifierAssignment(info, receiver, parameter, 63 /* SyntaxKind.EqualsToken */));
        }
        function visitArrayAssignmentTarget(node) {
            var target = ts.getTargetOfBindingOrAssignmentElement(node);
            if (target) {
                var wrapped = void 0;
                if (ts.isPrivateIdentifierPropertyAccessExpression(target)) {
                    wrapped = wrapPrivateIdentifierForDestructuringTarget(target);
                }
                else if (shouldTransformSuperInStaticInitializers &&
                    ts.isSuperProperty(target) &&
                    currentStaticPropertyDeclarationOrStaticBlock &&
                    currentClassLexicalEnvironment) {
                    var classConstructor = currentClassLexicalEnvironment.classConstructor, superClassReference = currentClassLexicalEnvironment.superClassReference, facts = currentClassLexicalEnvironment.facts;
                    if (facts & 1 /* ClassFacts.ClassWasDecorated */) {
                        wrapped = visitInvalidSuperProperty(target);
                    }
                    else if (classConstructor && superClassReference) {
                        var name = ts.isElementAccessExpression(target) ? ts.visitNode(target.argumentExpression, visitor, ts.isExpression) :
                            ts.isIdentifier(target.name) ? factory.createStringLiteralFromNode(target.name) :
                                undefined;
                        if (name) {
                            var temp = factory.createTempVariable(/*recordTempVariable*/ undefined);
                            wrapped = factory.createAssignmentTargetWrapper(temp, factory.createReflectSetCall(superClassReference, name, temp, classConstructor));
                        }
                    }
                }
                if (wrapped) {
                    if (ts.isAssignmentExpression(node)) {
                        return factory.updateBinaryExpression(node, wrapped, node.operatorToken, ts.visitNode(node.right, visitor, ts.isExpression));
                    }
                    else if (ts.isSpreadElement(node)) {
                        return factory.updateSpreadElement(node, wrapped);
                    }
                    else {
                        return wrapped;
                    }
                }
            }
            return ts.visitNode(node, visitorDestructuringTarget);
        }
        function visitObjectAssignmentTarget(node) {
            if (ts.isObjectBindingOrAssignmentElement(node) && !ts.isShorthandPropertyAssignment(node)) {
                var target = ts.getTargetOfBindingOrAssignmentElement(node);
                var wrapped = void 0;
                if (target) {
                    if (ts.isPrivateIdentifierPropertyAccessExpression(target)) {
                        wrapped = wrapPrivateIdentifierForDestructuringTarget(target);
                    }
                    else if (shouldTransformSuperInStaticInitializers &&
                        ts.isSuperProperty(target) &&
                        currentStaticPropertyDeclarationOrStaticBlock &&
                        currentClassLexicalEnvironment) {
                        var classConstructor = currentClassLexicalEnvironment.classConstructor, superClassReference = currentClassLexicalEnvironment.superClassReference, facts = currentClassLexicalEnvironment.facts;
                        if (facts & 1 /* ClassFacts.ClassWasDecorated */) {
                            wrapped = visitInvalidSuperProperty(target);
                        }
                        else if (classConstructor && superClassReference) {
                            var name = ts.isElementAccessExpression(target) ? ts.visitNode(target.argumentExpression, visitor, ts.isExpression) :
                                ts.isIdentifier(target.name) ? factory.createStringLiteralFromNode(target.name) :
                                    undefined;
                            if (name) {
                                var temp = factory.createTempVariable(/*recordTempVariable*/ undefined);
                                wrapped = factory.createAssignmentTargetWrapper(temp, factory.createReflectSetCall(superClassReference, name, temp, classConstructor));
                            }
                        }
                    }
                }
                if (ts.isPropertyAssignment(node)) {
                    var initializer = ts.getInitializerOfBindingOrAssignmentElement(node);
                    return factory.updatePropertyAssignment(node, ts.visitNode(node.name, visitor, ts.isPropertyName), wrapped ?
                        initializer ? factory.createAssignment(wrapped, ts.visitNode(initializer, visitor)) : wrapped :
                        ts.visitNode(node.initializer, visitorDestructuringTarget, ts.isExpression));
                }
                if (ts.isSpreadAssignment(node)) {
                    return factory.updateSpreadAssignment(node, wrapped || ts.visitNode(node.expression, visitorDestructuringTarget, ts.isExpression));
                }
                ts.Debug.assert(wrapped === undefined, "Should not have generated a wrapped target");
            }
            return ts.visitNode(node, visitor);
        }
        function visitAssignmentPattern(node) {
            if (ts.isArrayLiteralExpression(node)) {
                // Transforms private names in destructuring assignment array bindings.
                // Transforms SuperProperty assignments in destructuring assignment array bindings in static initializers.
                //
                // Source:
                // ([ this.#myProp ] = [ "hello" ]);
                //
                // Transformation:
                // [ { set value(x) { this.#myProp = x; } }.value ] = [ "hello" ];
                return factory.updateArrayLiteralExpression(node, ts.visitNodes(node.elements, visitArrayAssignmentTarget, ts.isExpression));
            }
            else {
                // Transforms private names in destructuring assignment object bindings.
                // Transforms SuperProperty assignments in destructuring assignment object bindings in static initializers.
                //
                // Source:
                // ({ stringProperty: this.#myProp } = { stringProperty: "hello" });
                //
                // Transformation:
                // ({ stringProperty: { set value(x) { this.#myProp = x; } }.value }) = { stringProperty: "hello" };
                return factory.updateObjectLiteralExpression(node, ts.visitNodes(node.properties, visitObjectAssignmentTarget, ts.isObjectLiteralElementLike));
            }
        }
    }
    ts.transformClassFields = transformClassFields;
    function createPrivateStaticFieldInitializer(variableName, initializer) {
        return ts.factory.createAssignment(variableName, ts.factory.createObjectLiteralExpression([
            ts.factory.createPropertyAssignment("value", initializer || ts.factory.createVoidZero())
        ]));
    }
    function createPrivateInstanceFieldInitializer(receiver, initializer, weakMapName) {
        return ts.factory.createCallExpression(ts.factory.createPropertyAccessExpression(weakMapName, "set"), 
        /*typeArguments*/ undefined, [receiver, initializer || ts.factory.createVoidZero()]);
    }
    function createPrivateInstanceMethodInitializer(receiver, weakSetName) {
        return ts.factory.createCallExpression(ts.factory.createPropertyAccessExpression(weakSetName, "add"), 
        /*typeArguments*/ undefined, [receiver]);
    }
    function isReservedPrivateName(node) {
        return node.escapedText === "#constructor";
    }
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var ES2017SubstitutionFlags;
    (function (ES2017SubstitutionFlags) {
        /** Enables substitutions for async methods with `super` calls. */
        ES2017SubstitutionFlags[ES2017SubstitutionFlags["AsyncMethodsWithSuper"] = 1] = "AsyncMethodsWithSuper";
    })(ES2017SubstitutionFlags || (ES2017SubstitutionFlags = {}));
    var ContextFlags;
    (function (ContextFlags) {
        ContextFlags[ContextFlags["NonTopLevel"] = 1] = "NonTopLevel";
        ContextFlags[ContextFlags["HasLexicalThis"] = 2] = "HasLexicalThis";
    })(ContextFlags || (ContextFlags = {}));
    function transformES2017(context) {
        var factory = context.factory, emitHelpers = context.getEmitHelperFactory, resumeLexicalEnvironment = context.resumeLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment, hoistVariableDeclaration = context.hoistVariableDeclaration;
        var resolver = context.getEmitResolver();
        var compilerOptions = context.getCompilerOptions();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        /**
         * Keeps track of whether expression substitution has been enabled for specific edge cases.
         * They are persisted between each SourceFile transformation and should not be reset.
         */
        var enabledSubstitutions;
        /**
         * This keeps track of containers where `super` is valid, for use with
         * just-in-time substitution for `super` expressions inside of async methods.
         */
        var enclosingSuperContainerFlags = 0;
        var enclosingFunctionParameterNames;
        /**
         * Keeps track of property names accessed on super (`super.x`) within async functions.
         */
        var capturedSuperProperties;
        /** Whether the async function contains an element access on super (`super[x]`). */
        var hasSuperElementAccess;
        /** A set of node IDs for generated super accessors (variable statements). */
        var substitutedSuperAccessors = [];
        var contextFlags = 0;
        // Save the previous transformation hooks.
        var previousOnEmitNode = context.onEmitNode;
        var previousOnSubstituteNode = context.onSubstituteNode;
        // Set new transformation hooks.
        context.onEmitNode = onEmitNode;
        context.onSubstituteNode = onSubstituteNode;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            setContextFlag(1 /* ContextFlags.NonTopLevel */, false);
            setContextFlag(2 /* ContextFlags.HasLexicalThis */, !ts.isEffectiveStrictModeSourceFile(node, compilerOptions));
            var visited = ts.visitEachChild(node, visitor, context);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            return visited;
        }
        function setContextFlag(flag, val) {
            contextFlags = val ? contextFlags | flag : contextFlags & ~flag;
        }
        function inContext(flags) {
            return (contextFlags & flags) !== 0;
        }
        function inTopLevelContext() {
            return !inContext(1 /* ContextFlags.NonTopLevel */);
        }
        function inHasLexicalThisContext() {
            return inContext(2 /* ContextFlags.HasLexicalThis */);
        }
        function doWithContext(flags, cb, value) {
            var contextFlagsToSet = flags & ~contextFlags;
            if (contextFlagsToSet) {
                setContextFlag(contextFlagsToSet, /*val*/ true);
                var result = cb(value);
                setContextFlag(contextFlagsToSet, /*val*/ false);
                return result;
            }
            return cb(value);
        }
        function visitDefault(node) {
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            if ((node.transformFlags & 256 /* TransformFlags.ContainsES2017 */) === 0) {
                return node;
            }
            switch (node.kind) {
                case 131 /* SyntaxKind.AsyncKeyword */:
                    // ES2017 async modifier should be elided for targets < ES2017
                    return undefined;
                case 218 /* SyntaxKind.AwaitExpression */:
                    return visitAwaitExpression(node);
                case 169 /* SyntaxKind.MethodDeclaration */:
                    return doWithContext(1 /* ContextFlags.NonTopLevel */ | 2 /* ContextFlags.HasLexicalThis */, visitMethodDeclaration, node);
                case 256 /* SyntaxKind.FunctionDeclaration */:
                    return doWithContext(1 /* ContextFlags.NonTopLevel */ | 2 /* ContextFlags.HasLexicalThis */, visitFunctionDeclaration, node);
                case 213 /* SyntaxKind.FunctionExpression */:
                    return doWithContext(1 /* ContextFlags.NonTopLevel */ | 2 /* ContextFlags.HasLexicalThis */, visitFunctionExpression, node);
                case 214 /* SyntaxKind.ArrowFunction */:
                    return doWithContext(1 /* ContextFlags.NonTopLevel */, visitArrowFunction, node);
                case 206 /* SyntaxKind.PropertyAccessExpression */:
                    if (capturedSuperProperties && ts.isPropertyAccessExpression(node) && node.expression.kind === 106 /* SyntaxKind.SuperKeyword */) {
                        capturedSuperProperties.add(node.name.escapedText);
                    }
                    return ts.visitEachChild(node, visitor, context);
                case 207 /* SyntaxKind.ElementAccessExpression */:
                    if (capturedSuperProperties && node.expression.kind === 106 /* SyntaxKind.SuperKeyword */) {
                        hasSuperElementAccess = true;
                    }
                    return ts.visitEachChild(node, visitor, context);
                case 172 /* SyntaxKind.GetAccessor */:
                case 173 /* SyntaxKind.SetAccessor */:
                case 171 /* SyntaxKind.Constructor */:
                case 257 /* SyntaxKind.ClassDeclaration */:
                case 226 /* SyntaxKind.ClassExpression */:
                    return doWithContext(1 /* ContextFlags.NonTopLevel */ | 2 /* ContextFlags.HasLexicalThis */, visitDefault, node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function asyncBodyVisitor(node) {
            if (ts.isNodeWithPossibleHoistedDeclaration(node)) {
                switch (node.kind) {
                    case 237 /* SyntaxKind.VariableStatement */:
                        return visitVariableStatementInAsyncBody(node);
                    case 242 /* SyntaxKind.ForStatement */:
                        return visitForStatementInAsyncBody(node);
                    case 243 /* SyntaxKind.ForInStatement */:
                        return visitForInStatementInAsyncBody(node);
                    case 244 /* SyntaxKind.ForOfStatement */:
                        return visitForOfStatementInAsyncBody(node);
                    case 292 /* SyntaxKind.CatchClause */:
                        return visitCatchClauseInAsyncBody(node);
                    case 235 /* SyntaxKind.Block */:
                    case 249 /* SyntaxKind.SwitchStatement */:
                    case 263 /* SyntaxKind.CaseBlock */:
                    case 289 /* SyntaxKind.CaseClause */:
                    case 290 /* SyntaxKind.DefaultClause */:
                    case 252 /* SyntaxKind.TryStatement */:
                    case 240 /* SyntaxKind.DoStatement */:
                    case 241 /* SyntaxKind.WhileStatement */:
                    case 239 /* SyntaxKind.IfStatement */:
                    case 248 /* SyntaxKind.WithStatement */:
                    case 250 /* SyntaxKind.LabeledStatement */:
                        return ts.visitEachChild(node, asyncBodyVisitor, context);
                    default:
                        return ts.Debug.assertNever(node, "Unhandled node.");
                }
            }
            return visitor(node);
        }
        function visitCatchClauseInAsyncBody(node) {
            var catchClauseNames = new ts.Set();
            recordDeclarationName(node.variableDeclaration, catchClauseNames); // TODO: GH#18217
            // names declared in a catch variable are block scoped
            var catchClauseUnshadowedNames;
            catchClauseNames.forEach(function (_, escapedName) {
                if (enclosingFunctionParameterNames.has(escapedName)) {
                    if (!catchClauseUnshadowedNames) {
                        catchClauseUnshadowedNames = new ts.Set(enclosingFunctionParameterNames);
                    }
                    catchClauseUnshadowedNames.delete(escapedName);
                }
            });
            if (catchClauseUnshadowedNames) {
                var savedEnclosingFunctionParameterNames = enclosingFunctionParameterNames;
                enclosingFunctionParameterNames = catchClauseUnshadowedNames;
                var result = ts.visitEachChild(node, asyncBodyVisitor, context);
                enclosingFunctionParameterNames = savedEnclosingFunctionParameterNames;
                return result;
            }
            else {
                return ts.visitEachChild(node, asyncBodyVisitor, context);
            }
        }
        function visitVariableStatementInAsyncBody(node) {
            if (isVariableDeclarationListWithCollidingName(node.declarationList)) {
                var expression = visitVariableDeclarationListWithCollidingNames(node.declarationList, /*hasReceiver*/ false);
                return expression ? factory.createExpressionStatement(expression) : undefined;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitForInStatementInAsyncBody(node) {
            return factory.updateForInStatement(node, isVariableDeclarationListWithCollidingName(node.initializer)
                ? visitVariableDeclarationListWithCollidingNames(node.initializer, /*hasReceiver*/ true)
                : ts.visitNode(node.initializer, visitor, ts.isForInitializer), ts.visitNode(node.expression, visitor, ts.isExpression), ts.visitIterationBody(node.statement, asyncBodyVisitor, context));
        }
        function visitForOfStatementInAsyncBody(node) {
            return factory.updateForOfStatement(node, ts.visitNode(node.awaitModifier, visitor, ts.isToken), isVariableDeclarationListWithCollidingName(node.initializer)
                ? visitVariableDeclarationListWithCollidingNames(node.initializer, /*hasReceiver*/ true)
                : ts.visitNode(node.initializer, visitor, ts.isForInitializer), ts.visitNode(node.expression, visitor, ts.isExpression), ts.visitIterationBody(node.statement, asyncBodyVisitor, context));
        }
        function visitForStatementInAsyncBody(node) {
            var initializer = node.initializer; // TODO: GH#18217
            return factory.updateForStatement(node, isVariableDeclarationListWithCollidingName(initializer)
                ? visitVariableDeclarationListWithCollidingNames(initializer, /*hasReceiver*/ false)
                : ts.visitNode(node.initializer, visitor, ts.isForInitializer), ts.visitNode(node.condition, visitor, ts.isExpression), ts.visitNode(node.incrementor, visitor, ts.isExpression), ts.visitIterationBody(node.statement, asyncBodyVisitor, context));
        }
        /**
         * Visits an AwaitExpression node.
         *
         * This function will be called any time a ES2017 await expression is encountered.
         *
         * @param node The node to visit.
         */
        function visitAwaitExpression(node) {
            // do not downlevel a top-level await as it is module syntax...
            if (inTopLevelContext()) {
                return ts.visitEachChild(node, visitor, context);
            }
            return ts.setOriginalNode(ts.setTextRange(factory.createYieldExpression(
            /*asteriskToken*/ undefined, ts.visitNode(node.expression, visitor, ts.isExpression)), node), node);
        }
        /**
         * Visits a MethodDeclaration node.
         *
         * This function will be called when one of the following conditions are met:
         * - The node is marked as async
         *
         * @param node The node to visit.
         */
        function visitMethodDeclaration(node) {
            return factory.updateMethodDeclaration(node, 
            /*decorators*/ undefined, ts.visitNodes(node.modifiers, visitor, ts.isModifier), node.asteriskToken, node.name, 
            /*questionToken*/ undefined, 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, ts.getFunctionFlags(node) & 2 /* FunctionFlags.Async */
                ? transformAsyncFunctionBody(node)
                : ts.visitFunctionBody(node.body, visitor, context));
        }
        /**
         * Visits a FunctionDeclaration node.
         *
         * This function will be called when one of the following conditions are met:
         * - The node is marked async
         *
         * @param node The node to visit.
         */
        function visitFunctionDeclaration(node) {
            return factory.updateFunctionDeclaration(node, 
            /*decorators*/ undefined, ts.visitNodes(node.modifiers, visitor, ts.isModifier), node.asteriskToken, node.name, 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, ts.getFunctionFlags(node) & 2 /* FunctionFlags.Async */
                ? transformAsyncFunctionBody(node)
                : ts.visitFunctionBody(node.body, visitor, context));
        }
        /**
         * Visits a FunctionExpression node.
         *
         * This function will be called when one of the following conditions are met:
         * - The node is marked async
         *
         * @param node The node to visit.
         */
        function visitFunctionExpression(node) {
            return factory.updateFunctionExpression(node, ts.visitNodes(node.modifiers, visitor, ts.isModifier), node.asteriskToken, node.name, 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, ts.getFunctionFlags(node) & 2 /* FunctionFlags.Async */
                ? transformAsyncFunctionBody(node)
                : ts.visitFunctionBody(node.body, visitor, context));
        }
        /**
         * Visits an ArrowFunction.
         *
         * This function will be called when one of the following conditions are met:
         * - The node is marked async
         *
         * @param node The node to visit.
         */
        function visitArrowFunction(node) {
            return factory.updateArrowFunction(node, ts.visitNodes(node.modifiers, visitor, ts.isModifier), 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, visitor, context), 
            /*type*/ undefined, node.equalsGreaterThanToken, ts.getFunctionFlags(node) & 2 /* FunctionFlags.Async */
                ? transformAsyncFunctionBody(node)
                : ts.visitFunctionBody(node.body, visitor, context));
        }
        function recordDeclarationName(_a, names) {
            var name = _a.name;
            if (ts.isIdentifier(name)) {
                names.add(name.escapedText);
            }
            else {
                for (var _i = 0, _b = name.elements; _i < _b.length; _i++) {
                    var element = _b[_i];
                    if (!ts.isOmittedExpression(element)) {
                        recordDeclarationName(element, names);
                    }
                }
            }
        }
        function isVariableDeclarationListWithCollidingName(node) {
            return !!node
                && ts.isVariableDeclarationList(node)
                && !(node.flags & 3 /* NodeFlags.BlockScoped */)
                && node.declarations.some(collidesWithParameterName);
        }
        function visitVariableDeclarationListWithCollidingNames(node, hasReceiver) {
            hoistVariableDeclarationList(node);
            var variables = ts.getInitializedVariables(node);
            if (variables.length === 0) {
                if (hasReceiver) {
                    return ts.visitNode(factory.converters.convertToAssignmentElementTarget(node.declarations[0].name), visitor, ts.isExpression);
                }
                return undefined;
            }
            return factory.inlineExpressions(ts.map(variables, transformInitializedVariable));
        }
        function hoistVariableDeclarationList(node) {
            ts.forEach(node.declarations, hoistVariable);
        }
        function hoistVariable(_a) {
            var name = _a.name;
            if (ts.isIdentifier(name)) {
                hoistVariableDeclaration(name);
            }
            else {
                for (var _i = 0, _b = name.elements; _i < _b.length; _i++) {
                    var element = _b[_i];
                    if (!ts.isOmittedExpression(element)) {
                        hoistVariable(element);
                    }
                }
            }
        }
        function transformInitializedVariable(node) {
            var converted = ts.setSourceMapRange(factory.createAssignment(factory.converters.convertToAssignmentElementTarget(node.name), node.initializer), node);
            return ts.visitNode(converted, visitor, ts.isExpression);
        }
        function collidesWithParameterName(_a) {
            var name = _a.name;
            if (ts.isIdentifier(name)) {
                return enclosingFunctionParameterNames.has(name.escapedText);
            }
            else {
                for (var _i = 0, _b = name.elements; _i < _b.length; _i++) {
                    var element = _b[_i];
                    if (!ts.isOmittedExpression(element) && collidesWithParameterName(element)) {
                        return true;
                    }
                }
            }
            return false;
        }
        function transformAsyncFunctionBody(node) {
            resumeLexicalEnvironment();
            var original = ts.getOriginalNode(node, ts.isFunctionLike);
            var nodeType = original.type;
            var promiseConstructor = languageVersion < 2 /* ScriptTarget.ES2015 */ ? getPromiseConstructor(nodeType) : undefined;
            var isArrowFunction = node.kind === 214 /* SyntaxKind.ArrowFunction */;
            var hasLexicalArguments = (resolver.getNodeCheckFlags(node) & 8192 /* NodeCheckFlags.CaptureArguments */) !== 0;
            // An async function is emit as an outer function that calls an inner
            // generator function. To preserve lexical bindings, we pass the current
            // `this` and `arguments` objects to `__awaiter`. The generator function
            // passed to `__awaiter` is executed inside of the callback to the
            // promise constructor.
            var savedEnclosingFunctionParameterNames = enclosingFunctionParameterNames;
            enclosingFunctionParameterNames = new ts.Set();
            for (var _i = 0, _a = node.parameters; _i < _a.length; _i++) {
                var parameter = _a[_i];
                recordDeclarationName(parameter, enclosingFunctionParameterNames);
            }
            var savedCapturedSuperProperties = capturedSuperProperties;
            var savedHasSuperElementAccess = hasSuperElementAccess;
            if (!isArrowFunction) {
                capturedSuperProperties = new ts.Set();
                hasSuperElementAccess = false;
            }
            var result;
            if (!isArrowFunction) {
                var statements = [];
                var statementOffset = factory.copyPrologue(node.body.statements, statements, /*ensureUseStrict*/ false, visitor);
                statements.push(factory.createReturnStatement(emitHelpers().createAwaiterHelper(inHasLexicalThisContext(), hasLexicalArguments, promiseConstructor, transformAsyncFunctionBodyWorker(node.body, statementOffset))));
                ts.insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());
                // Minor optimization, emit `_super` helper to capture `super` access in an arrow.
                // This step isn't needed if we eventually transform this to ES5.
                var emitSuperHelpers = languageVersion >= 2 /* ScriptTarget.ES2015 */ && resolver.getNodeCheckFlags(node) & (4096 /* NodeCheckFlags.AsyncMethodWithSuperBinding */ | 2048 /* NodeCheckFlags.AsyncMethodWithSuper */);
                if (emitSuperHelpers) {
                    enableSubstitutionForAsyncMethodsWithSuper();
                    if (capturedSuperProperties.size) {
                        var variableStatement = createSuperAccessVariableStatement(factory, resolver, node, capturedSuperProperties);
                        substitutedSuperAccessors[ts.getNodeId(variableStatement)] = true;
                        ts.insertStatementsAfterStandardPrologue(statements, [variableStatement]);
                    }
                }
                var block = factory.createBlock(statements, /*multiLine*/ true);
                ts.setTextRange(block, node.body);
                if (emitSuperHelpers && hasSuperElementAccess) {
                    // Emit helpers for super element access expressions (`super[x]`).
                    if (resolver.getNodeCheckFlags(node) & 4096 /* NodeCheckFlags.AsyncMethodWithSuperBinding */) {
                        ts.addEmitHelper(block, ts.advancedAsyncSuperHelper);
                    }
                    else if (resolver.getNodeCheckFlags(node) & 2048 /* NodeCheckFlags.AsyncMethodWithSuper */) {
                        ts.addEmitHelper(block, ts.asyncSuperHelper);
                    }
                }
                result = block;
            }
            else {
                var expression = emitHelpers().createAwaiterHelper(inHasLexicalThisContext(), hasLexicalArguments, promiseConstructor, transformAsyncFunctionBodyWorker(node.body));
                var declarations = endLexicalEnvironment();
                if (ts.some(declarations)) {
                    var block = factory.converters.convertToFunctionBlock(expression);
                    result = factory.updateBlock(block, ts.setTextRange(factory.createNodeArray(ts.concatenate(declarations, block.statements)), block.statements));
                }
                else {
                    result = expression;
                }
            }
            enclosingFunctionParameterNames = savedEnclosingFunctionParameterNames;
            if (!isArrowFunction) {
                capturedSuperProperties = savedCapturedSuperProperties;
                hasSuperElementAccess = savedHasSuperElementAccess;
            }
            return result;
        }
        function transformAsyncFunctionBodyWorker(body, start) {
            if (ts.isBlock(body)) {
                return factory.updateBlock(body, ts.visitNodes(body.statements, asyncBodyVisitor, ts.isStatement, start));
            }
            else {
                return factory.converters.convertToFunctionBlock(ts.visitNode(body, asyncBodyVisitor, ts.isConciseBody));
            }
        }
        function getPromiseConstructor(type) {
            var typeName = type && ts.getEntityNameFromTypeNode(type);
            if (typeName && ts.isEntityName(typeName)) {
                var serializationKind = resolver.getTypeReferenceSerializationKind(typeName);
                if (serializationKind === ts.TypeReferenceSerializationKind.TypeWithConstructSignatureAndValue
                    || serializationKind === ts.TypeReferenceSerializationKind.Unknown) {
                    return typeName;
                }
            }
            return undefined;
        }
        function enableSubstitutionForAsyncMethodsWithSuper() {
            if ((enabledSubstitutions & 1 /* ES2017SubstitutionFlags.AsyncMethodsWithSuper */) === 0) {
                enabledSubstitutions |= 1 /* ES2017SubstitutionFlags.AsyncMethodsWithSuper */;
                // We need to enable substitutions for call, property access, and element access
                // if we need to rewrite super calls.
                context.enableSubstitution(208 /* SyntaxKind.CallExpression */);
                context.enableSubstitution(206 /* SyntaxKind.PropertyAccessExpression */);
                context.enableSubstitution(207 /* SyntaxKind.ElementAccessExpression */);
                // We need to be notified when entering and exiting declarations that bind super.
                context.enableEmitNotification(257 /* SyntaxKind.ClassDeclaration */);
                context.enableEmitNotification(169 /* SyntaxKind.MethodDeclaration */);
                context.enableEmitNotification(172 /* SyntaxKind.GetAccessor */);
                context.enableEmitNotification(173 /* SyntaxKind.SetAccessor */);
                context.enableEmitNotification(171 /* SyntaxKind.Constructor */);
                // We need to be notified when entering the generated accessor arrow functions.
                context.enableEmitNotification(237 /* SyntaxKind.VariableStatement */);
            }
        }
        /**
         * Hook for node emit.
         *
         * @param hint A hint as to the intended usage of the node.
         * @param node The node to emit.
         * @param emit A callback used to emit the node in the printer.
         */
        function onEmitNode(hint, node, emitCallback) {
            // If we need to support substitutions for `super` in an async method,
            // we should track it here.
            if (enabledSubstitutions & 1 /* ES2017SubstitutionFlags.AsyncMethodsWithSuper */ && isSuperContainer(node)) {
                var superContainerFlags = resolver.getNodeCheckFlags(node) & (2048 /* NodeCheckFlags.AsyncMethodWithSuper */ | 4096 /* NodeCheckFlags.AsyncMethodWithSuperBinding */);
                if (superContainerFlags !== enclosingSuperContainerFlags) {
                    var savedEnclosingSuperContainerFlags = enclosingSuperContainerFlags;
                    enclosingSuperContainerFlags = superContainerFlags;
                    previousOnEmitNode(hint, node, emitCallback);
                    enclosingSuperContainerFlags = savedEnclosingSuperContainerFlags;
                    return;
                }
            }
            // Disable substitution in the generated super accessor itself.
            else if (enabledSubstitutions && substitutedSuperAccessors[ts.getNodeId(node)]) {
                var savedEnclosingSuperContainerFlags = enclosingSuperContainerFlags;
                enclosingSuperContainerFlags = 0;
                previousOnEmitNode(hint, node, emitCallback);
                enclosingSuperContainerFlags = savedEnclosingSuperContainerFlags;
                return;
            }
            previousOnEmitNode(hint, node, emitCallback);
        }
        /**
         * Hooks node substitutions.
         *
         * @param hint A hint as to the intended usage of the node.
         * @param node The node to substitute.
         */
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1 /* EmitHint.Expression */ && enclosingSuperContainerFlags) {
                return substituteExpression(node);
            }
            return node;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 206 /* SyntaxKind.PropertyAccessExpression */:
                    return substitutePropertyAccessExpression(node);
                case 207 /* SyntaxKind.ElementAccessExpression */:
                    return substituteElementAccessExpression(node);
                case 208 /* SyntaxKind.CallExpression */:
                    return substituteCallExpression(node);
            }
            return node;
        }
        function substitutePropertyAccessExpression(node) {
            if (node.expression.kind === 106 /* SyntaxKind.SuperKeyword */) {
                return ts.setTextRange(factory.createPropertyAccessExpression(factory.createUniqueName("_super", 16 /* GeneratedIdentifierFlags.Optimistic */ | 32 /* GeneratedIdentifierFlags.FileLevel */), node.name), node);
            }
            return node;
        }
        function substituteElementAccessExpression(node) {
            if (node.expression.kind === 106 /* SyntaxKind.SuperKeyword */) {
                return createSuperElementAccessInAsyncMethod(node.argumentExpression, node);
            }
            return node;
        }
        function substituteCallExpression(node) {
            var expression = node.expression;
            if (ts.isSuperProperty(expression)) {
                var argumentExpression = ts.isPropertyAccessExpression(expression)
                    ? substitutePropertyAccessExpression(expression)
                    : substituteElementAccessExpression(expression);
                return factory.createCallExpression(factory.createPropertyAccessExpression(argumentExpression, "call"), 
                /*typeArguments*/ undefined, __spreadArray([
                    factory.createThis()
                ], node.arguments, true));
            }
            return node;
        }
        function isSuperContainer(node) {
            var kind = node.kind;
            return kind === 257 /* SyntaxKind.ClassDeclaration */
                || kind === 171 /* SyntaxKind.Constructor */
                || kind === 169 /* SyntaxKind.MethodDeclaration */
                || kind === 172 /* SyntaxKind.GetAccessor */
                || kind === 173 /* SyntaxKind.SetAccessor */;
        }
        function createSuperElementAccessInAsyncMethod(argumentExpression, location) {
            if (enclosingSuperContainerFlags & 4096 /* NodeCheckFlags.AsyncMethodWithSuperBinding */) {
                return ts.setTextRange(factory.createPropertyAccessExpression(factory.createCallExpression(factory.createUniqueName("_superIndex", 16 /* GeneratedIdentifierFlags.Optimistic */ | 32 /* GeneratedIdentifierFlags.FileLevel */), 
                /*typeArguments*/ undefined, [argumentExpression]), "value"), location);
            }
            else {
                return ts.setTextRange(factory.createCallExpression(factory.createUniqueName("_superIndex", 16 /* GeneratedIdentifierFlags.Optimistic */ | 32 /* GeneratedIdentifierFlags.FileLevel */), 
                /*typeArguments*/ undefined, [argumentExpression]), location);
            }
        }
    }
    ts.transformES2017 = transformES2017;
    /** Creates a variable named `_super` with accessor properties for the given property names. */
    function createSuperAccessVariableStatement(factory, resolver, node, names) {
        // Create a variable declaration with a getter/setter (if binding) definition for each name:
        //   const _super = Object.create(null, { x: { get: () => super.x, set: (v) => super.x = v }, ... });
        var hasBinding = (resolver.getNodeCheckFlags(node) & 4096 /* NodeCheckFlags.AsyncMethodWithSuperBinding */) !== 0;
        var accessors = [];
        names.forEach(function (_, key) {
            var name = ts.unescapeLeadingUnderscores(key);
            var getterAndSetter = [];
            getterAndSetter.push(factory.createPropertyAssignment("get", factory.createArrowFunction(
            /* modifiers */ undefined, 
            /* typeParameters */ undefined, 
            /* parameters */ [], 
            /* type */ undefined, 
            /* equalsGreaterThanToken */ undefined, ts.setEmitFlags(factory.createPropertyAccessExpression(ts.setEmitFlags(factory.createSuper(), 4 /* EmitFlags.NoSubstitution */), name), 4 /* EmitFlags.NoSubstitution */))));
            if (hasBinding) {
                getterAndSetter.push(factory.createPropertyAssignment("set", factory.createArrowFunction(
                /* modifiers */ undefined, 
                /* typeParameters */ undefined, 
                /* parameters */ [
                    factory.createParameterDeclaration(
                    /* decorators */ undefined, 
                    /* modifiers */ undefined, 
                    /* dotDotDotToken */ undefined, "v", 
                    /* questionToken */ undefined, 
                    /* type */ undefined, 
                    /* initializer */ undefined)
                ], 
                /* type */ undefined, 
                /* equalsGreaterThanToken */ undefined, factory.createAssignment(ts.setEmitFlags(factory.createPropertyAccessExpression(ts.setEmitFlags(factory.createSuper(), 4 /* EmitFlags.NoSubstitution */), name), 4 /* EmitFlags.NoSubstitution */), factory.createIdentifier("v")))));
            }
            accessors.push(factory.createPropertyAssignment(name, factory.createObjectLiteralExpression(getterAndSetter)));
        });
        return factory.createVariableStatement(
        /* modifiers */ undefined, factory.createVariableDeclarationList([
            factory.createVariableDeclaration(factory.createUniqueName("_super", 16 /* GeneratedIdentifierFlags.Optimistic */ | 32 /* GeneratedIdentifierFlags.FileLevel */), 
            /*exclamationToken*/ undefined, 
            /* type */ undefined, factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier("Object"), "create"), 
            /* typeArguments */ undefined, [
                factory.createNull(),
                factory.createObjectLiteralExpression(accessors, /* multiline */ true)
            ]))
        ], 2 /* NodeFlags.Const */));
    }
    ts.createSuperAccessVariableStatement = createSuperAccessVariableStatement;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var ESNextSubstitutionFlags;
    (function (ESNextSubstitutionFlags) {
        /** Enables substitutions for async methods with `super` calls. */
        ESNextSubstitutionFlags[ESNextSubstitutionFlags["AsyncMethodsWithSuper"] = 1] = "AsyncMethodsWithSuper";
    })(ESNextSubstitutionFlags || (ESNextSubstitutionFlags = {}));
    // Facts we track as we traverse the tree
    var HierarchyFacts;
    (function (HierarchyFacts) {
        HierarchyFacts[HierarchyFacts["None"] = 0] = "None";
        //
        // Ancestor facts
        //
        HierarchyFacts[HierarchyFacts["HasLexicalThis"] = 1] = "HasLexicalThis";
        HierarchyFacts[HierarchyFacts["IterationContainer"] = 2] = "IterationContainer";
        // NOTE: do not add more ancestor flags without also updating AncestorFactsMask below.
        //
        // Ancestor masks
        //
        HierarchyFacts[HierarchyFacts["AncestorFactsMask"] = 3] = "AncestorFactsMask";
        HierarchyFacts[HierarchyFacts["SourceFileIncludes"] = 1] = "SourceFileIncludes";
        HierarchyFacts[HierarchyFacts["SourceFileExcludes"] = 2] = "SourceFileExcludes";
        HierarchyFacts[HierarchyFacts["StrictModeSourceFileIncludes"] = 0] = "StrictModeSourceFileIncludes";
        HierarchyFacts[HierarchyFacts["ClassOrFunctionIncludes"] = 1] = "ClassOrFunctionIncludes";
        HierarchyFacts[HierarchyFacts["ClassOrFunctionExcludes"] = 2] = "ClassOrFunctionExcludes";
        HierarchyFacts[HierarchyFacts["ArrowFunctionIncludes"] = 0] = "ArrowFunctionIncludes";
        HierarchyFacts[HierarchyFacts["ArrowFunctionExcludes"] = 2] = "ArrowFunctionExcludes";
        HierarchyFacts[HierarchyFacts["IterationStatementIncludes"] = 2] = "IterationStatementIncludes";
        HierarchyFacts[HierarchyFacts["IterationStatementExcludes"] = 0] = "IterationStatementExcludes";
    })(HierarchyFacts || (HierarchyFacts = {}));
    function transformES2018(context) {
        var factory = context.factory, emitHelpers = context.getEmitHelperFactory, resumeLexicalEnvironment = context.resumeLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment, hoistVariableDeclaration = context.hoistVariableDeclaration;
        var resolver = context.getEmitResolver();
        var compilerOptions = context.getCompilerOptions();
        var languageVersion = ts.getEmitScriptTarget(compilerOptions);
        var previousOnEmitNode = context.onEmitNode;
        context.onEmitNode = onEmitNode;
        var previousOnSubstituteNode = context.onSubstituteNode;
        context.onSubstituteNode = onSubstituteNode;
        var exportedVariableStatement = false;
        var enabledSubstitutions;
        var enclosingFunctionFlags;
        var parametersWithPrecedingObjectRestOrSpread;
        var enclosingSuperContainerFlags = 0;
        var hierarchyFacts = 0;
        var currentSourceFile;
        var taggedTemplateStringDeclarations;
        /** Keeps track of property names accessed on super (`super.x`) within async functions. */
        var capturedSuperProperties;
        /** Whether the async function contains an element access on super (`super[x]`). */
        var hasSuperElementAccess;
        /** A set of node IDs for generated super accessors. */
        var substitutedSuperAccessors = [];
        return ts.chainBundle(context, transformSourceFile);
        function affectsSubtree(excludeFacts, includeFacts) {
            return hierarchyFacts !== (hierarchyFacts & ~excludeFacts | includeFacts);
        }
        /**
         * Sets the `HierarchyFacts` for this node prior to visiting this node's subtree, returning the facts set prior to modification.
         * @param excludeFacts The existing `HierarchyFacts` to reset before visiting the subtree.
         * @param includeFacts The new `HierarchyFacts` to set before visiting the subtree.
         */
        function enterSubtree(excludeFacts, includeFacts) {
            var ancestorFacts = hierarchyFacts;
            hierarchyFacts = (hierarchyFacts & ~excludeFacts | includeFacts) & 3 /* HierarchyFacts.AncestorFactsMask */;
            return ancestorFacts;
        }
        /**
         * Restores the `HierarchyFacts` for this node's ancestor after visiting this node's
         * subtree.
         * @param ancestorFacts The `HierarchyFacts` of the ancestor to restore after visiting the subtree.
         */
        function exitSubtree(ancestorFacts) {
            hierarchyFacts = ancestorFacts;
        }
        function recordTaggedTemplateString(temp) {
            taggedTemplateStringDeclarations = ts.append(taggedTemplateStringDeclarations, factory.createVariableDeclaration(temp));
        }
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            currentSourceFile = node;
            var visited = visitSourceFile(node);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            currentSourceFile = undefined;
            taggedTemplateStringDeclarations = undefined;
            return visited;
        }
        function visitor(node) {
            return visitorWorker(node, /*expressionResultIsUnused*/ false);
        }
        function visitorWithUnusedExpressionResult(node) {
            return visitorWorker(node, /*expressionResultIsUnused*/ true);
        }
        function visitorNoAsyncModifier(node) {
            if (node.kind === 131 /* SyntaxKind.AsyncKeyword */) {
                return undefined;
            }
            return node;
        }
        function doWithHierarchyFacts(cb, value, excludeFacts, includeFacts) {
            if (affectsSubtree(excludeFacts, includeFacts)) {
                var ancestorFacts = enterSubtree(excludeFacts, includeFacts);
                var result = cb(value);
                exitSubtree(ancestorFacts);
                return result;
            }
            return cb(value);
        }
        function visitDefault(node) {
            return ts.visitEachChild(node, visitor, context);
        }
        /**
         * @param expressionResultIsUnused Indicates the result of an expression is unused by the parent node (i.e., the left side of a comma or the
         * expression of an `ExpressionStatement`).
         */
        function visitorWorker(node, expressionResultIsUnused) {
            if ((node.transformFlags & 128 /* TransformFlags.ContainsES2018 */) === 0) {
                return node;
            }
            switch (node.kind) {
                case 218 /* SyntaxKind.AwaitExpression */:
                    return visitAwaitExpression(node);
                case 224 /* SyntaxKind.YieldExpression */:
                    return visitYieldExpression(node);
                case 247 /* SyntaxKind.ReturnStatement */:
                    return visitReturnStatement(node);
                case 250 /* SyntaxKind.LabeledStatement */:
                    return visitLabeledStatement(node);
                case 205 /* SyntaxKind.ObjectLiteralExpression */:
                    return visitObjectLiteralExpression(node);
                case 221 /* SyntaxKind.BinaryExpression */:
                    return visitBinaryExpression(node, expressionResultIsUnused);
                case 351 /* SyntaxKind.CommaListExpression */:
                    return visitCommaListExpression(node, expressionResultIsUnused);
                case 292 /* SyntaxKind.CatchClause */:
                    return visitCatchClause(node);
                case 237 /* SyntaxKind.VariableStatement */:
                    return visitVariableStatement(node);
                case 254 /* SyntaxKind.VariableDeclaration */:
                    return visitVariableDeclaration(node);
                case 240 /* SyntaxKind.DoStatement */:
                case 241 /* SyntaxKind.WhileStatement */:
                case 243 /* SyntaxKind.ForInStatement */:
                    return doWithHierarchyFacts(visitDefault, node, 0 /* HierarchyFacts.IterationStatementExcludes */, 2 /* HierarchyFacts.IterationStatementIncludes */);
                case 244 /* SyntaxKind.ForOfStatement */:
                    return visitForOfStatement(node, /*outermostLabeledStatement*/ undefined);
                case 242 /* SyntaxKind.ForStatement */:
                    return doWithHierarchyFacts(visitForStatement, node, 0 /* HierarchyFacts.IterationStatementExcludes */, 2 /* HierarchyFacts.IterationStatementIncludes */);
                case 217 /* SyntaxKind.VoidExpression */:
                    return visitVoidExpression(node);
                case 171 /* SyntaxKind.Constructor */:
                    return doWithHierarchyFacts(visitConstructorDeclaration, node, 2 /* HierarchyFacts.ClassOrFunctionExcludes */, 1 /* HierarchyFacts.ClassOrFunctionIncludes */);
                case 169 /* SyntaxKind.MethodDeclaration */:
                    return doWithHierarchyFacts(visitMethodDeclaration, node, 2 /* HierarchyFacts.ClassOrFunctionExcludes */, 1 /* HierarchyFacts.ClassOrFunctionIncludes */);
                case 172 /* SyntaxKind.GetAccessor */:
                    return doWithHierarchyFacts(visitGetAccessorDeclaration, node, 2 /* HierarchyFacts.ClassOrFunctionExcludes */, 1 /* HierarchyFacts.ClassOrFunctionIncludes */);
                case 173 /* SyntaxKind.SetAccessor */:
                    return doWithHierarchyFacts(visitSetAccessorDeclaration, node, 2 /* HierarchyFacts.ClassOrFunctionExcludes */, 1 /* HierarchyFacts.ClassOrFunctionIncludes */);
                case 256 /* SyntaxKind.FunctionDeclaration */:
                    return doWithHierarchyFacts(visitFunctionDeclaration, node, 2 /* HierarchyFacts.ClassOrFunctionExcludes */, 1 /* HierarchyFacts.ClassOrFunctionIncludes */);
                case 213 /* SyntaxKind.FunctionExpression */:
                    return doWithHierarchyFacts(visitFunctionExpression, node, 2 /* HierarchyFacts.ClassOrFunctionExcludes */, 1 /* HierarchyFacts.ClassOrFunctionIncludes */);
                case 214 /* SyntaxKind.ArrowFunction */:
                    return doWithHierarchyFacts(visitArrowFunction, node, 2 /* HierarchyFacts.ArrowFunctionExcludes */, 0 /* HierarchyFacts.ArrowFunctionIncludes */);
                case 164 /* SyntaxKind.Parameter */:
                    return visitParameter(node);
                case 238 /* SyntaxKind.ExpressionStatement */:
                    return visitExpressionStatement(node);
                case 212 /* SyntaxKind.ParenthesizedExpression */:
                    return visitParenthesizedExpression(node, expressionResultIsUnused);
                case 210 /* SyntaxKind.TaggedTemplateExpression */:
                    return visitTaggedTemplateExpression(node);
                case 206 /* SyntaxKind.PropertyAccessExpression */:
                    if (capturedSuperProperties && ts.isPropertyAccessExpression(node) && node.expression.kind === 106 /* SyntaxKind.SuperKeyword */) {
                        capturedSuperProperties.add(node.name.escapedText);
                    }
                    return ts.visitEachChild(node, visitor, context);
                case 207 /* SyntaxKind.ElementAccessExpression */:
                    if (capturedSuperProperties && node.expression.kind === 106 /* SyntaxKind.SuperKeyword */) {
                        hasSuperElementAccess = true;
                    }
                    return ts.visitEachChild(node, visitor, context);
                case 257 /* SyntaxKind.ClassDeclaration */:
                case 226 /* SyntaxKind.ClassExpression */:
                    return doWithHierarchyFacts(visitDefault, node, 2 /* HierarchyFacts.ClassOrFunctionExcludes */, 1 /* HierarchyFacts.ClassOrFunctionIncludes */);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitAwaitExpression(node) {
            if (enclosingFunctionFlags & 2 /* FunctionFlags.Async */ && enclosingFunctionFlags & 1 /* FunctionFlags.Generator */) {
                return ts.setOriginalNode(ts.setTextRange(factory.createYieldExpression(/*asteriskToken*/ undefined, emitHelpers().createAwaitHelper(ts.visitNode(node.expression, visitor, ts.isExpression))), 
                /*location*/ node), node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitYieldExpression(node) {
            if (enclosingFunctionFlags & 2 /* FunctionFlags.Async */ && enclosingFunctionFlags & 1 /* FunctionFlags.Generator */) {
                if (node.asteriskToken) {
                    var expression = ts.visitNode(ts.Debug.checkDefined(node.expression), visitor, ts.isExpression);
                    return ts.setOriginalNode(ts.setTextRange(factory.createYieldExpression(
                    /*asteriskToken*/ undefined, emitHelpers().createAwaitHelper(factory.updateYieldExpression(node, node.asteriskToken, ts.setTextRange(emitHelpers().createAsyncDelegatorHelper(ts.setTextRange(emitHelpers().createAsyncValuesHelper(expression), expression)), expression)))), node), node);
                }
                return ts.setOriginalNode(ts.setTextRange(factory.createYieldExpression(
                /*asteriskToken*/ undefined, createDownlevelAwait(node.expression
                    ? ts.visitNode(node.expression, visitor, ts.isExpression)
                    : factory.createVoidZero())), node), node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitReturnStatement(node) {
            if (enclosingFunctionFlags & 2 /* FunctionFlags.Async */ && enclosingFunctionFlags & 1 /* FunctionFlags.Generator */) {
                return factory.updateReturnStatement(node, createDownlevelAwait(node.expression ? ts.visitNode(node.expression, visitor, ts.isExpression) : factory.createVoidZero()));
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitLabeledStatement(node) {
            if (enclosingFunctionFlags & 2 /* FunctionFlags.Async */) {
                var statement = ts.unwrapInnermostStatementOfLabel(node);
                if (statement.kind === 244 /* SyntaxKind.ForOfStatement */ && statement.awaitModifier) {
                    return visitForOfStatement(statement, node);
                }
                return factory.restoreEnclosingLabel(ts.visitNode(statement, visitor, ts.isStatement, factory.liftToBlock), node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function chunkObjectLiteralElements(elements) {
            var chunkObject;
            var objects = [];
            for (var _i = 0, elements_5 = elements; _i < elements_5.length; _i++) {
                var e = elements_5[_i];
                if (e.kind === 298 /* SyntaxKind.SpreadAssignment */) {
                    if (chunkObject) {
                        objects.push(factory.createObjectLiteralExpression(chunkObject));
                        chunkObject = undefined;
                    }
                    var target = e.expression;
                    objects.push(ts.visitNode(target, visitor, ts.isExpression));
                }
                else {
                    chunkObject = ts.append(chunkObject, e.kind === 296 /* SyntaxKind.PropertyAssignment */
                        ? factory.createPropertyAssignment(e.name, ts.visitNode(e.initializer, visitor, ts.isExpression))
                        : ts.visitNode(e, visitor, ts.isObjectLiteralElementLike));
                }
            }
            if (chunkObject) {
                objects.push(factory.createObjectLiteralExpression(chunkObject));
            }
            return objects;
        }
        function visitObjectLiteralExpression(node) {
            if (node.transformFlags & 32768 /* TransformFlags.ContainsObjectRestOrSpread */) {
                // spread elements emit like so:
                // non-spread elements are chunked together into object literals, and then all are passed to __assign:
                //     { a, ...o, b } => __assign(__assign({a}, o), {b});
                // If the first element is a spread element, then the first argument to __assign is {}:
                //     { ...o, a, b, ...o2 } => __assign(__assign(__assign({}, o), {a, b}), o2)
                //
                // We cannot call __assign with more than two elements, since any element could cause side effects. For
                // example:
                //      var k = { a: 1, b: 2 };
                //      var o = { a: 3, ...k, b: k.a++ };
                //      // expected: { a: 1, b: 1 }
                // If we translate the above to `__assign({ a: 3 }, k, { b: k.a++ })`, the `k.a++` will evaluate before
                // `k` is spread and we end up with `{ a: 2, b: 1 }`.
                //
                // This also occurs for spread elements, not just property assignments:
                //      var k = { a: 1, get b() { l = { z: 9 }; return 2; } };
                //      var l = { c: 3 };
                //      var o = { ...k, ...l };
                //      // expected: { a: 1, b: 2, z: 9 }
                // If we translate the above to `__assign({}, k, l)`, the `l` will evaluate before `k` is spread and we
                // end up with `{ a: 1, b: 2, c: 3 }`
                var objects = chunkObjectLiteralElements(node.properties);
                if (objects.length && objects[0].kind !== 205 /* SyntaxKind.ObjectLiteralExpression */) {
                    objects.unshift(factory.createObjectLiteralExpression());
                }
                var expression = objects[0];
                if (objects.length > 1) {
                    for (var i = 1; i < objects.length; i++) {
                        expression = emitHelpers().createAssignHelper([expression, objects[i]]);
                    }
                    return expression;
                }
                else {
                    return emitHelpers().createAssignHelper(objects);
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitExpressionStatement(node) {
            return ts.visitEachChild(node, visitorWithUnusedExpressionResult, context);
        }
        /**
         * @param expressionResultIsUnused Indicates the result of an expression is unused by the parent node (i.e., the left side of a comma or the
         * expression of an `ExpressionStatement`).
         */
        function visitParenthesizedExpression(node, expressionResultIsUnused) {
            return ts.visitEachChild(node, expressionResultIsUnused ? visitorWithUnusedExpressionResult : visitor, context);
        }
        function visitSourceFile(node) {
            var ancestorFacts = enterSubtree(2 /* HierarchyFacts.SourceFileExcludes */, ts.isEffectiveStrictModeSourceFile(node, compilerOptions) ?
                0 /* HierarchyFacts.StrictModeSourceFileIncludes */ :
                1 /* HierarchyFacts.SourceFileIncludes */);
            exportedVariableStatement = false;
            var visited = ts.visitEachChild(node, visitor, context);
            var statement = ts.concatenate(visited.statements, taggedTemplateStringDeclarations && [
                factory.createVariableStatement(/*modifiers*/ undefined, factory.createVariableDeclarationList(taggedTemplateStringDeclarations))
            ]);
            var result = factory.updateSourceFile(visited, ts.setTextRange(factory.createNodeArray(statement), node.statements));
            exitSubtree(ancestorFacts);
            return result;
        }
        function visitTaggedTemplateExpression(node) {
            return ts.processTaggedTemplateExpression(context, node, visitor, currentSourceFile, recordTaggedTemplateString, ts.ProcessLevel.LiftRestriction);
        }
        /**
         * Visits a BinaryExpression that contains a destructuring assignment.
         *
         * @param node A BinaryExpression node.
         * @param expressionResultIsUnused Indicates the result of an expression is unused by the parent node (i.e., the left side of a comma or the
         * expression of an `ExpressionStatement`).
         */
        function visitBinaryExpression(node, expressionResultIsUnused) {
            if (ts.isDestructuringAssignment(node) && node.left.transformFlags & 32768 /* TransformFlags.ContainsObjectRestOrSpread */) {
                return ts.flattenDestructuringAssignment(node, visitor, context, 1 /* FlattenLevel.ObjectRest */, !expressionResultIsUnused);
            }
            if (node.operatorToken.kind === 27 /* SyntaxKind.CommaToken */) {
                return factory.updateBinaryExpression(node, ts.visitNode(node.left, visitorWithUnusedExpressionResult, ts.isExpression), node.operatorToken, ts.visitNode(node.right, expressionResultIsUnused ? visitorWithUnusedExpressionResult : visitor, ts.isExpression));
            }
            return ts.visitEachChild(node, visitor, context);
        }
        /**
         * @param expressionResultIsUnused Indicates the result of an expression is unused by the parent node (i.e., the left side of a comma or the
         * expression of an `ExpressionStatement`).
         */
        function visitCommaListExpression(node, expressionResultIsUnused) {
            if (expressionResultIsUnused) {
                return ts.visitEachChild(node, visitorWithUnusedExpressionResult, context);
            }
            var result;
            for (var i = 0; i < node.elements.length; i++) {
                var element = node.elements[i];
                var visited = ts.visitNode(element, i < node.elements.length - 1 ? visitorWithUnusedExpressionResult : visitor, ts.isExpression);
                if (result || visited !== element) {
                    result || (result = node.elements.slice(0, i));
                    result.push(visited);
                }
            }
            var elements = result ? ts.setTextRange(factory.createNodeArray(result), node.elements) : node.elements;
            return factory.updateCommaListExpression(node, elements);
        }
        function visitCatchClause(node) {
            if (node.variableDeclaration &&
                ts.isBindingPattern(node.variableDeclaration.name) &&
                node.variableDeclaration.name.transformFlags & 32768 /* TransformFlags.ContainsObjectRestOrSpread */) {
                var name = factory.getGeneratedNameForNode(node.variableDeclaration.name);
                var updatedDecl = factory.updateVariableDeclaration(node.variableDeclaration, node.variableDeclaration.name, /*exclamationToken*/ undefined, /*type*/ undefined, name);
                var visitedBindings = ts.flattenDestructuringBinding(updatedDecl, visitor, context, 1 /* FlattenLevel.ObjectRest */);
                var block = ts.visitNode(node.block, visitor, ts.isBlock);
                if (ts.some(visitedBindings)) {
                    block = factory.updateBlock(block, __spreadArray([
                        factory.createVariableStatement(/*modifiers*/ undefined, visitedBindings)
                    ], block.statements, true));
                }
                return factory.updateCatchClause(node, factory.updateVariableDeclaration(node.variableDeclaration, name, /*exclamationToken*/ undefined, /*type*/ undefined, /*initializer*/ undefined), block);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitVariableStatement(node) {
            if (ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */)) {
                var savedExportedVariableStatement = exportedVariableStatement;
                exportedVariableStatement = true;
                var visited = ts.visitEachChild(node, visitor, context);
                exportedVariableStatement = savedExportedVariableStatement;
                return visited;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        /**
         * Visits a VariableDeclaration node with a binding pattern.
         *
         * @param node A VariableDeclaration node.
         */
        function visitVariableDeclaration(node) {
            if (exportedVariableStatement) {
                var savedExportedVariableStatement = exportedVariableStatement;
                exportedVariableStatement = false;
                var visited = visitVariableDeclarationWorker(node, /*exportedVariableStatement*/ true);
                exportedVariableStatement = savedExportedVariableStatement;
                return visited;
            }
            return visitVariableDeclarationWorker(node, /*exportedVariableStatement*/ false);
        }
        function visitVariableDeclarationWorker(node, exportedVariableStatement) {
            // If we are here it is because the name contains a binding pattern with a rest somewhere in it.
            if (ts.isBindingPattern(node.name) && node.name.transformFlags & 32768 /* TransformFlags.ContainsObjectRestOrSpread */) {
                return ts.flattenDestructuringBinding(node, visitor, context, 1 /* FlattenLevel.ObjectRest */, 
                /*rval*/ undefined, exportedVariableStatement);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitForStatement(node) {
            return factory.updateForStatement(node, ts.visitNode(node.initializer, visitorWithUnusedExpressionResult, ts.isForInitializer), ts.visitNode(node.condition, visitor, ts.isExpression), ts.visitNode(node.incrementor, visitorWithUnusedExpressionResult, ts.isExpression), ts.visitIterationBody(node.statement, visitor, context));
        }
        function visitVoidExpression(node) {
            return ts.visitEachChild(node, visitorWithUnusedExpressionResult, context);
        }
        /**
         * Visits a ForOfStatement and converts it into a ES2015-compatible ForOfStatement.
         *
         * @param node A ForOfStatement.
         */
        function visitForOfStatement(node, outermostLabeledStatement) {
            var ancestorFacts = enterSubtree(0 /* HierarchyFacts.IterationStatementExcludes */, 2 /* HierarchyFacts.IterationStatementIncludes */);
            if (node.initializer.transformFlags & 32768 /* TransformFlags.ContainsObjectRestOrSpread */) {
                node = transformForOfStatementWithObjectRest(node);
            }
            var result = node.awaitModifier ?
                transformForAwaitOfStatement(node, outermostLabeledStatement, ancestorFacts) :
                factory.restoreEnclosingLabel(ts.visitEachChild(node, visitor, context), outermostLabeledStatement);
            exitSubtree(ancestorFacts);
            return result;
        }
        function transformForOfStatementWithObjectRest(node) {
            var initializerWithoutParens = ts.skipParentheses(node.initializer);
            if (ts.isVariableDeclarationList(initializerWithoutParens) || ts.isAssignmentPattern(initializerWithoutParens)) {
                var bodyLocation = void 0;
                var statementsLocation = void 0;
                var temp = factory.createTempVariable(/*recordTempVariable*/ undefined);
                var statements = [ts.createForOfBindingStatement(factory, initializerWithoutParens, temp)];
                if (ts.isBlock(node.statement)) {
                    ts.addRange(statements, node.statement.statements);
                    bodyLocation = node.statement;
                    statementsLocation = node.statement.statements;
                }
                else if (node.statement) {
                    ts.append(statements, node.statement);
                    bodyLocation = node.statement;
                    statementsLocation = node.statement;
                }
                return factory.updateForOfStatement(node, node.awaitModifier, ts.setTextRange(factory.createVariableDeclarationList([
                    ts.setTextRange(factory.createVariableDeclaration(temp), node.initializer)
                ], 1 /* NodeFlags.Let */), node.initializer), node.expression, ts.setTextRange(factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), statementsLocation), 
                /*multiLine*/ true), bodyLocation));
            }
            return node;
        }
        function convertForOfStatementHead(node, boundValue) {
            var binding = ts.createForOfBindingStatement(factory, node.initializer, boundValue);
            var bodyLocation;
            var statementsLocation;
            var statements = [ts.visitNode(binding, visitor, ts.isStatement)];
            var statement = ts.visitIterationBody(node.statement, visitor, context);
            if (ts.isBlock(statement)) {
                ts.addRange(statements, statement.statements);
                bodyLocation = statement;
                statementsLocation = statement.statements;
            }
            else {
                statements.push(statement);
            }
            return ts.setEmitFlags(ts.setTextRange(factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), statementsLocation), 
            /*multiLine*/ true), bodyLocation), 48 /* EmitFlags.NoSourceMap */ | 384 /* EmitFlags.NoTokenSourceMaps */);
        }
        function createDownlevelAwait(expression) {
            return enclosingFunctionFlags & 1 /* FunctionFlags.Generator */
                ? factory.createYieldExpression(/*asteriskToken*/ undefined, emitHelpers().createAwaitHelper(expression))
                : factory.createAwaitExpression(expression);
        }
        function transformForAwaitOfStatement(node, outermostLabeledStatement, ancestorFacts) {
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            var iterator = ts.isIdentifier(expression) ? factory.getGeneratedNameForNode(expression) : factory.createTempVariable(/*recordTempVariable*/ undefined);
            var result = ts.isIdentifier(expression) ? factory.getGeneratedNameForNode(iterator) : factory.createTempVariable(/*recordTempVariable*/ undefined);
            var errorRecord = factory.createUniqueName("e");
            var catchVariable = factory.getGeneratedNameForNode(errorRecord);
            var returnMethod = factory.createTempVariable(/*recordTempVariable*/ undefined);
            var callValues = ts.setTextRange(emitHelpers().createAsyncValuesHelper(expression), node.expression);
            var callNext = factory.createCallExpression(factory.createPropertyAccessExpression(iterator, "next"), /*typeArguments*/ undefined, []);
            var getDone = factory.createPropertyAccessExpression(result, "done");
            var getValue = factory.createPropertyAccessExpression(result, "value");
            var callReturn = factory.createFunctionCallCall(returnMethod, iterator, []);
            hoistVariableDeclaration(errorRecord);
            hoistVariableDeclaration(returnMethod);
            // if we are enclosed in an outer loop ensure we reset 'errorRecord' per each iteration
            var initializer = ancestorFacts & 2 /* HierarchyFacts.IterationContainer */ ?
                factory.inlineExpressions([factory.createAssignment(errorRecord, factory.createVoidZero()), callValues]) :
                callValues;
            var forStatement = ts.setEmitFlags(ts.setTextRange(factory.createForStatement(
            /*initializer*/ ts.setEmitFlags(ts.setTextRange(factory.createVariableDeclarationList([
                ts.setTextRange(factory.createVariableDeclaration(iterator, /*exclamationToken*/ undefined, /*type*/ undefined, initializer), node.expression),
                factory.createVariableDeclaration(result)
            ]), node.expression), 2097152 /* EmitFlags.NoHoisting */), 
            /*condition*/ factory.createComma(factory.createAssignment(result, createDownlevelAwait(callNext)), factory.createLogicalNot(getDone)), 
            /*incrementor*/ undefined, 
            /*statement*/ convertForOfStatementHead(node, getValue)), 
            /*location*/ node), 256 /* EmitFlags.NoTokenTrailingSourceMaps */);
            ts.setOriginalNode(forStatement, node);
            return factory.createTryStatement(factory.createBlock([
                factory.restoreEnclosingLabel(forStatement, outermostLabeledStatement)
            ]), factory.createCatchClause(factory.createVariableDeclaration(catchVariable), ts.setEmitFlags(factory.createBlock([
                factory.createExpressionStatement(factory.createAssignment(errorRecord, factory.createObjectLiteralExpression([
                    factory.createPropertyAssignment("error", catchVariable)
                ])))
            ]), 1 /* EmitFlags.SingleLine */)), factory.createBlock([
                factory.createTryStatement(
                /*tryBlock*/ factory.createBlock([
                    ts.setEmitFlags(factory.createIfStatement(factory.createLogicalAnd(factory.createLogicalAnd(result, factory.createLogicalNot(getDone)), factory.createAssignment(returnMethod, factory.createPropertyAccessExpression(iterator, "return"))), factory.createExpressionStatement(createDownlevelAwait(callReturn))), 1 /* EmitFlags.SingleLine */)
                ]), 
                /*catchClause*/ undefined, 
                /*finallyBlock*/ ts.setEmitFlags(factory.createBlock([
                    ts.setEmitFlags(factory.createIfStatement(errorRecord, factory.createThrowStatement(factory.createPropertyAccessExpression(errorRecord, "error"))), 1 /* EmitFlags.SingleLine */)
                ]), 1 /* EmitFlags.SingleLine */))
            ]));
        }
        function parameterVisitor(node) {
            ts.Debug.assertNode(node, ts.isParameter);
            return visitParameter(node);
        }
        function visitParameter(node) {
            if (parametersWithPrecedingObjectRestOrSpread === null || parametersWithPrecedingObjectRestOrSpread === void 0 ? void 0 : parametersWithPrecedingObjectRestOrSpread.has(node)) {
                return factory.updateParameterDeclaration(node, 
                /*decorators*/ undefined, 
                /*modifiers*/ undefined, node.dotDotDotToken, ts.isBindingPattern(node.name) ? factory.getGeneratedNameForNode(node) : node.name, 
                /*questionToken*/ undefined, 
                /*type*/ undefined, 
                /*initializer*/ undefined);
            }
            if (node.transformFlags & 32768 /* TransformFlags.ContainsObjectRestOrSpread */) {
                // Binding patterns are converted into a generated name and are
                // evaluated inside the function body.
                return factory.updateParameterDeclaration(node, 
                /*decorators*/ undefined, 
                /*modifiers*/ undefined, node.dotDotDotToken, factory.getGeneratedNameForNode(node), 
                /*questionToken*/ undefined, 
                /*type*/ undefined, ts.visitNode(node.initializer, visitor, ts.isExpression));
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function collectParametersWithPrecedingObjectRestOrSpread(node) {
            var parameters;
            for (var _i = 0, _a = node.parameters; _i < _a.length; _i++) {
                var parameter = _a[_i];
                if (parameters) {
                    parameters.add(parameter);
                }
                else if (parameter.transformFlags & 32768 /* TransformFlags.ContainsObjectRestOrSpread */) {
                    parameters = new ts.Set();
                }
            }
            return parameters;
        }
        function visitConstructorDeclaration(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            var savedParametersWithPrecedingObjectRestOrSpread = parametersWithPrecedingObjectRestOrSpread;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            parametersWithPrecedingObjectRestOrSpread = collectParametersWithPrecedingObjectRestOrSpread(node);
            var updated = factory.updateConstructorDeclaration(node, 
            /*decorators*/ undefined, node.modifiers, ts.visitParameterList(node.parameters, parameterVisitor, context), transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            parametersWithPrecedingObjectRestOrSpread = savedParametersWithPrecedingObjectRestOrSpread;
            return updated;
        }
        function visitGetAccessorDeclaration(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            var savedParametersWithPrecedingObjectRestOrSpread = parametersWithPrecedingObjectRestOrSpread;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            parametersWithPrecedingObjectRestOrSpread = collectParametersWithPrecedingObjectRestOrSpread(node);
            var updated = factory.updateGetAccessorDeclaration(node, 
            /*decorators*/ undefined, node.modifiers, ts.visitNode(node.name, visitor, ts.isPropertyName), ts.visitParameterList(node.parameters, parameterVisitor, context), 
            /*type*/ undefined, transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            parametersWithPrecedingObjectRestOrSpread = savedParametersWithPrecedingObjectRestOrSpread;
            return updated;
        }
        function visitSetAccessorDeclaration(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            var savedParametersWithPrecedingObjectRestOrSpread = parametersWithPrecedingObjectRestOrSpread;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            parametersWithPrecedingObjectRestOrSpread = collectParametersWithPrecedingObjectRestOrSpread(node);
            var updated = factory.updateSetAccessorDeclaration(node, 
            /*decorators*/ undefined, node.modifiers, ts.visitNode(node.name, visitor, ts.isPropertyName), ts.visitParameterList(node.parameters, parameterVisitor, context), transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            parametersWithPrecedingObjectRestOrSpread = savedParametersWithPrecedingObjectRestOrSpread;
            return updated;
        }
        function visitMethodDeclaration(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            var savedParametersWithPrecedingObjectRestOrSpread = parametersWithPrecedingObjectRestOrSpread;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            parametersWithPrecedingObjectRestOrSpread = collectParametersWithPrecedingObjectRestOrSpread(node);
            var updated = factory.updateMethodDeclaration(node, 
            /*decorators*/ undefined, enclosingFunctionFlags & 1 /* FunctionFlags.Generator */
                ? ts.visitNodes(node.modifiers, visitorNoAsyncModifier, ts.isModifier)
                : node.modifiers, enclosingFunctionFlags & 2 /* FunctionFlags.Async */
                ? undefined
                : node.asteriskToken, ts.visitNode(node.name, visitor, ts.isPropertyName), ts.visitNode(/*questionToken*/ undefined, visitor, ts.isToken), 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, parameterVisitor, context), 
            /*type*/ undefined, enclosingFunctionFlags & 2 /* FunctionFlags.Async */ && enclosingFunctionFlags & 1 /* FunctionFlags.Generator */
                ? transformAsyncGeneratorFunctionBody(node)
                : transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            parametersWithPrecedingObjectRestOrSpread = savedParametersWithPrecedingObjectRestOrSpread;
            return updated;
        }
        function visitFunctionDeclaration(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            var savedParametersWithPrecedingObjectRestOrSpread = parametersWithPrecedingObjectRestOrSpread;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            parametersWithPrecedingObjectRestOrSpread = collectParametersWithPrecedingObjectRestOrSpread(node);
            var updated = factory.updateFunctionDeclaration(node, 
            /*decorators*/ undefined, enclosingFunctionFlags & 1 /* FunctionFlags.Generator */
                ? ts.visitNodes(node.modifiers, visitorNoAsyncModifier, ts.isModifier)
                : node.modifiers, enclosingFunctionFlags & 2 /* FunctionFlags.Async */
                ? undefined
                : node.asteriskToken, node.name, 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, parameterVisitor, context), 
            /*type*/ undefined, enclosingFunctionFlags & 2 /* FunctionFlags.Async */ && enclosingFunctionFlags & 1 /* FunctionFlags.Generator */
                ? transformAsyncGeneratorFunctionBody(node)
                : transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            parametersWithPrecedingObjectRestOrSpread = savedParametersWithPrecedingObjectRestOrSpread;
            return updated;
        }
        function visitArrowFunction(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            var savedParametersWithPrecedingObjectRestOrSpread = parametersWithPrecedingObjectRestOrSpread;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            parametersWithPrecedingObjectRestOrSpread = collectParametersWithPrecedingObjectRestOrSpread(node);
            var updated = factory.updateArrowFunction(node, node.modifiers, 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, parameterVisitor, context), 
            /*type*/ undefined, node.equalsGreaterThanToken, transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            parametersWithPrecedingObjectRestOrSpread = savedParametersWithPrecedingObjectRestOrSpread;
            return updated;
        }
        function visitFunctionExpression(node) {
            var savedEnclosingFunctionFlags = enclosingFunctionFlags;
            var savedParametersWithPrecedingObjectRestOrSpread = parametersWithPrecedingObjectRestOrSpread;
            enclosingFunctionFlags = ts.getFunctionFlags(node);
            parametersWithPrecedingObjectRestOrSpread = collectParametersWithPrecedingObjectRestOrSpread(node);
            var updated = factory.updateFunctionExpression(node, enclosingFunctionFlags & 1 /* FunctionFlags.Generator */
                ? ts.visitNodes(node.modifiers, visitorNoAsyncModifier, ts.isModifier)
                : node.modifiers, enclosingFunctionFlags & 2 /* FunctionFlags.Async */
                ? undefined
                : node.asteriskToken, node.name, 
            /*typeParameters*/ undefined, ts.visitParameterList(node.parameters, parameterVisitor, context), 
            /*type*/ undefined, enclosingFunctionFlags & 2 /* FunctionFlags.Async */ && enclosingFunctionFlags & 1 /* FunctionFlags.Generator */
                ? transformAsyncGeneratorFunctionBody(node)
                : transformFunctionBody(node));
            enclosingFunctionFlags = savedEnclosingFunctionFlags;
            parametersWithPrecedingObjectRestOrSpread = savedParametersWithPrecedingObjectRestOrSpread;
            return updated;
        }
        function transformAsyncGeneratorFunctionBody(node) {
            resumeLexicalEnvironment();
            var statements = [];
            var statementOffset = factory.copyPrologue(node.body.statements, statements, /*ensureUseStrict*/ false, visitor);
            appendObjectRestAssignmentsIfNeeded(statements, node);
            var savedCapturedSuperProperties = capturedSuperProperties;
            var savedHasSuperElementAccess = hasSuperElementAccess;
            capturedSuperProperties = new ts.Set();
            hasSuperElementAccess = false;
            var returnStatement = factory.createReturnStatement(emitHelpers().createAsyncGeneratorHelper(factory.createFunctionExpression(
            /*modifiers*/ undefined, factory.createToken(41 /* SyntaxKind.AsteriskToken */), node.name && factory.getGeneratedNameForNode(node.name), 
            /*typeParameters*/ undefined, 
            /*parameters*/ [], 
            /*type*/ undefined, factory.updateBlock(node.body, ts.visitLexicalEnvironment(node.body.statements, visitor, context, statementOffset))), !!(hierarchyFacts & 1 /* HierarchyFacts.HasLexicalThis */)));
            // Minor optimization, emit `_super` helper to capture `super` access in an arrow.
            // This step isn't needed if we eventually transform this to ES5.
            var emitSuperHelpers = languageVersion >= 2 /* ScriptTarget.ES2015 */ && resolver.getNodeCheckFlags(node) & (4096 /* NodeCheckFlags.AsyncMethodWithSuperBinding */ | 2048 /* NodeCheckFlags.AsyncMethodWithSuper */);
            if (emitSuperHelpers) {
                enableSubstitutionForAsyncMethodsWithSuper();
                var variableStatement = ts.createSuperAccessVariableStatement(factory, resolver, node, capturedSuperProperties);
                substitutedSuperAccessors[ts.getNodeId(variableStatement)] = true;
                ts.insertStatementsAfterStandardPrologue(statements, [variableStatement]);
            }
            statements.push(returnStatement);
            ts.insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());
            var block = factory.updateBlock(node.body, statements);
            if (emitSuperHelpers && hasSuperElementAccess) {
                if (resolver.getNodeCheckFlags(node) & 4096 /* NodeCheckFlags.AsyncMethodWithSuperBinding */) {
                    ts.addEmitHelper(block, ts.advancedAsyncSuperHelper);
                }
                else if (resolver.getNodeCheckFlags(node) & 2048 /* NodeCheckFlags.AsyncMethodWithSuper */) {
                    ts.addEmitHelper(block, ts.asyncSuperHelper);
                }
            }
            capturedSuperProperties = savedCapturedSuperProperties;
            hasSuperElementAccess = savedHasSuperElementAccess;
            return block;
        }
        function transformFunctionBody(node) {
            var _a;
            resumeLexicalEnvironment();
            var statementOffset = 0;
            var statements = [];
            var body = (_a = ts.visitNode(node.body, visitor, ts.isConciseBody)) !== null && _a !== void 0 ? _a : factory.createBlock([]);
            if (ts.isBlock(body)) {
                statementOffset = factory.copyPrologue(body.statements, statements, /*ensureUseStrict*/ false, visitor);
            }
            ts.addRange(statements, appendObjectRestAssignmentsIfNeeded(/*statements*/ undefined, node));
            var leadingStatements = endLexicalEnvironment();
            if (statementOffset > 0 || ts.some(statements) || ts.some(leadingStatements)) {
                var block = factory.converters.convertToFunctionBlock(body, /*multiLine*/ true);
                ts.insertStatementsAfterStandardPrologue(statements, leadingStatements);
                ts.addRange(statements, block.statements.slice(statementOffset));
                return factory.updateBlock(block, ts.setTextRange(factory.createNodeArray(statements), block.statements));
            }
            return body;
        }
        function appendObjectRestAssignmentsIfNeeded(statements, node) {
            var containsPrecedingObjectRestOrSpread = false;
            for (var _i = 0, _a = node.parameters; _i < _a.length; _i++) {
                var parameter = _a[_i];
                if (containsPrecedingObjectRestOrSpread) {
                    if (ts.isBindingPattern(parameter.name)) {
                        // In cases where a binding pattern is simply '[]' or '{}',
                        // we usually don't want to emit a var declaration; however, in the presence
                        // of an initializer, we must emit that expression to preserve side effects.
                        //
                        // NOTE: see `insertDefaultValueAssignmentForBindingPattern` in es2015.ts
                        if (parameter.name.elements.length > 0) {
                            var declarations = ts.flattenDestructuringBinding(parameter, visitor, context, 0 /* FlattenLevel.All */, factory.getGeneratedNameForNode(parameter));
                            if (ts.some(declarations)) {
                                var declarationList = factory.createVariableDeclarationList(declarations);
                                var statement = factory.createVariableStatement(/*modifiers*/ undefined, declarationList);
                                ts.setEmitFlags(statement, 1048576 /* EmitFlags.CustomPrologue */);
                                statements = ts.append(statements, statement);
                            }
                        }
                        else if (parameter.initializer) {
                            var name = factory.getGeneratedNameForNode(parameter);
                            var initializer = ts.visitNode(parameter.initializer, visitor, ts.isExpression);
                            var assignment = factory.createAssignment(name, initializer);
                            var statement = factory.createExpressionStatement(assignment);
                            ts.setEmitFlags(statement, 1048576 /* EmitFlags.CustomPrologue */);
                            statements = ts.append(statements, statement);
                        }
                    }
                    else if (parameter.initializer) {
                        // Converts a parameter initializer into a function body statement, i.e.:
                        //
                        //  function f(x = 1) { }
                        //
                        // becomes
                        //
                        //  function f(x) {
                        //    if (typeof x === "undefined") { x = 1; }
                        //  }
                        var name = factory.cloneNode(parameter.name);
                        ts.setTextRange(name, parameter.name);
                        ts.setEmitFlags(name, 48 /* EmitFlags.NoSourceMap */);
                        var initializer = ts.visitNode(parameter.initializer, visitor, ts.isExpression);
                        ts.addEmitFlags(initializer, 48 /* EmitFlags.NoSourceMap */ | 1536 /* EmitFlags.NoComments */);
                        var assignment = factory.createAssignment(name, initializer);
                        ts.setTextRange(assignment, parameter);
                        ts.setEmitFlags(assignment, 1536 /* EmitFlags.NoComments */);
                        var block = factory.createBlock([factory.createExpressionStatement(assignment)]);
                        ts.setTextRange(block, parameter);
                        ts.setEmitFlags(block, 1 /* EmitFlags.SingleLine */ | 32 /* EmitFlags.NoTrailingSourceMap */ | 384 /* EmitFlags.NoTokenSourceMaps */ | 1536 /* EmitFlags.NoComments */);
                        var typeCheck = factory.createTypeCheck(factory.cloneNode(parameter.name), "undefined");
                        var statement = factory.createIfStatement(typeCheck, block);
                        ts.startOnNewLine(statement);
                        ts.setTextRange(statement, parameter);
                        ts.setEmitFlags(statement, 384 /* EmitFlags.NoTokenSourceMaps */ | 32 /* EmitFlags.NoTrailingSourceMap */ | 1048576 /* EmitFlags.CustomPrologue */ | 1536 /* EmitFlags.NoComments */);
                        statements = ts.append(statements, statement);
                    }
                }
                else if (parameter.transformFlags & 32768 /* TransformFlags.ContainsObjectRestOrSpread */) {
                    containsPrecedingObjectRestOrSpread = true;
                    var declarations = ts.flattenDestructuringBinding(parameter, visitor, context, 1 /* FlattenLevel.ObjectRest */, factory.getGeneratedNameForNode(parameter), 
                    /*doNotRecordTempVariablesInLine*/ false, 
                    /*skipInitializer*/ true);
                    if (ts.some(declarations)) {
                        var declarationList = factory.createVariableDeclarationList(declarations);
                        var statement = factory.createVariableStatement(/*modifiers*/ undefined, declarationList);
                        ts.setEmitFlags(statement, 1048576 /* EmitFlags.CustomPrologue */);
                        statements = ts.append(statements, statement);
                    }
                }
            }
            return statements;
        }
        function enableSubstitutionForAsyncMethodsWithSuper() {
            if ((enabledSubstitutions & 1 /* ESNextSubstitutionFlags.AsyncMethodsWithSuper */) === 0) {
                enabledSubstitutions |= 1 /* ESNextSubstitutionFlags.AsyncMethodsWithSuper */;
                // We need to enable substitutions for call, property access, and element access
                // if we need to rewrite super calls.
                context.enableSubstitution(208 /* SyntaxKind.CallExpression */);
                context.enableSubstitution(206 /* SyntaxKind.PropertyAccessExpression */);
                context.enableSubstitution(207 /* SyntaxKind.ElementAccessExpression */);
                // We need to be notified when entering and exiting declarations that bind super.
                context.enableEmitNotification(257 /* SyntaxKind.ClassDeclaration */);
                context.enableEmitNotification(169 /* SyntaxKind.MethodDeclaration */);
                context.enableEmitNotification(172 /* SyntaxKind.GetAccessor */);
                context.enableEmitNotification(173 /* SyntaxKind.SetAccessor */);
                context.enableEmitNotification(171 /* SyntaxKind.Constructor */);
                // We need to be notified when entering the generated accessor arrow functions.
                context.enableEmitNotification(237 /* SyntaxKind.VariableStatement */);
            }
        }
        /**
         * Called by the printer just before a node is printed.
         *
         * @param hint A hint as to the intended usage of the node.
         * @param node The node to be printed.
         * @param emitCallback The callback used to emit the node.
         */
        function onEmitNode(hint, node, emitCallback) {
            // If we need to support substitutions for `super` in an async method,
            // we should track it here.
            if (enabledSubstitutions & 1 /* ESNextSubstitutionFlags.AsyncMethodsWithSuper */ && isSuperContainer(node)) {
                var superContainerFlags = resolver.getNodeCheckFlags(node) & (2048 /* NodeCheckFlags.AsyncMethodWithSuper */ | 4096 /* NodeCheckFlags.AsyncMethodWithSuperBinding */);
                if (superContainerFlags !== enclosingSuperContainerFlags) {
                    var savedEnclosingSuperContainerFlags = enclosingSuperContainerFlags;
                    enclosingSuperContainerFlags = superContainerFlags;
                    previousOnEmitNode(hint, node, emitCallback);
                    enclosingSuperContainerFlags = savedEnclosingSuperContainerFlags;
                    return;
                }
            }
            // Disable substitution in the generated super accessor itself.
            else if (enabledSubstitutions && substitutedSuperAccessors[ts.getNodeId(node)]) {
                var savedEnclosingSuperContainerFlags = enclosingSuperContainerFlags;
                enclosingSuperContainerFlags = 0;
                previousOnEmitNode(hint, node, emitCallback);
                enclosingSuperContainerFlags = savedEnclosingSuperContainerFlags;
                return;
            }
            previousOnEmitNode(hint, node, emitCallback);
        }
        /**
         * Hooks node substitutions.
         *
         * @param hint The context for the emitter.
         * @param node The node to substitute.
         */
        function onSubstituteNode(hint, node) {
            node = previousOnSubstituteNode(hint, node);
            if (hint === 1 /* EmitHint.Expression */ && enclosingSuperContainerFlags) {
                return substituteExpression(node);
            }
            return node;
        }
        function substituteExpression(node) {
            switch (node.kind) {
                case 206 /* SyntaxKind.PropertyAccessExpression */:
                    return substitutePropertyAccessExpression(node);
                case 207 /* SyntaxKind.ElementAccessExpression */:
                    return substituteElementAccessExpression(node);
                case 208 /* SyntaxKind.CallExpression */:
                    return substituteCallExpression(node);
            }
            return node;
        }
        function substitutePropertyAccessExpression(node) {
            if (node.expression.kind === 106 /* SyntaxKind.SuperKeyword */) {
                return ts.setTextRange(factory.createPropertyAccessExpression(factory.createUniqueName("_super", 16 /* GeneratedIdentifierFlags.Optimistic */ | 32 /* GeneratedIdentifierFlags.FileLevel */), node.name), node);
            }
            return node;
        }
        function substituteElementAccessExpression(node) {
            if (node.expression.kind === 106 /* SyntaxKind.SuperKeyword */) {
                return createSuperElementAccessInAsyncMethod(node.argumentExpression, node);
            }
            return node;
        }
        function substituteCallExpression(node) {
            var expression = node.expression;
            if (ts.isSuperProperty(expression)) {
                var argumentExpression = ts.isPropertyAccessExpression(expression)
                    ? substitutePropertyAccessExpression(expression)
                    : substituteElementAccessExpression(expression);
                return factory.createCallExpression(factory.createPropertyAccessExpression(argumentExpression, "call"), 
                /*typeArguments*/ undefined, __spreadArray([
                    factory.createThis()
                ], node.arguments, true));
            }
            return node;
        }
        function isSuperContainer(node) {
            var kind = node.kind;
            return kind === 257 /* SyntaxKind.ClassDeclaration */
                || kind === 171 /* SyntaxKind.Constructor */
                || kind === 169 /* SyntaxKind.MethodDeclaration */
                || kind === 172 /* SyntaxKind.GetAccessor */
                || kind === 173 /* SyntaxKind.SetAccessor */;
        }
        function createSuperElementAccessInAsyncMethod(argumentExpression, location) {
            if (enclosingSuperContainerFlags & 4096 /* NodeCheckFlags.AsyncMethodWithSuperBinding */) {
                return ts.setTextRange(factory.createPropertyAccessExpression(factory.createCallExpression(factory.createIdentifier("_superIndex"), 
                /*typeArguments*/ undefined, [argumentExpression]), "value"), location);
            }
            else {
                return ts.setTextRange(factory.createCallExpression(factory.createIdentifier("_superIndex"), 
                /*typeArguments*/ undefined, [argumentExpression]), location);
            }
        }
    }
    ts.transformES2018 = transformES2018;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    function transformES2019(context) {
        var factory = context.factory;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            if ((node.transformFlags & 64 /* TransformFlags.ContainsES2019 */) === 0) {
                return node;
            }
            switch (node.kind) {
                case 292 /* SyntaxKind.CatchClause */:
                    return visitCatchClause(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitCatchClause(node) {
            if (!node.variableDeclaration) {
                return factory.updateCatchClause(node, factory.createVariableDeclaration(factory.createTempVariable(/*recordTempVariable*/ undefined)), ts.visitNode(node.block, visitor, ts.isBlock));
            }
            return ts.visitEachChild(node, visitor, context);
        }
    }
    ts.transformES2019 = transformES2019;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    function transformES2020(context) {
        var factory = context.factory, hoistVariableDeclaration = context.hoistVariableDeclaration;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            if ((node.transformFlags & 32 /* TransformFlags.ContainsES2020 */) === 0) {
                return node;
            }
            switch (node.kind) {
                case 208 /* SyntaxKind.CallExpression */: {
                    var updated = visitNonOptionalCallExpression(node, /*captureThisArg*/ false);
                    ts.Debug.assertNotNode(updated, ts.isSyntheticReference);
                    return updated;
                }
                case 206 /* SyntaxKind.PropertyAccessExpression */:
                case 207 /* SyntaxKind.ElementAccessExpression */:
                    if (ts.isOptionalChain(node)) {
                        var updated = visitOptionalExpression(node, /*captureThisArg*/ false, /*isDelete*/ false);
                        ts.Debug.assertNotNode(updated, ts.isSyntheticReference);
                        return updated;
                    }
                    return ts.visitEachChild(node, visitor, context);
                case 221 /* SyntaxKind.BinaryExpression */:
                    if (node.operatorToken.kind === 60 /* SyntaxKind.QuestionQuestionToken */) {
                        return transformNullishCoalescingExpression(node);
                    }
                    return ts.visitEachChild(node, visitor, context);
                case 215 /* SyntaxKind.DeleteExpression */:
                    return visitDeleteExpression(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function flattenChain(chain) {
            ts.Debug.assertNotNode(chain, ts.isNonNullChain);
            var links = [chain];
            while (!chain.questionDotToken && !ts.isTaggedTemplateExpression(chain)) {
                chain = ts.cast(ts.skipPartiallyEmittedExpressions(chain.expression), ts.isOptionalChain);
                ts.Debug.assertNotNode(chain, ts.isNonNullChain);
                links.unshift(chain);
            }
            return { expression: chain.expression, chain: links };
        }
        function visitNonOptionalParenthesizedExpression(node, captureThisArg, isDelete) {
            var expression = visitNonOptionalExpression(node.expression, captureThisArg, isDelete);
            if (ts.isSyntheticReference(expression)) {
                // `(a.b)` -> { expression `((_a = a).b)`, thisArg: `_a` }
                // `(a[b])` -> { expression `((_a = a)[b])`, thisArg: `_a` }
                return factory.createSyntheticReferenceExpression(factory.updateParenthesizedExpression(node, expression.expression), expression.thisArg);
            }
            return factory.updateParenthesizedExpression(node, expression);
        }
        function visitNonOptionalPropertyOrElementAccessExpression(node, captureThisArg, isDelete) {
            if (ts.isOptionalChain(node)) {
                // If `node` is an optional chain, then it is the outermost chain of an optional expression.
                return visitOptionalExpression(node, captureThisArg, isDelete);
            }
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            ts.Debug.assertNotNode(expression, ts.isSyntheticReference);
            var thisArg;
            if (captureThisArg) {
                if (!ts.isSimpleCopiableExpression(expression)) {
                    thisArg = factory.createTempVariable(hoistVariableDeclaration);
                    expression = factory.createAssignment(thisArg, expression);
                }
                else {
                    thisArg = expression;
                }
            }
            expression = node.kind === 206 /* SyntaxKind.PropertyAccessExpression */
                ? factory.updatePropertyAccessExpression(node, expression, ts.visitNode(node.name, visitor, ts.isIdentifier))
                : factory.updateElementAccessExpression(node, expression, ts.visitNode(node.argumentExpression, visitor, ts.isExpression));
            return thisArg ? factory.createSyntheticReferenceExpression(expression, thisArg) : expression;
        }
        function visitNonOptionalCallExpression(node, captureThisArg) {
            if (ts.isOptionalChain(node)) {
                // If `node` is an optional chain, then it is the outermost chain of an optional expression.
                return visitOptionalExpression(node, captureThisArg, /*isDelete*/ false);
            }
            if (ts.isParenthesizedExpression(node.expression) && ts.isOptionalChain(ts.skipParentheses(node.expression))) {
                // capture thisArg for calls of parenthesized optional chains like `(foo?.bar)()`
                var expression = visitNonOptionalParenthesizedExpression(node.expression, /*captureThisArg*/ true, /*isDelete*/ false);
                var args = ts.visitNodes(node.arguments, visitor, ts.isExpression);
                if (ts.isSyntheticReference(expression)) {
                    return ts.setTextRange(factory.createFunctionCallCall(expression.expression, expression.thisArg, args), node);
                }
                return factory.updateCallExpression(node, expression, /*typeArguments*/ undefined, args);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitNonOptionalExpression(node, captureThisArg, isDelete) {
            switch (node.kind) {
                case 212 /* SyntaxKind.ParenthesizedExpression */: return visitNonOptionalParenthesizedExpression(node, captureThisArg, isDelete);
                case 206 /* SyntaxKind.PropertyAccessExpression */:
                case 207 /* SyntaxKind.ElementAccessExpression */: return visitNonOptionalPropertyOrElementAccessExpression(node, captureThisArg, isDelete);
                case 208 /* SyntaxKind.CallExpression */: return visitNonOptionalCallExpression(node, captureThisArg);
                default: return ts.visitNode(node, visitor, ts.isExpression);
            }
        }
        function visitOptionalExpression(node, captureThisArg, isDelete) {
            var _a = flattenChain(node), expression = _a.expression, chain = _a.chain;
            var left = visitNonOptionalExpression(ts.skipPartiallyEmittedExpressions(expression), ts.isCallChain(chain[0]), /*isDelete*/ false);
            var leftThisArg = ts.isSyntheticReference(left) ? left.thisArg : undefined;
            var capturedLeft = ts.isSyntheticReference(left) ? left.expression : left;
            var leftExpression = factory.restoreOuterExpressions(expression, capturedLeft, 8 /* OuterExpressionKinds.PartiallyEmittedExpressions */);
            if (!ts.isSimpleCopiableExpression(capturedLeft)) {
                capturedLeft = factory.createTempVariable(hoistVariableDeclaration);
                leftExpression = factory.createAssignment(capturedLeft, leftExpression);
            }
            var rightExpression = capturedLeft;
            var thisArg;
            for (var i = 0; i < chain.length; i++) {
                var segment = chain[i];
                switch (segment.kind) {
                    case 206 /* SyntaxKind.PropertyAccessExpression */:
                    case 207 /* SyntaxKind.ElementAccessExpression */:
                        if (i === chain.length - 1 && captureThisArg) {
                            if (!ts.isSimpleCopiableExpression(rightExpression)) {
                                thisArg = factory.createTempVariable(hoistVariableDeclaration);
                                rightExpression = factory.createAssignment(thisArg, rightExpression);
                            }
                            else {
                                thisArg = rightExpression;
                            }
                        }
                        rightExpression = segment.kind === 206 /* SyntaxKind.PropertyAccessExpression */
                            ? factory.createPropertyAccessExpression(rightExpression, ts.visitNode(segment.name, visitor, ts.isIdentifier))
                            : factory.createElementAccessExpression(rightExpression, ts.visitNode(segment.argumentExpression, visitor, ts.isExpression));
                        break;
                    case 208 /* SyntaxKind.CallExpression */:
                        if (i === 0 && leftThisArg) {
                            if (!ts.isGeneratedIdentifier(leftThisArg)) {
                                leftThisArg = factory.cloneNode(leftThisArg);
                                ts.addEmitFlags(leftThisArg, 1536 /* EmitFlags.NoComments */);
                            }
                            rightExpression = factory.createFunctionCallCall(rightExpression, leftThisArg.kind === 106 /* SyntaxKind.SuperKeyword */ ? factory.createThis() : leftThisArg, ts.visitNodes(segment.arguments, visitor, ts.isExpression));
                        }
                        else {
                            rightExpression = factory.createCallExpression(rightExpression, 
                            /*typeArguments*/ undefined, ts.visitNodes(segment.arguments, visitor, ts.isExpression));
                        }
                        break;
                }
                ts.setOriginalNode(rightExpression, segment);
            }
            var target = isDelete
                ? factory.createConditionalExpression(createNotNullCondition(leftExpression, capturedLeft, /*invert*/ true), /*questionToken*/ undefined, factory.createTrue(), /*colonToken*/ undefined, factory.createDeleteExpression(rightExpression))
                : factory.createConditionalExpression(createNotNullCondition(leftExpression, capturedLeft, /*invert*/ true), /*questionToken*/ undefined, factory.createVoidZero(), /*colonToken*/ undefined, rightExpression);
            ts.setTextRange(target, node);
            return thisArg ? factory.createSyntheticReferenceExpression(target, thisArg) : target;
        }
        function createNotNullCondition(left, right, invert) {
            return factory.createBinaryExpression(factory.createBinaryExpression(left, factory.createToken(invert ? 36 /* SyntaxKind.EqualsEqualsEqualsToken */ : 37 /* SyntaxKind.ExclamationEqualsEqualsToken */), factory.createNull()), factory.createToken(invert ? 56 /* SyntaxKind.BarBarToken */ : 55 /* SyntaxKind.AmpersandAmpersandToken */), factory.createBinaryExpression(right, factory.createToken(invert ? 36 /* SyntaxKind.EqualsEqualsEqualsToken */ : 37 /* SyntaxKind.ExclamationEqualsEqualsToken */), factory.createVoidZero()));
        }
        function transformNullishCoalescingExpression(node) {
            var left = ts.visitNode(node.left, visitor, ts.isExpression);
            var right = left;
            if (!ts.isSimpleCopiableExpression(left)) {
                right = factory.createTempVariable(hoistVariableDeclaration);
                left = factory.createAssignment(right, left);
            }
            return ts.setTextRange(factory.createConditionalExpression(createNotNullCondition(left, right), 
            /*questionToken*/ undefined, right, 
            /*colonToken*/ undefined, ts.visitNode(node.right, visitor, ts.isExpression)), node);
        }
        function visitDeleteExpression(node) {
            return ts.isOptionalChain(ts.skipParentheses(node.expression))
                ? ts.setOriginalNode(visitNonOptionalExpression(node.expression, /*captureThisArg*/ false, /*isDelete*/ true), node)
                : factory.updateDeleteExpression(node, ts.visitNode(node.expression, visitor, ts.isExpression));
        }
    }
    ts.transformES2020 = transformES2020;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    function transformES2021(context) {
        var hoistVariableDeclaration = context.hoistVariableDeclaration, factory = context.factory;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            if ((node.transformFlags & 16 /* TransformFlags.ContainsES2021 */) === 0) {
                return node;
            }
            switch (node.kind) {
                case 221 /* SyntaxKind.BinaryExpression */:
                    var binaryExpression = node;
                    if (ts.isLogicalOrCoalescingAssignmentExpression(binaryExpression)) {
                        return transformLogicalAssignment(binaryExpression);
                    }
                // falls through
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function transformLogicalAssignment(binaryExpression) {
            var operator = binaryExpression.operatorToken;
            var nonAssignmentOperator = ts.getNonAssignmentOperatorForCompoundAssignment(operator.kind);
            var left = ts.skipParentheses(ts.visitNode(binaryExpression.left, visitor, ts.isLeftHandSideExpression));
            var assignmentTarget = left;
            var right = ts.skipParentheses(ts.visitNode(binaryExpression.right, visitor, ts.isExpression));
            if (ts.isAccessExpression(left)) {
                var propertyAccessTargetSimpleCopiable = ts.isSimpleCopiableExpression(left.expression);
                var propertyAccessTarget = propertyAccessTargetSimpleCopiable ? left.expression :
                    factory.createTempVariable(hoistVariableDeclaration);
                var propertyAccessTargetAssignment = propertyAccessTargetSimpleCopiable ? left.expression : factory.createAssignment(propertyAccessTarget, left.expression);
                if (ts.isPropertyAccessExpression(left)) {
                    assignmentTarget = factory.createPropertyAccessExpression(propertyAccessTarget, left.name);
                    left = factory.createPropertyAccessExpression(propertyAccessTargetAssignment, left.name);
                }
                else {
                    var elementAccessArgumentSimpleCopiable = ts.isSimpleCopiableExpression(left.argumentExpression);
                    var elementAccessArgument = elementAccessArgumentSimpleCopiable ? left.argumentExpression :
                        factory.createTempVariable(hoistVariableDeclaration);
                    assignmentTarget = factory.createElementAccessExpression(propertyAccessTarget, elementAccessArgument);
                    left = factory.createElementAccessExpression(propertyAccessTargetAssignment, elementAccessArgumentSimpleCopiable ? left.argumentExpression : factory.createAssignment(elementAccessArgument, left.argumentExpression));
                }
            }
            return factory.createBinaryExpression(left, nonAssignmentOperator, factory.createParenthesizedExpression(factory.createAssignment(assignmentTarget, right)));
        }
    }
    ts.transformES2021 = transformES2021;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    function transformESNext(context) {
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            if ((node.transformFlags & 4 /* TransformFlags.ContainsESNext */) === 0) {
                return node;
            }
            switch (node.kind) {
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
    }
    ts.transformESNext = transformESNext;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    function transformJsx(context) {
        var factory = context.factory, emitHelpers = context.getEmitHelperFactory;
        var compilerOptions = context.getCompilerOptions();
        var currentSourceFile;
        var currentFileState;
        return ts.chainBundle(context, transformSourceFile);
        function getCurrentFileNameExpression() {
            if (currentFileState.filenameDeclaration) {
                return currentFileState.filenameDeclaration.name;
            }
            var declaration = factory.createVariableDeclaration(factory.createUniqueName("_jsxFileName", 16 /* GeneratedIdentifierFlags.Optimistic */ | 32 /* GeneratedIdentifierFlags.FileLevel */), /*exclaimationToken*/ undefined, /*type*/ undefined, factory.createStringLiteral(currentSourceFile.fileName));
            currentFileState.filenameDeclaration = declaration;
            return currentFileState.filenameDeclaration.name;
        }
        function getJsxFactoryCalleePrimitive(isStaticChildren) {
            return compilerOptions.jsx === 5 /* JsxEmit.ReactJSXDev */ ? "jsxDEV" : isStaticChildren ? "jsxs" : "jsx";
        }
        function getJsxFactoryCallee(isStaticChildren) {
            var type = getJsxFactoryCalleePrimitive(isStaticChildren);
            return getImplicitImportForName(type);
        }
        function getImplicitJsxFragmentReference() {
            return getImplicitImportForName("Fragment");
        }
        function getImplicitImportForName(name) {
            var _a, _b;
            var importSource = name === "createElement"
                ? currentFileState.importSpecifier
                : ts.getJSXRuntimeImport(currentFileState.importSpecifier, compilerOptions);
            var existing = (_b = (_a = currentFileState.utilizedImplicitRuntimeImports) === null || _a === void 0 ? void 0 : _a.get(importSource)) === null || _b === void 0 ? void 0 : _b.get(name);
            if (existing) {
                return existing.name;
            }
            if (!currentFileState.utilizedImplicitRuntimeImports) {
                currentFileState.utilizedImplicitRuntimeImports = new ts.Map();
            }
            var specifierSourceImports = currentFileState.utilizedImplicitRuntimeImports.get(importSource);
            if (!specifierSourceImports) {
                specifierSourceImports = new ts.Map();
                currentFileState.utilizedImplicitRuntimeImports.set(importSource, specifierSourceImports);
            }
            var generatedName = factory.createUniqueName("_".concat(name), 16 /* GeneratedIdentifierFlags.Optimistic */ | 32 /* GeneratedIdentifierFlags.FileLevel */ | 64 /* GeneratedIdentifierFlags.AllowNameSubstitution */);
            var specifier = factory.createImportSpecifier(/*isTypeOnly*/ false, factory.createIdentifier(name), generatedName);
            generatedName.generatedImportReference = specifier;
            specifierSourceImports.set(name, specifier);
            return generatedName;
        }
        /**
         * Transform JSX-specific syntax in a SourceFile.
         *
         * @param node A SourceFile node.
         */
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            currentSourceFile = node;
            currentFileState = {};
            currentFileState.importSpecifier = ts.getJSXImplicitImportBase(compilerOptions, node);
            var visited = ts.visitEachChild(node, visitor, context);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            var statements = visited.statements;
            if (currentFileState.filenameDeclaration) {
                statements = ts.insertStatementAfterCustomPrologue(statements.slice(), factory.createVariableStatement(/*modifiers*/ undefined, factory.createVariableDeclarationList([currentFileState.filenameDeclaration], 2 /* NodeFlags.Const */)));
            }
            if (currentFileState.utilizedImplicitRuntimeImports) {
                for (var _i = 0, _a = ts.arrayFrom(currentFileState.utilizedImplicitRuntimeImports.entries()); _i < _a.length; _i++) {
                    var _b = _a[_i], importSource = _b[0], importSpecifiersMap = _b[1];
                    if (ts.isExternalModule(node)) {
                        // Add `import` statement
                        var importStatement = factory.createImportDeclaration(/*decorators*/ undefined, /*modifiers*/ undefined, factory.createImportClause(/*typeOnly*/ false, /*name*/ undefined, factory.createNamedImports(ts.arrayFrom(importSpecifiersMap.values()))), factory.createStringLiteral(importSource), /*assertClause*/ undefined);
                        ts.setParentRecursive(importStatement, /*incremental*/ false);
                        statements = ts.insertStatementAfterCustomPrologue(statements.slice(), importStatement);
                    }
                    else if (ts.isExternalOrCommonJsModule(node)) {
                        // Add `require` statement
                        var requireStatement = factory.createVariableStatement(/*modifiers*/ undefined, factory.createVariableDeclarationList([
                            factory.createVariableDeclaration(factory.createObjectBindingPattern(ts.map(ts.arrayFrom(importSpecifiersMap.values()), function (s) { return factory.createBindingElement(/*dotdotdot*/ undefined, s.propertyName, s.name); })), 
                            /*exclaimationToken*/ undefined, 
                            /*type*/ undefined, factory.createCallExpression(factory.createIdentifier("require"), /*typeArguments*/ undefined, [factory.createStringLiteral(importSource)]))
                        ], 2 /* NodeFlags.Const */));
                        ts.setParentRecursive(requireStatement, /*incremental*/ false);
                        statements = ts.insertStatementAfterCustomPrologue(statements.slice(), requireStatement);
                    }
                    else {
                        // Do nothing (script file) - consider an error in the checker?
                    }
                }
            }
            if (statements !== visited.statements) {
                visited = factory.updateSourceFile(visited, statements);
            }
            currentFileState = undefined;
            return visited;
        }
        function visitor(node) {
            if (node.transformFlags & 2 /* TransformFlags.ContainsJsx */) {
                return visitorWorker(node);
            }
            else {
                return node;
            }
        }
        function visitorWorker(node) {
            switch (node.kind) {
                case 278 /* SyntaxKind.JsxElement */:
                    return visitJsxElement(node, /*isChild*/ false);
                case 279 /* SyntaxKind.JsxSelfClosingElement */:
                    return visitJsxSelfClosingElement(node, /*isChild*/ false);
                case 282 /* SyntaxKind.JsxFragment */:
                    return visitJsxFragment(node, /*isChild*/ false);
                case 288 /* SyntaxKind.JsxExpression */:
                    return visitJsxExpression(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function transformJsxChildToExpression(node) {
            switch (node.kind) {
                case 11 /* SyntaxKind.JsxText */:
                    return visitJsxText(node);
                case 288 /* SyntaxKind.JsxExpression */:
                    return visitJsxExpression(node);
                case 278 /* SyntaxKind.JsxElement */:
                    return visitJsxElement(node, /*isChild*/ true);
                case 279 /* SyntaxKind.JsxSelfClosingElement */:
                    return visitJsxSelfClosingElement(node, /*isChild*/ true);
                case 282 /* SyntaxKind.JsxFragment */:
                    return visitJsxFragment(node, /*isChild*/ true);
                default:
                    return ts.Debug.failBadSyntaxKind(node);
            }
        }
        /**
         * The react jsx/jsxs transform falls back to `createElement` when an explicit `key` argument comes after a spread
         */
        function hasKeyAfterPropsSpread(node) {
            var spread = false;
            for (var _i = 0, _a = node.attributes.properties; _i < _a.length; _i++) {
                var elem = _a[_i];
                if (ts.isJsxSpreadAttribute(elem)) {
                    spread = true;
                }
                else if (spread && ts.isJsxAttribute(elem) && elem.name.escapedText === "key") {
                    return true;
                }
            }
            return false;
        }
        function shouldUseCreateElement(node) {
            return currentFileState.importSpecifier === undefined || hasKeyAfterPropsSpread(node);
        }
        function visitJsxElement(node, isChild) {
            var tagTransform = shouldUseCreateElement(node.openingElement) ? visitJsxOpeningLikeElementCreateElement : visitJsxOpeningLikeElementJSX;
            return tagTransform(node.openingElement, node.children, isChild, /*location*/ node);
        }
        function visitJsxSelfClosingElement(node, isChild) {
            var tagTransform = shouldUseCreateElement(node) ? visitJsxOpeningLikeElementCreateElement : visitJsxOpeningLikeElementJSX;
            return tagTransform(node, /*children*/ undefined, isChild, /*location*/ node);
        }
        function visitJsxFragment(node, isChild) {
            var tagTransform = currentFileState.importSpecifier === undefined ? visitJsxOpeningFragmentCreateElement : visitJsxOpeningFragmentJSX;
            return tagTransform(node.openingFragment, node.children, isChild, /*location*/ node);
        }
        function convertJsxChildrenToChildrenPropObject(children) {
            var prop = convertJsxChildrenToChildrenPropAssignment(children);
            return prop && factory.createObjectLiteralExpression([prop]);
        }
        function convertJsxChildrenToChildrenPropAssignment(children) {
            var nonWhitespaceChildren = ts.getSemanticJsxChildren(children);
            if (ts.length(nonWhitespaceChildren) === 1 && !nonWhitespaceChildren[0].dotDotDotToken) {
                var result_13 = transformJsxChildToExpression(nonWhitespaceChildren[0]);
                return result_13 && factory.createPropertyAssignment("children", result_13);
            }
            var result = ts.mapDefined(children, transformJsxChildToExpression);
            return ts.length(result) ? factory.createPropertyAssignment("children", factory.createArrayLiteralExpression(result)) : undefined;
        }
        function visitJsxOpeningLikeElementJSX(node, children, isChild, location) {
            var tagName = getTagName(node);
            var childrenProp = children && children.length ? convertJsxChildrenToChildrenPropAssignment(children) : undefined;
            var keyAttr = ts.find(node.attributes.properties, function (p) { return !!p.name && ts.isIdentifier(p.name) && p.name.escapedText === "key"; });
            var attrs = keyAttr ? ts.filter(node.attributes.properties, function (p) { return p !== keyAttr; }) : node.attributes.properties;
            var objectProperties = ts.length(attrs) ? transformJsxAttributesToObjectProps(attrs, childrenProp) :
                factory.createObjectLiteralExpression(childrenProp ? [childrenProp] : ts.emptyArray); // When there are no attributes, React wants {}
            return visitJsxOpeningLikeElementOrFragmentJSX(tagName, objectProperties, keyAttr, children || ts.emptyArray, isChild, location);
        }
        function visitJsxOpeningLikeElementOrFragmentJSX(tagName, objectProperties, keyAttr, children, isChild, location) {
            var _a;
            var nonWhitespaceChildren = ts.getSemanticJsxChildren(children);
            var isStaticChildren = ts.length(nonWhitespaceChildren) > 1 || !!((_a = nonWhitespaceChildren[0]) === null || _a === void 0 ? void 0 : _a.dotDotDotToken);
            var args = [tagName, objectProperties];
            // function jsx(type, config, maybeKey) {}
            // "maybeKey" is optional. It is acceptable to use "_jsx" without a third argument
            if (keyAttr) {
                args.push(transformJsxAttributeInitializer(keyAttr.initializer));
            }
            if (compilerOptions.jsx === 5 /* JsxEmit.ReactJSXDev */) {
                var originalFile = ts.getOriginalNode(currentSourceFile);
                if (originalFile && ts.isSourceFile(originalFile)) {
                    // "maybeKey" has to be replaced with "void 0" to not break the jsxDEV signature
                    if (keyAttr === undefined) {
                        args.push(factory.createVoidZero());
                    }
                    // isStaticChildren development flag
                    args.push(isStaticChildren ? factory.createTrue() : factory.createFalse());
                    // __source development flag
                    var lineCol = ts.getLineAndCharacterOfPosition(originalFile, location.pos);
                    args.push(factory.createObjectLiteralExpression([
                        factory.createPropertyAssignment("fileName", getCurrentFileNameExpression()),
                        factory.createPropertyAssignment("lineNumber", factory.createNumericLiteral(lineCol.line + 1)),
                        factory.createPropertyAssignment("columnNumber", factory.createNumericLiteral(lineCol.character + 1))
                    ]));
                    // __self development flag
                    args.push(factory.createThis());
                }
            }
            var element = ts.setTextRange(factory.createCallExpression(getJsxFactoryCallee(isStaticChildren), /*typeArguments*/ undefined, args), location);
            if (isChild) {
                ts.startOnNewLine(element);
            }
            return element;
        }
        function visitJsxOpeningLikeElementCreateElement(node, children, isChild, location) {
            var tagName = getTagName(node);
            var attrs = node.attributes.properties;
            var objectProperties = ts.length(attrs) ? transformJsxAttributesToObjectProps(attrs) :
                factory.createNull(); // When there are no attributes, React wants "null"
            var callee = currentFileState.importSpecifier === undefined
                ? ts.createJsxFactoryExpression(factory, context.getEmitResolver().getJsxFactoryEntity(currentSourceFile), compilerOptions.reactNamespace, // TODO: GH#18217
                node)
                : getImplicitImportForName("createElement");
            var element = ts.createExpressionForJsxElement(factory, callee, tagName, objectProperties, ts.mapDefined(children, transformJsxChildToExpression), location);
            if (isChild) {
                ts.startOnNewLine(element);
            }
            return element;
        }
        function visitJsxOpeningFragmentJSX(_node, children, isChild, location) {
            var childrenProps;
            if (children && children.length) {
                var result = convertJsxChildrenToChildrenPropObject(children);
                if (result) {
                    childrenProps = result;
                }
            }
            return visitJsxOpeningLikeElementOrFragmentJSX(getImplicitJsxFragmentReference(), childrenProps || factory.createObjectLiteralExpression([]), 
            /*keyAttr*/ undefined, children, isChild, location);
        }
        function visitJsxOpeningFragmentCreateElement(node, children, isChild, location) {
            var element = ts.createExpressionForJsxFragment(factory, context.getEmitResolver().getJsxFactoryEntity(currentSourceFile), context.getEmitResolver().getJsxFragmentFactoryEntity(currentSourceFile), compilerOptions.reactNamespace, // TODO: GH#18217
            ts.mapDefined(children, transformJsxChildToExpression), node, location);
            if (isChild) {
                ts.startOnNewLine(element);
            }
            return element;
        }
        function transformJsxSpreadAttributeToSpreadAssignment(node) {
            return factory.createSpreadAssignment(ts.visitNode(node.expression, visitor, ts.isExpression));
        }
        function transformJsxAttributesToObjectProps(attrs, children) {
            var target = ts.getEmitScriptTarget(compilerOptions);
            return target && target >= 5 /* ScriptTarget.ES2018 */ ? factory.createObjectLiteralExpression(transformJsxAttributesToProps(attrs, children)) :
                transformJsxAttributesToExpression(attrs, children);
        }
        function transformJsxAttributesToProps(attrs, children) {
            var props = ts.flatten(ts.spanMap(attrs, ts.isJsxSpreadAttribute, function (attrs, isSpread) {
                return ts.map(attrs, function (attr) { return isSpread ? transformJsxSpreadAttributeToSpreadAssignment(attr) : transformJsxAttributeToObjectLiteralElement(attr); });
            }));
            if (children) {
                props.push(children);
            }
            return props;
        }
        function transformJsxAttributesToExpression(attrs, children) {
            // Map spans of JsxAttribute nodes into object literals and spans
            // of JsxSpreadAttribute nodes into expressions.
            var expressions = ts.flatten(ts.spanMap(attrs, ts.isJsxSpreadAttribute, function (attrs, isSpread) { return isSpread
                ? ts.map(attrs, transformJsxSpreadAttributeToExpression)
                : factory.createObjectLiteralExpression(ts.map(attrs, transformJsxAttributeToObjectLiteralElement)); }));
            if (ts.isJsxSpreadAttribute(attrs[0])) {
                // We must always emit at least one object literal before a spread
                // argument.factory.createObjectLiteral
                expressions.unshift(factory.createObjectLiteralExpression());
            }
            if (children) {
                expressions.push(factory.createObjectLiteralExpression([children]));
            }
            return ts.singleOrUndefined(expressions) || emitHelpers().createAssignHelper(expressions);
        }
        function transformJsxSpreadAttributeToExpression(node) {
            return ts.visitNode(node.expression, visitor, ts.isExpression);
        }
        function transformJsxAttributeToObjectLiteralElement(node) {
            var name = getAttributeName(node);
            var expression = transformJsxAttributeInitializer(node.initializer);
            return factory.createPropertyAssignment(name, expression);
        }
        function transformJsxAttributeInitializer(node) {
            if (node === undefined) {
                return factory.createTrue();
            }
            else if (node.kind === 10 /* SyntaxKind.StringLiteral */) {
                // Always recreate the literal to escape any escape sequences or newlines which may be in the original jsx string and which
                // Need to be escaped to be handled correctly in a normal string
                var singleQuote = node.singleQuote !== undefined ? node.singleQuote : !ts.isStringDoubleQuoted(node, currentSourceFile);
                var literal = factory.createStringLiteral(tryDecodeEntities(node.text) || node.text, singleQuote);
                return ts.setTextRange(literal, node);
            }
            else if (node.kind === 288 /* SyntaxKind.JsxExpression */) {
                if (node.expression === undefined) {
                    return factory.createTrue();
                }
                return ts.visitNode(node.expression, visitor, ts.isExpression);
            }
            else {
                return ts.Debug.failBadSyntaxKind(node);
            }
        }
        function visitJsxText(node) {
            var fixed = fixupWhitespaceAndDecodeEntities(node.text);
            return fixed === undefined ? undefined : factory.createStringLiteral(fixed);
        }
        /**
         * JSX trims whitespace at the end and beginning of lines, except that the
         * start/end of a tag is considered a start/end of a line only if that line is
         * on the same line as the closing tag. See examples in
         * tests/cases/conformance/jsx/tsxReactEmitWhitespace.tsx
         * See also https://www.w3.org/TR/html4/struct/text.html#h-9.1 and https://www.w3.org/TR/CSS2/text.html#white-space-model
         *
         * An equivalent algorithm would be:
         * - If there is only one line, return it.
         * - If there is only whitespace (but multiple lines), return `undefined`.
         * - Split the text into lines.
         * - 'trimRight' the first line, 'trimLeft' the last line, 'trim' middle lines.
         * - Decode entities on each line (individually).
         * - Remove empty lines and join the rest with " ".
         */
        function fixupWhitespaceAndDecodeEntities(text) {
            var acc;
            // First non-whitespace character on this line.
            var firstNonWhitespace = 0;
            // Last non-whitespace character on this line.
            var lastNonWhitespace = -1;
            // These initial values are special because the first line is:
            // firstNonWhitespace = 0 to indicate that we want leading whitsepace,
            // but lastNonWhitespace = -1 as a special flag to indicate that we *don't* include the line if it's all whitespace.
            for (var i = 0; i < text.length; i++) {
                var c = text.charCodeAt(i);
                if (ts.isLineBreak(c)) {
                    // If we've seen any non-whitespace characters on this line, add the 'trim' of the line.
                    // (lastNonWhitespace === -1 is a special flag to detect whether the first line is all whitespace.)
                    if (firstNonWhitespace !== -1 && lastNonWhitespace !== -1) {
                        acc = addLineOfJsxText(acc, text.substr(firstNonWhitespace, lastNonWhitespace - firstNonWhitespace + 1));
                    }
                    // Reset firstNonWhitespace for the next line.
                    // Don't bother to reset lastNonWhitespace because we ignore it if firstNonWhitespace = -1.
                    firstNonWhitespace = -1;
                }
                else if (!ts.isWhiteSpaceSingleLine(c)) {
                    lastNonWhitespace = i;
                    if (firstNonWhitespace === -1) {
                        firstNonWhitespace = i;
                    }
                }
            }
            return firstNonWhitespace !== -1
                // Last line had a non-whitespace character. Emit the 'trimLeft', meaning keep trailing whitespace.
                ? addLineOfJsxText(acc, text.substr(firstNonWhitespace))
                // Last line was all whitespace, so ignore it
                : acc;
        }
        function addLineOfJsxText(acc, trimmedLine) {
            // We do not escape the string here as that is handled by the printer
            // when it emits the literal. We do, however, need to decode JSX entities.
            var decoded = decodeEntities(trimmedLine);
            return acc === undefined ? decoded : acc + " " + decoded;
        }
        /**
         * Replace entities like "&nbsp;", "&#123;", and "&#xDEADBEEF;" with the characters they encode.
         * See https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references
         */
        function decodeEntities(text) {
            return text.replace(/&((#((\d+)|x([\da-fA-F]+)))|(\w+));/g, function (match, _all, _number, _digits, decimal, hex, word) {
                if (decimal) {
                    return ts.utf16EncodeAsString(parseInt(decimal, 10));
                }
                else if (hex) {
                    return ts.utf16EncodeAsString(parseInt(hex, 16));
                }
                else {
                    var ch = entities.get(word);
                    // If this is not a valid entity, then just use `match` (replace it with itself, i.e. don't replace)
                    return ch ? ts.utf16EncodeAsString(ch) : match;
                }
            });
        }
        /** Like `decodeEntities` but returns `undefined` if there were no entities to decode. */
        function tryDecodeEntities(text) {
            var decoded = decodeEntities(text);
            return decoded === text ? undefined : decoded;
        }
        function getTagName(node) {
            if (node.kind === 278 /* SyntaxKind.JsxElement */) {
                return getTagName(node.openingElement);
            }
            else {
                var name = node.tagName;
                if (ts.isIdentifier(name) && ts.isIntrinsicJsxName(name.escapedText)) {
                    return factory.createStringLiteral(ts.idText(name));
                }
                else {
                    return ts.createExpressionFromEntityName(factory, name);
                }
            }
        }
        /**
         * Emit an attribute name, which is quoted if it needs to be quoted. Because
         * these emit into an object literal property name, we don't need to be worried
         * about keywords, just non-identifier characters
         */
        function getAttributeName(node) {
            var name = node.name;
            var text = ts.idText(name);
            if (/^[A-Za-z_]\w*$/.test(text)) {
                return name;
            }
            else {
                return factory.createStringLiteral(text);
            }
        }
        function visitJsxExpression(node) {
            var expression = ts.visitNode(node.expression, visitor, ts.isExpression);
            return node.dotDotDotToken ? factory.createSpreadElement(expression) : expression;
        }
    }
    ts.transformJsx = transformJsx;
    var entities = new ts.Map(ts.getEntries({
        quot: 0x0022,
        amp: 0x0026,
        apos: 0x0027,
        lt: 0x003C,
        gt: 0x003E,
        nbsp: 0x00A0,
        iexcl: 0x00A1,
        cent: 0x00A2,
        pound: 0x00A3,
        curren: 0x00A4,
        yen: 0x00A5,
        brvbar: 0x00A6,
        sect: 0x00A7,
        uml: 0x00A8,
        copy: 0x00A9,
        ordf: 0x00AA,
        laquo: 0x00AB,
        not: 0x00AC,
        shy: 0x00AD,
        reg: 0x00AE,
        macr: 0x00AF,
        deg: 0x00B0,
        plusmn: 0x00B1,
        sup2: 0x00B2,
        sup3: 0x00B3,
        acute: 0x00B4,
        micro: 0x00B5,
        para: 0x00B6,
        middot: 0x00B7,
        cedil: 0x00B8,
        sup1: 0x00B9,
        ordm: 0x00BA,
        raquo: 0x00BB,
        frac14: 0x00BC,
        frac12: 0x00BD,
        frac34: 0x00BE,
        iquest: 0x00BF,
        Agrave: 0x00C0,
        Aacute: 0x00C1,
        Acirc: 0x00C2,
        Atilde: 0x00C3,
        Auml: 0x00C4,
        Aring: 0x00C5,
        AElig: 0x00C6,
        Ccedil: 0x00C7,
        Egrave: 0x00C8,
        Eacute: 0x00C9,
        Ecirc: 0x00CA,
        Euml: 0x00CB,
        Igrave: 0x00CC,
        Iacute: 0x00CD,
        Icirc: 0x00CE,
        Iuml: 0x00CF,
        ETH: 0x00D0,
        Ntilde: 0x00D1,
        Ograve: 0x00D2,
        Oacute: 0x00D3,
        Ocirc: 0x00D4,
        Otilde: 0x00D5,
        Ouml: 0x00D6,
        times: 0x00D7,
        Oslash: 0x00D8,
        Ugrave: 0x00D9,
        Uacute: 0x00DA,
        Ucirc: 0x00DB,
        Uuml: 0x00DC,
        Yacute: 0x00DD,
        THORN: 0x00DE,
        szlig: 0x00DF,
        agrave: 0x00E0,
        aacute: 0x00E1,
        acirc: 0x00E2,
        atilde: 0x00E3,
        auml: 0x00E4,
        aring: 0x00E5,
        aelig: 0x00E6,
        ccedil: 0x00E7,
        egrave: 0x00E8,
        eacute: 0x00E9,
        ecirc: 0x00EA,
        euml: 0x00EB,
        igrave: 0x00EC,
        iacute: 0x00ED,
        icirc: 0x00EE,
        iuml: 0x00EF,
        eth: 0x00F0,
        ntilde: 0x00F1,
        ograve: 0x00F2,
        oacute: 0x00F3,
        ocirc: 0x00F4,
        otilde: 0x00F5,
        ouml: 0x00F6,
        divide: 0x00F7,
        oslash: 0x00F8,
        ugrave: 0x00F9,
        uacute: 0x00FA,
        ucirc: 0x00FB,
        uuml: 0x00FC,
        yacute: 0x00FD,
        thorn: 0x00FE,
        yuml: 0x00FF,
        OElig: 0x0152,
        oelig: 0x0153,
        Scaron: 0x0160,
        scaron: 0x0161,
        Yuml: 0x0178,
        fnof: 0x0192,
        circ: 0x02C6,
        tilde: 0x02DC,
        Alpha: 0x0391,
        Beta: 0x0392,
        Gamma: 0x0393,
        Delta: 0x0394,
        Epsilon: 0x0395,
        Zeta: 0x0396,
        Eta: 0x0397,
        Theta: 0x0398,
        Iota: 0x0399,
        Kappa: 0x039A,
        Lambda: 0x039B,
        Mu: 0x039C,
        Nu: 0x039D,
        Xi: 0x039E,
        Omicron: 0x039F,
        Pi: 0x03A0,
        Rho: 0x03A1,
        Sigma: 0x03A3,
        Tau: 0x03A4,
        Upsilon: 0x03A5,
        Phi: 0x03A6,
        Chi: 0x03A7,
        Psi: 0x03A8,
        Omega: 0x03A9,
        alpha: 0x03B1,
        beta: 0x03B2,
        gamma: 0x03B3,
        delta: 0x03B4,
        epsilon: 0x03B5,
        zeta: 0x03B6,
        eta: 0x03B7,
        theta: 0x03B8,
        iota: 0x03B9,
        kappa: 0x03BA,
        lambda: 0x03BB,
        mu: 0x03BC,
        nu: 0x03BD,
        xi: 0x03BE,
        omicron: 0x03BF,
        pi: 0x03C0,
        rho: 0x03C1,
        sigmaf: 0x03C2,
        sigma: 0x03C3,
        tau: 0x03C4,
        upsilon: 0x03C5,
        phi: 0x03C6,
        chi: 0x03C7,
        psi: 0x03C8,
        omega: 0x03C9,
        thetasym: 0x03D1,
        upsih: 0x03D2,
        piv: 0x03D6,
        ensp: 0x2002,
        emsp: 0x2003,
        thinsp: 0x2009,
        zwnj: 0x200C,
        zwj: 0x200D,
        lrm: 0x200E,
        rlm: 0x200F,
        ndash: 0x2013,
        mdash: 0x2014,
        lsquo: 0x2018,
        rsquo: 0x2019,
        sbquo: 0x201A,
        ldquo: 0x201C,
        rdquo: 0x201D,
        bdquo: 0x201E,
        dagger: 0x2020,
        Dagger: 0x2021,
        bull: 0x2022,
        hellip: 0x2026,
        permil: 0x2030,
        prime: 0x2032,
        Prime: 0x2033,
        lsaquo: 0x2039,
        rsaquo: 0x203A,
        oline: 0x203E,
        frasl: 0x2044,
        euro: 0x20AC,
        image: 0x2111,
        weierp: 0x2118,
        real: 0x211C,
        trade: 0x2122,
        alefsym: 0x2135,
        larr: 0x2190,
        uarr: 0x2191,
        rarr: 0x2192,
        darr: 0x2193,
        harr: 0x2194,
        crarr: 0x21B5,
        lArr: 0x21D0,
        uArr: 0x21D1,
        rArr: 0x21D2,
        dArr: 0x21D3,
        hArr: 0x21D4,
        forall: 0x2200,
        part: 0x2202,
        exist: 0x2203,
        empty: 0x2205,
        nabla: 0x2207,
        isin: 0x2208,
        notin: 0x2209,
        ni: 0x220B,
        prod: 0x220F,
        sum: 0x2211,
        minus: 0x2212,
        lowast: 0x2217,
        radic: 0x221A,
        prop: 0x221D,
        infin: 0x221E,
        ang: 0x2220,
        and: 0x2227,
        or: 0x2228,
        cap: 0x2229,
        cup: 0x222A,
        int: 0x222B,
        there4: 0x2234,
        sim: 0x223C,
        cong: 0x2245,
        asymp: 0x2248,
        ne: 0x2260,
        equiv: 0x2261,
        le: 0x2264,
        ge: 0x2265,
        sub: 0x2282,
        sup: 0x2283,
        nsub: 0x2284,
        sube: 0x2286,
        supe: 0x2287,
        oplus: 0x2295,
        otimes: 0x2297,
        perp: 0x22A5,
        sdot: 0x22C5,
        lceil: 0x2308,
        rceil: 0x2309,
        lfloor: 0x230A,
        rfloor: 0x230B,
        lang: 0x2329,
        rang: 0x232A,
        loz: 0x25CA,
        spades: 0x2660,
        clubs: 0x2663,
        hearts: 0x2665,
        diams: 0x2666
    }));
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    function transformES2016(context) {
        var factory = context.factory, hoistVariableDeclaration = context.hoistVariableDeclaration;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitor(node) {
            if ((node.transformFlags & 512 /* TransformFlags.ContainsES2016 */) === 0) {
                return node;
            }
            switch (node.kind) {
                case 221 /* SyntaxKind.BinaryExpression */:
                    return visitBinaryExpression(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitBinaryExpression(node) {
            switch (node.operatorToken.kind) {
                case 67 /* SyntaxKind.AsteriskAsteriskEqualsToken */:
                    return visitExponentiationAssignmentExpression(node);
                case 42 /* SyntaxKind.AsteriskAsteriskToken */:
                    return visitExponentiationExpression(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitExponentiationAssignmentExpression(node) {
            var target;
            var value;
            var left = ts.visitNode(node.left, visitor, ts.isExpression);
            var right = ts.visitNode(node.right, visitor, ts.isExpression);
            if (ts.isElementAccessExpression(left)) {
                // Transforms `a[x] **= b` into `(_a = a)[_x = x] = Math.pow(_a[_x], b)`
                var expressionTemp = factory.createTempVariable(hoistVariableDeclaration);
                var argumentExpressionTemp = factory.createTempVariable(hoistVariableDeclaration);
                target = ts.setTextRange(factory.createElementAccessExpression(ts.setTextRange(factory.createAssignment(expressionTemp, left.expression), left.expression), ts.setTextRange(factory.createAssignment(argumentExpressionTemp, left.argumentExpression), left.argumentExpression)), left);
                value = ts.setTextRange(factory.createElementAccessExpression(expressionTemp, argumentExpressionTemp), left);
            }
            else if (ts.isPropertyAccessExpression(left)) {
                // Transforms `a.x **= b` into `(_a = a).x = Math.pow(_a.x, b)`
                var expressionTemp = factory.createTempVariable(hoistVariableDeclaration);
                target = ts.setTextRange(factory.createPropertyAccessExpression(ts.setTextRange(factory.createAssignment(expressionTemp, left.expression), left.expression), left.name), left);
                value = ts.setTextRange(factory.createPropertyAccessExpression(expressionTemp, left.name), left);
            }
            else {
                // Transforms `a **= b` into `a = Math.pow(a, b)`
                target = left;
                value = left;
            }
            return ts.setTextRange(factory.createAssignment(target, ts.setTextRange(factory.createGlobalMethodCall("Math", "pow", [value, right]), node)), node);
        }
        function visitExponentiationExpression(node) {
            // Transforms `a ** b` into `Math.pow(a, b)`
            var left = ts.visitNode(node.left, visitor, ts.isExpression);
            var right = ts.visitNode(node.right, visitor, ts.isExpression);
            return ts.setTextRange(factory.createGlobalMethodCall("Math", "pow", [left, right]), node);
        }
    }
    ts.transformES2016 = transformES2016;
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    var ES2015SubstitutionFlags;
    (function (ES2015SubstitutionFlags) {
        /** Enables substitutions for captured `this` */
        ES2015SubstitutionFlags[ES2015SubstitutionFlags["CapturedThis"] = 1] = "CapturedThis";
        /** Enables substitutions for block-scoped bindings. */
        ES2015SubstitutionFlags[ES2015SubstitutionFlags["BlockScopedBindings"] = 2] = "BlockScopedBindings";
    })(ES2015SubstitutionFlags || (ES2015SubstitutionFlags = {}));
    var LoopOutParameterFlags;
    (function (LoopOutParameterFlags) {
        LoopOutParameterFlags[LoopOutParameterFlags["Body"] = 1] = "Body";
        LoopOutParameterFlags[LoopOutParameterFlags["Initializer"] = 2] = "Initializer";
    })(LoopOutParameterFlags || (LoopOutParameterFlags = {}));
    var CopyDirection;
    (function (CopyDirection) {
        CopyDirection[CopyDirection["ToOriginal"] = 0] = "ToOriginal";
        CopyDirection[CopyDirection["ToOutParameter"] = 1] = "ToOutParameter";
    })(CopyDirection || (CopyDirection = {}));
    var Jump;
    (function (Jump) {
        Jump[Jump["Break"] = 2] = "Break";
        Jump[Jump["Continue"] = 4] = "Continue";
        Jump[Jump["Return"] = 8] = "Return";
    })(Jump || (Jump = {}));
    // Facts we track as we traverse the tree
    var HierarchyFacts;
    (function (HierarchyFacts) {
        HierarchyFacts[HierarchyFacts["None"] = 0] = "None";
        //
        // Ancestor facts
        //
        HierarchyFacts[HierarchyFacts["Function"] = 1] = "Function";
        HierarchyFacts[HierarchyFacts["ArrowFunction"] = 2] = "ArrowFunction";
        HierarchyFacts[HierarchyFacts["AsyncFunctionBody"] = 4] = "AsyncFunctionBody";
        HierarchyFacts[HierarchyFacts["NonStaticClassElement"] = 8] = "NonStaticClassElement";
        HierarchyFacts[HierarchyFacts["CapturesThis"] = 16] = "CapturesThis";
        HierarchyFacts[HierarchyFacts["ExportedVariableStatement"] = 32] = "ExportedVariableStatement";
        HierarchyFacts[HierarchyFacts["TopLevel"] = 64] = "TopLevel";
        HierarchyFacts[HierarchyFacts["Block"] = 128] = "Block";
        HierarchyFacts[HierarchyFacts["IterationStatement"] = 256] = "IterationStatement";
        HierarchyFacts[HierarchyFacts["IterationStatementBlock"] = 512] = "IterationStatementBlock";
        HierarchyFacts[HierarchyFacts["IterationContainer"] = 1024] = "IterationContainer";
        HierarchyFacts[HierarchyFacts["ForStatement"] = 2048] = "ForStatement";
        HierarchyFacts[HierarchyFacts["ForInOrForOfStatement"] = 4096] = "ForInOrForOfStatement";
        HierarchyFacts[HierarchyFacts["ConstructorWithCapturedSuper"] = 8192] = "ConstructorWithCapturedSuper";
        HierarchyFacts[HierarchyFacts["StaticInitializer"] = 16384] = "StaticInitializer";
        // NOTE: do not add more ancestor flags without also updating AncestorFactsMask below.
        // NOTE: when adding a new ancestor flag, be sure to update the subtree flags below.
        //
        // Ancestor masks
        //
        HierarchyFacts[HierarchyFacts["AncestorFactsMask"] = 32767] = "AncestorFactsMask";
        // We are always in *some* kind of block scope, but only specific block-scope containers are
        // top-level or Blocks.
        HierarchyFacts[HierarchyFacts["BlockScopeIncludes"] = 0] = "BlockScopeIncludes";
        HierarchyFacts[HierarchyFacts["BlockScopeExcludes"] = 7104] = "BlockScopeExcludes";
        // A source file is a top-level block scope.
        HierarchyFacts[HierarchyFacts["SourceFileIncludes"] = 64] = "SourceFileIncludes";
        HierarchyFacts[HierarchyFacts["SourceFileExcludes"] = 8064] = "SourceFileExcludes";
        // Functions, methods, and accessors are both new lexical scopes and new block scopes.
        HierarchyFacts[HierarchyFacts["FunctionIncludes"] = 65] = "FunctionIncludes";
        HierarchyFacts[HierarchyFacts["FunctionExcludes"] = 32670] = "FunctionExcludes";
        HierarchyFacts[HierarchyFacts["AsyncFunctionBodyIncludes"] = 69] = "AsyncFunctionBodyIncludes";
        HierarchyFacts[HierarchyFacts["AsyncFunctionBodyExcludes"] = 32662] = "AsyncFunctionBodyExcludes";
        // Arrow functions are lexically scoped to their container, but are new block scopes.
        HierarchyFacts[HierarchyFacts["ArrowFunctionIncludes"] = 66] = "ArrowFunctionIncludes";
        HierarchyFacts[HierarchyFacts["ArrowFunctionExcludes"] = 15232] = "ArrowFunctionExcludes";
        // Constructors are both new lexical scopes and new block scopes. Constructors are also
        // always considered non-static members of a class.
        HierarchyFacts[HierarchyFacts["ConstructorIncludes"] = 73] = "ConstructorIncludes";
        HierarchyFacts[HierarchyFacts["ConstructorExcludes"] = 32662] = "ConstructorExcludes";
        // 'do' and 'while' statements are not block scopes. We track that the subtree is contained
        // within an IterationStatement to indicate whether the embedded statement is an
        // IterationStatementBlock.
        HierarchyFacts[HierarchyFacts["DoOrWhileStatementIncludes"] = 1280] = "DoOrWhileStatementIncludes";
        HierarchyFacts[HierarchyFacts["DoOrWhileStatementExcludes"] = 0] = "DoOrWhileStatementExcludes";
        // 'for' statements are new block scopes and have special handling for 'let' declarations.
        HierarchyFacts[HierarchyFacts["ForStatementIncludes"] = 3328] = "ForStatementIncludes";
        HierarchyFacts[HierarchyFacts["ForStatementExcludes"] = 5056] = "ForStatementExcludes";
        // 'for-in' and 'for-of' statements are new block scopes and have special handling for
        // 'let' declarations.
        HierarchyFacts[HierarchyFacts["ForInOrForOfStatementIncludes"] = 5376] = "ForInOrForOfStatementIncludes";
        HierarchyFacts[HierarchyFacts["ForInOrForOfStatementExcludes"] = 3008] = "ForInOrForOfStatementExcludes";
        // Blocks (other than function bodies) are new block scopes.
        HierarchyFacts[HierarchyFacts["BlockIncludes"] = 128] = "BlockIncludes";
        HierarchyFacts[HierarchyFacts["BlockExcludes"] = 6976] = "BlockExcludes";
        HierarchyFacts[HierarchyFacts["IterationStatementBlockIncludes"] = 512] = "IterationStatementBlockIncludes";
        HierarchyFacts[HierarchyFacts["IterationStatementBlockExcludes"] = 7104] = "IterationStatementBlockExcludes";
        HierarchyFacts[HierarchyFacts["StaticInitializerIncludes"] = 16449] = "StaticInitializerIncludes";
        HierarchyFacts[HierarchyFacts["StaticInitializerExcludes"] = 32670] = "StaticInitializerExcludes";
        //
        // Subtree facts
        //
        HierarchyFacts[HierarchyFacts["NewTarget"] = 32768] = "NewTarget";
        HierarchyFacts[HierarchyFacts["CapturedLexicalThis"] = 65536] = "CapturedLexicalThis";
        //
        // Subtree masks
        //
        HierarchyFacts[HierarchyFacts["SubtreeFactsMask"] = -32768] = "SubtreeFactsMask";
        HierarchyFacts[HierarchyFacts["ArrowFunctionSubtreeExcludes"] = 0] = "ArrowFunctionSubtreeExcludes";
        HierarchyFacts[HierarchyFacts["FunctionSubtreeExcludes"] = 98304] = "FunctionSubtreeExcludes";
    })(HierarchyFacts || (HierarchyFacts = {}));
    var SpreadSegmentKind;
    (function (SpreadSegmentKind) {
        SpreadSegmentKind[SpreadSegmentKind["None"] = 0] = "None";
        SpreadSegmentKind[SpreadSegmentKind["UnpackedSpread"] = 1] = "UnpackedSpread";
        SpreadSegmentKind[SpreadSegmentKind["PackedSpread"] = 2] = "PackedSpread";
    })(SpreadSegmentKind || (SpreadSegmentKind = {}));
    function createSpreadSegment(kind, expression) {
        return { kind: kind, expression: expression };
    }
    function transformES2015(context) {
        var factory = context.factory, emitHelpers = context.getEmitHelperFactory, startLexicalEnvironment = context.startLexicalEnvironment, resumeLexicalEnvironment = context.resumeLexicalEnvironment, endLexicalEnvironment = context.endLexicalEnvironment, hoistVariableDeclaration = context.hoistVariableDeclaration;
        var compilerOptions = context.getCompilerOptions();
        var resolver = context.getEmitResolver();
        var previousOnSubstituteNode = context.onSubstituteNode;
        var previousOnEmitNode = context.onEmitNode;
        context.onEmitNode = onEmitNode;
        context.onSubstituteNode = onSubstituteNode;
        var currentSourceFile;
        var currentText;
        var hierarchyFacts;
        var taggedTemplateStringDeclarations;
        function recordTaggedTemplateString(temp) {
            taggedTemplateStringDeclarations = ts.append(taggedTemplateStringDeclarations, factory.createVariableDeclaration(temp));
        }
        /**
         * Used to track if we are emitting body of the converted loop
         */
        var convertedLoopState;
        /**
         * Keeps track of whether substitutions have been enabled for specific cases.
         * They are persisted between each SourceFile transformation and should not
         * be reset.
         */
        var enabledSubstitutions;
        return ts.chainBundle(context, transformSourceFile);
        function transformSourceFile(node) {
            if (node.isDeclarationFile) {
                return node;
            }
            currentSourceFile = node;
            currentText = node.text;
            var visited = visitSourceFile(node);
            ts.addEmitHelpers(visited, context.readEmitHelpers());
            currentSourceFile = undefined;
            currentText = undefined;
            taggedTemplateStringDeclarations = undefined;
            hierarchyFacts = 0 /* HierarchyFacts.None */;
            return visited;
        }
        /**
         * Sets the `HierarchyFacts` for this node prior to visiting this node's subtree, returning the facts set prior to modification.
         * @param excludeFacts The existing `HierarchyFacts` to reset before visiting the subtree.
         * @param includeFacts The new `HierarchyFacts` to set before visiting the subtree.
         */
        function enterSubtree(excludeFacts, includeFacts) {
            var ancestorFacts = hierarchyFacts;
            hierarchyFacts = (hierarchyFacts & ~excludeFacts | includeFacts) & 32767 /* HierarchyFacts.AncestorFactsMask */;
            return ancestorFacts;
        }
        /**
         * Restores the `HierarchyFacts` for this node's ancestor after visiting this node's
         * subtree, propagating specific facts from the subtree.
         * @param ancestorFacts The `HierarchyFacts` of the ancestor to restore after visiting the subtree.
         * @param excludeFacts The existing `HierarchyFacts` of the subtree that should not be propagated.
         * @param includeFacts The new `HierarchyFacts` of the subtree that should be propagated.
         */
        function exitSubtree(ancestorFacts, excludeFacts, includeFacts) {
            hierarchyFacts = (hierarchyFacts & ~excludeFacts | includeFacts) & -32768 /* HierarchyFacts.SubtreeFactsMask */ | ancestorFacts;
        }
        function isReturnVoidStatementInConstructorWithCapturedSuper(node) {
            return (hierarchyFacts & 8192 /* HierarchyFacts.ConstructorWithCapturedSuper */) !== 0
                && node.kind === 247 /* SyntaxKind.ReturnStatement */
                && !node.expression;
        }
        function isOrMayContainReturnCompletion(node) {
            return node.transformFlags & 2097152 /* TransformFlags.ContainsHoistedDeclarationOrCompletion */
                && (ts.isReturnStatement(node)
                    || ts.isIfStatement(node)
                    || ts.isWithStatement(node)
                    || ts.isSwitchStatement(node)
                    || ts.isCaseBlock(node)
                    || ts.isCaseClause(node)
                    || ts.isDefaultClause(node)
                    || ts.isTryStatement(node)
                    || ts.isCatchClause(node)
                    || ts.isLabeledStatement(node)
                    || ts.isIterationStatement(node, /*lookInLabeledStatements*/ false)
                    || ts.isBlock(node));
        }
        function shouldVisitNode(node) {
            return (node.transformFlags & 1024 /* TransformFlags.ContainsES2015 */) !== 0
                || convertedLoopState !== undefined
                || (hierarchyFacts & 8192 /* HierarchyFacts.ConstructorWithCapturedSuper */ && isOrMayContainReturnCompletion(node))
                || (ts.isIterationStatement(node, /*lookInLabeledStatements*/ false) && shouldConvertIterationStatement(node))
                || (ts.getEmitFlags(node) & 33554432 /* EmitFlags.TypeScriptClassWrapper */) !== 0;
        }
        function visitor(node) {
            return shouldVisitNode(node) ? visitorWorker(node, /*expressionResultIsUnused*/ false) : node;
        }
        function visitorWithUnusedExpressionResult(node) {
            return shouldVisitNode(node) ? visitorWorker(node, /*expressionResultIsUnused*/ true) : node;
        }
        function classWrapperStatementVisitor(node) {
            if (shouldVisitNode(node)) {
                var original = ts.getOriginalNode(node);
                if (ts.isPropertyDeclaration(original) && ts.hasStaticModifier(original)) {
                    var ancestorFacts = enterSubtree(32670 /* HierarchyFacts.StaticInitializerExcludes */, 16449 /* HierarchyFacts.StaticInitializerIncludes */);
                    var result = visitorWorker(node, /*expressionResultIsUnused*/ false);
                    exitSubtree(ancestorFacts, 98304 /* HierarchyFacts.FunctionSubtreeExcludes */, 0 /* HierarchyFacts.None */);
                    return result;
                }
                return visitorWorker(node, /*expressionResultIsUnused*/ false);
            }
            return node;
        }
        function callExpressionVisitor(node) {
            if (node.kind === 106 /* SyntaxKind.SuperKeyword */) {
                return visitSuperKeyword(/*isExpressionOfCall*/ true);
            }
            return visitor(node);
        }
        function visitorWorker(node, expressionResultIsUnused) {
            switch (node.kind) {
                case 124 /* SyntaxKind.StaticKeyword */:
                    return undefined; // elide static keyword
                case 257 /* SyntaxKind.ClassDeclaration */:
                    return visitClassDeclaration(node);
                case 226 /* SyntaxKind.ClassExpression */:
                    return visitClassExpression(node);
                case 164 /* SyntaxKind.Parameter */:
                    return visitParameter(node);
                case 256 /* SyntaxKind.FunctionDeclaration */:
                    return visitFunctionDeclaration(node);
                case 214 /* SyntaxKind.ArrowFunction */:
                    return visitArrowFunction(node);
                case 213 /* SyntaxKind.FunctionExpression */:
                    return visitFunctionExpression(node);
                case 254 /* SyntaxKind.VariableDeclaration */:
                    return visitVariableDeclaration(node);
                case 79 /* SyntaxKind.Identifier */:
                    return visitIdentifier(node);
                case 255 /* SyntaxKind.VariableDeclarationList */:
                    return visitVariableDeclarationList(node);
                case 249 /* SyntaxKind.SwitchStatement */:
                    return visitSwitchStatement(node);
                case 263 /* SyntaxKind.CaseBlock */:
                    return visitCaseBlock(node);
                case 235 /* SyntaxKind.Block */:
                    return visitBlock(node, /*isFunctionBody*/ false);
                case 246 /* SyntaxKind.BreakStatement */:
                case 245 /* SyntaxKind.ContinueStatement */:
                    return visitBreakOrContinueStatement(node);
                case 250 /* SyntaxKind.LabeledStatement */:
                    return visitLabeledStatement(node);
                case 240 /* SyntaxKind.DoStatement */:
                case 241 /* SyntaxKind.WhileStatement */:
                    return visitDoOrWhileStatement(node, /*outermostLabeledStatement*/ undefined);
                case 242 /* SyntaxKind.ForStatement */:
                    return visitForStatement(node, /*outermostLabeledStatement*/ undefined);
                case 243 /* SyntaxKind.ForInStatement */:
                    return visitForInStatement(node, /*outermostLabeledStatement*/ undefined);
                case 244 /* SyntaxKind.ForOfStatement */:
                    return visitForOfStatement(node, /*outermostLabeledStatement*/ undefined);
                case 238 /* SyntaxKind.ExpressionStatement */:
                    return visitExpressionStatement(node);
                case 205 /* SyntaxKind.ObjectLiteralExpression */:
                    return visitObjectLiteralExpression(node);
                case 292 /* SyntaxKind.CatchClause */:
                    return visitCatchClause(node);
                case 297 /* SyntaxKind.ShorthandPropertyAssignment */:
                    return visitShorthandPropertyAssignment(node);
                case 162 /* SyntaxKind.ComputedPropertyName */:
                    return visitComputedPropertyName(node);
                case 204 /* SyntaxKind.ArrayLiteralExpression */:
                    return visitArrayLiteralExpression(node);
                case 208 /* SyntaxKind.CallExpression */:
                    return visitCallExpression(node);
                case 209 /* SyntaxKind.NewExpression */:
                    return visitNewExpression(node);
                case 212 /* SyntaxKind.ParenthesizedExpression */:
                    return visitParenthesizedExpression(node, expressionResultIsUnused);
                case 221 /* SyntaxKind.BinaryExpression */:
                    return visitBinaryExpression(node, expressionResultIsUnused);
                case 351 /* SyntaxKind.CommaListExpression */:
                    return visitCommaListExpression(node, expressionResultIsUnused);
                case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                case 15 /* SyntaxKind.TemplateHead */:
                case 16 /* SyntaxKind.TemplateMiddle */:
                case 17 /* SyntaxKind.TemplateTail */:
                    return visitTemplateLiteral(node);
                case 10 /* SyntaxKind.StringLiteral */:
                    return visitStringLiteral(node);
                case 8 /* SyntaxKind.NumericLiteral */:
                    return visitNumericLiteral(node);
                case 210 /* SyntaxKind.TaggedTemplateExpression */:
                    return visitTaggedTemplateExpression(node);
                case 223 /* SyntaxKind.TemplateExpression */:
                    return visitTemplateExpression(node);
                case 224 /* SyntaxKind.YieldExpression */:
                    return visitYieldExpression(node);
                case 225 /* SyntaxKind.SpreadElement */:
                    return visitSpreadElement(node);
                case 106 /* SyntaxKind.SuperKeyword */:
                    return visitSuperKeyword(/*isExpressionOfCall*/ false);
                case 108 /* SyntaxKind.ThisKeyword */:
                    return visitThisKeyword(node);
                case 231 /* SyntaxKind.MetaProperty */:
                    return visitMetaProperty(node);
                case 169 /* SyntaxKind.MethodDeclaration */:
                    return visitMethodDeclaration(node);
                case 172 /* SyntaxKind.GetAccessor */:
                case 173 /* SyntaxKind.SetAccessor */:
                    return visitAccessorDeclaration(node);
                case 237 /* SyntaxKind.VariableStatement */:
                    return visitVariableStatement(node);
                case 247 /* SyntaxKind.ReturnStatement */:
                    return visitReturnStatement(node);
                case 217 /* SyntaxKind.VoidExpression */:
                    return visitVoidExpression(node);
                default:
                    return ts.visitEachChild(node, visitor, context);
            }
        }
        function visitSourceFile(node) {
            var ancestorFacts = enterSubtree(8064 /* HierarchyFacts.SourceFileExcludes */, 64 /* HierarchyFacts.SourceFileIncludes */);
            var prologue = [];
            var statements = [];
            startLexicalEnvironment();
            var statementOffset = factory.copyPrologue(node.statements, prologue, /*ensureUseStrict*/ false, visitor);
            ts.addRange(statements, ts.visitNodes(node.statements, visitor, ts.isStatement, statementOffset));
            if (taggedTemplateStringDeclarations) {
                statements.push(factory.createVariableStatement(/*modifiers*/ undefined, factory.createVariableDeclarationList(taggedTemplateStringDeclarations)));
            }
            factory.mergeLexicalEnvironment(prologue, endLexicalEnvironment());
            insertCaptureThisForNodeIfNeeded(prologue, node);
            exitSubtree(ancestorFacts, 0 /* HierarchyFacts.None */, 0 /* HierarchyFacts.None */);
            return factory.updateSourceFile(node, ts.setTextRange(factory.createNodeArray(ts.concatenate(prologue, statements)), node.statements));
        }
        function visitSwitchStatement(node) {
            if (convertedLoopState !== undefined) {
                var savedAllowedNonLabeledJumps = convertedLoopState.allowedNonLabeledJumps;
                // for switch statement allow only non-labeled break
                convertedLoopState.allowedNonLabeledJumps |= 2 /* Jump.Break */;
                var result = ts.visitEachChild(node, visitor, context);
                convertedLoopState.allowedNonLabeledJumps = savedAllowedNonLabeledJumps;
                return result;
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitCaseBlock(node) {
            var ancestorFacts = enterSubtree(7104 /* HierarchyFacts.BlockScopeExcludes */, 0 /* HierarchyFacts.BlockScopeIncludes */);
            var updated = ts.visitEachChild(node, visitor, context);
            exitSubtree(ancestorFacts, 0 /* HierarchyFacts.None */, 0 /* HierarchyFacts.None */);
            return updated;
        }
        function returnCapturedThis(node) {
            return ts.setOriginalNode(factory.createReturnStatement(factory.createUniqueName("_this", 16 /* GeneratedIdentifierFlags.Optimistic */ | 32 /* GeneratedIdentifierFlags.FileLevel */)), node);
        }
        function visitReturnStatement(node) {
            if (convertedLoopState) {
                convertedLoopState.nonLocalJumps |= 8 /* Jump.Return */;
                if (isReturnVoidStatementInConstructorWithCapturedSuper(node)) {
                    node = returnCapturedThis(node);
                }
                return factory.createReturnStatement(factory.createObjectLiteralExpression([
                    factory.createPropertyAssignment(factory.createIdentifier("value"), node.expression
                        ? ts.visitNode(node.expression, visitor, ts.isExpression)
                        : factory.createVoidZero())
                ]));
            }
            else if (isReturnVoidStatementInConstructorWithCapturedSuper(node)) {
                return returnCapturedThis(node);
            }
            return ts.visitEachChild(node, visitor, context);
        }
        function visitThisKeyword(node) {
            if (hierarchyFacts & 2 /* HierarchyFacts.ArrowFunction */ && !(hierarchyFacts & 16384 /* HierarchyFacts.StaticInitializer */)) {
                hierarchyFacts |= 65536 /* HierarchyFacts.CapturedLexicalThis */;
            }
            if (convertedLoopState) {
                if (hierarchyFacts & 2 /* HierarchyFacts.ArrowFunction */) {
                    // if the enclosing function is an ArrowFunction then we use the captured 'this' keyword.
                    convertedLoopState.containsLexicalThis = true;
                    return node;
                }
                return convertedLoopState.thisName || (convertedLoopState.thisName = factory.createUniqueName("this"));
            }
            return node;
        }
        function visitVoidExpression(node) {
            return ts.visitEachChild(node, visitorWithUnusedExpressionResult, context);
        }
        function visitIdentifier(node) {
            if (!convertedLoopState) {
                return node;
            }
            if (resolver.isArgumentsLocalBinding(node)) {
                return convertedLoopState.argumentsName || (convertedLoopState.argumentsName = factory.createUniqueName("arguments"));
            }
            return node;
        }
        function visitBreakOrContinueStatement(node) {
            if (convertedLoopState) {
                // check if we can emit break/continue as is
                // it is possible if either
                //   - break/continue is labeled and label is located inside the converted loop
                //   - break/continue is non-labeled and located in non-converted loop/switch statement
                var jump = node.kind === 246 /* SyntaxKind.BreakStatement */ ? 2 /* Jump.Break */ : 4 /* Jump.Continue */;
                var canUseBreakOrContinue = (node.label && convertedLoopState.labels && convertedLoopState.labels.get(ts.idText(node.label))) ||
                    (!node.label && (convertedLoopState.allowedNonLabeledJumps & jump));
                if (!canUseBreakOrContinue) {
                    var labelMarker = void 0;
                    var label = node.label;
                    if (!label) {
                        if (node.kind === 246 /* SyntaxKind.BreakStatement */) {
                            convertedLoopState.nonLocalJumps |= 2 /* Jump.Break */;
                            labelMarker = "break";
                        }
                        else {
                            convertedLoopState.nonLocalJumps |= 4 /* Jump.Continue */;
                            // note: return value is emitted only to simplify debugging, call to converted loop body does not do any dispatching on it.
                            labelMarker = "continue";
                        }
                    }
                    else {
                        if (node.kind === 246 /* SyntaxKind.BreakStatement */) {
                            labelMarker = "break-".concat(label.escapedText);
                            setLabeledJump(convertedLoopState, /*isBreak*/ true, ts.idText(label), labelMarker);
                        }
                        else {
                            labelMarker = "continue-".concat(label.escapedText);
                            setLabeledJump(convertedLoopState, /*isBreak*/ false, ts.idText(label), labelMarker);
                        }
                    }
                    var returnExpression = factory.createStringLiteral(labelMarker);
                    if (convertedLoopState.loopOutParameters.length) {
                        var outParams = convertedLoopState.loopOutParameters;
                        var expr = void 0;
                        for (var i = 0; i < outParams.length; i++) {
                            var copyExpr = copyOutParameter(outParams[i], 1 /* CopyDirection.ToOutParameter */);
                            if (i === 0) {
                                expr = copyExpr;
                            }
                            else {
                                expr = factory.createBinaryExpression(expr, 27 /* SyntaxKind.CommaToken */, copyExpr);
                            }
                        }
                        returnExpression = factory.createBinaryExpression(expr, 27 /* SyntaxKind.CommaToken */, returnExpression);
                    }
                    return factory.createReturnStatement(returnExpression);
                }
            }
            return ts.visitEachChild(node, visitor, context);
        }
        /**
         * Visits a ClassDeclaration and transforms it into a variable statement.
         *
         * @param node A ClassDeclaration node.
         */
        function visitClassDeclaration(node) {
            // [source]
            //      class C { }
            //
            // [output]
            //      var C = (function () {
            //          function C() {
            //          }
            //          return C;
            //      }());
            var variable = factory.createVariableDeclaration(factory.getLocalName(node, /*allowComments*/ true), 
            /*exclamationToken*/ undefined, 
            /*type*/ undefined, transformClassLikeDeclarationToExpression(node));
            ts.setOriginalNode(variable, node);
            var statements = [];
            var statement = factory.createVariableStatement(/*modifiers*/ undefined, factory.createVariableDeclarationList([variable]));
            ts.setOriginalNode(statement, node);
            ts.setTextRange(statement, node);
            ts.startOnNewLine(statement);
            statements.push(statement);
            // Add an `export default` statement for default exports (for `--target es5 --module es6`)
            if (ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */)) {
                var exportStatement = ts.hasSyntacticModifier(node, 512 /* ModifierFlags.Default */)
                    ? factory.createExportDefault(factory.getLocalName(node))
                    : factory.createExternalModuleExport(factory.getLocalName(node));
                ts.setOriginalNode(exportStatement, statement);
                statements.push(exportStatement);
            }
            var emitFlags = ts.getEmitFlags(node);
            if ((emitFlags & 4194304 /* EmitFlags.HasEndOfDeclarationMarker */) === 0) {
                // Add a DeclarationMarker as a marker for the end of the declaration
                statements.push(factory.createEndOfDeclarationMarker(node));
                ts.setEmitFlags(statement, emitFlags | 4194304 /* EmitFlags.HasEndOfDeclarationMarker */);
            }
            return ts.singleOrMany(statements);
        }
        /**
         * Visits a ClassExpression and transforms it into an expression.
         *
         * @param node A ClassExpression node.
         */
        function visitClassExpression(node) {
            // [source]
            //      C = class { }
            //
            // [output]
            //      C = (function () {
            //          function class_1() {
            //          }
            //          return class_1;
            //      }())
            return transformClassLikeDeclarationToExpression(node);
        }
        /**
         * Transforms a ClassExpression or ClassDeclaration into an expression.
         *
         * @param node A ClassExpression or ClassDeclaration node.
         */
        function transformClassLikeDeclarationToExpression(node) {
            // [source]
            //      class C extends D {
            //          constructor() {}
            //          method() {}
            //          get prop() {}
            //          set prop(v) {}
            //      }
            //
            // [output]
            //      (function (_super) {
            //          __extends(C, _super);
            //          function C() {
            //          }
            //          C.prototype.method = function () {}
            //          Object.defineProperty(C.prototype, "prop", {
            //              get: function() {},
            //              set: function() {},
            //              enumerable: true,
            //              configurable: true
            //          });
            //          return C;
            //      }(D))
            if (node.name) {
                enableSubstitutionsForBlockScopedBindings();
            }
            var extendsClauseElement = ts.getClassExtendsHeritageElement(node);
            var classFunction = factory.createFunctionExpression(
            /*modifiers*/ undefined, 
            /*asteriskToken*/ undefined, 
            /*name*/ undefined, 
            /*typeParameters*/ undefined, extendsClauseElement ? [factory.createParameterDeclaration(/*decorators*/ undefined, /*modifiers*/ undefined, /*dotDotDotToken*/ undefined, factory.createUniqueName("_super", 16 /* GeneratedIdentifierFlags.Optimistic */ | 32 /* GeneratedIdentifierFlags.FileLevel */))] : [], 
            /*type*/ undefined, transformClassBody(node, extendsClauseElement));
            // To preserve the behavior of the old emitter, we explicitly indent
            // the body of the function here if it was requested in an earlier
            // transformation.
            ts.setEmitFlags(classFunction, (ts.getEmitFlags(node) & 65536 /* EmitFlags.Indented */) | 524288 /* EmitFlags.ReuseTempVariableScope */);
            // "inner" and "outer" below are added purely to preserve source map locations from
            // the old emitter
            var inner = factory.createPartiallyEmittedExpression(classFunction);
            ts.setTextRangeEnd(inner, node.end);
            ts.setEmitFlags(inner, 1536 /* EmitFlags.NoComments */);
            var outer = factory.createPartiallyEmittedExpression(inner);
            ts.setTextRangeEnd(outer, ts.skipTrivia(currentText, node.pos));
            ts.setEmitFlags(outer, 1536 /* EmitFlags.NoComments */);
            var result = factory.createParenthesizedExpression(factory.createCallExpression(outer, 
            /*typeArguments*/ undefined, extendsClauseElement
                ? [ts.visitNode(extendsClauseElement.expression, visitor, ts.isExpression)]
                : []));
            ts.addSyntheticLeadingComment(result, 3 /* SyntaxKind.MultiLineCommentTrivia */, "* @class ");
            return result;
        }
        /**
         * Transforms a ClassExpression or ClassDeclaration into a function body.
         *
         * @param node A ClassExpression or ClassDeclaration node.
         * @param extendsClauseElement The expression for the class `extends` clause.
         */
        function transformClassBody(node, extendsClauseElement) {
            var statements = [];
            var name = factory.getInternalName(node);
            var constructorLikeName = ts.isIdentifierANonContextualKeyword(name) ? factory.getGeneratedNameForNode(name) : name;
            startLexicalEnvironment();
            addExtendsHelperIfNeeded(statements, node, extendsClauseElement);
            addConstructor(statements, node, constructorLikeName, extendsClauseElement);
            addClassMembers(statements, node);
            // Create a synthetic text range for the return statement.
            var closingBraceLocation = ts.createTokenRange(ts.skipTrivia(currentText, node.members.end), 19 /* SyntaxKind.CloseBraceToken */);
            // The following partially-emitted expression exists purely to align our sourcemap
            // emit with the original emitter.
            var outer = factory.createPartiallyEmittedExpression(constructorLikeName);
            ts.setTextRangeEnd(outer, closingBraceLocation.end);
            ts.setEmitFlags(outer, 1536 /* EmitFlags.NoComments */);
            var statement = factory.createReturnStatement(outer);
            ts.setTextRangePos(statement, closingBraceLocation.pos);
            ts.setEmitFlags(statement, 1536 /* EmitFlags.NoComments */ | 384 /* EmitFlags.NoTokenSourceMaps */);
            statements.push(statement);
            ts.insertStatementsAfterStandardPrologue(statements, endLexicalEnvironment());
            var block = factory.createBlock(ts.setTextRange(factory.createNodeArray(statements), /*location*/ node.members), /*multiLine*/ true);
            ts.setEmitFlags(block, 1536 /* EmitFlags.NoComments */);
            return block;
        }
        /**
         * Adds a call to the `__extends` helper if needed for a class.
         *
         * @param statements The statements of the class body function.
         * @param node The ClassExpression or ClassDeclaration node.
         * @param extendsClauseElement The expression for the class `extends` clause.
         */
        function addExtendsHelperIfNeeded(statements, node, extendsClauseElement) {
            if (extendsClauseElement) {
                statements.push(ts.setTextRange(factory.createExpressionStatement(emitHelpers().createExtendsHelper(factory.getInternalName(node))), 
                /*location*/ extendsClauseElement));
            }
        }
        /**
         * Adds the constructor of the class to a class body function.
         *
         * @param statements The statements of the class body function.
         * @param node The ClassExpression or ClassDeclaration node.
         * @param extendsClauseElement The expression for the class `extends` clause.
         */
        function addConstructor(statements, node, name, extendsClauseElement) {
            var savedConvertedLoopState = convertedLoopState;
            convertedLoopState = undefined;
            var ancestorFacts = enterSubtree(32662 /* HierarchyFacts.ConstructorExcludes */, 73 /* HierarchyFacts.ConstructorIncludes */);
            var constructor = ts.getFirstConstructorWithBody(node);
            var hasSynthesizedSuper = hasSynthesizedDefaultSuperCall(constructor, extendsClauseElement !== undefined);
            var constructorFunction = factory.createFunctionDeclaration(
            /*decorators*/ undefined, 
            /*modifiers*/ undefined, 
            /*asteriskToken*/ undefined, name, 
            /*typeParameters*/ undefined, transformConstructorParameters(constructor, hasSynthesizedSuper), 
            /*type*/ undefined, transformConstructorBody(constructor, node, extendsClauseElement, hasSynthesizedSuper));
            ts.setTextRange(constructorFunction, constructor || node);
            if (extendsClauseElement) {
                ts.setEmitFlags(constructorFunction, 8 /* EmitFlags.CapturesThis */);
            }
            statements.push(constructorFunction);
            exitSubtree(ancestorFacts, 98304 /* HierarchyFacts.FunctionSubtreeExcludes */, 0 /* HierarchyFacts.None */);
            convertedLoopState = savedConvertedLoopState;
        }
        /**
         * Transforms the parameters of the constructor declaration of a class.
         *
         * @param constructor The constructor for the class.
         * @param hasSynthesizedSuper A value indicating whether the constructor starts with a
         *                            synthesized `super` call.
         */
        function transformConstructorParameters(constructor, hasSynthesizedSuper) {
            // If the TypeScript transformer needed to synthesize a constructor for property
            // initializers, it would have also added a synthetic `...args` parameter and
            // `super` call.
            // If this is the case, we do not include the synthetic `...args` parameter and
            // will instead use the `arguments` object in ES5/3.
            return ts.visitParameterList(constructor && !hasSynthesizedSuper ? constructor.parameters : undefined, visitor, context)
                || [];
        }
        function createDefaultConstructorBody(node, isDerivedClass) {
            // We must be here because the user didn't write a constructor
            // but we needed to call 'super(...args)' anyway as per 14.5.14 of the ES2016 spec.
            // If that's the case we can just immediately return the result of a 'super()' call.
            var statements = [];
            resumeLexicalEnvironment();
            factory.mergeLexicalEnvironment(statements, endLexicalEnvironment());
            if (isDerivedClass) {
                // return _super !== null && _super.apply(this, arguments) || this;
                statements.push(factory.createReturnStatement(createDefaultSuperCallOrThis()));
            }
            var statementsArray = factory.createNodeArray(statements);
            ts.setTextRange(statementsArray, node.members);
            var block = factory.createBlock(statementsArray, /*multiLine*/ true);
            ts.setTextRange(block, node);
            ts.setEmitFlags(block, 1536 /* EmitFlags.NoComments */);
            return block;
        }
        /**
         * Transforms the body of a constructor declaration of a class.
         *
         * @param construct